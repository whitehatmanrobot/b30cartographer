
						 ulTouchCount = (ULONG)atol(&pchParam[1]);
						 pchParam += strlen(pchParam);
						 break;

					 case 'w':
					 case 'W':
						 bWrite = TRUE;
						 bRead = FALSE;
                         break;

					 case 'b':
					 case 'B':
						 bRead = TRUE;
						 bWrite = TRUE;
						 break;


					 default:
                         Usage (argv, "unknown flag");
                         break;

                 }  // end of switch
             }      // end of while
         }          // end of if
     }              // end of for...

	 if(!ulPageCount){
		 ulPageCount = NUM_FLUSH_READS;
	 }
     return;
 }

/*
 *
 *    Usage   - generates a usage message and an error message
 *              and terminates program.
 *
 *    Accepts - argv     - char *[]
 *              message  - char * - an error message
 *
 *    Returns - nothing.
 *
 */

 VOID Usage (char *argv[], char *message)
 {

     printf( "%s\n", message);
     printf( "usage: ");
     printf( "%s [-q] [-d] [-mx] [-px] [-w] [-tx]\n", argv[0]);
     printf( "\t-? :  This message\n");
     printf( "\t-q :  Quiet mode - Nothing printed.\n");
	 printf( "\t-d :  Debug break on Entry into and Exit from app.\n");
	 printf( "\t-m :  Number of megabytes to allocate.\n");
    printf( "\t   :  (default is to use all physical memory.)\n");
	 printf( "\t-p :  Number of pages to read (must be less than 63).\n");
	 printf( "\t-w :  Write to the virtual memory section.\n");
	 printf( "\t-b :  Read and Write the virtual memory section.\n");
	 printf( "\t-t :  Times to touch a page.\n");
	 printf( "**DEFAULT: clearmem -p63 -t1\n");
     exit (1);
 }

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cmdevent\cmdevent.c ===
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>


#define MAX_WAIT_HANDLES MAXIMUM_WAIT_OBJECTS

__cdecl
main (c, v)
int c;
char *v[];
{
    HANDLE hEvents[ 4 * MAX_WAIT_HANDLES ];
    char *EventNames[ 4 * MAX_WAIT_HANDLES ];
    char *s;
    ULONG nEvents, dwWaitResult;
    BOOLEAN fWaitAny = FALSE;
    BOOLEAN fWait = FALSE;
    BOOLEAN fVerbose = FALSE;
    BOOLEAN fUsage = TRUE;

    nEvents = 0;
    while (--c) {
        s = *++v;
        if (!_stricmp( s, "-a" )) {
            fWaitAny = TRUE;
            fWait = TRUE;
            }
        else
        if (!_stricmp( s, "-w" ))
            fWait = TRUE;
        else
        if (!_stricmp( s, "-v" ))
            fVerbose = TRUE;
        else
        if (nEvents == (4 * MAX_WAIT_HANDLES)) {
            fprintf( stderr, "CMDEVENT: Cant wait on more than %u events.\n",
                     4 * MAX_WAIT_HANDLES
                   );
            exit( -1 );
            }
        else {
            fUsage = FALSE;
            if (nEvents == MAX_WAIT_HANDLES && !fVerbose) {
                fprintf( stderr, "CMDEVENT: Waiting on more than %u events.  Forcing -v\n",
                         MAX_WAIT_HANDLES
                       );
                fVerbose = TRUE;
                }

            {
                char *d;

                d = s;
                while (*d) {
                    if (*d == '\\') {
                        *d = '_';
                        }
                    d++;
                    }
            }
            hEvents[ nEvents ] = fWait ? CreateEvent( NULL, TRUE, FALSE, s )
                                       : OpenEvent( EVENT_ALL_ACCESS, FALSE, s );

            if (hEvents[ nEvents ] == NULL) {
                fprintf( stderr, "CMDEVENT: Unable to %s event named '%s' - %u\n",
                         fWait ? "create" : "open",
                         s,
                         GetLastError()
                       );
                exit( -1 );
                break;
                }
            else
            if (!fWait) {
                if (!SetEvent( hEvents[ nEvents ] )) {
                    fprintf( stderr, "CMDEVENT: Unable to signal event named '%s' - %u\n",
                             s,
                             GetLastError()
                           );
                    }
                }
            else {
                EventNames[ nEvents ] = s;
                nEvents += 1;
                }
            }
        }

    if (fUsage) {
        fprintf( stderr, "usage: CMDEVENT [-w] [-v] EventName(s)...\n" );
        exit( -1 );
        }
    else
    if (fWait) {
        if (fVerbose) {
            fprintf( stderr, "\nWaiting for %u events:", nEvents );
            fflush( stderr );
            }

        while (nEvents) {
            dwWaitResult = WaitForMultipleObjects( nEvents > MAX_WAIT_HANDLES ?
                                                        MAX_WAIT_HANDLES :
                                                        nEvents,
                                                   hEvents,
                                                   FALSE,
                                                   INFINITE
                                                 );
            if (dwWaitResult == WAIT_FAILED) {
                fprintf( stderr, "\nCMDEVENT: Unable to wait for event(s) - %u\n",
                         GetLastError()
                       );
                exit( -1 );
                }
            else
            if (dwWaitResult < nEvents) {
                CloseHandle( hEvents[ dwWaitResult ] );

                if (fVerbose) {
                    fprintf( stderr, " %s", EventNames[ dwWaitResult ] );
                    fflush( stderr );
                    }

                if (fWaitAny) {
                    exit( dwWaitResult+1 );
                    }

                nEvents -= 1;
                if (dwWaitResult < nEvents) {
                    memmove( &hEvents[ dwWaitResult ],
                             &hEvents[ dwWaitResult+1 ],
                             (nEvents - dwWaitResult + 1) * sizeof( hEvents[ 0 ] )
                           );
                    memmove( &EventNames[ dwWaitResult ],
                             &EventNames[ dwWaitResult+1 ],
                             (nEvents - dwWaitResult + 1) * sizeof( EventNames[ 0 ] )
                           );
                    }
                }
            }

        if (fVerbose) {
            fprintf( stderr, "\n" );
            }
        }

    exit( 0 );
    return( 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cmdline\kill\pch.h ===
// *********************************************************************************
// 
//  Copyright (c) Microsoft Corporation
//  
//  Module Name:
// 
//		pch.h 
//  
//  Abstract:
//  
// 		pre-compiled header declaration
//		files that has to be pre-compiled into .pch file
//  
//  Author:
//  
// 	  Sunil G.V.N. Murali (murali.sunil@wipro.com) 24-Sep-2000
//  
//  Revision History:
//  
// 	  Sunil G.V.N. Murali (murali.sunil@wipro.com) 24-Sep-2000 : Created It.
//  
// *********************************************************************************

#ifndef __PCH_H
#define __PCH_H

#pragma once		// include header file only once

#if !defined( SECURITY_WIN32 ) && !defined( SECURITY_KERNEL ) && !defined( SECURITY_MAC )
#define SECURITY_WIN32
#endif

//
// Private nt headers.
//
extern "C"
{
	#include <nt.h>
	#include <ntrtl.h>
    #include <nturtl.h>
    #include <ntexapi.h>
	#include <Security.h>
	#include <SecExt.h>
}

//
// public Windows header files
//
#include <windows.h>
#include <winperf.h>
#include <wbemidl.h>
#include <chstring.h>
#include <comdef.h>
#include <wbemtime.h>
#include <tchar.h>
#include <dbghelp.h>

//
// public C header files
//
#include <stdio.h>
#include <string.h>
#include <crtdbg.h>
#include <errno.h>

//
// private Common header files
//
#include "cmdlineres.h"
#include "cmdline.h"

#endif	// __PCH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cmdline\kill\init.cpp ===
// *********************************************************************************
// 
//  Copyright (c) Microsoft Corporation
//  
//  Module Name:
//  
//		Init.cpp
//  
//  Abstract:
//  
// 		This module implements the general initialization stuff
//
//  Author:
//  
// 		Sunil G.V.N. Murali (murali.sunil@wipro.com) 26-Nov-2000
//  
//  Revision History:
//  
// 		Sunil G.V.N. Murali (murali.sunil@wipro.com) 26-Nov-2000 : Created It.
//  
// *********************************************************************************

#include "pch.h"
#include "wmi.h"
#include "taskkill.h"

// ***************************************************************************
// Routine Description:
//		CTaskKill contructor
//		  
// Arguments:
//		NONE
//  
// Return Value:
//		NONE
// 
// ***************************************************************************
CTaskKill::CTaskKill()
{
	// init to defaults
	m_arrFilters = NULL;
	m_arrTasksToKill = NULL;
	m_bUsage = FALSE;
	m_bTree = FALSE;
	m_bForce = FALSE;
	m_dwCurrentPid = 0;
	m_bNeedPassword = FALSE;
	m_arrFiltersEx = NULL;
	m_bNeedServicesInfo = FALSE;
	m_bNeedUserContextInfo = FALSE;
	m_bNeedModulesInfo = FALSE;
	m_pfilterConfigs = NULL;
	m_arrWindowTitles = NULL;
	m_pWbemLocator = NULL;
	m_pWbemServices = NULL;
	m_pWbemEnumObjects = NULL;
	m_pWbemTerminateInParams = NULL;
	m_bIsHydra = FALSE;
	m_hWinstaLib = NULL;
	m_pProcessInfo = NULL;
	m_ulNumberOfProcesses = 0;
	m_bCloseConnection = FALSE;
	m_dwServicesCount = 0;
	m_pServicesInfo = NULL;
	m_bUseRemote = FALSE;
	m_pdb = NULL;
	m_pfnWinStationFreeMemory = NULL;
	m_pfnWinStationOpenServerW = NULL;
	m_pfnWinStationCloseServer = NULL;
	m_pfnWinStationFreeGAPMemory = NULL;
	m_pfnWinStationGetAllProcesses = NULL;
	m_pfnWinStationEnumerateProcesses = NULL;
	m_arrRecord = NULL;
	m_pAuthIdentity = NULL;
	m_bTasksOptimized = FALSE;
	m_bFiltersOptimized = FALSE;
	m_hOutput = NULL;
}

// ***************************************************************************
// Routine Description:
//		CTaskKill destructor
//		  
// Arguments:
//		NONE
//  
// Return Value:
//		NONE
// 
// ***************************************************************************
CTaskKill::~CTaskKill()
{
	//
	// de-allocate memory allocations
	//
	
	//
	// destroy dynamic arrays
	DESTROY_ARRAY( m_arrRecord );
	DESTROY_ARRAY( m_arrFilters );
	DESTROY_ARRAY( m_arrFiltersEx );
	DESTROY_ARRAY( m_arrWindowTitles );
	DESTROY_ARRAY( m_arrTasksToKill );

	//
	// memory ( with new operator )
	RELEASE_MEMORY_EX( m_pfilterConfigs );

	//
	// release WMI / COM interfaces
	SAFE_RELEASE( m_pWbemLocator );
	SAFE_RELEASE( m_pWbemServices );
	SAFE_RELEASE( m_pWbemEnumObjects );
	SAFE_RELEASE( m_pWbemTerminateInParams );

	// free the wmi authentication structure
	WbemFreeAuthIdentity( &m_pAuthIdentity );

	// if connection to the remote system opened with NET API has to be closed .. do it
	if ( m_bCloseConnection == TRUE )
		CloseConnection( m_strServer );

	// free the memory allocated for services variables
	__free( m_pServicesInfo );

	// free the memory allocated for performance block
	if ( m_pdb != NULL )
	{
		HeapFree( GetProcessHeap(), 0, m_pdb );
		m_pdb = NULL;
	}

	//
	// free winstation block
	if ( m_bIsHydra == FALSE && m_pProcessInfo != NULL )
	{
		// free the GAP memory block
		WinStationFreeGAPMemory( GAP_LEVEL_BASIC, 
			(PTS_ALL_PROCESSES_INFO) m_pProcessInfo, m_ulNumberOfProcesses );
		
		// ...
		m_pProcessInfo = NULL;
	}
	else if ( m_bIsHydra == TRUE && m_pProcessInfo != NULL )
	{
		// free the winsta memory block
		WinStationFreeMemory( m_pProcessInfo );
		m_pProcessInfo = NULL;
	}

	// free the library
	if ( m_hWinstaLib != NULL )
	{
		FreeLibrary( m_hWinstaLib );
		m_hWinstaLib = NULL;
		m_pfnWinStationFreeMemory = NULL;
		m_pfnWinStationOpenServerW = NULL;
		m_pfnWinStationCloseServer = NULL;
		m_pfnWinStationFreeGAPMemory = NULL;
		m_pfnWinStationGetAllProcesses = NULL;
		m_pfnWinStationEnumerateProcesses = NULL;
	}

	// uninitialize the com library
	CoUninitialize();
}

// ***************************************************************************
// Routine Description:
//		initialize the task list utility
//		  
// Arguments:
//		NONE
//  
// Return Value:
//		TRUE	: if filters are appropriately specified
//		FALSE	: if filters are errorneously specified
// 
// ***************************************************************************
BOOL CTaskKill::Initialize()
{
	//
	// memory allocations

	// if at all any occurs, we know that is 'coz of the 
	// failure in memory allocation ... so set the error
	SetLastError( E_OUTOFMEMORY );
	SaveLastError();

	// get the current process id and save it
	m_dwCurrentPid = GetCurrentProcessId();

	// filters ( user supplied )
	if ( m_arrFilters == NULL )
	{
		m_arrFilters = CreateDynamicArray();
		if ( m_arrFilters == NULL )
			return FALSE;
	}

	// tasks to be killed ( user supplied )
	if ( m_arrTasksToKill == NULL )
	{
		m_arrTasksToKill = CreateDynamicArray();
		if ( m_arrTasksToKill == NULL )
			return FALSE;
	}

	// filters ( program generated parsed filters )
	if ( m_arrFiltersEx == NULL )
	{
		m_arrFiltersEx = CreateDynamicArray();
		if ( m_arrFiltersEx == NULL )
			return FALSE;
	}

	// filters configuration info
	if ( m_pfilterConfigs == NULL )
	{
		m_pfilterConfigs = new TFILTERCONFIG[ MAX_FILTERS ];
		if ( m_pfilterConfigs == NULL )
			return FALSE;

		// init to ZERO's
		ZeroMemory( m_pfilterConfigs, MAX_FILTERS * sizeof( TFILTERCONFIG ) );
	}

	// window titles
	if ( m_arrWindowTitles == NULL )
	{
		m_arrWindowTitles = CreateDynamicArray();
		if ( m_arrWindowTitles == NULL )
			return FALSE;
	}

	// tasks
	if ( m_arrRecord == NULL )
	{
		m_arrRecord = CreateDynamicArray();
		if ( m_arrRecord == NULL )
			return FALSE;
	}

	// initialize the COM library
	if ( InitializeCom( &m_pWbemLocator ) == FALSE )
		return FALSE;

	//
	// load the winsta library and needed functions
	// NOTE: do not raise any error if loading of winsta dll fails
	m_hWinstaLib = ::LoadLibrary( WINSTA_DLLNAME );
	if ( m_hWinstaLib != NULL )
	{
		// library loaded successfully ... now load the addresses of functions
		m_pfnWinStationFreeMemory = (FUNC_WinStationFreeMemory) ::GetProcAddress( m_hWinstaLib, FUNCNAME_WinStationFreeMemory );
		m_pfnWinStationCloseServer = (FUNC_WinStationCloseServer) ::GetProcAddress( m_hWinstaLib, FUNCNAME_WinStationCloseServer );
		m_pfnWinStationOpenServerW = (FUNC_WinStationOpenServerW) ::GetProcAddress( m_hWinstaLib, FUNCNAME_WinStationOpenServerW );
		m_pfnWinStationFreeGAPMemory = (FUNC_WinStationFreeGAPMemory) ::GetProcAddress( m_hWinstaLib, FUNCNAME_WinStationFreeGAPMemory );
		m_pfnWinStationGetAllProcesses = (FUNC_WinStationGetAllProcesses) ::GetProcAddress( m_hWinstaLib, FUNCNAME_WinStationGetAllProcesses );
		m_pfnWinStationEnumerateProcesses = (FUNC_WinStationEnumerateProcesses) ::GetProcAddress( m_hWinstaLib, FUNCNAME_WinStationEnumerateProcesses );

		// we will keep the library loaded in memory only if all the functions were loaded successfully
		if ( m_pfnWinStationFreeMemory == NULL || m_pfnWinStationCloseServer == NULL || 
			 m_pfnWinStationOpenServerW == NULL || m_pfnWinStationFreeGAPMemory == NULL ||
			 m_pfnWinStationGetAllProcesses == NULL || m_pfnWinStationEnumerateProcesses == NULL )
		{
			// some (or) all of the functions were not loaded ... unload the library
			FreeLibrary( m_hWinstaLib );
			m_hWinstaLib = NULL;
			m_pfnWinStationFreeMemory = NULL;
			m_pfnWinStationOpenServerW = NULL;
			m_pfnWinStationCloseServer = NULL;
			m_pfnWinStationFreeGAPMemory = NULL;
			m_pfnWinStationGetAllProcesses = NULL;
			m_pfnWinStationEnumerateProcesses = NULL;
		}
	}

	//
	// init the console scree buffer structure to zero's
	// and then get the console handle and screen buffer information
	//
	// prepare for status display.
	// for this get a handle to the screen output buffer
	// but this handle will be null if the output is being redirected. so do not check 
	// for the validity of the handle. instead try to get the console buffer information
	// only in case you have a valid handle to the output screen buffer
	ZeroMemory( &m_csbi, sizeof( CONSOLE_SCREEN_BUFFER_INFO ) );
	m_hOutput = GetStdHandle( STD_ERROR_HANDLE );
	if ( m_hOutput != NULL )
		GetConsoleScreenBufferInfo( m_hOutput, &m_csbi );

	// initialization is successful
	SetLastError( NOERROR );			// clear the error
	SetReason( NULL_STRING );			// clear the reason
	return TRUE;
}

// ***************************************************************************
// Routine Description:
//		Enables the debug privliges for the current process so that
//		this utility can terminate the processes on local system without any problem
//		  
// Arguments:
//		NONE
//
// Return Value:
//		TRUE upon successfull and FALSE if failed
//
// ***************************************************************************
BOOL CTaskKill::EnableDebugPriv()
{
	// local variables
    LUID luidValue;
	BOOL bResult = FALSE;
    HANDLE hToken = NULL;
    TOKEN_PRIVILEGES tkp;

    // Retrieve a handle of the access token
	bResult = OpenProcessToken( GetCurrentProcess(), 
		TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken );
    if ( bResult == FALSE ) 
	{
		// save the error messaage and return
        SaveLastError();
        return FALSE;
    }

    // Enable the SE_DEBUG_NAME privilege or disable
    // all privileges, depends on this flag.
	bResult = LookupPrivilegeValue( NULL, SE_DEBUG_NAME, &luidValue );
    if ( bResult == FALSE ) 
	{
		// save the error messaage and return
        SaveLastError();
		CloseHandle( hToken );
        return FALSE;
    }

	// prepare the token privileges structure
	tkp.PrivilegeCount = 1;
    tkp.Privileges[ 0 ].Luid = luidValue;
    tkp.Privileges[ 0 ].Attributes = SE_PRIVILEGE_ENABLED;

	// now enable the debug privileges in the token
	bResult = AdjustTokenPrivileges( hToken, FALSE, &tkp, sizeof( TOKEN_PRIVILEGES ),
		( PTOKEN_PRIVILEGES ) NULL, ( PDWORD ) NULL );
    if ( bResult == FALSE )
	{
        // The return value of AdjustTokenPrivileges be texted
        SaveLastError();
		CloseHandle( hToken );
        return FALSE;
    }

	// close the opened handle object
	CloseHandle( hToken );

	// enabled ... inform success
    return TRUE;
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
BOOLEAN CTaskKill::WinStationFreeMemory( PVOID pBuffer )
{
	// check the buffer and act
	if ( pBuffer == NULL )
		return TRUE;

	// check whether pointer exists or not
	if ( m_pfnWinStationFreeMemory == NULL )
		return FALSE;

	// call and return the same
	return ((FUNC_WinStationFreeMemory) m_pfnWinStationFreeMemory)( pBuffer );
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
BOOLEAN CTaskKill::WinStationCloseServer( HANDLE hServer )
{
	// check the input
	if ( hServer == NULL )
		return TRUE;

	// check whether the function pointer exists or not
	if ( m_pfnWinStationCloseServer == NULL )
		return FALSE;

	// call and return
	return ((FUNC_WinStationCloseServer) m_pfnWinStationCloseServer)( hServer );
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
HANDLE CTaskKill::WinStationOpenServerW( LPWSTR pwszServerName )
{
	// check the input & also check whether function pointer exists or not
	if ( pwszServerName == NULL || m_pfnWinStationOpenServerW == NULL )
		return NULL;

	// call and return
	return ((FUNC_WinStationOpenServerW) m_pfnWinStationOpenServerW)( pwszServerName );
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
BOOLEAN CTaskKill::WinStationEnumerateProcesses( HANDLE hServer, PVOID* ppProcessBuffer )
{
	// check the input and also check whether function pointer exists or not
	if ( ppProcessBuffer == NULL || m_pfnWinStationEnumerateProcesses == NULL )
		return FALSE;

	// call and return
	return ((FUNC_WinStationEnumerateProcesses) 
		m_pfnWinStationEnumerateProcesses)( hServer, ppProcessBuffer );
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
BOOLEAN CTaskKill::WinStationFreeGAPMemory( ULONG ulLevel, PVOID pProcessArray, ULONG ulCount )
{
	// check the input
	if ( pProcessArray == NULL )
		return TRUE;

	// check whether function pointer exists or not
	if ( m_pfnWinStationFreeGAPMemory == NULL )
		return FALSE;

	// call and return
	return ((FUNC_WinStationFreeGAPMemory) 
		m_pfnWinStationFreeGAPMemory)( ulLevel, pProcessArray, ulCount );
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
BOOLEAN CTaskKill::WinStationGetAllProcesses( HANDLE hServer, ULONG ulLevel, 
 											  ULONG* pNumberOfProcesses, PVOID* ppProcessArray )
{
	// check the input & check whether function pointer exists or not
	if (pNumberOfProcesses == NULL || ppProcessArray == NULL || m_pfnWinStationGetAllProcesses == NULL)
		return FALSE;

	return ((FUNC_WinStationGetAllProcesses) 
		m_pfnWinStationGetAllProcesses)( hServer, ulLevel, pNumberOfProcesses, ppProcessArray );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cmdline\kill\resource.h ===
#define IDS_FILTER_APPLICATION				102
#define IDS_FILTER_STATUS					103
#define IDS_FILTER_IMAGENAME				104
#define IDS_FILTER_PID						105
#define IDS_FILTER_SESSION					106
#define IDS_FILTER_CPUTIME					107
#define IDS_FILTER_MEMUSAGE					108
#define IDS_FILTER_USERNAME					109
#define IDS_FILTER_SERVICES					110
#define IDS_FILTER_WINDOWNAME				111
#define IDS_FILTER_MODULES					112
#define IDS_FVALUES_STATUS					113

#define IDS_OPERATORS_STRING				121
#define IDS_OPERATORS_NUMERIC				122

#define IDS_VALUE_RUNNING					151
#define IDS_VALUE_NOTRESPONDING				152
#define IDS_PID_0_DOMAIN					153
#define IDS_PID_0_USERNAME					154

#define IDS_MSG_KILL_SUCCESS				501
#define IDS_MSG_KILL_SUCCESS_QUEUED			502
#define IDS_MSG_KILL_SUCCESS_EX				503
#define IDS_MSG_KILL_SUCCESS_QUEUED_EX		504
#define IDS_ERROR_KILL_FAILED				505
#define IDS_ERROR_KILL_FAILED_EX			506
#define IDS_ERROR_PROCESS_NOTFOUND			507
#define IDS_ERROR_NO_PROCESSES				508
#define IDS_ERROR_UNABLE_TO_TERMINATE		509
#define IDS_ERROR_CRITICAL_SYSTEM_PROCESS	510
#define	IDS_ERROR_CANNOT_KILL_SILENTLY		511
#define IDS_ERROR_CANNOT_KILL_ITSELF		512
#define IDS_ERROR_COM_ERROR					513
#define IDS_ERROR_USERNAME_BUT_NOMACHINE	514
#define IDS_ERROR_PASSWORD_BUT_NOUSERNAME	515
#define IDS_ERROR_USERNAME_EMPTY			516
#define IDS_ERROR_SERVER_EMPTY				517
#define IDS_ERROR_WILDCARD_WITHOUT_FILTERS	518
#define IDS_ERROR_PID_OR_IM_ONLY			519
#define IDS_ERROR_NO_PID_AND_IM				520
#define IDS_ERROR_STRING_FOR_PID			521
#define IDS_ERROR_INVALID_USAGE_REQUEST		522
#define IDS_ERROR_PLATFORM_SHOULD_BE_X86	523
#define IDS_MSG_TREE_KILL_SUCCESS			524
#define IDS_ERROR_TREE_KILL_FAILED			525
#define IDS_ERROR_TASK_HAS_CHILDS			526

#define IDS_MSG_MODULESINFO					601
#define IDS_MSG_SERVICESINFO				602
#define IDS_MSG_TASKSINFO					603
#define	IDS_MSG_MODULESINFO_EX				604
#define IDS_MSG_FORMINGTREE					605

#define IDS_HELP_LINE1                  1001
#define IDS_HELP_LINE2                  1002
#define IDS_HELP_LINE3                  1003
#define IDS_HELP_LINE4                  1004
#define IDS_HELP_LINE5                  1005
#define IDS_HELP_LINE6                  1006
#define IDS_HELP_LINE7                  1007
#define IDS_HELP_LINE8                  1008
#define IDS_HELP_LINE9                  1009
#define IDS_HELP_LINE10                 1010
#define IDS_HELP_LINE11                 1011
#define IDS_HELP_LINE12                 1012
#define IDS_HELP_LINE13                 1013
#define IDS_HELP_LINE14                 1014
#define IDS_HELP_LINE15                 1015
#define IDS_HELP_LINE16                 1016
#define IDS_HELP_LINE17                 1017
#define IDS_HELP_LINE18                 1018
#define IDS_HELP_LINE19                 1019
#define IDS_HELP_LINE20                 1020
#define IDS_HELP_LINE21                 1021
#define IDS_HELP_LINE22                 1022
#define IDS_HELP_LINE23                 1023
#define IDS_HELP_LINE24                 1024
#define IDS_HELP_LINE25                 1025
#define IDS_HELP_LINE26                 1026
#define IDS_HELP_LINE27                 1027
#define IDS_HELP_LINE28                 1028
#define IDS_HELP_LINE29                 1029
#define IDS_HELP_LINE30                 1030
#define IDS_HELP_LINE31                 1031
#define IDS_HELP_LINE32                 1032
#define IDS_HELP_LINE33                 1033
#define IDS_HELP_LINE34                 1034
#define IDS_HELP_LINE35                 1035
#define IDS_HELP_LINE36                 1036
#define IDS_HELP_LINE37                 1037
#define IDS_HELP_LINE38                 1038
#define IDS_HELP_LINE39                 1039
#define IDS_HELP_LINE40                 1040
#define IDS_HELP_LINE41                 1041
#define IDS_HELP_LINE42                 1042
#define IDS_HELP_LINE43                 1043
#define IDS_HELP_LINE44                 1044
#define IDS_HELP_LINE45                 1045
#define IDS_HELP_LINE46                 1046
#define IDS_HELP_LINE47                 1047
#define IDS_HELP_LINE48                 1048
#define IDS_HELP_LINE49                 1049
#define IDS_HELP_LINE50                 1050
#define IDS_HELP_LINE51                 1051
#define IDS_HELP_LINE52                 1052
#define IDS_HELP_LINE53                 1053
#define IDS_HELP_LINE54                 1054
#define IDS_HELP_LINE55                 1055

// usage indexes into the string table
#define ID_HELP_START		IDS_HELP_LINE1
#define ID_HELP_END			IDS_HELP_LINE55
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cmdline\kill\parse.cpp ===
// *********************************************************************************
// 
//  Copyright (c) Microsoft Corporation
//  
//  Module Name:
//  
//		parse.cpp
//  
//  Abstract:
//  
// 		This module implements the command-line parsing and validating the filters
//  
//  Author:
//  
// 		Sunil G.V.N. Murali (murali.sunil@wipro.com) 26-Nov-2000
//  
//  Revision History:
//  
// 		Sunil G.V.N. Murali (murali.sunil@wipro.com) 26-Nov-2000 : Created It.
//  
// *********************************************************************************

#include "pch.h"
#include "taskkill.h"

//
// local function prototypes
//
BOOL ValidatePID( LPCWSTR pwszOption, LPCWSTR pwszValue, LPVOID pData );
BOOL TimeFieldsToElapsedTime( LPCWSTR pwszTime, LPCWSTR pwszToken, ULONG& ulElapsedTime );
DWORD FilterMemUsage( LPCWSTR pwszProperty, LPCWSTR pwszOperator, 
				      LPCWSTR pwszValue, LPVOID pData, TARRAY arrRow );
DWORD FilterCPUTime( LPCWSTR pwszProperty, LPCWSTR pwszOperator, 
				     LPCWSTR pwszValue, LPVOID pData, TARRAY arrRow );
DWORD FilterUserName( LPCWSTR pwszProperty, LPCWSTR pwszOperator, 
				      LPCWSTR pwszValue, LPVOID pData, TARRAY arrRow );
DWORD FilterProcessId( LPCWSTR pwszProperty, LPCWSTR pwszOperator, 
				       LPCWSTR pwszValue, LPVOID pData, TARRAY arrRow );

// ***************************************************************************
// Routine Description:
//		processes and validates the command line inputs
//		  
// Arguments:
//		[ in ] argc			 : no. of input arguments specified
//		[ in ] argv			 : input arguments specified at command prompt
//  
// Return Value:
//		TRUE  : if inputs are valid
//		FALSE : if inputs were errorneously specified
// 
// ***************************************************************************
BOOL CTaskKill::ProcessOptions( DWORD argc, LPCWSTR argv[] )
{
	// local variables
	BOOL bResult = FALSE;
	PTCMDPARSER pcmdOptions = NULL;

	// temporary local variables
	LPWSTR pwszServer = NULL;
	LPWSTR pwszUserName = NULL;
	LPWSTR pwszPassword = NULL;
	PTCMDPARSER pOption = NULL;
	PTCMDPARSER pOptionServer = NULL;
	PTCMDPARSER pOptionUserName = NULL;
	PTCMDPARSER pOptionPassword = NULL;

	//
	// prepare the command options
	pcmdOptions = new TCMDPARSER[ MAX_OPTIONS ];
	if ( pcmdOptions == NULL )
	{
		SetLastError( E_OUTOFMEMORY );
		SaveLastError();
		return FALSE;
	}

	// ...
	ZeroMemory( pcmdOptions, MAX_OPTIONS * sizeof( TCMDPARSER ) );

	try
	{
		// get the pointers to the input bufers
		pwszServer = m_strServer.GetBufferSetLength( MAX_STRING_LENGTH );
		pwszUserName = m_strUserName.GetBufferSetLength( MAX_STRING_LENGTH );
		pwszPassword = m_strPassword.GetBufferSetLength( MAX_STRING_LENGTH );

		// init the password contents with '*'
		lstrcpy( pwszPassword, L"*" );
	}
	catch( ... )
	{
		SetLastError( E_OUTOFMEMORY );
		SaveLastError();
		return FALSE;
	}

	// -?
	pOption = pcmdOptions + OI_USAGE;
	pOption->dwCount = 1;
	pOption->dwActuals = 0;
	pOption->dwFlags = CP_USAGE;
	pOption->pValue = &m_bUsage;
	pOption->pFunction = NULL;
	pOption->pFunctionData = NULL;
	lstrcpy( pOption->szValues, NULL_STRING );
	lstrcpy( pOption->szOption, OPTION_USAGE );

	// -s
	pOption = pcmdOptions + OI_SERVER;
	pOption->dwCount = 1;
	pOption->dwActuals = 0;
	pOption->dwFlags = CP_TYPE_TEXT | CP_VALUE_MANDATORY;
	pOption->pValue = pwszServer;
	pOption->pFunction = NULL;
	pOption->pFunctionData = NULL;
	lstrcpy( pOption->szValues, NULL_STRING );
	lstrcpy( pOption->szOption, OPTION_SERVER );

	// -u
	pOption = pcmdOptions + OI_USERNAME;
	pOption->dwCount = 1;
	pOption->dwActuals = 0;
	pOption->dwFlags = CP_TYPE_TEXT | CP_VALUE_MANDATORY;
	pOption->pValue = pwszUserName;
	pOption->pFunction = NULL;
	pOption->pFunctionData = NULL;
	lstrcpy( pOption->szValues, NULL_STRING );
	lstrcpy( pOption->szOption, OPTION_USERNAME );

	// -p
	pOption = pcmdOptions + OI_PASSWORD;
	pOption->dwCount = 1;
	pOption->dwActuals = 0;
	pOption->dwFlags = CP_TYPE_TEXT | CP_VALUE_OPTIONAL;
	pOption->pValue = pwszPassword;
	pOption->pFunction = NULL;
	pOption->pFunctionData = NULL;
	lstrcpy( pOption->szValues, NULL_STRING );
	lstrcpy( pOption->szOption, OPTION_PASSWORD );

	// -f
	pOption = pcmdOptions + OI_FORCE;
	pOption->dwCount = 1;
	pOption->dwActuals = 0;
	pOption->dwFlags = 0;
	pOption->pValue = &m_bForce;
	pOption->pFunction = NULL;
	pOption->pFunctionData = NULL;
	lstrcpy( pOption->szValues, NULL_STRING );
	lstrcpy( pOption->szOption, OPTION_FORCE );

	// -tr
	pOption = pcmdOptions + OI_TREE;
	pOption->dwCount = 1;
	pOption->dwActuals = 0;
	pOption->dwFlags = 0;
	pOption->pValue = &m_bTree;
	pOption->pFunction = NULL;
	pOption->pFunctionData = NULL;
	lstrcpy( pOption->szValues, NULL_STRING );
	lstrcpy( pOption->szOption, OPTION_TREE );

	// -fi
	pOption = pcmdOptions + OI_FILTER;
	pOption->dwCount = 0;
	pOption->dwActuals = 0;
	pOption->dwFlags = CP_TYPE_TEXT | CP_VALUE_MANDATORY | CP_MODE_ARRAY;
	pOption->pValue = &m_arrFilters;
	pOption->pFunction = NULL;
	pOption->pFunctionData = NULL;
	lstrcpy( pOption->szValues, NULL_STRING );
	lstrcpy( pOption->szOption, OPTION_FILTER );

	// -pid
	pOption = pcmdOptions + OI_PID;
	pOption->dwCount = 0;
	pOption->dwActuals = 0;
	pOption->dwFlags = CP_TYPE_TEXT | CP_MODE_ARRAY | CP_VALUE_NODUPLICATES | CP_TYPE_CUSTOM | CP_VALUE_MANDATORY;
	pOption->pValue = &m_arrTasksToKill;
	pOption->pFunction = ValidatePID;
	pOption->pFunctionData = m_arrTasksToKill;
	lstrcpy( pOption->szValues, NULL_STRING );
	lstrcpy( pOption->szOption, OPTION_PID );

	// -im
	pOption = pcmdOptions + OI_IMAGENAME;
	pOption->dwCount = 0;
	pOption->dwActuals = 0;
	pOption->dwFlags = CP_TYPE_TEXT | CP_MODE_ARRAY | CP_VALUE_NODUPLICATES | CP_VALUE_MANDATORY;
	pOption->pValue = &m_arrTasksToKill;
	pOption->pFunction = NULL;
	pOption->pFunctionData = NULL;
	lstrcpy( pOption->szValues, NULL_STRING );
	lstrcpy( pOption->szOption, OPTION_IMAGENAME );

	//
	// do the parsing
	bResult = DoParseParam( argc, argv, MAX_OPTIONS, pcmdOptions );

	// release the buffers
	m_strServer.ReleaseBuffer();
	m_strUserName.ReleaseBuffer();
	m_strPassword.ReleaseBuffer();

	// now check the result of parsing and decide
	if ( bResult == FALSE )
	{
		delete [] pcmdOptions;	// clear memory
		pcmdOptions = NULL;
		return FALSE;			// invalid syntax
	}

	//
	// now, check the mutually exclusive options
	pOptionServer = pcmdOptions + OI_SERVER;
	pOptionUserName = pcmdOptions + OI_USERNAME;
	pOptionPassword = pcmdOptions + OI_PASSWORD;

	// check the usage option
	if ( m_bUsage && ( argc > 2 ) )
	{
		// no other options are accepted along with -? option
		delete [] pcmdOptions;	// clear memory
		pcmdOptions = NULL;
		SetLastError( MK_E_SYNTAX );
		SetReason( ERROR_INVALID_USAGE_REQUEST );
		return FALSE;
	}
	else if ( m_bUsage == TRUE )
	{
		// should not do the furthur validations
		delete [] pcmdOptions;	// clear memory
		pcmdOptions = NULL;
		return TRUE;
	}

	// "-u" should not be specified without machine names
	if ( pOptionServer->dwActuals == 0 && pOptionUserName->dwActuals != 0 )
	{
		// invalid syntax
		SetReason( ERROR_USERNAME_BUT_NOMACHINE );
		delete [] pcmdOptions;	// clear memory
		pcmdOptions = NULL;
		return FALSE;			// indicate failure
	}

	// empty user is not valid
	if ( pOptionUserName->dwActuals != 0 && m_strUserName.GetLength() == 0 )
	{
		SetReason( ERROR_USERNAME_EMPTY );
		delete [] pcmdOptions;	// clear memory
		pcmdOptions = NULL;
		return FALSE;
	}

	// empty server name is not valid
	if ( pOptionServer->dwActuals != 0 && m_strServer.GetLength() == 0 )
	{
		SetReason( ERROR_SERVER_EMPTY );
		delete [] pcmdOptions;	// clear memory
		pcmdOptions = NULL;
		return FALSE;
	}

	// "-p" should not be specified without "-u"
	if ( pOptionUserName->dwActuals == 0 && pOptionPassword->dwActuals != 0 )
	{
		// invalid syntax
		SetReason( ERROR_PASSWORD_BUT_NOUSERNAME );
		delete [] pcmdOptions;	// clear memory
		pcmdOptions = NULL;
		return FALSE;			// indicate failure
	}

	// check whether caller should accept the password or not
	// if user has specified -s (or) -u and no "-p", then utility should accept password
	// the user will be prompter for the password only if establish connection 
	// is failed without the credentials information
	if ( pOptionPassword->dwActuals != 0 && m_strPassword.Compare( L"*" ) == 0 )
	{
		// user wants the utility to prompt for the password before trying to connect
		m_bNeedPassword = TRUE;
	}
	else if ( (pOptionPassword->dwActuals == 0 && 
			  (pOptionServer->dwActuals != 0 || pOptionUserName->dwActuals != 0)) )
	{
		// utility needs to try to connect first and if it fails then prompt for the password
		m_bNeedPassword = TRUE;
		m_strPassword.Empty();
	}

	// either -pid (or) -im are allowed but not both
	if ( (pcmdOptions + OI_PID)->dwActuals != 0 && (pcmdOptions + OI_IMAGENAME)->dwActuals != 0 )
	{
		// invalid syntax
		SetReason( ERROR_PID_OR_IM_ONLY );
		delete [] pcmdOptions;	// clear memory
		pcmdOptions = NULL;
		return FALSE;			// indicate failure
	}
	else if ( DynArrayGetCount( m_arrTasksToKill ) == 0 )
	{
		// tasks were not specified .. but user might have specified filters
		// check that and if user didn't filters error
		if ( DynArrayGetCount( m_arrFilters ) == 0 )
		{
			// invalid syntax
			SetReason( ERROR_NO_PID_AND_IM );
			delete [] pcmdOptions;	// clear memory
			pcmdOptions = NULL;
			return FALSE;			// indicate failure
		}

		// user specified filters ... add '*' to the list of task to kill
		DynArrayAppendString( m_arrTasksToKill, L"*", 0 );
	}

	// check if '*' is specified along with the filters or not
	// if not specified along with the filters, error
	if ( DynArrayGetCount( m_arrFilters ) == 0 )
	{
		// filters were not specified .. so '*' should not be specified
		LONG lIndex = 0;
		lIndex = DynArrayFindString( m_arrTasksToKill, L"*", TRUE, 0 );
		if ( lIndex != -1 )
		{
			// error ... '*' is specified even if filters were not specified
			SetReason( ERROR_WILDCARD_WITHOUT_FILTERS );
			delete [] pcmdOptions;	// clear memory
			pcmdOptions = NULL;
			return FALSE;
		}
	}

	// command-line parsing is successfull
	delete [] pcmdOptions;	// clear memory
	pcmdOptions = NULL;
	return TRUE;
}

// ***************************************************************************
// Routine Description:
//		validates the filter information specified with -filter option
//		  
// Arguments:
//		NONE
//  
// Return Value:
//		TRUE	: if filters are appropriately specified
//		FALSE	: if filters are errorneously specified
// 
// ***************************************************************************
BOOL CTaskKill::ValidateFilters()
{
	// local variables
	LONG lIndex = -1;
	BOOL bResult = FALSE;
	PTFILTERCONFIG pConfig = NULL;

	//
	// prepare the filter structure

	// status
	pConfig = m_pfilterConfigs + FI_STATUS;
	pConfig->dwColumn = TASK_STATUS;
	pConfig->dwFlags = F_TYPE_TEXT | F_MODE_VALUES;
	pConfig->pFunction = NULL;
	pConfig->pFunctionData = NULL;
	lstrcpy( pConfig->szOperators, OPERATORS_STRING );
	lstrcpy( pConfig->szProperty, FILTER_STATUS );
	lstrcpy( pConfig->szValues, FVALUES_STATUS );

	// imagename
	pConfig = m_pfilterConfigs + FI_IMAGENAME;
	pConfig->dwColumn = TASK_IMAGENAME;
	pConfig->dwFlags = F_TYPE_TEXT | F_MODE_PATTERN;
	pConfig->pFunction = NULL;
	pConfig->pFunctionData = NULL;
	lstrcpy( pConfig->szOperators, OPERATORS_STRING );
	lstrcpy( pConfig->szProperty, FILTER_IMAGENAME );
	lstrcpy( pConfig->szValues, NULL_STRING );

	// pid
	pConfig = m_pfilterConfigs + FI_PID;
	pConfig->dwColumn = TASK_PID;
	pConfig->dwFlags = F_TYPE_CUSTOM;
	pConfig->pFunction = FilterProcessId;
	pConfig->pFunctionData = NULL;
	lstrcpy( pConfig->szOperators, OPERATORS_NUMERIC );
	lstrcpy( pConfig->szProperty, FILTER_PID );
	lstrcpy( pConfig->szValues, NULL_STRING );

	// session
	pConfig = m_pfilterConfigs + FI_SESSION;
	pConfig->dwColumn = TASK_SESSION;
	pConfig->dwFlags = F_TYPE_UNUMERIC;
	pConfig->pFunction = NULL;
	pConfig->pFunctionData = NULL;
	lstrcpy( pConfig->szOperators, OPERATORS_NUMERIC );
	lstrcpy( pConfig->szProperty, FILTER_SESSION );
	lstrcpy( pConfig->szValues, NULL_STRING );

	// cputime
	pConfig = m_pfilterConfigs + FI_CPUTIME;
	pConfig->dwColumn = TASK_CPUTIME;
	pConfig->dwFlags = F_TYPE_CUSTOM;
	pConfig->pFunction = FilterCPUTime;
	pConfig->pFunctionData = NULL;
	lstrcpy( pConfig->szOperators, OPERATORS_NUMERIC );
	lstrcpy( pConfig->szProperty, FILTER_CPUTIME );
	lstrcpy( pConfig->szValues, NULL_STRING );

	// memusage
	pConfig = m_pfilterConfigs + FI_MEMUSAGE;
	pConfig->dwColumn = TASK_MEMUSAGE;
	pConfig->dwFlags = F_TYPE_UNUMERIC;
	pConfig->pFunction = NULL;
	pConfig->pFunctionData = NULL;
	lstrcpy( pConfig->szOperators, OPERATORS_NUMERIC );
	lstrcpy( pConfig->szProperty, FILTER_MEMUSAGE );
	lstrcpy( pConfig->szValues, NULL_STRING );

	// username
	pConfig = m_pfilterConfigs + FI_USERNAME;
	pConfig->dwColumn = TASK_USERNAME;
	pConfig->dwFlags = F_TYPE_CUSTOM;
	pConfig->pFunction = FilterUserName;
	pConfig->pFunctionData = NULL;
	lstrcpy( pConfig->szOperators, OPERATORS_STRING );
	lstrcpy( pConfig->szProperty, FILTER_USERNAME );
	lstrcpy( pConfig->szValues, NULL_STRING );

	// services
	pConfig = m_pfilterConfigs + FI_SERVICES;
	pConfig->dwColumn = TASK_SERVICES;
	pConfig->dwFlags = F_TYPE_TEXT | F_MODE_PATTERN | F_MODE_ARRAY;
	pConfig->pFunction = NULL;
	pConfig->pFunctionData = NULL;
	lstrcpy( pConfig->szOperators, OPERATORS_STRING );
	lstrcpy( pConfig->szProperty, FILTER_SERVICES );
	lstrcpy( pConfig->szValues, NULL_STRING );

	// windowtitle
	pConfig = m_pfilterConfigs + FI_WINDOWTITLE;
	pConfig->dwColumn = TASK_WINDOWTITLE;
	pConfig->dwFlags = F_TYPE_TEXT | F_MODE_PATTERN;
	pConfig->pFunction = NULL;
	pConfig->pFunctionData = NULL;
	lstrcpy( pConfig->szOperators, OPERATORS_STRING );
	lstrcpy( pConfig->szProperty, FILTER_WINDOWTITLE );
	lstrcpy( pConfig->szValues, NULL_STRING );

	// modules
	pConfig = m_pfilterConfigs + FI_MODULES;
	pConfig->dwColumn = TASK_MODULES;
	pConfig->dwFlags = F_TYPE_TEXT | F_MODE_PATTERN | F_MODE_ARRAY;
	pConfig->pFunction = NULL;
	pConfig->pFunctionData = NULL;
	lstrcpy( pConfig->szOperators, OPERATORS_STRING );
	lstrcpy( pConfig->szProperty, FILTER_MODULES );
	lstrcpy( pConfig->szValues, NULL_STRING );

	//
	// validate the filter
	bResult = ParseAndValidateFilter( MAX_FILTERS, 
		m_pfilterConfigs, m_arrFilters, &m_arrFiltersEx );

	// check the filter validation result
	if ( bResult == FALSE )
		return FALSE;

	// find out whether user has requested for the tasks to be filtered 
	// on user context and/or services are not ... if yes, set the appropriate flags
	// this check is being done to increase the performance of the utility
	// NOTE: we will be using the parsed filters info for doing this

	// user context
	if ( m_bNeedUserContextInfo == FALSE )
	{
		// find out if the filter property exists in this row
		// NOTE:- 
		//		  filter property do exists in the seperate indexes only.
		//		  refer to the logic of validating the filters in common functionality
		lIndex = DynArrayFindStringEx( m_arrFiltersEx, 
			F_PARSED_INDEX_PROPERTY, FILTER_USERNAME, TRUE, 0 );
		if ( lIndex != -1 )
			m_bNeedUserContextInfo = TRUE;
	}

	// services info
	if ( m_bNeedServicesInfo == FALSE )
	{
		// find out if the filter property exists in this row
		// NOTE:- 
		//		  filter property do exists in the seperate indexes only.
		//		  refer to the logic of validating the filters in common functionality
		lIndex = DynArrayFindStringEx( m_arrFiltersEx, 
			F_PARSED_INDEX_PROPERTY, FILTER_SERVICES, TRUE, 0 );
		if ( lIndex != -1 )
			m_bNeedServicesInfo = TRUE;
	}

	// modules info
	if ( m_bNeedModulesInfo == FALSE )
	{
		// find out if the filter property exists in this row
		// NOTE:- 
		//		  filter property do exists in the seperate indexes only.
		//		  refer to the logic of validating the filters in common functionality
		lIndex = DynArrayFindStringEx( m_arrFiltersEx, 
			F_PARSED_INDEX_PROPERTY, FILTER_MODULES, TRUE, 0 );
		if ( lIndex != -1 )
			m_bNeedModulesInfo = TRUE;
	}

	//
	// do the filter optimization by adding the wmi properties to the query
	//
	// NOTE: as the 'handle' property of the Win32_Process class is string type
	//       we cannot include that in the wmi query for optimization. So make use
	//		 of the ProcessId property

	// optimization should not be done if user requested for tree termination
	if ( m_bTree == TRUE )
	{
		try
		{
			// default query
			m_strQuery = WMI_PROCESS_QUERY;
		}
		catch( ... )
		{
			SetLastError( E_OUTOFMEMORY );
			SaveLastError();
			return FALSE;
		}

		// modify the record filtering type for "memusage" filter from built-in type to custom type
		( m_pfilterConfigs + FI_MEMUSAGE )->dwFlags = F_TYPE_CUSTOM;
		( m_pfilterConfigs + FI_MEMUSAGE )->pFunctionData = NULL;
		( m_pfilterConfigs + FI_MEMUSAGE )->pFunction = FilterMemUsage;

		// modify the record filtering type for "pid" filter from custom to built-in type
		( m_pfilterConfigs + FI_PID )->dwFlags = F_TYPE_UNUMERIC;
		( m_pfilterConfigs + FI_PID )->pFunctionData = NULL;
		( m_pfilterConfigs + FI_PID )->pFunction = NULL;

		// simply return ... filter validation is complete
		return TRUE;
	}

	// variables needed by optimization logic
	LONG lCount = 0;
	CHString strBuffer;
	BOOL bOptimized = FALSE;
	LPCWSTR pwszValue = NULL;
	LPCWSTR pwszClause = NULL;
	LPCWSTR pwszProperty = NULL;
	LPCWSTR pwszOperator = NULL;

	try
	{
		// first clause .. and init
		m_strQuery = WMI_PROCESS_QUERY;
		pwszClause = WMI_QUERY_FIRST_CLAUSE;

		// get the no. of filters
		lCount = DynArrayGetCount( m_arrFiltersEx );

		// traverse thru all the filters and do the optimization
		m_bFiltersOptimized = FALSE;
		for( LONG i = 0; i < lCount; i++ )
		{
			// assume this filter will not be delete / not useful for optimization
			bOptimized = FALSE;

			// get the property, operator and value
			pwszValue = DynArrayItemAsString2( m_arrFiltersEx, i, F_PARSED_INDEX_VALUE );
			pwszProperty = DynArrayItemAsString2( m_arrFiltersEx, i, F_PARSED_INDEX_PROPERTY );
			pwszOperator = DynArrayItemAsString2( m_arrFiltersEx, i, F_PARSED_INDEX_OPERATOR );
			if ( pwszProperty == NULL || pwszOperator == NULL || pwszValue == NULL )
			{
				SetLastError( STG_E_UNKNOWN );
				SaveLastError();
				return FALSE;
			}

			//
			// based on the property do optimization needed

			// get the mathematically equivalent operator
			pwszOperator = FindOperator( pwszOperator );

			// process id
			if ( StringCompare( FILTER_PID, pwszProperty, TRUE, 0 ) == 0 )
			{
				// convert the value into numeric
				DWORD dwProcessId = AsLong( pwszValue, 10 );
				strBuffer.Format( L" %s %s %s %d", 
					pwszClause, WIN32_PROCESS_PROPERTY_PROCESSID, pwszOperator, dwProcessId );

				// need to be optimized
				bOptimized = TRUE;
			}

			// session id
			else if ( StringCompare( FILTER_SESSION, pwszProperty, TRUE, 0 ) == 0 )
			{
				// convert the value into numeric
				DWORD dwSession = AsLong( pwszValue, 10 );
				strBuffer.Format( L" %s %s %s %d", 
					pwszClause, WIN32_PROCESS_PROPERTY_SESSION, pwszOperator, dwSession );

				// need to be optimized
				bOptimized = TRUE;
			}

			// image name
			else if ( StringCompare( FILTER_IMAGENAME, pwszProperty, TRUE, 0 ) == 0 )
			{
				// check if wild card is specified or not
				// if wild card is specified, this filter cannot be optimized
				if ( wcschr( pwszValue, L'*' ) == NULL )
				{
					// no conversions needed
					strBuffer.Format( L" %s %s %s '%s'", 
						pwszClause, WIN32_PROCESS_PROPERTY_IMAGENAME, pwszOperator, pwszValue );

					// need to be optimized
					bOptimized = TRUE;
				}
			}

			// status
			else if ( StringCompare( FILTER_STATUS, pwszProperty, TRUE, 0 ) == 0 )
			{
				//
				// do the value conversions
				//
				// if OPERATOR is =
				// value:	RUNNING means        OPERATOR is > and VALUE is 0
				//			NOT RESPONDING means OPERATOR = and VALUE is 0
				//
				// if OPERATOR is !=
				// value:   RUNNING means        OPERATOR is = and VALUE is 0
				//          NOT RESPONDING means OPERATOR is > and VALUE is 0
				if ( StringCompare( pwszValue, VALUE_RUNNING, TRUE, 0 ) == 0 )
				{
					if ( StringCompare( pwszOperator, MATH_EQ, TRUE, 0 ) == 0 )
						pwszOperator = MATH_GT;
					else
						pwszOperator = MATH_EQ;
				}
				else
				{
					if ( StringCompare( pwszOperator, MATH_EQ, TRUE, 0 ) == 0 )
						pwszOperator = MATH_EQ;
					else
						pwszOperator = MATH_GT;
				}

				// finally the filter condition
				strBuffer.Format( L" %s %s %s 0", 
					pwszClause, WIN32_PROCESS_PROPERTY_THREADS, pwszOperator );

				// need to be optimized
				bOptimized = TRUE;
			}

			// mem usage
			else if ( StringCompare( FILTER_MEMUSAGE, pwszProperty, TRUE, 0 ) == 0 )
			{
				// convert the value into numeric
				ULONG ulMemUsage = AsLong( pwszValue, 10 ) * 1024;
				strBuffer.Format( L" %s %s %s %lu", 
					pwszClause, WIN32_PROCESS_PROPERTY_MEMUSAGE, pwszOperator, ulMemUsage );

				// need to be optimized
				bOptimized = TRUE;
			}

			// check if property is optimizable ... if yes ... remove
			if ( bOptimized == TRUE )
			{
				// change the clause and append the current query
				m_strQuery += strBuffer;
				pwszClause = WMI_QUERY_SECOND_CLAUSE;

				// remove property and update the iterator variables
				m_bFiltersOptimized = TRUE;
				DynArrayRemove( m_arrFiltersEx, i );
				i--;
				lCount--;
			}
		}

		// final touch up to the query
		if ( m_bFiltersOptimized == TRUE )
			m_strQuery += L" )";
	}
	catch( ... )
	{
		SetLastError( E_OUTOFMEMORY );
		SaveLastError();
		return FALSE;
	}

	// return the filter validation result
	return TRUE;
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// ***************************************************************************
BOOL TimeFieldsToElapsedTime( LPCWSTR pwszTime, LPCWSTR pwszToken, ULONG& ulElapsedTime )
{
	// local variables
	ULONG ulValue = 0;
	LPCWSTR pwszField = NULL;
	__STRING_64 szTemp = NULL_STRING;
	DWORD dwNext = 0, dwLength = 0, dwCount = 0;

	// check the input
	if ( pwszTime == NULL || pwszToken == NULL )
		return FALSE;

	// start parsing the time info
	dwNext = 0;
	dwCount = 0;
	ulElapsedTime = 0;
	do
	{
		// search for the needed token
		pwszField = FindString( pwszTime, pwszToken, dwNext );
		if ( pwszField == NULL )
		{
			// check whether some more text exists in the actual string or not
			if ( (LONG) dwNext >= lstrlen( pwszTime ) )
				break;			// no more info found

			// get the last info
			lstrcpyn( szTemp, pwszTime + dwNext, SIZE_OF_ARRAY( szTemp ) );
			dwLength = lstrlen( szTemp );			 // update the length
		}
		else
		{
			// determine the length of numeric value and get the numeric value
			dwLength = lstrlen( pwszTime ) - lstrlen( pwszField ) - dwNext;

			// check the length info
			if ( dwLength > SIZE_OF_ARRAY( szTemp ) )
				return FALSE;

			// get the current info
			lstrcpyn( szTemp, pwszTime + dwNext, dwLength + 1 );	// +1 for NULL character
		}

		// update the count of fields we are getting
		dwCount++;

		// check whether this field is numeric or not
		if ( lstrlen( szTemp ) == 0 || IsNumeric( szTemp, 10, FALSE ) == FALSE )
			return FALSE;

		// from second token onwards, values greater than 59 are not allowed
		ulValue = AsLong( szTemp, 10 );
		if ( dwCount > 1 && ulValue > 59 )
			return FALSE;

		// update the elapsed time
		ulElapsedTime = ( ulElapsedTime + ulValue ) * (( dwCount < 3 ) ? 60 : 1);

		// position to the next information start
		dwNext += dwLength + lstrlen( pwszToken );
	} while ( pwszField != NULL && dwCount < 3 );

	// check the no. of time field we got .. we should have got 3 .. if not error
	if ( pwszField != NULL || dwCount != 3 )
		return FALSE;

	// so everything went right ... return success
	return TRUE;
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// ***************************************************************************
DWORD FilterCPUTime( LPCWSTR pwszProperty, LPCWSTR pwszOperator, 
				     LPCWSTR pwszValue, LPVOID pData, TARRAY arrRow )
{
	// local variables
	ULONG ulCPUTime = 0;
	ULONG ulElapsedTime = 0;
	LPCWSTR pwszCPUTime = NULL;

	// check the inputs
	if ( pwszProperty == NULL || pwszOperator == NULL || pwszValue == NULL )
		return F_FILTER_INVALID;

	// if the arrRow parameter is NULL, we need to validate the filter
	if ( arrRow == NULL )
	{
		// validate the filter value and return the result
		if ( TimeFieldsToElapsedTime( pwszValue, L":", ulElapsedTime ) == FALSE )
			return F_FILTER_INVALID;
		else
			return F_FILTER_VALID;
	}

	// get the filter value
	TimeFieldsToElapsedTime( pwszValue, L":", ulElapsedTime );

	// get the record value
	pwszCPUTime = DynArrayItemAsString( arrRow, TASK_CPUTIME );
	if ( pwszCPUTime == NULL )
		return F_RESULT_REMOVE;

	// convert the record value into elapsed time value
	TimeFieldsToElapsedTime( pwszCPUTime, L":", ulCPUTime );

	// return the result
	if ( ulCPUTime == ulElapsedTime )
		return MASK_EQ;
	else if ( ulCPUTime < ulElapsedTime )
		return MASK_LT;
	else if ( ulCPUTime > ulElapsedTime )
		return MASK_GT;

	// no way flow coming here .. still
	return F_RESULT_REMOVE;
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// ***************************************************************************
DWORD FilterMemUsage( LPCWSTR pwszProperty, LPCWSTR pwszOperator, 
				      LPCWSTR pwszValue, LPVOID pData, TARRAY arrRow )
{
	// local variables
	DWORD dwLength = 0;
	ULONGLONG ulValue = 0;
	ULONGLONG ulMemUsage = 0;
	LPCWSTR pwszMemUsage = NULL;

	// check the inputs
	if ( pwszProperty == NULL || pwszOperator == NULL || pwszValue == NULL )
		return F_FILTER_INVALID;

	// check the arrRow parameter
	// because this function will not / should not be called except for filtering
	if ( arrRow == NULL )
		return F_FILTER_INVALID;

	// check the inputs
	if ( pwszValue == NULL )
		return F_RESULT_REMOVE;

	// get the memusage value
	pwszMemUsage = DynArrayItemAsString( arrRow, TASK_MEMUSAGE );
	if ( pwszMemUsage == NULL )
		return F_RESULT_REMOVE;

	// NOTE: as there is no conversion API as of today we use manual ULONGLONG value 
	//       preparation from string value
	ulMemUsage = 0;
	dwLength = lstrlen( pwszMemUsage );
	for( DWORD dw = 0; dw < dwLength; dw++ )
	{
		// validate the digit
		if ( pwszMemUsage[ dw ] < L'0' || pwszMemUsage[ dw ] > '9' )
			return F_RESULT_REMOVE;

		// ...
		ulMemUsage = ulMemUsage * 10 + ( pwszMemUsage[ dw ] - 48 );
	}

	// get the user specified value
	ulValue = AsLong( pwszValue, 10 );

	//
	// now determine the result value
	if ( ulMemUsage == ulValue )
		return MASK_EQ;
	else if ( ulMemUsage < ulValue )
		return MASK_LT;
	else if ( ulMemUsage > ulValue )
		return MASK_GT;

	// never come across this situation ... still
	return F_RESULT_REMOVE;
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// ***************************************************************************
DWORD FilterUserName( LPCWSTR pwszProperty, LPCWSTR pwszOperator, 
				      LPCWSTR pwszValue, LPVOID pData, TARRAY arrRow )
{
	// local variables
	LONG lResult = 0;
	LONG lWildCardPos = 0;
	LPCWSTR pwszTemp = NULL;
	LPCWSTR pwszSearch = NULL;
	BOOL bOnlyUserName = FALSE;
	LPCWSTR pwszUserName = NULL;

	// check the inputs
	if ( pwszProperty == NULL || pwszOperator == NULL || pwszValue == NULL )
		return F_FILTER_INVALID;

	// if the arrRow parameter is NULL, we need to validate the filter
	if ( arrRow == NULL )
	{
		// nothing is there to validate ... just check the length 
		// and ensure that so text is present and the value should not be just '*'
		// NOTE: the common functionality will give the value after doing left and right trim
		if ( lstrlen( pwszValue ) == 0 || StringCompare( pwszValue, L"*", TRUE, 0 ) == 0 )
			return F_FILTER_INVALID;

		// the wild card character is allowed only at the end
		pwszTemp = _tcschr( pwszValue, L'*' );
		if ( pwszTemp != NULL && lstrlen( pwszTemp + 1 ) != 0 )
			return F_FILTER_INVALID;

		// filter is valid
		return F_FILTER_VALID;
	}

	// find the position of the wild card in the supplied user name
	lWildCardPos = 0;
	pwszTemp = _tcschr( pwszValue, L'*' );
	if ( pwszTemp != NULL )
	{
		// determine the wild card position
		lWildCardPos = lstrlen( pwszValue ) - lstrlen( pwszTemp );

		// special case:
		// if the pattern is just asterisk, which means that all the
		// information needs to passed thru the filter but there is no chance for 
		// this situation as specifying only '*' is being treated as invalid filter
		if ( lWildCardPos == 0 )
			return F_FILTER_INVALID;
	}

	// search for the domain and user name seperator ...
	// if domain name is not specified, comparision will be done only with the user name
	bOnlyUserName = FALSE;
	pwszTemp = _tcschr( pwszValue, L'\\' );
	if ( pwszTemp == NULL )
		bOnlyUserName = TRUE;

	// get the user name from the info
	pwszUserName = DynArrayItemAsString( arrRow, TASK_USERNAME );
	if ( pwszUserName == NULL )
		return F_RESULT_REMOVE;

	// based the search criteria .. meaning whether to search along with the domain or
	// only user name, the seach string will be decided
	pwszSearch = pwszUserName;
	if ( bOnlyUserName == TRUE )
	{
		// search for the domain and user name seperation character
		pwszTemp = _tcschr( pwszUserName, L'\\' );
		
		// position to the next character
		if ( pwszTemp != NULL )
			pwszSearch = pwszTemp + 1;
	}

	// validate the search string
	if ( pwszSearch == NULL )
		return F_RESULT_REMOVE;

	// now do the comparision
	lResult = StringCompare( pwszSearch, pwszValue, TRUE, lWildCardPos );

	//
	// now determine the result value
	if ( lResult == 0 )
		return MASK_EQ;
	else if ( lResult < 0 )
		return MASK_LT;
	else if ( lResult > 0 )
		return MASK_GT;

	// never come across this situation ... still
	return F_RESULT_REMOVE;
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// ***************************************************************************
DWORD FilterProcessId( LPCWSTR pwszProperty, LPCWSTR pwszOperator, 
				       LPCWSTR pwszValue, LPVOID pData, TARRAY arrRow )
{
	// local variables
	LONG lIndex = 0;
	LPWSTR pwsz = NULL;

	// check the inputs
	if ( pwszProperty == NULL || pwszOperator == NULL || pwszValue == NULL )
		return F_FILTER_INVALID;

	// check the arrRow parameter
	// because this function will not / should not be called except for validation
	if ( arrRow != NULL )
		return F_RESULT_REMOVE;

	// check the inputs ( only needed ones )
	if ( pwszValue == NULL )
		return F_FILTER_INVALID;

	// NOTE: do not call the IsNumeric function. do the numeric validation in this module itself
	//       also do not check for the overflow (or) underflow. 
	//       just check whether input is numeric or not
	wcstoul( pwszValue, &pwsz, 10 );
	if ( lstrlen( pwszValue ) == 0 || (pwsz != NULL && lstrlen( pwsz ) > 0 ))
		return F_FILTER_INVALID;

	// check if overflow (or) undeflow occured
	if ( errno == ERANGE )
	{
		SetReason( ERROR_NO_PROCESSES );
		return F_FILTER_INVALID;
	}

	// return
	return F_FILTER_VALID;
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// ***************************************************************************
BOOL ValidatePID( LPCWSTR pwszOption, LPCWSTR pwszValue, LPVOID pData )
{
	// local variable
	LONG lIndex = 0;
	LPWSTR pwsz = NULL;
	TARRAY arrTasks = NULL;

	// check the input values
	if ( pwszOption == NULL || pwszValue == NULL || pData == NULL )
	{
		SetLastError( E_OUTOFMEMORY );
		SaveLastError();
		return FALSE;
	}

	// NOTE: do not call the IsNumeric function. do the numeric validation in this module itself
	//       also do not check for the overflow (or) underflow. 
	//       just check whether input is numeric or not
	wcstoul( pwszValue, &pwsz, 10 );
	if ( lstrlen( pwszValue ) == 0 || (pwsz != NULL && lstrlen( pwsz ) > 0 ))
	{
		SetReason( ERROR_STRING_FOR_PID );
		return FALSE;
	}

	// check whether current value already exists in the list or not
	arrTasks = (TARRAY) pData;				// get the array reference
	lIndex = DynArrayFindString( arrTasks, pwszValue, TRUE, 0 );
	if ( lIndex == -1 && DynArrayAppendString( arrTasks, pwszValue, 0 ) == -1 )
	{
		SetLastError( E_OUTOFMEMORY );
		SaveLastError();
		return FALSE;
	}

	// return the result
	return TRUE;
}

// ***************************************************************************
// Routine Description:
//		This function fetches usage information from resource file and shows it
//		  
// Arguments:
//		NONE
//  
// Return Value:
//		NONE
// ***************************************************************************
VOID CTaskKill::Usage()
{
	// local variables
	DWORD dw = 0;

	// start displaying the usage
	for( dw = ID_HELP_START; dw <= ID_HELP_END; dw++ )
		ShowMessage( stdout, GetResString( dw ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cmdline\kill\wmi.cpp ===
// *********************************************************************************
// 
//  Copyright (c) Microsoft Corporation
//  
//  Module Name:
//  
//		WMI.cpp
//  
//  Abstract:
//  
// 		Common functionlity for dealing with WMI
//  
//  Author:
//  
// 	    Sunil G.V.N. Murali (murali.sunil@wipro.com) 22-Dec-2000
//  
//  Revision History:
//  
// 	    Sunil G.V.N. Murali (murali.sunil@wipro.com) 22-Dec-2000 : Created It.
//  
// *********************************************************************************

#include "pch.h"
#include "wmi.h"
#include "resource.h"

//
// messages
//
#define INPUT_PASSWORD		GetResString( IDS_STR_INPUT_PASSWORD )

// error constants
#define E_SERVER_NOTFOUND			0x800706ba

//
// private function prototype(s)
//
BOOL IsValidUserEx( LPCWSTR pwszUser );
HRESULT GetSecurityArguments( IUnknown* pInterface, 
							  DWORD& dwAuthorization, DWORD& dwAuthentication );
HRESULT SetInterfaceSecurity( IUnknown* pInterface, 
							  LPCWSTR pwszServer, LPCWSTR pwszUser, 
							  LPCWSTR pwszPassword, COAUTHIDENTITY** ppAuthIdentity );
HRESULT WINAPI SetProxyBlanket( IUnknown* pInterface,
							    DWORD dwAuthnSvc, DWORD dwAuthzSvc,
								LPWSTR pwszPrincipal, DWORD dwAuthLevel, DWORD dwImpLevel,
								RPC_AUTH_IDENTITY_HANDLE pAuthInfo, DWORD dwCapabilities );
HRESULT WINAPI WbemAllocAuthIdentity( LPCWSTR pwszUser, LPCWSTR pwszPassword, 
									  LPCWSTR pwszDomain, COAUTHIDENTITY** ppAuthIdent );
HRESULT RegQueryValueWMI( IWbemServices* pWbemServices, 
						  LPCWSTR pwszMethod, DWORD dwHDefKey, 
						  LPCWSTR pwszSubKeyName, LPCWSTR pwszValueName, _variant_t& varValue );

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
BOOL IsValidUserEx( LPCWSTR pwszUser )
{
	// local variables
	CHString strUser;
	LONG lPos = 0;

	try
	{
		// get user into local memory
		strUser = pwszUser;

		// user name should not be just '\'
		if ( strUser.CompareNoCase( L"\\" ) == 0 )
			return FALSE;

		// user name should not contain invalid characters
		if ( strUser.FindOneOf( L"/[]:|<>+=;,?*" ) != -1 )
			return FALSE;

		// SPECIAL CHECK
		// check for multiple '\' characters in the user name
		lPos = strUser.Find( L'\\' );
		if ( lPos != -1 )
		{
			// '\' character exists in the user name
			// strip off the user info upto first '\' character
			// check for one more '\' in the remaining string
			// if it exists, invalid user
			strUser = strUser.Mid( lPos + 1 );
			lPos = strUser.Find( L'\\' );
			if ( lPos != -1 )
				return FALSE;
		}
	}
	catch( ... )
	{
		SetLastError( E_OUTOFMEMORY );
		return FALSE;
	}

	// user name is valid
	return TRUE;
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
BOOL IsValidServerEx( LPCWSTR pwszServer, BOOL& bLocalSystem )
{
	// local variables
	CHString strTemp;

	// kick-off
	bLocalSystem = FALSE;

	// get a local copy
	strTemp = pwszServer;

	// remove the forward slashes (UNC) if exist in the begining of the server name
	if ( IsUNCFormat( strTemp ) == TRUE )
	{
		strTemp = strTemp.Mid( 2 );
		if ( strTemp.GetLength() == 0 )
			return FALSE;
	}

	// now check if any '\' character appears in the server name. If so error
	if ( strTemp.Find( L'\\' ) != -1 )
		return FALSE;

	// now check if server name is '.' only which represent local system in WMI
	// else determine whether this is a local system or not
	bLocalSystem = TRUE;
	if ( strTemp.CompareNoCase( L"." ) != 0 )
	{
		// validate the server
		if ( IsValidServer( strTemp ) == FALSE )
			return FALSE;

		// check whether this is a local system or not
		bLocalSystem = IsLocalSystem( strTemp );
	}

	// inform that server name is valid
	return TRUE;
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
BOOL InitializeCom( IWbemLocator** ppLocator )
{
	// local variables
	HRESULT hr;
	BOOL bResult = FALSE;

	try
	{
		// assume that connection to WMI namespace is failed
		bResult = FALSE;

		// initialize the COM library
		SAFE_EXECUTE( CoInitializeEx( NULL, COINIT_APARTMENTTHREADED ) );

		// initialize the security
		SAFE_EXECUTE( CoInitializeSecurity( NULL, -1, NULL, NULL,
			RPC_C_AUTHN_LEVEL_NONE, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE, 0 ) );

		// create the locator and get the pointer to the interface of IWbemLocator
		SAFE_RELEASE( *ppLocator );			// safe side
		SAFE_EXECUTE( CoCreateInstance( CLSID_WbemLocator, NULL, CLSCTX_INPROC_SERVER, 
			IID_IWbemLocator, ( LPVOID* ) ppLocator ) );

		// initialization successful
		bResult = TRUE;
	}
	catch( _com_error& e )
	{
		// save the WMI error
		WMISaveError( e );
	}

	// return the result;
	return bResult;
}

// ***************************************************************************
// Routine Description:
//		
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
BOOL ConnectWmi( IWbemLocator* pLocator, 
				 IWbemServices** ppServices, 
				 LPCWSTR pwszServer, LPCWSTR pwszUser, LPCWSTR pwszPassword, 
				 COAUTHIDENTITY** ppAuthIdentity, BOOL bCheckWithNullPwd, 
				 LPCWSTR pwszNamespace, HRESULT* phr, BOOL* pbLocalSystem )
{
	// local variables
	HRESULT hr;
	BOOL bResult = FALSE;
	BOOL bLocalSystem = FALSE;
	_bstr_t bstrServer;
	_bstr_t bstrNamespace;
	_bstr_t bstrUser, bstrPassword;

	// kick-off
	if ( pbLocalSystem != NULL )
		*pbLocalSystem = FALSE;

	// ...
	if ( phr != NULL )
		*phr = WBEM_S_NO_ERROR;

	try
	{
		// clear the error
		SetLastError( WBEM_S_NO_ERROR );

		// assume that connection to WMI namespace is failed
		bResult = FALSE;

		// check whether locator object exists or not
		// if not exists, return
		if ( pLocator == NULL )
		{
			if ( phr != NULL )
				*phr = WBEM_E_INVALID_PARAMETER;

			// return failure
			return FALSE;
		}

		// validate the server name
		if ( IsValidServerEx( pwszServer, bLocalSystem ) == FALSE )
			_com_issue_error( ERROR_BAD_NETPATH );

		// validate the user name
		if ( IsValidUserEx( pwszUser ) == FALSE )
			_com_issue_error( ERROR_NO_SUCH_USER );

		// prepare namespace
		bstrNamespace = pwszNamespace;				// name space
		if ( pwszServer != NULL && bLocalSystem == FALSE )
		{
			// get the server name
			bstrServer = pwszServer;

			// prepare the namespace
			// NOTE: check for the UNC naming format of the server and do
			if ( IsUNCFormat( pwszServer ) == TRUE )
				bstrNamespace = bstrServer + L"\\" + pwszNamespace;
			else
				bstrNamespace = L"\\\\" + bstrServer + L"\\" + pwszNamespace;

			// user credentials
			if ( pwszUser != NULL && lstrlen( pwszUser ) != 0 )
			{
				// copy the user name
				bstrUser = pwszUser;

				// if password is empty string and if we need to check with
				// null password, then do not set the password and try
				bstrPassword = pwszPassword;
				if ( bCheckWithNullPwd == TRUE && bstrPassword.length() == 0 )
					bstrPassword = (LPWSTR) NULL;
			}
		}
		else if ( bLocalSystem == TRUE && pwszUser != NULL && lstrlen( pwszUser ) != 0 )
		{
			// got the credentials for the local system
			if ( phr != NULL )
				*phr = WBEM_E_LOCAL_CREDENTIALS;
		}

		// release the existing services object ( to be in safer side )
		SAFE_RELEASE( *ppServices );

		// connect to the remote system's WMI
		// there is a twist here ... 
		// do not trap the ConnectServer function failure into exception
		// instead handle that action manually
		// by default try the ConnectServer function as the information which we have
		// in our hands at this point. If the ConnectServer is failed, 
		// check whether password variable has any contents are not ... if no contents
		// check with "" (empty) password ... this might pass in this situation ..
		// if this call is also failed ... nothing is there that we can do ... throw the exception
		hr = pLocator->ConnectServer( bstrNamespace, 
			bstrUser, bstrPassword, 0L, 0L, NULL, NULL, ppServices );
		if ( FAILED( hr ) )
		{
			//
			// special case ...

			// check whether password exists or not
			// NOTE: do not check for 'WBEM_E_ACCESS_DENIED'
			//       this error code says that user with the current credentials is not
			//       having access permisions to the 'namespace'
			if ( hr == E_ACCESSDENIED )
			{
				// check if we tried to connect to the system using null password
				// if so, then try connecting to the remote system with empty string
				if ( bCheckWithNullPwd == TRUE &&
					 bstrUser.length() != 0 && bstrPassword.length() == 0 )
				{
					// now invoke with ...
					hr = pLocator->ConnectServer( bstrNamespace, 
						bstrUser, _bstr_t( L"" ), 0L, 0L, NULL, NULL, ppServices );
				}
			}
			else if ( hr == WBEM_E_LOCAL_CREDENTIALS )
			{
				// credentials were passed to the local system. 
				// So ignore the credentials and try to reconnect
				bLocalSystem = TRUE;
				bstrUser = (LPWSTR) NULL;
				bstrPassword = (LPWSTR) NULL;
				bstrNamespace = pwszNamespace;				// name space
				hr = pLocator->ConnectServer( bstrNamespace, 
					NULL, NULL, 0L, 0L, NULL, NULL, ppServices );

				// check the result
				if ( SUCCEEDED( hr ) && phr != NULL )
				{
					// set the last error
					*phr = WBEM_E_LOCAL_CREDENTIALS;
				}
			}

			// now check the result again .. if failed .. ummmm..
			if ( FAILED( hr ) )
				_com_issue_error( hr );
			else
				bstrPassword = L"";
		}

		// set the security at the interface level also
		SAFE_EXECUTE( SetInterfaceSecurity( *ppServices, 
			pwszServer, bstrUser, bstrPassword, ppAuthIdentity ) );

		// connection to WMI is successful
		bResult = TRUE;
	}
	catch( _com_error& e )
	{
		// save the error
		WMISaveError( e );

		// save the hr value if needed by the caller
		if ( phr != NULL )
			*phr = e.Error();
	}

	// ...
	if ( pbLocalSystem != NULL )
		*pbLocalSystem = bLocalSystem;

	// return the result
	return bResult;
}

// ***************************************************************************
// Routine Description:
//		
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
BOOL ConnectWmiEx( IWbemLocator* pLocator, 
				   IWbemServices** ppServices, 
				   LPCWSTR pwszServer, CHString& strUserName, CHString& strPassword, 
				   COAUTHIDENTITY** ppAuthIdentity, 
				   BOOL bNeedPassword, LPCWSTR pwszNamespace, BOOL* pbLocalSystem )
{
	// local variables
	HRESULT hr;
	DWORD dwSize = 0;
	BOOL bResult = FALSE;
	LPWSTR pwszPassword = NULL;
	CHString strBuffer = NULL_STRING;

	// clear the error .. if any
	SetLastError( WBEM_S_NO_ERROR );

	// sometime users want the utility to prompt for the password
	// check what user wants the utility to do
	if ( bNeedPassword == TRUE && strPassword.Compare( L"*" ) == 0 )
	{
		// user wants the utility to prompt for the password
		// so skip this part and let the flow directly jump the password acceptance part
	}
	else
	{
		// try to establish connection to the remote system with the credentials supplied
		if ( strUserName.GetLength() == 0 )
		{
			// user name is empty
			// so, it is obvious that password will also be empty
			// even if password is specified, we have to ignore that
			bResult = ConnectWmi( pLocator, ppServices, 
				pwszServer, NULL, NULL, ppAuthIdentity, FALSE, pwszNamespace, &hr, pbLocalSystem );
		}
		else
		{
			// credentials were supplied
			// but password might not be specified ... so check and act accordingly
			LPCWSTR pwszTemp = NULL;
			BOOL bCheckWithNull = TRUE;
			if ( bNeedPassword == FALSE )
			{
				pwszTemp = strPassword;
				bCheckWithNull = FALSE;
			}

			// ...
			bResult = ConnectWmi( pLocator, ppServices, pwszServer,
				strUserName, pwszTemp, ppAuthIdentity, bCheckWithNull, pwszNamespace, &hr, pbLocalSystem );
		}

		// check the result ... if successful in establishing connection ... return
		if ( bResult == TRUE )
		{
			SetLastError( hr );			// set the error code
			return TRUE;
		}

		// now check the kind of error occurred
		switch( hr )
		{
		case E_ACCESSDENIED:
			break;

		case WBEM_E_ACCESS_DENIED:
		default:
			// NOTE: do not check for 'WBEM_E_ACCESS_DENIED'
			//       this error code says that user with the current credentials is not
			//       having access permisions to the 'namespace'
			WMISaveError( hr );
			return FALSE;		// no use of accepting the password .. return failure
			break;
		}

		// if failed in establishing connection to the remote terminal
		// even if the password is specifed, then there is nothing to do ... simply return failure
		if ( bNeedPassword == FALSE )
			return FALSE;
	}

	// check whether user name is specified or not
	// if not, get the local system's current user name under whose credentials, the process
	// is running
	if ( strUserName.GetLength() == 0 )
	{
		// sub-local variables
		LPWSTR pwszUserName = NULL;

		try
		{
			// get the required buffer
			pwszUserName = strUserName.GetBufferSetLength( MAX_STRING_LENGTH );
		}
		catch( ... )
		{
			SetLastError( E_OUTOFMEMORY );
			SaveLastError();
			return FALSE;
		}

		// get the user name
		DWORD dwUserLength = MAX_STRING_LENGTH;
		if ( GetUserNameEx( NameSamCompatible, pwszUserName, &dwUserLength ) == FALSE )
		{
			// error occured while trying to get the current user info
			SaveLastError();
			return FALSE;
		}

		// release the extra buffer allocated
		strUserName.ReleaseBuffer();
	}

	try
	{
		// get the required buffer
		pwszPassword = strPassword.GetBufferSetLength( MAX_STRING_LENGTH );
	}
	catch( ... )
	{
		SetLastError( E_OUTOFMEMORY );
		SaveLastError();
		return FALSE;
	}

	// accept the password from the user
	strBuffer.Format( INPUT_PASSWORD, strUserName );
	WriteConsoleW( GetStdHandle( STD_ERROR_HANDLE ), 
		strBuffer, strBuffer.GetLength(), &dwSize, NULL );
	GetPassword( pwszPassword, MAX_PASSWORD_LENGTH );

	// release the buffer allocated for password
	strPassword.ReleaseBuffer();

	// now again try to establish the connection using the currently
	// supplied credentials
	bResult = ConnectWmi( pLocator, ppServices, pwszServer,
		strUserName, strPassword, ppAuthIdentity, FALSE, pwszNamespace, &hr, pbLocalSystem );

	// set the last error 
	SetLastError( hr );

	// return the failure
	return bResult;
}

// ***************************************************************************
// Routine Description:
//		
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
HRESULT GetSecurityArguments( IUnknown* pInterface, 
							  DWORD& dwAuthorization, DWORD& dwAuthentication )
{
	// local variables
	HRESULT hr;
	DWORD dwAuthnSvc = 0, dwAuthzSvc = 0;
	IClientSecurity* pClientSecurity = NULL;

	// try to get the client security services values if possible
	hr = pInterface->QueryInterface( IID_IClientSecurity, (void**) &pClientSecurity );
	if ( SUCCEEDED( hr ) )
	{
		// got the client security interface
		// now try to get the security services values
		hr = pClientSecurity->QueryBlanket( pInterface, 
			&dwAuthnSvc, &dwAuthzSvc, NULL, NULL, NULL, NULL, NULL );
		if ( SUCCEEDED( hr ) )
		{
			// we've got the values from the interface
			dwAuthentication = dwAuthnSvc;
			dwAuthorization = dwAuthzSvc;
		}

		// release the client security interface
		SAFE_RELEASE( pClientSecurity );
	}

	// return always success
	return S_OK;
}

// ***************************************************************************
// Routine Description:
//		
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
HRESULT SetInterfaceSecurity( IUnknown* pInterface, 
							  LPCWSTR pwszServer, LPCWSTR pwszUser, 
							  LPCWSTR pwszPassword, COAUTHIDENTITY** ppAuthIdentity )
{
	// local variables
	HRESULT hr;
	CHString strUser;
	CHString strDomain;
	LPCWSTR pwszUserArg = NULL;
	LPCWSTR pwszDomainArg = NULL;
	DWORD dwAuthorization = RPC_C_AUTHZ_NONE;
	DWORD dwAuthentication = RPC_C_AUTHN_WINNT;

	// check the interface
	if ( pInterface == NULL )
		return WBEM_E_INVALID_PARAMETER;

	// check the authentity strcuture ... if authentity structure is already ready
	// simply invoke the 2nd version of SetInterfaceSecurity
	if ( *ppAuthIdentity != NULL )
		return SetInterfaceSecurity( pInterface, *ppAuthIdentity );

	// get the current security argument value
	// GetSecurityArguments( pInterface, dwAuthorization, dwAuthentication );

    // If we are doing trivial case, just pass in a null authenication structure 
    // for which the current logged in user's credentials will be considered
	if ( pwszUser == NULL && pwszPassword == NULL )
	{
		// set the security
		hr = SetProxyBlanket( pInterface, dwAuthentication, dwAuthorization, 
			NULL, RPC_C_AUTHN_LEVEL_DEFAULT, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE );

		// return the result
		return hr;
	}

	// parse and find out if the user name contains the domain name
	// if contains, extract the domain value from it
	LONG lPos = -1;
	strDomain = L"";
	strUser = pwszUser;
	if ( ( lPos = strUser.Find( L'\\' ) ) != -1 )
	{
		// user name contains domain name ... domain\user format
		strDomain = strUser.Left( lPos );
		strUser = strUser.Mid( lPos + 1 );
	}

	// get the domain info if it exists only
	if ( strDomain.GetLength() != 0 )
		pwszDomainArg = strDomain;

	// get the user info if it exists only
	if ( strUser.GetLength() != 0 )
		pwszUserArg = strUser;

	// check if authenication info is available or not ...
	// initialize the security authenication information ... UNICODE VERSION STRUCTURE
	if ( ppAuthIdentity == NULL )
        return WBEM_E_INVALID_PARAMETER;
	else if ( *ppAuthIdentity == NULL )
	{
		hr = WbemAllocAuthIdentity( pwszUserArg, pwszPassword, pwszDomainArg, ppAuthIdentity );
		if ( hr != S_OK )
			return hr;
	}

	// set the security information to the interface
	hr = SetProxyBlanket( pInterface, dwAuthentication, dwAuthorization, NULL,
		RPC_C_AUTHN_LEVEL_DEFAULT, RPC_C_IMP_LEVEL_IMPERSONATE, *ppAuthIdentity, EOAC_NONE );

	// return the result
	return hr;
}

// ***************************************************************************
// Routine Description:
//		
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
HRESULT SetInterfaceSecurity( IUnknown* pInterface, COAUTHIDENTITY* pAuthIdentity )
{
	// local variables
	HRESULT hr;
	LPWSTR pwszDomain = NULL;
	DWORD dwAuthorization = RPC_C_AUTHZ_NONE;
	DWORD dwAuthentication = RPC_C_AUTHN_WINNT;

	// check the interface
	if ( pInterface == NULL )
		return WBEM_E_INVALID_PARAMETER;

	// get the current security argument value
	// GetSecurityArguments( pInterface, dwAuthorization, dwAuthentication );

	// set the security information to the interface
	hr = SetProxyBlanket( pInterface, dwAuthentication, dwAuthorization, NULL,
		RPC_C_AUTHN_LEVEL_DEFAULT, RPC_C_IMP_LEVEL_IMPERSONATE, pAuthIdentity, EOAC_NONE );

	// return the result
	return hr;
}

// ***************************************************************************
// Routine Description:
//		
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
HRESULT WINAPI SetProxyBlanket( IUnknown* pInterface,
							    DWORD dwAuthnSvc, DWORD dwAuthzSvc,
								LPWSTR pwszPrincipal, DWORD dwAuthLevel, DWORD dwImpLevel,
								RPC_AUTH_IDENTITY_HANDLE pAuthInfo, DWORD dwCapabilities )
{
	// local variables
	HRESULT hr;
    IUnknown * pUnknown = NULL;
    IClientSecurity * pClientSecurity = NULL;

	// get the IUnknown interface ... to check whether this is a valid interface or not
    hr = pInterface->QueryInterface( IID_IUnknown, (void **) &pUnknown );
    if ( hr != S_OK )
        return hr;

	// now get the client security interface
    hr = pInterface->QueryInterface( IID_IClientSecurity, (void **) &pClientSecurity );
    if ( hr != S_OK )
    {
        SAFE_RELEASE( pUnknown );
        return hr;
    }

    //
    // Can't set pAuthInfo if cloaking requested, as cloaking implies
    // that the current proxy identity in the impersonated thread (rather
    // than the credentials supplied explicitly by the RPC_AUTH_IDENTITY_HANDLE)
    // is to be used.
    // See MSDN info on CoSetProxyBlanket for more details.
    //
    if ( dwCapabilities & (EOAC_STATIC_CLOAKING | EOAC_DYNAMIC_CLOAKING) )
        pAuthInfo = NULL;

	// now set the security
    hr = pClientSecurity->SetBlanket( pInterface, dwAuthnSvc, dwAuthzSvc, pwszPrincipal,
		dwAuthLevel, dwImpLevel, pAuthInfo, dwCapabilities );

	// release the security interface
	SAFE_RELEASE( pClientSecurity );

    // we should check the auth identity structure. if exists .. set for IUnknown also
    if ( pAuthInfo != NULL )
    {
        hr = pUnknown->QueryInterface( IID_IClientSecurity, (void **) &pClientSecurity );
        if ( hr == S_OK )
        {
			// set security authentication
            hr = pClientSecurity->SetBlanket( 
				pUnknown, dwAuthnSvc, dwAuthzSvc, pwszPrincipal, 
				dwAuthLevel, dwImpLevel, pAuthInfo, dwCapabilities );

			// release
            SAFE_RELEASE( pClientSecurity );
        }
        else if ( hr == E_NOINTERFACE )
            hr = S_OK;		// ignore no interface errors
    }

	// release the IUnknown
	SAFE_RELEASE( pUnknown );

	// return the result
    return hr;
}

// ***************************************************************************
// Routine Description:
//		
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
HRESULT WINAPI WbemAllocAuthIdentity( LPCWSTR pwszUser, LPCWSTR pwszPassword, 
									  LPCWSTR pwszDomain, COAUTHIDENTITY** ppAuthIdent )
{
	// local variables
    COAUTHIDENTITY* pAuthIdent = NULL;

	// validate the input parameter
    if ( ppAuthIdent == NULL )
        return WBEM_E_INVALID_PARAMETER;

    // allocation thru COM API
    pAuthIdent = ( COAUTHIDENTITY* ) CoTaskMemAlloc( sizeof( COAUTHIDENTITY ) );
    if ( NULL == pAuthIdent )
        return WBEM_E_OUT_OF_MEMORY;

	// init with 0's
    ZeroMemory( ( void* ) pAuthIdent, sizeof( COAUTHIDENTITY ) );

	//
	// Allocate needed memory and copy in data.  Cleanup if anything goes wrong

	// user
    if ( pwszUser != NULL )
    {
		// allocate memory for user
		LONG lLength = wcslen( pwszUser ); 
        pAuthIdent->User = ( LPWSTR ) CoTaskMemAlloc( (lLength + 1) * sizeof( WCHAR ) );
		if ( pAuthIdent->User == NULL )
		{
            WbemFreeAuthIdentity( &pAuthIdent );
            return WBEM_E_OUT_OF_MEMORY;
        }

		// set the length and do copy contents
        pAuthIdent->UserLength = lLength;
        wcscpy( pAuthIdent->User, pwszUser );
    }

	// domain
    if ( pwszDomain != NULL )
    {
		// allocate memory for domain
		LONG lLength = wcslen( pwszDomain ); 
        pAuthIdent->Domain = ( LPWSTR ) CoTaskMemAlloc( (lLength + 1) * sizeof( WCHAR ) );
        if ( pAuthIdent->Domain == NULL )
        {
            WbemFreeAuthIdentity( &pAuthIdent );
            return WBEM_E_OUT_OF_MEMORY;
        }

		// set the length and do copy contents
        pAuthIdent->DomainLength = lLength;
        wcscpy( pAuthIdent->Domain, pwszDomain );
    }

	// passsord
    if ( pwszPassword != NULL )
    {
		// allocate memory for passsord
		LONG lLength = wcslen( pwszPassword ); 
        pAuthIdent->Password = ( LPWSTR ) CoTaskMemAlloc( (lLength + 1) * sizeof( WCHAR ) );
        if ( pAuthIdent->Password == NULL )
        {
            WbemFreeAuthIdentity( &pAuthIdent );
            return WBEM_E_OUT_OF_MEMORY;
        }

		// set the length and do copy contents
        pAuthIdent->PasswordLength = lLength;
        wcscpy( pAuthIdent->Password, pwszPassword );
    }

	// type of the structure
    pAuthIdent->Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;

    // final set the address to out parameter
	*ppAuthIdent = pAuthIdent;

	// return result
    return S_OK;
}

// ***************************************************************************
// Routine Description:
//		
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
VOID WINAPI WbemFreeAuthIdentity( COAUTHIDENTITY** ppAuthIdentity )
{
    // make sure we have a pointer, then walk the structure members and  cleanup.
    if ( *ppAuthIdentity != NULL )
    {
		// free the memory allocated for user
        if ( (*ppAuthIdentity)->User != NULL )
            CoTaskMemFree( (*ppAuthIdentity)->User );

		// free the memory allocated for password
        if ( (*ppAuthIdentity)->Password != NULL )
            CoTaskMemFree( (*ppAuthIdentity)->Password );

		// free the memory allocated for domain
        if ( (*ppAuthIdentity)->Domain != NULL )
            CoTaskMemFree( (*ppAuthIdentity)->Domain );

        // final the structure
		CoTaskMemFree( *ppAuthIdentity );
    }

	// set to NULL
	*ppAuthIdentity = NULL;
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
VOID WMISaveError( HRESULT hrError )
{
	// local variables
	HRESULT hr;
	CHString strBuffer = NULL_STRING;
	IWbemStatusCodeText* pWbemStatus = NULL;

	// if the error is win32 based, choose FormatMessage to get the message
	switch( hrError )
	{
	case E_ACCESSDENIED:			// Message: "Access Denied"
	case ERROR_NO_SUCH_USER:		// Message: "The specified user does not exist."
		{
			// change the error message to "Logon failure: unknown user name or bad password." 
			if ( hrError == E_ACCESSDENIED )
				hrError = ERROR_LOGON_FAILURE;

			// ...
			SetLastError( hrError );
			SaveLastError();
			return;
		}
	}

	try
	{
		// get the pointer to buffer
		LPWSTR pwszBuffer = NULL;
		pwszBuffer = strBuffer.GetBufferSetLength( MAX_STRING_LENGTH );

		// get the wbem specific status code text
		hr = CoCreateInstance( CLSID_WbemStatusCodeText, 
			NULL, CLSCTX_INPROC_SERVER, IID_IWbemStatusCodeText, (LPVOID*) &pWbemStatus );

		// check whether we got the interface or not
		if ( SUCCEEDED( hr ) )
		{
			// get the error message
			BSTR bstr = NULL;
			hr = pWbemStatus->GetErrorCodeText( hrError, 0, 0, &bstr );
			if ( SUCCEEDED( hr ) )
			{
				// get the error message in proper format
				GetCompatibleStringFromUnicode( bstr, pwszBuffer, MAX_STRING_LENGTH );

				//
				// supress all the new-line characters and add '.' at the end ( if not exists )
				LPWSTR pwszTemp = NULL;
				pwszTemp = wcstok( pwszBuffer, L"\r\n" );
				if ( *( pwszTemp + lstrlenW( pwszTemp ) - 1 ) != L'.' )
					lstrcatW( pwszTemp, L"." );

				// free the BSTR
				SysFreeString( bstr );
				bstr = NULL;

				// now release status code interface
				SAFE_RELEASE( pWbemStatus );
			}
			else
			{
				// failed to get the error message ... get the com specific error message
				_com_issue_error( hrError );
			}
		}
		else
		{
			// failed to get the error message ... get the com specific error message
			_com_issue_error( hrError );
		}

		// release the buffer
		strBuffer.ReleaseBuffer();
	}
	catch( _com_error& e )
	{
		try
		{
			// get the error message
			strBuffer.ReleaseBuffer();
			if ( e.ErrorMessage() != NULL )
				strBuffer = e.ErrorMessage();
		}
		catch( ... )
		{
			SetLastError( E_OUTOFMEMORY );
			SaveLastError();
		}
	}
	catch( ... )
	{
		SetLastError( E_OUTOFMEMORY );
		SaveLastError();
		return;
	}

	// set the reason
	strBuffer += L"\n";
	SetReason( strBuffer );
}

// ***************************************************************************
// Routine Description:
//		Gets the value of the property from the WMI class object
//		  
// Arguments:
//		[ in ] pWmiObject		: pointer to the WBEM class object
//		[ in ] szProperty		: property name
//		[ out ] varValue		: value of the property
//  
// Return Value:
//		HRESULT - result of the operation
// 
// ***************************************************************************
HRESULT PropertyGet( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty, VARIANT* pvarValue )
{
	// local variables
	HRESULT hr;

	// check with object and property passed to the function are valid or not
	// if not, return failure
	if ( pWmiObject == NULL || pwszProperty == NULL || pvarValue == NULL )
		return WBEM_E_INVALID_PARAMETER;

	try
	{
		// initialize the variant and then get the value of the specified property
		hr = pWmiObject->Get( _bstr_t( pwszProperty ), 0, pvarValue, NULL, NULL );
		if ( FAILED( hr ) )
		{
			// clear the variant variable
			VariantClear( pvarValue );

			// failed to get the value for the property
			return hr;
		}
	}
	catch( _com_error& e )
	{
		WMISaveError( e );
		return e.Error();
	}

	// inform success
	return S_OK;
}

// ***************************************************************************
// Routine Description:
//		Gets the value of the property from the WMI class object
//		  
// Arguments:
//		[ in ] pWmiObject		: pointer to the WBEM class object
//		[ in ] szProperty		: property name
//		[ out ] varValue		: value of the property
//  
// Return Value:
//		HRESULT - result of the operation
// 
// ***************************************************************************
HRESULT PropertyGet( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty, _variant_t& varValue )
{
	// local variables
	HRESULT hr;
	VARIANT vtValue;

	// check with object and property passed to the function are valid or not
	// if not, return failure
	if ( pWmiObject == NULL || pwszProperty == NULL )
		return WBEM_E_INVALID_PARAMETER;

	try
	{
		// initialize the variant and then get the value of the specified property
		VariantInit( &vtValue );
		hr = pWmiObject->Get( _bstr_t( pwszProperty ), 0, &vtValue, NULL, NULL );
		if ( FAILED( hr ) )
		{
			// clear the variant variable
			VariantClear( &vtValue );

			// failed to get the value for the property
			return hr;
		}

		// set the value
		varValue = vtValue;

		// clear the variant variable
		VariantClear( &vtValue );
	}
	catch( _com_error& e )
	{
		WMISaveError( e );
		return e.Error();
	}

	// inform success
	return S_OK;
}

// ***************************************************************************
// Routine Description:
//		Gets the value of the property from the WMI class object in string format
//		  
// Arguments:
//  
// Return Value:
//		TRUE - if operation is successfull, otherwise FALSE
// 
// ***************************************************************************
BOOL PropertyGet( IWbemClassObject* pWmiObject, 
				  LPCWSTR pwszProperty, CHString& strValue, LPCWSTR pwszDefault )
{
	// local variables
	HRESULT hr;
	_variant_t var;

	// first copy the default value
	strValue = pwszDefault;

	// check with object and property passed to the function are valid or not
	// if not, return failure
	if ( pWmiObject == NULL || pwszProperty == NULL )
		return FALSE;

	// get the property value
	hr = PropertyGet( pWmiObject, pwszProperty, var );
	if ( FAILED( hr ) )
		return FALSE;

	try
	{
		// get the value
		if ( var.vt != VT_NULL && var.vt != VT_EMPTY )
			strValue = (LPCWSTR) _bstr_t( var );
	}
	catch( ... )
	{
		SetLastError( E_OUTOFMEMORY );
		SaveLastError();
		return FALSE;
	}

	// return
	return TRUE;
}

// ***************************************************************************
// Routine Description:
//		Gets the value of the property from the WMI class object in string format
//		  
// Arguments:
//		[ in ] pWmiObject		: pointer to the WBEM class object
//		[ in ] pwszProperty		: property name
//		[ out ] pdwValue		: value of the property
//		[ in ] dwDefault		: default in case failed in getting property value
//  
// Return Value:
//		TRUE - if operation is successfull, otherwise FALSE
// 
// ***************************************************************************
BOOL PropertyGet( IWbemClassObject* pWmiObject, 
				  LPCWSTR pwszProperty,  DWORD& dwValue, DWORD dwDefault )
{
	// local variables
	HRESULT hr;
	_variant_t var;

	// first set the defaul value
	dwValue = dwDefault;

	// check with object and property passed to the function are valid or not
	// if not, return failure
	if ( pWmiObject == NULL || pwszProperty == NULL )
		return FALSE;

	// get the value of the property
	hr = PropertyGet( pWmiObject, pwszProperty, var );
	if ( FAILED( hr ) )
		return FALSE;

	// get the process id from the variant
	if ( var.vt != VT_NULL && var.vt != VT_EMPTY )
		dwValue = (LONG) var;

	// return
	return TRUE;
}

// ***************************************************************************
// Routine Description:
//		Gets the value of the property from the WMI class object in string format
//		  
// Arguments:
//  
// Return Value:
//		TRUE - if operation is successfull, otherwise FALSE
// 
// ***************************************************************************
BOOL PropertyGet( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty,  ULONGLONG& ullValue )
{
	// local variables
	CHString str;

	// first set the default value
	ullValue = 1;

	// check with object and property passed to the function are valid or not
	// if not, return failure
	if ( pWmiObject == NULL || pwszProperty == NULL )
		return FALSE;

	// get the value of the property
	if ( PropertyGet( pWmiObject, pwszProperty, str, _T( "0" ) ) == FALSE )
		return FALSE;

	// get the 64-bit value
	ullValue = _wtoi64( str );

	// return
	return TRUE;
}

// ***************************************************************************
// Routine Description:
//		Gets the value of the property from the WMI class object in string format
//		  
// Arguments:
//  
// Return Value:
//		TRUE - if operation is successfull, otherwise FALSE
// 
// ***************************************************************************
BOOL PropertyGet( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty,  WBEMTime& wbemtime )
{
	// local variables
	CHString str;

	// Clear method sets the time in the WBEMTime object to an invalid time.
	wbemtime.Clear();

	// check with object and property passed to the function are valid or not
	// if not, return failure
	if ( pWmiObject == NULL || pwszProperty == NULL )
		return FALSE;

	// get the value of the property
	if ( PropertyGet( pWmiObject, pwszProperty, str, _T( "0" ) ) == FALSE )
		return FALSE;

	try
	{
		// convert into the time value
		wbemtime = _bstr_t( str );
	}
	catch( _com_error& e )
	{
		WMISaveError( e );
		return FALSE;
	}

	// return
	return TRUE;
}

// ***************************************************************************
// Routine Description:
//		Gets the value of the property from the WMI class object in string format
//		  
// Arguments:
//  
// Return Value:
//		TRUE - if operation is successfull, otherwise FALSE
// 
// ***************************************************************************
BOOL PropertyGet( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty,  SYSTEMTIME& systime )
{
	// local variables
	CHString strTime;

	// check with object and property passed to the function are valid or not
	// if not, return failure
	if ( pWmiObject == NULL || pwszProperty == NULL )
		return FALSE;

	// get the value of the property
	// 16010101000000.000000+000 is the default time
	if ( PropertyGet( pWmiObject, pwszProperty, strTime, _T( "16010101000000.000000+000" ) ) == FALSE )
		return FALSE;

	// prepare the systemtime structure
	// yyyymmddHHMMSS.mmmmmmsUUU
	systime.wYear = (WORD) AsLong( strTime.Left( 4 ), 10 );
	systime.wMonth = (WORD) AsLong( strTime.Mid( 4, 2 ), 10 );
	systime.wDayOfWeek = 0;
	systime.wDay = (WORD) AsLong( strTime.Mid( 6, 2 ), 10 );
	systime.wHour = (WORD) AsLong( strTime.Mid( 8, 2 ), 10 );
	systime.wMinute = (WORD) AsLong( strTime.Mid( 10, 2 ), 10 );
	systime.wSecond = (WORD) AsLong( strTime.Mid( 12, 2 ), 10 );
	systime.wMilliseconds = (WORD) AsLong( strTime.Mid( 15, 6 ), 10 );

	// return
	return TRUE;
}

// ***************************************************************************
// Routine Description:
//		Gets the value of the property from the WMI class object in string format
//		  
// Arguments:
//  
// Return Value:
//		TRUE - if operation is successfull, otherwise FALSE
// 
// ***************************************************************************
BOOL PropertyGet( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty, TARRAY arr )
{
	// local variables
	HRESULT hr;
	VARIANT vtValue;
	LONG lIndex = 0;
	LONG lLBound = 0;
	LONG lUBound = 0;
	VARTYPE vartype;
	SAFEARRAY* pSafeArray = NULL;

	// check the inputs
	if ( pWmiObject == NULL || pwszProperty == NULL || arr == NULL )
		return FALSE;

	// initialize the variant
	VariantInit( &vtValue );

	// now get the property value
	hr = PropertyGet( pWmiObject, pwszProperty, &vtValue );
	if ( FAILED( hr ) )
		return FALSE;

	if ( V_VT( &vtValue ) == VT_NULL )
		return TRUE;

		// confirm that the propety value is of array type .. if not return
	if ( ( V_VT( &vtValue ) & VT_ARRAY ) == 0 )
		return FALSE;

	// get the safearray value
	pSafeArray = V_ARRAY( &vtValue );

	// get the bounds of the array
    SafeArrayGetLBound( pSafeArray, 1, &lLBound );
    SafeArrayGetUBound( pSafeArray, 1, &lUBound );

	// get the type of the elements in the safe array
	vartype = V_VT( &vtValue ) & ~VT_ARRAY;

	try
	{
		// traverse thru the values in the safe array and update into dynamic array
		for( lIndex = lLBound; lIndex <= lUBound; lIndex++ )
		{
			// sub-local variables
			VARIANT var;
			CHString strValue;
			
			// get the value
			V_VT( &var ) = vartype;
			SafeArrayGetElement( pSafeArray, &lIndex, &V_UI1( &var ) );

			// add the information to the dynamic array
			switch( vartype )
			{
			case VT_BSTR:
				strValue = V_BSTR( &var );
				DynArrayAppendString( arr, strValue, 0 );
				break;
			}
		}
	}
	catch( ... )
	{
		// clear the variant
		VariantClear( &vtValue );
		return FALSE;	// failure
	}

	// clear the variant
	VariantClear( &vtValue );

	// return
	return TRUE;
}

// ***************************************************************************
// Routine Description:
//		Sets the value of the property to the WMI class object
//		  
// Arguments:
//		[ in ] pWmiObject		: pointer to the WBEM class object
//		[ in ] szProperty		: property name
//		[ in ] varValue	: value of the property
//  
// Return Value:
//		HRESULT - result of the operation
// 
// ***************************************************************************
HRESULT PropertyPut( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty, _variant_t& varValue )
{
	// local variables
	HRESULT hr;
	VARIANT var;

	// check the input value
	if ( pWmiObject == NULL || pwszProperty == NULL )
		return WBEM_E_INVALID_PARAMETER;

	try
	{
		// put the value
		var = varValue;
		hr = pWmiObject->Put( _bstr_t( pwszProperty ), 0, &var, 0 );
	}
	catch( _com_error& e )
	{
		WMISaveError( e );
		hr = e.Error();
	}
	
	// return the result
	return hr;
}

// ***************************************************************************
// Routine Description:
//		Sets the value of the property to the WMI class object
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
HRESULT PropertyPut( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty, LPCWSTR pwszValue )
{
	// local variables
	HRESULT hr;
	_variant_t varValue;

	// check the input value
	if ( pWmiObject == NULL || pwszProperty == NULL || pwszValue == NULL )
		return WBEM_E_INVALID_PARAMETER;

	try
	{
		varValue = pwszValue;
		hr = PropertyPut( pWmiObject, pwszProperty, varValue );
	}
	catch( _com_error& e )
	{
		WMISaveError( e );
		hr = e.Error();
	}

	// return 
	return hr;
}

// ***************************************************************************
// Routine Description:
//		Sets the value of the property to the WMI class object
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
HRESULT PropertyPut( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty, DWORD dwValue )
{
	// local variables
	HRESULT hr;
	_variant_t varValue;

	// check the input value
	if ( pWmiObject == NULL || pwszProperty == NULL )
		return WBEM_E_INVALID_PARAMETER;

	try
	{
		varValue = ( LONG ) dwValue;
		hr = PropertyPut( pWmiObject, pwszProperty, varValue );
	}
	catch( _com_error& e )
	{
		WMISaveError( e );
		hr = e.Error();
	}

	// return 
	return hr;
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
HRESULT RegQueryValueWMI( IWbemServices* pWbemServices, 
						  LPCWSTR pwszMethod, DWORD dwHDefKey, 
						  LPCWSTR pwszSubKeyName, LPCWSTR pwszValueName, _variant_t& varValue )
{
	// local variables
	HRESULT hr;
	BOOL bResult = FALSE;
	DWORD dwReturnValue = 0;
	IWbemClassObject* pClass = NULL;
	IWbemClassObject* pMethod = NULL;
	IWbemClassObject* pInParams = NULL;
	IWbemClassObject* pInParamsInstance = NULL;
	IWbemClassObject* pOutParamsInstance = NULL;

	// check the input value
	if (pWbemServices == NULL || pwszMethod == NULL || pwszSubKeyName == NULL || pwszValueName == NULL)
		return WBEM_E_INVALID_PARAMETER;

	try
	{
		// get the registry class object
		SAFE_EXECUTE( pWbemServices->GetObject( 
			_bstr_t( WMI_REGISTRY ), WBEM_FLAG_RETURN_WBEM_COMPLETE, NULL, &pClass, NULL ) );
		if ( pClass == NULL )						// check the object .. safety sake
			_com_issue_error( STG_E_UNKNOWN );

		// get the method reference required
		SAFE_EXECUTE( pClass->GetMethod( pwszMethod, 0, &pInParams, NULL ) );
		if ( pInParams == NULL )					// check the object .. safety sake
			_com_issue_error( STG_E_UNKNOWN );

		// create the instance for the in parameters
		SAFE_EXECUTE( pInParams->SpawnInstance( 0, &pInParamsInstance ) );
		if ( pInParamsInstance == NULL )
			_com_issue_error( STG_E_UNKNOWN );

		// set the input values
		PropertyPut( pInParamsInstance, _bstr_t( WMI_REGISTRY_IN_HDEFKEY ), dwHDefKey );
		PropertyPut( pInParamsInstance, _bstr_t( WMI_REGISTRY_IN_SUBKEY ), pwszSubKeyName );
		PropertyPut( pInParamsInstance, _bstr_t( WMI_REGISTRY_IN_VALUENAME ), pwszValueName );

		// now execute the method
		SAFE_EXECUTE( pWbemServices->ExecMethod( _bstr_t( WMI_REGISTRY ),
			_bstr_t( pwszMethod ), 0, NULL, pInParamsInstance, &pOutParamsInstance, NULL ) );
		if ( pOutParamsInstance == NULL )			// check the object .. safety sake
			_com_issue_error( STG_E_UNKNOWN );

		// now check the return value of the method from the output params object
		bResult = PropertyGet( pOutParamsInstance, 
			_bstr_t( WMI_REGISTRY_OUT_RETURNVALUE ), dwReturnValue );
		if ( bResult == FALSE || dwReturnValue != 0 )
			_com_issue_error( STG_E_UNKNOWN );

		// now everything is sucess .. get the required value
		PropertyGet( pOutParamsInstance, _bstr_t( WMI_REGISTRY_OUT_VALUE ), varValue );
	}
	catch( _com_error& e )
	{
		WMISaveError( e );
		return e.Error();
	}

	// release the interfaces
	SAFE_RELEASE( pClass );
	SAFE_RELEASE( pMethod );
	SAFE_RELEASE( pInParams );
	SAFE_RELEASE( pInParamsInstance );
	SAFE_RELEASE( pOutParamsInstance );

	// return success
	return S_OK;
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
BOOL RegQueryValueWMI( IWbemServices* pWbemServices, 
					   DWORD dwHDefKey, LPCWSTR pwszSubKeyName, 
					   LPCWSTR pwszValueName, CHString& strValue, LPCWSTR pwszDefault )
{
	// local variables
	HRESULT hr;
	_variant_t varValue;

	try
	{
		// set the default value
		if ( pwszDefault != NULL )
			strValue = pwszDefault;

		// check the input
		if ( pWbemServices == NULL || pwszSubKeyName == NULL || pwszValueName == NULL )
			return FALSE;

		// get the value
		hr = RegQueryValueWMI( pWbemServices, 
			WMI_REGISTRY_M_STRINGVALUE, dwHDefKey, pwszSubKeyName, pwszValueName, varValue );
		if ( FAILED( hr ) )
			return FALSE;

		// get the value from the variant
		// get the value
		if ( varValue.vt != VT_NULL && varValue.vt != VT_EMPTY )
			strValue = (LPCWSTR) _bstr_t( varValue );
	}
	catch( ... )
	{
		SetLastError( E_OUTOFMEMORY );
		SaveLastError();
		return FALSE;
	}

	// return success
	return TRUE;
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
DWORD GetTargetVersionEx( IWbemServices* pWbemServices, COAUTHIDENTITY* pAuthIdentity )
{
	// local variables
	HRESULT hr;
	LONG lPos = 0;
	DWORD dwMajor = 0;
	DWORD dwMinor = 0;
	DWORD dwVersion = 0;
	ULONG ulReturned = 0;
	CHString strVersion;
	IWbemClassObject* pWbemObject = NULL;
	IEnumWbemClassObject* pWbemInstances = NULL;

	// check the input value
	if ( pWbemServices == NULL )
		return 0;

	try
	{
		// get the OS information
		SAFE_EXECUTE( pWbemServices->CreateInstanceEnum( 
			_bstr_t( CLASS_CIMV2_Win32_OperatingSystem ), 0, NULL, &pWbemInstances ) );

		// set the security on the enumerated object
		SAFE_EXECUTE( SetInterfaceSecurity( pWbemInstances, pAuthIdentity ) );

		// get the enumerated objects information
		// NOTE: This needs to be traversed only one time. 
		SAFE_EXECUTE( pWbemInstances->Next( WBEM_INFINITE, 1, &pWbemObject, &ulReturned ) );

		// to be on safer side ... check the count of objects returned
		if ( ulReturned == 0 )
		{
			// release the interfaces
			SAFE_RELEASE( pWbemObject );
			SAFE_RELEASE( pWbemInstances );
			return 0;
		}

		// now get the os version value
		if ( PropertyGet( pWbemObject, L"Version", strVersion ) == FALSE )
		{
			// release the interfaces
			SAFE_RELEASE( pWbemObject );
			SAFE_RELEASE( pWbemInstances );
			return 0;
		}

		// release the interfaces .. we dont need them furthur
		SAFE_RELEASE( pWbemObject );
		SAFE_RELEASE( pWbemInstances );
	
		//
		// now determine the os version
		dwMajor = dwMinor = 0;

		// get the major version
		lPos = strVersion.Find( L'.' );
		if ( lPos == -1 )
		{
			// the version string itself is version ... THIS WILL NEVER HAPPEN
			dwMajor = AsLong( strVersion, 10 );
		}
		else
		{
			// major version
			dwMajor = AsLong( strVersion.Mid( 0, lPos ), 10 );

			// get the minor version
			strVersion = strVersion.Mid( lPos + 1 );
			lPos = strVersion.Find( L'.' );
			if ( lPos == -1 )
				dwMinor = AsLong( strVersion, 10 );
			else
				dwMinor = AsLong( strVersion.Mid( 0, lPos ), 10 );
		}

		// mix the version info
		dwVersion = dwMajor * 1000 + dwMinor;
	}
	catch( _com_error& e )
	{
		WMISaveError( e );
		return 0;
	}

	// return 
	return dwVersion;
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
DWORD GetTargetPlatformEx( IWbemServices* pWbemServices, COAUTHIDENTITY* pAuthIdentity )
{
	// local variables
	HRESULT hr;
	LONG lPos = 0;
	CHString strType;
	ULONG ulReturned = 0;
	IWbemClassObject* pWbemObject = NULL;
	IEnumWbemClassObject* pWbemInstances = NULL;

	// check the input value
	if ( pWbemServices == NULL )
		return 0;

	try
	{
		// get the OS information
		SAFE_EXECUTE( pWbemServices->CreateInstanceEnum( 
			_bstr_t( CLASS_CIMV2_Win32_ComputerSystem ), 0, NULL, &pWbemInstances ) );

		// set the security on the enumerated object
		SAFE_EXECUTE( SetInterfaceSecurity( pWbemInstances, pAuthIdentity ) );

		// get the enumerated objects information
		// NOTE: This needs to be traversed only one time. 
		SAFE_EXECUTE( pWbemInstances->Next( WBEM_INFINITE, 1, &pWbemObject, &ulReturned ) );

		// to be on safer side ... check the count of objects returned
		if ( ulReturned == 0 )
		{
			// release the interfaces
			SAFE_RELEASE( pWbemObject );
			SAFE_RELEASE( pWbemInstances );
			return 0;
		}

		// now get the os version value
		if ( PropertyGet( pWbemObject, L"SystemType", strType ) == FALSE )
		{
			// release the interfaces
			SAFE_RELEASE( pWbemObject );
			SAFE_RELEASE( pWbemInstances );
			return 0;
		}

		// release the interfaces .. we dont need them furthur
		SAFE_RELEASE( pWbemObject );
		SAFE_RELEASE( pWbemInstances );

		// determine the type of the platform
		if ( strType.Find( TEXT_X86 ) != -1 )
			return PLATFORM_X86;
		else if ( strType.Find( TEXT_IA64 ) != -1 )
			return PLATFORM_IA64;
		else if ( strType.Find( TEXT_AMD64 ) != -1 )
			return PLATFORM_AMD64;
	}
	catch( _com_error& e )
	{
		WMISaveError( e );
		return 0;
	}

	// return 
	return PLATFORM_UNKNOWN;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cmdline\kill\taskkill.h ===
// *********************************************************************************
// 
//  Copyright (c) Microsoft Corporation
//  
//  Module Name:
//
//		TaskKill.h  
//  
//  Abstract:
//  
//		macros and function prototypes of TaskKill.cpp
//  
//  Author:
//  
// 	  Sunil G.V.N. Murali (murali.sunil@wipro.com) 26-Nov-2000
//  
//  Revision History:
//  
// 	  Sunil G.V.N. Murali (murali.sunil@wipro.com) 26-Nov-2000 : Created It.
//  
// *********************************************************************************

#ifndef _TASKKILL_H
#define _TASKKILL_H

// resource header file
#include "resource.h"

//
// NOTE: THIS MODULE WILL WRITTEN IN SUCH A FASHION THAT IT WORKS ONLY
//       IN UNICODE BUILD COMPILATION
//
#ifndef UNICODE
#error Must compile only in unicode build environment
#endif

//
// general purpose macros
//
#define EXIT_PROCESS( exitcode )	\
	ReleaseGlobals();	\
	return (exitcode);	\
	1

#define HEAP_FREE( pointer )	\
	if ( (pointer) != NULL )	\
	{	\
		HeapFree( GetProcessHeap(), 0, (pointer) );	\
		(pointer) = NULL;	\
	}	\
	1

#define RELEASE_MEMORY( block )	\
	if ( (block) != NULL )	\
	{	\
		delete (block);	\
		(block) = NULL;	\
	}	\
	1

#define RELEASE_MEMORY_EX( block )	\
	if ( (block) != NULL )	\
	{	\
		delete [] (block);	\
		(block) = NULL;	\
	}	\
	1

#define DESTROY_ARRAY( array )	\
	if ( (array) != NULL )	\
	{	\
		DestroyDynamicArray( &(array) );	\
		(array) = NULL;	\
	}	\
	1

//
// winstation related structures ( extract from winsta.h - internal file )
//

//
// structures
typedef struct _CITRIX_PROCESS_INFORMATION {
	ULONG MagicNumber;
	ULONG LogonId;
	PVOID ProcessSid;
	ULONG Pad;
} CITRIX_PROCESS_INFORMATION, * PCITRIX_PROCESS_INFORMATION;

// ...
typedef struct _TS_UNICODE_STRING {
	USHORT Length;
	USHORT MaximumLength;
	PWSTR  Buffer;
} TS_UNICODE_STRING;

// CAUTION:
// TS_SYSTEM_PROCESS_INFORMATION is duplicated from ntexapi.h, and slightly modified.
// (not nice, but necessary because the Midl compiler doesn't like PVOID !)
typedef struct _TS_SYSTEM_PROCESS_INFORMATION {
	ULONG NextEntryOffset;
	ULONG NumberOfThreads;
	LARGE_INTEGER SpareLi1;
	LARGE_INTEGER SpareLi2;
	LARGE_INTEGER SpareLi3;
	LARGE_INTEGER CreateTime;
	LARGE_INTEGER UserTime;
	LARGE_INTEGER KernelTime;
	TS_UNICODE_STRING ImageName;
	LONG BasePriority;                     // KPRIORITY in ntexapi.h
	DWORD UniqueProcessId;                 // HANDLE in ntexapi.h
	DWORD InheritedFromUniqueProcessId;    // HANDLE in ntexapi.h
	ULONG HandleCount;
	ULONG SessionId;
	ULONG SpareUl3;
	SIZE_T PeakVirtualSize;
	SIZE_T VirtualSize;
	ULONG PageFaultCount;
	ULONG PeakWorkingSetSize;
	ULONG WorkingSetSize;
	SIZE_T QuotaPeakPagedPoolUsage;
	SIZE_T QuotaPagedPoolUsage;
	SIZE_T QuotaPeakNonPagedPoolUsage;
	SIZE_T QuotaNonPagedPoolUsage;
	SIZE_T PagefileUsage;
	SIZE_T PeakPagefileUsage;
	SIZE_T PrivatePageCount;
} TS_SYSTEM_PROCESS_INFORMATION, *PTS_SYSTEM_PROCESS_INFORMATION;

// ...
typedef struct _TS_ALL_PROCESSES_INFO {
	PTS_SYSTEM_PROCESS_INFORMATION pspiProcessInfo;
	DWORD SizeOfSid;
	PBYTE pSid;
} TS_ALL_PROCESSES_INFO, *PTS_ALL_PROCESSES_INFO;

// defines
#define SERVERNAME_CURRENT						((HANDLE)NULL)
#define GAP_LEVEL_BASIC							0
#define CITRIX_PROCESS_INFO_MAGIC				0x23495452
#define WINSTA_DLLNAME							L"Winsta.dll"
#define FUNCNAME_WinStationFreeMemory			"WinStationFreeMemory"
#define FUNCNAME_WinStationCloseServer			"WinStationCloseServer"
#define FUNCNAME_WinStationOpenServerW			"WinStationOpenServerW"
#define FUNCNAME_WinStationEnumerateProcesses	"WinStationEnumerateProcesses"
#define FUNCNAME_WinStationFreeGAPMemory		"WinStationFreeGAPMemory"
#define FUNCNAME_WinStationGetAllProcesses		"WinStationGetAllProcesses"
#define SIZEOF_SYSTEM_THREAD_INFORMATION		sizeof( struct SYSTEM_THREAD_INFORMATION )
#define SIZEOF_SYSTEM_PROCESS_INFORMATION		sizeof( struct SYSTEM_PROCESS_INFORMATION )

//
// function prototypes
typedef BOOLEAN (WINAPI * FUNC_WinStationFreeMemory)( PVOID pBuffer );
typedef BOOLEAN (WINAPI * FUNC_WinStationCloseServer)( HANDLE hServer );
typedef HANDLE  (WINAPI * FUNC_WinStationOpenServerW)( LPWSTR pwszServerName );
typedef BOOLEAN (WINAPI * FUNC_WinStationEnumerateProcesses)( HANDLE  hServer, PVOID *ppProcessBuffer );
typedef BOOLEAN (WINAPI * FUNC_WinStationFreeGAPMemory)( ULONG Level, 
													     PVOID ProcessArray, ULONG ulCount );
typedef BOOLEAN (WINAPI * FUNC_WinStationGetAllProcesses)( HANDLE hServer, 
														   ULONG Level, ULONG *pNumberOfProcesses, 
														   PVOID *ppProcessArray );

//
// constants / defines / enumerations
//

//
// WMI related stuff

// class name
#define CLASS_PROCESS								L"Win32_Process"

// wmi query
#define WMI_QUERY_TYPE					L"WQL"
#define WMI_SERVICE_QUERY				L"SELECT Name FROM Win32_Service WHERE ProcessId = %d and State=\"Running\""
#define WMI_MODULES_QUERY				L"ASSOCIATORS OF {%s} WHERE ResultClass = CIM_DataFile"
#define WMI_PROCESS_QUERY		\
	L"SELECT " \
	L"__PATH, ProcessId, CSName, Caption, SessionId, ThreadCount, "	\
	L"WorkingSetSize, KernelModeTime, UserModeTime, ParentProcessId "	\
	L"FROM Win32_Process"

// wmi query operators etc
#define WMI_QUERY_FIRST_CLAUSE		L"WHERE ("
#define WMI_QUERY_SECOND_CLAUSE		L"AND"

// Win32_Process class properties
#define WIN32_PROCESS_SYSPROPERTY_PATH				L"__PATH"
#define WIN32_PROCESS_PROPERTY_HANDLE				L"Handle"
#define WIN32_PROCESS_PROPERTY_COMPUTER				L"CSName"
#define WIN32_PROCESS_PROPERTY_IMAGENAME			L"Caption"
#define WIN32_PROCESS_PROPERTY_PROCESSID			L"ProcessId"
#define WIN32_PROCESS_PROPERTY_SESSION				L"SessionId"
#define WIN32_PROCESS_PROPERTY_THREADS				L"ThreadCount"
#define WIN32_PROCESS_PROPERTY_USERMODETIME			L"UserModeTime"
#define WIN32_PROCESS_PROPERTY_MEMUSAGE				L"WorkingSetSize"
#define WIN32_PROCESS_PROPERTY_KERNELMODETIME		L"KernelModeTime"
#define WIN32_PROCESS_PROPERTY_PARENTPROCESSID		L"ParentProcessId"

// Win32_Process class method(s)
#define WIN32_PROCESS_METHOD_GETOWNER				L"GetOwner"
#define WIN32_PROCESS_METHOD_TERMINATE				L"Terminate"

// GetOwner method's return values
#define GETOWNER_RETURNVALUE_USER					L"User"
#define GETOWNER_RETURNVALUE_DOMAIN					L"Domain"

// Terminate input values
#define TERMINATE_INPARAM_REASON					L"Reason"

// function default return value
#define WMI_RETURNVALUE								L"ReturnValue"

// Win32_Service related stuff
#define WIN32_SERVICE_PROPERTY_NAME					L"Name"

// CIM_DataFile related stuff
#define CIM_DATAFILE_PROPERTY_FILENAME				L"FileName"
#define CIM_DATAFILE_PROPERTY_EXTENSION				L"Extension"

//
// other stuff
#define VALUE_RUNNING				GetResString( IDS_VALUE_RUNNING )
#define VALUE_NOTRESPONDING			GetResString( IDS_VALUE_NOTRESPONDING )
#define PID_0_DOMAIN				GetResString( IDS_PID_0_DOMAIN )
#define PID_0_USERNAME				GetResString( IDS_PID_0_USERNAME )

// messages
#define MSG_KILL_SUCCESS						GetResString( IDS_MSG_KILL_SUCCESS )
#define MSG_KILL_SUCCESS_QUEUED					GetResString( IDS_MSG_KILL_SUCCESS_QUEUED )
#define MSG_KILL_SUCCESS_EX						GetResString( IDS_MSG_KILL_SUCCESS_EX )
#define MSG_KILL_SUCCESS_QUEUED_EX				GetResString( IDS_MSG_KILL_SUCCESS_QUEUED_EX )
#define MSG_TREE_KILL_SUCCESS					GetResString( IDS_MSG_TREE_KILL_SUCCESS )
#define ERROR_TREE_KILL_FAILED					GetResString( IDS_ERROR_TREE_KILL_FAILED )
#define ERROR_TASK_HAS_CHILDS					GetResString( IDS_ERROR_TASK_HAS_CHILDS )
#define ERROR_KILL_FAILED						GetResString( IDS_ERROR_KILL_FAILED )
#define ERROR_KILL_FAILED_EX					GetResString( IDS_ERROR_KILL_FAILED_EX )
#define ERROR_PROCESS_NOTFOUND					GetResString( IDS_ERROR_PROCESS_NOTFOUND )
#define ERROR_NO_PROCESSES						GetResString( IDS_ERROR_NO_PROCESSES )
#define ERROR_UNABLE_TO_TERMINATE				GetResString( IDS_ERROR_UNABLE_TO_TERMINATE	)
#define ERROR_CRITICAL_SYSTEM_PROCESS			GetResString( IDS_ERROR_CRITICAL_SYSTEM_PROCESS )
#define ERROR_CANNOT_KILL_SILENTLY				GetResString( IDS_ERROR_CANNOT_KILL_SILENTLY )
#define ERROR_CANNOT_KILL_ITSELF				GetResString( IDS_ERROR_CANNOT_KILL_ITSELF )
#define ERROR_COM_ERROR							GetResString( IDS_ERROR_COM_ERROR )
#define ERROR_USERNAME_BUT_NOMACHINE			GetResString( IDS_ERROR_USERNAME_BUT_NOMACHINE )
#define ERROR_PASSWORD_BUT_NOUSERNAME			GetResString( IDS_ERROR_PASSWORD_BUT_NOUSERNAME )
#define ERROR_USERNAME_EMPTY					GetResString( IDS_ERROR_USERNAME_EMPTY )
#define ERROR_SERVER_EMPTY						GetResString( IDS_ERROR_SERVER_EMPTY )
#define ERROR_WILDCARD_WITHOUT_FILTERS			GetResString( IDS_ERROR_WILDCARD_WITHOUT_FILTERS )
#define ERROR_PID_OR_IM_ONLY					GetResString( IDS_ERROR_PID_OR_IM_ONLY )
#define	ERROR_NO_PID_AND_IM						GetResString( IDS_ERROR_NO_PID_AND_IM )
#define ERROR_STRING_FOR_PID					GetResString( IDS_ERROR_STRING_FOR_PID )
#define ERROR_INVALID_USAGE_REQUEST				GetResString( IDS_ERROR_INVALID_USAGE_REQUEST )
#define ERROR_PLATFORM_SHOULD_BE_X86			GetResString( IDS_ERROR_PLATFORM_SHOULD_BE_X86 )

// progress messages
#define MSG_MODULESINFO					GetResString( IDS_MSG_MODULESINFO )
#define MSG_SERVICESINFO				GetResString( IDS_MSG_SERVICESINFO )
#define MSG_TASKSINFO					GetResString( IDS_MSG_TASKSINFO )
#define MSG_MODULESINFO_EX				GetResString( IDS_MSG_MODULESINFO_EX )
#define MSG_FORMINGTREE					GetResString( IDS_MSG_FORMINGTREE )
//
// command line options and their indexes in the array
#define MAX_OPTIONS			9

// supported options ( do not localize )
#define OPTION_USAGE		L"?"
#define OPTION_SERVER		L"s"
#define OPTION_USERNAME		L"u"
#define OPTION_PASSWORD		L"p"
#define OPTION_FORCE		L"f"
#define OPTION_FILTER		L"fi"
#define OPTION_PID			L"pid"
#define OPTION_IMAGENAME	L"im"
#define OPTION_TREE			L"t"

// indexes
#define OI_USAGE					0
#define OI_SERVER					1
#define OI_USERNAME					2
#define OI_PASSWORD					3
#define OI_FORCE					4
#define OI_FILTER					5
#define OI_PID						6
#define OI_IMAGENAME				7
#define OI_TREE						8

//
// filter details
#define MAX_FILTERS			10

// supported filters
#define FILTER_STATUS		GetResString( IDS_FILTER_STATUS )
#define FILTER_IMAGENAME	GetResString( IDS_FILTER_IMAGENAME )
#define FILTER_PID			GetResString( IDS_FILTER_PID )
#define FILTER_SESSION		GetResString( IDS_FILTER_SESSION )
#define FILTER_CPUTIME		GetResString( IDS_FILTER_CPUTIME )
#define FILTER_MEMUSAGE		GetResString( IDS_FILTER_MEMUSAGE )
#define FILTER_USERNAME		GetResString( IDS_FILTER_USERNAME )
#define FILTER_SERVICES		GetResString( IDS_FILTER_SERVICES )
#define FILTER_WINDOWTITLE	GetResString( IDS_FILTER_WINDOWNAME	)
#define FILTER_MODULES		GetResString( IDS_FILTER_MODULES )

#define FI_STATUS			0
#define FI_IMAGENAME		1
#define FI_PID				2
#define FI_SESSION			3
#define FI_CPUTIME			4
#define FI_MEMUSAGE			5
#define FI_USERNAME			6
#define FI_SERVICES			7
#define FI_WINDOWTITLE		8
#define FI_MODULES			9

// values supported by 'status' filter
#define FVALUES_STATUS		GetResString( IDS_FVALUES_STATUS )

// operators supported
#define OPERATORS_STRING	GetResString( IDS_OPERATORS_STRING )
#define OPERATORS_NUMERIC	GetResString( IDS_OPERATORS_NUMERIC )

// max. columns ( information ) to be stored for one task
#define MAX_TASKSINFO			18

// task info indexes
#define TASK_HOSTNAME			0
#define TASK_IMAGENAME			1
#define TASK_PID				2
#define TASK_SESSIONNAME		3
#define TASK_SESSION			4
#define TASK_MEMUSAGE			5
#define TASK_STATUS				6
#define TASK_USERNAME			7
#define TASK_CPUTIME			8
#define TASK_WINDOWTITLE		9
#define TASK_SERVICES			10
#define TASK_MODULES			11

// always hidden
#define TASK_HWND				12
#define TASK_WINSTA				13
#define TASK_DESK				14
#define TASK_CREATINGPROCESSID	15
#define TASK_OBJPATH			16
#define TASK_RANK				17

//
// CTaskKill
//
class CTaskKill
{
public:
	// enumerators
	enum 
	{
		twiProcessId = 0,
		twiWinSta = 1,
		twiDesktop = 2,
		twiHandle = 3,
		twiTitle = 4,
		twiCOUNT,
	};

// constructor / destructor
public:
	CTaskKill();
	~CTaskKill();

// data memebers
private:
	// input arguments
	BOOL m_bTree;					// -tr
	BOOL m_bForce;					// -fo
	CHString m_strServer;			// -s
	CHString m_strUserName;			// -u
	CHString m_strPassword;			// -p
	TARRAY m_arrFilters;			// -fi
	TARRAY m_arrTasksToKill;		// ( defaults = -im and -pid )

	// WMI Query
	CHString m_strQuery;

	// other(s)
	DWORD m_dwCurrentPid;
	BOOL m_bNeedPassword;				
	BOOL m_bNeedModulesInfo;
	TARRAY m_arrFiltersEx;			// parsed filters info
	TARRAY m_arrWindowTitles;			// window titles
	BOOL m_bNeedServicesInfo;		// determines whether services info has to gathered or not
	BOOL m_bNeedUserContextInfo;	// determines whether userinfo has to gathered or not
	PTFILTERCONFIG m_pfilterConfigs;	// filters config information

	// WMI / COM interfaces
	IWbemLocator* m_pWbemLocator;
	IWbemServices* m_pWbemServices;
	IEnumWbemClassObject* m_pWbemEnumObjects;
	IWbemClassObject* m_pWbemTerminateInParams;

	// WMI connectivity
	COAUTHIDENTITY* m_pAuthIdentity;

	// output data
	TARRAY m_arrRecord;
	DWORD m_dwProcessId;
	CHString m_strImageName;
	BOOL m_bTasksOptimized;
	BOOL m_bFiltersOptimized;

	// winstation related stuff
	CHString m_strUNCServer;				// server name
	BOOL m_bIsHydra;
	HMODULE m_hWinstaLib;
	PBYTE m_pProcessInfo;
	ULONG m_ulNumberOfProcesses;
	BOOL m_bCloseConnection;

	// services related stuff
	DWORD m_dwServicesCount;
	LPENUM_SERVICE_STATUS_PROCESS m_pServicesInfo;

	// modules related stuff ( remote only )
	BOOL m_bUseRemote;
	PPERF_DATA_BLOCK m_pdb;

	// progress message related
	HANDLE m_hOutput;
	CONSOLE_SCREEN_BUFFER_INFO m_csbi;

	//
	// functions
	FUNC_WinStationFreeMemory m_pfnWinStationFreeMemory;
	FUNC_WinStationOpenServerW m_pfnWinStationOpenServerW;
	FUNC_WinStationCloseServer m_pfnWinStationCloseServer;
	FUNC_WinStationFreeGAPMemory m_pfnWinStationFreeGAPMemory;
	FUNC_WinStationGetAllProcesses m_pfnWinStationGetAllProcesses;
	FUNC_WinStationEnumerateProcesses m_pfnWinStationEnumerateProcesses;

public:
	BOOL m_bUsage;					// -?
	BOOL m_bLocalSystem;

// functions
private:
	BOOL CanTerminate();
	BOOL Kill( BOOL& bQueued );
	BOOL KillProcessOnLocalSystem( BOOL& bQueued );
	BOOL ForciblyKillProcessOnLocalSystem();
	BOOL ForciblyKillProcessOnRemoteSystem();
	LONG MatchTaskToKill( DWORD& dwMatchedIndex );

	// helpers
	VOID DoOptimization();
	VOID SaveData( IWbemClassObject* pWmiObject );
	VOID SetStatus( IWbemClassObject* pWmiObject );
	VOID SetMemUsage( IWbemClassObject* pWmiObject );
	VOID SetCPUTime( IWbemClassObject* pWmiObject );
	VOID SetUserContext( IWbemClassObject* pWmiObject );
	VOID SetWindowTitle( IWbemClassObject* pWmiObject );
	VOID SetServicesInfo( IWbemClassObject* pWmiObject );
	BOOL SetModulesInfo( IWbemClassObject* pWmiObject );

	// ...
	BOOL LoadTasksEx();
	BOOL LoadModulesInfo();
	BOOL LoadServicesInfo();
	BOOL GetModulesOnRemote( TARRAY arrModules );
	BOOL GetModulesOnRemoteEx( TARRAY arrModules );
	BOOL LoadModulesOnLocal( TARRAY arrModules );
	BOOL LoadUserNameFromWinsta( CHString& strDomain, CHString& strUserName );

	// winsta functions
	BOOLEAN WinStationFreeMemory( PVOID pBuffer );
	BOOLEAN WinStationCloseServer( HANDLE hServer );
	HANDLE  WinStationOpenServerW( LPWSTR pwszServerName );
	BOOLEAN WinStationEnumerateProcesses( HANDLE  hServer, PVOID *ppProcessBuffer );
	BOOLEAN WinStationFreeGAPMemory( ULONG Level, PVOID ProcessArray, ULONG ulCount );
	BOOLEAN WinStationGetAllProcesses( HANDLE hServer, ULONG Level, 
									   ULONG *pNumberOfProcesses, PVOID *ppProcessArray );
public:
	VOID Usage();
	BOOL Initialize();
	VOID PrepareColumns();
	BOOL ValidateFilters();
	BOOL ProcessOptions( DWORD argc, LPCTSTR argv[] );

	// functionality related
	BOOL Connect();
	BOOL LoadTasks();
	BOOL EnableDebugPriv();
	BOOL DoTerminate( DWORD& dwTerminate );
};

// 
// public functions
//
VOID PrintProgressMsg( HANDLE hOutput, LPCWSTR pwszMsg, const CONSOLE_SCREEN_BUFFER_INFO& csbi );

#endif	// _TASKLIST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cmdline\kill\terminate.cpp ===
// *********************************************************************************
// 
//  Copyright (c) Microsoft Corporation
//  
//  Module Name:
//  
//		Terminate.cpp
//  
//  Abstract:
//  
// 		This module implements the actual termination of process
//  
//  Author:
//  
// 		Sunil G.V.N. Murali (murali.sunil@wipro.com) 26-Nov-2000
//  
//  Revision History:
//  
// 		Sunil G.V.N. Murali (murali.sunil@wipro.com) 26-Nov-2000 : Created It.
//  
// *********************************************************************************

#include "pch.h"
#include "wmi.h"
#include "TaskKill.h"

//
// define(s) / constants
// 
#define MAX_ENUM_TASKS				5
#define	MAX_ENUM_SERVICES			10
#define	MAX_ENUM_MODULES			10
#define WAIT_TIME_IN_SECS			1000				// 1 second ( 1000 milliseconds )
#define MAX_TIMEOUT_RETRIES			60					// 60 times
#define MAX_TERMINATE_TIMEOUT		1000				// 1 seconds

// We won't allow the following set of critical system processes to be terminated,
// since the system would bug check immediately, no matter who you are.
#define PROCESS_CSRSS_EXE			L"csrss.exe"
#define PROCESS_WINLOGON_EXE		L"winlogon.exe"
#define PROCESS_SMSS_EXE			L"smss.exe"
#define PROCESS_SERVICES_EXE		L"services.exe"

//
// function prototypes
//
#ifndef _WIN64
BOOL EnumLoadedModulesProc( LPSTR lpszModuleName, ULONG ulModuleBase, ULONG ulModuleSize, PVOID pUserData );
#else
BOOL EnumLoadedModulesProc64( LPSTR lpszModuleName, DWORD64 ulModuleBase, ULONG ulModuleSize, PVOID pUserData );
#endif

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//		NONE
//
// Return Value:
//
// ***************************************************************************
BOOL CTaskKill::DoTerminate( DWORD& dwExitCode )
{
	// local variables
	HRESULT hr;
	CHString str;
	LONG lIndex = -1;
	DWORD dwCount = 0;
	DWORD dwKilled = 0;
	DWORD dwFilters = 0;
	DWORD dwTimeOuts = 0;
	DWORD dwImageNames = 0;
	DWORD dwTasksToKill = 0;
	DWORD dwMatchedIndex = 0;
	BOOL bQueued = FALSE;
	BOOL bCanExit = FALSE;
	BOOL bAllTasks = FALSE;
	BOOL bImageName = FALSE;
	ULONG ulReturned = 0;
	TARRAY arrTasks = NULL;
	TARRAY arrImageNames = NULL;
	LPCWSTR pwszTask = NULL;
	IWbemClassObject* pObjects[ MAX_ENUM_TASKS ];

	// clear the error
	SetLastError( NO_ERROR );

	try
	{
		//
		// prepare ...
		bCanExit = FALSE;
		dwImageNames = 0;
		dwFilters = DynArrayGetCount( m_arrFiltersEx );
		dwTasksToKill = DynArrayGetCount( m_arrTasksToKill );
		arrTasks = CreateDynamicArray();
		arrImageNames = CreateDynamicArray();
		if ( arrImageNames == NULL || arrTasks == NULL )
		{
			dwExitCode = 1;
			SetLastError( E_OUTOFMEMORY );
			SaveLastError();
			
			// release the allocations
			DESTROY_ARRAY( arrTasks );
			DESTROY_ARRAY( arrImageNames );
			
			// inform failure
			return FALSE;
		}
		
		// check if '*' is specified or not
		lIndex = DynArrayFindString( m_arrTasksToKill, L"*", TRUE, 0 );
		if ( lIndex != -1 )
		{
			// wild card specified
			dwTasksToKill--;								// update the counter
			bAllTasks = TRUE;								// remember
			DynArrayRemove( m_arrTasksToKill, lIndex );		// remove the wildcard entry
		}
		
		// init all the objects first
		for( DWORD dw = 0; dw < MAX_ENUM_TASKS; dw++ )
			pObjects[ dw ] = NULL;
		
		// if -tr is specified, free the already allocated memory for m_arrRecord
		if ( m_bTree == TRUE )
		{
			DESTROY_ARRAY( m_arrRecord );
		}
		
		// traverse thru the running processed and terminate the needed
		dwCount = 0;
		dwKilled = 0;
		do
		{
			// status message
			if ( m_bTree == TRUE )
				PrintProgressMsg( m_hOutput, MSG_TASKSINFO, m_csbi );

			// get the object ... time out should not occur
			// NOTE: one-by-one
			hr = m_pWbemEnumObjects->Next( 
				WAIT_TIME_IN_SECS, MAX_ENUM_TASKS, pObjects, &ulReturned );
			if ( hr == WBEM_S_FALSE )
			{
				// we've reached the end of enumeration .. set the flag 
				bCanExit = TRUE;
			}
			else if ( hr == WBEM_S_TIMEDOUT )
			{
				// update the timeouts occured 
				dwTimeOuts++;
				
				// check if max. retries have reached ... if yes better stop
				if ( dwTimeOuts > MAX_TIMEOUT_RETRIES )
				{
					dwExitCode = 1;
					DESTROY_ARRAY( arrTasks );
					DESTROY_ARRAY( arrImageNames );
					SetLastError( ERROR_TIMEOUT );
					SaveLastError();
					return FALSE;
				}
				
				// still we can do some more tries ...
				continue;
			}
			else if ( FAILED( hr ) )
			{
				// some error has occured ... oooppps
				dwExitCode = 1;
				DESTROY_ARRAY( arrTasks );
				DESTROY_ARRAY( arrImageNames );
				WMISaveError( hr );
				return FALSE;
			}
			
			// reset the timeout counter
			dwTimeOuts = 0;
			
			// loop thru the objects and save the info
			for( ULONG ul = 0; ul < ulReturned; ul++ )
			{
				// get the current cursor position .. 
				if ( m_hOutput != NULL )
					GetConsoleScreenBufferInfo( m_hOutput, &m_csbi );
				
				// if tree option is specified, allocate memory for record every we loop
				if ( m_bTree == TRUE )
				{
					// create a new array
					m_arrRecord = CreateDynamicArray();
					if ( m_arrRecord == NULL )
					{
						dwExitCode = 1;
						SetLastError( E_OUTOFMEMORY );
						SaveLastError();
						
						// release the allocations
						DESTROY_ARRAY( arrTasks );
						DESTROY_ARRAY( arrImageNames );
						
						// inform failure
						return FALSE;
					}
				}
				else
				{
					// tree option is not specified, so, just remove the contents
					DynArrayRemoveAll( m_arrRecord );
				}
				
				// add the columns first
				DynArrayAddColumns( m_arrRecord, MAX_TASKSINFO );	
				
				// retrive and save data
				SaveData( pObjects[ ul ] );
				
				// release the object
				SAFE_RELEASE( pObjects[ ul ] );
				
				// check if this has to be filtered or not
				if ( dwFilters != 0 )
				{
					BOOL bIgnore = FALSE;
					bIgnore = CanFilterRecord( MAX_FILTERS, 
						m_pfilterConfigs, m_arrRecord, m_arrFiltersEx );
					
					// check if this has to be ignored or not
					if ( bIgnore == TRUE )
					{
						if ( m_bTree == TRUE )
						{
							// save this record with rank as 0
							DynArraySetDWORD( m_arrRecord, TASK_RANK, 0 );
							DynArrayAppendEx( arrTasks, m_arrRecord );
						}
						
						// continue to the task
						continue;			
					}
				}
				
				// crossed from the filter -- update the count
				dwCount++;
				
				// find the task that has to be killed
				// and check if this task has to be killed or not
				lIndex = -1;
				pwszTask = NULL;
				bImageName = FALSE;
				if ( dwTasksToKill != 0 || dwImageNames != 0 )
				{
					// check if the process is in list
					if ( dwTasksToKill != 0 )
						lIndex = MatchTaskToKill( dwMatchedIndex );
					
					// if task is not, check if image names exist and if it matches or not
					if ( lIndex == -1 && dwImageNames != 0 )
					{
						// get the image name and search for the same in the image names list
						DWORD dwLength = 0;
						LPCWSTR pwsz = NULL;
						LPCWSTR pwszTemp = NULL;
						LPCWSTR pwszImageName = NULL;
						pwszImageName = DynArrayItemAsString( m_arrRecord, TASK_IMAGENAME );
						if ( pwszImageName == NULL )
						{
							dwExitCode = 1;
							DESTROY_ARRAY( arrTasks );
							DESTROY_ARRAY( arrImageNames );
							SetLastError( STG_E_UNKNOWN );
							SaveLastError();
							return FALSE;
						}
						
						// ...
						for( DWORD dw = 0; dw < dwImageNames; dw++ )
						{
							// get the image name from the list
							pwszTemp = DynArrayItemAsString( arrImageNames, dw );
							if ( pwszTemp == NULL )
							{
								dwExitCode = 1;
								DESTROY_ARRAY( arrTasks );
								DESTROY_ARRAY( arrImageNames );
								SetLastError( STG_E_UNKNOWN );
								SaveLastError();
								return FALSE;
							}

							// determine the no. of characters to compare
							dwLength = 0;
							pwsz = FindChar( pwszTemp, L'*', 0 );
							if ( pwsz != NULL )
							{
								// '*' - wildcard is specified in the image name
								// so, determine the no. of characters to compare
								// but before that check the length of the string pointer from '*'
								// it should be 1 - meaning the '*' can be specified only at the end
								// but not in the middle
								if ( lstrlen( pwsz ) == 1 )
								{
									dwLength = lstrlen( pwszTemp ) - lstrlen( pwsz );
								}
							}

							// now do the comparision
							if ( StringCompare( pwszImageName, pwszTemp, TRUE, dwLength ) == 0 )
							{
								// image found - has to be terminated
								bImageName = TRUE;
								pwszTask = pwszTemp;
							}
						}
					}
					else if ( lIndex != -1 && dwMatchedIndex == TASK_IMAGENAME )
					{
						bImageName = TRUE;			// image name 
						pwszTask = DynArrayItemAsString( m_arrTasksToKill, lIndex );
					}
				}
				
				// check whether attempt to terminate or not to attempt
				if ( bAllTasks == FALSE && lIndex == -1 && bImageName == FALSE )
				{
					if ( m_bTree == TRUE )
					{
						// save this record with rank as 0
						dwCount--;
						DynArraySetDWORD( m_arrRecord, TASK_RANK, 0 );
						DynArrayAppendEx( arrTasks, m_arrRecord );
					}
					
					// continue to the task
					continue;			
				}
				
				// we need to post-pone the killing of the current identified task till we get the 
				// entire list of processes
				if ( m_bTree == TRUE )
				{
					// mark this as rank 1 process
					DynArraySetDWORD( m_arrRecord, TASK_RANK, 1 );
					
					// now add this record to the tasks array
					DynArrayAppendEx( arrTasks, m_arrRecord );
				}
				else
				{
					// kill the current task
					bQueued = FALSE;
					if ( this->Kill( bQueued ) == TRUE )
					{
						dwKilled++;		// updated killed processes counter
						
						// success message will depend on the task info specified by the user
						// at the command prompt
						if ( bImageName == TRUE )
						{
							str.Format(MSG_KILL_SUCCESS_EX, m_strImageName, m_dwProcessId);
						}
						else
						{
							str.Format( MSG_KILL_SUCCESS, m_dwProcessId );
						}
						
						// show the message
						ShowMessage( stdout, str );
					}
					else
					{
						// failed to kill the process .. save the error message
						if ( bImageName == FALSE )
							str.Format( ERROR_KILL_FAILED, m_dwProcessId, GetReason() );
						else
							str.Format( ERROR_KILL_FAILED_EX, m_strImageName, m_dwProcessId, GetReason() );
						
						// show the message
						ShowMessage( stderr, str );
					}
				}
				
				// user might have specified the duplications in the list 
				// so check for that and remove it
				if ( bImageName == TRUE )
				{
					// sub-local
					CHString strProcessId;
					LONG lProcessIndex = -1;
					strProcessId.Format( L"%ld", m_dwProcessId );
					lProcessIndex = DynArrayFindString( m_arrTasksToKill, strProcessId, TRUE, 0 );
					if ( lProcessIndex != -1 && lIndex != lProcessIndex )
						DynArrayRemove( m_arrTasksToKill, lProcessIndex );
				}
				else if ( pwszTask != NULL )
				{
					// sub-local
					LONG lProcessIndex = -1;
					lProcessIndex = DynArrayFindString( m_arrTasksToKill, pwszTask, TRUE, 0 );
					if ( lProcessIndex != -1 && lIndex != lProcessIndex )
					{
						bImageName = TRUE;
						DynArrayRemove( m_arrTasksToKill, lProcessIndex );
					}
				}
				
				// if this is a image name, all the tasks with this image name
				// has to be terminated. so we need to save the image name
				// but before doing this, in order to save memory, check if this image name
				// already exists in the list .. this will avoid duplication of image names
				// in the list and helps in performace
				if ( bImageName == TRUE && pwszTask != NULL && 
					 DynArrayFindString(arrImageNames, pwszTask, TRUE, 0) == -1 )
				{
					// add to the list
					dwImageNames++;
					DynArrayAppendString( arrImageNames, pwszTask, 0 );
				}
				
				// delete the process info from the arrProcesses ( if needed )
				if ( lIndex != -1 )
				{
					// yes ... current task was killed remove the entry from arrProcess into
					// consideration ... so delete it
					dwTasksToKill--;		// update the counter
					DynArrayRemove( m_arrTasksToKill, lIndex );
				}
				
				// check whether we need to quit the program or not
				if ( m_bTree == FALSE && bAllTasks == FALSE && dwTasksToKill == 0 && dwImageNames == 0 )
				{
					bCanExit = TRUE;
					break;
				}
			}
		} while ( bCanExit == FALSE );
	
		// if the -tr is specified, reset the m_arrRecord variable to NULL
		// this will avoid double free-ing the same heap memory
		if ( m_bTree == TRUE )
		{
			m_arrRecord = NULL;

			// erase progress message
			PrintProgressMsg( m_hOutput, NULL, m_csbi );
		}
	
		//
		// SPECIAL HANDLING FOR TREE TERMINATION STARTS HERE
		// 
		dwExitCode = 0;
		if ( m_bTree == TRUE && dwCount != 0 )
		{
			//
			// prepare the tree
			
			// sub-local variables
			LONG lTemp = 0;
			DWORD dwTemp = 0;
			DWORD dwRank = 0;
			DWORD dwIndex = 0;
			DWORD dwLastRank = 0;
			DWORD dwTasksCount = 0;
			DWORD dwProcessId = 0;
			DWORD dwParentProcessId = 0;
			
			// show progress message
			PrintProgressMsg( m_hOutput, MSG_FORMINGTREE, m_csbi );

			// loop thru the list of processes
			dwLastRank = 1;
			dwTasksCount = DynArrayGetCount( arrTasks );
			for( dwIndex = 0; dwIndex < dwTasksCount; dwIndex++ )
			{
				// get the rank of the current process
				// and check whether the current process is marked for termination or not
				dwRank = DynArrayItemAsDWORD2( arrTasks, dwIndex, TASK_RANK );
				if ( dwRank == 0 )
					continue;
				
				// now loop thru the begining of the tasks and 
				// assign the ranks to the childs of this process
				dwProcessId = DynArrayItemAsDWORD2( arrTasks, dwIndex, TASK_PID );
				for( DWORD dw = dwIndex + 1; dw < dwTasksCount; dw++ )
				{
					// get the process id this process
					dwTemp = DynArrayItemAsDWORD2( arrTasks, dw, TASK_PID );
					if ( dwTemp == dwProcessId )
						continue;				// skip this process
					
					// get the parent process id of this process
					dwParentProcessId = DynArrayItemAsDWORD2( arrTasks, dw, TASK_CREATINGPROCESSID );
					if ( dwTemp == dwParentProcessId )
						continue;						// skip this process also
					
					// check the process relation
					if ( dwProcessId == dwParentProcessId )
					{
						// set the rank to this process
						DynArraySetDWORD2( arrTasks, dw, TASK_RANK, dwRank + 1 );
						
						// update the last rank
						if ( dwRank + 1 > dwLastRank )
						{
							dwLastRank = dwRank + 1;
						}
						
						// SPECIAL CONDITION:
						// -----------------
						// we need to check the index of this task in the list of tasks information we have
						// if the index of this task information is above its parent process, 
						// we need to re-initiate the outter loop once again
						// this is a sort of optimization which we are doing here instead of looping the
						// outter loop unnecessarily
						// if ( dw < dwIndex )
						// {
						//	dwIndex = 0;
						// }
						// ----------------------------------------------------------
						// currently we are assuming that the list of processe we get 
						// will be in sorting order of creation time
						// ----------------------------------------------------------
					}
				}
			}
			
			// erase progress message
			PrintProgressMsg( m_hOutput, NULL, m_csbi );

			//
			// now start terminating the tasks based on their ranks
			dwKilled = 0;
			for( DWORD dwRank = dwLastRank; dwRank > 0; dwRank-- )
			{
				// loop thru all the processes and terminate
				for ( LONG lIndex = 0; lIndex < (LONG) dwTasksCount; lIndex++ )
				{
					// get the record
					m_arrRecord = (TARRAY) DynArrayItem( arrTasks, lIndex );
					if ( m_arrRecord == NULL )
						continue;
					
					// check the rank
					dwTemp = DynArrayItemAsDWORD( m_arrRecord, TASK_RANK );
					if ( dwTemp != dwRank )
					{
						// OPTIMIZATION:
						// ------------
						//    check the rank. if the rank is zero, delete this task from the list
						//    this improves the performance when we run for the next loop
						if ( dwTemp == 0 )
						{
							DynArrayRemove( arrTasks, lIndex );
							lIndex--;
							dwTasksCount--;
						}
						
						// skip this task
						continue;			
					}
					
					// get the process id and its parent process id
					m_dwProcessId = DynArrayItemAsDWORD( m_arrRecord, TASK_PID );
					dwParentProcessId = DynArrayItemAsDWORD( m_arrRecord, TASK_CREATINGPROCESSID );
					
					// ensure that there are no child for this process
					// NOTE: Termination of some childs might have failed ( this is needed only if -f is not specified )
					if ( m_bForce == FALSE )
					{
						lTemp = DynArrayFindDWORDEx( arrTasks, TASK_CREATINGPROCESSID, m_dwProcessId );
						if ( lTemp != -1 )
						{
							// set the reason 
							SetReason( ERROR_TASK_HAS_CHILDS );

							// format the error message
							str.Format( ERROR_TREE_KILL_FAILED, m_dwProcessId, dwParentProcessId, GetReason() );

							// show the message
							ShowMessage( stderr, str );

							// skip this
							continue;
						}
					}
					
					// kill the current task
					bQueued = FALSE;
					if ( this->Kill( bQueued ) == TRUE )
					{
						dwKilled++;		// updated killed processes counter
						
						// prepare the error message
						str.Format( MSG_TREE_KILL_SUCCESS, m_dwProcessId, dwParentProcessId );
						
						// remove the current task entry from the list and update the indexes accordingly
						DynArrayRemove( arrTasks, lIndex );
						lIndex--;
						dwTasksCount--;
						
						// show the message
						ShowMessage( stdout, str );
					}
					else
					{
						// prepare the error message
						str.Format( ERROR_TREE_KILL_FAILED, m_dwProcessId, dwParentProcessId, GetReason() );
						
						// show the message
						ShowMessage( stderr, str );
					}
				}
			}

			// reset the value of m_arrRecord
			m_arrRecord = NULL;

			// determine the exit code
			if ( dwTasksCount == dwCount )
				dwExitCode = 255;			// not even one task got terminated
			else if ( dwTasksToKill != 0 || dwTasksCount != 0 )
				dwExitCode = 128;			// tasks were terminated partially
		}
		//
		// SPECIAL HANDLING FOR TREE TERMINATION ENDS HERE
		// 
	}
	catch( ... )
	{
		SetLastError( E_OUTOFMEMORY );
		ShowLastError( stderr );
		return 255;
	}

	// free the memory
	DESTROY_ARRAY( arrTasks );
	DESTROY_ARRAY( arrImageNames );

	// final check-up ... 
	if ( dwCount == 0 && ( dwTasksToKill == 0 || m_bFiltersOptimized || dwFilters != 0 ) )
	{
		dwExitCode = 0;
		ShowMessage( stdout, ERROR_NO_PROCESSES );		// no tasks were found
	}
	else if ( dwTasksToKill != 0 )
	{
		// some processes which are requested to kill are not found
		LPCWSTR pwszTemp = NULL;
		for( DWORD dw = 0; dw < dwTasksToKill; dw++ )
		{
			// get the task name
			pwszTemp = DynArrayItemAsString( m_arrTasksToKill, dw );
			if ( pwszTemp == NULL )
				continue;					// skip

			// prepare and display message ...
			str.Format( ERROR_PROCESS_NOTFOUND, pwszTemp );
			ShowMessage( stderr, str );
		}

		// exit code
		dwExitCode = 128;
	}

	// return 
	return TRUE;
}

// ***************************************************************************
// Routine Description:
//		Invokes the appropriate kill function based on the mode of termination
//		  
// Arguments:
//		[ in ] bForce		: mode of termination (silent/force)
//
// Return Value:
//		TRUE upon successfull and FALSE if failed
// ***************************************************************************
inline BOOL CTaskKill::Kill( BOOL& bQueued )
{
	// local variables
	BOOL bResult = FALSE;

	// check whether task can be terminated or not
	if ( CanTerminate() == FALSE )
		return FALSE;

	// check whether local system / remote system
	bQueued = FALSE;
	if ( m_bLocalSystem == TRUE )
	{
		//
		// process termination on local system

		// based on the mode of termination invoke appropriate method
		if ( m_bForce == FALSE )
			bResult = KillProcessOnLocalSystem( bQueued );
		else
			bResult = ForciblyKillProcessOnLocalSystem();
	}
	else
	{
		//
		// process termination on remote system

		// silent termination of the process on a remote system is not supported
		// it will be always forcible termination
		bResult = ForciblyKillProcessOnRemoteSystem();
	}

	// inform the result
	return bResult;
}

// ***************************************************************************
// Routine Description:
//		Terminates the process in silence mode ... by posting WM_CLOSE message 
//		this is for local system only
//		  
// Arguments:
//		NONE
//
// Return Value:
//		TRUE upon successfull and FALSE if failed
// ***************************************************************************
BOOL CTaskKill::KillProcessOnLocalSystem( BOOL& bQueued )
{
	// local variables
	HDESK hDesk = NULL;
	HDESK hdeskSave = NULL;
	HWINSTA hWinSta = NULL;
	HWINSTA hwinstaSave = NULL;
	HANDLE hProcess = NULL;
	
	// variables which contains data
	HWND hWnd = NULL;
	LPCWSTR pwszDesktop = NULL;
	LPCWSTR pwszWindowStation = NULL;

	// clear the reason
	SetReason( NULL_STRING );

	// get the window station and desktop information
	hWnd = ( HWND ) DynArrayItemAsHandle( m_arrRecord, TASK_HWND );
	pwszDesktop = DynArrayItemAsString( m_arrRecord, TASK_DESK );
	pwszWindowStation = DynArrayItemAsString( m_arrRecord, TASK_WINSTA );

	// check whether window window handle exists for this process or not if not, return 
	if ( hWnd == NULL )
	{
		SetLastError( CO_E_NOT_SUPPORTED );
		SetReason( ERROR_CANNOT_KILL_SILENTLY );
		return FALSE;
	}

	// get and save the current window station and desktop
	hwinstaSave = GetProcessWindowStation();
	hdeskSave = GetThreadDesktop( GetCurrentThreadId() );

	// open current tasks window station and change the context to the new workstation
	if ( pwszWindowStation != NULL )
	{
		//
		// process has window station ... get it
		hWinSta = OpenWindowStation( pwszWindowStation, 
			FALSE, WINSTA_ENUMERATE | WINSTA_ENUMDESKTOPS );
		if ( hWinSta == NULL )
		{
			// failed in getting the process window station
			SaveLastError();
			return FALSE;
		}
		else
		{
			// change the context to the new workstation
			if ( hWinSta != hwinstaSave && SetProcessWindowStation( hWinSta ) == FALSE )
			{
				// failed in changing the context
				SaveLastError();
				return FALSE;
			}
		}
	}

	// open the tasks desktop and change the context to the new desktop
	if ( pwszDesktop != NULL )
	{
		//
		// process has desktop ... get it
		hDesk = OpenDesktop( pwszDesktop, 0, FALSE, DESKTOP_ENUMERATE );
		if ( hDesk == NULL )
		{
			// failed in getting the process desktop
			SaveLastError();
			return FALSE;
		}
		else
		{
			// change the context to the new desktop
			if ( hDesk != hdeskSave && SetThreadDesktop( hDesk ) == FALSE )
			{
				// failed in changing the context
				SaveLastError();
				// ?? return FALSE; - has to be uncommented
			}
		}
	}

	// atlast ... now kill the process
	if ( hWnd != NULL && PostMessage( hWnd, WM_CLOSE, 0, 0 ) == FALSE )
	{
		// failed in posting the message
		SaveLastError();
		return FALSE;
	}

	// restore the previous desktop
	if ( hDesk != NULL && hDesk != hdeskSave )
	{
		SetThreadDesktop( hdeskSave );
		CloseDesktop( hDesk );
	}

	// restore the context to the previous window station
	if ( hWinSta != NULL && hWinSta != hwinstaSave )
	{
		SetProcessWindowStation( hwinstaSave );
		CloseWindowStation( hWinSta );
	}

	// before return from this function check if process is terminated 
	// or queued for termination
	bQueued = FALSE;
	hProcess = OpenProcess( PROCESS_QUERY_INFORMATION, FALSE, m_dwProcessId );
	if ( hProcess != NULL )
	{
		//
		// process might be in queue for termination

		// get the state of the process
		DWORD dwExitCode = 0;
		if ( GetExitCodeProcess( hProcess, &dwExitCode ) == TRUE && dwExitCode == STILL_ACTIVE )
			bQueued = TRUE;		// process is in queue

		// close the handle to the process
		CloseHandle( hProcess );
	}

	// inform success
	return TRUE;
}

// ***************************************************************************
// Routine Description:
//		Terminates the process forcibly ... this is for local system only
//		  
// Arguments:
//		NONE
//
// Return Value:
//		TRUE upon successfull and FALSE if failed
// ***************************************************************************
BOOL CTaskKill::ForciblyKillProcessOnLocalSystem()
{
	// local variables
	DWORD dwExitCode = 0;
	HANDLE hProcess = NULL;

	// get the handle to the process using the process id
	hProcess = OpenProcess( 
		PROCESS_TERMINATE | PROCESS_QUERY_INFORMATION, FALSE, m_dwProcessId );

	// check whether we got the handle successfully or not ... if not error
	if ( hProcess == NULL )
	{
		// failed in getting the process handle ... may be process might have finished
		// there is one occassion in which, we get the last error as invalid parameter
		// 'coz it doesn't convey proper message to the user, we will check for that error
		// and change the message appropriately
		if ( GetLastError() == ERROR_INVALID_PARAMETER )
			SetLastError( CO_E_NOT_SUPPORTED );

		// save the error message
		SaveLastError();

		// return failure
		return FALSE;
	}

	// get the state of the process
	if ( GetExitCodeProcess( hProcess, &dwExitCode ) == FALSE )
	{
		// unknow error has occured ... failed
		CloseHandle( hProcess );			// close the process handle
		SaveLastError();
		return FALSE;
	}

	// now check whether the process is active or not
	if ( dwExitCode != STILL_ACTIVE )
	{
		// process is not active ... it is already terminated
		CloseHandle( hProcess );			// close the process handle
		SetLastError( SCHED_E_TASK_NOT_RUNNING );
		SaveLastError();
		return FALSE;
	}

	// now forcibly try to terminate the process ( exit code will be 1 )
	if ( TerminateProcess( hProcess, 1 ) == FALSE )
	{
		// failed in terminating the process
		CloseHandle( hProcess );			// close the process handle
	
		// there is one occassion in which, we get the last error as invalid parameter
		// 'coz it doesn't convey proper message to the user, we will check for that error
		// and change the message appropriately
		if ( GetLastError() == ERROR_INVALID_PARAMETER )
			SetLastError( CO_E_NOT_SUPPORTED );

		// save the error message
		SaveLastError();

		// return failure
		return FALSE;
	}

	// successfully terminated the process with exit code 1
	CloseHandle( hProcess );			// close the process handle
	return TRUE;						// inform success
}

// ***************************************************************************
// Routine Description:
//		Terminates the process forcibly ... uses WMI for terminating
//		this is for remote system
//		  
// Arguments:
//		NONE
//
// Return Value:
//		TRUE upon successfull and FALSE if failed
// ***************************************************************************
BOOL CTaskKill::ForciblyKillProcessOnRemoteSystem()
{
	// local variables
	HRESULT hr;
	_variant_t varTemp;
	BOOL bResult = FALSE;
	LPCWSTR pwszPath = NULL;
	IWbemClassObject* pInParams = NULL;
	IWbemClassObject* pOutParams = NULL;
	IWbemCallResult* pCallResult = NULL;

	// get the object path
	pwszPath = DynArrayItemAsString( m_arrRecord, TASK_OBJPATH );
	if ( pwszPath == NULL )
	{
		SetLastError( STG_E_UNKNOWN );
		SaveLastError();
		return FALSE;
	}

	try
	{
		// create an instance for input parameters
		SAFE_EXECUTE( m_pWbemTerminateInParams->SpawnInstance( 0, &pInParams ) );

		// set the reason ( abnormal termination )
		varTemp = 1L;
		SAFE_EXECUTE( PropertyPut( pInParams, TERMINATE_INPARAM_REASON, varTemp ) );

		// now execute the method ( semi-synchronous call )
		SAFE_EXECUTE( m_pWbemServices->ExecMethod( 
			_bstr_t( pwszPath ), _bstr_t( WIN32_PROCESS_METHOD_TERMINATE ), 
			WBEM_FLAG_RETURN_IMMEDIATELY, NULL, pInParams, NULL, &pCallResult ) );

		// set security info to the interface
		SAFE_EXECUTE( SetInterfaceSecurity( pCallResult, m_pAuthIdentity ) );

		// keep on retring until we get the control or tries reached max
		LONG lStatus = 0;
		for	( DWORD dw = 0; dw < MAX_TIMEOUT_RETRIES; dw++ )
		{
			// get the call status
			hr = pCallResult->GetCallStatus( 0, &lStatus );
			if ( SUCCEEDED( hr ) )
				break;
			else if ( hr == WBEM_S_TIMEDOUT )
				continue;
			else if ( FAILED( hr ) )
				_com_issue_error( hr );
		}

		// check if time out max. retries finished
		if ( dw == MAX_TIMEOUT_RETRIES )
			_com_issue_error( hr );

		// now get the result object
		SAFE_EXECUTE( pCallResult->GetResultObject( MAX_TERMINATE_TIMEOUT, &pOutParams ) );

		// get the return value of the result object
		DWORD dwReturnValue = 0;
		if ( PropertyGet( pOutParams, WMI_RETURNVALUE, dwReturnValue ) == FALSE )
			_com_issue_error( ERROR_INTERNAL_ERROR );

		// now check the return value
		// if should be zero .. if not .. failed
		if ( dwReturnValue != 0 )
		{
			//
			// format the message and set the reason

			// frame the error error message depending on the error
			if ( dwReturnValue == 2 )
			{
				SetLastError( STG_E_ACCESSDENIED );
				SaveLastError();
			}
			else if ( dwReturnValue == 3 )
			{
				SetLastError( ERROR_DS_INSUFF_ACCESS_RIGHTS );
				SaveLastError();
			}
			else
			{
				CHString str;
				str.Format( ERROR_UNABLE_TO_TERMINATE, dwReturnValue );
				SetReason( str );
			}
		}
		else
		{
			// everything went successfully ... process terminated successfully
			bResult = TRUE;
		}
	}
	catch( _com_error& e )
	{
		// save the error message and mark as failure
		WMISaveError( e );
		bResult = FALSE;
	}

	// release the in and out params references
	SAFE_RELEASE( pInParams );
	SAFE_RELEASE( pOutParams );
	SAFE_RELEASE( pCallResult );

	// return the result
	return bResult;
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//		[ out ] dwMatchTaskToKill	: 
//
// Return Value:
// ***************************************************************************
LONG CTaskKill::MatchTaskToKill( DWORD& dwMatchedIndex )
{
	// local variables
	LONG lCount = 0;
	DWORD dwLength = 0;
	LPCWSTR pwsz = NULL;
	LPCWSTR pwszTask = NULL;

	// check if this task has to be killed or not
	lCount = DynArrayGetCount( m_arrTasksToKill );
	for( LONG lIndex = 0; lIndex < lCount; lIndex++ )
	{
		// get the task specified
		pwszTask = DynArrayItemAsString( m_arrTasksToKill, lIndex );
		if ( pwszTask == NULL )
			return -1;

		// check with process id first ( only if task is in numeric format )
		dwMatchedIndex = TASK_PID;
		if ( IsNumeric(pwszTask, 10, FALSE) && (m_dwProcessId == (DWORD) AsLong(pwszTask, 10)) )
			return lIndex;		// specified task matched with current process id

		// determine the no. of characters to compare
		dwLength = 0;
		pwsz = FindChar( pwszTask, L'*', 0 );
		if ( pwsz != NULL )
		{
			// '*' - wildcard is specified in the image name
			// so, determine the no. of characters to compare
			// but before that check the length of the string pointer from '*'
			// it should be 1 - meaning the '*' can be specified only at the end
			// but not in the middle
			if ( lstrlen( pwsz ) == 1 )
			{
				dwLength = lstrlen( pwszTask ) - lstrlen( pwsz );
			}
		}
		
		// check with image name
		dwMatchedIndex = TASK_IMAGENAME;
		if ( StringCompare( m_strImageName, pwszTask, TRUE, dwLength ) == 0 )
			return lIndex;		// specified task mathed with the image name
	}

	// return the index
	return -1;
}

// ***************************************************************************
// Routine Description:
//		Invokes the appropriate kill function based on the mode of termination
//		  
// Arguments:
//		[ in ] bForce		: mode of termination (silent/force)
//
// Return Value:
//		TRUE upon successfull and FALSE if failed
// ***************************************************************************
BOOL CTaskKill::CanTerminate()
{
	// local variables
	DWORD dw = 0;
	DWORD dwCount = 0;
	LPCWSTR pwszTaskToTerminate = NULL;

	//
	// prepare a list of os critical tasks
	LPCWSTR pwszTasks[] = {
		PROCESS_CSRSS_EXE, 
		PROCESS_SMSS_EXE,
		PROCESS_SERVICES_EXE,
		PROCESS_WINLOGON_EXE
	};

	// process id with 0 cannot be terminated
	if ( m_dwProcessId == 0 )
	{
		SetReason( ERROR_CRITICAL_SYSTEM_PROCESS );
		return FALSE;		// task should not be terminated
	}

	// the process cannot be terminated itself
	if ( m_dwProcessId == m_dwCurrentPid )
	{
		SetReason( ERROR_CANNOT_KILL_ITSELF );
		return FALSE;
	}

	// get the task name which user is trying to terminate
	pwszTaskToTerminate = DynArrayItemAsString( m_arrRecord, TASK_IMAGENAME );
	if ( pwszTaskToTerminate == NULL )
	{
		SetLastError( STG_E_UNKNOWN );
		SaveLastError();
		return FALSE;		// task should not be terminated
	}

	// check if user is trying to terminate the os critical task
	dwCount = SIZE_OF_ARRAY( pwszTasks );
	for( dw = 0; dw < dwCount; dw++ )
	{
		if ( StringCompare( pwszTasks[ dw ], pwszTaskToTerminate, TRUE, 0 ) == 0 )
		{
			SetReason( ERROR_CRITICAL_SYSTEM_PROCESS );
			return FALSE;		// task should not be terminated
		}
	}

	// task can be terminated
	return TRUE;
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
//		Process id as DWORD
// 
// ***************************************************************************
VOID CTaskKill::SaveData( IWbemClassObject* pWmiObject )
{
	// local variables
	CHString str;
	DWORD dwValue = 0;

	// process id
	PropertyGet( pWmiObject, WIN32_PROCESS_PROPERTY_PROCESSID, m_dwProcessId );
	DynArraySetDWORD( m_arrRecord, TASK_PID, m_dwProcessId );

	// image name
	PropertyGet( pWmiObject, WIN32_PROCESS_PROPERTY_IMAGENAME, m_strImageName );
	DynArraySetString( m_arrRecord, TASK_IMAGENAME, m_strImageName, 0 );

	// object path
	PropertyGet( pWmiObject, WIN32_PROCESS_SYSPROPERTY_PATH, str );
	DynArraySetString( m_arrRecord, TASK_OBJPATH, str, 0 );

	// host name
	PropertyGet( pWmiObject, WIN32_PROCESS_PROPERTY_COMPUTER, str );
	DynArraySetString( m_arrRecord, TASK_HOSTNAME, str, 0 );

	// parent process id
	PropertyGet( pWmiObject, WIN32_PROCESS_PROPERTY_PARENTPROCESSID, dwValue, 0 );
	DynArraySetDWORD( m_arrRecord, TASK_CREATINGPROCESSID, dwValue );

	// user context
	SetUserContext( pWmiObject );

	// cpu time
	SetCPUTime( pWmiObject );

	// window title
	SetWindowTitle( pWmiObject );

	// services
	SetServicesInfo( pWmiObject );

	// modules
	SetModulesInfo( pWmiObject );

	// check if the tree termination is requested
	if ( m_bTree == TRUE )
	{
		// session id
		PropertyGet( pWmiObject, WIN32_PROCESS_PROPERTY_SESSION, dwValue,  0 );
		DynArraySetDWORD( m_arrRecord, TASK_SESSION, dwValue );
	
		// status
		SetStatus( pWmiObject );

		// mem usage
		SetMemUsage( pWmiObject );
	}
	else
	{
		//
		// status, session id, memory usage
		// property retrieval is built into WMI
		//
	}
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
VOID CTaskKill::SetUserContext( IWbemClassObject* pWmiObject )
{
	// local variables
	HRESULT hr;
	CHString str;
	CHString strPath;
	CHString strDomain;
	CHString strUserName;
	IWbemClassObject* pOutParams = NULL;

	// check if user name has to be retrieved or not
	if ( m_bNeedUserContextInfo == FALSE )
		return;

	//
	// for getting the user first we will try with API
	// it at all API fails, we will try to get the same information from WMI
	//

	// get the user name
	if ( LoadUserNameFromWinsta( strDomain, strUserName ) == TRUE )
	{
		// format the user name
		str.Format( L"%s\\%s", strDomain, strUserName );
	}
	else
	{
		try
		{
			// user name has to be retrieved - get the path of the current object
			hr = PropertyGet( pWmiObject, WIN32_PROCESS_SYSPROPERTY_PATH, strPath );
			if ( FAILED( hr ) || strPath.GetLength() == 0 )
				return;
			
			// execute the GetOwner method and get the user name
			// under which the current process is executing
			hr = m_pWbemServices->ExecMethod( _bstr_t( strPath ), 
				_bstr_t( WIN32_PROCESS_METHOD_GETOWNER ), 0, NULL, NULL, &pOutParams, NULL );
			if ( FAILED( hr ) )
				return;
			
			// get the domain and user values from out params object
			// NOTE: do not check the results
			PropertyGet( pOutParams, GETOWNER_RETURNVALUE_DOMAIN, strDomain, L"" );
			PropertyGet( pOutParams, GETOWNER_RETURNVALUE_USER, strUserName, L"" );
			
			// get the value
			if ( strDomain.GetLength() != 0 )
				str.Format( L"%s\\%s", strDomain, strUserName );
			else if ( strUserName.GetLength() != 0 )
				str = strUserName;
		}
		catch( ... )
		{
			return;
		}
	}

	// save the info
	DynArraySetString( m_arrRecord, TASK_USERNAME, str, 0 );
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
VOID CTaskKill::SetCPUTime( IWbemClassObject* pWmiObject )
{
	// local variables
	CHString str;
	ULONGLONG ullCPUTime = 0;
	ULONGLONG ullUserTime = 0;
	ULONGLONG ullKernelTime = 0;

 	// get the KernelModeTime value
	PropertyGet( pWmiObject, WIN32_PROCESS_PROPERTY_KERNELMODETIME, ullKernelTime );

	// get the user mode time
	PropertyGet( pWmiObject, WIN32_PROCESS_PROPERTY_USERMODETIME, ullUserTime );

	// calculate the CPU time
	ullCPUTime = ullUserTime + ullKernelTime;

	// now convert the long time into hours format
	TIME_FIELDS time;
    RtlTimeToElapsedTimeFields ( (LARGE_INTEGER* ) &ullCPUTime, &time );

	// convert the days into hours
    time.Hour = static_cast<CSHORT>( time.Hour + static_cast<SHORT>( time.Day * 24 ) );
    
	// prepare into time format ( user locale specific time seperator )
	str.Format( L"%d:%02d:%02d", time.Hour, time.Minute, time.Second );

	// save the info
	DynArraySetString( m_arrRecord, TASK_CPUTIME, str, 0 );
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
VOID CTaskKill::SetWindowTitle( IWbemClassObject* pWmiObject )
{
	// local variables
	LONG lTemp = 0;
	HWND hWnd = NULL;
	LPCTSTR pszTemp = NULL;

	// get the window details ... window station, desktop, window title
	// NOTE: This will work only for local system
	lTemp = DynArrayFindDWORDEx( m_arrWindowTitles, CTaskKill::twiProcessId, m_dwProcessId );
	if ( lTemp != -1 )
	{
		// save the window title
		pszTemp = DynArrayItemAsString2( m_arrWindowTitles, lTemp, CTaskKill::twiTitle );
		if ( pszTemp != NULL )
			DynArraySetString( m_arrRecord, TASK_WINDOWTITLE, pszTemp, 0 );

		// save the window station
		pszTemp = DynArrayItemAsString2( m_arrWindowTitles, lTemp, CTaskKill::twiWinSta );
		if ( pszTemp != NULL )
			DynArraySetString( m_arrRecord, TASK_WINSTA, pszTemp, 0 );

		// save the desktop information
		pszTemp = DynArrayItemAsString2( m_arrWindowTitles, lTemp, CTaskKill::twiDesktop );
		if ( pszTemp != NULL )
			DynArraySetString( m_arrRecord, TASK_DESK, pszTemp, 0 );

		// save the window handle also
		hWnd = (HWND) DynArrayItemAsHandle2( m_arrWindowTitles, lTemp, CTaskKill::twiHandle );
		if ( hWnd != NULL )
			DynArraySetHandle( m_arrRecord, TASK_HWND, hWnd );
	}
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
VOID CTaskKill::SetStatus( IWbemClassObject* pWmiObject )
{
	// local variables
	DWORD dwThreads = 0;

	// get the threads count for the process
	if ( PropertyGet( pWmiObject, WIN32_PROCESS_PROPERTY_THREADS, dwThreads ) == FALSE )
		return;

	// now determine the status
	if ( dwThreads > 0 )
		DynArraySetString( m_arrRecord, TASK_STATUS, VALUE_RUNNING, 0 );
	else
		DynArraySetString( m_arrRecord, TASK_STATUS, VALUE_NOTRESPONDING, 0 );
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
VOID CTaskKill::SetMemUsage( IWbemClassObject* pWmiObject )
{
	// local variables
	CHString str;
	NTSTATUS ntstatus;
	ULONGLONG ullMemUsage = 0;
	LARGE_INTEGER liTemp = { 0, 0 };
	CHAR szTempBuffer[ 33 ] = "\0";

	try
	{
		// NOTE:
		// ----
		// The max. value of 
		// (2 ^ 64) - 1 = "18,446,744,073,709,600,000 K"  (29 chars).
		// 
		// so, the buffer size to store the number is fixed as 32 characters 
		// which is more than the 29 characters in actuals
		
		// set the default value
		DynArraySetString( m_arrRecord, TASK_MEMUSAGE, L"0", 0 );
		
		// get the KernelModeTime value
		if ( PropertyGet( pWmiObject, WIN32_PROCESS_PROPERTY_MEMUSAGE, ullMemUsage ) == FALSE )
			return;
		
		// convert the value into K Bytes
		ullMemUsage /= 1024;
		
		// now again convert the value from ULONGLONG to string and check the result
		liTemp.QuadPart = ullMemUsage;
		ntstatus = RtlLargeIntegerToChar( &liTemp, 10, SIZE_OF_ARRAY( szTempBuffer ), szTempBuffer );
		if ( ! NT_SUCCESS( ntstatus ) )
			return;
		
		// now copy this info into UNICODE buffer
		str = szTempBuffer;
		
		// save the id
		DynArraySetString( m_arrRecord, TASK_MEMUSAGE, str, 0 );
	}
	catch( ... )
	{
		SetLastError( E_OUTOFMEMORY );
		SaveLastError();
	}
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
VOID CTaskKill::SetServicesInfo( IWbemClassObject* pWmiObject )
{
	// local variables
	HRESULT hr;
	CHString strQuery;
	CHString strService;
	ULONG ulReturned = 0;
	BOOL bResult = FALSE;
	BOOL bCanExit = FALSE;
	TARRAY arrServices = NULL;
	IEnumWbemClassObject* pEnumServices = NULL;
	IWbemClassObject* pObjects[ MAX_ENUM_SERVICES ];

	// check whether we need to gather services info or not .. if not skip
	if ( m_bNeedServicesInfo == FALSE )
		return;

	// create array
	arrServices = CreateDynamicArray();
	if ( arrServices == NULL )
	{
		SetLastError( E_OUTOFMEMORY );
		SaveLastError();
		return;
	}

	//
	// for getting the services info first we will try with the one we got from API
	// it at all API fails, we will try to get the same information from WMI
	//

	// check whether API returned services or not
	if ( m_pServicesInfo != NULL )
	{
		// get the service names related to the current process
		// identify all the services related to the current process ( based on the PID )
		// and save the info
		for ( DWORD dw = 0; dw < m_dwServicesCount; dw++ )
		{
			// compare the PID's
			if ( m_dwProcessId == m_pServicesInfo[ dw ].ServiceStatusProcess.dwProcessId )
			{
				// this service is related with the current process ... store service name
				DynArrayAppendString( arrServices, m_pServicesInfo[ dw ].lpServiceName, 0 );
			}
		}
	}
	else
	{
		try
		{
			// init the objects to NULL's
			for( DWORD dw = 0; dw < MAX_ENUM_SERVICES; dw++ )
				pObjects[ dw ] = NULL;
			
			// prepare the query
			strQuery.Format( WMI_SERVICE_QUERY, m_dwProcessId );
			
			// execute the query
			hr = m_pWbemServices->ExecQuery( _bstr_t( WMI_QUERY_TYPE ), _bstr_t( strQuery ), 
				WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY, NULL, &pEnumServices );
			
			// check the result
			if ( FAILED( hr ) )
				_com_issue_error( hr );
			
			// set the security
			hr = SetInterfaceSecurity( pEnumServices, m_pAuthIdentity );
			if ( FAILED( hr ) )
				_com_issue_error( hr );
			
			// loop thru the service instances 
			do
			{
				// get the object ... wait 
				// NOTE: one-by-one
				hr = pEnumServices->Next( WBEM_INFINITE, MAX_ENUM_SERVICES, pObjects, &ulReturned );
				if ( hr == WBEM_S_FALSE )
				{
					// we've reached the end of enumeration .. set the flag 
					bCanExit = TRUE;
				}
				else if ( hr == WBEM_S_TIMEDOUT || FAILED( hr ) )
				{
					//
					// some error has occured ... oooppps
			
					// exit from the loop
					break;
				}
			
				// loop thru the objects and save the info
				for( ULONG ul = 0; ul < ulReturned; ul++ )
				{
					// get the value of the property
					bResult = PropertyGet( pObjects[ ul ], WIN32_SERVICE_PROPERTY_NAME, strService );
					if (  bResult == TRUE )
						DynArrayAppendString( arrServices, strService, 0 );
			
					// release the interface
					SAFE_RELEASE( pObjects[ ul ] );
				}
			} while ( bCanExit == FALSE );
		}
		catch( _com_error& e )
		{
			// save the error
			WMISaveError( e );
		}

		// release the objects to NULL's
		for( DWORD dw = 0; dw < MAX_ENUM_SERVICES; dw++ )
		{
			// release all the objects
			SAFE_RELEASE( pObjects[ dw ] );
		}

		// now release the enumeration object
		SAFE_RELEASE( pEnumServices );
	}

	// save and return
	DynArraySetEx( m_arrRecord, TASK_SERVICES, arrServices );
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
BOOL CTaskKill::SetModulesInfo( IWbemClassObject* pWmiObject )
{
	// local variables
	LONG lPos = 0;
	BOOL bResult = FALSE;
	TARRAY arrModules = NULL;

	// check whether we need to get the modules or not
	if ( m_bNeedModulesInfo == FALSE )
		return TRUE;

	// allocate for memory
	arrModules = CreateDynamicArray();
	if ( arrModules == NULL )
	{
		SetLastError( E_OUTOFMEMORY );
		SaveLastError();
		return FALSE;
	}

	// the way we get the modules information is different for local remote
	// so depending that call appropriate function
	if ( m_bLocalSystem == TRUE && m_bUseRemote == FALSE )
	{
		// enumerate the modules for the current process
		bResult = LoadModulesOnLocal( arrModules );
	}
	else
	{
		// identify the modules information for the current process ... remote system
		bResult = GetModulesOnRemote( arrModules );
	}

	// check the result
	if ( bResult == TRUE )
	{
		// check if the modules list contains the imagename also. If yes remove that entry
		lPos = DynArrayFindString( arrModules, m_strImageName, TRUE, 0 );
		if ( lPos != -1 )
		{
			// remove the entry
			DynArrayRemove( arrModules, lPos );
		}
	}

	// save the modules information to the array
	// NOTE: irrespective of whether enumeration is success or not we will add the array
	DynArraySetEx( m_arrRecord, TASK_MODULES, arrModules );

	// return
	return bResult;
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
BOOL CTaskKill::LoadModulesOnLocal( TARRAY arrModules )
{
	// local variables
	LONG lPos = 0;
	BOOL bResult = FALSE;
	HANDLE hProcess = NULL;

	// check the input values
	if ( arrModules == NULL )
		return FALSE;

	// open the process handle
	hProcess = OpenProcess( PROCESS_VM_READ | PROCESS_QUERY_INFORMATION, FALSE, m_dwProcessId );
	if ( hProcess == NULL )
	{
		// failed in getting the process handle
		return FALSE;
	}

#ifndef _WIN64
	bResult = EnumerateLoadedModules( hProcess, EnumLoadedModulesProc, arrModules );
#else
	bResult = EnumerateLoadedModules64( hProcess, EnumLoadedModulesProc64, arrModules );
#endif

	// close the process handle .. we dont need this furthur
	CloseHandle( hProcess );
	hProcess = NULL;

	// return
	return bResult;
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
BOOL CTaskKill::GetModulesOnRemote( TARRAY arrModules )
{
	// local variables
	LONG lPos = 0;
	DWORD dwLength = 0;
	DWORD dwOffset = 0;
	DWORD dwInstance = 0;
	PPERF_OBJECT_TYPE pot = NULL;
	PPERF_OBJECT_TYPE potImages = NULL;
	PPERF_INSTANCE_DEFINITION pidImages = NULL;
	PPERF_COUNTER_BLOCK pcbImages = NULL;
	PPERF_OBJECT_TYPE potAddressSpace = NULL;
	PPERF_INSTANCE_DEFINITION pidAddressSpace = NULL;
	PPERF_COUNTER_BLOCK pcbAddressSpace = NULL;
    PPERF_COUNTER_DEFINITION pcd = NULL;

	// check the input values
	if ( arrModules == NULL )
		return FALSE;

	// check whether the performance object exists or not
	// if doesn't exists, get the same using WMI
	if ( m_pdb == NULL )
	{
		// invoke the WMI method
		return GetModulesOnRemoteEx( arrModules );
	}

	// get the perf object types
    pot = (PPERF_OBJECT_TYPE) ( (LPBYTE) m_pdb + m_pdb->HeaderLength );
	for( DWORD dw = 0; dw < m_pdb->NumObjectTypes; dw++ )
	{
		if ( pot->ObjectNameTitleIndex == 740 )
			potImages = pot;
		else if ( pot->ObjectNameTitleIndex == 786 )
			potAddressSpace = pot;

		// move to the next object
		dwOffset = pot->TotalByteLength;
		if( dwOffset != 0 )
			pot = ( (PPERF_OBJECT_TYPE) ((PBYTE) pot + dwOffset));
	}

	// check whether we got both the object types or not
	if ( potImages == NULL || potAddressSpace == NULL )
		return FALSE;

	// find the offset of the process id in the address space object type
    // get the first counter definition of address space object
    pcd = (PPERF_COUNTER_DEFINITION) ( (LPBYTE) potAddressSpace + potAddressSpace->HeaderLength);

	// loop thru the counters and find the offset
	dwOffset = 0;
    for( DWORD dw = 0; dw < potAddressSpace->NumCounters; dw++)
    {
        // 784 is the counter for process id
        if ( pcd->CounterNameTitleIndex == 784 )
        {
            dwOffset = pcd->CounterOffset;
            break;
        }

        // next counter
        pcd = ( (PPERF_COUNTER_DEFINITION) ( (LPBYTE) pcd + pcd->ByteLength) );
    }

	// check whether we got the offset or not
	// if not, we are unsuccessful
	if ( dwOffset == 0 )
	{
		// set the error message
		SetLastError( ERROR_ACCESS_DENIED );
		SaveLastError();
		return FALSE;
	}

	// get the instances
	pidImages = (PPERF_INSTANCE_DEFINITION) ( (LPBYTE) potImages + potImages->DefinitionLength );
	pidAddressSpace = (PPERF_INSTANCE_DEFINITION) ( (LPBYTE) potAddressSpace + potAddressSpace->DefinitionLength );

	// counter blocks
	pcbImages = (PPERF_COUNTER_BLOCK) ( (LPBYTE) pidImages + pidImages->ByteLength );
	pcbAddressSpace = (PPERF_COUNTER_BLOCK) ( (LPBYTE) pidAddressSpace + pidAddressSpace->ByteLength );

	// find the instance number of the process which we are looking for
	for( dwInstance = 0; dwInstance < (DWORD) potAddressSpace->NumInstances; dwInstance++ )
	{
		// sub-local variables
		DWORD dwProcessId = 0;

		// get the process id
		dwProcessId = *((DWORD*) ( (LPBYTE) pcbAddressSpace + dwOffset ));

		// now check if this is the process which we are looking for
		if ( dwProcessId == m_dwProcessId )
			break;

		// continue looping thru other instances
		pidAddressSpace = (PPERF_INSTANCE_DEFINITION) ( (LPBYTE) pcbAddressSpace + pcbAddressSpace->ByteLength );
		pcbAddressSpace = (PPERF_COUNTER_BLOCK) ( (LPBYTE) pidAddressSpace + pidAddressSpace->ByteLength );
	}

	// check whether we got the instance or not
	// if not, there are no modules for this process
	if ( dwInstance == potAddressSpace->NumInstances )
		return TRUE;

	// now based the parent instance, collect all the modules
    for( DWORD dw = 0; (LONG) dw < potImages->NumInstances; dw++)
    {
		// check the parent object instance number
		if ( pidImages->ParentObjectInstance == dwInstance )
		{
			try
			{
				// sub-local variables
				CHString str;
				LPWSTR pwszTemp;

				// get the buffer
				pwszTemp = str.GetBufferSetLength( pidImages->NameLength + 10 );		// +10 to be on safe side
				if ( pwszTemp == NULL )
				{
					SetLastError( E_OUTOFMEMORY );
					SaveLastError();
					return FALSE;
				}

				// get the instance name
				lstrcpyn( pwszTemp, (LPWSTR) ( (LPBYTE) pidImages + pidImages->NameOffset ), pidImages->NameLength + 1 );

				// release buffer
				str.ReleaseBuffer();

				// add the info the userdata ( for us we will get that in the form of an array
				LONG lIndex = DynArrayAppendString( arrModules, str, 0 );
				if ( lIndex == -1 )
				{
					// append is failed .. this could be because of lack of memory .. stop the enumeration
					return FALSE;
				}
			}
			catch( ... )
			{
				SetLastError( E_OUTOFMEMORY );
				SaveLastError();
				return FALSE;
			}
		}

		// continue looping thru other instances
		pidImages = (PPERF_INSTANCE_DEFINITION) ( (LPBYTE) pcbImages + pcbImages->ByteLength );
		pcbImages = (PPERF_COUNTER_BLOCK) ( (LPBYTE) pidImages + pidImages->ByteLength );
    }

    return TRUE;
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
BOOL CTaskKill::GetModulesOnRemoteEx( TARRAY arrModules )
{
	// local variables
	HRESULT hr;
	BOOL bStatus = FALSE;
	CHString strQuery;
	CHString strModule;
	CHString strMessage;
	CHString strFileName;
	CHString strExtension;
	ULONG ulReturned = 0;
	BOOL bResult = FALSE;
	BOOL bCanExit = FALSE;
	LPCWSTR pwszPath = NULL;
	IEnumWbemClassObject* pEnumModules = NULL;
	IWbemClassObject* pObjects[ MAX_ENUM_MODULES ];

	// check the input values
	if ( arrModules == NULL )
		return FALSE;

	// get the path of the object from the tasks array
	pwszPath = DynArrayItemAsString( m_arrRecord, TASK_OBJPATH );
	if ( pwszPath == NULL )
		return FALSE;

	//determine the length of the module name .. 
	try
	{
		// init the objects to NULL's
		for( DWORD dw = 0; dw < MAX_ENUM_MODULES; dw++ )
			pObjects[ dw ] = NULL;
		
		// prepare the query
		strQuery.Format( WMI_MODULES_QUERY, pwszPath );

		// preare and display the status message
		bStatus = TRUE;
		strMessage.Format( MSG_MODULESINFO_EX, m_dwProcessId );
		PrintProgressMsg( m_hOutput, strMessage + L" --", m_csbi );
		
		// execute the query
		hr = m_pWbemServices->ExecQuery( _bstr_t( WMI_QUERY_TYPE ), _bstr_t( strQuery ), 
			WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY, NULL, &pEnumModules );
		
		// check the result
		if ( FAILED( hr ) )
			_com_issue_error( hr );
		
		// set the security
		hr = SetInterfaceSecurity( pEnumModules, m_pAuthIdentity );
		if ( FAILED( hr ) )
			_com_issue_error( hr );
		
		// loop thru the instances 
		do
		{
			// get the object ... wait 
			// NOTE: one-by-one
			hr = pEnumModules->Next( WBEM_INFINITE, MAX_ENUM_MODULES, pObjects, &ulReturned );
			if ( hr == WBEM_S_FALSE )
			{
				// we've reached the end of enumeration .. set the flag 
				bCanExit = TRUE;
			}
			else if ( hr == WBEM_S_TIMEDOUT || FAILED( hr ))
			{
				// some error has occured ... oooppps
				WMISaveError( hr );
				SetLastError( STG_E_UNKNOWN );
				break;
			}

			// reset the counter
			bStatus = bStatus ? FALSE : TRUE;
			PrintProgressMsg( m_hOutput, strMessage + (( bStatus ) ? L" --" : L" |"), m_csbi );

			// loop thru the objects and save the info
			for( ULONG ul = 0; ul < ulReturned; ul++ )
			{
				// get the file name
				bResult = PropertyGet( pObjects[ ul ], CIM_DATAFILE_PROPERTY_FILENAME, strFileName );
				if ( bResult == FALSE )
					continue;

				// get the extension
				bResult = PropertyGet( pObjects[ ul ], CIM_DATAFILE_PROPERTY_EXTENSION, strExtension );
				if ( bResult == FALSE )
					continue;

				// format the module name
				strModule.Format( L"%s.%s", strFileName, strExtension );

				// add the info the userdata ( for us we will get that in the form of an array
				LONG lIndex = DynArrayAppendString( arrModules, strModule, 0 );
				if ( lIndex == -1 )
				{
					// append is failed .. this could be because of lack of memory .. stop the enumeration
					PrintProgressMsg( m_hOutput, NULL, m_csbi );
					return FALSE;
				}

				// release the interface
				SAFE_RELEASE( pObjects[ ul ] );
			}
		} while ( bCanExit == FALSE );

		// erase the status message
		PrintProgressMsg( m_hOutput, NULL, m_csbi );
	}
	catch( _com_error& e )
	{
		// save the error
		WMISaveError( e );
		return FALSE;
	}
	catch( ... )
	{
		// out of memory
		WMISaveError( E_OUTOFMEMORY );
		return FALSE;
	}

	// release the objects to NULL's
	for( DWORD dw = 0; dw < MAX_ENUM_MODULES; dw++ )
	{
		// release all the objects
		SAFE_RELEASE( pObjects[ dw ] );
	}

	// now release the enumeration object
	SAFE_RELEASE( pEnumModules );

	// return 
    return TRUE;
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
#ifndef _WIN64
BOOL EnumLoadedModulesProc( LPSTR lpszModuleName, ULONG ulModuleBase, ULONG ulModuleSize, PVOID pUserData )
#else
BOOL EnumLoadedModulesProc64( LPSTR lpszModuleName, DWORD64 ulModuleBase, ULONG ulModuleSize, PVOID pUserData )
#endif
{
	// local variables
	CHString str;
	LONG lIndex = 0;
	TARRAY arrModules = NULL;

	// check the input values
	if ( lpszModuleName == NULL || pUserData == NULL )
		return FALSE;

	// get the array pointer into the local variable
	arrModules = (TARRAY) pUserData;

	try
	{
		// copy the module name into the local string variable 
		// ( conversion from multibyte to unicode will automatically take place )
		str = lpszModuleName;

		// add the info the userdata ( for us we will get that in the form of an array
		lIndex = DynArrayAppendString( arrModules, str, 0 );
		if ( lIndex == -1 )
		{
			// append is failed .. this could be because of lack of memory .. stop the enumeration
			return FALSE;
		}
	}
	catch( ... )
	{
			// out of memory stop the enumeration
			return FALSE;
	}

	// success .. continue the enumeration
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cmdline\kill\taskkill.cpp ===
// *********************************************************************************
// 
//  Copyright (c) Microsoft Corporation
//  
//  Module Name:
//  
//		TaskKill.cpp
//  
//  Abstract:
//  
// 		This module implements the termination of processes runnging on either local
//		or remote system
//
//		Syntax:
//		------
//			TaskKill.exe [ -s server [ -u username [ -p password ] ] ] [ -f ] [ -t ]
//				[ -fi filter ] [ -im imagename | -pid pid ]
//	
//  Author:
//  
// 		Sunil G.V.N. Murali (murali.sunil@wipro.com) 26-Nov-2000
//  
//  Revision History:
//  
// 		Sunil G.V.N. Murali (murali.sunil@wipro.com) 26-Nov-2000 : Created It.
//  
// *********************************************************************************

#include "pch.h"
#include "wmi.h"
#include "TaskKill.h"

//
// local structures
//
typedef struct __tagWindowTitles
{
	LPWSTR pwszDesk;
	LPWSTR pwszWinsta;
	BOOL bFirstLoop;
	TARRAY arrWindows;
} TWINDOWTITLES, *PTWINDOWTITLES;

//
// private functions ... prototypes
//
BOOL CALLBACK EnumWindowsProc( HWND hWnd, LPARAM lParam );
BOOL CALLBACK EnumDesktopsFunc( LPWSTR pwsz, LPARAM lParam );
BOOL CALLBACK EnumWindowStationsFunc( LPWSTR pwsz, LPARAM lParam );
BOOL CALLBACK EnumMessageWindows( WNDENUMPROC lpEnumFunc, LPARAM lParam );
BOOL GetPerfDataBlock( HKEY hKey, LPWSTR szObjectIndex, PPERF_DATA_BLOCK* ppdb );

// ***************************************************************************
// Routine Description:
//		This the entry point to this utility.
//		  
// Arguments:
//		[ in ] argc		: argument(s) count specified at the command prompt
//		[ in ] argv		: argument(s) specified at the command prompt
//
// Return Value:
//		The below are actually not return values but are the exit values 
//		returned to the OS by this application
//			0		: utility is successfull
//			1		: utility failed
// ***************************************************************************
DWORD __cdecl _tmain( DWORD argc, LPCTSTR argv[] )
{
	// local variables
	CTaskKill taskkill;
	BOOL bResult = FALSE;
	DWORD dwExitCode = 0;

	// initialize the taskkill utility
	if ( taskkill.Initialize() == FALSE )
	{
		CHString strBuffer;
		strBuffer.Format( L"%s %s", TAG_ERROR, GetReason() );
		ShowMessage( stderr, strBuffer );
		EXIT_PROCESS( 1 );
	}

	// now do parse the command line options
	if ( taskkill.ProcessOptions( argc, argv ) == FALSE )
	{
		CHString strBuffer;
		strBuffer.Format( L"%s %s", TAG_ERROR, GetReason() );
		ShowMessage( stderr, strBuffer );
		EXIT_PROCESS( 1 );
	}

	// check whether usage has to be displayed or not
	if ( taskkill.m_bUsage == TRUE )
	{
		// show the usage of the utility
		taskkill.Usage();

		// quit from the utility
		EXIT_PROCESS( 0 );
	}

	// now validate the filters and check the result of the filter validation
	if ( taskkill.ValidateFilters() == FALSE )
	{
		// invalid filter
		// SPECIAL:
		// -------
		//     for the custom filter "pid" we are setting the tag "INFO:" before
		//     the message in the filter validation part itself
		//     so, check and display
		FILE* fp = NULL;
		CHString strInfo;
		CHString strBuffer;

		// ...
		fp = stdout;
		dwExitCode = 255;			// info exit code
		strBuffer = GetReason();
		strInfo = TAG_INFORMATION;
		if ( strBuffer.Left( strInfo.GetLength() ) != strInfo )
		{
			fp = stderr;
			dwExitCode = 1;
			strBuffer.Format( L"%s %s", TAG_ERROR, GetReason() );
		}

		// display the message
		ShowMessage( fp, strBuffer );
		EXIT_PROCESS( dwExitCode );
	}

	// enable the kill privileges
	if ( taskkill.EnableDebugPriv() == FALSE )
	{
		// show the error message and exit
		CHString strBuffer;
		SaveLastError();
		strBuffer.Format( L"%s %s", TAG_ERROR, GetReason() );
		ShowMessage( stderr, strBuffer );
		EXIT_PROCESS( 1 );
	}

	// connect to the server
	bResult = taskkill.Connect();
	if ( bResult == FALSE )
	{
		// show the error message
		CHString strBuffer;
		strBuffer.Format( L"%s %s", TAG_ERROR, GetReason() );
		ShowMessage( stderr, strBuffer );
		EXIT_PROCESS( 1 );
	}

	// load the data and check
	bResult = taskkill.LoadTasks();
	if ( bResult == FALSE )
	{
		// show the error message
		CHString strBuffer;
		strBuffer.Format( L"%s %s", TAG_ERROR, GetReason() );
		ShowMessage( stderr, strBuffer );
		EXIT_PROCESS( 1 );
	}

	// invoke the actual termination and get the exit code
	bResult = taskkill.DoTerminate( dwExitCode );
	if ( bResult == FALSE )
	{
		// NOTE: the 'FALSE' return value indicates that some major problem has occured
		//       while trying to terminate the process. Still the exit code will be determined by 
		//       the function only. Do not change/set the exit code value
		CHString strBuffer;
		strBuffer.Format( L"%s %s", TAG_ERROR, GetReason() );
		ShowMessage( stderr, strBuffer );
	}

	// exit from the utility
	EXIT_PROCESS( dwExitCode );
}
	
// ***************************************************************************
// Routine Description:
//		connects to the remote as well as remote system's WMI
//		  
// Arguments:
//		NONE
//  
// Return Value:
//		TRUE  : if connection is successful
//		FALSE : if connection is unsuccessful
// 
// ***************************************************************************
BOOL CTaskKill::Connect()
{
	// local variables
	BOOL bResult = FALSE;

	// release the existing auth identity structure
	WbemFreeAuthIdentity( &m_pAuthIdentity );

	// connect to WMI
	bResult = ConnectWmiEx( m_pWbemLocator, 
		&m_pWbemServices, m_strServer, m_strUserName, m_strPassword, 
		&m_pAuthIdentity, m_bNeedPassword, WMI_NAMESPACE_CIMV2, &m_bLocalSystem );

	// check the result of connection
	if ( bResult == FALSE )
		return FALSE;

#ifndef _WIN64
	// determine the type of the platform if modules info is required
	if ( m_bLocalSystem == TRUE && m_bNeedModulesInfo == TRUE )
	{
		// sub-local variables
		DWORD dwPlatform = 0;

		// get the platform type
		dwPlatform = GetTargetPlatformEx( m_pWbemServices, m_pAuthIdentity );

		// if the platform is not 32-bit, error
		if ( dwPlatform != PLATFORM_X86 )
		{
			// let the tool use WMI calls instead of Win32 API
			m_bUseRemote = TRUE;
		}
	}
#endif

	try
	{
		// check the local credentials and if need display warning
		if ( GetLastError() == WBEM_E_LOCAL_CREDENTIALS )
		{
			CHString str;
			WMISaveError( WBEM_E_LOCAL_CREDENTIALS );
			str.Format( L"\n%s %s", TAG_WARNING, GetReason() );
			ShowMessage( stdout, str );

			// get the next cursor position
			if ( m_hOutput != NULL )
				GetConsoleScreenBufferInfo( m_hOutput, &m_csbi );
		}

		// check the remote system version and its compatiblity
		if ( m_bLocalSystem == FALSE )
		{
			// check the version compatibility
			DWORD dwVersion = 0;
			dwVersion = GetTargetVersionEx( m_pWbemServices, m_pAuthIdentity );
			if ( IsCompatibleOperatingSystem( dwVersion ) == FALSE )
			{
				SetReason( ERROR_OS_INCOMPATIBLE );
				return FALSE;
			}
		}

		// save the server name
		m_strUNCServer = L"";
		if ( m_strServer.GetLength() != 0 )
		{
			// check whether the server name is in UNC format or not .. if not prepare it
			m_strUNCServer = m_strServer;
			if ( IsUNCFormat( m_strServer ) == FALSE )
				m_strUNCServer.Format( L"\\\\%s", m_strServer );
		}
	}
	catch( _com_error& e )
	{
		WMISaveError( e );
		return FALSE;
	}

	// return the result
	return TRUE;
}

// ***************************************************************************
// Routine Description:
//		initiate the enumeration
//		  
// Arguments:
//		NONE
//  
// Return Value:
//		TRUE  : if successful
//		FALSE : if unsuccessful
// 
// ***************************************************************************
BOOL CTaskKill::LoadTasks()
{
	// local variables
	HRESULT hr;

	// check the services object
	if ( m_pWbemServices == NULL )
	{
		SetLastError( STG_E_UNKNOWN );
		SaveLastError();
		return FALSE;
	}

	try
	{
		// do the optimization
		DoOptimization();

		// load the tasks from WMI based on generated query
		SAFE_RELEASE( m_pWbemEnumObjects );
		hr = m_pWbemServices->ExecQuery( _bstr_t( WMI_QUERY_TYPE ), _bstr_t( m_strQuery ), 
			WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY, NULL, &m_pWbemEnumObjects );
		
		// check the result of the ExecQuery
		if ( FAILED( hr ) )
		{
			WMISaveError( hr );
			return FALSE;
		}

		// set the interface security and check the result
		hr = SetInterfaceSecurity( m_pWbemEnumObjects, m_pAuthIdentity );
		if ( FAILED( hr ) )
		{
			WMISaveError( hr );
			return FALSE;
		}
		
		//
		// get the reference to the Win32_Process class object 
		// and then reference to the input parameters of the "Terminate" method
		IWbemClassObject* pObject = NULL;
		SAFE_EXECUTE( m_pWbemServices->GetObject( 
			_bstr_t( CLASS_PROCESS ), 0, NULL, &pObject, NULL ) );
		SAFE_EXECUTE( pObject->GetMethod( 
			_bstr_t( WIN32_PROCESS_METHOD_TERMINATE ), 0, &m_pWbemTerminateInParams, NULL ) );

		// release the WMI object
		SAFE_RELEASE( pObject );

		//
		// retrieve the window title information if needed
		
		// remove the current window titles information
		DynArrayRemoveAll( m_arrWindowTitles );
		
		// for the local system, enumerate the window titles of the processes
		// there is no provision for collecting the window titles of remote processes
		if ( m_bLocalSystem == TRUE )
		{
			// prepare the tasks list info
			TWINDOWTITLES windowtitles;
			windowtitles.pwszDesk = NULL;
			windowtitles.pwszWinsta = NULL;
			windowtitles.bFirstLoop = FALSE;
			windowtitles.arrWindows = m_arrWindowTitles;
			EnumWindowStations( EnumWindowStationsFunc, ( LPARAM ) &windowtitles );
			
			// free the memory allocated with _tcsdup string function
			if ( windowtitles.pwszDesk != NULL )
				free( windowtitles.pwszDesk );
			if ( windowtitles.pwszWinsta != NULL )
				free( windowtitles.pwszWinsta );
		}

		// load the extended tasks information
		LoadTasksEx();			// NOTE: here we are not much bothered abt the return value

		// erase the status messages
		PrintProgressMsg( m_hOutput, NULL, m_csbi );
	}
	catch( ... )
	{
		// save the error
		WMISaveError( E_OUTOFMEMORY );
		return FALSE;
	}

	// return success
	return TRUE;
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
BOOL CTaskKill::LoadTasksEx()
{
	// local variables
	BOOL bResult = FALSE;

	//
	// NOTE: we are relying on NET API for getting the user context / services info
	// so if any one of them is needed, establish connection to the remote system using NET API
	if ( m_bNeedModulesInfo == FALSE && m_bNeedUserContextInfo == FALSE && m_bNeedServicesInfo == FALSE )
		return TRUE;

	// init
	m_bCloseConnection = FALSE;

	// we need to use NET API only in case connecting to the remote system
	// with credentials information i.e; m_pAuthIdentity is not NULL
	if ( m_bLocalSystem == FALSE && m_pAuthIdentity != NULL )
	{
		// sub-local variables
		DWORD dwConnect = 0;
		LPCWSTR pwszUser = NULL;
		LPCWSTR pwszPassword = NULL;

		// identify the password to connect to the remote system
		pwszPassword = m_pAuthIdentity->Password;
		if ( m_strUserName.GetLength() != 0 )
			pwszUser = m_strUserName;

		// establish connection to the remote system using NET API
		// this we need to do only for remote system
		dwConnect = NO_ERROR;
		m_bCloseConnection = TRUE;
		dwConnect = ConnectServer( m_strUNCServer, pwszUser, pwszPassword );
		if ( dwConnect != NO_ERROR )
		{
			// connection should not be closed .. this is because we didn't establish the connection
			m_bCloseConnection = FALSE;

			// this might be 'coz of the conflict in the credentials ... check that
			if ( dwConnect != ERROR_SESSION_CREDENTIAL_CONFLICT )
			{
				// return failure
				return FALSE;
			}
		}

		// check the whether we need to close the connection or not
		// if user name is NULL (or) password is NULL then don't close the connection
		if ( pwszUser == NULL || pwszPassword == NULL )
			m_bCloseConnection = FALSE;
	}

	try
	{
		// prepare to get the user context info .. if needed
		if ( m_bNeedUserContextInfo == TRUE )
		{
			// sub-local variables
			HANDLE hServer = NULL;

			// connect to the remote system's winstation
			bResult = TRUE;
			hServer = SERVERNAME_CURRENT;
			if ( m_bLocalSystem == FALSE )
			{
				// sub-local variables
				LPWSTR pwsz = NULL;

				// connect to the winsta and check the result
				pwsz = m_strUNCServer.GetBuffer( m_strUNCServer.GetLength() );
				hServer = WinStationOpenServerW( pwsz );

				// proceed furthur only if winstation of the remote system is successfully opened
				if ( hServer == NULL )
					bResult = FALSE;
			}

			// check the result of the connection to the remote system
			if ( bResult == TRUE )
			{
				// get all the process details
				m_bIsHydra = FALSE;
				bResult = WinStationGetAllProcesses( hServer, 
					GAP_LEVEL_BASIC, &m_ulNumberOfProcesses, (PVOID*) &m_pProcessInfo );
					
				// check the result
				if ( bResult == FALSE )
				{
					// Maybe a Hydra 4 server ?
					// Check the return code indicating that the interface is not available.
					if ( GetLastError() == RPC_S_PROCNUM_OUT_OF_RANGE )
					{
						// The new interface is not known
						// It must be a Hydra 4 server
						// try with the old interface
						bResult = WinStationEnumerateProcesses( hServer, (PVOID*) &m_pProcessInfo );

						// check the result of enumeration
						if ( bResult == TRUE )
							m_bIsHydra = TRUE;
					}
				}

				// close the connection to the winsta
				if ( hServer != NULL )
					WinStationCloseServer( hServer );
			}
		}
	}
	catch( ... )
	{
		SetLastError( E_OUTOFMEMORY );
		SaveLastError();
		return FALSE;
	}

	// check whether we need services info or not
	if ( m_bNeedServicesInfo == TRUE )
	{
		// load the services 
		bResult = LoadServicesInfo();

		// check the result
		if ( bResult == FALSE )
			return FALSE;
	}

	// check whether we need modules info or not
	if ( m_bNeedModulesInfo == TRUE )
	{
		// load the modules information
		bResult = LoadModulesInfo();

		// check the result
		if ( bResult == FALSE )
			return FALSE;
	}

	// NETWORK OPTIMIZATION -
	// while progressing furthur in display of the data, we don't need the connection
	// to the remote system with NET API ... but the connection should be live 
	// if user name has to be retrieved .. so check if user name info is needed or not
	// if not, close the connection
	if ( m_bNeedUserContextInfo == FALSE && m_bCloseConnection == TRUE )
	{
		m_bCloseConnection = FALSE;				// reset the flag
		CloseConnection( m_strUNCServer );		// close connection
	}

	// return
	return TRUE;
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
BOOL CTaskKill::LoadModulesInfo()
{
	// local variables
	HKEY hKey;
	LONG lReturn = 0;
	BOOL bResult = FALSE;
	BOOL bImagesObject = FALSE;
	BOOL bAddressSpaceObject = FALSE;
	PPERF_OBJECT_TYPE pot = NULL;
    PPERF_COUNTER_DEFINITION pcd = NULL;

	// check whether we need the modules infor or not
	// NOTE: we need to load the performance data only in case if user is querying for remote system only
	if ( m_bNeedModulesInfo == FALSE || m_bLocalSystem == TRUE )
		return TRUE;

	// display the status message
	PrintProgressMsg( m_hOutput, MSG_MODULESINFO, m_csbi );

	// open the remote system performance data key
	lReturn = RegConnectRegistry( m_strUNCServer, HKEY_PERFORMANCE_DATA, &hKey );
	if ( lReturn != ERROR_SUCCESS )
	{
		SetLastError( lReturn );
		SaveLastError();
		return FALSE;
	}

	// get the performance object ( images )
	bResult = GetPerfDataBlock( hKey, L"740", &m_pdb );
	if ( bResult == FALSE )
	{
		// close the registry key and return
		RegCloseKey( hKey );
		return FALSE;
	}

	// check the validity of the perf block
	if ( StringCompare( m_pdb->Signature, L"PERF", FALSE, 4 ) != 0 )
	{
		// close the registry key and return
		RegCloseKey( hKey );
		
		// set the error message
		SetLastError( ERROR_ACCESS_DENIED );
		SaveLastError();
		return FALSE;
	}

	// close the registry key and return
	RegCloseKey( hKey );

	//
	// check whether we got both 740 and 786 blocks or not
	//
	bImagesObject = FALSE;
	bAddressSpaceObject = FALSE;
    pot = (PPERF_OBJECT_TYPE) ( (LPBYTE) m_pdb + m_pdb->HeaderLength );
	for( DWORD dw = 0; dw < m_pdb->NumObjectTypes; dw++ )
	{
		if ( pot->ObjectNameTitleIndex == 740 )
			bImagesObject = TRUE;
		else if ( pot->ObjectNameTitleIndex == 786 )
			bAddressSpaceObject = TRUE;

		// move to the next object
		if( pot->TotalByteLength != 0 )
			pot = ( (PPERF_OBJECT_TYPE) ((PBYTE) pot + pot->TotalByteLength));
	}

	// check whether we got the needed objects or not
	if ( bImagesObject == FALSE || bAddressSpaceObject == FALSE )
	{
		SetLastError( ERROR_ACCESS_DENIED );
		SaveLastError();
		return FALSE;
	}

	// return
	return TRUE;
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
BOOL CTaskKill::LoadUserNameFromWinsta( CHString& strDomain, CHString& strUserName )
{
	// local variables
	PSID pSid = NULL;
	BOOL bResult = FALSE;
	LPWSTR pwszUser = NULL;
	LPWSTR pwszDomain = NULL;
	LPCWSTR pwszServer = NULL;
	DWORD dwUserLength = 0;
	DWORD dwDomainLength = 0;
	SID_NAME_USE siduse;

	// check whether winsta data exists or not
	if ( m_pProcessInfo == NULL )
		return FALSE;

	try
	{
		// allocate buffers
		dwUserLength = 128;
		dwDomainLength = 128;
		pwszUser = strUserName.GetBufferSetLength( dwUserLength );
		pwszDomain = strDomain.GetBufferSetLength( dwDomainLength );
	}
	catch( ... )
	{
		SetLastError( E_OUTOFMEMORY );
		SaveLastError();
		return FALSE;
	}

	//
	// find for the appropriate the process
	pSid = NULL;
	if ( m_bIsHydra == FALSE )
	{
		// sub-local variables
		PTS_ALL_PROCESSES_INFO ptsallpi = NULL;
		PTS_SYSTEM_PROCESS_INFORMATION pspi = NULL;

		// loop ...
		ptsallpi = (PTS_ALL_PROCESSES_INFO) m_pProcessInfo;
        for( ULONG ul = 0; ul < m_ulNumberOfProcesses; ul++ )
        {
            pspi = ( PTS_SYSTEM_PROCESS_INFORMATION )( ptsallpi[ ul ].pspiProcessInfo );
			if ( pspi->UniqueProcessId == m_dwProcessId )
			{
				// get the SID and convert it into
	            pSid = ptsallpi[ ul ].pSid;
				break;				 // break from the loop
			}
        }
	}
	else
	{
		//
		// HYDRA ...
		//

		// sub-local variables
		DWORD dwTotalOffset = 0;
		PTS_SYSTEM_PROCESS_INFORMATION pspi = NULL;
		PCITRIX_PROCESS_INFORMATION pcpi = NULL;

		// traverse thru the process info and find the process id
		dwTotalOffset = 0;
		pspi = ( PTS_SYSTEM_PROCESS_INFORMATION ) m_pProcessInfo;
		for( ;; )
		{
			// check the processid
			if ( pspi->UniqueProcessId == m_dwProcessId )
				break;

			// check whether any more processes exist or not
			if( pspi->NextEntryOffset == 0 )
					break;

			// position to the next process info
			dwTotalOffset += pspi->NextEntryOffset;
			pspi = (PTS_SYSTEM_PROCESS_INFORMATION) &m_pProcessInfo[ dwTotalOffset ];
		}

		// get the citrix_information which follows the threads
		pcpi = (PCITRIX_PROCESS_INFORMATION) 
			( ((PUCHAR) pspi) + sizeof( TS_SYSTEM_PROCESS_INFORMATION ) +
			(sizeof( SYSTEM_THREAD_INFORMATION ) * pspi->NumberOfThreads) );

		// check the magic number .. if it is not valid ... we haven't got SID
		if( pcpi->MagicNumber == CITRIX_PROCESS_INFO_MAGIC )
			pSid = pcpi->ProcessSid;
	}

	// check the sid value
	if ( pSid == NULL )
	{
		// SPECIAL CASE:
		// -------------
		// PID -> 0 will have a special hard coded user name info
		if ( m_dwProcessId == 0 )
		{
			bResult = TRUE;
			lstrcpynW( pwszUser, PID_0_USERNAME, dwUserLength );
			lstrcpynW( pwszDomain, PID_0_DOMAIN, dwDomainLength );
		}

		// release the buffer
		strDomain.ReleaseBuffer();
		strUserName.ReleaseBuffer();
		return bResult;
	}

	// determine the server
	pwszServer = NULL;
	if ( m_bLocalSystem == FALSE )
		pwszServer = m_strUNCServer;

	// map the sid to the user name
	bResult = LookupAccountSid( pwszServer, pSid, 
		pwszUser, &dwUserLength, pwszDomain, &dwDomainLength, &siduse );

	// release the buffer
	strDomain.ReleaseBuffer();
	strUserName.ReleaseBuffer();

	// return the result
	return bResult;
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
BOOL CTaskKill::LoadServicesInfo()
{
	// local variables
	DWORD dw = 0;						// looping variable
    DWORD dwSize = 0;					// used in memory allocation 
    DWORD dwResume = 0;					// used in EnumServicesStatusEx
	BOOL bResult = FALSE;				// captures the result of EnumServicesStatusEx
    SC_HANDLE hScm = NULL;				// holds the handle to the service 
	DWORD dwExtraNeeded = 0;			// used in EnumServicesStatusEx and memory allocation
	LPCWSTR pwszServer = NULL;
	LPENUM_SERVICE_STATUS_PROCESS pInfo = NULL;		// holds the services info
    
    // Initialize the output parameter(s).
	m_dwServicesCount = 0;
    m_pServicesInfo = NULL;

	// check whether we need to load the services info or not
	if ( m_bNeedServicesInfo == FALSE )
		return TRUE;

	// display the status message
	PrintProgressMsg( m_hOutput, MSG_SERVICESINFO, m_csbi );

	// determine the server
	pwszServer = NULL;
	if ( m_bLocalSystem == FALSE )
		pwszServer = m_strUNCServer;

    // Connect to the service controller and check the result
    hScm = OpenSCManager( pwszServer, NULL, SC_MANAGER_CONNECT | SC_MANAGER_ENUMERATE_SERVICE );
    if ( hScm == NULL) 
	{
		// set the reason for the failure and return from here itself
		SaveLastError();
		return FALSE;
	}
        
	// enumerate the names of the active win32 services
    // for this, first pass through the loop and allocate memory from an initial guess. (4K)
    // if that isn't sufficient, we make another pass and allocate
    // what is actually needed.  
	// (we only go through the loop a maximum of two times)
	dw = 0;					// no. of loops
	dwResume = 0;			// reset / initialize variables
	dwSize = 4 * 1024;		// reset / initialize variables
    while ( ++dw <= 2 ) 
	{
		// set the size
		dwSize += dwExtraNeeded;

		// allocate memory for storing services information
		pInfo = ( LPENUM_SERVICE_STATUS_PROCESS ) __calloc( 1, dwSize );
		if ( pInfo == NULL )
		{
			// failed in allocating needed memory ... error
			SetLastError( E_OUTOFMEMORY );
			SaveLastError();
			return FALSE;
		}

		// enumerate services, the process identifier and additional flags for the service
		dwResume = 0;			// lets get all the services again
        bResult = EnumServicesStatusEx( hScm, SC_ENUM_PROCESS_INFO, SERVICE_WIN32, 
			SERVICE_ACTIVE, ( LPBYTE ) pInfo, dwSize, &dwExtraNeeded, &m_dwServicesCount, &dwResume, NULL ); 

		// check the result of the enumeration
		if ( bResult )
		{
			// successfully enumerated all the services information
			break;		// jump out of the loop
		}

		// first free the allocated memory
        __free( pInfo );

		// now lets look at what is the error
		if ( GetLastError() == ERROR_MORE_DATA )
		{
			// some more services are not listed because of less memory
			// allocate some more memory and enumerate the remaining services info
			continue;
		}
		else
		{
			// some strange error occured ... inform the same to the caller
			SaveLastError();			// set the reason for the failure
		    CloseServiceHandle( hScm );	// close the handle to the service
			return FALSE;				// inform failure
		}
	}

	// check whether there any services or not ... if services count is zero, free the memory
	if ( m_dwServicesCount == 0 )
	{
		// no services exists
		__free( pInfo );
	}
	else
	{
		// set the local pointer to the out parameter
		m_pServicesInfo = pInfo;
	}

	// inform success
    return TRUE;
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
BOOL GetPerfDataBlock( HKEY hKey, LPWSTR pwszObjectIndex, PPERF_DATA_BLOCK* ppdb )
{
	// local variables
    LONG lReturn = 0;
    DWORD dwBytes = 0;
	BOOL bResult = FALSE;

	// check the input parameters
	if ( pwszObjectIndex == NULL || ppdb == NULL )
		return FALSE;

    // allocate memory for PERF_DATA_BLOCK
	dwBytes = 32 * 1024;		// initially allocate for 32 K
    *ppdb = (PPERF_DATA_BLOCK) HeapAlloc( GetProcessHeap(), 0, dwBytes );
    if( *ppdb == NULL ) 
	{
		SetLastError( E_OUTOFMEMORY );
		SaveLastError();
		return FALSE;
	}

    // get performance data on passed Object
	lReturn = RegQueryValueEx( hKey, pwszObjectIndex, NULL, NULL, (LPBYTE) *ppdb, &dwBytes );
    while( lReturn == ERROR_MORE_DATA )
    {
        // increase memory by 8 K
        dwBytes += 8192;

        // allocated memory is too small reallocate new memory
        *ppdb = (PPERF_DATA_BLOCK) HeapReAlloc( GetProcessHeap(), 0, *ppdb, dwBytes );
		if( *ppdb == NULL ) 
		{
			SetLastError( E_OUTOFMEMORY );
			SaveLastError();
			return FALSE;
		}

		// try to get the info again
		lReturn = RegQueryValueEx( hKey, pwszObjectIndex, NULL, NULL, (LPBYTE) *ppdb, &dwBytes );
    }

	// check the reason for coming out of the loop
	bResult = TRUE;
    if ( lReturn != ERROR_SUCCESS ) 
	{
		if ( *ppdb != NULL) 
		{
			HeapFree( GetProcessHeap(), 0, *ppdb );
			*ppdb = NULL;
		}

		// save the error info
		bResult = FALSE;
		SetLastError( lReturn );
		SaveLastError();
	}

	// return the result
    return bResult;
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
VOID CTaskKill::DoOptimization()
{
	// local variables
	DWORD dwCount = 0;
	CHString strCondition;
	BOOL bOptimized = FALSE;
	LPCWSTR pwsz = NULL;
	LPCWSTR pwszTask = NULL;
	LPCWSTR pwszClause = NULL;
	CHString strInternalQuery;

	// do not the optimization if user requested the tree termination
	if ( m_bTree == TRUE )
		return;

	try
	{
		// traverse thru list of specified tasks to kill and prepare the query
		pwszClause = NULL_STRING;
		dwCount = DynArrayGetCount( m_arrTasksToKill );
		for( DWORD dw = 0; dw < dwCount; dw++ )
		{
			// get the task
			pwszTask = DynArrayItemAsString( m_arrTasksToKill, dw );
			if ( pwszTask == NULL )
				continue;

			// check the for the special input '*' which cannot be optimized
			if ( StringCompare( pwszTask, L"*", TRUE, 0 ) == 0 )
				return;		// query should not be optimized ... return back

			// now check whether wild-card is specified in the image name
			if ( (pwsz = FindChar( pwszTask, L'*', 0 )) != NULL )
			{
				// the image name contains wild card in it - this cannot be included in query
				if ( lstrlen( pwsz ) == 1 )
					continue;
			}
	
			// prepare the query based on the type of input
			// NOTE: in case of numeric it might be a process id (or) image name
			//       we are not sure abt what it can be. So prepare query for both
			if ( IsNumeric( pwszTask, 10, FALSE ) == TRUE )
			{
				// prepare condition
				strCondition.Format( L" %s %s = %s", pwszClause, 
					WIN32_PROCESS_PROPERTY_PROCESSID, pwszTask );
			}
			else
			{
				// prepare the condition
				strCondition.Format( L" %s %s = \"%s\"", 
					pwszClause, WIN32_PROCESS_PROPERTY_IMAGENAME, pwszTask );
			}

			// append to the final query
			strInternalQuery += strCondition;

			// from next time onwards query clause has to be added
			bOptimized = TRUE;
			pwszClause = WMI_CLAUSE_OR;
		}

		// do modifications to the query only if tasks were optimized
		if ( bOptimized == TRUE )
		{
			// now this internal query has to be added to the main query
			// before adding this check whether query optimization is done in filters or not
			// if not, we have to add the where clause also
			strCondition.Format( L"%s %s", m_strQuery, 
				(m_bFiltersOptimized == TRUE ? WMI_CLAUSE_AND : WMI_CLAUSE_WHERE) );

			// now add the internal query to the final query
			m_bTasksOptimized = TRUE;
			m_strQuery.Format( L"%s (%s)", strCondition, strInternalQuery );
		}
	}
	catch( ... )
	{
		// we can't anything here ... just return
		SetLastError( E_OUTOFMEMORY );
		SaveLastError();
		return;
	}
}

// ***************************************************************************
// Routine Description:
//		Enumerates the desktops available on a particular window station
//		This is a CALLBACK function ... called by EnumWindowStations API function
//		  
// Arguments:
//		[ in ] lpstr	: window station name
//		[ in ] lParam	: user supplied parameter to this function
//						  in this function, this points to TTASKSLIST structure variable
//  
// Return Value:
//		TRUE upon success and FALSE on failure
// 
// ***************************************************************************
BOOL CALLBACK EnumWindowStationsFunc( LPWSTR pwsz, LPARAM lParam )
{
	// local variables
    HWINSTA hWinSta = NULL;
    HWINSTA hwinstaSave = NULL;
    PTWINDOWTITLES pWndTitles = ( PTWINDOWTITLES ) lParam;

	// check the input arguments
	if ( pwsz == NULL || lParam == NULL )
		return FALSE;
		
	// get and save the current window station
	hwinstaSave = GetProcessWindowStation();

	// open current tasks window station and change the context to the new workstation
	hWinSta = OpenWindowStation( pwsz, FALSE, WINSTA_ENUMERATE | WINSTA_ENUMDESKTOPS );
	if ( hWinSta == NULL )
	{
		// failed in getting the process window station
		SaveLastError();
		return FALSE;
	}
	else
	{
		// change the context to the new workstation
		if ( hWinSta != hwinstaSave && SetProcessWindowStation( hWinSta ) == FALSE )
		{
			// failed in changing the context
			SaveLastError();
			return FALSE;
		}

		// release the memory allocated for earlier window station
		if ( pWndTitles->pwszWinsta != NULL )
		{
			free( pWndTitles->pwszWinsta );
			pWndTitles->pwszWinsta = NULL;
		}

		// store the window station name
		if ( pwsz != NULL )
		{
			pWndTitles->pwszWinsta = _wcsdup( pwsz );
			if ( pWndTitles->pwszWinsta == NULL )
			{
				SetLastError( E_OUTOFMEMORY );
				SaveLastError();
				return FALSE;
			}
		}
	}

    // enumerate all the desktops for this windowstation
    EnumDesktops( hWinSta, EnumDesktopsFunc, lParam );

    // restore the context to the previous windowstation
    if (hWinSta != hwinstaSave) 
	{
        SetProcessWindowStation( hwinstaSave );
        CloseWindowStation( hWinSta );
    }

    // continue the enumeration
    return TRUE;
}

// ***************************************************************************
// Routine Description:
//		Enumerates the windows on a particular desktop
//		This is a CALLBACK function ... called by EnumDesktops API function
//		  
// Arguments:
//		[ in ] lpstr	: desktop name
//		[ in ] lParam	: user supplied parameter to this function
//						  in this function, this points to TTASKSLIST structure variable
//  
// Return Value:
//		TRUE upon success and FALSE on failure
// 
// ***************************************************************************
BOOL CALLBACK EnumDesktopsFunc( LPWSTR pwsz, LPARAM lParam )
{
	// local variables
    HDESK hDesk = NULL;
    HDESK hdeskSave = NULL;
    PTWINDOWTITLES pWndTitles = ( PTWINDOWTITLES )lParam;

	// check the input arguments
	if ( pwsz == NULL || lParam == NULL )
		return FALSE;
		
	// get and save the current desktop
	hdeskSave = GetThreadDesktop( GetCurrentThreadId() );

	// open the tasks desktop and change the context to the new desktop
	hDesk = OpenDesktop( pwsz, 0, FALSE, DESKTOP_ENUMERATE );
	if ( hDesk == NULL )
	{
		// failed in getting the process desktop
		SaveLastError();
		return FALSE;
	}
	else
	{
		// change the context to the new desktop
		if ( hDesk != hdeskSave && SetThreadDesktop( hDesk ) == FALSE )
		{
			// failed in changing the context
			SaveLastError();
			// ?? return FALSE; -- needs to uncommented
		}

		// release the memory allocated for earlier window station
		if ( pWndTitles->pwszDesk != NULL )
		{
			free( pWndTitles->pwszDesk );
			pWndTitles->pwszDesk = NULL;
		}

		// store the desktop name
		if ( pwsz != NULL )
		{
			pWndTitles->pwszDesk = _wcsdup( pwsz );
			if ( pWndTitles->pwszDesk == NULL )
			{
				SetLastError( E_OUTOFMEMORY );
				SaveLastError();
				return FALSE;
			}
		}
	}

    // enumerate all windows in the new desktop
	// first try to get only the top level windows and visible windows only
	( ( PTWINDOWTITLES ) lParam )->bFirstLoop = TRUE;
    EnumWindows( ( WNDENUMPROC ) EnumWindowsProc, lParam );
    EnumMessageWindows( ( WNDENUMPROC ) EnumWindowsProc, lParam );

    // enumerate all windows in the new desktop
	// now try to get window titles of all those processes whose we ignored earlier while
	// looping first time
	( ( PTWINDOWTITLES ) lParam )->bFirstLoop = FALSE;
    EnumWindows( ( WNDENUMPROC ) EnumWindowsProc, lParam );
    EnumMessageWindows( ( WNDENUMPROC ) EnumWindowsProc, lParam );

    // restore the previous desktop
    if (hDesk != hdeskSave) 
	{
        SetThreadDesktop( hdeskSave );
        CloseDesktop( hDesk );
    }

	// continue enumeration
    return TRUE;
}

// ***************************************************************************
// Routine Description:
//		Enumerates the message windows
//		  
// Arguments:
//		[ in ] lpEnumFunc	: address of call back function that has to be called for
//							  each message window found
//		[ in ] lParam		: user supplied parameter to this function
//							  in this function, this points to TTASKSLIST structure variable
//  
// Return Value:
//		TRUE upon success and FALSE on failure
// ***************************************************************************
BOOL CALLBACK EnumMessageWindows( WNDENUMPROC lpEnumFunc, LPARAM lParam )
{
	// local variables
    HWND hWnd = NULL;
	BOOL bResult = FALSE;

	// check the input arguments
	if ( lpEnumFunc == NULL || lParam == NULL )
		return FALSE;
		
	// enumerate all the message windows
    do
	{
		// find the message window
        hWnd = FindWindowEx( HWND_MESSAGE, hWnd, NULL, NULL );

		// check whether we got the handle to the message window or not
        if ( hWnd != NULL ) 
		{
			// explicitly call the windows enumerators call back function for this window
			bResult = ( *lpEnumFunc )( hWnd, lParam );

			// check the result of the enumeator call back function
            if ( bResult == FALSE ) 
			{
				// terminate the enumeration
                break;
            }
        }
    } while ( hWnd != NULL );

	// return the enumeration result
    return bResult;
}

// ***************************************************************************
// Routine Description:
//		call back called by the API for each window
//		retrives the window title and updates the accordingly
//		  
// Arguments:
//		[ in ] hWnd			: handle to the window
//		[ in ] lParam		: user supplied parameter to this function
//							  in this function, this points to TTASKSLIST structure variable
//  
// Return Value:
//		TRUE upon success and FALSE on failure
// ***************************************************************************
BOOL CALLBACK EnumWindowsProc( HWND hWnd, LPARAM lParam )
{
	// local variables
	LONG lIndex = 0;
    DWORD dwPID = 0;
	BOOL bVisible = FALSE;
	TARRAY arrWindows = NULL;
    PTWINDOWTITLES pWndTitles = NULL;
    __MAX_SIZE_STRING szWindowTitle = NULL_STRING;

	// check the input arguments
	if ( hWnd == NULL || lParam == NULL )
		return FALSE;
		
	// get the values from the lParam
	pWndTitles = ( PTWINDOWTITLES ) lParam;
	arrWindows = pWndTitles->arrWindows;

	// get the processid for this window
   	if ( GetWindowThreadProcessId( hWnd, &dwPID ) == 0 ) 
	{
		// failed in getting the process id 
		return TRUE;			// return but, proceed enumerating other window handle
	}

	// get the visibility state of the window 
	// if the window is not visible, and if this is the first we are enumerating the 
	// window titles, ignore this process
	bVisible = GetWindowLong( hWnd, GWL_STYLE ) & WS_VISIBLE;
	if ( bVisible == FALSE && pWndTitles->bFirstLoop == TRUE )
		return TRUE;	// return but, proceed enumerating other window handle

	// check whether the current window ( for which we have the handle )
	// is main window or not. we don't need child windows
	if ( GetWindow(hWnd, GW_OWNER) != NULL )
	{
		// the current window handle is not for a top level window
		return TRUE;			// return but, proceed enumerating other window handle
	}

	// check if we are already got the window handle for the curren process or not
	// save it only if we are not having it
	lIndex = DynArrayFindDWORDEx( arrWindows, CTaskKill::twiProcessId, dwPID );
	if (  lIndex == -1 )
	{
		// window for this process is not there ... save it
		lIndex = DynArrayAppendRow( arrWindows, CTaskKill::twiCOUNT );
	}
	else 
	{
		// check whether window details already exists or not
		if ( DynArrayItemAsHandle2( arrWindows, lIndex, CTaskKill::twiHandle ) != NULL )
			lIndex = -1;		// window details already exists
	}

	// check if window details has to be saved or not ... if needed save them
	if ( lIndex != -1 )
	{
		DynArraySetDWORD2( arrWindows, lIndex, CTaskKill::twiProcessId, dwPID );
		DynArraySetHandle2( arrWindows, lIndex, CTaskKill::twiHandle, hWnd );
		DynArraySetString2( arrWindows, lIndex, 
			CTaskKill::twiWinSta, pWndTitles->pwszWinsta, 0 );		
		DynArraySetString2( arrWindows, lIndex, 
			CTaskKill::twiDesktop, pWndTitles->pwszDesk, 0 );

		// get and save the window title
		if ( GetWindowText( hWnd, szWindowTitle, SIZE_OF_ARRAY( szWindowTitle ) ) != 0 )
			DynArraySetString2( arrWindows, lIndex, CTaskKill::twiTitle, szWindowTitle, 0 );
	}
	
    // continue the enumeration
    return TRUE;
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
VOID PrintProgressMsg( HANDLE hOutput, LPCWSTR pwszMsg, const CONSOLE_SCREEN_BUFFER_INFO& csbi )
{
	// local variables
	COORD coord; 
	DWORD dwSize = 0;
	WCHAR wszSpaces[ 80 ] = L"";

	// check the handle. if it is null, it means that output is being redirected. so return
	if ( hOutput == NULL )
		return;

	// set the cursor position
    coord.X = 0;
    coord.Y = csbi.dwCursorPosition.Y;

	// first erase contents on the current line
	ZeroMemory( wszSpaces, 80 );
	SetConsoleCursorPosition( hOutput, coord );
	WriteConsoleW( hOutput, Replicate( wszSpaces, L"", 79 ), 79, &dwSize, NULL );

	// now display the message ( if exists )
	SetConsoleCursorPosition( hOutput, coord );
	if ( pwszMsg != NULL )
		WriteConsoleW( hOutput, pwszMsg, lstrlen( pwszMsg ), &dwSize, NULL );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cmdline\kill\wmi.h ===
// *********************************************************************************
// 
//  Copyright (c) Microsoft Corporation
//  
//  Module Name:
//
//		WMI.h  
//  
//  Abstract:
//  
// 		Common functionality for WMI
//
//  Author:
//  
// 	    Sunil G.V.N. Murali (murali.sunil@wipro.com) 22-Dec-2000
//  
//  Revision History:
//  
// 	    Sunil G.V.N. Murali (murali.sunil@wipro.com) 22-Dec-2000 : Created It.
//  
// *********************************************************************************

#ifndef __WMI_H
#define __WMI_H

//
// macros
//
#define SAFE_RELEASE( interfacepointer )	\
	if ( (interfacepointer) != NULL )	\
	{	\
		(interfacepointer)->Release();	\
		(interfacepointer) = NULL;	\
	}	\
	1

#define SAFE_EXECUTE( statement )				\
	hr = statement;		\
	if ( FAILED( hr ) )	\
	{	\
		_com_issue_error( hr );	\
	}	\
	1

//
// define(s) / enumerators / constants
//
#define WMI_NAMESPACE_CIMV2		L"root\\cimv2"
#define WMI_NAMESPACE_DEFAULT	L"root\\default"

#define WMI_CLAUSE_AND			L"AND"
#define WMI_CLAUSE_OR			L"OR"
#define WMI_CLAUSE_WHERE		L"WHERE"

#define CLASS_CIMV2_Win32_OperatingSystem	L"Win32_OperatingSystem"
#define CLASS_CIMV2_Win32_ComputerSystem	L"Win32_ComputerSystem"

#define WMI_REGISTRY					L"StdRegProv"
#define WMI_REGISTRY_M_STRINGVALUE		L"GetStringValue"

#define WMI_REGISTRY_IN_HDEFKEY			L"hDefKey"
#define WMI_REGISTRY_IN_SUBKEY			L"sSubKeyName"
#define WMI_REGISTRY_IN_VALUENAME		L"sValueName"
#define WMI_REGISTRY_OUT_VALUE			L"sValue"
#define WMI_REGISTRY_OUT_RETURNVALUE	L"ReturnValue"

#define WMI_HKEY_CLASSES_ROOT				2147483648 
#define WMI_HKEY_CURRENT_USER				2147483649
#define WMI_HKEY_LOCAL_MACHINE				2147483650
#define WMI_HKEY_USERS						2147483651
#define WMI_HKEY_CURRENT_CONFIG				2147482652

#define PLATFORM_UNKNOWN				0
#define PLATFORM_X86					1
#define PLATFORM_IA64					2
#define PLATFORM_AMD64					3

#define TEXT_X86						L"X86"
#define TEXT_IA64						L"IA64"
#define TEXT_AMD64						L"AMD64"

// messages
// #define ERROR_COM_ERROR					GetResString( IDS_ERROR_COM_ERROR )

//
// function prototype(s)
//
BOOL InitializeCom( IWbemLocator** ppLocator );
BOOL ConnectWmi( IWbemLocator* pLocator, 
				 IWbemServices** ppServices, 
				 LPCWSTR pwszServer, LPCWSTR pwszUser, LPCWSTR pwszPassword, 
				 COAUTHIDENTITY** ppAuthIdentity, 
				 BOOL bCheckWithNullPwd = FALSE, 
				 LPCWSTR pwszNamespace = WMI_NAMESPACE_CIMV2, 
				 HRESULT* phr = NULL, BOOL* pbLocalSystem = NULL );
BOOL ConnectWmiEx( IWbemLocator* pLocator, 
				   IWbemServices** ppServices, 
				   LPCWSTR pwszServer, CHString& strUserName, CHString& strPassword, 
				   COAUTHIDENTITY** ppAuthIdentity, BOOL bNeedPassword = FALSE, 
				   LPCWSTR pszNamespace = WMI_NAMESPACE_CIMV2, BOOL* pbLocalSystem = NULL );
BOOL IsValidServerEx( LPCWSTR pwszServer, BOOL& bLocalSystem );
HRESULT SetInterfaceSecurity( IUnknown* pInterface, COAUTHIDENTITY* pAuthIdentity );
VOID WINAPI WbemFreeAuthIdentity( COAUTHIDENTITY** ppAuthIdentity );
VOID WMISaveError( HRESULT hrError );
HRESULT PropertyGet( IWbemClassObject* pWmiObject, 
					 LPCWSTR pwszProperty, _variant_t& varValue );
BOOL PropertyGet( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty, 
				  CHString& strValue, LPCWSTR pwszDefault = V_NOT_AVAILABLE );
BOOL PropertyGet( IWbemClassObject* pWmiObject, 
				  LPCWSTR pwszProperty,  DWORD& dwValue, DWORD dwDefault = 0 );
BOOL PropertyGet( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty,  ULONGLONG& ullValue );
BOOL PropertyGet( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty,  WBEMTime& wbemtime );
BOOL PropertyGet( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty,  SYSTEMTIME& systime );
BOOL PropertyGet( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty, TARRAY arr );
HRESULT PropertyPut( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty, DWORD dwValue );
HRESULT PropertyPut( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty, LPCWSTR pwszValue );
HRESULT PropertyPut( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty, _variant_t& varValue );
DWORD GetTargetVersionEx( IWbemServices* pWbemServices, COAUTHIDENTITY* pAuthIdentity );
DWORD GetTargetPlatformEx( IWbemServices* pWbemServices, COAUTHIDENTITY* pAuthIdentity );
BOOL RegQueryValueWMI( IWbemServices* pWbemServices, DWORD dwHDefKey, 
					   LPCWSTR pwszSubKeyName, LPCWSTR pwszValueName, 
					   CHString& strValue, LPCWSTR pwszDefault = V_NOT_AVAILABLE );

//
// inline functions
//

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
inline VOID WMISaveError( _com_error& e )
{
	WMISaveError( e.Error() );
}

#endif // __WMI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cmdline\systeminfo\wmi.h ===
// *********************************************************************************
// 
//  Copyright (c) Microsoft Corporation
//  
//  Module Name:
//
//		WMI.h  
//  
//  Abstract:
//  
// 		Common functionality for WMI
//
//  Author:
//  
// 	    Sunil G.V.N. Murali (murali.sunil@wipro.com) 22-Dec-2000
//  
//  Revision History:
//  
// 	    Sunil G.V.N. Murali (murali.sunil@wipro.com) 22-Dec-2000 : Created It.
//  
// *********************************************************************************

#ifndef __WMI_H
#define __WMI_H

//
// macros
//
#define SAFE_RELEASE( interfacepointer )	\
	if ( (interfacepointer) != NULL )	\
	{	\
		(interfacepointer)->Release();	\
		(interfacepointer) = NULL;	\
	}	\
	1

#define SAFE_EXECUTE( statement )				\
	hr = statement;		\
	if ( FAILED( hr ) )	\
	{	\
		_com_issue_error( hr );	\
	}	\
	1

//
// define(s) / enumerators / constants
//
#define WMI_NAMESPACE_CIMV2		L"root\\cimv2"
#define WMI_NAMESPACE_DEFAULT	L"root\\default"

#define WMI_CLAUSE_AND			L"AND"
#define WMI_CLAUSE_OR			L"OR"
#define WMI_CLAUSE_WHERE		L"WHERE"

#define CLASS_CIMV2_Win32_OperatingSystem	L"Win32_OperatingSystem"
#define CLASS_CIMV2_Win32_ComputerSystem	L"Win32_ComputerSystem"

#define WMI_REGISTRY					L"StdRegProv"
#define WMI_REGISTRY_M_STRINGVALUE		L"GetStringValue"

#define WMI_REGISTRY_IN_HDEFKEY			L"hDefKey"
#define WMI_REGISTRY_IN_SUBKEY			L"sSubKeyName"
#define WMI_REGISTRY_IN_VALUENAME		L"sValueName"
#define WMI_REGISTRY_OUT_VALUE			L"sValue"
#define WMI_REGISTRY_OUT_RETURNVALUE	L"ReturnValue"

#define WMI_HKEY_CLASSES_ROOT				2147483648 
#define WMI_HKEY_CURRENT_USER				2147483649
#define WMI_HKEY_LOCAL_MACHINE				2147483650
#define WMI_HKEY_USERS						2147483651
#define WMI_HKEY_CURRENT_CONFIG				2147482652

#define PLATFORM_UNKNOWN				0
#define PLATFORM_X86					1
#define PLATFORM_IA64					2
#define PLATFORM_AMD64					3

#define TEXT_X86						L"X86"
#define TEXT_IA64						L"IA64"
#define TEXT_AMD64						L"AMD64"

// messages
// #define ERROR_COM_ERROR					GetResString( IDS_ERROR_COM_ERROR )

//
// function prototype(s)
//
BOOL InitializeCom( IWbemLocator** ppLocator );
BOOL ConnectWmi( IWbemLocator* pLocator, 
				 IWbemServices** ppServices, 
				 LPCWSTR pwszServer, LPCWSTR pwszUser, LPCWSTR pwszPassword, 
				 COAUTHIDENTITY** ppAuthIdentity, 
				 BOOL bCheckWithNullPwd = FALSE, 
				 LPCWSTR pwszNamespace = WMI_NAMESPACE_CIMV2, 
				 HRESULT* phr = NULL, BOOL* pbLocalSystem = NULL );
BOOL ConnectWmiEx( IWbemLocator* pLocator, 
				   IWbemServices** ppServices, 
				   LPCWSTR pwszServer, CHString& strUserName, CHString& strPassword, 
				   COAUTHIDENTITY** ppAuthIdentity, BOOL bNeedPassword = FALSE, 
				   LPCWSTR pszNamespace = WMI_NAMESPACE_CIMV2, BOOL* pbLocalSystem = NULL );
BOOL IsValidServerEx( LPCWSTR pwszServer, BOOL& bLocalSystem );
HRESULT SetInterfaceSecurity( IUnknown* pInterface, COAUTHIDENTITY* pAuthIdentity );
VOID WINAPI WbemFreeAuthIdentity( COAUTHIDENTITY** ppAuthIdentity );
VOID WMISaveError( HRESULT hrError );
HRESULT PropertyGet( IWbemClassObject* pWmiObject, 
					 LPCWSTR pwszProperty, _variant_t& varValue );
BOOL PropertyGet( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty, 
				  CHString& strValue, LPCWSTR pwszDefault = V_NOT_AVAILABLE );
BOOL PropertyGet( IWbemClassObject* pWmiObject, 
				  LPCWSTR pwszProperty,  DWORD& dwValue, DWORD dwDefault = 0 );
BOOL PropertyGet( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty,  ULONGLONG& ullValue );
BOOL PropertyGet( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty,  WBEMTime& wbemtime );
BOOL PropertyGet( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty,  SYSTEMTIME& systime );
BOOL PropertyGet( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty, TARRAY arr );
HRESULT PropertyPut( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty, DWORD dwValue );
HRESULT PropertyPut( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty, LPCWSTR pwszValue );
HRESULT PropertyPut( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty, _variant_t& varValue );
DWORD GetTargetVersionEx( IWbemServices* pWbemServices, COAUTHIDENTITY* pAuthIdentity );
DWORD GetTargetPlatformEx( IWbemServices* pWbemServices, COAUTHIDENTITY* pAuthIdentity );
BOOL RegQueryValueWMI( IWbemServices* pWbemServices, DWORD dwHDefKey, 
					   LPCWSTR pwszSubKeyName, LPCWSTR pwszValueName, 
					   CHString& strValue, LPCWSTR pwszDefault = V_NOT_AVAILABLE );

//
// inline functions
//

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
inline VOID WMISaveError( _com_error& e )
{
	WMISaveError( e.Error() );
}

#endif // __WMI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cmdline\systeminfo\pch.h ===
// *********************************************************************************
// 
//  Copyright (c) Microsoft Corporation
//  
//  Module Name:
// 
//		pch.h 
//  
//  Abstract:
//  
// 		pre-compiled header declaration
//		files that has to be pre-compiled into .pch file
//  
//  Author:
//  
// 	  Sunil G.V.N. Murali (murali.sunil@wipro.com) 22-Dec-2000
//  
//  Revision History:
//  
// 	  Sunil G.V.N. Murali (murali.sunil@wipro.com) 22-Dec-2000 : Created It.
//  
// *********************************************************************************

#ifndef __PCH_H
#define __PCH_H

#pragma once		// include header file only once

#if !defined( SECURITY_WIN32 ) && !defined( SECURITY_KERNEL ) && !defined( SECURITY_MAC )
#define SECURITY_WIN32
#endif

//
// Private nt headers.
//
extern "C"
{
	#include <nt.h>
	#include <ntrtl.h>
    #include <nturtl.h>
    #include <ntexapi.h>
	#include <Security.h>
	#include <SecExt.h>
}

//
// public Windows header files
//
#include <windows.h>
#include <tchar.h>
#include <wbemidl.h>
#include <chstring.h>
#include <comdef.h>
#include <wbemtime.h>
#include <dsrole.h>					// domain role information

//
// public C header files
//
#include <stdio.h>
#include <string.h>
#include <crtdbg.h>

//
// private Common header files
//
#include "cmdlineres.h"
#include "cmdline.h"

#endif	// __PCH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cmdline\systeminfo\systeminfo.cpp ===
// *********************************************************************************
// 
//  Copyright (c) Microsoft Corporation
//  
//  Module Name:
//  
//		SystemInfo.cpp
//  
//  Abstract:
//  
// 		This module displays the system information of local / remote system.
//
//  Author:
//  
// 		Sunil G.V.N. Murali (murali.sunil@wipro.com) 27-Dec-2000
//  
//  Revision History:
//  
// 		Sunil G.V.N. Murali (murali.sunil@wipro.com) 27-Dec-2000 : Created It.
//  
// *********************************************************************************

#include "pch.h"
#include "wmi.h"
#include "SystemInfo.h"

//
// private function prototype(s)
//
LCID GetSupportedUserLocale( BOOL& bLocaleChanged );
BOOL TranslateLocaleCode( CHString& strLocale );
BOOL FormatNumber( LPCWSTR strValue, CHString& strFmtValue );
BOOL FormatNumberEx( LPCWSTR pwszValue, CHString& strFmtValue );
VOID PrintProgressMsg( HANDLE hOutput, LPCWSTR pwszMsg, const CONSOLE_SCREEN_BUFFER_INFO& csbi );

// ***************************************************************************
// Routine Description:
//		This the entry point to this utility.
//		  
// Arguments:
//		[ in ] argc		: argument(s) count specified at the command prompt
//		[ in ] argv		: argument(s) specified at the command prompt
//
// Return Value:
//		The below are actually not return values but are the exit values 
//		returned to the OS by this application
//			0		: utility is successfull
//			1		: utility failed
// ***************************************************************************
DWORD __cdecl _tmain( DWORD argc, LPCTSTR argv[] )
{
	// local variables
	CSystemInfo sysinfo;
	BOOL bResult = FALSE;
	DWORD dwExitCode = 0;

		// initialize the taskkill utility
	if ( sysinfo.Initialize() == FALSE )
	{
		CHString strBuffer;
		strBuffer.Format( L"%s %s", TAG_ERROR, GetReason() );
		DISPLAY_MESSAGE( stderr, strBuffer );
		EXIT_PROCESS( 1 );
	}

	// now do parse the command line options
	if ( sysinfo.ProcessOptions( argc, argv ) == FALSE )
	{
		CHString strBuffer;
		strBuffer.Format( L"%s %s", TAG_ERROR, GetReason() );
		ShowMessage( stderr, strBuffer );
		EXIT_PROCESS( 1 );
	}

	// check whether usage has to be displayed or not
	if ( sysinfo.m_bUsage == TRUE )
	{
		// show the usage of the utility
		sysinfo.ShowUsage();

		// quit from the utility
		EXIT_PROCESS( 0 );
	}

	// connect to the WMI
	bResult = sysinfo.Connect();
	if ( bResult == FALSE )
	{
		// show the error message
		CHString strBuffer;
		strBuffer.Format( L"%s %s", TAG_ERROR, GetReason() );
		ShowMessage( stderr, strBuffer );
		EXIT_PROCESS( 1 );
	}

	// load the data
	if ( sysinfo.LoadData() == FALSE )
	{
		// show the error message
		CHString strBuffer;
		strBuffer.Format( L"\n%s %s", TAG_ERROR, GetReason() );
		ShowMessage( stderr, strBuffer );
		EXIT_PROCESS( 1 );
	}

#ifdef _FAST_LIST
	// NOTE: for list for output will be shown while loading itself. 
	// so show the output incase of table and csv formats only
	if ( (sysinfo.m_dwFormat & SR_FORMAT_MASK) != SR_FORMAT_LIST )
#endif

	// show the system configuration information
	sysinfo.ShowOutput();

	// exit from the program
	EXIT_PROCESS( 0 );
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
BOOL CSystemInfo::Connect()
{
	// local variables
	BOOL bResult = FALSE;
	BOOL bLocalSystem = FALSE;

	// connect to WMI
	bResult = ConnectWmiEx( m_pWbemLocator, 
		&m_pWbemServices, m_strServer, m_strUserName, m_strPassword, 
		&m_pAuthIdentity, m_bNeedPassword, WMI_NAMESPACE_CIMV2, &bLocalSystem );

	// check the result of connection
	if ( bResult == FALSE )
		return FALSE;

	// check the local credentials and if need display warning
	if ( GetLastError() == WBEM_E_LOCAL_CREDENTIALS )
	{
		CHString str;
		WMISaveError( WBEM_E_LOCAL_CREDENTIALS );
		str.Format( L"%s %s", TAG_WARNING, GetReason() );
		ShowMessage( stdout, str );

		// get the new screen co-ordinates
		if ( m_hOutput != NULL )
			GetConsoleScreenBufferInfo( m_hOutput, &m_csbi );
	}

	// check the remote system version and its compatiblity
	if ( bLocalSystem == FALSE )
	{
		DWORD dwVersion = 0;
		dwVersion = GetTargetVersionEx( m_pWbemServices, m_pAuthIdentity );
		if ( IsCompatibleOperatingSystem( dwVersion ) == FALSE )
		{
			SetReason( ERROR_OS_INCOMPATIBLE );
			return FALSE;
		}
	}

	// return the result
	return bResult;
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
BOOL CSystemInfo::LoadData()
{
	// local variables
	BOOL bResult = FALSE;
	HANDLE hStdErr = NULL;

	//
	// load os information
	bResult = LoadOSInfo();
	if ( bResult == FALSE )
		return FALSE;

#ifdef _FAST_LIST
	// ***********************************************
	// show the paritial output .. only in list format
	// ***********************************************
	// Columns Shown here:
	//		Host Name, OS Name, OS Version, OS Manufacturer
	// ***********************************************
	if ( (m_dwFormat & SR_FORMAT_MASK) == SR_FORMAT_LIST )
	{
		// erase the last status message
		PrintProgressMsg( m_hOutput, NULL, m_csbi );

		ShowOutput( CI_HOSTNAME, CI_OS_MANUFACTURER );
		if ( m_hOutput != NULL )
			GetConsoleScreenBufferInfo( m_hOutput, &m_csbi );
	}
#endif

	//
	// load computer information
	bResult = LoadComputerInfo();
	if ( bResult == FALSE )
		return FALSE;

#ifdef _FAST_LIST
	// ***********************************************
	// show the paritial output .. only in list format
	// ***********************************************
	// Columns Shown here:
	//		OS Configuration, OS Build Type, Registered Owner, 
	//		Registered Organization, Product ID, Original Install Date
	// ***********************************************
	if ( (m_dwFormat & SR_FORMAT_MASK) == SR_FORMAT_LIST )
	{
		// erase the last status message
		PrintProgressMsg( m_hOutput, NULL, m_csbi );

		ShowOutput( CI_OS_CONFIG, CI_INSTALL_DATE );
		if ( m_hOutput != NULL )
			GetConsoleScreenBufferInfo( m_hOutput, &m_csbi );
	}
#endif

	//
	// load systemuptime information from perf data
	bResult = LoadPerformanceInfo();
	// if ( bResult == FALSE )
	//	return FALSE;

#ifdef _FAST_LIST
	// ***********************************************
	// show the paritial output .. only in list format
	// ***********************************************
	// Columns Shown here:
	//		System Up Time, System Manufacturer, System Model, System type
	// ***********************************************
	if ( (m_dwFormat & SR_FORMAT_MASK) == SR_FORMAT_LIST )
	{
		// erase the last status message
		PrintProgressMsg( m_hOutput, NULL, m_csbi );

		ShowOutput( CI_SYSTEM_UPTIME, CI_SYSTEM_TYPE );
		if ( m_hOutput != NULL )
			GetConsoleScreenBufferInfo( m_hOutput, &m_csbi );
	}
#endif

	//
	// load processor information
	bResult = LoadProcessorInfo();
	if ( bResult == FALSE )
		return FALSE;

#ifdef _FAST_LIST
	// ***********************************************
	// show the paritial output .. only in list format
	// ***********************************************
	// Columns Shown here:
	//		Processor(s)
	// ***********************************************
	if ( (m_dwFormat & SR_FORMAT_MASK) == SR_FORMAT_LIST )
	{
		// erase the last status message
		PrintProgressMsg( m_hOutput, NULL, m_csbi );

		ShowOutput( CI_PROCESSOR, CI_PROCESSOR );
		if ( m_hOutput != NULL )
			GetConsoleScreenBufferInfo( m_hOutput, &m_csbi );
	}
#endif

	//
	// load bios information
	bResult = LoadBiosInfo();
	if ( bResult == FALSE )
		return FALSE;

#ifdef _FAST_LIST
	// ***********************************************
	// show the paritial output .. only in list format
	// ***********************************************
	// Columns Shown here:
	//		BIOS Version, Windows Directory, System Directory, Boot Device, System Locale
	// ***********************************************
	if ( (m_dwFormat & SR_FORMAT_MASK) == SR_FORMAT_LIST )
	{
		// erase the last status message
		PrintProgressMsg( m_hOutput, NULL, m_csbi );

		ShowOutput( CI_BIOS_VERSION, CI_SYSTEM_LOCALE );
		if ( m_hOutput != NULL )
			GetConsoleScreenBufferInfo( m_hOutput, &m_csbi );
	}
#endif

	//
	// load input locale information from keyboard class
	bResult = LoadKeyboardInfo();
	if ( bResult == FALSE )
		return FALSE;

	//
	// load timezone information
	bResult = LoadTimeZoneInfo();
	if ( bResult == FALSE )
		return FALSE;

#ifdef _FAST_LIST
	// ***********************************************
	// show the paritial output .. only in list format
	// ***********************************************
	// Columns Shown here:
	//		Input Locale, Time Zone, Total Physical Memory, Available Physical Memory, 
	//		Virtual Memory: Max Size, Virtual Memory: Available, Virtual Memory: In Use
	// ***********************************************
	if ( (m_dwFormat & SR_FORMAT_MASK) == SR_FORMAT_LIST )
	{
		// erase the last status message
		PrintProgressMsg( m_hOutput, NULL, m_csbi );

		ShowOutput( CI_INPUT_LOCALE, CI_VIRTUAL_MEMORY_INUSE );
		if ( m_hOutput != NULL )
			GetConsoleScreenBufferInfo( m_hOutput, &m_csbi );
	}
#endif

	// load the logon server information
	bResult = LoadProfileInfo();
	if ( bResult == FALSE )
		return FALSE;

	//
	// load pagefile information
	bResult = LoadPageFileInfo();
	if ( bResult == FALSE )
		return FALSE;

	//
	// load hotfix information from quick fix engineering class
	bResult = LoadHotfixInfo();
	if ( bResult == FALSE )
		return FALSE;

	//
	// load n/w card information from network adapter class
	bResult = LoadNetworkCardInfo();
	if ( bResult == FALSE )
		return FALSE;

#ifdef _FAST_LIST
	// ***********************************************
	// show the paritial output .. only in list format
	// ***********************************************
	// Columns Shown here:
	//		Page File Location(s), Domain, Logon Server, Hotfix(s), NetWork Card(s)
	// ***********************************************
	if ( (m_dwFormat & SR_FORMAT_MASK) == SR_FORMAT_LIST )
	{
		// erase the last status message
		PrintProgressMsg( m_hOutput, NULL, m_csbi );

		ShowOutput( CI_PAGEFILE_LOCATION, CI_NETWORK_CARD );
		if ( m_hOutput != NULL )
			GetConsoleScreenBufferInfo( m_hOutput, &m_csbi );
	}
#endif

	// erase the last status message
	PrintProgressMsg( m_hOutput, NULL, m_csbi );

	// return
	return TRUE;
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
BOOL CSystemInfo::LoadOSInfo()
{
	// local variables
	HRESULT hr;
	ULONG ulReturned = 0;
	CHString strInstallDate;
	CHString strVirtualMemoryInUse;		// totalvirtualmemorysize - freevirtualmemory
	IWbemClassObject* pWbemObject = NULL;
	IEnumWbemClassObject* pWbemEnum = NULL;

	// property values
	CHString strHostName;				// csname
	CHString strName;					// caption
	CHString strVersion;				// version
	CHString strServicePack;			// csdversion
	CHString strBuildNumber;			// buildnumber
	CHString strManufacturer;			// manufacturer
	CHString strBuildType;				// buildtype
	CHString strOwner;					// registereduser
	CHString strOrganization;			// organization
	CHString strSerialNumber;			// serialnumber
	CHString strWindowsDir;				// windowsdirectory
	CHString strSystemDir;				// systemdirectory
	CHString strBootDevice;				// bootdevice
	CHString strFreePhysicalMemory;		// freephysicalmemory
	CHString strTotalVirtualMemory;		// totalvirtualmemorysize
	CHString strFreeVirtualMemory;		// freevirtualmemory
	CHString strLocale;					// locale
	SYSTEMTIME systimeInstallDate;		// installdate

	// display the status message
	PrintProgressMsg( m_hOutput, MSG_OSINFO, m_csbi );

	try
	{
		// enumerate the instances of Win32_OperatingSystem class 
		hr = m_pWbemServices->CreateInstanceEnum( _bstr_t( WIN32_OPERATINGSYSTEM ),
			WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY, NULL, &pWbemEnum );
	
		// check the result of enumeration
		if ( FAILED( hr ) )
		{
			WMISaveError( hr );
			return FALSE;
		}
	}
	catch( _com_error& e )
	{
		WMISaveError( e );
		return FALSE;
	}

	// set the security on the obtained interface
	hr = SetInterfaceSecurity( pWbemEnum, m_pAuthIdentity );
	if ( FAILED( hr ) )
	{
		WMISaveError( hr );
		return FALSE;
	}

	// get the enumerated objects information
	// NOTE: This needs to be traversed only one time. 
	hr = pWbemEnum->Next( WBEM_INFINITE, 1, &pWbemObject, &ulReturned );
	if ( FAILED( hr ) )
	{
		// some error has occured ... oooppps
		WMISaveError( hr );
		return FALSE;
	}

	// get the propert information
	PropertyGet( pWbemObject, WIN32_OPERATINGSYSTEM_P_CAPTION, strName );
	PropertyGet( pWbemObject, WIN32_OPERATINGSYSTEM_P_CSNAME, strHostName );
	PropertyGet( pWbemObject, WIN32_OPERATINGSYSTEM_P_VERSION, strVersion );
	PropertyGet( pWbemObject, WIN32_OPERATINGSYSTEM_P_CSDVERSION, strServicePack );
	PropertyGet( pWbemObject, WIN32_OPERATINGSYSTEM_P_BUILDNUMBER, strBuildNumber );
	PropertyGet( pWbemObject, WIN32_OPERATINGSYSTEM_P_MANUFACTURER, strManufacturer );
	PropertyGet( pWbemObject, WIN32_OPERATINGSYSTEM_P_BUILDTYPE, strBuildType );
	PropertyGet( pWbemObject, WIN32_OPERATINGSYSTEM_P_REGUSER, strOwner );
	PropertyGet( pWbemObject, WIN32_OPERATINGSYSTEM_P_ORGANIZATION, strOrganization );
	PropertyGet( pWbemObject, WIN32_OPERATINGSYSTEM_P_SERIALNUMBER, strSerialNumber );
	PropertyGet( pWbemObject, WIN32_OPERATINGSYSTEM_P_WINDOWSDIR, strWindowsDir );
	PropertyGet( pWbemObject, WIN32_OPERATINGSYSTEM_P_SYSTEMDIR, strSystemDir );
	PropertyGet( pWbemObject, WIN32_OPERATINGSYSTEM_P_BOOTDEVICE, strBootDevice );
	PropertyGet( pWbemObject, WIN32_OPERATINGSYSTEM_P_LOCALE, strLocale );
	PropertyGet( pWbemObject, WIN32_OPERATINGSYSTEM_P_FREEPHYSICALMEMORY, strFreePhysicalMemory );
	PropertyGet( pWbemObject, WIN32_OPERATINGSYSTEM_P_TOTALVIRTUALMEMORY, strTotalVirtualMemory );
	PropertyGet( pWbemObject, WIN32_OPERATINGSYSTEM_P_FREEVIRTUALMEMORY, strFreeVirtualMemory );
	PropertyGet( pWbemObject, WIN32_OPERATINGSYSTEM_P_INSTALLDATE, systimeInstallDate );

	// relase the interfaces
	SAFE_RELEASE( pWbemEnum );
	SAFE_RELEASE( pWbemObject );

	//
	// do the needed formatting the information obtained
	//

	// convert the system locale into appropriate code
	TranslateLocaleCode( strLocale );

	//
	// format the version info
	try
	{
		// sub-local variable
		CHString str;

		// attach the service pack info
		str = strVersion;
		if ( strServicePack.IsEmpty() == FALSE )
			str.Format( L"%s %s", strVersion, strServicePack );

		// attach the build number
		strVersion.Format( FMT_OSVERSION, str, strBuildNumber );
	}
	catch( ... )
	{
		SetLastError( E_OUTOFMEMORY );
		SaveLastError();
		return FALSE;
	}

	//
	// get the formatted date and time
	{
		// sub-local variables
		LCID lcid;
		CHString strTime;
		CHString strDate;
		BOOL bLocaleChanged = FALSE;

		// verify whether console supports the current locale 100% or not
		lcid = GetSupportedUserLocale( bLocaleChanged );

		// get the formatted date
		try
		{
			// get the size of buffer that is needed
			DWORD dwCount = 0;

			dwCount = GetDateFormat( lcid, 0, &systimeInstallDate, 
				((bLocaleChanged == TRUE) ? L"MM/dd/yyyy" : NULL), NULL, 0 );

			// get the required buffer
			LPWSTR pwszTemp = NULL;
			pwszTemp = strDate.GetBufferSetLength( dwCount + 1 );

			// now format the date
			GetDateFormat( lcid, 0, &systimeInstallDate, 
				((bLocaleChanged == TRUE) ? L"MM/dd/yyyy" : NULL), pwszTemp, dwCount );

			// release the buffer
			strDate.ReleaseBuffer();
		}
		catch( ... )
		{
			SetLastError( E_OUTOFMEMORY );
			SaveLastError();
			return FALSE;
		}

		// get the formatted time
		try
		{
			// get the size of buffer that is needed
			DWORD dwCount = 0;
			dwCount = GetTimeFormat( LOCALE_USER_DEFAULT, 0, &systimeInstallDate, 
				((bLocaleChanged == TRUE) ? L"HH:mm:ss" : NULL), NULL, 0 );

			// get the required buffer
			LPWSTR pwszTemp = NULL;
			pwszTemp = strTime.GetBufferSetLength( dwCount + 1 );

			// now format the date
			GetTimeFormat( LOCALE_USER_DEFAULT, 0, &systimeInstallDate, 
				((bLocaleChanged == TRUE) ? L"HH:mm:ss" : NULL), pwszTemp, dwCount );

			// release the buffer
			strTime.ReleaseBuffer();
		}
		catch( ... )
		{
			SetLastError( E_OUTOFMEMORY );
			SaveLastError();
			return FALSE;
		}

		// prepare the
		try
		{
			// prepare the datetime
			strInstallDate.Format( L"%s, %s", strDate, strTime );
		}
		catch( ... )
		{
			SetLastError( E_OUTOFMEMORY );
			SaveLastError();
			return FALSE;
		}
	}

	// format the numeric data
	try
	{
		// sub-local variables
		CHString str;
		WCHAR wszBuffer[ 33 ] = L"\0";

		//
		// first determine the virtual memory in use
		ULONGLONG ullAvailablePhysicalMemory = 0, ullTotal = 0, ullFree = 0, ullInUse = 0;
		ullFree = (ULONGLONG) ( ((( float ) _wtoi64( strFreeVirtualMemory )) / 1024.0f) + 0.5f );
		ullTotal = (ULONGLONG) ( ((( float ) _wtoi64( strTotalVirtualMemory )) / 1024.0f) + 0.5f );
		ullAvailablePhysicalMemory = (ULONGLONG) ( ((( float ) _wtoi64( strFreePhysicalMemory )) / 1024.0f) + 0.5f );
		ullInUse = ullTotal - ullFree;
		
		//
		// format the virtual memory in use
		_ui64tow( ullInUse, wszBuffer, 10 );					// convert the ulonglong value into string
		if ( FormatNumberEx( wszBuffer, str ) == FALSE )
			return FALSE;

		// ...
		strVirtualMemoryInUse.Format( FMT_MEGABYTES, str );

		//
		// format the available physical memory
		_ui64tow( ullAvailablePhysicalMemory, wszBuffer, 10 );	// convert the ulonglong value into string
		if ( FormatNumberEx( wszBuffer, str ) == FALSE )
			return FALSE;

		// ...
		strFreePhysicalMemory.Format( FMT_MEGABYTES, str );

		//
		// format the virtual memory max.
		_ui64tow( ullTotal, wszBuffer, 10 );					// convert the ulonglong value into string
		if ( FormatNumberEx( wszBuffer, str ) == FALSE )
			return FALSE;

		// ...
		strTotalVirtualMemory.Format( FMT_MEGABYTES, str );

		//
		// format the virtual memory free
		_ui64tow( ullFree, wszBuffer, 10 );					// convert the ulonglong value into string
		if ( FormatNumberEx( wszBuffer, str ) == FALSE )
			return FALSE;

		// ...
		strFreeVirtualMemory.Format( FMT_MEGABYTES, str );
	}
	catch( ... )
	{
		SetLastError( E_OUTOFMEMORY );
		SaveLastError();
		return FALSE;
	}

	//
	// save the info in dynamic array
	DynArraySetString2( m_arrData, 0, CI_HOSTNAME, strHostName, 0 );
	DynArraySetString2( m_arrData, 0, CI_OS_NAME, strName, 0 );
	DynArraySetString2( m_arrData, 0, CI_OS_VERSION, strVersion, 0 );
	DynArraySetString2( m_arrData, 0, CI_OS_MANUFACTURER, strManufacturer, 0 );
	DynArraySetString2( m_arrData, 0, CI_OS_BUILDTYPE, strBuildType, 0 );
	DynArraySetString2( m_arrData, 0, CI_REG_OWNER, strOwner, 0 );
	DynArraySetString2( m_arrData, 0, CI_REG_ORG, strOrganization, 0 );
	DynArraySetString2( m_arrData, 0, CI_PRODUCT_ID, strSerialNumber, 0 );
	DynArraySetString2( m_arrData, 0, CI_INSTALL_DATE, strInstallDate, 0 );
	DynArraySetString2( m_arrData, 0, CI_WINDOWS_DIRECTORY, strWindowsDir, 0 );
	DynArraySetString2( m_arrData, 0, CI_SYSTEM_DIRECTORY, strSystemDir, 0 );
	DynArraySetString2( m_arrData, 0, CI_BOOT_DEVICE, strBootDevice, 0 );
	DynArraySetString2( m_arrData, 0, CI_SYSTEM_LOCALE, strLocale, 0 );
	DynArraySetString2( m_arrData, 0, CI_AVAILABLE_PHYSICAL_MEMORY, strFreePhysicalMemory, 0 );
	DynArraySetString2( m_arrData, 0, CI_VIRTUAL_MEMORY_MAX, strTotalVirtualMemory, 0 );
	DynArraySetString2( m_arrData, 0, CI_VIRTUAL_MEMORY_AVAILABLE, strFreeVirtualMemory, 0 );
	DynArraySetString2( m_arrData, 0, CI_VIRTUAL_MEMORY_INUSE, strVirtualMemoryInUse, 0 );

	// return success
	return TRUE;
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
BOOL CSystemInfo::LoadComputerInfo()
{
	// local variables
	HRESULT hr;
	ULONG ulReturned = 0;
	CHString strDomainRole;
	CHString strTotalPhysicalMemory;
	IWbemClassObject* pWbemObject = NULL;
	IEnumWbemClassObject* pWbemEnum = NULL;

	// property values
	CHString strModel;
	DWORD dwDomainRole;
	CHString strDomain;
	CHString strSystemType;
	CHString strManufacturer;
	ULONGLONG ullTotalPhysicalMemory;

	// display the status message
	PrintProgressMsg( m_hOutput, MSG_COMPINFO, m_csbi );

	try
	{
		// enumerate the instances of Win32_ComputerSystem class 
		hr = m_pWbemServices->CreateInstanceEnum( _bstr_t( WIN32_COMPUTERSYSTEM ),
			WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY, NULL, &pWbemEnum );
		
		// check the result of enumeration
		if ( FAILED( hr ) )
		{
			WMISaveError( hr );
			return FALSE;
		}
	}
	catch( _com_error& e )
	{
		WMISaveError( e );
		return FALSE;
	}

	// set the security on the obtained interface
	hr = SetInterfaceSecurity( pWbemEnum, m_pAuthIdentity );
	if ( FAILED( hr ) )
	{
		WMISaveError( hr );
		return FALSE;
	}

	// get the enumerated objects information
	// NOTE: This needs to be traversed only one time. 
	hr = pWbemEnum->Next( WBEM_INFINITE, 1, &pWbemObject, &ulReturned );
	if ( FAILED( hr ) )
	{
		// some error has occured ... oooppps
		WMISaveError( hr );
		return FALSE;
	}

	// get the propert information
	PropertyGet( pWbemObject, WIN32_COMPUTERSYSTEM_P_MODEL, strModel );
	PropertyGet( pWbemObject, WIN32_COMPUTERSYSTEM_P_DOMAIN, strDomain );
	PropertyGet( pWbemObject, WIN32_COMPUTERSYSTEM_P_USERNAME, m_strLogonUser );
	PropertyGet( pWbemObject, WIN32_COMPUTERSYSTEM_P_DOMAINROLE, dwDomainRole );
	PropertyGet( pWbemObject, WIN32_COMPUTERSYSTEM_P_SYSTEMTYPE, strSystemType );
	PropertyGet( pWbemObject, WIN32_COMPUTERSYSTEM_P_MANUFACTURER, strManufacturer );
	PropertyGet( pWbemObject, WIN32_COMPUTERSYSTEM_P_TOTALPHYSICALMEMORY, ullTotalPhysicalMemory );

	// relase the interfaces
	SAFE_RELEASE( pWbemEnum );
	SAFE_RELEASE( pWbemObject );

	//
	// do the needed formatting the information obtained
	//

	// convert the total physical memory from KB into MB
	try
	{
		// NOTE:
		// ----
		// The max. value of 
		// (2 ^ 64) - 1 = "18,446,744,073,709,600,000 K"  (29 chars).
		//              = "18,014,398,509,482,031 M"      (22 chars).
		// 
		// so, the buffer size to store the number is fixed as 32 characters 
		// which is more than the 29 characters in actuals

		// sub-local variables
		CHString str;
		WCHAR wszBuffer[ 33 ] = L"\0";

		// convert the value first ( take care of rounding )
		ullTotalPhysicalMemory = 
			(ULONGLONG) (( ((float) ullTotalPhysicalMemory) / (1024.0f * 1024.0f)) + 0.5f);

		// now ULONGLONG to string 
		_ui64tow( ullTotalPhysicalMemory, wszBuffer, 10 );

		// get the formatted number
		if ( FormatNumberEx( wszBuffer, str ) == FALSE )
			return FALSE;
	
		// ...
		strTotalPhysicalMemory.Format( FMT_MEGABYTES, str );
	}
	catch( ... )
	{
		SetLastError( E_OUTOFMEMORY );
		SaveLastError();
		return FALSE;
	}

	// map the domain role from numeric value to appropriate text value
	try
	{
		// 
		// Mapping information of Win32_ComputerSystem's DomainRole property
		// NOTE: Refer to the _DSROLE_MACHINE_ROLE enumeration values in DsRole.h header file
		switch( dwDomainRole )
		{
		case DsRole_RoleStandaloneWorkstation:
			strDomainRole = VALUE_STANDALONEWORKSTATION;
			break;

		case DsRole_RoleMemberWorkstation:
			strDomainRole = VALUE_MEMBERWORKSTATION;
			break;
		
		case DsRole_RoleStandaloneServer:
			strDomainRole = VALUE_STANDALONESERVER;
			break;
		
		case DsRole_RoleMemberServer:
			strDomainRole = VALUE_MEMBERSERVER;
			break;
		
		case DsRole_RoleBackupDomainController:
			strDomainRole = VALUE_BACKUPDOMAINCONTROLLER;
			break;
		
		case DsRole_RolePrimaryDomainController:
			strDomainRole = VALUE_PRIMARYDOMAINCONTROLLER;
			break;
		}
	}
	catch( ... )
	{
		SetLastError( E_OUTOFMEMORY );
		SaveLastError();
		return FALSE;
	}

	//
	// save the info in dynamic array
	DynArraySetString2( m_arrData, 0, CI_DOMAIN, strDomain, 0 );
	DynArraySetString2( m_arrData, 0, CI_SYSTEM_MODEL, strModel, 0 );
	DynArraySetString2( m_arrData, 0, CI_OS_CONFIG, strDomainRole, 0 );
	DynArraySetString2( m_arrData, 0, CI_SYSTEM_TYPE, strSystemType, 0 );
	DynArraySetString2( m_arrData, 0, CI_SYSTEM_MANUFACTURER, strManufacturer, 0 );
	DynArraySetString2( m_arrData, 0, CI_TOTAL_PHYSICAL_MEMORY, strTotalPhysicalMemory, 0 );

	// return success
	return TRUE;
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
BOOL CSystemInfo::LoadBiosInfo()
{
	// local variables
	HRESULT hr;
	ULONG ulReturned = 0;
	IWbemClassObject* pWbemObject = NULL;
	IEnumWbemClassObject* pWbemEnum = NULL;

	// property values
	CHString strVersion;

	// display the status message
	PrintProgressMsg( m_hOutput, MSG_BIOSINFO, m_csbi );

	try
	{
		// enumerate the instances of Win32_BIOS class 
		hr = m_pWbemServices->CreateInstanceEnum( _bstr_t( WIN32_BIOS ),
			WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY, NULL, &pWbemEnum );
		
		// check the result of enumeration
		if ( FAILED( hr ) )
		{
			WMISaveError( hr );
			return FALSE;
		}
	}
	catch( _com_error& e )
	{
		WMISaveError( e );
		return FALSE;
	}

	// set the security on the obtained interface
	hr = SetInterfaceSecurity( pWbemEnum, m_pAuthIdentity );
	if ( FAILED( hr ) )
	{
		WMISaveError( hr );
		return FALSE;
	}

	// get the enumerated objects information
	// NOTE: This needs to be traversed only one time. 
	hr = pWbemEnum->Next( WBEM_INFINITE, 1, &pWbemObject, &ulReturned );
	if ( FAILED( hr ) )
	{
		// some error has occured ... oooppps
		WMISaveError( hr );
		return FALSE;
	}

	// get the propert information
	PropertyGet( pWbemObject, WIN32_BIOS_P_VERSION, strVersion );

	// relase the interfaces
	SAFE_RELEASE( pWbemEnum );
	SAFE_RELEASE( pWbemObject );

	//
	// save the info in dynamic array
	DynArraySetString2( m_arrData, 0, CI_BIOS_VERSION, strVersion, 0 );

	// return
	return TRUE;
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
BOOL CSystemInfo::LoadTimeZoneInfo()
{
	// local variables
	HRESULT hr;
	ULONG ulReturned = 0;
	IWbemClassObject* pWbemObject = NULL;
	IEnumWbemClassObject* pWbemEnum = NULL;

	// property values
	CHString strCaption;

	// display the status message
	PrintProgressMsg( m_hOutput, MSG_TZINFO, m_csbi );

	try
	{
		// enumerate the instances of Win32_TimeZone class 
		hr = m_pWbemServices->CreateInstanceEnum( _bstr_t( WIN32_TIMEZONE ),
			WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY, NULL, &pWbemEnum );
		
		// check the result of enumeration
		if ( FAILED( hr ) )
		{
			WMISaveError( hr );
			return FALSE;
		}
	}
	catch( _com_error& e )
	{
		WMISaveError( e );
		return FALSE;
	}

	// set the security on the obtained interface
	hr = SetInterfaceSecurity( pWbemEnum, m_pAuthIdentity );
	if ( FAILED( hr ) )
	{
		WMISaveError( hr );
		return FALSE;
	}

	// get the enumerated objects information
	// NOTE: This needs to be traversed only one time. 
	hr = pWbemEnum->Next( WBEM_INFINITE, 1, &pWbemObject, &ulReturned );
	if ( FAILED( hr ) )
	{
		// some error has occured ... oooppps
		WMISaveError( hr );
		return FALSE;
	}

	// get the propert information
	PropertyGet( pWbemObject, WIN32_TIMEZONE_P_CAPTION, strCaption );

	// relase the interfaces
	SAFE_RELEASE( pWbemEnum );
	SAFE_RELEASE( pWbemObject );

	//
	// save the info in dynamic array
	DynArraySetString2( m_arrData, 0, CI_TIME_ZONE, strCaption, 0 );

	// return
	return TRUE;
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
BOOL CSystemInfo::LoadPageFileInfo()
{
	// local variables
	HRESULT hr;
	ULONG ulReturned = 0;
	TARRAY arrValues = NULL;
	IWbemClassObject* pWbemObject = NULL;
	IEnumWbemClassObject* pWbemEnum = NULL;

	// property values
	CHString strCaption;

	// display the status message
	PrintProgressMsg( m_hOutput, MSG_PAGEFILEINFO, m_csbi );

	try
	{
		// enumerate the instances of Win32_PageFile class 
		hr = m_pWbemServices->CreateInstanceEnum( _bstr_t( WIN32_PAGEFILE ),
			WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY, NULL, &pWbemEnum );
		
		// check the result of enumeration
		if ( FAILED( hr ) )
		{
			WMISaveError( hr );
			return FALSE;
		}
	}
	catch( _com_error& e )
	{
		WMISaveError( e );
		return FALSE;
	}

	// set the security on the obtained interface
	hr = SetInterfaceSecurity( pWbemEnum, m_pAuthIdentity );
	if ( FAILED( hr ) )
	{
		WMISaveError( hr );
		return FALSE;
	}

	// get the enumerated objects information
	// NOTE: This needs to be traversed only one time. 
	do
	{
		hr = pWbemEnum->Next( WBEM_INFINITE, 1, &pWbemObject, &ulReturned );
		if ( hr == WBEM_S_FALSE )
		{
			// we've reached the end of enumeration .. go out of the loop
			break;
		}
		else if ( FAILED( hr ) )
		{
			// some error has occured ... oooppps
			WMISaveError( hr );
			return FALSE;
		}

		// get the propert information
		PropertyGet( pWbemObject, WIN32_PAGEFILE_P_NAME, strCaption );

		// release the current object
		SAFE_RELEASE( pWbemObject );

		// add the values to the data
		if ( arrValues == NULL )
		{
			arrValues = DynArrayItem2( m_arrData, 0, CI_PAGEFILE_LOCATION );
			if ( arrValues == NULL )
			{
				SetLastError( E_UNEXPECTED );
				SaveLastError();
				return FALSE;
			}

			// remove all the existing entries
			DynArrayRemoveAll( arrValues );
		}

		// add the data
		DynArrayAppendString( arrValues, strCaption, 0 );
	} while ( 1 );

	// release the enumerated object
	SAFE_RELEASE( pWbemEnum );

	// return
	return TRUE;
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
BOOL CSystemInfo::LoadProcessorInfo()
{
	// local variables
	HRESULT hr;
	CHString str;
	DWORD dwCount = 0;
	ULONG ulReturned = 0;
	TARRAY arrValues = NULL;
	IWbemClassObject* pWbemObject = NULL;
	IEnumWbemClassObject* pWbemEnum = NULL;

	// property values
	DWORD dwClockSpeed;
	CHString strCaption;
	CHString strManufacturer;

	// display the status message
	PrintProgressMsg( m_hOutput, MSG_PROCESSORINFO, m_csbi );

	try
	{
		// enumerate the instances of Win32_Processor class 
		hr = m_pWbemServices->CreateInstanceEnum( _bstr_t( WIN32_PROCESSOR ),
			WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY, NULL, &pWbemEnum );
		
		// check the result of enumeration
		if ( FAILED( hr ) )
		{
			WMISaveError( hr );
			return FALSE;
		}
	}
	catch( _com_error& e )
	{
		WMISaveError( e );
		return FALSE;
	}

	// set the security on the obtained interface
	hr = SetInterfaceSecurity( pWbemEnum, m_pAuthIdentity );
	if ( FAILED( hr ) )
	{
		WMISaveError( hr );
		return FALSE;
	}

	// get the enumerated objects information
	try
	{
		do
		{
			hr = pWbemEnum->Next( WBEM_INFINITE, 1, &pWbemObject, &ulReturned );
			if ( hr == WBEM_S_FALSE )
			{
				// we've reached the end of enumeration .. go out of the loop
				break;
			}
			else if ( FAILED( hr ) )
			{
				// some error has occured ... oooppps
				WMISaveError( hr );
				return FALSE;
			}

			// update the counter
			dwCount++;

			// get the propert information
			PropertyGet( pWbemObject, WIN32_PROCESSOR_P_CAPTION, strCaption );
			PropertyGet( pWbemObject, WIN32_PROCESSOR_P_MANUFACTURER, strManufacturer );
			PropertyGet( pWbemObject, WIN32_PROCESSOR_P_CURRENTCLOCKSPEED, dwClockSpeed );

			// check whether we got the clock speed correctly or not
			// if not, get the max. clock speed
			if ( dwClockSpeed == 0 )
				PropertyGet( pWbemObject, WIN32_PROCESSOR_P_MAXCLOCKSPEED, dwClockSpeed );

			// release the current object
			SAFE_RELEASE( pWbemObject );

			// add the values to the data
			if ( arrValues == NULL )
			{
				arrValues = DynArrayItem2( m_arrData, 0, CI_PROCESSOR );
				if ( arrValues == NULL )
				{
					SetLastError( E_UNEXPECTED );
					SaveLastError();
					return FALSE;
				}

				// remove all the existing entries
				DynArrayRemoveAll( arrValues );
			}

			//
			// prepare the processor info
			str.Format( FMT_PROCESSOR_INFO, dwCount, strCaption, strManufacturer, dwClockSpeed );

			// add the data
			DynArrayAppendString( arrValues, str, 0 );
		} while ( 1 );

		// release the enumerated object
		SAFE_RELEASE( pWbemEnum );

		// update the total no. of processors info
		if ( arrValues != NULL )
		{
			// NOTE: this should appear at the first line
			str.Format( FMT_PROCESSOR_TOTAL, dwCount );
			DynArrayInsertString( arrValues, 0, str, 0 );
		}
	}
	catch( ... )
	{
		SetLastError( E_OUTOFMEMORY );
		SaveLastError();
		return FALSE;
	}

	// return
	return TRUE;
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
BOOL CSystemInfo::LoadKeyboardInfo()
{
	// local variables
	HRESULT hr;
	ULONG ulReturned = 0;
	IWbemClassObject* pWbemObject = NULL;
	IEnumWbemClassObject* pWbemEnum = NULL;

	// property values
	CHString strLayout;

	// display the status message
	PrintProgressMsg( m_hOutput, MSG_INPUTLOCALEINFO, m_csbi );

	try
	{
		// enumerate the instances of Win32_Keyboard class 
		hr = m_pWbemServices->CreateInstanceEnum( _bstr_t( WIN32_KEYBOARD ),
			WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY, NULL, &pWbemEnum );
		
		// check the result of enumeration
		if ( FAILED( hr ) )
		{
			WMISaveError( hr );
			return FALSE;
		}
	}
	catch( _com_error& e )
	{
		WMISaveError( e );
		return FALSE;
	}

	// set the security on the obtained interface
	hr = SetInterfaceSecurity( pWbemEnum, m_pAuthIdentity );
	if ( FAILED( hr ) )
	{
		WMISaveError( hr );
		return FALSE;
	}

	// get the enumerated objects information
	// NOTE: This needs to be traversed only one time. 
	hr = pWbemEnum->Next( WBEM_INFINITE, 1, &pWbemObject, &ulReturned );
	if ( FAILED( hr ) )
	{
		// some error has occured ... oooppps
		WMISaveError( hr );
		return FALSE;
	}

	// get the propert information
	PropertyGet( pWbemObject, WIN32_KEYBOARD_P_LAYOUT, strLayout );

	// relase the interfaces
	SAFE_RELEASE( pWbemEnum );
	SAFE_RELEASE( pWbemObject );

	// convert the code page into appropriate text
	TranslateLocaleCode( strLayout );

	//
	// save the info in dynamic array
 	DynArraySetString2( m_arrData, 0, CI_INPUT_LOCALE, strLayout, 0 );

	// return
	return TRUE;
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
BOOL CSystemInfo::LoadHotfixInfo()
{
	// local variables
	HRESULT hr;
	CHString str;
	DWORD dwCount = 0;
	ULONG ulReturned = 0;
	TARRAY arrValues = NULL;
	IWbemClassObject* pWbemObject = NULL;
	IEnumWbemClassObject* pWbemEnum = NULL;

	// property values
	CHString strHotFix;
	CHString strComments;

	// display the status message
	PrintProgressMsg( m_hOutput, MSG_HOTFIXINFO, m_csbi );

	try
	{
		// enumerate the instances of Win32_QuickFixEngineering class 
		hr = m_pWbemServices->CreateInstanceEnum( _bstr_t( WIN32_QUICKFIXENGINEERING ),
			WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY, NULL, &pWbemEnum );
		
		// check the result of enumeration
		if ( FAILED( hr ) )
		{
			WMISaveError( hr );
			return FALSE;
		}
	}
	catch( _com_error& e )
	{
		WMISaveError( e );
		return FALSE;
	}

	// set the security on the obtained interface
	hr = SetInterfaceSecurity( pWbemEnum, m_pAuthIdentity );
	if ( FAILED( hr ) )
	{
		WMISaveError( hr );
		return FALSE;
	}

	// get the enumerated objects information
	try
	{
		do
		{
			hr = pWbemEnum->Next( WBEM_INFINITE, 1, &pWbemObject, &ulReturned );
			if ( hr == WBEM_S_FALSE )
			{
				// we've reached the end of enumeration .. go out of the loop
				break;
			}
			else if ( FAILED( hr ) )
			{
				// some error has occured ... oooppps
				WMISaveError( hr );
				return FALSE;
			}

			// update the counter
			dwCount++;

			// get the propert information
			PropertyGet( pWbemObject, WIN32_QUICKFIXENGINEERING_P_HOTFIXID, strHotFix );
			PropertyGet( pWbemObject, WIN32_QUICKFIXENGINEERING_P_FIXCOMMENTS, strComments );

			// release the current object
			SAFE_RELEASE( pWbemObject );

			// add the values to the data
			if ( arrValues == NULL )
			{
				arrValues = DynArrayItem2( m_arrData, 0, CI_HOTFIX );
				if ( arrValues == NULL )
				{
					SetLastError( E_UNEXPECTED );
					SaveLastError();
					return FALSE;
				}

				// remove all the existing entries
				DynArrayRemoveAll( arrValues );
			}

			// check if fix comments were available or not
			// if available, append that to the the hot fix number
			if ( strComments.GetLength() != 0 )
				strHotFix += L" - " + strComments;

			// prepare the hot fix info
			str.Format( FMT_HOTFIX_INFO, dwCount, strHotFix );

			// add the data
			DynArrayAppendString( arrValues, str, 0 );
		} while ( 1 );

		// release the enumerated object
		SAFE_RELEASE( pWbemEnum );

		// update the total no. of hotfix's info
		if ( arrValues != NULL )
		{
			// NOTE: this should appear at the first line
			str.Format( FMT_HOTFIX_TOTAL, dwCount );
			DynArrayInsertString( arrValues, 0, str, 0 );
		}
	}
	catch( ... )
	{
		SetLastError( E_OUTOFMEMORY );
		SaveLastError();
		return FALSE;
	}


	// return 
	return TRUE;
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
BOOL CSystemInfo::LoadPerformanceInfo()
{
	// local variables
	HRESULT hr;
	CHString strUpTime;
	ULONG ulReturned = 0;
	ULONGLONG ullSysUpTime = 0;
	ULONGLONG ullElapsedTime = 0;
	ULONGLONG ullFrequencyObject = 0;
	ULONGLONG ullTimestampObject = 0;
	IWbemClassObject* pWbemObject = NULL;
	IEnumWbemClassObject* pWbemEnum = NULL;
	DWORD dwDays = 0, dwHours = 0, dwMinutes = 0, dwSeconds = 0;

	// display the status message
	PrintProgressMsg( m_hOutput, MSG_PERFINFO, m_csbi );

	try
	{
		// enumerate the instances of Win32_PerfRawData_PerfOS_System class 
		hr = m_pWbemServices->CreateInstanceEnum( _bstr_t( WIN32_PERFRAWDATA_PERFOS_SYSTEM ),
			WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY, NULL, &pWbemEnum );
		
		// check the result of enumeration
		if ( FAILED( hr ) )
		{
			WMISaveError( hr );
			return FALSE;
		}
	}
	catch( _com_error& e )
	{
		WMISaveError( e );
		return FALSE;
	}

	// set the security on the obtained interface
	hr = SetInterfaceSecurity( pWbemEnum, m_pAuthIdentity );
	if ( FAILED( hr ) )
	{
		WMISaveError( hr );
		return FALSE;
	}

	// get the enumerated objects information
	// NOTE: This needs to be traversed only one time. 
	hr = pWbemEnum->Next( WBEM_INFINITE, 1, &pWbemObject, &ulReturned );
	if ( FAILED( hr ) )
	{
		// some error has occured ... oooppps
		WMISaveError( hr );
		return FALSE;
	}

	// get the performance information
	PropertyGet( pWbemObject, WIN32_PERFRAWDATA_PERFOS_SYSTEM_P_SYSUPTIME, ullSysUpTime );
	PropertyGet( pWbemObject, WIN32_PERFRAWDATA_PERFOS_SYSTEM_P_TIMESTAMP, ullTimestampObject );
	PropertyGet( pWbemObject, WIN32_PERFRAWDATA_PERFOS_SYSTEM_P_FREQUENCY, ullFrequencyObject );

	// ( performance_time_object - system_up_time ) / frequency_object = elapsed_time
	// NOTE: take care of divide by zero errors.
	if ( ullFrequencyObject == 0 )
	{
		SetLastError( STG_E_UNKNOWN );
		SaveLastError();
		return FALSE;
	}

	// ...
	ullElapsedTime = ( ullTimestampObject - ullSysUpTime ) / ullFrequencyObject;

	//
	// in calculations currently assuming as differences will not cross 2 ^ 32 value
	//

	// no. of days = elapsed_time / 86400
	// update with elapsed_time %= 86400
	dwDays = (DWORD) (ullElapsedTime / 86400);
	ullElapsedTime %= 86400;

	// no. of hours = elapsed_time / 3600
	// update with elapsed_time %= 3600
	dwHours = (DWORD) (ullElapsedTime / 3600);
	ullElapsedTime %= 3600;

	// no. of minutes = elapsed_time / 60
	// no. of seconds = elapsed_time % 60
	dwMinutes = (DWORD) (ullElapsedTime / 60);
	dwSeconds = (DWORD) (ullElapsedTime % 60);

	try
	{
		// now prepare the system up time information
		strUpTime.Format( FMT_UPTIME, dwDays, dwHours, dwMinutes, dwSeconds );
	}
	catch( ... )
	{
		SetLastError( E_OUTOFMEMORY );
		SaveLastError();
		return FALSE;
	}


	// save the info
	DynArraySetString2( m_arrData, 0, CI_SYSTEM_UPTIME, strUpTime, 0 );

	// return
	return TRUE;
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
BOOL CSystemInfo::LoadNetworkCardInfo()
{
	// local variables
	HRESULT hr;
	CHString str;
	DWORD dwCount = 0;
	DWORD dwStatus = 0;
	BOOL bResult = FALSE;
	ULONG ulReturned = 0;
	TARRAY arrValues = NULL;
	IWbemClassObject* pWbemObject = NULL;
	IEnumWbemClassObject* pWbemEnum = NULL;

	// property values
	DWORD dwIndex = 0;
	CHString strConnection;
	CHString strDescription;

	// display the status message
	PrintProgressMsg( m_hOutput, MSG_NICINFO, m_csbi );

	try
	{
		// enumerate the instances of Win32_NetworkAdapter class 
		hr = m_pWbemServices->CreateInstanceEnum( _bstr_t( WIN32_NETWORKADAPTER ),
			WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY, NULL, &pWbemEnum );
		
		// check the result of enumeration
		if ( FAILED( hr ) )
		{
			WMISaveError( hr );
			return FALSE;
		}
	}
	catch( _com_error& e )
	{
		WMISaveError( e );
		return FALSE;
	}

	// set the security on the obtained interface
	hr = SetInterfaceSecurity( pWbemEnum, m_pAuthIdentity );
	if ( FAILED( hr ) )
	{
		WMISaveError( hr );
		return FALSE;
	}

	// get the enumerated objects information
	try
	{
		do
		{
			hr = pWbemEnum->Next( WBEM_INFINITE, 1, &pWbemObject, &ulReturned );
			if ( hr == WBEM_S_FALSE )
			{
				// we've reached the end of enumeration .. go out of the loop
				break;
			}
			else if ( FAILED( hr ) )
			{
				// some error has occured ... oooppps
				WMISaveError( hr );
				return FALSE;
			}

			// get the property information
			// NOTE: get the result of getting status property information
			PropertyGet( pWbemObject, WIN32_NETWORKADAPTER_P_INDEX, dwIndex );
			PropertyGet( pWbemObject, WIN32_NETWORKADAPTER_P_DESCRIPTION, strDescription );
			PropertyGet( pWbemObject, WIN32_NETWORKADAPTER_P_NETCONNECTIONID, strConnection );
			bResult = PropertyGet( pWbemObject, WIN32_NETWORKADAPTER_P_STATUS, dwStatus, -1 );

			// release the current object
			SAFE_RELEASE( pWbemObject );

			// add the values to the data
			// NOTE: do this only if either we couldn't find the property or status is not -1
			//       FOR WINDOWS 2000 MACHINES 'NetConnectionStatus' PROPERT IS NOT EXISTED IN
			//       WMI 'Win32_NetworkAdapter' CLASS. SO WE WILL BE DISPLAYING THE N/W CARD
			//       INFORMATION IF PROPERTY DOESN'T EXIST OR IF EXISTS AND THE STATUS IS NOT -1
			if ( bResult == FALSE || dwStatus != -1 )
			{
				// update the counter
				dwCount++;

				if ( arrValues == NULL )
				{
					arrValues = DynArrayItem2( m_arrData, 0, CI_NETWORK_CARD );
					if ( arrValues == NULL )
					{
						SetLastError( E_UNEXPECTED );
						SaveLastError();
						return FALSE;
					}

					// remove all the existing entries
					DynArrayRemoveAll( arrValues );
				}

				// prepare the n/w card info
				str.Format( FMT_NIC_INFO, dwCount, strDescription );

				// add the data
				DynArrayAppendString( arrValues, str, 0 );

				// now check the status in detail ... only if the property exists
				if ( bResult == TRUE )
				{
					//
					// property do exists ... so determine the status
					// display the status of the NIC except it is connected
					// if the NIC is connected, display the ipaddress and its other information

					// add the connection name
					str.Format( FMT_CONNECTION, strConnection );
					DynArrayAppendString( arrValues, str, 0 );

					// ...
					if ( dwStatus != 2 )
					{
						// sub-local variables
						CHString strValues[] = { 
							VALUE_DISCONNECTED, VALUE_CONNECTING, 
							VALUE_CONNECTED, VALUE_DISCONNECTING, VALUE_HWNOTPRESENT, 
							VALUE_HWDISABLED, VALUE_HWMALFUNCTION, VALUE_MEDIADISCONNECTED, 
							VALUE_AUTHENTICATING, VALUE_AUTHSUCCEEDED, VALUE_AUTHFAILED };

						// prepare the status info
						if ( dwStatus > 0 && dwStatus < SIZE_OF_ARRAY( strValues ) )
						{
							// ...
							str.Format( FMT_NIC_STATUS, strValues[ dwStatus ] );

							// save the info
							DynArrayAppendString( arrValues, str, 0 );
						}
					}
					else
					{
						//
						// get the adapter configuration

						// sub-local variables
						DWORD dwCount = 0;
						CHString strTemp;
						CHString strDhcpServer;
						DWORD dwDhcpEnabled = 0;
						TARRAY arrIPAddress = NULL;

						// create the ipaddress array
						arrIPAddress = CreateDynamicArray();
						if ( arrIPAddress == NULL )
						{
							WMISaveError( E_OUTOFMEMORY );
							return FALSE;
						}

						// prepare the object path
						str.Format( WIN32_NETWORKADAPTERCONFIGURATION_GET, dwIndex );

						// get the nic config info object
						hr = m_pWbemServices->GetObject( _bstr_t( str ), 
							WBEM_FLAG_RETURN_WBEM_COMPLETE, NULL, &pWbemObject, NULL );

						// check the result .. proceed furthur only if successfull
						if ( SUCCEEDED( hr ) )
						{
							// get the needed property values
							PropertyGet( pWbemObject, WIN32_NETWORKADAPTERCONFIGURATION_P_IPADDRESS, arrIPAddress );
							PropertyGet( pWbemObject, WIN32_NETWORKADAPTERCONFIGURATION_P_DHCPSERVER, strDhcpServer );
							PropertyGet( pWbemObject, WIN32_NETWORKADAPTERCONFIGURATION_P_DHCPENABLED, dwDhcpEnabled );

							// check and add the dhcp information
							// NOTE: CIM_BOOLEAN -> TRUE = -1, FALSE = 0
							strTemp = FMT_DHCP_STATUS;
							str.Format( strTemp,  ( ( dwDhcpEnabled == -1 ) ? VALUE_YES : VALUE_NO ) );
							DynArrayAppendString( arrValues, str, 0 );

							// add the dhcp server info ( if needed )
							if ( dwDhcpEnabled == -1 )
							{
								str.Format( FMT_DHCP_SERVER, strDhcpServer );
								DynArrayAppendString( arrValues, str, 0 );
							}

							//
							// add the IP Address information
							DynArrayAppendString( arrValues, FMT_IPADDRESS_TOTAL, 0 );

							dwCount = DynArrayGetCount( arrIPAddress );
							for( DWORD dw = 0; dw < dwCount; dw++ )
							{
								// get the info
								LPCWSTR pwsz = NULL;
								pwsz = DynArrayItemAsString( arrIPAddress, dw );
								if ( pwsz == NULL )
									continue;

								// prepare and add the info
								str.Format( FMT_IPADDRESS_INFO, dw + 1, pwsz );
								DynArrayAppendString( arrValues, str, 0 );
							}
						}

						// release the object
						SAFE_RELEASE( pWbemObject );

						// destroy the dynamic array created for storing ip address info
						DestroyDynamicArray( &arrIPAddress );
					}
				}
			}
		} while ( 1 );

		// release the enumerated object
		SAFE_RELEASE( pWbemEnum );

		// update the total no. of hotfix's info
		if ( arrValues != NULL )
		{
			// NOTE: this should appear at the first line
			str.Format( FMT_NIC_TOTAL, dwCount );
			DynArrayInsertString( arrValues, 0, str, 0 );
		}
	}
	catch( ... )
	{
		WMISaveError( E_OUTOFMEMORY );
		return FALSE;
	}

	// return 
	return TRUE;
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
BOOL CSystemInfo::LoadProfileInfo()
{
	// local variables
	HRESULT hr;
	CHString strLogonServer;
	LPCWSTR pwszPassword = NULL;
	IWbemServices* pDefaultNamespace = NULL;

	// display the status message
	PrintProgressMsg( m_hOutput, MSG_PROFILEINFO, m_csbi );

	// determine the password with which connection to default name has to be made
	pwszPassword = NULL;
	if ( m_pAuthIdentity != NULL )
		pwszPassword = m_pAuthIdentity->Password;

	// we need to establish connection to the remote system's registry
	// for this connect to the default namespace of the WMI using the credentials available with us
	hr = ConnectWmi( m_pWbemLocator, &pDefaultNamespace, 
		m_strServer, m_strUserName, pwszPassword, &m_pAuthIdentity, FALSE, WMI_NAMESPACE_DEFAULT );
	if ( FAILED( hr ) )
		return FALSE;

	// get the value of the LOGONSERVER
	RegQueryValueWMI( pDefaultNamespace, WMI_HKEY_CURRENT_USER, 
		SUBKEY_VOLATILE_ENVIRONMENT, KEY_LOGONSERVER, strLogonServer );
	
	//
	// save the info
	DynArraySetString2( m_arrData, 0, CI_LOGON_SERVER, strLogonServer, 0 );

	// return
	return TRUE;
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
VOID PrintProgressMsg( HANDLE hOutput, LPCWSTR pwszMsg, const CONSOLE_SCREEN_BUFFER_INFO& csbi )
{
	// local variables
	COORD coord; 
	DWORD dwSize = 0;
	WCHAR wszSpaces[ 80 ] = L"";

	// check the handle. if it is null, it means that output is being redirected. so return
	if ( hOutput == NULL )
		return;

	// set the cursor position
    coord.X = 0;
    coord.Y = csbi.dwCursorPosition.Y;

	// first erase contents on the current line
	ZeroMemory( wszSpaces, 80 );
	SetConsoleCursorPosition( hOutput, coord );
	WriteConsoleW( hOutput, Replicate( wszSpaces, L"", 79 ), 79, &dwSize, NULL );

	// now display the message ( if exists )
	SetConsoleCursorPosition( hOutput, coord );
	if ( pwszMsg != NULL )
		WriteConsoleW( hOutput, pwszMsg, lstrlen( pwszMsg ), &dwSize, NULL );
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
BOOL TranslateLocaleCode( CHString& strLocale )
{
	// local variables
	CHString str;
	HKEY hKey = NULL;
	DWORD dwSize = 0;
    LONG lRegReturn = 0;
	HKEY hMainKey = NULL;
	WCHAR wszValue[ 64 ] = L"\0";

	//
	// THIS IS A TYPICAL THING WHICH WE ARE DOING HERE
	// BECAUSE WE DONT KNOW WHAT LANGUAGE TARGET MACHINE IS USING
	// SO WE GET THE LOCALE CODE PAGE BEING USED BY THE TARGET MACHINE
	// AND GET THE APPROPRIATE NAME FOR THAT LOCALE FROM THE CURRENT SYSTEM
	// REGISTRY DATABASE. IF THE REGISTRY IS CORRUPTED THEN THERE IS NO WAY
	// TO JUDGE THE OUTPUT THAT DISPLAYED BY THIS UTILITY IS VALID OR INVALID
	// 

	try
	{
		// get the reference to the promary hive
		lRegReturn = RegConnectRegistry( NULL, HKEY_CLASSES_ROOT, &hMainKey );
		if ( lRegReturn != ERROR_SUCCESS ) 
		{
			SaveLastError();
			return FALSE;
		}
		else if ( hMainKey == NULL )
		{
			// THIS IS MEANING LESS IN DOING
			// BUT JUST TO AVOID PREfix BUG THIS PART IS WRITTEN
			SetLastError( E_OUTOFMEMORY );
			SaveLastError();
			return FALSE;
		}

		// now get the reference to the database path
		lRegReturn = RegOpenKeyEx( hMainKey, LOCALE_PATH, 0, KEY_QUERY_VALUE, &hKey);
		if ( lRegReturn != ERROR_SUCCESS )
		{
			switch( lRegReturn )
			{
			case ERROR_FILE_NOT_FOUND:
				SetLastError( ERROR_REGISTRY_CORRUPT );
				break;

			default:
				// save the error information and return FAILURE
				SetLastError( lRegReturn );
				break;
			}

			// close the key and return
			SaveLastError();
			RegCloseKey( hMainKey );
			return FALSE;
		}
		else if ( hKey == NULL )
		{
			// THIS IS MEANING LESS IN DOING
			// BUT JUST TO AVOID PREfix BUG THIS PART IS WRITTEN
			SetLastError( E_OUTOFMEMORY );
			SaveLastError();
			return FALSE;
		}

		// we are interested in the last 4 characters of the code page info
		str = strLocale.Right( 4 );

		//copy the last four charecters in to the string to get the locale
		dwSize = SIZE_OF_ARRAY( wszValue );
		lRegReturn = RegQueryValueExW( hKey, str, NULL, NULL, ( LPBYTE ) wszValue, &dwSize);

		// first close the registry handles
		RegCloseKey( hKey );
		RegCloseKey( hMainKey );

		// now check the return value
		if( lRegReturn != ERROR_SUCCESS )
			return FALSE;

		// save the value
		strLocale = wszValue;
	}
	catch( ... )
	{
		WMISaveError( E_OUTOFMEMORY );
		return FALSE;
	}
	
	// return
	return TRUE;
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
BOOL FormatNumber( LPCWSTR pwszValue, CHString& strFmtValue )
{
	try
	{
		// get the size of buffer that is needed
		DWORD dwCount = 0;
		dwCount = GetNumberFormat( LOCALE_USER_DEFAULT, 0, pwszValue, NULL, NULL, 0 );

		// get the required buffer
		LPWSTR pwszTemp = NULL;
		pwszTemp = strFmtValue.GetBufferSetLength( dwCount + 1 );

		// now format the date
		GetNumberFormat( LOCALE_USER_DEFAULT, 0, pwszValue, NULL, pwszTemp, dwCount );

		// release the buffer
		strFmtValue.ReleaseBuffer();
	}
	catch( ... )
	{
		SetLastError( E_OUTOFMEMORY );
		SaveLastError();
		return FALSE;
	}

	// return 
	return TRUE;
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
BOOL FormatNumberEx( LPCWSTR pwszValue, CHString& strFmtValue )
{
	// local variables
	CHString str;
	LONG lTemp = 0;
	NUMBERFMTW nfmtw;
	DWORD dwGroupSep = 0;
	LPWSTR pwszTemp = NULL;
	CHString strGroupThousSep;
	
	try
	{
		//
		// get the group seperator character
		lTemp = GetLocaleInfo( LOCALE_USER_DEFAULT, LOCALE_SGROUPING, NULL, 0 );
		if ( lTemp == 0 )
		{
			// we don't know how to resolve this
			return FALSE;
		}
		else
		{
			// get the group seperation character
			pwszTemp = str.GetBufferSetLength( lTemp + 2 );
			ZeroMemory( pwszTemp, ( lTemp + 2 ) * sizeof( WCHAR ) );
			GetLocaleInfo( LOCALE_USER_DEFAULT, LOCALE_SGROUPING, pwszTemp, lTemp );

			// change the group info into appropriate number
			lTemp = 0;
			dwGroupSep = 0;
			while ( lTemp < str.GetLength() )
			{
				if ( AsLong( str.Mid( lTemp, 1 ), 10 ) != 0 )
					dwGroupSep = dwGroupSep * 10 + AsLong( str.Mid( lTemp, 1 ), 10 );

				// increment by 2
				lTemp += 2;
			}
		}

		//
		// get the thousand seperator character
		lTemp = GetLocaleInfo( LOCALE_USER_DEFAULT, LOCALE_STHOUSAND, NULL, 0 );
		if ( lTemp == 0 )
		{
			// we don't know how to resolve this
			return FALSE;
		}
		else
		{
			// get the thousand sepeartion charactor
			pwszTemp = strGroupThousSep.GetBufferSetLength( lTemp + 2 );
			ZeroMemory( pwszTemp, ( lTemp + 2 ) * sizeof( WCHAR ) );
			GetLocaleInfo( LOCALE_USER_DEFAULT, LOCALE_STHOUSAND, pwszTemp, lTemp );
		}

		// release the CHStrig buffers
		str.ReleaseBuffer();
		strGroupThousSep.ReleaseBuffer();
	}
	catch( ... )
	{
		SetLastError( E_OUTOFMEMORY );
		SaveLastError();
		return FALSE;
	}

	// format the number
	try
	{
		nfmtw.NumDigits = 0;
		nfmtw.LeadingZero = 0;
		nfmtw.NegativeOrder = 0;
		nfmtw.Grouping = dwGroupSep;
		nfmtw.lpDecimalSep = NULL_STRING;
		nfmtw.lpThousandSep = strGroupThousSep.GetBuffer( strGroupThousSep.GetLength() );

		// get the size of buffer that is needed
		lTemp = GetNumberFormatW( LOCALE_USER_DEFAULT, 0, pwszValue, &nfmtw, NULL, 0 );

		// get/allocate the required buffer
		pwszTemp = strFmtValue.GetBufferSetLength( lTemp + 1 );

		// now format the date
		GetNumberFormat( LOCALE_USER_DEFAULT, 0, pwszValue, &nfmtw, pwszTemp, lTemp );

		// release the buffer
		strFmtValue.ReleaseBuffer();
	}
	catch( ... )
	{
		SetLastError( E_OUTOFMEMORY );
		SaveLastError();
		return FALSE;
	}

	// return 
	return TRUE;
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
LCID GetSupportedUserLocale( BOOL& bLocaleChanged )
{
	// local variables
    LCID lcid;

	// get the current locale
	lcid = GetUserDefaultLCID();

	// check whether the current locale is supported by our tool or not
	// if not change the locale to the english which is our default locale
	bLocaleChanged = FALSE;
    if ( PRIMARYLANGID( lcid ) == LANG_ARABIC || PRIMARYLANGID( lcid ) == LANG_HEBREW ||
         PRIMARYLANGID( lcid ) == LANG_THAI   || PRIMARYLANGID( lcid ) == LANG_HINDI  ||
         PRIMARYLANGID( lcid ) == LANG_TAMIL  || PRIMARYLANGID( lcid ) == LANG_FARSI )
    {
		bLocaleChanged = TRUE;
        lcid = MAKELCID( MAKELANGID( LANG_ENGLISH, SUBLANG_DEFAULT ), SORT_DEFAULT ); // 0x409;
    }

	// return the locale
    return lcid;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cmdline\systeminfo\init.cpp ===
// *********************************************************************************
// 
//  Copyright (c) Microsoft Corporation
//  
//  Module Name:
//  
//		Init.cpp
//  
//  Abstract:
//  
// 		This module implements the general initialization stuff
//
//  Author:
//  
// 		Sunil G.V.N. Murali (murali.sunil@wipro.com) 22-Dec-2000
//  
//  Revision History:
//  
// 		Sunil G.V.N. Murali (murali.sunil@wipro.com) 22-Dec-2000 : Created It.
//  
// *********************************************************************************

#include "pch.h"
#include "wmi.h"
#include "systeminfo.h"

//
// private function prototype(s)
//

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
CSystemInfo::CSystemInfo()
{
	m_dwFormat = 0;
	m_bUsage = FALSE;
	m_pWbemLocator = NULL;
	m_pWbemServices = NULL;
	m_pAuthIdentity = NULL;
	m_arrData = NULL;
	m_bNeedPassword = FALSE;
	m_pColumns = FALSE;
	m_hOutput = NULL;
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
CSystemInfo::~CSystemInfo()
{
	// connection to the remote system has to be closed which is established thru win32 api
	if ( m_bCloseConnection == TRUE )
		CloseConnection( m_strServer );

	// release memory
	DESTROY_ARRAY( m_arrData );

	// release the interfaces
	SAFE_RELEASE( m_pWbemLocator );
	SAFE_RELEASE( m_pWbemServices );

	// release the memory allocated for output columns
	RELEASE_MEMORY_EX( m_pColumns );

	// uninitialize the com library
	CoUninitialize();
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
BOOL CSystemInfo::Initialize()
{
	//
	// memory allocations

	// allocate for storage dynamic array
	if ( m_arrData == NULL )
	{
		m_arrData = CreateDynamicArray();
		if ( m_arrData == NULL )
		{
			SetLastError( E_OUTOFMEMORY );
			SaveLastError();
			return FALSE;
		}

		// make the array as a 2-dimensinal array
		DynArrayAppendRow( m_arrData, 0 );

		// put the default values
		for( DWORD dw = 0; dw < MAX_COLUMNS; dw++ )
		{
			switch( dw )
			{
			case CI_PROCESSOR:
			case CI_PAGEFILE_LOCATION:
			case CI_HOTFIX:
			case CI_NETWORK_CARD:
				{
					// create the array
					TARRAY arr = NULL;
					arr = CreateDynamicArray();
					if ( arr == NULL )
					{
						SetLastError( E_OUTOFMEMORY );
						SaveLastError();
						return FALSE;
					}

					// set the default value
					DynArrayAppendString( arr, V_NOT_AVAILABLE, 0 );

					// add this array to the array
					DynArrayAppendEx2( m_arrData, 0, arr );

					// break the switch
					break;
				}

			default:
				// string type
				DynArrayAppendString2( m_arrData, 0, V_NOT_AVAILABLE, 0 );
			}
		}
	}

	//
	// allocate for output columns
	if ( AllocateColumns() == FALSE )
		return FALSE;

	//
	// init the console scree buffer structure to zero's
	// and then get the console handle and screen buffer information
	//
	// prepare for status display.
	// for this get a handle to the screen output buffer
	// but this handle will be null if the output is being redirected. so do not check 
	// for the validity of the handle. instead try to get the console buffer information
	// only in case you have a valid handle to the output screen buffer
	ZeroMemory( &m_csbi, sizeof( CONSOLE_SCREEN_BUFFER_INFO ) );
	m_hOutput = GetStdHandle( STD_ERROR_HANDLE );
	if ( m_hOutput != NULL )
		GetConsoleScreenBufferInfo( m_hOutput, &m_csbi );

	//
	// initialize the COM library
	if ( InitializeCom( &m_pWbemLocator ) == FALSE )
		return FALSE;

	// initialization is successful
	SetLastError( NOERROR );			// clear the error
	SetReason( NULL_STRING );			// clear the reason
	return TRUE;
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
BOOL CSystemInfo::AllocateColumns()
{
	// local variables
	PTCOLUMNS pCurrentColumn = NULL;

	//
	// allocate memory for columns
	m_pColumns = new TCOLUMNS [ MAX_COLUMNS ];
	if ( m_pColumns == NULL )
	{
		// generate error info
		SetLastError( E_OUTOFMEMORY );
		SaveLastError();

		// prepare the error message
		CHString strBuffer;
		strBuffer.Format( _T( "%s %s" ), TAG_ERROR, GetReason() );
		DISPLAY_MESSAGE( stderr, strBuffer );

		// return
		return FALSE;
	}

	// init with null's
	ZeroMemory( m_pColumns, sizeof( TCOLUMNS ) * MAX_COLUMNS );

	// host name
	pCurrentColumn = m_pColumns + CI_HOSTNAME;
	pCurrentColumn->dwWidth = COLWIDTH_HOSTNAME;
	pCurrentColumn->dwFlags = SR_TYPE_STRING;
	lstrcpy( pCurrentColumn->szColumn, COLHEAD_HOSTNAME );

	// OS Name
	pCurrentColumn = m_pColumns + CI_OS_NAME;
	pCurrentColumn->dwWidth = COLWIDTH_OS_NAME;
	pCurrentColumn->dwFlags = SR_TYPE_STRING;
	lstrcpy( pCurrentColumn->szColumn, COLHEAD_OS_NAME );
	
	// OS Version
	pCurrentColumn = m_pColumns + CI_OS_VERSION;
	pCurrentColumn->dwWidth = COLWIDTH_OS_VERSION;
	pCurrentColumn->dwFlags = SR_TYPE_STRING;
	lstrcpy( pCurrentColumn->szColumn, COLHEAD_OS_VERSION );
		
	// OS Manufacturer
	pCurrentColumn = m_pColumns + CI_OS_MANUFACTURER;
	pCurrentColumn->dwWidth = COLWIDTH_OS_MANUFACTURER;
	pCurrentColumn->dwFlags = SR_TYPE_STRING;
	lstrcpy( pCurrentColumn->szColumn, COLHEAD_OS_MANUFACTURER );
		
	// OS Configuration
	pCurrentColumn = m_pColumns + CI_OS_CONFIG;
	pCurrentColumn->dwWidth = COLWIDTH_OS_CONFIG;
	pCurrentColumn->dwFlags = SR_TYPE_STRING;
	lstrcpy( pCurrentColumn->szColumn, COLHEAD_OS_CONFIG );
	
	// OS Build Type
	pCurrentColumn = m_pColumns + CI_OS_BUILDTYPE;
	pCurrentColumn->dwWidth = COLWIDTH_OS_BUILDTYPE;
	pCurrentColumn->dwFlags = SR_TYPE_STRING;
	lstrcpy( pCurrentColumn->szColumn, COLHEAD_OS_BUILDTYPE );
	
	// Registered Owner
	pCurrentColumn = m_pColumns + CI_REG_OWNER;
	pCurrentColumn->dwWidth = COLWIDTH_REG_OWNER;
	pCurrentColumn->dwFlags = SR_TYPE_STRING;
	lstrcpy( pCurrentColumn->szColumn, COLHEAD_REG_OWNER );
	
	// Registered Organization
	pCurrentColumn = m_pColumns + CI_REG_ORG;
	pCurrentColumn->dwWidth = COLWIDTH_REG_ORG;
	pCurrentColumn->dwFlags = SR_TYPE_STRING;
	lstrcpy( pCurrentColumn->szColumn, COLHEAD_REG_ORG );
	
	// Product ID
	pCurrentColumn = m_pColumns + CI_PRODUCT_ID;
	pCurrentColumn->dwWidth = COLWIDTH_PRODUCT_ID;
	pCurrentColumn->dwFlags = SR_TYPE_STRING;
	lstrcpy( pCurrentColumn->szColumn, COLHEAD_PRODUCT_ID );
	
	// install date
	pCurrentColumn = m_pColumns + CI_INSTALL_DATE;
	pCurrentColumn->dwWidth = COLWIDTH_INSTALL_DATE;
	pCurrentColumn->dwFlags = SR_TYPE_STRING;
	lstrcpy( pCurrentColumn->szColumn, COLHEAD_INSTALL_DATE );
	
	// system up time
	pCurrentColumn = m_pColumns + CI_SYSTEM_UPTIME;
	pCurrentColumn->dwWidth = COLWIDTH_SYSTEM_UPTIME;
	pCurrentColumn->dwFlags = SR_TYPE_STRING;
	lstrcpy( pCurrentColumn->szColumn, COLHEAD_SYSTEM_UPTIME );
	
	// system manufacturer
	pCurrentColumn = m_pColumns + CI_SYSTEM_MANUFACTURER;
	pCurrentColumn->dwWidth = COLWIDTH_SYSTEM_MANUFACTURER;
	pCurrentColumn->dwFlags = SR_TYPE_STRING;
	lstrcpy( pCurrentColumn->szColumn, COLHEAD_SYSTEM_MANUFACTURER );
	
	// system model
	pCurrentColumn = m_pColumns + CI_SYSTEM_MODEL;
	pCurrentColumn->dwWidth = COLWIDTH_SYSTEM_MODEL;
	pCurrentColumn->dwFlags = SR_TYPE_STRING;
	lstrcpy( pCurrentColumn->szColumn, COLHEAD_SYSTEM_MODEL );
	
	// system type
	pCurrentColumn = m_pColumns + CI_SYSTEM_TYPE;
	pCurrentColumn->dwWidth = COLWIDTH_SYSTEM_TYPE;
	pCurrentColumn->dwFlags = SR_TYPE_STRING;
	lstrcpy( pCurrentColumn->szColumn, COLHEAD_SYSTEM_TYPE );
	
	// processor
	pCurrentColumn = m_pColumns + CI_PROCESSOR;
	pCurrentColumn->dwWidth = COLWIDTH_PROCESSOR;
	pCurrentColumn->dwFlags = SR_ARRAY | SR_TYPE_STRING;
	lstrcpy( pCurrentColumn->szColumn, COLHEAD_PROCESSOR );
	
	// bios version
	pCurrentColumn = m_pColumns + CI_BIOS_VERSION;
	pCurrentColumn->dwWidth = COLWIDTH_BIOS_VERSION;
	pCurrentColumn->dwFlags = SR_TYPE_STRING;
	lstrcpy( pCurrentColumn->szColumn, COLHEAD_BIOS_VERSION );
	
	// windows directory
	pCurrentColumn = m_pColumns + CI_WINDOWS_DIRECTORY;
	pCurrentColumn->dwWidth = COLWIDTH_WINDOWS_DIRECTORY;
	pCurrentColumn->dwFlags = SR_TYPE_STRING;
	lstrcpy( pCurrentColumn->szColumn, COLHEAD_WINDOWS_DIRECTORY );
	
	// system directory
	pCurrentColumn = m_pColumns + CI_SYSTEM_DIRECTORY;
	pCurrentColumn->dwWidth = COLWIDTH_SYSTEM_DIRECTORY;
	pCurrentColumn->dwFlags = SR_TYPE_STRING;
	lstrcpy( pCurrentColumn->szColumn, COLHEAD_SYSTEM_DIRECTORY );
	
	// boot device
	pCurrentColumn = m_pColumns + CI_BOOT_DEVICE;
	pCurrentColumn->dwWidth = COLWIDTH_BOOT_DEVICE;
	pCurrentColumn->dwFlags = SR_TYPE_STRING;
	lstrcpy( pCurrentColumn->szColumn, COLHEAD_BOOT_DEVICE );
	
	// system locale
	pCurrentColumn = m_pColumns + CI_SYSTEM_LOCALE;
	pCurrentColumn->dwWidth = COLWIDTH_SYSTEM_LOCALE;
	pCurrentColumn->dwFlags = SR_TYPE_STRING;
	lstrcpy( pCurrentColumn->szColumn, COLHEAD_SYSTEM_LOCALE );
	
	// input locale
	pCurrentColumn = m_pColumns + CI_INPUT_LOCALE;
	pCurrentColumn->dwWidth = COLWIDTH_INPUT_LOCALE;
	pCurrentColumn->dwFlags = SR_TYPE_STRING;
	lstrcpy( pCurrentColumn->szColumn, COLHEAD_INPUT_LOCALE );
	
	// time zone
	pCurrentColumn = m_pColumns + CI_TIME_ZONE;
	pCurrentColumn->dwWidth = COLWIDTH_TIME_ZONE;
	pCurrentColumn->dwFlags = SR_TYPE_STRING;
	lstrcpy( pCurrentColumn->szColumn, COLHEAD_TIME_ZONE );
	
	// total physical memory
	pCurrentColumn = m_pColumns + CI_TOTAL_PHYSICAL_MEMORY;
	pCurrentColumn->dwWidth = COLWIDTH_TOTAL_PHYSICAL_MEMORY;
	pCurrentColumn->dwFlags = SR_TYPE_STRING;
	lstrcpy( pCurrentColumn->szColumn, COLHEAD_TOTAL_PHYSICAL_MEMORY );
	
	// available physical memory
	pCurrentColumn = m_pColumns + CI_AVAILABLE_PHYSICAL_MEMORY;
	pCurrentColumn->dwWidth = COLWIDTH_AVAILABLE_PHYSICAL_MEMORY;
	pCurrentColumn->dwFlags = SR_TYPE_STRING;
	lstrcpy( pCurrentColumn->szColumn, COLHEAD_AVAILABLE_PHYSICAL_MEMORY );
	
	// virtual memory max
	pCurrentColumn = m_pColumns + CI_VIRTUAL_MEMORY_MAX;
	pCurrentColumn->dwWidth = COLWIDTH_VIRTUAL_MEMORY_MAX;
	pCurrentColumn->dwFlags = SR_TYPE_STRING;
	lstrcpy( pCurrentColumn->szColumn, COLHEAD_VIRTUAL_MEMORY_MAX );
	
	// virtual memory available
	pCurrentColumn = m_pColumns + CI_VIRTUAL_MEMORY_AVAILABLE;
	pCurrentColumn->dwWidth = COLWIDTH_VIRTUAL_MEMORY_AVAILABLE;
	pCurrentColumn->dwFlags = SR_TYPE_STRING;
	lstrcpy( pCurrentColumn->szColumn, COLHEAD_VIRTUAL_MEMORY_AVAILABLE );
	
	// virtual memory usage
	pCurrentColumn = m_pColumns + CI_VIRTUAL_MEMORY_INUSE;
	pCurrentColumn->dwWidth = COLWIDTH_VIRTUAL_MEMORY_INUSE;
	pCurrentColumn->dwFlags = SR_TYPE_STRING;
	lstrcpy( pCurrentColumn->szColumn, COLHEAD_VIRTUAL_MEMORY_INUSE );
	
	// page file location
	pCurrentColumn = m_pColumns + CI_PAGEFILE_LOCATION;
	pCurrentColumn->dwWidth = COLWIDTH_PAGEFILE_LOCATION;
	pCurrentColumn->dwFlags = SR_ARRAY | SR_TYPE_STRING;
	lstrcpy( pCurrentColumn->szColumn, COLHEAD_PAGEFILE_LOCATION );
	
	// domain
	pCurrentColumn = m_pColumns + CI_DOMAIN;
	pCurrentColumn->dwWidth = COLWIDTH_DOMAIN;
	pCurrentColumn->dwFlags = SR_TYPE_STRING;
	lstrcpy( pCurrentColumn->szColumn, COLHEAD_DOMAIN );
	
	// logon server
	pCurrentColumn = m_pColumns + CI_LOGON_SERVER;
	pCurrentColumn->dwWidth = COLWIDTH_LOGON_SERVER;
	pCurrentColumn->dwFlags = SR_TYPE_STRING;
	lstrcpy( pCurrentColumn->szColumn, COLHEAD_LOGON_SERVER );
	
	// hotfix
	pCurrentColumn = m_pColumns + CI_HOTFIX;
	pCurrentColumn->dwWidth = COLWIDTH_HOTFIX;
	pCurrentColumn->dwFlags = SR_ARRAY | SR_TYPE_STRING;
	lstrcpy( pCurrentColumn->szColumn, COLHEAD_HOTFIX );
	
	// network card
	pCurrentColumn = m_pColumns + CI_NETWORK_CARD;
	pCurrentColumn->dwWidth = COLWIDTH_NETWORK_CARD;
	pCurrentColumn->dwFlags = SR_ARRAY | SR_TYPE_STRING;
	lstrcpy( pCurrentColumn->szColumn, COLHEAD_NETWORK_CARD );

	// return
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cmdline\systeminfo\wmi.cpp ===
// *********************************************************************************
// 
//  Copyright (c) Microsoft Corporation
//  
//  Module Name:
//  
//		WMI.cpp
//  
//  Abstract:
//  
// 		Common functionlity for dealing with WMI
//  
//  Author:
//  
// 	    Sunil G.V.N. Murali (murali.sunil@wipro.com) 22-Dec-2000
//  
//  Revision History:
//  
// 	    Sunil G.V.N. Murali (murali.sunil@wipro.com) 22-Dec-2000 : Created It.
//  
// *********************************************************************************

#include "pch.h"
#include "wmi.h"
#include "resource.h"

//
// messages
//
#define INPUT_PASSWORD		GetResString( IDS_STR_INPUT_PASSWORD )

// error constants
#define E_SERVER_NOTFOUND			0x800706ba

//
// private function prototype(s)
//
BOOL IsValidUserEx( LPCWSTR pwszUser );
HRESULT GetSecurityArguments( IUnknown* pInterface, 
							  DWORD& dwAuthorization, DWORD& dwAuthentication );
HRESULT SetInterfaceSecurity( IUnknown* pInterface, 
							  LPCWSTR pwszServer, LPCWSTR pwszUser, 
							  LPCWSTR pwszPassword, COAUTHIDENTITY** ppAuthIdentity );
HRESULT WINAPI SetProxyBlanket( IUnknown* pInterface,
							    DWORD dwAuthnSvc, DWORD dwAuthzSvc,
								LPWSTR pwszPrincipal, DWORD dwAuthLevel, DWORD dwImpLevel,
								RPC_AUTH_IDENTITY_HANDLE pAuthInfo, DWORD dwCapabilities );
HRESULT WINAPI WbemAllocAuthIdentity( LPCWSTR pwszUser, LPCWSTR pwszPassword, 
									  LPCWSTR pwszDomain, COAUTHIDENTITY** ppAuthIdent );
HRESULT RegQueryValueWMI( IWbemServices* pWbemServices, 
						  LPCWSTR pwszMethod, DWORD dwHDefKey, 
						  LPCWSTR pwszSubKeyName, LPCWSTR pwszValueName, _variant_t& varValue );

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
BOOL IsValidUserEx( LPCWSTR pwszUser )
{
	// local variables
	CHString strUser;
	LONG lPos = 0;

	try
	{
		// get user into local memory
		strUser = pwszUser;

		// user name should not be just '\'
		if ( strUser.CompareNoCase( L"\\" ) == 0 )
			return FALSE;

		// user name should not contain invalid characters
		if ( strUser.FindOneOf( L"/[]:|<>+=;,?*" ) != -1 )
			return FALSE;

		// SPECIAL CHECK
		// check for multiple '\' characters in the user name
		lPos = strUser.Find( L'\\' );
		if ( lPos != -1 )
		{
			// '\' character exists in the user name
			// strip off the user info upto first '\' character
			// check for one more '\' in the remaining string
			// if it exists, invalid user
			strUser = strUser.Mid( lPos + 1 );
			lPos = strUser.Find( L'\\' );
			if ( lPos != -1 )
				return FALSE;
		}
	}
	catch( ... )
	{
		SetLastError( E_OUTOFMEMORY );
		return FALSE;
	}

	// user name is valid
	return TRUE;
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
BOOL IsValidServerEx( LPCWSTR pwszServer, BOOL& bLocalSystem )
{
	// local variables
	CHString strTemp;

	// kick-off
	bLocalSystem = FALSE;

	// get a local copy
	strTemp = pwszServer;

	// remove the forward slashes (UNC) if exist in the begining of the server name
	if ( IsUNCFormat( strTemp ) == TRUE )
	{
		strTemp = strTemp.Mid( 2 );
		if ( strTemp.GetLength() == 0 )
			return FALSE;
	}

	// now check if any '\' character appears in the server name. If so error
	if ( strTemp.Find( L'\\' ) != -1 )
		return FALSE;

	// now check if server name is '.' only which represent local system in WMI
	// else determine whether this is a local system or not
	bLocalSystem = TRUE;
	if ( strTemp.CompareNoCase( L"." ) != 0 )
	{
		// validate the server
		if ( IsValidServer( strTemp ) == FALSE )
			return FALSE;

		// check whether this is a local system or not
		bLocalSystem = IsLocalSystem( strTemp );
	}

	// inform that server name is valid
	return TRUE;
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
BOOL InitializeCom( IWbemLocator** ppLocator )
{
	// local variables
	HRESULT hr;
	BOOL bResult = FALSE;

	try
	{
		// assume that connection to WMI namespace is failed
		bResult = FALSE;

		// initialize the COM library
		SAFE_EXECUTE( CoInitializeEx( NULL, COINIT_APARTMENTTHREADED ) );

		// initialize the security
		SAFE_EXECUTE( CoInitializeSecurity( NULL, -1, NULL, NULL,
			RPC_C_AUTHN_LEVEL_NONE, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE, 0 ) );

		// create the locator and get the pointer to the interface of IWbemLocator
		SAFE_RELEASE( *ppLocator );			// safe side
		SAFE_EXECUTE( CoCreateInstance( CLSID_WbemLocator, NULL, CLSCTX_INPROC_SERVER, 
			IID_IWbemLocator, ( LPVOID* ) ppLocator ) );

		// initialization successful
		bResult = TRUE;
	}
	catch( _com_error& e )
	{
		// save the WMI error
		WMISaveError( e );
	}

	// return the result;
	return bResult;
}

// ***************************************************************************
// Routine Description:
//		
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
BOOL ConnectWmi( IWbemLocator* pLocator, 
				 IWbemServices** ppServices, 
				 LPCWSTR pwszServer, LPCWSTR pwszUser, LPCWSTR pwszPassword, 
				 COAUTHIDENTITY** ppAuthIdentity, BOOL bCheckWithNullPwd, 
				 LPCWSTR pwszNamespace, HRESULT* phr, BOOL* pbLocalSystem )
{
	// local variables
	HRESULT hr;
	BOOL bResult = FALSE;
	BOOL bLocalSystem = FALSE;
	_bstr_t bstrServer;
	_bstr_t bstrNamespace;
	_bstr_t bstrUser, bstrPassword;

	// kick-off
	if ( pbLocalSystem != NULL )
		*pbLocalSystem = FALSE;

	// ...
	if ( phr != NULL )
		*phr = WBEM_S_NO_ERROR;

	try
	{
		// clear the error
		SetLastError( WBEM_S_NO_ERROR );

		// assume that connection to WMI namespace is failed
		bResult = FALSE;

		// check whether locator object exists or not
		// if not exists, return
		if ( pLocator == NULL )
		{
			if ( phr != NULL )
				*phr = WBEM_E_INVALID_PARAMETER;

			// return failure
			return FALSE;
		}

		// validate the server name
		if ( IsValidServerEx( pwszServer, bLocalSystem ) == FALSE )
			_com_issue_error( ERROR_BAD_NETPATH );

		// validate the user name
		if ( IsValidUserEx( pwszUser ) == FALSE )
			_com_issue_error( ERROR_NO_SUCH_USER );

		// prepare namespace
		bstrNamespace = pwszNamespace;				// name space
		if ( pwszServer != NULL && bLocalSystem == FALSE )
		{
			// get the server name
			bstrServer = pwszServer;

			// prepare the namespace
			// NOTE: check for the UNC naming format of the server and do
			if ( IsUNCFormat( pwszServer ) == TRUE )
				bstrNamespace = bstrServer + L"\\" + pwszNamespace;
			else
				bstrNamespace = L"\\\\" + bstrServer + L"\\" + pwszNamespace;

			// user credentials
			if ( pwszUser != NULL && lstrlen( pwszUser ) != 0 )
			{
				// copy the user name
				bstrUser = pwszUser;

				// if password is empty string and if we need to check with
				// null password, then do not set the password and try
				bstrPassword = pwszPassword;
				if ( bCheckWithNullPwd == TRUE && bstrPassword.length() == 0 )
					bstrPassword = (LPWSTR) NULL;
			}
		}
		else if ( bLocalSystem == TRUE && pwszUser != NULL && lstrlen( pwszUser ) != 0 )
		{
			// got the credentials for the local system
			if ( phr != NULL )
				*phr = WBEM_E_LOCAL_CREDENTIALS;
		}

		// release the existing services object ( to be in safer side )
		SAFE_RELEASE( *ppServices );

		// connect to the remote system's WMI
		// there is a twist here ... 
		// do not trap the ConnectServer function failure into exception
		// instead handle that action manually
		// by default try the ConnectServer function as the information which we have
		// in our hands at this point. If the ConnectServer is failed, 
		// check whether password variable has any contents are not ... if no contents
		// check with "" (empty) password ... this might pass in this situation ..
		// if this call is also failed ... nothing is there that we can do ... throw the exception
		hr = pLocator->ConnectServer( bstrNamespace, 
			bstrUser, bstrPassword, 0L, 0L, NULL, NULL, ppServices );
		if ( FAILED( hr ) )
		{
			//
			// special case ...

			// check whether password exists or not
			// NOTE: do not check for 'WBEM_E_ACCESS_DENIED'
			//       this error code says that user with the current credentials is not
			//       having access permisions to the 'namespace'
			if ( hr == E_ACCESSDENIED )
			{
				// check if we tried to connect to the system using null password
				// if so, then try connecting to the remote system with empty string
				if ( bCheckWithNullPwd == TRUE &&
					 bstrUser.length() != 0 && bstrPassword.length() == 0 )
				{
					// now invoke with ...
					hr = pLocator->ConnectServer( bstrNamespace, 
						bstrUser, _bstr_t( L"" ), 0L, 0L, NULL, NULL, ppServices );
				}
			}
			else if ( hr == WBEM_E_LOCAL_CREDENTIALS )
			{
				// credentials were passed to the local system. 
				// So ignore the credentials and try to reconnect
				bLocalSystem = TRUE;
				bstrUser = (LPWSTR) NULL;
				bstrPassword = (LPWSTR) NULL;
				bstrNamespace = pwszNamespace;				// name space
				hr = pLocator->ConnectServer( bstrNamespace, 
					NULL, NULL, 0L, 0L, NULL, NULL, ppServices );

				// check the result
				if ( SUCCEEDED( hr ) && phr != NULL )
				{
					// set the last error
					*phr = WBEM_E_LOCAL_CREDENTIALS;
				}
			}

			// now check the result again .. if failed .. ummmm..
			if ( FAILED( hr ) )
				_com_issue_error( hr );
			else
				bstrPassword = L"";
		}

		// set the security at the interface level also
		SAFE_EXECUTE( SetInterfaceSecurity( *ppServices, 
			pwszServer, bstrUser, bstrPassword, ppAuthIdentity ) );

		// connection to WMI is successful
		bResult = TRUE;
	}
	catch( _com_error& e )
	{
		// save the error
		WMISaveError( e );

		// save the hr value if needed by the caller
		if ( phr != NULL )
			*phr = e.Error();
	}

	// ...
	if ( pbLocalSystem != NULL )
		*pbLocalSystem = bLocalSystem;

	// return the result
	return bResult;
}

// ***************************************************************************
// Routine Description:
//		
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
BOOL ConnectWmiEx( IWbemLocator* pLocator, 
				   IWbemServices** ppServices, 
				   LPCWSTR pwszServer, CHString& strUserName, CHString& strPassword, 
				   COAUTHIDENTITY** ppAuthIdentity, 
				   BOOL bNeedPassword, LPCWSTR pwszNamespace, BOOL* pbLocalSystem )
{
	// local variables
	HRESULT hr;
	DWORD dwSize = 0;
	BOOL bResult = FALSE;
	LPWSTR pwszPassword = NULL;
	CHString strBuffer = NULL_STRING;

	// clear the error .. if any
	SetLastError( WBEM_S_NO_ERROR );

	// sometime users want the utility to prompt for the password
	// check what user wants the utility to do
	if ( bNeedPassword == TRUE && strPassword.Compare( L"*" ) == 0 )
	{
		// user wants the utility to prompt for the password
		// so skip this part and let the flow directly jump the password acceptance part
	}
	else
	{
		// try to establish connection to the remote system with the credentials supplied
		if ( strUserName.GetLength() == 0 )
		{
			// user name is empty
			// so, it is obvious that password will also be empty
			// even if password is specified, we have to ignore that
			bResult = ConnectWmi( pLocator, ppServices, 
				pwszServer, NULL, NULL, ppAuthIdentity, FALSE, pwszNamespace, &hr, pbLocalSystem );
		}
		else
		{
			// credentials were supplied
			// but password might not be specified ... so check and act accordingly
			LPCWSTR pwszTemp = NULL;
			BOOL bCheckWithNull = TRUE;
			if ( bNeedPassword == FALSE )
			{
				pwszTemp = strPassword;
				bCheckWithNull = FALSE;
			}

			// ...
			bResult = ConnectWmi( pLocator, ppServices, pwszServer,
				strUserName, pwszTemp, ppAuthIdentity, bCheckWithNull, pwszNamespace, &hr, pbLocalSystem );
		}

		// check the result ... if successful in establishing connection ... return
		if ( bResult == TRUE )
		{
			SetLastError( hr );			// set the error code
			return TRUE;
		}

		// now check the kind of error occurred
		switch( hr )
		{
		case E_ACCESSDENIED:
			break;

		case WBEM_E_ACCESS_DENIED:
		default:
			// NOTE: do not check for 'WBEM_E_ACCESS_DENIED'
			//       this error code says that user with the current credentials is not
			//       having access permisions to the 'namespace'
			WMISaveError( hr );
			return FALSE;		// no use of accepting the password .. return failure
			break;
		}

		// if failed in establishing connection to the remote terminal
		// even if the password is specifed, then there is nothing to do ... simply return failure
		if ( bNeedPassword == FALSE )
			return FALSE;
	}

	// check whether user name is specified or not
	// if not, get the local system's current user name under whose credentials, the process
	// is running
	if ( strUserName.GetLength() == 0 )
	{
		// sub-local variables
		LPWSTR pwszUserName = NULL;

		try
		{
			// get the required buffer
			pwszUserName = strUserName.GetBufferSetLength( MAX_STRING_LENGTH );
		}
		catch( ... )
		{
			SetLastError( E_OUTOFMEMORY );
			SaveLastError();
			return FALSE;
		}

		// get the user name
		DWORD dwUserLength = MAX_STRING_LENGTH;
		if ( GetUserNameEx( NameSamCompatible, pwszUserName, &dwUserLength ) == FALSE )
		{
			// error occured while trying to get the current user info
			SaveLastError();
			return FALSE;
		}

		// release the extra buffer allocated
		strUserName.ReleaseBuffer();
	}

	try
	{
		// get the required buffer
		pwszPassword = strPassword.GetBufferSetLength( MAX_STRING_LENGTH );
	}
	catch( ... )
	{
		SetLastError( E_OUTOFMEMORY );
		SaveLastError();
		return FALSE;
	}

	// accept the password from the user
	strBuffer.Format( INPUT_PASSWORD, strUserName );
	WriteConsoleW( GetStdHandle( STD_ERROR_HANDLE ), 
		strBuffer, strBuffer.GetLength(), &dwSize, NULL );
	GetPassword( pwszPassword, MAX_PASSWORD_LENGTH );

	// release the buffer allocated for password
	strPassword.ReleaseBuffer();

	// now again try to establish the connection using the currently
	// supplied credentials
	bResult = ConnectWmi( pLocator, ppServices, pwszServer,
		strUserName, strPassword, ppAuthIdentity, FALSE, pwszNamespace, &hr, pbLocalSystem );

	// set the last error 
	SetLastError( hr );

	// return the failure
	return bResult;
}

// ***************************************************************************
// Routine Description:
//		
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
HRESULT GetSecurityArguments( IUnknown* pInterface, 
							  DWORD& dwAuthorization, DWORD& dwAuthentication )
{
	// local variables
	HRESULT hr;
	DWORD dwAuthnSvc = 0, dwAuthzSvc = 0;
	IClientSecurity* pClientSecurity = NULL;

	// try to get the client security services values if possible
	hr = pInterface->QueryInterface( IID_IClientSecurity, (void**) &pClientSecurity );
	if ( SUCCEEDED( hr ) )
	{
		// got the client security interface
		// now try to get the security services values
		hr = pClientSecurity->QueryBlanket( pInterface, 
			&dwAuthnSvc, &dwAuthzSvc, NULL, NULL, NULL, NULL, NULL );
		if ( SUCCEEDED( hr ) )
		{
			// we've got the values from the interface
			dwAuthentication = dwAuthnSvc;
			dwAuthorization = dwAuthzSvc;
		}

		// release the client security interface
		SAFE_RELEASE( pClientSecurity );
	}

	// return always success
	return S_OK;
}

// ***************************************************************************
// Routine Description:
//		
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
HRESULT SetInterfaceSecurity( IUnknown* pInterface, 
							  LPCWSTR pwszServer, LPCWSTR pwszUser, 
							  LPCWSTR pwszPassword, COAUTHIDENTITY** ppAuthIdentity )
{
	// local variables
	HRESULT hr;
	CHString strUser;
	CHString strDomain;
	LPCWSTR pwszUserArg = NULL;
	LPCWSTR pwszDomainArg = NULL;
	DWORD dwAuthorization = RPC_C_AUTHZ_NONE;
	DWORD dwAuthentication = RPC_C_AUTHN_WINNT;

	// check the interface
	if ( pInterface == NULL )
		return WBEM_E_INVALID_PARAMETER;

	// check the authentity strcuture ... if authentity structure is already ready
	// simply invoke the 2nd version of SetInterfaceSecurity
	if ( *ppAuthIdentity != NULL )
		return SetInterfaceSecurity( pInterface, *ppAuthIdentity );

	// get the current security argument value
	// GetSecurityArguments( pInterface, dwAuthorization, dwAuthentication );

    // If we are doing trivial case, just pass in a null authenication structure 
    // for which the current logged in user's credentials will be considered
	if ( pwszUser == NULL && pwszPassword == NULL )
	{
		// set the security
		hr = SetProxyBlanket( pInterface, dwAuthentication, dwAuthorization, 
			NULL, RPC_C_AUTHN_LEVEL_DEFAULT, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE );

		// return the result
		return hr;
	}

	// parse and find out if the user name contains the domain name
	// if contains, extract the domain value from it
	LONG lPos = -1;
	strDomain = L"";
	strUser = pwszUser;
	if ( ( lPos = strUser.Find( L'\\' ) ) != -1 )
	{
		// user name contains domain name ... domain\user format
		strDomain = strUser.Left( lPos );
		strUser = strUser.Mid( lPos + 1 );
	}

	// get the domain info if it exists only
	if ( strDomain.GetLength() != 0 )
		pwszDomainArg = strDomain;

	// get the user info if it exists only
	if ( strUser.GetLength() != 0 )
		pwszUserArg = strUser;

	// check if authenication info is available or not ...
	// initialize the security authenication information ... UNICODE VERSION STRUCTURE
	if ( ppAuthIdentity == NULL )
        return WBEM_E_INVALID_PARAMETER;
	else if ( *ppAuthIdentity == NULL )
	{
		hr = WbemAllocAuthIdentity( pwszUserArg, pwszPassword, pwszDomainArg, ppAuthIdentity );
		if ( hr != S_OK )
			return hr;
	}

	// set the security information to the interface
	hr = SetProxyBlanket( pInterface, dwAuthentication, dwAuthorization, NULL,
		RPC_C_AUTHN_LEVEL_DEFAULT, RPC_C_IMP_LEVEL_IMPERSONATE, *ppAuthIdentity, EOAC_NONE );

	// return the result
	return hr;
}

// ***************************************************************************
// Routine Description:
//		
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
HRESULT SetInterfaceSecurity( IUnknown* pInterface, COAUTHIDENTITY* pAuthIdentity )
{
	// local variables
	HRESULT hr;
	LPWSTR pwszDomain = NULL;
	DWORD dwAuthorization = RPC_C_AUTHZ_NONE;
	DWORD dwAuthentication = RPC_C_AUTHN_WINNT;

	// check the interface
	if ( pInterface == NULL )
		return WBEM_E_INVALID_PARAMETER;

	// get the current security argument value
	// GetSecurityArguments( pInterface, dwAuthorization, dwAuthentication );

	// set the security information to the interface
	hr = SetProxyBlanket( pInterface, dwAuthentication, dwAuthorization, NULL,
		RPC_C_AUTHN_LEVEL_DEFAULT, RPC_C_IMP_LEVEL_IMPERSONATE, pAuthIdentity, EOAC_NONE );

	// return the result
	return hr;
}

// ***************************************************************************
// Routine Description:
//		
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
HRESULT WINAPI SetProxyBlanket( IUnknown* pInterface,
							    DWORD dwAuthnSvc, DWORD dwAuthzSvc,
								LPWSTR pwszPrincipal, DWORD dwAuthLevel, DWORD dwImpLevel,
								RPC_AUTH_IDENTITY_HANDLE pAuthInfo, DWORD dwCapabilities )
{
	// local variables
	HRESULT hr;
    IUnknown * pUnknown = NULL;
    IClientSecurity * pClientSecurity = NULL;

	// get the IUnknown interface ... to check whether this is a valid interface or not
    hr = pInterface->QueryInterface( IID_IUnknown, (void **) &pUnknown );
    if ( hr != S_OK )
        return hr;

	// now get the client security interface
    hr = pInterface->QueryInterface( IID_IClientSecurity, (void **) &pClientSecurity );
    if ( hr != S_OK )
    {
        SAFE_RELEASE( pUnknown );
        return hr;
    }

    //
    // Can't set pAuthInfo if cloaking requested, as cloaking implies
    // that the current proxy identity in the impersonated thread (rather
    // than the credentials supplied explicitly by the RPC_AUTH_IDENTITY_HANDLE)
    // is to be used.
    // See MSDN info on CoSetProxyBlanket for more details.
    //
    if ( dwCapabilities & (EOAC_STATIC_CLOAKING | EOAC_DYNAMIC_CLOAKING) )
        pAuthInfo = NULL;

	// now set the security
    hr = pClientSecurity->SetBlanket( pInterface, dwAuthnSvc, dwAuthzSvc, pwszPrincipal,
		dwAuthLevel, dwImpLevel, pAuthInfo, dwCapabilities );

	// release the security interface
	SAFE_RELEASE( pClientSecurity );

    // we should check the auth identity structure. if exists .. set for IUnknown also
    if ( pAuthInfo != NULL )
    {
        hr = pUnknown->QueryInterface( IID_IClientSecurity, (void **) &pClientSecurity );
        if ( hr == S_OK )
        {
			// set security authentication
            hr = pClientSecurity->SetBlanket( 
				pUnknown, dwAuthnSvc, dwAuthzSvc, pwszPrincipal, 
				dwAuthLevel, dwImpLevel, pAuthInfo, dwCapabilities );

			// release
            SAFE_RELEASE( pClientSecurity );
        }
        else if ( hr == E_NOINTERFACE )
            hr = S_OK;		// ignore no interface errors
    }

	// release the IUnknown
	SAFE_RELEASE( pUnknown );

	// return the result
    return hr;
}

// ***************************************************************************
// Routine Description:
//		
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
HRESULT WINAPI WbemAllocAuthIdentity( LPCWSTR pwszUser, LPCWSTR pwszPassword, 
									  LPCWSTR pwszDomain, COAUTHIDENTITY** ppAuthIdent )
{
	// local variables
    COAUTHIDENTITY* pAuthIdent = NULL;

	// validate the input parameter
    if ( ppAuthIdent == NULL )
        return WBEM_E_INVALID_PARAMETER;

    // allocation thru COM API
    pAuthIdent = ( COAUTHIDENTITY* ) CoTaskMemAlloc( sizeof( COAUTHIDENTITY ) );
    if ( NULL == pAuthIdent )
        return WBEM_E_OUT_OF_MEMORY;

	// init with 0's
    ZeroMemory( ( void* ) pAuthIdent, sizeof( COAUTHIDENTITY ) );

	//
	// Allocate needed memory and copy in data.  Cleanup if anything goes wrong

	// user
    if ( pwszUser != NULL )
    {
		// allocate memory for user
		LONG lLength = wcslen( pwszUser ); 
        pAuthIdent->User = ( LPWSTR ) CoTaskMemAlloc( (lLength + 1) * sizeof( WCHAR ) );
		if ( pAuthIdent->User == NULL )
		{
            WbemFreeAuthIdentity( &pAuthIdent );
            return WBEM_E_OUT_OF_MEMORY;
        }

		// set the length and do copy contents
        pAuthIdent->UserLength = lLength;
        wcscpy( pAuthIdent->User, pwszUser );
    }

	// domain
    if ( pwszDomain != NULL )
    {
		// allocate memory for domain
		LONG lLength = wcslen( pwszDomain ); 
        pAuthIdent->Domain = ( LPWSTR ) CoTaskMemAlloc( (lLength + 1) * sizeof( WCHAR ) );
        if ( pAuthIdent->Domain == NULL )
        {
            WbemFreeAuthIdentity( &pAuthIdent );
            return WBEM_E_OUT_OF_MEMORY;
        }

		// set the length and do copy contents
        pAuthIdent->DomainLength = lLength;
        wcscpy( pAuthIdent->Domain, pwszDomain );
    }

	// passsord
    if ( pwszPassword != NULL )
    {
		// allocate memory for passsord
		LONG lLength = wcslen( pwszPassword ); 
        pAuthIdent->Password = ( LPWSTR ) CoTaskMemAlloc( (lLength + 1) * sizeof( WCHAR ) );
        if ( pAuthIdent->Password == NULL )
        {
            WbemFreeAuthIdentity( &pAuthIdent );
            return WBEM_E_OUT_OF_MEMORY;
        }

		// set the length and do copy contents
        pAuthIdent->PasswordLength = lLength;
        wcscpy( pAuthIdent->Password, pwszPassword );
    }

	// type of the structure
    pAuthIdent->Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;

    // final set the address to out parameter
	*ppAuthIdent = pAuthIdent;

	// return result
    return S_OK;
}

// ***************************************************************************
// Routine Description:
//		
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
VOID WINAPI WbemFreeAuthIdentity( COAUTHIDENTITY** ppAuthIdentity )
{
    // make sure we have a pointer, then walk the structure members and  cleanup.
    if ( *ppAuthIdentity != NULL )
    {
		// free the memory allocated for user
        if ( (*ppAuthIdentity)->User != NULL )
            CoTaskMemFree( (*ppAuthIdentity)->User );

		// free the memory allocated for password
        if ( (*ppAuthIdentity)->Password != NULL )
            CoTaskMemFree( (*ppAuthIdentity)->Password );

		// free the memory allocated for domain
        if ( (*ppAuthIdentity)->Domain != NULL )
            CoTaskMemFree( (*ppAuthIdentity)->Domain );

        // final the structure
		CoTaskMemFree( *ppAuthIdentity );
    }

	// set to NULL
	*ppAuthIdentity = NULL;
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
VOID WMISaveError( HRESULT hrError )
{
	// local variables
	HRESULT hr;
	CHString strBuffer = NULL_STRING;
	IWbemStatusCodeText* pWbemStatus = NULL;

	// if the error is win32 based, choose FormatMessage to get the message
	switch( hrError )
	{
	case E_ACCESSDENIED:			// Message: "Access Denied"
	case ERROR_NO_SUCH_USER:		// Message: "The specified user does not exist."
		{
			// change the error message to "Logon failure: unknown user name or bad password." 
			if ( hrError == E_ACCESSDENIED )
				hrError = ERROR_LOGON_FAILURE;

			// ...
			SetLastError( hrError );
			SaveLastError();
			return;
		}
	}

	try
	{
		// get the pointer to buffer
		LPWSTR pwszBuffer = NULL;
		pwszBuffer = strBuffer.GetBufferSetLength( MAX_STRING_LENGTH );

		// get the wbem specific status code text
		hr = CoCreateInstance( CLSID_WbemStatusCodeText, 
			NULL, CLSCTX_INPROC_SERVER, IID_IWbemStatusCodeText, (LPVOID*) &pWbemStatus );

		// check whether we got the interface or not
		if ( SUCCEEDED( hr ) )
		{
			// get the error message
			BSTR bstr = NULL;
			hr = pWbemStatus->GetErrorCodeText( hrError, 0, 0, &bstr );
			if ( SUCCEEDED( hr ) )
			{
				// get the error message in proper format
				GetCompatibleStringFromUnicode( bstr, pwszBuffer, MAX_STRING_LENGTH );

				//
				// supress all the new-line characters and add '.' at the end ( if not exists )
				LPWSTR pwszTemp = NULL;
				pwszTemp = wcstok( pwszBuffer, L"\r\n" );
				if ( *( pwszTemp + lstrlenW( pwszTemp ) - 1 ) != L'.' )
					lstrcatW( pwszTemp, L"." );

				// free the BSTR
				SysFreeString( bstr );
				bstr = NULL;

				// now release status code interface
				SAFE_RELEASE( pWbemStatus );
			}
			else
			{
				// failed to get the error message ... get the com specific error message
				_com_issue_error( hrError );
			}
		}
		else
		{
			// failed to get the error message ... get the com specific error message
			_com_issue_error( hrError );
		}

		// release the buffer
		strBuffer.ReleaseBuffer();
	}
	catch( _com_error& e )
	{
		try
		{
			// get the error message
			strBuffer.ReleaseBuffer();
			if ( e.ErrorMessage() != NULL )
				strBuffer = e.ErrorMessage();
		}
		catch( ... )
		{
			SetLastError( E_OUTOFMEMORY );
			SaveLastError();
		}
	}
	catch( ... )
	{
		SetLastError( E_OUTOFMEMORY );
		SaveLastError();
		return;
	}

	// set the reason
	strBuffer += L"\n";
	SetReason( strBuffer );
}

// ***************************************************************************
// Routine Description:
//		Gets the value of the property from the WMI class object
//		  
// Arguments:
//		[ in ] pWmiObject		: pointer to the WBEM class object
//		[ in ] szProperty		: property name
//		[ out ] varValue		: value of the property
//  
// Return Value:
//		HRESULT - result of the operation
// 
// ***************************************************************************
HRESULT PropertyGet( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty, VARIANT* pvarValue )
{
	// local variables
	HRESULT hr;

	// check with object and property passed to the function are valid or not
	// if not, return failure
	if ( pWmiObject == NULL || pwszProperty == NULL || pvarValue == NULL )
		return WBEM_E_INVALID_PARAMETER;

	try
	{
		// initialize the variant and then get the value of the specified property
		hr = pWmiObject->Get( _bstr_t( pwszProperty ), 0, pvarValue, NULL, NULL );
		if ( FAILED( hr ) )
		{
			// clear the variant variable
			VariantClear( pvarValue );

			// failed to get the value for the property
			return hr;
		}
	}
	catch( _com_error& e )
	{
		WMISaveError( e );
		return e.Error();
	}

	// inform success
	return S_OK;
}

// ***************************************************************************
// Routine Description:
//		Gets the value of the property from the WMI class object
//		  
// Arguments:
//		[ in ] pWmiObject		: pointer to the WBEM class object
//		[ in ] szProperty		: property name
//		[ out ] varValue		: value of the property
//  
// Return Value:
//		HRESULT - result of the operation
// 
// ***************************************************************************
HRESULT PropertyGet( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty, _variant_t& varValue )
{
	// local variables
	HRESULT hr;
	VARIANT vtValue;

	// check with object and property passed to the function are valid or not
	// if not, return failure
	if ( pWmiObject == NULL || pwszProperty == NULL )
		return WBEM_E_INVALID_PARAMETER;

	try
	{
		// initialize the variant and then get the value of the specified property
		VariantInit( &vtValue );
		hr = pWmiObject->Get( _bstr_t( pwszProperty ), 0, &vtValue, NULL, NULL );
		if ( FAILED( hr ) )
		{
			// clear the variant variable
			VariantClear( &vtValue );

			// failed to get the value for the property
			return hr;
		}

		// set the value
		varValue = vtValue;

		// clear the variant variable
		VariantClear( &vtValue );
	}
	catch( _com_error& e )
	{
		WMISaveError( e );
		return e.Error();
	}

	// inform success
	return S_OK;
}

// ***************************************************************************
// Routine Description:
//		Gets the value of the property from the WMI class object in string format
//		  
// Arguments:
//  
// Return Value:
//		TRUE - if operation is successfull, otherwise FALSE
// 
// ***************************************************************************
BOOL PropertyGet( IWbemClassObject* pWmiObject, 
				  LPCWSTR pwszProperty, CHString& strValue, LPCWSTR pwszDefault )
{
	// local variables
	HRESULT hr;
	_variant_t var;

	// first copy the default value
	strValue = pwszDefault;

	// check with object and property passed to the function are valid or not
	// if not, return failure
	if ( pWmiObject == NULL || pwszProperty == NULL )
		return FALSE;

	// get the property value
	hr = PropertyGet( pWmiObject, pwszProperty, var );
	if ( FAILED( hr ) )
		return FALSE;

	try
	{
		// get the value
		if ( var.vt != VT_NULL && var.vt != VT_EMPTY )
			strValue = (LPCWSTR) _bstr_t( var );
	}
	catch( ... )
	{
		SetLastError( E_OUTOFMEMORY );
		SaveLastError();
		return FALSE;
	}

	// return
	return TRUE;
}

// ***************************************************************************
// Routine Description:
//		Gets the value of the property from the WMI class object in string format
//		  
// Arguments:
//		[ in ] pWmiObject		: pointer to the WBEM class object
//		[ in ] pwszProperty		: property name
//		[ out ] pdwValue		: value of the property
//		[ in ] dwDefault		: default in case failed in getting property value
//  
// Return Value:
//		TRUE - if operation is successfull, otherwise FALSE
// 
// ***************************************************************************
BOOL PropertyGet( IWbemClassObject* pWmiObject, 
				  LPCWSTR pwszProperty,  DWORD& dwValue, DWORD dwDefault )
{
	// local variables
	HRESULT hr;
	_variant_t var;

	// first set the defaul value
	dwValue = dwDefault;

	// check with object and property passed to the function are valid or not
	// if not, return failure
	if ( pWmiObject == NULL || pwszProperty == NULL )
		return FALSE;

	// get the value of the property
	hr = PropertyGet( pWmiObject, pwszProperty, var );
	if ( FAILED( hr ) )
		return FALSE;

	// get the process id from the variant
	if ( var.vt != VT_NULL && var.vt != VT_EMPTY )
		dwValue = (LONG) var;

	// return
	return TRUE;
}

// ***************************************************************************
// Routine Description:
//		Gets the value of the property from the WMI class object in string format
//		  
// Arguments:
//  
// Return Value:
//		TRUE - if operation is successfull, otherwise FALSE
// 
// ***************************************************************************
BOOL PropertyGet( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty,  ULONGLONG& ullValue )
{
	// local variables
	CHString str;

	// first set the default value
	ullValue = 1;

	// check with object and property passed to the function are valid or not
	// if not, return failure
	if ( pWmiObject == NULL || pwszProperty == NULL )
		return FALSE;

	// get the value of the property
	if ( PropertyGet( pWmiObject, pwszProperty, str, _T( "0" ) ) == FALSE )
		return FALSE;

	// get the 64-bit value
	ullValue = _wtoi64( str );

	// return
	return TRUE;
}

// ***************************************************************************
// Routine Description:
//		Gets the value of the property from the WMI class object in string format
//		  
// Arguments:
//  
// Return Value:
//		TRUE - if operation is successfull, otherwise FALSE
// 
// ***************************************************************************
BOOL PropertyGet( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty,  WBEMTime& wbemtime )
{
	// local variables
	CHString str;

	// Clear method sets the time in the WBEMTime object to an invalid time.
	wbemtime.Clear();

	// check with object and property passed to the function are valid or not
	// if not, return failure
	if ( pWmiObject == NULL || pwszProperty == NULL )
		return FALSE;

	// get the value of the property
	if ( PropertyGet( pWmiObject, pwszProperty, str, _T( "0" ) ) == FALSE )
		return FALSE;

	try
	{
		// convert into the time value
		wbemtime = _bstr_t( str );
	}
	catch( _com_error& e )
	{
		WMISaveError( e );
		return FALSE;
	}

	// return
	return TRUE;
}

// ***************************************************************************
// Routine Description:
//		Gets the value of the property from the WMI class object in string format
//		  
// Arguments:
//  
// Return Value:
//		TRUE - if operation is successfull, otherwise FALSE
// 
// ***************************************************************************
BOOL PropertyGet( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty,  SYSTEMTIME& systime )
{
	// local variables
	CHString strTime;

	// check with object and property passed to the function are valid or not
	// if not, return failure
	if ( pWmiObject == NULL || pwszProperty == NULL )
		return FALSE;

	// get the value of the property
	// 16010101000000.000000+000 is the default time
	if ( PropertyGet( pWmiObject, pwszProperty, strTime, _T( "16010101000000.000000+000" ) ) == FALSE )
		return FALSE;

	// prepare the systemtime structure
	// yyyymmddHHMMSS.mmmmmmsUUU
	systime.wYear = (WORD) AsLong( strTime.Left( 4 ), 10 );
	systime.wMonth = (WORD) AsLong( strTime.Mid( 4, 2 ), 10 );
	systime.wDayOfWeek = 0;
	systime.wDay = (WORD) AsLong( strTime.Mid( 6, 2 ), 10 );
	systime.wHour = (WORD) AsLong( strTime.Mid( 8, 2 ), 10 );
	systime.wMinute = (WORD) AsLong( strTime.Mid( 10, 2 ), 10 );
	systime.wSecond = (WORD) AsLong( strTime.Mid( 12, 2 ), 10 );
	systime.wMilliseconds = (WORD) AsLong( strTime.Mid( 15, 6 ), 10 );

	// return
	return TRUE;
}

// ***************************************************************************
// Routine Description:
//		Gets the value of the property from the WMI class object in string format
//		  
// Arguments:
//  
// Return Value:
//		TRUE - if operation is successfull, otherwise FALSE
// 
// ***************************************************************************
BOOL PropertyGet( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty, TARRAY arr )
{
	// local variables
	HRESULT hr;
	VARIANT vtValue;
	LONG lIndex = 0;
	LONG lLBound = 0;
	LONG lUBound = 0;
	VARTYPE vartype;
	SAFEARRAY* pSafeArray = NULL;

	// check the inputs
	if ( pWmiObject == NULL || pwszProperty == NULL || arr == NULL )
		return FALSE;

	// initialize the variant
	VariantInit( &vtValue );

	// now get the property value
	hr = PropertyGet( pWmiObject, pwszProperty, &vtValue );
	if ( FAILED( hr ) )
		return FALSE;

	if ( V_VT( &vtValue ) == VT_NULL )
		return TRUE;

		// confirm that the propety value is of array type .. if not return
	if ( ( V_VT( &vtValue ) & VT_ARRAY ) == 0 )
		return FALSE;

	// get the safearray value
	pSafeArray = V_ARRAY( &vtValue );

	// get the bounds of the array
    SafeArrayGetLBound( pSafeArray, 1, &lLBound );
    SafeArrayGetUBound( pSafeArray, 1, &lUBound );

	// get the type of the elements in the safe array
	vartype = V_VT( &vtValue ) & ~VT_ARRAY;

	try
	{
		// traverse thru the values in the safe array and update into dynamic array
		for( lIndex = lLBound; lIndex <= lUBound; lIndex++ )
		{
			// sub-local variables
			VARIANT var;
			CHString strValue;
			
			// get the value
			V_VT( &var ) = vartype;
			SafeArrayGetElement( pSafeArray, &lIndex, &V_UI1( &var ) );

			// add the information to the dynamic array
			switch( vartype )
			{
			case VT_BSTR:
				strValue = V_BSTR( &var );
				DynArrayAppendString( arr, strValue, 0 );
				break;
			}
		}
	}
	catch( ... )
	{
		// clear the variant
		VariantClear( &vtValue );
		return FALSE;	// failure
	}

	// clear the variant
	VariantClear( &vtValue );

	// return
	return TRUE;
}

// ***************************************************************************
// Routine Description:
//		Sets the value of the property to the WMI class object
//		  
// Arguments:
//		[ in ] pWmiObject		: pointer to the WBEM class object
//		[ in ] szProperty		: property name
//		[ in ] varValue	: value of the property
//  
// Return Value:
//		HRESULT - result of the operation
// 
// ***************************************************************************
HRESULT PropertyPut( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty, _variant_t& varValue )
{
	// local variables
	HRESULT hr;
	VARIANT var;

	// check the input value
	if ( pWmiObject == NULL || pwszProperty == NULL )
		return WBEM_E_INVALID_PARAMETER;

	try
	{
		// put the value
		var = varValue;
		hr = pWmiObject->Put( _bstr_t( pwszProperty ), 0, &var, 0 );
	}
	catch( _com_error& e )
	{
		WMISaveError( e );
		hr = e.Error();
	}
	
	// return the result
	return hr;
}

// ***************************************************************************
// Routine Description:
//		Sets the value of the property to the WMI class object
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
HRESULT PropertyPut( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty, LPCWSTR pwszValue )
{
	// local variables
	HRESULT hr;
	_variant_t varValue;

	// check the input value
	if ( pWmiObject == NULL || pwszProperty == NULL || pwszValue == NULL )
		return WBEM_E_INVALID_PARAMETER;

	try
	{
		varValue = pwszValue;
		hr = PropertyPut( pWmiObject, pwszProperty, varValue );
	}
	catch( _com_error& e )
	{
		WMISaveError( e );
		hr = e.Error();
	}

	// return 
	return hr;
}

// ***************************************************************************
// Routine Description:
//		Sets the value of the property to the WMI class object
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
HRESULT PropertyPut( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty, DWORD dwValue )
{
	// local variables
	HRESULT hr;
	_variant_t varValue;

	// check the input value
	if ( pWmiObject == NULL || pwszProperty == NULL )
		return WBEM_E_INVALID_PARAMETER;

	try
	{
		varValue = ( LONG ) dwValue;
		hr = PropertyPut( pWmiObject, pwszProperty, varValue );
	}
	catch( _com_error& e )
	{
		WMISaveError( e );
		hr = e.Error();
	}

	// return 
	return hr;
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
HRESULT RegQueryValueWMI( IWbemServices* pWbemServices, 
						  LPCWSTR pwszMethod, DWORD dwHDefKey, 
						  LPCWSTR pwszSubKeyName, LPCWSTR pwszValueName, _variant_t& varValue )
{
	// local variables
	HRESULT hr;
	BOOL bResult = FALSE;
	DWORD dwReturnValue = 0;
	IWbemClassObject* pClass = NULL;
	IWbemClassObject* pMethod = NULL;
	IWbemClassObject* pInParams = NULL;
	IWbemClassObject* pInParamsInstance = NULL;
	IWbemClassObject* pOutParamsInstance = NULL;

	// check the input value
	if (pWbemServices == NULL || pwszMethod == NULL || pwszSubKeyName == NULL || pwszValueName == NULL)
		return WBEM_E_INVALID_PARAMETER;

	try
	{
		// get the registry class object
		SAFE_EXECUTE( pWbemServices->GetObject( 
			_bstr_t( WMI_REGISTRY ), WBEM_FLAG_RETURN_WBEM_COMPLETE, NULL, &pClass, NULL ) );
		if ( pClass == NULL )						// check the object .. safety sake
			_com_issue_error( STG_E_UNKNOWN );

		// get the method reference required
		SAFE_EXECUTE( pClass->GetMethod( pwszMethod, 0, &pInParams, NULL ) );
		if ( pInParams == NULL )					// check the object .. safety sake
			_com_issue_error( STG_E_UNKNOWN );

		// create the instance for the in parameters
		SAFE_EXECUTE( pInParams->SpawnInstance( 0, &pInParamsInstance ) );
		if ( pInParamsInstance == NULL )
			_com_issue_error( STG_E_UNKNOWN );

		// set the input values
		PropertyPut( pInParamsInstance, _bstr_t( WMI_REGISTRY_IN_HDEFKEY ), dwHDefKey );
		PropertyPut( pInParamsInstance, _bstr_t( WMI_REGISTRY_IN_SUBKEY ), pwszSubKeyName );
		PropertyPut( pInParamsInstance, _bstr_t( WMI_REGISTRY_IN_VALUENAME ), pwszValueName );

		// now execute the method
		SAFE_EXECUTE( pWbemServices->ExecMethod( _bstr_t( WMI_REGISTRY ),
			_bstr_t( pwszMethod ), 0, NULL, pInParamsInstance, &pOutParamsInstance, NULL ) );
		if ( pOutParamsInstance == NULL )			// check the object .. safety sake
			_com_issue_error( STG_E_UNKNOWN );

		// now check the return value of the method from the output params object
		bResult = PropertyGet( pOutParamsInstance, 
			_bstr_t( WMI_REGISTRY_OUT_RETURNVALUE ), dwReturnValue );
		if ( bResult == FALSE || dwReturnValue != 0 )
			_com_issue_error( STG_E_UNKNOWN );

		// now everything is sucess .. get the required value
		PropertyGet( pOutParamsInstance, _bstr_t( WMI_REGISTRY_OUT_VALUE ), varValue );
	}
	catch( _com_error& e )
	{
		WMISaveError( e );
		return e.Error();
	}

	// release the interfaces
	SAFE_RELEASE( pClass );
	SAFE_RELEASE( pMethod );
	SAFE_RELEASE( pInParams );
	SAFE_RELEASE( pInParamsInstance );
	SAFE_RELEASE( pOutParamsInstance );

	// return success
	return S_OK;
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
BOOL RegQueryValueWMI( IWbemServices* pWbemServices, 
					   DWORD dwHDefKey, LPCWSTR pwszSubKeyName, 
					   LPCWSTR pwszValueName, CHString& strValue, LPCWSTR pwszDefault )
{
	// local variables
	HRESULT hr;
	_variant_t varValue;

	try
	{
		// set the default value
		if ( pwszDefault != NULL )
			strValue = pwszDefault;

		// check the input
		if ( pWbemServices == NULL || pwszSubKeyName == NULL || pwszValueName == NULL )
			return FALSE;

		// get the value
		hr = RegQueryValueWMI( pWbemServices, 
			WMI_REGISTRY_M_STRINGVALUE, dwHDefKey, pwszSubKeyName, pwszValueName, varValue );
		if ( FAILED( hr ) )
			return FALSE;

		// get the value from the variant
		// get the value
		if ( varValue.vt != VT_NULL && varValue.vt != VT_EMPTY )
			strValue = (LPCWSTR) _bstr_t( varValue );
	}
	catch( ... )
	{
		SetLastError( E_OUTOFMEMORY );
		SaveLastError();
		return FALSE;
	}

	// return success
	return TRUE;
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
DWORD GetTargetVersionEx( IWbemServices* pWbemServices, COAUTHIDENTITY* pAuthIdentity )
{
	// local variables
	HRESULT hr;
	LONG lPos = 0;
	DWORD dwMajor = 0;
	DWORD dwMinor = 0;
	DWORD dwVersion = 0;
	ULONG ulReturned = 0;
	CHString strVersion;
	IWbemClassObject* pWbemObject = NULL;
	IEnumWbemClassObject* pWbemInstances = NULL;

	// check the input value
	if ( pWbemServices == NULL )
		return 0;

	try
	{
		// get the OS information
		SAFE_EXECUTE( pWbemServices->CreateInstanceEnum( 
			_bstr_t( CLASS_CIMV2_Win32_OperatingSystem ), 0, NULL, &pWbemInstances ) );

		// set the security on the enumerated object
		SAFE_EXECUTE( SetInterfaceSecurity( pWbemInstances, pAuthIdentity ) );

		// get the enumerated objects information
		// NOTE: This needs to be traversed only one time. 
		SAFE_EXECUTE( pWbemInstances->Next( WBEM_INFINITE, 1, &pWbemObject, &ulReturned ) );

		// to be on safer side ... check the count of objects returned
		if ( ulReturned == 0 )
		{
			// release the interfaces
			SAFE_RELEASE( pWbemObject );
			SAFE_RELEASE( pWbemInstances );
			return 0;
		}

		// now get the os version value
		if ( PropertyGet( pWbemObject, L"Version", strVersion ) == FALSE )
		{
			// release the interfaces
			SAFE_RELEASE( pWbemObject );
			SAFE_RELEASE( pWbemInstances );
			return 0;
		}

		// release the interfaces .. we dont need them furthur
		SAFE_RELEASE( pWbemObject );
		SAFE_RELEASE( pWbemInstances );
	
		//
		// now determine the os version
		dwMajor = dwMinor = 0;

		// get the major version
		lPos = strVersion.Find( L'.' );
		if ( lPos == -1 )
		{
			// the version string itself is version ... THIS WILL NEVER HAPPEN
			dwMajor = AsLong( strVersion, 10 );
		}
		else
		{
			// major version
			dwMajor = AsLong( strVersion.Mid( 0, lPos ), 10 );

			// get the minor version
			strVersion = strVersion.Mid( lPos + 1 );
			lPos = strVersion.Find( L'.' );
			if ( lPos == -1 )
				dwMinor = AsLong( strVersion, 10 );
			else
				dwMinor = AsLong( strVersion.Mid( 0, lPos ), 10 );
		}

		// mix the version info
		dwVersion = dwMajor * 1000 + dwMinor;
	}
	catch( _com_error& e )
	{
		WMISaveError( e );
		return 0;
	}

	// return 
	return dwVersion;
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
DWORD GetTargetPlatformEx( IWbemServices* pWbemServices, COAUTHIDENTITY* pAuthIdentity )
{
	// local variables
	HRESULT hr;
	LONG lPos = 0;
	CHString strType;
	ULONG ulReturned = 0;
	IWbemClassObject* pWbemObject = NULL;
	IEnumWbemClassObject* pWbemInstances = NULL;

	// check the input value
	if ( pWbemServices == NULL )
		return 0;

	try
	{
		// get the OS information
		SAFE_EXECUTE( pWbemServices->CreateInstanceEnum( 
			_bstr_t( CLASS_CIMV2_Win32_ComputerSystem ), 0, NULL, &pWbemInstances ) );

		// set the security on the enumerated object
		SAFE_EXECUTE( SetInterfaceSecurity( pWbemInstances, pAuthIdentity ) );

		// get the enumerated objects information
		// NOTE: This needs to be traversed only one time. 
		SAFE_EXECUTE( pWbemInstances->Next( WBEM_INFINITE, 1, &pWbemObject, &ulReturned ) );

		// to be on safer side ... check the count of objects returned
		if ( ulReturned == 0 )
		{
			// release the interfaces
			SAFE_RELEASE( pWbemObject );
			SAFE_RELEASE( pWbemInstances );
			return 0;
		}

		// now get the os version value
		if ( PropertyGet( pWbemObject, L"SystemType", strType ) == FALSE )
		{
			// release the interfaces
			SAFE_RELEASE( pWbemObject );
			SAFE_RELEASE( pWbemInstances );
			return 0;
		}

		// release the interfaces .. we dont need them furthur
		SAFE_RELEASE( pWbemObject );
		SAFE_RELEASE( pWbemInstances );

		// determine the type of the platform
		if ( strType.Find( TEXT_X86 ) != -1 )
			return PLATFORM_X86;
		else if ( strType.Find( TEXT_IA64 ) != -1 )
			return PLATFORM_IA64;
		else if ( strType.Find( TEXT_AMD64 ) != -1 )
			return PLATFORM_AMD64;
	}
	catch( _com_error& e )
	{
		WMISaveError( e );
		return 0;
	}

	// return 
	return PLATFORM_UNKNOWN;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cmdline\systeminfo\resource.h ===
#define IDS_FMT_KILOBYTES				101
#define IDS_FMT_UPTIME					102
#define IDS_FMT_OSVERSION				103
#define IDS_FMT_MEGABYTES				104
#define IDS_FMT_PROCESSOR_TOTAL			105
#define IDS_FMT_PROCESSOR_INFO			106
#define IDS_FMT_NIC_TOTAL				107
#define IDS_FMT_NIC_INFO				108
#define IDS_FMT_HOTFIX_TOTAL			109
#define IDS_FMT_HOTFIX_INFO				110
#define IDS_FMT_DHCP_STATUS				111
#define IDS_FMT_DHCP_SERVER				112
#define IDS_FMT_IPADDRESS_TOTAL			113
#define IDS_FMT_IPADDRESS_INFO			114
#define IDS_FMT_NIC_STATUS				115
#define IDS_FMT_CONNECTION				116

#define IDS_OVALUES_FORMAT						126
#define IDS_TEXT_FORMAT_LIST					127
#define IDS_TEXT_FORMAT_TABLE					128
#define IDS_TEXT_FORMAT_CSV						129
#define IDS_VALUE_STANDALONEWORKSTATION			130	
#define IDS_VALUE_MEMBERWORKSTATION				131
#define IDS_VALUE_STANDALONESERVER				132
#define IDS_VALUE_MEMBERSERVER					133
#define IDS_VALUE_BACKUPDOMAINCONTROLLER		134
#define IDS_VALUE_PRIMARYDOMAINCONTROLLER		135
#define IDS_VALUE_YES							136
#define IDS_VALUE_NO							137
#define IDS_VALUE_DISCONNECTED					138
#define IDS_VALUE_CONNECTING					139
#define IDS_VALUE_CONNECTED						140
#define IDS_VALUE_DISCONNECTING					141
#define IDS_VALUE_HWNOTPRESENT					142
#define IDS_VALUE_HWDISABLED					143
#define IDS_VALUE_HWMALFUNCTION					144
#define IDS_VALUE_MEDIADISCONNECTED				145
#define IDS_VALUE_AUTHENTICATING				146
#define IDS_VALUE_AUTHSUCCEEDED					147
#define IDS_VALUE_AUTHFAILED					148

#define IDS_COLHEAD_HOSTNAME					151
#define IDS_COLHEAD_OS_NAME						152
#define IDS_COLHEAD_OS_VERSION					153
#define IDS_COLHEAD_OS_MANUFACTURER				154
#define IDS_COLHEAD_OS_CONFIG					155
#define IDS_COLHEAD_OS_BUILDTYPE				156
#define IDS_COLHEAD_REG_OWNER					157
#define IDS_COLHEAD_REG_ORG						158
#define IDS_COLHEAD_PRODUCT_ID					159
#define IDS_COLHEAD_INSTALL_DATE				160
#define IDS_COLHEAD_SYSTEM_UPTIME				161
#define IDS_COLHEAD_SYSTEM_MANUFACTURER			162
#define IDS_COLHEAD_SYSTEM_MODEL				163
#define IDS_COLHEAD_SYSTEM_TYPE					164
#define IDS_COLHEAD_PROCESSOR					165
#define IDS_COLHEAD_BIOS_VERSION				166
#define IDS_COLHEAD_WINDOWS_DIRECTORY			167
#define IDS_COLHEAD_SYSTEM_DIRECTORY			168
#define IDS_COLHEAD_BOOT_DEVICE					169
#define IDS_COLHEAD_SYSTEM_LOCALE				170
#define IDS_COLHEAD_INPUT_LOCALE				171
#define IDS_COLHEAD_TIME_ZONE					172
#define IDS_COLHEAD_TOTAL_PHYSICAL_MEMORY		173
#define IDS_COLHEAD_AVAILABLE_PHYSICAL_MEMORY	174
#define IDS_COLHEAD_VIRTUAL_MEMORY_MAX			175
#define IDS_COLHEAD_VIRTUAL_MEMORY_AVAILABLE	176
#define IDS_COLHEAD_VIRTUAL_MEMORY_INUSE		177
#define IDS_COLHEAD_PAGEFILE_LOCATION			178
#define IDS_COLHEAD_DOMAIN						179
#define IDS_COLHEAD_LOGON_SERVER				180
#define IDS_COLHEAD_HOTFIX						181
#define IDS_COLHEAD_NETWORK_CARD				182

#define IDS_COLWIDTH_HOSTNAME					201
#define IDS_COLWIDTH_OS_NAME					202
#define IDS_COLWIDTH_OS_VERSION					203
#define IDS_COLWIDTH_OS_MANUFACTURER			204
#define IDS_COLWIDTH_OS_CONFIG					205
#define IDS_COLWIDTH_OS_BUILDTYPE				206
#define IDS_COLWIDTH_REG_OWNER					207
#define IDS_COLWIDTH_REG_ORG					208
#define IDS_COLWIDTH_PRODUCT_ID					209
#define IDS_COLWIDTH_INSTALL_DATE				210
#define IDS_COLWIDTH_SYSTEM_UPTIME				211
#define IDS_COLWIDTH_SYSTEM_MANUFACTURER		212
#define IDS_COLWIDTH_SYSTEM_MODEL				213
#define IDS_COLWIDTH_SYSTEM_TYPE				214
#define IDS_COLWIDTH_PROCESSOR					215
#define IDS_COLWIDTH_BIOS_VERSION				216
#define IDS_COLWIDTH_WINDOWS_DIRECTORY			217
#define IDS_COLWIDTH_SYSTEM_DIRECTORY			218
#define IDS_COLWIDTH_BOOT_DEVICE				219
#define IDS_COLWIDTH_SYSTEM_LOCALE				220
#define IDS_COLWIDTH_INPUT_LOCALE				221
#define IDS_COLWIDTH_TIME_ZONE					222
#define IDS_COLWIDTH_TOTAL_PHYSICAL_MEMORY		223
#define IDS_COLWIDTH_AVAILABLE_PHYSICAL_MEMORY	224
#define IDS_COLWIDTH_VIRTUAL_MEMORY_MAX			225
#define IDS_COLWIDTH_VIRTUAL_MEMORY_AVAILABLE	226
#define IDS_COLWIDTH_VIRTUAL_MEMORY_INUSE		227
#define IDS_COLWIDTH_PAGEFILE_LOCATION			228
#define IDS_COLWIDTH_DOMAIN						229
#define IDS_COLWIDTH_LOGON_SERVER				230
#define IDS_COLWIDTH_HOTFIX						231
#define IDS_COLWIDTH_NETWORK_CARD				232

#define IDS_ERROR_USERNAME_BUT_NOMACHINE	501
#define IDS_ERROR_PASSWORD_BUT_NOUSERNAME	502
#define IDS_ERROR_COM_ERROR					503
#define IDS_ERROR_USERNAME_EMPTY			504
#define	IDS_ERROR_NH_NOTSUPPORTED			505
#define IDS_ERROR_SERVERNAME_EMPTY			506
#define IDS_ERROR_INVALID_USAGE_REQUEST		507

#define IDS_MSG_OSINFO					551
#define IDS_MSG_COMPINFO				552
#define IDS_MSG_PERFINFO				553
#define IDS_MSG_PROCESSORINFO			554
#define IDS_MSG_BIOSINFO				555
#define IDS_MSG_INPUTLOCALEINFO			556
#define IDS_MSG_TZINFO					557
#define IDS_MSG_PAGEFILEINFO			558
#define IDS_MSG_HOTFIXINFO				559
#define IDS_MSG_NICINFO					560
#define IDS_MSG_PROFILEINFO				561

#define IDS_HELP_LINE1			1001
#define IDS_HELP_LINE2			1002
#define IDS_HELP_LINE3			1003
#define IDS_HELP_LINE4			1004
#define IDS_HELP_LINE5			1005
#define IDS_HELP_LINE6			1006
#define IDS_HELP_LINE7			1007
#define IDS_HELP_LINE8			1008
#define IDS_HELP_LINE9			1009
#define IDS_HELP_LINE10			1010
#define IDS_HELP_LINE11			1011
#define IDS_HELP_LINE12			1012
#define IDS_HELP_LINE13			1013
#define IDS_HELP_LINE14			1014
#define IDS_HELP_LINE15			1015
#define IDS_HELP_LINE16			1016
#define IDS_HELP_LINE17			1017
#define IDS_HELP_LINE18			1018
#define IDS_HELP_LINE19			1019
#define IDS_HELP_LINE20			1020
#define IDS_HELP_LINE21			1021
#define IDS_HELP_LINE22			1022
#define IDS_HELP_LINE23			1023
#define IDS_HELP_LINE24			1024
#define IDS_HELP_LINE25			1025
#define IDS_HELP_LINE26			1026
#define IDS_HELP_LINE27			1027
#define IDS_HELP_LINE28			1028

// usage indexes into the string table
#define ID_HELP_START		IDS_HELP_LINE1
#define ID_HELP_END			IDS_HELP_LINE28
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cmdline\systeminfo\parseandshow.cpp ===
// *********************************************************************************
// 
//  Copyright (c) Microsoft Corporation
//  
//  Module Name:
//  
//		parseAndshow.cpp
//  
//  Abstract:
//  
// 		This module implements the command-line parsing and validating the filters
//  
//  Author:
//  
// 		Sunil G.V.N. Murali (murali.sunil@wipro.com) 27-Dec-2000
//  
//  Revision History:
//  
// 		Sunil G.V.N. Murali (murali.sunil@wipro.com) 27-Dec-2000 : Created It.
//  
// *********************************************************************************

#include "pch.h"
#include "systeminfo.h"

//
// local function prototypes
//

// ***************************************************************************
// Routine Description:
//		processes and validates the command line inputs
//		  
// Arguments:
//		[ in ] argc			 : no. of input arguments specified
//		[ in ] argv			 : input arguments specified at command prompt
//  
// Return Value:
//		TRUE  : if inputs are valid
//		FALSE : if inputs were errorneously specified
// 
// ***************************************************************************
BOOL CSystemInfo::ProcessOptions( DWORD argc, LPCTSTR argv[] )
{
	// local variables
	CHString strFormat;
	BOOL bNoHeader = FALSE;
	PTCMDPARSER pcmdOptions = NULL;

	// temporary local variables
	LPWSTR pwszFormat = NULL;
	LPWSTR pwszServer = NULL;
	LPWSTR pwszUserName = NULL;
	LPWSTR pwszPassword = NULL;
	PTCMDPARSER pOption = NULL;
	PTCMDPARSER pOptionServer = NULL;
	PTCMDPARSER pOptionUserName = NULL;
	PTCMDPARSER pOptionPassword = NULL;

	//
	// prepare the command options
	pcmdOptions = new TCMDPARSER[ MAX_OPTIONS ];
	if ( pcmdOptions == NULL )
	{
		SetLastError( E_OUTOFMEMORY );
		SaveLastError();
		return FALSE;
	}
	else
	{
		ZeroMemory( pcmdOptions, MAX_OPTIONS * sizeof( TCMDPARSER ) );
	}

	try
	{
		// get the internal buffers
		pwszFormat = strFormat.GetBufferSetLength( MAX_STRING_LENGTH );
		pwszServer = m_strServer.GetBufferSetLength( MAX_STRING_LENGTH );
		pwszUserName = m_strUserName.GetBufferSetLength( MAX_STRING_LENGTH );
		pwszPassword = m_strPassword.GetBufferSetLength( MAX_STRING_LENGTH );

		// init the password contents with '*'
		lstrcpy( pwszPassword, L"*" );
	}
	catch( ... )
	{
		SetLastError( E_OUTOFMEMORY );
		SaveLastError();
		return FALSE;
	}

	// -?
	pOption = pcmdOptions + OI_USAGE;
	pOption->dwCount = 1;
	pOption->dwActuals = 0;
	pOption->dwFlags = CP_USAGE;
	pOption->pValue = &m_bUsage;
	pOption->pFunction = NULL;
	pOption->pFunctionData = NULL;
	lstrcpy( pOption->szValues, NULL_STRING );
	lstrcpy( pOption->szOption, OPTION_USAGE );

	// -s
	pOption = pcmdOptions + OI_SERVER;
	pOption->dwCount = 1;
	pOption->dwActuals = 0;
	pOption->pValue = pwszServer;
	pOption->pFunction = NULL;
	pOption->pFunctionData = NULL;
	pOption->dwFlags = CP_TYPE_TEXT | CP_VALUE_MANDATORY;
	lstrcpy( pOption->szValues, NULL_STRING );
	lstrcpy( pOption->szOption, OPTION_SERVER );

	// -u
	pOption = pcmdOptions + OI_USERNAME;
	pOption->dwCount = 1;
	pOption->dwActuals = 0;
	pOption->dwFlags = CP_TYPE_TEXT | CP_VALUE_MANDATORY;
	pOption->pValue = pwszUserName;
	pOption->pFunction = NULL;
	pOption->pFunctionData = NULL;
	lstrcpy( pOption->szValues, NULL_STRING );
	lstrcpy( pOption->szOption, OPTION_USERNAME );

	// -p
	pOption = pcmdOptions + OI_PASSWORD;
	pOption->dwCount = 1;
	pOption->dwActuals = 0;
	pOption->dwFlags = CP_TYPE_TEXT | CP_VALUE_OPTIONAL;
	pOption->pValue = pwszPassword;
	pOption->pFunction = NULL;
	pOption->pFunctionData = NULL;
	lstrcpy( pOption->szValues, NULL_STRING );
	lstrcpy( pOption->szOption, OPTION_PASSWORD );

	// -format
	pOption = pcmdOptions + OI_FORMAT;
	pOption->dwCount = 1;
	pOption->dwActuals = 0;
	pOption->dwFlags = CP_TYPE_TEXT | CP_VALUE_MANDATORY | CP_MODE_VALUES;
	pOption->pValue = pwszFormat;
	pOption->pFunction = NULL;
	pOption->pFunctionData = NULL;
	lstrcpy( pOption->szValues, OVALUES_FORMAT );
	lstrcpy( pOption->szOption, OPTION_FORMAT );

	// -noheader
	pOption = pcmdOptions + OI_NOHEADER;
	pOption->dwCount = 1;
	pOption->dwActuals = 0;
	pOption->dwFlags = 0;
	pOption->pValue = &bNoHeader;
	pOption->pFunction = NULL;
	pOption->pFunctionData = NULL;
	lstrcpy( pOption->szValues, NULL_STRING );
	lstrcpy( pOption->szOption, OPTION_NOHEADER );

	//
	// now, check the mutually exclusive options
	pOptionServer = pcmdOptions + OI_SERVER;
	pOptionUserName = pcmdOptions + OI_USERNAME;
	pOptionPassword = pcmdOptions + OI_PASSWORD;

	//
	// do the parsing
	if ( DoParseParam( argc, argv, MAX_OPTIONS, pcmdOptions ) == FALSE )
	{
		RELEASE_MEMORY_EX( pcmdOptions );	// clear memory
		return FALSE;			// invalid syntax
	}

	// release the buffers
	strFormat.ReleaseBuffer();
	m_strServer.ReleaseBuffer();
	m_strUserName.ReleaseBuffer();
	m_strPassword.ReleaseBuffer();

	// check the usage option
	if ( m_bUsage && ( argc > 2 ) )
	{
		// no other options are accepted along with -? option
		SetLastError( MK_E_SYNTAX );
		SetReason( ERROR_INVALID_USAGE_REQUEST );
		RELEASE_MEMORY_EX( pcmdOptions );	// clear memory
		return FALSE;
	}
	else if ( m_bUsage == TRUE )
	{
		// should not do the furthur validations
		RELEASE_MEMORY_EX( pcmdOptions );	// clear memory
		return TRUE;
	}

	// empty server name is not valid
	if ( pOptionServer->dwActuals != 0 && m_strServer.GetLength() == 0 )
	{
		SetReason( ERROR_SERVERNAME_EMPTY );
		RELEASE_MEMORY_EX( pcmdOptions );	// clear memory
		return FALSE;			// indicate failure
	}

	// empty user is not valid
	if ( pOptionUserName->dwActuals != 0 && m_strUserName.GetLength() == 0 )
	{
		SetReason( ERROR_USERNAME_EMPTY );
		RELEASE_MEMORY_EX( pcmdOptions );	// clear memory
		return FALSE;
	}

	// "-u" should not be specified without machine names
	if ( pOptionServer->dwActuals == 0 && pOptionUserName->dwActuals != 0 )
	{
		// invalid syntax
		SetReason( ERROR_USERNAME_BUT_NOMACHINE );
		RELEASE_MEMORY_EX( pcmdOptions );	// clear memory
		return FALSE;			// indicate failure
	}

	// "-p" should not be specified without "-u"
	if ( pOptionUserName->dwActuals == 0 && pOptionPassword->dwActuals != 0 )
	{
		// invalid syntax
		SetReason( ERROR_PASSWORD_BUT_NOUSERNAME );
		RELEASE_MEMORY_EX( pcmdOptions );	// clear memory
		return FALSE;			// indicate failure
	}

	// determine the format in which the process information has to be displayed
	m_dwFormat = SR_FORMAT_LIST;		// default format
	if ( strFormat.CompareNoCase( TEXT_FORMAT_LIST ) == 0 )
		m_dwFormat = SR_FORMAT_LIST;
	else if ( strFormat.CompareNoCase( TEXT_FORMAT_TABLE ) == 0 )
		m_dwFormat = SR_FORMAT_TABLE;
	else if ( strFormat.CompareNoCase( TEXT_FORMAT_CSV ) == 0 )
		m_dwFormat = SR_FORMAT_CSV;

	// user might have given no header option for a LIST format which is invalid
	if ( bNoHeader == TRUE && m_dwFormat == SR_FORMAT_LIST )
	{
		// invalid syntax
		SetReason( ERROR_NH_NOTSUPPORTED );
		RELEASE_MEMORY_EX( pcmdOptions );			// clear memory
		return FALSE;								// indicate failure
	}

	// check for the no header info and apply to the format variable
	if ( bNoHeader == TRUE )
		m_dwFormat |= SR_NOHEADER;

	// check whether caller should accept the password or not
	// if user has specified -s (or) -u and no "-p", then utility should accept password
	// the user will be prompter for the password only if establish connection 
	// is failed without the credentials information
	if ( pOptionPassword->dwActuals != 0 && m_strPassword.Compare( L"*" ) == 0 )
	{
		// user wants the utility to prompt for the password before trying to connect
		m_bNeedPassword = TRUE;
	}
	else if ( (pOptionPassword->dwActuals == 0 && 
			  (pOptionServer->dwActuals != 0 || pOptionUserName->dwActuals != 0)) )
	{
		// utility needs to try to connect first and if it fails then prompt for the password
		m_bNeedPassword = TRUE;
		m_strPassword.Empty();
	}

	// command-line parsing is successfull
	RELEASE_MEMORY_EX( pcmdOptions );	// clear memory
	return TRUE;
}

// ***************************************************************************
// Routine Description:
//		show the system configuration information
//		  
// Arguments:
//		NONE
//  
// Return Value:
//		NONE
// 
// ***************************************************************************
VOID CSystemInfo::ShowOutput( DWORD dwStart, DWORD dwEnd )
{
	// local variables
	PTCOLUMNS pColumn = NULL;

	// dynamically show / hide columns on need basis
	for( DWORD dw = 0; dw < MAX_COLUMNS; dw++ )
	{
		// point to the column info
		pColumn = m_pColumns + dw;

		// remove the hide flag from the column
		pColumn->dwFlags &= ~( SR_HIDECOLUMN );

		// now if the column should not be shown, set the hide flag)
		if ( dw < dwStart || dw > dwEnd )
			pColumn->dwFlags |= SR_HIDECOLUMN;
	}

	// if the data is being displayed from the first line onwards, 
	// add a blank line
	if ( dwStart == 0 )
		ShowMessage( stdout, L"\n" );

	//
	// display the results
	ShowResults( MAX_COLUMNS, m_pColumns, m_dwFormat, m_arrData );
}

// ***************************************************************************
// Routine Description:
//		This function fetches usage information from resource file and shows it
//		  
// Arguments:
//		NONE
//  
// Return Value:
//		NONE
// ***************************************************************************
VOID CSystemInfo::ShowUsage()
{
	// local variables
	DWORD dw = 0;

	// start displaying the usage
	for( dw = ID_HELP_START; dw <= ID_HELP_END; dw++ )
		ShowMessage( stdout, GetResString( dw ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cmdline\systeminfo\systeminfo.h ===
// *********************************************************************************
// 
//  Copyright (c) Microsoft Corporation
//  
//  Module Name:
//
//		SystemInfo.h  
//  
//  Abstract:
//  
//		macros and function prototypes of SystemInfo.cpp
//  
//  Author:
//  
// 	  Sunil G.V.N. Murali (murali.sunil@wipro.com) 22-Dec-2000
//  
//  Revision History:
//  
// 	  Sunil G.V.N. Murali (murali.sunil@wipro.com) 22-Dec-2000 : Created It.
//  
// *********************************************************************************

#ifndef __SYSTEMINFO_H
#define __SYSTEMINFO_H

// resource header file
#include "resource.h"

//
// NOTE: THIS MODULE WILL WRITTEN IN SUCH A FASHION THAT IT WORKS ONLY
//       IN UNICODE BUILD COMPILATION
//
#ifndef UNICODE
#error Must compile only in unicode build environment
#endif

//
// general purpose macros
//
#define EXIT_PROCESS( exitcode )	\
	ReleaseGlobals();	\
	return exitcode;	\
	1

#define RELEASE_MEMORY( block )	\
	if ( (block) != NULL )	\
	{	\
		delete (block);	\
		(block) = NULL;	\
	}	\
	1

#define RELEASE_MEMORY_EX( block )	\
	if ( (block) != NULL )	\
	{	\
		delete [] (block);	\
		(block) = NULL;	\
	}	\
	1

#define DESTROY_ARRAY( array )	\
	if ( (array) != NULL )	\
	{	\
		DestroyDynamicArray( &(array) );	\
		(array) = NULL;	\
	}	\
	1

//
// constants / defines / enumerations
//

// registry path
#define LOCALE_PATH							L"MIME\\Database\\Rfc1766"

// messages
#define ERROR_USERNAME_BUT_NOMACHINE	GetResString( IDS_ERROR_USERNAME_BUT_NOMACHINE )
#define ERROR_PASSWORD_BUT_NOUSERNAME	GetResString( IDS_ERROR_PASSWORD_BUT_NOUSERNAME )
#define ERROR_USERNAME_EMPTY			GetResString( IDS_ERROR_USERNAME_EMPTY )
#define ERROR_NH_NOTSUPPORTED			GetResString( IDS_ERROR_NH_NOTSUPPORTED )
#define ERROR_SERVERNAME_EMPTY			GetResString( IDS_ERROR_SERVERNAME_EMPTY )
#define ERROR_INVALID_USAGE_REQUEST		GetResString( IDS_ERROR_INVALID_USAGE_REQUEST )

// output formats
#define TEXT_FORMAT_LIST		GetResString( IDS_TEXT_FORMAT_LIST )
#define TEXT_FORMAT_TABLE		GetResString( IDS_TEXT_FORMAT_TABLE )
#define TEXT_FORMAT_CSV			GetResString( IDS_TEXT_FORMAT_CSV )

//
// WMI related stuff

// Win32_OperatingSystem class information
#define WIN32_OPERATINGSYSTEM							L"Win32_OperatingSystem"
#define WIN32_OPERATINGSYSTEM_P_CAPTION						L"Caption"
#define WIN32_OPERATINGSYSTEM_P_CSNAME						L"CSName"
#define WIN32_OPERATINGSYSTEM_P_VERSION						L"Version"
#define WIN32_OPERATINGSYSTEM_P_CSDVERSION					L"CSDVersion"
#define WIN32_OPERATINGSYSTEM_P_BUILDNUMBER					L"BuildNumber"
#define WIN32_OPERATINGSYSTEM_P_MANUFACTURER				L"Manufacturer"
#define WIN32_OPERATINGSYSTEM_P_BUILDTYPE					L"BuildType"
#define WIN32_OPERATINGSYSTEM_P_REGUSER						L"RegisteredUser"
#define WIN32_OPERATINGSYSTEM_P_ORGANIZATION				L"Organization"
#define WIN32_OPERATINGSYSTEM_P_SERIALNUMBER				L"SerialNumber"
#define WIN32_OPERATINGSYSTEM_P_INSTALLDATE					L"InstallDate"
#define WIN32_OPERATINGSYSTEM_P_WINDOWSDIR					L"WindowsDirectory"
#define WIN32_OPERATINGSYSTEM_P_SYSTEMDIR					L"SystemDirectory"
#define WIN32_OPERATINGSYSTEM_P_BOOTDEVICE					L"BootDevice"
#define WIN32_OPERATINGSYSTEM_P_LOCALE						L"Locale"
#define WIN32_OPERATINGSYSTEM_P_FREEPHYSICALMEMORY			L"FreePhysicalMemory"
#define WIN32_OPERATINGSYSTEM_P_TOTALVIRTUALMEMORY			L"TotalVirtualMemorySize"
#define WIN32_OPERATINGSYSTEM_P_FREEVIRTUALMEMORY			L"FreeVirtualMemory"

// Win32_ComputerSystem class information
#define WIN32_COMPUTERSYSTEM							L"Win32_ComputerSystem"
#define WIN32_COMPUTERSYSTEM_P_MODEL						L"Model"
#define WIN32_COMPUTERSYSTEM_P_SYSTEMTYPE					L"SystemType"
#define WIN32_COMPUTERSYSTEM_P_TOTALPHYSICALMEMORY			L"TotalPhysicalMemory"
#define WIN32_COMPUTERSYSTEM_P_MANUFACTURER					L"Manufacturer"
#define WIN32_COMPUTERSYSTEM_P_DOMAIN						L"Domain"
#define WIN32_COMPUTERSYSTEM_P_DOMAINROLE					L"DomainRole"
#define WIN32_COMPUTERSYSTEM_P_USERNAME						L"UserName"

// Win32_BIOS
#define WIN32_BIOS										L"Win32_BIOS"
#define WIN32_BIOS_P_VERSION								L"Version"

// Win32_TimeZone
#define WIN32_TIMEZONE									L"Win32_TimeZone"
#define WIN32_TIMEZONE_P_CAPTION							L"Caption"

// Win32_PageFile
#define WIN32_PAGEFILE									L"Win32_PageFileSetting"
#define WIN32_PAGEFILE_P_NAME								L"Name"

// Win32_Processor
#define WIN32_PROCESSOR									L"Win32_Processor"
#define WIN32_PROCESSOR_P_CAPTION							L"Caption"
#define WIN32_PROCESSOR_P_MANUFACTURER						L"Manufacturer"
#define WIN32_PROCESSOR_P_CURRENTCLOCKSPEED					L"CurrentClockSpeed"
#define WIN32_PROCESSOR_P_MAXCLOCKSPEED						L"MaxClockSpeed"

// Win32_PerfRawData_PerfOS_System
#define WIN32_PERFRAWDATA_PERFOS_SYSTEM					L"Win32_PerfRawData_PerfOS_System"
#define WIN32_PERFRAWDATA_PERFOS_SYSTEM_P_SYSUPTIME			L"SystemUpTime"
#define WIN32_PERFRAWDATA_PERFOS_SYSTEM_P_TIMESTAMP			L"Timestamp_Object"
#define WIN32_PERFRAWDATA_PERFOS_SYSTEM_P_FREQUENCY			L"Frequency_Object"

// Win32_Keyboard
#define WIN32_KEYBOARD									L"Win32_Keyboard"
#define WIN32_KEYBOARD_P_LAYOUT								L"Layout"

// Win32_QuickFixEngineering
#define WIN32_QUICKFIXENGINEERING						L"Win32_QuickFixEngineering"
#define WIN32_QUICKFIXENGINEERING_P_HOTFIXID				L"HotFixID"
#define WIN32_QUICKFIXENGINEERING_P_FIXCOMMENTS				L"FixComments"

// Win32_NetworkAdapter
#define WIN32_NETWORKADAPTER							L"Win32_NetworkAdapter"
#define WIN32_NETWORKADAPTER_P_INDEX						L"Index"
#define WIN32_NETWORKADAPTER_P_NETCONNECTIONID				L"NetConnectionID"
#define WIN32_NETWORKADAPTER_P_DESCRIPTION					L"Description"
#define WIN32_NETWORKADAPTER_P_STATUS						L"NetConnectionStatus"

// Win32_NetworkAdapterConfiguration
#define WIN32_NETWORKADAPTERCONFIGURATION_GET			L"Win32_NetworkAdapterConfiguration.Index=%d"
#define WIN32_NETWORKADAPTERCONFIGURATION_P_IPADDRESS		L"IPAddress"
#define WIN32_NETWORKADAPTERCONFIGURATION_P_DHCPENABLED		L"DHCPEnabled"
#define WIN32_NETWORKADAPTERCONFIGURATION_P_DHCPSERVER		L"DHCPServer"

//
// registry specific

// registry paths
#define SUBKEY_VOLATILE_ENVIRONMENT						L"Volatile Environment"
#define KEY_LOGONSERVER									L"LOGONSERVER"

//
// column heading names and their indexes in the array ( in fact positions )
#define MAX_COLUMNS				32

// column headings
#define COLHEAD_HOSTNAME					GetResString( IDS_COLHEAD_HOSTNAME )
#define COLHEAD_OS_NAME						GetResString( IDS_COLHEAD_OS_NAME )
#define COLHEAD_OS_VERSION					GetResString( IDS_COLHEAD_OS_VERSION )
#define COLHEAD_OS_MANUFACTURER				GetResString( IDS_COLHEAD_OS_MANUFACTURER )
#define COLHEAD_OS_CONFIG					GetResString( IDS_COLHEAD_OS_CONFIG )
#define COLHEAD_OS_BUILDTYPE				GetResString( IDS_COLHEAD_OS_BUILDTYPE )
#define COLHEAD_REG_OWNER					GetResString( IDS_COLHEAD_REG_OWNER )
#define COLHEAD_REG_ORG						GetResString( IDS_COLHEAD_REG_ORG )
#define COLHEAD_PRODUCT_ID					GetResString( IDS_COLHEAD_PRODUCT_ID )
#define COLHEAD_INSTALL_DATE				GetResString( IDS_COLHEAD_INSTALL_DATE )
#define COLHEAD_SYSTEM_UPTIME				GetResString( IDS_COLHEAD_SYSTEM_UPTIME )
#define COLHEAD_SYSTEM_MANUFACTURER			GetResString( IDS_COLHEAD_SYSTEM_MANUFACTURER )
#define COLHEAD_SYSTEM_MODEL				GetResString( IDS_COLHEAD_SYSTEM_MODEL )
#define COLHEAD_SYSTEM_TYPE					GetResString( IDS_COLHEAD_SYSTEM_TYPE )
#define COLHEAD_PROCESSOR					GetResString( IDS_COLHEAD_PROCESSOR )
#define COLHEAD_BIOS_VERSION				GetResString( IDS_COLHEAD_BIOS_VERSION )
#define COLHEAD_WINDOWS_DIRECTORY			GetResString( IDS_COLHEAD_WINDOWS_DIRECTORY )
#define COLHEAD_SYSTEM_DIRECTORY			GetResString( IDS_COLHEAD_SYSTEM_DIRECTORY )
#define COLHEAD_BOOT_DEVICE					GetResString( IDS_COLHEAD_BOOT_DEVICE )
#define COLHEAD_SYSTEM_LOCALE				GetResString( IDS_COLHEAD_SYSTEM_LOCALE )
#define COLHEAD_INPUT_LOCALE				GetResString( IDS_COLHEAD_INPUT_LOCALE )
#define COLHEAD_TIME_ZONE					GetResString( IDS_COLHEAD_TIME_ZONE )
#define COLHEAD_TOTAL_PHYSICAL_MEMORY		GetResString( IDS_COLHEAD_TOTAL_PHYSICAL_MEMORY )
#define COLHEAD_AVAILABLE_PHYSICAL_MEMORY	GetResString( IDS_COLHEAD_AVAILABLE_PHYSICAL_MEMORY )
#define COLHEAD_VIRTUAL_MEMORY_MAX			GetResString( IDS_COLHEAD_VIRTUAL_MEMORY_MAX )
#define COLHEAD_VIRTUAL_MEMORY_AVAILABLE	GetResString( IDS_COLHEAD_VIRTUAL_MEMORY_AVAILABLE )
#define COLHEAD_VIRTUAL_MEMORY_INUSE		GetResString( IDS_COLHEAD_VIRTUAL_MEMORY_INUSE )
#define COLHEAD_PAGEFILE_LOCATION			GetResString( IDS_COLHEAD_PAGEFILE_LOCATION )
#define COLHEAD_DOMAIN						GetResString( IDS_COLHEAD_DOMAIN )
#define COLHEAD_LOGON_SERVER				GetResString( IDS_COLHEAD_LOGON_SERVER )
#define COLHEAD_HOTFIX						GetResString( IDS_COLHEAD_HOTFIX )
#define COLHEAD_NETWORK_CARD				GetResString( IDS_COLHEAD_NETWORK_CARD )

// colwidths
#define COLWIDTH_HOSTNAME					AsLong( GetResString( IDS_COLWIDTH_HOSTNAME ), 10 )
#define COLWIDTH_OS_NAME					AsLong( GetResString( IDS_COLWIDTH_OS_NAME ), 10 )
#define COLWIDTH_OS_VERSION					AsLong( GetResString( IDS_COLWIDTH_OS_VERSION ), 10 )
#define COLWIDTH_OS_MANUFACTURER			AsLong( GetResString( IDS_COLWIDTH_OS_MANUFACTURER ), 10 )
#define COLWIDTH_OS_CONFIG					AsLong( GetResString( IDS_COLWIDTH_OS_CONFIG ), 10 )
#define COLWIDTH_OS_BUILDTYPE				AsLong( GetResString( IDS_COLWIDTH_OS_BUILDTYPE ), 10 )
#define COLWIDTH_REG_OWNER					AsLong( GetResString( IDS_COLWIDTH_REG_OWNER ), 10 )
#define COLWIDTH_REG_ORG					AsLong( GetResString( IDS_COLWIDTH_REG_ORG ), 10 )
#define COLWIDTH_PRODUCT_ID					AsLong( GetResString( IDS_COLWIDTH_PRODUCT_ID ), 10 )
#define COLWIDTH_INSTALL_DATE				AsLong( GetResString( IDS_COLWIDTH_INSTALL_DATE ), 10 )
#define COLWIDTH_SYSTEM_UPTIME				AsLong( GetResString( IDS_COLWIDTH_SYSTEM_UPTIME ), 10 )
#define COLWIDTH_SYSTEM_MANUFACTURER		AsLong( GetResString( IDS_COLWIDTH_SYSTEM_MANUFACTURER ), 10 )
#define COLWIDTH_SYSTEM_MODEL				AsLong( GetResString( IDS_COLWIDTH_SYSTEM_MODEL ), 10 )
#define COLWIDTH_SYSTEM_TYPE				AsLong( GetResString( IDS_COLWIDTH_SYSTEM_TYPE ), 10 )
#define COLWIDTH_PROCESSOR					AsLong( GetResString( IDS_COLWIDTH_PROCESSOR ), 10 )
#define COLWIDTH_BIOS_VERSION				AsLong( GetResString( IDS_COLWIDTH_BIOS_VERSION ), 10 )
#define COLWIDTH_WINDOWS_DIRECTORY			AsLong( GetResString( IDS_COLWIDTH_WINDOWS_DIRECTORY ), 10 )
#define COLWIDTH_SYSTEM_DIRECTORY			AsLong( GetResString( IDS_COLWIDTH_SYSTEM_DIRECTORY ), 10 )
#define COLWIDTH_BOOT_DEVICE				AsLong( GetResString( IDS_COLWIDTH_BOOT_DEVICE ), 10 )
#define COLWIDTH_SYSTEM_LOCALE				AsLong( GetResString( IDS_COLWIDTH_SYSTEM_LOCALE ), 10 )
#define COLWIDTH_INPUT_LOCALE				AsLong( GetResString( IDS_COLWIDTH_INPUT_LOCALE ), 10 )
#define COLWIDTH_TIME_ZONE					AsLong( GetResString( IDS_COLWIDTH_TIME_ZONE ), 10 )
#define COLWIDTH_TOTAL_PHYSICAL_MEMORY		AsLong( GetResString( IDS_COLWIDTH_TOTAL_PHYSICAL_MEMORY ), 10 )
#define COLWIDTH_AVAILABLE_PHYSICAL_MEMORY	AsLong( GetResString( IDS_COLWIDTH_AVAILABLE_PHYSICAL_MEMORY ), 10 )
#define COLWIDTH_VIRTUAL_MEMORY_MAX			AsLong( GetResString( IDS_COLWIDTH_VIRTUAL_MEMORY_MAX ), 10 )
#define COLWIDTH_VIRTUAL_MEMORY_AVAILABLE	AsLong( GetResString( IDS_COLWIDTH_VIRTUAL_MEMORY_AVAILABLE ), 10 )
#define COLWIDTH_VIRTUAL_MEMORY_INUSE		AsLong( GetResString( IDS_COLWIDTH_VIRTUAL_MEMORY_INUSE ), 10 )
#define COLWIDTH_PAGEFILE_LOCATION			AsLong( GetResString( IDS_COLWIDTH_PAGEFILE_LOCATION ), 10 )
#define COLWIDTH_DOMAIN						AsLong( GetResString( IDS_COLWIDTH_DOMAIN ), 10 )
#define COLWIDTH_LOGON_SERVER				AsLong( GetResString( IDS_COLWIDTH_LOGON_SERVER ), 10 )
#define COLWIDTH_HOTFIX						AsLong( GetResString( IDS_COLWIDTH_HOTFIX ), 10 )
#define COLWIDTH_NETWORK_CARD				AsLong( GetResString( IDS_COLWIDTH_NETWORK_CARD ), 10 )

// indexes
#define CI_HOSTNAME						0
#define CI_OS_NAME						1
#define CI_OS_VERSION					2
#define CI_OS_MANUFACTURER				3
#define CI_OS_CONFIG					4
#define CI_OS_BUILDTYPE					5
#define CI_REG_OWNER					6
#define CI_REG_ORG						7
#define CI_PRODUCT_ID					8
#define CI_INSTALL_DATE					9
#define CI_SYSTEM_UPTIME				10
#define CI_SYSTEM_MANUFACTURER			11
#define CI_SYSTEM_MODEL					12
#define CI_SYSTEM_TYPE					13
#define CI_PROCESSOR					14
#define CI_BIOS_VERSION					15
#define CI_WINDOWS_DIRECTORY			16
#define CI_SYSTEM_DIRECTORY				17
#define CI_BOOT_DEVICE					18
#define CI_SYSTEM_LOCALE				19
#define CI_INPUT_LOCALE					20
#define CI_TIME_ZONE					21
#define CI_TOTAL_PHYSICAL_MEMORY		22
#define CI_AVAILABLE_PHYSICAL_MEMORY	23
#define CI_VIRTUAL_MEMORY_MAX			24
#define CI_VIRTUAL_MEMORY_AVAILABLE		25
#define CI_VIRTUAL_MEMORY_INUSE			26
#define CI_PAGEFILE_LOCATION			27
#define CI_DOMAIN						28
#define CI_LOGON_SERVER					29
#define CI_HOTFIX						30
#define CI_NETWORK_CARD					31

// formats
#define FMT_OSVERSION			GetResString( IDS_FMT_OSVERSION )
#define FMT_KILOBYTES			GetResString( IDS_FMT_KILOBYTES )
#define FMT_MEGABYTES			GetResString( IDS_FMT_MEGABYTES )
#define FMT_PROCESSOR_TOTAL		GetResString( IDS_FMT_PROCESSOR_TOTAL )
#define FMT_PROCESSOR_INFO		GetResString( IDS_FMT_PROCESSOR_INFO )
#define FMT_UPTIME				GetResString( IDS_FMT_UPTIME )
#define FMT_HOTFIX_TOTAL		GetResString( IDS_FMT_HOTFIX_TOTAL )
#define FMT_HOTFIX_INFO			GetResString( IDS_FMT_HOTFIX_INFO )
#define FMT_NIC_TOTAL			GetResString( IDS_FMT_NIC_TOTAL )
#define FMT_NIC_INFO			GetResString( IDS_FMT_NIC_INFO )
#define FMT_NIC_STATUS			GetResString( IDS_FMT_NIC_STATUS )
#define FMT_DHCP_STATUS			GetResString( IDS_FMT_DHCP_STATUS )
#define FMT_DHCP_SERVER			GetResString( IDS_FMT_DHCP_SERVER )
#define FMT_IPADDRESS_TOTAL		GetResString( IDS_FMT_IPADDRESS_TOTAL )
#define FMT_IPADDRESS_INFO		GetResString( IDS_FMT_IPADDRESS_INFO )
#define FMT_CONNECTION			GetResString( IDS_FMT_CONNECTION )

// 
// Mapping information of Win32_ComputerSystem's DomainRole property
// NOTE: Refer to the _DSROLE_MACHINE_ROLE enumeration values in DsRole.h header file
#define VALUE_STANDALONEWORKSTATION			GetResString( IDS_VALUE_STANDALONEWORKSTATION )
#define VALUE_MEMBERWORKSTATION				GetResString( IDS_VALUE_MEMBERWORKSTATION )
#define VALUE_STANDALONESERVER				GetResString( IDS_VALUE_STANDALONESERVER )
#define VALUE_MEMBERSERVER					GetResString( IDS_VALUE_MEMBERSERVER )
#define VALUE_BACKUPDOMAINCONTROLLER		GetResString( IDS_VALUE_BACKUPDOMAINCONTROLLER )
#define VALUE_PRIMARYDOMAINCONTROLLER		GetResString( IDS_VALUE_PRIMARYDOMAINCONTROLLER )

// netcard status mapping
#define VALUE_DISCONNECTED					GetResString( IDS_VALUE_DISCONNECTED )
#define VALUE_CONNECTING					GetResString( IDS_VALUE_CONNECTING )
#define VALUE_CONNECTED						GetResString( IDS_VALUE_CONNECTED )
#define VALUE_DISCONNECTING					GetResString( IDS_VALUE_DISCONNECTING )
#define VALUE_HWNOTPRESENT					GetResString( IDS_VALUE_HWNOTPRESENT )
#define VALUE_HWDISABLED					GetResString( IDS_VALUE_HWDISABLED )
#define VALUE_HWMALFUNCTION					GetResString( IDS_VALUE_HWMALFUNCTION )
#define VALUE_MEDIADISCONNECTED				GetResString( IDS_VALUE_MEDIADISCONNECTED )
#define VALUE_AUTHENTICATING				GetResString( IDS_VALUE_AUTHENTICATING )
#define VALUE_AUTHSUCCEEDED					GetResString( IDS_VALUE_AUTHSUCCEEDED )
#define VALUE_AUTHFAILED					GetResString( IDS_VALUE_AUTHFAILED )

#define VALUE_YES							GetResString( IDS_VALUE_YES )
#define VALUE_NO							GetResString( IDS_VALUE_NO )

// status messages
#define MSG_OSINFO							GetResString( IDS_MSG_OSINFO )
#define MSG_COMPINFO						GetResString( IDS_MSG_COMPINFO )
#define MSG_PERFINFO						GetResString( IDS_MSG_PERFINFO )
#define MSG_PROCESSORINFO					GetResString( IDS_MSG_PROCESSORINFO	)
#define MSG_BIOSINFO						GetResString( IDS_MSG_BIOSINFO )
#define MSG_INPUTLOCALEINFO					GetResString( IDS_MSG_INPUTLOCALEINFO )
#define MSG_TZINFO							GetResString( IDS_MSG_TZINFO )
#define MSG_PAGEFILEINFO					GetResString( IDS_MSG_PAGEFILEINFO )
#define MSG_HOTFIXINFO						GetResString( IDS_MSG_HOTFIXINFO )
#define MSG_NICINFO							GetResString( IDS_MSG_NICINFO )
#define MSG_PROFILEINFO						GetResString( IDS_MSG_PROFILEINFO )

//
// command line options

// command line options and their indexes in the array
#define MAX_OPTIONS			6

// options allowed ( no need to localize )
#define OPTION_USAGE		_T( "?" )
#define OPTION_SERVER		_T( "s" )
#define OPTION_USERNAME		_T( "u" )
#define OPTION_PASSWORD		_T( "p" )
#define OPTION_FORMAT		_T( "fo" )
#define OPTION_NOHEADER		_T( "nh" )

// option indexes
#define OI_USAGE					0
#define OI_SERVER					1
#define OI_USERNAME					2
#define OI_PASSWORD					3
#define OI_FORMAT					4
#define OI_NOHEADER					5

// values allowed for format
#define OVALUES_FORMAT			GetResString( IDS_OVALUES_FORMAT )

//
// CSystemInfo
//
class CSystemInfo
{
// constructor / destructor
public:
	CSystemInfo();
	~CSystemInfo();

// data members
private:

	// command line options
	CHString m_strServer;
	CHString m_strUserName;
	CHString m_strPassword;

	// WMI interfaces
	IWbemLocator* m_pWbemLocator;
	IWbemServices* m_pWbemServices;

	// progress message related
	HANDLE m_hOutput;
	CONSOLE_SCREEN_BUFFER_INFO m_csbi;

	// other(s)
	TARRAY m_arrData;					// output data storage
	PTCOLUMNS m_pColumns;				// output columns information
	BOOL m_bNeedPassword;				// indicates whether password needs to be accepted or not
	BOOL m_bCloseConnection;			// indicate whether closeconnection function to be called or not
	CHString m_strLogonUser;			// used to find the logon server
	COAUTHIDENTITY* m_pAuthIdentity;	// auth identity

public:
	BOOL m_bUsage;
	DWORD m_dwFormat;

// methods
private:
	BOOL LoadOSInfo();
	BOOL LoadBiosInfo();
	BOOL LoadHotfixInfo();
	BOOL LoadProfileInfo();
	BOOL LoadComputerInfo();
	BOOL LoadTimeZoneInfo();
	BOOL LoadPageFileInfo();
	BOOL LoadKeyboardInfo();
	BOOL LoadProcessorInfo();
	BOOL LoadPerformanceInfo();
	BOOL LoadNetworkCardInfo();
	
	// output related ...
	BOOL AllocateColumns();

public:
	BOOL LoadData();
	BOOL Initialize();
	BOOL ProcessOptions( DWORD argc, LPCTSTR argv[] );
	BOOL Connect();

	VOID ShowUsage();
	VOID ShowOutput( DWORD dwStart = 0, DWORD dwEnd = MAX_COLUMNS );
};

#endif	// __SYSTEMINFO_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cmdline\tasklist\init.cpp ===
// *********************************************************************************
// 
//  Copyright (c) Microsoft Corporation
//  
//  Module Name:
//  
//		Init.cpp
//  
//  Abstract:
//  
// 		This module implements the general initialization stuff
//
//  Author:
//  
// 		Sunil G.V.N. Murali (murali.sunil@wipro.com) 24-Nov-2000
//  
//  Revision History:
//  
// 		Sunil G.V.N. Murali (murali.sunil@wipro.com) 24-Nov-2000 : Created It.
//  
// *********************************************************************************

#include "pch.h"
#include "wmi.h"
#include "tasklist.h"

//
// macros
//
#define RELEASE_MEMORY( block )	\
	if ( (block) != NULL )	\
	{	\
		delete (block);	\
		(block) = NULL;	\
	}	\
	1

#define RELEASE_MEMORY_EX( block )	\
	if ( (block) != NULL )	\
	{	\
		delete [] (block);	\
		(block) = NULL;	\
	}	\
	1

#define DESTROY_ARRAY( array )	\
	if ( (array) != NULL )	\
	{	\
		DestroyDynamicArray( &(array) );	\
		(array) = NULL;	\
	}	\
	1

// ***************************************************************************
// Routine Description:
//		CTaskList contructor
//		  
// Arguments:
//		NONE
//  
// Return Value:
//		NONE
// 
// ***************************************************************************
CTaskList::CTaskList()
{
	// init to defaults
	m_pWbemLocator = NULL;
	m_pEnumObjects = NULL;
	m_pWbemServices = NULL;
	m_pAuthIdentity = NULL;
	m_bVerbose = FALSE;
	m_bAllServices = FALSE;
	m_bAllModules = FALSE;
	m_dwFormat = 0;
	m_arrFilters = NULL;
	m_bNeedPassword = FALSE;
	m_bNeedModulesInfo = FALSE;
	m_bNeedServicesInfo = FALSE;
	m_bNeedWindowTitles = FALSE;
	m_bNeedUserContextInfo = FALSE;
	m_bLocalSystem = FALSE;
	m_pColumns = NULL;
	m_arrFiltersEx = NULL;
	m_arrWindowTitles = NULL;
	m_pfilterConfigs = NULL;
	m_dwGroupSep = 0;
	m_arrTasks = NULL;
	m_dwProcessId = 0;
	m_bIsHydra = FALSE;
	m_hServer = NULL;
	m_hWinstaLib = NULL;
	m_pProcessInfo = NULL;
	m_ulNumberOfProcesses = 0;
	m_bCloseConnection = FALSE;
	m_dwServicesCount = 0;
	m_pServicesInfo = NULL;
	m_pdb = NULL;
	m_bUseRemote = FALSE;
	m_pfnWinStationFreeMemory = NULL;
	m_pfnWinStationOpenServerW = NULL;
	m_pfnWinStationCloseServer = NULL;
	m_pfnWinStationFreeGAPMemory = NULL;
	m_pfnWinStationGetAllProcesses = NULL;
	m_pfnWinStationNameFromLogonIdW = NULL;
	m_pfnWinStationEnumerateProcesses = NULL;
	m_bUsage = FALSE;
	m_bLocalSystem = TRUE;
	m_hOutput = NULL;
}

// ***************************************************************************
// Routine Description:
//		CTaskList destructor
//		  
// Arguments:
//		NONE
//  
// Return Value:
//		NONE
// 
// ***************************************************************************
CTaskList::~CTaskList()
{
	//
	// de-allocate memory allocations
	//

	//
	// destroy dynamic arrays
	DESTROY_ARRAY( m_arrTasks );
	DESTROY_ARRAY( m_arrFilters );
	DESTROY_ARRAY( m_arrFiltersEx );
	DESTROY_ARRAY( m_arrWindowTitles );

	//
	// memory ( with new operator )
	// NOTE: should not free m_pszWindowStation and m_pszDesktop 
	RELEASE_MEMORY_EX( m_pColumns );
	RELEASE_MEMORY_EX( m_pfilterConfigs );

	//
	// release WMI / COM interfaces
	SAFE_RELEASE( m_pWbemLocator );
	SAFE_RELEASE( m_pWbemServices );
	SAFE_RELEASE( m_pEnumObjects );

	// free authentication identity structure
	// release the existing auth identity structure
	WbemFreeAuthIdentity( &m_pAuthIdentity );

	// close the connection to the remote machine
	if ( m_bCloseConnection == TRUE )
		CloseConnection( m_strUNCServer );

	// free the memory allocated for services variables
	__free( m_pServicesInfo );

	// free the memory allocated for performance block
	if ( m_pdb != NULL )
	{
		HeapFree( GetProcessHeap(), 0, m_pdb );
		m_pdb = NULL;
	}

	//
	// free winstation block
	if ( m_bIsHydra == FALSE && m_pProcessInfo != NULL )
	{
		// free the GAP memory block
		WinStationFreeGAPMemory( GAP_LEVEL_BASIC, 
			(PTS_ALL_PROCESSES_INFO) m_pProcessInfo, m_ulNumberOfProcesses );
		
		// ...
		m_pProcessInfo = NULL;
	}
	else if ( m_bIsHydra == TRUE && m_pProcessInfo != NULL )
	{
		// free the winsta memory block
		WinStationFreeMemory( m_pProcessInfo );
		m_pProcessInfo = NULL;
	}

	// close the connection window station if needed
	if ( m_hServer != NULL )
		WinStationCloseServer( m_hServer );

	// free the library
	if ( m_hWinstaLib != NULL )
	{
		FreeLibrary( m_hWinstaLib );
		m_hWinstaLib = NULL;
		m_pfnWinStationFreeMemory = NULL;
		m_pfnWinStationOpenServerW = NULL;
		m_pfnWinStationCloseServer = NULL;
		m_pfnWinStationFreeGAPMemory = NULL;
		m_pfnWinStationGetAllProcesses = NULL;
		m_pfnWinStationEnumerateProcesses = NULL;
	}

	// un-initialize the COM library
	CoUninitialize();
}

// ***************************************************************************
// Routine Description:
//		initialize the task list utility
//		  
// Arguments:
//		NONE
//  
// Return Value:
//		TRUE	: if filters are appropriately specified
//		FALSE	: if filters are errorneously specified
// 
// ***************************************************************************
BOOL CTaskList::Initialize()
{
	// local variables
	CHString str;
	LONG lTemp = 0;

	//
	// memory allocations

	// if at all any occurs, we know that is 'coz of the 
	// failure in memory allocation ... so set the error
	SetLastError( E_OUTOFMEMORY );
	SaveLastError();

	// filters ( user supplied )
	if ( m_arrFilters == NULL )
	{
		m_arrFilters = CreateDynamicArray();
		if ( m_arrFilters == NULL )
			return FALSE;
	}

	// filters ( program generated parsed filters )
	if ( m_arrFiltersEx == NULL )
	{
		m_arrFiltersEx = CreateDynamicArray();
		if ( m_arrFiltersEx == NULL )
			return FALSE;
	}

	// columns configuration info
	if ( m_pColumns == NULL )
	{
		m_pColumns = new TCOLUMNS [ MAX_COLUMNS ];
		if ( m_pColumns == NULL )
			return FALSE;

		// init to ZERO's
		ZeroMemory( m_pColumns, MAX_COLUMNS * sizeof( TCOLUMNS ) );
	}

	// filters configuration info
	if ( m_pfilterConfigs == NULL )
	{
		m_pfilterConfigs = new TFILTERCONFIG[ MAX_FILTERS ];
		if ( m_pfilterConfigs == NULL )
			return FALSE;

		// init to ZERO's
		ZeroMemory( m_pfilterConfigs, MAX_FILTERS * sizeof( TFILTERCONFIG ) );
	}

	// window titles
	if ( m_arrWindowTitles == NULL )
	{
		m_arrWindowTitles = CreateDynamicArray();
		if ( m_arrWindowTitles == NULL )
			return FALSE;
	}

	// tasks
	if ( m_arrTasks == NULL )
	{
		m_arrTasks = CreateDynamicArray();
		if ( m_arrTasks == NULL )
			return FALSE;
	}

	// initialize the COM library
	if ( InitializeCom( &m_pWbemLocator ) == FALSE )
		return FALSE;
	
	//
	// get the locale specific information
	//

	try
	{
		// sub-local variables
		LPWSTR pwszTemp = NULL;

		//
		// get the time seperator character
		lTemp = GetLocaleInfo( LOCALE_USER_DEFAULT, LOCALE_STIME, NULL, 0 );
		if ( lTemp == 0 )
		{
			// set the default seperator
			pwszTemp = m_strTimeSep.GetBufferSetLength( 2 );
			ZeroMemory( pwszTemp, 2 * sizeof( WCHAR ) );
			lstrcpy( pwszTemp, _T( ":" ) );
		}
		else
		{
			// get the time field seperator
			pwszTemp = m_strTimeSep.GetBufferSetLength( lTemp + 2 );
			ZeroMemory( pwszTemp, ( lTemp + 2 ) * sizeof( WCHAR ) );
			GetLocaleInfo( LOCALE_USER_DEFAULT, LOCALE_STIME, pwszTemp, lTemp );
		}

		//
		// get the group seperator character
		lTemp = GetLocaleInfo( LOCALE_USER_DEFAULT, LOCALE_SGROUPING, NULL, 0 );
		if ( lTemp == 0 )
		{
			// we don't know how to resolve this
			return FALSE;
		}
		else
		{
			// get the group seperation character
			pwszTemp = str.GetBufferSetLength( lTemp + 2 );
			ZeroMemory( pwszTemp, ( lTemp + 2 ) * sizeof( WCHAR ) );
			GetLocaleInfo( LOCALE_USER_DEFAULT, LOCALE_SGROUPING, pwszTemp, lTemp );

			// change the group info into appropriate number
			lTemp = 0;
			m_dwGroupSep = 0;
			while ( lTemp < str.GetLength() )
			{
				if ( AsLong( str.Mid( lTemp, 1 ), 10 ) != 0 )
					m_dwGroupSep = m_dwGroupSep * 10 + AsLong( str.Mid( lTemp, 1 ), 10 );

				// increment by 2
				lTemp += 2;
			}
		}

		//
		// get the thousand seperator character
		lTemp = GetLocaleInfo( LOCALE_USER_DEFAULT, LOCALE_STHOUSAND, NULL, 0 );
		if ( lTemp == 0 )
		{
			// we don't know how to resolve this
			return FALSE;
		}
		else
		{
			// get the thousand sepeartion charactor
			pwszTemp = m_strGroupThousSep.GetBufferSetLength( lTemp + 2 );
			ZeroMemory( pwszTemp, ( lTemp + 2 ) * sizeof( WCHAR ) );
			GetLocaleInfo( LOCALE_USER_DEFAULT, LOCALE_STHOUSAND, pwszTemp, lTemp );
		}

		// release the CHStrig buffers
		str.ReleaseBuffer();
		m_strTimeSep.ReleaseBuffer();
		m_strGroupThousSep.ReleaseBuffer();
	}
	catch( ... )
	{
		// out of memory
		return FALSE;
	}

	//
	// load the winsta library and needed functions
	// NOTE: do not raise any error if loading of winsta dll fails
	m_hWinstaLib = ::LoadLibrary( WINSTA_DLLNAME );
	if ( m_hWinstaLib != NULL )
	{
		// library loaded successfully ... now load the addresses of functions
		m_pfnWinStationFreeMemory = (FUNC_WinStationFreeMemory) ::GetProcAddress( m_hWinstaLib, FUNCNAME_WinStationFreeMemory );
		m_pfnWinStationCloseServer = (FUNC_WinStationCloseServer) ::GetProcAddress( m_hWinstaLib, FUNCNAME_WinStationCloseServer );
		m_pfnWinStationOpenServerW = (FUNC_WinStationOpenServerW) ::GetProcAddress( m_hWinstaLib, FUNCNAME_WinStationOpenServerW );
		m_pfnWinStationFreeGAPMemory = (FUNC_WinStationFreeGAPMemory) ::GetProcAddress( m_hWinstaLib, FUNCNAME_WinStationFreeGAPMemory );
		m_pfnWinStationGetAllProcesses = (FUNC_WinStationGetAllProcesses) ::GetProcAddress( m_hWinstaLib, FUNCNAME_WinStationGetAllProcesses );
		m_pfnWinStationNameFromLogonIdW = (FUNC_WinStationNameFromLogonIdW) ::GetProcAddress( m_hWinstaLib, FUNCNAME_WinStationNameFromLogonIdW );
		m_pfnWinStationEnumerateProcesses = (FUNC_WinStationEnumerateProcesses) ::GetProcAddress( m_hWinstaLib, FUNCNAME_WinStationEnumerateProcesses );

		// we will keep the library loaded in memory only if all the functions were loaded successfully
		if ( m_pfnWinStationFreeMemory == NULL || 
			 m_pfnWinStationCloseServer == NULL || m_pfnWinStationOpenServerW == NULL || 
			 m_pfnWinStationFreeGAPMemory == NULL || m_pfnWinStationGetAllProcesses == NULL || 
			 m_pfnWinStationEnumerateProcesses == NULL || m_pfnWinStationNameFromLogonIdW == NULL )

		{
			// some (or) all of the functions were not loaded ... unload the library
			FreeLibrary( m_hWinstaLib );
			m_hWinstaLib = NULL;
			m_pfnWinStationFreeMemory = NULL;
			m_pfnWinStationOpenServerW = NULL;
			m_pfnWinStationCloseServer = NULL;
			m_pfnWinStationFreeGAPMemory = NULL;
			m_pfnWinStationGetAllProcesses = NULL;
			m_pfnWinStationNameFromLogonIdW = NULL;
			m_pfnWinStationEnumerateProcesses = NULL;
		}
	}

	//
	// init the console scree buffer structure to zero's
	// and then get the console handle and screen buffer information
	//
	// prepare for status display.
	// for this get a handle to the screen output buffer
	// but this handle will be null if the output is being redirected. so do not check 
	// for the validity of the handle. instead try to get the console buffer information
	// only in case you have a valid handle to the output screen buffer
	ZeroMemory( &m_csbi, sizeof( CONSOLE_SCREEN_BUFFER_INFO ) );
	m_hOutput = GetStdHandle( STD_ERROR_HANDLE );
	if ( m_hOutput != NULL )
		GetConsoleScreenBufferInfo( m_hOutput, &m_csbi );

	// enable debug privelages
	EnableDebugPriv();

	// initialization is successful
	SetLastError( NOERROR );			// clear the error
	SetReason( NULL_STRING );			// clear the reason
	return TRUE;
}

// ***************************************************************************
// Routine Description:
//		Enables the debug privliges for the current process so that
//		this utility can terminate the processes on local system without any problem
//		  
// Arguments:
//		NONE
//
// Return Value:
//		TRUE upon successfull and FALSE if failed
//
// ***************************************************************************
BOOL CTaskList::EnableDebugPriv()
{
	// local variables
    LUID luidValue;
	BOOL bResult = FALSE;
    HANDLE hToken = NULL;
    TOKEN_PRIVILEGES tkp;

    // Retrieve a handle of the access token
	bResult = OpenProcessToken( GetCurrentProcess(), 
		TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken );
    if ( bResult == FALSE ) 
	{
		// save the error messaage and return
        SaveLastError();
        return FALSE;
    }

    // Enable the SE_DEBUG_NAME privilege or disable
    // all privileges, depends on this flag.
	bResult = LookupPrivilegeValue( NULL, SE_DEBUG_NAME, &luidValue );
    if ( bResult == FALSE ) 
	{
		// save the error messaage and return
        SaveLastError();
		CloseHandle( hToken );
        return FALSE;
    }

	// prepare the token privileges structure
	tkp.PrivilegeCount = 1;
    tkp.Privileges[ 0 ].Luid = luidValue;
    tkp.Privileges[ 0 ].Attributes = SE_PRIVILEGE_ENABLED;

	// now enable the debug privileges in the token
	bResult = AdjustTokenPrivileges( hToken, FALSE, &tkp, sizeof( TOKEN_PRIVILEGES ),
		( PTOKEN_PRIVILEGES ) NULL, ( PDWORD ) NULL );
    if ( bResult == FALSE )
	{
        // The return value of AdjustTokenPrivileges be texted
        SaveLastError();
		CloseHandle( hToken );
        return FALSE;
    }

	// close the opened token handle
	CloseHandle( hToken );

	// enabled ... inform success
    return TRUE;
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
BOOLEAN CTaskList::WinStationFreeMemory( PVOID pBuffer )
{
	// check the buffer and act
	if ( pBuffer == NULL )
		return TRUE;

	// check whether pointer exists or not
	if ( m_pfnWinStationFreeMemory == NULL )
		return FALSE;

	// call and return the same
	return ((FUNC_WinStationFreeMemory) m_pfnWinStationFreeMemory)( pBuffer );
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
BOOLEAN CTaskList::WinStationCloseServer( HANDLE hServer )
{
	// check the input
	if ( hServer == NULL )
		return TRUE;

	// check whether the function pointer exists or not
	if ( m_pfnWinStationCloseServer == NULL )
		return FALSE;

	// call and return
	return ((FUNC_WinStationCloseServer) m_pfnWinStationCloseServer)( hServer );
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
HANDLE CTaskList::WinStationOpenServerW( LPWSTR pwszServerName )
{
	// check the input & also check whether function pointer exists or not
	if ( pwszServerName == NULL || m_pfnWinStationOpenServerW == NULL )
		return NULL;

	// call and return
	return ((FUNC_WinStationOpenServerW) m_pfnWinStationOpenServerW)( pwszServerName );
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
BOOLEAN CTaskList::WinStationEnumerateProcesses( HANDLE hServer, PVOID* ppProcessBuffer )
{
	// check the input and also check whether function pointer exists or not
	if ( ppProcessBuffer == NULL || m_pfnWinStationEnumerateProcesses == NULL )
		return FALSE;

	// call and return
	return ((FUNC_WinStationEnumerateProcesses) 
		m_pfnWinStationEnumerateProcesses)( hServer, ppProcessBuffer );
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
BOOLEAN CTaskList::WinStationFreeGAPMemory( ULONG ulLevel, PVOID pProcessArray, ULONG ulCount )
{
	// check the input
	if ( pProcessArray == NULL )
		return TRUE;

	// check whether function pointer exists or not
	if ( m_pfnWinStationFreeGAPMemory == NULL )
		return FALSE;

	// call and return
	return ((FUNC_WinStationFreeGAPMemory) 
		m_pfnWinStationFreeGAPMemory)( ulLevel, pProcessArray, ulCount );
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
BOOLEAN CTaskList::WinStationGetAllProcesses( HANDLE hServer, ULONG ulLevel, 
 											  ULONG* pNumberOfProcesses, PVOID* ppProcessArray )
{
	// check the input & check whether function pointer exists or not
	if (pNumberOfProcesses == NULL || ppProcessArray == NULL || m_pfnWinStationGetAllProcesses == NULL)
		return FALSE;

	return ((FUNC_WinStationGetAllProcesses) 
		m_pfnWinStationGetAllProcesses)( hServer, ulLevel, pNumberOfProcesses, ppProcessArray );
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
BOOLEAN CTaskList::WinStationNameFromLogonIdW( HANDLE hServer, ULONG ulLogonId, LPWSTR pwszWinStationName )
{
	// check the input & check whether function pointer exists or not
	if (pwszWinStationName == NULL || m_pfnWinStationNameFromLogonIdW == NULL)
		return FALSE;

	return ((FUNC_WinStationNameFromLogonIdW) 
		m_pfnWinStationNameFromLogonIdW)( hServer, ulLogonId, pwszWinStationName );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cmdline\tasklist\wmi.h ===
// *********************************************************************************
// 
//  Copyright (c) Microsoft Corporation
//  
//  Module Name:
//
//		WMI.h  
//  
//  Abstract:
//  
// 		Common functionality for WMI
//
//  Author:
//  
// 	    Sunil G.V.N. Murali (murali.sunil@wipro.com) 22-Dec-2000
//  
//  Revision History:
//  
// 	    Sunil G.V.N. Murali (murali.sunil@wipro.com) 22-Dec-2000 : Created It.
//  
// *********************************************************************************

#ifndef __WMI_H
#define __WMI_H

//
// macros
//
#define SAFE_RELEASE( interfacepointer )	\
	if ( (interfacepointer) != NULL )	\
	{	\
		(interfacepointer)->Release();	\
		(interfacepointer) = NULL;	\
	}	\
	1

#define SAFE_EXECUTE( statement )				\
	hr = statement;		\
	if ( FAILED( hr ) )	\
	{	\
		_com_issue_error( hr );	\
	}	\
	1

//
// define(s) / enumerators / constants
//
#define WMI_NAMESPACE_CIMV2		L"root\\cimv2"
#define WMI_NAMESPACE_DEFAULT	L"root\\default"

#define WMI_CLAUSE_AND			L"AND"
#define WMI_CLAUSE_OR			L"OR"
#define WMI_CLAUSE_WHERE		L"WHERE"

#define CLASS_CIMV2_Win32_OperatingSystem	L"Win32_OperatingSystem"
#define CLASS_CIMV2_Win32_ComputerSystem	L"Win32_ComputerSystem"

#define WMI_REGISTRY					L"StdRegProv"
#define WMI_REGISTRY_M_STRINGVALUE		L"GetStringValue"

#define WMI_REGISTRY_IN_HDEFKEY			L"hDefKey"
#define WMI_REGISTRY_IN_SUBKEY			L"sSubKeyName"
#define WMI_REGISTRY_IN_VALUENAME		L"sValueName"
#define WMI_REGISTRY_OUT_VALUE			L"sValue"
#define WMI_REGISTRY_OUT_RETURNVALUE	L"ReturnValue"

#define WMI_HKEY_CLASSES_ROOT				2147483648 
#define WMI_HKEY_CURRENT_USER				2147483649
#define WMI_HKEY_LOCAL_MACHINE				2147483650
#define WMI_HKEY_USERS						2147483651
#define WMI_HKEY_CURRENT_CONFIG				2147482652

#define PLATFORM_UNKNOWN				0
#define PLATFORM_X86					1
#define PLATFORM_IA64					2
#define PLATFORM_AMD64					3

#define TEXT_X86						L"X86"
#define TEXT_IA64						L"IA64"
#define TEXT_AMD64						L"AMD64"

// messages
// #define ERROR_COM_ERROR					GetResString( IDS_ERROR_COM_ERROR )

//
// function prototype(s)
//
BOOL InitializeCom( IWbemLocator** ppLocator );
BOOL ConnectWmi( IWbemLocator* pLocator, 
				 IWbemServices** ppServices, 
				 LPCWSTR pwszServer, LPCWSTR pwszUser, LPCWSTR pwszPassword, 
				 COAUTHIDENTITY** ppAuthIdentity, 
				 BOOL bCheckWithNullPwd = FALSE, 
				 LPCWSTR pwszNamespace = WMI_NAMESPACE_CIMV2, 
				 HRESULT* phr = NULL, BOOL* pbLocalSystem = NULL );
BOOL ConnectWmiEx( IWbemLocator* pLocator, 
				   IWbemServices** ppServices, 
				   LPCWSTR pwszServer, CHString& strUserName, CHString& strPassword, 
				   COAUTHIDENTITY** ppAuthIdentity, BOOL bNeedPassword = FALSE, 
				   LPCWSTR pszNamespace = WMI_NAMESPACE_CIMV2, BOOL* pbLocalSystem = NULL );
BOOL IsValidServerEx( LPCWSTR pwszServer, BOOL& bLocalSystem );
HRESULT SetInterfaceSecurity( IUnknown* pInterface, COAUTHIDENTITY* pAuthIdentity );
VOID WINAPI WbemFreeAuthIdentity( COAUTHIDENTITY** ppAuthIdentity );
VOID WMISaveError( HRESULT hrError );
HRESULT PropertyGet( IWbemClassObject* pWmiObject, 
					 LPCWSTR pwszProperty, _variant_t& varValue );
BOOL PropertyGet( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty, 
				  CHString& strValue, LPCWSTR pwszDefault = V_NOT_AVAILABLE );
BOOL PropertyGet( IWbemClassObject* pWmiObject, 
				  LPCWSTR pwszProperty,  DWORD& dwValue, DWORD dwDefault = 0 );
BOOL PropertyGet( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty,  ULONGLONG& ullValue );
BOOL PropertyGet( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty,  WBEMTime& wbemtime );
BOOL PropertyGet( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty,  SYSTEMTIME& systime );
BOOL PropertyGet( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty, TARRAY arr );
HRESULT PropertyPut( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty, DWORD dwValue );
HRESULT PropertyPut( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty, LPCWSTR pwszValue );
HRESULT PropertyPut( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty, _variant_t& varValue );
DWORD GetTargetVersionEx( IWbemServices* pWbemServices, COAUTHIDENTITY* pAuthIdentity );
DWORD GetTargetPlatformEx( IWbemServices* pWbemServices, COAUTHIDENTITY* pAuthIdentity );
BOOL RegQueryValueWMI( IWbemServices* pWbemServices, DWORD dwHDefKey, 
					   LPCWSTR pwszSubKeyName, LPCWSTR pwszValueName, 
					   CHString& strValue, LPCWSTR pwszDefault = V_NOT_AVAILABLE );

//
// inline functions
//

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
inline VOID WMISaveError( _com_error& e )
{
	WMISaveError( e.Error() );
}

#endif // __WMI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cmdline\tasklist\parse.cpp ===
// *********************************************************************************
// 
//  Copyright (c) Microsoft Corporation
//  
//  Module Name:
//  
//		parse.cpp
//  
//  Abstract:
//  
// 		This module implements the command-line parsing and validating the filters
//  
//  Author:
//  
// 		Sunil G.V.N. Murali (murali.sunil@wipro.com) 24-Nov-2000
//  
//  Revision History:
//  
// 		Sunil G.V.N. Murali (murali.sunil@wipro.com) 24-Nov-2000 : Created It.
//  
// *********************************************************************************

#include "pch.h"
#include "tasklist.h"

//
// local function prototypes
//
BOOL TimeFieldsToElapsedTime( LPCWSTR pwszTime, LPCWSTR pwszToken, ULONG& ulElapsedTime );
DWORD FilterUserName( LPCWSTR pwszProperty, LPCWSTR pwszOperator, 
				      LPCWSTR pwszValue, LPVOID pData, TARRAY arrRow );
DWORD FilterCPUTime( LPCWSTR pwszProperty, LPCWSTR pwszOperator, 
				    LPCWSTR pwszValue, LPVOID pData, TARRAY arrRow );

// ***************************************************************************
// Routine Description:
//		processes and validates the command line inputs
//		  
// Arguments:
//		[ in ] argc			 : no. of input arguments specified
//		[ in ] argv			 : input arguments specified at command prompt
//  
// Return Value:
//		TRUE  : if inputs are valid
//		FALSE : if inputs were errorneously specified
// 
// ***************************************************************************
BOOL CTaskList::ProcessOptions( DWORD argc, LPCTSTR argv[] )
{
	// local variables
	BOOL bNoHeader = FALSE;
	PTCMDPARSER pcmdOptions = NULL;
	__STRING_64 szFormat = NULL_STRING;

	// temporary local variables
	LPWSTR pwszModules = NULL;
	LPWSTR pwszServer = NULL;
	LPWSTR pwszUserName = NULL;
	LPWSTR pwszPassword = NULL;
	PTCMDPARSER pOption = NULL;
	PTCMDPARSER pOptionServer = NULL;
	PTCMDPARSER pOptionUserName = NULL;
	PTCMDPARSER pOptionPassword = NULL;

	//
	// prepare the command options
	pcmdOptions = new TCMDPARSER[ MAX_OPTIONS ];
	if ( pcmdOptions == NULL )
	{
		SetLastError( E_OUTOFMEMORY );
		SaveLastError();
		return FALSE;
	}

	try
	{
		// get the memory
		pwszModules = m_strModules.GetBufferSetLength( MAX_STRING_LENGTH );
		pwszServer = m_strServer.GetBufferSetLength( MAX_STRING_LENGTH );
		pwszUserName = m_strUserName.GetBufferSetLength( MAX_STRING_LENGTH );
		pwszPassword = m_strPassword.GetBufferSetLength( MAX_STRING_LENGTH );

		// init to NULL's
		ZeroMemory( pwszModules, sizeof( WCHAR ) * MAX_STRING_LENGTH );
		ZeroMemory( pwszServer, sizeof( WCHAR ) * MAX_STRING_LENGTH );
		ZeroMemory( pwszUserName, sizeof( WCHAR ) * MAX_STRING_LENGTH );
		ZeroMemory( pwszPassword, sizeof( WCHAR ) * MAX_STRING_LENGTH );

		// init the password contents with '*'
		lstrcpy( pwszPassword, L"*" );
	}
	catch( ... )
	{
		SetLastError( E_OUTOFMEMORY );
		SaveLastError();
		return FALSE;
	}

	// initialize to ZERO's
	ZeroMemory( pcmdOptions, MAX_OPTIONS * sizeof( TCMDPARSER ) );

	// -?
	pOption = pcmdOptions + OI_USAGE;
	pOption->dwCount = 1;
	pOption->dwActuals = 0;
	pOption->dwFlags = CP_USAGE;
	pOption->pValue = &m_bUsage;
	pOption->pFunction = NULL;
	pOption->pFunctionData = NULL;
	lstrcpy( pOption->szValues, NULL_STRING );
	lstrcpy( pOption->szOption, OPTION_USAGE );

	// -s
	pOption = pcmdOptions + OI_SERVER;
	pOption->dwCount = 1;
	pOption->dwActuals = 0;
	pOption->dwFlags = 	CP_TYPE_TEXT | CP_VALUE_MANDATORY;
	pOption->pValue = pwszServer;
	pOption->pFunction = NULL;
	pOption->pFunctionData = NULL;
	lstrcpy( pOption->szValues, NULL_STRING );
	lstrcpy( pOption->szOption, OPTION_SERVER );

	// -u
	pOption = pcmdOptions + OI_USERNAME;
	pOption->dwCount = 1;
	pOption->dwActuals = 0;
	pOption->dwFlags = CP_TYPE_TEXT | CP_VALUE_MANDATORY;
	pOption->pValue = pwszUserName;
	pOption->pFunction = NULL;
	pOption->pFunctionData = NULL;
	lstrcpy( pOption->szValues, NULL_STRING );
	lstrcpy( pOption->szOption, OPTION_USERNAME );

	// -p
	pOption = pcmdOptions + OI_PASSWORD;
	pOption->dwCount = 1;
	pOption->dwActuals = 0;
	pOption->dwFlags = CP_TYPE_TEXT | CP_VALUE_OPTIONAL;
	pOption->pValue = pwszPassword;
	pOption->pFunction = NULL;
	pOption->pFunctionData = NULL;
	lstrcpy( pOption->szValues, NULL_STRING );
	lstrcpy( pOption->szOption, OPTION_PASSWORD );

	// -fi
	pOption = pcmdOptions + OI_FILTER;
	pOption->dwCount = 0;
	pOption->dwActuals = 0;
	pOption->dwFlags = CP_TYPE_TEXT | CP_VALUE_MANDATORY | CP_MODE_ARRAY;
	pOption->pValue = &m_arrFilters;
	pOption->pFunction = NULL;
	pOption->pFunctionData = NULL;
	lstrcpy( pOption->szValues, NULL_STRING );
	lstrcpy( pOption->szOption, OPTION_FILTER );

	// -fo
	pOption = pcmdOptions + OI_FORMAT;
	pOption->dwCount = 1;
	pOption->dwActuals = 0;
	pOption->dwFlags = CP_TYPE_TEXT | CP_VALUE_MANDATORY | CP_MODE_VALUES;
	pOption->pValue = &szFormat;
	pOption->pFunction = NULL;
	pOption->pFunctionData = NULL;
	lstrcpy( pOption->szValues, OVALUES_FORMAT );
	lstrcpy( pOption->szOption, OPTION_FORMAT );

	// -nh
	pOption = pcmdOptions + OI_NOHEADER;
	pOption->dwCount = 1;
	pOption->dwActuals = 0;
	pOption->dwFlags = 0;
	pOption->pValue = &bNoHeader;
	pOption->pFunction = NULL;
	pOption->pFunctionData = NULL;
	lstrcpy( pOption->szValues, NULL_STRING );
	lstrcpy( pOption->szOption, OPTION_NOHEADER );

	// -v
	pOption = pcmdOptions + OI_VERBOSE;
	pOption->dwCount = 1;
	pOption->dwActuals = 0;
	pOption->dwFlags = 0;
	pOption->pValue = &m_bVerbose;
	pOption->pFunction = NULL;
	pOption->pFunctionData = NULL;
	lstrcpy( pOption->szValues, NULL_STRING );
	lstrcpy( pOption->szOption, OPTION_VERBOSE );

	// -svc
	pOption = pcmdOptions + OI_SVC;
	pOption->dwCount = 1;
	pOption->dwActuals = 0;
	pOption->dwFlags = 0;
	pOption->pValue = &m_bAllServices;
	pOption->pFunction = NULL;
	pOption->pFunctionData = NULL;
	lstrcpy( pOption->szValues, NULL_STRING );
	lstrcpy( pOption->szOption, OPTION_SVC );

	// -m
	pOption = pcmdOptions + OI_MODULES;
	pOption->dwCount = 1;
	pOption->dwActuals = 0;
	pOption->dwFlags = CP_TYPE_TEXT | CP_VALUE_OPTIONAL;
	pOption->pValue = pwszModules;
	pOption->pFunction = NULL;
	pOption->pFunctionData = NULL;
	lstrcpy( pOption->szValues, NULL_STRING );
	lstrcpy( pOption->szOption, OPTION_MODULES );

	//
	// do the parsing
	if ( DoParseParam( argc, argv, MAX_OPTIONS, pcmdOptions ) == FALSE )
	{
		delete [] pcmdOptions;	// clear memory
		pcmdOptions = NULL;
		return FALSE;			// invalid syntax
	}

	// release the buffers
	m_strModules.ReleaseBuffer();
	m_strServer.ReleaseBuffer();
	m_strUserName.ReleaseBuffer();
	m_strPassword.ReleaseBuffer();

	//
	// now, check the mutually exclusive options
	pOptionServer = pcmdOptions + OI_SERVER;
	pOptionUserName = pcmdOptions + OI_USERNAME;
	pOptionPassword = pcmdOptions + OI_PASSWORD;

	// check the usage option
	if ( m_bUsage && ( argc > 2 ) )
	{
		// no other options are accepted along with -? option
		SetLastError( MK_E_SYNTAX );
		SetReason( ERROR_INVALID_USAGE_REQUEST );
		delete [] pcmdOptions;		// clear the cmd parser config info
		return FALSE;
	}
	else if ( m_bUsage == TRUE )
	{
		// should not do the furthur validations
		delete [] pcmdOptions;		// clear the cmd parser config info
		return TRUE;
	}

	// "-u" should not be specified without machine names
	if ( pOptionServer->dwActuals == 0 && pOptionUserName->dwActuals != 0 )
	{
		// invalid syntax
		SetReason( ERROR_USERNAME_BUT_NOMACHINE );
		delete [] pcmdOptions;		// clear the cmd parser config info
		return FALSE;			// indicate failure
	}

	// empty server name is not valid
	if ( pOptionServer->dwActuals != 0 )
	{
		// trim the contents
		m_strServer.TrimLeft();
		m_strServer.TrimRight();

		// check the value
		if ( m_strServer.GetLength() == 0 )
		{
			SetReason( ERROR_SERVERNAME_EMPTY );
			delete [] pcmdOptions;		// clear the cmd parser config info
			return FALSE;			// indicate failure
		}
	}

	// empty user is not valid
	m_strUserName.TrimLeft();
	m_strUserName.TrimRight();
	if ( pOptionUserName->dwActuals != 0 && m_strUserName.GetLength() == 0 )
	{
		SetReason( ERROR_USERNAME_EMPTY );
		delete [] pcmdOptions;
		return FALSE;
	}

	// "-p" should not be specified without "-u"
	if ( pOptionUserName->dwActuals == 0 && pOptionPassword->dwActuals != 0 )
	{
		// invalid syntax
		SetReason( ERROR_PASSWORD_BUT_NOUSERNAME );
		delete [] pcmdOptions;		// clear the cmd parser config info
		return FALSE;			// indicate failure
	}

	// check whether user has specified modules or not
	if ( pcmdOptions[ OI_MODULES ].dwActuals != 0 )
	{
		// user has specified modules information
		m_bAllModules = TRUE;
		m_bNeedModulesInfo = TRUE;

		// now need to check whether user specified value or not this option
		m_strModules.TrimLeft();
		m_strModules.TrimRight();
		if ( m_strModules.GetLength() != 0 )
		{
			// sub-local variales
			CHString str;
			LONG lPos = 0;

			// validate the modules .. direct filter
			// if should not have '*' character in between
			lPos = m_strModules.Find( L"*" );
			if ( lPos != -1 && m_strModules.Mid( lPos + 1 ).GetLength() != 0 )
			{
				SetReason( ERROR_M_CHAR_AFTER_WILDCARD );
				delete [] pcmdOptions;
				return FALSE;
			}

			// if the wildcard is not specified, it means user is looking for just a particular module name
			// so, do not show the modules info instead show the filtered regular information
			// if ( lPos == -1 )
			//	m_bAllModules = FALSE;

			// if the filter specified is not just '*' add a custom filter
			if ( m_strModules.Compare( L"*" ) != 0 )
			{
				// prepare the search string
				str.Format( FMT_MODULES_FILTER, m_strModules );

				// add the value to the filters list
				if ( DynArrayAppendString( m_arrFilters, str, 0 ) == -1 )
				{
					SetLastError( E_OUTOFMEMORY );
					SaveLastError();
					delete [] pcmdOptions;
					return FALSE;
				}
			}
			else
			{
				// user specified just '*' ... clear the contents
				m_strModules.Empty();
			}
		}
	}

	// determine the format in which the process information has to be displayed
	m_dwFormat = SR_FORMAT_TABLE;
	if ( lstrcmpi( szFormat, TEXT_FORMAT_LIST ) == 0 )
		m_dwFormat = SR_FORMAT_LIST;
	else if ( lstrcmpi( szFormat, TEXT_FORMAT_TABLE ) == 0 )
		m_dwFormat = SR_FORMAT_TABLE;
	else if ( lstrcmpi( szFormat, TEXT_FORMAT_CSV ) == 0 )
		m_dwFormat = SR_FORMAT_CSV;

	// -nh option is not valid of LIST format
	if ( bNoHeader == TRUE && m_dwFormat == SR_FORMAT_LIST )
	{
		// invalid syntax
		SetReason( ERROR_NH_NOTSUPPORTED );
		delete [] pcmdOptions;		// clear the cmd parser config info
		return FALSE;			// indicate failure
	}

	// identify output format
	if ( bNoHeader )
		m_dwFormat |= SR_NOHEADER;		// do not display the header

	// -svc, -m and -v should not be combined
	if ( (m_bAllServices == TRUE && (m_bAllModules == TRUE || m_bVerbose == TRUE)) ||
		 (m_bAllModules == TRUE && (m_bAllServices == TRUE || m_bVerbose == TRUE)) ||
		 (m_bVerbose == TRUE && (m_bAllServices == TRUE || m_bAllModules == TRUE)) )
	{
		// invalid syntax
		SetReason( ERROR_M_SVC_V_CANNOTBECOUPLED );
		delete [] pcmdOptions;		// clear the cmd parser config info
		return FALSE;			// indicate failure
	}

	// determine whether we need to get the services / username info or not
	if ( m_bAllServices == TRUE )
		m_bNeedServicesInfo = TRUE;
	else if ( m_bVerbose == TRUE )
	{
		m_bNeedWindowTitles = TRUE;
		m_bNeedUserContextInfo = TRUE;
	}
	
	// check whether caller should accept the password or not
	// if user has specified -s (or) -u and no "-p", then utility should accept password
	// the user will be prompter for the password only if establish connection 
	// is failed without the credentials information
	if ( pOptionPassword->dwActuals != 0 && m_strPassword.Compare( L"*" ) == 0 )
	{
		// user wants the utility to prompt for the password before trying to connect
		m_bNeedPassword = TRUE;
	}
	else if ( (pOptionPassword->dwActuals == 0 && 
			  (pOptionServer->dwActuals != 0 || pOptionUserName->dwActuals != 0)) )
	{
		// utility needs to try to connect first and if it fails then prompt for the password
		m_bNeedPassword = TRUE;
		m_strPassword.Empty();
	}

	// command-line parsing is successfull
	delete [] pcmdOptions;		// clear the cmd parser config info
	return TRUE;
}

// ***************************************************************************
// Routine Description:
//		validates the filter information specified with -filter option
//		  
// Arguments:
//		NONE
//  
// Return Value:
//		TRUE	: if filters are appropriately specified
//		FALSE	: if filters are errorneously specified
// 
// ***************************************************************************
BOOL CTaskList::ValidateFilters()
{
	// local variables
	LONG lIndex = -1;
	BOOL bResult = FALSE;
	PTFILTERCONFIG pConfig = NULL;

	//
	// prepare the filter structure

	// sessionname
	pConfig = m_pfilterConfigs + FI_SESSIONNAME;
	pConfig->dwColumn = CI_SESSIONNAME;
	pConfig->dwFlags = F_TYPE_TEXT | F_MODE_PATTERN;
	pConfig->pFunction = NULL;
	pConfig->pFunctionData = NULL;
	lstrcpy( pConfig->szOperators, OPERATORS_STRING );
	lstrcpy( pConfig->szProperty, FILTER_SESSIONNAME );
	lstrcpy( pConfig->szValues, NULL_STRING );

	// status
	pConfig = m_pfilterConfigs + FI_STATUS;
	pConfig->dwColumn = CI_STATUS;
	pConfig->dwFlags = F_TYPE_TEXT | F_MODE_VALUES;
	pConfig->pFunction = NULL;
	pConfig->pFunctionData = NULL;
	lstrcpy( pConfig->szOperators, OPERATORS_STRING );
	lstrcpy( pConfig->szProperty, FILTER_STATUS );
	lstrcpy( pConfig->szValues, FVALUES_STATUS );

	// imagename
	pConfig = m_pfilterConfigs + FI_IMAGENAME;
	pConfig->dwColumn = CI_IMAGENAME;
	pConfig->dwFlags = F_TYPE_TEXT | F_MODE_PATTERN;
	pConfig->pFunction = NULL;
	pConfig->pFunctionData = NULL;
	lstrcpy( pConfig->szOperators, OPERATORS_STRING );
	lstrcpy( pConfig->szProperty, FILTER_IMAGENAME );
	lstrcpy( pConfig->szValues, NULL_STRING );

	// pid
	pConfig = m_pfilterConfigs + FI_PID;
	pConfig->dwColumn = CI_PID;
	pConfig->dwFlags = F_TYPE_UNUMERIC;
	pConfig->pFunction = NULL;
	pConfig->pFunctionData = NULL;
	lstrcpy( pConfig->szOperators, OPERATORS_NUMERIC );
	lstrcpy( pConfig->szProperty, FILTER_PID );
	lstrcpy( pConfig->szValues, NULL_STRING );

	// session
	pConfig = m_pfilterConfigs + FI_SESSION;
	pConfig->dwColumn = CI_SESSION;
	pConfig->dwFlags = F_TYPE_UNUMERIC;
	pConfig->pFunction = NULL;
	pConfig->pFunctionData = NULL;
	lstrcpy( pConfig->szOperators, OPERATORS_NUMERIC );
	lstrcpy( pConfig->szProperty, FILTER_SESSION );
	lstrcpy( pConfig->szValues, NULL_STRING );

	// cputime
	pConfig = m_pfilterConfigs + FI_CPUTIME;
	pConfig->dwColumn = CI_CPUTIME;
	pConfig->dwFlags = F_TYPE_CUSTOM;
	pConfig->pFunction = FilterCPUTime;
	pConfig->pFunctionData = ( LPVOID) ((LPCWSTR) m_strTimeSep);
	lstrcpy( pConfig->szOperators, OPERATORS_NUMERIC );
	lstrcpy( pConfig->szProperty, FILTER_CPUTIME );
	lstrcpy( pConfig->szValues, NULL_STRING );

	// memusage
	pConfig = m_pfilterConfigs + FI_MEMUSAGE;
	pConfig->dwColumn = CI_MEMUSAGE;
	pConfig->dwFlags = F_TYPE_UNUMERIC;
	pConfig->pFunction = NULL;
	pConfig->pFunctionData = NULL;
	lstrcpy( pConfig->szOperators, OPERATORS_NUMERIC );
	lstrcpy( pConfig->szProperty, FILTER_MEMUSAGE );
	lstrcpy( pConfig->szValues, NULL_STRING );

	// username
	pConfig = m_pfilterConfigs + FI_USERNAME;
	pConfig->dwColumn = CI_USERNAME;
	pConfig->dwFlags = F_TYPE_CUSTOM;
	pConfig->pFunction = FilterUserName;
	pConfig->pFunctionData = NULL;
	lstrcpy( pConfig->szOperators, OPERATORS_STRING );
	lstrcpy( pConfig->szProperty, FILTER_USERNAME );
	lstrcpy( pConfig->szValues, NULL_STRING );

	// services
	pConfig = m_pfilterConfigs + FI_SERVICES;
	pConfig->dwColumn = CI_SERVICES;
	pConfig->dwFlags = F_TYPE_TEXT | F_MODE_PATTERN | F_MODE_ARRAY;
	pConfig->pFunction = NULL;
	pConfig->pFunctionData = NULL;
	lstrcpy( pConfig->szOperators, OPERATORS_STRING );
	lstrcpy( pConfig->szProperty, FILTER_SERVICES );
	lstrcpy( pConfig->szValues, NULL_STRING );

	// windowtitle
	pConfig = m_pfilterConfigs + FI_WINDOWTITLE;
	pConfig->dwColumn = CI_WINDOWTITLE;
	pConfig->dwFlags = F_TYPE_TEXT | F_MODE_PATTERN;
	pConfig->pFunction = NULL;
	pConfig->pFunctionData = NULL;
	lstrcpy( pConfig->szOperators, OPERATORS_STRING );
	lstrcpy( pConfig->szProperty, FILTER_WINDOWTITLE );
	lstrcpy( pConfig->szValues, NULL_STRING );

	// modules
	pConfig = m_pfilterConfigs + FI_MODULES;
	pConfig->dwColumn = CI_MODULES;
	pConfig->dwFlags = F_TYPE_TEXT | F_MODE_PATTERN | F_MODE_ARRAY;
	pConfig->pFunction = NULL;
	pConfig->pFunctionData = NULL;
	lstrcpy( pConfig->szOperators, OPERATORS_STRING );
	lstrcpy( pConfig->szProperty, FILTER_MODULES );
	lstrcpy( pConfig->szValues, NULL_STRING );

	//
	// validate the filter
	bResult = ParseAndValidateFilter( MAX_FILTERS, 
		m_pfilterConfigs, m_arrFilters, &m_arrFiltersEx );

	// check the filter validation result
	if ( bResult == FALSE )
		return FALSE;

	// find out whether user has requested for the tasks to be filtered 
	// on user context and/or services are not ... if yes, set the appropriate flags
	// this check is being done to increase the performance of the utility
	// NOTE: we will be using the parsed filters info for doing this

	// window titles
	if ( m_bNeedWindowTitles == FALSE )
	{
		// find out if the filter property exists in this row
		// NOTE:- 
		//		  filter property do exists in the seperate indexes only.
		//		  refer to the logic of validating the filters in common functionality
		lIndex = DynArrayFindStringEx( m_arrFiltersEx, 
			F_PARSED_INDEX_PROPERTY, FILTER_WINDOWTITLE, TRUE, 0 );
		if ( lIndex != -1 )
			m_bNeedWindowTitles = TRUE;
	}

	// user context
	if ( m_bNeedUserContextInfo == FALSE )
	{
		// find out if the filter property exists in this row
		// NOTE:- 
		//		  filter property do exists in the seperate indexes only.
		//		  refer to the logic of validating the filters in common functionality
		lIndex = DynArrayFindStringEx( m_arrFiltersEx, 
			F_PARSED_INDEX_PROPERTY, FILTER_USERNAME, TRUE, 0 );
		if ( lIndex != -1 )
			m_bNeedUserContextInfo = TRUE;
	}

	// services info
	if ( m_bNeedServicesInfo == FALSE )
	{
		// find out if the filter property exists in this row
		// NOTE:- 
		//		  filter property do exists in the seperate indexes only.
		//		  refer to the logic of validating the filters in common functionality
		lIndex = DynArrayFindStringEx( m_arrFiltersEx, 
			F_PARSED_INDEX_PROPERTY, FILTER_SERVICES, TRUE, 0 );
		if ( lIndex != -1 )
			m_bNeedServicesInfo = TRUE;
	}

	// modules info
	if ( m_bNeedModulesInfo == FALSE )
	{
		// find out if the filter property exists in this row
		// NOTE:- 
		//		  filter property do exists in the seperate indexes only.
		//		  refer to the logic of validating the filters in common functionality
		lIndex = DynArrayFindStringEx( m_arrFiltersEx, 
			F_PARSED_INDEX_PROPERTY, FILTER_MODULES, TRUE, 0 );
		if ( lIndex != -1 )
			m_bNeedModulesInfo = TRUE;
	}

	//
	// do the filter optimization by adding the wmi properties to the query
	//
	// NOTE: as the 'handle' property of the Win32_Process class is string type
	//       we cannot include that in the wmi query for optimization. So make use
	//		 of the ProcessId property
	LONG lCount = 0;
	CHString strBuffer;
	BOOL bOptimized = FALSE;
	LPCWSTR pwszValue = NULL;
	LPCWSTR pwszClause = NULL;
	LPCWSTR pwszProperty = NULL;
	LPCWSTR pwszOperator = NULL;

	// first clause .. and init
	m_strQuery = WMI_PROCESS_QUERY;
	pwszClause = WMI_QUERY_FIRST_CLAUSE;

	// get the no. of filters
	lCount = DynArrayGetCount( m_arrFiltersEx );

	// traverse thru all the filters and do the optimization
	for( LONG i = 0; i < lCount; i++ )
	{
		// assume this filter will not be delete / not useful for optimization
		bOptimized = FALSE;

		// get the property, operator and value
		pwszValue = DynArrayItemAsString2( m_arrFiltersEx, i, F_PARSED_INDEX_VALUE );
		pwszProperty = DynArrayItemAsString2( m_arrFiltersEx, i, F_PARSED_INDEX_PROPERTY );
		pwszOperator = DynArrayItemAsString2( m_arrFiltersEx, i, F_PARSED_INDEX_OPERATOR );
		if ( pwszProperty == NULL || pwszOperator == NULL || pwszValue == NULL )
		{
			SetLastError( STG_E_UNKNOWN );
			SaveLastError();
			return FALSE;
		}

		//
		// based on the property do optimization needed

		// get the mathematically equivalent operator
		pwszOperator = FindOperator( pwszOperator );

		// process id
		if ( StringCompare( FILTER_PID, pwszProperty, TRUE, 0 ) == 0 )
		{
			// convert the value into numeric
			DWORD dwProcessId = AsLong( pwszValue, 10 );
			strBuffer.Format( L" %s %s %s %d", 
				pwszClause, WIN32_PROCESS_PROPERTY_PROCESSID, pwszOperator, dwProcessId );

			// need to be optimized
			bOptimized = TRUE;
		}

		// session id
		else if ( StringCompare( FILTER_SESSION, pwszProperty, TRUE, 0 ) == 0 )
		{
			// convert the value into numeric
			DWORD dwSession = AsLong( pwszValue, 10 );
			strBuffer.Format( L" %s %s %s %d", 
				pwszClause, WIN32_PROCESS_PROPERTY_SESSION, pwszOperator, dwSession );

			// need to be optimized
			bOptimized = TRUE;
		}

		// image name
		else if ( StringCompare( FILTER_IMAGENAME, pwszProperty, TRUE, 0 ) == 0 )
		{
			// check if wild card is specified or not
			// if wild card is specified, this filter cannot be optimized
			if ( wcschr( pwszValue, _T( '*' ) ) == NULL )
			{
				// no conversions needed
				strBuffer.Format( L" %s %s %s '%s'", 
					pwszClause, WIN32_PROCESS_PROPERTY_IMAGENAME, pwszOperator, pwszValue );

				// need to be optimized
				bOptimized = TRUE;
			}
		}

		// status
		else if ( StringCompare( FILTER_STATUS, pwszProperty, TRUE, 0 ) == 0 )
		{
			//
			// do the value conversions
			//
			// if OPERATOR is =
			// value:	RUNNING means        OPERATOR is > and VALUE is 0
			//			NOT RESPONDING means OPERATOR = and VALUE is 0
			//
			// if OPERATOR is !=
			// value:   RUNNING means        OPERATOR is = and VALUE is 0
			//          NOT RESPONDING means OPERATOR is > and VALUE is 0
			if ( StringCompare( pwszValue, VALUE_RUNNING, TRUE, 0 ) == 0 )
			{
				if ( StringCompare( pwszOperator, MATH_EQ, TRUE, 0 ) == 0 )
					pwszOperator = MATH_GT;
				else
					pwszOperator = MATH_EQ;
			}
			else
			{
				if ( StringCompare( pwszOperator, MATH_EQ, TRUE, 0 ) == 0 )
					pwszOperator = MATH_EQ;
				else
					pwszOperator = MATH_GT;
			}

			// finally the filter condition
			strBuffer.Format( L" %s %s %s 0", 
				pwszClause, WIN32_PROCESS_PROPERTY_THREADS, pwszOperator );

			// need to be optimized
			bOptimized = TRUE;
		}

		// mem usage
		else if ( StringCompare( FILTER_MEMUSAGE, pwszProperty, TRUE, 0 ) == 0 )
		{
			// convert the value into numeric
			ULONG ulMemUsage = AsLong( pwszValue, 10 ) * 1024;
			strBuffer.Format( L" %s %s %s %lu", 
				pwszClause, WIN32_PROCESS_PROPERTY_MEMUSAGE, pwszOperator, ulMemUsage );

			// need to be optimized
			bOptimized = TRUE;
		}

		// check if property is optimizable ... if yes ... remove
		if ( bOptimized == TRUE )
		{
			// change the clause and append the current query
			m_strQuery += strBuffer;
			pwszClause = WMI_QUERY_SECOND_CLAUSE;

			// remove property and update the iterator variables
			DynArrayRemove( m_arrFiltersEx, i );
			i--;
			lCount--;
		}
	}

	// return the filter validation result
	return bResult;
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// ***************************************************************************
BOOL TimeFieldsToElapsedTime( LPCWSTR pwszTime, LPCWSTR pwszToken, ULONG& ulElapsedTime )
{
	// local variables
	ULONG ulValue = 0;
	LPCWSTR pwszField = NULL;
	__STRING_64 szTemp = NULL_STRING;
	DWORD dwNext = 0, dwLength = 0, dwCount = 0;

	// check the input
	if ( pwszTime == NULL || pwszToken == NULL )
		return FALSE;

	// start parsing the time info
	dwNext = 0;
	dwCount = 0;
	ulElapsedTime = 0;
	do
	{
		// search for the needed token
		pwszField = FindString( pwszTime, pwszToken, dwNext );
		if ( pwszField == NULL )
		{
			// check whether some more text exists in the actual string or not
			if ( (LONG) dwNext >= lstrlen( pwszTime ) )
				break;			// no more info found

			// get the last info
			lstrcpyn( szTemp, pwszTime + dwNext, SIZE_OF_ARRAY( szTemp ) );
			dwLength = lstrlen( szTemp );			 // update the length
		}
		else
		{
			// determine the length of numeric value and get the numeric value
			dwLength = lstrlen( pwszTime ) - lstrlen( pwszField ) - dwNext;

			// check the length info
			if ( dwLength > SIZE_OF_ARRAY( szTemp ) )
				return FALSE;

			// get the current info
			lstrcpyn( szTemp, pwszTime + dwNext, dwLength + 1 );	// +1 for NULL character
		}

		// update the count of fields we are getting
		dwCount++;

		// check whether this field is numeric or not
		if ( lstrlen( szTemp ) == 0 || IsNumeric( szTemp, 10, FALSE ) == FALSE )
			return FALSE;

		// from second token onwards, values greater than 59 are not allowed
		ulValue = AsLong( szTemp, 10 );
		if ( dwCount > 1 && ulValue > 59 )
			return FALSE;

		// update the elapsed time
		ulElapsedTime = ( ulElapsedTime + ulValue ) * (( dwCount < 3 ) ? 60 : 1);

		// position to the next information start
		dwNext += dwLength + lstrlen( pwszToken );
	} while ( pwszField != NULL && dwCount < 3 );

	// check the no. of time field we got .. we should have got 3 .. if not error
	if ( pwszField != NULL || dwCount != 3 )
		return FALSE;

	// so everything went right ... return success
	return TRUE;
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// ***************************************************************************
DWORD FilterCPUTime( LPCWSTR pwszProperty, LPCWSTR pwszOperator, 
				     LPCWSTR pwszValue, LPVOID pData, TARRAY arrRow )
{
	// local variables
	ULONG ulCPUTime = 0;
	ULONG ulElapsedTime = 0;
	LPCWSTR pwszCPUTime = NULL;

	// if the arrRow parameter is NULL, we need to validate the filter
	if ( arrRow == NULL )
	{
		// validate the filter value and return the result
		if ( TimeFieldsToElapsedTime( pwszValue, L":", ulElapsedTime ) == FALSE )
			return F_FILTER_INVALID;
		else
			return F_FILTER_VALID;
	}

	// get the filter value
	TimeFieldsToElapsedTime( pwszValue, L":", ulElapsedTime );

	// get the record value
	pwszCPUTime = DynArrayItemAsString( arrRow, TASK_CPUTIME );
	if ( pwszCPUTime == NULL )
		return F_RESULT_REMOVE;

	// convert the record value into elapsed time value
	TimeFieldsToElapsedTime( pwszCPUTime, (LPCWSTR) pData, ulCPUTime );

	// return the result
	if ( ulCPUTime == ulElapsedTime )
		return MASK_EQ;
	else if ( ulCPUTime < ulElapsedTime )
		return MASK_LT;
	else if ( ulCPUTime > ulElapsedTime )
		return MASK_GT;

	// no way flow coming here .. still
	return F_RESULT_REMOVE;
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// ***************************************************************************
DWORD FilterUserName( LPCWSTR pwszProperty, LPCWSTR pwszOperator, 
				      LPCWSTR pwszValue, LPVOID pData, TARRAY arrRow )
{
	// local variables
	LONG lResult = 0;
	LONG lWildCardPos = 0;
	LPCWSTR pwszTemp = NULL;
	LPCWSTR pwszSearch = NULL;
	BOOL bOnlyUserName = FALSE;
	LPCWSTR pwszUserName = NULL;

	// check the inputs
	if ( pwszProperty == NULL || pwszOperator == NULL || pwszValue == NULL )
		return F_FILTER_INVALID;

	// if the arrRow parameter is NULL, we need to validate the filter
	if ( arrRow == NULL )
	{
		// nothing is there to validate ... just check the length 
		// and ensure that so text is present and the value should not be just '*'
		// NOTE: the common functionality will give the value after doing left and right trim
		if ( lstrlen( pwszValue ) == 0 || StringCompare( pwszValue, L"*", TRUE, 0 ) == 0 )
			return F_FILTER_INVALID;

		// the wild card character is allowed only at the end
		pwszTemp = _tcschr( pwszValue, L'*' );
		if ( pwszTemp != NULL && lstrlen( pwszTemp + 1 ) != 0 )
			return F_FILTER_INVALID;

		// filter is valid
		return F_FILTER_VALID;
	}

	// find the position of the wild card in the supplied user name
	lWildCardPos = 0;
	pwszTemp = _tcschr( pwszValue, L'*' );
	if ( pwszTemp != NULL )
	{
		// determine the wild card position
		lWildCardPos = lstrlen( pwszValue ) - lstrlen( pwszTemp );

		// special case:
		// if the pattern is just asterisk, which means that all the
		// information needs to passed thru the filter but there is no chance for 
		// this situation as specifying only '*' is being treated as invalid filter
		if ( lWildCardPos == 0 )
			return F_FILTER_INVALID;
	}

	// search for the domain and user name seperator ...
	// if domain name is not specified, comparision will be done only with the user name
	bOnlyUserName = FALSE;
	pwszTemp = _tcschr( pwszValue, L'\\' );
	if ( pwszTemp == NULL )
		bOnlyUserName = TRUE;

	// get the user name from the info
	pwszUserName = DynArrayItemAsString( arrRow, TASK_USERNAME );
	if ( pwszUserName == NULL )
		return F_RESULT_REMOVE;

	// based the search criteria .. meaning whether to search along with the domain or
	// only user name, the seach string will be decided
	pwszSearch = pwszUserName;
	if ( bOnlyUserName == TRUE )
	{
		// search for the domain and user name seperation character
		pwszTemp = _tcschr( pwszUserName, L'\\' );
		
		// position to the next character
		if ( pwszTemp != NULL )
			pwszSearch = pwszTemp + 1;
	}

	// validate the search string
	if ( pwszSearch == NULL )
		return F_RESULT_REMOVE;

	// now do the comparision
	lResult = StringCompare( pwszSearch, pwszValue, TRUE, lWildCardPos );

	//
	// now determine the result value
	if ( lResult == 0 )
		return MASK_EQ;
	else if ( lResult < 0 )
		return MASK_LT;
	else if ( lResult > 0 )
		return MASK_GT;

	// never come across this situation ... still
	return F_RESULT_REMOVE;
}

// ***************************************************************************
// Routine Description:
//		This function fetches usage information from resource file and shows it
//		  
// Arguments:
//		NONE
//  
// Return Value:
//		NONE
// ***************************************************************************
VOID CTaskList::Usage()
{
	// local variables
	DWORD dw = 0;

	// start displaying the usage
	ShowMessage( stdout, L"\n" );
	for( dw = ID_HELP_START; dw <= ID_HELP_END; dw++ )
		ShowMessage( stdout, GetResString( dw ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cmdline\tasklist\pch.h ===
// *********************************************************************************
// 
//  Copyright (c) Microsoft Corporation
//  
//  Module Name:
// 
//		pch.h 
//  
//  Abstract:
//  
// 		pre-compiled header declaration
//		files that has to be pre-compiled into .pch file
//  
//  Author:
//  
// 	  Sunil G.V.N. Murali (murali.sunil@wipro.com) 24-Sep-2000
//  
//  Revision History:
//  
// 	  Sunil G.V.N. Murali (murali.sunil@wipro.com) 24-Sep-2000 : Created It.
//  
// *********************************************************************************

#ifndef __PCH_H
#define __PCH_H

#pragma once		// include header file only once

#if !defined( SECURITY_WIN32 ) && !defined( SECURITY_KERNEL ) && !defined( SECURITY_MAC )
#define SECURITY_WIN32
#endif

//
// Private nt headers.
//
extern "C"
{
	#include <nt.h>
	#include <ntrtl.h>
    #include <nturtl.h>
    #include <ntexapi.h>
	#include <Security.h>
	#include <SecExt.h>
}

//
// public Windows header files
//
#include <windows.h>
#include <winperf.h>
#include <wbemidl.h>
#include <chstring.h>
#include <comdef.h>
#include <wbemtime.h>
#include <tchar.h>
#include <dbghelp.h>

//
// public C header files
//
#include <stdio.h>
#include <string.h>
#include <crtdbg.h>

//
// private Common header files
//
#include "cmdlineres.h"
#include "cmdline.h"

#endif	// __PCH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cmdline\tasklist\showtasks.cpp ===
// *********************************************************************************
// 
//  Copyright (c) Microsoft Corporation
//  
//  Module Name:
//  
//		ShowTasks.cpp
//  
//  Abstract:
//  
// 		This module displays the tasks that were retrieved
//  
//  Author:
//  
// 		Sunil G.V.N. Murali (murali.sunil@wipro.com) 25-Nov-2000
//  
//  Revision History:
//  
// 		Sunil G.V.N. Murali (murali.sunil@wipro.com) 25-Nov-2000 : Created It.
//  
// *********************************************************************************

#include "pch.h"
#include "wmi.h"
#include "TaskList.h"

//
// define(s) / constants
// 
#define MAX_TIMEOUT_RETRIES				300
#define MAX_ENUM_TASKS					5
#define	MAX_ENUM_SERVICES				10
#define	MAX_ENUM_MODULES				5
#define FMT_KILOBYTE					GetResString( IDS_FMT_KILOBYTE )

// structure signatures
#define SIGNATURE_MODULES		9

//
// typedefs
//
typedef struct _tagModulesInfo
{
	DWORD dwSignature;
	DWORD dwLength;
	LPCWSTR pwszModule;
	TARRAY arrModules;
} TMODULESINFO, *PTMODULESINFO;

//
// function prototypes
//
#ifndef _WIN64
BOOL EnumLoadedModulesProc( LPSTR lpszModuleName, ULONG ulModuleBase, ULONG ulModuleSize, PVOID pUserData );
#else
BOOL EnumLoadedModulesProc64( LPSTR lpszModuleName, DWORD64 ulModuleBase, ULONG ulModuleSize, PVOID pUserData );
#endif

// ***************************************************************************
// Routine Description:
//		show the tasks running 
//		  
// Arguments:
//		NONE
//  
// Return Value:
//		NONE
// 
// ***************************************************************************
DWORD CTaskList::Show()
{
	// local variables
	HRESULT hr;
	CHString strStatus;
	DWORD dwCount = 0;
	DWORD dwFormat = 0;
	DWORD dwFilters = 0;
	DWORD dwTimeOuts = 0;
	ULONG ulReturned = 0;
	BOOL bCanExit = FALSE;
	IWbemClassObject* pObjects[ MAX_ENUM_TASKS ];

	// init the objects to NULL's
	for( DWORD dw = 0; dw < MAX_ENUM_TASKS; dw++ )
		pObjects[ dw ] = NULL;

	// copy the format that has to be displayed into local memory
	bCanExit = FALSE;
	dwFormat = m_dwFormat;
	dwFilters = DynArrayGetCount( m_arrFiltersEx );

	// prepare the columns structure to display
	PrepareColumns();

	// clear the error code ... if any
	SetLastError( NO_ERROR );
	
	// dynamically decide whether to hide or show the window title in non-verbose mode
	if ( m_bLocalSystem == FALSE && m_bVerbose == TRUE )
		( m_pColumns + CI_WINDOWTITLE )->dwFlags |= SR_HIDECOLUMN;

	try
	{
		// loop thru the process instances 
		dwTimeOuts = 0;
		strStatus = MSG_TASKSINFO;
		do
		{
			// get the object ... wait only for 1 sec at one time ...
			hr = m_pEnumObjects->Next( 1000, MAX_ENUM_TASKS, pObjects, &ulReturned );
			if ( hr == WBEM_S_FALSE )
			{
				// we've reached the end of enumeration .. set the flag 
				bCanExit = TRUE;
			}
			else if ( hr == WBEM_S_TIMEDOUT )
			{
				// update the timeouts occured 
				dwTimeOuts++;

				// display the status message
				if ( m_hOutput != NULL )
					PrintProgressMsg( m_hOutput, strStatus + ((dwTimeOuts % 2 == 0) ? L" --" : L" |"), m_csbi );

				// check if max. retries have reached ... if yes better stop
				if ( dwTimeOuts > MAX_TIMEOUT_RETRIES )
				{
					// erase the status messages
					if ( m_hOutput != NULL )
						PrintProgressMsg( m_hOutput, NULL, m_csbi );

					// time out error
					SetLastError( ERROR_TIMEOUT );
					SaveLastError();
					return 0;
				}

				// still we can do more tries ...
				continue;
			}
			else if ( FAILED( hr ) )
			{
				// some error has occured ... oooppps
				WMISaveError( hr );
				SetLastError( STG_E_UNKNOWN );
				return 0;
			}

			// reset the timeout counter
			dwTimeOuts = 0;

			// erase the status messages
			if ( m_hOutput != NULL )
				PrintProgressMsg( m_hOutput, NULL, m_csbi );

			// loop thru the objects and save the info
			for( ULONG ul = 0; ul < ulReturned; ul++ )
			{
				// retrive and save data
				LONG lIndex = DynArrayAppendRow( m_arrTasks, MAX_TASKSINFO );
				SaveInformation( lIndex, pObjects[ ul ] );

				// we need to release the wmi object
				SAFE_RELEASE( pObjects[ ul ] );
			}

			// filter the results .. before doing first if filters do exist or not
			if ( dwFilters != 0 )
				FilterResults( MAX_FILTERS, m_pfilterConfigs, m_arrTasks, m_arrFiltersEx );

			// now show the tasks ... if exists
			if ( DynArrayGetCount( m_arrTasks ) != 0 )
			{
				// erase status messages if any
				PrintProgressMsg( m_hOutput, NULL, m_csbi );

				// if the output is not being displayed first time, 
				// print one blank line in between ONLY FOR LIST FORMAT
				if ( dwCount != 0 && ((dwFormat & SR_FORMAT_MASK) == SR_FORMAT_LIST) )
				{
					ShowMessage( stdout, L"\n" );
				}
				else if ( dwCount == 0 )
				{
					// output is being displayed for the first time
					ShowMessage( stdout, L"\n" );
				}

				// show the tasks
				ShowResults( MAX_COLUMNS, m_pColumns, dwFormat, m_arrTasks );

				// clear the contents and reset
				dwCount += DynArrayGetCount( m_arrTasks );			// update count
				DynArrayRemoveAll( m_arrTasks );

				// to be on safe side, set the apply no heade flag to the format info
				dwFormat |= SR_NOHEADER;

				// get the next cursor position
				if ( m_hOutput != NULL )
					GetConsoleScreenBufferInfo( m_hOutput, &m_csbi );
			}
		} while ( bCanExit == FALSE );
	}
	catch( ... )
	{
		SetLastError( E_OUTOFMEMORY );
		SaveLastError();
		return 0;
	}

	// erase the status message
	PrintProgressMsg( m_hOutput, NULL, m_csbi );

	// clear the error
	SetLastError( NO_ERROR );

	// return the no. of tasks that were shown
	return dwCount;
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
//		Process id as DWORD
// 
// ***************************************************************************
BOOL CTaskList::SaveInformation( LONG lIndex, IWbemClassObject* pWmiObject )
{
	// local variables
	CHString str;

	// object path
	PropertyGet( pWmiObject, WIN32_PROCESS_SYSPROPERTY_PATH, str );
	DynArraySetString2( m_arrTasks, lIndex, TASK_OBJPATH, str, 0 );

	// process id
	PropertyGet( pWmiObject, WIN32_PROCESS_PROPERTY_PROCESSID, m_dwProcessId );
	DynArraySetDWORD2( m_arrTasks, lIndex, TASK_PID, m_dwProcessId );

	// host name
	PropertyGet( pWmiObject, WIN32_PROCESS_PROPERTY_COMPUTER, str );
	DynArraySetString2( m_arrTasks, lIndex, TASK_HOSTNAME, str, 0 );

	// image name
	PropertyGet( pWmiObject, WIN32_PROCESS_PROPERTY_IMAGENAME, m_strImageName );
	DynArraySetString2( m_arrTasks, lIndex, TASK_IMAGENAME, m_strImageName, 0 );

	// status
	SetStatus( lIndex, pWmiObject );

	// cpu Time
	SetCPUTime( lIndex, pWmiObject );

	// session id and session name
	SetSession( lIndex, pWmiObject );

	// mem usage
	SetMemUsage( lIndex, pWmiObject );

	// user context
	SetUserContext( lIndex, pWmiObject );

	// window title
	SetWindowTitle( lIndex, pWmiObject );

	// services
	SetServicesInfo( lIndex, pWmiObject );

	// modules
	SetModulesInfo( lIndex, pWmiObject );

	// return
	return TRUE;
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
VOID CTaskList::SetUserContext( LONG lIndex, IWbemClassObject* pWmiObject )
{
	// local variables
	HRESULT hr;
	CHString str;
	CHString strPath;
	CHString strDomain;
	CHString strUserName;
	IWbemClassObject* pOutParams = NULL;

	// set the default value
	DynArraySetString2( m_arrTasks, lIndex, TASK_USERNAME, V_NOT_AVAILABLE, 0 );

	// check if user name has to be retrieved or not
	if ( m_bNeedUserContextInfo == FALSE )
		return;

	//
	// for getting the user first we will try with API
	// it at all API fails, we will try to get the same information from WMI
	//
	try
	{
		// get the user name
		str = V_NOT_AVAILABLE;
		if ( LoadUserNameFromWinsta( strDomain, strUserName ) == TRUE )
		{
			// format the user name
			str.Format( L"%s\\%s", strDomain, strUserName );
		}
		else
		{
			// user name has to be retrieved - get the path of the current object
			hr = PropertyGet( pWmiObject, WIN32_PROCESS_SYSPROPERTY_PATH, strPath );
			if ( FAILED( hr ) || strPath.GetLength() == 0 )
				return;
			
			// execute the GetOwner method and get the user name
			// under which the current process is executing
			hr = m_pWbemServices->ExecMethod( _bstr_t( strPath ), 
				_bstr_t( WIN32_PROCESS_METHOD_GETOWNER ), 0, NULL, NULL, &pOutParams, NULL );
			if ( FAILED( hr ) )
				return;
			
			// get the domain and user values from out params object
			// NOTE: do not check the results
			PropertyGet( pOutParams, GETOWNER_RETURNVALUE_DOMAIN, strDomain, L"" );
			PropertyGet( pOutParams, GETOWNER_RETURNVALUE_USER, strUserName, L"" );
			
			// get the value
			str = V_NOT_AVAILABLE;
			if ( strDomain.GetLength() != 0 )
				str.Format( L"%s\\%s", strDomain, strUserName );
			else if ( strUserName.GetLength() != 0 )
				str = strUserName;
		}

		// the formatted username might contain the UPN format user name
		// so ... remove that part
		if ( str.Find( L"@" ) != -1 )
		{
			// sub-local 
			LONG lPos = 0;
			CHString strTemp;

			// get the position
			lPos = str.Find( L"@" );
			strTemp = str.Left( lPos );
			str = strTemp;
		}
	}
	catch( ... )
	{
		return;
	}

	// save the info
	DynArraySetString2( m_arrTasks, lIndex, TASK_USERNAME, str, 0 );
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
VOID CTaskList::SetCPUTime( LONG lIndex, IWbemClassObject* pWmiObject )
{
	// local variables
	CHString str;
	BOOL bResult = FALSE;
	ULONGLONG ullCPUTime = 0;
	ULONGLONG ullUserTime = 0;
	ULONGLONG ullKernelTime = 0;

 	// get the KernelModeTime value
	bResult = PropertyGet( pWmiObject, WIN32_PROCESS_PROPERTY_KERNELMODETIME, ullKernelTime );

	// get the user mode time
	bResult = PropertyGet( pWmiObject, WIN32_PROCESS_PROPERTY_USERMODETIME, ullUserTime );

	// calculate the CPU time
	ullCPUTime = ullUserTime + ullKernelTime;

	// now convert the long time into hours format
	TIME_FIELDS time;
	ZeroMemory( &time, sizeof( TIME_FIELDS ) );
    RtlTimeToElapsedTimeFields ( (LARGE_INTEGER* ) &ullCPUTime, &time );

	// convert the days into hours
    time.Hour = static_cast<CSHORT>( time.Hour + static_cast<SHORT>( time.Day * 24 ) );
    
	// prepare into time format ( user locale specific time seperator )
    str.Format( L"%d%s%02d%s%02d", 
		time.Hour, m_strTimeSep, time.Minute, m_strTimeSep, time.Second );

	// save the info
	DynArraySetString2( m_arrTasks, lIndex, TASK_CPUTIME, str, 0 );
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
VOID CTaskList::SetWindowTitle( LONG lIndex, IWbemClassObject* pWmiObject )
{
	// local variables
	CHString str;
	LONG lTemp = 0;
	LPCWSTR pwszTemp = NULL;

	// get the window details ... window station, desktop, window title
	// NOTE: This will work only for local system
	lTemp = DynArrayFindDWORDEx( m_arrWindowTitles, CTaskList::twiProcessId, m_dwProcessId );
	if ( lTemp != -1 )
	{
		pwszTemp = DynArrayItemAsString2( m_arrWindowTitles, lTemp, CTaskList::twiTitle );
		if ( pwszTemp != NULL )
			str = pwszTemp;
	}

	// save the info
	DynArraySetString2( m_arrTasks, lIndex, TASK_WINDOWTITLE, str, 0 );
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
VOID CTaskList::SetStatus( LONG lIndex, IWbemClassObject* pWmiObject )
{
	// local variables
	DWORD dwThreads = 0;

	// set the default value
	DynArraySetString2( m_arrTasks, lIndex, TASK_STATUS, V_NOT_AVAILABLE, 0 );

	// get the threads count for the process
	if ( PropertyGet( pWmiObject, WIN32_PROCESS_PROPERTY_THREADS, dwThreads ) == FALSE )
		return;

	// now determine the status
	if ( dwThreads > 0 )
		DynArraySetString2( m_arrTasks, lIndex, TASK_STATUS, VALUE_RUNNING, 0 );
	else
		DynArraySetString2( m_arrTasks, lIndex, TASK_STATUS, VALUE_NOTRESPONDING, 0 );
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
VOID CTaskList::SetSession( LONG lIndex, IWbemClassObject* pWmiObject )
{
	// local variables
	CHString str;
	DWORD dwSessionId = 0;

	// set the default value
	DynArraySetString2( m_arrTasks, lIndex, TASK_SESSION, V_NOT_AVAILABLE, 0 );
	DynArraySetString2( m_arrTasks, lIndex, TASK_SESSIONNAME, L"", 0 );

	// get the threads count for the process
	if ( PropertyGet( pWmiObject, WIN32_PROCESS_PROPERTY_SESSION, dwSessionId ) == FALSE )
		return;

	// get the session id in string format
	str.Format( L"%d", dwSessionId );

	try
	{
		// save the id
		DynArraySetString2( m_arrTasks, lIndex, TASK_SESSION, str, 0 );
		
		// get the session name
		if ( m_bLocalSystem == TRUE || ( m_bLocalSystem == FALSE && m_hServer != NULL ) )
		{
			// sub-local variables
			LPWSTR pwsz = NULL;
			
			// get the buffer
			pwsz = str.GetBufferSetLength( WINSTATIONNAME_LENGTH + 1 );
			
			// get the name for the session
			if ( WinStationNameFromLogonIdW( m_hServer, dwSessionId, pwsz ) == FALSE )
				return;				// failed in getting the winstation/session name ... return
			
			// release buffer
			str.ReleaseBuffer();
			
			// save the session name ... do this only if session name is not empty
			if ( str.GetLength() != 0 )
				DynArraySetString2( m_arrTasks, lIndex, TASK_SESSIONNAME, str, 0 );
		}
	}
	catch( ... )
	{
		// simply return
		return;
	}
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
VOID CTaskList::SetMemUsage( LONG lIndex, IWbemClassObject* pWmiObject )
{
	// local variables
	CHString str;
	LONG lTemp = 0;
	NUMBERFMTW nfmtw;
	NTSTATUS ntstatus;
	ULONGLONG ullMemUsage = 0;
	LARGE_INTEGER liTemp = { 0, 0 };
	CHAR szTempBuffer[ 33 ] = "\0";
	WCHAR wszNumberStr[ 33 ] = L"\0";

	try
	{
		// NOTE:
		// ----
		// The max. value of 
		// (2 ^ 64) - 1 = "18,446,744,073,709,600,000 K"  (29 chars).
		// 
		// so, the buffer size to store the number is fixed as 32 characters 
		// which is more than the 29 characters in actuals
		
		// set the default value
		DynArraySetString2( m_arrTasks, lIndex, TASK_MEMUSAGE, V_NOT_AVAILABLE, 0 );
		
		// get the KernelModeTime value
		if ( PropertyGet( pWmiObject, WIN32_PROCESS_PROPERTY_MEMUSAGE, ullMemUsage ) == FALSE )
			return;
		
		// convert the value into K Bytes
		ullMemUsage /= 1024;
		
		// now again convert the value from ULONGLONG to string and check the result
		liTemp.QuadPart = ullMemUsage;
		ntstatus = RtlLargeIntegerToChar( &liTemp, 10, SIZE_OF_ARRAY( szTempBuffer ), szTempBuffer );
		if ( ! NT_SUCCESS( ntstatus ) )
			return;
		
		// now copy this info into UNICODE buffer
		str = szTempBuffer;
		
		//
		// prepare to Format the number with commas according to locale conventions.
		nfmtw.NumDigits = 0;
		nfmtw.LeadingZero = 0;
		nfmtw.NegativeOrder = 0;
		nfmtw.Grouping = m_dwGroupSep;
		nfmtw.lpDecimalSep = m_strGroupThousSep.GetBuffer( m_strGroupThousSep.GetLength() );
		nfmtw.lpThousandSep = m_strGroupThousSep.GetBuffer( m_strGroupThousSep.GetLength() );
		
		// convert the value
		lTemp = GetNumberFormatW( LOCALE_USER_DEFAULT, 
			0, str, &nfmtw, wszNumberStr, SIZE_OF_ARRAY( wszNumberStr ) );
		
		// get the session id in string format
		str.Format( FMT_KILOBYTE, wszNumberStr );
		
		// save the id
		DynArraySetString2( m_arrTasks, lIndex, TASK_MEMUSAGE, str, 0 );
	}
	catch( ... )
	{
		SetLastError( E_OUTOFMEMORY );
		SaveLastError();
	}
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
VOID CTaskList::SetServicesInfo( LONG lIndex, IWbemClassObject* pWmiObject )
{
	// local variables
	HRESULT hr;
	CHString strQuery;
	CHString strService;
	ULONG ulReturned = 0;
	BOOL bResult = FALSE;
	BOOL bCanExit = FALSE;
	TARRAY arrServices = NULL;
	IEnumWbemClassObject* pEnumServices = NULL;
	IWbemClassObject* pObjects[ MAX_ENUM_SERVICES ];

	// check whether we need to gather services info or not .. if not skip
	if ( m_bNeedServicesInfo == FALSE )
		return;

	// create array
	arrServices = CreateDynamicArray();
	if ( arrServices == NULL )
	{
		SetLastError( E_OUTOFMEMORY );
		SaveLastError();
		return;
	}

	//
	// for getting the services info first we will try with the one we got from API
	// it at all API fails, we will try to get the same information from WMI
	//

	// check whether API returned services or not
	if ( m_pServicesInfo != NULL )
	{
		// get the service names related to the current process
		// identify all the services related to the current process ( based on the PID )
		// and save the info
		for ( DWORD dw = 0; dw < m_dwServicesCount; dw++ )
		{
			// compare the PID's
			if ( m_dwProcessId == m_pServicesInfo[ dw ].ServiceStatusProcess.dwProcessId )
			{
				// this service is related with the current process ... store service name
				DynArrayAppendString( arrServices, m_pServicesInfo[ dw ].lpServiceName, 0 );
			}
		}
	}
	else
	{
		try
		{
			// init the objects to NULL's
			for( DWORD dw = 0; dw < MAX_ENUM_SERVICES; dw++ )
				pObjects[ dw ] = NULL;
			
			// prepare the query
			strQuery.Format( WMI_SERVICE_QUERY, m_dwProcessId );
			
			// execute the query
			hr = m_pWbemServices->ExecQuery( _bstr_t( WMI_QUERY_TYPE ), _bstr_t( strQuery ), 
				WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY, NULL, &pEnumServices );
			
			// check the result
			if ( FAILED( hr ) )
				_com_issue_error( hr );
			
			// set the security
			hr = SetInterfaceSecurity( pEnumServices, m_pAuthIdentity );
			if ( FAILED( hr ) )
				_com_issue_error( hr );
			
			// loop thru the service instances 
			do
			{
				// get the object ... wait 
				// NOTE: one-by-one
				hr = pEnumServices->Next( WBEM_INFINITE, MAX_ENUM_SERVICES, pObjects, &ulReturned );
				if ( hr == WBEM_S_FALSE )
				{
					// we've reached the end of enumeration .. set the flag 
					bCanExit = TRUE;
				}
				else if ( hr == WBEM_S_TIMEDOUT || FAILED( hr ) )
				{
					//
					// some error has occured ... oooppps
			
					// exit from the loop
					break;
				}
			
				// loop thru the objects and save the info
				for( ULONG ul = 0; ul < ulReturned; ul++ )
				{
					// get the value of the property
					bResult = PropertyGet( pObjects[ ul ], WIN32_SERVICE_PROPERTY_NAME, strService );
					if (  bResult == TRUE )
						DynArrayAppendString( arrServices, strService, 0 );
			
					// release the interface
					SAFE_RELEASE( pObjects[ ul ] );
				}
			} while ( bCanExit == FALSE );
		}
		catch( _com_error& e )
		{
			// save the error
			WMISaveError( e );
		}

		// release the objects to NULL's
		for( DWORD dw = 0; dw < MAX_ENUM_SERVICES; dw++ )
		{
			// release all the objects
			SAFE_RELEASE( pObjects[ dw ] );
		}

		// now release the enumeration object
		SAFE_RELEASE( pEnumServices );
	}

	// save and return
	DynArraySetEx2( m_arrTasks, lIndex, TASK_SERVICES, arrServices );
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
BOOL CTaskList::SetModulesInfo( LONG lIndex, IWbemClassObject* pWmiObject )
{
	// local variables
	LONG lPos = 0;
	BOOL bResult = FALSE;
	TARRAY arrModules = NULL;

	// check whether we need to get the modules or not
	if ( m_bNeedModulesInfo == FALSE )
		return TRUE;

	// allocate for memory
	arrModules = CreateDynamicArray();
	if ( arrModules == NULL )
	{
		SetLastError( E_OUTOFMEMORY );
		SaveLastError();
		return FALSE;
	}

	// the way we get the modules information is different for local remote
	// so depending that call appropriate function
	if ( m_bLocalSystem == TRUE && m_bUseRemote == FALSE )
	{
			// enumerate the modules for the current process
			bResult = LoadModulesOnLocal( lIndex, arrModules );
	}
	else
	{
		// identify the modules information for the current process ... remote system
		bResult = GetModulesOnRemote( lIndex, arrModules );
	}

	// check the result
	if ( bResult == TRUE )
	{
		// check if the modules list contains the imagename also. If yes remove that entry
		lPos = DynArrayFindString( arrModules, m_strImageName, TRUE, 0 );
		if ( lPos != -1 )
		{
			// remove the entry
			DynArrayRemove( arrModules, lPos );
		}
	}

	// save the modules information to the array
	// NOTE: irrespective of whether enumeration is success or not we will add the array
	DynArraySetEx2( m_arrTasks, lIndex, TASK_MODULES, arrModules );

	// return
	return bResult;
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
BOOL CTaskList::LoadModulesOnLocal( LONG lIndex, TARRAY arrModules )
{
	// local variables
	LONG lPos = 0;
	BOOL bResult = FALSE;
	TMODULESINFO modules;
	HANDLE hProcess = NULL;

	// check the input values
	if ( arrModules == NULL )
		return FALSE;

	// open the process handle
	hProcess = OpenProcess( PROCESS_VM_READ | PROCESS_QUERY_INFORMATION, FALSE, m_dwProcessId );
	if ( hProcess == NULL )
	{
		return FALSE;								// failed in getting the process handle
	}

	// prepare the modules structure
	ZeroMemory( &modules, sizeof( TMODULESINFO ) );
	modules.dwSignature = SIGNATURE_MODULES;
	modules.dwLength = 0;
	modules.arrModules = arrModules;
	modules.pwszModule = ((m_strModules.GetLength() != 0) ? (LPCWSTR) m_strModules : NULL);
	if ( (lPos = m_strModules.Find( L"*" )) != -1 )
	{
		modules.dwLength = (DWORD) lPos;
		modules.pwszModule = m_strModules;
	}

#ifndef _WIN64
	bResult = EnumerateLoadedModules( hProcess, EnumLoadedModulesProc, &modules );
#else
	bResult = EnumerateLoadedModules64( hProcess, EnumLoadedModulesProc64, &modules );
#endif

	// close the process handle .. we dont need this furthur
	CloseHandle( hProcess );
	hProcess = NULL;

	// return
	return bResult;
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
BOOL CTaskList::GetModulesOnRemote( LONG lIndex, TARRAY arrModules )
{
	// local variables
	LONG lPos = 0;
	DWORD dwLength = 0;
	DWORD dwOffset = 0;
	DWORD dwInstance = 0;
	PPERF_OBJECT_TYPE pot = NULL;
	PPERF_OBJECT_TYPE potImages = NULL;
	PPERF_INSTANCE_DEFINITION pidImages = NULL;
	PPERF_COUNTER_BLOCK pcbImages = NULL;
	PPERF_OBJECT_TYPE potAddressSpace = NULL;
	PPERF_INSTANCE_DEFINITION pidAddressSpace = NULL;
	PPERF_COUNTER_BLOCK pcbAddressSpace = NULL;
    PPERF_COUNTER_DEFINITION pcd = NULL;

	// check the input values
	if ( arrModules == NULL )
		return FALSE;

	// check whether the performance object exists or not
	// if doesn't exists, get the same using WMI
	if ( m_pdb == NULL )
	{
		// invoke the WMI method
		return GetModulesOnRemoteEx( lIndex, arrModules );
	}

	// get the perf object types
    pot = (PPERF_OBJECT_TYPE) ( (LPBYTE) m_pdb + m_pdb->HeaderLength );
	for( DWORD dw = 0; dw < m_pdb->NumObjectTypes; dw++ )
	{
		if ( pot->ObjectNameTitleIndex == 740 )
			potImages = pot;
		else if ( pot->ObjectNameTitleIndex == 786 )
			potAddressSpace = pot;

		// move to the next object
		dwOffset = pot->TotalByteLength;
		if( dwOffset != 0 )
			pot = ( (PPERF_OBJECT_TYPE) ((PBYTE) pot + dwOffset));
	}

	// check whether we got both the object types or not
	if ( potImages == NULL || potAddressSpace == NULL )
		return FALSE;

	// find the offset of the process id in the address space object type
    // get the first counter definition of address space object
    pcd = (PPERF_COUNTER_DEFINITION) ( (LPBYTE) potAddressSpace + potAddressSpace->HeaderLength);

	// loop thru the counters and find the offset
	dwOffset = 0;
    for( DWORD dw = 0; dw < potAddressSpace->NumCounters; dw++)
    {
        // 784 is the counter for process id
        if ( pcd->CounterNameTitleIndex == 784 )
        {
            dwOffset = pcd->CounterOffset;
            break;
        }

        // next counter
        pcd = ( (PPERF_COUNTER_DEFINITION) ( (LPBYTE) pcd + pcd->ByteLength) );
    }

	// check whether we got the offset or not
	// if not, we are unsuccessful
	if ( dwOffset == 0 )
	{
		// set the error message
		SetLastError( ERROR_ACCESS_DENIED );
		SaveLastError();
		return FALSE;
	}

	// get the instances
	pidImages = (PPERF_INSTANCE_DEFINITION) ( (LPBYTE) potImages + potImages->DefinitionLength );
	pidAddressSpace = (PPERF_INSTANCE_DEFINITION) ( (LPBYTE) potAddressSpace + potAddressSpace->DefinitionLength );

	// counter blocks
	pcbImages = (PPERF_COUNTER_BLOCK) ( (LPBYTE) pidImages + pidImages->ByteLength );
	pcbAddressSpace = (PPERF_COUNTER_BLOCK) ( (LPBYTE) pidAddressSpace + pidAddressSpace->ByteLength );

	// find the instance number of the process which we are looking for
	for( dwInstance = 0; dwInstance < (DWORD) potAddressSpace->NumInstances; dwInstance++ )
	{
		// sub-local variables
		DWORD dwProcessId = 0;

		// get the process id
		dwProcessId = *((DWORD*) ( (LPBYTE) pcbAddressSpace + dwOffset ));

		// now check if this is the process which we are looking for
		if ( dwProcessId == m_dwProcessId )
			break;

		// continue looping thru other instances
		pidAddressSpace = (PPERF_INSTANCE_DEFINITION) ( (LPBYTE) pcbAddressSpace + pcbAddressSpace->ByteLength );
		pcbAddressSpace = (PPERF_COUNTER_BLOCK) ( (LPBYTE) pidAddressSpace + pidAddressSpace->ByteLength );
	}

	// check whether we got the instance or not
	// if not, there are no modules for this process
	if ( dwInstance == potAddressSpace->NumInstances )
		return TRUE;

	//determine the length of the module name .. 
	dwLength = 0;
	if ( (lPos = m_strModules.Find( L"*" )) != -1 )
		dwLength = (DWORD) lPos;

	// now based the parent instance, collect all the modules
    for( DWORD dw = 0; (LONG) dw < potImages->NumInstances; dw++)
    {
		// check the parent object instance number
		if ( pidImages->ParentObjectInstance == dwInstance )
		{
			try
			{
				// sub-local variables
				CHString str;
				LPWSTR pwszTemp;

				// get the buffer
				pwszTemp = str.GetBufferSetLength( pidImages->NameLength + 10 );		// +10 to be on safe side
				if ( pwszTemp == NULL )
				{
					SetLastError( E_OUTOFMEMORY );
					SaveLastError();
					return FALSE;
				}

				// get the instance name
				lstrcpyn( pwszTemp, (LPWSTR) ( (LPBYTE) pidImages + pidImages->NameOffset ), pidImages->NameLength + 1 );

				// release buffer
				str.ReleaseBuffer();

				// check whether this module needs to be added to the list
				if ( m_strModules.GetLength() == 0 || StringCompare( str, m_strModules, TRUE, dwLength ) == 0 )
				{
					// add the info the userdata ( for us we will get that in the form of an array
					lIndex = DynArrayAppendString( arrModules, str, 0 );
					if ( lIndex == -1 )
					{
						// append is failed .. this could be because of lack of memory .. stop the enumeration
						return FALSE;
					}
				}
			}
			catch( ... )
			{
				SetLastError( E_OUTOFMEMORY );
				SaveLastError();
				return FALSE;
			}
		}

		// continue looping thru other instances
		pidImages = (PPERF_INSTANCE_DEFINITION) ( (LPBYTE) pcbImages + pcbImages->ByteLength );
		pcbImages = (PPERF_COUNTER_BLOCK) ( (LPBYTE) pidImages + pidImages->ByteLength );
    }

    return TRUE;
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
BOOL CTaskList::GetModulesOnRemoteEx( LONG lIndex, TARRAY arrModules )
{
	// local variables
	HRESULT hr;
	LONG lPos = 0;
	BOOL bStatus = FALSE;
	DWORD dwLength = 0;
	CHString strQuery;
	CHString strModule;
	CHString strMessage;
	CHString strFileName;
	CHString strExtension;
	ULONG ulReturned = 0;
	BOOL bResult = FALSE;
	BOOL bCanExit = FALSE;
	LPCWSTR pwszPath = NULL;
	IEnumWbemClassObject* pEnumServices = NULL;
	IWbemClassObject* pObjects[ MAX_ENUM_MODULES ];

	// check the input values
	if ( arrModules == NULL )
		return FALSE;

	// get the path of the object from the tasks array
	pwszPath = DynArrayItemAsString2( m_arrTasks, lIndex, TASK_OBJPATH );
	if ( pwszPath == NULL )
		return FALSE;

	//determine the length of the module name .. 
	dwLength = 0;
	if ( (lPos = m_strModules.Find( L"*" )) != -1 )
		dwLength = (DWORD) lPos;

	try
	{
		// init the objects to NULL's
		for( DWORD dw = 0; dw < MAX_ENUM_MODULES; dw++ )
			pObjects[ dw ] = NULL;
		
		// prepare the query
		strQuery.Format( WMI_MODULES_QUERY, pwszPath );

		// preare and display the status message
		bStatus = TRUE;
		strMessage.Format( MSG_MODULESINFO_EX, m_dwProcessId );
		PrintProgressMsg( m_hOutput, strMessage + L" --", m_csbi );
		
		// execute the query
		hr = m_pWbemServices->ExecQuery( _bstr_t( WMI_QUERY_TYPE ), _bstr_t( strQuery ), 
			WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY, NULL, &pEnumServices );
		
		// check the result
		if ( FAILED( hr ) )
			_com_issue_error( hr );
		
		// set the security
		hr = SetInterfaceSecurity( pEnumServices, m_pAuthIdentity );
		if ( FAILED( hr ) )
			_com_issue_error( hr );
		
		// loop thru the instances 
		do
		{
			// get the object ... wait 
			// NOTE: one-by-one
			hr = pEnumServices->Next( WBEM_INFINITE, MAX_ENUM_MODULES, pObjects, &ulReturned );
			if ( hr == WBEM_S_FALSE )
			{
				// we've reached the end of enumeration .. set the flag 
				bCanExit = TRUE;
			}
			else if ( hr == WBEM_S_TIMEDOUT || FAILED( hr ))
			{
				// some error has occured ... oooppps
				WMISaveError( hr );
				SetLastError( STG_E_UNKNOWN );
				break;
			}

			// reset the counter
			bStatus = bStatus ? FALSE : TRUE;
			PrintProgressMsg( m_hOutput, strMessage + (( bStatus ) ? L" --" : L" |"), m_csbi );

			// loop thru the objects and save the info
			for( ULONG ul = 0; ul < ulReturned; ul++ )
			{
				// get the file name
				bResult = PropertyGet( pObjects[ ul ], CIM_DATAFILE_PROPERTY_FILENAME, strFileName );
				if ( bResult == FALSE )
					continue;

				// get the extension
				bResult = PropertyGet( pObjects[ ul ], CIM_DATAFILE_PROPERTY_EXTENSION, strExtension );
				if ( bResult == FALSE )
					continue;

				// format the module name
				strModule.Format( L"%s.%s", strFileName, strExtension );

				// check whether this module needs to be added to the list
				if ( m_strModules.GetLength() == 0 || StringCompare( strModule, m_strModules, TRUE, dwLength ) == 0 )
				{
					// add the info the userdata ( for us we will get that in the form of an array
					lIndex = DynArrayAppendString( arrModules, strModule, 0 );
					if ( lIndex == -1 )
					{
						// append is failed .. this could be because of lack of memory .. stop the enumeration
						return FALSE;
					}
				}

				// release the interface
				SAFE_RELEASE( pObjects[ ul ] );
			}
		} while ( bCanExit == FALSE );
	}
	catch( _com_error& e )
	{
		// save the error
		WMISaveError( e );
		return FALSE;
	}
	catch( ... )
	{
		// out of memory
		WMISaveError( E_OUTOFMEMORY );
		return FALSE;
	}

	// release the objects to NULL's
	for( DWORD dw = 0; dw < MAX_ENUM_MODULES; dw++ )
	{
		// release all the objects
		SAFE_RELEASE( pObjects[ dw ] );
	}

	// now release the enumeration object
	SAFE_RELEASE( pEnumServices );

	// return 
    return TRUE;
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
#ifndef _WIN64
BOOL EnumLoadedModulesProc( LPSTR lpszModuleName, ULONG ulModuleBase, ULONG ulModuleSize, PVOID pUserData )
#else
BOOL EnumLoadedModulesProc64( LPSTR lpszModuleName, DWORD64 ulModuleBase, ULONG ulModuleSize, PVOID pUserData )
#endif
{
	// local variables
	CHString str;
	LONG lIndex = 0;
	TARRAY arrModules = NULL;
	PTMODULESINFO pModulesInfo = NULL;

	// check the input values
	if ( lpszModuleName == NULL || pUserData == NULL )
		return FALSE;

	// check the internal array info
	pModulesInfo = (PTMODULESINFO) pUserData;
	if ( pModulesInfo->dwSignature != SIGNATURE_MODULES || pModulesInfo->arrModules == NULL )
		return FALSE;

	// get the array pointer into the local variable
	arrModules = (TARRAY) pModulesInfo->arrModules;

	try
	{
		// copy the module name into the local string variable 
		// ( conversion from multibyte to unicode will automatically take place )
		str = lpszModuleName;

		// check whether this module needs to be added to the list
		if ( pModulesInfo->pwszModule == NULL || 
			 StringCompare( str, pModulesInfo->pwszModule, TRUE, pModulesInfo->dwLength ) == 0 )
		{
			// add the info the userdata ( for us we will get that in the form of an array
			lIndex = DynArrayAppendString( arrModules, str, 0 );
			if ( lIndex == -1 )
			{
				// append is failed .. this could be because of lack of memory .. stop the enumeration
				return FALSE;
			}
		}
	}
	catch( ... )
	{
			// out of memory stop the enumeration
			return FALSE;
	}

	// success .. continue the enumeration
	return TRUE;
}

// ***************************************************************************
// Routine Description:
//		prpepares the columns information
//		
// Arguments:
//		[ in ] bVerbose		: informs whether preparation has to be done for verbose display
//		[ out ] pColumns	: filled with columns information like, thier o/p type, position,
//							  width, heading etc
// Return Value:
//		NONE
// 
// ***************************************************************************
VOID CTaskList::PrepareColumns()
{
	// local variables
	PTCOLUMNS pCurrentColumn = NULL;

	// host name
	pCurrentColumn = m_pColumns + CI_HOSTNAME;
	pCurrentColumn->dwWidth = COLWIDTH_HOSTNAME;
	pCurrentColumn->dwFlags = SR_TYPE_STRING | SR_HIDECOLUMN;
	pCurrentColumn->pFunction = NULL;
	pCurrentColumn->pFunctionData = NULL;
	lstrcpy( pCurrentColumn->szFormat, NULL_STRING );
	lstrcpy( pCurrentColumn->szColumn, COLHEAD_HOSTNAME );

	// status
	pCurrentColumn = m_pColumns + CI_STATUS;
	pCurrentColumn->dwWidth = COLWIDTH_STATUS;
	pCurrentColumn->dwFlags = SR_TYPE_STRING | SR_HIDECOLUMN;
	pCurrentColumn->pFunction = NULL;
	pCurrentColumn->pFunctionData = NULL;
	lstrcpy( pCurrentColumn->szFormat, NULL_STRING );
	lstrcpy( pCurrentColumn->szColumn, COLHEAD_STATUS );

	// image name
	pCurrentColumn = m_pColumns + CI_IMAGENAME;
	pCurrentColumn->dwWidth = COLWIDTH_IMAGENAME;
	pCurrentColumn->dwFlags = SR_TYPE_STRING | SR_HIDECOLUMN;
	pCurrentColumn->pFunction = NULL;
	pCurrentColumn->pFunctionData = NULL;
	lstrcpy( pCurrentColumn->szFormat, NULL_STRING );
	lstrcpy( pCurrentColumn->szColumn, COLHEAD_IMAGENAME );

	// pid
	pCurrentColumn = m_pColumns + CI_PID;
	pCurrentColumn->dwWidth = COLWIDTH_PID;
	pCurrentColumn->dwFlags = SR_TYPE_NUMERIC | SR_HIDECOLUMN;
	pCurrentColumn->pFunction = NULL;
	pCurrentColumn->pFunctionData = NULL;
	lstrcpy( pCurrentColumn->szFormat, NULL_STRING );
	lstrcpy( pCurrentColumn->szColumn, COLHEAD_PID );

	// session name
	pCurrentColumn = m_pColumns + CI_SESSIONNAME;
	pCurrentColumn->dwWidth = COLWIDTH_SESSIONNAME;
	pCurrentColumn->dwFlags = SR_TYPE_STRING | SR_HIDECOLUMN;
	pCurrentColumn->pFunction = NULL;
	pCurrentColumn->pFunctionData = NULL;
	lstrcpy( pCurrentColumn->szFormat, NULL_STRING );
	lstrcpy( pCurrentColumn->szColumn, COLHEAD_SESSIONNAME );

	// session#
	pCurrentColumn = m_pColumns + CI_SESSION;
	pCurrentColumn->dwWidth = COLWIDTH_SESSION;
	pCurrentColumn->dwFlags = SR_TYPE_STRING | SR_ALIGN_LEFT | SR_HIDECOLUMN;
	pCurrentColumn->pFunction = NULL;
	pCurrentColumn->pFunctionData = NULL;
	lstrcpy( pCurrentColumn->szFormat, NULL_STRING );
	lstrcpy( pCurrentColumn->szColumn, COLHEAD_SESSION );

	// window name
	pCurrentColumn = m_pColumns + CI_WINDOWTITLE;
	pCurrentColumn->dwWidth = COLWIDTH_WINDOWTITLE;
	pCurrentColumn->dwFlags = SR_TYPE_STRING | SR_HIDECOLUMN | SR_SHOW_NA_WHEN_BLANK;
	pCurrentColumn->pFunction = NULL;
	pCurrentColumn->pFunctionData = NULL;
	lstrcpy( pCurrentColumn->szFormat, NULL_STRING );
	lstrcpy( pCurrentColumn->szColumn, COLHEAD_WINDOWTITLE );

	// user name
	pCurrentColumn = m_pColumns + CI_USERNAME;
	pCurrentColumn->dwWidth = COLWIDTH_USERNAME;
	pCurrentColumn->dwFlags = SR_TYPE_STRING | SR_HIDECOLUMN;
	pCurrentColumn->pFunction = NULL;
	pCurrentColumn->pFunctionData = NULL;
	lstrcpy( pCurrentColumn->szFormat, NULL_STRING );
	lstrcpy( pCurrentColumn->szColumn, COLHEAD_USERNAME );

	// cpu time
	pCurrentColumn = m_pColumns + CI_CPUTIME;
	pCurrentColumn->dwWidth = COLWIDTH_CPUTIME;
	pCurrentColumn->dwFlags = SR_TYPE_STRING | SR_ALIGN_LEFT | SR_HIDECOLUMN;
	pCurrentColumn->pFunction = NULL;
	pCurrentColumn->pFunctionData = NULL;
	lstrcpy( pCurrentColumn->szFormat, NULL_STRING );
	lstrcpy( pCurrentColumn->szColumn, COLHEAD_CPUTIME );

	// mem usage
	pCurrentColumn = m_pColumns + CI_MEMUSAGE;
	pCurrentColumn->dwWidth = COLWIDTH_MEMUSAGE;
	pCurrentColumn->dwFlags = SR_TYPE_STRING | SR_ALIGN_LEFT | SR_HIDECOLUMN;
	pCurrentColumn->pFunction = NULL;
	pCurrentColumn->pFunctionData = NULL;
	lstrcpy( pCurrentColumn->szFormat, NULL_STRING );
	lstrcpy( pCurrentColumn->szColumn, COLHEAD_MEMUSAGE );

	// services
	pCurrentColumn = m_pColumns + CI_SERVICES;
	pCurrentColumn->dwWidth = COLWIDTH_MODULES_WRAP;
	pCurrentColumn->dwFlags = SR_ARRAY | SR_TYPE_STRING | SR_NO_TRUNCATION | SR_HIDECOLUMN | SR_SHOW_NA_WHEN_BLANK;
	pCurrentColumn->pFunction = NULL;
	pCurrentColumn->pFunctionData = NULL;
	lstrcpy( pCurrentColumn->szFormat, NULL_STRING );
	lstrcpy( pCurrentColumn->szColumn, COLHEAD_SERVICES );

	// modules
	pCurrentColumn = m_pColumns + CI_MODULES;
	pCurrentColumn->dwWidth = COLWIDTH_MODULES_WRAP;
	pCurrentColumn->dwFlags = SR_ARRAY | SR_TYPE_STRING | SR_NO_TRUNCATION | SR_HIDECOLUMN | SR_SHOW_NA_WHEN_BLANK;
	pCurrentColumn->pFunction = NULL;
	pCurrentColumn->pFunctionData = NULL;
	lstrcpy( pCurrentColumn->szFormat, NULL_STRING );
	lstrcpy( pCurrentColumn->szColumn, COLHEAD_MODULES );

	// 
	// based on the option selected by the user .. show only needed columns
	if ( m_bAllServices == TRUE )
	{
		( m_pColumns + CI_IMAGENAME )->dwFlags &= ~( SR_HIDECOLUMN );
		( m_pColumns + CI_PID )->dwFlags &= ~( SR_HIDECOLUMN );
		( m_pColumns + CI_SERVICES )->dwFlags &= ~( SR_HIDECOLUMN );
	}
	else if ( m_bAllModules == TRUE )
	{
		( m_pColumns + CI_IMAGENAME )->dwFlags &= ~( SR_HIDECOLUMN );
		( m_pColumns + CI_PID )->dwFlags &= ~( SR_HIDECOLUMN );
		( m_pColumns + CI_MODULES )->dwFlags &= ~( SR_HIDECOLUMN );
	}
	else
	{
		// default ... enable min. columns
		( m_pColumns + CI_IMAGENAME )->dwFlags &= ~( SR_HIDECOLUMN );
		( m_pColumns + CI_PID )->dwFlags &= ~( SR_HIDECOLUMN );
		( m_pColumns + CI_SESSIONNAME )->dwFlags &= ~( SR_HIDECOLUMN );
		( m_pColumns + CI_SESSION )->dwFlags &= ~( SR_HIDECOLUMN );
		( m_pColumns + CI_MEMUSAGE )->dwFlags &= ~( SR_HIDECOLUMN );

		// check if verbose option is specified .. show other columns
		if ( m_bVerbose == TRUE )
		{
			( m_pColumns + CI_STATUS )->dwFlags &= ~( SR_HIDECOLUMN );
			( m_pColumns + CI_USERNAME )->dwFlags &= ~( SR_HIDECOLUMN );
			( m_pColumns + CI_CPUTIME )->dwFlags &= ~( SR_HIDECOLUMN );
			( m_pColumns + CI_WINDOWTITLE )->dwFlags &= ~( SR_HIDECOLUMN );
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cmdline\tasklist\resource.h ===
#define IDS_COLHEAD_HOSTNAME				101
#define IDS_COLHEAD_STATUS					102
#define IDS_COLHEAD_IMAGENAME				103
#define IDS_COLHEAD_PID						104
#define IDS_COLHEAD_SESSION					105
#define IDS_COLHEAD_USERNAME				106
#define IDS_COLHEAD_WINDOWTITLE				107
#define IDS_COLHEAD_CPUTIME					108
#define IDS_COLHEAD_MEMUSAGE				109
#define IDS_COLHEAD_SERVICES				110
#define IDS_COLHEAD_SESSIONNAME				111
#define IDS_COLHEAD_MODULES					112

#define IDS_TEXT_FORMAT_LIST				126
#define IDS_TEXT_FORMAT_TABLE				127
#define IDS_TEXT_FORMAT_CSV					128
#define IDS_OVALUES_FORMAT					129

#define IDS_COLWIDTH_HOSTNAME				151
#define IDS_COLWIDTH_STATUS					152
#define IDS_COLWIDTH_IMAGENAME				153
#define IDS_COLWIDTH_PID					154
#define IDS_COLWIDTH_SESSION				155
#define IDS_COLWIDTH_USERNAME				156
#define IDS_COLWIDTH_WINDOWTITLE			157
#define IDS_COLWIDTH_CPUTIME				158
#define IDS_COLWIDTH_MEMUSAGE				159
#define IDS_COLWIDTH_SERVICES				160
#define IDS_COLWIDTH_SERVICES_WRAP			161
#define IDS_COLWIDTH_SESSIONNAME			162
#define IDS_COLWIDTH_MODULES				163
#define IDS_COLWIDTH_MODULES_WRAP			164

#define IDS_FILTER_SESSIONNAME				201
#define IDS_FILTER_STATUS					202
#define IDS_FILTER_IMAGENAME				203
#define IDS_FILTER_PID						204
#define IDS_FILTER_SESSION					205
#define IDS_FILTER_CPUTIME					206
#define IDS_FILTER_MEMUSAGE					207
#define IDS_FILTER_USERNAME					208
#define IDS_FILTER_SERVICES					209
#define IDS_FILTER_WINDOWTITLE				210
#define IDS_FILTER_MODULES					211

#define IDS_FVALUES_STATUS					226

#define IDS_OPERATORS_STRING				227
#define IDS_OPERATORS_NUMERIC				228

#define IDS_VALUE_RUNNING					251
#define IDS_VALUE_NOTRESPONDING				252
#define IDS_FMT_KILOBYTE					253
#define IDS_PID_0_DOMAIN					254
#define IDS_PID_0_USERNAME					255
#define IDS_FMT_MODULES_FILTER				256

#define IDS_ERROR_USERNAME_BUT_NOMACHINE	501
#define IDS_ERROR_PASSWORD_BUT_NOUSERNAME	502
#define IDS_ERROR_NODATA_AVAILABLE			503
#define IDS_ERROR_COM_ERROR					504
#define IDS_ERROR_USERNAME_EMPTY			505
#define IDS_ERROR_NH_NOTSUPPORTED			506
#define IDS_ERROR_M_SVC_V_CANNOTBECOUPLED	507
#define IDS_ERROR_SERVERNAME_EMPTY			508
#define IDS_ERROR_INVALID_USAGE_REQUEST		509
#define IDS_ERROR_M_CHAR_AFTER_WILDCARD		510

#define IDS_MSG_MODULESINFO					601
#define IDS_MSG_SERVICESINFO				602
#define IDS_MSG_TASKSINFO					603
#define IDS_MSG_MODULESINFO_EX				604

#define IDS_HELP_LINE1                  1001
#define IDS_HELP_LINE2                  1002
#define IDS_HELP_LINE3                  1003
#define IDS_HELP_LINE4                  1004
#define IDS_HELP_LINE5                  1005
#define IDS_HELP_LINE6                  1006
#define IDS_HELP_LINE7                  1007
#define IDS_HELP_LINE8                  1008
#define IDS_HELP_LINE9                  1009
#define IDS_HELP_LINE10                 1010
#define IDS_HELP_LINE11                 1011
#define IDS_HELP_LINE12                 1012
#define IDS_HELP_LINE13                 1013
#define IDS_HELP_LINE14                 1014
#define IDS_HELP_LINE15                 1015
#define IDS_HELP_LINE16                 1016
#define IDS_HELP_LINE17                 1017
#define IDS_HELP_LINE18                 1018
#define IDS_HELP_LINE19                 1019
#define IDS_HELP_LINE20                 1020
#define IDS_HELP_LINE21                 1021
#define IDS_HELP_LINE22                 1022
#define IDS_HELP_LINE23                 1023
#define IDS_HELP_LINE24                 1024
#define IDS_HELP_LINE25                 1025
#define IDS_HELP_LINE26                 1026
#define IDS_HELP_LINE27                 1027
#define IDS_HELP_LINE28                 1028
#define IDS_HELP_LINE29                 1029
#define IDS_HELP_LINE30                 1030
#define IDS_HELP_LINE31                 1031
#define IDS_HELP_LINE32                 1032
#define IDS_HELP_LINE33                 1033
#define IDS_HELP_LINE34                 1034
#define IDS_HELP_LINE35                 1035
#define IDS_HELP_LINE36                 1036
#define IDS_HELP_LINE37                 1037
#define IDS_HELP_LINE38                 1038
#define IDS_HELP_LINE39                 1039
#define IDS_HELP_LINE40                 1040
#define IDS_HELP_LINE41                 1041
#define IDS_HELP_LINE42                 1042
#define IDS_HELP_LINE43                 1043
#define IDS_HELP_LINE44                 1044
#define IDS_HELP_LINE45                 1045
#define IDS_HELP_LINE46                 1046
#define IDS_HELP_LINE47                 1047
#define IDS_HELP_LINE48                 1048
#define IDS_HELP_LINE49                 1049
#define IDS_HELP_LINE50                 1050
#define IDS_HELP_LINE51                 1051
#define IDS_HELP_LINE52                 1052
#define IDS_HELP_LINE53                 1053
#define IDS_HELP_LINE54                 1054
#define IDS_HELP_LINE55                 1055
#define IDS_HELP_LINE56                 1056
#define IDS_HELP_LINE57                 1057
#define IDS_HELP_LINE58                 1058
#define IDS_HELP_LINE59                 1059

// usage indexes into the string table
#define ID_HELP_START		IDS_HELP_LINE1
#define ID_HELP_END			IDS_HELP_LINE59
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cmdline\tasklist\tasklist.cpp ===
// *********************************************************************************
// 
//  Copyright (c) Microsoft Corporation
//  
//  Module Name:
//  
//		TaskList.cpp
//  
//  Abstract:
//  
// 		This module implements the command-line parsing the displaying the tasks
//		information current running on local and remote systems
//
//		Syntax:
//		------
//			TaskList.exe [-s server [-u username [-p password]]]
//					     [-fo format] [-fi filter] [-nh] [-v | -svc | -m]
//  
//  Author:
//  
// 		Sunil G.V.N. Murali (murali.sunil@wipro.com) 24-Sep-2000
//  
//  Revision History:
//  
// 		Sunil G.V.N. Murali (murali.sunil@wipro.com) 24-Sep-2000 : Created It.
//  
// *********************************************************************************

#include "pch.h"
#include "wmi.h"
#include "TaskList.h"

//
// local structures
//
typedef struct __tagWindowTitles
{
	LPWSTR lpDesk;
	LPWSTR lpWinsta;
	BOOL bFirstLoop;
	TARRAY arrWindows;
} TWINDOWTITLES, *PTWINDOWTITLES;

//
// private functions ... prototypes
//
BOOL CALLBACK EnumWindowsProc( HWND hWnd, LPARAM lParam );
BOOL CALLBACK EnumDesktopsFunc( LPWSTR lpstr, LPARAM lParam );
BOOL CALLBACK EnumWindowStationsFunc( LPWSTR lpstr, LPARAM lParam );
BOOL CALLBACK EnumMessageWindows( WNDENUMPROC lpEnumFunc, LPARAM lParam );
BOOL GetPerfDataBlock( HKEY hKey, LPWSTR szObjectIndex, PPERF_DATA_BLOCK* ppdb );

// ***************************************************************************
// Routine Description:
//		This the entry point to this utility.
//		  
// Arguments:
//		[ in ] argc		: argument(s) count specified at the command prompt
//		[ in ] argv		: argument(s) specified at the command prompt
//
// Return Value:
//		The below are actually not return values but are the exit values 
//		returned to the OS by this application
//			0		: utility is successfull
//			1		: utility failed
// ***************************************************************************
DWORD __cdecl _tmain( DWORD argc, LPCWSTR argv[] )
{
	// local variables
	CTaskList tasklist;

	// initialize the tasklist utility
	if ( tasklist.Initialize() == FALSE )
	{
		SHOW_MESSAGE_EX( TAG_ERROR, GetReason() );
		EXIT_PROCESS( 1 );
	}

	// now do parse the command line options
	if ( tasklist.ProcessOptions( argc, argv ) == FALSE )
	{
		SHOW_MESSAGE_EX( TAG_ERROR, GetReason() );
		EXIT_PROCESS( 1 );
	}

	// check whether usage has to be displayed or not
	if ( tasklist.m_bUsage == TRUE )
	{
		// show the usage of the utility
		tasklist.Usage();

		// quit from the utility
		EXIT_PROCESS( 0 );
	}

	// now validate the filters and check the result of the filter validation
	if ( tasklist.ValidateFilters() == FALSE )
	{
		// invalid filter
		SHOW_MESSAGE_EX( TAG_ERROR, GetReason() );

		// quit from the utility
		EXIT_PROCESS( 1 );
	}

	// connect to the server
	if ( tasklist.Connect() == FALSE )
	{
		// show the error message
		SHOW_MESSAGE_EX( TAG_ERROR, GetReason() );
		EXIT_PROCESS( 1 );
	}

	// load the data and check
	if ( tasklist.LoadTasks() == FALSE )
	{
		// show the error message
		SHOW_MESSAGE_EX( TAG_ERROR, GetReason() );

		// exit 
		EXIT_PROCESS( 1 );
	}

	// now show the tasks running on the machine
	if ( tasklist.Show() == 0 )
	{
		//
		// no tasks were shown ... display the message 

		// check if this is because of any error
		if ( GetLastError() != NO_ERROR )
		{
			SHOW_MESSAGE_EX( TAG_ERROR, GetReason() );
			EXIT_PROCESS( 1 );
		}
		else
		{
			DISPLAY_MESSAGE( stderr, ERROR_NODATA_AVAILABLE );
		}
	}

	// clean exit
	EXIT_PROCESS( 0 );
}

// ***************************************************************************
// Routine Description:
//		connects to the remote as well as remote system's WMI
//		  
// Arguments:
//		[ in ] pszServer	 : remote server name
//  
// Return Value:
//		TRUE  : if connection is successful
//		FALSE : if connection is unsuccessful
// 
// ***************************************************************************
BOOL CTaskList::Connect()
{
	// local variables
	BOOL bResult = FALSE;

	// release the existing auth identity structure
	m_bUseRemote = FALSE;
	WbemFreeAuthIdentity( &m_pAuthIdentity );

	// connect to WMI
	bResult = ConnectWmiEx( m_pWbemLocator, 
		&m_pWbemServices, m_strServer, m_strUserName, m_strPassword, 
		&m_pAuthIdentity, m_bNeedPassword, WMI_NAMESPACE_CIMV2, &m_bLocalSystem );

	// check the result of connection
	if ( bResult == FALSE )
		return FALSE;

#ifndef _WIN64
	// determine the type of the platform if modules info is required
	if ( m_bLocalSystem == TRUE && m_bNeedModulesInfo == TRUE )
	{
		// sub-local variables
		DWORD dwPlatform = 0;

		// get the platform type
		dwPlatform = GetTargetPlatformEx( m_pWbemServices, m_pAuthIdentity );

		// if the platform is not 32-bit, error
		if ( dwPlatform != PLATFORM_X86 )
		{
			// let the tool use WMI calls instead of Win32 API
			m_bUseRemote = TRUE;
		}
	}
#endif

	try
	{
		// check the local credentials and if need display warning
		if ( GetLastError() == WBEM_E_LOCAL_CREDENTIALS )
		{
			CHString str;
			WMISaveError( WBEM_E_LOCAL_CREDENTIALS );
			str.Format( L"\n%s %s", TAG_WARNING, GetReason() );
			ShowMessage( stdout, str );

			// get the next cursor position
			if ( m_hOutput != NULL )
				GetConsoleScreenBufferInfo( m_hOutput, &m_csbi );
		}

		// check the remote system version and its compatiblity
		if ( m_bLocalSystem == FALSE )
		{
			// check the version compatibility
			DWORD dwVersion = 0;
			dwVersion = GetTargetVersionEx( m_pWbemServices, m_pAuthIdentity );
			if ( IsCompatibleOperatingSystem( dwVersion ) == FALSE )
			{
				SetReason( ERROR_OS_INCOMPATIBLE );
				return FALSE;
			}
		}

		// save the server name
		m_strUNCServer = L"";
		if ( m_strServer.GetLength() != 0 )
		{
			// check whether the server name is in UNC format or not .. if not prepare it
			m_strUNCServer = m_strServer;
			if ( IsUNCFormat( m_strServer ) == FALSE )
				m_strUNCServer.Format( L"\\\\%s", m_strServer );
		}
	}
	catch( _com_error& e )
	{
		WMISaveError( e );
		return FALSE;
	}

	// return the result
	return TRUE;
}

// ***************************************************************************
// Routine Description:
//		initiate the enumeration
//		  
// Arguments:
//		NONE
//  
// Return Value:
//		TRUE  : if successful
//		FALSE : if unsuccessful
// 
// ***************************************************************************
BOOL CTaskList::LoadTasks()
{
	// local variables
	HRESULT hr;
	
	try
	{
		// check the services object
		if ( m_pWbemServices == NULL )
		{
			SetLastError( STG_E_UNKNOWN );
			SaveLastError();
			return FALSE;
		}
		
		// load the tasks from WMI based on generated query
		SAFE_RELEASE( m_pEnumObjects );
		hr = m_pWbemServices->ExecQuery( _bstr_t( WMI_QUERY_TYPE ), _bstr_t( m_strQuery ), 
			WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY, NULL, &m_pEnumObjects );
		
		// check the result of the ExecQuery
		if ( FAILED( hr ) )
		{
			WMISaveError( hr );
			return FALSE;
		}
		
		// set the interface security and check the result
		hr = SetInterfaceSecurity( m_pEnumObjects, m_pAuthIdentity );
		if ( FAILED( hr ) )
		{
			WMISaveError( hr );
			return FALSE;
		}
		
		// remove the current window titles information
		DynArrayRemoveAll( m_arrWindowTitles );
		
		// for the local system, enumerate the window titles of the processes
		// there is no provision for collecting the window titles of remote processes
		if ( m_bLocalSystem == TRUE && m_bNeedWindowTitles == TRUE )
		{
			// prepare the tasks list info
			TWINDOWTITLES windowtitles;
			windowtitles.lpDesk = NULL;
			windowtitles.lpWinsta = NULL;
			windowtitles.bFirstLoop = FALSE;
			windowtitles.arrWindows = m_arrWindowTitles;
			EnumWindowStations( EnumWindowStationsFunc, ( LPARAM ) &windowtitles );
			
			// free the memory allocated with _tcsdup string function
			if ( windowtitles.lpDesk != NULL )
				free( windowtitles.lpDesk );
			if ( windowtitles.lpWinsta != NULL )
				free( windowtitles.lpWinsta );
		}

		// load the extended tasks information
		LoadTasksEx();			// NOTE: here we are not much bothered abt the return value

		// erase the status messages
		PrintProgressMsg( m_hOutput, NULL, m_csbi );
	}
	catch( _com_error& e )
	{
		WMISaveError( e );
		return FALSE;
	}
		
	// return success
	return TRUE;
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
BOOL CTaskList::LoadTasksEx()
{
	// local variables
	BOOL bResult = FALSE;

	// init
	m_bCloseConnection = FALSE;

	// we need to use NET API only in case connecting to the remote system
	// with credentials information i.e; m_pAuthIdentity is not NULL
	if ( m_bLocalSystem == FALSE && m_pAuthIdentity != NULL )
	{
		// sub-local variables
		DWORD dwConnect = 0;
		LPCWSTR pwszUser = NULL;
		LPCWSTR pwszPassword = NULL;

		// identify the password to connect to the remote system
		pwszPassword = m_pAuthIdentity->Password;
		if ( m_strUserName.GetLength() != 0 )
			pwszUser = m_strUserName;

		// establish connection to the remote system using NET API
		// this we need to do only for remote system
		dwConnect = NO_ERROR;
		m_bCloseConnection = TRUE;
		dwConnect = ConnectServer( m_strUNCServer, pwszUser, pwszPassword );
		if ( dwConnect != NO_ERROR )
		{
			// connection should not be closed .. this is because we didn't establish the connection
			m_bCloseConnection = FALSE;

			// this might be 'coz of the conflict in the credentials ... check that
			if ( dwConnect != ERROR_SESSION_CREDENTIAL_CONFLICT )
			{
				// return failure
				return FALSE;
			}
		}

		// check the whether we need to close the connection or not
		// if user name is NULL (or) password is NULL then don't close the connection
		if ( pwszUser == NULL || pwszPassword == NULL )
			m_bCloseConnection = FALSE;
	}

	try
	{
		// connect to the remote system's winstation
		bResult = TRUE;
		m_hServer = SERVERNAME_CURRENT;
		if ( m_bLocalSystem == FALSE )
		{
			// sub-local variables
			LPWSTR pwsz = NULL;

			// connect to the winsta and check the result
			pwsz = m_strUNCServer.GetBuffer( m_strUNCServer.GetLength() );
			m_hServer = WinStationOpenServerW( pwsz );

			// proceed furthur only if winstation of the remote system is successfully opened
			if ( m_hServer == NULL )
				bResult = FALSE;
		}
	}
	catch( ... )
	{
		SetLastError( E_OUTOFMEMORY );
		SaveLastError();
		return FALSE;
	}

	// prepare to get the user context info .. if needed
	if ( m_bNeedUserContextInfo == TRUE && bResult == TRUE )
	{
		// get all the process details
		m_bIsHydra = FALSE;
		bResult = WinStationGetAllProcesses( m_hServer, 
			GAP_LEVEL_BASIC, &m_ulNumberOfProcesses, (PVOID*) &m_pProcessInfo );
			
		// check the result
		if ( bResult == FALSE )
		{
			// Maybe a Hydra 4 server ?
			// Check the return code indicating that the interface is not available.
			if ( GetLastError() == RPC_S_PROCNUM_OUT_OF_RANGE )
			{
				// The new interface is not known
				// It must be a Hydra 4 server
				// try with the old interface
				bResult = WinStationEnumerateProcesses( m_hServer, (PVOID*) &m_pProcessInfo );

				// check the result of enumeration
				if ( bResult == TRUE )
					m_bIsHydra = TRUE;
			}
		}
	}

	// check whether we need services info or not
	if ( m_bNeedServicesInfo == TRUE )
	{
		// load the services 
		bResult = LoadServicesInfo();

		// check the result
		if ( bResult == FALSE )
			return FALSE;
	}

	// check whether we need modules info or not
	if ( m_bNeedModulesInfo == TRUE )
	{
		// load the modules information
		bResult = LoadModulesInfo();

		// check the result
		if ( bResult == FALSE )
			return FALSE;
	}

	// return
	return TRUE;
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
BOOL CTaskList::LoadModulesInfo()
{
	// local variables
	HKEY hKey;
	LONG lReturn = 0;
	BOOL bResult = FALSE;
	BOOL bImagesObject = FALSE;
	BOOL bAddressSpaceObject = FALSE;
	PPERF_OBJECT_TYPE pot = NULL;
    PPERF_COUNTER_DEFINITION pcd = NULL;

	// check whether we need the modules infor or not
	// NOTE: we need to load the performance data only in case if user is querying for remote system only
	if ( m_bNeedModulesInfo == FALSE || m_bLocalSystem == TRUE )
		return TRUE;

	// display the status message
	PrintProgressMsg( m_hOutput, MSG_MODULESINFO, m_csbi );

	// open the remote system performance data key
	lReturn = RegConnectRegistry( m_strUNCServer, HKEY_PERFORMANCE_DATA, &hKey );
	if ( lReturn != ERROR_SUCCESS )
	{
		SetLastError( lReturn );
		SaveLastError();
		return FALSE;
	}

	// get the performance object ( images )
	bResult = GetPerfDataBlock( hKey, L"740", &m_pdb );
	if ( bResult == FALSE )
	{
		// close the registry key and return
		RegCloseKey( hKey );
		return FALSE;
	}

	// check the validity of the perf block
	if ( StringCompare( m_pdb->Signature, L"PERF", FALSE, 4 ) != 0 )
	{
		// close the registry key and return
		RegCloseKey( hKey );
		
		// set the error message
		SetLastError( ERROR_ACCESS_DENIED );
		SaveLastError();
		return FALSE;
	}

	// close the registry key and return
	RegCloseKey( hKey );

	//
	// check whether we got both 740 and 786 blocks or not
	//
	bImagesObject = FALSE;
	bAddressSpaceObject = FALSE;
    pot = (PPERF_OBJECT_TYPE) ( (LPBYTE) m_pdb + m_pdb->HeaderLength );
	for( DWORD dw = 0; dw < m_pdb->NumObjectTypes; dw++ )
	{
		if ( pot->ObjectNameTitleIndex == 740 )
			bImagesObject = TRUE;
		else if ( pot->ObjectNameTitleIndex == 786 )
			bAddressSpaceObject = TRUE;

		// move to the next object
		if( pot->TotalByteLength != 0 )
			pot = ( (PPERF_OBJECT_TYPE) ((PBYTE) pot + pot->TotalByteLength));
	}

	// check whether we got the needed objects or not
	if ( bImagesObject == FALSE || bAddressSpaceObject == FALSE )
	{
		SetLastError( ERROR_ACCESS_DENIED );
		SaveLastError();
		return FALSE;
	}

	// return
	return TRUE;
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
BOOL CTaskList::LoadUserNameFromWinsta( CHString& strDomain, CHString& strUserName )
{
	// local variables
	PSID pSid = NULL;
	BOOL bResult = FALSE;
	LPWSTR pwszUser = NULL;
	LPWSTR pwszDomain = NULL;
	LPCWSTR pwszServer = NULL;
	DWORD dwUserLength = 0;
	DWORD dwDomainLength = 0;
	SID_NAME_USE siduse;

	// check whether winsta data exists or not
	if ( m_pProcessInfo == NULL )
		return FALSE;

	try
	{
		// allocate buffers
		dwUserLength = 128;
		dwDomainLength = 128;
		pwszUser = strUserName.GetBufferSetLength( dwUserLength );
		pwszDomain = strDomain.GetBufferSetLength( dwDomainLength );
	}
	catch( ... )
	{
		SetLastError( E_OUTOFMEMORY );
		SaveLastError();
		return FALSE;
	}

	//
	// find for the appropriate the process
	pSid = NULL;
	if ( m_bIsHydra == FALSE )
	{
		// sub-local variables
		PTS_ALL_PROCESSES_INFO ptsallpi = NULL;
		PTS_SYSTEM_PROCESS_INFORMATION pspi = NULL;

		// loop ...
		ptsallpi = (PTS_ALL_PROCESSES_INFO) m_pProcessInfo;
        for( ULONG ul = 0; ul < m_ulNumberOfProcesses; ul++ )
        {
            pspi = ( PTS_SYSTEM_PROCESS_INFORMATION )( ptsallpi[ ul ].pspiProcessInfo );
			if ( pspi->UniqueProcessId == m_dwProcessId )
			{
				// get the SID and convert it into
	            pSid = ptsallpi[ ul ].pSid;
				break;				 // break from the loop
			}
        }
	}
	else
	{
		//
		// HYDRA ...
		//

		// sub-local variables
		DWORD dwTotalOffset = 0;
		PTS_SYSTEM_PROCESS_INFORMATION pspi = NULL;
		PCITRIX_PROCESS_INFORMATION pcpi = NULL;

		// traverse thru the process info and find the process id
		dwTotalOffset = 0;
		pspi = ( PTS_SYSTEM_PROCESS_INFORMATION ) m_pProcessInfo;
		for( ;; )
		{
			// check the processid
			if ( pspi->UniqueProcessId == m_dwProcessId )
				break;

			// check whether any more processes exist or not
			if( pspi->NextEntryOffset == 0 )
					break;

			// position to the next process info
			dwTotalOffset += pspi->NextEntryOffset;
			pspi = (PTS_SYSTEM_PROCESS_INFORMATION) &m_pProcessInfo[ dwTotalOffset ];
		}

		// get the citrix_information which follows the threads
		pcpi = (PCITRIX_PROCESS_INFORMATION) 
			( ((PUCHAR) pspi) + sizeof( TS_SYSTEM_PROCESS_INFORMATION ) +
			(sizeof( SYSTEM_THREAD_INFORMATION ) * pspi->NumberOfThreads) );

		// check the magic number .. if it is not valid ... we haven't got SID
		if( pcpi->MagicNumber == CITRIX_PROCESS_INFO_MAGIC )
			pSid = pcpi->ProcessSid;
	}

	// check the sid value
	if ( pSid == NULL )
	{
		// SPECIAL CASE:
		// -------------
		// PID -> 0 will have a special hard coded user name info
		if ( m_dwProcessId == 0 )
		{
			bResult = TRUE;
			lstrcpynW( pwszUser, PID_0_USERNAME, dwUserLength );
			lstrcpynW( pwszDomain, PID_0_DOMAIN, dwDomainLength );
		}

		// release the buffer
		strDomain.ReleaseBuffer();
		strUserName.ReleaseBuffer();
		return bResult;
	}

	// determine the server
	pwszServer = NULL;
	if ( m_bLocalSystem == FALSE )
		pwszServer = m_strUNCServer;

	// map the sid to the user name
	bResult = LookupAccountSid( pwszServer, pSid, 
		pwszUser, &dwUserLength, pwszDomain, &dwDomainLength, &siduse );

	// release the buffer
	strDomain.ReleaseBuffer();
	strUserName.ReleaseBuffer();

	// return the result
	return bResult;
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
BOOL CTaskList::LoadServicesInfo()
{
	// local variables
	DWORD dw = 0;						// looping variable
    DWORD dwSize = 0;					// used in memory allocation 
    DWORD dwResume = 0;					// used in EnumServicesStatusEx
	BOOL bResult = FALSE;				// captures the result of EnumServicesStatusEx
    SC_HANDLE hScm = NULL;				// holds the handle to the service 
	DWORD dwExtraNeeded = 0;			// used in EnumServicesStatusEx and memory allocation
	LPCWSTR pwszServer = NULL;
	LPENUM_SERVICE_STATUS_PROCESS pInfo = NULL;		// holds the services info
    
    // Initialize the output parameter(s).
	m_dwServicesCount = 0;
    m_pServicesInfo = NULL;

	// check whether we need to load the services info or not
	if ( m_bNeedServicesInfo == FALSE )
		return TRUE;

	// display the status message
	PrintProgressMsg( m_hOutput, MSG_SERVICESINFO, m_csbi );

	// determine the server
	pwszServer = NULL;
	if ( m_bLocalSystem == FALSE )
		pwszServer = m_strUNCServer;

    // Connect to the service controller and check the result
    hScm = OpenSCManager( pwszServer, NULL, SC_MANAGER_CONNECT | SC_MANAGER_ENUMERATE_SERVICE );
    if ( hScm == NULL) 
	{
		// set the reason for the failure and return from here itself
		SaveLastError();
		return FALSE;
	}
        
	// enumerate the names of the active win32 services
    // for this, first pass through the loop and allocate memory from an initial guess. (4K)
    // if that isn't sufficient, we make another pass and allocate
    // what is actually needed.  
	// (we only go through the loop a maximum of two times)
	dw = 0;					// no. of loops
	dwResume = 0;			// reset / initialize variables
	dwSize = 4 * 1024;		// reset / initialize variables
    while ( ++dw <= 2 ) 
	{
		// set the size
		dwSize += dwExtraNeeded;

		// allocate memory for storing services information
		pInfo = ( LPENUM_SERVICE_STATUS_PROCESS ) __calloc( 1, dwSize );
		if ( pInfo == NULL )
		{
			// failed in allocating needed memory ... error
			SetLastError( E_OUTOFMEMORY );
			SaveLastError();
			return FALSE;
		}

		// enumerate services, the process identifier and additional flags for the service
		dwResume = 0;			// lets get all the services again
        bResult = EnumServicesStatusEx( hScm, SC_ENUM_PROCESS_INFO, SERVICE_WIN32, 
			SERVICE_ACTIVE, ( LPBYTE ) pInfo, dwSize, &dwExtraNeeded, &m_dwServicesCount, &dwResume, NULL ); 

		// check the result of the enumeration
		if ( bResult )
		{
			// successfully enumerated all the services information
			break;		// jump out of the loop
		}

		// first free the allocated memory
        __free( pInfo );

		// now lets look at what is the error
		if ( GetLastError() == ERROR_MORE_DATA )
		{
			// some more services are not listed because of less memory
			// allocate some more memory and enumerate the remaining services info
			continue;
		}
		else
		{
			// some strange error occured ... inform the same to the caller
			SaveLastError();			// set the reason for the failure
		    CloseServiceHandle( hScm );	// close the handle to the service
			return FALSE;				// inform failure
		}
	}

	// check whether there any services or not ... if services count is zero, free the memory
	if ( m_dwServicesCount == 0 )
	{
		// no services exists
		__free( pInfo );
	}
	else
	{
		// set the local pointer to the out parameter
		m_pServicesInfo = pInfo;
	}

	// inform success
    return TRUE;
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
BOOL GetPerfDataBlock( HKEY hKey, LPWSTR pwszObjectIndex, PPERF_DATA_BLOCK* ppdb )
{
	// local variables
    LONG lReturn = 0;
    DWORD dwBytes = 0;
	BOOL bResult = FALSE;

	// check the input parameters
	if ( pwszObjectIndex == NULL || ppdb == NULL )
		return FALSE;

    // allocate memory for PERF_DATA_BLOCK
	dwBytes = 32 * 1024;		// initially allocate for 32 K
    *ppdb = (PPERF_DATA_BLOCK) HeapAlloc( GetProcessHeap(), 0, dwBytes );
    if( *ppdb == NULL ) 
	{
		SetLastError( E_OUTOFMEMORY );
		SaveLastError();
		return FALSE;
	}

    // get performance data on passed Object
	lReturn = RegQueryValueEx( hKey, pwszObjectIndex, NULL, NULL, (LPBYTE) *ppdb, &dwBytes );
    while( lReturn == ERROR_MORE_DATA )
    {
        // increase memory by 8 K
        dwBytes += 8192;

        // allocated memory is too small reallocate new memory
        *ppdb = (PPERF_DATA_BLOCK) HeapReAlloc( GetProcessHeap(), 0, *ppdb, dwBytes );
		if( *ppdb == NULL ) 
		{
			SetLastError( E_OUTOFMEMORY );
			SaveLastError();
			return FALSE;
		}

		// try to get the info again
		lReturn = RegQueryValueEx( hKey, pwszObjectIndex, NULL, NULL, (LPBYTE) *ppdb, &dwBytes );
    }

	// check the reason for coming out of the loop
	bResult = TRUE;
    if ( lReturn != ERROR_SUCCESS ) 
	{
		if ( *ppdb != NULL) 
		{
			HeapFree( GetProcessHeap(), 0, *ppdb );
			*ppdb = NULL;
		}

		// save the error info
		bResult = FALSE;
		SetLastError( lReturn );
		SaveLastError();
	}

	// return the result
    return bResult;
}

// ***************************************************************************
// Routine Description:
//		Enumerates the desktops available on a particular window station
//		This is a CALLBACK function ... called by EnumWindowStations API function
//		  
// Arguments:
//		[ in ] lpstr	: window station name
//		[ in ] lParam	: user supplied parameter to this function
//						  in this function, this points to TTASKSLIST structure variable
//  
// Return Value:
//		TRUE upon success and FALSE on failure
// 
// ***************************************************************************
BOOL CALLBACK EnumWindowStationsFunc( LPTSTR lpstr, LPARAM lParam )
{
	// local variables
    HWINSTA hWinSta = NULL;
    HWINSTA hwinstaSave = NULL;
    PTWINDOWTITLES pWndTitles = ( PTWINDOWTITLES ) lParam;

	// check the input arguments
	if ( lpstr == NULL || lParam == NULL )
		return FALSE;

	// get and save the current window station
	hwinstaSave = GetProcessWindowStation();

	// open current tasks window station and change the context to the new workstation
	hWinSta = OpenWindowStation( lpstr, FALSE, WINSTA_ENUMERATE | WINSTA_ENUMDESKTOPS );
	if ( hWinSta == NULL )
	{
		// failed in getting the process window station
		SaveLastError();
		return FALSE;
	}
	else
	{
		// change the context to the new workstation
		if ( hWinSta != hwinstaSave && SetProcessWindowStation( hWinSta ) == FALSE )
		{
			// failed in changing the context
			SaveLastError();
			return FALSE;
		}

		// release the memory allocated for earlier window station
		if ( pWndTitles->lpWinsta != NULL )
		{
			free( pWndTitles->lpWinsta );
			pWndTitles->lpWinsta = NULL;
		}

		// store the window station name
		pWndTitles->lpWinsta = _tcsdup( lpstr );
		if ( pWndTitles->lpWinsta == NULL )
		{
			SetLastError( E_OUTOFMEMORY );
			SaveLastError();
			return FALSE;
		}
	}

    // enumerate all the desktops for this windowstation
    EnumDesktops( hWinSta, EnumDesktopsFunc, lParam );

    // restore the context to the previous windowstation
    if (hWinSta != hwinstaSave) 
	{
        SetProcessWindowStation( hwinstaSave );
        CloseWindowStation( hWinSta );
    }

    // continue the enumeration
    return TRUE;
}

// ***************************************************************************
// Routine Description:
//		Enumerates the windows on a particular desktop
//		This is a CALLBACK function ... called by EnumDesktops API function
//		  
// Arguments:
//		[ in ] lpstr	: desktop name
//		[ in ] lParam	: user supplied parameter to this function
//						  in this function, this points to TTASKSLIST structure variable
//  
// Return Value:
//		TRUE upon success and FALSE on failure
// 
// ***************************************************************************
BOOL CALLBACK EnumDesktopsFunc( LPTSTR lpstr, LPARAM lParam )
{
	// local variables
    HDESK hDesk = NULL;
    HDESK hdeskSave = NULL;
    PTWINDOWTITLES pWndTitles = ( PTWINDOWTITLES )lParam;

	// check the input arguments
	if ( lpstr == NULL || lParam == NULL )
		return FALSE;

	// get and save the current desktop
	hdeskSave = GetThreadDesktop( GetCurrentThreadId() );

	// open the tasks desktop and change the context to the new desktop
	hDesk = OpenDesktop( lpstr, 0, FALSE, DESKTOP_ENUMERATE );
	if ( hDesk == NULL )
	{
		// failed in getting the process desktop
		SaveLastError();
		return FALSE;
	}
	else
	{
		// change the context to the new desktop
		if ( hDesk != hdeskSave && SetThreadDesktop( hDesk ) == FALSE )
		{
			// failed in changing the context
			SaveLastError();
			// ?? return FALSE; -- needs to uncommented
		}

		// release the memory allocated for earlier window station
		if ( pWndTitles->lpDesk != NULL )
		{
			free( pWndTitles->lpDesk );
			pWndTitles->lpDesk = NULL;
		}

		// store the desktop name
	    pWndTitles->lpDesk = _tcsdup( lpstr );
		if ( pWndTitles->lpDesk == NULL )
		{
			SetLastError( E_OUTOFMEMORY );
			SaveLastError();
			return FALSE;
		}
	}

    // enumerate all windows in the new desktop
	// first try to get only the top level windows and visible windows only
	( ( PTWINDOWTITLES ) lParam )->bFirstLoop = TRUE;
    EnumWindows( ( WNDENUMPROC ) EnumWindowsProc, lParam );
    EnumMessageWindows( ( WNDENUMPROC ) EnumWindowsProc, lParam );

    // enumerate all windows in the new desktop
	// now try to get window titles of all those processes whose we ignored earlier while
	// looping first time
	( ( PTWINDOWTITLES ) lParam )->bFirstLoop = FALSE;
    EnumWindows( ( WNDENUMPROC ) EnumWindowsProc, lParam );
    EnumMessageWindows( ( WNDENUMPROC ) EnumWindowsProc, lParam );

    // restore the previous desktop
    if (hDesk != hdeskSave) 
	{
        SetThreadDesktop( hdeskSave );
        CloseDesktop( hDesk );
    }

	// continue enumeration
    return TRUE;
}

// ***************************************************************************
// Routine Description:
//		Enumerates the message windows
//		  
// Arguments:
//		[ in ] lpEnumFunc	: address of call back function that has to be called for
//							  each message window found
//		[ in ] lParam		: user supplied parameter to this function
//							  in this function, this points to TTASKSLIST structure variable
//  
// Return Value:
//		TRUE upon success and FALSE on failure
// ***************************************************************************
BOOL CALLBACK EnumMessageWindows( WNDENUMPROC lpEnumFunc, LPARAM lParam )
{
	// local variables
    HWND hWnd = NULL;
	BOOL bResult = FALSE;

	// check the input arguments
	if ( lpEnumFunc == NULL || lParam == NULL )
		return FALSE;

	// enumerate all the message windows
    do
	{
		// find the message window
        hWnd = FindWindowEx( HWND_MESSAGE, hWnd, NULL, NULL );

		// check whether we got the handle to the message window or not
        if ( hWnd != NULL ) 
		{
			// explicitly call the windows enumerators call back function for this window
			bResult = ( *lpEnumFunc )( hWnd, lParam );

			// check the result of the enumeator call back function
            if ( bResult == FALSE ) 
			{
				// terminate the enumeration
                break;
            }
        }
    } while ( hWnd != NULL );

	// return the enumeration result
    return bResult;
}

// ***************************************************************************
// Routine Description:
//		call back called by the API for each window
//		retrives the window title and updates the accordingly
//		  
// Arguments:
//		[ in ] hWnd			: handle to the window
//		[ in ] lParam		: user supplied parameter to this function
//							  in this function, this points to TTASKSLIST structure variable
//  
// Return Value:
//		TRUE upon success and FALSE on failure
// ***************************************************************************
BOOL CALLBACK EnumWindowsProc( HWND hWnd, LPARAM lParam )
{
	// local variables
	LONG lIndex = 0;
    DWORD dwPID = 0;
	BOOL bVisible = FALSE;
	TARRAY arrWindows = NULL;
    PTWINDOWTITLES pWndTitles = NULL;
    __MAX_SIZE_STRING szWindowTitle = NULL_STRING;

	// check the input arguments
	if ( hWnd == NULL || lParam == NULL )
		return FALSE;
		
	// get the values from the lParam
	pWndTitles = ( PTWINDOWTITLES ) lParam;
	arrWindows = pWndTitles->arrWindows;

	// get the processid for this window
   	if ( GetWindowThreadProcessId( hWnd, &dwPID ) == 0 ) 
	{
		// failed in getting the process id 
		return TRUE;			// return but, proceed enumerating other window handle
	}

	// get the visibility state of the window 
	// if the window is not visible, and if this is the first we are enumerating the 
	// window titles, ignore this process
	bVisible = GetWindowLong( hWnd, GWL_STYLE ) & WS_VISIBLE;
	if ( bVisible == FALSE && pWndTitles->bFirstLoop == TRUE )
		return TRUE;	// return but, proceed enumerating other window handle

	// check whether the current window ( for which we have the handle )
	// is main window or not. we don't need child windows
	if ( GetWindow(hWnd, GW_OWNER) != NULL )
	{
		// the current window handle is not for a top level window
		return TRUE;			// return but, proceed enumerating other window handle
	}

	// check if we are already got the window handle for the curren process or not
	// save it only if we are not having it
	lIndex = DynArrayFindDWORDEx( arrWindows, CTaskList::twiProcessId, dwPID );
	if (  lIndex == -1 )
	{
		// window for this process is not there ... save it
		lIndex = DynArrayAppendRow( arrWindows, CTaskList::twiCOUNT );
	}
	else 
	{
		// check whether window details already exists or not
		if ( DynArrayItemAsHandle2( arrWindows, lIndex, CTaskList::twiHandle ) != NULL )
			lIndex = -1;		// window details already exists
	}

	// check if window details has to be saved or not ... if needed save them
	if ( lIndex != -1 )
	{
		DynArraySetDWORD2( arrWindows, lIndex, CTaskList::twiProcessId, dwPID );
		DynArraySetHandle2( arrWindows, lIndex, CTaskList::twiHandle, hWnd );
		DynArraySetString2( arrWindows, lIndex, 
			CTaskList::twiWinSta, pWndTitles->lpWinsta, 0 );		
		DynArraySetString2( arrWindows, lIndex, 
			CTaskList::twiDesktop, pWndTitles->lpDesk, 0 );

		// get and save the window title
		if ( GetWindowText( hWnd, szWindowTitle, SIZE_OF_ARRAY( szWindowTitle ) ) != 0 )
			DynArraySetString2( arrWindows, lIndex, CTaskList::twiTitle, szWindowTitle, 0 );
	}
	
    // continue the enumeration
    return TRUE;
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
VOID PrintProgressMsg( HANDLE hOutput, LPCWSTR pwszMsg, const CONSOLE_SCREEN_BUFFER_INFO& csbi )
{
	// local variables
	COORD coord; 
	DWORD dwSize = 0;
	WCHAR wszSpaces[ 80 ] = L"";

	// check the handle. if it is null, it means that output is being redirected. so return
	if ( hOutput == NULL )
		return;

	// set the cursor position
    coord.X = 0;
    coord.Y = csbi.dwCursorPosition.Y;

	// first erase contents on the current line
	ZeroMemory( wszSpaces, 80 );
	SetConsoleCursorPosition( hOutput, coord );
	WriteConsoleW( hOutput, Replicate( wszSpaces, L"", 79 ), 79, &dwSize, NULL );

	// now display the message ( if exists )
	SetConsoleCursorPosition( hOutput, coord );
	if ( pwszMsg != NULL )
		WriteConsoleW( hOutput, pwszMsg, lstrlen( pwszMsg ), &dwSize, NULL );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cmdline\tasklist\wmi.cpp ===
// *********************************************************************************
// 
//  Copyright (c) Microsoft Corporation
//  
//  Module Name:
//  
//		WMI.cpp
//  
//  Abstract:
//  
// 		Common functionlity for dealing with WMI
//  
//  Author:
//  
// 	    Sunil G.V.N. Murali (murali.sunil@wipro.com) 22-Dec-2000
//  
//  Revision History:
//  
// 	    Sunil G.V.N. Murali (murali.sunil@wipro.com) 22-Dec-2000 : Created It.
//  
// *********************************************************************************

#include "pch.h"
#include "wmi.h"
#include "resource.h"

//
// messages
//
#define INPUT_PASSWORD		GetResString( IDS_STR_INPUT_PASSWORD )

// error constants
#define E_SERVER_NOTFOUND			0x800706ba

//
// private function prototype(s)
//
BOOL IsValidUserEx( LPCWSTR pwszUser );
HRESULT GetSecurityArguments( IUnknown* pInterface, 
							  DWORD& dwAuthorization, DWORD& dwAuthentication );
HRESULT SetInterfaceSecurity( IUnknown* pInterface, 
							  LPCWSTR pwszServer, LPCWSTR pwszUser, 
							  LPCWSTR pwszPassword, COAUTHIDENTITY** ppAuthIdentity );
HRESULT WINAPI SetProxyBlanket( IUnknown* pInterface,
							    DWORD dwAuthnSvc, DWORD dwAuthzSvc,
								LPWSTR pwszPrincipal, DWORD dwAuthLevel, DWORD dwImpLevel,
								RPC_AUTH_IDENTITY_HANDLE pAuthInfo, DWORD dwCapabilities );
HRESULT WINAPI WbemAllocAuthIdentity( LPCWSTR pwszUser, LPCWSTR pwszPassword, 
									  LPCWSTR pwszDomain, COAUTHIDENTITY** ppAuthIdent );
HRESULT RegQueryValueWMI( IWbemServices* pWbemServices, 
						  LPCWSTR pwszMethod, DWORD dwHDefKey, 
						  LPCWSTR pwszSubKeyName, LPCWSTR pwszValueName, _variant_t& varValue );

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
BOOL IsValidUserEx( LPCWSTR pwszUser )
{
	// local variables
	CHString strUser;
	LONG lPos = 0;

	try
	{
		// get user into local memory
		strUser = pwszUser;

		// user name should not be just '\'
		if ( strUser.CompareNoCase( L"\\" ) == 0 )
			return FALSE;

		// user name should not contain invalid characters
		if ( strUser.FindOneOf( L"/[]:|<>+=;,?*" ) != -1 )
			return FALSE;

		// SPECIAL CHECK
		// check for multiple '\' characters in the user name
		lPos = strUser.Find( L'\\' );
		if ( lPos != -1 )
		{
			// '\' character exists in the user name
			// strip off the user info upto first '\' character
			// check for one more '\' in the remaining string
			// if it exists, invalid user
			strUser = strUser.Mid( lPos + 1 );
			lPos = strUser.Find( L'\\' );
			if ( lPos != -1 )
				return FALSE;
		}
	}
	catch( ... )
	{
		SetLastError( E_OUTOFMEMORY );
		return FALSE;
	}

	// user name is valid
	return TRUE;
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
BOOL IsValidServerEx( LPCWSTR pwszServer, BOOL& bLocalSystem )
{
	// local variables
	CHString strTemp;

	// kick-off
	bLocalSystem = FALSE;

	// get a local copy
	strTemp = pwszServer;

	// remove the forward slashes (UNC) if exist in the begining of the server name
	if ( IsUNCFormat( strTemp ) == TRUE )
	{
		strTemp = strTemp.Mid( 2 );
		if ( strTemp.GetLength() == 0 )
			return FALSE;
	}

	// now check if any '\' character appears in the server name. If so error
	if ( strTemp.Find( L'\\' ) != -1 )
		return FALSE;

	// now check if server name is '.' only which represent local system in WMI
	// else determine whether this is a local system or not
	bLocalSystem = TRUE;
	if ( strTemp.CompareNoCase( L"." ) != 0 )
	{
		// validate the server
		if ( IsValidServer( strTemp ) == FALSE )
			return FALSE;

		// check whether this is a local system or not
		bLocalSystem = IsLocalSystem( strTemp );
	}

	// inform that server name is valid
	return TRUE;
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
BOOL InitializeCom( IWbemLocator** ppLocator )
{
	// local variables
	HRESULT hr;
	BOOL bResult = FALSE;

	try
	{
		// assume that connection to WMI namespace is failed
		bResult = FALSE;

		// initialize the COM library
		SAFE_EXECUTE( CoInitializeEx( NULL, COINIT_APARTMENTTHREADED ) );

		// initialize the security
		SAFE_EXECUTE( CoInitializeSecurity( NULL, -1, NULL, NULL,
			RPC_C_AUTHN_LEVEL_NONE, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE, 0 ) );

		// create the locator and get the pointer to the interface of IWbemLocator
		SAFE_RELEASE( *ppLocator );			// safe side
		SAFE_EXECUTE( CoCreateInstance( CLSID_WbemLocator, NULL, CLSCTX_INPROC_SERVER, 
			IID_IWbemLocator, ( LPVOID* ) ppLocator ) );

		// initialization successful
		bResult = TRUE;
	}
	catch( _com_error& e )
	{
		// save the WMI error
		WMISaveError( e );
	}

	// return the result;
	return bResult;
}

// ***************************************************************************
// Routine Description:
//		
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
BOOL ConnectWmi( IWbemLocator* pLocator, 
				 IWbemServices** ppServices, 
				 LPCWSTR pwszServer, LPCWSTR pwszUser, LPCWSTR pwszPassword, 
				 COAUTHIDENTITY** ppAuthIdentity, BOOL bCheckWithNullPwd, 
				 LPCWSTR pwszNamespace, HRESULT* phr, BOOL* pbLocalSystem )
{
	// local variables
	HRESULT hr;
	BOOL bResult = FALSE;
	BOOL bLocalSystem = FALSE;
	_bstr_t bstrServer;
	_bstr_t bstrNamespace;
	_bstr_t bstrUser, bstrPassword;

	// kick-off
	if ( pbLocalSystem != NULL )
		*pbLocalSystem = FALSE;

	// ...
	if ( phr != NULL )
		*phr = WBEM_S_NO_ERROR;

	try
	{
		// clear the error
		SetLastError( WBEM_S_NO_ERROR );

		// assume that connection to WMI namespace is failed
		bResult = FALSE;

		// check whether locator object exists or not
		// if not exists, return
		if ( pLocator == NULL )
		{
			if ( phr != NULL )
				*phr = WBEM_E_INVALID_PARAMETER;

			// return failure
			return FALSE;
		}

		// validate the server name
		if ( IsValidServerEx( pwszServer, bLocalSystem ) == FALSE )
			_com_issue_error( ERROR_BAD_NETPATH );

		// validate the user name
		if ( IsValidUserEx( pwszUser ) == FALSE )
			_com_issue_error( ERROR_NO_SUCH_USER );

		// prepare namespace
		bstrNamespace = pwszNamespace;				// name space
		if ( pwszServer != NULL && bLocalSystem == FALSE )
		{
			// get the server name
			bstrServer = pwszServer;

			// prepare the namespace
			// NOTE: check for the UNC naming format of the server and do
			if ( IsUNCFormat( pwszServer ) == TRUE )
				bstrNamespace = bstrServer + L"\\" + pwszNamespace;
			else
				bstrNamespace = L"\\\\" + bstrServer + L"\\" + pwszNamespace;

			// user credentials
			if ( pwszUser != NULL && lstrlen( pwszUser ) != 0 )
			{
				// copy the user name
				bstrUser = pwszUser;

				// if password is empty string and if we need to check with
				// null password, then do not set the password and try
				bstrPassword = pwszPassword;
				if ( bCheckWithNullPwd == TRUE && bstrPassword.length() == 0 )
					bstrPassword = (LPWSTR) NULL;
			}
		}
		else if ( bLocalSystem == TRUE && pwszUser != NULL && lstrlen( pwszUser ) != 0 )
		{
			// got the credentials for the local system
			if ( phr != NULL )
				*phr = WBEM_E_LOCAL_CREDENTIALS;
		}

		// release the existing services object ( to be in safer side )
		SAFE_RELEASE( *ppServices );

		// connect to the remote system's WMI
		// there is a twist here ... 
		// do not trap the ConnectServer function failure into exception
		// instead handle that action manually
		// by default try the ConnectServer function as the information which we have
		// in our hands at this point. If the ConnectServer is failed, 
		// check whether password variable has any contents are not ... if no contents
		// check with "" (empty) password ... this might pass in this situation ..
		// if this call is also failed ... nothing is there that we can do ... throw the exception
		hr = pLocator->ConnectServer( bstrNamespace, 
			bstrUser, bstrPassword, 0L, 0L, NULL, NULL, ppServices );
		if ( FAILED( hr ) )
		{
			//
			// special case ...

			// check whether password exists or not
			// NOTE: do not check for 'WBEM_E_ACCESS_DENIED'
			//       this error code says that user with the current credentials is not
			//       having access permisions to the 'namespace'
			if ( hr == E_ACCESSDENIED )
			{
				// check if we tried to connect to the system using null password
				// if so, then try connecting to the remote system with empty string
				if ( bCheckWithNullPwd == TRUE &&
					 bstrUser.length() != 0 && bstrPassword.length() == 0 )
				{
					// now invoke with ...
					hr = pLocator->ConnectServer( bstrNamespace, 
						bstrUser, _bstr_t( L"" ), 0L, 0L, NULL, NULL, ppServices );
				}
			}
			else if ( hr == WBEM_E_LOCAL_CREDENTIALS )
			{
				// credentials were passed to the local system. 
				// So ignore the credentials and try to reconnect
				bLocalSystem = TRUE;
				bstrUser = (LPWSTR) NULL;
				bstrPassword = (LPWSTR) NULL;
				bstrNamespace = pwszNamespace;				// name space
				hr = pLocator->ConnectServer( bstrNamespace, 
					NULL, NULL, 0L, 0L, NULL, NULL, ppServices );

				// check the result
				if ( SUCCEEDED( hr ) && phr != NULL )
				{
					// set the last error
					*phr = WBEM_E_LOCAL_CREDENTIALS;
				}
			}

			// now check the result again .. if failed .. ummmm..
			if ( FAILED( hr ) )
				_com_issue_error( hr );
			else
				bstrPassword = L"";
		}

		// set the security at the interface level also
		SAFE_EXECUTE( SetInterfaceSecurity( *ppServices, 
			pwszServer, bstrUser, bstrPassword, ppAuthIdentity ) );

		// connection to WMI is successful
		bResult = TRUE;
	}
	catch( _com_error& e )
	{
		// save the error
		WMISaveError( e );

		// save the hr value if needed by the caller
		if ( phr != NULL )
			*phr = e.Error();
	}

	// ...
	if ( pbLocalSystem != NULL )
		*pbLocalSystem = bLocalSystem;

	// return the result
	return bResult;
}

// ***************************************************************************
// Routine Description:
//		
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
BOOL ConnectWmiEx( IWbemLocator* pLocator, 
				   IWbemServices** ppServices, 
				   LPCWSTR pwszServer, CHString& strUserName, CHString& strPassword, 
				   COAUTHIDENTITY** ppAuthIdentity, 
				   BOOL bNeedPassword, LPCWSTR pwszNamespace, BOOL* pbLocalSystem )
{
	// local variables
	HRESULT hr;
	DWORD dwSize = 0;
	BOOL bResult = FALSE;
	LPWSTR pwszPassword = NULL;
	CHString strBuffer = NULL_STRING;

	// clear the error .. if any
	SetLastError( WBEM_S_NO_ERROR );

	// sometime users want the utility to prompt for the password
	// check what user wants the utility to do
	if ( bNeedPassword == TRUE && strPassword.Compare( L"*" ) == 0 )
	{
		// user wants the utility to prompt for the password
		// so skip this part and let the flow directly jump the password acceptance part
	}
	else
	{
		// try to establish connection to the remote system with the credentials supplied
		if ( strUserName.GetLength() == 0 )
		{
			// user name is empty
			// so, it is obvious that password will also be empty
			// even if password is specified, we have to ignore that
			bResult = ConnectWmi( pLocator, ppServices, 
				pwszServer, NULL, NULL, ppAuthIdentity, FALSE, pwszNamespace, &hr, pbLocalSystem );
		}
		else
		{
			// credentials were supplied
			// but password might not be specified ... so check and act accordingly
			LPCWSTR pwszTemp = NULL;
			BOOL bCheckWithNull = TRUE;
			if ( bNeedPassword == FALSE )
			{
				pwszTemp = strPassword;
				bCheckWithNull = FALSE;
			}

			// ...
			bResult = ConnectWmi( pLocator, ppServices, pwszServer,
				strUserName, pwszTemp, ppAuthIdentity, bCheckWithNull, pwszNamespace, &hr, pbLocalSystem );
		}

		// check the result ... if successful in establishing connection ... return
		if ( bResult == TRUE )
		{
			SetLastError( hr );			// set the error code
			return TRUE;
		}

		// now check the kind of error occurred
		switch( hr )
		{
		case E_ACCESSDENIED:
			break;

		case WBEM_E_ACCESS_DENIED:
		default:
			// NOTE: do not check for 'WBEM_E_ACCESS_DENIED'
			//       this error code says that user with the current credentials is not
			//       having access permisions to the 'namespace'
			WMISaveError( hr );
			return FALSE;		// no use of accepting the password .. return failure
			break;
		}

		// if failed in establishing connection to the remote terminal
		// even if the password is specifed, then there is nothing to do ... simply return failure
		if ( bNeedPassword == FALSE )
			return FALSE;
	}

	// check whether user name is specified or not
	// if not, get the local system's current user name under whose credentials, the process
	// is running
	if ( strUserName.GetLength() == 0 )
	{
		// sub-local variables
		LPWSTR pwszUserName = NULL;

		try
		{
			// get the required buffer
			pwszUserName = strUserName.GetBufferSetLength( MAX_STRING_LENGTH );
		}
		catch( ... )
		{
			SetLastError( E_OUTOFMEMORY );
			SaveLastError();
			return FALSE;
		}

		// get the user name
		DWORD dwUserLength = MAX_STRING_LENGTH;
		if ( GetUserNameEx( NameSamCompatible, pwszUserName, &dwUserLength ) == FALSE )
		{
			// error occured while trying to get the current user info
			SaveLastError();
			return FALSE;
		}

		// release the extra buffer allocated
		strUserName.ReleaseBuffer();
	}

	try
	{
		// get the required buffer
		pwszPassword = strPassword.GetBufferSetLength( MAX_STRING_LENGTH );
	}
	catch( ... )
	{
		SetLastError( E_OUTOFMEMORY );
		SaveLastError();
		return FALSE;
	}

	// accept the password from the user
	strBuffer.Format( INPUT_PASSWORD, strUserName );
	WriteConsoleW( GetStdHandle( STD_ERROR_HANDLE ), 
		strBuffer, strBuffer.GetLength(), &dwSize, NULL );
	GetPassword( pwszPassword, MAX_PASSWORD_LENGTH );

	// release the buffer allocated for password
	strPassword.ReleaseBuffer();

	// now again try to establish the connection using the currently
	// supplied credentials
	bResult = ConnectWmi( pLocator, ppServices, pwszServer,
		strUserName, strPassword, ppAuthIdentity, FALSE, pwszNamespace, &hr, pbLocalSystem );

	// set the last error 
	SetLastError( hr );

	// return the failure
	return bResult;
}

// ***************************************************************************
// Routine Description:
//		
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
HRESULT GetSecurityArguments( IUnknown* pInterface, 
							  DWORD& dwAuthorization, DWORD& dwAuthentication )
{
	// local variables
	HRESULT hr;
	DWORD dwAuthnSvc = 0, dwAuthzSvc = 0;
	IClientSecurity* pClientSecurity = NULL;

	// try to get the client security services values if possible
	hr = pInterface->QueryInterface( IID_IClientSecurity, (void**) &pClientSecurity );
	if ( SUCCEEDED( hr ) )
	{
		// got the client security interface
		// now try to get the security services values
		hr = pClientSecurity->QueryBlanket( pInterface, 
			&dwAuthnSvc, &dwAuthzSvc, NULL, NULL, NULL, NULL, NULL );
		if ( SUCCEEDED( hr ) )
		{
			// we've got the values from the interface
			dwAuthentication = dwAuthnSvc;
			dwAuthorization = dwAuthzSvc;
		}

		// release the client security interface
		SAFE_RELEASE( pClientSecurity );
	}

	// return always success
	return S_OK;
}

// ***************************************************************************
// Routine Description:
//		
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
HRESULT SetInterfaceSecurity( IUnknown* pInterface, 
							  LPCWSTR pwszServer, LPCWSTR pwszUser, 
							  LPCWSTR pwszPassword, COAUTHIDENTITY** ppAuthIdentity )
{
	// local variables
	HRESULT hr;
	CHString strUser;
	CHString strDomain;
	LPCWSTR pwszUserArg = NULL;
	LPCWSTR pwszDomainArg = NULL;
	DWORD dwAuthorization = RPC_C_AUTHZ_NONE;
	DWORD dwAuthentication = RPC_C_AUTHN_WINNT;

	// check the interface
	if ( pInterface == NULL )
		return WBEM_E_INVALID_PARAMETER;

	// check the authentity strcuture ... if authentity structure is already ready
	// simply invoke the 2nd version of SetInterfaceSecurity
	if ( *ppAuthIdentity != NULL )
		return SetInterfaceSecurity( pInterface, *ppAuthIdentity );

	// get the current security argument value
	// GetSecurityArguments( pInterface, dwAuthorization, dwAuthentication );

    // If we are doing trivial case, just pass in a null authenication structure 
    // for which the current logged in user's credentials will be considered
	if ( pwszUser == NULL && pwszPassword == NULL )
	{
		// set the security
		hr = SetProxyBlanket( pInterface, dwAuthentication, dwAuthorization, 
			NULL, RPC_C_AUTHN_LEVEL_DEFAULT, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE );

		// return the result
		return hr;
	}

	// parse and find out if the user name contains the domain name
	// if contains, extract the domain value from it
	LONG lPos = -1;
	strDomain = L"";
	strUser = pwszUser;
	if ( ( lPos = strUser.Find( L'\\' ) ) != -1 )
	{
		// user name contains domain name ... domain\user format
		strDomain = strUser.Left( lPos );
		strUser = strUser.Mid( lPos + 1 );
	}

	// get the domain info if it exists only
	if ( strDomain.GetLength() != 0 )
		pwszDomainArg = strDomain;

	// get the user info if it exists only
	if ( strUser.GetLength() != 0 )
		pwszUserArg = strUser;

	// check if authenication info is available or not ...
	// initialize the security authenication information ... UNICODE VERSION STRUCTURE
	if ( ppAuthIdentity == NULL )
        return WBEM_E_INVALID_PARAMETER;
	else if ( *ppAuthIdentity == NULL )
	{
		hr = WbemAllocAuthIdentity( pwszUserArg, pwszPassword, pwszDomainArg, ppAuthIdentity );
		if ( hr != S_OK )
			return hr;
	}

	// set the security information to the interface
	hr = SetProxyBlanket( pInterface, dwAuthentication, dwAuthorization, NULL,
		RPC_C_AUTHN_LEVEL_DEFAULT, RPC_C_IMP_LEVEL_IMPERSONATE, *ppAuthIdentity, EOAC_NONE );

	// return the result
	return hr;
}

// ***************************************************************************
// Routine Description:
//		
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
HRESULT SetInterfaceSecurity( IUnknown* pInterface, COAUTHIDENTITY* pAuthIdentity )
{
	// local variables
	HRESULT hr;
	LPWSTR pwszDomain = NULL;
	DWORD dwAuthorization = RPC_C_AUTHZ_NONE;
	DWORD dwAuthentication = RPC_C_AUTHN_WINNT;

	// check the interface
	if ( pInterface == NULL )
		return WBEM_E_INVALID_PARAMETER;

	// get the current security argument value
	// GetSecurityArguments( pInterface, dwAuthorization, dwAuthentication );

	// set the security information to the interface
	hr = SetProxyBlanket( pInterface, dwAuthentication, dwAuthorization, NULL,
		RPC_C_AUTHN_LEVEL_DEFAULT, RPC_C_IMP_LEVEL_IMPERSONATE, pAuthIdentity, EOAC_NONE );

	// return the result
	return hr;
}

// ***************************************************************************
// Routine Description:
//		
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
HRESULT WINAPI SetProxyBlanket( IUnknown* pInterface,
							    DWORD dwAuthnSvc, DWORD dwAuthzSvc,
								LPWSTR pwszPrincipal, DWORD dwAuthLevel, DWORD dwImpLevel,
								RPC_AUTH_IDENTITY_HANDLE pAuthInfo, DWORD dwCapabilities )
{
	// local variables
	HRESULT hr;
    IUnknown * pUnknown = NULL;
    IClientSecurity * pClientSecurity = NULL;

	// get the IUnknown interface ... to check whether this is a valid interface or not
    hr = pInterface->QueryInterface( IID_IUnknown, (void **) &pUnknown );
    if ( hr != S_OK )
        return hr;

	// now get the client security interface
    hr = pInterface->QueryInterface( IID_IClientSecurity, (void **) &pClientSecurity );
    if ( hr != S_OK )
    {
        SAFE_RELEASE( pUnknown );
        return hr;
    }

    //
    // Can't set pAuthInfo if cloaking requested, as cloaking implies
    // that the current proxy identity in the impersonated thread (rather
    // than the credentials supplied explicitly by the RPC_AUTH_IDENTITY_HANDLE)
    // is to be used.
    // See MSDN info on CoSetProxyBlanket for more details.
    //
    if ( dwCapabilities & (EOAC_STATIC_CLOAKING | EOAC_DYNAMIC_CLOAKING) )
        pAuthInfo = NULL;

	// now set the security
    hr = pClientSecurity->SetBlanket( pInterface, dwAuthnSvc, dwAuthzSvc, pwszPrincipal,
		dwAuthLevel, dwImpLevel, pAuthInfo, dwCapabilities );

	// release the security interface
	SAFE_RELEASE( pClientSecurity );

    // we should check the auth identity structure. if exists .. set for IUnknown also
    if ( pAuthInfo != NULL )
    {
        hr = pUnknown->QueryInterface( IID_IClientSecurity, (void **) &pClientSecurity );
        if ( hr == S_OK )
        {
			// set security authentication
            hr = pClientSecurity->SetBlanket( 
				pUnknown, dwAuthnSvc, dwAuthzSvc, pwszPrincipal, 
				dwAuthLevel, dwImpLevel, pAuthInfo, dwCapabilities );

			// release
            SAFE_RELEASE( pClientSecurity );
        }
        else if ( hr == E_NOINTERFACE )
            hr = S_OK;		// ignore no interface errors
    }

	// release the IUnknown
	SAFE_RELEASE( pUnknown );

	// return the result
    return hr;
}

// ***************************************************************************
// Routine Description:
//		
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
HRESULT WINAPI WbemAllocAuthIdentity( LPCWSTR pwszUser, LPCWSTR pwszPassword, 
									  LPCWSTR pwszDomain, COAUTHIDENTITY** ppAuthIdent )
{
	// local variables
    COAUTHIDENTITY* pAuthIdent = NULL;

	// validate the input parameter
    if ( ppAuthIdent == NULL )
        return WBEM_E_INVALID_PARAMETER;

    // allocation thru COM API
    pAuthIdent = ( COAUTHIDENTITY* ) CoTaskMemAlloc( sizeof( COAUTHIDENTITY ) );
    if ( NULL == pAuthIdent )
        return WBEM_E_OUT_OF_MEMORY;

	// init with 0's
    ZeroMemory( ( void* ) pAuthIdent, sizeof( COAUTHIDENTITY ) );

	//
	// Allocate needed memory and copy in data.  Cleanup if anything goes wrong

	// user
    if ( pwszUser != NULL )
    {
		// allocate memory for user
		LONG lLength = wcslen( pwszUser ); 
        pAuthIdent->User = ( LPWSTR ) CoTaskMemAlloc( (lLength + 1) * sizeof( WCHAR ) );
		if ( pAuthIdent->User == NULL )
		{
            WbemFreeAuthIdentity( &pAuthIdent );
            return WBEM_E_OUT_OF_MEMORY;
        }

		// set the length and do copy contents
        pAuthIdent->UserLength = lLength;
        wcscpy( pAuthIdent->User, pwszUser );
    }

	// domain
    if ( pwszDomain != NULL )
    {
		// allocate memory for domain
		LONG lLength = wcslen( pwszDomain ); 
        pAuthIdent->Domain = ( LPWSTR ) CoTaskMemAlloc( (lLength + 1) * sizeof( WCHAR ) );
        if ( pAuthIdent->Domain == NULL )
        {
            WbemFreeAuthIdentity( &pAuthIdent );
            return WBEM_E_OUT_OF_MEMORY;
        }

		// set the length and do copy contents
        pAuthIdent->DomainLength = lLength;
        wcscpy( pAuthIdent->Domain, pwszDomain );
    }

	// passsord
    if ( pwszPassword != NULL )
    {
		// allocate memory for passsord
		LONG lLength = wcslen( pwszPassword ); 
        pAuthIdent->Password = ( LPWSTR ) CoTaskMemAlloc( (lLength + 1) * sizeof( WCHAR ) );
        if ( pAuthIdent->Password == NULL )
        {
            WbemFreeAuthIdentity( &pAuthIdent );
            return WBEM_E_OUT_OF_MEMORY;
        }

		// set the length and do copy contents
        pAuthIdent->PasswordLength = lLength;
        wcscpy( pAuthIdent->Password, pwszPassword );
    }

	// type of the structure
    pAuthIdent->Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;

    // final set the address to out parameter
	*ppAuthIdent = pAuthIdent;

	// return result
    return S_OK;
}

// ***************************************************************************
// Routine Description:
//		
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
VOID WINAPI WbemFreeAuthIdentity( COAUTHIDENTITY** ppAuthIdentity )
{
    // make sure we have a pointer, then walk the structure members and  cleanup.
    if ( *ppAuthIdentity != NULL )
    {
		// free the memory allocated for user
        if ( (*ppAuthIdentity)->User != NULL )
            CoTaskMemFree( (*ppAuthIdentity)->User );

		// free the memory allocated for password
        if ( (*ppAuthIdentity)->Password != NULL )
            CoTaskMemFree( (*ppAuthIdentity)->Password );

		// free the memory allocated for domain
        if ( (*ppAuthIdentity)->Domain != NULL )
            CoTaskMemFree( (*ppAuthIdentity)->Domain );

        // final the structure
		CoTaskMemFree( *ppAuthIdentity );
    }

	// set to NULL
	*ppAuthIdentity = NULL;
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
VOID WMISaveError( HRESULT hrError )
{
	// local variables
	HRESULT hr;
	CHString strBuffer = NULL_STRING;
	IWbemStatusCodeText* pWbemStatus = NULL;

	// if the error is win32 based, choose FormatMessage to get the message
	switch( hrError )
	{
	case E_ACCESSDENIED:			// Message: "Access Denied"
	case ERROR_NO_SUCH_USER:		// Message: "The specified user does not exist."
		{
			// change the error message to "Logon failure: unknown user name or bad password." 
			if ( hrError == E_ACCESSDENIED )
				hrError = ERROR_LOGON_FAILURE;

			// ...
			SetLastError( hrError );
			SaveLastError();
			return;
		}
	}

	try
	{
		// get the pointer to buffer
		LPWSTR pwszBuffer = NULL;
		pwszBuffer = strBuffer.GetBufferSetLength( MAX_STRING_LENGTH );

		// get the wbem specific status code text
		hr = CoCreateInstance( CLSID_WbemStatusCodeText, 
			NULL, CLSCTX_INPROC_SERVER, IID_IWbemStatusCodeText, (LPVOID*) &pWbemStatus );

		// check whether we got the interface or not
		if ( SUCCEEDED( hr ) )
		{
			// get the error message
			BSTR bstr = NULL;
			hr = pWbemStatus->GetErrorCodeText( hrError, 0, 0, &bstr );
			if ( SUCCEEDED( hr ) )
			{
				// get the error message in proper format
				GetCompatibleStringFromUnicode( bstr, pwszBuffer, MAX_STRING_LENGTH );

				//
				// supress all the new-line characters and add '.' at the end ( if not exists )
				LPWSTR pwszTemp = NULL;
				pwszTemp = wcstok( pwszBuffer, L"\r\n" );
				if ( *( pwszTemp + lstrlenW( pwszTemp ) - 1 ) != L'.' )
					lstrcatW( pwszTemp, L"." );

				// free the BSTR
				SysFreeString( bstr );
				bstr = NULL;

				// now release status code interface
				SAFE_RELEASE( pWbemStatus );
			}
			else
			{
				// failed to get the error message ... get the com specific error message
				_com_issue_error( hrError );
			}
		}
		else
		{
			// failed to get the error message ... get the com specific error message
			_com_issue_error( hrError );
		}

		// release the buffer
		strBuffer.ReleaseBuffer();
	}
	catch( _com_error& e )
	{
		try
		{
			// get the error message
			strBuffer.ReleaseBuffer();
			if ( e.ErrorMessage() != NULL )
				strBuffer = e.ErrorMessage();
		}
		catch( ... )
		{
			SetLastError( E_OUTOFMEMORY );
			SaveLastError();
		}
	}
	catch( ... )
	{
		SetLastError( E_OUTOFMEMORY );
		SaveLastError();
		return;
	}

	// set the reason
	strBuffer += L"\n";
	SetReason( strBuffer );
}

// ***************************************************************************
// Routine Description:
//		Gets the value of the property from the WMI class object
//		  
// Arguments:
//		[ in ] pWmiObject		: pointer to the WBEM class object
//		[ in ] szProperty		: property name
//		[ out ] varValue		: value of the property
//  
// Return Value:
//		HRESULT - result of the operation
// 
// ***************************************************************************
HRESULT PropertyGet( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty, VARIANT* pvarValue )
{
	// local variables
	HRESULT hr;

	// check with object and property passed to the function are valid or not
	// if not, return failure
	if ( pWmiObject == NULL || pwszProperty == NULL || pvarValue == NULL )
		return WBEM_E_INVALID_PARAMETER;

	try
	{
		// initialize the variant and then get the value of the specified property
		hr = pWmiObject->Get( _bstr_t( pwszProperty ), 0, pvarValue, NULL, NULL );
		if ( FAILED( hr ) )
		{
			// clear the variant variable
			VariantClear( pvarValue );

			// failed to get the value for the property
			return hr;
		}
	}
	catch( _com_error& e )
	{
		WMISaveError( e );
		return e.Error();
	}

	// inform success
	return S_OK;
}

// ***************************************************************************
// Routine Description:
//		Gets the value of the property from the WMI class object
//		  
// Arguments:
//		[ in ] pWmiObject		: pointer to the WBEM class object
//		[ in ] szProperty		: property name
//		[ out ] varValue		: value of the property
//  
// Return Value:
//		HRESULT - result of the operation
// 
// ***************************************************************************
HRESULT PropertyGet( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty, _variant_t& varValue )
{
	// local variables
	HRESULT hr;
	VARIANT vtValue;

	// check with object and property passed to the function are valid or not
	// if not, return failure
	if ( pWmiObject == NULL || pwszProperty == NULL )
		return WBEM_E_INVALID_PARAMETER;

	try
	{
		// initialize the variant and then get the value of the specified property
		VariantInit( &vtValue );
		hr = pWmiObject->Get( _bstr_t( pwszProperty ), 0, &vtValue, NULL, NULL );
		if ( FAILED( hr ) )
		{
			// clear the variant variable
			VariantClear( &vtValue );

			// failed to get the value for the property
			return hr;
		}

		// set the value
		varValue = vtValue;

		// clear the variant variable
		VariantClear( &vtValue );
	}
	catch( _com_error& e )
	{
		WMISaveError( e );
		return e.Error();
	}

	// inform success
	return S_OK;
}

// ***************************************************************************
// Routine Description:
//		Gets the value of the property from the WMI class object in string format
//		  
// Arguments:
//  
// Return Value:
//		TRUE - if operation is successfull, otherwise FALSE
// 
// ***************************************************************************
BOOL PropertyGet( IWbemClassObject* pWmiObject, 
				  LPCWSTR pwszProperty, CHString& strValue, LPCWSTR pwszDefault )
{
	// local variables
	HRESULT hr;
	_variant_t var;

	// first copy the default value
	strValue = pwszDefault;

	// check with object and property passed to the function are valid or not
	// if not, return failure
	if ( pWmiObject == NULL || pwszProperty == NULL )
		return FALSE;

	// get the property value
	hr = PropertyGet( pWmiObject, pwszProperty, var );
	if ( FAILED( hr ) )
		return FALSE;

	try
	{
		// get the value
		if ( var.vt != VT_NULL && var.vt != VT_EMPTY )
			strValue = (LPCWSTR) _bstr_t( var );
	}
	catch( ... )
	{
		SetLastError( E_OUTOFMEMORY );
		SaveLastError();
		return FALSE;
	}

	// return
	return TRUE;
}

// ***************************************************************************
// Routine Description:
//		Gets the value of the property from the WMI class object in string format
//		  
// Arguments:
//		[ in ] pWmiObject		: pointer to the WBEM class object
//		[ in ] pwszProperty		: property name
//		[ out ] pdwValue		: value of the property
//		[ in ] dwDefault		: default in case failed in getting property value
//  
// Return Value:
//		TRUE - if operation is successfull, otherwise FALSE
// 
// ***************************************************************************
BOOL PropertyGet( IWbemClassObject* pWmiObject, 
				  LPCWSTR pwszProperty,  DWORD& dwValue, DWORD dwDefault )
{
	// local variables
	HRESULT hr;
	_variant_t var;

	// first set the defaul value
	dwValue = dwDefault;

	// check with object and property passed to the function are valid or not
	// if not, return failure
	if ( pWmiObject == NULL || pwszProperty == NULL )
		return FALSE;

	// get the value of the property
	hr = PropertyGet( pWmiObject, pwszProperty, var );
	if ( FAILED( hr ) )
		return FALSE;

	// get the process id from the variant
	if ( var.vt != VT_NULL && var.vt != VT_EMPTY )
		dwValue = (LONG) var;

	// return
	return TRUE;
}

// ***************************************************************************
// Routine Description:
//		Gets the value of the property from the WMI class object in string format
//		  
// Arguments:
//  
// Return Value:
//		TRUE - if operation is successfull, otherwise FALSE
// 
// ***************************************************************************
BOOL PropertyGet( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty,  ULONGLONG& ullValue )
{
	// local variables
	CHString str;

	// first set the default value
	ullValue = 1;

	// check with object and property passed to the function are valid or not
	// if not, return failure
	if ( pWmiObject == NULL || pwszProperty == NULL )
		return FALSE;

	// get the value of the property
	if ( PropertyGet( pWmiObject, pwszProperty, str, _T( "0" ) ) == FALSE )
		return FALSE;

	// get the 64-bit value
	ullValue = _wtoi64( str );

	// return
	return TRUE;
}

// ***************************************************************************
// Routine Description:
//		Gets the value of the property from the WMI class object in string format
//		  
// Arguments:
//  
// Return Value:
//		TRUE - if operation is successfull, otherwise FALSE
// 
// ***************************************************************************
BOOL PropertyGet( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty,  WBEMTime& wbemtime )
{
	// local variables
	CHString str;

	// Clear method sets the time in the WBEMTime object to an invalid time.
	wbemtime.Clear();

	// check with object and property passed to the function are valid or not
	// if not, return failure
	if ( pWmiObject == NULL || pwszProperty == NULL )
		return FALSE;

	// get the value of the property
	if ( PropertyGet( pWmiObject, pwszProperty, str, _T( "0" ) ) == FALSE )
		return FALSE;

	try
	{
		// convert into the time value
		wbemtime = _bstr_t( str );
	}
	catch( _com_error& e )
	{
		WMISaveError( e );
		return FALSE;
	}

	// return
	return TRUE;
}

// ***************************************************************************
// Routine Description:
//		Gets the value of the property from the WMI class object in string format
//		  
// Arguments:
//  
// Return Value:
//		TRUE - if operation is successfull, otherwise FALSE
// 
// ***************************************************************************
BOOL PropertyGet( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty,  SYSTEMTIME& systime )
{
	// local variables
	CHString strTime;

	// check with object and property passed to the function are valid or not
	// if not, return failure
	if ( pWmiObject == NULL || pwszProperty == NULL )
		return FALSE;

	// get the value of the property
	// 16010101000000.000000+000 is the default time
	if ( PropertyGet( pWmiObject, pwszProperty, strTime, _T( "16010101000000.000000+000" ) ) == FALSE )
		return FALSE;

	// prepare the systemtime structure
	// yyyymmddHHMMSS.mmmmmmsUUU
	systime.wYear = (WORD) AsLong( strTime.Left( 4 ), 10 );
	systime.wMonth = (WORD) AsLong( strTime.Mid( 4, 2 ), 10 );
	systime.wDayOfWeek = 0;
	systime.wDay = (WORD) AsLong( strTime.Mid( 6, 2 ), 10 );
	systime.wHour = (WORD) AsLong( strTime.Mid( 8, 2 ), 10 );
	systime.wMinute = (WORD) AsLong( strTime.Mid( 10, 2 ), 10 );
	systime.wSecond = (WORD) AsLong( strTime.Mid( 12, 2 ), 10 );
	systime.wMilliseconds = (WORD) AsLong( strTime.Mid( 15, 6 ), 10 );

	// return
	return TRUE;
}

// ***************************************************************************
// Routine Description:
//		Gets the value of the property from the WMI class object in string format
//		  
// Arguments:
//  
// Return Value:
//		TRUE - if operation is successfull, otherwise FALSE
// 
// ***************************************************************************
BOOL PropertyGet( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty, TARRAY arr )
{
	// local variables
	HRESULT hr;
	VARIANT vtValue;
	LONG lIndex = 0;
	LONG lLBound = 0;
	LONG lUBound = 0;
	VARTYPE vartype;
	SAFEARRAY* pSafeArray = NULL;

	// check the inputs
	if ( pWmiObject == NULL || pwszProperty == NULL || arr == NULL )
		return FALSE;

	// initialize the variant
	VariantInit( &vtValue );

	// now get the property value
	hr = PropertyGet( pWmiObject, pwszProperty, &vtValue );
	if ( FAILED( hr ) )
		return FALSE;

	if ( V_VT( &vtValue ) == VT_NULL )
		return TRUE;

		// confirm that the propety value is of array type .. if not return
	if ( ( V_VT( &vtValue ) & VT_ARRAY ) == 0 )
		return FALSE;

	// get the safearray value
	pSafeArray = V_ARRAY( &vtValue );

	// get the bounds of the array
    SafeArrayGetLBound( pSafeArray, 1, &lLBound );
    SafeArrayGetUBound( pSafeArray, 1, &lUBound );

	// get the type of the elements in the safe array
	vartype = V_VT( &vtValue ) & ~VT_ARRAY;

	try
	{
		// traverse thru the values in the safe array and update into dynamic array
		for( lIndex = lLBound; lIndex <= lUBound; lIndex++ )
		{
			// sub-local variables
			VARIANT var;
			CHString strValue;
			
			// get the value
			V_VT( &var ) = vartype;
			SafeArrayGetElement( pSafeArray, &lIndex, &V_UI1( &var ) );

			// add the information to the dynamic array
			switch( vartype )
			{
			case VT_BSTR:
				strValue = V_BSTR( &var );
				DynArrayAppendString( arr, strValue, 0 );
				break;
			}
		}
	}
	catch( ... )
	{
		// clear the variant
		VariantClear( &vtValue );
		return FALSE;	// failure
	}

	// clear the variant
	VariantClear( &vtValue );

	// return
	return TRUE;
}

// ***************************************************************************
// Routine Description:
//		Sets the value of the property to the WMI class object
//		  
// Arguments:
//		[ in ] pWmiObject		: pointer to the WBEM class object
//		[ in ] szProperty		: property name
//		[ in ] varValue	: value of the property
//  
// Return Value:
//		HRESULT - result of the operation
// 
// ***************************************************************************
HRESULT PropertyPut( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty, _variant_t& varValue )
{
	// local variables
	HRESULT hr;
	VARIANT var;

	// check the input value
	if ( pWmiObject == NULL || pwszProperty == NULL )
		return WBEM_E_INVALID_PARAMETER;

	try
	{
		// put the value
		var = varValue;
		hr = pWmiObject->Put( _bstr_t( pwszProperty ), 0, &var, 0 );
	}
	catch( _com_error& e )
	{
		WMISaveError( e );
		hr = e.Error();
	}
	
	// return the result
	return hr;
}

// ***************************************************************************
// Routine Description:
//		Sets the value of the property to the WMI class object
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
HRESULT PropertyPut( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty, LPCWSTR pwszValue )
{
	// local variables
	HRESULT hr;
	_variant_t varValue;

	// check the input value
	if ( pWmiObject == NULL || pwszProperty == NULL || pwszValue == NULL )
		return WBEM_E_INVALID_PARAMETER;

	try
	{
		varValue = pwszValue;
		hr = PropertyPut( pWmiObject, pwszProperty, varValue );
	}
	catch( _com_error& e )
	{
		WMISaveError( e );
		hr = e.Error();
	}

	// return 
	return hr;
}

// ***************************************************************************
// Routine Description:
//		Sets the value of the property to the WMI class object
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
HRESULT PropertyPut( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty, DWORD dwValue )
{
	// local variables
	HRESULT hr;
	_variant_t varValue;

	// check the input value
	if ( pWmiObject == NULL || pwszProperty == NULL )
		return WBEM_E_INVALID_PARAMETER;

	try
	{
		varValue = ( LONG ) dwValue;
		hr = PropertyPut( pWmiObject, pwszProperty, varValue );
	}
	catch( _com_error& e )
	{
		WMISaveError( e );
		hr = e.Error();
	}

	// return 
	return hr;
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
HRESULT RegQueryValueWMI( IWbemServices* pWbemServices, 
						  LPCWSTR pwszMethod, DWORD dwHDefKey, 
						  LPCWSTR pwszSubKeyName, LPCWSTR pwszValueName, _variant_t& varValue )
{
	// local variables
	HRESULT hr;
	BOOL bResult = FALSE;
	DWORD dwReturnValue = 0;
	IWbemClassObject* pClass = NULL;
	IWbemClassObject* pMethod = NULL;
	IWbemClassObject* pInParams = NULL;
	IWbemClassObject* pInParamsInstance = NULL;
	IWbemClassObject* pOutParamsInstance = NULL;

	// check the input value
	if (pWbemServices == NULL || pwszMethod == NULL || pwszSubKeyName == NULL || pwszValueName == NULL)
		return WBEM_E_INVALID_PARAMETER;

	try
	{
		// get the registry class object
		SAFE_EXECUTE( pWbemServices->GetObject( 
			_bstr_t( WMI_REGISTRY ), WBEM_FLAG_RETURN_WBEM_COMPLETE, NULL, &pClass, NULL ) );
		if ( pClass == NULL )						// check the object .. safety sake
			_com_issue_error( STG_E_UNKNOWN );

		// get the method reference required
		SAFE_EXECUTE( pClass->GetMethod( pwszMethod, 0, &pInParams, NULL ) );
		if ( pInParams == NULL )					// check the object .. safety sake
			_com_issue_error( STG_E_UNKNOWN );

		// create the instance for the in parameters
		SAFE_EXECUTE( pInParams->SpawnInstance( 0, &pInParamsInstance ) );
		if ( pInParamsInstance == NULL )
			_com_issue_error( STG_E_UNKNOWN );

		// set the input values
		PropertyPut( pInParamsInstance, _bstr_t( WMI_REGISTRY_IN_HDEFKEY ), dwHDefKey );
		PropertyPut( pInParamsInstance, _bstr_t( WMI_REGISTRY_IN_SUBKEY ), pwszSubKeyName );
		PropertyPut( pInParamsInstance, _bstr_t( WMI_REGISTRY_IN_VALUENAME ), pwszValueName );

		// now execute the method
		SAFE_EXECUTE( pWbemServices->ExecMethod( _bstr_t( WMI_REGISTRY ),
			_bstr_t( pwszMethod ), 0, NULL, pInParamsInstance, &pOutParamsInstance, NULL ) );
		if ( pOutParamsInstance == NULL )			// check the object .. safety sake
			_com_issue_error( STG_E_UNKNOWN );

		// now check the return value of the method from the output params object
		bResult = PropertyGet( pOutParamsInstance, 
			_bstr_t( WMI_REGISTRY_OUT_RETURNVALUE ), dwReturnValue );
		if ( bResult == FALSE || dwReturnValue != 0 )
			_com_issue_error( STG_E_UNKNOWN );

		// now everything is sucess .. get the required value
		PropertyGet( pOutParamsInstance, _bstr_t( WMI_REGISTRY_OUT_VALUE ), varValue );
	}
	catch( _com_error& e )
	{
		WMISaveError( e );
		return e.Error();
	}

	// release the interfaces
	SAFE_RELEASE( pClass );
	SAFE_RELEASE( pMethod );
	SAFE_RELEASE( pInParams );
	SAFE_RELEASE( pInParamsInstance );
	SAFE_RELEASE( pOutParamsInstance );

	// return success
	return S_OK;
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
BOOL RegQueryValueWMI( IWbemServices* pWbemServices, 
					   DWORD dwHDefKey, LPCWSTR pwszSubKeyName, 
					   LPCWSTR pwszValueName, CHString& strValue, LPCWSTR pwszDefault )
{
	// local variables
	HRESULT hr;
	_variant_t varValue;

	try
	{
		// set the default value
		if ( pwszDefault != NULL )
			strValue = pwszDefault;

		// check the input
		if ( pWbemServices == NULL || pwszSubKeyName == NULL || pwszValueName == NULL )
			return FALSE;

		// get the value
		hr = RegQueryValueWMI( pWbemServices, 
			WMI_REGISTRY_M_STRINGVALUE, dwHDefKey, pwszSubKeyName, pwszValueName, varValue );
		if ( FAILED( hr ) )
			return FALSE;

		// get the value from the variant
		// get the value
		if ( varValue.vt != VT_NULL && varValue.vt != VT_EMPTY )
			strValue = (LPCWSTR) _bstr_t( varValue );
	}
	catch( ... )
	{
		SetLastError( E_OUTOFMEMORY );
		SaveLastError();
		return FALSE;
	}

	// return success
	return TRUE;
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
DWORD GetTargetVersionEx( IWbemServices* pWbemServices, COAUTHIDENTITY* pAuthIdentity )
{
	// local variables
	HRESULT hr;
	LONG lPos = 0;
	DWORD dwMajor = 0;
	DWORD dwMinor = 0;
	DWORD dwVersion = 0;
	ULONG ulReturned = 0;
	CHString strVersion;
	IWbemClassObject* pWbemObject = NULL;
	IEnumWbemClassObject* pWbemInstances = NULL;

	// check the input value
	if ( pWbemServices == NULL )
		return 0;

	try
	{
		// get the OS information
		SAFE_EXECUTE( pWbemServices->CreateInstanceEnum( 
			_bstr_t( CLASS_CIMV2_Win32_OperatingSystem ), 0, NULL, &pWbemInstances ) );

		// set the security on the enumerated object
		SAFE_EXECUTE( SetInterfaceSecurity( pWbemInstances, pAuthIdentity ) );

		// get the enumerated objects information
		// NOTE: This needs to be traversed only one time. 
		SAFE_EXECUTE( pWbemInstances->Next( WBEM_INFINITE, 1, &pWbemObject, &ulReturned ) );

		// to be on safer side ... check the count of objects returned
		if ( ulReturned == 0 )
		{
			// release the interfaces
			SAFE_RELEASE( pWbemObject );
			SAFE_RELEASE( pWbemInstances );
			return 0;
		}

		// now get the os version value
		if ( PropertyGet( pWbemObject, L"Version", strVersion ) == FALSE )
		{
			// release the interfaces
			SAFE_RELEASE( pWbemObject );
			SAFE_RELEASE( pWbemInstances );
			return 0;
		}

		// release the interfaces .. we dont need them furthur
		SAFE_RELEASE( pWbemObject );
		SAFE_RELEASE( pWbemInstances );
	
		//
		// now determine the os version
		dwMajor = dwMinor = 0;

		// get the major version
		lPos = strVersion.Find( L'.' );
		if ( lPos == -1 )
		{
			// the version string itself is version ... THIS WILL NEVER HAPPEN
			dwMajor = AsLong( strVersion, 10 );
		}
		else
		{
			// major version
			dwMajor = AsLong( strVersion.Mid( 0, lPos ), 10 );

			// get the minor version
			strVersion = strVersion.Mid( lPos + 1 );
			lPos = strVersion.Find( L'.' );
			if ( lPos == -1 )
				dwMinor = AsLong( strVersion, 10 );
			else
				dwMinor = AsLong( strVersion.Mid( 0, lPos ), 10 );
		}

		// mix the version info
		dwVersion = dwMajor * 1000 + dwMinor;
	}
	catch( _com_error& e )
	{
		WMISaveError( e );
		return 0;
	}

	// return 
	return dwVersion;
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
DWORD GetTargetPlatformEx( IWbemServices* pWbemServices, COAUTHIDENTITY* pAuthIdentity )
{
	// local variables
	HRESULT hr;
	LONG lPos = 0;
	CHString strType;
	ULONG ulReturned = 0;
	IWbemClassObject* pWbemObject = NULL;
	IEnumWbemClassObject* pWbemInstances = NULL;

	// check the input value
	if ( pWbemServices == NULL )
		return 0;

	try
	{
		// get the OS information
		SAFE_EXECUTE( pWbemServices->CreateInstanceEnum( 
			_bstr_t( CLASS_CIMV2_Win32_ComputerSystem ), 0, NULL, &pWbemInstances ) );

		// set the security on the enumerated object
		SAFE_EXECUTE( SetInterfaceSecurity( pWbemInstances, pAuthIdentity ) );

		// get the enumerated objects information
		// NOTE: This needs to be traversed only one time. 
		SAFE_EXECUTE( pWbemInstances->Next( WBEM_INFINITE, 1, &pWbemObject, &ulReturned ) );

		// to be on safer side ... check the count of objects returned
		if ( ulReturned == 0 )
		{
			// release the interfaces
			SAFE_RELEASE( pWbemObject );
			SAFE_RELEASE( pWbemInstances );
			return 0;
		}

		// now get the os version value
		if ( PropertyGet( pWbemObject, L"SystemType", strType ) == FALSE )
		{
			// release the interfaces
			SAFE_RELEASE( pWbemObject );
			SAFE_RELEASE( pWbemInstances );
			return 0;
		}

		// release the interfaces .. we dont need them furthur
		SAFE_RELEASE( pWbemObject );
		SAFE_RELEASE( pWbemInstances );

		// determine the type of the platform
		if ( strType.Find( TEXT_X86 ) != -1 )
			return PLATFORM_X86;
		else if ( strType.Find( TEXT_IA64 ) != -1 )
			return PLATFORM_IA64;
		else if ( strType.Find( TEXT_AMD64 ) != -1 )
			return PLATFORM_AMD64;
	}
	catch( _com_error& e )
	{
		WMISaveError( e );
		return 0;
	}

	// return 
	return PLATFORM_UNKNOWN;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cmdline\tasklist\tasklist.h ===
// *********************************************************************************
// 
//  Copyright (c) Microsoft Corporation
//  
//  Module Name:
//
//		TaskList.h  
//  
//  Abstract:
//  
//		macros and function prototypes of TList.cpp
//  
//  Author:
//  
// 	  Sunil G.V.N. Murali (murali.sunil@wipro.com) 24-Sep-2000
//  
//  Revision History:
//  
// 	  Sunil G.V.N. Murali (murali.sunil@wipro.com) 24-Sep-2000 : Created It.
//  
// *********************************************************************************

#ifndef _TASKLIST_H
#define _TASKLIST_H

// resource header file
#include "resource.h"

//
// NOTE: THIS MODULE WILL WRITTEN IN SUCH A FASHION THAT IT WORKS ONLY
//       IN UNICODE BUILD COMPILATION
//
#ifndef UNICODE
#error Must compile only in unicode build environment
#endif

//
// general purpose macros
//
#define EXIT_PROCESS( exitcode )	\
	ReleaseGlobals();	\
	return exitcode;	\
	1

#define HEAP_FREE( pointer )	\
	if ( (pointer) != NULL )	\
	{	\
		HeapFree( GetProcessHeap(), 0, (pointer) );	\
		(pointer) = NULL;	\
	}	\
	1

#define SHOW_MESSAGE_EX( tag, message )	\
	{	\
		CHString strBuffer;	\
		strBuffer.Format( L"%s %s", tag, message );	\
		ShowMessage( stderr, strBuffer );	\
	}	\
	1

//
// winstation related structures ( extract from winsta.h - internal file )
//

//
// structures
typedef struct _CITRIX_PROCESS_INFORMATION {
	ULONG MagicNumber;
	ULONG LogonId;
	PVOID ProcessSid;
	ULONG Pad;
} CITRIX_PROCESS_INFORMATION, * PCITRIX_PROCESS_INFORMATION;

// ...
typedef struct _TS_UNICODE_STRING {
	USHORT Length;
	USHORT MaximumLength;
	PWSTR  Buffer;
} TS_UNICODE_STRING;

// CAUTION:
// TS_SYSTEM_PROCESS_INFORMATION is duplicated from ntexapi.h, and slightly modified.
// (not nice, but necessary because the Midl compiler doesn't like PVOID !)
typedef struct _TS_SYSTEM_PROCESS_INFORMATION {
	ULONG NextEntryOffset;
	ULONG NumberOfThreads;
	LARGE_INTEGER SpareLi1;
	LARGE_INTEGER SpareLi2;
	LARGE_INTEGER SpareLi3;
	LARGE_INTEGER CreateTime;
	LARGE_INTEGER UserTime;
	LARGE_INTEGER KernelTime;
	TS_UNICODE_STRING ImageName;
	LONG BasePriority;                     // KPRIORITY in ntexapi.h
	DWORD UniqueProcessId;                 // HANDLE in ntexapi.h
	DWORD InheritedFromUniqueProcessId;    // HANDLE in ntexapi.h
	ULONG HandleCount;
	ULONG SessionId;
	ULONG SpareUl3;
	SIZE_T PeakVirtualSize;
	SIZE_T VirtualSize;
	ULONG PageFaultCount;
	ULONG PeakWorkingSetSize;
	ULONG WorkingSetSize;
	SIZE_T QuotaPeakPagedPoolUsage;
	SIZE_T QuotaPagedPoolUsage;
	SIZE_T QuotaPeakNonPagedPoolUsage;
	SIZE_T QuotaNonPagedPoolUsage;
	SIZE_T PagefileUsage;
	SIZE_T PeakPagefileUsage;
	SIZE_T PrivatePageCount;
} TS_SYSTEM_PROCESS_INFORMATION, *PTS_SYSTEM_PROCESS_INFORMATION;

// ...
typedef struct _TS_ALL_PROCESSES_INFO {
	PTS_SYSTEM_PROCESS_INFORMATION pspiProcessInfo;
	DWORD SizeOfSid;
	PBYTE pSid;
} TS_ALL_PROCESSES_INFO, *PTS_ALL_PROCESSES_INFO;

// defines
#define SERVERNAME_CURRENT						((HANDLE)NULL)
#define GAP_LEVEL_BASIC							0
#define CITRIX_PROCESS_INFO_MAGIC				0x23495452
#define WINSTATIONNAME_LENGTH					64
#define WINSTA_DLLNAME							L"Winsta.dll"
#define FUNCNAME_WinStationFreeMemory			"WinStationFreeMemory"
#define FUNCNAME_WinStationCloseServer			"WinStationCloseServer"
#define FUNCNAME_WinStationOpenServerW			"WinStationOpenServerW"
#define FUNCNAME_WinStationEnumerateProcesses	"WinStationEnumerateProcesses"
#define FUNCNAME_WinStationFreeGAPMemory		"WinStationFreeGAPMemory"
#define FUNCNAME_WinStationGetAllProcesses		"WinStationGetAllProcesses"
#define FUNCNAME_WinStationNameFromLogonIdW		"WinStationNameFromLogonIdW"
#define SIZEOF_SYSTEM_THREAD_INFORMATION		sizeof( struct SYSTEM_THREAD_INFORMATION )
#define SIZEOF_SYSTEM_PROCESS_INFORMATION		sizeof( struct SYSTEM_PROCESS_INFORMATION )

//
// function prototypes
typedef BOOLEAN (WINAPI * FUNC_WinStationFreeMemory)( PVOID pBuffer );
typedef BOOLEAN (WINAPI * FUNC_WinStationCloseServer)( HANDLE hServer );
typedef HANDLE  (WINAPI * FUNC_WinStationOpenServerW)( LPWSTR pwszServerName );
typedef BOOLEAN (WINAPI * FUNC_WinStationNameFromLogonIdW)( HANDLE hServer, 
														    ULONG LogonId, LPWSTR pwszWinStationName );
typedef BOOLEAN (WINAPI * FUNC_WinStationEnumerateProcesses)( HANDLE  hServer, PVOID *ppProcessBuffer );
typedef BOOLEAN (WINAPI * FUNC_WinStationFreeGAPMemory)( ULONG Level, 
													     PVOID ProcessArray, ULONG ulCount );
typedef BOOLEAN (WINAPI * FUNC_WinStationGetAllProcesses)( HANDLE hServer, 
														   ULONG Level, ULONG *pNumberOfProcesses, 
														   PVOID *ppProcessArray );

//
// constants / defines / enumerations
//

//
// WMI related stuff

// class name
#define CLASS_PROCESS								L"Win32_Process"

// wmi query
#define WMI_QUERY_TYPE					L"WQL"
#define WMI_SERVICE_QUERY				L"SELECT Name FROM Win32_Service WHERE ProcessId = %d and State=\"Running\""
#define WMI_MODULES_QUERY				L"ASSOCIATORS OF {%s} WHERE ResultClass = CIM_DataFile"
#define WMI_PROCESS_QUERY		\
	L"SELECT " \
	L"__PATH, ProcessId, CSName, Caption, SessionId, ThreadCount, "	\
	L"WorkingSetSize, KernelModeTime, UserModeTime "	\
	L" FROM Win32_Process"

// wmi query operators etc
#define WMI_QUERY_FIRST_CLAUSE		L"WHERE"
#define WMI_QUERY_SECOND_CLAUSE		L"AND"

// Win32_Process class properties
#define WIN32_PROCESS_SYSPROPERTY_PATH				L"__PATH"
#define WIN32_PROCESS_PROPERTY_HANDLE				L"Handle"
#define WIN32_PROCESS_PROPERTY_COMPUTER				L"CSName"
#define WIN32_PROCESS_PROPERTY_IMAGENAME			L"Caption"
#define WIN32_PROCESS_PROPERTY_PROCESSID			L"ProcessId"
#define WIN32_PROCESS_PROPERTY_SESSION				L"SessionId"
#define WIN32_PROCESS_PROPERTY_THREADS				L"ThreadCount"
#define WIN32_PROCESS_PROPERTY_USERMODETIME			L"UserModeTime"
#define WIN32_PROCESS_PROPERTY_MEMUSAGE				L"WorkingSetSize"
#define WIN32_PROCESS_PROPERTY_KERNELMODETIME		L"KernelModeTime"

// Win32_Process class method(s)
#define WIN32_PROCESS_METHOD_GETOWNER				L"GetOwner"

// GetOwner method's return values
#define GETOWNER_RETURNVALUE_USER					L"User"
#define GETOWNER_RETURNVALUE_DOMAIN					L"Domain"

// function default return value
#define WMI_RETURNVALUE								L"ReturnValue"

// Win32_Service related stuff
#define WIN32_SERVICE_PROPERTY_NAME					L"Name"

// CIM_DataFile related stuff
#define CIM_DATAFILE_PROPERTY_FILENAME				L"FileName"
#define CIM_DATAFILE_PROPERTY_EXTENSION				L"Extension"

//
// other stuff

// generals
#define VALUE_RUNNING				GetResString( IDS_VALUE_RUNNING )
#define VALUE_NOTRESPONDING			GetResString( IDS_VALUE_NOTRESPONDING )
#define PID_0_DOMAIN				GetResString( IDS_PID_0_DOMAIN )
#define PID_0_USERNAME				GetResString( IDS_PID_0_USERNAME )
#define FMT_MODULES_FILTER			GetResString( IDS_FMT_MODULES_FILTER )

// error messages
#define ERROR_USERNAME_BUT_NOMACHINE	GetResString( IDS_ERROR_USERNAME_BUT_NOMACHINE )
#define ERROR_PASSWORD_BUT_NOUSERNAME	GetResString( IDS_ERROR_PASSWORD_BUT_NOUSERNAME )
#define ERROR_NODATA_AVAILABLE			GetResString( IDS_ERROR_NODATA_AVAILABLE )
#define ERROR_USERNAME_EMPTY			GetResString( IDS_ERROR_USERNAME_EMPTY )
#define ERROR_NH_NOTSUPPORTED			GetResString( IDS_ERROR_NH_NOTSUPPORTED )
#define ERROR_M_SVC_V_CANNOTBECOUPLED	GetResString( IDS_ERROR_M_SVC_V_CANNOTBECOUPLED )
#define ERROR_SERVERNAME_EMPTY			GetResString( IDS_ERROR_SERVERNAME_EMPTY )
#define ERROR_INVALID_USAGE_REQUEST		GetResString( IDS_ERROR_INVALID_USAGE_REQUEST )
#define ERROR_M_CHAR_AFTER_WILDCARD		GetResString( IDS_ERROR_M_CHAR_AFTER_WILDCARD )
#define ERROR_PLATFORM_SHOULD_BE_X86	GetResString( IDS_ERROR_PLATFORM_SHOULD_BE_X86 )

// progress messages
#define MSG_MODULESINFO					GetResString( IDS_MSG_MODULESINFO )
#define MSG_MODULESINFO_EX				GetResString( IDS_MSG_MODULESINFO_EX )
#define MSG_SERVICESINFO				GetResString( IDS_MSG_SERVICESINFO )
#define MSG_TASKSINFO					GetResString( IDS_MSG_TASKSINFO )

// output formats
#define TEXT_FORMAT_LIST		GetResString( IDS_TEXT_FORMAT_LIST )
#define TEXT_FORMAT_TABLE		GetResString( IDS_TEXT_FORMAT_TABLE )
#define TEXT_FORMAT_CSV			GetResString( IDS_TEXT_FORMAT_CSV )

//
// column heading names and their indexes in the array ( in fact positions )
#define MAX_COLUMNS				12

// column headings
#define COLHEAD_HOSTNAME		GetResString( IDS_COLHEAD_HOSTNAME )
#define COLHEAD_STATUS			GetResString( IDS_COLHEAD_STATUS )
#define COLHEAD_IMAGENAME		GetResString( IDS_COLHEAD_IMAGENAME )
#define COLHEAD_PID				GetResString( IDS_COLHEAD_PID )
#define COLHEAD_SESSION			GetResString( IDS_COLHEAD_SESSION )
#define COLHEAD_USERNAME		GetResString( IDS_COLHEAD_USERNAME )
#define COLHEAD_WINDOWTITLE		GetResString( IDS_COLHEAD_WINDOWTITLE )
#define COLHEAD_CPUTIME			GetResString( IDS_COLHEAD_CPUTIME )
#define COLHEAD_MEMUSAGE		GetResString( IDS_COLHEAD_MEMUSAGE )
#define COLHEAD_SERVICES		GetResString( IDS_COLHEAD_SERVICES )
#define COLHEAD_SESSIONNAME		GetResString( IDS_COLHEAD_SESSIONNAME )
#define COLHEAD_MODULES			GetResString( IDS_COLHEAD_MODULES )

// indexes
#define CI_HOSTNAME			TASK_HOSTNAME
#define CI_STATUS			TASK_STATUS
#define CI_IMAGENAME		TASK_IMAGENAME
#define CI_PID				TASK_PID
#define CI_SESSION			TASK_SESSION
#define CI_USERNAME			TASK_USERNAME	
#define CI_WINDOWTITLE		TASK_WINDOWTITLE
#define CI_CPUTIME			TASK_CPUTIME
#define CI_MEMUSAGE			TASK_MEMUSAGE
#define CI_SERVICES			TASK_SERVICES
#define CI_SESSIONNAME		TASK_SESSIONNAME
#define CI_MODULES			TASK_MODULES

// column widths
#define COLWIDTH_HOSTNAME		AsLong( GetResString( IDS_COLWIDTH_HOSTNAME ), 10 )
#define COLWIDTH_STATUS			AsLong( GetResString( IDS_COLWIDTH_STATUS ), 10 )
#define COLWIDTH_IMAGENAME		AsLong( GetResString( IDS_COLWIDTH_IMAGENAME ), 10 )
#define COLWIDTH_PID			AsLong( GetResString( IDS_COLWIDTH_PID ), 10 )
#define COLWIDTH_SESSION		AsLong( GetResString( IDS_COLWIDTH_SESSION ), 10 )
#define COLWIDTH_USERNAME		AsLong( GetResString( IDS_COLWIDTH_USERNAME ), 10 )
#define COLWIDTH_WINDOWTITLE	AsLong( GetResString( IDS_COLWIDTH_WINDOWTITLE ), 10 )
#define COLWIDTH_CPUTIME		AsLong( GetResString( IDS_COLWIDTH_CPUTIME	), 10 )
#define COLWIDTH_MEMUSAGE		AsLong( GetResString( IDS_COLWIDTH_MEMUSAGE	), 10 )
#define COLWIDTH_SERVICES		AsLong( GetResString( IDS_COLWIDTH_SERVICES	), 10 )
#define COLWIDTH_SERVICES_WRAP  AsLong( GetResString( IDS_COLWIDTH_SERVICES_WRAP ), 10 )
#define COLWIDTH_SESSIONNAME	AsLong( GetResString( IDS_COLWIDTH_SESSIONNAME ), 10 )
#define COLWIDTH_MODULES		AsLong( GetResString( IDS_COLWIDTH_MODULES ), 10 )
#define COLWIDTH_MODULES_WRAP	AsLong( GetResString( IDS_COLWIDTH_MODULES_WRAP ), 10 )

//
// command line options

// command line options and their indexes in the array
#define MAX_OPTIONS			10

// options allowed ( no need to localize )
#define OPTION_USAGE		L"?"
#define OPTION_SERVER		L"s"
#define OPTION_USERNAME		L"u"
#define OPTION_PASSWORD		L"p"
#define OPTION_FILTER		L"fi"
#define OPTION_FORMAT		L"fo"
#define OPTION_NOHEADER		L"nh"
#define OPTION_VERBOSE		L"v"
#define OPTION_SVC			L"svc"
#define OPTION_MODULES		L"m"

// option indexes
#define OI_USAGE					0
#define OI_SERVER					1
#define OI_USERNAME					2
#define OI_PASSWORD					3
#define OI_FILTER					4
#define OI_FORMAT					5
#define OI_NOHEADER					6
#define OI_VERBOSE					7
#define OI_SVC						8
#define OI_MODULES					9

// values allowed for format
#define OVALUES_FORMAT			GetResString( IDS_OVALUES_FORMAT )

//
// filter details
#define MAX_FILTERS			11

// filter allowed
#define FILTER_SESSIONNAME		GetResString( IDS_FILTER_SESSIONNAME )
#define FILTER_STATUS			GetResString( IDS_FILTER_STATUS	)
#define FILTER_IMAGENAME		GetResString( IDS_FILTER_IMAGENAME )
#define FILTER_PID				GetResString( IDS_FILTER_PID )
#define FILTER_SESSION			GetResString( IDS_FILTER_SESSION )
#define FILTER_CPUTIME			GetResString( IDS_FILTER_CPUTIME )
#define FILTER_MEMUSAGE			GetResString( IDS_FILTER_MEMUSAGE )
#define FILTER_USERNAME			GetResString( IDS_FILTER_USERNAME )
#define FILTER_SERVICES			GetResString( IDS_FILTER_SERVICES )
#define FILTER_WINDOWTITLE		GetResString( IDS_FILTER_WINDOWTITLE )
#define FILTER_MODULES			GetResString( IDS_FILTER_MODULES )

// indexes
#define FI_SESSIONNAME		0
#define FI_STATUS			1
#define FI_IMAGENAME		2
#define FI_PID				3
#define FI_SESSION			4
#define FI_CPUTIME			5
#define FI_MEMUSAGE			6
#define FI_USERNAME			7
#define FI_SERVICES			8
#define FI_WINDOWTITLE		9
#define FI_MODULES			10

// values allowed for status
#define FVALUES_STATUS		GetResString( IDS_FVALUES_STATUS )

// operators
#define OPERATORS_STRING	GetResString( IDS_OPERATORS_STRING )
#define OPERATORS_NUMERIC	GetResString( IDS_OPERATORS_NUMERIC )

// max. columns ( information ) to be stored for one task
#define MAX_TASKSINFO			17

// task info indexes
#define TASK_HOSTNAME			0
#define TASK_IMAGENAME			1
#define TASK_PID				2
#define TASK_SESSIONNAME		3
#define TASK_SESSION			4
#define TASK_MEMUSAGE			5
#define TASK_STATUS				6
#define TASK_USERNAME			7
#define TASK_CPUTIME			8
#define TASK_WINDOWTITLE		9
#define TASK_SERVICES			10
#define TASK_MODULES			11

// always hidden
#define TASK_HWND				12
#define TASK_WINSTA				13
#define TASK_DESK				14
#define TASK_CREATINGPROCESSID	15
#define TASK_OBJPATH			16

//
// CTaskList
//
class CTaskList
{
public:
	// enumerators
	enum 
	{
		twiProcessId = 0,
		twiWinSta = 1,
		twiDesktop = 2,
		twiHandle = 3,
		twiTitle = 4,
		twiCOUNT,
	};

// constructor / destructor
public:
	CTaskList();
	~CTaskList();

// data memebers
private:
	// WMI / COM interfaces
	IWbemLocator* m_pWbemLocator;
	IWbemServices* m_pWbemServices;
	IEnumWbemClassObject* m_pEnumObjects;

	// WMI connectivity
	COAUTHIDENTITY* m_pAuthIdentity;

	// command-line argument values
	BOOL m_bVerbose;
	BOOL m_bAllServices;
	BOOL m_bAllModules;
	DWORD m_dwFormat;
	TARRAY m_arrFilters;
	CHString m_strServer;
	CHString m_strUserName;
	CHString m_strPassword;
	CHString m_strModules;

	// others
	BOOL m_bNeedPassword;				// infoms whether password has to read or not
	BOOL m_bNeedModulesInfo;
	BOOL m_bNeedServicesInfo;			// determines whether services info has to gathered or not
	BOOL m_bNeedUserContextInfo;		// determines whether userinfo has to gathered or not
	BOOL m_bNeedWindowTitles;			// determines whether window titles has to be gathered or not
	PTCOLUMNS m_pColumns;				// columns config information
	TARRAY m_arrFiltersEx;				// parsed filters info
	TARRAY m_arrWindowTitles;			// window titles
	PTFILTERCONFIG m_pfilterConfigs;	// filters config information
	CHString m_strQuery;				// optimized WMI Query for filters
	DWORD m_dwGroupSep;				// number group seperation in number formatting
	CHString m_strTimeSep;				// time seperator
	CHString m_strGroupThousSep;		// thousand sepeartion character in number formatting

	// output data
	TARRAY m_arrTasks;
	DWORD m_dwProcessId;
	CHString m_strImageName;

	// helpers .. in getting info using API
	CHString m_strUNCServer;				// server name
	BOOL m_bCloseConnection;

	// winstation related stuff
	BOOL m_bIsHydra;
	HANDLE m_hServer;
	HMODULE m_hWinstaLib;
	PBYTE m_pProcessInfo;
	ULONG m_ulNumberOfProcesses;

	// services related stuff
	DWORD m_dwServicesCount;
	LPENUM_SERVICE_STATUS_PROCESS m_pServicesInfo;

	// modules related stuff ( remote only )
	BOOL m_bUseRemote;
	PPERF_DATA_BLOCK m_pdb;

	// progress message related
	HANDLE m_hOutput;
	CONSOLE_SCREEN_BUFFER_INFO m_csbi;

	//
	// functions
	FUNC_WinStationFreeMemory m_pfnWinStationFreeMemory;
	FUNC_WinStationOpenServerW m_pfnWinStationOpenServerW;
	FUNC_WinStationCloseServer m_pfnWinStationCloseServer;
	FUNC_WinStationFreeGAPMemory m_pfnWinStationFreeGAPMemory;
	FUNC_WinStationGetAllProcesses m_pfnWinStationGetAllProcesses;
	FUNC_WinStationNameFromLogonIdW m_pfnWinStationNameFromLogonIdW;
	FUNC_WinStationEnumerateProcesses m_pfnWinStationEnumerateProcesses;

public:
	// command-line argument values
	BOOL m_bUsage;
	BOOL m_bLocalSystem;

// functions
private:

	// helpers
	VOID SetStatus( LONG lIndex, IWbemClassObject* pWmiObject );
	VOID SetCPUTime( LONG lIndex, IWbemClassObject* pWmiObject );
	VOID SetSession( LONG lIndex, IWbemClassObject* pWmiObject );
	VOID SetMemUsage( LONG lIndex, IWbemClassObject* pWmiObject );
	VOID SetUserContext( LONG lIndex, IWbemClassObject* pWmiObject );
	VOID SetWindowTitle( LONG lIndex, IWbemClassObject* pWmiObject );
	VOID SetServicesInfo( LONG lIndex, IWbemClassObject* pWmiObject );
	BOOL SetModulesInfo( LONG lIndex, IWbemClassObject* pWmiObject );
	BOOL SaveInformation( LONG lIndex, IWbemClassObject* pWmiObject );

	// ...
	BOOL LoadTasksEx();
	BOOL LoadModulesInfo();
	BOOL LoadServicesInfo();
	BOOL EnableDebugPriv();
	BOOL GetModulesOnRemote( LONG lIndex, TARRAY arrModules );
	BOOL GetModulesOnRemoteEx( LONG lIndex, TARRAY arrModules );
	BOOL LoadModulesOnLocal( LONG lIndex, TARRAY arrModules );
	BOOL LoadUserNameFromWinsta( CHString& strDomain, CHString& strUserName );

	// winsta functions
	BOOLEAN WinStationFreeMemory( PVOID pBuffer );
	BOOLEAN WinStationCloseServer( HANDLE hServer );
	HANDLE  WinStationOpenServerW( LPWSTR pwszServerName );
	BOOLEAN WinStationEnumerateProcesses( HANDLE  hServer, PVOID *ppProcessBuffer );
	BOOLEAN WinStationFreeGAPMemory( ULONG Level, PVOID ProcessArray, ULONG ulCount );
	BOOLEAN WinStationNameFromLogonIdW( HANDLE hServer,	ULONG ulLogonId, LPWSTR pwszWinStationName );
	BOOLEAN WinStationGetAllProcesses( HANDLE hServer, ULONG Level, 
									   ULONG *pNumberOfProcesses, PVOID *ppProcessArray );
public:
	VOID Usage();
	BOOL Initialize();
	VOID PrepareColumns();
	BOOL ValidateFilters();
	BOOL ProcessOptions( DWORD argc, LPCWSTR argv[] );

	// functionality related
	DWORD Show();
	BOOL Connect();
	BOOL LoadTasks();
};

// 
// public functions
//
VOID PrintProgressMsg( HANDLE hOutput, LPCWSTR pwszMsg, const CONSOLE_SCREEN_BUFFER_INFO& csbi );

#endif	// _TASKLIST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cntrtext\common\makefile.inc ===
!IFNDEF BUILDMSG
BUILDMSG=
!ENDIF

!IF "$(BUILDMSG)" != ""
    @ech ; $(BUILDMSG) ;
!ENDIF




.\ldprfmsg.h .\msg00001.bin .\ldprfmsg.rc : .\ldprfmsg.mc
	mc -v  ldprfmsg.mc


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cntrtext\common\common.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    common.c

Abstract:

    Utility routines used by Lodctr and/or UnLodCtr
    

Author:

    Bob Watson (a-robw) 12 Feb 93

Revision History:

--*/
#define     UNICODE     1
#define     _UNICODE    1
//
//  "C" Include files
//
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <malloc.h>
#include <locale.h>
//
//  Windows Include files
//
#include <windows.h>
#include <winperf.h>
#include <tchar.h>
#include <initguid.h>
#include <guiddef.h>
#include "wmistr.h"
#include "evntrace.h"
//
//  local include files
//
#define _INIT_WINPERFP_
#include "winperfp.h"
#include "common.h"
//
//
//  Text string Constant definitions
//
LPCTSTR NamesKey = (LPCTSTR)TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib");
LPCTSTR DefaultLangId = (LPCTSTR)TEXT("009");
LPCTSTR DefaultLangTag = (LPCTSTR)TEXT("000");
LPCTSTR Counters = (LPCTSTR)TEXT("Counters");
LPCTSTR Help = (LPCTSTR)TEXT("Help");
LPCTSTR VersionStr = (LPCTSTR)TEXT("Version");
LPCTSTR LastHelp = (LPCTSTR)TEXT("Last Help");
LPCTSTR LastCounter = (LPCTSTR)TEXT("Last Counter");
LPCTSTR FirstHelp = (LPCTSTR)TEXT("First Help");
LPCTSTR cszFirstCounter = (LPCTSTR)TEXT("First Counter");
LPCTSTR Busy = (LPCTSTR)TEXT("Updating");
LPCTSTR Slash = (LPCTSTR)TEXT("\\");
LPCTSTR BlankString = (LPCTSTR)TEXT(" ");
LPCTSTR DriverPathRoot = (LPCTSTR)TEXT("SYSTEM\\CurrentControlSet\\Services");
LPCTSTR Performance = (LPCTSTR)TEXT("Performance");
LPCTSTR CounterNameStr = (LPCTSTR)TEXT("Counter ");
LPCTSTR HelpNameStr = (LPCTSTR)TEXT("Explain ");
LPCTSTR AddCounterNameStr = (LPCTSTR)TEXT("Addcounter ");
LPCTSTR AddHelpNameStr = (LPCTSTR)TEXT("Addexplain ");
LPCTSTR szObjectList = (LPCTSTR)TEXT("Object List");
LPCTSTR szLibraryValidationCode = (LPCTSTR)TEXT("Library Validation Code");

BOOLEAN g_bCheckTraceLevel = FALSE;

//  Global (to this module) Buffers
//
static  TCHAR   DisplayStringBuffer[DISP_BUFF_SIZE];
static  TCHAR   TextFormat[DISP_BUFF_SIZE];
static  HANDLE  hMod = NULL;    // process handle
static  DWORD   dwLastError = ERROR_SUCCESS;

HANDLE hEventLog      = NULL;
HANDLE hLoadPerfMutex = NULL;
//
//  local static data
//
static  TCHAR   cDoubleQuote =  TEXT('\"');

BOOL
__stdcall
DllEntryPoint(
    IN HANDLE DLLHandle,
    IN DWORD  Reason,
    IN LPVOID ReservedAndUnused
)
{
    BOOL    bReturn = FALSE;

    ReservedAndUnused;

    DisableThreadLibraryCalls (DLLHandle);

    switch(Reason) {
        case DLL_PROCESS_ATTACH:
            setlocale(LC_ALL, ".OCP");

            hMod = DLLHandle;   // use DLL handle , not APP handle

            // register eventlog source
            hEventLog = RegisterEventSourceW (
                NULL, (LPCWSTR)L"LoadPerf");

            bReturn = TRUE;
            break;

        case DLL_PROCESS_DETACH:
            if (hEventLog != NULL) {
                if (DeregisterEventSource(hEventLog)) {
                    hEventLog = NULL;
                }
            }
            if (hLoadPerfMutex != NULL) {
                CloseHandle(hLoadPerfMutex);
                hLoadPerfMutex = NULL;
            }
            bReturn = TRUE;
            break;

        case DLL_THREAD_ATTACH:
        case DLL_THREAD_DETACH:
            bReturn = TRUE;
            break;
    }

    return bReturn;
}

LPCTSTR
GetStringResource (
    UINT    wStringId
)
/*++

    Retrived UNICODE strings from the resource file for display 

--*/
{

    if (!hMod) {
        hMod = (HINSTANCE)GetModuleHandle(NULL); // get instance ID of this module;
    }
    
    if (hMod) {
        if ((LoadString(hMod, wStringId, DisplayStringBuffer, DISP_BUFF_SIZE)) > 0) {
            return (LPTSTR)&DisplayStringBuffer[0];
        } else {
            dwLastError = GetLastError();
            return BlankString;
        }
    } else {
        return BlankString;
    }
}
LPCWSTR
GetFormatResource (
    UINT    wStringId
)
/*++

    Returns an ANSI string for use as a format string in a printf fn.

--*/
{

    if (!hMod) {
        hMod = (HINSTANCE)GetModuleHandle(NULL); // get instance ID of this module;
    }
    
    if (hMod) {
        if ((LoadStringW(hMod, wStringId, TextFormat, DISP_BUFF_SIZE)) > 0) {
            return (LPCTSTR)&TextFormat[0];
        } else {
            dwLastError = GetLastError();
            return BlankString;
        }
    } else {
        return BlankString;
    }
}

VOID
DisplayCommandHelp (
    UINT    iFirstLine,
    UINT    iLastLine
)
/*++

DisplayCommandHelp

    displays usage of command line arguments

Arguments

    NONE

Return Value

    NONE

--*/
{
    UINT    iThisLine;
    WCHAR   StringBuffer[DISP_BUFF_SIZE];
    CHAR    OemStringBuffer[DISP_BUFF_SIZE];
    int     nStringBufferLen;
    int     nOemStringBufferLen;

    // clear the buffer
    memset (StringBuffer, 0, sizeof(StringBuffer));

    if (!hMod) {
        hMod = (HINSTANCE)GetModuleHandle(NULL); // get instance ID of this module;
    }
    
    if (hMod) {
        for (iThisLine = iFirstLine;
            iThisLine <= iLastLine;
            iThisLine++) {
            
            nStringBufferLen = LoadStringW(hMod, iThisLine, StringBuffer,
                    DISP_BUFF_SIZE);
            if (nStringBufferLen > 0) {
                nOemStringBufferLen = sizeof(OemStringBuffer) / sizeof(OemStringBuffer[0]);
                WideCharToMultiByte (CP_OEMCP, 0,
                    StringBuffer,           // string to convert
                    nStringBufferLen +1,    // string length + null
                    OemStringBuffer,
                    nOemStringBufferLen,
                    NULL, NULL);

                fprintf (stdout, "\n%s", OemStringBuffer);
            }
        }    
    } // else do nothing

} // DisplayCommandHelp

BOOL
TrimSpaces (
    IN  OUT LPTSTR  szString
)
/*++

Routine Description:

    Trims leading and trailing spaces from szString argument, modifying
        the buffer passed in

Arguments:

    IN  OUT LPTSTR  szString
        buffer to process

Return Value:

    TRUE if string was modified
    FALSE if not

--*/
{
    LPTSTR  szSource;
    LPTSTR  szDest;
    LPTSTR  szLast;
    BOOL    bChars;

    szLast = szSource = szDest = szString;
    bChars = FALSE;

    while (*szSource != 0) {
        // skip leading non-space chars
        if (!_istspace(*szSource)) {
            szLast = szDest;
            bChars = TRUE;
        }
        if (bChars) {
            // remember last non-space character
            // copy source to destination & increment both
            *szDest++ = *szSource++;
        } else {
            szSource++;
        }
    }

    if (bChars) {
        *++szLast = 0; // terminate after last non-space char
    } else {
        // string was all spaces so return an empty (0-len) string
        *szString = 0;
    }

    return (szLast != szSource);
}

BOOL
IsDelimiter (
    IN  TCHAR   cChar,
    IN  TCHAR   cDelimiter
)
/*++

Routine Description:

    compares the characte to the delimiter. If the delimiter is
        a whitespace character then any whitespace char will match
        otherwise an exact match is required
--*/
{
    if (_istspace(cDelimiter)) {
        // delimiter is whitespace so any whitespace char will do
        return (_istspace(cChar));
    } else {
        // delimiter is not white space so use an exact match
        return (cChar == cDelimiter);
    }
}

LPCTSTR
GetItemFromString (
    IN  LPCTSTR     szEntry,
    IN  DWORD       dwItem,
    IN  TCHAR       cDelimiter

)
/*++

Routine Description:

    returns nth item from a list delimited by the cDelimiter Char.
        Leaves (double)quoted strings intact.

Arguments:

    IN  LPCTSTR szEntry
        Source string returned to parse

    IN  DWORD   dwItem
        1-based index indicating which item to return. (i.e. 1= first item
        in list, 2= second, etc.)

    IN  TCHAR   cDelimiter
        character used to separate items. Note if cDelimiter is WhiteSpace
        (e.g. a tab or a space) then any white space will serve as a delim.

Return Value:

    pointer to buffer containing desired entry in string. Note, this
        routine may only be called 4 times before the string
        buffer is re-used. (i.e. don't use this function more than
        4 times in single function call!!)

--*/
{
    static  TCHAR   szReturnBuffer[4][MAX_PATH];
    static  LONG    dwBuff;
    LPTSTR  szSource, szDest;
    DWORD   dwThisItem;
    DWORD   dwStrLeft;

    dwBuff = ++dwBuff % 4; // wrap buffer index

    szSource = (LPTSTR)szEntry;
    szDest = &szReturnBuffer[dwBuff][0];

    // clear previous contents
    memset (szDest, 0, (MAX_PATH * sizeof(TCHAR)));

    // find desired entry in string
    dwThisItem = 1;
    while (dwThisItem < dwItem) {
        if (*szSource != 0) {
            while (!IsDelimiter(*szSource, cDelimiter) && (*szSource != 0)) {
                if (*szSource == cDoubleQuote) {
                    // if this is a quote, then go to the close quote
                    szSource++;
                    while ((*szSource != cDoubleQuote) && (*szSource != 0)) szSource++;
                }
                if (*szSource != 0) szSource++;
            }
        }
        dwThisItem++;
        if (*szSource != 0) szSource++;
    }
    // copy this entry to the return buffer
    if (*szSource != 0) {
        dwStrLeft = MAX_PATH-1;
        while (!IsDelimiter(*szSource, cDelimiter) && (*szSource != 0)) {
            if (*szSource == cDoubleQuote) {
                // if this is a quote, then go to the close quote
                // don't copy quotes!
                szSource++;
                while ((*szSource != cDoubleQuote) && (*szSource != 0)) {
                    *szDest++ = *szSource++;
                    dwStrLeft--;
                    if (!dwStrLeft) break;   // dest is full (except for term NULL
                }
                if (*szSource != 0) szSource++;
            } else {
                *szDest++ = *szSource++;
                dwStrLeft--;
                if (!dwStrLeft) break;   // dest is full (except for term NULL
            }
        }
        *szDest = 0;
    }

    // remove any leading and/or trailing spaces

    TrimSpaces (&szReturnBuffer[dwBuff][0]);

    return &szReturnBuffer[dwBuff][0];
}

void
ReportLoadPerfEvent(
    IN  WORD    EventType,
    IN  DWORD   EventID,
    IN  DWORD   dwDataCount,
    IN  DWORD   dwData1,
    IN  DWORD   dwData2,
    IN  DWORD   dwData3,
    IN  WORD    wStringCount,
    IN  LPWSTR  szString1,
    IN  LPWSTR  szString2,
    IN  LPWSTR  szString3
)
{
    WCHAR  szDbg[1024];
    DWORD  dwData[4];
    LPWSTR szMessageArray[4];
    BOOL   bResult     = FALSE;
    DWORD  dwLastError = GetLastError();

    if (dwDataCount > 3)  dwDataCount  = 3;
    if (wStringCount > 3) wStringCount = 3;

    if (dwDataCount > 0) dwData[0] = dwData1;
    if (dwDataCount > 1) dwData[1] = dwData2;
    if (dwDataCount > 2) dwData[2] = dwData3;
    dwDataCount *= sizeof(DWORD);

    if (wStringCount > 0 && szString1) szMessageArray[0] = szString1;
    if (wStringCount > 1 && szString2) szMessageArray[1] = szString2;
    if (wStringCount > 2 && szString3) szMessageArray[2] = szString3;

    if (hEventLog == NULL) {
        hEventLog = RegisterEventSourceW (NULL, (LPCWSTR)L"LoadPerf");
    }

    if (dwDataCount > 0 && wStringCount > 0) {
        bResult = ReportEventW(hEventLog,
                     EventType,             // event type 
                     0,                     // category (not used)
                     EventID,               // event,
                     NULL,                  // SID (not used),
                     wStringCount,          // number of strings
                     dwDataCount,           // sizeof raw data
                     szMessageArray,        // message text array
                     (LPVOID) & dwData[0]); // raw data
    }
    else if (dwDataCount > 0) {
        bResult = ReportEventW(hEventLog,
                     EventType,             // event type
                     0,                     // category (not used)
                     EventID,               // event,
                     NULL,                  // SID (not used),
                     0,                     // number of strings
                     dwDataCount,           // sizeof raw data
                     NULL,                  // message text array
                     (LPVOID) & dwData[0]); // raw data
    }
    else if (wStringCount > 0) {
        bResult = ReportEventW(hEventLog,
                     EventType,             // event type
                     0,                     // category (not used)
                     EventID,               // event,
                     NULL,                  // SID (not used),
                     wStringCount,          // number of strings
                     0,                     // sizeof raw data
                     szMessageArray,        // message text array
                     NULL);                 // raw data
    }
    else {
        bResult = ReportEventW(hEventLog,
                     EventType,             // event type
                     0,                     // category (not used)
                     EventID,               // event,
                     NULL,                  // SID (not used),
                     0,                     // number of strings
                     0,                     // sizeof raw data
                     NULL,                  // message text array
                     NULL);                 // raw data
    }

    if (! bResult) {
        swprintf(szDbg,
                (LPCWSTR) L"LOADPERF(0x%08X)::(%d,0x%08X,%d)(%d,%d,%d,%d)(%d,%ws,%ws,%ws)\n",
                GetCurrentThreadId(),
                EventType, EventID, GetLastError(),
                dwDataCount, dwData1, dwData2, dwData3,
                wStringCount, szString1, szString2, szString3);
        OutputDebugString(szDbg);
    }

    SetLastError(dwLastError);
}

BOOLEAN LoadPerfGrabMutex()
{
    BOOLEAN bResult      = TRUE;
    HANDLE  hLocalMutex  = NULL;
    DWORD   dwWaitStatus = 0;

    if (hLoadPerfMutex == NULL) {
        hLocalMutex = CreateMutex(NULL, TRUE, TEXT("LOADPERF_MUTEX"));
        if (hLocalMutex == NULL) {
            bResult = FALSE;
        }
        else {
            InterlockedCompareExchangePointer(& hLoadPerfMutex,
                                              hLocalMutex,
                                              NULL);
        }
    }

    if (hLocalMutex == NULL) {
        dwWaitStatus = WaitForSingleObject(hLoadPerfMutex, H_MUTEX_TIMEOUT);
        if (dwWaitStatus != WAIT_OBJECT_0 && dwWaitStatus != WAIT_ABANDONED) {
            SetLastError(dwWaitStatus);
            bResult = FALSE;
        }
    }

    if (! bResult) {
        TRACE((WINPERF_DBG_TRACE_FATAL),
              (& LoadPerfGuid,
               __LINE__,
               LOADPERF_LOADPERFGRABMUTEX,
               0,
               GetLastError(),
               NULL));
    }

    return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cntrtext\common\lodctr.c ===
/*++

Copyright (c) 1991-1999  Microsoft Corporation

Module Name:

    lodctr.c

Abstract:

    Program to read the contents of the file specified in the command line
    and update the registry accordingly

Author:

    Bob Watson (a-robw) 10 Feb 93

Revision History:

    a-robw  25-Feb-93   revised calls to make it compile as a UNICODE or
            an ANSI app.

    Bob Watson (bobw)   10 Mar 99 added event log messages


--*/
#ifndef     UNICODE
#define     UNICODE     1
#endif

#ifndef     _UNICODE
#define     _UNICODE    1
#endif

#ifdef      _LODCTR_DBG_OUTPUT
#undef      _LODCTR_DBG_OUTPUT
#endif
//#define      _LODCTR_DBG_OUTPUT

//
//  "C" Include files
//
#include <stdio.h>
#include <stdlib.h>
#include <conio.h>
#include <string.h>
#include <malloc.h>
#include <assert.h>
//
//  Windows Include files
//
#include <windows.h>
#define __LOADPERF__
#include <loadperf.h>
#include <winperf.h>
#include <tchar.h>
#include "wmistr.h"
#include "evntrace.h"
//
//  application include files
//
#include "winperfp.h"
#include "common.h"
#include "lodctr.h"
#include "wbemutil.h"
#include "mofcomp.h"
#include "ldprfmsg.h"

typedef struct _DllValidationData {
    FILETIME    CreationDate;
    LONGLONG    FileSize;
} DllValidationData, *pDllValidationData;

#define  OLD_VERSION 0x010000
static DWORD    dwSystemVersion;
static DWORD    dwFileSize;
static TCHAR    ComputerName[FILE_NAME_BUFFER_SIZE];
static HKEY     hPerfData;
static BOOL     bQuietMode = TRUE;     // quiet means no _tprintf's

// string constants
static const TCHAR  szDataFileRoot[] = {TEXT("%systemroot%\\system32\\Perf")};
static const TCHAR  szDatExt[] = {TEXT(".DAT")};
static const TCHAR  szBakExt[] = {TEXT(".BAK")};
static const TCHAR  szInfo[] = {TEXT("info")};
static const TCHAR  szDriverName[] = {TEXT("drivername")};
static const TCHAR  szMofFileName[] = {TEXT("MofFile")};
static const TCHAR  szNotFound[] = {TEXT("NotFound")};
static const TCHAR  szLanguages[] = {TEXT("languages")};
static const TCHAR  sz009[] = {TEXT("009")};
static const TCHAR  szSymbolFile[] = {TEXT("symbolfile")};
static const TCHAR  szName[] = {TEXT("_NAME")};
static const TCHAR  szHelp[] = {TEXT("_HELP")};
static const TCHAR  sz_DFormat[] = {TEXT(" %d")};
static const TCHAR  szDFormat[] = {TEXT("%d")};
static const TCHAR  szText[] = {TEXT("text")};
static const TCHAR  szObjects[] = {TEXT("objects")};
static const TCHAR  szSpace[] = {TEXT(" ")};
static const TCHAR  MapFileName[] = {TEXT("Perflib Busy")};
static const TCHAR  szPerflib[] = {TEXT("Perflib")};
static const TCHAR  cszLibrary[] = {TEXT("Library")};
static const CHAR   caszOpen[] = {"Open"};
static const CHAR   caszCollect[] = {"Collect"};
static const CHAR   caszClose[] = {"Close"};
static const TCHAR  szBaseIndex[] = {TEXT("Base Index")};
static const TCHAR  szTrusted[] = {TEXT("Trusted")};
static const TCHAR  szDisablePerformanceCounters[] = {TEXT("Disable Performance Counters")};

#define MemoryAllocate(x)   ((LPVOID)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, x))
#define MemoryFree(x)       ((VOID)HeapFree(GetProcessHeap(), HEAP_ZERO_MEMORY, x))
#define MemorySize(x)       ((x != NULL) ? (DWORD)HeapSize(GetProcessHeap(), HEAP_ZERO_MEMORY, x) : (DWORD)0)
#define MemoryResize(x,y)   ((LPVOID)HeapReAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,x,y));

#define  OLD_VERSION 0x010000
LPCWSTR VersionName = (LPCWSTR)L"Version";
LPCWSTR CounterName = (LPCWSTR)L"Counter ";
LPCWSTR HelpName = (LPCWSTR)L"Explain ";

int __cdecl
My_vfwprintf(
    FILE *str,
    const wchar_t *format,
    va_list argptr
    );

__inline
void __cdecl
OUTPUT_MESSAGE (
    const TCHAR* format,
    ...
)
{
    va_list args;
    va_start( args, format );

    if (!bQuietMode) {
        My_vfwprintf(stdout, format, args);
    }

    va_end(args);
}

__inline
static
PPERF_OBJECT_TYPE
NextObject (
    PPERF_OBJECT_TYPE pObject
)
{  // NextObject
    return ((PPERF_OBJECT_TYPE) ((PBYTE) pObject + pObject->TotalByteLength));
}  // NextObject

__inline
static
PERF_COUNTER_DEFINITION *
FirstCounter(
    PERF_OBJECT_TYPE *pObjectDef
)
{
    return (PERF_COUNTER_DEFINITION *)
               ((PCHAR) pObjectDef + pObjectDef->HeaderLength);
}

__inline
static
PERF_COUNTER_DEFINITION *
NextCounter(
    PERF_COUNTER_DEFINITION *pCounterDef
)
{
    return (PERF_COUNTER_DEFINITION *)
               ((PCHAR) pCounterDef + pCounterDef->ByteLength);
}

DWORD
MakeTempFileName (
    LPCWSTR wszRoot,
    LPWSTR wszTempFilename
)
{
    FILETIME    ft;
    DWORD       dwReturn;
    WCHAR       wszLocalFilename[MAX_PATH];

    GetSystemTimeAsFileTime (&ft);
    dwReturn = (DWORD) swprintf(wszLocalFilename,
        (LPCWSTR)L"%%windir%%\\system32\\wbem\\%s_%8.8x%8.8x.mof",
        (wszRoot != NULL ? wszRoot : (LPCWSTR)L"LodCtr"),
        ft.dwHighDateTime, ft.dwLowDateTime);
    if (dwReturn > 0) {
        // expand env. vars
        dwReturn = ExpandEnvironmentStringsW (
            wszLocalFilename,
            wszTempFilename,
            MAX_PATH-1);
    }
    return dwReturn;
}

DWORD
WriteWideStringToAnsiFile (
    HANDLE  hFile,
    LPCWSTR szWideString,
    LPDWORD pdwLength
)
{
    BOOL    bStatus;
    DWORD    dwStatus;
    LPSTR    szAnsiString;
    DWORD    dwBytesWritten = 0;

    szAnsiString = MemoryAllocate(*pdwLength);
    if (szAnsiString != NULL) {
        wcstombs (szAnsiString, szWideString, *pdwLength);
        bStatus = WriteFile (
            hFile,
            (LPCVOID)szAnsiString,
            *pdwLength,
            &dwBytesWritten,
            NULL);

        if (bStatus) {
            *pdwLength = dwBytesWritten;
            dwStatus = ERROR_SUCCESS;
        } else {
            dwStatus = GetLastError();
        }
        MemoryFree (szAnsiString);
    } else {
        dwStatus = GetLastError();
    }
    return dwStatus;
}

LPWSTR
*BuildNameTable(
    HKEY    hKeyRegistry,   // handle to registry db with counter names
    LPWSTR  lpszLangId,     // unicode value of Language subkey
    PDWORD  pdwLastItem     // size of array in elements
)
/*++

BuildNameTable

Arguments:

    hKeyRegistry
            Handle to an open registry (this can be local or remote.) and
            is the value returned by RegConnectRegistry or a default key.

    lpszLangId
            The unicode id of the language to look up. (default is 409)

Return Value:

    pointer to an allocated table. (the caller must MemoryFree it when finished!)
    the table is an array of pointers to zero terminated strings. NULL is
    returned if an error occured.

--*/
{

    LPWSTR  *lpReturnValue;

    LPWSTR  *lpCounterId;
    LPWSTR  lpCounterNames;
    LPWSTR  lpHelpText;

    LPWSTR  lpThisName;

    LONG    lWin32Status;
    DWORD   dwLastError;
    DWORD   dwValueType;
    DWORD   dwArraySize;
    DWORD   dwBufferSize;
    DWORD   dwCounterSize;
    DWORD   dwHelpSize;
    DWORD   dwThisCounter;

    DWORD   dwSystemVersion;
    DWORD   dwLastId;
    DWORD   dwLastHelpId;
    DWORD   dwLastCounterId;

    DWORD   dwLastCounterIdUsed;
    DWORD   dwLastHelpIdUsed;

    HKEY    hKeyValue;
    HKEY    hKeyNames;

    LPWSTR  lpValueNameString;
    WCHAR   CounterNameBuffer [50];
    WCHAR   HelpNameBuffer [50];

    lpValueNameString = NULL;   //initialize to NULL
    lpReturnValue = NULL;
    hKeyValue = NULL;
    hKeyNames = NULL;

    // check for null arguments and insert defaults if necessary

    if (!lpszLangId) {
        lpszLangId = (LPWSTR)DefaultLangId;
    }

    // open registry to get number of items for computing array size

    lWin32Status = RegOpenKeyEx (
        hKeyRegistry,
        NamesKey,
        RESERVED,
        KEY_READ,
        &hKeyValue);

    if (lWin32Status != ERROR_SUCCESS) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_UNABLE_OPEN_KEY, // event,
                1, lWin32Status, 0, 0,
                1, (LPWSTR) NamesKey, NULL, NULL);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_LODCTR_BUILDNAMETABLE,
                ARG_DEF(ARG_TYPE_WSTR, 1),
                lWin32Status,
                TRACE_WSTR(NamesKey),
                NULL));
        goto BNT_BAILOUT;
    }

    // get number of items

    dwBufferSize = sizeof (dwLastHelpId);
    lWin32Status = RegQueryValueEx (
        hKeyValue,
        LastHelp,
        RESERVED,
        &dwValueType,
        (LPBYTE)&dwLastHelpId,
        &dwBufferSize);

    if ((lWin32Status != ERROR_SUCCESS) || (dwValueType != REG_DWORD)) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_UNABLE_READ_VALUE, // event,
                1, lWin32Status, 0, 0,
                1, (LPWSTR) LastHelp, NULL, NULL);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_LODCTR_BUILDNAMETABLE,
                ARG_DEF(ARG_TYPE_WSTR, 1),
                lWin32Status,
                TRACE_WSTR(LastHelp),
                NULL));
        goto BNT_BAILOUT;
    }

    // get number of items

    dwBufferSize = sizeof (dwLastId);
    lWin32Status = RegQueryValueEx (
        hKeyValue,
        LastCounter,
        RESERVED,
        &dwValueType,
        (LPBYTE)&dwLastCounterId,
        &dwBufferSize);

    if ((lWin32Status != ERROR_SUCCESS) || (dwValueType != REG_DWORD)) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_UNABLE_READ_VALUE, // event,
                1, lWin32Status, 0, 0,
                1, (LPWSTR) LastCounter, NULL, NULL);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_LODCTR_BUILDNAMETABLE,
                ARG_DEF(ARG_TYPE_WSTR, 1),
                lWin32Status,
                TRACE_WSTR(LastCounter),
                NULL));
        goto BNT_BAILOUT;
    }

    dwLastId = (dwLastCounterId < dwLastHelpId)
             ? (dwLastHelpId) : (dwLastCounterId);

    // compute size of pointer array
    dwArraySize = (dwLastId + 1) * sizeof(LPWSTR);

    // get Perflib system version
    dwBufferSize = sizeof (dwSystemVersion);
    lWin32Status = RegQueryValueEx (
        hKeyValue,
        VersionName,
        RESERVED,
        &dwValueType,
        (LPBYTE)&dwSystemVersion,
        &dwBufferSize);

    if ((lWin32Status != ERROR_SUCCESS) || (dwValueType != REG_DWORD)) {
        dwSystemVersion = OLD_VERSION;
        // reset the error status
        lWin32Status = ERROR_SUCCESS;
    }

    TRACE((WINPERF_DBG_TRACE_INFO),
          (& LoadPerfGuid,
            __LINE__,
            LOADPERF_LODCTR_BUILDNAMETABLE,
            0,
            lWin32Status,
            TRACE_DWORD(dwLastCounterId),
            TRACE_DWORD(dwLastHelpId),
            NULL));

    if (dwSystemVersion == OLD_VERSION) {
        // get names from registry
        lpValueNameString = MemoryAllocate (
            lstrlen(NamesKey) * sizeof (WCHAR) +
            lstrlen(Slash) * sizeof (WCHAR) +
            lstrlen(lpszLangId) * sizeof (WCHAR) +
            sizeof (UNICODE_NULL));

        if (!lpValueNameString) goto BNT_BAILOUT;

        lstrcpy (lpValueNameString, NamesKey);
        lstrcat (lpValueNameString, Slash);
        lstrcat (lpValueNameString, lpszLangId);

        lWin32Status = RegOpenKeyEx (
            hKeyRegistry,
            lpValueNameString,
            RESERVED,
            KEY_READ,
            &hKeyNames);
    } else {
        if (ComputerName[0] == 0) {
            hKeyNames = HKEY_PERFORMANCE_DATA;
        } else {
            lWin32Status = RegConnectRegistry (ComputerName,
                HKEY_PERFORMANCE_DATA,
                &hKeyNames);
        }
        lstrcpy (CounterNameBuffer, CounterName);
        lstrcat (CounterNameBuffer, lpszLangId);

        lstrcpy (HelpNameBuffer, HelpName);
        lstrcat (HelpNameBuffer, lpszLangId);
    }

    // get size of counter names and add that to the arrays

    if (lWin32Status != ERROR_SUCCESS) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_UNABLE_ACCESS_STRINGS, // event,
                1, lWin32Status, 0, 0,
                1, (LPWSTR) lpszLangId, NULL, NULL);
        goto BNT_BAILOUT;
    }
    dwBufferSize = 0;
    lWin32Status = RegQueryValueEx (
        hKeyNames,
        dwSystemVersion == OLD_VERSION ? Counters : CounterNameBuffer,
        RESERVED,
        &dwValueType,
        NULL,
        &dwBufferSize);

    if (lWin32Status != ERROR_SUCCESS) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_UNABLE_READ_COUNTER_STRINGS, // event,
                1, lWin32Status, 0, 0,
                1, (LPWSTR) lpszLangId, NULL, NULL);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_LODCTR_BUILDNAMETABLE,
                ARG_DEF(ARG_TYPE_WSTR, 1),
                lWin32Status,
                TRACE_WSTR(Counters),
                NULL));
        goto BNT_BAILOUT;
    }

    dwCounterSize = dwBufferSize;

    // get size of counter names and add that to the arrays

    if (lWin32Status != ERROR_SUCCESS) goto BNT_BAILOUT;

    dwBufferSize = 0;
    lWin32Status = RegQueryValueEx (
        hKeyNames,
        dwSystemVersion == OLD_VERSION ? Help : HelpNameBuffer,
        RESERVED,
        &dwValueType,
        NULL,
        &dwBufferSize);

    if (lWin32Status != ERROR_SUCCESS) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_UNABLE_READ_HELP_STRINGS, // event,
                1, lWin32Status, 0, 0,
                1, (LPWSTR) lpszLangId, NULL, NULL);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_LODCTR_BUILDNAMETABLE,
                ARG_DEF(ARG_TYPE_WSTR, 1),
                lWin32Status,
                TRACE_WSTR(Help),
                NULL));
        goto BNT_BAILOUT;
    }

    dwHelpSize = dwBufferSize;

    lpReturnValue = MemoryAllocate (dwArraySize + dwCounterSize + dwHelpSize);

    if (!lpReturnValue) {
        lWin32Status = ERROR_OUTOFMEMORY;
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_MEMORY_ALLOCATION_FAILURE, // event,
                0, 0, 0, 0,
                0, NULL, NULL, NULL);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_LODCTR_BUILDNAMETABLE,
                0,
                ERROR_OUTOFMEMORY,
                NULL));
        goto BNT_BAILOUT;
    }
    // initialize pointers into buffer

    lpCounterId = lpReturnValue;
    lpCounterNames = (LPWSTR)((LPBYTE)lpCounterId + dwArraySize);
    lpHelpText = (LPWSTR)((LPBYTE)lpCounterNames + dwCounterSize);

    // read counters into memory

    dwBufferSize = dwCounterSize;
    lWin32Status = RegQueryValueEx (
        hKeyNames,
        dwSystemVersion == OLD_VERSION ? Counters : CounterNameBuffer,
        RESERVED,
        &dwValueType,
        (LPVOID)lpCounterNames,
        &dwBufferSize);

    if (!lpReturnValue) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_UNABLE_READ_COUNTER_STRINGS, // event,
                1, lWin32Status, 0, 0,
                1, (LPWSTR) lpszLangId, NULL, NULL);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_LODCTR_BUILDNAMETABLE,
                ARG_DEF(ARG_TYPE_WSTR, 1),
                lWin32Status,
                TRACE_WSTR(Counters),
                NULL));
        goto BNT_BAILOUT;
    }

    dwBufferSize = dwHelpSize;
    lWin32Status = RegQueryValueEx (
        hKeyNames,
        dwSystemVersion == OLD_VERSION ? Help : HelpNameBuffer,
        RESERVED,
        &dwValueType,
        (LPVOID)lpHelpText,
        &dwBufferSize);

    if (!lpReturnValue) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_UNABLE_READ_HELP_STRINGS, // event,
                1, lWin32Status, 0, 0,
                1, (LPWSTR) lpszLangId, NULL, NULL);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_LODCTR_BUILDNAMETABLE,
                ARG_DEF(ARG_TYPE_WSTR, 1),
                lWin32Status,
                TRACE_WSTR(Help),
                NULL));
        goto BNT_BAILOUT;
    }

    dwLastCounterIdUsed = 0;
    dwLastHelpIdUsed = 0;

    // load counter array items

    for (lpThisName = lpCounterNames;
         *lpThisName;
         lpThisName += (lstrlen(lpThisName)+1) ) {

        // first string should be an integer (in decimal unicode digits)

        dwThisCounter = wcstoul (lpThisName, NULL, 10);

        if ((dwThisCounter == 0) || (dwThisCounter > dwLastId)) {
            lWin32Status = ERROR_INVALID_DATA;
            ReportLoadPerfEvent(
                    EVENTLOG_ERROR_TYPE, // error type
                    (DWORD) LDPRFMSG_REGISTRY_COUNTER_STRINGS_CORRUPT, // event,
                    1, dwThisCounter, 0, 0,
                    0, NULL, NULL, NULL);
            TRACE((WINPERF_DBG_TRACE_ERROR),
                  (& LoadPerfGuid,
                    __LINE__,
                    LOADPERF_LODCTR_BUILDNAMETABLE,
                    ARG_DEF(ARG_TYPE_WSTR, 1),
                    lWin32Status,
                    TRACE_WSTR(lpThisName),
                    TRACE_DWORD(dwThisCounter),
                    TRACE_DWORD(dwLastId),
                    NULL));
            goto BNT_BAILOUT;  // bad entry
        }

        // point to corresponding counter name

        lpThisName += (lstrlen(lpThisName)+1);

        // and load array element;

        lpCounterId[dwThisCounter] = lpThisName;

        if (dwThisCounter > dwLastCounterIdUsed) dwLastCounterIdUsed = dwThisCounter;

    }

    for (lpThisName = lpHelpText;
         *lpThisName;
         lpThisName += (lstrlen(lpThisName)+1) ) {

        // first string should be an integer (in decimal unicode digits)

        dwThisCounter = wcstoul (lpThisName, NULL, 10);

        if ((dwThisCounter == 0) || (dwThisCounter > dwLastId)) {
            lWin32Status = ERROR_INVALID_DATA;
            ReportLoadPerfEvent(
                    EVENTLOG_ERROR_TYPE, // error type
                    (DWORD) LDPRFMSG_REGISTRY_HELP_STRINGS_CORRUPT, // event,
                    1, dwThisCounter, 0, 0,
                    0, NULL, NULL, NULL);
            TRACE((WINPERF_DBG_TRACE_ERROR),
                  (& LoadPerfGuid,
                    __LINE__,
                    LOADPERF_LODCTR_BUILDNAMETABLE,
                    ARG_DEF(ARG_TYPE_WSTR, 1),
                    lWin32Status,
                    TRACE_WSTR(lpThisName),
                    TRACE_DWORD(dwThisCounter),
                    TRACE_DWORD(dwLastId),
                    NULL));
            goto BNT_BAILOUT;  // bad entry
        }
        // point to corresponding counter name

        lpThisName += (lstrlen(lpThisName)+1);

        // and load array element;

        lpCounterId[dwThisCounter] = lpThisName;

        if (dwThisCounter > dwLastHelpIdUsed) dwLastHelpIdUsed= dwThisCounter;
    }

    TRACE((WINPERF_DBG_TRACE_INFO),
          (& LoadPerfGuid,
            __LINE__,
            LOADPERF_LODCTR_BUILDNAMETABLE,
            ARG_DEF(ARG_TYPE_WSTR, 1),
            lWin32Status,
            TRACE_WSTR(lpszLangId),
            TRACE_DWORD(dwLastCounterIdUsed),
            TRACE_DWORD(dwLastHelpIdUsed),
            TRACE_DWORD(dwLastId),
            NULL));

    // check the registry for consistency
    // the last help string index should be the last ID used
    if (dwLastCounterIdUsed > dwLastId) {
        lWin32Status = ERROR_INVALID_DATA;
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_REGISTRY_INDEX_CORRUPT, // event,
                2, dwLastId, dwLastCounterIdUsed, 0,
                0, NULL, NULL, NULL);
        goto BNT_BAILOUT;  // bad registry
    }
    if (dwLastHelpIdUsed > dwLastId) {
        lWin32Status = ERROR_INVALID_DATA;
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_REGISTRY_INDEX_CORRUPT, // event,
                2, dwLastId, dwLastHelpIdUsed, 0,
                0, NULL, NULL, NULL);
        goto BNT_BAILOUT;  // bad registry
    }

    if (pdwLastItem) *pdwLastItem = dwLastId;

    MemoryFree ((LPVOID)lpValueNameString);
    RegCloseKey (hKeyValue);
    RegCloseKey (hKeyNames);

    return lpReturnValue;

BNT_BAILOUT:
    if (lWin32Status != ERROR_SUCCESS) {
        dwLastError = GetLastError();
    }
    if (lpValueNameString) {
        MemoryFree ((LPVOID)lpValueNameString);
    }
    if (lpReturnValue) {
        MemoryFree ((LPVOID)lpReturnValue);
    }

    if (hKeyValue) RegCloseKey (hKeyValue);
    RegCloseKey (hKeyNames);


    return NULL;
}

BOOL
MakeBackupCopyOfLanguageFiles (
    IN  LPCTSTR szLangId
)
{
    TCHAR   szOldFileName[MAX_PATH];
    TCHAR   szTmpFileName[MAX_PATH];
    TCHAR   szNewFileName[MAX_PATH];

    BOOL    bStatus;

    DWORD   dwStatus;
    HANDLE  hOutFile;

    UNREFERENCED_PARAMETER (szLangId);

    ExpandEnvironmentStrings (szDataFileRoot, szOldFileName, MAX_PATH);
    _stprintf (szNewFileName, (LPCTSTR)(TEXT("%sStringBackup.INI")), szOldFileName);
    _stprintf(szTmpFileName,
              (LPCTSTR)(TEXT("%sStringBackup.TMP")),
              szOldFileName);

    // see if the file already exists
    hOutFile = CreateFile(
            szTmpFileName,
            GENERIC_READ,
            0,      // no sharing
            NULL,   // default security
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL);
    if (hOutFile != INVALID_HANDLE_VALUE) {
        CloseHandle(hOutFile);
        bStatus = DeleteFile(szTmpFileName);
    }

    // create backup of file
    //
    dwStatus = BackupPerfRegistryToFileW (szTmpFileName, NULL);
    if (dwStatus == ERROR_SUCCESS) {
        bStatus = CopyFile(szTmpFileName, szNewFileName, FALSE);
        if (bStatus) {
            DeleteFile(szTmpFileName);
        }
    } else {
        // unable to create a backup file
        SetLastError (dwStatus);
        bStatus = FALSE;
    }

    TRACE((WINPERF_DBG_TRACE_INFO),
          (& LoadPerfGuid,
            __LINE__,
            LOADPERF_MAKEBACKUPCOPYOFLANGUAGEFILES,
            ARG_DEF(ARG_TYPE_WSTR, 1),
            GetLastError(),
            TRACE_WSTR(szNewFileName),
            NULL));

    return bStatus;
}

BOOL
GetFileFromCommandLine (
    IN  LPTSTR   lpCommandLine,
    OUT LPTSTR   *lpFileName,
    IN    DWORD_PTR *pdwFlags
)
/*++

GetFileFromCommandLine

    parses the command line to retrieve the ini filename that should be
    the first and only argument.

Arguments

    lpCommandLine   pointer to command line (returned by GetCommandLine)
    lpFileName      pointer to buffer that will recieve address of the
            validated filename entered on the command line
    pdwFlags        pointer to dword containing flag bits

Return Value

    TRUE if a valid filename was returned
    FALSE if the filename is not valid or missing
        error is returned in GetLastError

--*/
{
    INT     iNumArgs;

    LPTSTR  lpExeName = NULL;
    LPTSTR  lpCmdLineName = NULL;
    LPWSTR  lpIniFileName = NULL;
    LPWSTR  lpMofFlag = NULL;
    HANDLE  hFileHandle;
    TCHAR   LocalComputerName[FILE_NAME_BUFFER_SIZE];
    DWORD   NameBuffer;

    DWORD    dwCpuArg, dwIniArg;

    // check for valid arguments

    if (!lpCommandLine) return (ERROR_INVALID_PARAMETER);
    if (!lpFileName) return (ERROR_INVALID_PARAMETER);
    if (!pdwFlags) return (ERROR_INVALID_PARAMETER);

    // allocate memory for parsing operation

    lpExeName = MemoryAllocate (FILE_NAME_BUFFER_SIZE * sizeof(TCHAR));
    lpCmdLineName = MemoryAllocate (FILE_NAME_BUFFER_SIZE * sizeof(TCHAR));
    lpIniFileName = MemoryAllocate (FILE_NAME_BUFFER_SIZE * sizeof(WCHAR));
    lpMofFlag = MemoryAllocate (FILE_NAME_BUFFER_SIZE * sizeof(WCHAR));

    if (!lpExeName || !lpIniFileName || !lpCmdLineName || !lpMofFlag) {
        SetLastError (ERROR_OUTOFMEMORY);
        if (lpExeName) MemoryFree (lpExeName);
        if (lpIniFileName) MemoryFree (lpIniFileName);
        if (lpCmdLineName) MemoryFree (lpCmdLineName);
        if (lpMofFlag) MemoryFree (lpMofFlag);
        return FALSE;
    } else {
        // get strings from command line
        ComputerName[0] = 0;

        // check for mof Flag
        lstrcpyW (lpMofFlag, GetItemFromString (lpCommandLine, 2, cSpace));

        *pdwFlags |= LOADPERF_FLAGS_LOAD_REGISTRY_ONLY; // default unless a switch is found
        
        if ((lpMofFlag[0] == cHyphen) || (lpMofFlag[0] == cSlash)) {
            if ((lpMofFlag[1] == cM)  || (lpMofFlag[1] == cm)) {
                *pdwFlags &= ~LOADPERF_FLAGS_LOAD_REGISTRY_ONLY; // clear that bit
            } else if ((lpMofFlag[1] == cQuestion)) {
               // ask for usage
               if (lpExeName) MemoryFree (lpExeName);
               if (lpIniFileName) MemoryFree (lpIniFileName);
               if (lpMofFlag) MemoryFree (lpMofFlag);
               return FALSE;
            }
            dwCpuArg = 3;
            dwIniArg = 4;
        } else {
            dwCpuArg = 2;
            dwIniArg = 3;
        }

        // Get INI File name

        lstrcpy (lpCmdLineName, GetItemFromString (lpCommandLine, dwIniArg, cSpace));
        if (lstrlen(lpCmdLineName) == 0) {
            // then no computer name was specified so try to get the
            // ini file from the 2nd entry
            lstrcpy (lpCmdLineName, GetItemFromString (lpCommandLine, dwCpuArg, cSpace));
            if (lstrlen(lpCmdLineName) == 0) {
                // no ini file found
                iNumArgs = 1;
            } else {
                // fill in a blank computer name
                iNumArgs = 2;
                ComputerName[0] = 0;
            }
        } else {
            // the computer name must be present so fetch it
            lstrcpy (LocalComputerName, GetItemFromString (lpCommandLine, dwCpuArg, cSpace));
            iNumArgs = 3;
        }

        if (iNumArgs != 2 && iNumArgs != 3) {
            // wrong number of arguments
            SetLastError (ERROR_INVALID_PARAMETER);
            if (lpExeName) MemoryFree (lpExeName);
            if (lpIniFileName) MemoryFree (lpIniFileName);
            if (lpMofFlag) MemoryFree (lpMofFlag);
            return FALSE;
        } else {
            // check if there is a computer name in the input line
            if (LocalComputerName[0] == cBackslash &&
                LocalComputerName[1] == cBackslash) {
                // save it form now
                lstrcpy (ComputerName, LocalComputerName);
                // reuse local buffer to get the this computer's name
                NameBuffer = sizeof (LocalComputerName) / sizeof (TCHAR);
                GetComputerName(LocalComputerName, &NameBuffer);
                if (!lstrcmpi(LocalComputerName, &ComputerName[2])) {
                    // same name as local computer name
                    // so clear computer name buffer
                    ComputerName[0] = 0;
                }
            }

            if (SearchPath (NULL, lpCmdLineName,
                NULL, FILE_NAME_BUFFER_SIZE,
                lpIniFileName, NULL) > 0) {

                hFileHandle = CreateFile (
                    lpIniFileName,
                    GENERIC_READ,
                    0,
                    NULL,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL);

                MemoryFree (lpCmdLineName);

                if (hFileHandle && hFileHandle != INVALID_HANDLE_VALUE) {
                    // get file size
                    dwFileSize = GetFileSize (hFileHandle, NULL);
                    if (dwFileSize == 0xffffffff) {
                        dwFileSize = 0L;
                    } else {
                        dwFileSize *= sizeof (TCHAR);
                    }

                    CloseHandle (hFileHandle);

                    // file exists, so return name and success
                    if (lpExeName) MemoryFree (lpExeName);

                    lstrcpyW (*lpFileName, lpIniFileName);

                    if (lpIniFileName) MemoryFree (lpIniFileName);
                    return TRUE;
                } else {
                    // filename was on command line, but not valid so return
                    // false, but send name back for error message
                    if (lpExeName) MemoryFree (lpExeName);
                    lstrcpyW (*lpFileName, lpIniFileName);
                    if (lpIniFileName) MemoryFree (lpIniFileName);
                    return FALSE;
                }
            } else {
                MemoryFree (lpCmdLineName);
                SetLastError (ERROR_OPEN_FAILED);
                if (lpExeName) MemoryFree (lpExeName);
                if (lpIniFileName) MemoryFree (lpIniFileName);
                return FALSE;
            }
        }
    }
}

BOOL
LodctrSetSericeAsTrusted(
    IN  LPCTSTR  lpIniFile,
    IN  LPCTSTR  szMachineName,
    IN  LPCTSTR  szServiceName
)
/*++
GetDriverName

    looks up driver name in the .ini file and returns it in lpDevName

Arguments

    lpIniFile

    Filename of ini file

    lpDevName

    pointer to pointer to reciev buffer w/dev name in it

Return Value

    TRUE if found
    FALSE if not found in .ini file

--*/
{
    DWORD   dwRetSize;
    DWORD   dwStatus;
    BOOL    bReturn;
    WCHAR   szParam[MAX_PATH];

    dwRetSize = GetPrivateProfileString (
        szInfo,         // info section
        szTrusted,      // Trusted name value
        szNotFound,     // default value
        szParam,
        MAX_PATH,
        lpIniFile);

    if ((lstrcmpi(szParam, szNotFound)) != 0) {
        // Trusted string found so set
        dwStatus = SetServiceAsTrustedW (
            szMachineName,
            szServiceName);
        if (dwStatus != ERROR_SUCCESS) {
            SetLastError (dwStatus);
            bReturn = FALSE;
        }
        bReturn = TRUE;
    } else {
        // Service is not trusted to have a good Perf DLL
        SetLastError (ERROR_SUCCESS);
        bReturn = FALSE;
    }

    return bReturn;
}

BOOL
GetDriverName (
    IN  LPTSTR  lpIniFile,
    OUT LPTSTR  *lpDevName
)
/*++
GetDriverName

    looks up driver name in the .ini file and returns it in lpDevName

Arguments

    lpIniFile

    Filename of ini file

    lpDevName

    pointer to pointer to reciev buffer w/dev name in it

Return Value

    TRUE if found
    FALSE if not found in .ini file

--*/
{
    DWORD   dwRetSize;
    BOOL    bReturn = FALSE;

    if (lpDevName) {
        dwRetSize = GetPrivateProfileString (
            szInfo,         // info section
            szDriverName,   // driver name value
            szNotFound,     // default value
            *lpDevName,
            MAX_PATH,
            lpIniFile);

        if ((lstrcmpi(*lpDevName, szNotFound)) != 0) {
            // name found
            bReturn = TRUE;
        } else {
            // name not found, default returned so return NULL string
            SetLastError (ERROR_BAD_DRIVER);
            *lpDevName = 0;
        }
    } else {
        SetLastError (ERROR_INVALID_PARAMETER);
    }

    if (lpDevName && * lpDevName) {
        TRACE((WINPERF_DBG_TRACE_INFO),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_GETDRIVERNAME,
                ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                GetLastError(),
                TRACE_WSTR(lpIniFile),
                TRACE_WSTR(* lpDevName),
                NULL));
    }
    else {
        TRACE((WINPERF_DBG_TRACE_INFO),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_GETDRIVERNAME,
                ARG_DEF(ARG_TYPE_WSTR, 1),
                GetLastError(),
                TRACE_WSTR(lpIniFile),
                NULL));
    }
    return bReturn;
}

BOOL
BuildLanguageTables (
    IN  LPTSTR  lpIniFile,
    IN OUT PLANGUAGE_LIST_ELEMENT   pFirstElem
)
/*++

BuildLanguageTables

    Creates a list of structures that will hold the text for
    each supported language

Arguments

    lpIniFile

    Filename with data

    pFirstElem

    pointer to first list entry

ReturnValue

    TRUE if all OK
    FALSE if not

--*/
{

    LPTSTR  lpEnumeratedLangs = NULL;
    LPTSTR  lpThisLang        = NULL;
    PLANGUAGE_LIST_ELEMENT   pThisElem;
    PLANGUAGE_LIST_ELEMENT   pPrevElem;
    DWORD   dwSize;
    BOOL    bReturn = FALSE;

    if (lpIniFile == NULL || pFirstElem == NULL) {
        SetLastError (ERROR_INVALID_PARAMETER);
        goto Cleanup;
    }

    lpEnumeratedLangs = MemoryAllocate(SMALL_BUFFER_SIZE * sizeof(TCHAR));

    if (!lpEnumeratedLangs) {
        SetLastError (ERROR_OUTOFMEMORY);
        goto Cleanup;
    }

    dwSize = GetPrivateProfileString (
        szLanguages,
        NULL,                   // return all values in multi-sz string
        sz009,                  // english as the default
        lpEnumeratedLangs,
        SMALL_BUFFER_SIZE,
        lpIniFile);

    // do first language

    lpThisLang = lpEnumeratedLangs;
    pThisElem = NULL;
    pPrevElem = NULL;

    while (*lpThisLang) {
        //
        //  see if this language is supporte on this machine
        //
        if (pThisElem == NULL) {
            pThisElem = pPrevElem = pFirstElem;
        } else {
            pThisElem->pNextLang = MemoryAllocate  (sizeof(LANGUAGE_LIST_ELEMENT));
            if (!pThisElem->pNextLang) {
                SetLastError (ERROR_OUTOFMEMORY);
                goto Cleanup;
            }
            pPrevElem = pThisElem;
            pThisElem = pThisElem->pNextLang;   // point to new one
        }
        pThisElem->pNextLang = NULL;
        pThisElem->LangId = (LPTSTR) MemoryAllocate ((lstrlen(lpThisLang) + 1) * sizeof(TCHAR));
        if (pThisElem->LangId == NULL) {
            if (pThisElem == pFirstElem) {
                pThisElem = pPrevElem = NULL;
            }
            else {
                MemoryFree(pThisElem);
                pThisElem = pPrevElem;
                pThisElem->pNextLang = NULL;
            }
            SetLastError(ERROR_OUTOFMEMORY);
            goto Cleanup;
        }
        lstrcpy (pThisElem->LangId, lpThisLang);
        pThisElem->pFirstName = NULL;
        pThisElem->pThisName = NULL;
        pThisElem->dwNumElements=0;
        pThisElem->NameBuffer = NULL;
        pThisElem->HelpBuffer = NULL;
        pThisElem->dwNameBuffSize = 0;
        pThisElem->dwHelpBuffSize = 0;

        TRACE((WINPERF_DBG_TRACE_INFO),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_BUILDLANGUAGETABLES,
                ARG_DEF(ARG_TYPE_WSTR, 1),
                ERROR_SUCCESS,
                TRACE_WSTR(pThisElem->LangId),
                NULL));

        // go to next string

        lpThisLang += lstrlen(lpThisLang) + 1;
    }

    if (pThisElem == NULL) {
        // then no languages were found
        SetLastError (ERROR_RESOURCE_LANG_NOT_FOUND);
    } else {
        bReturn = TRUE;
    }

Cleanup:
    if (! bReturn) {
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_BUILDLANGUAGETABLES,
                ARG_DEF(ARG_TYPE_WSTR, 1),
                GetLastError(),
                TRACE_WSTR(lpThisLang),
                NULL));
    }
    if (lpEnumeratedLangs != NULL) {
        MemoryFree(lpEnumeratedLangs);
    }
    return bReturn;
}

BOOL
LoadIncludeFile (
    IN LPTSTR lpIniFile,
    OUT PSYMBOL_TABLE_ENTRY   *pTable
)
/*++

LoadIncludeFile

    Reads the include file that contains symbolic name definitions and
    loads a table with the values defined

Arguments

    lpIniFile

    Ini file with include file name

    pTable

    address of pointer to table structure created
Return Value

    TRUE if table read or if no table defined
    FALSE if error encountere reading table

--*/
{
    INT         iNumArgs;
    DWORD       dwSize;
    BOOL        bReUse;
    PSYMBOL_TABLE_ENTRY   pThisSymbol = NULL;
    LPTSTR      lpIncludeFileName     = NULL;
    LPTSTR      lpIncludeFile         = NULL;
    LPTSTR      lpIniPath             = NULL;
    LPSTR       lpLineBuffer          = NULL;
    LPSTR       lpAnsiSymbol          = NULL;
    TCHAR       szIniDrive[_MAX_DRIVE];
    TCHAR       szIniDir[_MAX_DIR];
    FILE        *fIncludeFile;
    DWORD       dwLen;
    BOOL        bReturn = TRUE;

    lpIncludeFileName = MemoryAllocate  (MAX_PATH * sizeof (TCHAR));
    lpIncludeFile = MemoryAllocate (MAX_PATH * sizeof(TCHAR));
    lpLineBuffer = MemoryAllocate (DISP_BUFF_SIZE);
    lpAnsiSymbol = MemoryAllocate (DISP_BUFF_SIZE);
    lpIniPath = MemoryAllocate (MAX_PATH * sizeof (TCHAR));

    if (!lpIncludeFileName || !lpLineBuffer || !lpAnsiSymbol || !lpIniPath) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_MEMORY_ALLOCATION_FAILURE, // event,
                0, 0, 0, 0,
                0, NULL, NULL, NULL);
        SetLastError (ERROR_OUTOFMEMORY);
        bReturn = FALSE;
        goto Cleanup;
    }

    // get name of include file (if present)

    dwSize = GetPrivateProfileString (
        szInfo,
        szSymbolFile,
        szNotFound,
        lpIncludeFileName,
        MAX_PATH,
        lpIniFile);

    TRACE((WINPERF_DBG_TRACE_INFO),
          (& LoadPerfGuid,
            __LINE__,
            LOADPERF_LOADINCLUDEFILE,
            ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
            ERROR_SUCCESS,
            TRACE_WSTR(lpIniFile),
            TRACE_WSTR(lpIncludeFileName),
            NULL));

    if (lstrcmpi(lpIncludeFileName, szNotFound) == 0) {
        // no symbol file defined
        * pTable = NULL;
        bReturn = TRUE;
        goto Cleanup;
    }

    // if here, then a symbol file was defined and is now stored in
    // lpIncludeFileName

    // get path for the ini file and search that first

    _tsplitpath (lpIniFile, szIniDrive, szIniDir, NULL, NULL);
    lpIniPath = lstrcpy (lpIniPath, szIniDrive);
    lpIniPath = lstrcat (lpIniPath, szIniDir);

    dwLen = SearchPath(lpIniPath, lpIncludeFileName, NULL,
        MAX_PATH, lpIncludeFile, NULL);
    if (dwLen == 0) {
        // include file not found with the ini file so search the std. path
        dwLen = SearchPath(NULL, lpIncludeFileName, NULL,
                MAX_PATH, lpIncludeFile, NULL);
    }

    if (dwLen > 0) {

        // file name expanded and found so open
        fIncludeFile = _tfopen (lpIncludeFile, (LPCTSTR)TEXT("rt"));

        if (!fIncludeFile) {
            OUTPUT_MESSAGE (GetFormatResource(LC_ERR_OPEN_INCLUDE), lpIncludeFileName);
            *pTable = NULL;
            SetLastError (ERROR_OPEN_FAILED);
            bReturn = FALSE;
            goto Cleanup;
        }
    } else {
        // unable to find the include filename
        // error is already in GetLastError
        OUTPUT_MESSAGE (GetFormatResource(LC_ERR_OPEN_INCLUDE), lpIncludeFileName);
        *pTable = NULL;
        SetLastError (ERROR_BAD_PATHNAME);
        bReturn = FALSE;
        goto Cleanup;
    }

    //
    //  read ANSI Characters from include file
    //

    bReUse = FALSE;

    while (fgets(lpLineBuffer, DISP_BUFF_SIZE, fIncludeFile) != NULL) {
        if (strlen(lpLineBuffer) > 8) {
            if (!bReUse) {
                if (*pTable) {
                    // then add to list
                    pThisSymbol->pNext = MemoryAllocate (sizeof (SYMBOL_TABLE_ENTRY));
                    pThisSymbol = pThisSymbol->pNext;
                } else { // allocate first element
                    *pTable = MemoryAllocate (sizeof (SYMBOL_TABLE_ENTRY));
                    pThisSymbol = *pTable;
                }

                if (!pThisSymbol) {
                    SetLastError (ERROR_OUTOFMEMORY);
                    bReturn = FALSE;
                    goto Cleanup;
                }

                // allocate room for the symbol name by using the line length
                // - the size of "#define "

//              pThisSymbol->SymbolName = MemoryAllocate ((strlen(lpLineBuffer) - 8) * sizeof (TCHAR));
                pThisSymbol->SymbolName = MemoryAllocate (DISP_BUFF_SIZE * sizeof (TCHAR));

                if (!pThisSymbol->SymbolName) {
                   SetLastError (ERROR_OUTOFMEMORY);
                   bReturn = FALSE;
                   goto Cleanup;
                }

            }

            // all the memory is allocated so load the fields

            pThisSymbol->pNext = NULL;

            iNumArgs = sscanf (lpLineBuffer, "#define %s %d",
            lpAnsiSymbol, &pThisSymbol->Value);

            if (iNumArgs != 2) {
                *(pThisSymbol->SymbolName) = 0;
                pThisSymbol->Value = (DWORD)-1L;
                bReUse = TRUE;
            } else {
                // OemToChar (lpAnsiSymbol, pThisSymbol->SymbolName);
                mbstowcs (pThisSymbol->SymbolName,
                    lpAnsiSymbol, lstrlenA(lpAnsiSymbol)+1);
                TRACE((WINPERF_DBG_TRACE_INFO),
                      (& LoadPerfGuid,
                        __LINE__,
                        LOADPERF_LOADINCLUDEFILE,
                        ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                        ERROR_SUCCESS,
                        TRACE_WSTR(lpIncludeFileName),
                        TRACE_WSTR(pThisSymbol->SymbolName),
                        TRACE_DWORD(pThisSymbol->Value),
                        NULL));
                bReUse = FALSE;
            }
        }
    }

Cleanup:
    if (! bReturn) {
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_LOADINCLUDEFILE,
                ARG_DEF(ARG_TYPE_WSTR, 1),
                GetLastError(),
                TRACE_WSTR(lpIniFile),
                NULL));
    }
    if (lpIncludeFileName) MemoryFree(lpIncludeFileName);
    if (lpIncludeFile)     MemoryFree(lpIncludeFile);
    if (lpLineBuffer)      MemoryFree(lpLineBuffer);
    if (lpIniPath)         MemoryFree(lpIniPath);
    fclose (fIncludeFile);

    return bReturn;

}

BOOL
ParseTextId (
    IN LPTSTR  lpTextId,
    IN PSYMBOL_TABLE_ENTRY pFirstSymbol,
    OUT PDWORD  pdwOffset,
    OUT LPTSTR  *lpLangId,
    OUT PDWORD  pdwType
)
/*++

ParseTextId

    decodes Text Id key from .INI file

    syntax for this process is:

    {<DecimalNumber>}                {"NAME"}
    {<SymbolInTable>}_<LangIdString>_{"HELP"}

     e.g. 0_009_NAME
          OBJECT_1_009_HELP

Arguments

    lpTextId

    string to decode

    pFirstSymbol

    pointer to first entry in symbol table (NULL if no table)

    pdwOffset

    address of DWORD to recive offest value

    lpLangId

    address of pointer to Language Id string
    (NOTE: this will point into the string lpTextID which will be
    modified by this routine)

    pdwType

    pointer to dword that will recieve the type of string i.e.
    HELP or NAME

Return Value

    TRUE    text Id decoded successfully
    FALSE   unable to decode string

    NOTE: the string in lpTextID will be modified by this procedure

--*/
{
    LPTSTR  lpThisChar;
    PSYMBOL_TABLE_ENTRY pThisSymbol;

    // check for valid return arguments

    if (!(pdwOffset) || !(lpLangId) || !(pdwType)) {
        SetLastError (ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    // search string from right to left in order to identify the
    // components of the string.

    lpThisChar = lpTextId + lstrlen(lpTextId); // point to end of string

    while (*lpThisChar != cUnderscore) {
        lpThisChar--;
        if (lpThisChar <= lpTextId) {
            // underscore not found in string
            SetLastError (ERROR_INVALID_DATA);
            return FALSE;
        }
    }

    // first underscore found

    if ((lstrcmpi(lpThisChar, szName)) == 0) {
        // name found, so set type
        *pdwType = TYPE_NAME;
    } else if ((lstrcmpi(lpThisChar, szHelp)) == 0) {
        // help text found, so set type
        *pdwType = TYPE_HELP;
    } else {
        // bad format
        SetLastError (ERROR_INVALID_DATA);
        return FALSE;
    }

    // set the current underscore to \0 and look for language ID

    *lpThisChar-- = 0;

    while (*lpThisChar != cUnderscore) {
        lpThisChar--;
        if (lpThisChar <= lpTextId) {
            // underscore not found in string
            SetLastError (ERROR_INVALID_DATA);
            return FALSE;
        }
    }

    // set lang ID string pointer to current char ('_') + 1

    *lpLangId = lpThisChar + 1;

    // set this underscore to a NULL and try to decode the remaining text

    *lpThisChar = 0;

    // see if the first part of the string is a decimal digit

    if ((_stscanf (lpTextId, sz_DFormat, pdwOffset)) != 1) {
        // it's not a digit, so try to decode it as a symbol in the
        // loaded symbol table

        for (pThisSymbol=pFirstSymbol;
            pThisSymbol && *(pThisSymbol->SymbolName);
            pThisSymbol = pThisSymbol->pNext) {

            if ((lstrcmpi(lpTextId, pThisSymbol->SymbolName)) == 0) {
            // a matching symbol was found, so insert it's value
            // and return (that's all that needs to be done
            *pdwOffset = pThisSymbol->Value;
            return TRUE;
            }
        }
        // if here, then no matching symbol was found, and it's not
        // a number, so return an error

        SetLastError (ERROR_BAD_TOKEN_TYPE);
        return FALSE;
    } else {
        // symbol was prefixed with a decimal number
        return TRUE;
    }
}

PLANGUAGE_LIST_ELEMENT
FindLanguage (
    IN PLANGUAGE_LIST_ELEMENT   pFirstLang,
    IN LPCTSTR   pLangId
)
/*++

FindLanguage

    searchs the list of languages and returns a pointer to the language
    list entry that matches the pLangId string argument

Arguments

    pFirstLang

    pointer to first language list element

    pLangId

    pointer to text string with language ID to look up

Return Value

    Pointer to matching language list entry
    or NULL if no match

--*/
{
    PLANGUAGE_LIST_ELEMENT  pThisLang;

    for (pThisLang = pFirstLang;
     pThisLang;
     pThisLang = pThisLang->pNextLang) {
        if ((lstrcmpi(pLangId, pThisLang->LangId)) == 0) {
            // match found so return pointer
            return pThisLang;
        }
    }
    return NULL;    // no match found
}

BOOL
GetValue(
    LPTSTR lpLocalSectionBuff,
    LPTSTR lpLocalStringBuff
)
{

    LPTSTR  lpPosition;

    BOOL    bReturn = FALSE;

    lpPosition = _tcschr(lpLocalSectionBuff,cEquals);
    if (lpPosition) {
        lpPosition++;
        // make sure the "=" isn't the last char
        if (*lpPosition != 0) {
            //Found the "equals" sign
            lstrcpy (lpLocalStringBuff,lpPosition);
        } else {
            // empty string, return a pseudo blank string
            lstrcpy(lpLocalStringBuff, L" ");
        }
        bReturn = TRUE;
    } else {
        //ErrorFinfing the "="
        // bad format
        SetLastError (ERROR_INVALID_DATA);
    }
    return bReturn;
}

BOOL
GetValueFromIniKey (LPTSTR lpValueKey,
                    LPTSTR lpTextSection,
                    DWORD* pdwLastReadOffset,
                    DWORD  dwTryCount,
                    LPTSTR lpLocalStringBuff
                    )
{
    LPTSTR  lpLocalSectionBuff;
    DWORD   dwIndex;
    DWORD   dwLastReadOffset;
    BOOL    bRetVal = FALSE;

    if ((lpTextSection) && (lpValueKey)) {
        dwLastReadOffset = *pdwLastReadOffset;
        lpLocalSectionBuff = lpTextSection ;
        lpLocalSectionBuff += dwLastReadOffset;

        while(!(*lpLocalSectionBuff)){

            dwLastReadOffset += (lstrlen(lpTextSection + dwLastReadOffset) + 1);
            lpLocalSectionBuff = lpTextSection + dwLastReadOffset;
            *pdwLastReadOffset = dwLastReadOffset;

        }

        // search next N entries in buffer for entry
        // this should usually work since the file
        // is scanned sequentially so it's tried first
        for (dwIndex = 0;
             dwIndex < dwTryCount ;
             dwIndex++) {
            //  see if this is the correct entry
            // and return it if it is
            if (_tcsstr(lpLocalSectionBuff,lpValueKey)) {
                bRetVal = GetValue(lpLocalSectionBuff,
                        lpLocalStringBuff);
                //Set the lastReadOffset First
                dwLastReadOffset += (lstrlen(lpTextSection + dwLastReadOffset) + 1);
                *pdwLastReadOffset = dwLastReadOffset;
                break; // out of the for loop
            } else {
                // this isn't the correct one so go to the next
                // entry in the file
                dwLastReadOffset += (lstrlen(lpTextSection + dwLastReadOffset) + 1);
                lpLocalSectionBuff = lpTextSection + dwLastReadOffset;
                *pdwLastReadOffset = dwLastReadOffset;
            }
        }

        if (!bRetVal) {
            //Cannont Find the key using lastReadOffset
            //try again from the beggining of the Array
            dwLastReadOffset = 0;
            lpLocalSectionBuff = lpTextSection;
            *pdwLastReadOffset = dwLastReadOffset;

            while (*lpLocalSectionBuff != 0) {
                if (_tcsstr(lpLocalSectionBuff,lpValueKey)) {
                     bRetVal = GetValue(lpLocalSectionBuff,
                                lpLocalStringBuff);
                     break;
                } else {
                    // go to the next entry
                    dwLastReadOffset += (lstrlen(lpTextSection + dwLastReadOffset) + 1);
                    lpLocalSectionBuff = lpTextSection + dwLastReadOffset;
                    *pdwLastReadOffset = dwLastReadOffset;
                }
            }
        }
    } else {
        // one or two null pointers so give up now
    }
    return bRetVal;
}

BOOL
AddEntryToLanguage (
    PLANGUAGE_LIST_ELEMENT  pLang,
    LPTSTR                  lpValueKey,
    LPTSTR                  lpTextSection,
    DWORD                   *pdwLastReadOffset,
    DWORD                   dwTryCount,
    DWORD                   dwType,
    DWORD                   dwOffset,
    LPTSTR                  lpIniFile
)
/*++

AddEntryToLanguage

    Add a text entry to the list of text entries for the specified language

Arguments

    pLang

    pointer to language structure to update

    lpValueKey

    value key to look up in .ini file

    dwOffset

    numeric offset of name in registry

    lpIniFile

    ini file

Return Value

    TRUE if added successfully
    FALSE if error
    (see GetLastError for status)

--*/
{
    LPTSTR  lpLocalStringBuff = NULL;
    DWORD   dwBufferSize;
    DWORD   dwStatus = ERROR_SUCCESS;
    BOOL    bRetVal;
    BOOL    bReturn = FALSE;

    UNREFERENCED_PARAMETER (lpIniFile);

    if (   (dwType == TYPE_NAME && dwOffset < FIRST_EXT_COUNTER_INDEX)
        || (dwType == TYPE_HELP && dwOffset < FIRST_EXT_HELP_INDEX)) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE,
                (DWORD) LDPRFMSG_CORRUPT_INDEX,
                2, dwOffset, dwType, 0,
                1, lpValueKey, NULL, NULL);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_ADDENTRYTOLANGUAGE,
                ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                ERROR_BADKEY,
                TRACE_WSTR(lpTextSection),
                TRACE_WSTR(lpValueKey),
                TRACE_DWORD(dwType),
                TRACE_DWORD(dwOffset),
                NULL));
        dwStatus = ERROR_BADKEY;
        goto Cleanup;
    }

    dwBufferSize = SMALL_BUFFER_SIZE * 4 * sizeof(TCHAR);
    if (dwBufferSize < dwFileSize) {
        dwBufferSize = dwFileSize;
    }

    lpLocalStringBuff = MemoryAllocate (dwBufferSize);

    if (!lpLocalStringBuff) {
        dwStatus = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }

    bRetVal = GetValueFromIniKey(lpValueKey,
                       lpTextSection,
                       pdwLastReadOffset,
                       dwTryCount,
                       lpLocalStringBuff);

    if (!bRetVal) {
        dwStatus = ERROR_BADKEY;
        goto Cleanup;
    }

    if ((lstrcmpi(lpLocalStringBuff, szNotFound))== 0) {
        dwStatus = ERROR_BADKEY;
        goto Cleanup;
    }
    // key found, so load structure

    if (!pLang->pThisName) {
        // this is the first
        pLang->pThisName =
                MemoryAllocate (sizeof (NAME_ENTRY) +
                        (lstrlen(lpLocalStringBuff) + 1) * sizeof (TCHAR));
        if (!pLang->pThisName) {
            dwStatus = ERROR_OUTOFMEMORY;
            goto Cleanup;
        } else {
            pLang->pFirstName = pLang->pThisName;
        }
    } else {
        pLang->pThisName->pNext =
            MemoryAllocate (sizeof (NAME_ENTRY) +
                (lstrlen(lpLocalStringBuff) + 1) * sizeof (TCHAR));
        if (!pLang->pThisName->pNext) {
            dwStatus = ERROR_OUTOFMEMORY;
            goto Cleanup;
        } else {
            pLang->pThisName = pLang->pThisName->pNext;
        }
    }

    // pLang->pThisName now points to an uninitialized structre

    pLang->pThisName->pNext    = NULL;
    pLang->pThisName->dwOffset = dwOffset;
    pLang->pThisName->dwType   = dwType;
    pLang->pThisName->lpText   = (LPTSTR) & (pLang->pThisName[1]);
    lstrcpy (pLang->pThisName->lpText, lpLocalStringBuff);
    bReturn = TRUE;

Cleanup:
    if (lpLocalStringBuff != NULL) MemoryFree (lpLocalStringBuff);
    SetLastError(dwStatus);
    return (bReturn);
}

BOOL
CreateObjectList (
    IN  LPTSTR  lpIniFile,
    IN  DWORD   dwFirstDriverCounter,
    IN  PSYMBOL_TABLE_ENTRY pFirstSymbol,
    IN  LPTSTR  lpszObjectList,
    IN  PPERFOBJECT_LOOKUP  pObjectGuidTable,
    IN  LPDWORD pdwObjectGuidTableEntries
    )
{
    TCHAR   szDigits[32];
    LPTSTR  szLangId;
    TCHAR   szTempString[256];
    TCHAR   szObjectSectionEntries[2048];
    LPWSTR  szGuidStringBuffer;
    LPTSTR  szThisKey;
    DWORD   dwSize;
    DWORD   dwObjectCount = 0;
    DWORD   dwId;
    DWORD   dwType;
    DWORD   dwObjectGuidIndex = 0;

    szObjectSectionEntries[0] = 0;
    szThisKey = &szObjectSectionEntries[0];

    dwSize = GetPrivateProfileString (
        szObjects,
        NULL,
        szNotFound,
        szObjectSectionEntries,
        sizeof(szObjectSectionEntries) / sizeof (TCHAR),
        lpIniFile);

    *lpszObjectList = 0;
    if (lstrcmp (szObjectSectionEntries, szNotFound) != 0) {
        // then some entries were found so read each one, compute the
        // index value and save in the string buffer passed by the caller
        for (szThisKey = szObjectSectionEntries;
            *szThisKey != 0;
            szThisKey += lstrlen(szThisKey) + 1) {
            // ParstTextId modifies the string so we need to make a work copy
            lstrcpy (szTempString, szThisKey);
            if (ParseTextId(szTempString, pFirstSymbol, &dwId, &szLangId, &dwType)) {
                // then dwID is the id of an object supported by this DLL
                if (dwObjectCount != 0) {
                    lstrcat (lpszObjectList, szSpace);
                }
                _ultot ((dwId + dwFirstDriverCounter), szDigits, 10);
                lstrcat (lpszObjectList, szDigits);
                //
                //  now see if this object has a GUID string
                //
                szGuidStringBuffer = MemoryAllocate(1024);
                if (szGuidStringBuffer == NULL) {
                    // cannot allocate memory for szGuidStringBuffer, ignore
                    // and continue the next one.
                    //
                    dwObjectCount ++;
                    continue;
                }
                dwSize = GetPrivateProfileStringW (
                    szObjects,
                    szThisKey,
                    szNotFound,
                    szGuidStringBuffer,
                    1024,
                    lpIniFile);
                if (dwSize > 0) {
                    if (lstrcmpW (szGuidStringBuffer, szNotFound) != 0) {
                        // then some string is present, so see if
                        // it looks like a GUID
                        if ((szGuidStringBuffer[0] == L'{') &&
                            (szGuidStringBuffer[9] == L'-') &&
                            (szGuidStringBuffer[14] == L'-') &&
                            (szGuidStringBuffer[19] == L'-') &&
                            (szGuidStringBuffer[24] == L'-') &&
                            (szGuidStringBuffer[37] == L'}')) {
                            // then it's probably a GUID so store it
                            szGuidStringBuffer = MemoryResize (szGuidStringBuffer,
                                (dwSize + 1) * sizeof(WCHAR));
                            if (szGuidStringBuffer == NULL) {
                                // cannot reallocate memory for
                                // szGuidStringBuffer, ignore and continue
                                // the next one.
                                //
                                continue;
                            }
                            if (dwObjectGuidIndex < *pdwObjectGuidTableEntries) {
                                pObjectGuidTable[dwObjectGuidIndex].PerfObjectId =
                                    dwId + dwFirstDriverCounter;
                                pObjectGuidTable[dwObjectGuidIndex].GuidString =
                                    szGuidStringBuffer;
                                dwObjectGuidIndex++;

                                TRACE((WINPERF_DBG_TRACE_INFO),
                                      (& LoadPerfGuid,
                                        __LINE__,
                                        LOADPERF_CREATEOBJECTLIST,
                                        ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                                        ERROR_SUCCESS,
                                        TRACE_WSTR(lpIniFile),
                                        TRACE_WSTR(szGuidStringBuffer),
                                        TRACE_DWORD(dwObjectGuidIndex),
                                        NULL));
                            } else {
                                // table is full
                            }
                        } else {
                            // not a GUID so ignore
                        }
                    } else {
                        // no string after object reference
                    }
                }
                dwObjectCount++;
            } else {
                // invalid key format
            }
        }
        // save size of Guid Table
        *pdwObjectGuidTableEntries = dwObjectGuidIndex;
    } else {
        // log message that object list is not used
        ReportLoadPerfEvent(
                EVENTLOG_WARNING_TYPE, // error type
                (DWORD) LDPRFMSG_NO_OBJECT_LIST, // event,
                0, 0, 0, 0,
                0, NULL, NULL, NULL);
        TRACE((WINPERF_DBG_TRACE_WARNING),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_CREATEOBJECTLIST,
                ARG_DEF(ARG_TYPE_WSTR, 1),
                ERROR_SUCCESS,
                TRACE_WSTR(lpIniFile),
                TRACE_DWORD(dwFirstDriverCounter),
                NULL));
    }

    return TRUE;
}

BOOL
LoadLanguageLists (
    IN LPTSTR  lpIniFile,
    IN DWORD   dwFirstCounter,
    IN DWORD   dwFirstHelp,
    IN PSYMBOL_TABLE_ENTRY   pFirstSymbol,
    IN PLANGUAGE_LIST_ELEMENT  pFirstLang
)
/*++

LoadLanguageLists

    Reads in the name and explain text definitions from the ini file and
    builds a list of these items for each of the supported languages and
    then combines all the entries into a sorted MULTI_SZ string buffer.

Arguments

    lpIniFile

    file containing the definitions to add to the registry

    dwFirstCounter

    starting counter name index number

    dwFirstHelp

    starting help text index number

    pFirstLang

    pointer to first element in list of language elements

Return Value

    TRUE if all is well
    FALSE if not
    error is returned in GetLastError

--*/
{
    LPTSTR  lpTextIdArray;
    LPTSTR  lpLocalKey;
    LPTSTR  lpThisKey;
    LPTSTR  lpTextSectionArray;
    DWORD   dwSize;
    LPTSTR  lpLang;
    DWORD   dwOffset;
    DWORD   dwType;
    PLANGUAGE_LIST_ELEMENT  pThisLang, pLangPointer=NULL;
    DWORD   dwBufferSize;
    DWORD   dwSuccessCount = 0;
    DWORD   dwErrorCount = 0;
    DWORD   dwLastReadOffset = 0;
    DWORD   dwTryCount = 4;     //Init this value with 4 (at least 4 times to try maching Key and Value)

    pLangPointer = pFirstLang;

    while (pFirstLang) {
         pFirstLang = pFirstLang->pNextLang;
         //if you have more languages then increase this try limit to 4 + No. of langs
         dwTryCount++;
    }
    pFirstLang = pLangPointer;

    dwBufferSize = SMALL_BUFFER_SIZE * 4 * sizeof(TCHAR);
    if (dwBufferSize < dwFileSize) {
        dwBufferSize = dwFileSize;
    }

    lpTextIdArray = MemoryAllocate (dwBufferSize);
    if (lpTextIdArray == NULL) {
        SetLastError (ERROR_OUTOFMEMORY);
        return FALSE;
    }

    lpLocalKey = MemoryAllocate (MAX_PATH * sizeof(TCHAR));
    if (lpLocalKey == NULL) {
        SetLastError (ERROR_OUTOFMEMORY);
        if (lpTextIdArray) MemoryFree (lpTextIdArray);
        return FALSE;
    }

    lpTextSectionArray = MemoryAllocate (dwBufferSize);
    if (lpTextSectionArray == NULL) {
        SetLastError (ERROR_OUTOFMEMORY);
        if (lpTextIdArray) MemoryFree(lpTextIdArray);
        if (lpLocalKey)    MemoryFree(lpLocalKey);
        return FALSE;
    }

    TRACE((WINPERF_DBG_TRACE_INFO),
          (& LoadPerfGuid,
            __LINE__,
            LOADPERF_LOADLANGUAGELISTS,
            ARG_DEF(ARG_TYPE_WSTR, 1),
            ERROR_SUCCESS,
            TRACE_WSTR(lpIniFile),
            TRACE_DWORD(dwFirstCounter),
            TRACE_DWORD(dwFirstHelp),
            NULL));

    // get list of text keys to look up

    dwSize = GetPrivateProfileString (
        szText,   // [text] section of .INI file
        NULL,           // return all keys
        szNotFound,
        lpTextIdArray,  // return buffer
        dwBufferSize / sizeof(TCHAR),
        lpIniFile);     // .INI file name

    if ((lstrcmpi(lpTextIdArray, szNotFound)) == 0) {
        // key not found, default returned
        SetLastError (ERROR_NO_SUCH_GROUP);
        if (lpTextIdArray)      MemoryFree(lpTextIdArray);
        if (lpLocalKey)         MemoryFree(lpLocalKey);
        if (lpTextSectionArray) MemoryFree(lpTextSectionArray);
        return FALSE;
    }

    // get the the [text] section from the ini file

    dwSize = GetPrivateProfileSection (
        szText,              // [text] section of .INI file
        lpTextSectionArray,  // return buffer
        dwBufferSize / sizeof(TCHAR),
        lpIniFile);          // .INI file name

    // do each key returned

    for (lpThisKey=lpTextIdArray;
         * lpThisKey;
         lpThisKey += (lstrlen(lpThisKey) + 1)) {

        lstrcpy (lpLocalKey, lpThisKey);    // make a copy of the key

        // parse key to see if it's in the correct format

        if (ParseTextId(lpLocalKey, pFirstSymbol, &dwOffset, &lpLang, &dwType)) {
            // so get pointer to language entry structure
            pThisLang = FindLanguage (pFirstLang, lpLang);
            if (pThisLang) {
                if (!AddEntryToLanguage(pThisLang,
                                        lpThisKey,
                                        lpTextSectionArray,
                                        & dwLastReadOffset,
                                        dwTryCount,
                                        dwType,
                                        (dwOffset + (  (dwType == TYPE_NAME)
                                                     ? dwFirstCounter
                                                     : dwFirstHelp)),
                                        lpIniFile)) {
                    OUTPUT_MESSAGE (GetFormatResource (LC_ERRADDTOLANG),
                        lpThisKey,
                        lpLang,
                        GetLastError());
                    dwErrorCount ++;
                } else {
                    dwSuccessCount ++;
                }
                TRACE((WINPERF_DBG_TRACE_INFO),
                      (& LoadPerfGuid,
                        __LINE__,
                        LOADPERF_LOADLANGUAGELISTS,
                        ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                        ERROR_SUCCESS,
                        TRACE_WSTR(lpThisKey),
                        TRACE_WSTR(lpLang),
                        TRACE_DWORD(dwOffset),
                        TRACE_DWORD(dwType),
                        NULL));
            } else { // language not in list
                OUTPUT_MESSAGE (GetFormatResource(LC_LANGNOTFOUND), lpLang, lpThisKey);
                TRACE((WINPERF_DBG_TRACE_INFO),
                      (& LoadPerfGuid,
                        __LINE__,
                        LOADPERF_LOADLANGUAGELISTS,
                        ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                        ERROR_SUCCESS,
                        TRACE_WSTR(lpThisKey),
                        TRACE_WSTR(lpLang),
                        NULL));
            }
        } else { // unable to parse ID string
            OUTPUT_MESSAGE(GetFormatResource(LC_BAD_KEY), lpThisKey);
            TRACE((WINPERF_DBG_TRACE_ERROR),
                  (& LoadPerfGuid,
                    __LINE__,
                    LOADPERF_LOADLANGUAGELISTS,
                    ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                    ERROR_BADKEY,
                    TRACE_WSTR(lpThisKey),
                    TRACE_WSTR(lpLang),
                    NULL));
        }
    }

    if (lpTextIdArray)      MemoryFree(lpTextIdArray);
    if (lpLocalKey)         MemoryFree(lpLocalKey);
    if (lpTextSectionArray) MemoryFree(lpTextSectionArray);

    return (BOOL) (dwErrorCount == 0);
}

BOOL
SortLanguageTables (
    PLANGUAGE_LIST_ELEMENT pFirstLang,
    PDWORD                 pdwLastName,
    PDWORD                 pdwLastHelp
)
/*++

SortLangageTables

    walks list of languages loaded, allocates and loads a sorted multi_SZ
    buffer containing new entries to be added to current names/help text

Arguments

    pFirstLang

    pointer to first element in list of languages

ReturnValue

    TRUE    everything done as expected
    FALSE   error occurred, status in GetLastError

--*/
{
    PLANGUAGE_LIST_ELEMENT  pThisLang;

    BOOL            bSorted;

    LPTSTR          pNameBufPos, pHelpBufPos;

    PNAME_ENTRY     pThisName, pPrevName;

    DWORD           dwHelpSize, dwNameSize, dwSize;
    DWORD           dwCurrentLastName;
    DWORD           dwCurrentLastHelp;

    if (!pdwLastName || !pdwLastHelp) {
        SetLastError (ERROR_BAD_ARGUMENTS);
        return FALSE;
    }

    for (pThisLang = pFirstLang;
         pThisLang;
         pThisLang = pThisLang->pNextLang) {
        // do each language in list
        // sort elements in list by value (offset) so that lowest is first

        if (pThisLang->pFirstName == NULL) {
            // no elements in this list, continue the next one
            continue;
        }

        bSorted = FALSE;
        while (!bSorted ) {
            // point to start of list

            pPrevName = pThisLang->pFirstName;
            if (pPrevName) {
                pThisName = pPrevName->pNext;
            } else {
                break; // no elements in this list
            }

            if (!pThisName) {
                break;      // only one element in the list
            }
            bSorted = TRUE; // assume that it's sorted

            // go until end of list

            while (pThisName->pNext) {
                if (pThisName->dwOffset > pThisName->pNext->dwOffset) {
                    // switch 'em
                    PNAME_ENTRY     pA, pB;
                    pPrevName->pNext = pThisName->pNext;
                    pA = pThisName->pNext;
                    pB = pThisName->pNext->pNext;
                    pThisName->pNext = pB;
                    pA->pNext = pThisName;
                    pThisName = pA;
                    bSorted = FALSE;
                }
                //move to next entry
                pPrevName = pThisName;
                pThisName = pThisName->pNext;
            }
            // if bSorted = TRUE , then we walked all the way down
            // the list without changing anything so that's the end.
        }

        // with the list sorted, build the MULTI_SZ strings for the
        // help and name text strings

        // compute buffer size

        dwNameSize = dwHelpSize = 0;
        dwCurrentLastName = 0;
        dwCurrentLastHelp = 0;

        for (pThisName = pThisLang->pFirstName;
            pThisName;
            pThisName = pThisName->pNext) {
            // compute buffer requirements for this entry
            dwSize = SIZE_OF_OFFSET_STRING;
            dwSize += lstrlen (pThisName->lpText);
            dwSize += 1;   // null
            dwSize *= sizeof (TCHAR);   // adjust for character size
            // add to appropriate size register
            if (pThisName->dwType == TYPE_NAME) {
                dwNameSize += dwSize;
                if (pThisName->dwOffset > dwCurrentLastName) {
                    dwCurrentLastName = pThisName->dwOffset;
                }
            } else if (pThisName->dwType == TYPE_HELP) {
                dwHelpSize += dwSize;
                if (pThisName->dwOffset > dwCurrentLastHelp) {
                    dwCurrentLastHelp = pThisName->dwOffset;
                }
            }
        }

        // allocate buffers for the Multi_SZ strings

        pThisLang->NameBuffer = MemoryAllocate (dwNameSize);
        pThisLang->HelpBuffer = MemoryAllocate (dwHelpSize);

        if (!pThisLang->NameBuffer || !pThisLang->HelpBuffer) {
            SetLastError (ERROR_OUTOFMEMORY);
            return FALSE;
        }

        // fill in buffers with sorted strings

        pNameBufPos = (LPTSTR)pThisLang->NameBuffer;
        pHelpBufPos = (LPTSTR)pThisLang->HelpBuffer;

        for (pThisName = pThisLang->pFirstName;
            pThisName;
            pThisName = pThisName->pNext) {
            if (pThisName->dwType == TYPE_NAME) {
                // load number as first 0-term. string
                dwSize = _stprintf (pNameBufPos, szDFormat, pThisName->dwOffset);
                pNameBufPos += dwSize + 1;  // save NULL term.
                // load the text to match
                lstrcpy (pNameBufPos, pThisName->lpText);
                pNameBufPos += lstrlen(pNameBufPos) + 1;
            } else if (pThisName->dwType == TYPE_HELP) {
                // load number as first 0-term. string
                dwSize = _stprintf (pHelpBufPos, szDFormat, pThisName->dwOffset);
                pHelpBufPos += dwSize + 1;  // save NULL term.
                // load the text to match
                lstrcpy (pHelpBufPos, pThisName->lpText);
                pHelpBufPos += lstrlen(pHelpBufPos) + 1;
            }
        }

        // add additional NULL at end of string to terminate MULTI_SZ

        * pHelpBufPos = 0;
        * pNameBufPos = 0;

        // compute size of MULTI_SZ strings

        pThisLang->dwNameBuffSize = (DWORD)((PBYTE)pNameBufPos -
                            (PBYTE)pThisLang->NameBuffer) +
                            sizeof(TCHAR);
        pThisLang->dwHelpBuffSize = (DWORD)((PBYTE)pHelpBufPos -
                            (PBYTE)pThisLang->HelpBuffer) +
                            sizeof(TCHAR);

        if (* pdwLastName < dwCurrentLastName) {
            * pdwLastName = dwCurrentLastName;
        }
        if (* pdwLastHelp < dwCurrentLastHelp) {
            * pdwLastHelp = dwCurrentLastHelp;
        }
        TRACE((WINPERF_DBG_TRACE_INFO),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_SORTLANGUAGETABLES,
                ARG_DEF(ARG_TYPE_WSTR, 1),
                ERROR_SUCCESS,
                TRACE_WSTR(pThisLang->LangId),
                TRACE_DWORD(pThisLang->dwNumElements),
                TRACE_DWORD(dwCurrentLastName),
                TRACE_DWORD(dwCurrentLastHelp),
                NULL));
    }

    dwCurrentLastName = * pdwLastName;
    dwCurrentLastHelp = * pdwLastHelp;
    TRACE((WINPERF_DBG_TRACE_INFO),
          (& LoadPerfGuid,
            __LINE__,
            LOADPERF_SORTLANGUAGETABLES,
            0,
            ERROR_SUCCESS,
            TRACE_DWORD(dwCurrentLastName),
            TRACE_DWORD(dwCurrentLastHelp),
            NULL));
    return TRUE;
}

BOOL
GetInstalledLanguageList (
    HKEY hPerflibRoot,
    LPTSTR *mszLangList
)
/*++
    returns a list of language sub keys found under the perflib key

--*/
{
    BOOL    bReturn = TRUE;
    LONG    lStatus;
    DWORD   dwIndex = 0;
    LPTSTR  szBuffer;
    DWORD   dwBufSize;
    LPTSTR  szRetBuffer = NULL;
    DWORD   dwRetBufSize = 0;
    DWORD   dwLastBufSize = 0;
    LPTSTR  szNextString;

    dwBufSize = MAX_PATH;
    szBuffer = MemoryAllocate(dwBufSize * sizeof(TCHAR));

    if (szBuffer == NULL) {
        SetLastError (ERROR_OUTOFMEMORY);
        bReturn = FALSE;
    }

    if (bReturn) {
        while ((lStatus = RegEnumKeyEx (hPerflibRoot,
            dwIndex, szBuffer, &dwBufSize,
                NULL, NULL, NULL, NULL)) == ERROR_SUCCESS) {

            dwRetBufSize += (lstrlen(szBuffer) + 1) * sizeof (TCHAR);
            if (szRetBuffer != NULL) {
                LPTSTR szTmpBuffer = szRetBuffer;
                szRetBuffer = MemoryResize (szRetBuffer, dwRetBufSize);
                if (szRetBuffer == NULL) {
                    MemoryFree(szTmpBuffer);
                }
            } else {
                szRetBuffer = MemoryAllocate (dwRetBufSize);
            }

            if (szRetBuffer == NULL) {
                SetLastError (ERROR_OUTOFMEMORY);
                bReturn = FALSE;
                break;
            }

            szNextString = (LPTSTR)((LPBYTE)szRetBuffer + dwLastBufSize);
            lstrcpy (szNextString, szBuffer);
            TRACE((WINPERF_DBG_TRACE_INFO),
                  (& LoadPerfGuid,
                    __LINE__,
                    LOADPERF_GETINSTALLEDLANGUAGELIST,
                    ARG_DEF(ARG_TYPE_WSTR, 1),
                    ERROR_SUCCESS,
                    TRACE_WSTR(szBuffer),
                    TRACE_DWORD(dwIndex),
                    NULL));
            dwLastBufSize = dwRetBufSize;
            dwIndex++;
            dwBufSize = MAX_PATH;
        }
    }

    if (bReturn) {
        // add terminating null char
        dwRetBufSize += sizeof (TCHAR);
        if (szRetBuffer != NULL) {
            szRetBuffer = MemoryResize (szRetBuffer, dwRetBufSize);
        } else {
            szRetBuffer = MemoryAllocate (dwRetBufSize);
        }

        if (szRetBuffer == NULL) {
            SetLastError (ERROR_OUTOFMEMORY);
            bReturn = FALSE;
        }
        else {
            szNextString = (LPTSTR)((LPBYTE)szRetBuffer + dwLastBufSize);
            * szNextString = 0;
        }
    }

    if (bReturn) {
        *mszLangList = szRetBuffer;
    }

    return bReturn;
}

BOOL
CheckNameTable(
    LPTSTR lpNameStr,
    LPTSTR lpHelpStr,
    DWORD  dwLastCounter,
    DWORD  dwLastHelp)
{
    DWORD  dwLastId         = (dwLastCounter > dwLastHelp)
                            ? (dwLastCounter) : (dwLastHelp);
    BOOL   bResult          = TRUE;
    LPTSTR lpThisId;
    DWORD  dwThisId;

    for (lpThisId = lpNameStr;
         * lpThisId;
         lpThisId += (lstrlen(lpThisId) + 1)) {

        dwThisId = _tcstoul(lpThisId, NULL, 10);
        if ((dwThisId == 0) || (dwThisId > dwLastId)
                            || (dwThisId > dwLastCounter)) {
            ReportLoadPerfEvent(
                    EVENTLOG_ERROR_TYPE, // error type
                    (DWORD) LDPRFMSG_REGISTRY_COUNTER_STRINGS_CORRUPT, // event,
                    1, dwThisId, 0, 0,
                    0, NULL, NULL, NULL);
            TRACE((WINPERF_DBG_TRACE_ERROR),
                  (& LoadPerfGuid,
                    __LINE__,
                    LOADPERF_CHECKNAMETABLE,
                    ARG_DEF(ARG_TYPE_WSTR, 1),
                    ERROR_BADKEY,
                    TRACE_WSTR(lpThisId),
                    TRACE_DWORD(dwThisId),
                    TRACE_DWORD(dwLastCounter),
                    TRACE_DWORD(dwLastHelp),
                    NULL));
            SetLastError(ERROR_BADKEY);
            bResult = FALSE;
            break;
        }

        // point to corresponding counter name

        lpThisId += (lstrlen(lpThisId) + 1);
    }

    if (bResult) {
        for (lpThisId = lpHelpStr;
             * lpThisId;
             lpThisId += (lstrlen(lpThisId) + 1)) {

            dwThisId = _tcstoul(lpThisId, NULL, 10);
            if ((dwThisId == 0) || (dwThisId > dwLastId)
                            || (dwThisId > dwLastHelp)) {
                ReportLoadPerfEvent(
                        EVENTLOG_ERROR_TYPE, // error type
                        (DWORD) LDPRFMSG_REGISTRY_HELP_STRINGS_CORRUPT, // event,
                        1, dwThisId, 0, 0,
                        0, NULL, NULL, NULL);
                TRACE((WINPERF_DBG_TRACE_ERROR),
                      (& LoadPerfGuid,
                        __LINE__,
                        LOADPERF_CHECKNAMETABLE,
                        ARG_DEF(ARG_TYPE_WSTR, 1),
                        ERROR_BADKEY,
                        TRACE_WSTR(lpThisId),
                        TRACE_DWORD(dwThisId),
                        TRACE_DWORD(dwLastCounter),
                        TRACE_DWORD(dwLastHelp),
                        NULL));
                SetLastError(ERROR_BADKEY);
                bResult = FALSE;
                break;
            }

            // point to corresponding counter name

            lpThisId += (lstrlen(lpThisId) + 1);
        }
    }

    return bResult;
}

BOOL
UpdateEachLanguage (
    HKEY    hPerflibRoot,
    LPWSTR  mszInstalledLangList,
    DWORD   dwLastCounter,
    DWORD   dwLastHelp,
    PLANGUAGE_LIST_ELEMENT    pFirstLang
)
/*++

UpdateEachLanguage

    Goes through list of languages and adds the sorted MULTI_SZ strings
    to the existing counter and explain text in the registry.
    Also updates the "Last Counter and Last Help" values

Arguments

    hPerflibRoot    handle to Perflib key in the registry

    mszInstalledLangList
                    MSZ string of installed language keys

    pFirstLanguage  pointer to first language entry

Return Value

    TRUE    all went as planned
    FALSE   an error occured, use GetLastError to find out what it was.

--*/
{

    PLANGUAGE_LIST_ELEMENT  pThisLang;

    LPTSTR      pHelpBuffer;
    LPTSTR      pNameBuffer;
    LPTSTR      pNewName;
    LPTSTR      pNewHelp;
    DWORD       dwBufferSize;
    DWORD       dwValueType;
    DWORD       dwCounterSize;
    DWORD       dwHelpSize;
    HKEY        hKeyThisLang;
    LONG        lStatus;
    TCHAR       CounterNameBuffer [20];
    TCHAR       HelpNameBuffer [20];
    TCHAR       AddCounterNameBuffer [20];
    TCHAR       AddHelpNameBuffer [20];
    LPTSTR      szThisLang;

    for (szThisLang = mszInstalledLangList;
        *szThisLang != 0;
        szThisLang += (lstrlen(szThisLang) + 1)) {

        if (dwSystemVersion == OLD_VERSION) {
            // Open key for this language

            lStatus = RegOpenKeyEx(
            hPerflibRoot,
            szThisLang,
            RESERVED,
            KEY_READ | KEY_WRITE,
            &hKeyThisLang);
        } else {
            lstrcpy(CounterNameBuffer, CounterNameStr);
            lstrcat(CounterNameBuffer, szThisLang);
            lstrcpy(HelpNameBuffer, HelpNameStr);
            lstrcat(HelpNameBuffer, szThisLang);
            lstrcpy(AddCounterNameBuffer, AddCounterNameStr);
            lstrcat(AddCounterNameBuffer, szThisLang);
            lstrcpy(AddHelpNameBuffer, AddHelpNameStr);
            lstrcat(AddHelpNameBuffer, szThisLang);

            // make sure this language is loaded
            lStatus = RegOpenKeyEx(
                hPerflibRoot,
                szThisLang,
                RESERVED,
                KEY_READ,
                &hKeyThisLang);

            // we just need the open status, not the key handle so
            // close this handle and set the one we need.

            if (lStatus == ERROR_SUCCESS) {
                RegCloseKey (hKeyThisLang);
            }
            hKeyThisLang = hPerfData;
        }

        // look up the new strings to add

        pThisLang = FindLanguage (pFirstLang, szThisLang);

        if (pThisLang == NULL) {
            // try default language if available
            pThisLang = FindLanguage (pFirstLang, DefaultLangTag);
        }

        if (pThisLang == NULL) {
            // try english language if available
            pThisLang = FindLanguage (pFirstLang, DefaultLangId);
        }

        if (pThisLang == NULL) {
            // unable to add this language so continue
            lStatus = ERROR_NO_MATCH;
        }
        else if (pThisLang->NameBuffer == NULL || pThisLang->HelpBuffer == NULL) {
            ReportLoadPerfEvent(
                    EVENTLOG_WARNING_TYPE, // error type
                    (DWORD) LDPRFMSG_CORRUPT_INCLUDE_FILE, // event,
                    0, 0, 0, 0,
                    1, pThisLang->LangId, NULL, NULL);
            TRACE((WINPERF_DBG_TRACE_WARNING),
                  (& LoadPerfGuid,
                    __LINE__,
                    LOADPERF_UPDATEEACHLANGUAGE,
                    ARG_DEF(ARG_TYPE_WSTR, 1),
                    LDPRFMSG_CORRUPT_INCLUDE_FILE,
                    TRACE_WSTR(pThisLang->LangId),
                    NULL));
            lStatus = LDPRFMSG_CORRUPT_INCLUDE_FILE;
        }

        TRACE((WINPERF_DBG_TRACE_INFO),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_UPDATEEACHLANGUAGE,
                ARG_DEF(ARG_TYPE_WSTR, 1),
                lStatus,
                TRACE_WSTR(pThisLang->LangId),
                TRACE_DWORD(dwLastCounter),
                TRACE_DWORD(dwLastHelp),
                NULL));

        if (lStatus == ERROR_SUCCESS) {
            // make a backup copy of the data file before updating the
            // contents
            if (dwSystemVersion != OLD_VERSION) {
            //  this isn't possible on 3.1
                MakeBackupCopyOfLanguageFiles (pThisLang->LangId);
            }

            // get size of counter names

            dwBufferSize = 0;
            lStatus = RegQueryValueEx (
                hKeyThisLang,
                (dwSystemVersion == OLD_VERSION) ? Counters : CounterNameBuffer,
                RESERVED,
                &dwValueType,
                NULL,
                &dwBufferSize);

            if (lStatus != ERROR_SUCCESS) {
                if (dwSystemVersion != OLD_VERSION) {
                    // this means the language is not installed in the system.
                    continue;
                }
                ReportLoadPerfEvent(
                        EVENTLOG_ERROR_TYPE, // error type
                        (DWORD) LDPRFMSG_UNABLE_READ_COUNTER_STRINGS, // event,
                        1, lStatus, 0, 0,
                        1, pThisLang->LangId, NULL, NULL);
                TRACE((WINPERF_DBG_TRACE_ERROR),
                      (& LoadPerfGuid,
                        __LINE__,
                        LOADPERF_UPDATEEACHLANGUAGE,
                        ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                        lStatus,
                        TRACE_WSTR(pThisLang->LangId),
                        TRACE_WSTR(Counters),
                        NULL));
                SetLastError (lStatus);
                return FALSE;
            }

            dwCounterSize = dwBufferSize;

            // get size of help text

            dwBufferSize = 0;
            lStatus = RegQueryValueEx (
                hKeyThisLang,
                (dwSystemVersion == OLD_VERSION) ? Help : HelpNameBuffer,
                RESERVED,
                &dwValueType,
                NULL,
                &dwBufferSize);

            if (lStatus != ERROR_SUCCESS) {
                if (dwSystemVersion != OLD_VERSION) {
                    // this means the language is not installed in the system.
                    continue;
                }
                ReportLoadPerfEvent(
                        EVENTLOG_ERROR_TYPE, // error type
                        (DWORD) LDPRFMSG_UNABLE_READ_HELP_STRINGS, // event,
                        1, lStatus, 0, 0,
                        1, pThisLang->LangId, NULL, NULL);
                TRACE((WINPERF_DBG_TRACE_ERROR),
                      (& LoadPerfGuid,
                        __LINE__,
                        LOADPERF_UPDATEEACHLANGUAGE,
                        ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                        lStatus,
                        TRACE_WSTR(pThisLang->LangId),
                        TRACE_WSTR(Help),
                        NULL));
                SetLastError (lStatus);
                return FALSE;
            }

            dwHelpSize = dwBufferSize;

            // allocate new buffers

            dwCounterSize += pThisLang->dwNameBuffSize;
            pNameBuffer = MemoryAllocate(dwCounterSize);

            dwHelpSize += pThisLang->dwHelpBuffSize;
            pHelpBuffer = MemoryAllocate(dwHelpSize);

            if (!pNameBuffer || !pHelpBuffer) {
                if (pNameBuffer) MemoryFree(pNameBuffer);
                if (pHelpBuffer) MemoryFree(pHelpBuffer);
                SetLastError(ERROR_OUTOFMEMORY);
                return (FALSE);
            }

            // load current buffers into memory

            // read counter names into buffer. Counter names will be stored as
            // a MULTI_SZ string in the format of "###" "Name"

            dwBufferSize = dwCounterSize;
            lStatus = RegQueryValueEx (
                hKeyThisLang,
                (dwSystemVersion == OLD_VERSION) ? Counters : CounterNameBuffer,
                RESERVED,
                &dwValueType,
                (LPVOID)pNameBuffer,
                &dwBufferSize);

            if (lStatus != ERROR_SUCCESS) {
                MemoryFree (pNameBuffer);
                MemoryFree (pHelpBuffer);

                ReportLoadPerfEvent(
                        EVENTLOG_ERROR_TYPE, // error type
                        (DWORD) LDPRFMSG_UNABLE_READ_COUNTER_STRINGS, // event,
                        1, lStatus, 0, 0,
                        1, pThisLang->LangId, NULL, NULL);
                TRACE((WINPERF_DBG_TRACE_ERROR),
                      (& LoadPerfGuid,
                        __LINE__,
                        LOADPERF_UPDATEEACHLANGUAGE,
                        ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                        lStatus,
                        TRACE_WSTR(pThisLang->LangId),
                        TRACE_WSTR(Counters),
                        NULL));
                SetLastError (lStatus);
                return FALSE;
            }

            // set pointer to location in buffer where new string should be
            //  appended: end of buffer - 1 (second null at end of MULTI_SZ

            pNewName = (LPTSTR)((PBYTE)pNameBuffer + dwBufferSize - sizeof(TCHAR));

            // adjust buffer length to take into account 2nd null from 1st
            // buffer that has been overwritten

            dwCounterSize -= sizeof(TCHAR);

            // read explain text into buffer. Counter names will be stored as
            // a MULTI_SZ string in the format of "###" "Text..."

            dwBufferSize = dwHelpSize;
            lStatus = RegQueryValueEx (
                hKeyThisLang,
                (dwSystemVersion == OLD_VERSION) ? Help : HelpNameBuffer,
                RESERVED,
                &dwValueType,
                (LPVOID)pHelpBuffer,
                &dwBufferSize);

            if (lStatus != ERROR_SUCCESS) {
                MemoryFree (pNameBuffer);
                MemoryFree (pHelpBuffer);

                ReportLoadPerfEvent(
                        EVENTLOG_ERROR_TYPE, // error type
                        (DWORD) LDPRFMSG_UNABLE_READ_HELP_STRINGS, // event,
                        1, lStatus, 0, 0,
                        1, pThisLang->LangId, NULL, NULL);
                TRACE((WINPERF_DBG_TRACE_ERROR),
                      (& LoadPerfGuid,
                        __LINE__,
                        LOADPERF_UPDATEEACHLANGUAGE,
                        ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                        lStatus,
                        TRACE_WSTR(pThisLang->LangId),
                        TRACE_WSTR(Help),
                        NULL));
                SetLastError (lStatus);
                return FALSE;
            }

            // set pointer to location in buffer where new string should be
            //  appended: end of buffer - 1 (second null at end of MULTI_SZ

            pNewHelp = (LPTSTR)((PBYTE)pHelpBuffer + dwBufferSize - sizeof(TCHAR));

            // adjust buffer length to take into account 2nd null from 1st
            // buffer that has been overwritten

            dwHelpSize -= sizeof(TCHAR);

            // append new strings to end of current strings

            memcpy (pNewHelp, pThisLang->HelpBuffer, pThisLang->dwHelpBuffSize);
            memcpy (pNewName, pThisLang->NameBuffer, pThisLang->dwNameBuffSize);

            if (! CheckNameTable(pNameBuffer, pHelpBuffer,
                                 dwLastCounter, dwLastHelp)) {
                MemoryFree(pNameBuffer);
                MemoryFree(pHelpBuffer);
                return FALSE;
            }

            if (dwSystemVersion == OLD_VERSION) {
                // load new strings back to the registry

                lStatus = RegSetValueEx (
                    hKeyThisLang,
                    Counters,
                    RESERVED,
                    REG_MULTI_SZ,
                    (LPBYTE)pNameBuffer,
                    dwCounterSize);

                if (lStatus != ERROR_SUCCESS) {
                    MemoryFree (pNameBuffer);
                    MemoryFree (pHelpBuffer);

                    ReportLoadPerfEvent(
                            EVENTLOG_ERROR_TYPE, // error type
                            (DWORD) LDPRFMSG_UNABLE_UPDATE_COUNTER_STRINGS, // event,
                            1, lStatus, 0, 0,
                            1, pThisLang->LangId, NULL, NULL);
                    TRACE((WINPERF_DBG_TRACE_ERROR),
                          (& LoadPerfGuid,
                            __LINE__,
                        LOADPERF_UPDATEEACHLANGUAGE,
                        ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                        lStatus,
                        TRACE_WSTR(pThisLang->LangId),
                        TRACE_WSTR(Counters),
                        NULL));
                    SetLastError (lStatus);
                    return FALSE;
                }

                lStatus = RegSetValueEx (
                    hKeyThisLang,
                    Help,
                    RESERVED,
                    REG_MULTI_SZ,
                    (LPBYTE)pHelpBuffer,
                    dwHelpSize);

                if (lStatus != ERROR_SUCCESS) {
                    MemoryFree (pNameBuffer);
                    MemoryFree (pHelpBuffer);

                    ReportLoadPerfEvent(
                            EVENTLOG_ERROR_TYPE, // error type
                            (DWORD) LDPRFMSG_UNABLE_UPDATE_HELP_STRINGS, // event,
                            1, lStatus, 0, 0,
                            1, pThisLang->LangId, NULL, NULL);
                    TRACE((WINPERF_DBG_TRACE_ERROR),
                          (& LoadPerfGuid,
                            __LINE__,
                        LOADPERF_UPDATEEACHLANGUAGE,
                        ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                        lStatus,
                        TRACE_WSTR(pThisLang->LangId),
                        TRACE_WSTR(Help),
                        NULL));
                    SetLastError (lStatus);
                    return FALSE;
                }
            } else {
                // write to the file thru PerfLib
                dwBufferSize = dwCounterSize;
                lStatus = RegQueryValueEx (
                    hKeyThisLang,
                    AddCounterNameBuffer,
                    RESERVED,
                    &dwValueType,
                    (LPVOID)pNameBuffer,
                    &dwBufferSize);
                if (lStatus != ERROR_SUCCESS) {
                    MemoryFree(pNameBuffer);
                    MemoryFree(pHelpBuffer);
                    ReportLoadPerfEvent(
                            EVENTLOG_ERROR_TYPE, // error type
                            (DWORD) LDPRFMSG_UNABLE_UPDATE_COUNTER_STRINGS, // event,
                            1, lStatus, 0, 0,
                            1, pThisLang->LangId, NULL, NULL);
                    TRACE((WINPERF_DBG_TRACE_ERROR),
                          (& LoadPerfGuid,
                            __LINE__,
                        LOADPERF_UPDATEEACHLANGUAGE,
                        ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                        lStatus,
                        TRACE_WSTR(pThisLang->LangId),
                        TRACE_WSTR(AddCounterNameBuffer),
                        NULL));
                    SetLastError (lStatus);
                    return FALSE;
                }
                dwBufferSize = dwHelpSize;
                lStatus = RegQueryValueEx (
                    hKeyThisLang,
                    AddHelpNameBuffer,
                    RESERVED,
                    &dwValueType,
                    (LPVOID)pHelpBuffer,
                    &dwBufferSize);
                if (lStatus != ERROR_SUCCESS) {
                    MemoryFree (pNameBuffer);
                    MemoryFree (pHelpBuffer);
                    ReportLoadPerfEvent(
                            EVENTLOG_ERROR_TYPE, // error type
                            (DWORD) LDPRFMSG_UNABLE_UPDATE_HELP_STRINGS, // event,
                            1, lStatus, 0, 0,
                            1, pThisLang->LangId, NULL, NULL);
                    TRACE((WINPERF_DBG_TRACE_ERROR),
                          (& LoadPerfGuid,
                            __LINE__,
                        LOADPERF_UPDATEEACHLANGUAGE,
                        ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                        lStatus,
                        TRACE_WSTR(pThisLang->LangId),
                        TRACE_WSTR(AddHelpNameBuffer),
                        NULL));
                    SetLastError (lStatus);
                    return FALSE;
                }
            }
            MemoryFree(pNameBuffer);
            MemoryFree(pHelpBuffer);

            if (dwSystemVersion == OLD_VERSION) {
                RegCloseKey (hKeyThisLang);
            }
        } else {
            OUTPUT_MESSAGE (GetFormatResource (LC_UNABLEOPENLANG), szThisLang);
        }
    }

    return TRUE;
}

BOOL
UpdateRegistry (
    LPTSTR                  lpIniFile,
    LPTSTR                  lpDriverName,
    PLANGUAGE_LIST_ELEMENT  pFirstLang,
    PSYMBOL_TABLE_ENTRY     pFirstSymbol,
    PPERFOBJECT_LOOKUP      plObjectGuidTable,
    LPDWORD                 pdwObjectGuidTableSize,
    LPDWORD                 pdwIndexValues

)
/*++

UpdateRegistry

    - checks, and if not busy, sets the "busy" key in the registry
    - Reads in the text and help definitions from the .ini file
    - Reads in the current contents of the HELP and COUNTER names
    - Builds a sorted MULTI_SZ struct containing the new definitions
    - Appends the new MULTI_SZ to the current as read from the registry
    - loads the new MULTI_SZ string into the registry
    - updates the keys in the driver's entry and Perflib's entry in the
        registry (e.g. first, last, etc)
    - deletes the DisablePerformanceCounters value if it's present in 
        order to re-enable the perf counter DLL
    - clears the "busy" key

Arguments

    lpIniFile
    pathname to .ini file conatining definitions

    hKeyMachine
    handle to HKEY_LOCAL_MACHINE in registry on system to
    update counters for.

    lpDriverName
    Name of device driver to load counters for

    pFirstLang
    pointer to first element in language structure list

    pFirstSymbol
    pointer to first element in symbol definition list


Return Value

    TRUE if registry updated successfully
    FALSE if registry not updated
    (This routine will print an error message to stdout if an error
    is encountered).

--*/
{

    HKEY    hDriverPerf = NULL;
    HKEY    hPerflib = NULL;

    LPTSTR  lpDriverKeyPath;
    HKEY    hKeyMachine = NULL;

    DWORD   dwType;
    DWORD   dwSize;

    DWORD   dwFirstDriverCounter;
    DWORD   dwFirstDriverHelp;
    DWORD   dwLastDriverCounter;
    DWORD   dwLastPerflibCounter;
    DWORD   dwLastPerflibHelp;
    DWORD   dwPerflibBaseIndex;
    DWORD   dwLastCounter;
    DWORD   dwLastHelp;

    BOOL    bStatus;
    LONG    lStatus;

    HANDLE  hFileMapping = NULL;
    DWORD             MapFileSize;
    SECURITY_ATTRIBUTES  SecAttr;
    DWORD             *lpData;

    TCHAR   lpszObjectList[MAX_PATH];

    LPTSTR  mszLangList = NULL;

    LONG_PTR    TempFileHandle = -1;
    DWORD dwWaitStatus;
    HANDLE  hLocalMutex = NULL;

    if (LoadPerfGrabMutex() == FALSE) {
        return FALSE;
    }

    bStatus = FALSE;
    SetLastError (ERROR_SUCCESS);

    // allocate temporary buffers
    lpDriverKeyPath = MemoryAllocate (MAX_PATH * sizeof(TCHAR));

    if (!lpDriverKeyPath) {
        SetLastError (ERROR_OUTOFMEMORY);
        goto UpdateRegExit;
    }

    // build driver key path string

    lstrcpy (lpDriverKeyPath, DriverPathRoot);
    lstrcat (lpDriverKeyPath, Slash);
    lstrcat (lpDriverKeyPath, lpDriverName);
    lstrcat (lpDriverKeyPath, Slash);
    lstrcat (lpDriverKeyPath, Performance);

    // check if we need to connect to remote machine
    if (ComputerName[0]) {
        lStatus = !ERROR_SUCCESS;
        try {
            lStatus = RegConnectRegistry (
            (LPTSTR)ComputerName,
            HKEY_LOCAL_MACHINE,
            &hKeyMachine);
        } finally {
            if (lStatus != ERROR_SUCCESS) {
                SetLastError (lStatus);
                hKeyMachine = NULL;
                OUTPUT_MESSAGE (GetFormatResource(LC_CONNECT_PROBLEM),
                    ComputerName, lStatus);
                bStatus = FALSE;
            }
        }
        if (lStatus != ERROR_SUCCESS)
            goto UpdateRegExit;
    } else {
        hKeyMachine = HKEY_LOCAL_MACHINE;
    }

    // open keys to registry
    // open key to driver's performance key

    lStatus = RegOpenKeyEx (
        hKeyMachine,
        lpDriverKeyPath,
        RESERVED,
        KEY_WRITE | KEY_READ,
        &hDriverPerf);

    if (lStatus != ERROR_SUCCESS) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_UNABLE_OPEN_KEY, // event,
                1, lStatus, 0, 0,
                1, (LPWSTR) lpDriverKeyPath, NULL, NULL);
        OUTPUT_MESSAGE (GetFormatResource(LC_ERR_OPEN_DRIVERPERF1), lpDriverKeyPath);
        OUTPUT_MESSAGE (GetFormatResource(LC_ERR_OPEN_DRIVERPERF2), lStatus);
        SetLastError (lStatus);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_UPDATEREGISTRY,
                ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                lStatus,
                TRACE_WSTR(lpIniFile),
                TRACE_WSTR(lpDriverName),
                NULL));
        goto UpdateRegExit;
    }

    // open key to perflib's "root" key

    lStatus = RegOpenKeyEx (
        hKeyMachine,
        NamesKey,
        RESERVED,
        KEY_WRITE | KEY_READ,
        &hPerflib);

    if (lStatus != ERROR_SUCCESS) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_UNABLE_OPEN_KEY, // event,
                1, lStatus, 0, 0,
                1, (LPWSTR) NamesKey, NULL, NULL);
        OUTPUT_MESSAGE (GetFormatResource(LC_ERR_OPEN_PERFLIB), lStatus);
        SetLastError (lStatus);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_UPDATEREGISTRY,
                ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                lStatus,
                TRACE_WSTR(lpDriverName),
                TRACE_WSTR(NamesKey),
                NULL));
        goto UpdateRegExit;
    }

    // get "LastCounter" values from PERFLIB

    dwType = 0;
    dwLastPerflibCounter = 0;
    dwSize = sizeof (dwLastPerflibCounter);
    lStatus = RegQueryValueEx (
        hPerflib,
        LastCounter,
        RESERVED,
        &dwType,
        (LPBYTE)&dwLastPerflibCounter,
        &dwSize);

    if (lStatus != ERROR_SUCCESS) {
        // this request should always succeed, if not then worse things
        // will happen later on, so quit now and avoid the trouble.
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_UNABLE_QUERY_VALUE, // event,
                1, lStatus, 0, 0,
                2, (LPWSTR) LastCounter, (LPWSTR) NamesKey, NULL);
        OUTPUT_MESSAGE (GetFormatResource (LC_ERR_READLASTPERFLIB), lStatus);
        SetLastError (lStatus);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_UPDATEREGISTRY,
                ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                lStatus,
                TRACE_WSTR(NamesKey),
                TRACE_WSTR(LastCounter),
                NULL));
        goto UpdateRegExit;
    }

    // get "LastHelp" value now

    dwType = 0;
    dwLastPerflibHelp = 0;
    dwSize = sizeof (dwLastPerflibHelp);
    lStatus = RegQueryValueEx (
        hPerflib,
        LastHelp,
        RESERVED,
        &dwType,
        (LPBYTE)&dwLastPerflibHelp,
        &dwSize);

    if (lStatus != ERROR_SUCCESS) {
        // this request should always succeed, if not then worse things
        // will happen later on, so quit now and avoid the trouble.
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_UNABLE_QUERY_VALUE, // event,
                1, lStatus, 0, 0,
                2, (LPWSTR) LastHelp, (LPWSTR) NamesKey, NULL);
        OUTPUT_MESSAGE (GetFormatResource (LC_ERR_READLASTPERFLIB), lStatus);
        SetLastError (lStatus);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_UPDATEREGISTRY,
                ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                lStatus,
                TRACE_WSTR(NamesKey),
                TRACE_WSTR(LastHelp),
                NULL));
        goto UpdateRegExit;
    }

    // get "Base Index" value now
    dwType = 0;
    dwPerflibBaseIndex = 0;
    dwSize = sizeof (dwPerflibBaseIndex);
    lStatus = RegQueryValueEx (
        hPerflib,
        szBaseIndex,
        RESERVED,
        &dwType,
        (LPBYTE) & dwPerflibBaseIndex,
        &dwSize);

    if (lStatus != ERROR_SUCCESS) {
        // this request should always succeed, if not then worse things
        // will happen later on, so quit now and avoid the trouble.
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_UNABLE_QUERY_VALUE, // event,
                1, lStatus, 0, 0,
                2, (LPWSTR) szBaseIndex, (LPWSTR) NamesKey, NULL);
        OUTPUT_MESSAGE (GetFormatResource (LC_ERR_READLASTPERFLIB), lStatus);
        SetLastError (lStatus);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_UPDATEREGISTRY,
                ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                lStatus,
                TRACE_WSTR(NamesKey),
                TRACE_WSTR(szBaseIndex),
                NULL));
        goto UpdateRegExit;
    }

    // get "Version" value now

    dwType = 0;
    dwSize = sizeof (dwSystemVersion);
    lStatus = RegQueryValueEx (
        hPerflib,
        VersionStr,
        RESERVED,
        &dwType,
        (LPBYTE)&dwSystemVersion,
        &dwSize);

    if (lStatus != ERROR_SUCCESS) {
        dwSystemVersion = OLD_VERSION;
    }


    // set the hPerfData to HKEY_PERFORMANCE_DATA for new version
    // if remote machine, then need to connect to it.
    if (dwSystemVersion != OLD_VERSION) {
        hPerfData = HKEY_PERFORMANCE_DATA;
        lStatus = !ERROR_SUCCESS;
        if (ComputerName[0]) {
        // have to do it the old faction way
        dwSystemVersion = OLD_VERSION;
        lStatus = ERROR_SUCCESS;
        }
    } // NEW_VERSION

    // see if this driver's counter names have already been installed
    // by checking to see if LastCounter's value is less than Perflib's
    // Last Counter

    dwType = 0;
    dwLastDriverCounter = 0;
    dwSize = sizeof (dwLastDriverCounter);
    lStatus = RegQueryValueEx (
        hDriverPerf,
        LastCounter,
        RESERVED,
        &dwType,
        (LPBYTE)&dwLastDriverCounter,
        &dwSize);

    if (lStatus == ERROR_SUCCESS) {
        // if key found, then compare with perflib value and exit this
        // procedure if the driver's last counter is <= to perflib's last
        //
        // if key not found, then continue with installation
        // on the assumption that the counters have not been installed

        if (dwLastDriverCounter <= dwLastPerflibCounter) {
            OUTPUT_MESSAGE (GetFormatResource(LC_ERR_ALREADY_IN), lpDriverName);
            SetLastError (ERROR_ALREADY_EXISTS);
            goto UpdateRegExit;
        }
    }

    // create the file mapping
    SecAttr.nLength = sizeof (SecAttr);
    SecAttr.bInheritHandle = TRUE;
    SecAttr.lpSecurityDescriptor = NULL;

    MapFileSize = sizeof(DWORD);
    hFileMapping = CreateFileMapping ((HANDLE)TempFileHandle, &SecAttr,
       PAGE_READWRITE, (DWORD_PTR)0, MapFileSize, (LPCTSTR)MapFileName);
    if (hFileMapping) {
        lpData = MapViewOfFile (hFileMapping,
            FILE_MAP_ALL_ACCESS, 0L, 0L, 0L);
        if (lpData) {
            *lpData = 1L;
            UnmapViewOfFile (lpData);
        }
    }

    TRACE((WINPERF_DBG_TRACE_INFO),
          (& LoadPerfGuid,
            __LINE__,
            LOADPERF_UPDATEREGISTRY,
            ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
            lStatus,
            TRACE_WSTR(lpIniFile),
            TRACE_WSTR(lpDriverName),
            TRACE_DWORD(dwLastPerflibCounter),
            TRACE_DWORD(dwLastPerflibHelp),
            TRACE_DWORD(dwPerflibBaseIndex),
            TRACE_DWORD(dwSystemVersion),
            NULL));

    // set the "busy" indicator under the PERFLIB key

    dwSize = lstrlen(lpDriverName) * sizeof (TCHAR);
    lStatus = RegSetValueEx (
        hPerflib,
        Busy,
        RESERVED,
        REG_SZ,
        (LPBYTE)lpDriverName,
        dwSize);

    if (lStatus != ERROR_SUCCESS) {
        OUTPUT_MESSAGE (GetFormatResource (LC_ERR_UNABLESETBUSY), lStatus);
        SetLastError (lStatus);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_UPDATEREGISTRY,
                ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                lStatus,
                TRACE_WSTR(NamesKey),
                TRACE_WSTR(Busy),
                NULL));
        goto UpdateRegExit;
    }

    // increment (by 2) the last counters so they point to the first
    // unused index after the existing names and then
    // set the first driver counters

    dwLastCounter        = dwLastPerflibCounter;
    dwLastHelp           = dwLastPerflibHelp;
    dwFirstDriverCounter = dwLastPerflibCounter + 2;
    dwFirstDriverHelp    = dwLastPerflibHelp + 2;

    if (   (dwPerflibBaseIndex < PERFLIB_BASE_INDEX)
        || (dwFirstDriverCounter < dwPerflibBaseIndex)
        || (dwFirstDriverHelp < dwPerflibBaseIndex)) {
        // potential CounterIndex/HelpIndex overlap with Base counters,
        //
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_REGISTRY_BASEINDEX_CORRUPT, // event,
                3, dwPerflibBaseIndex, dwFirstDriverCounter, dwFirstDriverHelp,
                0, NULL, NULL, NULL);
        lStatus = ERROR_BADKEY;
        SetLastError(lStatus);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_UPDATEREGISTRY,
                ARG_DEF(ARG_TYPE_WSTR, 1),
                lStatus,
                TRACE_WSTR(lpDriverName),
                TRACE_DWORD(dwPerflibBaseIndex),
                TRACE_DWORD(dwFirstDriverCounter),
                TRACE_DWORD(dwFirstDriverHelp),
                NULL));
        goto UpdateRegExit;
    }

    // load .INI file definitions into language tables

    if (!LoadLanguageLists (lpIniFile, dwFirstDriverCounter , dwFirstDriverHelp,
        pFirstSymbol, pFirstLang)) {
        // error message is displayed by LoadLanguageLists so just abort
        // error is in GetLastError already
        goto UpdateRegExit;
    }

    if (!CreateObjectList (lpIniFile, dwFirstDriverCounter, pFirstSymbol,
        lpszObjectList, plObjectGuidTable, pdwObjectGuidTableSize)) {
        // error message is displayed by CreateObjectList so just abort
        // error is in GetLastError already

        goto UpdateRegExit;
    }

    // all the symbols and definitions have been loaded into internal
    // tables. so now they need to be sorted and merged into a multiSZ string
    // this routine also updates the "last" counters

    if (!SortLanguageTables (pFirstLang, &dwLastCounter, &dwLastHelp)) {
        OUTPUT_MESSAGE (GetFormatResource(LC_UNABLESORTTABLES), GetLastError());
        goto UpdateRegExit;
    }

    if (   (dwLastCounter < dwLastPerflibCounter)
        || (dwLastHelp < dwLastPerflibHelp)) {
        // potential CounterIndex/HelpIndex overlap with Base counters,
        //
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_REGISTRY_BASEINDEX_CORRUPT, // event,
                3, dwPerflibBaseIndex, dwLastCounter, dwLastHelp,
                0, NULL, NULL, NULL);
        lStatus = ERROR_BADKEY;
        SetLastError(lStatus);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_UPDATEREGISTRY,
                ARG_DEF(ARG_TYPE_WSTR, 1),
                lStatus,
                TRACE_WSTR(lpDriverName),
                TRACE_DWORD(dwLastPerflibCounter),
                TRACE_DWORD(dwLastPerflibHelp),
                TRACE_DWORD(dwLastCounter),
                TRACE_DWORD(dwLastHelp),
                NULL));
        goto UpdateRegExit;
    }

    // get the list of installed languages on this machine
    if (!GetInstalledLanguageList (hPerflib, &mszLangList)) {
        OUTPUT_MESSAGE (GetFormatResource(LC_ERR_UPDATELANG), GetLastError());
        goto UpdateRegExit;
    }

    if (!UpdateEachLanguage (hPerflib, mszLangList, dwLastCounter, dwLastHelp, pFirstLang)) {
        OUTPUT_MESSAGE (GetFormatResource(LC_ERR_UPDATELANG), GetLastError());
        goto UpdateRegExit;
    }

    dwLastPerflibCounter = dwLastCounter;
    dwLastPerflibHelp    = dwLastHelp;

    TRACE((WINPERF_DBG_TRACE_INFO),
          (& LoadPerfGuid,
            __LINE__,
            LOADPERF_UPDATEREGISTRY,
            ARG_DEF(ARG_TYPE_WSTR, 1),
            lStatus,
            TRACE_WSTR(lpDriverName),
            TRACE_DWORD(dwFirstDriverCounter),
            TRACE_DWORD(dwFirstDriverHelp),
            TRACE_DWORD(dwLastPerflibCounter),
            TRACE_DWORD(dwLastPerflibHelp),
            NULL));

    if (dwLastCounter < dwFirstDriverCounter) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_CORRUPT_INDEX_RANGE, // event,
                2, dwFirstDriverCounter, dwLastCounter, 0,
                2, (LPWSTR) Counters, (LPWSTR) lpDriverKeyPath, NULL);
        goto UpdateRegExit;
    }
    if (dwLastHelp < dwFirstDriverHelp) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_CORRUPT_INDEX_RANGE, // event,
                2, dwFirstDriverHelp, dwLastHelp, 0,
                2, (LPWSTR) Help, (LPWSTR) lpDriverKeyPath, NULL);
        goto UpdateRegExit;
    }

    // update last counters for driver and perflib

    // perflib...

    lStatus = RegSetValueEx(
        hPerflib,
        LastCounter,
        RESERVED,
        REG_DWORD,
        (LPBYTE)&dwLastPerflibCounter,
        sizeof(DWORD));
    if (lStatus != ERROR_SUCCESS) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_UNABLE_UPDATE_VALUE, // event,
                2, lStatus, dwLastPerflibCounter, 0,
                2, (LPWSTR) LastCounter, (LPWSTR) NamesKey, NULL);
        OUTPUT_MESSAGE (GetFormatResource (LC_UNABLESETVALUE),
            LastCounter, szPerflib);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_UPDATEREGISTRY,
                ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                lStatus,
                TRACE_WSTR(NamesKey),
                TRACE_WSTR(LastCounter),
                TRACE_DWORD(dwLastPerflibCounter),
                NULL));
    }

    lStatus = RegSetValueEx(
                hPerflib,
                LastHelp,
                RESERVED,
                REG_DWORD,
                (LPBYTE)&dwLastPerflibHelp,
                sizeof(DWORD));
    if (lStatus != ERROR_SUCCESS) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_UNABLE_UPDATE_VALUE, // event,
                2, lStatus, dwLastPerflibHelp, 0,
                2, (LPWSTR) LastHelp, (LPWSTR) NamesKey, NULL);
        OUTPUT_MESSAGE (GetFormatResource (LC_UNABLESETVALUE),
            LastHelp, szPerflib);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_UPDATEREGISTRY,
                ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                lStatus,
                TRACE_WSTR(NamesKey),
                TRACE_WSTR(LastHelp),
                TRACE_DWORD(dwLastPerflibHelp),
                NULL));
    }

    // and the driver

    lStatus = RegSetValueEx(
        hDriverPerf,
        LastCounter,
        RESERVED,
        REG_DWORD,
        (LPBYTE)&dwLastPerflibCounter,
        sizeof(DWORD));
    if (lStatus != ERROR_SUCCESS) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_UNABLE_UPDATE_VALUE, // event,
                2, lStatus, dwLastPerflibCounter, 0,
                2, (LPWSTR) LastCounter, (LPWSTR) lpDriverKeyPath, NULL);
        OUTPUT_MESSAGE (GetFormatResource (LC_UNABLESETVALUE),
            LastCounter, lpDriverName);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_UPDATEREGISTRY,
                ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                lStatus,
                TRACE_WSTR(lpDriverName),
                TRACE_WSTR(LastCounter),
                TRACE_DWORD(dwLastPerflibCounter),
                NULL));
    }

    lStatus = RegSetValueEx(
        hDriverPerf,
        LastHelp,
        RESERVED,
        REG_DWORD,
        (LPBYTE)&dwLastPerflibHelp,
        sizeof(DWORD));
    if (lStatus != ERROR_SUCCESS) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_UNABLE_UPDATE_VALUE, // event,
                2, lStatus, dwLastPerflibHelp, 0,
                2, (LPWSTR) LastHelp, (LPWSTR) lpDriverKeyPath, NULL);
        OUTPUT_MESSAGE (GetFormatResource (LC_UNABLESETVALUE),
            LastHelp, lpDriverName);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_UPDATEREGISTRY,
                ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                lStatus,
                TRACE_WSTR(lpDriverName),
                TRACE_WSTR(LastHelp),
                TRACE_DWORD(dwLastPerflibHelp),
                NULL));
    }

    lStatus = RegSetValueEx(
        hDriverPerf,
        cszFirstCounter,
        RESERVED,
        REG_DWORD,
        (LPBYTE)&dwFirstDriverCounter,
        sizeof(DWORD));
    if (lStatus != ERROR_SUCCESS) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_UNABLE_UPDATE_VALUE, // event,
                2, lStatus, dwFirstDriverCounter, 0,
                2, (LPWSTR) cszFirstCounter, (LPWSTR) lpDriverKeyPath, NULL);
        OUTPUT_MESSAGE (GetFormatResource (LC_UNABLESETVALUE),
            cszFirstCounter, lpDriverName);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_UPDATEREGISTRY,
                ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                lStatus,
                TRACE_WSTR(lpDriverName),
                TRACE_WSTR(cszFirstCounter),
                TRACE_DWORD(dwFirstDriverCounter),
                NULL));
    }

    lStatus = RegSetValueEx(
        hDriverPerf,
        FirstHelp,
        RESERVED,
        REG_DWORD,
        (LPBYTE)&dwFirstDriverHelp,
        sizeof(DWORD));
    if (lStatus != ERROR_SUCCESS) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_UNABLE_UPDATE_VALUE, // event,
                2, lStatus, dwFirstDriverHelp, 0,
                2, (LPWSTR) FirstHelp, (LPWSTR) lpDriverKeyPath, NULL);
        OUTPUT_MESSAGE (GetFormatResource (LC_UNABLESETVALUE),
            FirstHelp, lpDriverName);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_UPDATEREGISTRY,
                ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                lStatus,
                TRACE_WSTR(lpDriverName),
                TRACE_WSTR(FirstHelp),
                TRACE_DWORD(dwFirstDriverHelp),
                NULL));
    }

    if (*lpszObjectList != 0) {
        lStatus = RegSetValueEx(
            hDriverPerf,
            szObjectList,
            RESERVED,
            REG_SZ,
            (LPBYTE)&lpszObjectList,
            (lstrlen(lpszObjectList) + 1) * sizeof (TCHAR));

        if (lStatus != ERROR_SUCCESS) {
            ReportLoadPerfEvent(
                    EVENTLOG_ERROR_TYPE, // error type
                    (DWORD) LDPRFMSG_UNABLE_UPDATE_VALUE, // event,
                    2, lStatus, 0, 0,
                    2, (LPWSTR) szObjectList, (LPWSTR) lpDriverKeyPath, NULL);
            OUTPUT_MESSAGE (GetFormatResource (LC_UNABLESETVALUE),
            szObjectList, lpDriverName);
            TRACE((WINPERF_DBG_TRACE_ERROR),
                  (& LoadPerfGuid,
                    __LINE__,
                    LOADPERF_UPDATEREGISTRY,
                    ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                    lStatus,
                    TRACE_WSTR(lpDriverName),
                    TRACE_WSTR(szObjectList),
                    NULL));
        }
    }

    bStatus = TRUE;

    pdwIndexValues[0] = dwFirstDriverCounter;   // first Counter
    pdwIndexValues[1] = dwLastPerflibCounter;   // last Counter
    pdwIndexValues[2] = dwFirstDriverHelp;      // first Help
    pdwIndexValues[3] = dwLastPerflibHelp;      // last Help

    // remove "DisablePerformanceCounter" value so perf counters are re-enabled.
    lStatus = RegDeleteValue (hDriverPerf, szDisablePerformanceCounters);

    // MemoryFree temporary buffers
UpdateRegExit:
    // clear busy flag

    lStatus = RegDeleteValue (
        hPerflib,
        Busy);

    ReleaseMutex(hLoadPerfMutex);

    // MemoryFree temporary buffers

    // free any guid string buffers here
    // TODO: add this code

    if (lpDriverKeyPath) MemoryFree (lpDriverKeyPath);
    if (hDriverPerf)     RegCloseKey (hDriverPerf);
    if (hPerflib)        RegCloseKey (hPerflib);

    if (mszLangList != NULL) MemoryFree(mszLangList);

    if (hFileMapping) {
        CloseHandle (hFileMapping);
    }

    if (hPerfData && hPerfData != HKEY_PERFORMANCE_DATA) {
        RegCloseKey (hPerfData);
    }

    if (hKeyMachine && hKeyMachine != HKEY_LOCAL_MACHINE) {
        RegCloseKey (hKeyMachine) ;
    }

    return bStatus;
}

DWORD
GetMofFileFromIni (
    LPCWSTR    lpIniFile,
    LPWSTR    MofFilename
)
{
    DWORD   dwRetSize;
    DWORD   dwReturn = ERROR_SUCCESS;

    if (MofFilename) {
        dwRetSize = GetPrivateProfileString (
            szInfo,         // info section
            szMofFileName,  // Mof Filename value
            szNotFound,     // default value
            MofFilename,    // output buffer
            MAX_PATH,        // buffer size
            lpIniFile);        // ini file to read

        if ((lstrcmpi(MofFilename, szNotFound)) != 0) {
            // name found
            TRACE((WINPERF_DBG_TRACE_INFO),
                  (& LoadPerfGuid,
                    __LINE__,
                    LOADPERF_GETMOFFILEFROMINI,
                    ARG_DEF(ARG_TYPE_WSTR, 1),
                    dwReturn,
                    TRACE_WSTR(MofFilename),
                    NULL));
        } else {
            // name not found, default returned so return NULL string
            MofFilename[0] = 0;
            dwReturn = ERROR_FILE_NOT_FOUND;
        }
    } else {
        dwReturn = ERROR_INVALID_PARAMETER;
    }

    if (dwReturn != ERROR_SUCCESS) {
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_GETMOFFILEFROMINI, 0, dwReturn, NULL));
    }

    return dwReturn;
}

DWORD
OpenCounterAndBuildMofFile (
    LPCWSTR                lpDriverName,
    LPCWSTR                MofFilename,
    PPERFOBJECT_LOOKUP  plObjectGuidTable,
    DWORD               dwObjectGuidTableSize
)
{
    DWORD    dwType;
    DWORD    dwSize;
    HKEY    hKeyMachine = NULL;
    HKEY    hDriverPerf = NULL;
    LONG    lStatus = ERROR_SUCCESS;
    LPWSTR    *lpCounterText;
    LPWSTR    *lpDisplayText = NULL; // Localized name strings array
    DWORD    dwLastElement;
    WCHAR    lpDriverKeyPath[MAX_PATH];
    WCHAR    wszPerfLibraryName[MAX_PATH];
    WCHAR    wszLibraryExpPath[MAX_PATH];
    WCHAR    szProviderName[MAX_PATH];
    DWORD    dwProviderNameSize;
    HANDLE    hPerfLibrary = NULL;
    CHAR    szOpenProcName[MAX_PATH];
    PM_OPEN_PROC    *pOpenProc = NULL;
    CHAR    szCollectProcName[MAX_PATH];
    PM_COLLECT_PROC    *pCollectProc = NULL;
    CHAR    szCloseProcName[MAX_PATH];
    PM_CLOSE_PROC    *pCloseProc = NULL;
    LPBYTE    pPerfBuffer = NULL;
    LPBYTE    pPerfBufferArg;
    DWORD    dwPerfBufferSize;
    DWORD    dwThisObject;
    DWORD    dwThisCounterDef;
    WCHAR    szMofBuffer[8192*2];
    DWORD    dwMofBufferSize;
    HANDLE    hMofFile;
    PERF_COUNTER_DLL_INFO    PcDllInfo;
    DWORD   dwGuidIdx;
    WCHAR    wszLocalLang[8];

    PPERF_OBJECT_TYPE    pThisObject;
    PPERF_COUNTER_DEFINITION    pThisCounterDef;

    // get registry key for this object
    // build driver key path string

    lstrcpy (lpDriverKeyPath, DriverPathRoot);
    lstrcat (lpDriverKeyPath, Slash);
    lstrcat (lpDriverKeyPath, lpDriverName);
    lstrcat (lpDriverKeyPath, Slash);
    lstrcat (lpDriverKeyPath, Performance);

    // check if we need to connect to remote machine

    if (ComputerName[0]) {
        lStatus = !ERROR_SUCCESS;
        try {
            lStatus = RegConnectRegistry (
            (LPTSTR)ComputerName,
            HKEY_LOCAL_MACHINE,
            &hKeyMachine);
        } finally {
            if (lStatus != ERROR_SUCCESS) {
                hKeyMachine = NULL;
            }
        }
    } else {
        hKeyMachine = HKEY_LOCAL_MACHINE;
    }

    // bail out here if unable to open the registry
    if (hKeyMachine == NULL) return lStatus;

    // get ENGLISH string list
    lpCounterText = BuildNameTable (
        hKeyMachine,
        (LPWSTR)L"009",        // Use english as the language entry for WBEM
        &dwLastElement);

    if (lpCounterText == NULL) {
        goto MakeMofErrorExit;
    }

    // get LOCAL strings
    // get locale and convert to string first
    memset (wszLocalLang, 0, sizeof(wszLocalLang));
    swprintf (wszLocalLang,  (LPCWSTR)L"0%2.2x", (GetSystemDefaultLCID() & 0x000000FF));

    lpDisplayText = BuildNameTable (
        hKeyMachine,
        (LPWSTR)wszLocalLang,        // Use local language for strings
        &dwLastElement);

    if (lpDisplayText == NULL) {

        lpDisplayText = BuildNameTable (
                hKeyMachine,
                (LPWSTR)L"009",        // then Use english
                &dwLastElement);

        if (lpDisplayText == NULL) {
            goto MakeMofErrorExit;
        }
    }

    // open key to driver's performance key

    lStatus = RegOpenKeyEx (
        hKeyMachine,
        lpDriverKeyPath,
        RESERVED,
        KEY_WRITE | KEY_READ,
        &hDriverPerf);

    if (lStatus != ERROR_SUCCESS) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_UNABLE_OPEN_KEY, // event,
                1, lStatus, 0, 0,
                1, (LPWSTR) lpDriverKeyPath, NULL, NULL);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_OPENCOUNTERANDBUILDMOFFILE,
                ARG_DEF(ARG_TYPE_WSTR, 1),
                lStatus,
                TRACE_WSTR(lpDriverName),
                NULL));
        goto MakeMofErrorExit;
    }

    // get library name
    dwType = 0;
    dwSize = sizeof(wszPerfLibraryName);
    lStatus = RegQueryValueExW (hDriverPerf,
                        cszLibrary,
                        NULL,
                        &dwType,
                        (LPBYTE)&wszPerfLibraryName[0],
                        &dwSize);

    if (lStatus == ERROR_SUCCESS) {
        if (dwType == REG_EXPAND_SZ) {
            // expand any environment vars
            dwSize = ExpandEnvironmentStringsW(
                wszPerfLibraryName,
                wszLibraryExpPath,
                MAX_PATH);

            if ((dwSize > MAX_PATH) || (dwSize == 0)) {
                lStatus = ERROR_INVALID_DLL;
            }
        } else if (dwType == REG_SZ) {
            // look for dll and save full file Path
            dwSize = SearchPathW (
                NULL,   // use standard system search path
                wszPerfLibraryName,
                NULL,
                MAX_PATH,
                wszLibraryExpPath,
                NULL);

            if ((dwSize > MAX_PATH) || (dwSize == 0)) {
                lStatus = ERROR_INVALID_DLL;
            }
        } else {
            lStatus = ERROR_INVALID_DLL;
        }
        if (lStatus != ERROR_SUCCESS) {
            TRACE((WINPERF_DBG_TRACE_ERROR),
                  (& LoadPerfGuid,
                    __LINE__,
                    LOADPERF_OPENCOUNTERANDBUILDMOFFILE,
                    ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                    lStatus,
                    TRACE_WSTR(lpDriverName),
                    TRACE_WSTR(wszPerfLibraryName),
                    NULL));
        }
    }
    else {
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_OPENCOUNTERANDBUILDMOFFILE,
                ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                lStatus,
                TRACE_WSTR(lpDriverName),
                TRACE_WSTR(cszLibrary),
                NULL));
    }

    // unable to continue if error
    if (lStatus != ERROR_SUCCESS) {
        goto MakeMofErrorExit;
    }

    // get open procedure name
    dwType = 0;
    dwSize = sizeof(szOpenProcName);
    lStatus = RegQueryValueExA (hDriverPerf,
                        caszOpen,
                        NULL,
                        &dwType,
                        (LPBYTE)&szOpenProcName[0],
                        &dwSize);
    // unable to continue if error
    if (lStatus != ERROR_SUCCESS) {
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_OPENCOUNTERANDBUILDMOFFILE,
                ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_STR, 2),
                lStatus,
                TRACE_WSTR(lpDriverName),
                TRACE_STR(caszOpen),
                NULL));
        goto MakeMofErrorExit;
    }

    // get collect procedure name
    dwType = 0;
    dwSize = sizeof(szCollectProcName);
    lStatus = RegQueryValueExA (hDriverPerf,
                        caszCollect,
                        NULL,
                        &dwType,
                        (LPBYTE)&szCollectProcName[0],
                        &dwSize);
    // unable to continue if error
    if (lStatus != ERROR_SUCCESS) {
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_OPENCOUNTERANDBUILDMOFFILE,
                ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_STR, 2),
                lStatus,
                TRACE_WSTR(lpDriverName),
                TRACE_STR(caszCollect),
                NULL));
        goto MakeMofErrorExit;
    }

    // get close procedure name
    dwType = 0;
    dwSize = sizeof(szCloseProcName);
    lStatus = RegQueryValueExA (hDriverPerf,
                        caszClose,
                        NULL,
                        &dwType,
                        (LPBYTE)&szCloseProcName[0],
                        &dwSize);
    // unable to continue if error
    if (lStatus != ERROR_SUCCESS) {
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_OPENCOUNTERANDBUILDMOFFILE,
                ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_STR, 2),
                lStatus,
                TRACE_WSTR(lpDriverName),
                TRACE_STR(caszClose),
                NULL));
        goto MakeMofErrorExit;
    }

    // load perf counter library
    hPerfLibrary = LoadLibraryW (wszPerfLibraryName);
    if (hPerfLibrary == NULL) {
        lStatus = GetLastError();
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_OPENCOUNTERANDBUILDMOFFILE,
                ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                lStatus,
                TRACE_WSTR(lpDriverName),
                TRACE_WSTR(wszPerfLibraryName),
                NULL));
        goto MakeMofErrorExit;
    }

    // get open procedure pointer
    pOpenProc = (PM_OPEN_PROC *) GetProcAddress (
        hPerfLibrary,
        szOpenProcName);

    if (pOpenProc == NULL) {
        lStatus = GetLastError();
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_OPENCOUNTERANDBUILDMOFFILE,
                ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_STR, 2),
                lStatus,
                TRACE_WSTR(lpDriverName),
                TRACE_STR(szOpenProcName),
                NULL));
        goto MakeMofErrorExit;
    }

    // get collect procedure pointer
    pCollectProc = (PM_COLLECT_PROC *) GetProcAddress (
        hPerfLibrary,
        szCollectProcName);

    if (pCollectProc == NULL) {
        lStatus = GetLastError();
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_OPENCOUNTERANDBUILDMOFFILE,
                ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_STR, 2),
                lStatus,
                TRACE_WSTR(lpDriverName),
                TRACE_STR(szCollectProcName),
                NULL));
        goto MakeMofErrorExit;
    }

    // get close procedure pointer
    pCloseProc = (PM_CLOSE_PROC *) GetProcAddress (
        hPerfLibrary,
        szCloseProcName);

    if (pCloseProc == NULL) {
        lStatus = GetLastError();
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_OPENCOUNTERANDBUILDMOFFILE,
                ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_STR, 2),
                lStatus,
                TRACE_WSTR(lpDriverName),
                TRACE_STR(szCloseProcName),
                NULL));
        goto MakeMofErrorExit;
    }

    // call open procedure to initialize the counter
    __try {
        lStatus = (*pOpenProc)((LPWSTR)L"");
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        lStatus = GetExceptionCode();
    }
    // unable to continue if error
    if (lStatus != ERROR_SUCCESS) {
        goto MakeMofErrorExit;
    }

    dwPerfBufferSize = 0;
    // call the collect function to get a buffer
    do {
        // allocate a query buffer to pass to the collect function
        dwPerfBufferSize += 0x8000;
        if (pPerfBuffer == NULL) {
            pPerfBuffer = (LPBYTE) MemoryAllocate (dwPerfBufferSize);
        } else {
            // if buffer is too small, resize and try again
            pPerfBuffer = (LPBYTE) MemoryResize (pPerfBuffer, dwPerfBufferSize);
        }

        if (pPerfBuffer == NULL) {
            goto MakeMofErrorExit;
        }

        dwSize = dwPerfBufferSize;
        dwType = 0; // count of object types
        pPerfBufferArg = pPerfBuffer;
        lStatus = (* pCollectProc) (
            (LPWSTR)L"Global",
            &pPerfBufferArg,
            &dwSize,
            &dwType);

    } while (lStatus == ERROR_MORE_DATA);

    if (lStatus != ERROR_SUCCESS) {
        goto MakeMofErrorExit;
    }

    // create temporary file for writing the MOF to

    hMofFile = CreateFileW (
        MofFilename,
        GENERIC_WRITE,
        0, // no sharing
        NULL, // default security
        CREATE_ALWAYS,    // always start fresh
        FILE_ATTRIBUTE_NORMAL, // nothing special
        NULL); // no template

    if (hMofFile == INVALID_HANDLE_VALUE) {
        // unable to create MOF file
        lStatus = GetLastError();
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_OPENCOUNTERANDBUILDMOFFILE,
                ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                lStatus,
                TRACE_WSTR(lpDriverName),
                TRACE_WSTR(MofFilename),
                NULL));
        goto MakeMofErrorExit;
    }

    lstrcpyW (szProviderName, wszPerfLibraryName);
    dwProviderNameSize = (sizeof(szProviderName) / sizeof(szProviderName[0]));
    dwMofBufferSize = (sizeof(szMofBuffer) / sizeof(szMofBuffer[0]));
    lStatus = GenerateMofHeader (szMofBuffer, (LPTSTR)ComputerName, &dwMofBufferSize);
    if (lStatus == ERROR_SUCCESS) {
        lStatus = WriteWideStringToAnsiFile (hMofFile, szMofBuffer, &dwMofBufferSize);
    }

    PcDllInfo.szWbemProviderName = szProviderName;
    PcDllInfo.szRegistryKey = (LPWSTR)lpDriverName;

    // for each object returned
    pThisObject = (PPERF_OBJECT_TYPE)pPerfBuffer;
    for (dwThisObject = 0; dwThisObject < dwType; dwThisObject++) {
        PcDllInfo.szClassGuid = (LPWSTR)L"";
        // look up class guid string in table passed in
        if (plObjectGuidTable != NULL) {
            dwGuidIdx = 0;
            while (dwGuidIdx < dwObjectGuidTableSize) {
                if (pThisObject->ObjectNameTitleIndex == (DWORD)plObjectGuidTable[dwGuidIdx].PerfObjectId) {
                    PcDllInfo.szClassGuid = plObjectGuidTable[dwGuidIdx].GuidString;
                    break;
                }
                dwGuidIdx++;
            }
        }
        if (PcDllInfo.szClassGuid[0] == 0) {
            // try the standard list
            PcDllInfo.szClassGuid = (LPWSTR)GetPerfObjectGuid (pThisObject->ObjectNameTitleIndex);
        } else {
            // just leave it blank
        }
        //   create WBEM Class object for this perf object
        dwMofBufferSize = (sizeof(szMofBuffer) / sizeof(szMofBuffer[0]));
        lStatus = GenerateMofObject (szMofBuffer, &dwMofBufferSize,
            &PcDllInfo,
            pThisObject, lpCounterText, lpDisplayText, WM_GMO_RAW_DEFINITION);
        if (lStatus == ERROR_SUCCESS) {
            if (lStatus == ERROR_SUCCESS) {
                lStatus = WriteWideStringToAnsiFile (
                    hMofFile, szMofBuffer, &dwMofBufferSize);
            }
            //    for each counter defined in this object
            pThisCounterDef = FirstCounter (pThisObject);
            for (dwThisCounterDef = 0;
                 dwThisCounterDef < pThisObject->NumCounters;
                 dwThisCounterDef++) {
                //        define a WBEM property
                dwMofBufferSize = (sizeof(szMofBuffer) / sizeof(szMofBuffer[0]));
                lStatus = GenerateMofCounter (szMofBuffer, &dwMofBufferSize,
                    pThisCounterDef, lpCounterText,lpDisplayText, WM_GMO_RAW_DEFINITION);
                if (lStatus == ERROR_SUCCESS) {
                    lStatus = WriteWideStringToAnsiFile (
                        hMofFile, szMofBuffer, &dwMofBufferSize);
                }

                pThisCounterDef = NextCounter (pThisCounterDef);
            }
            dwMofBufferSize = (sizeof(szMofBuffer) / sizeof(szMofBuffer[0]));
            lStatus = GenerateMofObjectTail (szMofBuffer, &dwMofBufferSize);
            if (lStatus == ERROR_SUCCESS) {
                lStatus = WriteWideStringToAnsiFile (
                    hMofFile, szMofBuffer, &dwMofBufferSize);
            }
        }

        // end for each object
        pThisObject = NextObject (pThisObject);    
    }

    // write end of file
    SetEndOfFile(hMofFile);
    CloseHandle(hMofFile);
    // call close proc

    lStatus = (* pCloseProc)();

    TRACE((WINPERF_DBG_TRACE_INFO),
          (& LoadPerfGuid,
            __LINE__,
            LOADPERF_OPENCOUNTERANDBUILDMOFFILE,
            ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2) |
                    ARG_DEF(ARG_TYPE_WSTR, 3) | ARG_DEF(ARG_TYPE_STR, 4) |
                    ARG_DEF(ARG_TYPE_STR, 5) | ARG_DEF(ARG_TYPE_STR, 6),
            lStatus,
            TRACE_WSTR(lpDriverName),
            TRACE_WSTR(MofFilename),
            TRACE_WSTR(wszPerfLibraryName),
            TRACE_STR(szOpenProcName),
            TRACE_STR(szCollectProcName),
            TRACE_STR(szCloseProcName),
            NULL));

MakeMofErrorExit:
    // close the registry key if necessary
    if ((hKeyMachine != HKEY_LOCAL_MACHINE) &&
        (hKeyMachine != NULL)) {
        RegCloseKey (hKeyMachine);
    }

    if (hDriverPerf != NULL) RegCloseKey (hDriverPerf);

    if (lpCounterText == NULL) MemoryFree (lpCounterText);
    if (lpDisplayText == NULL) MemoryFree (lpDisplayText);

    // MemoryFree perf counter library
    if (hPerfLibrary != NULL) FreeLibrary (hPerfLibrary);

    // MemoryFree the collection buffer
    if (pPerfBuffer != NULL) MemoryFree (pPerfBuffer);

    // return
    return (DWORD)lStatus;
}

LOADPERF_FUNCTION
InstallPerfDllW (
    IN  LPCWSTR    szComputerName,
    IN    LPCWSTR    lpIniFile,
    IN  ULONG_PTR   dwFlags
)
{
    LPWSTR                lpDriverName = NULL;
    WCHAR                  MofFilename[MAX_PATH];
    PERFOBJECT_LOOKUP      plObjectGuidTable[16];
    DWORD                  dwObjectGuidTableSize;
    DWORD                  dwObjectIndex;
    LANGUAGE_LIST_ELEMENT  LangList;
    PSYMBOL_TABLE_ENTRY    SymbolTable = NULL;
    DWORD                  ErrorCode = ERROR_SUCCESS;
    DWORD                  dwIndexValues[4] = {0,0,0,0};

    WinPerfStartTrace(NULL);

    bQuietMode = (BOOL)((dwFlags & LOADPERF_FLAGS_DISPLAY_USER_MSGS) == 0);
    
    // initialize the object GUID table
    memset (plObjectGuidTable, 0, sizeof (plObjectGuidTable));
    dwObjectGuidTableSize = sizeof (plObjectGuidTable) / sizeof (plObjectGuidTable[0]) ;

    if (szComputerName == NULL) {
        ComputerName[0] = 0;    // use the local computer
    } else {
        if (lstrlenW(szComputerName) < FILE_NAME_BUFFER_SIZE) {
            lstrcpyW (ComputerName, szComputerName);
        } else {
            ErrorCode = ERROR_INVALID_PARAMETER;
        }
    }

    if ((lpIniFile != NULL)  && (ErrorCode == ERROR_SUCCESS)) {
        lpDriverName = MemoryAllocate (MAX_PATH * sizeof (WCHAR));
        if (lpDriverName == NULL) {
            ErrorCode = ERROR_OUTOFMEMORY;
            goto EndOfMain;
        } 

        // valid filename (i.e. file exists)
        // get device driver name

        if (!GetDriverName ((LPWSTR)lpIniFile, &lpDriverName)) {
            OUTPUT_MESSAGE (GetFormatResource(LC_DEVNAME_ERR_1), lpIniFile);
            OUTPUT_MESSAGE (GetFormatResource(LC_DEVNAME_ERR_2));
            ErrorCode = GetLastError();
            goto EndOfMain;
        }

        if (!BuildLanguageTables((LPWSTR)lpIniFile, &LangList)) {
            OUTPUT_MESSAGE (GetFormatResource(LC_LANGLIST_ERR), lpIniFile);
            ErrorCode = GetLastError();
            goto EndOfMain;
        }

        if (!LoadIncludeFile((LPWSTR)lpIniFile, &SymbolTable)) {
            // open errors displayed in routine
            ErrorCode = GetLastError();
            goto EndOfMain;
        }

        if (!UpdateRegistry((LPWSTR) lpIniFile,
                            lpDriverName,
                            & LangList,
                            SymbolTable,
                            plObjectGuidTable,
                            & dwObjectGuidTableSize,
                            (LPDWORD) & dwIndexValues)) {
            ErrorCode = GetLastError();
            goto EndOfMain;
        }

        if (ComputerName[0] == 0) {   // until remote is supported
            LodctrSetSericeAsTrusted(
                    lpIniFile,
                    NULL,
                    lpDriverName);
        }

        // now it's time to load the MOF for WBEM access
        if (!(dwFlags & LOADPERF_FLAGS_LOAD_REGISTRY_ONLY)) {
            // the didn't say not to, so create if necessary and
            // load the MOF into the CIMOM

            // see if there's a mof file in the Ini file (if so, use that)
            ErrorCode = GetMofFileFromIni (lpIniFile, MofFilename);

            if (ErrorCode == ERROR_FILE_NOT_FOUND) {
                WCHAR    wszTempFilename[MAX_PATH];
                MakeTempFileName (lpDriverName, wszTempFilename);
                // otherwise we'll try to make one
                ErrorCode = OpenCounterAndBuildMofFile (
                    lpDriverName, wszTempFilename,
                    plObjectGuidTable,
                    dwObjectGuidTableSize);

                if (ErrorCode == ERROR_SUCCESS) {
                    lstrcpyW (MofFilename, wszTempFilename);
                } else {
                    // report unable to create mof file
                    ReportLoadPerfEvent(
                            EVENTLOG_WARNING_TYPE, // error type
                            (DWORD) LDPRFMSG_NO_MOF_FILE_CREATED, // event,
                            1, ErrorCode, 0, 0,
                            1, (LPWSTR) lpDriverName, NULL, NULL);
                    TRACE((WINPERF_DBG_TRACE_ERROR),
                          (& LoadPerfGuid,
                            __LINE__,
                            LOADPERF_INSTALLPERFDLL,
                            ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                            ErrorCode,
                            TRACE_WSTR(lpDriverName),
                            TRACE_WSTR(wszTempFilename),
                            NULL));
                }
            }

            // now let's load it into the CIMOM
            if (ErrorCode == ERROR_SUCCESS) {
                ErrorCode = LodctrCompileMofFile ( ComputerName, MofFilename );
                if (ErrorCode != ERROR_SUCCESS) {
                    // display error message
                    ReportLoadPerfEvent(
                            EVENTLOG_WARNING_TYPE, // error type
                            (DWORD) LDPRFMSG_NO_MOF_FILE_LOADED, // event,
                            1, ErrorCode, 0, 0,
                            1, (LPWSTR) lpDriverName, NULL, NULL);
                    TRACE((WINPERF_DBG_TRACE_ERROR),
                          (& LoadPerfGuid,
                            __LINE__,
                            LOADPERF_INSTALLPERFDLL,
                            ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                            ErrorCode,
                            TRACE_WSTR(lpDriverName),
                            TRACE_WSTR(MofFilename),
                            NULL));
                }
            }

            // toss the mof if they don't want it
            if ((ErrorCode == ERROR_SUCCESS) &&
                (dwFlags & LOADPERF_FLAGS_DELETE_MOF_ON_EXIT)) {
                // display error message
                ReportLoadPerfEvent(
                        EVENTLOG_WARNING_TYPE, // error type
                        (DWORD) LDPRFMSG_CANT_DELETE_MOF, // event,
                        0, 0, 0, 0,
                        1, (LPWSTR) lpDriverName, NULL, NULL);
            }
            // reset the error code to success since all worked before the
            // MOF operations.
            ErrorCode = ERROR_SUCCESS;
        }
        // signal WMI with this change, ignore WMI return error.
        SignalWmiWithNewData (WMI_LODCTR_EVENT);
    } else {
        if (*lpIniFile) {
            OUTPUT_MESSAGE (GetFormatResource(LC_NO_INIFILE), lpIniFile);
            ErrorCode = ERROR_OPEN_FAILED;
        } else {
            //Incorrect Command Format
            // display command line usage
            if (!bQuietMode) {
                DisplayCommandHelp(LC_FIRST_CMD_HELP, LC_LAST_CMD_HELP);
            }
            ErrorCode = ERROR_INVALID_PARAMETER;
        }
    }

EndOfMain:
    if (ErrorCode != ERROR_SUCCESS) {
        if (ErrorCode == ERROR_ALREADY_EXISTS) {
            ReportLoadPerfEvent(
                    EVENTLOG_INFORMATION_TYPE, // error type
                    (DWORD) LDPRFMSG_ALREADY_EXIST, // event,
                    0, 0, 0, 0,
                    1, (LPWSTR) lpDriverName, NULL, NULL);
            ErrorCode = ERROR_SUCCESS;
        }
        else {
            ReportLoadPerfEvent(
                    EVENTLOG_ERROR_TYPE, // error type
                    (DWORD) LDPRFMSG_LOAD_FAILURE, // event,
                    1, ErrorCode, 0, 0,
                    1, (LPWSTR) lpDriverName, NULL, NULL);
        }
    } else {
        // log success message
        ReportLoadPerfEvent(
                EVENTLOG_INFORMATION_TYPE,  // error type
                (DWORD) LDPRFMSG_LOAD_SUCCESS, // event,
                0, 0, 0, 0,
                1, (LPWSTR) lpDriverName, NULL, NULL);
    }
    TRACE((WINPERF_DBG_TRACE_INFO),
          (& LoadPerfGuid,
            __LINE__,
            LOADPERF_INSTALLPERFDLL,
            ARG_DEF(ARG_TYPE_WSTR, 1),
            ErrorCode,
            TRACE_WSTR(lpDriverName),
            NULL));

    for (dwObjectIndex = 0; dwObjectIndex < dwObjectGuidTableSize; dwObjectIndex++) {
        if (plObjectGuidTable[dwObjectIndex].GuidString != NULL) {
            MemoryFree (plObjectGuidTable[dwObjectIndex].GuidString);
        }
    }
    if (lpDriverName) MemoryFree (lpDriverName);

    return (ErrorCode);
}

LOADPERF_FUNCTION
InstallPerfDllA (
    IN  LPCSTR    szComputerName,
    IN  LPCSTR    szIniFile,
    IN  ULONG_PTR dwFlags
)
{
    LPWSTR    lpWideComputerName = NULL;
    LPWSTR  lpWideFileName = NULL;
    DWORD   dwStrLen;
    DWORD   lReturn;

    if (szIniFile != NULL) {
        //length of string including terminator
        dwStrLen = lstrlenA(szIniFile) + 1;

        lpWideFileName = MemoryAllocate (dwStrLen * sizeof(WCHAR));
        if (lpWideFileName != NULL) {
            mbstowcs (lpWideFileName, szIniFile, dwStrLen);
            lReturn = ERROR_SUCCESS;
        } else {
            lReturn = ERROR_OUTOFMEMORY;
        }
    } else {
        lReturn = ERROR_INVALID_PARAMETER;
    }

    if (lReturn == ERROR_SUCCESS) {
        if (szComputerName != NULL) {
            dwStrLen = lstrlenA (szComputerName) + 1;
            lpWideComputerName = (LPWSTR)MemoryAllocate (dwStrLen * sizeof(WCHAR));
            if (lpWideComputerName != NULL) {
                mbstowcs (lpWideComputerName, szComputerName, dwStrLen);
                lReturn = ERROR_SUCCESS;
            } else {
                lReturn = ERROR_OUTOFMEMORY;
            }
        } else {
            lpWideComputerName = NULL;
            lReturn = ERROR_SUCCESS;
        }

    }

    if (lReturn == ERROR_SUCCESS) {
        lReturn = InstallPerfDllW (
            lpWideComputerName,
            lpWideFileName,
            dwFlags);
        MemoryFree (lpWideFileName);
        MemoryFree (lpWideComputerName);
    }

    return lReturn;
}

LOADPERF_FUNCTION
LoadPerfCounterTextStringsW (
    IN  LPWSTR  lpCommandLine,
    IN  BOOL    bQuietModeArg
)
/*++

LoadPerfCounterTexStringsW

    loads the perf counter strings into the registry and updates
    the perf counter text registry values

Arguments

    command line string in the following format:

    "/?"                    displays the usage text
    "file.ini"              loads the perf strings found in file.ini
    "\\machine file.ini"    loads the perf strings found onto machine


ReturnValue

    0 (ERROR_SUCCESS) if command was processed
    Non-Zero if command error was detected.

--*/
{
    LPWSTR  lpIniFile;

    DWORD                        ErrorCode = ERROR_SUCCESS;
    ULONG_PTR                    dwFlags = 0;

    WinPerfStartTrace(NULL);

    dwFlags |= (bQuietModeArg ? 0 : LOADPERF_FLAGS_DISPLAY_USER_MSGS);

    lpIniFile = MemoryAllocate (MAX_PATH * sizeof (TCHAR));

    if (!lpIniFile) {
        return (ERROR_OUTOFMEMORY);
    }
    *lpIniFile = 0;

    // init last error value
    SetLastError (ERROR_SUCCESS);

    // read command line to determine what to do
    if (GetFileFromCommandLine (lpCommandLine, &lpIniFile, &dwFlags)) {
        dwFlags |= LOADPERF_FLAGS_LOAD_REGISTRY_ONLY; // don't do mof's even if they want
        // call installation function
        ErrorCode = InstallPerfDllW (ComputerName, lpIniFile, dwFlags);
    } else {
        //Incorrect Command Format
        // display command line usage
        if (!bQuietModeArg) {
            DisplayCommandHelp(LC_FIRST_CMD_HELP, LC_LAST_CMD_HELP);
        }
        ErrorCode = ERROR_INVALID_PARAMETER;
    }

    if (lpIniFile) MemoryFree (lpIniFile);

    return (ErrorCode);
}

LOADPERF_FUNCTION
LoadPerfCounterTextStringsA (
    IN  LPSTR   lpAnsiCommandLine,
    IN  BOOL    bQuietModeArg
)
{
    LPWSTR  lpWideCommandLine;
    DWORD   dwStrLen;
    DWORD    lReturn;

    if (lpAnsiCommandLine != NULL) {
        //length of string including terminator
        dwStrLen = lstrlenA(lpAnsiCommandLine) + 1;

        lpWideCommandLine = MemoryAllocate (dwStrLen * sizeof(WCHAR));
        if (lpWideCommandLine != NULL) {
            mbstowcs (lpWideCommandLine, lpAnsiCommandLine, dwStrLen);
            lReturn = LoadPerfCounterTextStringsW (lpWideCommandLine,
            bQuietModeArg );
            MemoryFree (lpWideCommandLine);
        } else {
            lReturn = GetLastError();
        }
    } else {
        lReturn = ERROR_INVALID_PARAMETER;
    }
    return lReturn;
}

LOADPERF_FUNCTION
LoadMofFromInstalledServiceW (
    IN  LPCWSTR    szServiceName,     // service to create mof for
    IN  LPCWSTR    szMofFilenameArg,  // name of file to create
    IN  ULONG_PTR  dwFlags            // flags
)
{
    DWORD ErrorCode;
    WCHAR    wszTempFilename[MAX_PATH];

    WinPerfStartTrace(NULL);

    if (szServiceName == NULL) {
        ErrorCode = ERROR_INVALID_PARAMETER;
    } else {
        if (szMofFilenameArg == NULL) {
            MakeTempFileName (szServiceName, wszTempFilename);
        } else {
            lstrcpyW (wszTempFilename, szMofFilenameArg);
        }
    
        // otherwise we'll try to make one
        ErrorCode = OpenCounterAndBuildMofFile (
                       szServiceName, wszTempFilename,
                    NULL, 0L);

        TRACE((WINPERF_DBG_TRACE_INFO),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_LOADMOFFROMINSTALLEDSERVICE,
                ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                ErrorCode,
                TRACE_WSTR(szServiceName),
                TRACE_WSTR(wszTempFilename),
                NULL));
    
        // now let's load it into the CIMOM        
        if (ErrorCode == ERROR_SUCCESS) {
            ErrorCode = SignalWmiWithNewData (WMI_LODCTR_EVENT);
        } else {
            ReportLoadPerfEvent(
                    EVENTLOG_WARNING_TYPE,        // error type
                    (DWORD) LDPRFMSG_NO_MOF_FILE_CREATED, // event,
                    1, ErrorCode, 0, 0,
                    1, (LPWSTR) szServiceName, NULL, NULL);
        }

        // if everything is going well and the caller
        // wants to delete the  file created to contain the MOF
        // then delete it
        if (ErrorCode == ERROR_SUCCESS) {
            if ((dwFlags & LOADPERF_FLAGS_DELETE_MOF_ON_EXIT) && (szMofFilenameArg == NULL)) {
                if (!DeleteFile(wszTempFilename)) {
                    ErrorCode = GetLastError();
                }
            }
        } else {
            ReportLoadPerfEvent(
                    EVENTLOG_WARNING_TYPE,        // error type
                    (DWORD) LDPRFMSG_NO_MOF_FILE_LOADED, // event,
                    1, ErrorCode, 0, 0,
                    1, (LPWSTR) szServiceName, NULL, NULL);
            TRACE((WINPERF_DBG_TRACE_WARNING),
                  (& LoadPerfGuid,
                    __LINE__,
                    LOADPERF_LOADMOFFROMINSTALLEDSERVICE,
                    ARG_DEF(ARG_TYPE_WSTR, 1),
                    ErrorCode,
                    TRACE_WSTR(szServiceName),
                    NULL));
        }
    }

    return (ErrorCode);
}

LOADPERF_FUNCTION
LoadMofFromInstalledServiceA (
    IN  LPCSTR    szServiceName,  // service to create mof for
    IN     LPCSTR    szMofFilenameArg,  // name of file to create
    IN  ULONG_PTR   dwFlags     // delete mof on exit
)
{
    DWORD   ErrorCode = ERROR_SUCCESS;
    LPWSTR  wszServiceName;
    DWORD   dwServiceNameLen;
    LPWSTR  wszMofFilename;
    DWORD   dwMofFilenameLen;

    if (szServiceName == NULL) {
        ErrorCode = ERROR_INVALID_PARAMETER;
    } else {
        dwServiceNameLen = lstrlenA(szServiceName) + 1;
        wszServiceName = MemoryAllocate (
            dwServiceNameLen * sizeof(WCHAR));
        if (wszServiceName == NULL) {
            ErrorCode = ERROR_OUTOFMEMORY;
        } else {
            mbstowcs (wszServiceName, szServiceName, dwServiceNameLen);
            if (szMofFilenameArg != NULL) {
                dwMofFilenameLen = lstrlenA(szMofFilenameArg) + 1;
                wszMofFilename = MemoryAllocate (dwMofFilenameLen);
                if (wszMofFilename != NULL) {
                    mbstowcs (wszMofFilename, szMofFilenameArg, dwMofFilenameLen);
                } else {
                    ErrorCode = ERROR_OUTOFMEMORY;
                }
            } else {
                wszMofFilename = NULL;
            }
            if (ErrorCode == ERROR_SUCCESS) {
                ErrorCode = LoadMofFromInstalledServiceW (
                    wszServiceName,
                    wszMofFilename,
                    dwFlags);
            }
            if (wszMofFilename != NULL) MemoryFree (wszMofFilename);
            MemoryFree (wszServiceName);
        }
    }
    return ErrorCode;
}

LOADPERF_FUNCTION
UpdatePerfNameFilesX (
    IN  LPCWSTR     szNewCtrFilePath,   // data file with new base counter strings
    IN  LPCWSTR     szNewHlpFilePath,   // data file with new base counter strings
    IN     LPWSTR      szLanguageID,       // Lang ID to update
    IN  ULONG_PTR   dwFlags             // flags
)
{
    DWORD   dwReturn = ERROR_SUCCESS;

    LPWSTR  szCtrNameIn = NULL;
    LPWSTR  szHlpNameIn = NULL;
    LPWSTR  szNewCtrStrings = NULL;
    LPWSTR  szNewHlpStrings = NULL;
    LPWSTR  szNewCtrMSZ = NULL;
    LPWSTR  szNewHlpMSZ = NULL;
    WCHAR   szSystemPath[MAX_PATH];
    DWORD   dwLength;
    LPWSTR  *pszNewNameTable = NULL;
    LPWSTR  *pszOldNameTable = NULL;
    LPWSTR  lpThisName;
    LPWSTR  szThisCtrString = NULL;
    LPWSTR  szThisHlpString = NULL;
    WCHAR   szLangSection[MAX_PATH];
    DWORD   dwLastEntry = 0;
    DWORD   dwStringSize;
    DWORD   dwHlpFileSize = 0, dwCtrFileSize = 0 ;
    DWORD   dwThisCounter;
    DWORD   dwSize;
    DWORD   dwLastBaseValue = 0;
    DWORD   dwType;
    DWORD   dwIndex;
    HANDLE  hCtrFileIn = INVALID_HANDLE_VALUE;
    HANDLE  hCtrFileMap = NULL;
    HANDLE  hHlpFileIn = INVALID_HANDLE_VALUE;
    HANDLE  hHlpFileMap = NULL;
    HKEY    hKeyPerflib;

    WinPerfStartTrace(NULL);

    if (szNewCtrFilePath == NULL) dwReturn = ERROR_INVALID_PARAMETER;
    if ((szNewHlpFilePath == NULL) && !(dwFlags & LODCTR_UPNF_RESTORE)) dwReturn = ERROR_INVALID_PARAMETER;
    if (szLanguageID == NULL) dwReturn = ERROR_INVALID_PARAMETER;

    if (dwReturn == ERROR_SUCCESS) {
        TRACE((WINPERF_DBG_TRACE_INFO),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_UPDATEPERFNAMEFILES,
                ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                ERROR_SUCCESS,
                TRACE_WSTR(szNewCtrFilePath),
                TRACE_WSTR(szLanguageID),
                NULL));
    }

    if ((dwReturn == ERROR_SUCCESS) && !(dwFlags & LODCTR_UPNF_RESTORE)) {
        // save the original files, unless it's a restoration
        MakeBackupCopyOfLanguageFiles (szLanguageID);
        dwLength = ExpandEnvironmentStringsW ((LPCWSTR)L"%windir%\\system32",
            (LPWSTR)szSystemPath, (sizeof(szSystemPath) / sizeof(szSystemPath[0])));
    } else {
        dwLength = 0;
        SetLastError (dwReturn);
    }

    if (dwLength > 0) {
        // create input filenames
        szCtrNameIn = MemoryAllocate (MAX_PATH * 2 * sizeof (WCHAR));
        szHlpNameIn = MemoryAllocate (MAX_PATH * 2 * sizeof (WCHAR));

        if ((szCtrNameIn != NULL) && (szHlpNameIn != NULL)) {
            ExpandEnvironmentStrings (szNewCtrFilePath, szCtrNameIn, (MAX_PATH * 2));
            ExpandEnvironmentStrings (szNewHlpFilePath, szHlpNameIn, (MAX_PATH * 2));
        } else {
            dwReturn = ERROR_OUTOFMEMORY;
        }

        if (dwReturn == ERROR_SUCCESS) {
            // open and map new files
            hCtrFileIn = CreateFile (
                szCtrNameIn, GENERIC_READ,
                FILE_SHARE_READ, NULL, OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL, NULL);
            if (hCtrFileIn != INVALID_HANDLE_VALUE) {
                // map file
                dwCtrFileSize = GetFileSize(hCtrFileIn, NULL);
                if (dwCtrFileSize == 0xFFFFFFFF){
                    dwReturn =GetLastError();
                }

                hCtrFileMap = CreateFileMapping (
                    hCtrFileIn, NULL, PAGE_READONLY, 0, 0, NULL);
                if (hCtrFileMap != NULL) {
                    szNewCtrStrings = (LPWSTR)MapViewOfFileEx (
                        hCtrFileMap, FILE_MAP_READ, 0, 0, 0, NULL);
                    if (szNewCtrStrings == NULL) {
                        dwReturn = GetLastError();
                    }
                } else {
                    dwReturn = GetLastError();
                }
            } else {
                dwReturn = GetLastError();
            }
        } else {
            dwReturn = GetLastError();
        }

        if (dwReturn == ERROR_SUCCESS) {
            // open and map new files
            hHlpFileIn = CreateFile (
                szHlpNameIn, GENERIC_READ,
                FILE_SHARE_READ, NULL, OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL, NULL);
            if (hHlpFileIn != INVALID_HANDLE_VALUE) {
                // map file
                dwHlpFileSize = GetFileSize (hHlpFileIn, NULL);
                if (dwHlpFileSize == 0xFFFFFFFF){
                    dwReturn =GetLastError();
                }
                hHlpFileMap = CreateFileMapping (
                    hHlpFileIn, NULL, PAGE_READONLY, 0, 0, NULL);
                if (hHlpFileMap != NULL) {
                    szNewHlpStrings = (LPWSTR)MapViewOfFileEx (
                        hHlpFileMap, FILE_MAP_READ, 0, 0, 0, NULL);
                    if (szNewHlpStrings == NULL) {
                        dwReturn = GetLastError();
                    }
                } else {
                    dwReturn = GetLastError();
                }
            } else {
                dwReturn = GetLastError();
            }
        } else {
            dwReturn = GetLastError();
        }
    } else if (dwFlags & LODCTR_UPNF_RESTORE) {
        szCtrNameIn = MemoryAllocate (MAX_PATH * 2 * sizeof (WCHAR));

        if (szCtrNameIn != NULL) {
            dwLength = ExpandEnvironmentStringsW (szNewCtrFilePath,
                szCtrNameIn, (sizeof(szSystemPath) / sizeof(szSystemPath[0])));

            dwLastEntry = GetPrivateProfileIntW (
                (LPCWSTR)L"Perflib",
                (LPCWSTR)L"Last Help",
                -1,
                szCtrNameIn);
            if (dwLastEntry != (DWORD)-1) {
                // get the input file size
                hCtrFileIn = CreateFile (
                    szCtrNameIn, GENERIC_READ,
                    FILE_SHARE_READ, NULL, OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL, NULL);
                if (hCtrFileIn != INVALID_HANDLE_VALUE) {
                    // map file
                    dwCtrFileSize = GetFileSize (hCtrFileIn, NULL);
                } else {
                    dwCtrFileSize = 64 * 1024;  // assign 64k if unable to read it
                }
                // load new values from ini file
                szNewCtrStrings = (LPWSTR)MemoryAllocate (dwCtrFileSize * sizeof(WCHAR));
                if (szNewCtrStrings) {
                    lstrcpyW (szLangSection, (LPCWSTR)L"Perfstrings_");
                    lstrcatW (szLangSection, szLanguageID);
                    dwSize = GetPrivateProfileSectionW (
                        szLangSection,
                        szNewCtrStrings,
                        dwCtrFileSize,
                        szCtrNameIn);
                    if (dwSize == 0) {
                        dwReturn = ERROR_FILE_INVALID;
                    } else {
                        // set file sizes
                        dwHlpFileSize = 0;
                        dwCtrFileSize = (dwSize+2) * sizeof(WCHAR);
                    }
               } else {
                    dwReturn = ERROR_OUTOFMEMORY;
                }
            } else {
                // unable to open input file or file is invalid
                dwReturn = ERROR_FILE_INVALID;
            }
        } else {
            dwReturn = ERROR_OUTOFMEMORY;
        }
    }

    if ((dwReturn == ERROR_SUCCESS) && (!(dwFlags & LODCTR_UPNF_RESTORE))) {
        // build name table of current strings
        pszOldNameTable = BuildNameTable (
            HKEY_LOCAL_MACHINE,
            szLanguageID,
            &dwLastEntry);
        if (pszOldNameTable == NULL) {
            dwReturn = GetLastError();
        }
    }

    if (dwReturn == ERROR_SUCCESS) {
        // build name table of new strings
        pszNewNameTable = (LPWSTR *)MemoryAllocate(
            (dwLastEntry + 2) * sizeof(LPWSTR));    // allow for index offset
        if (pszNewNameTable != NULL) {
            for (lpThisName = szNewCtrStrings;
                 *lpThisName;
                 lpThisName += (lstrlen(lpThisName)+1) ) {

                // first string should be an integer (in decimal unicode digits)

                dwThisCounter = wcstoul (lpThisName, NULL, 10);
                if (dwThisCounter == 0) {
                    continue;  // bad entry, try next
                }

                // point to corresponding counter name

                if (dwFlags & LODCTR_UPNF_RESTORE) {
                    // point to string that follows the "=" char
                    lpThisName = wcschr (lpThisName, L'=');
                    if (lpThisName != NULL) {
                        lpThisName++;
                    } else {
                        continue;
                    }
                } else {
                    // string is next in MSZ
                    lpThisName += (lstrlen(lpThisName)+1);
                }

                // and load array element;

                pszNewNameTable[dwThisCounter] = lpThisName;
            }

            if (!(dwFlags & LODCTR_UPNF_RESTORE)) {
                for (lpThisName = szNewHlpStrings;
                     *lpThisName;
                     lpThisName += (lstrlen(lpThisName)+1) ) {

                    // first string should be an integer (in decimal unicode digits)

                    dwThisCounter = wcstoul (lpThisName, NULL, 10);
                    if (dwThisCounter == 0) {
                        continue;  // bad entry, try next
                    }

                    // point to corresponding counter name

                    lpThisName += (lstrlen(lpThisName)+1);

                    // and load array element;

                    pszNewNameTable[dwThisCounter] = lpThisName;
                }
            }

            // allocate string buffers for the resulting string
            // we want to make sure there's plenty of room so we'll make it
            // the size of the input file + the current buffer

            dwStringSize = dwHlpFileSize;
            dwStringSize += dwCtrFileSize;
            dwStringSize += MemorySize(pszOldNameTable);

            szNewCtrMSZ = MemoryAllocate (dwStringSize);
            szNewHlpMSZ = MemoryAllocate (dwStringSize);

            if ((szNewCtrMSZ == NULL) || (szNewHlpMSZ == NULL)) {
                dwReturn = ERROR_OUTOFMEMORY;
            }
        } else {
            dwReturn = ERROR_OUTOFMEMORY;
        }
    }

    if (dwReturn == ERROR_SUCCESS) {
        // write new strings into registry
        dwReturn = RegOpenKeyEx (
            HKEY_LOCAL_MACHINE,
            NamesKey,
            RESERVED,
            KEY_READ,
            &hKeyPerflib);
        dwSize = sizeof (dwLastBaseValue);
        dwLastBaseValue = 0;
        if (dwReturn == ERROR_SUCCESS) {
            dwReturn = RegQueryValueEx (
                hKeyPerflib,
                szBaseIndex,
                RESERVED,
                &dwType,
                (LPBYTE)&dwLastBaseValue,
                &dwSize);

            if (dwLastBaseValue == 0) {
                dwReturn = ERROR_BADDB;
            }
            TRACE((WINPERF_DBG_TRACE_INFO),
                  (& LoadPerfGuid,
                    __LINE__,
                    LOADPERF_UPDATEPERFNAMEFILES,
                    ARG_DEF(ARG_TYPE_WSTR, 1),
                    dwReturn,
                    TRACE_WSTR(szBaseIndex),
                    TRACE_DWORD(dwLastBaseValue),
                    NULL));

            RegCloseKey (hKeyPerflib);
        }
    }
    else {
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_UPDATEPERFNAMEFILES,
                ARG_DEF(ARG_TYPE_WSTR, 1),
                dwReturn,
                TRACE_WSTR(NamesKey),
                NULL));
    }

    if (dwReturn == ERROR_SUCCESS) {
        DWORD   dwLoopLimit;
        // the strings should be mapped by now
        // pszNewNameTable contains the new strings from the
        // source path and pszOldNameTable contains the strings
        // from the original system. The merge will consist of
        // taking all base values from the new table and the
        // extended values from the old table.
        dwIndex =1;
        szThisCtrString = szNewCtrMSZ;
        szThisHlpString = szNewHlpMSZ;

        // index 1 is a special case and belongs in the counter string
        // after that even numbers (starting w/ #2) go into the counter string
        // and odd numbers (starting w/ #3) go into the help string

        assert (pszNewNameTable[dwIndex] != NULL);

        szThisCtrString += swprintf (szThisCtrString,
            (LPCWSTR)L"%d", dwIndex) + 1;

        szThisCtrString += swprintf (szThisCtrString,
            (LPCWSTR)L"%s", pszNewNameTable[dwIndex]) + 1;

        dwIndex++;
        assert (dwIndex == 2);

        if (dwFlags & LODCTR_UPNF_RESTORE) {
            // restore ALL strings from the input file only if this
            // is a restoration
            dwLoopLimit = dwLastEntry;
        } else {
            // only update the system counters from the input file
            dwLoopLimit = dwLastBaseValue;
        }

        TRACE((WINPERF_DBG_TRACE_INFO),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_UPDATEPERFNAMEFILES,
                0,
                ERROR_SUCCESS,
                TRACE_DWORD(dwLastEntry),
                TRACE_DWORD(dwLastBaseValue),
                NULL));

        for (/*dwIndex from above*/; dwIndex <= dwLoopLimit; dwIndex++) {
            if (pszNewNameTable[dwIndex] != NULL) {
                TRACE((WINPERF_DBG_TRACE_INFO),
                      (& LoadPerfGuid,
                        __LINE__,
                        LOADPERF_UPDATEPERFNAMEFILES,
                        ARG_DEF(ARG_TYPE_WSTR, 1),
                        ERROR_SUCCESS,
                        TRACE_WSTR(pszNewNameTable[dwIndex]),
                        TRACE_DWORD(dwIndex),
                        NULL));
                if (dwIndex & 0x01) {
                    // then it's a help string
                    szThisHlpString += swprintf (szThisHlpString,
                        (LPCWSTR)L"%d", dwIndex) + 1;

                    szThisHlpString += swprintf (szThisHlpString,
                        (LPCWSTR)L"%s", pszNewNameTable[dwIndex]) + 1;
                } else {
                    // it's a counter string
                    szThisCtrString += swprintf (szThisCtrString,
                        (LPCWSTR)L"%d", dwIndex) + 1;

                    szThisCtrString += swprintf (szThisCtrString,
                        (LPCWSTR)L"%s", pszNewNameTable[dwIndex]) + 1;
                }
            } // else just skip it
        }
        for (/*dwIndex from last run */;dwIndex <= dwLastEntry; dwIndex++) {
            if (pszOldNameTable[dwIndex] != NULL) {
                TRACE((WINPERF_DBG_TRACE_INFO),
                      (& LoadPerfGuid,
                        __LINE__,
                        LOADPERF_UPDATEPERFNAMEFILES,
                        ARG_DEF(ARG_TYPE_WSTR, 1),
                        ERROR_SUCCESS,
                        TRACE_WSTR(pszOldNameTable[dwIndex]),
                        TRACE_DWORD(dwIndex),
                        NULL));
               if (dwIndex & 0x01) {
                    // then it's a help string
                    szThisHlpString += swprintf (szThisHlpString,
                        (LPCWSTR)L"%d", dwIndex) + 1;

                    szThisHlpString += swprintf (szThisHlpString,
                        (LPCWSTR)L"%s", pszOldNameTable[dwIndex]) + 1;
                } else {
                    // it's a counter string
                    szThisCtrString += swprintf (szThisCtrString,
                        (LPCWSTR)L"%d", dwIndex) + 1;

                    szThisCtrString += swprintf (szThisCtrString,
                        (LPCWSTR)L"%s", pszOldNameTable[dwIndex]) + 1;
                }
            } // else just skip it
        }
        // terminate the MSZ
        *szThisCtrString++ = 0;
        *szThisHlpString++ = 0;
    }

    // close mapped memory sections:
    if (szNewCtrStrings != NULL) UnmapViewOfFile(szNewCtrStrings);
    if (hCtrFileMap != NULL)     CloseHandle(hCtrFileMap);
    if (hCtrFileIn != NULL)      CloseHandle(hCtrFileIn);
    if (szNewHlpStrings != NULL) UnmapViewOfFile(szNewHlpStrings);
    if (hHlpFileMap != NULL)     CloseHandle(hHlpFileMap);
    if (hHlpFileIn != NULL)      CloseHandle(hHlpFileIn);

    if (dwReturn == ERROR_SUCCESS) {
        // write new values to registry
        LONG        lStatus;
        WCHAR       AddCounterNameBuffer[20];
        WCHAR       AddHelpNameBuffer[20];

        lstrcpyW(AddCounterNameBuffer, AddCounterNameStr);
        lstrcatW(AddCounterNameBuffer, szLanguageID);
        lstrcpyW(AddHelpNameBuffer,    AddHelpNameStr);
        lstrcatW(AddHelpNameBuffer,    szLanguageID);

        // because these are perf counter strings, RegQueryValueEx
        // is used instead of RegSetValueEx as one might expect.

        dwSize = (DWORD)((DWORD_PTR)szThisCtrString - (DWORD_PTR)szNewCtrMSZ);
        lStatus = RegQueryValueExW (
            HKEY_PERFORMANCE_DATA,
            AddCounterNameBuffer,
            RESERVED,
            &dwType,
            (LPVOID)szNewCtrMSZ,
            &dwSize);
        if (lStatus != ERROR_SUCCESS) {
            dwReturn = (DWORD)lStatus;
            TRACE((WINPERF_DBG_TRACE_ERROR),
                  (& LoadPerfGuid,
                    __LINE__,
                    LOADPERF_UPDATEPERFNAMEFILES,
                    ARG_DEF(ARG_TYPE_WSTR, 1),
                    lStatus,
                    TRACE_WSTR(AddCounterNameBuffer),
                    TRACE_DWORD(dwSize),
                    NULL));
        }

        dwSize = (DWORD)((DWORD_PTR)szThisHlpString - (DWORD_PTR)szNewHlpMSZ);
        lStatus = RegQueryValueExW (
            HKEY_PERFORMANCE_DATA,
            AddHelpNameBuffer,
            RESERVED,
            &dwType,
            (LPVOID)szNewHlpMSZ,
            &dwSize);
        if (lStatus != ERROR_SUCCESS) {
            dwReturn = (DWORD)lStatus;
            TRACE((WINPERF_DBG_TRACE_ERROR),
                  (& LoadPerfGuid,
                    __LINE__,
                    LOADPERF_UPDATEPERFNAMEFILES,
                    ARG_DEF(ARG_TYPE_WSTR, 1),
                    lStatus,
                    TRACE_WSTR(AddHelpNameBuffer),
                    TRACE_DWORD(dwSize),
                    NULL));
        }
    }

    if (szCtrNameIn != NULL) MemoryFree (szCtrNameIn);
    if (szHlpNameIn != NULL) MemoryFree (szHlpNameIn);
    if (pszNewNameTable != NULL) MemoryFree (pszNewNameTable);
    if (pszOldNameTable != NULL) MemoryFree (pszOldNameTable);
    if (szNewCtrMSZ != NULL) MemoryFree (szNewCtrMSZ);
    if (szNewHlpMSZ != NULL) MemoryFree (szNewHlpMSZ);

    return dwReturn;
}

// exported version of the above function
LOADPERF_FUNCTION
UpdatePerfNameFilesW (
    IN  LPCWSTR     szNewCtrFilePath,   // data file with new base counter strings
    IN  LPCWSTR     szNewHlpFilePath,   // data file with new base counter strings
    IN     LPWSTR      szLanguageID,       // Lang ID to update
    IN  ULONG_PTR   dwFlags             // flags
)
{
volatile    DWORD dwStatus;

    dwStatus = UpdatePerfNameFilesX (
        szNewCtrFilePath,   // data file with new base counter strings
        szNewHlpFilePath,   // data file with new base counter strings
        szLanguageID,       // Lang ID to update
        dwFlags);             // flags

    return dwStatus;
}

LOADPERF_FUNCTION
UpdatePerfNameFilesA (
    IN  LPCSTR      szNewCtrFilePath, // data file with new base counter strings
    IN  LPCSTR      szNewHlpFilePath, // data file with new base counter strings
    IN     LPSTR       szLanguageID,  // Lang ID to update
    IN  ULONG_PTR   dwFlags     // flags
)
{
    DWORD   dwError = ERROR_SUCCESS;
    LPWSTR  wszNewCtrFilePath = NULL;
    LPWSTR  wszNewHlpFilePath = NULL;
    LPWSTR  wszLanguageID = NULL;
    DWORD   dwLength;

    if (szNewCtrFilePath != NULL) {
        dwLength = lstrlenA (szNewCtrFilePath);
        dwLength += 1; //add term null
        wszNewCtrFilePath = MemoryAllocate (dwLength * sizeof(WCHAR));
        if (wszNewCtrFilePath != NULL) {
            mbstowcs (wszNewCtrFilePath, szNewCtrFilePath, dwLength);
        }
    } else {
        dwError = ERROR_INVALID_PARAMETER;
    }

    if (szNewHlpFilePath != NULL) {
        dwLength = lstrlenA (szNewHlpFilePath);
        dwLength += 1; //add term null
        wszNewHlpFilePath = MemoryAllocate (dwLength * sizeof(WCHAR));
        if (wszNewHlpFilePath != NULL) {
            mbstowcs (wszNewHlpFilePath, szNewHlpFilePath, dwLength);
        }
    } else {
        // this parameter can only be NULL if this flag bit is set.
        if (!(dwFlags & LODCTR_UPNF_RESTORE)) {
            dwError = ERROR_INVALID_PARAMETER;
        } else {
            wszNewHlpFilePath = NULL;
        }
    }

    if (szLanguageID != NULL) {
        dwLength = lstrlenA (szLanguageID);
        dwLength += 1; //add term null
        wszLanguageID= MemoryAllocate (dwLength * sizeof(WCHAR));
        if (wszLanguageID != NULL) {
            mbstowcs (wszLanguageID, szLanguageID, dwLength);
        }
    } else {
        dwError = ERROR_INVALID_PARAMETER;
    }

    if (dwError == ERROR_SUCCESS) {
        dwError = UpdatePerfNameFilesX (
                        wszNewCtrFilePath,
                        wszNewHlpFilePath,
                        wszLanguageID,
                        dwFlags);
    }

    if (wszNewCtrFilePath != NULL) MemoryFree (wszNewCtrFilePath);
    if (wszNewHlpFilePath != NULL) MemoryFree (wszNewHlpFilePath);
    if (wszLanguageID != NULL) MemoryFree (wszLanguageID);

    return dwError;
}

LOADPERF_FUNCTION
SetServiceAsTrustedW (
    LPCWSTR szMachineName,  // reserved, MBZ
    LPCWSTR szServiceName
)
{
    HKEY    hKeyService_Perf;
    DWORD   dwReturn;
    WCHAR   szPerfKeyString[MAX_PATH * 2];
    HKEY    hKeyLM = HKEY_LOCAL_MACHINE;    // until remote machine access is supported
    WCHAR   szLibName[MAX_PATH * 2];
    WCHAR   szExpLibName[MAX_PATH * 2];
    WCHAR   szFullPathName[MAX_PATH * 2];
    DWORD   dwSize, dwType;
    HANDLE  hFile;
    DllValidationData   dvdLibrary;
    LARGE_INTEGER   liSize;
    BOOL    bStatus;

    WinPerfStartTrace(NULL);

    if ((szMachineName != NULL) || (szServiceName == NULL)) {
        // reserved for future use
        return ERROR_INVALID_PARAMETER;
    }

    // build path to performance subkey
    lstrcpyW (szPerfKeyString, DriverPathRoot); // SYSTEM\CurrentControlSet\Services
    lstrcatW (szPerfKeyString, Slash);
    lstrcatW (szPerfKeyString, szServiceName);
    lstrcatW (szPerfKeyString, Slash);
    lstrcatW (szPerfKeyString, Performance);

    // open performance key under the service key
    dwReturn = RegOpenKeyExW (
        hKeyLM,
        szPerfKeyString,
        0L,
        KEY_READ | KEY_WRITE,
        &hKeyService_Perf);

    if (dwReturn == ERROR_SUCCESS) {
        // get library name
        dwType = 0;
        dwSize = sizeof(szLibName) / sizeof (szLibName[0]);
        dwReturn = RegQueryValueExW (
            hKeyService_Perf,
            cszLibrary,
            NULL,
            &dwType,
            (LPBYTE)&szLibName[0],
            &dwSize);

        if (dwReturn == ERROR_SUCCESS) {
            // expand path name if necessary
            if (dwType == REG_EXPAND_SZ) {
               dwSize = ExpandEnvironmentStringsW (
                   szLibName,
                   szExpLibName,
                   sizeof(szExpLibName) / sizeof (szExpLibName[0]));
            } else {
                lstrcpyW (szExpLibName, szLibName);
                // dwSize is same as returned from Fn Call.
            }

            if (dwSize != 0) {
                // find DLL file
                dwSize = SearchPathW (
                    NULL,
                    szExpLibName,
                    NULL,
                    sizeof(szFullPathName) / sizeof (szFullPathName[0]),
                    szFullPathName,
                    NULL);

                if (dwSize > 0) {
                    hFile = CreateFileW (
                        szFullPathName,
                        GENERIC_READ,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);
                    if (hFile != INVALID_HANDLE_VALUE) {
                         // read file date/time & size
                        bStatus = GetFileTime (
                            hFile,
                            &dvdLibrary.CreationDate,
                            NULL,
                            NULL);
                        if (bStatus) {
                            liSize.LowPart = GetFileSize (
                                hFile,
                                (DWORD *)&liSize.HighPart);
                            dvdLibrary.FileSize = liSize.QuadPart;
                            // set registry value
                            dwReturn = RegSetValueExW (
                                hKeyService_Perf,
                                szLibraryValidationCode,
                                0L,
                                REG_BINARY,
                                (LPBYTE)&dvdLibrary,
                                sizeof(dvdLibrary));

                            TRACE((WINPERF_DBG_TRACE_INFO),
                                  (& LoadPerfGuid,
                                    __LINE__,
                                    LOADPERF_SETSERVICEASTRUSTED,
                                    ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2) | ARG_DEF(ARG_TYPE_WSTR, 3),
                                    dwReturn,
                                    TRACE_WSTR(szServiceName),
                                    TRACE_WSTR(szExpLibName),
                                    TRACE_WSTR(szLibraryValidationCode),
                                    NULL));
                        } else {
                            dwReturn = GetLastError();
                        }
                        CloseHandle (hFile);
                    } else {
                        dwReturn = GetLastError();
                    }
                } else {
                    dwReturn = ERROR_FILE_NOT_FOUND;
                }
            } else {
                // unable to expand environment strings
                dwReturn = GetLastError();
            }
        }
        else {
            TRACE((WINPERF_DBG_TRACE_ERROR),
                  (& LoadPerfGuid,
                    __LINE__,
                    LOADPERF_SETSERVICEASTRUSTED,
                    ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                    dwReturn,
                    TRACE_WSTR(szServiceName),
                    TRACE_WSTR(cszLibrary),
                    NULL));
        }
        // close key
        RegCloseKey (hKeyService_Perf);
    }
    else {
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_SETSERVICEASTRUSTED,
                ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                dwReturn,
                TRACE_WSTR(szServiceName),
                TRACE_WSTR(Performance),
                NULL));
    }

    return dwReturn;
}

LOADPERF_FUNCTION
SetServiceAsTrustedA (
    LPCSTR szMachineName,  // reserved, MBZ
    LPCSTR szServiceName
)
{
    LPWSTR lpWideServiceName;
    DWORD  dwStrLen;
    DWORD  lReturn;

    if ((szMachineName != NULL) || (szServiceName == NULL)) {
        // reserved for future use
        return ERROR_INVALID_PARAMETER;
    }

    if (szServiceName != NULL) {
        //length of string including terminator
        dwStrLen = lstrlenA(szServiceName) + 1;
        lpWideServiceName = MemoryAllocate (dwStrLen * sizeof(WCHAR));
        if (lpWideServiceName != NULL) {
            mbstowcs (lpWideServiceName, szServiceName, dwStrLen);
            lReturn = SetServiceAsTrustedW (NULL, lpWideServiceName);
            MemoryFree (lpWideServiceName);
        } else {
            lReturn = GetLastError();
        }
    } else {
        lReturn = ERROR_INVALID_PARAMETER;
    }
    return lReturn;
}

int __cdecl
My_vfwprintf(
    FILE *str,
    const wchar_t *format,
    va_list argptr
    )
{
    HANDLE hOut;

    if (str == stderr) {
        hOut = GetStdHandle(STD_ERROR_HANDLE);
    }
    else {
        hOut = GetStdHandle(STD_OUTPUT_HANDLE);
    }

    if ((GetFileType(hOut) & ~FILE_TYPE_REMOTE) == FILE_TYPE_CHAR) {
        DWORD  cchWChar;
        WCHAR  szBufferMessage[1024];

        vswprintf( szBufferMessage, format, argptr );
        cchWChar = wcslen(szBufferMessage);
        WriteConsoleW(hOut, szBufferMessage, cchWChar, &cchWChar, NULL);
        return cchWChar;
    }

    return vfwprintf(str, format, argptr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cntrtext\common\mofcomp.h ===
#ifndef _LODCTR_MOFCOMP_H
#define _LODCTR_MOFCOMP_H

#ifdef __cplusplus
extern "C" {
#endif

#define WMI_LODCTR_EVENT    1
#define WMI_UNLODCTR_EVENT  2


DWORD SignalWmiWithNewData ( DWORD  dwEventId );
DWORD LodctrCompileMofFile ( LPCWSTR szComputerName, LPCWSTR szMofFileName );
DWORD LodctrCompileMofBuffer ( LPCWSTR szComputerName, LPVOID pMofBuffer, DWORD dwBufSize );

#ifdef __cplusplus
}
#endif 
#endif  //_LODCTR_MOFCOMP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cntrtext\common\common.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

common.h

    constants and globals that are common to LODCTR and UNLODCTR

Author:

    Bob Watson (a-robw) 10 Feb 93

Revision History:

--*/
#ifndef _LODCTR_COMMON_H_
#define _LODCTR_COMMON_H_
//
//  Local constants
//
#define RESERVED                0L
#define LARGE_BUFFER_SIZE       0x10000         // 64K
#define MEDIUM_BUFFER_SIZE      0x8000          // 32K
#define SMALL_BUFFER_SIZE       0x1000          //  4K
#define FILE_NAME_BUFFER_SIZE   MAX_PATH
#define DISP_BUFF_SIZE          256L
#define SIZE_OF_OFFSET_STRING   15
#define PERFLIB_BASE_INDEX      1847
#define FIRST_EXT_COUNTER_INDEX 1848
#define FIRST_EXT_HELP_INDEX    1849

#define H_MUTEX_TIMEOUT         10000L

#define LODCTR_UPNF_RESTORE     0x00000001
//
//  Data structure and type definitions
//
typedef struct _NAME_ENTRY {
    struct _NAME_ENTRY  *pNext;
    DWORD               dwOffset;
    DWORD               dwType;
    LPTSTR              lpText;
} NAME_ENTRY, *PNAME_ENTRY;

typedef struct _LANGUAGE_LIST_ELEMENT {
    struct _LANGUAGE_LIST_ELEMENT   *pNextLang;     // next lang. list
    LPTSTR  LangId;                                 // lang ID string for this elem
    PNAME_ENTRY pFirstName;                         // head of name list
    PNAME_ENTRY pThisName;                          // pointer to current entry
    DWORD   dwNumElements;                          // number of elements in array
    DWORD   dwNameBuffSize;
    DWORD   dwHelpBuffSize;
    PBYTE   NameBuffer;                             // buffer to store strings
    PBYTE   HelpBuffer;                             // buffer to store help strings
} LANGUAGE_LIST_ELEMENT, *PLANGUAGE_LIST_ELEMENT;

typedef struct _SYMBOL_TABLE_ENTRY {
    struct _SYMBOL_TABLE_ENTRY    *pNext;
    LPTSTR  SymbolName;
    DWORD   Value;
} SYMBOL_TABLE_ENTRY, *PSYMBOL_TABLE_ENTRY;

//
//  Utility Routine prototypes for routines in common.c
//
#define StringToInt(in,out) \
    (((_stscanf ((in), (LPCTSTR)TEXT(" %d"), (out))) == 1) ? TRUE : FALSE)

LPCTSTR
GetStringResource (
    UINT    wStringId
);

LPCTSTR
GetFormatResource (
    UINT    wStringId
);

VOID
DisplayCommandHelp (
    UINT    iFirstLine,
    UINT    iLastLine
);

BOOL
TrimSpaces (
    IN  OUT LPTSTR  szString
);

BOOL
IsDelimiter (
    IN  TCHAR   cChar,
    IN  TCHAR   cDelimiter
);

LPCTSTR
GetItemFromString (
    IN  LPCTSTR     szEntry,
    IN  DWORD       dwItem,
    IN  TCHAR       cDelimiter

);

BOOLEAN LoadPerfGrabMutex();

void
ReportLoadPerfEvent(
    IN  WORD    EventType,
    IN  DWORD   EventID,
    IN  DWORD   dwDataCount,
    IN  DWORD   dwData1,
    IN  DWORD   dwData2,
    IN  DWORD   dwData3,
    IN  WORD    wStringCount,
    IN  LPWSTR  szString1,
    IN  LPWSTR  szString2,
    IN  LPWSTR  szString3
);

// defined in dumpload.c

DWORD
BackupPerfRegistryToFileW (
    IN  LPCWSTR szFileName,
    IN  LPCWSTR szCommentString
);

DWORD
RestorePerfRegistryFromFileW (
    IN  LPCWSTR szFileName,
    IN  LPCWSTR szLangId
);

extern LPCTSTR NamesKey;
extern LPCTSTR DefaultLangId;
extern LPCTSTR DefaultLangTag;
extern LPCTSTR Counters;
extern LPCTSTR Help;
extern LPCTSTR LastHelp;
extern LPCTSTR LastCounter;
extern LPCTSTR FirstHelp;
extern LPCTSTR cszFirstCounter;
extern LPCTSTR Busy;
extern LPCTSTR Slash;
extern LPCTSTR BlankString;
extern LPCTSTR DriverPathRoot;
extern LPCTSTR Performance;
extern LPCTSTR CounterNameStr;
extern LPCTSTR HelpNameStr;
extern LPCTSTR AddCounterNameStr;
extern LPCTSTR AddHelpNameStr;
extern LPCTSTR VersionStr;
extern LPCTSTR szObjectList;
extern LPCTSTR szLibraryValidationCode;

extern HANDLE hEventLog; 
extern HANDLE hLoadPerfMutex; 

#endif  // _LODCTR_COMMON_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cntrtext\common\mofcomp.cpp ===
#include    <windows.h>
#include    <wbemidl.h>
#include    <wbemint.h>
#include    <assert.h>
#include    <stdio.h>
#include    "mofcomp.h"

static CONST WCHAR cszWmiLoadEventName[] = {L"WMI_SysEvent_LodCtr"};
static CONST WCHAR cszWmiUnloadEventName[] = {L"WMI_SysEvent_UnLodCtr"};

DWORD SignalWmiWithNewData (DWORD  dwEventId)
{
    HANDLE  hEvent;
    DWORD   dwStatus = ERROR_SUCCESS;

    LPWSTR szEventName = NULL;

    switch (dwEventId) {
    case WMI_LODCTR_EVENT:
        szEventName = (LPWSTR)cszWmiLoadEventName;
        break;

    case WMI_UNLODCTR_EVENT:
        szEventName = (LPWSTR)cszWmiUnloadEventName;
        break;

    default:
        dwStatus = ERROR_INVALID_PARAMETER;
        break;
    }

    if (dwStatus == ERROR_SUCCESS) {
        hEvent = OpenEventW (
            EVENT_MODIFY_STATE | SYNCHRONIZE,
            FALSE,
            szEventName);
        if (hEvent != NULL) {
            // set event
            SetEvent (hEvent);
            CloseHandle (hEvent);
        } else {
            dwStatus = GetLastError();
        }
        
    }
    return dwStatus;
}


DWORD LodctrCompileMofFile ( LPCWSTR szComputerName, LPCWSTR szMofFileName )
{
    HRESULT hRes;
    IMofCompiler    *pMofComp = NULL;
    DWORD   dwReturn = ERROR_SUCCESS;
    WBEM_COMPILE_STATUS_INFO    Info;
 
    WCHAR   szLocalServerName[1024];
    LPWSTR  szServerPath;

    hRes = CoInitializeEx (0, COINIT_MULTITHREADED);

    if (hRes == S_OK) {
        // open the COM interface to the mof compiler object
        hRes = CoCreateInstance(
            CLSID_MofCompiler,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IMofCompiler,
            (LPVOID *)&pMofComp);
                       
        if (hRes == S_OK) {
            // load mof
            assert (pMofComp != NULL);

            if (szComputerName == NULL) {
                szServerPath = NULL;
            } else {
                assert (lstrlenW(szComputerName) < MAX_PATH);
                lstrcpyW (szLocalServerName, szComputerName);
                lstrcatW (szLocalServerName, L"\\root\\default");
                szServerPath = &szLocalServerName[0];
            }

            hRes = pMofComp->CompileFile (
                (LPWSTR)szMofFileName,
                NULL,			// load into namespace specified in MOF file
                NULL,           // use default User
                NULL,           // use default Authority
                NULL,           // use default Password
                0,              // no options
                0,				// no class flags
                0,              // no instance flags
                &Info);

            if (hRes != S_OK) {
                dwReturn = (DWORD)Info.hRes;
            }

            // close COM interface
            pMofComp->Release();
        } else {
            dwReturn = (DWORD)hRes;
        }
        CoUninitialize();
    } else {
        dwReturn = (DWORD)hRes;
    }

    return dwReturn;
}

DWORD LodctrCompileMofBuffer ( LPCWSTR szComputerName, LPVOID pMofBuffer, DWORD dwBufSize )
{
    HRESULT hRes;
    IMofCompiler    *pMofComp = NULL;
    DWORD   dwReturn = ERROR_SUCCESS;
    WBEM_COMPILE_STATUS_INFO    Info;
    
    DBG_UNREFERENCED_PARAMETER (szComputerName);

    hRes = CoInitializeEx (0, COINIT_MULTITHREADED);

    if (hRes == S_OK) {
        // open the COM interface to the mof compiler object
        hRes = CoCreateInstance(
            CLSID_MofCompiler,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IMofCompiler,
            (LPVOID *)&pMofComp);
                       
        if (hRes == S_OK) {
            // load mof
            assert (pMofComp != NULL);

            hRes = pMofComp->CompileBuffer (
                dwBufSize,
                (LPBYTE) pMofBuffer,
                NULL,           // load into Root\Default on local mashine
                NULL,           // use default User
                NULL,           // use default Authority
                NULL,           // use default Password
                0,              // no options
                WBEM_FLAG_UPDATE_FORCE_MODE,    // no class flags
                0,              // no instance flags
                &Info);

            if (hRes != S_OK) {
                // return the detailed error code
                dwReturn = (DWORD)Info.hRes;
            }

            // close COM interface
            pMofComp->Release();
        } else {
            dwReturn = (DWORD)hRes;
        }
        CoUninitialize();
    } else {
        dwReturn = (DWORD)hRes;
    }

    return dwReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cntrtext\common\lodctr.h ===
/*++

lodctr.h

    Include file for lodctr 
    
--*/
#ifndef _LODCTR_H
#define _LODCTR_H

#define cC          TEXT('C')
#define cH          TEXT('H')
#define cSpace      TEXT(' ')
#define cEquals     TEXT('=')
#define cQuestion   TEXT('?')
#define cBackslash  TEXT('\\')
#define cUnderscore TEXT('_')
#define cHyphen		TEXT('-')
#define cSlash		TEXT('/')
#define cM			TEXT('M')
#define cm			TEXT('m')


#define TYPE_HELP   1
#define TYPE_NAME   2


#define LC_CMD_HELP_1           201
#define LC_CMD_HELP_2           202
#define LC_CMD_HELP_3           203
#define LC_CMD_HELP_4           204
#define LC_CMD_HELP_5           205
#define LC_CMD_HELP_6           206
#define LC_CMD_HELP_7           207
#define LC_CMD_HELP_8           208
#define LC_CMD_HELP_9           209 
#define LC_CMD_HELP_10          210
#define LC_CMD_HELP_11          211
#define LC_CMD_HELP_12          212
#define LC_CMD_HELP_13          213
#define LC_CMD_HELP_14          214
#define LC_CMD_HELP_15          215
#define LC_FIRST_CMD_HELP   LC_CMD_HELP_1
#define LC_LAST_CMD_HELP    LC_CMD_HELP_15

#define LC_DEVNAME_ERR_1        107
#define LC_DEVNAME_ERR_2        108

#define LC_NO_INIFILE           109
                  
#define LC_LANGLIST_ERR         110

#define LC_ERR_OPEN_INCLUDE     111

#define LC_ERR_OPEN_DRIVERPERF1 113
#define LC_ERR_OPEN_DRIVERPERF2 114
#define LC_ERR_OPEN_PERFLIB     115
#define LC_ERR_READLASTPERFLIB  116
#define LC_ERR_ALREADY_IN       117
#define LC_ERR_UNABLESETBUSY    118
#define LC_ERRO_READBASEINDEX   119

#define LC_BAD_KEY              120
#define LC_LANGNOTFOUND         121
#define LC_ERR_ADDENTRY         122
#define LC_ERRADDTOLANG         123
#define LC_UNABLESORTTABLES     124
#define LC_UNABLEOPENLANG       125
#define LC_UNABLESETVALUE       126
#define LC_ERR_UPDATELANG       127
#define LC_PERFLIBISBUSY        128
#define LC_CONNECT_PROBLEM      129

#endif  // _LODCTR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cntrtext\common\dumpload.c ===
/*++

Copyright (c) 1991-1999  Microsoft Corporation

Module Name:

    dumpload.c

Abstract:

    functions to dump and load the contents of the performance related registry
	entries

Author:

    Bob Watson (bobw) 13 Jun 99

Revision History:



--*/
#ifndef     UNICODE
#define     UNICODE     1
#endif

#ifndef     _UNICODE
#define     _UNICODE    1
#endif
//
//  "C" Include files
//
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <malloc.h>
//
//  Windows Include files
//
#include <windows.h>
#include <winperf.h>
#include <loadperf.h>
#include "wmistr.h"
#include "evntrace.h"
//
//  application include files
//
#include "winperfp.h"
#include "common.h"
#include "ldprfmsg.h"

static const WCHAR  cszServiceKeyName[] = {L"SYSTEM\\CurrentControlSet\\Services"};
static const WCHAR  cszPerflibKeyName[] = {L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib"};
static const WCHAR  cszLastCounter[] = {L"Last Counter"};
static const WCHAR  cszFirstHelp[] = {L"First Help"};
static const WCHAR  cszLastHelp[] = {L"Last Help"};
static const WCHAR  cszBaseIndex[] = {L"Base Index"};
static const WCHAR  cszPerformance[] = {L"\\Performance"};
static const WCHAR  cszDisablePerformanceCounters[] = {L"Disable Performance Counters"};

// headings in save file
static const WCHAR  cszFmtSectionHeader[] = {L"\r\n\r\n[%s]"};
static const WCHAR  cszFmtServiceSectionHeader[] = {L"\r\n\r\n[PERF_%s]"};
static const WCHAR  cszFmtServiceSectionName[] = {L"PERF_%s"};
static const WCHAR  cszFmtStringSectionHeader[] = {L"\r\n\r\n[PerfStrings_%s]"};
static const WCHAR  cszFmtExtCtrString[] = {L"\r\n%d=%s"};
static const WCHAR  cszFmtDecimalParam[] = {L"\r\n%s=%d"};
static const WCHAR  cszFmtNoParam[] = {L"\r\n%s="};

static const WCHAR  cszExtensiblePerfStrings[] = {L"Strings"};
static const WCHAR  cszPerfCounterServices[] = {L"PerfCounterServices"};
static const WCHAR  cszNoPerfCounterServices[] = {L"NoPerfCounterServices"};
static const WCHAR  cszPerflib[] = {L"Perflib"};

// external forward definitions
LPWSTR
*BuildNameTable(
    HKEY    hKeyRegistry,   // handle to registry db with counter names
    LPWSTR  lpszLangId,     // unicode value of Language subkey
    PDWORD  pdwLastItem     // size of array in elements
);

DWORD
UpdatePerfNameFilesX (
	IN  LPCWSTR     szNewCtrFilePath,   // data file with new base counter strings
	IN  LPCWSTR     szNewHlpFilePath,   // data file with new base counter strings
    IN 	LPWSTR      szLanguageID,       // Lang ID to update
    IN  ULONG_PTR   dwFlags             // flags
);

DWORD
static
DumpNameTable (
    IN  HANDLE  hOutputFile,
    IN  LPCWSTR szLangId,
    IN  LPCWSTR *pszNameTable,
    IN  DWORD   dwStartIndex,
    IN  DWORD   dwLastIndex
)
{
    DWORD   ndx;
    WCHAR   szOutputBuffer[4096];
    DWORD   dwSize, dwSizeWritten;

    dwSize = swprintf (szOutputBuffer, cszFmtStringSectionHeader, szLangId);
    dwSize *= sizeof (WCHAR);

    WriteFile (hOutputFile, szOutputBuffer, dwSize, &dwSizeWritten, NULL);

    for (ndx = dwStartIndex; ndx <= dwLastIndex; ndx++) {
        if (pszNameTable[ndx] != NULL) {
            dwSize = swprintf (szOutputBuffer, cszFmtExtCtrString, ndx, pszNameTable[ndx] );
            dwSize *= sizeof (WCHAR);
            WriteFile (hOutputFile, szOutputBuffer, dwSize, &dwSizeWritten, NULL);
        }
    }

    return ERROR_SUCCESS;
}

DWORD
static
DumpPerfServiceEntries (
    IN  HANDLE  hOutputFile,
    IN  LPCWSTR szServiceName
)
{
    LONG    lStatus = ERROR_SUCCESS;
    WCHAR   szPerfSubKeyName[MAX_PATH+20];
    HKEY    hKeyPerformance;
    HKEY    hKeyServices = NULL;
    DWORD   dwItemSize, dwType, dwValue;
    DWORD   dwRegAccessMask;
    DWORD   dwRetStatus = ERROR_SUCCESS;

    DWORD   dwSize, dwSizeWritten;
    WCHAR   szOutputBuffer[4096];

    // try read-only then
    dwRegAccessMask = KEY_READ;
    lStatus = RegOpenKeyExW (HKEY_LOCAL_MACHINE,
        cszServiceKeyName,
        0L,
        dwRegAccessMask,
        &hKeyServices);

    if (lStatus == ERROR_SUCCESS) {
        //try to open the perfkey under this key.
        lstrcpy (szPerfSubKeyName, szServiceName);
        lstrcat (szPerfSubKeyName, cszPerformance);

        lStatus = RegOpenKeyExW (
            hKeyServices,
            szPerfSubKeyName,
            0L,
            dwRegAccessMask,
            &hKeyPerformance);

        if (lStatus == ERROR_SUCCESS) {
            // key found so service has perf data
            dwSize = swprintf (szOutputBuffer, cszFmtServiceSectionHeader, szServiceName);
            dwSize *= sizeof (WCHAR);
            WriteFile (hOutputFile, szOutputBuffer, dwSize, &dwSizeWritten, NULL);

            // now check to see if the strings have been loaded
            dwType = dwValue = 0;
            dwItemSize = sizeof (dwValue);
            lStatus = RegQueryValueExW (
                    hKeyPerformance,
                    cszFirstCounter,
                    NULL,
                    &dwType,
                    (LPBYTE)&dwValue,
                    &dwItemSize);
            TRACE((WINPERF_DBG_TRACE_INFO),
                  (& LoadPerfGuid,
                   __LINE__,
                   LOADPERF_DUMPPERFSERVICEENTRIES,
                   ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                   lStatus,
                   TRACE_WSTR(szServiceName),
                   TRACE_WSTR(cszFirstCounter),
                   TRACE_DWORD(dwValue),
                   NULL));
            if ((lStatus == ERROR_SUCCESS) &&
                ((dwType == REG_DWORD) || dwType == REG_BINARY)) {
                dwSize = swprintf (szOutputBuffer, cszFmtDecimalParam, cszFirstCounter, dwValue);
                dwSize *= sizeof (WCHAR);
                WriteFile (hOutputFile, szOutputBuffer, dwSize, &dwSizeWritten, NULL);
            }

            dwType = dwValue = 0;
            dwItemSize = sizeof (dwValue);
            lStatus = RegQueryValueExW (
                    hKeyPerformance,
                    cszFirstHelp,
                    NULL,
                    &dwType,
                    (LPBYTE)&dwValue,
                    &dwItemSize);
            TRACE((WINPERF_DBG_TRACE_INFO),
                  (& LoadPerfGuid,
                   __LINE__,
                   LOADPERF_DUMPPERFSERVICEENTRIES,
                   ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                   lStatus,
                   TRACE_WSTR(szServiceName),
                   TRACE_WSTR(cszFirstHelp),
                   TRACE_DWORD(dwValue),
                   NULL));
            if ((lStatus == ERROR_SUCCESS) &&
                ((dwType == REG_DWORD) || dwType == REG_BINARY)) {
                dwSize = swprintf (szOutputBuffer, cszFmtDecimalParam, cszFirstHelp, dwValue);
                dwSize *= sizeof (WCHAR);
                WriteFile (hOutputFile, szOutputBuffer, dwSize, &dwSizeWritten, NULL);
            }

            dwType = dwValue = 0;
            dwItemSize = sizeof (dwValue);
            lStatus = RegQueryValueExW (
                    hKeyPerformance,
                    cszLastCounter,
                    NULL,
                    &dwType,
                    (LPBYTE)&dwValue,
                    &dwItemSize);
            TRACE((WINPERF_DBG_TRACE_INFO),
                  (& LoadPerfGuid,
                   __LINE__,
                   LOADPERF_DUMPPERFSERVICEENTRIES,
                   ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                   lStatus,
                   TRACE_WSTR(szServiceName),
                   TRACE_WSTR(cszLastCounter),
                   TRACE_DWORD(dwValue),
                   NULL));
            if ((lStatus == ERROR_SUCCESS) &&
                ((dwType == REG_DWORD) || dwType == REG_BINARY)) {
                dwSize = swprintf (szOutputBuffer, cszFmtDecimalParam, cszLastCounter, dwValue);
                dwSize *= sizeof (WCHAR);
                WriteFile (hOutputFile, szOutputBuffer, dwSize, &dwSizeWritten, NULL);
            }

            dwType = dwValue = 0;
            dwItemSize = sizeof (dwValue);
            lStatus = RegQueryValueExW (
                    hKeyPerformance,
                    cszLastHelp,
                    NULL,
                    &dwType,
                    (LPBYTE)&dwValue,
                    &dwItemSize);
            TRACE((WINPERF_DBG_TRACE_INFO),
                  (& LoadPerfGuid,
                   __LINE__,
                   LOADPERF_DUMPPERFSERVICEENTRIES,
                   ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                   lStatus,
                   TRACE_WSTR(szServiceName),
                   TRACE_WSTR(cszLastHelp),
                   TRACE_DWORD(dwValue),
                   NULL));
            if ((lStatus == ERROR_SUCCESS) &&
                ((dwType == REG_DWORD) || dwType == REG_BINARY)) {
                dwSize = swprintf (szOutputBuffer, cszFmtDecimalParam, cszLastHelp, dwValue);
                dwSize *= sizeof (WCHAR);
                WriteFile (hOutputFile, szOutputBuffer, dwSize, &dwSizeWritten, NULL);
            }

            dwType = dwValue = 0;
            dwItemSize = sizeof (dwValue);
            lStatus = RegQueryValueExW (
                    hKeyPerformance,
                    cszDisablePerformanceCounters,
                    NULL,
                    &dwType,
                    (LPBYTE)&dwValue,
                    &dwItemSize);
            TRACE((WINPERF_DBG_TRACE_INFO),
                  (& LoadPerfGuid,
                   __LINE__,
                   LOADPERF_DUMPPERFSERVICEENTRIES,
                   ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                   lStatus,
                   TRACE_WSTR(szServiceName),
                   TRACE_WSTR(cszDisablePerformanceCounters),
                   TRACE_DWORD(dwValue),
                   NULL));
            if ((lStatus == ERROR_SUCCESS) &&
                ((dwType == REG_DWORD) || dwType == REG_BINARY)) {
                dwSize = swprintf (szOutputBuffer, cszFmtDecimalParam, cszDisablePerformanceCounters, dwValue);
                dwSize *= sizeof (WCHAR);
                WriteFile (hOutputFile, szOutputBuffer, dwSize, &dwSizeWritten, NULL);
            }

            RegCloseKey (hKeyPerformance);
        } else {
            dwRetStatus = lStatus;
            TRACE((WINPERF_DBG_TRACE_ERROR),
                  (& LoadPerfGuid,
                   __LINE__,
                   LOADPERF_DUMPPERFSERVICEENTRIES,
                   ARG_DEF(ARG_TYPE_WSTR, 1),
                   lStatus,
                   TRACE_WSTR(szServiceName),
                   NULL));
        }

        RegCloseKey (hKeyServices);
    }
    else {
        dwRetStatus = lStatus;
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
               __LINE__,
               LOADPERF_DUMPPERFSERVICEENTRIES,
               ARG_DEF(ARG_TYPE_WSTR, 1),
               lStatus,
               TRACE_WSTR(cszServiceKeyName),
               NULL));
    }

    return dwRetStatus;
}

DWORD
static
DumpPerflibEntries (
    IN  HANDLE  hOutputFile,
    IN  LPDWORD pdwFirstExtCtrIndex

)
{
    HKEY    hKeyPerflib = NULL;
    DWORD   dwStatus;
    DWORD   dwItemSize, dwType, dwValue;

    DWORD   dwSize, dwSizeWritten;
    WCHAR   szOutputBuffer[4096];

    dwStatus = RegOpenKeyExW (HKEY_LOCAL_MACHINE,
        cszPerflibKeyName,
        0L,
        KEY_READ,
        &hKeyPerflib);

    if (dwStatus == ERROR_SUCCESS) {
        dwSize = swprintf (szOutputBuffer, cszFmtSectionHeader, cszPerflib);
        dwSize *= sizeof (WCHAR);
        WriteFile (hOutputFile, szOutputBuffer, dwSize, &dwSizeWritten, NULL);
    }
    else {
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
               __LINE__,
               LOADPERF_DUMPPERFLIBENTRIES,
               ARG_DEF(ARG_TYPE_WSTR, 1),
               dwStatus,
               TRACE_WSTR(cszPerflibKeyName),
               NULL));
    }

    if (dwStatus == ERROR_SUCCESS) {
        dwType = dwValue = 0;
        dwItemSize = sizeof (dwValue);
        dwStatus = RegQueryValueEx (
                hKeyPerflib,
                cszBaseIndex,
                NULL,
                &dwType,
                (LPBYTE)&dwValue,
                &dwItemSize);
        TRACE((WINPERF_DBG_TRACE_INFO),
              (& LoadPerfGuid,
               __LINE__,
               LOADPERF_DUMPPERFLIBENTRIES,
               ARG_DEF(ARG_TYPE_WSTR, 1),
               dwStatus,
               TRACE_WSTR(cszBaseIndex),
               TRACE_DWORD(dwValue),
               NULL));
        if ((dwStatus == ERROR_SUCCESS) && (dwType == REG_DWORD)) {
            dwSize = swprintf (szOutputBuffer, cszFmtDecimalParam, cszBaseIndex, dwValue);
            dwSize *= sizeof (WCHAR);
            WriteFile (hOutputFile, szOutputBuffer, dwSize, &dwSizeWritten, NULL);
            *pdwFirstExtCtrIndex = dwValue + 1;
        }
    }

    if (dwStatus == ERROR_SUCCESS) {
        dwType = dwValue = 0;
        dwItemSize = sizeof (dwValue);
        dwStatus = RegQueryValueEx (
                hKeyPerflib,
                cszLastCounter,
                NULL,
                &dwType,
                (LPBYTE)&dwValue,
                &dwItemSize);
        TRACE((WINPERF_DBG_TRACE_INFO),
              (& LoadPerfGuid,
               __LINE__,
               LOADPERF_DUMPPERFLIBENTRIES,
               ARG_DEF(ARG_TYPE_WSTR, 1),
               dwStatus,
               TRACE_WSTR(cszLastCounter),
               TRACE_DWORD(dwValue),
               NULL));
        if ((dwStatus == ERROR_SUCCESS) && (dwType == REG_DWORD)) {
            dwSize = swprintf (szOutputBuffer, cszFmtDecimalParam, cszLastCounter, dwValue);
            dwSize *= sizeof (WCHAR);
            WriteFile (hOutputFile, szOutputBuffer, dwSize, &dwSizeWritten, NULL);
        }
    }

    if (dwStatus == ERROR_SUCCESS) {
        dwType = dwValue = 0;
        dwItemSize = sizeof (dwValue);
        dwStatus = RegQueryValueEx (
                hKeyPerflib,
                cszLastHelp,
                NULL,
                &dwType,
                (LPBYTE)&dwValue,
                &dwItemSize);
        TRACE((WINPERF_DBG_TRACE_INFO),
              (& LoadPerfGuid,
               __LINE__,
               LOADPERF_DUMPPERFLIBENTRIES,
               ARG_DEF(ARG_TYPE_WSTR, 1),
               dwStatus,
               TRACE_WSTR(cszLastHelp),
               TRACE_DWORD(dwValue),
               NULL));
        if ((dwStatus == ERROR_SUCCESS) && (dwType == REG_DWORD)) {
            dwSize = swprintf (szOutputBuffer, cszFmtDecimalParam, cszLastHelp, dwValue);
            dwSize *= sizeof (WCHAR);
            WriteFile (hOutputFile, szOutputBuffer, dwSize, &dwSizeWritten, NULL);
        }
    }

    if (hKeyPerflib != NULL) RegCloseKey (hKeyPerflib);

    return dwStatus;
}


DWORD
static
BuildServiceLists (
    IN  LPWSTR  mszPerfServiceList,
    IN  LPDWORD pcchPerfServiceListSize,
    IN  LPWSTR  mszNoPerfServiceList,
    IN  LPDWORD pcchNoPerfServiceListSize
)
{
    LONG    lStatus = ERROR_SUCCESS;
    LONG    lEnumStatus = ERROR_SUCCESS;
    DWORD   dwServiceIndex = 0;
    WCHAR   szServiceSubKeyName[MAX_PATH];
    WCHAR   szPerfSubKeyName[MAX_PATH+20];
    DWORD   dwNameSize = MAX_PATH;
    HKEY    hKeyPerformance;
    HKEY    hKeyServices = NULL;
    DWORD   dwItemSize, dwType, dwValue;
    DWORD   dwRegAccessMask;
    DWORD   bServiceHasPerfCounters;
    DWORD   dwRetStatus = ERROR_SUCCESS;

    LPWSTR  szNextNoPerfChar, szNextPerfChar;
    DWORD   dwNoPerfSizeRem, dwPerfSizeRem;
    DWORD   dwPerfSizeUsed = 0, dwNoPerfSizeUsed = 0;

    // try read-only then
    dwRegAccessMask = KEY_READ;
    lStatus = RegOpenKeyExW (HKEY_LOCAL_MACHINE,
        cszServiceKeyName,
        0L,
        dwRegAccessMask,
        &hKeyServices);

    if (lStatus == ERROR_SUCCESS) {
        szNextNoPerfChar = mszNoPerfServiceList;
        szNextPerfChar = mszPerfServiceList;
        dwNoPerfSizeRem = *pcchPerfServiceListSize;
        dwPerfSizeRem = *pcchNoPerfServiceListSize;
        dwPerfSizeUsed = 0;
        dwNoPerfSizeUsed = 0;

        while ((lEnumStatus = RegEnumKeyExW (
            hKeyServices,
            dwServiceIndex,
            szServiceSubKeyName,
            &dwNameSize,
            NULL,
            NULL,
            NULL,
            NULL)) == ERROR_SUCCESS) {

            //try to open the perfkey under this key.
            lstrcpy (szPerfSubKeyName, szServiceSubKeyName);
            lstrcat (szPerfSubKeyName, cszPerformance);

            lStatus = RegOpenKeyExW (
                hKeyServices,
                szPerfSubKeyName,
                0L,
                dwRegAccessMask,
                &hKeyPerformance);

            if (lStatus == ERROR_SUCCESS) {
                // key found so service has perf data
                // now check to see if the strings have been loaded
                dwType = dwValue = 0;
                dwItemSize = sizeof (dwValue);
                lStatus = RegQueryValueExW (
                    hKeyPerformance,
                    cszFirstCounter,
                    NULL,
                    &dwType,
                    (LPBYTE)&dwValue,
                    &dwItemSize);
                if ((lStatus == ERROR_SUCCESS) &&
                    ((dwType == REG_DWORD) || dwType == REG_BINARY)) {
                    bServiceHasPerfCounters = TRUE;
                } else {
                    bServiceHasPerfCounters = FALSE;
                }

                RegCloseKey (hKeyPerformance);
            } else {
                // key not found so service doesn't have perfdata
                bServiceHasPerfCounters = FALSE;
            }

            TRACE((WINPERF_DBG_TRACE_INFO),
                  (& LoadPerfGuid,
                   __LINE__,
                   LOADPERF_BUILDSERVICELISTS,
                   ARG_DEF(ARG_TYPE_WSTR, 1),
                   lStatus,
                   TRACE_WSTR(szServiceSubKeyName),
                   TRACE_DWORD(bServiceHasPerfCounters),
                   NULL));

            if (bServiceHasPerfCounters != FALSE) {
                // add to the perf service list
                if ((dwNameSize + 1)< dwPerfSizeRem) {
                    // add to list
                    lstrcpyW (szNextPerfChar, szServiceSubKeyName);
                    szNextPerfChar += dwNameSize;
                    *szNextPerfChar = 0;
                    szNextPerfChar++;
                    dwPerfSizeRem -= dwNameSize + 1;
                } else {
                    dwRetStatus = ERROR_MORE_DATA;
                }
                dwPerfSizeUsed += dwNameSize + 1;
            } else {
                // add to the no perf list
                if ((dwNameSize + 1) < dwNoPerfSizeRem) {
                    // add to list
                    lstrcpyW (szNextNoPerfChar, szServiceSubKeyName);
                    szNextNoPerfChar += dwNameSize;
                    *szNextNoPerfChar = 0;
                    szNextNoPerfChar++;
                    dwNoPerfSizeRem -= dwNameSize + 1;
                } else {
                    dwRetStatus = ERROR_MORE_DATA;
                }
                dwNoPerfSizeUsed += dwNameSize + 1;
            }
            // reset for next loop
            dwServiceIndex++;
            dwNameSize = MAX_PATH;
        }

        // zero term the MSZ
        if (1 < dwPerfSizeRem) {
            *szNextPerfChar = 0;
            szNextPerfChar++;
            dwPerfSizeRem -= 1;
        } else {
            dwRetStatus = ERROR_MORE_DATA;
        }
        dwPerfSizeUsed += 1;

        // zero term the no perf list
        if (1 < dwNoPerfSizeRem) {
            // add to list
            *szNextNoPerfChar = 0;
            szNextNoPerfChar++;
            dwNoPerfSizeRem -= 1;
        } else {
            dwRetStatus = ERROR_MORE_DATA;
        }
        dwNoPerfSizeUsed += 1;
    }
    else {
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
               __LINE__,
               LOADPERF_BUILDSERVICELISTS,
               ARG_DEF(ARG_TYPE_WSTR, 1),
               lStatus,
               TRACE_WSTR(cszServiceKeyName),
               NULL));
    }

    if (hKeyServices != NULL) RegCloseKey (hKeyServices);

    *pcchPerfServiceListSize = dwPerfSizeUsed;
    *pcchNoPerfServiceListSize = dwNoPerfSizeUsed;

    return dwRetStatus;
}


DWORD
BackupPerfRegistryToFileW (
    IN  LPCWSTR szFileName,
    IN  LPCWSTR szCommentString
)
{
    HANDLE  hOutFile;
    DWORD   dwStatus = ERROR_SUCCESS;
    LPWSTR  szNewFileName = NULL;
    DWORD   dwNewFileNameLen;
    DWORD   dwOrigFileNameLen;
    DWORD   dwFileNameSN;

    LPWSTR  mszPerfServiceList = NULL;
    DWORD   dwPerfServiceListSize = 0;
    LPWSTR  mszNoPerfServiceList = NULL;
    DWORD   dwNoPerfServiceListSize = 0;

    LPWSTR  *lpCounterText = NULL;
    DWORD   dwLastElement = 0;
    DWORD   dwFirstExtCtrIndex = 0;

    LPWSTR  szThisServiceName;

    LPWSTR  szLangId = (LPWSTR)L"009";

    DBG_UNREFERENCED_PARAMETER (szCommentString);

    WinPerfStartTrace(NULL);

    // open output file
    hOutFile = CreateFileW (
        szFileName,
        GENERIC_WRITE,
        0,  // no sharing
        NULL,   // default security
        CREATE_NEW,
        FILE_ATTRIBUTE_NORMAL,
        NULL);

    // if the file open failed
    if (hOutFile == INVALID_HANDLE_VALUE) {
        // see if it's because the file already exists
        dwStatus = GetLastError();
        if (dwStatus == ERROR_FILE_EXISTS) {
            // then try appending a serial number to the name
            dwOrigFileNameLen = lstrlenW (szFileName);
            dwNewFileNameLen = dwOrigFileNameLen + 4;
            szNewFileName = HeapAlloc (
                GetProcessHeap(),
                HEAP_ZERO_MEMORY,
                (dwNewFileNameLen +1) * sizeof(WCHAR));
            if (szNewFileName != NULL) {
                lstrcpyW (szNewFileName, szFileName);
                for (dwFileNameSN = 1; dwFileNameSN < 1000; dwFileNameSN++) {
                    swprintf (&szNewFileName[dwOrigFileNameLen],
                        (LPCWSTR)L"_%3.3d", dwFileNameSN);
                    hOutFile = CreateFileW (
                        szNewFileName,
                        GENERIC_WRITE,
                        0,  // no sharing
                        NULL,   // default security
                        CREATE_NEW,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);

                    // if the file open failed
                    if (hOutFile == INVALID_HANDLE_VALUE) {
                        dwStatus = GetLastError();
                        if (dwStatus != ERROR_FILE_EXISTS) {
                            // some other error occurred so bail out
                            break;
                        } else {
                            continue; // with the next try
                        }
                    } else {
                        // found one not in use so continue on
                        dwStatus = ERROR_SUCCESS;
                        break;
                    }
                }
            } else {
                dwStatus = ERROR_OUTOFMEMORY;
            }
        }
    } else {
        // file opened so continue
        dwStatus = ERROR_SUCCESS;
    }

    if (dwStatus == ERROR_SUCCESS) {
        // dump perflib key entires
        dwStatus = DumpPerflibEntries (hOutFile, &dwFirstExtCtrIndex);
    }

    if (dwStatus == ERROR_SUCCESS) {
        do {
            if (mszPerfServiceList != NULL) {
                HeapFree (GetProcessHeap(), 0, mszPerfServiceList);
                mszPerfServiceList = NULL;
            }

            if (mszNoPerfServiceList != NULL) {
                HeapFree (GetProcessHeap(), 0, mszNoPerfServiceList);
                mszNoPerfServiceList = NULL;
            }

            // build service lists
            dwPerfServiceListSize += 32768;
            dwNoPerfServiceListSize += 65536;
            mszPerfServiceList = HeapAlloc (
                GetProcessHeap(),
                HEAP_ZERO_MEMORY,
                (dwPerfServiceListSize) * sizeof(WCHAR));

            mszNoPerfServiceList = HeapAlloc (
                GetProcessHeap(),
                HEAP_ZERO_MEMORY,
                (dwNoPerfServiceListSize) * sizeof(WCHAR));

            if ((mszNoPerfServiceList == NULL) || (mszPerfServiceList  == NULL)) {
                dwStatus = ERROR_OUTOFMEMORY;
                break;
            }

            if (dwStatus == ERROR_SUCCESS) {
                dwStatus = BuildServiceLists (
                    mszPerfServiceList,
                    &dwPerfServiceListSize,
                    mszNoPerfServiceList,
                    &dwNoPerfServiceListSize);
                if (dwStatus == ERROR_SUCCESS) break; // and continue on
            }
        } while (dwPerfServiceListSize < 4194304);
    }

    // dump service entries for those services with perf counters
    if (dwStatus == ERROR_SUCCESS) {
        for (szThisServiceName = mszPerfServiceList;
            *szThisServiceName != 0;
            szThisServiceName += lstrlenW(szThisServiceName)+1) {

            dwStatus = DumpPerfServiceEntries (
                hOutFile,
                szThisServiceName);

            if (dwStatus != ERROR_SUCCESS) break;
        }
    }

    // dump perf string entries
    if (dwStatus == ERROR_SUCCESS) {
        // build Name table
        // get ENGLISH string list
        lpCounterText = BuildNameTable (
            HKEY_LOCAL_MACHINE, // use only local machine
            (LPWSTR)szLangId,		
            &dwLastElement);

        if (lpCounterText != NULL) {
            dwStatus = DumpNameTable (
                hOutFile,
                szLangId,
                lpCounterText,
                0,              // dump the entire table for complete restore
                dwLastElement
                );
        } else {
            dwStatus = GetLastError();
        }
    }

    // free buffers
    if (lpCounterText != NULL) {
        HeapFree (GetProcessHeap(), 0, lpCounterText);
        lpCounterText = NULL;
    }

    if (mszNoPerfServiceList != NULL) {
        HeapFree (GetProcessHeap(), 0, mszNoPerfServiceList);
        mszNoPerfServiceList = NULL;
    }

    if (mszPerfServiceList != NULL) {
        HeapFree (GetProcessHeap(), 0, mszPerfServiceList);
        mszPerfServiceList = NULL;
    }

    if (szNewFileName  != NULL) {
        HeapFree (GetProcessHeap(), 0, szNewFileName);
        szNewFileName = NULL;
    }

    // close file handles
    if (hOutFile != INVALID_HANDLE_VALUE) {
        CloseHandle (hOutFile);
    }

    return dwStatus;
}

DWORD
RestorePerfRegistryFromFileW (
    IN  LPCWSTR szFileName,
    IN  LPCWSTR szLangId
)
{
    LONG    lStatus = ERROR_SUCCESS;
    LONG    lEnumStatus = ERROR_SUCCESS;
    DWORD   dwServiceIndex = 0;
    WCHAR   szServiceSubKeyName[MAX_PATH];
    WCHAR   szPerfSubKeyName[MAX_PATH+20];
    DWORD   dwNameSize = MAX_PATH;
    HKEY    hKeyPerformance;
    HKEY    hKeyServices = NULL;
    HKEY    hKeyPerflib = NULL;
    DWORD   dwItemSize;
    DWORD   dwRegAccessMask;
    DWORD   dwRetStatus = ERROR_SUCCESS;
    UINT    nValue;
    DWORD   dwnValue;
    BOOL    bServiceRegistryOk = TRUE;

    WCHAR   wPerfSection[MAX_PATH * 2];

    LPWSTR  szLocalLangId;

    WinPerfStartTrace(NULL);

    if (szLangId == NULL) {
        szLocalLangId = (LPWSTR)L"009";
    } else {
        szLocalLangId = (LPWSTR)szLangId;
    }

    lStatus = RegOpenKeyExW (HKEY_LOCAL_MACHINE,
        cszServiceKeyName,
        0L,
        KEY_READ,
        &hKeyServices);

    if (lStatus == ERROR_SUCCESS) {
        // enum service list
        while ((lEnumStatus = RegEnumKeyExW (
            hKeyServices,
            dwServiceIndex,
            szServiceSubKeyName,
            &dwNameSize,
            NULL,
            NULL,
            NULL,
            NULL)) == ERROR_SUCCESS) {

            //try to open the perfkey under this key.
            lstrcpy (szPerfSubKeyName, szServiceSubKeyName);
            lstrcat (szPerfSubKeyName, cszPerformance);

            bServiceRegistryOk = TRUE;
            dwRegAccessMask = KEY_READ | KEY_WRITE;
            // look for a performance subkey
            lStatus = RegOpenKeyExW (
                hKeyServices,
                szPerfSubKeyName,
                0L,
                dwRegAccessMask,
                &hKeyPerformance);

            if (lStatus == ERROR_SUCCESS) {
                // key found so service has perf data
                // if performance subkey then
                dwItemSize = swprintf (wPerfSection,
                    cszFmtServiceSectionName, szServiceSubKeyName);
                // look into the file for a perf entry for this service
                nValue = GetPrivateProfileIntW (
                        wPerfSection,
                        cszFirstCounter,
                        -1,
                        szFileName);

                if (nValue != (UINT) -1) {
                    // if found in file then update registry with values from file
                    lStatus = RegSetValueExW (hKeyPerformance,
                            cszFirstCounter,
                            0L,
                            REG_DWORD,
                            (const BYTE *) & nValue,
                            sizeof(nValue));
                    dwnValue = nValue;
                    TRACE((WINPERF_DBG_TRACE_INFO),
                          (& LoadPerfGuid,
                           __LINE__,
                           LOADPERF_RESTOREPERFREGISTRYFROMFILEW,
                           ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                           lStatus,
                           TRACE_WSTR(szServiceSubKeyName),
                           TRACE_WSTR(cszFirstCounter),
                           TRACE_DWORD(dwnValue),
                           NULL));
                    // now read the other values
                } else {
                    // there's one or more missing entries so
                    // remove the whole entry
                    bServiceRegistryOk = FALSE;
                }

                // look into the file for a perf entry for this service
                nValue = GetPrivateProfileIntW (
                        wPerfSection,
                        cszFirstHelp,
                        -1,
                        szFileName);

                if (nValue != (UINT)-1) {
                    // if found in file then update registry with values from file
                    lStatus = RegSetValueExW (hKeyPerformance,
                            cszFirstHelp,
                            0L,
                            REG_DWORD,
                            (const BYTE *)&nValue,
                            sizeof(nValue));
                    dwnValue = nValue;
                    TRACE((WINPERF_DBG_TRACE_INFO),
                          (& LoadPerfGuid,
                           __LINE__,
                           LOADPERF_RESTOREPERFREGISTRYFROMFILEW,
                           ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                           lStatus,
                           TRACE_WSTR(szServiceSubKeyName),
                           TRACE_WSTR(cszFirstHelp),
                           TRACE_DWORD(dwnValue),
                           NULL));
                    // now read the other values
                } else {
                    // there's one or more missing entries so
                    // remove the whole entry
                    bServiceRegistryOk = FALSE;
                }

                // look into the file for a perf entry for this service
                nValue = GetPrivateProfileIntW (
                    wPerfSection,
                    cszLastCounter,
                    -1,
                    szFileName);

                if (nValue != (UINT)-1) {
                    // if found in file then update registry with values from file
                    lStatus = RegSetValueExW (hKeyPerformance,
                            cszLastCounter,
                            0L,
                            REG_DWORD,
                            (const BYTE *)&nValue,
                            sizeof(nValue));
                    dwnValue = nValue;
                    TRACE((WINPERF_DBG_TRACE_INFO),
                          (& LoadPerfGuid,
                           __LINE__,
                           LOADPERF_RESTOREPERFREGISTRYFROMFILEW,
                           ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                           lStatus,
                           TRACE_WSTR(szServiceSubKeyName),
                           TRACE_WSTR(cszLastCounter),
                           TRACE_DWORD(dwnValue),
                           NULL));
                    // now read the other values
                } else {
                    // there's one or more missing entries so
                    // remove the whole entry
                    bServiceRegistryOk = FALSE;
                }

                // look into the file for a perf entry for this service
                nValue = GetPrivateProfileIntW (
                    wPerfSection,
                    cszLastHelp,
                    -1,
                    szFileName);

                if (nValue != (UINT)-1) {
                    // if found in file then update registry with values from file
                    lStatus = RegSetValueExW (hKeyPerformance,
                            cszLastHelp,
                            0L,
                            REG_DWORD,
                            (const BYTE *)&nValue,
                            sizeof(nValue));
                    dwnValue = nValue;
                    TRACE((WINPERF_DBG_TRACE_INFO),
                          (& LoadPerfGuid,
                           __LINE__,
                           LOADPERF_RESTOREPERFREGISTRYFROMFILEW,
                           ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                           lStatus,
                           TRACE_WSTR(szServiceSubKeyName),
                           TRACE_WSTR(cszLastHelp),
                           TRACE_DWORD(dwnValue),
                           NULL));
                    // now read the other values
                } else {
                    // there's one or more missing entries so
                    // remove the whole entry
                    bServiceRegistryOk = FALSE;
                }

                if (!bServiceRegistryOk) {
                    // an error occurred so delete the first/last counter/help values
                    RegDeleteValue (hKeyPerformance, cszFirstCounter);
                    RegDeleteValue (hKeyPerformance, cszFirstHelp);
                    RegDeleteValue (hKeyPerformance, cszLastCounter);
                    RegDeleteValue (hKeyPerformance, cszLastHelp);
                } // else continiue

                RegCloseKey (hKeyPerformance);
            } // else this service has no perf data so skip
            else {
                TRACE((WINPERF_DBG_TRACE_ERROR),
                      (& LoadPerfGuid,
                       __LINE__,
                       LOADPERF_RESTOREPERFREGISTRYFROMFILEW,
                       ARG_DEF(ARG_TYPE_WSTR, 1),
                       lStatus,
                       TRACE_WSTR(szServiceSubKeyName),
                       NULL));
            }

            // reset for next loop
            dwServiceIndex++;
            dwNameSize = MAX_PATH;
        } // end enum service list
    }
    else {
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
               __LINE__,
               LOADPERF_RESTOREPERFREGISTRYFROMFILEW,
               ARG_DEF(ARG_TYPE_WSTR, 1),
               lStatus,
               TRACE_WSTR(cszServiceKeyName),
               NULL));
    }

    if (hKeyServices != NULL) RegCloseKey (hKeyServices);

    if (dwRetStatus == ERROR_SUCCESS) {
        // merge registry string values:
        dwRetStatus = UpdatePerfNameFilesX (
            szFileName, NULL,
            szLocalLangId,
            LODCTR_UPNF_RESTORE);

        if (dwRetStatus == ERROR_SUCCESS) {
            // update the keys in the registry

            lStatus = RegOpenKeyExW (HKEY_LOCAL_MACHINE,
                    cszPerflibKeyName,
                    0L,
                    KEY_ALL_ACCESS,
                    &hKeyPerflib);
            if (lStatus != ERROR_SUCCESS) {
                TRACE((WINPERF_DBG_TRACE_ERROR),
                      (& LoadPerfGuid,
                       __LINE__,
                       LOADPERF_RESTOREPERFREGISTRYFROMFILEW,
                       ARG_DEF(ARG_TYPE_WSTR, 1),
                       lStatus,
                       TRACE_WSTR(cszPerflibKeyName),
                       NULL));
            }

            if (lStatus == ERROR_SUCCESS) {
               nValue = GetPrivateProfileIntW (
                    cszPerflib,
                    cszLastCounter,
                    -1,
                    szFileName);

                if (nValue != (UINT)-1) {
                    // if found in file then update registry with values from file
                    lStatus = RegSetValueExW (hKeyPerflib,
                            cszLastCounter,
                            0L,
                            REG_DWORD,
                            (const BYTE *)&nValue,
                            sizeof(nValue));
                    dwnValue = nValue;
                    TRACE((WINPERF_DBG_TRACE_INFO),
                          (& LoadPerfGuid,
                           __LINE__,
                           LOADPERF_RESTOREPERFREGISTRYFROMFILEW,
                           ARG_DEF(ARG_TYPE_WSTR, 1),
                           lStatus,
                           TRACE_WSTR(cszLastCounter),
                           TRACE_DWORD(dwnValue),
                           NULL));
                }
            }

            if (lStatus == ERROR_SUCCESS) {
                // look into the file for a perf entry for this service
                nValue = GetPrivateProfileIntW (
                    cszPerflib,
                    cszLastHelp,
                    -1,
                    szFileName);

                if (nValue != (UINT)-1) {
                    // if found in file then update registry with values from file
                    lStatus = RegSetValueExW (hKeyPerflib,
                            cszLastHelp,
                            0L,
                            REG_DWORD,
                            (const BYTE *)&nValue,
                            sizeof(nValue));
                    dwnValue = nValue;
                    TRACE((WINPERF_DBG_TRACE_INFO),
                          (& LoadPerfGuid,
                           __LINE__,
                           LOADPERF_RESTOREPERFREGISTRYFROMFILEW,
                           ARG_DEF(ARG_TYPE_WSTR, 1),
                           lStatus,
                           TRACE_WSTR(cszLastHelp),
                           TRACE_DWORD(dwnValue),
                           NULL));
                }
            }

            if (lStatus == ERROR_SUCCESS) {
                // look into the file for a perf entry for this service
                nValue = GetPrivateProfileIntW (
                    cszPerflib,
                    cszBaseIndex,
                    -1,
                    szFileName);

                if (nValue != (UINT)-1) {
                    // if found in file then update registry with values from file
                    lStatus = RegSetValueExW (hKeyPerflib,
                            cszBaseIndex,
                            0L,
                            REG_DWORD,
                            (const BYTE *)&nValue,
                            sizeof(nValue));
                    dwnValue = nValue;
                    TRACE((WINPERF_DBG_TRACE_INFO),
                          (& LoadPerfGuid,
                           __LINE__,
                           LOADPERF_RESTOREPERFREGISTRYFROMFILEW,
                           ARG_DEF(ARG_TYPE_WSTR, 1),
                           lStatus,
                           TRACE_WSTR(cszBaseIndex),
                           TRACE_DWORD(dwnValue),
                           NULL));
                }
            }

            if (hKeyPerflib != NULL) RegCloseKey (hKeyPerflib);
        }
        dwRetStatus = lStatus;
    }

    return dwRetStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cntrtext\common\unlodctr.h ===
/*++

unlodctr.h

    Definitions that are specific to the counter unloader
   
Author:

    Bob Watson (a-robw) 12 Feb 93

Revision History:

--*/
#ifndef _UNLODCTR_H_
#define _UNLODCTR_H_

// resource file constants
#define UC_CMD_HELP_1       401
#define UC_CMD_HELP_2       402
#define UC_CMD_HELP_3       403
#define UC_CMD_HELP_4       404
#define UC_CMD_HELP_5       405
#define UC_CMD_HELP_6       406
#define UC_CMD_HELP_7       407
#define UC_CMD_HELP_8       408
#define UC_CMD_HELP_9       409
#define UC_CMD_HELP_10      410
#define UC_CMD_HELP_11      411
#define UC_FIRST_CMD_HELP   UC_CMD_HELP_1
#define UC_LAST_CMD_HELP    UC_CMD_HELP_11
                           
#define UC_DRIVERNOTFOUND   311
#define UC_NOTINSTALLED     312
#define UC_REMOVINGDRIVER   313
#define UC_UNABLEOPENKEY    314
#define UC_UNABLESETVALUE   315
#define UC_UNABLEREADVALUE  316
#define UC_DOINGLANG        318
#define UC_UNABLELOADLANG   320 
#define UC_CONNECT_PROBLEM  322
#define UC_BAD_DRIVER_NAME  323

#endif // _UNLODCTR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cntrtext\common\wbemutil.c ===
/*
	WbemUtil.C

	functions and definitions used to access WBEM perf 
	data

*/
#include <windows.h>
#include <rpc.h>
#include <ntprfctr.h>
#include <stdio.h>
#include <assert.h>
#include "wbemutil.h"

const PERFTYPE_LOOKUP PerfTypeTable[] = 
{
	{PERF_100NSEC_MULTI_TIMER,      (LPWSTR)L"uint64"	,(LPWSTR)L"real64"},
	{PERF_100NSEC_MULTI_TIMER_INV,  (LPWSTR)L"uint64"	,(LPWSTR)L"real64"},
	{PERF_100NSEC_TIMER,            (LPWSTR)L"uint64"	,(LPWSTR)L"real64"},
	{PERF_100NSEC_TIMER_INV,        (LPWSTR)L"uint64"	,(LPWSTR)L"real64"},
	{PERF_AVERAGE_BASE,             (LPWSTR)L"uint32"	,(LPWSTR)L""},
	{PERF_AVERAGE_BULK,             (LPWSTR)L"uint64"	,(LPWSTR)L"real64"},
	{PERF_AVERAGE_TIMER,            (LPWSTR)L"uint32"	,(LPWSTR)L"real64"},
	{PERF_COUNTER_BULK_COUNT,       (LPWSTR)L"uint64"	,(LPWSTR)L"real64"},
	{PERF_COUNTER_COUNTER,          (LPWSTR)L"uint32"	,(LPWSTR)L"real64"},
	{PERF_COUNTER_DELTA,            (LPWSTR)L"uint32"	,(LPWSTR)L"uint32"},
	{PERF_COUNTER_HISTOGRAM_TYPE,   (LPWSTR)L""        ,(LPWSTR)L""},
	{PERF_COUNTER_LARGE_DELTA,      (LPWSTR)L"uint64"	,(LPWSTR)L"uint64"},
	{PERF_COUNTER_LARGE_QUEUELEN_TYPE, (LPWSTR)L"uint64"	,(LPWSTR)L"real64"},
	{PERF_COUNTER_LARGE_RAWCOUNT,   (LPWSTR)L"uint64"	,(LPWSTR)L"uint64"},
	{PERF_COUNTER_LARGE_RAWCOUNT_HEX, (LPWSTR)L"uint64",(LPWSTR)L"uint64"},
	{PERF_COUNTER_MULTI_BASE,       (LPWSTR)L"uint64"  ,(LPWSTR)L""},
	{PERF_COUNTER_MULTI_TIMER,      (LPWSTR)L"uint64"	,(LPWSTR)L"real64"},
	{PERF_COUNTER_MULTI_TIMER_INV,  (LPWSTR)L"uint64"	,(LPWSTR)L"real64"},
	{PERF_COUNTER_NODATA,           (LPWSTR)L""        ,(LPWSTR)L""},
	{PERF_COUNTER_QUEUELEN_TYPE,    (LPWSTR)L"uint32"	,(LPWSTR)L"real64"},
	{PERF_COUNTER_RAWCOUNT,         (LPWSTR)L"uint32"	,(LPWSTR)L"uint32"},
	{PERF_COUNTER_RAWCOUNT_HEX,     (LPWSTR)L"uint32"	,(LPWSTR)L"uint32"},
	{PERF_COUNTER_TEXT,             (LPWSTR)L"string"	,(LPWSTR)L"string"},
	{PERF_COUNTER_TIMER,            (LPWSTR)L"uint64"	,(LPWSTR)L"real64"},
	{PERF_COUNTER_TIMER_INV,        (LPWSTR)L"uint64"	,(LPWSTR)L"real64"},
	{PERF_ELAPSED_TIME,             (LPWSTR)L"uint64"	,(LPWSTR)L"real64"},
	{PERF_RAW_BASE,                 (LPWSTR)L"uint32"	,(LPWSTR)L""},
	{PERF_RAW_FRACTION,             (LPWSTR)L"uint32"	,(LPWSTR)L"real64"},
	{PERF_SAMPLE_FRACTION,          (LPWSTR)L"uint32"	,(LPWSTR)L"real64"},
	{PERF_SAMPLE_BASE,              (LPWSTR)L"uint32"	,(LPWSTR)L""},
	{PERF_SAMPLE_COUNTER,           (LPWSTR)L"uint32"	,(LPWSTR)L"real64"},
	{PERF_COUNTER_100NS_QUEUELEN_TYPE, (LPWSTR)L"uint64"	,(LPWSTR)L"real64"},
	{PERF_COUNTER_OBJ_TIME_QUEUELEN_TYPE, (LPWSTR)L"uint64"	,(LPWSTR)L"real64"},
	{PERF_OBJ_TIME_TIMER,           (LPWSTR)L"uint64"	,(LPWSTR)L"real64"},
	{PERF_LARGE_RAW_BASE,           (LPWSTR)L"uint64"	,(LPWSTR)L""},
	{PERF_LARGE_RAW_FRACTION,       (LPWSTR)L"uint64"	,(LPWSTR)L"real64"},
	{PERF_PRECISION_SYSTEM_TIMER,   (LPWSTR)L"uint64"	,(LPWSTR)L"real64"},
	{PERF_PRECISION_100NS_TIMER,    (LPWSTR)L"uint64"	,(LPWSTR)L"real64"},
	{PERF_PRECISION_OBJECT_TIMER,   (LPWSTR)L"uint64"	,(LPWSTR)L"real64"}
};

const PPERFTYPE_LOOKUP PerfTypes = (const PPERFTYPE_LOOKUP)&PerfTypeTable[0];
const DWORD			 dwNumPerfTypes = (sizeof(PerfTypeTable) / sizeof(PerfTypeTable[0]));

const PERFOBJECT_LOOKUP PerfObjectGuidTable[] = 
{
     {SYSTEM_OBJECT_TITLE_INDEX,         (LPWSTR)L"{5C7A4F5C-9E4D-11d1-BB3C-00A0C913CAD4}"},
     {PROCESSOR_OBJECT_TITLE_INDEX,      (LPWSTR)L"{5C7A4F5D-9E4D-11d1-BB3C-00A0C913CAD4}"},
     {MEMORY_OBJECT_TITLE_INDEX,         (LPWSTR)L"{5C7A4F5E-9E4D-11d1-BB3C-00A0C913CAD4}"},
     {CACHE_OBJECT_TITLE_INDEX,          (LPWSTR)L"{5C7A4F5F-9E4D-11d1-BB3C-00A0C913CAD4}"},
     {PHYSICAL_DISK_OBJECT_TITLE_INDEX,  (LPWSTR)L"{5C7A4F60-9E4D-11d1-BB3C-00A0C913CAD4}"},
     {LOGICAL_DISK_OBJECT_TITLE_INDEX,   (LPWSTR)L"{5C7A4F61-9E4D-11d1-BB3C-00A0C913CAD4}"},
     {PROCESS_OBJECT_TITLE_INDEX,        (LPWSTR)L"{5C7A4F62-9E4D-11d1-BB3C-00A0C913CAD4}"},
     {THREAD_OBJECT_TITLE_INDEX,         (LPWSTR)L"{5C7A4F63-9E4D-11d1-BB3C-00A0C913CAD4}"},
     {OBJECT_OBJECT_TITLE_INDEX,         (LPWSTR)L"{5C7A4F64-9E4D-11d1-BB3C-00A0C913CAD4}"},
     {REDIRECTOR_OBJECT_TITLE_INDEX,     (LPWSTR)L"{5C7A4F65-9E4D-11d1-BB3C-00A0C913CAD4}"},
     {SERVER_OBJECT_TITLE_INDEX,         (LPWSTR)L"{5C7A4F66-9E4D-11d1-BB3C-00A0C913CAD4}"},
     {SERVER_QUEUE_OBJECT_TITLE_INDEX,   (LPWSTR)L"{5C7A4F67-9E4D-11d1-BB3C-00A0C913CAD4}"},
     {PAGEFILE_OBJECT_TITLE_INDEX,       (LPWSTR)L"{5C7A4F68-9E4D-11d1-BB3C-00A0C913CAD4}"},
     {BROWSER_OBJECT_TITLE_INDEX,        (LPWSTR)L"{5C7A4F69-9E4D-11d1-BB3C-00A0C913CAD4}"},
     {EXPROCESS_OBJECT_TITLE_INDEX,      (LPWSTR)L"{5C7A4F6A-9E4D-11d1-BB3C-00A0C913CAD4}"},
     {IMAGE_OBJECT_TITLE_INDEX,          (LPWSTR)L"{5C7A4F6B-9E4D-11d1-BB3C-00A0C913CAD4}"},
     {THREAD_DETAILS_OBJECT_TITLE_INDEX, (LPWSTR)L"{5C7A4F6C-9E4D-11d1-BB3C-00A0C913CAD4}"},
     {LONG_IMAGE_OBJECT_TITLE_INDEX,     (LPWSTR)L"{5C7A4F6D-9E4D-11d1-BB3C-00A0C913CAD4}"},
     {TCP_OBJECT_TITLE_INDEX,            (LPWSTR)L"{5C7A4F6E-9E4D-11d1-BB3C-00A0C913CAD4}"},
     {UDP_OBJECT_TITLE_INDEX,            (LPWSTR)L"{5C7A4F6F-9E4D-11d1-BB3C-00A0C913CAD4}"},
     {IP_OBJECT_TITLE_INDEX,             (LPWSTR)L"{5C7A4F70-9E4D-11d1-BB3C-00A0C913CAD4}"},
     {ICMP_OBJECT_TITLE_INDEX,           (LPWSTR)L"{5C7A4F71-9E4D-11d1-BB3C-00A0C913CAD4}"},
     {NET_OBJECT_TITLE_INDEX,            (LPWSTR)L"{5C7A4F72-9E4D-11d1-BB3C-00A0C913CAD4}"},
     {NBT_OBJECT_TITLE_INDEX,            (LPWSTR)L"{5C7A4F73-9E4D-11d1-BB3C-00A0C913CAD4}"},
    {NBF_OBJECT_TITLE_INDEX,            (LPWSTR)L"{5C7A4F74-9E4D-11d1-BB3C-00A0C913CAD4}"},
    {NBF_RESOURCE_OBJECT_TITLE_INDEX,   (LPWSTR)L"{5C7A4F75-9E4D-11d1-BB3C-00A0C913CAD4}"},
    {FTP_FIRST_COUNTER_INDEX,           (LPWSTR)L"{5C7A4F76-9E4D-11d1-BB3C-00A0C913CAD4}"},
    {RAS_FIRST_COUNTER_INDEX,           (LPWSTR)L"{5C7A4F77-9E4D-11d1-BB3C-00A0C913CAD4}"},
    {WIN_FIRST_COUNTER_INDEX,           (LPWSTR)L"{5C7A4F78-9E4D-11d1-BB3C-00A0C913CAD4}"},
    {SFM_FIRST_COUNTER_INDEX,           (LPWSTR)L"{5C7A4F79-9E4D-11d1-BB3C-00A0C913CAD4}"},
    {ATK_FIRST_COUNTER_INDEX,           (LPWSTR)L"{5C7A4F7A-9E4D-11d1-BB3C-00A0C913CAD4}"},
    {BH_FIRST_COUNTER_INDEX,            (LPWSTR)L"{5C7A4F7B-9E4D-11d1-BB3C-00A0C913CAD4}"},
    {TAPI_FIRST_COUNTER_INDEX,          (LPWSTR)L"{5C7A4F7C-9E4D-11d1-BB3C-00A0C913CAD4}"},
    {LSPL_FIRST_COUNTER_INDEX,          (LPWSTR)L"{5C7A4F7D-9E4D-11d1-BB3C-00A0C913CAD4}"},
     {JOB_OBJECT_TITLE_INDEX,            (LPWSTR)L"{5C7A4F7E-9E4D-11d1-BB3C-00A0C913CAD4}"},
     {JOB_DETAILS_OBJECT_TITLE_INDEX,    (LPWSTR)L"{5C7A4F7F-9E4D-11d1-BB3C-00A0C913CAD4}"}
//    {RSVP_FIRST_COUNTER_INDEX,          (LPWSTR)L"{5C7A4F80-9E4D-11d1-BB3C-00A0C913CAD4}"}
};

const PPERFOBJECT_LOOKUP PerfObjectGuids = (const PPERFOBJECT_LOOKUP)&PerfObjectGuidTable[0];
const DWORD				dwNumPerfObjectGuids = (sizeof(PerfObjectGuidTable) / sizeof(PerfObjectGuidTable[0]));

LPCWSTR szRawClass = (LPCWSTR)L"Win32_PerfRawData";
LPCWSTR szFmtClass = (LPCWSTR)L"Win32_PerfFormattedData";
LPCWSTR szGenericProviderName = (LPCWSTR)L"NT5_GenericPerfProvider_V1";
LPCWSTR szGenericProviderGuid = (LPCWSTR)L"{FF37A93C-C28E-11D1-AEB6-00C04FB68820}";

__inline
static
PPERF_OBJECT_TYPE
FirstObject (
    PPERF_DATA_BLOCK pPerfData
)
{
    return ((PPERF_OBJECT_TYPE) ((PBYTE) pPerfData + pPerfData->HeaderLength));
}


__inline
static
PPERF_OBJECT_TYPE
NextObject (
    PPERF_OBJECT_TYPE pObject
)
{  // NextObject
    return ((PPERF_OBJECT_TYPE) ((PBYTE) pObject + pObject->TotalByteLength));
}  // NextObject

__inline
static
PERF_COUNTER_DEFINITION *
FirstCounter(
    PERF_OBJECT_TYPE *pObjectDef
)
{
    return (PERF_COUNTER_DEFINITION *)
               ((PCHAR) pObjectDef + pObjectDef->HeaderLength);
}

__inline
static
PERF_COUNTER_DEFINITION *
NextCounter(
    PERF_COUNTER_DEFINITION *pCounterDef
)
{
    return (PERF_COUNTER_DEFINITION *)
               ((PCHAR) pCounterDef + pCounterDef->ByteLength);
}

__inline
static
PERF_INSTANCE_DEFINITION *
FirstInstance(
    PERF_OBJECT_TYPE * pObjectDef)
{
    return (PERF_INSTANCE_DEFINITION * )
               ((PCHAR) pObjectDef + pObjectDef->DefinitionLength);
}

__inline
static
PERF_INSTANCE_DEFINITION *
NextInstance(
    PERF_INSTANCE_DEFINITION * pInstDef)
{
    PERF_COUNTER_BLOCK *pCounterBlock;

    pCounterBlock = (PERF_COUNTER_BLOCK *)
                        ((PCHAR) pInstDef + pInstDef->ByteLength);

    return (PERF_INSTANCE_DEFINITION * )
               ((PCHAR) pCounterBlock + pCounterBlock->ByteLength);
}

__inline
static
LPCWSTR
GetInstanceName(
    PERF_INSTANCE_DEFINITION *pInstDef
)
{
    static WCHAR    szLocalName[MAX_PATH];
    LPWSTR  szSrc, szDest;

    assert ((pInstDef->NameLength) < (MAX_PATH * sizeof(WCHAR)));
    szDest = &szLocalName[0];
    szSrc = (LPWSTR) ((PCHAR) pInstDef + pInstDef->NameOffset); 

    while (*szSrc != 0) {
        switch (*szSrc) {
        case '\\':
            *szDest++ = *szSrc;
            *szDest++ = *szSrc++;
            break;

        default:
            *szDest++ = *szSrc++;
        };
    }
    *szDest++ = 0;

    return (LPCWSTR)&szLocalName[0];
}

static
__inline
DWORD
AddStringToBuffer (
	LPWSTR szBuffer, 
	LPWSTR szNewString,
	LPDWORD pLength, 
	LPDWORD pTotalLength, 
	DWORD dwMaxLength
)
{
	DWORD	dwReturn = ERROR_SUCCESS;
	if ((*pTotalLength + *pLength) < dwMaxLength) {
		memcpy (&szBuffer[*pTotalLength], szNewString, (*pLength * sizeof(WCHAR)));
		*pTotalLength += *pLength;
		szBuffer[*pTotalLength] = 0;
	} else {
		*pTotalLength += *pLength;
		dwReturn = ERROR_INSUFFICIENT_BUFFER;
	}

	return dwReturn;
}

LPCWSTR 
FormatPerfName (
    LPWSTR  szNameIn,
    BOOL    bHiddenCounter
)
{
    static WCHAR szStringBuffer[MAX_PATH];
    LPWSTR  szSrc, szDest;
    BOOL    bUpCase = FALSE;

    memset(szStringBuffer, 0, sizeof(szStringBuffer));
    szDest = &szStringBuffer[0];

    if (szNameIn != NULL) {
        for (szSrc = szNameIn; *szSrc != 0; szSrc++) {
            switch (*szSrc) {
                case '%':
                    lstrcpyW(szDest, (LPCWSTR)L"Percent");
                    szDest += lstrlenW((LPCWSTR)L"Percent");
                    bUpCase = TRUE;
                    break;
                case '#':
                    lstrcpyW(szDest, (LPCWSTR)L"NumberOf");
                    szDest += lstrlenW((LPCWSTR)L"NumberOf");
                    bUpCase = TRUE;
                    break;
                case '/':
                    lstrcpyW(szDest, (LPCWSTR)L"Per");
                    szDest += lstrlenW((LPCWSTR)L"Per");
                    bUpCase = TRUE;
                    break;
                case ' ':
                case ')':
                case '(':
                case '.':
                case '-':
                    // skip
                    bUpCase = TRUE;
                    break;
                default:
                    if (bUpCase) {
                        *szDest++ = towupper(*szSrc);
                        bUpCase = FALSE;
                    } else {
                        *szDest++ = *szSrc;
                    }
                    break;
            }
        }
        if (bHiddenCounter) {
            lstrcpyW (szDest, (LPCWSTR)L"_Base");
            szDest += lstrlenW((LPCWSTR)L"_Base");
        }
    }
    *szDest = 0;
    
    return (LPCWSTR)&szStringBuffer[0];
}

PERFTYPE_LOOKUP *
GetPerfTypeInfo (
    DWORD dwType
)
{
    DWORD   dwIndex = 0;
    
    while (dwIndex < dwNumPerfTypes) {
        if (dwType == (DWORD)PerfTypes[dwIndex].PerfType) {
            return (&PerfTypes[dwIndex]);
        } else {
            dwIndex++;
        }
    }
    return NULL;
}

LPCWSTR
GetPerfObjectGuid (
    DWORD dwObjectId
)
{
    DWORD   dwIndex = 0;
    
    while (dwIndex < dwNumPerfObjectGuids) {
        if (dwObjectId == (DWORD)PerfObjectGuids[dwIndex].PerfObjectId) {
            return ((LPCWSTR)PerfObjectGuids[dwIndex].GuidString);
        } else {
            dwIndex++;
        }
    }
    return (LPCWSTR)L"";
}

DWORD
GenerateMofHeader (
	LPWSTR	szBuffer,			// string buffer
	LPCWSTR	szComputerName,
	LPDWORD	pcchBufferSize		// max size in characters in, size used out
)
{
    WCHAR   szMachineName[MAX_PATH];
	WCHAR	szTempBuffer[MAX_PATH];
	DWORD	dwTotalLength = 0;
    DWORD   dwLength = sizeof(szMachineName)/sizeof(szMachineName[0]);
    SYSTEMTIME  st;
	DWORD	dwReturn = ERROR_SUCCESS;

    if (szComputerName == NULL) {
		GetComputerNameW(&szMachineName[0], &dwLength);
	} else if (szComputerName[0] == 0){
		GetComputerNameW(&szMachineName[0], &dwLength);
	} else {
		lstrcpyW (szMachineName, szComputerName);
	}

    GetLocalTime( &st );

    dwLength = swprintf (szTempBuffer, (LPCWSTR)L"\x0D\x0A//WBEM Performance Data MOF Dumped from machine %ws on %2.2d/%2.2d/%2.2d %2.2d:%2.2d:%2.2d\x0D\x0A",
        szMachineName,
        st.wMonth, st.wDay, (st.wYear % 100),
        st.wHour, st.wMinute, st.wSecond);
	dwReturn = AddStringToBuffer (
		szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);

    dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"\x0D\x0A#pragma autorecover");
	dwReturn = AddStringToBuffer (
		szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);

    dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"\x0D\x0A#pragma namespace (\"\\\\\\\\.\\\\Root\\\\Default\")");
	dwReturn = AddStringToBuffer (
		szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);

    dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"\x0D\x0A#pragma classflags(\"forceupdate\")\x0D\x0A");
	dwReturn = AddStringToBuffer (
		szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);

    dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"\x0D\x0Aqualifier vendor:ToInstance;");
	dwReturn = AddStringToBuffer (
		szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);

    dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"\x0D\x0Aqualifier classguid:ToInstance;");
	dwReturn = AddStringToBuffer (
		szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);

    dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"\x0D\x0Aqualifier locale:ToInstance;");
	dwReturn = AddStringToBuffer (
		szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);

    dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"\x0D\x0Aqualifier display:ToInstance;");
	dwReturn = AddStringToBuffer (
		szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);

    dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"\x0D\x0Aqualifier perfindex:ToInstance;");
	dwReturn = AddStringToBuffer (
		szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);

    dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"\x0D\x0Aqualifier helpindex:ToInstance;");
	dwReturn = AddStringToBuffer (
		szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);

    dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"\x0D\x0Aqualifier perfdetail:ToInstance;");
	dwReturn = AddStringToBuffer (
		szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);

    dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"\x0D\x0Aqualifier countertype:ToInstance;");
	dwReturn = AddStringToBuffer (
		szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);

	dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"\x0D\x0Aqualifier perfdefault:ToInstance;");
	dwReturn = AddStringToBuffer (
		szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);

	dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"\x0D\x0Aqualifier defaultscale:ToInstance;");
	dwReturn = AddStringToBuffer (
		szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);

    dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"\x0D\x0A");
	dwReturn = AddStringToBuffer (
		szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);

	*pcchBufferSize = dwTotalLength;
	return dwReturn;
}

DWORD
GenerateMofObject (
	LPWSTR				szBuffer,
	LPDWORD				pcchBufferSize,
	PPERF_COUNTER_DLL_INFO	pPcDllInfo,
    PERF_OBJECT_TYPE    *pPerfObject,
	LPWSTR				*lpCounterText,	// name strings array
	LPWSTR				*lpDisplayText, // Localized name strings array
	DWORD				dwFlags
)
{
    BOOL                bRawDefinition = (dwFlags & WM_GMO_RAW_DEFINITION);
    BOOL                bCostlyObject = (dwFlags & WM_GMO_COSTLY_OBJECT);
	BOOL				bDefaultObject = (dwFlags & WM_GMO_DEFAULT_OBJECT); 

	WCHAR	szTempBuffer[MAX_PATH];
	DWORD	dwTotalLength = 0;
    DWORD   dwLength;
	DWORD	dwReturn = ERROR_SUCCESS;

    dwLength = swprintf (szTempBuffer, (LPCWSTR)L"\x0D\x0A\x0D\x0A[");
	dwReturn = AddStringToBuffer (
		szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);

    if (pPerfObject->NumInstances == PERF_NO_INSTANCES) {
        dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"\x0D\x0A singleton,");
		dwReturn = AddStringToBuffer (
			szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);
    }
    if (bCostlyObject) {
        dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"\x0D\x0A costly,");
		dwReturn = AddStringToBuffer (
			szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);
    }
	if (bDefaultObject) {
		dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"\x0D\x0A perfdefault,");
		dwReturn = AddStringToBuffer (
			szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);

	}

	if (pPcDllInfo != NULL) {
		dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"\x0D\x0A dynamic,");
		dwReturn = AddStringToBuffer (
			szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);
	
		if ((dwReturn == ERROR_SUCCESS) && (pPcDllInfo->szWbemProviderName != NULL)) {
			dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"\x0D\x0A provider(\"%s\"),",
				szGenericProviderName);
			dwReturn = AddStringToBuffer (
				szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);
		} else {
			// if this structure is used, all fields must be present
			dwReturn = ERROR_INVALID_PARAMETER;
		}

		if ((dwReturn == ERROR_SUCCESS) && (pPcDllInfo->szRegistryKey != NULL)) {
			dwLength = swprintf (szTempBuffer, (LPCWSTR)L"\x0D\x0A registrykey(\"%s\"),",
				pPcDllInfo->szRegistryKey);
			dwReturn = AddStringToBuffer (
				szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);
		} else {
			// if this structure is used, all fields must be present
			dwReturn = ERROR_INVALID_PARAMETER;
		}

		if ((dwReturn == ERROR_SUCCESS) && (pPcDllInfo->szClassGuid != NULL)) {
            if (pPcDllInfo->szClassGuid[0] != 0) {
			    dwLength = swprintf (szTempBuffer, (LPCWSTR)L"\x0D\x0A classguid(\"%s\"),",
				    pPcDllInfo->szClassGuid);
			    dwReturn = AddStringToBuffer (
				    szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);
            }
		} else {
			// if this structure is used, all fields must be present
			dwReturn = ERROR_INVALID_PARAMETER;
		}
	}
	
    dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"\x0D\x0A locale(\"0x%4.4x\"),", (GetSystemDefaultLCID() & 0x0000FFFF));
	dwReturn = AddStringToBuffer (
		szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);

    dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"\x0D\x0A display(\"%ws\"),", 
		lpDisplayText[pPerfObject->ObjectNameTitleIndex]);
	dwReturn = AddStringToBuffer (
		szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);

    dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"\x0D\x0A perfindex(%d),", pPerfObject->ObjectNameTitleIndex);
	dwReturn = AddStringToBuffer (
		szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);

    dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"\x0D\x0A helpindex(%d),", pPerfObject->ObjectHelpTitleIndex);
	dwReturn = AddStringToBuffer (
		szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);

    dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"\x0D\x0A perfdetail(%d)", pPerfObject->DetailLevel);
	dwReturn = AddStringToBuffer (
		szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);

    dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"\x0D\x0A]%sclass Win32Perf_%ws%ws : %ws\x0D\x0A{",
		(LPCWSTR)L"\x0D\x0A", (bRawDefinition ? (LPCWSTR)L"Raw" : (LPCWSTR)L""),
        FormatPerfName(lpCounterText[pPerfObject->ObjectNameTitleIndex],FALSE), 
        (bRawDefinition ? szRawClass : szFmtClass));
	dwReturn = AddStringToBuffer (
		szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);

    // add an entry for the instance name here if the object has instances
    if (pPerfObject->NumInstances != PERF_NO_INSTANCES) {
        dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"\x0D\x0A    [key]\x0D\x0A    string\tName;");
		dwReturn = AddStringToBuffer (
			szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);
    }

	*pcchBufferSize = dwTotalLength;
	return dwReturn;
}

DWORD
GenerateMofObjectTail (
	LPWSTR				szBuffer,
	LPDWORD				pcchBufferSize
)
{
	WCHAR	szTempBuffer[MAX_PATH];
	DWORD	dwTotalLength = 0;
    DWORD   dwLength;
	DWORD	dwReturn = ERROR_SUCCESS;

    dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"\x0D\x0A};\x0D\x0A");
	dwReturn = AddStringToBuffer (
		szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);

	*pcchBufferSize = dwTotalLength;
	return dwReturn;
}

DWORD
GenerateMofCounter (
	LPWSTR					szBuffer,
	LPDWORD					pcchBufferSize,
    PERF_COUNTER_DEFINITION *pPerfCounter,
	LPWSTR				*lpCounterText,	// name strings array
	LPWSTR				*lpDisplayText, // Localized name strings array
	DWORD				dwFlags
)
{
	WCHAR	szTempBuffer[MAX_PATH];
	DWORD	dwTotalLength = 0;
    DWORD   dwLength;
	DWORD	dwReturn = ERROR_SUCCESS;

    BOOL                bRawDefinition = (dwFlags & WM_GMO_RAW_DEFINITION);
    BOOL                bDefaultCounter = (dwFlags & WM_GMO_DEFAULT_COUNTER);
    PERFTYPE_LOOKUP		*pType;

    pType = GetPerfTypeInfo (pPerfCounter->CounterType);
	
	if (pType != NULL) {
		if (bRawDefinition || IsDisplayableType(pPerfCounter->CounterType)) {
			dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"\x0D\x0A    [");
			dwReturn = AddStringToBuffer (
				szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);

			if (bDefaultCounter) {
				dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"\x0D\x0A     perfdefault,");
				dwReturn = AddStringToBuffer (
					szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);
			}
			dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"\x0D\x0A     display(\"%ws\"),", 
				lpDisplayText[pPerfCounter->CounterNameTitleIndex]);
			dwReturn = AddStringToBuffer (
				szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);

			dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"\x0D\x0A     countertype(%u),", pPerfCounter->CounterType);
			dwReturn = AddStringToBuffer (
				szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);

			dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"\x0D\x0A     perfindex(%d),", pPerfCounter->CounterNameTitleIndex);
			dwReturn = AddStringToBuffer (
				szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);

			dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"\x0D\x0A     helpindex(%d),", pPerfCounter->CounterHelpTitleIndex);
			dwReturn = AddStringToBuffer (
				szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);

			dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"\x0D\x0A     defaultscale(%d),", pPerfCounter->DefaultScale);
			dwReturn = AddStringToBuffer (
				szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);

			dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"\x0D\x0A     perfdetail(%d)", pPerfCounter->DetailLevel);
			dwReturn = AddStringToBuffer (
				szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);

			dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"\x0D\x0A    ]\x0D\x0A    %ws\t%ws;\x0D\x0A",
				(bRawDefinition ? pType->RawType : pType->FmtType),
				 FormatPerfName (lpCounterText[pPerfCounter->CounterNameTitleIndex],
					(IsDisplayableType(pPerfCounter->CounterType) ? FALSE : TRUE)));
			dwReturn = AddStringToBuffer (
				szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);
			// return size used
			*pcchBufferSize = dwTotalLength;
		}
	} else {
		dwReturn = ERROR_FILE_NOT_FOUND;
	}

	return dwReturn;
}

DWORD
GenerateMofInstances (
	LPWSTR					szBuffer,
	LPDWORD					pcchBufferSize,
    PERF_DATA_BLOCK		*   pPerfDataBlock,
    PERF_OBJECT_TYPE	*   pPerfObject,
	LPWSTR				*	lpCounterText,	// name strings array
	LPWSTR				*	lpDisplayText, // Localized name strings array
	DWORD					dwFlags
)
{
	WCHAR	szTempBuffer[MAX_PATH];
	DWORD	dwTotalLength = 0;
    DWORD   dwLength;
	DWORD	dwReturn = ERROR_SUCCESS;

    BOOL bRawDefinition = (dwFlags & WM_GMO_RAW_DEFINITION);
    //
    //  for each instance, dump all the counter data for that instance
    //
    PERF_INSTANCE_DEFINITION *  pThisInstance;
    PERF_INSTANCE_DEFINITION *  pParentInstance;
    PERF_OBJECT_TYPE *          pParentObject;
    PERF_COUNTER_DEFINITION  *  pThisCounter;
    DWORD   dwParentInstIdx;
    DWORD   dwObjectIdx;
    DWORD   dwInstanceIndex;
    DWORD   dwCounterCount;
    LPDWORD   pValue;
    LONGLONG 	llTimeStamp;

    UNREFERENCED_PARAMETER (lpDisplayText);

    if (pPerfObject->NumInstances == PERF_NO_INSTANCES) {
        dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"\x0D\x0A\x0D\x0Ainstance of Win32Perf_%ws%ws\x0D\x0A{",
            (bRawDefinition ? (LPCWSTR)L"Raw" : (LPCWSTR)L""),
            FormatPerfName(lpCounterText[pPerfObject->ObjectNameTitleIndex], FALSE));
		dwReturn = AddStringToBuffer (
			szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);

		GetSystemTimeAsFileTime ((LPFILETIME)&llTimeStamp);
		dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"\x0D\x0A    Timestamp = ");
		dwReturn = AddStringToBuffer (
			szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);

		pValue = (LPDWORD)&llTimeStamp;
        pValue++;
        dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"0x%8.8x", *pValue);
		dwReturn = AddStringToBuffer (
			szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);

        pValue--;
        dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"%8.8x;", *pValue);
		dwReturn = AddStringToBuffer (
			szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);


        pThisCounter = FirstCounter(pPerfObject);
        assert (pThisCounter != NULL);
        for (dwCounterCount = 0; dwCounterCount < pPerfObject->NumCounters; dwCounterCount++) {
            dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"\x0D\x0A    %ws = ", 
                 FormatPerfName (lpCounterText[pThisCounter->CounterNameTitleIndex],
                    (IsDisplayableType(pThisCounter->CounterType) ? FALSE : TRUE)));
			dwReturn = AddStringToBuffer (
				szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);

            pValue = (LPDWORD)pPerfObject;
            pValue = (LPDWORD)((LPBYTE)pValue + pPerfObject->DefinitionLength);
            pValue = (LPDWORD)((LPBYTE)pValue + pThisCounter->CounterOffset);

            if (pThisCounter->CounterSize == 8) {
                pValue++;
                dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"0x%8.8x", *pValue);
				dwReturn = AddStringToBuffer (
					szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);

                pValue--;
                dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"%8.8x;", *pValue);
				dwReturn = AddStringToBuffer (
					szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);

            } else {
                dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"0x%8.8x;", *pValue);
				dwReturn = AddStringToBuffer (
					szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);

            }
            pThisCounter = NextCounter (pThisCounter);
        }
        dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"\x0D\x0A};\x0D\x0A");
		dwReturn = AddStringToBuffer (
			szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);

    } else {
        // do the multiple instance case here
        pThisInstance = FirstInstance(pPerfObject);
        for (dwInstanceIndex = 0; dwInstanceIndex < (DWORD)pPerfObject->NumInstances; dwInstanceIndex++)  {
            dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"\x0D\x0A\x0D\x0Ainstance of Win32Perf_%ws%ws\x0D\x0A{",
                (bRawDefinition ? (LPCWSTR)L"Raw" : (LPCWSTR)L""),
                FormatPerfName(lpCounterText[pPerfObject->ObjectNameTitleIndex],FALSE));
			dwReturn = AddStringToBuffer (
				szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);

            if (pThisInstance->ParentObjectTitleIndex > 0) {
                // get parent instance name
                pParentObject = FirstObject(pPerfDataBlock);
                dwObjectIdx = 0;
                while ((pParentObject != NULL) && 
                    (pParentObject->ObjectNameTitleIndex != pThisInstance->ParentObjectTitleIndex) &&
                    (dwObjectIdx < pPerfDataBlock->NumObjectTypes)) {
                    pParentObject = NextObject (pParentObject);
                    dwObjectIdx++;
                }
                if (pParentObject->ObjectNameTitleIndex == pThisInstance->ParentObjectTitleIndex) {
                    pParentInstance = FirstInstance (pParentObject);
                    for (dwParentInstIdx = 0; 
                        dwParentInstIdx < pThisInstance->ParentObjectInstance; 
                        dwParentInstIdx++) {
                        pParentInstance = NextInstance(pParentInstance);
                    }
                    dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"\x0D\x0A    Name = \"%ws/",
                        GetInstanceName (pParentInstance));
					dwReturn = AddStringToBuffer (
						szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);

                    dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"%ws\";", GetInstanceName (pThisInstance));
					dwReturn = AddStringToBuffer (
						szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);

                } else {
                    dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"\x0D\x0A    Name = \"%ws\";",
                        GetInstanceName (pThisInstance));
					dwReturn = AddStringToBuffer (
						szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);

                }
            } else {
                dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"\x0D\x0A    Name = \"%ws\";",
                    GetInstanceName (pThisInstance));
				dwReturn = AddStringToBuffer (
					szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);

            }
            pThisCounter = FirstCounter(pPerfObject);
            assert (pThisCounter != NULL);
            for (dwCounterCount = 0; dwCounterCount < pPerfObject->NumCounters; dwCounterCount++) {
                assert (pThisCounter != NULL);
                dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"\x0D\x0A    %ws = ", 
                     FormatPerfName (lpCounterText[pThisCounter->CounterNameTitleIndex],
                        (IsDisplayableType(pThisCounter->CounterType) ? FALSE : TRUE)));
				dwReturn = AddStringToBuffer (
					szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);

                pValue = (LPDWORD)pThisInstance;
                pValue = (LPDWORD)((LPBYTE)pValue + pThisInstance->ByteLength);
                pValue = (LPDWORD)((LPBYTE)pValue + pThisCounter->CounterOffset);
                if (pThisCounter->CounterSize == 8) {
                    pValue++;
                    dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"0x%8.8x", *pValue);
					dwReturn = AddStringToBuffer (
						szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);

                    pValue--;
                    dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"%8.8x;", *pValue);
					dwReturn = AddStringToBuffer (
						szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);

                } else {
                    dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"0x%8.8x;", *pValue);
					dwReturn = AddStringToBuffer (
						szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);

                }
                pThisCounter = NextCounter (pThisCounter);
            }
            dwLength = swprintf (szTempBuffer,  (LPCWSTR)L"\x0D\x0A};\x0D\x0A");
			dwReturn = AddStringToBuffer (
				szBuffer, szTempBuffer, &dwLength, &dwTotalLength, *pcchBufferSize);

            pThisInstance = NextInstance(pThisInstance);
        }
    }
	*pcchBufferSize = dwTotalLength;

	return dwReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cntrtext\common\unlodctr.c ===
/*++

Copyright (c) 1991-1999  Microsoft Corporation

Module Name:

    unlodctr.c

Abstract:

    Program to remove the counter names belonging to the driver specified
        in the command line and update the registry accordingly

Author:

    Bob Watson (a-robw) 12 Feb 93

Revision History:

    Bob Watson (bobw)   10 Mar 99 added event log messages

--*/
#ifndef     UNICODE
#define     UNICODE     1
#endif

#ifndef     _UNICODE
#define     _UNICODE    1
#endif
//
//  "C" Include files
//
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <malloc.h>
//
//  Windows Include files
//
#include <windows.h>
#define __LOADPERF__
#include <loadperf.h>
#include <tchar.h>
#include "wmistr.h"
#include "evntrace.h"
//
//  local include files
//
#include "winperfp.h"
#include "common.h"
#include "unlodctr.h"
#include "mofcomp.h"
#include "ldprfmsg.h"

// version number for NT 1.0
#define OLD_VERSION  0x010000
static DWORD   dwSystemVersion;    // PerfLib version number
static DWORD   dwHelpItems;        // number of explain text items
static DWORD   dwCounterItems;     // number of counter text items
static DWORD   dwLastCounter;
static DWORD   dwLastHelp;
static TCHAR   ComputerName[MAX_PATH];
static HKEY    hPerfData;    // handle to remote machine HKEY_PERFORMANCE_DATA
static BOOL     bQuietMode = TRUE;     // quiet means no _tprintf's

#define  OUTPUT_MESSAGE     if (!bQuietMode) _tprintf

static
LPTSTR
*BuildNameTable(
    IN HKEY    hKeyPerflib,     // handle to perflib key with counter names
    IN LPTSTR  lpszLangId,      // unicode value of Language subkey
    OUT PDWORD  pdwLastItem,     // size of array in elements
    OUT HKEY    *hKeyNames,
    OUT LPTSTR  CounterNameBuffer,  // New version counter name key
    OUT LPTSTR  HelpNameBuffer     // New version help name key
)
/*++

BuildNameTable

    Caches the counter names and explain text to accelerate name lookups
    for display.

Arguments:

    hKeyPerflib
            Handle to an open registry (this can be local or remote.) and
            is the value returned by RegConnectRegistry or a default key.

    lpszLangId
            The unicode id of the language to look up. (default is 009)

    pdwLastItem
            The last array element

Return Value:

    pointer to an allocated table. (the caller must free it when finished!)
    the table is an array of pointers to zero terminated TEXT strings.

    A NULL pointer is returned if an error occured. (error value is
    available using the GetLastError function).

    The structure of the buffer returned is:

        Array of pointers to zero terminated strings consisting of
            pdwLastItem elements

        MULTI_SZ string containing counter id's and names returned from
            registry for the specified language

        MULTI_SZ string containing explain text id's and explain text strings
            as returned by the registry for the specified language

    The structures listed above are contiguous so that they may be freed
    by a single "free" call when finished with them, however only the
    array elements are intended to be used.

--*/
{

    LPTSTR  *lpReturnValue;     // returned pointer to buffer

    LPTSTR  *lpCounterId;       //
    LPTSTR  lpCounterNames;     // pointer to Names buffer returned by reg.
    LPTSTR  lpHelpText ;        // pointet to exlpain buffer returned by reg.

    LPTSTR  lpThisName;         // working pointer


    BOOL    bStatus;            // return status from TRUE/FALSE fn. calls
    LONG    lWin32Status;       // return status from fn. calls

    DWORD   dwValueType;        // value type of buffer returned by reg.
    DWORD   dwArraySize;        // size of pointer array in bytes
    DWORD   dwBufferSize;       // size of total buffer in bytes
    DWORD   dwCounterSize;      // size of counter text buffer in bytes
    DWORD   dwHelpSize;         // size of help text buffer in bytes
    DWORD   dwThisCounter;      // working counter

    DWORD   dwLastId;           // largest ID value used by explain/counter text

    DWORD   dwLastCounterIdUsed;
    DWORD   dwLastHelpIdUsed;

    LPTSTR  lpValueNameString;  // pointer to buffer conatining subkey name

    //initialize pointers to NULL

    lpValueNameString = NULL;
    lpReturnValue = NULL;

    // check for null arguments and insert defaults if necessary

    if (!lpszLangId) {
        lpszLangId = (LPTSTR)DefaultLangId;
    }

    if (hKeyNames) {
        *hKeyNames = NULL;
    } else {
        SetLastError (ERROR_BAD_ARGUMENTS);
        return NULL;
    }

    // use the greater of Help items or Counter Items to size array

    if (dwHelpItems >= dwCounterItems) {
        dwLastId = dwHelpItems;
    } else {
        dwLastId = dwCounterItems;
    }

    // array size is # of elements (+ 1, since names are "1" based)
    // times the size of a pointer

    dwArraySize = (dwLastId + 1) * sizeof(LPTSTR);

    // allocate string buffer for language ID key string

    lpValueNameString = malloc (
        lstrlen(NamesKey) * sizeof (TCHAR) +
        lstrlen(Slash) * sizeof (TCHAR) +
        lstrlen(lpszLangId) * sizeof (TCHAR) +
        sizeof (TCHAR));

    if (!lpValueNameString) {
        lWin32Status = ERROR_OUTOFMEMORY;
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_MEMORY_ALLOCATION_FAILURE, // event,
                0, 0, 0, 0,
                0, NULL, NULL, NULL);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
               __LINE__,
               LOADPERF_UNLODCTR_BUILDNAMETABLE,
               0,
               lWin32Status,
               NULL));
        goto BNT_BAILOUT;
    }

    if (dwSystemVersion == OLD_VERSION) {
        lWin32Status = RegOpenKeyEx (   // get handle to this key in the
            hKeyPerflib,               // registry
            lpszLangId,
            RESERVED,
            KEY_READ | KEY_WRITE,
            hKeyNames);
    } else {
//        *hKeyNames = HKEY_PERFORMANCE_DATA;
        *hKeyNames = hPerfData;

        lstrcpy (CounterNameBuffer, CounterNameStr);
        lstrcat (CounterNameBuffer, lpszLangId);
        lstrcpy (HelpNameBuffer, HelpNameStr);
        lstrcat (HelpNameBuffer, lpszLangId);

        lWin32Status = ERROR_SUCCESS;
    }

    if (lWin32Status != ERROR_SUCCESS) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_UNABLE_ACCESS_STRINGS, // event,
                1, lWin32Status, 0, 0,
                1, lpszLangId, NULL, NULL);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
               __LINE__,
               LOADPERF_UNLODCTR_BUILDNAMETABLE,
               ARG_DEF(ARG_TYPE_WSTR, 1),
               lWin32Status,
               TRACE_WSTR(lpszLangId),
               NULL));
        goto BNT_BAILOUT;
    }

    // get size of counter names

    dwBufferSize = 0;
    lWin32Status = RegQueryValueEx (
        *hKeyNames,
        dwSystemVersion == OLD_VERSION ? Counters : CounterNameBuffer,
        RESERVED,
        &dwValueType,
        NULL,
        &dwBufferSize);
    if (lWin32Status != ERROR_SUCCESS) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_UNABLE_READ_COUNTER_STRINGS, // event,
                1, lWin32Status, 0, 0,
                1, lpszLangId, NULL, NULL);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
               __LINE__,
               LOADPERF_UNLODCTR_BUILDNAMETABLE,
               ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
               lWin32Status,
               TRACE_WSTR(lpszLangId),
               TRACE_WSTR(Counters),
               TRACE_DWORD(dwSystemVersion),
               TRACE_DWORD(dwBufferSize),
               NULL));
        goto BNT_BAILOUT;
    }

    dwCounterSize = dwBufferSize;

    // get size of help text

    dwBufferSize = 0;
    lWin32Status = RegQueryValueEx (
        *hKeyNames,
        dwSystemVersion == OLD_VERSION ? Help : HelpNameBuffer,
        RESERVED,
        &dwValueType,
        NULL,
        &dwBufferSize);

    if (lWin32Status != ERROR_SUCCESS) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_UNABLE_READ_HELP_STRINGS, // event,
                1, lWin32Status, 0, 0,
                1, lpszLangId, NULL, NULL);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
               __LINE__,
               LOADPERF_UNLODCTR_BUILDNAMETABLE,
               ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
               lWin32Status,
               TRACE_WSTR(lpszLangId),
               TRACE_WSTR(Help),
               TRACE_DWORD(dwSystemVersion),
               TRACE_DWORD(dwBufferSize),
               NULL));
        goto BNT_BAILOUT;
    }

    dwHelpSize = dwBufferSize;

    // allocate buffer with room for pointer array, counter name
    // strings and help name strings

    lpReturnValue = malloc (dwArraySize + dwCounterSize + dwHelpSize);

    if (!lpReturnValue) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_MEMORY_ALLOCATION_FAILURE, // event,
                0, 0, 0, 0,
                0, NULL, NULL, NULL);
        lWin32Status = ERROR_OUTOFMEMORY;
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
               __LINE__,
               LOADPERF_UNLODCTR_BUILDNAMETABLE,
               0,
               lWin32Status,
               TRACE_DWORD(dwArraySize),
               TRACE_DWORD(dwCounterSize),
               TRACE_DWORD(dwHelpSize),
               NULL));
        goto BNT_BAILOUT;
    }

    // initialize buffer

    memset (lpReturnValue, 0, _msize(lpReturnValue));

    // initialize pointers into buffer

    lpCounterId = lpReturnValue;
    lpCounterNames = (LPTSTR)((LPBYTE)lpCounterId + dwArraySize);
    lpHelpText = (LPTSTR)((LPBYTE)lpCounterNames + dwCounterSize);

    // read counter names into buffer. Counter names will be stored as
    // a MULTI_SZ string in the format of "###" "Name"

    dwBufferSize = dwCounterSize;
    lWin32Status = RegQueryValueEx (
        *hKeyNames,
        dwSystemVersion == OLD_VERSION ? Counters : CounterNameBuffer,
        RESERVED,
        &dwValueType,
        (LPVOID)lpCounterNames,
        &dwBufferSize);

    if (lWin32Status != ERROR_SUCCESS) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_UNABLE_READ_COUNTER_STRINGS, // event,
                1, lWin32Status, 0, 0,
                1, lpszLangId, NULL, NULL);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
               __LINE__,
               LOADPERF_UNLODCTR_BUILDNAMETABLE,
               ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
               lWin32Status,
               TRACE_WSTR(lpszLangId),
               TRACE_WSTR(Counters),
               TRACE_DWORD(dwSystemVersion),
               TRACE_DWORD(dwBufferSize),
               NULL));
        goto BNT_BAILOUT;
    }
    // read explain text into buffer. Counter names will be stored as
    // a MULTI_SZ string in the format of "###" "Text..."

    dwBufferSize = dwHelpSize;
    lWin32Status = RegQueryValueEx (
        *hKeyNames,
        dwSystemVersion == OLD_VERSION ? Help : HelpNameBuffer,
        RESERVED,
        &dwValueType,
        (LPVOID)lpHelpText,
        &dwBufferSize);

    if (lWin32Status != ERROR_SUCCESS) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_UNABLE_READ_HELP_STRINGS, // event,
                1, lWin32Status, 0, 0,
                1, lpszLangId, NULL, NULL);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
               __LINE__,
               LOADPERF_UNLODCTR_BUILDNAMETABLE,
               ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
               lWin32Status,
               TRACE_WSTR(lpszLangId),
               TRACE_WSTR(Help),
               TRACE_DWORD(dwSystemVersion),
               TRACE_DWORD(dwBufferSize),
               NULL));
        goto BNT_BAILOUT;
    }

    dwLastCounterIdUsed = 0;
    dwLastHelpIdUsed = 0;

    // load counter array items, by locating each text string
    // in the returned buffer and loading the
    // address of it in the corresponding pointer array element.

    for (lpThisName = lpCounterNames;
         *lpThisName;
         lpThisName += (lstrlen(lpThisName)+1) ) {

        // first string should be an integer (in decimal digit characters)
        // so translate to an integer for use in array element identification

        do {
            bStatus = StringToInt (lpThisName, &dwThisCounter);

            if (!bStatus) {
                ReportLoadPerfEvent(
                    EVENTLOG_WARNING_TYPE, // error type
                    (DWORD) LDPRFMSG_REGISTRY_CORRUPT_MULTI_SZ, // event,
                    0, 0, 0, 0,
                    2, CounterNameBuffer, lpThisName, NULL);
                TRACE((WINPERF_DBG_TRACE_WARNING),
                      (& LoadPerfGuid,
                       __LINE__,
                       LOADPERF_UNLODCTR_BUILDNAMETABLE,
                       ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                       ERROR_BADKEY,
                       TRACE_WSTR(Counters),
                       TRACE_WSTR(lpThisName),
                       NULL));
                lpThisName += (lstrlen(lpThisName) + 1);
            }
        }
        while ((! bStatus) && (* lpThisName));

        if (! bStatus) {
            lWin32Status = ERROR_BADKEY;
            goto BNT_BAILOUT;  // bad entry
        }

        // point to corresponding counter name which follows the id number
        // string.

        lpThisName += (lstrlen(lpThisName)+1);

        // and load array element with pointer to string

        lpCounterId[dwThisCounter] = lpThisName;

        if (dwThisCounter > dwLastCounterIdUsed) dwLastCounterIdUsed = dwThisCounter;
    }

    // repeat the above for the explain text strings

    for (lpThisName = lpHelpText;
         *lpThisName;
         lpThisName += (lstrlen(lpThisName)+1) ) {

        // first string should be an integer (in decimal unicode digits)

        do {
            bStatus = StringToInt (lpThisName, &dwThisCounter);
            if (! bStatus) {
                ReportLoadPerfEvent(
                    EVENTLOG_WARNING_TYPE, // error type
                    (DWORD) LDPRFMSG_REGISTRY_CORRUPT_MULTI_SZ, // event,
                    0, 0, 0, 0,
                    2, HelpNameBuffer, lpThisName, NULL);
                TRACE((WINPERF_DBG_TRACE_WARNING),
                      (& LoadPerfGuid,
                       __LINE__,
                       LOADPERF_UNLODCTR_BUILDNAMETABLE,
                       ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                       ERROR_BADKEY,
                       TRACE_WSTR(Help),
                       TRACE_WSTR(lpThisName),
                       NULL));
                lpThisName += (lstrlen(lpThisName) + 1);
            }
        }
        while ((! bStatus) && (* lpThisName));
        if (!bStatus) {
            lWin32Status = ERROR_BADKEY;
            goto BNT_BAILOUT;  // bad entry
        }

        // point to corresponding counter name

        lpThisName += (lstrlen(lpThisName)+1);

        // and load array element;

        lpCounterId[dwThisCounter] = lpThisName;

        if (dwThisCounter > dwLastHelpIdUsed) dwLastHelpIdUsed= dwThisCounter;
    }

    TRACE((WINPERF_DBG_TRACE_INFO),
          (& LoadPerfGuid,
           __LINE__,
           LOADPERF_UNLODCTR_BUILDNAMETABLE,
           0,
           ERROR_SUCCESS,
           TRACE_DWORD(dwLastId),
           TRACE_DWORD(dwLastCounterIdUsed),
           TRACE_DWORD(dwLastHelpIdUsed),
           TRACE_DWORD(dwCounterItems),
           TRACE_DWORD(dwHelpItems),
           NULL));

    if (dwLastHelpIdUsed > dwLastId) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_REGISTRY_INDEX_CORRUPT, // event,
                2, dwLastId, dwLastHelpIdUsed, 0,
                0, NULL, NULL, NULL);
        lWin32Status = ERROR_BADKEY;
        goto BNT_BAILOUT;  // bad registry
    }

    // if the last item arugment was used, then load the last ID value in it

    if (pdwLastItem) *pdwLastItem = dwLastId;

    // free the temporary buffer used

    if (lpValueNameString) {
        free ((LPVOID)lpValueNameString);
    }

    // exit returning the pointer to the buffer

    return lpReturnValue;

BNT_BAILOUT:
    if (lWin32Status != ERROR_SUCCESS) {
        // if lWin32Status has error, then set last error value to it,
        // otherwise assume that last error already has value in it
        SetLastError (lWin32Status);
    }

    // free buffers used by this routine

    if (lpValueNameString) {
        free ((LPVOID)lpValueNameString);
    }

    if (lpReturnValue) {
        free ((LPVOID)lpReturnValue);
    }

    return NULL;
} // BuildNameTable

static
BOOL
GetDriverFromCommandLine (
    LPTSTR  lpCommandLine,
    HKEY    *hKeyMachine,
    LPTSTR  lpDriverName,
    HKEY    *hDriverPerf
)
/*++

GetDriverFromCommandLine

    locates the first argument in the command line string (after the
    image name) and checks to see if

        a) it's there

        b) it's the name of a device driver listed in the
            Registry\Machine\System\CurrentControlSet\Services key
            in the registry and it has a "Performance" subkey

        c) that the "First Counter" value under the Performance subkey
            is defined.

    if all these criteria are true, then the routine returns TRUE and
    passes the pointer to the driver name back in the argument. If any
    one of them fail, then NULL is returned in the DriverName arg and
    the routine returns FALSE

Arguments

    lpDriverName

        the address of a LPTSTR to recive the pointer to the driver name

    hDriverPerf

        the key to the driver's performance subkey

Return Value

    TRUE if a valid driver was found in the command line

    FALSE if not (see above)

--*/
{
    LPTSTR  lpDriverKey;    // buffer to build driver key name in

    LONG    lStatus;
    DWORD   dwFirstCounter;
    DWORD   dwSize;
    DWORD   dwType;
    TCHAR   LocalComputerName[MAX_PATH];
    DWORD   NameBuffer;
    INT     iNumArgs;
    BOOL    bComputerName = FALSE;
    BOOL    bReturn = FALSE;

    if (!lpDriverName || !hDriverPerf) {
        SetLastError (ERROR_BAD_ARGUMENTS);
        goto Cleanup;
    }

    *hDriverPerf = NULL;

    // an argument was found so see if it's a driver
    lpDriverKey = malloc (MAX_PATH * sizeof (TCHAR));
    if (!lpDriverKey) {
        SetLastError (ERROR_OUTOFMEMORY);
        goto Cleanup;
    }

    lstrcpy (lpDriverName, GetItemFromString (lpCommandLine, 3, TEXT(' ')));
    lstrcpy (ComputerName, GetItemFromString (lpCommandLine, 2, TEXT(' ')));

    // check for usage
    if (ComputerName[1] == TEXT('?')) {
        if (!bQuietMode) {
            DisplayCommandHelp (UC_FIRST_CMD_HELP, UC_LAST_CMD_HELP);
        }
        SetLastError (ERROR_SUCCESS);
        goto Cleanup;
    }

    // no /? so process args read

    if (lstrlen(lpDriverName) == 0) {
        // then no computer name is specifed so assume the local computer
        // and the driver name is listed in the computer name param
        if (lstrlen(ComputerName) == 0) {
            iNumArgs = 1;   // command line only
        } else {
            lstrcpy (lpDriverName, ComputerName);
            ComputerName[0] = 0;
            ComputerName[1] = 0;
            iNumArgs = 2;
        }
    } else {
        if (lstrlen(ComputerName) == 0) {
              // this case is impossible since the driver name is after the computer name
            iNumArgs = 1;
        } else {
            iNumArgs = 3;
        }
    }

    // check if there is any computer name
    if (ComputerName[0] == TEXT('\\') &&
        ComputerName[1] == TEXT('\\')) {
        // see if the specified computer is THIS computer and remove
        // name if it is
        NameBuffer = sizeof (LocalComputerName) / sizeof (TCHAR);
        GetComputerName(LocalComputerName, &NameBuffer);
        if (!lstrcmpi(LocalComputerName, &ComputerName[2])) {
            // same name as local computer name
            ComputerName[0] = TEXT('\0');
        }
        bComputerName = TRUE;
    } else {
        // this is a driver name
        ComputerName[0] = TEXT('\0');
    }

    if (iNumArgs >= 2) {
        if (ComputerName[0]) {
            lStatus = !ERROR_SUCCESS;
            try {
                lStatus = RegConnectRegistry (
                    (LPTSTR)ComputerName,
                    HKEY_LOCAL_MACHINE,
                    hKeyMachine);
            } finally {
                if (lStatus != ERROR_SUCCESS) {
                    SetLastError (lStatus);
                    *hKeyMachine = NULL;
                    OUTPUT_MESSAGE (GetFormatResource(UC_CONNECT_PROBLEM),
                        ComputerName, lStatus);
                }
            }
            if (lStatus != ERROR_SUCCESS)
                goto Cleanup;
        } else {
            *hKeyMachine = HKEY_LOCAL_MACHINE;
        }

        if (lstrlen(lpDriverName) > (MAX_PATH / 2)) {
            // then it's too long to make a path out of
            dwSize = 0;
        } else {
            lstrcpy (lpDriverKey, DriverPathRoot);
            lstrcat (lpDriverKey, Slash);
            lstrcat (lpDriverKey, lpDriverName);
            lstrcat (lpDriverKey, Slash);
            lstrcat (lpDriverKey, Performance);
            dwSize = lstrlen(lpDriverKey);
        }

        if ((dwSize > 0) && (dwSize < MAX_PATH)) {
            lStatus = RegOpenKeyEx (
                *hKeyMachine,
                lpDriverKey,
                RESERVED,
                KEY_READ | KEY_WRITE,
                hDriverPerf);
        } else {
            // driver name is too long
            lStatus = ERROR_INVALID_PARAMETER;
        }

        if (lStatus == ERROR_SUCCESS) {
            //
            //  this driver has a performance section so see if its
            //  counters are installed by checking the First Counter
            //  value key for a valid return. If it returns a value
            //  then chances are, it has some counters installed, if
            //  not, then display a message and quit.
            //
            free (lpDriverKey); // don't need this any more

            dwType = 0;
            dwSize = sizeof (dwFirstCounter);

            lStatus = RegQueryValueEx (
                *hDriverPerf,
                cszFirstCounter,
                RESERVED,
                &dwType,
                (LPBYTE)&dwFirstCounter,
                &dwSize);

            if (lStatus == ERROR_SUCCESS) {
                // counter names are installed so return success
                SetLastError (ERROR_SUCCESS);
                bReturn = TRUE;
            } else {
                // counter names are probably not installed so return FALSE
                OUTPUT_MESSAGE (GetFormatResource (UC_NOTINSTALLED), lpDriverName);
                *lpDriverName = TEXT('\0'); // remove driver name
                SetLastError (ERROR_BADKEY);
            }
        } else { // key not found
            if (lStatus != ERROR_INVALID_PARAMETER) {
                OUTPUT_MESSAGE (GetFormatResource (UC_DRIVERNOTFOUND),
                    lpDriverKey, lStatus);
            } else {
                OUTPUT_MESSAGE (GetFormatResource (UC_BAD_DRIVER_NAME), 0);
            }
            SetLastError (lStatus);
            free (lpDriverKey);
        }
    } else {
        if (!bQuietMode) {
            DisplayCommandHelp (UC_FIRST_CMD_HELP, UC_LAST_CMD_HELP);
        }
        SetLastError (ERROR_INVALID_PARAMETER);
    }

Cleanup:
    if (bReturn) {
        TRACE((WINPERF_DBG_TRACE_INFO),
              (& LoadPerfGuid,
               __LINE__,
               LOADPERF_GETDRIVERFROMCOMMANDLINE,
               ARG_DEF(ARG_TYPE_WSTR, 1),
               ERROR_SUCCESS,
               TRACE_WSTR(lpDriverName),
               NULL));
    }
    else {
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
               __LINE__,
               LOADPERF_GETDRIVERFROMCOMMANDLINE,
               0,
               GetLastError(),
               NULL));
    }
    return bReturn;
}

static
LONG
FixNames (
    HANDLE  hKeyLang,
    LPTSTR  *lpOldNameTable,
    IN LPTSTR  lpszLangId,      // unicode value of Language subkey
    DWORD   dwLastItem,
    DWORD   dwFirstNameToRemove,
    DWORD   dwLastNameToRemove
   )
{
    LONG    lStatus;
    LPTSTR  lpNameBuffer = NULL;
    LPTSTR  lpHelpBuffer = NULL;
    DWORD   dwTextIndex, dwSize, dwValueType;
    LPTSTR  lpNextHelpText;
    LPTSTR  lpNextNameText;
    TCHAR   AddHelpNameBuffer[40];
    TCHAR   AddCounterNameBuffer[40];

    // allocate space for the array of new text it will point
    // into the text buffer returned in the lpOldNameTable buffer)

    lpNameBuffer = malloc (_msize(lpOldNameTable));
    lpHelpBuffer = malloc (_msize(lpOldNameTable));

    if (!lpNameBuffer || !lpHelpBuffer) {
        lStatus = ERROR_OUTOFMEMORY;
        goto UCN_FinishLang;
    }

    // remove this driver's counters from array

    for (dwTextIndex = dwFirstNameToRemove;
         dwTextIndex <= dwLastNameToRemove;
         dwTextIndex++) {

        if (dwTextIndex > dwLastItem)
           break;

        lpOldNameTable[dwTextIndex] = NULL;
    }

    lpNextHelpText = lpHelpBuffer;
    lpNextNameText = lpNameBuffer;

    // build new Multi_SZ strings from New Table

    for (dwTextIndex = 0; dwTextIndex <= dwLastItem; dwTextIndex++){
        if (lpOldNameTable[dwTextIndex]) {
            // if there's a text string at that index, then ...
            if ((dwTextIndex & 0x1) && dwTextIndex != 1) {    // ODD number == Help Text
                lpNextHelpText +=
                    _stprintf (lpNextHelpText, (LPCTSTR)TEXT("%d"), dwTextIndex) + 1;
                lpNextHelpText +=
                    _stprintf (lpNextHelpText, (LPCTSTR)TEXT("%s"),
                    lpOldNameTable[dwTextIndex]) + 1;
                if (dwTextIndex > dwLastHelp){
                    dwLastHelp = dwTextIndex;
                }
            } else { // EVEN number == counter name text
                lpNextNameText +=
                    _stprintf (lpNextNameText, (LPCTSTR)TEXT("%d"), dwTextIndex) + 1;
                lpNextNameText +=
                    _stprintf (lpNextNameText, (LPCTSTR)TEXT("%s"),
                lpOldNameTable[dwTextIndex]) + 1;
                if (dwTextIndex > dwLastCounter){
                    dwLastCounter = dwTextIndex;
                }
            }
        }
    } // for dwTextIndex

    TRACE((WINPERF_DBG_TRACE_INFO),
          (& LoadPerfGuid,
            __LINE__,
            LOADPERF_FIXNAMES,
            ARG_DEF(ARG_TYPE_WSTR, 1),
            ERROR_SUCCESS,
            TRACE_WSTR(lpszLangId),
            TRACE_DWORD(dwLastItem),
            TRACE_DWORD(dwLastCounter),
            TRACE_DWORD(dwLastHelp),
            TRACE_DWORD(dwCounterItems),
            TRACE_DWORD(dwHelpItems),
            TRACE_DWORD(dwFirstNameToRemove),
            TRACE_DWORD(dwLastNameToRemove),
            NULL));

    if (   (dwLastCounter < PERFLIB_BASE_INDEX - 1)
        || (dwLastHelp < PERFLIB_BASE_INDEX)) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_REGISTRY_BASEINDEX_CORRUPT, // event,
                3, PERFLIB_BASE_INDEX, dwLastCounter, dwLastHelp,
                0, NULL, NULL, NULL);
        lStatus = ERROR_BADKEY;
        goto UCN_FinishLang;
    }

    // add MULTI_SZ terminating NULL
    *lpNextNameText++ = TEXT ('\0');
    *lpNextHelpText++ = TEXT ('\0');

    // update counter name text buffer

    dwSize = (DWORD)((LPBYTE)lpNextNameText - (LPBYTE)lpNameBuffer);
    if (dwSystemVersion == OLD_VERSION) {
        lStatus = RegSetValueEx (
            hKeyLang,
            Counters,
            RESERVED,
            REG_MULTI_SZ,
            (LPBYTE)lpNameBuffer,
            dwSize);
    } else {
        lstrcpy (AddCounterNameBuffer, AddCounterNameStr);
        lstrcat (AddCounterNameBuffer, lpszLangId);

        lStatus = RegQueryValueEx (
            hKeyLang,
            AddCounterNameBuffer,
            RESERVED,
            &dwValueType,
            (LPBYTE)lpNameBuffer,
            &dwSize);
    }
    if (lStatus != ERROR_SUCCESS) {
       ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_UNABLE_UPDATE_COUNTER_STRINGS, // event,
                1, lStatus, 0, 0,
                1, lpszLangId, NULL, NULL);
        OUTPUT_MESSAGE (GetFormatResource(UC_UNABLELOADLANG),
                Counters, lpszLangId, lStatus);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_FIXNAMES,
                ARG_DEF(ARG_TYPE_WSTR, 1),
                lStatus,
                TRACE_WSTR(Counters),
                TRACE_DWORD(dwSize),
                NULL));
        goto UCN_FinishLang;
    }

    dwSize = (DWORD)((LPBYTE)lpNextHelpText - (LPBYTE)lpHelpBuffer);
    if (dwSystemVersion == OLD_VERSION) {
        lStatus = RegSetValueEx (
            hKeyLang,
            Help,
            RESERVED,
            REG_MULTI_SZ,
            (LPBYTE)lpHelpBuffer,
            dwSize);
    } else {
        lstrcpy (AddHelpNameBuffer, AddHelpNameStr);
        lstrcat (AddHelpNameBuffer, lpszLangId);

        lStatus = RegQueryValueEx (
            hKeyLang,
            AddHelpNameBuffer,
            RESERVED,
            &dwValueType,
            (LPBYTE)lpHelpBuffer,
            &dwSize);
    }
    if (lStatus != ERROR_SUCCESS) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_UNABLE_UPDATE_HELP_STRINGS, // event,
                1, lStatus, 0, 0,
                1, lpszLangId, NULL, NULL);
        OUTPUT_MESSAGE (GetFormatResource(UC_UNABLELOADLANG),
                Help, lpszLangId, lStatus);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_FIXNAMES,
                ARG_DEF(ARG_TYPE_WSTR, 1),
                lStatus,
                TRACE_WSTR(Help),
                TRACE_DWORD(dwSize),
                NULL));
        goto UCN_FinishLang;
    }

UCN_FinishLang:
    if (lpNameBuffer)
        free (lpNameBuffer);
    if (lpHelpBuffer)
        free (lpHelpBuffer);
    free (lpOldNameTable);

    if (dwSystemVersion == OLD_VERSION) {
        RegCloseKey (hKeyLang);
    }

    return lStatus;
}

static
LONG
UnloadCounterNames (
    HKEY    hKeyMachine,
    HKEY    hDriverPerf,
    LPTSTR  lpDriverName
)
/*++

UnloadCounterNames

    removes the names and explain text for the driver referenced by
    hDriverPerf and updates the first and last counter values accordingly

    update process:

        - set "updating" flag under Perflib to name of driver being modified
        - FOR each language under perflib key
            -- load current counter names and explain text into array of
                pointers
            -- look at all drivers and copy their names and text into a new
                buffer adjusting for the removed counter's entries keeping
                track of the lowest entry copied.  (the names for the driver
                to be removed will not be copied, of course)
            -- update each driver's "first" and "last" index values
            -- copy all other entries from 0 to the lowest copied (i.e. the
                system counters)
            -- build a new MULIT_SZ string of help text and counter names
            -- load new strings into registry
        - update perflibl "last" counters
        - delete updating flag

     ******************************************************
     *                                                    *
     *  NOTE: FUNDAMENTAL ASSUMPTION.....                 *
     *                                                    *
     *  this routine assumes that:                        *
     *                                                    *
     *      ALL COUNTER NAMES are even numbered and       *
     *      ALL HELP TEXT STRINGS are odd numbered        *
     *                                                    *
     ******************************************************

Arguments

    hKeyMachine

        handle to HKEY_LOCAL_MACHINE node of registry on system to
        remove counters from

    hDrivefPerf
        handle to registry key of driver to be de-installed

    lpDriverName
        name of driver being de-installed

Return Value

    DOS Error code.

        ERROR_SUCCESS if all went OK
        error value if not.

--*/
{
    HKEY    hPerflib;
    HKEY    hServices;
    HKEY    hKeyLang;

    LONG    lStatus;

    DWORD   dwLangIndex;
    DWORD   dwSize;
    DWORD   dwType;
    DWORD   dwLastItem;

    DWORD   dwRemLastDriverCounter;
    DWORD   dwRemFirstDriverCounter;
    DWORD   dwRemLastDriverHelp;
    DWORD   dwRemFirstDriverHelp;

    DWORD   dwFirstNameToRemove;
    DWORD   dwLastNameToRemove;
    DWORD   dwLastNameInTable;

    LPTSTR  *lpOldNameTable;

    LPTSTR  lpLangName = NULL;
    LPTSTR  lpThisDriver = NULL;

    BOOL    bPerflibUpdated = FALSE;

    DWORD   dwBufferSize;       // size of total buffer in bytes

    TCHAR   CounterNameBuffer [40];
    TCHAR   HelpNameBuffer [40];
    HANDLE  hFileMapping = NULL;
    DWORD             MapFileSize;
    SECURITY_ATTRIBUTES  SecAttr;
    TCHAR MapFileName[] = TEXT("Perflib Busy");
    DWORD             *lpData;

    LONG_PTR    TempFileHandle = -1;

    if (LoadPerfGrabMutex() == FALSE) {
        return (GetLastError());
    }

    lStatus = RegOpenKeyEx (
        hKeyMachine,
        DriverPathRoot,
        RESERVED,
        KEY_READ | KEY_WRITE,
        &hServices);

    if (lStatus != ERROR_SUCCESS) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_UNABLE_OPEN_KEY, // event,
                1, lStatus, 0, 0,
                1, (LPWSTR) DriverPathRoot, NULL, NULL);
        OUTPUT_MESSAGE (GetFormatResource(UC_UNABLEOPENKEY),
                DriverPathRoot, lStatus);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_UNLOADCOUNTERNAMES,
                ARG_DEF(ARG_TYPE_WSTR, 1),
                lStatus,
                TRACE_WSTR(DriverPathRoot),
                NULL));
        ReleaseMutex(hLoadPerfMutex);
        return lStatus;
    }

    // open registry handle to perflib key

    lStatus = RegOpenKeyEx (
        hKeyMachine,
        NamesKey,
        RESERVED,
        KEY_READ | KEY_WRITE,
        &hPerflib);

    if (lStatus != ERROR_SUCCESS) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_UNABLE_OPEN_KEY, // event,
                1, lStatus, 0, 0,
                1, (LPWSTR) NamesKey, NULL, NULL);
        OUTPUT_MESSAGE (GetFormatResource(UC_UNABLEOPENKEY),
                NamesKey, lStatus);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_UNLOADCOUNTERNAMES,
                ARG_DEF(ARG_TYPE_WSTR, 1),
                lStatus,
                TRACE_WSTR(NamesKey),
                NULL));
        ReleaseMutex(hLoadPerfMutex);
        return lStatus;
    }

    lStatus = RegSetValueEx (
        hPerflib,
        Busy,
        RESERVED,
        REG_SZ,
        (LPBYTE)lpDriverName,
        lstrlen(lpDriverName) * sizeof(TCHAR));

    if (lStatus != ERROR_SUCCESS) {
        OUTPUT_MESSAGE (GetFormatResource(UC_UNABLESETVALUE),
                Busy, NamesKey, lStatus);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_UNLOADCOUNTERNAMES,
                ARG_DEF(ARG_TYPE_WSTR, 1),
                lStatus,
                TRACE_WSTR(Busy),
                NULL));
        RegCloseKey (hPerflib);
        ReleaseMutex(hLoadPerfMutex);
        return lStatus;
    }

    // query registry to get number of Explain text items

    dwBufferSize = sizeof (dwHelpItems);
    lStatus = RegQueryValueEx (
        hPerflib,
        LastHelp,
        RESERVED,
        &dwType,
        (LPBYTE)&dwHelpItems,
        &dwBufferSize);

    if ((lStatus != ERROR_SUCCESS) || (dwType != REG_DWORD)) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_UNABLE_READ_VALUE, // event,
                1, lStatus, 0, 0,
                1, (LPWSTR) LastHelp, NULL, NULL);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_UNLOADCOUNTERNAMES,
                ARG_DEF(ARG_TYPE_WSTR, 1),
                lStatus,
                TRACE_WSTR(LastHelp),
                NULL));
        RegCloseKey (hPerflib);
        ReleaseMutex(hLoadPerfMutex);
        return lStatus;
    }

    // query registry to get number of counter and object name items

    dwBufferSize = sizeof (dwCounterItems);
    lStatus = RegQueryValueEx (
        hPerflib,
        LastCounter,
        RESERVED,
        &dwType,
        (LPBYTE)&dwCounterItems,
        &dwBufferSize);

    if ((lStatus != ERROR_SUCCESS) || (dwType != REG_DWORD)) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_UNABLE_READ_VALUE, // event,
                1, lStatus, 0, 0,
                1, (LPWSTR) LastCounter, NULL, NULL);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_UNLOADCOUNTERNAMES,
                ARG_DEF(ARG_TYPE_WSTR, 1),
                lStatus,
                TRACE_WSTR(LastCounter),
                NULL));
        RegCloseKey (hPerflib);
        ReleaseMutex(hLoadPerfMutex);
        return lStatus;
    }

    dwLastNameInTable = dwHelpItems;
    if (dwLastNameInTable < dwCounterItems) dwLastNameInTable = dwCounterItems;

    // query registry to get PerfLib system version

    dwBufferSize = sizeof (dwSystemVersion);
    lStatus = RegQueryValueEx (
        hPerflib,
        VersionStr,
        RESERVED,
        &dwType,
        (LPBYTE)&dwSystemVersion,
        &dwBufferSize);

    if ((lStatus != ERROR_SUCCESS) || (dwType != REG_DWORD)) {
        // Key not there, must be NT 1.0 version
        dwSystemVersion = OLD_VERSION;
    }

    // set the hPerfData to HKEY_PERFORMANCE_DATA for new version
    // if remote machine, then need to connect to it.
    if (dwSystemVersion != OLD_VERSION) {
        lStatus = !ERROR_SUCCESS;
        hPerfData = HKEY_PERFORMANCE_DATA;
        if (ComputerName[0]) {
            // have to do it the old faction way
            dwSystemVersion = OLD_VERSION;
            lStatus = ERROR_SUCCESS;
        }
    } // NEW_VERSION

    // allocate temporary String buffer

    lpLangName = malloc (MAX_PATH * sizeof(TCHAR));
    lpThisDriver = malloc (MAX_PATH * sizeof(TCHAR));

    if (!lpLangName || !lpThisDriver) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_MEMORY_ALLOCATION_FAILURE, // event,
                0, 0, 0, 0,
                0, NULL, NULL, NULL);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_UNLOADCOUNTERNAMES,
                0,
                ERROR_OUTOFMEMORY,
                NULL));
        lStatus = ERROR_OUTOFMEMORY;
        goto UCN_ExitPoint;
    }

    // Get the values that are in use by the driver to be removed

    dwSize = sizeof (dwRemLastDriverCounter);
    lStatus = RegQueryValueEx (
        hDriverPerf,
        LastCounter,
        RESERVED,
        &dwType,
        (LPBYTE)&dwRemLastDriverCounter,
        &dwSize);

    if (lStatus != ERROR_SUCCESS) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_UNABLE_READ_VALUE, // event,
                1, lStatus, 0, 0,
                1, (LPWSTR) LastCounter, NULL, NULL);
        OUTPUT_MESSAGE (GetFormatResource (UC_UNABLEREADVALUE),
                lpDriverName, LastCounter, lStatus);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_UNLOADCOUNTERNAMES,
                ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                lStatus,
                TRACE_WSTR(lpDriverName),
                TRACE_WSTR(LastCounter),
                NULL));
        goto UCN_ExitPoint;
    }

    dwSize = sizeof (dwRemFirstDriverCounter);
    lStatus = RegQueryValueEx (
        hDriverPerf,
        cszFirstCounter,
        RESERVED,
        &dwType,
        (LPBYTE)&dwRemFirstDriverCounter,
        &dwSize);

    if (lStatus != ERROR_SUCCESS) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_UNABLE_READ_VALUE, // event,
                1, lStatus, 0, 0,
                1, (LPWSTR) cszFirstCounter, NULL, NULL);
        OUTPUT_MESSAGE (GetFormatResource (UC_UNABLEREADVALUE),
                lpDriverName, cszFirstCounter, lStatus);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_UNLOADCOUNTERNAMES,
                ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                lStatus,
                TRACE_WSTR(lpDriverName),
                TRACE_WSTR(cszFirstCounter),
                NULL));
        goto UCN_ExitPoint;
    }

    dwSize = sizeof (dwRemLastDriverHelp);
    lStatus = RegQueryValueEx (
        hDriverPerf,
        LastHelp,
        RESERVED,
        &dwType,
        (LPBYTE)&dwRemLastDriverHelp,
        &dwSize);

    if (lStatus != ERROR_SUCCESS) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_UNABLE_READ_VALUE, // event,
                1, lStatus, 0, 0,
                1, (LPWSTR) LastHelp, NULL, NULL);
        OUTPUT_MESSAGE (GetFormatResource (UC_UNABLEREADVALUE),
                lpDriverName, LastHelp, lStatus);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_UNLOADCOUNTERNAMES,
                ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                lStatus,
                TRACE_WSTR(lpDriverName),
                TRACE_WSTR(LastHelp),
                NULL));
        goto UCN_ExitPoint;
    }

    dwSize = sizeof (dwRemFirstDriverHelp);
    lStatus = RegQueryValueEx (
        hDriverPerf,
        FirstHelp,
        RESERVED,
        &dwType,
        (LPBYTE)&dwRemFirstDriverHelp,
        &dwSize);

    if (lStatus != ERROR_SUCCESS) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_UNABLE_READ_VALUE, // event,
                1, lStatus, 0, 0,
                1, (LPWSTR) FirstHelp, NULL, NULL);
        OUTPUT_MESSAGE (GetFormatResource (UC_UNABLEREADVALUE),
                lpDriverName, FirstHelp, lStatus);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_UNLOADCOUNTERNAMES,
                ARG_DEF(ARG_TYPE_WSTR, 1) | ARG_DEF(ARG_TYPE_WSTR, 2),
                lStatus,
                TRACE_WSTR(lpDriverName),
                TRACE_WSTR(FirstHelp),
                NULL));
        goto UCN_ExitPoint;
    }

    TRACE((WINPERF_DBG_TRACE_INFO),
          (& LoadPerfGuid,
            __LINE__,
            LOADPERF_UNLOADCOUNTERNAMES,
            ARG_DEF(ARG_TYPE_WSTR, 1),
            lStatus,
            TRACE_WSTR(lpDriverName),
            TRACE_DWORD(dwLastNameInTable),
            TRACE_DWORD(dwCounterItems),
            TRACE_DWORD(dwHelpItems),
            TRACE_DWORD(dwRemFirstDriverCounter),
            TRACE_DWORD(dwRemLastDriverCounter),
            TRACE_DWORD(dwRemFirstDriverHelp),
            TRACE_DWORD(dwRemLastDriverHelp),
            NULL));

    //  get the first and last counters to define block of names used
    //  by this device

    dwFirstNameToRemove = (dwRemFirstDriverCounter <= dwRemFirstDriverHelp ?
        dwRemFirstDriverCounter : dwRemFirstDriverHelp);

    dwLastNameToRemove = (dwRemLastDriverCounter >= dwRemLastDriverHelp ?
        dwRemLastDriverCounter : dwRemLastDriverHelp);

    dwLastCounter = dwLastHelp = 0;

    // create the file mapping
    SecAttr.nLength = sizeof (SecAttr);
    SecAttr.bInheritHandle = TRUE;
    SecAttr.lpSecurityDescriptor = NULL;

    MapFileSize = sizeof(DWORD);
    hFileMapping = CreateFileMapping ((HANDLE)TempFileHandle, &SecAttr,
       PAGE_READWRITE, (DWORD_PTR)0, MapFileSize, (LPCTSTR)MapFileName);
    if (hFileMapping) {
        lpData = MapViewOfFile (hFileMapping,
            FILE_MAP_ALL_ACCESS, 0L, 0L, 0L);
        if (lpData) {
            *lpData = 1L;
            UnmapViewOfFile (lpData);
        } else {
            lStatus = GetLastError();
        }
    } else {
        lStatus = GetLastError();
    }

    if (lStatus != ERROR_SUCCESS) {
        OUTPUT_MESSAGE (GetFormatResource (UC_UNABLEREADVALUE),
                lpDriverName, FirstHelp, lStatus);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_UNLOADCOUNTERNAMES,
                ARG_DEF(ARG_TYPE_WSTR, 1),
                lStatus,
                TRACE_WSTR(lpDriverName),
                NULL));
        goto UCN_ExitPoint;
    }

    // do each language under perflib
    if (dwSystemVersion == OLD_VERSION) {
        for (dwLangIndex = 0, dwSize = _msize(lpLangName);
             (RegEnumKey(hPerflib, dwLangIndex, lpLangName, dwSize)) == ERROR_SUCCESS;
            dwLangIndex++, dwSize = _msize(lpLangName)) {

            OUTPUT_MESSAGE (GetFormatResource (UC_DOINGLANG), lpLangName);

            lpOldNameTable = BuildNameTable (hPerflib, lpLangName,
                &dwLastItem, &hKeyLang, CounterNameBuffer, HelpNameBuffer);

            if (lpOldNameTable) {
                if (dwLastItem <= dwLastNameInTable) {
                    // registry is OK so continue
                    if ((lStatus = FixNames (
                        hKeyLang,
                        lpOldNameTable,
                        lpLangName,
                        dwLastItem,
                        dwFirstNameToRemove,
                        dwLastNameToRemove)) == ERROR_SUCCESS) {
                        bPerflibUpdated = TRUE;
                    }
                } else {
                    // registry has been corrupted so abort
                    lStatus = ERROR_BADDB;
                    break;
                }
            } else { // unable to unload names for this language
                // display error message
                lStatus = GetLastError();
            }
        } // end for (more languages)
    } // end of OLD_VERSION
    else {
        CHAR  *pSystemRoot;
        WIN32_FIND_DATA FindFileInfo ;
        HANDLE         hFindFile ;
        CHAR  FileName[128];
        WCHAR wFileName[128];
        WCHAR LangId[10];
        WCHAR *pLangId;
        DWORD   dwIdx;

        pSystemRoot = getenv ("SystemRoot");

        if (pSystemRoot == NULL) {
            // unable to find systemroot so try windir
            pSystemRoot = getenv ("windir");
        }

        if (pSystemRoot != NULL) {
            strcpy(FileName, pSystemRoot);
            strcat(FileName, "\\system32\\perfc???.dat");
        } else {
            // unable to look up the windows directory so
            // try searching from the root of the boot drive
            strcpy(FileName, "C:\\perfc???.dat");
        }
        mbstowcs(wFileName, FileName, strlen(FileName) + 1);

        hFindFile = FindFirstFile ((LPCTSTR)wFileName, &FindFileInfo) ;

        if (!hFindFile || hFindFile == INVALID_HANDLE_VALUE) {
            lStatus = GetLastError();
        } else {
            do {
                // get langid
                // start at lang id # of file name based on the format
                //      perfxyyy.dat
                //  where x= h for help file, c for counter names
                //        y= hex digits of language ID
                //
                dwIdx = 0;
                pLangId = &FindFileInfo.cFileName[0];
                // go to lang ID code in filename (yyy above)
                for (dwIdx = 0; (dwIdx < 5) && (*pLangId++ > 0); dwIdx++);
                if (*pLangId > 0) {
                    // get lang ID from file name
                    LangId[0] = *pLangId++;
                    LangId[1] = *pLangId++;
                    LangId[2] = *pLangId++;
                    LangId[3] = L'\0';
                } else {
                    continue; // on to next file
                }

                OUTPUT_MESSAGE (GetFormatResource (UC_DOINGLANG), LangId);

                lpOldNameTable = BuildNameTable (hPerflib, LangId,
                    &dwLastItem, &hKeyLang, CounterNameBuffer, HelpNameBuffer);

                if (lpOldNameTable) {
                    if (dwLastItem <= dwLastNameInTable) {
                        // registry is OK so continue

                        if ((lStatus = FixNames (
                            hKeyLang,
                            lpOldNameTable,
                            LangId,
                            dwLastItem,
                            dwFirstNameToRemove,
                            dwLastNameToRemove)) == ERROR_SUCCESS) {
                            bPerflibUpdated = TRUE;
                        }
                    } else {
                        lStatus = ERROR_BADDB;
                        break;
                    }
                } else { // unable to unload names for this language
                    lStatus = GetLastError();
                }
            } while (FindNextFile(hFindFile, &FindFileInfo));
        }
        FindClose (hFindFile);
    } // end of NEW_VERSION


    if ((bPerflibUpdated) && (lStatus == ERROR_SUCCESS)) {
        // update perflib's "last" values

        dwSize = sizeof (dwLastCounter);
        lStatus = RegSetValueEx (
                hPerflib,
                LastCounter,
                RESERVED,
                REG_DWORD,
                (LPBYTE) & dwLastCounter,
                dwSize);

        if (lStatus == ERROR_SUCCESS) {
            dwSize = sizeof (dwLastHelp);
            lStatus = RegSetValueEx (
                    hPerflib,
                    LastHelp,
                    RESERVED,
                    REG_DWORD,
                    (LPBYTE) & dwLastHelp,
                    dwSize);
            if (lStatus != ERROR_SUCCESS) {
                ReportLoadPerfEvent(
                        EVENTLOG_ERROR_TYPE, // error type
                        (DWORD) LDPRFMSG_UNABLE_UPDATE_VALUE, // event,
                        2, lStatus, dwLastHelp, 0,
                        2, (LPWSTR) LastHelp, (LPWSTR) NamesKey, NULL);
                TRACE((WINPERF_DBG_TRACE_ERROR),
                      (& LoadPerfGuid,
                        __LINE__,
                        LOADPERF_UNLOADCOUNTERNAMES,
                        ARG_DEF(ARG_TYPE_WSTR, 1),
                        lStatus,
                        TRACE_WSTR(LastHelp),
                        TRACE_DWORD(dwLastHelp),
                        NULL));
            }
        }
        else {
            ReportLoadPerfEvent(
                    EVENTLOG_ERROR_TYPE, // error type
                    (DWORD) LDPRFMSG_UNABLE_UPDATE_VALUE, // event,
                    2, lStatus, dwLastCounter, 0,
                    2, (LPWSTR) LastCounter, (LPWSTR) NamesKey, NULL);
            TRACE((WINPERF_DBG_TRACE_ERROR),
                  (& LoadPerfGuid,
                    __LINE__,
                    LOADPERF_UNLOADCOUNTERNAMES,
                    ARG_DEF(ARG_TYPE_WSTR, 1),
                    lStatus,
                    TRACE_WSTR(LastCounter),
                    TRACE_DWORD(dwLastCounter),
                    NULL));
        }

        if (lStatus == ERROR_SUCCESS) {
            ReportLoadPerfEvent(
                    EVENTLOG_INFORMATION_TYPE, // error type
                    (DWORD) LDPRFMSG_UNLOAD_SUCCESS, // event,
                    2, dwLastCounter, dwLastHelp, 0,
                    1, (LPWSTR) lpDriverName, NULL, NULL);
            TRACE((WINPERF_DBG_TRACE_INFO),
                  (& LoadPerfGuid,
                    __LINE__,
                    LOADPERF_UNLOADCOUNTERNAMES,
                    ARG_DEF(ARG_TYPE_WSTR, 1),
                    lStatus,
                    TRACE_WSTR(lpDriverName),
                    TRACE_DWORD(dwLastCounter),
                    TRACE_DWORD(dwLastHelp),
                    NULL));
            RegDeleteValue (hDriverPerf, cszFirstCounter);
            RegDeleteValue (hDriverPerf, LastCounter);
            RegDeleteValue (hDriverPerf, FirstHelp);
            RegDeleteValue (hDriverPerf, LastHelp);
            RegDeleteValue (hDriverPerf, szObjectList);
            RegDeleteValue (hDriverPerf, szLibraryValidationCode);
        }
    }

UCN_ExitPoint:
    RegDeleteValue (hPerflib, Busy);
    RegCloseKey (hPerflib);
    RegCloseKey (hServices);
    if (lpLangName) free (lpLangName);
    if (lpThisDriver) free (lpThisDriver);

    if (hFileMapping) {
        CloseHandle (hFileMapping);
    }

    if (lStatus != ERROR_SUCCESS) {
        ReportLoadPerfEvent(
                EVENTLOG_ERROR_TYPE, // error type
                (DWORD) LDPRFMSG_UNLOAD_FAILURE, // event,
                1, lStatus, 0, 0,
                1, (LPWSTR) lpDriverName, NULL, NULL);
        TRACE((WINPERF_DBG_TRACE_ERROR),
              (& LoadPerfGuid,
                __LINE__,
                LOADPERF_UNLOADCOUNTERNAMES,
                ARG_DEF(ARG_TYPE_WSTR, 1),
                lStatus,
                TRACE_WSTR(lpDriverName),
                NULL));
    }
    ReleaseMutex(hLoadPerfMutex);
    return lStatus;

}

LOADPERF_FUNCTION
UnloadPerfCounterTextStringsW (
    IN  LPWSTR  lpCommandLine,
    IN  BOOL    bQuietModeArg
)
/*++

UnloadPerfCounterTextStringsW

    entry point to Counter Name Unloader


Arguments

    command line string in the format:

    "/?"                displays the usage help
    "driver"            driver containing the performance counters
    "\\machine driver"  removes the counters from the driver on \\machine

ReturnValue

    0 (ERROR_SUCCESS) if command was processed
    Non-Zero if command error was detected.

--*/
{
    LPTSTR  lpDriverName=NULL;   // name of driver to delete from perflib
    HKEY    hDriverPerf=NULL;    // handle to performance sub-key of driver
    HKEY    hMachineKey=NULL;    // handle to remote machine HKEY_LOCAL_MACHINE

    DWORD   dwStatus = ERROR_SUCCESS;       // return status of fn. calls

    WinPerfStartTrace(NULL);

    lpDriverName = (LPTSTR)malloc(MAX_PATH * sizeof(TCHAR));

    bQuietMode = bQuietModeArg;

    if (lpDriverName != NULL) {
        if (!GetDriverFromCommandLine (
            lpCommandLine, &hMachineKey, lpDriverName, &hDriverPerf)) {
            // error message was printed in routine if there was an error
            dwStatus = GetLastError();
            goto Exit0;
        }
    } else {
        dwStatus = ERROR_OUTOFMEMORY;
        goto Exit0;
    }

    OUTPUT_MESSAGE(GetFormatResource(UC_REMOVINGDRIVER), lpDriverName);

    // removes names and explain text for driver in lpDriverName
    // displays error messages for errors encountered

    dwStatus = (DWORD)UnloadCounterNames(hMachineKey,
        hDriverPerf, lpDriverName);

    if (dwStatus == ERROR_SUCCESS) {
        SignalWmiWithNewData (WMI_UNLODCTR_EVENT);
    }

Exit0:
    TRACE((WINPERF_DBG_TRACE_INFO),
          (& LoadPerfGuid,
            __LINE__,
            LOADPERF_UNLOADPERFCOUNTERTEXTSTRINGS,
            ARG_DEF(ARG_TYPE_WSTR, 1),
            dwStatus,
            TRACE_WSTR(lpDriverName),
            NULL));
    if (lpDriverName != NULL) free (lpDriverName);

    if (hDriverPerf)
        RegCloseKey (hDriverPerf);

    if (hMachineKey != HKEY_LOCAL_MACHINE && hMachineKey != NULL) {
        RegCloseKey (hMachineKey);
    }
    if (hPerfData != HKEY_PERFORMANCE_DATA && hPerfData != NULL) {
        RegCloseKey (hPerfData);
    }
    return dwStatus;

}

LOADPERF_FUNCTION
UnloadPerfCounterTextStringsA (
    IN  LPSTR   lpAnsiCommandLine,
    IN  BOOL    bQuietModeArg
)
{
    LPWSTR  lpWideCommandLine;
    DWORD   dwStrLen;
    DWORD   lReturn;

    if (lpAnsiCommandLine != 0) { // to catch bogus parameters
        //length of string including terminator
        dwStrLen = lstrlenA(lpAnsiCommandLine) + 1;

        lpWideCommandLine = GlobalAlloc (GPTR, (dwStrLen * sizeof(WCHAR)));
        if (lpWideCommandLine != NULL) {
            mbstowcs (lpWideCommandLine, lpAnsiCommandLine, dwStrLen);
            lReturn = UnloadPerfCounterTextStringsW(lpWideCommandLine,
                bQuietModeArg );
            GlobalFree (lpWideCommandLine);
        } else {
            lReturn = GetLastError();
        }
    } else {
        lReturn = ERROR_INVALID_PARAMETER;
    }
    return lReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cntrtext\initodat\common.h ===
/*++

Copyright (c) 1993-1994 Microsoft Corporation

Module Name:

    common.c

Abstract:

    Utility routines used by IniToDat.exe
    

Author:

    HonWah Chan (a-honwah) October, 1993 

Revision History:

--*/

#ifndef _COMMON_H_
#define _COMMON_H_


//
//  Local constants
//
#define RESERVED                0L
#define LARGE_BUFFER_SIZE       0x10000         // 64K
#define MEDIUM_BUFFER_SIZE      0x8000          // 32K
#define SMALL_BUFFER_SIZE       0x1000          //  4K
#define FILE_NAME_BUFFER_SIZE   MAX_PATH
#define DISP_BUFF_SIZE          256L
#define SIZE_OF_OFFSET_STRING   15



LPTSTR
GetStringResource (
    UINT    wStringId
);

LPSTR
GetFormatResource (
    UINT    wStringId
);

VOID
DisplayCommandHelp (
    UINT    iFirstLine,
    UINT    iLastLine
);

VOID
DisplaySummary (
    LPTSTR  lpLastID,
    LPTSTR  lpLastText,
    UINT    NumOfID
);

VOID
DisplaySummaryError (
    LPTSTR  lpLastID,
    LPTSTR  lpLastText,
    UINT    NumOfID
);


#endif  // _COMMON_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cntrtext\initodat\common.c ===
/*++

Copyright (c) 1993-1994 Microsoft Corporation

Module Name:

    common.c

Abstract:

    Utility routines used by IniToDat.exe
    

Author:

    HonWah Chan (a-honwah) October, 1993 

Revision History:

--*/

//
//  "C" Include files
//
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <malloc.h>
//
//  Windows Include files
//
#include <windows.h>
#include <winperf.h>
#include <tchar.h>
//
//  local include files
//
#include "common.h"
#include "strids.h"

//  Global Buffers
//
TCHAR   DisplayStringBuffer[DISP_BUFF_SIZE];
CHAR    TextFormat[DISP_BUFF_SIZE];
HANDLE  hMod;
DWORD   dwLastError;
const   LPTSTR BlankString = (const LPTSTR)TEXT(" ");
const   LPSTR  BlankAnsiString = " ";


LPTSTR
GetStringResource (
    UINT    wStringId
)
/*++

    Retrived UNICODE strings from the resource file for display 

--*/
{

    if (!hMod) {
        hMod = (HINSTANCE)GetModuleHandle(NULL); // get instance ID of this module;
    }
    
    if (hMod) {
        if ((LoadString(hMod, wStringId, DisplayStringBuffer, DISP_BUFF_SIZE)) > 0) {
            return (LPTSTR)&DisplayStringBuffer[0];
        } else {
            dwLastError = GetLastError();
            return BlankString;
        }
    } else {
        return BlankString;
    }
}
LPSTR
GetFormatResource (
    UINT    wStringId
)
/*++

    Returns an ANSI string for use as a format string in a printf fn.

--*/
{

    if (!hMod) {
        hMod = (HINSTANCE)GetModuleHandle(NULL); // get instance ID of this module;
    }
    
    if (hMod) {
        if ((LoadStringA(hMod, wStringId, TextFormat, DISP_BUFF_SIZE)) > 0) {
            return (LPSTR)&TextFormat[0];
        } else {
            dwLastError = GetLastError();
            return BlankAnsiString;
        }
    } else {
        return BlankAnsiString;
    }
}

VOID
DisplayCommandHelp (
    UINT    iFirstLine,
    UINT    iLastLine
)
/*++

DisplayCommandHelp

    displays usage of command line arguments

Arguments

    NONE

Return Value

    NONE

--*/
{
    UINT iThisLine;

    for (iThisLine = iFirstLine;
        iThisLine <= iLastLine;
        iThisLine++) {
        printf ("\n%ws", GetStringResource(iThisLine));
    }

} // DisplayCommandHelp

VOID
DisplaySummary (
    LPTSTR  lpLastID,
    LPTSTR  lpLastText,
    UINT    NumOfID
)
{
   printf ("%ws", GetStringResource(LC_SUMMARY));
   printf ("%ws", GetStringResource(LC_NUM_OF_ID));
   printf ("%ld\n", NumOfID);
   printf ("%ws", GetStringResource(LC_LAST_ID));
   printf ("%ws\n", lpLastID ? lpLastID : (LPCTSTR)TEXT(""));
   printf ("%ws", GetStringResource(LC_LAST_TEXT));
   printf ("%ws\n", lpLastText ? lpLastText : (LPCTSTR)TEXT(""));
}


VOID
DisplaySummaryError (
    LPTSTR  lpLastID,
    LPTSTR  lpLastText,
    UINT    NumOfID
)
{
   printf ("%ws", GetStringResource(LC_BAD_ID));
   printf ("%ws\n", lpLastID ? lpLastID : (LPCTSTR)TEXT(""));
   printf ("%ws\n", GetStringResource(LC_MISSING_DEL));
   DisplaySummary (lpLastID, lpLastText, NumOfID);
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cntrtext\common\wbemutil.h ===
/*
	WBEMUtil.H

	utilities & definitions for use with WBEM perf counters

*/
#ifndef __CNTRTEXT_WBEMUTIL_H_
#define __CNTRTEXT_WBEMUTIL_H_
#include <winperf.h>

#ifdef __cplusplus
extern "c" {
#endif

typedef struct _PERFTYPE_LOOKUP {
	LONG	PerfType;
	LPWSTR	RawType;
	LPWSTR	FmtType;
} PERFTYPE_LOOKUP, *PPERFTYPE_LOOKUP;

typedef struct _PERFOBJECT_LOOKUP {
    LONG    PerfObjectId;
    LPWSTR  GuidString;
} PERFOBJECT_LOOKUP, *PPERFOBJECT_LOOKUP;

typedef struct _PERF_COUNTER_DLL_INFO {
	LPWSTR	szWbemProviderName;
	LPWSTR	szClassGuid;
	LPWSTR	szRegistryKey;
} PERF_COUNTER_DLL_INFO, *PPERF_COUNTER_DLL_INFO;

extern const PPERFTYPE_LOOKUP PerfTypes;
extern const DWORD			dwNumPerfTypes;
extern const PPERFOBJECT_LOOKUP PerfObjectGuids;
extern const DWORD			dwNumPerfObjectGuids;

extern LPCWSTR szRawClass;
extern LPCWSTR szFmtClass;
extern LPCWSTR	szGenericProviderName;
extern LPCWSTR	szGenericProviderGuid;

__inline
BOOL
IsDisplayableType (
    DWORD   dwCounterType
)
{
    if ((dwCounterType & PERF_DISPLAY_NOSHOW) &&
        (dwCounterType != PERF_AVERAGE_BULK)) {
        return FALSE;
    } else {
        return TRUE;
    }
}

LPCWSTR
GetPerfObjectGuid (
    DWORD dwObjectId
);

PERFTYPE_LOOKUP *
GetPerfTypeInfo (
    DWORD dwType
);

LPCWSTR 
FormatPerfName (
    LPWSTR  szNameIn,
    BOOL    bHiddenCounter
);

DWORD
GenerateMofHeader (
	LPWSTR	szBuffer,			// string buffer
	LPCWSTR	szComputerName,
	LPDWORD	pcchBufferSize
);

// dwFlags values
#define	WM_GMO_RAW_DEFINITION	((DWORD)0x00000001)
#define	WM_GMO_COSTLY_OBJECT	((DWORD)0x00000002)
#define WM_GMO_DEFAULT_OBJECT	((DWORD)0x00000004)
#define WM_GMO_DEFAULT_COUNTER	((DWORD)0x00000008)

DWORD
GenerateMofObject (
	LPWSTR				szBuffer,
	LPDWORD				pcchBufferSize,
	PPERF_COUNTER_DLL_INFO	pPcDllInfo,
    PERF_OBJECT_TYPE    *pPerfObject,
	LPWSTR				*lpCounterText,
	LPWSTR				*lpDisplayText, // Localized name strings array
	DWORD				dwFlags
);

DWORD
GenerateMofCounter (
	LPWSTR					szBuffer,
	LPDWORD					pcchBufferSize,
    PERF_COUNTER_DEFINITION *pPerfCounter,
	LPWSTR					*lpCounterText,	// ENGLISH name strings array
	LPWSTR					*lpDisplayText, // Localized name strings array
	DWORD					dwFlags
);

DWORD
GenerateMofObjectTail (
	LPWSTR				szBuffer,
	LPDWORD				pcchBufferSize
);


DWORD
GenerateMofInstances (
	LPWSTR					szBuffer,
	LPDWORD					pcchBufferSize,
    PERF_DATA_BLOCK		*   pPerfDataBlock,
    PERF_OBJECT_TYPE	*   pPerfObject,
	LPWSTR				*	lpCounterText,	// ENGLISH name strings array
	LPWSTR				*	lpDisplayText, // Localized name strings array
	DWORD					dwFlags
);

#ifdef __cplusplus
}
#endif

#endif //__CNTRTEXT_WBEMUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cntrtext\ctrlist\ctrlist.c ===
/*++

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    ctrlist.c

Abstract:

    Program to read the current perfmon counters and dump a list of
        objects and counters returned by the registry

Author:

    Bob Watson (a-robw) 4 Dec 92

Revision History:
    HonWah Chan May 22, 93 - added more features
    HonWah Chan Oct 18, 93 - added check for perflib version.
            Old version --> get names from registry
            New version --> get names from PerfLib thru HKEY_PERFORMANCE_DATA
    Bob Watson (a-robw) 1 Dec 95    added new counter types

--*/
#define UNICODE 1
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>
#include <winperf.h>
#include <ntprfctr.h>
#include <wbemutil.h>

#define MAX_LEVEL 400
LPSTR DetailLevelStr[] = { "Novice", "Advanced", "Expert", "Wizard"};
// LPCWSTR lpwszDiskPerfKey = (LPCWSTR)L"SYSTEM\\CurrentControlSet\\Services\\Diskperf";        
LPCWSTR NamesKey = (LPCWSTR)L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib";
LPCWSTR DefaultLangId = (LPCWSTR)L"009";
LPCWSTR Counters = (LPCWSTR)L"Counters";
LPCWSTR Help = (LPCWSTR)L"Help";
LPCWSTR LastHelp = (LPCWSTR)L"Last Help";
LPCWSTR LastCounter = (LPCWSTR)L"Last Counter";
LPCWSTR Slash = (LPCWSTR)L"\\";

// the following strings are for getting texts from perflib
#define  OLD_VERSION 0x010000
LPCWSTR VersionName = (LPCWSTR)L"Version";
LPCWSTR CounterName = (LPCWSTR)L"Counter ";
LPCWSTR HelpName = (LPCWSTR)L"Explain ";

#define RESERVED    0L
#define INITIAL_SIZE     (1024*64)
#define EXTEND_SIZE      (1024*16)
#define LINE_LENGTH     80
#define WRAP_POINT      LINE_LENGTH-12

typedef LPVOID  LPMEMORY;
typedef HGLOBAL HMEMORY;

#define MemoryAllocate(x)   ((LPMEMORY)GlobalAlloc(GPTR, x))
#define MemoryFree(x)       ((VOID)GlobalFree(x))
#define MemorySize(x)       ((x != NULL) ? (DWORD)GlobalSize(x) : (DWORD)0)
#define MemoryResize(x,y)   ((LPMEMORY)GlobalReAlloc(x,y,GMEM_MOVEABLE));

LPWSTR  *lpCounterText;
LPWSTR	*lpDisplayText;

TCHAR  szComputerName[MAX_COMPUTERNAME_LENGTH+1];

const CHAR  PerfCounterCounter[]       = "PERF_COUNTER_COUNTER";
const CHAR  PerfCounterTimer[]         = "PERF_COUNTER_TIMER";
const CHAR  PerfCounterQueueLen[]      = "PERF_COUNTER_QUEUELEN_TYPE";
const CHAR  PerfCounterLargeQueueLen[] = "PERF_COUNTER_LARGE_QUEUELEN_TYPE";
const CHAR  PerfCounterBulkCount[]     = "PERF_COUNTER_BULK_COUNT";
const CHAR  PerfCounterText[]          = "PERF_COUNTER_TEXT";
const CHAR  PerfCounterRawcount[]      = "PERF_COUNTER_RAWCOUNT";
const CHAR  PerfCounterRawcountHex[]   = "PERF_COUNTER_RAWCOUNT_HEX";
const CHAR  PerfCounterLargeRawcount[] = "PERF_COUNTER_LARGE_RAWCOUNT";
const CHAR  PerfCounterLargeRawcountHex[] = "PERF_COUNTER_LARGE_RAWCOUNT_HEX";
const CHAR  PerfSampleFraction[]       = "PERF_SAMPLE_FRACTION";
const CHAR  PerfSampleCounter[]        = "PERF_SAMPLE_COUNTER";
const CHAR  PerfCounterNodata[]        = "PERF_COUNTER_NODATA";
const CHAR  PerfCounterTimerInv[]      = "PERF_COUNTER_TIMER_INV";
const CHAR  PerfSampleBase[]           = "PERF_SAMPLE_BASE";
const CHAR  PerfAverageTimer[]         = "PERF_AVERAGE_TIMER";
const CHAR  PerfAverageBase[]          = "PERF_AVERAGE_BASE";
const CHAR  PerfAverageBulk[]          = "PERF_AVERAGE_BULK";
const CHAR  Perf100nsecTimer[]         = "PERF_100NSEC_TIMER";
const CHAR  Perf100nsecTimerInv[]      = "PERF_100NSEC_TIMER_INV";
const CHAR  PerfCounterMultiTimer[]    = "PERF_COUNTER_MULTI_TIMER";

const CHAR  PerfCounterMultiTimerInv[] = "PERF_COUNTER_MULTI_TIMER_INV";
const CHAR  PerfCounterMultiBase[]     = "PERF_COUNTER_MULTI_BASE";
const CHAR  Perf100nsecMultiTimer[]    = "PERF_100NSEC_MULTI_TIMER";
const CHAR  Perf100nsecMultiTimerInv[] = "PERF_100NSEC_MULTI_TIMER_INV";
const CHAR  PerfRawFraction[]          = "PERF_RAW_FRACTION";
const CHAR  PerfRawBase[]              = "PERF_RAW_BASE";
const CHAR  PerfElapsedTime[]          = "PERF_ELAPSED_TIME";
const CHAR  PerfCounterHistogramType[] = "PERF_COUNTER_HISTOGRAM_TYPE";
const CHAR  PerfCounterDelta[]         = "PERF_COUNTER_DELTA";
const CHAR  PerfCounterLargeDelta[]    = "PERF_COUNTER_LARGE_DELTA";
const CHAR  NotDefineCounterType[]     = " ";

const CHAR  PerfCounter100NsQueLenType[] = "PERF_COUNTER_100NS_QUEUELEN_TYPE";
const CHAR  PerfCounterObjTimeQueLenType[] = "PERF_COUNTER_OBJ_TIME_QUEUELEN_TYPE";
const CHAR  PerfObjTimeTimer[]         = "PERF_OBJ_TIME_TIMER";
const CHAR  PerfLargeRawFraction[]     = "PERF_LARGE_RAW_FRACTION";
const CHAR  PerfLargeRawBase[]         = "PERF_LARGE_RAW_BASE";
const CHAR  PerfPrecisionSystemTimer[] = "PERF_PRECISION_SYSTEM_TIMER";
const CHAR  PerfPrecision100NsTimer[]  = "PERF_PRECISION_100NS_TIMER";
const CHAR  PerfPrecisionObjectTimer[] = "PERF_PRECISION_OBJECT_TIMER";

BOOL    bFormatCSV  = FALSE;
BOOL    bFormatMOF  = FALSE;
BOOL    bPrintMOFData = FALSE;
BOOL    bCheckCtrType = FALSE;
//
//  Object Record Fields are:
//      Record Type = "O" for Object Record
//      Object name string ID
//      Object Name in selected language
//      Object Detail Level string (in english)
//      has Instance Records [1= yes, 0= no]
//      Object Instance Code Page [0 = unicode]
//      Help text ID
//      Help text
//
const CHAR  fmtObjectRecord[] =
    "\n\"O\",\"%d\",\"%ws\",\"%s\",\"%d\",\"%d\",\"%d\",\"%ws\"";
//
//  Counter Record Fields are:
//      Record Type = "C" for Counter Record
//      Object name string ID               { these fields are used as links
//      Object Name in selected language    {   to object info records
//      Counter name string ID
//      Counter name text in selected language
//      Counter Detail Level string (in english)
//      Counter Type value as a HEX string
//      Counter Type Name
//      Counter Data field size in bytes
//      Counter Visibility [1= listed in list box, 0=hidden]
//      Counter Help text ID
//      Counter Help text
//
const CHAR  fmtCounterRecord[] =
    "\n\"C\",\"%d\",\"%ws\",\"%d\",\"%ws\",\"%s\",\"0x%8.8x\",\"%s\",\"%d\",\"%d\",\"%d\",\"%ws\"";


__inline
static
PPERF_OBJECT_TYPE
FirstObject (
    PPERF_DATA_BLOCK pPerfData
)
{
    return ((PPERF_OBJECT_TYPE) ((PBYTE) pPerfData + pPerfData->HeaderLength));
}


__inline
static
PPERF_OBJECT_TYPE
NextObject (
    PPERF_OBJECT_TYPE pObject
)
{  // NextObject
    return ((PPERF_OBJECT_TYPE) ((PBYTE) pObject + pObject->TotalByteLength));
}  // NextObject

__inline
static
PERF_COUNTER_DEFINITION *
FirstCounter(
    PERF_OBJECT_TYPE *pObjectDef
)
{
    return (PERF_COUNTER_DEFINITION *)
               ((PCHAR) pObjectDef + pObjectDef->HeaderLength);
}

__inline
static
PERF_COUNTER_DEFINITION *
NextCounter(
    PERF_COUNTER_DEFINITION *pCounterDef
)
{
    return (PERF_COUNTER_DEFINITION *)
               ((PCHAR) pCounterDef + pCounterDef->ByteLength);
}

__inline
static
BOOL
ValidCtrSizeDef(
    PERF_COUNTER_DEFINITION *pThisCounter
)
{
#define PERF_COUNTER_SIZE_MASK  0x00000300
    DWORD   dwSizeValue = pThisCounter->CounterType & PERF_COUNTER_SIZE_MASK;
    BOOL    bReturn = TRUE;
    if ((dwSizeValue == PERF_SIZE_DWORD) && (pThisCounter->CounterSize != sizeof(DWORD))) {
        bReturn = FALSE;
    } else if ((dwSizeValue == PERF_SIZE_LARGE) && (pThisCounter->CounterSize != sizeof(__int64))) {
        bReturn = FALSE;
    } else if ((dwSizeValue == PERF_SIZE_ZERO) && (pThisCounter->CounterSize != 0)) {
        bReturn = FALSE;
    } // else assume that the variable length value is valid
    return bReturn;
}

_inline
static
DWORD
CtrTypeSize (
    PERF_COUNTER_DEFINITION *pThisCounter
)
{
    DWORD   dwSizeValue = pThisCounter->CounterType & PERF_COUNTER_SIZE_MASK;

    switch (dwSizeValue) {
    case PERF_SIZE_DWORD:
        return sizeof(DWORD);

    case PERF_SIZE_LARGE:
        return sizeof(__int64);

    case PERF_SIZE_ZERO:
        return 0;

    default:
        return (pThisCounter->CounterSize);
    }
}

__inline
static
PERF_INSTANCE_DEFINITION *
FirstInstance(
    PERF_OBJECT_TYPE * pObjectDef)
{
    return (PERF_INSTANCE_DEFINITION * )
               ((PCHAR) pObjectDef + pObjectDef->DefinitionLength);
}

__inline
static
PERF_INSTANCE_DEFINITION *
NextInstance(
    PERF_INSTANCE_DEFINITION * pInstDef)
{
    PERF_COUNTER_BLOCK *pCounterBlock;

    pCounterBlock = (PERF_COUNTER_BLOCK *)
                        ((PCHAR) pInstDef + pInstDef->ByteLength);

    return (PERF_INSTANCE_DEFINITION * )
               ((PCHAR) pCounterBlock + pCounterBlock->ByteLength);
}

__inline
static
LPCWSTR
GetInstanceName(
    PERF_INSTANCE_DEFINITION *pInstDef
)
{
    static WCHAR    szLocalName[MAX_PATH];
    LPWSTR  szSrc, szDest;

    assert ((pInstDef->NameLength) < (MAX_PATH * sizeof(WCHAR)));
    szDest = &szLocalName[0];
    szSrc = (LPWSTR) ((PCHAR) pInstDef + pInstDef->NameOffset); 

    while (*szSrc != 0) {
        switch (*szSrc) {
        case '\\':
            *szDest++ = *szSrc;
            *szDest++ = *szSrc++;
            break;

        default:
            *szDest++ = *szSrc++;
        };
    }
    *szDest++ = 0;

    return (LPCWSTR)&szLocalName[0];
}

void
PrintMofHeader ()
{
    WCHAR	szPrintBuffer[8192];
    DWORD   dwLength = 8192;
	DWORD	dwStatus;

	dwStatus = GenerateMofHeader (szPrintBuffer, szComputerName, &dwLength);

	if (dwStatus == ERROR_SUCCESS) {
		printf ("%ls", szPrintBuffer);
	}
}

void
PrintMofObject (
    PERF_OBJECT_TYPE    *pPerfObject,
    BOOL                bRawDefinition,
    BOOL                bCostlyObject,
	BOOL				bDefaultObject
)
{
    WCHAR	szPrintBuffer[8192*2];
    DWORD   dwLength = 8192*2;
	DWORD	dwStatus;
	DWORD	dwFlags;

	dwFlags = 0;
	dwFlags |= (bRawDefinition ? WM_GMO_RAW_DEFINITION : 0);
    dwFlags |= (bCostlyObject ? WM_GMO_COSTLY_OBJECT : 0);
	dwFlags |= (bDefaultObject ? WM_GMO_DEFAULT_OBJECT : 0); 

	dwStatus = GenerateMofObject (
		szPrintBuffer,
		&dwLength,
		NULL,
		pPerfObject,
		lpCounterText,
		lpDisplayText,
		dwFlags);

	if (dwStatus == ERROR_SUCCESS) {
		printf ("%ls", szPrintBuffer);
	}
}

void
PrintMofCounter (
    PERF_COUNTER_DEFINITION *pPerfCounter,
    BOOL                    bRawDefinition,
	BOOL					bDefaultCounter
)
{
    WCHAR	szPrintBuffer[8192*2];
    DWORD   dwLength = 8192*2;
	DWORD	dwStatus;
	DWORD	dwFlags;

	dwFlags = 0;
	dwFlags |= (bRawDefinition ? WM_GMO_RAW_DEFINITION : 0);
	dwFlags |= (bDefaultCounter ? WM_GMO_DEFAULT_COUNTER : 0); 

	dwStatus = GenerateMofCounter (
		szPrintBuffer,
		&dwLength,
		pPerfCounter,
		lpCounterText,
		lpDisplayText,
		dwFlags);

	if (dwStatus == ERROR_SUCCESS) {
		printf ("%ls", szPrintBuffer);
	}
}

void
PrintMofInstances (
    PERF_DATA_BLOCK *  pPerfDataBlock,
    PERF_OBJECT_TYPE * pPerfObject,
    BOOL                bRawDefinition
)
{
    WCHAR	szPrintBuffer[8192*2];
    DWORD   dwLength = 8192*2;
	DWORD	dwStatus;
	DWORD	dwFlags;

	dwFlags = 0;
	dwFlags |= (bRawDefinition ? WM_GMO_RAW_DEFINITION : 0);

	dwStatus = GenerateMofInstances (
		szPrintBuffer,
		&dwLength,
		pPerfDataBlock,
		pPerfObject,
		lpCounterText,	// name strings array
		lpDisplayText,
		dwFlags);

	if (dwStatus == ERROR_SUCCESS) {
		printf ("%ls", szPrintBuffer);
	}
}

LPCSTR
GetCounterType(
    DWORD CounterType
)
{
    switch (CounterType) {
         case PERF_COUNTER_COUNTER:
               return (PerfCounterCounter);

         case PERF_COUNTER_TIMER:
               return (PerfCounterTimer);

         case PERF_COUNTER_QUEUELEN_TYPE:
               return (PerfCounterQueueLen);

         case PERF_COUNTER_LARGE_QUEUELEN_TYPE:
               return (PerfCounterLargeQueueLen);

         case PERF_COUNTER_100NS_QUEUELEN_TYPE:
               return (PerfCounter100NsQueLenType);

         case PERF_COUNTER_OBJ_TIME_QUEUELEN_TYPE:
               return (PerfCounterObjTimeQueLenType);

         case PERF_COUNTER_BULK_COUNT:
               return (PerfCounterBulkCount);

         case PERF_COUNTER_TEXT:
               return (PerfCounterText);

         case PERF_COUNTER_RAWCOUNT:
               return (PerfCounterRawcount);

         case PERF_COUNTER_LARGE_RAWCOUNT:
               return (PerfCounterLargeRawcount);

         case PERF_COUNTER_RAWCOUNT_HEX:
               return (PerfCounterRawcountHex);

         case PERF_COUNTER_LARGE_RAWCOUNT_HEX:
               return (PerfCounterLargeRawcountHex);

         case PERF_SAMPLE_FRACTION:
               return (PerfSampleFraction);

         case PERF_SAMPLE_COUNTER:
               return (PerfSampleCounter);

         case PERF_COUNTER_NODATA:
               return (PerfCounterNodata);

         case PERF_COUNTER_TIMER_INV:
               return (PerfCounterTimerInv);

         case PERF_SAMPLE_BASE:
               return (PerfSampleBase);

         case PERF_AVERAGE_TIMER:
               return (PerfAverageTimer);

         case PERF_AVERAGE_BASE:
               return (PerfAverageBase);

         case PERF_AVERAGE_BULK:
               return (PerfAverageBulk);
    
         case PERF_OBJ_TIME_TIMER:
               return (PerfObjTimeTimer);

         case PERF_100NSEC_TIMER:
               return (Perf100nsecTimer);

         case PERF_100NSEC_TIMER_INV:
               return (Perf100nsecTimerInv);

         case PERF_COUNTER_MULTI_TIMER:
               return (PerfCounterMultiTimer);

         case PERF_COUNTER_MULTI_TIMER_INV:
               return (PerfCounterMultiTimerInv);

         case PERF_COUNTER_MULTI_BASE:
               return (PerfCounterMultiBase);

         case PERF_100NSEC_MULTI_TIMER:
               return (Perf100nsecMultiTimer);

         case PERF_100NSEC_MULTI_TIMER_INV:
               return (Perf100nsecMultiTimerInv);

         case PERF_RAW_FRACTION:
               return (PerfRawFraction);

         case PERF_LARGE_RAW_FRACTION:
               return (PerfLargeRawFraction);

         case PERF_RAW_BASE:
               return (PerfRawBase);

         case PERF_LARGE_RAW_BASE:
               return (PerfLargeRawBase);

         case PERF_ELAPSED_TIME:
               return (PerfElapsedTime);

         case PERF_COUNTER_HISTOGRAM_TYPE:
               return (PerfCounterHistogramType);

         case PERF_COUNTER_DELTA:
                return (PerfCounterDelta);

         case PERF_COUNTER_LARGE_DELTA:
                return (PerfCounterLargeDelta);

         case PERF_PRECISION_SYSTEM_TIMER:
                return (PerfPrecisionSystemTimer);

         case PERF_PRECISION_100NS_TIMER:
                return (PerfPrecision100NsTimer);

         case PERF_PRECISION_OBJECT_TIMER:
                return (PerfPrecisionObjectTimer);

         default:
               return (NotDefineCounterType);
    }
}

void
DisplayUsage (
    void
)
{

    printf("\nCtrList - Lists all the objects and counters installed in\n");
    printf("          the system for the given language ID\n");
    printf("\nUsage:  ctrlist [-cmd] [LangID] [\\\\machine] > <filename>\n");
    printf("\n -c prints data in a CSV format");
    printf("\n -m prints data as a WBEM MOF");
    printf("\n -d prints data as a WBEM MOF with perf data instances defined");
    printf("\n (note: only one of the above command switches may be used");
    printf("\n   LangID  - 009 for English (default)\n");
    printf("           - 007 for German\n");
    printf("           - 00A for Spanish\n");
    printf("           - 00C for French\n");
    printf("   \\\\machine may be specified to list counters on a\n");
    printf("           remote system\n\n");
    printf("   Example - \"ctrlist 00C > french.lst\" will get all the\n");
    printf("   objects and counters for the French system and put\n");
    printf("   them in the file french.lst\n");


    return;

} /* DisplayUsage() */

LPWSTR
*BuildNameTable(
    HKEY    hKeyRegistry,   // handle to registry db with counter names
    LPWSTR  lpszLangId,     // unicode value of Language subkey
    PDWORD  pdwLastItem     // size of array in elements
)
/*++
   
BuildNameTable

Arguments:

    hKeyRegistry
            Handle to an open registry (this can be local or remote.) and
            is the value returned by RegConnectRegistry or a default key.

    lpszLangId
            The unicode id of the language to look up. (default is 409)

Return Value:
     
    pointer to an allocated table. (the caller must free it when finished!)
    the table is an array of pointers to zero terminated strings. NULL is
    returned if an error occured.

--*/
{

    LPWSTR  *lpReturnValue;

    LPWSTR  *lpCounterId;
    LPWSTR  lpCounterNames;
    LPWSTR  lpHelpText;

    LPWSTR  lpThisName;

    LONG    lWin32Status;
    DWORD   dwLastError;
    DWORD   dwValueType;
    DWORD   dwArraySize;
    DWORD   dwBufferSize;
    DWORD   dwCounterSize;
    DWORD   dwHelpSize;
    DWORD   dwThisCounter;
    
    DWORD   dwSystemVersion;
    DWORD   dwLastId;
    DWORD   dwLastHelpId;
    
    HKEY    hKeyValue;
    HKEY    hKeyNames;

    LPWSTR  lpValueNameString;
    WCHAR   CounterNameBuffer [50];
    WCHAR   HelpNameBuffer [50];



    lpValueNameString = NULL;   //initialize to NULL
    lpReturnValue = NULL;
    hKeyValue = NULL;
    hKeyNames = NULL;
   
    // check for null arguments and insert defaults if necessary

    if (!lpszLangId) {
        lpszLangId = (LPWSTR)DefaultLangId;
    }

    // open registry to get number of items for computing array size

    lWin32Status = RegOpenKeyEx (
        hKeyRegistry,
        NamesKey,
        RESERVED,
        KEY_READ,
        &hKeyValue);
    
    if (lWin32Status != ERROR_SUCCESS) {
        goto BNT_BAILOUT;
    }

    // get number of items
    
    dwBufferSize = sizeof (dwLastHelpId);
    lWin32Status = RegQueryValueEx (
        hKeyValue,
        LastHelp,
        RESERVED,
        &dwValueType,
        (LPBYTE)&dwLastHelpId,
        &dwBufferSize);

    if ((lWin32Status != ERROR_SUCCESS) || (dwValueType != REG_DWORD)) {
        goto BNT_BAILOUT;
    }

    // get number of items
    
    dwBufferSize = sizeof (dwLastId);
    lWin32Status = RegQueryValueEx (
        hKeyValue,
        LastCounter,
        RESERVED,
        &dwValueType,
        (LPBYTE)&dwLastId,
        &dwBufferSize);

    if ((lWin32Status != ERROR_SUCCESS) || (dwValueType != REG_DWORD)) {
        goto BNT_BAILOUT;
    }


    if (dwLastId < dwLastHelpId)
        dwLastId = dwLastHelpId;

    dwArraySize = dwLastId * sizeof(LPWSTR);

    // get Perflib system version
    dwBufferSize = sizeof (dwSystemVersion);
    lWin32Status = RegQueryValueEx (
        hKeyValue,
        VersionName,
        RESERVED,
        &dwValueType,
        (LPBYTE)&dwSystemVersion,
        &dwBufferSize);

    if ((lWin32Status != ERROR_SUCCESS) || (dwValueType != REG_DWORD)) {
        dwSystemVersion = OLD_VERSION;
    }

    if (dwSystemVersion == OLD_VERSION) {
        // get names from registry
        lpValueNameString = MemoryAllocate (
            lstrlen(NamesKey) * sizeof (WCHAR) +
            lstrlen(Slash) * sizeof (WCHAR) +
            lstrlen(lpszLangId) * sizeof (WCHAR) +
            sizeof (UNICODE_NULL));
        
        if (!lpValueNameString) goto BNT_BAILOUT;

        lstrcpy (lpValueNameString, NamesKey);
        lstrcat (lpValueNameString, Slash);
        lstrcat (lpValueNameString, lpszLangId);

        lWin32Status = RegOpenKeyEx (
            hKeyRegistry,
            lpValueNameString,
            RESERVED,
            KEY_READ,
            &hKeyNames);
    } else {
        if (szComputerName[0] == 0) {
            hKeyNames = HKEY_PERFORMANCE_DATA;
        } else {
            lWin32Status = RegConnectRegistry (szComputerName,
                HKEY_PERFORMANCE_DATA,
                &hKeyNames);
        }
        lstrcpy (CounterNameBuffer, CounterName);
        lstrcat (CounterNameBuffer, lpszLangId);

        lstrcpy (HelpNameBuffer, HelpName);
        lstrcat (HelpNameBuffer, lpszLangId);
    }

    // get size of counter names and add that to the arrays
    
    if (lWin32Status != ERROR_SUCCESS) goto BNT_BAILOUT;

    dwBufferSize = 0;
    lWin32Status = RegQueryValueEx (
        hKeyNames,
        dwSystemVersion == OLD_VERSION ? Counters : CounterNameBuffer,
        RESERVED,
        &dwValueType,
        NULL,
        &dwBufferSize);

    if (lWin32Status != ERROR_SUCCESS) goto BNT_BAILOUT;

    dwCounterSize = dwBufferSize;

    // get size of counter names and add that to the arrays
    
    if (lWin32Status != ERROR_SUCCESS) goto BNT_BAILOUT;

    dwBufferSize = 0;
    lWin32Status = RegQueryValueEx (
        hKeyNames,
        dwSystemVersion == OLD_VERSION ? Help : HelpNameBuffer,
        RESERVED,
        &dwValueType,
        NULL,
        &dwBufferSize);

    if (lWin32Status != ERROR_SUCCESS) goto BNT_BAILOUT;
   
    dwHelpSize = dwBufferSize;

    lpReturnValue = MemoryAllocate (dwArraySize + dwCounterSize + dwHelpSize);

    if (!lpReturnValue) goto BNT_BAILOUT;

    // initialize pointers into buffer

    lpCounterId = lpReturnValue;
    lpCounterNames = (LPWSTR)((LPBYTE)lpCounterId + dwArraySize);
    lpHelpText = (LPWSTR)((LPBYTE)lpCounterNames + dwCounterSize);

    // read counters into memory

    dwBufferSize = dwCounterSize;
    lWin32Status = RegQueryValueEx (
        hKeyNames,
        dwSystemVersion == OLD_VERSION ? Counters : CounterNameBuffer,
        RESERVED,
        &dwValueType,
        (LPVOID)lpCounterNames,
        &dwBufferSize);

    if (!lpReturnValue) goto BNT_BAILOUT;
 
    dwBufferSize = dwHelpSize;
    lWin32Status = RegQueryValueEx (
        hKeyNames,
        dwSystemVersion == OLD_VERSION ? Help : HelpNameBuffer,
        RESERVED,
        &dwValueType,
        (LPVOID)lpHelpText,
        &dwBufferSize);
                            
    if (!lpReturnValue) goto BNT_BAILOUT;
 
    // load counter array items

    for (lpThisName = lpCounterNames;
         *lpThisName;
         lpThisName += (lstrlen(lpThisName)+1) ) {

        // first string should be an integer (in decimal unicode digits)

        dwThisCounter = wcstoul (lpThisName, NULL, 10);

        if (dwThisCounter == 0) goto BNT_BAILOUT;  // bad entry

        // point to corresponding counter name

        lpThisName += (lstrlen(lpThisName)+1);  

        // and load array element;

        lpCounterId[dwThisCounter] = lpThisName;

    }

    for (lpThisName = lpHelpText;
         *lpThisName;
         lpThisName += (lstrlen(lpThisName)+1) ) {

        // first string should be an integer (in decimal unicode digits)

        dwThisCounter = wcstoul (lpThisName, NULL, 10);

        if (dwThisCounter == 0) goto BNT_BAILOUT;  // bad entry

        // point to corresponding counter name

        lpThisName += (lstrlen(lpThisName)+1);

        // and load array element;

        lpCounterId[dwThisCounter] = lpThisName;

    }
    
    if (pdwLastItem) *pdwLastItem = dwLastId;

    MemoryFree ((LPVOID)lpValueNameString);
    RegCloseKey (hKeyValue);
//    if (dwSystemVersion == OLD_VERSION)
        RegCloseKey (hKeyNames);

    return lpReturnValue;

BNT_BAILOUT:
    if (lWin32Status != ERROR_SUCCESS) {
        dwLastError = GetLastError();
    }

    if (lpValueNameString) {
        MemoryFree ((LPVOID)lpValueNameString);
    }
    
    if (lpReturnValue) {
        MemoryFree ((LPVOID)lpReturnValue);
    }
    
    if (hKeyValue) RegCloseKey (hKeyValue);

//    if (dwSystemVersion == OLD_VERSION &&
//        hKeyNames) 
       RegCloseKey (hKeyNames);


    return NULL;
}

LONG
GetEnumPerfData (
    IN HKEY hKeySystem,
    IN DWORD dwIndex,
    IN PPERF_DATA_BLOCK *pPerfData
)
{  // GetSystemPerfData
    LONG     lError ;
    DWORD    Size;
    DWORD    Type;

    if (dwIndex >= 2)
        return !ERROR_SUCCESS;

    if (*pPerfData == NULL) {
        *pPerfData = MemoryAllocate (INITIAL_SIZE);
        if (*pPerfData == NULL) { 
            return ERROR_OUTOFMEMORY;
	    }
    }
#pragma warning ( disable : 4127 )
    while (TRUE) {
        Size = MemorySize (*pPerfData);
   
        lError = RegQueryValueEx (
            hKeySystem,
            dwIndex == 0 ?
               (LPCWSTR)L"Global" :
               (LPCWSTR)L"Costly",
            RESERVED,
            &Type,
            (LPBYTE)*pPerfData,
            &Size);

        if ((!lError) &&
            (Size > 0) &&
            (*pPerfData)->Signature[0] == (WCHAR)'P' &&
            (*pPerfData)->Signature[1] == (WCHAR)'E' &&
            (*pPerfData)->Signature[2] == (WCHAR)'R' &&
            (*pPerfData)->Signature[3] == (WCHAR)'F' ) {

            return (ERROR_SUCCESS);
        }

        if (lError == ERROR_MORE_DATA) {
            *pPerfData = MemoryResize (
                *pPerfData, 
                MemorySize (*pPerfData) +
                EXTEND_SIZE);

            if (!*pPerfData) {
                return (lError);
            }
        } else {
            return (lError);  
        }  // else
    }
#pragma warning ( default : 4127 )

}  // GetSystemPerfData

LONG
PrintHelpText(
    DWORD   Indent,
    DWORD   dwID,
    LPWSTR  szTextString
)
{
    LPWSTR  szThisChar;

    BOOL    bNewLine;

    DWORD   dwThisPos;
    DWORD   dwLinesUsed;

    szThisChar = szTextString;
    dwLinesUsed = 0;

    // check arguments

    if (!szTextString) {
        return dwLinesUsed;
    }
    
    if (Indent > WRAP_POINT) {
        return dwLinesUsed; // can't do this
    }

    // display id number 

    for (dwThisPos = 0; dwThisPos < Indent - 6; dwThisPos++) {
        putchar (' ');
    }

    dwThisPos += printf ("[%3.3d] ", dwID);
    bNewLine = FALSE;

    // print text

    while (*szThisChar) {

        if (bNewLine){
            for (dwThisPos = 0; dwThisPos < Indent; dwThisPos++) {
                putchar (' ');
            }

            bNewLine = FALSE;
        }
        if ((*szThisChar == L' ') && (dwThisPos >= WRAP_POINT)) {
            putchar ('\n');
            bNewLine = TRUE;
            // go to next printable character
            while (*szThisChar <= L' ') {
                szThisChar++;
            }
            dwLinesUsed++;
        } else {
            putchar (*szThisChar);
            szThisChar++;
        }

        dwThisPos++;
    }

    putchar ('\n');
    bNewLine = TRUE;
    dwLinesUsed++;

    return dwLinesUsed;
}

#pragma warning ( disable : 4706 )
int
__cdecl main(
    int argc,
    char *argv[]
    )
{
    int     ArgNo;

    DWORD   dwLastElement;

    DWORD   dwIndex;
    
    DWORD   dwDisplayLevel;

    PPERF_DATA_BLOCK   pDataBlock; // pointer to perfdata block
    BOOL   bError;

    DWORD   dwThisObject;
    DWORD   dwThisCounter;
    CHAR    LangID[10];
    WCHAR   wLangID[10];
    BOOL    UseDefaultID = FALSE;
    LPSTR   szComputerNameArg = NULL;
    DWORD   dwLoop;
    DWORD   dwLoopEnd;
    DWORD   dwErrorCount;
    DWORD   dwStatus;

    PPERF_OBJECT_TYPE   pThisObject;
    PPERF_COUNTER_DEFINITION pThisCounter;

    HKEY    hKeyMachine = HKEY_LOCAL_MACHINE;
    HKEY    hKeyPerformance = HKEY_PERFORMANCE_DATA;

    dwDisplayLevel = PERF_DETAIL_WIZARD;
    
    // open key to registry or use default

    if (argc >= 2) {
        if ((argv[1][0] == '-' || argv[1][0] == '/') &&
             argv[1][1] == '?') {
            DisplayUsage();
            return 0;
        }

        if (argv[1][0] != '\\') {
            if ((argv[1][0] == '-') || (argv[1][0] == '/')) {
                // then this is a command switch
                if ((argv[1][1] == 'c') || (argv[1][1] == 'C')) {
                    // then format is a CSV
                    bFormatCSV = TRUE;
                } else if ((argv[1][1] == 'm') || (argv[1][1] == 'M')) {
                    // then format is a MOF
                    bFormatMOF = TRUE;
                } else if ((argv[1][1] == 'd') || (argv[1][1] == 'D')) {
                    // then format is a MOF w/ data
                    bFormatMOF = TRUE;
                    bPrintMOFData = TRUE;
                } else if ((argv[1][1] == 'e') || (argv[1][1] == 'E')) {
                    bCheckCtrType = TRUE;
                }
                ArgNo = 2;
            } else {
                ArgNo = 1;
            }

            if (argc > ArgNo) {
                // get the lang ID
                if (argv[ArgNo][0] != '\\') {
                    LangID[0] = argv[ArgNo][0];        
                    LangID[1] = argv[ArgNo][1];        
                    LangID[2] = argv[ArgNo][2];        
                    LangID[3] = '\0';
                    mbstowcs(wLangID, LangID, 4);
                    ++ArgNo;
                } else {
                    lstrcpyW (wLangID, (LPCWSTR)L"009");
                }

                if (argc > (ArgNo)) {
                    // see if the next arg is a computer name
                    if (argv[ArgNo][0] == '\\') {
                        mbstowcs (szComputerName, argv[ArgNo],
                            MAX_COMPUTERNAME_LENGTH);
                        szComputerNameArg = argv[ArgNo];
                    } else {
                        szComputerName[0] = 0;
                    }
                }
            }
        } else {
            // 1st arg is a computer name
            mbstowcs (szComputerName, argv[1], MAX_COMPUTERNAME_LENGTH);
            szComputerNameArg = argv[1];
        }

#if 0
        // get user level from command line
        if (argc > 2 && sscanf(argv[2], " %d", &dwDisplayLevel) == 1) {
            if (dwDisplayLevel <= PERF_DETAIL_NOVICE) {
                dwDisplayLevel = PERF_DETAIL_NOVICE;
            } else if (dwDisplayLevel <= PERF_DETAIL_ADVANCED) {
                dwDisplayLevel = PERF_DETAIL_ADVANCED;
            } else if (dwDisplayLevel <= PERF_DETAIL_EXPERT) {
                dwDisplayLevel = PERF_DETAIL_EXPERT;
            } else {
                dwDisplayLevel = PERF_DETAIL_WIZARD;
            }
        } else {
            dwDisplayLevel = PERF_DETAIL_WIZARD;
        }
#endif

    } else {
        UseDefaultID = TRUE;
        szComputerName[0] = 0;
    }

    if (szComputerName[0] != 0) {
        if (RegConnectRegistry (szComputerName, HKEY_LOCAL_MACHINE,
            &hKeyMachine) != ERROR_SUCCESS) {
            printf ("\nUnable to connect to %s", szComputerNameArg);
            return 0;
        }
        dwStatus = RegConnectRegistry (szComputerName, HKEY_PERFORMANCE_DATA,
            &hKeyPerformance);
        if (dwStatus  != ERROR_SUCCESS) {
            printf ("\nUnable to connect to %s", szComputerNameArg);
            return 0;
        }
    } else {
        // use default initializations
    }

    lpCounterText = BuildNameTable (
        hKeyMachine,
        (LPWSTR)(DefaultLangId),	// counter text is in ENGLISH always
        &dwLastElement);

    if (!lpCounterText) {
        printf("***FAILure*** Cannot open the registry\n");
        return 0;
    }

    lpDisplayText = BuildNameTable (
        hKeyMachine,
        (LPWSTR)(UseDefaultID ? DefaultLangId : wLangID),
        &dwLastElement);

    if (!lpDisplayText) {
        printf("***FAILure*** Cannot open the registry\n");
        return 0;
    }

    if (bFormatMOF) {
        // then print the header block
        PrintMofHeader ();
    }

    // get a performance data buffer with counters

    pDataBlock = 0;


    for (dwIndex = 0; (bError = GetEnumPerfData (  
        hKeyPerformance,
        dwIndex,
        &pDataBlock) == ERROR_SUCCESS); dwIndex++) {

        for (dwThisObject = 0, pThisObject = FirstObject (pDataBlock);
            dwThisObject < pDataBlock->NumObjectTypes;
            dwThisObject++, pThisObject = NextObject(pThisObject)) {

            if (bFormatMOF) {
                if (bPrintMOFData) {
                    dwLoopEnd = 2;
                } else {
                    dwLoopEnd = 1;
                }
            } else {
                dwLoopEnd = 0;
            }

            dwLoop = 0;
            do {
                if (bFormatCSV) {
                    printf (fmtObjectRecord,
                        pThisObject->ObjectNameTitleIndex,
                        lpDisplayText[pThisObject->ObjectNameTitleIndex],
                        pThisObject->DetailLevel <= MAX_LEVEL ?
                            DetailLevelStr[pThisObject->DetailLevel/100-1] :
                            "<N\\A>",
                        pThisObject->NumInstances == PERF_NO_INSTANCES ?
                            0 : 1,
                        pThisObject->CodePage,
                        pThisObject->ObjectHelpTitleIndex,
                        lpDisplayText[pThisObject->ObjectHelpTitleIndex]);
                } else if (bFormatMOF) {
                    if (dwLoop < 2) PrintMofObject (pThisObject, 
                            (dwLoop == 0 ? FALSE : TRUE),
                            (dwIndex == 0 ? FALSE : TRUE),
							((DWORD)pDataBlock->DefaultObject == 
								pThisObject->ObjectNameTitleIndex ? TRUE : FALSE));
                } else {
                    printf ("\nObject: \"%ws\"  [%3.3d]",
                        lpDisplayText[pThisObject->ObjectNameTitleIndex],
                        pThisObject->ObjectNameTitleIndex);
                    if (!bCheckCtrType) {
                        printf ("\n   Detail Level: %s\n",
                            pThisObject->DetailLevel <= MAX_LEVEL ?
                            DetailLevelStr[pThisObject->DetailLevel/100-1] :
                            "<N\\A>");
                   
                        PrintHelpText (9,
                            pThisObject->ObjectHelpTitleIndex,
                            lpDisplayText[pThisObject->ObjectHelpTitleIndex]);
                    }
                }

                dwErrorCount = 0;

                for (dwThisCounter = 0, pThisCounter = FirstCounter(pThisObject);
                    dwThisCounter < pThisObject->NumCounters;
                    dwThisCounter++, pThisCounter = NextCounter(pThisCounter)) {

                    __try {
                        if (pThisCounter->DetailLevel <= dwDisplayLevel) {
                            if (bFormatCSV) {
                                printf (fmtCounterRecord,
                                    pThisObject->ObjectNameTitleIndex,
                                    lpDisplayText[pThisObject->ObjectNameTitleIndex],
                                    pThisCounter->CounterNameTitleIndex,
                                    lpDisplayText[pThisCounter->CounterNameTitleIndex],
                                    ((pThisCounter->DetailLevel <= MAX_LEVEL)  &&
                                        (pThisCounter->DetailLevel > 0 )) ?
                                        DetailLevelStr[pThisCounter->DetailLevel/100-1] :
                                        "<N\\A>",
                                    pThisCounter->CounterType,
                                    GetCounterType(pThisCounter->CounterType),
                                    pThisCounter->CounterSize,
                                    IsDisplayableType(pThisCounter->CounterType) ?
                                        1 : 0,
                                    pThisCounter->CounterHelpTitleIndex,
                                    lpDisplayText[pThisCounter->CounterHelpTitleIndex]);
                            } else if (bFormatMOF) {
                                if (dwLoop < 2) {
                                    PrintMofCounter (pThisCounter, 
										(dwLoop == 0 ? FALSE : TRUE),
										(dwThisCounter == (DWORD)pThisObject->DefaultCounter ? TRUE : FALSE));
                                }
                            } else if (bCheckCtrType) {
                                if (!ValidCtrSizeDef(pThisCounter)) {
                                    printf ("\n    [%3.3d] \"%ws\" data size should be %d bytes, but reports a size of %d bytes",
                                        pThisCounter->CounterNameTitleIndex,
                                        lpDisplayText[pThisCounter->CounterNameTitleIndex],
                                        CtrTypeSize (pThisCounter),
                                        pThisCounter->CounterSize);
                                    dwErrorCount++;
                                }
                            } else {
                                printf ("\n    <%ws> [%3.3d]",
                                    lpDisplayText[pThisCounter->CounterNameTitleIndex],
                                    pThisCounter->CounterNameTitleIndex);
                                printf ("\n          Default Scale: %d",
                                    pThisCounter->DefaultScale);
                                printf ("\n          Detail Level: %s",
                                    ((pThisCounter->DetailLevel <= MAX_LEVEL)  &&
                                    (pThisCounter->DetailLevel > 0 ))?
                                    DetailLevelStr[pThisCounter->DetailLevel/100-1] :
                                    "<N\\A>");
                                printf ("\n          Counter Type: 0x%x, %s",
                                    pThisCounter->CounterType,
                                    GetCounterType(pThisCounter->CounterType));
                                printf ("\n          Counter Size: %d bytes",
                                    pThisCounter->CounterSize);

                                printf ("\n");
                                PrintHelpText (16,
                                    pThisCounter->CounterHelpTitleIndex,
                                    lpDisplayText[pThisCounter->CounterHelpTitleIndex]);
                            }
                        } // end if the right detail level
                    } __except (EXCEPTION_EXECUTE_HANDLER) {
                        if (!bFormatCSV) {
                            printf ("\n          Error (%d) reading this counter",
                                GetExceptionCode());
                        }
                    }
                }  // end for each counter

                if ((dwLoop == 2) && bFormatMOF) {
                    // dump data for raw classes only
                    PrintMofInstances (pDataBlock, pThisObject, TRUE);
                } 

                // close up object text
                if ((bFormatMOF) && (dwLoop != 2)) {
                    //{ brace inserted to not throw off the brace counter
                    printf("\n};\n");
                }

                if (bCheckCtrType) {
                    printf ("\n    %d bad counters in this object.\n",
                        dwErrorCount);
                } else {
                    printf ("\n");
                }


            } while (dwLoop++ < dwLoopEnd); // end while
        }
        RegCloseKey (hKeyPerformance);
        if (szComputerName[0] != 0) {
            RegCloseKey (hKeyMachine);
        }
    }

	if (lpDisplayText != NULL) MemoryFree (lpDisplayText);
	if (lpCounterText != NULL) MemoryFree (lpCounterText);

    return 0;
}
#pragma warning ( default : 4706)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cntrtext\initodat\fileutl.c ===
/*++

Copyright (c) 1993-1994  Microsoft Corporation

Module Name:

    fileutl.c

Abstract:

    Routines for getting data from ini file

Author:

    HonWah Chan (a-honwah)  October, 1993

Revision History:

--*/

#include "initodat.h"
#include "strids.h"
#include "common.h"
#include "winerror.h"

NTSTATUS
DatReadMultiSzFile(
#ifdef FE_SB
    IN UINT uCodePage,
#endif
    IN PUNICODE_STRING FileName,
    OUT PVOID *ValueBuffer,
    OUT PULONG ValueLength
    )
{
    NTSTATUS Status;
    UNICODE_STRING NtFileName;
    PWSTR s;
    UNICODE_STRING MultiSource;
    UNICODE_STRING MultiValue;
    REG_UNICODE_FILE MultiSzFile;
    ULONG MultiSzFileSize;

    if (ValueBuffer == NULL || ValueLength == NULL) {
        return STATUS_INVALID_PARAMETER;
    }

    FileName->Buffer[ FileName->Length/sizeof(WCHAR) ] = UNICODE_NULL;

    RtlDosPathNameToNtPathName_U( FileName->Buffer,
                                  &NtFileName,
                                  NULL,
                                  NULL );

    #ifdef FE_SB
    Status = DatLoadAsciiFileAsUnicode( uCodePage, &NtFileName,  &MultiSzFile );
    #else
    Status = DatLoadAsciiFileAsUnicode( &NtFileName, &MultiSzFile );
    #endif

    if (!NT_SUCCESS( Status )) {
        return( Status );
    }

    MultiSzFileSize = (ULONG)(MultiSzFile.EndOfFile -
                       MultiSzFile.NextLine) * sizeof(WCHAR);

    *ValueLength = 0;
    *ValueBuffer = RtlAllocateHeap( RtlProcessHeap(), 0,
                                    MultiSzFileSize);
    if (* ValueBuffer == NULL) {
        return STATUS_NO_MEMORY;
    }

    MultiSource.Buffer = MultiSzFile.NextLine;
    if (MultiSzFileSize <= MAXUSHORT) {
        MultiSource.Length =
        MultiSource.MaximumLength = (USHORT)MultiSzFileSize;
    } else {
        MultiSource.Length =
        MultiSource.MaximumLength = MAXUSHORT;
    }

    while (DatGetMultiString(&MultiSource, &MultiValue)) {
        RtlMoveMemory( (PUCHAR)*ValueBuffer + *ValueLength,
                       MultiValue.Buffer,
                       MultiValue.Length );
        *ValueLength += MultiValue.Length;

        s = MultiSource.Buffer;
        while ( *s != L'"' &&
                *s != L',' &&
                ((s - MultiSource.Buffer) * sizeof(WCHAR)) <
                    MultiSource.Length ) s++;
        if ( ((s - MultiSource.Buffer) * sizeof(WCHAR)) ==
             MultiSource.Length ||
             *s == L',' ||
             *s == L';'   ) {

            ((PWSTR)*ValueBuffer)[ *ValueLength / sizeof(WCHAR) ] =
                UNICODE_NULL;
            *ValueLength += sizeof(UNICODE_NULL);
            if ( *s ==  L';' ) {
                break;
            }
        }

        if ( (MultiSzFile.EndOfFile - MultiSource.Buffer) * sizeof(WCHAR) >=
              MAXUSHORT ) {
            MultiSource.Length =
            MultiSource.MaximumLength = MAXUSHORT;
        } else {
            MultiSource.Length =
            MultiSource.MaximumLength =
                (USHORT)((MultiSzFile.EndOfFile - MultiSource.Buffer) *
                         sizeof(WCHAR));
        }
    }

    ((PWSTR)*ValueBuffer)[ *ValueLength / sizeof(WCHAR) ] = UNICODE_NULL;
    *ValueLength += sizeof(UNICODE_NULL);

    // Virtual memory for reading of MultiSzFile freed at process
    // death?

    return( TRUE );
}

NTSTATUS
DatLoadAsciiFileAsUnicode(
#ifdef FE_SB
    IN UINT uCodePage,
#endif
    IN PUNICODE_STRING FileName,
    OUT PREG_UNICODE_FILE UnicodeFile
    )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatus;
    HANDLE File;
    FILE_BASIC_INFORMATION FileDateTimeInfo;
    FILE_STANDARD_INFORMATION FileInformation;
    SIZE_T BufferSize;
    ULONG i, i1, LineCount;
    PVOID BufferBase;
    PCHAR Src = NULL;
    PCHAR Src1;
    PWSTR Dst = NULL;

    memset (&FileDateTimeInfo, 0, sizeof(FileDateTimeInfo));

    InitializeObjectAttributes( &ObjectAttributes,
                                FileName,
                                OBJ_CASE_INSENSITIVE,
                                (HANDLE)NULL,
                                NULL
                              );

    Status = NtOpenFile( &File,
                         SYNCHRONIZE | GENERIC_READ,
                         &ObjectAttributes,
                         &IoStatus,
                         FILE_SHARE_DELETE |
                            FILE_SHARE_READ |
                            FILE_SHARE_WRITE,
                         FILE_SYNCHRONOUS_IO_NONALERT |
                            FILE_NON_DIRECTORY_FILE
                       );
    if (!NT_SUCCESS( Status )) {
        return( Status );
        }

    Status = NtQueryInformationFile( File,
                                     &IoStatus,
                                     (PVOID)&FileInformation,
                                     sizeof( FileInformation ),
                                     FileStandardInformation
                                   );
    if (NT_SUCCESS( Status )) {
        if (FileInformation.EndOfFile.HighPart) {
            Status = STATUS_BUFFER_OVERFLOW;
            }
        }
    if (!NT_SUCCESS( Status )) {
        NtClose( File );
        return( Status );
        }

#ifdef FE_SB
    BufferSize = FileInformation.EndOfFile.LowPart * sizeof( WCHAR ) * 2;
#else
    BufferSize = FileInformation.EndOfFile.LowPart * sizeof( WCHAR );
#endif

    BufferSize += sizeof( UNICODE_NULL );
    BufferBase = NULL;
    Status = NtAllocateVirtualMemory( NtCurrentProcess(),
                                      (PVOID *)&BufferBase,
                                      0,
                                      &BufferSize,
                                      MEM_COMMIT,
                                      PAGE_READWRITE
                                    );
    if (NT_SUCCESS( Status )) {
        Src = (PCHAR)BufferBase + ((FileInformation.EndOfFile.LowPart+1) & ~1);
        Dst = (PWSTR)BufferBase;
        Status = NtReadFile( File,
                             NULL,
                             NULL,
                             NULL,
                             &IoStatus,
                             Src,
                             FileInformation.EndOfFile.LowPart,
                             NULL,
                             NULL
                           );

        if (NT_SUCCESS( Status )) {
            Status = IoStatus.Status;

            if (NT_SUCCESS( Status )) {
                if (IoStatus.Information != FileInformation.EndOfFile.LowPart) {
                    Status = STATUS_END_OF_FILE;
                    }
                else {
                    Status = NtQueryInformationFile( File,
                                                     &IoStatus,
                                                     (PVOID)&FileDateTimeInfo,
                                                     sizeof( FileDateTimeInfo ),
                                                     FileBasicInformation
                                                   );
                    }
                }
            }

        if (!NT_SUCCESS( Status )) {
            NtFreeVirtualMemory( NtCurrentProcess(),
                                 (PVOID *)&BufferBase,
                                 &BufferSize,
                                 MEM_RELEASE
                               );
            }
        }

    NtClose( File );
    if (!NT_SUCCESS( Status )) {
        return( Status );
        }

    i = 0;
    while (i < FileInformation.EndOfFile.LowPart) {

        if (i > 1 && (Src[-2] == ' ' || Src[-2] == '\t') &&
            Src[-1] == '\\' && (*Src == '\r' || *Src == '\n')
           ) {
            if (Dst[-1] == L'\\') {
                --Dst;
                }
            while (Dst > (PWSTR)BufferBase) {
                if (Dst[-1] > L' ') {
                    break;
                    }
                Dst--;
                }
            LineCount = 0;
            while (i < FileInformation.EndOfFile.LowPart) {
                if (*Src == '\n') {
                    i++;
                    Src++;
                    LineCount++;
                    }
                else
                if (*Src == '\r' &&
                    (i+1) < FileInformation.EndOfFile.LowPart &&
                    Src[ 1 ] == '\n'
                   ) {
                    i += 2;
                    Src += 2;
                    LineCount++;
                    }
                else {
                    break;
                    }
                }

            if (LineCount > 1) {
                *Dst++ = L'\n';
                }
            else {
                *Dst++ = L' ';
                while (i < FileInformation.EndOfFile.LowPart && (*Src == ' ' || *Src == '\t')) {
                    i++;
                    Src++;
                    }
                }

            if (i >= FileInformation.EndOfFile.LowPart) {
                break;
                }
            }
        else
        if ((*Src == '\r' && Src[1] == '\n') || *Src == '\n') {
#pragma warning ( disable : 4127 )
            while (TRUE) {
                while (i < FileInformation.EndOfFile.LowPart && (*Src == '\r' || *Src == '\n')) {
                    i++;
                    Src++;
                    }
                Src1 = Src;
                i1 = i;
                while (i1 < FileInformation.EndOfFile.LowPart && (*Src1 == ' ' || *Src1 == '\t')) {
                    i1++;
                    Src1++;
                    }
                if (i1 < FileInformation.EndOfFile.LowPart &&
                    (*Src1 == '\r' && Src1[1] == '\n') || *Src1 == '\n'
                   ) {
                    Src = Src1;
                    i = i1;
                    }
                else {
                    break;
                    }
                }
#pragma warning ( default : 4127 )

            *Dst++ = L'\n';
            }
        else {
#ifdef FE_SB
            WCHAR UnicodeCharacter;
            LONG cbCharSize = IsDBCSLeadByteEx(uCodePage,*Src) ? 2 : 1;

            if ( MultiByteToWideChar(
                     uCodePage,
                     0,
                     Src,
                     cbCharSize,
                     &UnicodeCharacter,
                     1) == 0) {
                //
                // Check for error - The only time this will happen is if there is
                // a leadbyte without a trail byte.
                //
                UnicodeCharacter = 0x0020;
            }
            i += cbCharSize;
            Src += cbCharSize;
            *Dst++ = UnicodeCharacter;
#else
            i++;
            *Dst++ = RtlAnsiCharToUnicodeChar( &Src );
#endif
            }
        }

    if (NT_SUCCESS( Status )) {
        *Dst = UNICODE_NULL;
        UnicodeFile->FileContents = BufferBase;
        UnicodeFile->EndOfFile = Dst;
        UnicodeFile->BeginLine = NULL;
        UnicodeFile->EndOfLine = NULL;
        UnicodeFile->NextLine = BufferBase;
        UnicodeFile->LastWriteTime = FileDateTimeInfo.LastWriteTime;
        }
    else {
        NtFreeVirtualMemory( NtCurrentProcess(),
                             (PVOID *)&BufferBase,
                             &BufferSize,
                             MEM_RELEASE
                           );
        }

    return( Status );
}

//
//  Define an upcase macro for temporary use by the upcase routines
//

#define upcase(C) (WCHAR )(((C) >= 'a' && (C) <= 'z' ? (C) - ('a' - 'A') : (C)))

BOOLEAN
DatGetMultiString(
    IN OUT PUNICODE_STRING ValueString,
    OUT PUNICODE_STRING MultiString
    )

/*++

Routine Description:

    This routine parses multi-strings of the form

        "foo" "bar" "bletch"

    Each time it is called, it strips the first string in quotes from
    the input string, and returns it as the multi-string.

    INPUT ValueString: "foo" "bar" "bletch"

    OUTPUT ValueString: "bar" "bletch"
           MultiString: foo

Arguments:

    ValueString - Supplies the string from which the multi-string will be
                  parsed
                - Returns the remaining string after the multi-string is
                  removed

    MultiString - Returns the multi-string removed from ValueString

Return Value:

    TRUE - multi-string found and removed.

    FALSE - no more multi-strings remaining.

--*/

{
    //
    // Find the first quote mark.
    //
    while ((*(ValueString->Buffer) != L'"') &&
           (ValueString->Length > 0)) {
        ++ValueString->Buffer;
        ValueString->Length -= sizeof(WCHAR);
        ValueString->MaximumLength -= sizeof(WCHAR);
    }

    if (ValueString->Length == 0) {
        return(FALSE);
    }

    //
    // We have found the start of the multi-string.  Now find the end,
    // building up our return MultiString as we go.
    //
    ++ValueString->Buffer;
    ValueString->Length -= sizeof(WCHAR);
    ValueString->MaximumLength -= sizeof(WCHAR);
    MultiString->Buffer = ValueString->Buffer;
    MultiString->Length = 0;
    MultiString->MaximumLength = 0;
    while ((*(ValueString->Buffer) != L'"') &&
           (ValueString->Length > 0)) {
        ++ValueString->Buffer;
        ValueString->Length -= sizeof(WCHAR);
        ValueString->MaximumLength -= sizeof(WCHAR);

        MultiString->Length += sizeof(WCHAR);
        MultiString->MaximumLength += sizeof(WCHAR);
    }

    if (ValueString->Length == 0) {
        return(FALSE);
    }

    ++ValueString->Buffer;
    ValueString->Length -= sizeof(WCHAR);
    ValueString->MaximumLength -= sizeof(WCHAR);

    return( TRUE );

}

#define EXTENSION_DELIMITER      TEXT('.')
LPTSTR
FindFileExtension (
    IN PUNICODE_STRING FileName
)
{
   LPTSTR          lpszDelimiter ;

   lpszDelimiter = _tcsrchr ((LPCTSTR)FileName->Buffer, (TCHAR)EXTENSION_DELIMITER) ;

   if (lpszDelimiter)
      return lpszDelimiter;
   else
      return (LPTSTR)((PBYTE)FileName->Buffer + FileName->Length - sizeof(WCHAR));
}

BOOL
OutputIniData (
    IN PUNICODE_STRING FileName,
    IN LPTSTR OutFileCandidate,
    IN PVOID  pValueBuffer,
    IN ULONG  ValueLength
   )
{
    HANDLE   hOutFile = NULL;
    LPTSTR   lpExtension = NULL;
    DWORD    nAmtWritten ;
    BOOL     bSuccess ;
    DWORD    ErrorCode ;

    // If output file not specified, derive from input file name

    if (! lstrcmp(OutFileCandidate, (LPCWSTR)L"\0")) {
        lpExtension = FindFileExtension (FileName);
        lstrcpy (lpExtension, (LPCTSTR)TEXT(".dat"));
        lstrcpy (OutFileCandidate, FileName->Buffer);
    }

   hOutFile = (HANDLE) CreateFile (
      OutFileCandidate,
      GENERIC_READ | GENERIC_WRITE,
      FILE_SHARE_READ,
      NULL, CREATE_ALWAYS,
      FILE_ATTRIBUTE_NORMAL, NULL);

   if ((hOutFile == NULL) || (hOutFile == INVALID_HANDLE_VALUE)) {
      ErrorCode = GetLastError();
      printf (GetFormatResource(LC_CANT_CREATE), ErrorCode);
      if (ErrorCode == ERROR_ACCESS_DENIED)
         printf ("%ws\n", GetStringResource(LC_ACCESS_DENIED));
      return FALSE;
      }

   bSuccess = WriteFile (
      hOutFile,
      pValueBuffer,
      ValueLength,
      &nAmtWritten,
      NULL) ;

   bSuccess = bSuccess && (nAmtWritten == ValueLength) ;

   CloseHandle( hOutFile );

   if (!bSuccess) {
      ErrorCode = GetLastError();
      printf (GetFormatResource(LC_CANT_WRITE), ErrorCode);
      if (ErrorCode == ERROR_DISK_FULL)
         printf ("%ws\n", GetStringResource(LC_DISK_FULL));
      }

   return bSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cntrtext\initodat\initodat.h ===
/*++

Copyright (c) 1993-1994  Microsoft Corporation

Module Name:

    initodat.h

Abstract:

    This is the include file for the ini to data file conversion functions.

Author:

    HonWah Chan (a-honwah)  October, 1993

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>

#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <ctype.h>
#include <string.h>
// #include <io.h>
#include <fcntl.h>
#include <malloc.h>
#include <sys\types.h>
#include <sys\stat.h>
#include <tchar.h>


#define VALUE_BUFFER_SIZE (4096 * 100)


typedef struct _REG_UNICODE_FILE {
    LARGE_INTEGER LastWriteTime;
    PWSTR FileContents;
    PWSTR EndOfFile;
    PWSTR BeginLine;
    PWSTR EndOfLine;
    PWSTR NextLine;
} REG_UNICODE_FILE, *PREG_UNICODE_FILE;

NTSTATUS
DatReadMultiSzFile(
#if FE_SB
    UINT uCodePage,
#endif
    IN PUNICODE_STRING FileName,
    OUT PVOID *ValueBuffer,
    OUT PULONG ValueLength
    );

NTSTATUS
DatLoadAsciiFileAsUnicode(
#if FE_SB
    UINT uCodePage,
#endif
    IN PUNICODE_STRING FileName,
    OUT PREG_UNICODE_FILE UnicodeFile
    );


BOOLEAN
DatGetMultiString(
    IN OUT PUNICODE_STRING ValueString,
    OUT PUNICODE_STRING MultiString
    );


BOOL
OutputIniData (
    IN PUNICODE_STRING FileName,
    IN LPTSTR OutFileCandidate,
    IN PVOID  pValueBuffer,
    IN ULONG  ValueLength
   );


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cntrtext\initodat\initodat.c ===
/*++

Copyright (c) 1993-1994  Microsoft Corporation

Module Name:

    initodat.c

Abstract:

    Routines for converting Perf???.ini to Perf???.dat files.

Author:

    HonWah Chan (a-honwah)  October, 1993

Revision History:

--*/

#include "initodat.h"
#include "strids.h"
#include "common.h"
#include "tchar.h"

#define ALLOCMEM(x)	HeapAlloc (GetProcessHeap(), HEAP_ZERO_MEMORY, (DWORD)(x))
#define FREEMEM(x)	HeapFree (GetProcessHeap(), 0, (LPVOID)(x))

BOOL
MakeUpgradeFilename (
    LPCTSTR szDataFileName,
    LPTSTR  szUpgradeFileName
)
{
    BOOL    bReturn = FALSE;
    // note: assumes szUpgradeFileName buffer is large enough for result
    TCHAR   szDrive[_MAX_DRIVE];
    TCHAR   szDir[_MAX_DIR];
    TCHAR   szFileName[_MAX_FNAME];
    TCHAR   szExt[_MAX_EXT];

    _tsplitpath(szDataFileName, 
        (LPTSTR)szDrive,
        (LPTSTR)szDir,
        (LPTSTR)szFileName,
        (LPTSTR)szExt);

    // see if the filename fits the "PERF[C|H]XXX" format
    if (((szFileName[4] == TEXT('C')) || (szFileName[4] == TEXT('H'))) ||
        ((szFileName[4] == TEXT('c')) || (szFileName[4] == TEXT('h')))) {
        // then it's the correct format so change the 4th letter up 1 letter
        szFileName[4] += 1;
        // and make a new path
        _tmakepath (szUpgradeFileName, 
            (LPCTSTR)szDrive, 
            (LPCTSTR)szDir, 
            (LPCTSTR)szFileName, 
            (LPCTSTR)szExt);
        bReturn = TRUE;
    } else {
        // bogus name so return false
    }
    return bReturn;
}

BOOL
GetFilesFromCommandLine (
    IN LPTSTR   lpCommandLine,
#ifdef FE_SB
    OUT UINT    *puCodePage,
#endif
    OUT LPTSTR  *lpFileNameI,
    OUT LPTSTR  *lpFileNameD
)
/*++

GetFilesFromCommandLine

    parses the command line to retrieve the ini filename that should be
    the first and only argument.

Arguments

    lpCommandLine   pointer to command line (returned by GetCommandLine)
    lpFileNameI     pointer to buffer that will receive address of the
                        validated input filename entered on the command line
    lpFileNameD     pointer to buffer that will receive address of the
                        optional output filename entered on the command line

Return Value

    TRUE if a valid filename was returned
    FALSE if the filename is not valid or missing
            error is returned in GetLastError

--*/
{
    INT     iNumArgs;

    HFILE   hIniFile;
    OFSTRUCT    ofIniFile;

    LPSTR   lpIniFileName = NULL;
    LPTSTR  lpExeName = NULL;
    LPTSTR  lpIniName = NULL;

    // check for valid arguments

    if (lpCommandLine == NULL) return (FALSE);
    if (*lpFileNameI == NULL) return (FALSE);
    if (*lpFileNameD == NULL) return (FALSE);

    // allocate memory for parsing operation

    lpExeName = ALLOCMEM (FILE_NAME_BUFFER_SIZE * sizeof(TCHAR));
    lpIniName = ALLOCMEM (FILE_NAME_BUFFER_SIZE * sizeof(TCHAR));
    lpIniFileName = ALLOCMEM (FILE_NAME_BUFFER_SIZE);

    if ((lpExeName == NULL) ||
	 (lpIniFileName == NULL) ||
	 (lpIniName == NULL)) {
        if (lpExeName) FREEMEM (lpExeName);
        if (lpIniFileName) FREEMEM (lpIniFileName);
        if (lpIniName) FREEMEM (lpIniName);
        return FALSE;
    } else {
        // get strings from command line

#ifdef FE_SB
        iNumArgs = _stscanf (lpCommandLine, (LPCTSTR)TEXT(" %s %d %s %s "), lpExeName, puCodePage, lpIniName, *lpFileNameD);
#else
        iNumArgs = _stscanf (lpCommandLine, (LPCTSTR)TEXT(" %s %s %s "), lpExeName, lpIniName, *lpFileNameD);
#endif

#ifdef FE_SB
        if (iNumArgs < 3 || iNumArgs > 4) {
#else
        if (iNumArgs < 2 || iNumArgs > 3) {
#endif
            // wrong number of arguments
            FREEMEM (lpExeName);
            FREEMEM (lpIniFileName);
            FREEMEM (lpIniName);
            return FALSE;
        } else {
            // see if file specified exists
            // file name is always an ANSI buffer
            wcstombs (lpIniFileName, lpIniName, lstrlenW(lpIniName)+1);
            FREEMEM (lpIniName);
            FREEMEM (lpExeName);
            hIniFile = OpenFile (lpIniFileName,
                &ofIniFile,
                OF_PARSE);

            if (hIniFile != HFILE_ERROR) {
                hIniFile = OpenFile (lpIniFileName,
                    &ofIniFile,
                    OF_EXIST);

                if ((hIniFile && hIniFile != HFILE_ERROR) ||
                    (GetLastError() == ERROR_FILE_EXISTS)) {
                    // file exists, so return name and success
                    // return full pathname if found
                    mbstowcs (*lpFileNameI, ofIniFile.szPathName, lstrlenA(ofIniFile.szPathName)+1);
                    FREEMEM (lpIniFileName);
                    return TRUE;
                } else {
                    // filename was on command line, but not valid so return
                    // false, but send name back for error message
                    mbstowcs (*lpFileNameI, lpIniFileName, lstrlenA(lpIniFileName)+1);
                    FREEMEM (lpIniFileName);
                    return FALSE;
                }
            } else {
                FREEMEM (lpIniFileName);
                return FALSE;
            }
        }
    }
}

BOOL  VerifyIniData(
    IN PVOID  pValueBuffer,
    IN ULONG  ValueLength
)
/*++

VerifyIniData
   This routine does some simple check to see if the ini file is good.
   Basically, it is looking for (ID, Text) and checking that ID is an
   integer.   Mostly in case of missing comma or quote, the ID will be
   an invalid integer.

--*/
{
    INT     iNumArg;
    INT     TextID;
    LPTSTR  lpID = NULL;
    LPTSTR  lpText = NULL;
    LPTSTR  lpLastID;
    LPTSTR  lpLastText;
    LPTSTR  lpInputBuffer = (LPTSTR) pValueBuffer;
    LPTSTR  lpBeginBuffer = (LPTSTR) pValueBuffer;
    BOOL    returnCode = TRUE;
    UINT    NumOfID = 0;
    ULONG   CurrentLength;

#pragma warning ( disable : 4127 )
    while (TRUE) {

        // save up the last items for summary display later
        lpLastID = lpID;
        lpLastText = lpText;

        // increment to next ID and text location
        lpID = lpInputBuffer;
        CurrentLength = (ULONG)((PBYTE)lpID - (PBYTE)lpBeginBuffer + sizeof(WCHAR));

        if (CurrentLength >= ValueLength)
            break;

        try {
            lpText = lpID + lstrlen (lpID) + 1;

            lpInputBuffer = lpText + lstrlen (lpText) + 1;

            iNumArg = _stscanf (lpID, (LPCTSTR)TEXT("%d"), &TextID);
        }
        except (TRUE) {
            iNumArg = -1;
        }

        if (iNumArg != 1) {
            // bad ID
            returnCode = FALSE;
            break ;
        }
        NumOfID++;
    }
#pragma warning ( default : 4127 )

    if (returnCode == FALSE) {
       DisplaySummaryError (lpLastID, lpLastText, NumOfID);
    }
    else {
       DisplaySummary (lpLastID, lpLastText, NumOfID);
    }
    return (returnCode);
}


__cdecl main(
//    int argc,
//    char *argv[]
)
/*++

main



Arguments


ReturnValue

    0 (ERROR_SUCCESS) if command was processed
    Non-Zero if command error was detected.

--*/
{
    LPTSTR  lpCommandLine;
    LPTSTR  lpIniFile;
    LPTSTR  lpDatFile;
    UNICODE_STRING IniFileName;
    PVOID   pValueBuffer;
    ULONG   ValueLength;
    BOOL    bStatus;
    NTSTATUS   NtStatus;
#if 0
    // part of bogus filename change code
    LPTSTR      pchar ;
    INT         npos;   
    TCHAR       ch = TEXT('f');
#endif
#ifdef FE_SB
    UINT    uCodePage=CP_ACP;
#endif

    lpIniFile = ALLOCMEM (MAX_PATH * sizeof (TCHAR));
    lpDatFile = ALLOCMEM (MAX_PATH * sizeof (TCHAR));
    if (lpIniFile == NULL) return ERROR_OUTOFMEMORY;
    if (lpDatFile == NULL) return ERROR_OUTOFMEMORY;
    lstrcpy(lpDatFile, (LPCTSTR)TEXT("\0"));

    lpCommandLine = GetCommandLine(); // get command line
    if (lpCommandLine == NULL) {
        NtStatus = GetLastError();
        FREEMEM (lpIniFile);
        FREEMEM (lpDatFile);
        return NtStatus;
    }

    // read command line to determine what to do

#ifdef FE_SB  // FE_SB
    if (GetFilesFromCommandLine (lpCommandLine, &uCodePage, &lpIniFile, &lpDatFile)) {

        if (!IsValidCodePage(uCodePage)) {
            uCodePage = CP_ACP;
        }
#else
    if (GetFilesFromCommandLine (lpCommandLine, &lpIniFile, &lpDatFile)) {
#endif // FE_SB



        // valid filename (i.e. ini file exists)
        IniFileName.Buffer = lpIniFile;
        IniFileName.MaximumLength = 
        IniFileName.Length = (WORD)((lstrlen (lpIniFile) + 1 ) * sizeof(WCHAR)) ;
#ifdef FE_SB
        bStatus = DatReadMultiSzFile (uCodePage, &IniFileName,
#else
        bStatus = DatReadMultiSzFile (&IniFileName,
#endif
            &pValueBuffer,
            &ValueLength);

        if (bStatus) {
            bStatus = VerifyIniData (pValueBuffer, ValueLength);
            if (bStatus) {
                bStatus = OutputIniData (&IniFileName,
                    lpDatFile,
                    pValueBuffer,
                    ValueLength);
#if 0
                // this is a really bogus way to find "PERF" in the 
                // filename string

                //Add the new file that'll be used in upgrade
                // find the last "F" in the file name by reversing
                // the string, finding the first "F"
                // then go to the previous character and incrementing
                // it. Finally reverse the characters in the file name
                // returning it to the correct order.
                //
                // this creates the "upgrade" file with a slightly different
                // filename that is used by Lodctr to insert the new system 
                // strings into the existing list of system strings.
                //
                _tcsrev(lpDatFile);
                pchar = _tcschr(lpDatFile,ch);
                npos = (INT)(pchar - lpDatFile) - 1;
                lpDatFile[npos]  = (TCHAR)((lpDatFile[npos]) + 1);
                _tcsrev(lpDatFile);
#else
                bStatus = MakeUpgradeFilename (
                    lpDatFile, lpDatFile);

#endif
                if (bStatus) {
                    bStatus = OutputIniData (&IniFileName,
                        lpDatFile,
                        pValueBuffer,
                        ValueLength);
                }
            }
        }
    } else {
        if (*lpIniFile) {
            printf (GetFormatResource(LC_NO_INIFILE), lpIniFile);
        } else {
            //Incorrect Command Format
            // display command line usage
            DisplayCommandHelp(LC_FIRST_CMD_HELP, LC_LAST_CMD_HELP);
        }
    }


    if (lpIniFile) FREEMEM (lpIniFile);
    if (lpDatFile) FREEMEM (lpDatFile);

    return (ERROR_SUCCESS); // success
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cntrtext\initodat\strids.h ===
/*++

Copyright (c) 1993-1994  Microsoft Corporation

Module Name:

    strids.h

Abstract:

    This is the include file for the strings ids use in initodat.exe

Author:

    HonWah Chan (a-honwah)  October, 1993

Revision History:

--*/

// strings defines for Help
#define  LC_CMD_HELP_1     100
#define  LC_CMD_HELP_2     101
#define  LC_CMD_HELP_3     102
#define  LC_CMD_HELP_4     103
#define  LC_CMD_HELP_5     104
#define  LC_CMD_HELP_6     105
#define  LC_CMD_HELP_7     106
#define  LC_CMD_HELP_8     107
#define  LC_CMD_HELP_9     108
#define  LC_CMD_HELP_10    109
#define  LC_CMD_HELP_11    110
#define  LC_CMD_HELP_12    111
#define  LC_CMD_HELP_13    112

#define  LC_FIRST_CMD_HELP 100
#define  LC_LAST_CMD_HELP  112


// strings defines for error

#define  LC_NO_INIFILE     202
#define  LC_SUMMARY        203
#define  LC_NUM_OF_ID      204
#define  LC_LAST_ID        205
#define  LC_LAST_TEXT      206
#define  LC_BAD_ID         207
#define  LC_MISSING_DEL    208
#define  LC_CANT_CREATE    209
#define  LC_CANT_WRITE     210
#define  LC_ACCESS_DENIED  211
#define  LC_DISK_FULL      212
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cntrtext\perfini\ara\makefile.inc ===
!include ..\common.mk
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cntrtext\perfini\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

TARGETPATH=obj
TARGETNAME=NOTARGET
TARGETTYPE=NOTARGET
SOURCES=
SOURCES_USED=..\sources.inc

#
#   define _LANGCODE to be the primary language id in hex
#
#   usa = 009
#

!if "$(ALT_PROJECT)"=="."
_LANGCODE=009
CODEPAGE=1252
!elseif "$(ALT_PROJECT)"=="ARA"
_LANGCODE=001
CODEPAGE=1256
!elseif "$(ALT_PROJECT)"=="CHS"
_LANGCODE=004
CODEPAGE=936
!elseif "$(ALT_PROJECT)"=="CHT"
_LANGCODE=004
CODEPAGE=950
!elseif "$(ALT_PROJECT)"=="GER"
_LANGCODE=007
CODEPAGE=1252
!elseif "$(ALT_PROJECT)"=="HEB"
_LANGCODE=00D
CODEPAGE=1255
!elseif "$(ALT_PROJECT)"=="JPN"
_LANGCODE=011
CODEPAGE=932
!elseif "$(ALT_PROJECT)"=="KOR"
_LANGCODE=012
CODEPAGE=949
!elseif "$(ALT_PROJECT)"=="br"
_LANGCODE=016
CODEPAGE=1252
!elseif "$(ALT_PROJECT)"=="cs"
_LANGCODE=005
CODEPAGE=1250
!elseif "$(ALT_PROJECT)"=="da"
_LANGCODE=006
CODEPAGE=1252
!elseif "$(ALT_PROJECT)"=="el"
_LANGCODE=008
CODEPAGE=1253
!elseif "$(ALT_PROJECT)"=="es"
_LANGCODE=00a
CODEPAGE=1252
!elseif "$(ALT_PROJECT)"=="fi"
_LANGCODE=00b
CODEPAGE=1252
!elseif "$(ALT_PROJECT)"=="fr"
_LANGCODE=00c
CODEPAGE=1252
!elseif "$(ALT_PROJECT)"=="hu"
_LANGCODE=00e
CODEPAGE=1250
!elseif "$(ALT_PROJECT)"=="it"
_LANGCODE=010
CODEPAGE=1252
!elseif "$(ALT_PROJECT)"=="nl"
_LANGCODE=013
CODEPAGE=1252
!elseif "$(ALT_PROJECT)"=="no"
_LANGCODE=014
CODEPAGE=1252
!elseif "$(ALT_PROJECT)"=="pl"
_LANGCODE=015
CODEPAGE=1250
!elseif "$(ALT_PROJECT)"=="psu"
_LANGCODE=01f
CODEPAGE=1253
!elseif "$(ALT_PROJECT)"=="pt"
_LANGCODE=016
CODEPAGE=1252
!elseif "$(ALT_PROJECT)"=="ru"
_LANGCODE=019
CODEPAGE=1251
!elseif "$(ALT_PROJECT)"=="sv"
_LANGCODE=01d
CODEPAGE=1252
!elseif "$(ALT_PROJECT)"=="tr"
_LANGCODE=01f
CODEPAGE=1254
!elseif "$(ALT_PROJECT)"=="TST"
_LANGCODE=009
CODEPAGE=1252
!endif

PERFCINI=perfc$(_LANGCODE).ini
PERFHINI=perfh$(_LANGCODE).ini

NTTARGETFILES=

MISCFILES= \
        $(O)\perfc$(_LANGCODE).dat \
        $(O)\perfd$(_LANGCODE).dat \
        $(O)\perfh$(_LANGCODE).dat \
        $(O)\perfi$(_LANGCODE).dat
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cntrtext\perfini\cht\makefile.inc ===
!include ..\common.mk
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cntrtext\perfini\cs\makefile.inc ===
!include ..\common.mk
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cntrtext\lodctr\lodctr.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    lodctr.c

Abstract:

    Program to read the contents of the file specified in the command line
        and update the registry accordingly

Author:

    Bob Watson (a-robw) 10 Feb 93

Revision History:

    a-robw  25-Feb-93   revised calls to make it compile as a UNICODE or
                        an ANSI app.

    a-robw  10-Nov-95   revised to use DLL functions for all the dirty work

    // command line arguments supported:

    /C:<filename>   upgrade counter text strings using <filename>
    /H:<filename>   upgrade help text strings using <filename>
    /L:<LangID>     /C and /H params are for language <LangID>

    /S:<filename>   save current perf registry strings & info to <filname>
    /R:<filename>   restore perf registry strings & info using <filname>

    /T:<service>    set <service> to be Trusted using current DLL 

--*/
#define     UNICODE     1
#define     _UNICODE    1
//
//  Windows Include files
//
#include <windows.h>
#include <stdlib.h>
#include <tchar.h>

#include <loadperf.h>
#include "..\common\common.h"

static CHAR szFileNameBuffer[MAX_PATH*2];

static
LPCSTR
GetTrustedServiceName (
    LPCSTR  szArg1
)
{
    LPSTR   szReturn = NULL;

    if ((szArg1[0] == '-') || (szArg1[0] == '/')) {
        //it's a switch command
        if ((szArg1[1] == 't') || (szArg1[1] == 'T')) {
            // the command is to Save the configuration to a file
            if (szArg1[2] == ':') {
                // then the rest of the string is the name of the trusted service
                szReturn = (LPSTR)&szArg1[3];
            }
        }
    }
    return (LPCSTR)szReturn;
}
static
BOOL
GetUpgradeFileNames (
    LPCSTR  *szArgs,
    LPSTR   *szCounterFile,
    LPSTR   *szHelpFile,
    LPSTR   *szLangId
)
{
    DWORD   dwArgIdx = 1;
    DWORD   dwMask = 0;

    do {
        // check first arg, function assumes there are 2 args or more
        if ((szArgs[dwArgIdx][0] == '-') || (szArgs[dwArgIdx][0] == '/')) {
            //it's a switch command
            if ((szArgs[dwArgIdx][1] == 'c') || (szArgs[dwArgIdx ][1] == 'C')) {
                // the command is to load a service
                if (szArgs[dwArgIdx ][2] == ':') {
                    // then the rest of the string is the service name
                    *szCounterFile = (LPSTR)&szArgs[dwArgIdx ][3];
                    dwMask |= 1;
                }
            } else if ((szArgs[dwArgIdx][1] == 'h') || (szArgs[dwArgIdx ][1] == 'H')) {
                // the command is to load a service
                if (szArgs[dwArgIdx][2] == ':') {
                    // then the rest of the string is the service name
                    *szHelpFile = (LPSTR)&szArgs[dwArgIdx ][3];
                    dwMask |= 2;
                }
            } else if ((szArgs[dwArgIdx][1] == 'l') || (szArgs[dwArgIdx ][1] == 'L')) {
                // the command is to load a service
                if (szArgs[dwArgIdx][2] == ':') {
                    // then the rest of the string is the service name
                    *szLangId = (LPSTR)&szArgs[dwArgIdx ][3];
                    dwMask |= 4;
                }
            }
        }
        dwArgIdx++;
    } while (dwArgIdx <= 3);

    if (dwMask == 7) {
        // all names found
        return TRUE;
    } else {
        return FALSE;
    }
}

static
LPCSTR
GetSaveFileName (
    LPCSTR  szArg1
)
{
    LPSTR   szReturn = NULL;
    DWORD   dwSize;

    if ((szArg1[0] == '-') || (szArg1[0] == '/')) {
        //it's a switch command
        if ((szArg1[1] == 's') || (szArg1[1] == 'S')) {
            // the command is to Save the configuration to a file
            if (szArg1[2] == ':') {
                // then the rest of the string is the input file name
                dwSize = SearchPathA (NULL, (LPSTR)&szArg1[3], NULL, 
                    sizeof(szFileNameBuffer)/sizeof(szFileNameBuffer[0]),
                    szFileNameBuffer, NULL);
                if (dwSize == 0) {
                    //unable to find file in path so use it as is
                    szReturn = (LPSTR)&szArg1[3];
                } else {
                    // else return the expanded file name
                    szReturn = szFileNameBuffer;
                }
            }
        }
    }
    return (LPCSTR)szReturn;
}
static
LPCSTR
GetRestoreFileName (
    LPCSTR  szArg1  
)
{
    LPSTR   szReturn = NULL;
    DWORD   dwSize;

    if ((szArg1[0] == '-') || (szArg1[0] == '/')) {
        //it's a switch command
        if ((szArg1[1] == 'r') || (szArg1[1] == 'R')) {
            // the command is to Save the configuration to a file
            if (szArg1[2] == ':') {
                // then the rest of the string is the input file name
                dwSize = SearchPathA (NULL, (LPSTR)&szArg1[3], NULL, 
                    sizeof(szFileNameBuffer)/sizeof(szFileNameBuffer[0]),
                    szFileNameBuffer, NULL);
                if (dwSize == 0) {
                    //unable to find file in path so use it as is
                    szReturn = (LPSTR)&szArg1[3];
                } else {
                    // else return the expanded file name
                    szReturn = szFileNameBuffer;
                }
            }
        }
    }
    return (LPCSTR)szReturn;
}

int
__cdecl main(
    int argc,
    char *argv[]
)
/*++

main



Arguments


ReturnValue

    0 (ERROR_SUCCESS) if command was processed
    Non-Zero if command error was detected.

--*/
{
    LPTSTR  lpCommandLine;
    LPSTR   szCmdArgFileName;
    LPWSTR  wszFileName;
    DWORD   dwFileNameLen;
    int     nReturn;

    lpCommandLine = GetCommandLine(); // get command line

    // check for a service name in the command line

    if (argc >= 2) {
        if (argc >= 4) {
            BOOL    bDoUpdate;
            LPSTR   szCounterFile = NULL;
            LPSTR   szHelpFile = NULL;
            LPSTR   szLanguageID = NULL;

            bDoUpdate = GetUpgradeFileNames (
                argv,
                &szCounterFile,
                &szHelpFile,
                &szLanguageID);

            if (bDoUpdate) {
                return (int) UpdatePerfNameFilesA (
	                szCounterFile, 
	                szHelpFile, 
                    szLanguageID,
                    0);

            }
        } else {    
            // then there's a param to check
            szCmdArgFileName = (LPSTR)GetSaveFileName (argv[1]);
            if (szCmdArgFileName != NULL) {
                dwFileNameLen = lstrlenA(szCmdArgFileName) + 1;
                wszFileName = HeapAlloc (GetProcessHeap(), 0, (dwFileNameLen) * sizeof (WCHAR));
                if (wszFileName != NULL) {
                    mbstowcs (wszFileName, szCmdArgFileName, dwFileNameLen);
                    nReturn = (int)BackupPerfRegistryToFileW (
                            (LPCWSTR)wszFileName,
                            (LPCWSTR)L"");
                    HeapFree (GetProcessHeap(), 0, wszFileName);
                    return nReturn;
                }
            } 

            // try Restore file name
            szCmdArgFileName = (LPSTR)GetRestoreFileName (argv[1]);
            if (szCmdArgFileName != NULL) {
                dwFileNameLen = lstrlenA(szCmdArgFileName) + 1;
                wszFileName = HeapAlloc (GetProcessHeap(), 0, (dwFileNameLen) * sizeof (WCHAR));
                if (wszFileName != NULL) {
                    mbstowcs (wszFileName, szCmdArgFileName, dwFileNameLen);
                    nReturn = (int)RestorePerfRegistryFromFileW  (
                            (LPCWSTR)wszFileName,
                            (LPCWSTR)L"009");
                    HeapFree (GetProcessHeap(), 0, wszFileName);
                    return nReturn;
                }
            }

            // try Trusted service name
            szCmdArgFileName = (LPSTR)GetTrustedServiceName (argv[1]);
            if (szCmdArgFileName != NULL) {
                dwFileNameLen = lstrlenA(szCmdArgFileName) + 1;
                wszFileName = HeapAlloc (GetProcessHeap(), 0, (dwFileNameLen) * sizeof (WCHAR));
                if (wszFileName != NULL) {
                    mbstowcs (wszFileName, szCmdArgFileName, dwFileNameLen);
                    nReturn = (int)SetServiceAsTrusted  (NULL,
                            (LPCWSTR)wszFileName);  // filename is really the service name
                    HeapFree (GetProcessHeap(), 0, wszFileName);
                    return nReturn;
                }
            }
        }
    }
    // if here then load the registry from an ini file
    return (int) LoadPerfCounterTextStrings (
        lpCommandLine,
        FALSE);     // show text strings to console
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cntrtext\perfini\br\makefile.inc ===
!include ..\common.mk
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cntrtext\perfini\da\makefile.inc ===
!include ..\common.mk
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cntrtext\perfini\el\makefile.inc ===
!include ..\common.mk
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cntrtext\perfini\es\makefile.inc ===
!include ..\common.mk
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cntrtext\perfini\fi\makefile.inc ===
!include ..\common.mk
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cntrtext\perfini\fr\makefile.inc ===
!include ..\common.mk
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cntrtext\perfini\ger\makefile.inc ===
!include ..\common.mk
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cntrtext\perfini\heb\makefile.inc ===
!include ..\common.mk
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cntrtext\perfini\chs\makefile.inc ===
!include ..\common.mk
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cntrtext\perfini\hu\makefile.inc ===
!include ..\common.mk
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cntrtext\perfini\it\makefile.inc ===
!include ..\common.mk
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cntrtext\perfini\jpn\makefile.inc ===
!include ..\common.mk
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cntrtext\perfini\kor\makefile.inc ===
!include ..\common.mk
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cntrtext\perfini\nl\makefile.inc ===
!include ..\common.mk
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cntrtext\perfini\pl\makefile.inc ===
!include ..\common.mk
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cntrtext\perfini\no\makefile.inc ===
!include ..\common.mk
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cntrtext\perfini\psu\makefile.inc ===
!include ..\common.mk
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cntrtext\perfini\pt\makefile.inc ===
!include ..\common.mk
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cntrtext\perfini\sv\makefile.inc ===
!include ..\common.mk
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cntrtext\perfini\ru\makefile.inc ===
!include ..\common.mk
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cntrtext\perfini\tr\makefile.inc ===
!include ..\common.mk
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cntrtext\perfini\usa\makefile.inc ===
!include ..\common.mk
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cntrtext\perfini\tst\makefile.inc ===
!include ..\common.mk
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cntrtext\showperf\maindlg.h ===
INT_PTR
MainDlgProc (
    IN  HWND    hDlg,
    IN  UINT    message,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cntrtext\showperf\mainwnd.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    MainWnd.H

Abstract:
    
    Global functions and constants used by the Main Application Window

Author:

    Bob Watson (a-robw)

Revision History:

    23 NOV 94


--*/
#ifndef _MAINWND_H_
#define _MAINWND_H_

//  Main Window Constants

//
//  Global functions
//
LRESULT CALLBACK
MainWndProc (
    IN	HWND hWnd,         // window handle
    IN	UINT message,      // type of message
    IN	WPARAM wParam,     // additional information
    IN  LPARAM lParam      // additional information
);

BOOL
RegisterMainWindowClass (
    IN  HINSTANCE   hInstance
);

HWND
CreateMainWindow (
    IN  HINSTANCE   hInstance
);


#endif  // _MAINWND_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cntrtext\showperf\maindlg.c ===
#include <windows.h>
#include <winperf.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <tchar.h>
#include "showperf.h"
#include "perfdata.h"
#include "resource.h"
#include "maindlg.h"

static PPERF_DATA_BLOCK   pMainPerfData = NULL; // pointer to perfdata block
static LPWSTR             *szNameTable = NULL;   // pointer to perf name table
static DWORD              dwLastName = 0;
static TCHAR              szComputerName[MAX_COMPUTERNAME_LENGTH+3];
static TCHAR              szThisComputerName[MAX_COMPUTERNAME_LENGTH+3];
static HKEY               hKeyMachine = NULL;
static HKEY               hKeyPerformance = NULL;

#define NUM_TAB_STOPS       3
static INT nDataListTabs[NUM_TAB_STOPS] = {
        26
    ,   160
    ,   235
};

static
BOOL
LoadObjectList (
    IN  HWND    hDlg,
    IN  LPCTSTR  szMatchItem
)
{
    PPERF_OBJECT_TYPE   pObject;
    HWND        hWndObjectCB;
    UINT        nInitial = 0;
    UINT        nIndex;
    TCHAR       szNameBuffer[MAX_PATH];
    DWORD       dwThisObject = 0;
    DWORD       dwCounterType;
    BOOL        bReturn = TRUE;

    hWndObjectCB = GetDlgItem (hDlg, IDC_OBJECT);

    if (IsDlgButtonChecked (hDlg, IDC_INCLUDE_COSTLY) == CHECKED) {
        dwCounterType = 1;
    } else {
        dwCounterType = 0;
    }

    // get current data block
    if (GetSystemPerfData (hKeyPerformance, &pMainPerfData,
        dwCounterType) == ERROR_SUCCESS) {
        // data acquired so clear combo and display
        SendMessage (hWndObjectCB, CB_RESETCONTENT, 0, 0);
        pObject = FirstObject (pMainPerfData);
        __try {
            for (dwThisObject = 0; dwThisObject < pMainPerfData->NumObjectTypes; dwThisObject++) {

                // get counter object name here...

                _stprintf (szNameBuffer, (LPCTSTR)TEXT("(%d) %s"),
                    pObject->ObjectNameTitleIndex,
                    pObject->ObjectNameTitleIndex <= dwLastName ?
                    szNameTable[pObject->ObjectNameTitleIndex] : (LPCTSTR)TEXT("Name not loaded"));

                nIndex = (UINT)SendMessage (hWndObjectCB, CB_INSERTSTRING, (WPARAM)-1,
                    (LPARAM)szNameBuffer);

                if (nIndex != CB_ERR) {
                    // save object pointer
                    SendMessage (hWndObjectCB, CB_SETITEMDATA,
                        (WPARAM)nIndex, (LPARAM)pObject);

                    if (pObject->ObjectNameTitleIndex == (DWORD)pMainPerfData->DefaultObject) {
                        // remember this index to set the default object
                        nInitial = nIndex;
                    }
                }

                pObject = NextObject(pObject);
            }
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            _stprintf (szNameBuffer,
                (LPCTSTR)TEXT("An exception (0x%8.8x) occured in object block # %d returned by the system."),
                GetExceptionCode (), dwThisObject+1);
            MessageBox (hDlg, szNameBuffer, (LPCTSTR)TEXT("Data Error"), MB_OK);
            // update the data buffer so that only the valid objects
            // are accessed in the future.
            pMainPerfData->NumObjectTypes = dwThisObject-1;
        }
        if (szMatchItem == NULL) {
            SendMessage (hWndObjectCB, CB_SETCURSEL, (WPARAM)nInitial, 0);
        } else {
            // match to arg string as best as possible
            if (SendMessage (hWndObjectCB, CB_SELECTSTRING, (WPARAM)-1,
                (LPARAM)szMatchItem) == CB_ERR) {
                    // no match found so use default
                SendMessage (hWndObjectCB, CB_SETCURSEL, (WPARAM)nInitial, 0);
            }
        }
    } else {
        DisplayMessageBox (hDlg,
            IDS_UNABLE_GET_DATA,
            IDS_APP_ERROR, MB_OK);
        bReturn = FALSE;
    }
    return bReturn;
}

static
LoadInstanceList (
    IN  HWND    hDlg,
    IN  LPCTSTR  szMatchItem
)
{
    PPERF_OBJECT_TYPE   pObject;
    PPERF_OBJECT_TYPE   pParentObject;
    PPERF_COUNTER_BLOCK pCounterBlock;
    PPERF_INSTANCE_DEFINITION   pInstance;
    PPERF_INSTANCE_DEFINITION   pParentInstance;
    UINT                nCbSel;
    LONG                lThisInstance;
    TCHAR               szNameBuffer[MAX_PATH];
    TCHAR               szParentName[MAX_PATH];
    UINT                nIndex;

    nCbSel = (UINT)SendDlgItemMessage (hDlg, IDC_OBJECT, CB_GETCURSEL, 0, 0);

    if (nCbSel != CB_ERR) {
        pObject = (PPERF_OBJECT_TYPE)SendDlgItemMessage (hDlg, IDC_OBJECT, CB_GETITEMDATA,
            (WPARAM)nCbSel, 0);

        if (pObject->NumInstances == PERF_NO_INSTANCES) {
            // no instances so...
            // clear old contents
            SendDlgItemMessage (hDlg, IDC_INSTANCE, CB_RESETCONTENT, 0, 0);
            // add display text
            SendDlgItemMessage (hDlg, IDC_INSTANCE, CB_INSERTSTRING, (WPARAM)-1,
                (LPARAM)TEXT("<No Instances>"));
            // select this (and only) string
            SendDlgItemMessage (hDlg, IDC_INSTANCE, CB_SETCURSEL, 0, 0);
            // get pointer to counter data
            pCounterBlock = (PPERF_COUNTER_BLOCK)((LPBYTE)pObject + pObject->DefinitionLength);
            // and save it as item data
            SendDlgItemMessage (hDlg, IDC_INSTANCE, CB_SETITEMDATA, 0,
                (LPARAM)pCounterBlock);
            // finally grey the window to prevent selections
            EnableWindow (GetDlgItem (hDlg, IDC_INSTANCE), FALSE);
        } else {
            //enable window
            EnableWindow (GetDlgItem (hDlg, IDC_INSTANCE), TRUE);
            SendDlgItemMessage (hDlg, IDC_INSTANCE, CB_RESETCONTENT, 0, 0);
            pInstance = FirstInstance (pObject);
            for (lThisInstance = 0; lThisInstance < pObject->NumInstances; lThisInstance++) {
                pParentObject = GetObjectDefByTitleIndex (
                    pMainPerfData,
                    pInstance->ParentObjectTitleIndex);
                if (pParentObject != NULL) {
                    pParentInstance = GetInstance (pParentObject,
                        pInstance->ParentObjectInstance);
                } else {
                    pParentInstance = NULL;
                }
                if (pParentInstance != NULL) {
                    if (pParentInstance->UniqueID < 0) {
                        // use the instance name
                        wcsncpy (szParentName,
                            (LPWSTR)((LPBYTE)pParentInstance+pParentInstance->NameOffset),
                            pParentInstance->NameLength);
                        lstrcat (szParentName, (LPCTSTR)TEXT("==>"));
                    } else {
                        // use the instance number
                        _stprintf (szParentName, (LPCTSTR)TEXT("[%d]==>"),
                            pParentInstance->UniqueID);
                    }
                } else {
                    // unknown parent
                    *szParentName = 0;
                }
                if (pInstance->UniqueID < 0) {
                    // use the instance name
                    wcsncpy (szNameBuffer,
                        (LPWSTR)((LPBYTE)pInstance+pInstance->NameOffset),
                        pInstance->NameLength);
                } else {
                    // use the instance number
                    _stprintf (szNameBuffer, (LPCTSTR)TEXT("(%d)"),
                        pInstance->UniqueID);
                }
                lstrcat (szParentName, szNameBuffer);
                nIndex = (UINT)SendDlgItemMessage (hDlg, IDC_INSTANCE,
                    CB_INSERTSTRING, (WPARAM)-1,
                    (LPARAM)szParentName);
                if (nIndex != CB_ERR) {
                    // save pointer to counter block
                    pCounterBlock = (PERF_COUNTER_BLOCK *)
                        ((PCHAR) pInstance + pInstance->ByteLength);
                    SendDlgItemMessage (hDlg, IDC_INSTANCE, CB_SETITEMDATA,
                        (WPARAM)nIndex, (LPARAM)pCounterBlock);
                }
                pInstance = NextInstance (pInstance);
            }
            if (szMatchItem == NULL) {
                SendDlgItemMessage (hDlg, IDC_INSTANCE, CB_SETCURSEL, 0, 0);
            } else {
                if (SendDlgItemMessage (hDlg, IDC_INSTANCE, CB_SELECTSTRING,
                    (WPARAM)-1, (LPARAM)szMatchItem) == CB_ERR) {
                    SendDlgItemMessage (hDlg, IDC_INSTANCE, CB_SETCURSEL, 0, 0);
                }
            }
        }
    } else {
        // no object selected
        // clear old contents
        SendDlgItemMessage (hDlg, IDC_INSTANCE, CB_RESETCONTENT, 0, 0);
        // add display text
        SendDlgItemMessage (hDlg, IDC_INSTANCE, CB_INSERTSTRING, (WPARAM)-1,
            (LPARAM)TEXT("<No object selected>"));
        // select this (and only) string
        SendDlgItemMessage (hDlg, IDC_INSTANCE, CB_SETCURSEL, 0, 0);
        // and save null pointer as item data
        SendDlgItemMessage (hDlg, IDC_INSTANCE, CB_SETITEMDATA, 0,
            (LPARAM)0);
        // finally grey the window to prevent selections
        EnableWindow (GetDlgItem (hDlg, IDC_INSTANCE), FALSE);
    }

    return TRUE;
}

static
LPCTSTR
GetCounterTypeName (
    IN  DWORD   dwCounterType
)
{
    UINT    nTypeString = 0;

    switch (dwCounterType) {
        case     PERF_COUNTER_COUNTER:
            nTypeString = IDS_TYPE_COUNTER_COUNTER    ;
            break;

        case     PERF_COUNTER_TIMER:
            nTypeString = IDS_TYPE_COUNTER_TIMER      ;
            break;

        case     PERF_COUNTER_QUEUELEN_TYPE:
            nTypeString = IDS_TYPE_COUNTER_QUEUELEN   ;
            break;

        case     PERF_COUNTER_LARGE_QUEUELEN_TYPE:
            nTypeString = IDS_TYPE_COUNTER_LARGE_QUEUELEN   ;
            break;

        case     PERF_COUNTER_100NS_QUEUELEN_TYPE:
            nTypeString = IDS_TYPE_COUNTER_100NS_QUEUELEN   ;
            break;

        case     PERF_COUNTER_OBJ_TIME_QUEUELEN_TYPE:
            nTypeString = IDS_TYPE_COUNTER_OBJ_TIME_QUEUELEN   ;
            break;

        case     PERF_COUNTER_BULK_COUNT:
            nTypeString = IDS_TYPE_COUNTER_BULK_COUNT ;
            break;

        case     PERF_COUNTER_TEXT:
            nTypeString = IDS_TYPE_COUNTER_TEXT       ;
            break;

        case     PERF_COUNTER_RAWCOUNT:
            nTypeString = IDS_TYPE_COUNTER_RAWCOUNT   ;
            break;

        case     PERF_COUNTER_LARGE_RAWCOUNT:
            nTypeString = IDS_TYPE_COUNTER_LARGE_RAW  ;
            break;

        case     PERF_COUNTER_RAWCOUNT_HEX:
            nTypeString = IDS_TYPE_COUNTER_RAW_HEX    ;
            break;

        case     PERF_COUNTER_LARGE_RAWCOUNT_HEX:
            nTypeString = IDS_TYPE_COUNTER_LARGE_RAW_HEX  ;
            break;

        case     PERF_SAMPLE_FRACTION:
            nTypeString = IDS_TYPE_SAMPLE_FRACTION    ;
            break;

        case     PERF_SAMPLE_COUNTER:
            nTypeString = IDS_TYPE_SAMPLE_COUNTER     ;
            break;

        case     PERF_COUNTER_NODATA:
            nTypeString = IDS_TYPE_COUNTER_NODATA     ;
            break;

        case     PERF_COUNTER_TIMER_INV:
            nTypeString = IDS_TYPE_COUNTER_TIMER_INV  ;
            break;

        case     PERF_SAMPLE_BASE:
            nTypeString = IDS_TYPE_SAMPLE_BASE        ;
            break;

        case     PERF_AVERAGE_TIMER:
            nTypeString = IDS_TYPE_AVERAGE_TIMER      ;
            break;

        case     PERF_AVERAGE_BASE:
            nTypeString = IDS_TYPE_AVERAGE_BASE       ;
            break;

        case     PERF_AVERAGE_BULK:
            nTypeString = IDS_TYPE_AVERAGE_BULK       ;
            break;

        case     PERF_OBJ_TIME_TIMER:
            nTypeString = IDS_TYPE_OBJ_TIME_TIMER     ;
            break;

        case     PERF_100NSEC_TIMER:
            nTypeString = IDS_TYPE_100NS_TIMER        ;
            break;

        case     PERF_100NSEC_TIMER_INV:
            nTypeString = IDS_TYPE_100NS_TIMER_INV    ;
            break;

        case     PERF_COUNTER_MULTI_TIMER:
            nTypeString = IDS_TYPE_MULTI_TIMER        ;
            break;

        case     PERF_COUNTER_MULTI_TIMER_INV:
            nTypeString = IDS_TYPE_MULTI_TIMER_INV    ;
            break;

        case     PERF_COUNTER_MULTI_BASE:
            nTypeString = IDS_TYPE_MULTI_BASE         ;
            break;

        case     PERF_100NSEC_MULTI_TIMER:
            nTypeString = IDS_TYPE_100NS_MULTI_TIMER  ;
            break;

        case     PERF_100NSEC_MULTI_TIMER_INV:
            nTypeString = IDS_TYPE_100NS_MULTI_TIMER_INV ;
            break;

        case     PERF_RAW_FRACTION:
            nTypeString = IDS_TYPE_RAW_FRACTION       ;
            break;

        case     PERF_LARGE_RAW_FRACTION:
            nTypeString = IDS_TYPE_LARGE_RAW_FRACTION ;
            break;

        case     PERF_RAW_BASE:
            nTypeString = IDS_TYPE_RAW_BASE           ;
            break;

        case     PERF_LARGE_RAW_BASE:
            nTypeString = IDS_TYPE_LARGE_RAW_BASE     ;
            break;

        case     PERF_ELAPSED_TIME:
            nTypeString = IDS_TYPE_ELAPSED_TIME       ;
            break;

        case     PERF_COUNTER_HISTOGRAM_TYPE:
            nTypeString = IDS_TYPE_HISTOGRAM          ;
            break;

        case     PERF_COUNTER_DELTA:
            nTypeString = IDS_TYPE_COUNTER_DELTA      ;
            break;

        case     PERF_COUNTER_LARGE_DELTA:
            nTypeString = IDS_TYPE_COUNTER_LARGE_DELTA;
            break;

        case     PERF_PRECISION_SYSTEM_TIMER:
            nTypeString = IDS_TYPE_PRECISION_SYSTEM_TIMER;
            break;

        case     PERF_PRECISION_100NS_TIMER:
            nTypeString = IDS_TYPE_PRECISION_100NS_TIMER ;
            break;

        case     PERF_PRECISION_OBJECT_TIMER:
            nTypeString = IDS_TYPE_PRECISION_OBJECT_TIMER;
            break;

	default:
            nTypeString = 0;
            break;
    }

    if (nTypeString != 0) {
        return GetStringResource (NULL, nTypeString);
    } else {
        return (LPCTSTR)TEXT("");
    }
}

static
BOOL
ShowCounterData (
    IN  HWND    hDlg,
    IN  LONG    lDisplayIndex
)
{
    PPERF_OBJECT_TYPE   pObject;
    PPERF_COUNTER_DEFINITION pCounterDef;
    PPERF_COUNTER_BLOCK pCounterBlock;
    UINT    nSelObject, nSelInstance;
    TCHAR   szTypeNameBuffer[MAX_PATH];

    TCHAR   szDisplayBuffer [SMALL_BUFFER_SIZE];

    DWORD   *pdwLoDword, *pdwHiDword;

    DWORD   dwThisCounter;

    SendDlgItemMessage (hDlg, IDC_DATA_LIST, LB_RESETCONTENT, 0, 0);

    nSelObject = (UINT)SendDlgItemMessage (hDlg, IDC_OBJECT, CB_GETCURSEL, 0, 0);
    nSelInstance = (UINT)SendDlgItemMessage (hDlg, IDC_INSTANCE, CB_GETCURSEL, 0, 0);

    if ((nSelObject != CB_ERR) && (nSelInstance != CB_ERR)) {
        pObject = (PPERF_OBJECT_TYPE)SendDlgItemMessage (hDlg, IDC_OBJECT,
            CB_GETITEMDATA, (WPARAM)nSelObject, 0);

        pCounterBlock = (PPERF_COUNTER_BLOCK)SendDlgItemMessage (hDlg, IDC_INSTANCE,
            CB_GETITEMDATA, (WPARAM)nSelInstance, 0);

        pCounterDef = FirstCounter (pObject);

        for (dwThisCounter = 0; dwThisCounter < pObject->NumCounters; dwThisCounter++) {
            // get pointer to this counter's data (in this instance if applicable
            pdwLoDword = (PDWORD)((LPBYTE)pCounterBlock + pCounterDef->CounterOffset);
            pdwHiDword = pdwLoDword + 1;

            lstrcpy (szTypeNameBuffer, GetCounterTypeName (pCounterDef->CounterType));
            if (*szTypeNameBuffer == 0) {
                // no string returned so format data as HEX DWORD
                _stprintf (szTypeNameBuffer, (LPCTSTR)TEXT("Undefined Type: 0x%8.8x"),
                    pCounterDef->CounterType);
            }

            if (pCounterDef->CounterSize <= sizeof(DWORD)) {
                _stprintf (szDisplayBuffer, (LPCTSTR)TEXT("%d\t%s\t%s\t0x%8.8x (%d)"),
                    pCounterDef->CounterNameTitleIndex,
                    (pCounterDef->CounterNameTitleIndex <= dwLastName ?
                    szNameTable[pCounterDef->CounterNameTitleIndex] : (LPCTSTR)TEXT("Name not loaded")),
                    szTypeNameBuffer,
                    *pdwLoDword, *pdwLoDword);
            } else {
                _stprintf (szDisplayBuffer, (LPCTSTR)TEXT("%d\t%s\t%s\t0x%8.8x%8.8x"),
                    pCounterDef->CounterNameTitleIndex,
                    (pCounterDef->CounterNameTitleIndex <= dwLastName ?
                    szNameTable[pCounterDef->CounterNameTitleIndex] : (LPCTSTR)TEXT("Name not loaded")),
                    szTypeNameBuffer,
                    *pdwHiDword, *pdwLoDword);
            }
            SendDlgItemMessage (hDlg, IDC_DATA_LIST, LB_INSERTSTRING,
                (WPARAM)-1, (LPARAM)szDisplayBuffer);
            pCounterDef = NextCounter(pCounterDef);
        }
        if (lDisplayIndex < 0) {
            if (pObject->DefaultCounter >= 0) {
                SendDlgItemMessage (hDlg, IDC_DATA_LIST, LB_SETCURSEL,
                    (WPARAM)pObject->DefaultCounter, 0);
            } else {
                SendDlgItemMessage (hDlg, IDC_DATA_LIST, LB_SETCURSEL,
                    (WPARAM)0, 0);
            }
        } else {
            SendDlgItemMessage (hDlg, IDC_DATA_LIST, LB_SETCURSEL,
                (WPARAM)lDisplayIndex, (LPARAM)0);
        }
    } else {
        // no object and/or instsance selected so nothing else to do
    }

    return TRUE;
}

static
BOOL
OnComputerChange (
    IN  HWND    hDlg
)
{
    TCHAR   szLocalComputerName [MAX_COMPUTERNAME_LENGTH+3];
    HKEY    hLocalMachineKey = NULL;
    HKEY    hLocalPerfKey = NULL;
    LPWSTR  *szLocalNameTable = NULL;
    BOOL    bResult = FALSE;
    HWND    hWndComputerName;

    SET_WAIT_CURSOR;

    // get name from edit control
    hWndComputerName = GetDlgItem (hDlg, IDC_COMPUTERNAME);

    GetWindowText (hWndComputerName,
        szLocalComputerName,
        MAX_COMPUTERNAME_LENGTH+2);

    if (lstrcmpi(szComputerName, szLocalComputerName) != 0) {
        // a new name has been entered so try to connect to it
        if (lstrcmpi(szLocalComputerName, szThisComputerName) == 0) {
            // then this is the local machine which is a special case
            hLocalMachineKey = HKEY_LOCAL_MACHINE;
            hLocalPerfKey = HKEY_PERFORMANCE_DATA;
            szLocalComputerName[0] = 0;
        } else {
            // try to connect to remote computer
            if (RegConnectRegistry (szLocalComputerName,
                HKEY_LOCAL_MACHINE, &hLocalMachineKey) == ERROR_SUCCESS) {
                // connected to the new machine, so Try to connect to
                // the performance data, too
                if (RegConnectRegistry (szLocalComputerName,
                    HKEY_PERFORMANCE_DATA, &hLocalPerfKey) == ERROR_SUCCESS) {
                } else {
                    DisplayMessageBox (hDlg,
                        IDS_UNABLE_CONNECT_PERF,
                        IDS_APP_ERROR, MB_OK);
                }
            } else {
                DisplayMessageBox (hDlg,
                    IDS_UNABLE_CONNECT_MACH,
                    IDS_APP_ERROR, MB_OK);
            }
        }
        if ((hLocalMachineKey != NULL) && (hLocalPerfKey != NULL)) {
            // try to get a new name table
            szLocalNameTable = BuildNameTable (
                (szLocalComputerName == 0 ? NULL : szLocalComputerName),
                NULL,
                &dwLastName);

            if (szLocalNameTable) {
                bResult = TRUE;
            } else {
                DisplayMessageBox (hDlg,
                    IDS_UNABLE_GET_NAMES,
                    IDS_APP_ERROR, MB_OK);
            }
        }

        if (bResult) {
            // made it so close the old connections

            if (hKeyMachine != NULL) {
                RegCloseKey (hKeyMachine);
            }
            hKeyMachine = hLocalMachineKey;

            if (hKeyPerformance != NULL) {
                RegCloseKey (hKeyPerformance);
            }
            hKeyPerformance = hLocalPerfKey;

            if (szNameTable != NULL) {
                MemoryFree (szNameTable);
            }
            szNameTable = szLocalNameTable;

            if (szLocalComputerName[0] == 0) {
                lstrcpy (szComputerName, szThisComputerName);
            }

            // then update the fields
            bResult = LoadObjectList (hDlg, NULL);
            if (bResult) {
                LoadInstanceList (hDlg, NULL);
                ShowCounterData (hDlg, -1);
            }
        } else {
            // unable to get info from machine so clean up
            if (hLocalPerfKey != NULL) RegCloseKey (hLocalPerfKey);
            if (hLocalMachineKey != NULL) RegCloseKey (hLocalMachineKey);
            if (szLocalNameTable != NULL) MemoryFree (szLocalNameTable);
            // reset computer name to the one that works.
            SetWindowText (hWndComputerName, szComputerName);
        }
    } else {
        // the name hasn't changed
    }

    return TRUE;

}

static
BOOL
MainDlg_WM_INITDIALOG (
    IN  HWND    hDlg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
{
    DWORD       dwComputerNameLength = MAX_COMPUTERNAME_LENGTH+1;

    UNREFERENCED_PARAMETER (lParam);
    UNREFERENCED_PARAMETER (wParam);

    SET_WAIT_CURSOR;

    lstrcpy (szThisComputerName, (LPCTSTR)TEXT("\\\\"));
    GetComputerName (szThisComputerName+2, &dwComputerNameLength);

    szComputerName[0] = 0;  // reset the computer name
    // load the local machine name into the edit box
    SetWindowText (GetDlgItem (hDlg, IDC_COMPUTERNAME), szThisComputerName);

    SendDlgItemMessage (hDlg, IDC_DATA_LIST, LB_SETTABSTOPS,
        (WPARAM)NUM_TAB_STOPS, (LPARAM)&nDataListTabs);
    CheckDlgButton (hDlg, IDC_INCLUDE_COSTLY, UNCHECKED);

    OnComputerChange (hDlg);

    SetFocus (GetDlgItem (hDlg, IDC_OBJECT));

    SET_ARROW_CURSOR;
    return FALSE;
}

static
BOOL
MainDlg_IDC_COMPUTERNAME (
    IN  HWND    hDlg,
    IN  WORD    wNotifyMsg,
    IN  HWND    hWndControl
)
{
    UNREFERENCED_PARAMETER (hWndControl);

    switch (wNotifyMsg) {
        case EN_KILLFOCUS:
            OnComputerChange(hDlg);
            return TRUE;

        default:
            return FALSE;
    }
}

static
BOOL
MainDlg_IDC_OBJECT (
    IN  HWND    hDlg,
    IN  WORD    wNotifyMsg,
    IN  HWND    hWndControl
)
{
    UNREFERENCED_PARAMETER (hWndControl);

    switch (wNotifyMsg) {
        case CBN_SELCHANGE:
            SET_WAIT_CURSOR;
            if (pMainPerfData) {
                LoadInstanceList (hDlg, NULL);
                ShowCounterData (hDlg, -1);
            }
            SET_ARROW_CURSOR;
            return TRUE;

        default:
            return FALSE;
    }
}

static
BOOL
MainDlg_IDC_INSTANCE (
    IN  HWND    hDlg,
    IN  WORD    wNotifyMsg,
    IN  HWND    hWndControl
)
{
    UNREFERENCED_PARAMETER (hWndControl);

    switch (wNotifyMsg) {
        case CBN_SELCHANGE:
            SET_WAIT_CURSOR;
            ShowCounterData (hDlg, -1);
            SET_ARROW_CURSOR;
            return TRUE;

        default:
            return FALSE;
    }
}

static
BOOL
MainDlg_IDC_DATA_LIST (
    IN  HWND    hDlg,
    IN  WORD    wNotifyMsg,
    IN  HWND    hWndControl
)
{
    UNREFERENCED_PARAMETER (hWndControl);
    UNREFERENCED_PARAMETER (hDlg);

    switch (wNotifyMsg) {
        default:
            return FALSE;
    }
}

static
BOOL
MainDlg_IDC_REFRESH (
    IN  HWND    hDlg,
    IN  WORD    wNotifyMsg,
    IN  HWND    hWndControl
)
{
    TCHAR   szSelObject[MAX_PATH];
    TCHAR   szSelInstance[MAX_PATH];
    BOOL    bResult;
    LONG    lCounterIdx;

    UNREFERENCED_PARAMETER (hWndControl);

    switch (wNotifyMsg) {
        case BN_CLICKED:
            SET_WAIT_CURSOR;
            GetDlgItemText (hDlg, IDC_OBJECT,
                szSelObject, MAX_PATH-1);

            GetDlgItemText (hDlg, IDC_INSTANCE,
                szSelInstance, MAX_PATH-1);

            lCounterIdx = (ULONG)SendDlgItemMessage (hDlg, IDC_DATA_LIST,
                LB_GETCURSEL, 0, 0);

            bResult = LoadObjectList (hDlg, szSelObject);
            if (bResult) {
                LoadInstanceList (hDlg, szSelInstance);
                ShowCounterData (hDlg, lCounterIdx);
            }
            SET_ARROW_CURSOR;
            return TRUE;

        default:
            return FALSE;
    }
}

static
BOOL
MainDlg_WM_COMMAND (
    IN  HWND    hDlg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
{
    WORD    wCtrlId, wNotifyMsg;
    HWND    hWndControl;

    wCtrlId = GET_CONTROL_ID (wParam);
    wNotifyMsg = GET_NOTIFY_MSG (wParam, lParam);
    hWndControl = GET_COMMAND_WND (lParam);

    switch (wCtrlId) {
        case IDC_COMPUTERNAME:
            return MainDlg_IDC_COMPUTERNAME (hDlg, wNotifyMsg, hWndControl);

        case IDC_OBJECT:
            return MainDlg_IDC_OBJECT (hDlg, wNotifyMsg, hWndControl);

        case IDC_INSTANCE:
            return MainDlg_IDC_INSTANCE (hDlg, wNotifyMsg, hWndControl);

        case IDC_DATA_LIST:
            return MainDlg_IDC_DATA_LIST (hDlg, wNotifyMsg, hWndControl);

        case IDC_REFRESH:
            return MainDlg_IDC_REFRESH (hDlg, wNotifyMsg, hWndControl);

        case IDOK:
            EndDialog (hDlg, IDOK);
            return TRUE;

        default:
            return FALSE;
    }
}

static
BOOL
MainDlg_WM_SYSCOMMAND (
    IN  HWND    hDlg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
{
    UNREFERENCED_PARAMETER (lParam);

    switch (wParam) {
        case SC_CLOSE:
            EndDialog (hDlg, IDOK);
            return TRUE;

        default:
            return FALSE;
    }
}

static
BOOL
MainDlg_WM_CLOSE (
    IN  HWND    hDlg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
{
    UNREFERENCED_PARAMETER (lParam);
    UNREFERENCED_PARAMETER (wParam);
    UNREFERENCED_PARAMETER (hDlg);

    MemoryFree (pMainPerfData);
    pMainPerfData = NULL;

    MemoryFree (szNameTable);
    szNameTable = NULL;

    return TRUE;
}

INT_PTR
MainDlgProc (
    IN  HWND    hDlg,
    IN  UINT    message,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
)
{
    switch (message) {
        case WM_INITDIALOG:
            return MainDlg_WM_INITDIALOG (hDlg, wParam, lParam);

        case WM_COMMAND:
            return MainDlg_WM_COMMAND (hDlg, wParam, lParam);

        case WM_SYSCOMMAND:
            return MainDlg_WM_SYSCOMMAND (hDlg, wParam, lParam);

        case WM_CLOSE:
            return MainDlg_WM_CLOSE (hDlg, wParam, lParam);

        default:
            return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cntrtext\showperf\mainwnd.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    mainwnd.c

Abstract:

    Main Window procedure for ShowPerf app

Author:

    Bob Watson (a-robw)

Revision History:

    23 Nov 94


--*/
#include    <windows.h>
#include    <tchar.h>
#include    <stdlib.h>
#include    <stdio.h>
#include    <string.h>
#include    "resource.h"
#include    "SHOWPERF.h"
#include    "mainwnd.h"
#include    "maindlg.h"

//
//  GLOBAL functions
//
LRESULT CALLBACK
MainWndProc (
    IN	HWND hWnd,         // window handle
    IN	UINT message,      // type of message
    IN	WPARAM wParam,     // additional information
    IN  LPARAM lParam      // additional information
)
/*++

Routine Description:

    Windows Message processing routine for restkeys application.

Arguments:

    Standard WNDPROC api arguments

ReturnValue:

    0   or
    value returned by DefWindowProc

--*/
{
    switch (message) {
        case WM_CLOSE:
            DestroyWindow (hWnd);
            return ERROR_SUCCESS;

        case WM_DESTROY:
            PostQuitMessage (ERROR_SUCCESS);
            return ERROR_SUCCESS;

        default:
        	return (DefWindowProc(hWnd, message, wParam, lParam));
    }
}

BOOL
RegisterMainWindowClass (
    IN  HINSTANCE   hInstance
)
/*++

Routine Description:

    Registers the main window class for this application

Arguments:

    hInstance   application instance handle

Return Value:

    Return value of RegisterClass function

--*/
{
    WNDCLASS    wc;

    // Fill in window class structure with parameters that describe the
    // main window.

    wc.style         = CS_HREDRAW | CS_VREDRAW;// Class style(s).
    wc.lpfnWndProc   = (WNDPROC)MainWndProc;   // Window Procedure
    wc.cbClsExtra    = 0;                      // No per-class extra data.
    wc.cbWndExtra    = 0;                      // no extra data bytes.
    wc.hInstance     = hInstance;              // Owner of this class
    wc.hIcon         = NULL;                   // No Icon
    wc.hCursor       = LoadCursor(NULL, IDC_ARROW);     // Cursor
    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);        // Default color
    wc.lpszMenuName  = NULL;                            // No Menu
    wc.lpszClassName = GetStringResource(hInstance, IDS_APP_WINDOW_CLASS); // Name to register as

    // Register the window class and return success/failure code.
    return (BOOL)RegisterClass(&wc);
}

HWND
CreateMainWindow (
    IN  HINSTANCE   hInstance
)
{
    HWND        hWnd;   // return value
    RECT        rDesktop;  // desktop window
    
    GetWindowRect (GetDesktopWindow(), &rDesktop);

    // Create a main window for this application instance.

    hWnd = CreateWindowEx(
        0L,                 // make this window normal so debugger isn't covered
	    GetStringResource (hInstance, IDS_APP_WINDOW_CLASS), // See RegisterClass() call.
	    GetStringResource (hInstance, IDS_APP_TITLE), // Text for window title bar.
	    (DWORD)(WS_OVERLAPPEDWINDOW),   // Window style.
	    rDesktop.right+1,       // position window off desktop
	    rDesktop.bottom+1,
        1,
	    1,
	    (HWND)NULL,		    // Overlapped windows have no parent.
	    (HMENU)NULL,        // use class menu
	    hInstance,	        // This instance owns this window.
	    NULL                // not used
    );

    // If window could not be created, return "failure"
    if (hWnd != NULL) {
        DialogBox (hInstance,
            MAKEINTRESOURCE (IDD_MAIN),
            hWnd,
            MainDlgProc);

        PostMessage (hWnd, WM_CLOSE, 0, 0); // pack up and leave
    }
    return hWnd;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cntrtext\showperf\resource.h ===
#define IDC_STATIC                  -1
#define IDD_MAIN                    100
#define IDC_OBJECT                  1001
#define IDC_INSTANCE                1002
#define IDC_DATA_LIST               1003
#define IDC_REFRESH                 1004
#define IDC_INCLUDE_COSTLY          1005
#define IDH_CONTENTS                10000
#define IDI_APP_ICON                11000
#define IDS_APP_TITLE               20001
#define IDS_APP_ERROR               20003
#define IDS_APP_WINDOW_CLASS        20006
#define IDS_HELP_FILENAME           20007
#define IDS_UNABLE_GET_DATA         20009
#define IDS_UNABLE_CONNECT_PERF     20010
#define IDS_UNABLE_CONNECT_MACH     20011
#define IDS_UNABLE_GET_NAMES        20012
#define IDS_TYPE_COUNTER_COUNTER    20101
#define IDS_TYPE_COUNTER_TIMER      20102
#define IDS_TYPE_COUNTER_QUEUELEN   20103
#define IDS_TYPE_COUNTER_BULK_COUNT 20104
#define IDS_TYPE_COUNTER_TEXT       20105
#define IDS_TYPE_COUNTER_RAWCOUNT   20106
#define IDS_TYPE_COUNTER_LARGE_RAW  20107
#define IDS_TYPE_SAMPLE_FRACTION    20108
#define IDS_TYPE_SAMPLE_COUNTER     20109
#define IDS_TYPE_COUNTER_NODATA     20110
#define IDS_TYPE_COUNTER_TIMER_INV  20111
#define IDS_TYPE_SAMPLE_BASE        20112
#define IDS_TYPE_AVERAGE_TIMER      20113
#define IDS_TYPE_AVERAGE_BASE       20114
#define IDS_TYPE_AVERAGE_BULK       20115
#define IDS_TYPE_100NS_TIMER        20116
#define IDS_TYPE_100NS_TIMER_INV    20117
#define IDS_TYPE_MULTI_TIMER        20118
#define IDS_TYPE_MULTI_TIMER_INV    20119
#define IDS_TYPE_MULTI_BASE         20120
#define IDS_TYPE_100NS_MULTI_TIMER  20121
#define IDS_TYPE_100NS_MULTI_TIMER_INV 20122
#define IDS_TYPE_RAW_FRACTION       20123
#define IDS_TYPE_RAW_BASE           20124
#define IDS_TYPE_ELAPSED_TIME       20125
#define IDS_TYPE_HISTOGRAM          20126
#define IDS_TYPE_COUNTER_LARGE_QUEUELEN  20127
#define IDS_TYPE_COUNTER_DELTA      20128
#define IDS_TYPE_COUNTER_LARGE_DELTA 20129
#define IDS_TYPE_COUNTER_100NS_QUEUELEN 20130
#define IDS_TYPE_COUNTER_OBJ_TIME_QUEUELEN 20131
#define IDS_TYPE_COUNTER_RAW_HEX    20132
#define IDS_TYPE_COUNTER_LARGE_RAW_HEX 20133
#define IDS_TYPE_OBJ_TIME_TIMER     20134
#define IDS_TYPE_LARGE_RAW_FRACTION 20135
#define IDS_TYPE_LARGE_RAW_BASE     20136
#define IDS_TYPE_PRECISION_SYSTEM_TIMER 20137
#define IDS_TYPE_PRECISION_100NS_TIMER 20138
#define IDS_TYPE_PRECISION_OBJECT_TIMER 20139
#define IDD_COUNTER_DETAILS         200
#define IDC_COUNTER                 202
#define IDC_COUNTER_NAME_TITLE_INDEX 1006
#define IDC_COUNTER_NAME_TEXT       1007
#define IDC_COUNTER_HELP_TITLE_INDEX 1009
#define IDC_EXPLAIN_TEXT            1010
#define IDC_DEFAULT_SCALE           1011
#define IDC_DEFAULT_SCALE_FACTOR    1012
#define IDC_COUNTER_DETAIL_LEVEL    1013
#define IDC_COUNTER_SIZE            1014
#define IDC_COUNTER_VALUE           1015
#define IDC_COMPUTERNAME            1016
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cntrtext\showperf\perfdata.c ===
#include <windows.h>
#include <winperf.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <tchar.h>
#include "perfdata.h"

const LPWSTR NamesKey = (const LPWSTR)L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib";
const LPWSTR DefaultLangId = (const LPWSTR)L"009";
const LPWSTR Counters = (const LPWSTR)L"Counters";
const LPWSTR Help = (const LPWSTR)L"Help";
const LPWSTR LastHelp = (const LPWSTR)L"Last Help";
const LPWSTR LastCounter = (const LPWSTR)L"Last Counter";
const LPWSTR Slash = (const LPWSTR)L"\\";

// the following strings are for getting texts from perflib
#define  OLD_VERSION 0x010000
const LPWSTR VersionName = (const LPWSTR)L"Version";
const LPWSTR CounterName = (const LPWSTR)L"Counter ";
const LPWSTR HelpName = (const LPWSTR)L"Explain ";


LPMEMORY
MemoryAllocate (
    DWORD dwSize
)
{  // MemoryAllocate
    HMEMORY        hMemory ;
    LPMEMORY       lpMemory ;

    hMemory = GlobalAlloc (GHND, dwSize);
    if (!hMemory)
        return (NULL);
    lpMemory = GlobalLock (hMemory);
    if (!lpMemory)
        GlobalFree (hMemory);
    return (lpMemory);
}  // MemoryAllocate

VOID
MemoryFree (
    LPMEMORY lpMemory
)
{  // MemoryFree
    HMEMORY        hMemory ;

    if (!lpMemory)
        return ;

    hMemory = GlobalHandle (lpMemory);

    if (hMemory)
        {  // if
        GlobalUnlock (hMemory);
        GlobalFree (hMemory);
        }  // if
}  // MemoryFree

DWORD
MemorySize (
    LPMEMORY lpMemory
)
{
    HMEMORY        hMemory ;

    hMemory = GlobalHandle (lpMemory);
    if (!hMemory)
        return (0L);

    return (DWORD)(GlobalSize (hMemory));
}

LPMEMORY
MemoryResize (
    LPMEMORY lpMemory,
    DWORD dwNewSize
)
{
    HMEMORY        hMemory ;
    LPMEMORY       lpNewMemory ;

    hMemory = GlobalHandle (lpMemory);
    if (!hMemory)
        return (NULL);

    GlobalUnlock (hMemory);

    hMemory = GlobalReAlloc (hMemory, dwNewSize, GHND);

    if (!hMemory)
        return (NULL);


    lpNewMemory = GlobalLock (hMemory);

    return (lpNewMemory);
}  // MemoryResize

LPWSTR
*BuildNameTable(
    LPWSTR  szComputerName, // computer to query names from
    LPWSTR  lpszLangId,     // unicode value of Language subkey
    PDWORD  pdwLastItem     // size of array in elements
)
/*++

BuildNameTable

Arguments:

    hKeyRegistry
            Handle to an open registry (this can be local or remote.) and
            is the value returned by RegConnectRegistry or a default key.

    lpszLangId
            The unicode id of the language to look up. (default is 409)

Return Value:

    pointer to an allocated table. (the caller must free it when finished!)
    the table is an array of pointers to zero terminated strings. NULL is
    returned if an error occured.

--*/
{

    LPWSTR  *lpReturnValue;

    LPWSTR  *lpCounterId;
    LPWSTR  lpCounterNames;
    LPWSTR  lpHelpText;

    LPWSTR  lpThisName;

    LONG    lWin32Status;
    DWORD   dwLastError;
    DWORD   dwValueType;
    DWORD   dwArraySize;
    DWORD   dwBufferSize;
    DWORD   dwCounterSize;
    DWORD   dwHelpSize;
    DWORD   dwThisCounter;

    DWORD   dwSystemVersion;
    DWORD   dwLastId;
    DWORD   dwLastHelpId;

    HKEY    hKeyRegistry = NULL;
    HKEY    hKeyValue = NULL;
    HKEY    hKeyNames = NULL;

    LPWSTR  lpValueNameString;
    WCHAR   CounterNameBuffer [50];
    WCHAR   HelpNameBuffer [50];

    lpValueNameString = NULL;   //initialize to NULL
    lpReturnValue = NULL;

    if (szComputerName == NULL) {
        // use local machine
        hKeyRegistry = HKEY_LOCAL_MACHINE;
    } else {
        if (RegConnectRegistry (szComputerName,
            HKEY_LOCAL_MACHINE, &hKeyRegistry) != ERROR_SUCCESS) {
            // unable to connect to registry
            return NULL;
        }
    }

    // check for null arguments and insert defaults if necessary

    if (!lpszLangId) {
        lpszLangId = DefaultLangId;
    }

    // open registry to get number of items for computing array size

    lWin32Status = RegOpenKeyEx (
        hKeyRegistry,
        NamesKey,
        RESERVED,
        KEY_READ,
        &hKeyValue);

    if (lWin32Status != ERROR_SUCCESS) {
        goto BNT_BAILOUT;
    }

    // get number of items

    dwBufferSize = sizeof (dwLastHelpId);
    lWin32Status = RegQueryValueEx (
        hKeyValue,
        LastHelp,
        RESERVED,
        &dwValueType,
        (LPBYTE)&dwLastHelpId,
        &dwBufferSize);

    if ((lWin32Status != ERROR_SUCCESS) || (dwValueType != REG_DWORD)) {
        goto BNT_BAILOUT;
    }

    // get number of items

    dwBufferSize = sizeof (dwLastId);
    lWin32Status = RegQueryValueEx (
        hKeyValue,
        LastCounter,
        RESERVED,
        &dwValueType,
        (LPBYTE)&dwLastId,
        &dwBufferSize);

    if ((lWin32Status != ERROR_SUCCESS) || (dwValueType != REG_DWORD)) {
        goto BNT_BAILOUT;
    }


    if (dwLastId < dwLastHelpId)
        dwLastId = dwLastHelpId;

    dwArraySize = dwLastId * sizeof(LPWSTR);

    // get Perflib system version
    dwBufferSize = sizeof (dwSystemVersion);
    lWin32Status = RegQueryValueEx (
        hKeyValue,
        VersionName,
        RESERVED,
        &dwValueType,
        (LPBYTE)&dwSystemVersion,
        &dwBufferSize);

    if ((lWin32Status != ERROR_SUCCESS) || (dwValueType != REG_DWORD)) {
        dwSystemVersion = OLD_VERSION;
    }

    if (dwSystemVersion == OLD_VERSION) {
        // get names from registry
        lpValueNameString = MemoryAllocate (
            lstrlen(NamesKey) * sizeof (WCHAR) +
            lstrlen(Slash) * sizeof (WCHAR) +
            lstrlen(lpszLangId) * sizeof (WCHAR) +
            sizeof (UNICODE_NULL));

        if (!lpValueNameString) goto BNT_BAILOUT;

        lstrcpy (lpValueNameString, NamesKey);
        lstrcat (lpValueNameString, Slash);
        lstrcat (lpValueNameString, lpszLangId);

        lWin32Status = RegOpenKeyEx (
            hKeyRegistry,
            lpValueNameString,
            RESERVED,
            KEY_READ,
            &hKeyNames);
    } else {
        if (szComputerName == NULL) {
            hKeyNames = HKEY_PERFORMANCE_DATA;
        } else {
            if (RegConnectRegistry (szComputerName,
                HKEY_PERFORMANCE_DATA, &hKeyNames) != ERROR_SUCCESS) {
                goto BNT_BAILOUT;
            }
        }

        lstrcpy (CounterNameBuffer, CounterName);
        lstrcat (CounterNameBuffer, lpszLangId);

        lstrcpy (HelpNameBuffer, HelpName);
        lstrcat (HelpNameBuffer, lpszLangId);
    }

    // get size of counter names and add that to the arrays

    if (lWin32Status != ERROR_SUCCESS) goto BNT_BAILOUT;

    dwBufferSize = 0;
    lWin32Status = RegQueryValueEx (
        hKeyNames,
        dwSystemVersion == OLD_VERSION ? Counters : CounterNameBuffer,
        RESERVED,
        &dwValueType,
        NULL,
        &dwBufferSize);

    if (lWin32Status != ERROR_SUCCESS) goto BNT_BAILOUT;

    dwCounterSize = dwBufferSize;

    // get size of counter names and add that to the arrays

    if (lWin32Status != ERROR_SUCCESS) goto BNT_BAILOUT;

    dwBufferSize = 0;
    lWin32Status = RegQueryValueEx (
        hKeyNames,
        dwSystemVersion == OLD_VERSION ? Help : HelpNameBuffer,
        RESERVED,
        &dwValueType,
        NULL,
        &dwBufferSize);

    if (lWin32Status != ERROR_SUCCESS) goto BNT_BAILOUT;

    dwHelpSize = dwBufferSize;

    lpReturnValue = MemoryAllocate (dwArraySize + dwCounterSize + dwHelpSize);

    if (!lpReturnValue) goto BNT_BAILOUT;

    // initialize pointers into buffer

    lpCounterId = lpReturnValue;
    lpCounterNames = (LPWSTR)((LPBYTE)lpCounterId + dwArraySize);
    lpHelpText = (LPWSTR)((LPBYTE)lpCounterNames + dwCounterSize);

    // read counters into memory

    dwBufferSize = dwCounterSize;
    lWin32Status = RegQueryValueEx (
        hKeyNames,
        dwSystemVersion == OLD_VERSION ? Counters : CounterNameBuffer,
        RESERVED,
        &dwValueType,
        (LPVOID)lpCounterNames,
        &dwBufferSize);

    if (!lpReturnValue) goto BNT_BAILOUT;

    dwBufferSize = dwHelpSize;
    lWin32Status = RegQueryValueEx (
        hKeyNames,
        dwSystemVersion == OLD_VERSION ? Help : HelpNameBuffer,
        RESERVED,
        &dwValueType,
        (LPVOID)lpHelpText,
        &dwBufferSize);

    if (!lpReturnValue) goto BNT_BAILOUT;

    // load counter array items

    for (lpThisName = lpCounterNames;
         *lpThisName;
         lpThisName += (lstrlen(lpThisName)+1) ) {

        // first string should be an integer (in decimal unicode digits)

        dwThisCounter = wcstoul (lpThisName, NULL, 10);

        // point to corresponding counter name

        lpThisName += (lstrlen(lpThisName)+1);

        // and load array element;

        lpCounterId[dwThisCounter] = lpThisName;

    }

    for (lpThisName = lpHelpText;
         *lpThisName;
         lpThisName += (lstrlen(lpThisName)+1) ) {

        // first string should be an integer (in decimal unicode digits)

        dwThisCounter = wcstoul (lpThisName, NULL, 10);

        // point to corresponding counter name

        lpThisName += (lstrlen(lpThisName)+1);

        // and load array element;

        lpCounterId[dwThisCounter] = lpThisName;

    }

    if (pdwLastItem) *pdwLastItem = dwLastId;

    MemoryFree ((LPVOID)lpValueNameString);
    RegCloseKey (hKeyValue);
    if (dwSystemVersion == OLD_VERSION)
        RegCloseKey (hKeyNames);

    return lpReturnValue;

BNT_BAILOUT:
    if (lWin32Status != ERROR_SUCCESS) {
        dwLastError = GetLastError();
    }

    if (lpValueNameString) {
        MemoryFree ((LPVOID)lpValueNameString);
    }

    if (lpReturnValue) {
        MemoryFree ((LPVOID)lpReturnValue);
    }

    if (hKeyValue) RegCloseKey (hKeyValue);
    if (hKeyNames) RegCloseKey (hKeyNames);
    if (hKeyRegistry) RegCloseKey (hKeyNames);

    return NULL;
}

PPERF_OBJECT_TYPE
FirstObject (
    IN  PPERF_DATA_BLOCK pPerfData
)
{
    return ((PPERF_OBJECT_TYPE) ((PBYTE) pPerfData + pPerfData->HeaderLength));
}

PPERF_OBJECT_TYPE
NextObject (
    IN  PPERF_OBJECT_TYPE pObject
)
{  // NextObject
    DWORD   dwOffset;
    dwOffset =  pObject->TotalByteLength;
    if (dwOffset != 0) {
        return ((PPERF_OBJECT_TYPE) ((PBYTE) pObject + dwOffset));
    } else {
        return NULL;
    }
}  // NextObject

PERF_OBJECT_TYPE *
GetObjectDefByTitleIndex(
    IN  PERF_DATA_BLOCK *pDataBlock,
    IN  DWORD ObjectTypeTitleIndex
)
{
    DWORD NumTypeDef;

    PERF_OBJECT_TYPE *pObjectDef;

    pObjectDef = FirstObject(pDataBlock);

    for ( NumTypeDef = 0;
	  NumTypeDef < pDataBlock->NumObjectTypes;
	  NumTypeDef++ ) {

        if ( pObjectDef->ObjectNameTitleIndex == ObjectTypeTitleIndex ) {

	    return pObjectDef;
	}
        pObjectDef = NextObject(pObjectDef);
    }
    return 0;
}

PERF_INSTANCE_DEFINITION *
FirstInstance(
    IN  PERF_OBJECT_TYPE *pObjectDef
)
{
    return (PERF_INSTANCE_DEFINITION *)
               ((PCHAR) pObjectDef + pObjectDef->DefinitionLength);
}

PERF_INSTANCE_DEFINITION *
NextInstance(
    IN  PERF_INSTANCE_DEFINITION *pInstDef
)
{
    PERF_COUNTER_BLOCK *pCounterBlock;


    pCounterBlock = (PERF_COUNTER_BLOCK *)
                        ((PCHAR) pInstDef + pInstDef->ByteLength);

    return (PERF_INSTANCE_DEFINITION *)
               ((PCHAR) pCounterBlock + pCounterBlock->ByteLength);
}

PERF_INSTANCE_DEFINITION *
GetInstance(
    IN  PERF_OBJECT_TYPE *pObjectDef,
    IN  LONG InstanceNumber
)
{

   PERF_INSTANCE_DEFINITION *pInstanceDef;
   LONG NumInstance;

   if (!pObjectDef)
      {
      return 0;
      }

   pInstanceDef = FirstInstance(pObjectDef);

   for ( NumInstance = 0;
      NumInstance < pObjectDef->NumInstances;
      NumInstance++ )
      {
   	if ( InstanceNumber == NumInstance )
         {
         return pInstanceDef;
         }
      pInstanceDef = NextInstance(pInstanceDef);
      }

   return 0;
}

PERF_COUNTER_DEFINITION *
FirstCounter(
    PERF_OBJECT_TYPE *pObjectDef
)
{
    return (PERF_COUNTER_DEFINITION *)
               ((PCHAR) pObjectDef + pObjectDef->HeaderLength);
}

PERF_COUNTER_DEFINITION *
NextCounter(
    PERF_COUNTER_DEFINITION *pCounterDef
)
{
    DWORD   dwOffset;
    dwOffset =  pCounterDef->ByteLength;
    if (dwOffset != 0) {
        return (PERF_COUNTER_DEFINITION *)
                ((PCHAR) pCounterDef + dwOffset);
    } else {
        return NULL;
    }
}

#pragma warning ( disable : 4127 )
LONG
GetSystemPerfData (
    IN HKEY hKeySystem,
    IN PPERF_DATA_BLOCK *pPerfData,
    IN DWORD dwIndex       // 0 = Global, 1 = Costly
)
{  // GetSystemPerfData
    LONG     lError ;
    DWORD    Size;
    DWORD    Type;

	printf ("\nGetSystemPerfdata entered in line %d of %s", __LINE__, __FILE__);
    if (dwIndex >= 2) {
        return !ERROR_SUCCESS;
    }

    if (*pPerfData == NULL) {
        *pPerfData = MemoryAllocate (INITIAL_SIZE);
        if (*pPerfData == NULL) {
			printf ("\nMemory Allocation Failure in line %d of %s", __LINE__, __FILE__);
			return ERROR_OUTOFMEMORY;
		}
    }

    while (TRUE) {
        Size = MemorySize (*pPerfData);

        lError = RegQueryValueEx (
            hKeySystem,
            dwIndex == 0 ?
               (LPCWSTR)L"Global" :
               (LPCWSTR)L"Costly",
            RESERVED,
            &Type,
            (LPBYTE)*pPerfData,
            &Size);

        if ((!lError) &&
            (Size > 0) &&
            ((*pPerfData)->Signature[0] == (WCHAR)'P') &&
            ((*pPerfData)->Signature[1] == (WCHAR)'E') &&
            ((*pPerfData)->Signature[2] == (WCHAR)'R') &&
            ((*pPerfData)->Signature[3] == (WCHAR)'F')) {

            return (ERROR_SUCCESS);
        }

        if (lError == ERROR_MORE_DATA) {
            *pPerfData = MemoryResize (
                *pPerfData,
                MemorySize (*pPerfData) +
                EXTEND_SIZE);

            if (*pPerfData == NULL) {
                return (lError);
            }
        } else {
            return (lError);
        }
    }
}  // GetSystemPerfData
#pragma warning ( default : 4127 )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cntrtext\showperf\showperf.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    SHOWPERF.H

Abstract:


Author:

    Bob Watson (a-robw)

Revision History:

    23 NOV 94


--*/
#ifndef _SHOWPERF_H_
#define _SHOWPERF_H_

//  WIN32 Constant Definitions
//
#define BEEP_EXCLAMATION    MB_ICONEXCLAMATION
#define OF_SEARCH           0

#define MAX_PATH_BYTES      (MAX_PATH * sizeof(TCHAR))

#define SMALL_BUFFER_SIZE   1023
#define SMALL_BUFFER_BYTES  ((SMALL_BUFFER_SIZE + 1) * sizeof (TCHAR))

#define MEDIUM_BUFFER_SIZE  4095
#define MEDIUM_BUFFER_BYTES ((MEDIUM_BUFFER_SIZE + 1) * sizeof (TCHAR))

#define LARGE_BUFFER_SIZE   65535
#define LARGE_BUFFER_BYTES  ((LARGE_BUFFER_SIZE + 1) * sizeof (TCHAR))

// define dialog box button states
#define     ENABLED         TRUE
#define     DISABLED        FALSE

#define     CHECKED         1
#define     UNCHECKED       0

// define Mailbox buttons
#define MBOK_EXCLAIM            (MB_OK | MB_ICONEXCLAMATION | MB_TASKMODAL)
#define MBOK_INFO               (MB_OK | MB_ICONINFORMATION | MB_TASKMODAL)
#define MBOKCANCEL_EXCLAIM      (MB_OKCANCEL | MB_ICONEXCLAMATION | MB_TASKMODAL)
#define MBOKCANCEL_INFO         (MB_OKCANCEL | MB_ICONINFORMATION | MB_TASKMODAL)
#define MBOKCANCEL_QUESTION     (MB_OKCANCEL | MB_ICONQUESTION | MB_TASKMODAL)
#define MBYESNO_QUESTION        (MB_YESNO | MB_ICONQUESTION | MB_TASKMODAL)
#define MBYESNOCANCEL_QUESTION  (MB_YESNOCANCEL | MB_ICONQUESTION | MB_TASKMODAL)
#define MBYESNOCANCEL_EXCLAIM   (MB_YESNOCANCEL | MB_ICONEXCLAMATION | MB_TASKMODAL)

// other constants
#define MAX_USERNAME            15
#define MAX_DOMAINNAME          15
#define MAX_ORGNAME             255
#define MAX_PRODUCT_NAME_LENGTH 32

//
//  WIN32 Version of common macros
//
#define GLOBAL_ALLOC(s)		GlobalAlloc(GPTR,s)
#define GLOBAL_FREE_IF_ALLOC(p)	(p != NULL ? GlobalFree(p) : 0)

#define GET_CONTROL_ID(w)   (LOWORD(w))
#define GET_NOTIFY_MSG(w,l) (HIWORD(w))
#define GET_COMMAND_WND(l)  ((HWND)(l))
#define GET_INSTANCE(h)     ((HINSTANCE)GetWindowLongPtr(h, GWLP_HINSTANCE))
#define SAVE_HWND(w,o,v)    SetWindowLong (w,o,(LONG)v)
#define GET_HWND(w,o)       (HWND)GetWindowLong (w,o)
#define SET_HWND(w,o,v)     SetWindowLong (w,o, (DWORD)v)
#define SET_INFO(w,o,p)     (LPVOID)SetWindowLong (w,o,(LONG)p)
#define GET_INFO(w,o)       (LPVOID)GetWindowLong (w,o)
#define SEND_WM_COMMAND(w,c,n,cw)  SendMessage (w, WM_COMMAND, MAKEWPARAM(c,n), (LPARAM)cw)
#define POST_WM_COMMAND(w,c,n,cw)  PostMessage (w, WM_COMMAND, MAKEWPARAM(c,n), (LPARAM)cw)
#define GetMyLastError		GetLastError	
#define CLEAR_FIRST_FOUR_BYTES(x)   *(DWORD *)(x) = 0L
#define SET_WAIT_CURSOR     (SetCursor(LoadCursor(NULL, IDC_WAIT)))
#define SET_ARROW_CURSOR    (SetCursor(LoadCursor(NULL, IDC_ARROW)))

//
//  Global Functions
//
LPCTSTR
GetStringResource (
    IN  HANDLE	hInstance,
    IN  UINT    nId
);

BOOL
ShowAppHelp (
    IN  HWND    hWnd
);

int
DisplayMessageBox (
    IN  HWND    hWnd,
    IN  UINT    nMessageId,
    IN  UINT    nTitleId,
    IN  UINT    nStyle
);

VOID
SetHelpContextId (
    WORD    wId
);

WORD
GetHelpContextId (
);


#endif // _SHOWPERF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cntrtext\showperf\showperf.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    ShowPerf.c

Abstract:

    Provides a GUI interface to display the contents of a perf data
    block

Author:

    Bob Watson (a-robw)

Revision History:

    23 Nov 94


--*/
#include    <windows.h>
#include    <stdlib.h>
#include    <stdio.h>
#include    "showperf.h"
#include    "resource.h"
#include    "mainwnd.h"
#include    "maindlg.h"

#define NUM_BUFS    4

// variable definition

static  WORD    wHelpContextId = IDH_CONTENTS;

LPCTSTR
GetStringResource (
    IN  HANDLE	hInstance,
    IN  UINT    nId
)
/*++

Routine Description:

    look up string resource and return string

Arguments:

    IN  UINT    nId
        Resource ID of string to look up

Return Value:

    pointer to string referenced by ID in arg list

--*/
{
    static  TCHAR   szBufArray[NUM_BUFS][SMALL_BUFFER_SIZE];
    static  DWORD   dwIndex;
    LPTSTR  szBuffer;
    DWORD   dwLength;

    HANDLE  hMod;

    if (hInstance != NULL) {
        hMod = hInstance;
    } else {
        hMod = GetModuleHandle(NULL);
    }

    dwIndex++;
    dwIndex %= NUM_BUFS;
    szBuffer = &szBufArray[dwIndex][0];

    // clear previous contents
    memset (szBuffer, 0, (SMALL_BUFFER_SIZE * sizeof(TCHAR)));

    dwLength = LoadString (
        hMod,
        nId,
        szBuffer,
        SMALL_BUFFER_SIZE);

    return (LPCTSTR)szBuffer;
}

VOID
SetHelpContextId (
    WORD    wId
)
{
    wHelpContextId = wId;
    return;
}

WORD
GetHelpContextId (
)
{
    return wHelpContextId;
}

int
DisplayMessageBox (
    IN  HWND    hWnd,
    IN  UINT    nMessageId,
    IN  UINT    nTitleId,
    IN  UINT    nStyle
)
/*++

Routine Description:

    Displays a message box displaying text from the resource file, as
        opposed to literal strings.

Arguments:

    IN  HWND    hWnd            window handle to parent window
    IN  UINT    nMessageId      String Resource ID of message text to display
    IN  UINT    nTitleId        String Resource ID of title text to display
    IN  UINT    nStyle          MB style bits (see MessageBox function)

Return Value:

    ID of button pressed to exit message box

--*/
{
    LPTSTR      szMessageText = NULL;
    LPTSTR      szTitleText = NULL;
    HINSTANCE   hInst;
    int         nReturn;

    hInst = GET_INSTANCE(hWnd);

    szMessageText = GLOBAL_ALLOC (SMALL_BUFFER_BYTES);
    szTitleText = GLOBAL_ALLOC (SMALL_BUFFER_BYTES);

    if ((szMessageText != NULL) &&
        (szTitleText != NULL)) {
        LoadString (hInst,
            ((nTitleId != 0) ? nTitleId : IDS_APP_TITLE),
            szTitleText,
            SMALL_BUFFER_SIZE -1);

        LoadString (hInst,
            nMessageId,
            szMessageText,
            SMALL_BUFFER_SIZE - 1);

        nReturn = MessageBox (
            hWnd,
            szMessageText,
            szTitleText,
            nStyle);
    } else {
        nReturn = IDCANCEL;
    }

    GLOBAL_FREE_IF_ALLOC (szMessageText);
    GLOBAL_FREE_IF_ALLOC (szTitleText);

    return nReturn;
}

BOOL
UpdateSystemMenu (
    IN  HWND    hWnd   // window handle
)
/*++

Routine Description:

    modifies the system menu by:
        Removing the "Restore", "Size", "Minimize" and "Maximize" entries

Arguments:

    IN  HWND    hWnd
        window handle of window containing the system menu to modify


Return Value:

    TRUE if successfully made changes, otherwise
    FALSE if error occurred

--*/
{
    UNREFERENCED_PARAMETER (hWnd);

    return TRUE;
}

BOOL
ShowAppHelp (
    IN  HWND    hWnd
)
/*++

Routine Description:

    Generic routine to call WinHelp engine for displaying application
        help. wContext parameter is used for context.

Arguments:

    IN  HWND    hWnd
        window handle of calling window

Return Value:

    TRUE if help called successfully

--*/
{
    return WinHelp (hWnd,
        GetStringResource(GET_INSTANCE(hWnd), IDS_HELP_FILENAME),
        HELP_CONTEXT,
        (DWORD)GetHelpContextId());
}

int APIENTRY
WinMain(
    IN  HINSTANCE hInstance,
    IN  HINSTANCE hPrevInstance,
    IN  LPSTR     szCmdLine,
    IN  int       nCmdShow
)
/*++

Routine Description:

    Program entry point for LoadAccount application. Initializes Windows
        data structures and begins windows message processing loop.

Arguments:

    Standard WinMain arguments

ReturnValue:

    0 if unable to initialize correctly, or
    wParam from WM_QUIT message if messages processed

--*/
{
    HWND        hWnd; // Main window handle.
	MSG         msg;

    UNREFERENCED_PARAMETER (nCmdShow);
    UNREFERENCED_PARAMETER (szCmdLine);
    UNREFERENCED_PARAMETER (hPrevInstance);

    if (RegisterMainWindowClass(hInstance)) {
        hWnd = CreateMainWindow (hInstance);

        if (hWnd != NULL) {

	        // Acquire and dispatch messages until a
            //  WM_QUIT message is received.

	        while (GetMessage(&msg, // message structure
	            NULL,   // handle of window receiving the message
	            0,      // lowest message to examine
	            0))    // highest message to examine
            {
                // process this message
                TranslateMessage(&msg);// Translates virtual key codes
                DispatchMessage(&msg); // Dispatches message to window
            }
	        return (int)(msg.wParam); // Returns the value from PostQuitMessage
        } else {
            return (ERROR_CAN_NOT_COMPLETE);
        }
    } else {
        return (ERROR_CAN_NOT_COMPLETE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cntrtext\showperf\perfdata.h ===
#ifndef _PERFDATA_H_
#define _PERFDATA_H_

#define INITIAL_SIZE    4096L
#define EXTEND_SIZE     4096L
#define RESERVED        0L

typedef LPVOID  LPMEMORY;
typedef HGLOBAL HMEMORY;

typedef struct _UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
    PWSTR  Buffer;
} UNICODE_STRING, *PUNICODE_STRING;
#define UNICODE_NULL ((WCHAR)0) // winnt

LPMEMORY
MemoryAllocate (
    DWORD dwSize
);

VOID
MemoryFree (
    LPMEMORY lpMemory
);

DWORD
MemorySize (
    LPMEMORY lpMemory
);

LPMEMORY
MemoryResize (
    LPMEMORY lpMemory,
    DWORD dwNewSize
);

LPWSTR
*BuildNameTable(
    LPWSTR  szComputerName, // computer to query names from 
    LPWSTR  lpszLangId,     // unicode value of Language subkey
    PDWORD  pdwLastItem     // size of array in elements
);

PPERF_OBJECT_TYPE
FirstObject (
    IN  PPERF_DATA_BLOCK pPerfData
);

PPERF_OBJECT_TYPE
NextObject (
    IN  PPERF_OBJECT_TYPE pObject
);

PERF_OBJECT_TYPE *
GetObjectDefByTitleIndex(
    IN  PERF_DATA_BLOCK *pDataBlock,
    IN  DWORD ObjectTypeTitleIndex
);

PERF_INSTANCE_DEFINITION *
FirstInstance(
    IN  PERF_OBJECT_TYPE *pObjectDef
);

PERF_INSTANCE_DEFINITION *
NextInstance(
    IN  PERF_INSTANCE_DEFINITION *pInstDef
);

PERF_INSTANCE_DEFINITION *
GetInstance(
    IN  PERF_OBJECT_TYPE *pObjectDef,
    IN  LONG InstanceNumber
);

PERF_COUNTER_DEFINITION *
FirstCounter(
    PERF_OBJECT_TYPE *pObjectDef
);

PERF_COUNTER_DEFINITION *
NextCounter(
    PERF_COUNTER_DEFINITION *pCounterDef
);

LONG
GetSystemPerfData (
    IN HKEY hKeySystem,
    IN PPERF_DATA_BLOCK *pPerfData,
    IN DWORD dwIndex       // 0 = Global, 1 = Costly
);



#endif //_PERFDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\compdir\compdir.h ===
#include <windows.h>
#include <stdio.h>

#include <stdlib.h>
#include <string.h>

#include <direct.h>
#include <io.h>
#include <conio.h>

#define GetFileAttributeError 0xFFFFFFFF
#define printval( var, type) printf( #var " = %" #type "\n", var) // macro for debugging
#define READ_BUFFER_SIZE ( 8*1024*sizeof(DWORD)) // 32k blocks


#define ATTRIBUTE_TYPE DWORD
#define GET_ATTRIBUTES( FileName, Attributes) Attributes = GetFileAttributes( FileName)
#define SET_ATTRIBUTES( FileName, Attributes) !SetFileAttributes( FileName, Attributes)

HINSTANCE NtDll; // used to load Dll's rather than link with them

#define WORK_INITIALIZE_ITEM 0
#define WORK_ITEM            1
#define WORK_TERMINATE_ITEM  2

typedef VOID (*PWORKER_ROUTINE)();

typedef struct _WORK_QUEUE {
    CRITICAL_SECTION CriticalSection;
    HANDLE Semaphore;
    LIST_ENTRY Queue;
    BOOL Terminating;
    PWORKER_ROUTINE WorkerRoutine;
    DWORD NumberOfWorkerThreads;
    HANDLE WorkerThreads[ 1 ];      // Variable length array
} WORK_QUEUE, *PWORK_QUEUE;

typedef struct _WORK_QUEUE_ITEM {
    LIST_ENTRY List;
    DWORD Reason;
    PWORK_QUEUE WorkQueue;
} WORK_QUEUE_ITEM, *PWORK_QUEUE_ITEM;

typedef struct _VIRTUAL_BUFFER {
    LPVOID Base;
    SIZE_T PageSize;
    LPVOID CommitLimit;
    LPVOID ReserveLimit;
} VIRTUAL_BUFFER, *PVIRTUAL_BUFFER;

typedef struct _COPY_REQUEST_STATE {
    VIRTUAL_BUFFER Buffer;
    LPSTR CurrentOutput;
} COPY_REQUEST_STATE, *PCOPY_REQUEST_STATE;

CRITICAL_SECTION CreatePathCriticalSection;

typedef struct _COPY_REQUEST {
    WORK_QUEUE_ITEM WorkItem;
    LPSTR Destination;
    LPSTR FullPathSrc;
    ATTRIBUTE_TYPE Attributes;
    DWORD SizeLow;
} COPY_REQUEST, *PCOPY_REQUEST;

INT NumberOfWorkerThreads;
DWORD TlsIndex;
PWORK_QUEUE CDWorkQueue;

#define NONREADONLYSYSTEMHIDDEN ( ~( FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_HIDDEN))
#define NORMAL_ATTRIBUTES (FILE_ATTRIBUTE_DIRECTORY |   \
                           FILE_ATTRIBUTE_READONLY |    \
                           FILE_ATTRIBUTE_SYSTEM |      \
                           FILE_ATTRIBUTE_HIDDEN |      \
                           FILE_ATTRIBUTE_ARCHIVE)

#define _strrev

FILE *CheckFile;
char CheckFileName[_MAX_PATH];

typedef struct NodeStruct {
    char			  *Name;
    FILETIME                      Time;
    ATTRIBUTE_TYPE                Attributes;
    int                           Height;
    struct NodeStruct             *First;
    struct NodeStruct             *Last;
    struct NodeStruct             *Left;
    struct NodeStruct             *Next;
    struct NodeStruct             *Right;
    DWORD			  SizeHigh;
    DWORD			  SizeLow;
    char			  Flag[5];
    struct NodeStruct             *DiffNode;
    BOOL                          Process;

} *LinkedFileList; /* linked file list */

typedef struct CFLStruct {
    LinkedFileList *List;
    char           *Path;
} *PCFLStruct;

DWORD ReadBuffer[READ_BUFFER_SIZE/sizeof(DWORD)];

BOOL ProcessModeDefault;

//
// Flags passed to COMPDIR
//

BOOL  fBreakLinks;
BOOL  fCheckAttribs;
BOOL  fCheckBits;
BOOL  fChecking;
BOOL  fCheckSize;
BOOL  fCheckTime;
BOOL  fCreateNew;
BOOL  fCreateLink;
BOOL  fDoNotDelete;
BOOL  fDoNotRecurse;
BOOL  fDontCopyAttribs;
BOOL  fDontLowerCase;
BOOL  fExclude;
BOOL  fExecute;
BOOL  fIgnoreRs;       // Ignore Resource, TimeStamps, CheckSums and Rebase Information
BOOL  fIgnoreSlmFiles;
BOOL  fMatching;
BOOL  fMultiThread;
BOOL  fOpposite;
BOOL  fScript;
BOOL  fSpecAttribs;
BOOL  fVerbose;

BOOL  ExitValue;
BOOL  SparseTree;

BOOL NoMapBinaryCompare( char *file1, char *file2);
BOOL BinaryCompare( char *file1, char *file2);
LPSTR CombineThreeStrings( char *FirstString, char *SecondString, char *ThirdString);
void  CompDir( char *Path1, char *Path2);
BOOL  FilesDiffer( LinkedFileList File1, LinkedFileList File2, char *Path1, char *Path2);
void  CompLists( LinkedFileList *AddList, LinkedFileList *DelList, LinkedFileList *DifList, char *Path1, char *Path2);
void  CopyNode( char *Destination, LinkedFileList Source, char *FullPathSrc);
DWORD CreateFileList( LPVOID ThreadParameter);
BOOL  DelNode( char *name);
BOOL  IsFlag( char *argv);
BOOL  MyCreatePath( char *Path, BOOL IsDirectory);
BOOL  MyCopyFile( LPCSTR lpExistingFileName, LPCSTR lpNewFileName, BOOL bFailIfExists);
void  ParseEnvArgs( void);
void  ParseArgs( int argc, char *argv[]);
void  PrintFile( LinkedFileList File, char *Path, char *DiffPath);
void  PrintList( LinkedFileList list);
void  ProcessAdd( LinkedFileList List, char *String1, char *String2);
void  ProcessDel( LinkedFileList List, char *String);
void  ProcessDiff( LinkedFileList List, char *String1, char *String2);
void  ProcessLists( LinkedFileList AddList, LinkedFileList DelList, LinkedFileList DifList,
                   char *Path1, char *Path2                                               );
void  Usage( void);
BOOL  AddToList( LinkedFileList Node, LinkedFileList *list);

void  CreateNode( LinkedFileList *Node, WIN32_FIND_DATA *Buff);
BOOL  InitializeNtDllFunctions();
BOOL  MakeLink( char *src, char *dst, BOOL Output);
int   NumberOfLinks( char *FileName);
BOOL  SisCopyFile( LPCSTR lpExistingFileName, LPCSTR lpNewFileName, BOOL bFailIfExists, LPBOOL fTrySis);

PWORK_QUEUE CreateWorkQueue( IN DWORD NumberOfWorkerThreads, IN PWORKER_ROUTINE WorkerRoutine);
VOID  ProcessRequest( IN PWORK_QUEUE_ITEM WorkItem);
VOID  DestroyWorkQueue( IN OUT PWORK_QUEUE WorkQueue);
DWORD WorkerThread( LPVOID lpThreadParameter);
VOID  DestroyWorkQueue( IN OUT PWORK_QUEUE WorkQueue);
BOOL  QueueWorkItem( IN OUT PWORK_QUEUE WorkQueue, IN PWORK_QUEUE_ITEM WorkItem);
VOID  ProcessCopyFile( IN PCOPY_REQUEST WorkerRequest, IN PCOPY_REQUEST_STATE State);
BOOL  CreateVirtualBuffer( OUT PVIRTUAL_BUFFER Buffer, IN SIZE_T CommitSize, IN SIZE_T ReserveSize OPTIONAL);
BOOL  ExtendVirtualBuffer( IN PVIRTUAL_BUFFER Buffer, IN LPVOID Address);
BOOL  TrimVirtualBuffer( IN PVIRTUAL_BUFFER Buffer);
BOOL  FreeVirtualBuffer( IN PVIRTUAL_BUFFER Buffer);
int   VirtualBufferExceptionFilter( IN DWORD ExceptionCode, IN PEXCEPTION_POINTERS ExceptionInfo, IN OUT PVIRTUAL_BUFFER Buffer);

void  CreateNameNode( LinkedFileList *Node, char *Name);
void  DuplicateNode( LinkedFileList FirstNode, LinkedFileList *Node);
BOOL  Excluded( char *Buff, char *Path);
BOOL  Matched( char *Buff, char *Path);
void  FreeList( LinkedFileList *list);
LPSTR MyStrCat( char* firststring, char *secondstring);
BOOL  Match( char *pat, char* text);
void  OutOfMem( void);
void  PrintTree( LinkedFileList List, int Level);
BOOL  FindInMatchListTop( char *Name, LinkedFileList *List);
BOOL  FindInMatchListFront( char *Name, LinkedFileList *List);
LinkedFileList *FindInList( char *Name, LinkedFileList *List);
LinkedFileList *Next( LinkedFileList List);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\compdir\compdir.c ===
/************************************************************************
 *  Compdir: compare directories
 *
 ************************************************************************/

#define IF_GET_ATTR_FAILS( FileName, Attributes) GET_ATTRIBUTES( FileName, Attributes); if ( Attributes == GetFileAttributeError)
#define FIND_FIRST( String, Buff) FindFirstFile( String, &Buff)
#define FIND_NEXT( handle, Buff) !FindNextFile( handle, &Buff)
#define FREE( memory)
#define MYSTRCAT( FirstString, SecondString) strcat( strcpy( _alloca( strlen( FirstString) + strlen( SecondString) + 1), FirstString), SecondString)
#define COMBINETHREESTRINGS( FirstString, SecondString, ThirdString) strcat( strcat( strcpy( _alloca( strlen( FirstString) + strlen( SecondString) + strlen( ThirdString) + 1), FirstString), SecondString), ThirdString)

#include "compdir.h"

#include "imagehlp.h"

int Mymemcmp( const void *buf1, const void *buf2, size_t count );

char RebasedFile[MAX_PATH]; // used in BinaryCompares with /i switch
char *RebasedFile2 = NULL;  // used in BinaryCompares with /i switch

LinkedFileList  MatchList   = NULL;
LinkedFileList  MStarList   = NULL;
LinkedFileList  ExcludeList = NULL;
LinkedFileList  EStarList   = NULL;

DWORD Granularity = 0;   // used in ParseArgs

ATTRIBUTE_TYPE CompareAttribute, NegativeCompareAttribute; // used as file compare criteria
BOOL CompareAttributeSet = FALSE;
BOOL NegativeCompareAttributeSet = FALSE;
BOOL Excludes    = FALSE;
BOOL Matches     = FALSE;
BOOL RunningOnNT = FALSE;

BOOL DealingWithDirectories;

fSpecAttribs     = FALSE;
fBreakLinks      = FALSE;
fCheckAttribs    = FALSE;
fCheckBits       = FALSE;
fChecking        = FALSE;
fCheckSize       = FALSE;
fCheckTime       = FALSE;
fCreateNew       = FALSE;
fCreateLink      = FALSE;
fDoNotDelete     = FALSE;
fDoNotRecurse    = FALSE;
fDontCopyAttribs = FALSE;
fDontLowerCase   = FALSE;
fExclude         = FALSE;
fExecute         = FALSE;
fForce           = FALSE;
fIgnoreRs        = FALSE;
fIgnoreSlmFiles  = FALSE;
fMatching        = FALSE;
fMultiThread     = FALSE;
fOnlyIfExists    = FALSE;
fOpposite        = FALSE;
fScript          = FALSE;
fTrySis          = FALSE;
fVerbose         = FALSE;

void  __cdecl main( int argc, char **argv)
{
    ATTRIBUTE_TYPE Attributes1, Attributes2;
    char *Path1, *Path2;

    OSVERSIONINFO VersionInformation;

    SYSTEM_INFO SystemInformation;

    ExitValue = 0;

    Attributes1 = GetFileAttributeError;
    Attributes2 = GetFileAttributeError;

    ProcessModeDefault = TRUE;               // Used by opposite mode

    ParseEnvArgs( );         // Parse COMPDIRCMD environment variable
    ParseArgs( argc, argv);  // Check argument validity.

    //
    // Check existence of first path.
    //

    IF_GET_ATTR_FAILS( argv[argc - 2], Attributes1)
    {
        fprintf( stderr, "Could not find %s (error = %d)\n", argv[argc - 2], GetLastError());
        exit( 1);
    }

    IF_GET_ATTR_FAILS( argv[argc - 1], Attributes2)
    {
        if ( !fCreateNew)
        {
            fprintf( stderr, "Could not find %s (error = %d)\n", argv[argc - 1], GetLastError());
            exit( 1);
        }
    }
    //
    // If second directory is a drive letter append path of first directory
    //     to it
    //
    if (
        ( strlen( argv[argc-1]) == 2)
                   &&
        ( *( argv[argc-1] + 1) == ':')
       )
    {
        if ( ( Path2 = _fullpath( NULL, argv[argc-2], 0)) == NULL)
        {
            Path2 = argv[argc-1];

        } else
        {
            Path2[0] = *( argv[argc-1]);
            IF_GET_ATTR_FAILS( Path2, Attributes2)
            {
                if ( !fCreateNew)
                {
                    fprintf( stderr, "Could not find %s (error = %d)\n", Path2, GetLastError());
                    exit( 1);
                }
            }
        }

    } else if ( ( Path2 = _fullpath( NULL, argv[argc-1], 0)) == NULL)
    {
        Path2 = argv[argc-1];
    }

    if ( ( Path1 = _fullpath( NULL, argv[argc-2], 0)) == NULL)
    {
        Path1 = argv[argc-2];
    }

    if ( !fDontLowerCase)
    {
        _strlwr( Path1);
        _strlwr( Path2);
    }

    if ( fVerbose)
    {
        fprintf( stdout, "Compare criterion: existence" );
        if ( fCheckSize)
        {
            fprintf( stdout, ", size" );
        }
        if ( fCheckTime)
        {
            fprintf( stdout, ", date/time" );
        }
        if ( fCheckBits)
        {
            fprintf( stdout, ", contents" );
        }
        fprintf( stdout, "\n" );
        fprintf( stdout, "Path1: %s\n", Path1);
        fprintf( stdout, "Path2: %s\n", Path2);
    }

    VersionInformation.dwOSVersionInfoSize = sizeof( OSVERSIONINFO);

    if ( GetVersionEx( &VersionInformation) )
    {
        if ( VersionInformation.dwPlatformId == VER_PLATFORM_WIN32_NT )
        {
            RunningOnNT = TRUE;
        }
    }

    if ( ( fCreateLink) || ( fBreakLinks) || ( fTrySis))
    {
        if ( RunningOnNT)
        {
            NtDll = LoadLibrary( "ntdll.dll");
            if ( !NtDll)
            {
                fprintf( stderr, "Could not find ntdll.dll. Can't perform /l or /$\n");
                fCreateLink = FALSE;
                fTrySis = FALSE;
                ExitValue = 1;

            } else
            {
                if ( !InitializeNtDllFunctions())
                {
                    fprintf( stderr, "Could not load ntdll.dll. Can't perform /l or /$\n");
                    fCreateLink = FALSE;
                    fTrySis = FALSE;
                    ExitValue = 1;
                }
            }

        } else
        {
            fprintf( stderr, "/l and /$ only work on NT. Can't perform /l or /$\n");
            fCreateLink = FALSE;
            fTrySis = FALSE;
            ExitValue = 1;
        }

    }

    if ( fMultiThread)
    {
        //
        // Query the number of processors from the system and
        // default the number of worker threads to 4 times that.
        //

        GetSystemInfo( &SystemInformation );
        NumberOfWorkerThreads = SystemInformation.dwNumberOfProcessors * 4;
        if ( fVerbose)
        {
            fprintf( stdout, "Processors: %d\n", SystemInformation.dwNumberOfProcessors );
        }

        //
        // Allocate a thread local storage slot for use by our worker
        // thread routine ( ProcessRequest).  This call reserves a
        // 32-bit slot in the thread local storage array for every
        // thread in this process.  Remember the slot index in a global
        // variable for use by our worker thread routine.
        //

        TlsIndex = TlsAlloc();
        if ( TlsIndex == 0xFFFFFFFF)
        {
            fprintf( stderr, "Unable to allocate thread local storage.\n" );
            fMultiThread = FALSE;
            ExitValue = 1;
        }
        //
        // Create a work queue, which will create the specified number of threads
        // to process.
        //

        CDWorkQueue = CreateWorkQueue( NumberOfWorkerThreads, ProcessRequest );
        if ( CDWorkQueue == NULL)
        {
            fprintf( stderr, "Unable to create %u worker threads.\n", NumberOfWorkerThreads );
            fMultiThread = FALSE;
            ExitValue = 1;
        }
        //
        // Mutual exclusion between and requests that are creating paths
        // is done with a critical section.
        //

        InitializeCriticalSection( &CreatePathCriticalSection );
    }


    if ( Attributes1 & FILE_ATTRIBUTE_DIRECTORY)
    {
        DealingWithDirectories = TRUE;

    } else
    {
        DealingWithDirectories = FALSE;
    }

    if ( Matches)
    {
        SparseTree = TRUE;

    } else
    {
        SparseTree = FALSE;
    }

    if ( fCreateNew)
    {
        IF_GET_ATTR_FAILS( Path2, Attributes2)
        {
            fprintf ( stdout, "Making %s\t", Path2);

            if ( !MyCreatePath( Path2, DealingWithDirectories))
            {
                fprintf ( stderr, "Unable to create path %s\n", Path2);
                fprintf ( stdout, "\n");
                ExitValue = 1;

            } else
            {
                fprintf( stdout, "[OK]\n");
                CompDir( Path1, Path2);
            }

        } else
        {
            CompDir( Path1, Path2);
        }

    } else
    {
        CompDir( Path1, Path2);
    }

    free( Path1);
    free( Path2);

    if ( fIgnoreRs)
    {
        _unlink( RebasedFile2); // Delete RebasedFile that might have been created
    }

    if ( fMultiThread)
    {
        //
        // This will wait for the work queues to empty before terminating the
        // worker threads and destroying the queue.
        //

        DestroyWorkQueue( CDWorkQueue );
        DeleteCriticalSection( &CreatePathCriticalSection );
    }

    if ( fCreateLink)
    {
        FreeLibrary( NtDll);
    }

    exit( ExitValue);

}  // main

BOOL NoMapBinaryCompare ( char *file1, char *file2)
{
    register int char1, char2;
    FILE *filehandle1, *filehandle2;

    if ( ( filehandle1 = fopen ( file1, "rb")) == NULL)
    {
        fprintf ( stderr, "cannot open %s\n", file1);
        ExitValue = 1;
        return ( FALSE);
    }
    if ( ( filehandle2 = fopen( file2, "rb")) == NULL)
    {
        fprintf( stderr, "cannot open %s\n", file2);
        fclose( filehandle1);
        ExitValue = 1;
        return( FALSE);
    }
    while ( TRUE)
    {
        if ( ( char1 = getc( filehandle1)) != EOF)
        {
            if ( ( char2 = getc( filehandle2)) != EOF)
            {
                if ( char1 != char2)
                {
                    fclose( filehandle1);
                    fclose( filehandle2);
                    return( FALSE);
                }

            } else
            {
                fclose( filehandle1);
                fclose( filehandle2);
                return( FALSE);
            }

        } else
        {
            if ( ( char2 = getc( filehandle2)) == EOF)
            {
                fclose( filehandle1);
                fclose( filehandle2);
                return( TRUE);

            } else
            {
                fclose( filehandle1);
                fclose( filehandle2);
                return( FALSE);
            }
        }
    }
}


BOOL BinaryCompare( char *file1, char *file2)
{

    HANDLE hFile1, hFile2;
    HANDLE hMappedFile1, hMappedFile2;

    BOOL IsNTImage = FALSE;

    LPVOID MappedAddr1, MappedAddr2;

    PIMAGE_NT_HEADERS32   NtHeader1, NtHeader2;

    ULONG OldImageSize, NewImageSize;
    ULONG_PTR OldImageBase, NewImageBase;

    // fprintf( stdout, "file1: %s, file2: %s\n", file1, file2);

    //
    // File1 Mapping
    //

    if ( ( hFile1 = CreateFile(
                               file1,
                               GENERIC_READ,
                               FILE_SHARE_READ,
                               NULL,
                               OPEN_EXISTING,
                               0,
                               NULL
                              )) == (HANDLE)-1)
    {
        fprintf( stderr, "Unable to open %s, error code %d\n", file1, GetLastError() );
        if ( hFile1 != INVALID_HANDLE_VALUE)
        {
            CloseHandle( hFile1 );
        }
        return FALSE;
    }

    hMappedFile1 = CreateFileMapping(
                                     hFile1,
                                     NULL,
                                     PAGE_WRITECOPY,
                                     0,
                                     0,
                                     NULL
                                    );

    if ( hMappedFile1 == NULL)
    {
        fprintf( stderr, "Unable to map %s, error code %d\n", file1, GetLastError() );
        CloseHandle( hFile1);
        return FALSE;
    }

    MappedAddr1 = MapViewOfFile(
                                hMappedFile1,
                                FILE_MAP_COPY,
                                0,
                                0,
                                0
                               );

    if ( MappedAddr1 == NULL)
    {
        fprintf( stderr, "Unable to get mapped view of %s, error code %d\n", file1, GetLastError() );
        CloseHandle( hFile1 );
        return FALSE;
    }

    CloseHandle( hMappedFile1);

    //
    // File2 rebasing and mapping
    //

    if ( fIgnoreRs)
    {
        if ( ( ( PIMAGE_DOS_HEADER)MappedAddr1)->e_magic == IMAGE_DOS_SIGNATURE)
        {
            try
            {
                NtHeader1 = ( PIMAGE_NT_HEADERS32)( (PCHAR)MappedAddr1 + ( (PIMAGE_DOS_HEADER)MappedAddr1)->e_lfanew);

                if ( NtHeader1->Signature == IMAGE_NT_SIGNATURE)
                {
                    NewImageBase = ( NtHeader1->OptionalHeader.ImageBase);

                    if (
                         ( RebasedFile2 != NULL)
                                   &&
                         ( CopyFile ( file2, RebasedFile2, FALSE))
                                   &&
                         ( ReBaseImage(
                                       RebasedFile2,
                                       NULL,
                                       TRUE,
                                       FALSE,
                                       FALSE,
                                       0,
                                       &OldImageSize,
                                       &OldImageBase,
                                       &NewImageSize,
                                       &NewImageBase,
                                       0
                                      ))
                       )
                    {
                        IsNTImage = TRUE;
                    }
                }
            }
            except( EXCEPTION_EXECUTE_HANDLER ) {}
        }
    }

    if ( IsNTImage)
    {
        if ( ( hFile2 = CreateFile(
                                   RebasedFile2,
                                   GENERIC_READ,
                                   FILE_SHARE_READ,
                                   NULL,
                                   OPEN_EXISTING,
                                   0,
                                   NULL
                                  )) == (HANDLE)-1)
        {
            fprintf( stderr, "Unable to open %s, error code %d\n", RebasedFile2, GetLastError() );
            if ( hFile2 != INVALID_HANDLE_VALUE)
            {
                CloseHandle( hFile2 );
            }
            return FALSE;
        }

    } else
    {
        if ( ( hFile2 = CreateFile(
                                   file2,
                                   GENERIC_READ,
                                   FILE_SHARE_READ,
                                   NULL,
                                   OPEN_EXISTING,
                                   0,
                                   NULL
                                  )) == (HANDLE)-1 )
        {
            fprintf( stderr, "Unable to open %s, error code %d\n", file2, GetLastError() );
            if ( hFile2 != INVALID_HANDLE_VALUE)
            {
                CloseHandle( hFile2 );
            }
            return FALSE;
        }
    }

    hMappedFile2 = CreateFileMapping(
                                     hFile2,
                                     NULL,
                                     PAGE_WRITECOPY,
                                     0,
                                     0,
                                     NULL
                                    );

    if ( hMappedFile2 == NULL)
    {
        fprintf( stderr, "Unable to map %s, error code %d\n", file2, GetLastError() );
        CloseHandle( hFile2);
        return FALSE;
    }

    MappedAddr2 = MapViewOfFile(
                                hMappedFile2,
                                FILE_MAP_COPY,
                                0,
                                0,
                                0
                               );

    if ( MappedAddr2 == NULL)
    {
        fprintf( stderr, "Unable to get mapped view of %s, error code %d\n", file1, GetLastError() );
        UnmapViewOfFile( MappedAddr1 );
        CloseHandle( hFile1 );
        return FALSE;
    }

    CloseHandle( hMappedFile2);

    if ( fIgnoreRs & IsNTImage)
    {
        if ( ( (PIMAGE_DOS_HEADER)MappedAddr2)->e_magic == IMAGE_DOS_SIGNATURE)
        {
            try
            {
                NtHeader2 = (PIMAGE_NT_HEADERS32)( (PCHAR)MappedAddr2 + ( (PIMAGE_DOS_HEADER)MappedAddr2)->e_lfanew);

                if ( NtHeader2->Signature == IMAGE_NT_SIGNATURE)
                {
                    IsNTImage = IsNTImage & TRUE;
                }
            }
            except( EXCEPTION_EXECUTE_HANDLER ) {}
        }
    }

    //
    //  Main compare block
    //

    if ( fIgnoreRs)
    {
        if ( IsNTImage)
        {
            try
            {
                ULONG i, c;
                ULONG DirectoryAddressA;
                ULONG DirectoryAddressB;
                ULONG DirectoryAddressD;
                ULONG DirectoryAddressE;
                ULONG DirectoryAddressI;
                ULONG DirectoryAddressR;
                ULONG SizetoEndofFile1 = 0;
                ULONG SizetoResource1  = 0;
                ULONG SizeZeroedOut1   = 0;
                ULONG SizetoEndofFile2 = 0;
                ULONG SizetoResource2  = 0;
                ULONG SizeZeroedOut2   = 0;

                PIMAGE_SECTION_HEADER NtSection;
                PIMAGE_DEBUG_DIRECTORY Debug;
                PIMAGE_EXPORT_DIRECTORY Export;

                BOOL DeleteHeader, AfterResource;

                //
                // Set up virtual addresses of sections of interest
                //

                DirectoryAddressA = NtHeader1->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT].VirtualAddress;

                DirectoryAddressB = NtHeader1->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].VirtualAddress;

                DirectoryAddressD = NtHeader1->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].VirtualAddress;

                DirectoryAddressI = NtHeader1->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;

                DirectoryAddressE = NtHeader1->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;

                DirectoryAddressR = NtHeader1->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].VirtualAddress;

                //
                //  Zero out Binding Info
                //

                if ( ( DirectoryAddressB < NtHeader1->OptionalHeader.SizeOfHeaders) && ( 0 < DirectoryAddressB))
                {
                    //  fprintf( stdout, "ZeroMemoryBa %lx\n", DirectoryAddressB );

                    ZeroMemory( (PVOID)( (ULONG_PTR)MappedAddr1 + DirectoryAddressB) ,
                                NtHeader1->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].Size);
                }

                NtSection = (PIMAGE_SECTION_HEADER)(
                                                    (ULONG_PTR)NtHeader1 +
                                                    sizeof( ULONG) +
                                                    sizeof( IMAGE_FILE_HEADER) +
                                                    NtHeader1->FileHeader.SizeOfOptionalHeader
                                                   );


                AfterResource = FALSE; // Initialize

                //
                // Loop through file1 mapping zeroing out ignore sections
                //

                for ( i=0; i<NtHeader1->FileHeader.NumberOfSections; i++)
                {
                    DeleteHeader = FALSE; // Initialize

                    //
                    // Deal with IAT
                    //

                    if ( DirectoryAddressA >= NtSection->VirtualAddress &&
                         DirectoryAddressA < NtSection->VirtualAddress + NtSection->SizeOfRawData)
                    {
                        // fprintf ( stdout, "ZeroMemoryA1 start %lx and length %lx\n", ( ( DirectoryAddressA - NtSection->VirtualAddress) + NtSection->PointerToRawData),
                        //           NtHeader1->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT].Size);

                        ZeroMemory( (PVOID)( (ULONG_PTR)MappedAddr1 + ( DirectoryAddressA - NtSection->VirtualAddress) + NtSection->PointerToRawData),
                                    NtHeader1->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT].Size);

                        DeleteHeader = TRUE;
                    }

                    //
                    // Deal with Import
                    //

                    if ( DirectoryAddressI >= NtSection->VirtualAddress &&
                         DirectoryAddressI < NtSection->VirtualAddress + NtSection->SizeOfRawData)
                    {
                        // fprintf ( stdout, "ZeroMemoryI1 start %lx and length %lx\n", ( ( DirectoryAddressI - NtSection->VirtualAddress) + NtSection->PointerToRawData),
                        //           NtHeader1->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Size);

                        ZeroMemory( (PVOID)( (ULONG_PTR)MappedAddr1 + ( DirectoryAddressI - NtSection->VirtualAddress) + NtSection->PointerToRawData),
                                   NtHeader1->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Size);

                        DeleteHeader = TRUE;
                    }

                    //
                    // Deal with Export
                    //

                    if ( DirectoryAddressE >= NtSection->VirtualAddress &&
                         DirectoryAddressE < NtSection->VirtualAddress + NtSection->SizeOfRawData)
                    {
                        ULONG NumberOfExportDirectories;

                        NumberOfExportDirectories = NtHeader1->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size / sizeof( IMAGE_EXPORT_DIRECTORY );

                        Export = (PIMAGE_EXPORT_DIRECTORY)( (ULONG_PTR)MappedAddr1 + ( DirectoryAddressE - NtSection->VirtualAddress) + NtSection->PointerToRawData);

                        for ( c=0; c<NumberOfExportDirectories; c++)
                        {
                            // fprintf ( stdout, "ZeroMemoryE1 start %lx and length %lx\n", ( ( DirectoryAddressE - NtSection->VirtualAddress) + NtSection->PointerToRawData),
                            //           NtHeader1->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size);

                            Export->TimeDateStamp = 0;

                            Export++;
                        }
                    }

                    //
                    // Deal with Debug
                    //

                    if ( DirectoryAddressD >= NtSection->VirtualAddress &&
                         DirectoryAddressD < NtSection->VirtualAddress + NtSection->SizeOfRawData)
                    {
                        DWORD TimeDate;
                        ULONG NumberOfDebugDirectories;

                        NumberOfDebugDirectories = NtHeader1->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].Size / sizeof( IMAGE_DEBUG_DIRECTORY );

                        Debug = (PIMAGE_DEBUG_DIRECTORY)( (ULONG_PTR)MappedAddr1 + ( DirectoryAddressD - NtSection->VirtualAddress) + NtSection->PointerToRawData);

                        for ( c=0; c<NumberOfDebugDirectories; c++)
                        {
                            // fprintf ( stdout, "ZeroMemoryD1 start %lx and length %lx\n", ( ( DirectoryAddressD - NtSection->VirtualAddress) + NtSection->PointerToRawData),
                            //           NtHeader1->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].Size);

                            if (Debug->PointerToRawData && Debug->SizeOfData)
                            {
                                ZeroMemory((PVOID)((ULONG_PTR)MappedAddr1 + Debug->PointerToRawData),
                                           Debug->SizeOfData);
                            }

                            Debug->PointerToRawData = 0;
                            if (c == 0)
                            {
                                TimeDate = Debug->TimeDateStamp;
                            }
                            Debug->TimeDateStamp = 0;

                            Debug++;
                        }
                        while ( Debug->TimeDateStamp == TimeDate)
                        {
                            Debug->TimeDateStamp = 0;
                            Debug++;
                        }
                    }

                    //
                    // Deal with Resource
                    //

                    if ( DirectoryAddressR >= NtSection->VirtualAddress &&
                         DirectoryAddressR < NtSection->VirtualAddress + NtSection->SizeOfRawData)
                    {
                        SizetoResource1 = ( ( DirectoryAddressR - NtSection->VirtualAddress) + NtSection->PointerToRawData);
                        SizeZeroedOut1 = NtSection->SizeOfRawData;

                        // fprintf ( stdout, "ZeroMemoryR1 start %lx and length %lx\n", SizetoResource1,
                        //           SizeZeroedOut1);

                        ZeroMemory( (PVOID)( (ULONG_PTR)MappedAddr1 + SizetoResource1),
                                    SizeZeroedOut1);

                        DeleteHeader = TRUE;
                        AfterResource = TRUE;
                    }

                    //
                    // Deal with Header
                    //

                    if ( DeleteHeader || AfterResource)
                    {
                        // fprintf ( stdout, "ZeroMemoryH1 start %lx and length %lx\n", (PUCHAR)NtSection - (PUCHAR)MappedAddr1, sizeof( IMAGE_SECTION_HEADER));

                        ZeroMemory( NtSection, sizeof( IMAGE_SECTION_HEADER));
                    }
                    ++NtSection;

                }

                //
                // Set up virtual addresses of sections of interest
                //

                DirectoryAddressA = NtHeader2->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT].VirtualAddress;

                DirectoryAddressB = NtHeader2->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].VirtualAddress;

                DirectoryAddressI = NtHeader2->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;

                DirectoryAddressE = NtHeader2->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;

                DirectoryAddressD = NtHeader2->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].VirtualAddress;

                DirectoryAddressR = NtHeader2->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].VirtualAddress;



                NtSection = (PIMAGE_SECTION_HEADER)(
                                                    (ULONG_PTR)NtHeader2 +
                                                    sizeof( ULONG) +
                                                    sizeof( IMAGE_FILE_HEADER) +
                                                    NtHeader2->FileHeader.SizeOfOptionalHeader
                                                   );

                //
                //  Zero out Binding Info
                //

                if ( ( DirectoryAddressB < NtHeader2->OptionalHeader.SizeOfHeaders) && ( 0 < DirectoryAddressB))
                {
                    // fprintf( stdout, "ZeroMemoryBb %lx\n", DirectoryAddressB );

                    ZeroMemory( (PVOID)( (ULONG_PTR)MappedAddr2 + DirectoryAddressB) ,
                                NtHeader2->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].Size);
                }

                AfterResource = FALSE; //Initialize

                //
                // Loop through file2 mapping zeroing out ignore sections
                //

                for ( i=0; i<NtHeader2->FileHeader.NumberOfSections; i++)
                {
                    DeleteHeader = FALSE; // Initialize

                    //
                    // Deal with IAT
                    //

                    if ( DirectoryAddressA >= NtSection->VirtualAddress &&
                         DirectoryAddressA < NtSection->VirtualAddress + NtSection->SizeOfRawData)
                    {
                        // fprintf ( stdout, "ZeroMemoryA2 start %lx and length %lx\n", ( ( DirectoryAddressA - NtSection->VirtualAddress) + NtSection->PointerToRawData),
                        //           NtHeader2->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT].Size);

                        ZeroMemory( (PVOID)( (ULONG_PTR)MappedAddr2 + ( DirectoryAddressA - NtSection->VirtualAddress) + NtSection->PointerToRawData),
                                    NtHeader2->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT].Size);

                        DeleteHeader = TRUE;
                    }

                    //
                    // Deal with Import
                    //

                    if ( DirectoryAddressI >= NtSection->VirtualAddress &&
                         DirectoryAddressI < NtSection->VirtualAddress + NtSection->SizeOfRawData)
                    {
                        // fprintf ( stdout, "ZeroMemoryI2 start %lx and length %lx\n", ( ( DirectoryAddressI - NtSection->VirtualAddress) + NtSection->PointerToRawData),
                        //           NtHeader2->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Size);

                        ZeroMemory( (PVOID)( (ULONG_PTR)MappedAddr2 + ( DirectoryAddressI - NtSection->VirtualAddress) + NtSection->PointerToRawData),
                                   NtHeader2->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Size);

                        DeleteHeader = TRUE;
                    }

                    //
                    // Deal with Export
                    //

                    if ( DirectoryAddressE >= NtSection->VirtualAddress &&
                         DirectoryAddressE < NtSection->VirtualAddress + NtSection->SizeOfRawData)
                    {
                        ULONG NumberOfExportDirectories;

                        NumberOfExportDirectories = NtHeader2->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size / sizeof( IMAGE_EXPORT_DIRECTORY );

                        Export = (PIMAGE_EXPORT_DIRECTORY)( (ULONG_PTR)MappedAddr2 + ( DirectoryAddressE - NtSection->VirtualAddress) + NtSection->PointerToRawData);

                        for ( c=0; c<NumberOfExportDirectories; c++)
                        {
                            // fprintf ( stdout, "ZeroMemoryE2 start %lx and length %lx\n", ( ( DirectoryAddressE - NtSection->VirtualAddress) + NtSection->PointerToRawData),
                            //           NtHeader2->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size);

                            Export->TimeDateStamp = 0;

                            Export++;
                        }
                    }

                    //
                    // Deal with Debug
                    //

                    if ( DirectoryAddressD >= NtSection->VirtualAddress &&
                         DirectoryAddressD < NtSection->VirtualAddress + NtSection->SizeOfRawData)
                    {
                        DWORD TimeDate;
                        ULONG NumberOfDebugDirectories;

                        NumberOfDebugDirectories = NtHeader2->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].Size / sizeof( IMAGE_DEBUG_DIRECTORY );

                        Debug = (PIMAGE_DEBUG_DIRECTORY)( (ULONG_PTR)MappedAddr2 + ( DirectoryAddressD - NtSection->VirtualAddress) + NtSection->PointerToRawData);

                        for ( c=0; c<NumberOfDebugDirectories; c++)
                        {
                            // fprintf ( stdout, "ZeroMemoryD2 start %lx and length %lx\n", ( ( DirectoryAddressD - NtSection->VirtualAddress) + NtSection->PointerToRawData),
                            //           NtHeader2->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].Size);

                            if (Debug->PointerToRawData && Debug->SizeOfData)
                            {
                                ZeroMemory((PVOID)((ULONG_PTR)MappedAddr2 + Debug->PointerToRawData),
                                           Debug->SizeOfData);
                            }

                            Debug->PointerToRawData = 0;
                            if (c == 0)
                            {
                                TimeDate = Debug->TimeDateStamp;
                            }
                            Debug->TimeDateStamp = 0;

                            Debug++;
                        }
                        while ( Debug->TimeDateStamp == TimeDate)
                        {
                            Debug->TimeDateStamp = 0;
                            Debug++;
                        }
                    }

                    //
                    // Deal with Resource
                    //

                    if ( DirectoryAddressR >= NtSection->VirtualAddress &&
                         DirectoryAddressR < NtSection->VirtualAddress + NtSection->SizeOfRawData)
                    {
                        SizetoResource2 = ( ( DirectoryAddressR - NtSection->VirtualAddress) + NtSection->PointerToRawData);
                        SizeZeroedOut2 = NtSection->SizeOfRawData;

                        // fprintf ( stdout, "ZeroMemoryR2 start %lx and length %lx\n", SizetoResource2,
                        //           SizeZeroedOut2);

                        ZeroMemory( (PVOID)( (ULONG_PTR)MappedAddr2 + SizetoResource2),
                                    SizeZeroedOut2);

                        DeleteHeader = TRUE;
                        AfterResource = TRUE;
                    }

                    //
                    // Deal with Header
                    //

                    if ( DeleteHeader || AfterResource)
                    {
                        // fprintf( stdout, "ZeroMemoryH2 start %lx and length %lx\n", (PUCHAR)NtSection - (PUCHAR)MappedAddr2, sizeof( IMAGE_SECTION_HEADER));

                        ZeroMemory( NtSection, sizeof( IMAGE_SECTION_HEADER));
                    }
                    ++NtSection;
                }

                //
                //  Zero out header info
                //

                NtHeader1->FileHeader.TimeDateStamp = 0;

                NtHeader2->FileHeader.TimeDateStamp = 0;

                NtHeader1->OptionalHeader.CheckSum = 0;

                NtHeader2->OptionalHeader.CheckSum = 0;

                NtHeader1->OptionalHeader.SizeOfInitializedData = 0;

                NtHeader2->OptionalHeader.SizeOfInitializedData = 0;

                NtHeader1->OptionalHeader.SizeOfImage = 0;

                NtHeader2->OptionalHeader.SizeOfImage = 0;

                NtHeader1->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].Size = 0;

                NtHeader2->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].Size = 0;

                NtHeader1->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].Size = 0;

                NtHeader2->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].Size = 0;

                NtHeader1->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].VirtualAddress = 0;

                NtHeader2->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].VirtualAddress = 0;

                NtHeader1->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress = 0;

                NtHeader2->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress = 0;

                //
                // Do compares here
                //

                if ( SizetoResource1 == SizetoResource2)
                {
                    if ( memcmp( MappedAddr1, MappedAddr2, SizetoResource1) == 0)
                    {
                        SizetoEndofFile1 =  GetFileSize( hFile1, NULL) - ( SizetoResource1 + SizeZeroedOut1);

                        SizetoEndofFile2 =  GetFileSize( hFile2, NULL) - ( SizetoResource2 + SizeZeroedOut2);

                        if ( SizetoEndofFile1 == SizetoEndofFile2)
                        {
                            if ( memcmp( (PVOID)( (ULONG_PTR)MappedAddr1 + SizetoResource1 + SizeZeroedOut1), (PVOID)( ( ULONG_PTR)MappedAddr2 + SizetoResource2 + SizeZeroedOut2), SizetoEndofFile1) == 0)
                            {
                                UnmapViewOfFile( MappedAddr1 );
                                UnmapViewOfFile( MappedAddr2 );
                                CloseHandle( hFile1 );
                                CloseHandle( hFile2 );
                                return TRUE;
                            }
                        }
                    }
                }
                UnmapViewOfFile( MappedAddr1 );
                UnmapViewOfFile( MappedAddr2 );
                CloseHandle( hFile1 );
                CloseHandle( hFile2 );
                return FALSE;
            }
            except( EXCEPTION_EXECUTE_HANDLER )
            {
                UnmapViewOfFile( MappedAddr1 );
                UnmapViewOfFile( MappedAddr2 );
                CloseHandle( hFile1 );
                CloseHandle( hFile2 );
                if ( !NoMapBinaryCompare( file1, file2))
                {
                    return FALSE;

                } else
                {
                    return TRUE;
                }
            }
        }
    }

    if ( GetFileSize( hFile1, NULL) == GetFileSize( hFile2, NULL) )
    {
        try
        {
            if ( memcmp( MappedAddr1, MappedAddr2, GetFileSize( hFile1, NULL)) == 0)
            {
                UnmapViewOfFile( MappedAddr1 );
                UnmapViewOfFile( MappedAddr2 );
                CloseHandle( hFile1 );
                CloseHandle( hFile2 );
                return TRUE;
            }
        }
        except( EXCEPTION_EXECUTE_HANDLER )
        {
            UnmapViewOfFile( MappedAddr1 );
            UnmapViewOfFile( MappedAddr2 );
            CloseHandle( hFile1 );
            CloseHandle( hFile2 );
            if ( !NoMapBinaryCompare( file1, file2))
            {
                return FALSE;

            } else
            {
                return TRUE;
            }
        }
    }

    UnmapViewOfFile( MappedAddr1 );
    UnmapViewOfFile( MappedAddr2 );
    CloseHandle( hFile1 );
    CloseHandle( hFile2 );
    return FALSE;

}

int Mymemcmp( const void *buf1, const void *buf2, size_t count )
{
    size_t memoffset = 0;
    int retval = FALSE;

    do
    {
        try
        {
            if ( memcmp( (PVOID)( (PCHAR)buf1 + memoffset), (PVOID)( (PCHAR)buf2 + memoffset), sizeof( size_t)) != 0)
            {
                fprintf( stdout, "Offset is %Lx ", memoffset);
                fprintf( stdout, "Contents are %Lx and %Lx\n", *( (PULONG)( (PCHAR)buf1 + memoffset)), *( (PULONG)( (PCHAR)buf2 + memoffset)) );

                retval = TRUE;
            }
        }

        except( EXCEPTION_EXECUTE_HANDLER )
        {
            fprintf( stdout, "Memory not allocated\n");

        }

    }  while ( ( memoffset = memoffset + sizeof( size_t)) < count);

    return retval;

}

//
// CompDir turns Path1 and Path2 into:
//
//   AddList - Files that exist in Path1 but not in Path2
//
//   DelList - Files that do not exist in Path1 but exist in Path2
//
//   DifList - Files that are different between Path1 and Path2 based
//             on criteria provided by flags passed to CompDir
//
//   It then passes these lists to CompLists and processes the result.
//

void CompDir( char *Path1, char *Path2)
{
    LinkedFileList   AddList, DelList, DifList;
    struct CFLStruct Parameter1, Parameter2;

    DWORD            Id;
    HANDLE           Threads[2];

    DWORD CFReturn;

    AddList  = NULL;  //
    DelList  = NULL;  //  Start with empty lists
    DifList  = NULL;  //

    Parameter1.List = &AddList;
    Parameter1.Path = Path1;

    if ( fMultiThread)
    {
        Threads[0] = CreateThread(
                                  NULL,
                                  0,
                                  CreateFileList,
                                  &Parameter1,
                                  0,
                                  &Id
                                 );

        if ( Threads[0] == NULL)
        {
            fprintf( stderr, "CreateThread1Failed, error code %d\n", GetLastError() );
            CreateFileList( &Parameter1);
            fMultiThread = FALSE;
        }

    } else
    {
        CreateFileList( &Parameter1);
    }

    Parameter2.List = &DelList;
    Parameter2.Path = Path2;

    if ( fMultiThread)
    {
        Threads[1] = CreateThread(
                                  NULL,
                                  0,
                                  CreateFileList,
                                  &Parameter2,
                                  0,
                                  &Id
                                 );
        if ( Threads[1] == NULL)
        {
            fprintf( stderr, "CreateThread2Failed, error code %d\n", GetLastError() );
            CFReturn = CreateFileList( &Parameter2);
            fMultiThread = FALSE;
        }

    } else
    {
        CFReturn = CreateFileList( &Parameter2);
    }


    if ( fMultiThread)
    {
        Id = WaitForMultipleObjects(
                                    2,
                                    Threads,
                                    TRUE,
                                    (DWORD)-1
                                   );

        GetExitCodeThread( Threads[1], &CFReturn);

        CloseHandle( Threads[0]);
        CloseHandle( Threads[1]);
    }

    if ( CFReturn == 0)
    {
        CompLists( &AddList, &DelList, &DifList, Path1, Path2);

        ProcessLists( AddList, DelList, DifList, Path1, Path2);
    }

    FreeList( &DifList);
    FreeList( &DelList);
    FreeList( &AddList);

} // CompDir

BOOL FilesDiffer( LinkedFileList File1, LinkedFileList File2, char *Path1, char *Path2)
{

    DWORD High1, High2, Low1, Low2;     // Used in comparing times
    BOOL Differ = FALSE;
    char *FullPath1, *FullPath2;

    //
    // Check if same name is a directory under Path1
    // and a file under Path2 or vice-versa
    //

    if (
        ( (*File1).Attributes & FILE_ATTRIBUTE_DIRECTORY)
                                ||
        ( (*File2).Attributes & FILE_ATTRIBUTE_DIRECTORY)
       )
    {
        if ( ( (*File1).Attributes & FILE_ATTRIBUTE_DIRECTORY) && ( (*File2).Attributes & FILE_ATTRIBUTE_DIRECTORY))
        {
            if ( !fDoNotRecurse)
            {
                //
                // Create Full Path Strings
                //
                _strrev( (*File1).Name);
                _strrev( (*File2).Name);

                if ( DealingWithDirectories)
                {
                    ( Path1[strlen( Path1) - 1] == '\\') ? ( FullPath1 = MYSTRCAT( Path1, (*File1).Name)) :
                        ( FullPath1 = COMBINETHREESTRINGS( Path1, "\\", (*File1).Name));

                    ( Path2[strlen( Path2) - 1] == '\\') ? ( FullPath2 = MYSTRCAT( Path2, (*File1).Name)) :
                        ( FullPath2 = COMBINETHREESTRINGS( Path2, "\\", (*File1).Name));
                } else
                {
                    FullPath1 = MYSTRCAT( Path1, "");

                    FullPath2 = MYSTRCAT( Path2, "");
                }

                _strrev( (*File1).Name);
                _strrev( (*File2).Name);

                CompDir( FullPath1, FullPath2);

                FREE( FullPath1);
                FREE( FullPath2);
            }

        } else
        {
            if( ! ( (*File1).Attributes & FILE_ATTRIBUTE_DIRECTORY))
            {
                strcat( (*File1).Flag, "@");

            } else
            {
                strcat( (*File2).Flag, "@");
            }
            Differ = TRUE;
        }

    } else
    {
        if ( fCheckTime)
        {
            if ( Granularity)
            {
                //
                // Bit manipulation to deal with large integers.
                //

                High1 = (*File1).Time.dwHighDateTime>>23;
                High2 = (*File2).Time.dwHighDateTime>>23;
                if ( High1 == High2)
                {
                    Low1 = ( (*File1).Time.dwHighDateTime<<9) |
                           ( (*File1).Time.dwLowDateTime>>23);
                    Low2 = ( (*File2).Time.dwHighDateTime<<9) |
                           ( (*File2).Time.dwLowDateTime>>23);
                    if ( ( ( Low1 > Low2) ? ( Low1 - Low2) : ( Low2 - Low1))
                                                          > Granularity)
                    {
                       strcat( (*File1).Flag, "T");
                       Differ = TRUE;
                    }
                 } else
                 {
                     Differ = TRUE;
                 }

            } else if ( CompareFileTime( &( (*File1).Time),
                     &( (*File2).Time)) != 0)
            {
                strcat( (*File1).Flag, "T");
                Differ = TRUE;
            }
        }

        if ( fCheckSize &&
             (
              ( (*File1).SizeLow != (*File2).SizeLow)
                             ||
              ( (*File1).SizeHigh != (*File2).SizeHigh)
             )
           )
        {
            strcat( (*File1).Flag, "S");
            Differ = TRUE;
        }

        if ( fCheckAttribs)
        {
            if ( ((*File1).Attributes ^ (*File2).Attributes) & NORMAL_ATTRIBUTES)
            {
                strcat( (*File1).Flag, "A");
                Differ = TRUE;
            }
        }

        if ( fCheckBits)
        {
            //
            // Create Full Path Strings
            //
            _strrev( (*File1).Name);
            _strrev( (*File2).Name);

            if ( DealingWithDirectories)
            {
                ( Path1[strlen( Path1) - 1] == '\\') ? ( FullPath1 = MYSTRCAT( Path1, (*File1).Name)) :
                    ( FullPath1 = COMBINETHREESTRINGS( Path1, "\\", (*File1).Name));

                ( Path2[strlen( Path2) - 1] == '\\') ? ( FullPath2 = MYSTRCAT( Path2, (*File1).Name)) :
                    ( FullPath2 = COMBINETHREESTRINGS( Path2, "\\", (*File1).Name));
            } else
            {
                FullPath1 = MYSTRCAT( Path1, "");

                FullPath2 = MYSTRCAT( Path2, "");
            }

            _strrev( (*File1).Name);
            _strrev( (*File2).Name);

            if ( fIgnoreRs)
            {
                if (
                    (
                     (*File1).SizeLow != 0
                              ||
                     (*File1).SizeHigh != 0)
                              &&
                     ( !BinaryCompare( FullPath1, FullPath2)
                    )
                   )
                {
                    strcat( (*File1).Flag, "B");
                    Differ = TRUE;
                }

            } else
            {
                if (
                    ( (*File1).SizeLow   != (*File2).SizeLow)
                                    ||
                    ( (*File1).SizeHigh  != (*File2).SizeHigh)
                                    ||
                    (
                     (
                      (*File1).SizeLow != 0
                                ||
                      (*File1).SizeHigh != 0
                     )
                                    &&
                     ( !BinaryCompare( FullPath1, FullPath2))
                    )
                   )
                {
                    strcat( (*File1).Flag, "B");
                    Differ = TRUE;
                }
            }

            FREE( FullPath1);
            FREE( FullPath2);
        }

        if ( fForce)
        {
            Differ = TRUE;
        }
    }

    return Differ;

} // FilesDiffer

//
// CompLists Does the dirty work for CompDir
//
void CompLists( LinkedFileList *AddList, LinkedFileList *DelList, LinkedFileList *DifList, char *Path1, char *Path2)
{
    LinkedFileList *TmpAdd, *TmpDel, TmpNode;
    char *FullPath1, *FullPath2;

    if ( ( DelList == NULL) || ( *DelList == NULL) || ( AddList == NULL) || ( *AddList == NULL))
    {
        return;
    }
    TmpAdd = AddList;   // pointer to keep track of position in addlist

    if ( *TmpAdd != NULL)
    {
        TmpAdd = &( **TmpAdd).First;
    }

    do
    {
        if ( DealingWithDirectories)
        {
            TmpDel = FindInList( ( **TmpAdd).Name, DelList);

        } else
        {
            TmpDel = DelList;
        }
        if ( TmpDel != NULL)
        {
            if ( FilesDiffer( *TmpAdd, *TmpDel, Path1, Path2))
            {
                //
                // Combine Both Nodes together so they
                // can be printed out together
                //
                DuplicateNode( *TmpAdd, &TmpNode);
                DuplicateNode( *TmpDel, &( *TmpNode).DiffNode);
                AddToList( TmpNode, DifList);
                ( **TmpDel).Process = FALSE;
                ( **TmpAdd).Process = FALSE;

            } else
            {
                ( **TmpDel).Process = FALSE;
                ( **TmpAdd).Process = !ProcessModeDefault;
            }

        } else if ( SparseTree && ( ( **TmpAdd).Attributes & FILE_ATTRIBUTE_DIRECTORY))
        {
            if ( !fDoNotRecurse)
            {
                _strrev( ( **TmpAdd).Name);

                ( Path1[strlen( Path1) - 1] == '\\') ? ( FullPath1 = MYSTRCAT( Path1, ( **TmpAdd).Name)) :
                    ( FullPath1 = COMBINETHREESTRINGS( Path1, "\\", ( **TmpAdd).Name));

                ( Path2[strlen( Path2) - 1] == '\\') ? ( FullPath2 = MYSTRCAT( Path2, ( **TmpAdd).Name)) :
                    ( FullPath2 = COMBINETHREESTRINGS( Path2, "\\", ( **TmpAdd).Name));

                _strrev( ( **TmpAdd).Name);

                CompDir( FullPath1, FullPath2);
            }

        } // if ( *TmpDel != NULL)

        TmpAdd = &( ( **TmpAdd).Next);

    } while ( *TmpAdd != NULL);

} // CompLists

//
// CopyNode walks the source node and its children ( recursively)
// and creats the appropriate parts on the destination node
//

void CopyNode ( char *Destination, LinkedFileList Source, char *FullPathSrc)
{
    BOOL pend, CanDetectFreeSpace = TRUE;
    int i;
    DWORD sizeround;
    DWORD BytesPerCluster;
    ATTRIBUTE_TYPE Attributes;

    int LastErrorGot;
    __int64 freespac;
    char root[5] = {*Destination,':','\\','\0'};
    DWORD cSecsPerClus, cBytesPerSec, cFreeClus, cTotalClus;

    if ( !GetDiskFreeSpace( root, &cSecsPerClus, &cBytesPerSec, &cFreeClus, &cTotalClus ) )
    {
        CanDetectFreeSpace = FALSE;

    } else
    {
        freespac = ( (__int64)cBytesPerSec * (__int64)cSecsPerClus * (__int64)cFreeClus );
        BytesPerCluster = cSecsPerClus * cBytesPerSec;
    }

    fprintf( stdout, "%s => %s\t", FullPathSrc, Destination);

    if ( CanDetectFreeSpace)
    {
        sizeround = (*Source).SizeLow;
        sizeround += BytesPerCluster - 1;
        sizeround /= BytesPerCluster;
        sizeround *= BytesPerCluster;

        if ( freespac < sizeround)
        {
            fprintf( stderr, "not enough space\n");
            return;
        }
    }

    GET_ATTRIBUTES( Destination, Attributes);
    i = SET_ATTRIBUTES( Destination, Attributes & NONREADONLYSYSTEMHIDDEN );

    i = 1;

    do
    {
        if ( !fCreateLink)
        {
            if ( !fBreakLinks)
            {
                pend = MyCopyFile( FullPathSrc, Destination, FALSE);

            } else
            {
                _unlink( Destination);
                pend = MyCopyFile( FullPathSrc, Destination, FALSE);
            }

        } else
        {
            if ( i == 1)
            {
                pend = MakeLink( FullPathSrc, Destination, FALSE);

            } else
            {
                pend = MakeLink( FullPathSrc, Destination, TRUE);
            }
        }

        if ( SparseTree && !pend)
        {
            if ( !MyCreatePath( Destination, FALSE))
            {
                fprintf( stderr, "Unable to create path %s", Destination);
                ExitValue = 1;
            }
        }

    } while ( ( i++ < 2) && ( !pend) );

    if ( !pend)
    {
        LastErrorGot = GetLastError ();

        if ( ( fCreateLink) && ( LastErrorGot == 1))
        {
            fprintf( stderr, "Can only make links on NTFS and OFS");

        } else if ( fCreateLink)
        {
            fprintf( stderr, "(error = %d)", LastErrorGot);

        } else
        {
            fprintf( stderr, "Copy Error (error = %d)", LastErrorGot);
        }

        ExitValue = 1;
    }

    if ( pend)
    {
        fprintf( stdout, "[OK]\n");

    } else
    {
        fprintf( stderr, "\n");
    }
    //
    // Copy attributes from Source to Destination
    //

    // GET_ATTRIBUTES( FullPathSrc, Attributes);
    if ( !fDontCopyAttribs)
    {
        i = SET_ATTRIBUTES( Destination, Source->Attributes);
    }
    else
    {
        i = SET_ATTRIBUTES( Destination, FILE_ATTRIBUTE_ARCHIVE);
    }

} // CopyNode

//
// CreateFileList walks down list adding files as they are found
//
DWORD CreateFileList( LPVOID ThreadParameter)
{
    PCFLStruct Parameter = ( PCFLStruct)ThreadParameter;
    LinkedFileList *List = Parameter->List;
    char *Path = Parameter->Path;
    LinkedFileList Node;
    char *String;
    ATTRIBUTE_TYPE Attributes;

    HANDLE handle;
    WIN32_FIND_DATA Buff;

    IF_GET_ATTR_FAILS( Path, Attributes)
    {
        return 0;
    }

    if ( Attributes & FILE_ATTRIBUTE_DIRECTORY)
    {
        ( Path[strlen( Path) - 1] != '\\') ? ( String = MYSTRCAT( Path,"\\*.*")) :
            ( String = MYSTRCAT( Path,"*.*"));

        handle = FIND_FIRST( String, Buff);

    } else
    {
        handle = FIND_FIRST( Path, Buff);
    }

    FREE( String);

    if ( handle != INVALID_HANDLE_VALUE)
    {
            //
            // Need to find the '.' or '..' directories and get them out of the way
            //

        do
        {
            if (
                ( strcmp( Buff.cFileName, ".")  != 0)
                                &&
                ( strcmp( Buff.cFileName, "..") != 0)
                                &&
                ( ((Buff.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0) ||
                  !fDoNotRecurse)
               )
            {
                //
                // If extensions are defined we match them here
                //
                if (
                    ( !Excludes )
                           ||
                    ( Excludes && ( !Excluded( Buff.cFileName, Path)) )
                   )
                {
                    if (
                        ( !Matches )
                              ||
                        ( ( Buff.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) )
                                          ||
                        ( Matches && ( Matched( Buff.cFileName, Path)) )
                       )
                    {
                        if ( !fIgnoreSlmFiles
                                    ||
                             (
                              (_stricmp( Buff.cFileName, "slm.ini") != 0)
                                               &&
                              (_stricmp( Buff.cFileName, "slm.dif") != 0)
                                               &&
                              (_stricmp( Buff.cFileName, "iedcache.slm.v6") != 0)
                             )
                           )
                        {

                            if ( fSpecAttribs)
                            {
                                if ( Buff.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                                {
                                    CreateNode( &Node, &Buff);
                                    AddToList( Node, List);

                                } else if ( NegativeCompareAttributeSet && CompareAttributeSet)
                                {
                                    if (
                                        !( Buff.dwFileAttributes & NegativeCompareAttribute)
                                                           &&
                                        ( ( Buff.dwFileAttributes & CompareAttribute) == CompareAttribute)
                                       )
                                    {
                                        CreateNode( &Node, &Buff);
                                        AddToList( Node, List);
                                    }

                                } else if ( CompareAttributeSet )
                                {
                                    if ( ( Buff.dwFileAttributes & CompareAttribute) == CompareAttribute)
                                    {

                                        CreateNode( &Node, &Buff);
                                        AddToList( Node, List);
                                    }

                                } else if ( NegativeCompareAttributeSet )
                                {
                                    if ( !( Buff.dwFileAttributes & NegativeCompareAttribute) )
                                    {
                                         CreateNode( &Node, &Buff);
                                         AddToList( Node, List);
                                    }
                                }

                            } else
                            {
                                CreateNode( &Node, &Buff);
                                AddToList( Node, List);
                            }
                        }
                    }
                }
            }
        } while ( FIND_NEXT( handle, Buff) == 0);

    } // ( handle != INVALID_HANDLE_VALUE)

    FindClose( handle);

    return 0;       // This will exit this thread

} // CreateFileList

BOOL DelNode ( char *Path)
{
    char *String;
    ATTRIBUTE_TYPE Attributes;

    HANDLE handle;
    WIN32_FIND_DATA Buff;

    IF_GET_ATTR_FAILS( Path, Attributes)
        return TRUE;

    if ( Attributes & FILE_ATTRIBUTE_DIRECTORY)
    {
        ( Path[strlen( Path) - 1] != '\\') ? ( String = MYSTRCAT( Path,"\\*.*")) :
             ( String = MYSTRCAT( Path,"*.*"));

        handle = FIND_FIRST( String, Buff);

        if ( handle == INVALID_HANDLE_VALUE)
        {
            fprintf( stderr, "%s is inaccesible\n", Path);
            ExitValue = 1;
            return FALSE;
        }

        FREE( String);

        do
        {
            //
            // Need to find the '.' or '..' directories and get them out of the way
            //

            if (
                ( strcmp( Buff.cFileName, ".")  != 0)
                              &&
                ( strcmp( Buff.cFileName, "..") != 0)
               )
            {
                //
                // if directory is read-only, make it writable
                //
                if ( Attributes & FILE_ATTRIBUTE_READONLY)
                {
                    if ( SET_ATTRIBUTES( Path, Attributes & ~FILE_ATTRIBUTE_READONLY) != 0)
                    {
                        break;
                    }
                }
                String = COMBINETHREESTRINGS( Path, "\\", Buff.cFileName);
                if ( !DelNode( String))
                {
                    FREE( String);
                    return FALSE;

                } else
                {
                    FREE( String);
                }
            }

        } while ( FIND_NEXT( handle, Buff) == 0);

        FindClose( handle);

        if ( _rmdir( Path) != 0)
        {
            return FALSE;
        }

    } else
    {
        //
        // if file is read-only, make it writable
        //
        if ( Attributes & FILE_ATTRIBUTE_READONLY)
        {
           if ( SET_ATTRIBUTES( Path, Attributes & ~FILE_ATTRIBUTE_READONLY) != 0)
           {
               return FALSE;
           }
        }

        if ( _unlink( Path) != 0)
        {
            return FALSE;
        }
    }
    return TRUE;

} // DelNode

BOOL IsFlag( char *argv)
{
    char String[MAX_PATH];
    char *String1, *String2;
    char *TmpArg;
    char *ExcludeFile, *MatchFile;
    FILE *FileHandle;
    LinkedFileList Node;
    BOOL NegationFlagSet = FALSE;


    if ( ( *argv == '/') || ( *argv == '-'))
    {
        fMatching = FALSE; // If there's a new flag then that's the
        fExclude  = FALSE; // end of the match/exclude list

        if ( strchr( argv, '?'))
        {
            Usage();
        }
        TmpArg = _strlwr( argv);

        while ( *++TmpArg != '\0')
        {
            switch ( *TmpArg)
            {
                case 'a' :
                    fCheckAttribs = !NegationFlagSet;
                    NegationFlagSet = FALSE;
                    break;

                case 'b' :
                    fCheckBits = !NegationFlagSet;
                    NegationFlagSet = FALSE;
                    break;

                case 'c' :
                    fScript = !NegationFlagSet;
                    NegationFlagSet = FALSE;
                    break;

                case 'd' :
                    fDoNotDelete = !NegationFlagSet;
                    NegationFlagSet = FALSE;
                    break;

                case 'e' :
                    fExecute = !NegationFlagSet;
                    NegationFlagSet = FALSE;
                    break;

                case 'f' :
                    fOnlyIfExists = !NegationFlagSet;
                    NegationFlagSet = FALSE;
                    break;

                case 'g' :
                    fIgnoreSlmFiles = !NegationFlagSet;
                    NegationFlagSet = FALSE;
                    break;

                case 'h' :
                    fDontCopyAttribs = !NegationFlagSet;
                    NegationFlagSet = FALSE;
                    break;

                case 'i' :
                    fIgnoreRs = !NegationFlagSet;

                    if ( fIgnoreRs) {
                        GetTempPath( MAX_PATH, String);

                        RebasedFile2 = RebasedFile;

                        GetTempFileName( String, NULL, 0, RebasedFile2);
                    }

                    NegationFlagSet = FALSE;
                    break;

                case 'k' :
                    fBreakLinks = !NegationFlagSet;
                    NegationFlagSet = FALSE;
                    break;

                case 'l' :
                    fCreateLink = !NegationFlagSet;
                    NegationFlagSet = FALSE;
                    break;

                case 'm' :

                    if ( NegationFlagSet) {
                        fprintf ( stderr, "can't use - on /m option\n");
                        Usage();
                    }

                    if (
                        ( *( TmpArg + 1) == ':')
                                &&
                        ( *( TmpArg + 2) != '\0')
                       )
                    {

                        ( MatchFile = TmpArg + 2);

                        while (isgraph( *( ++TmpArg + 1))) {}

                        if  ( ( FileHandle = fopen( MatchFile, "r")) == NULL)
                        {
                            fprintf( stderr, "cannot open %s\n", MatchFile);
                            Usage();

                        } else
                        {
                            while ( fgets( String1   = String, MAX_PATH, FileHandle) != NULL)
                            {
                                while ( *( String2 = &( String1[ strspn( String1, " \n\r") ])))
                                {
                                    if ( *( String1 = &( String2[ strcspn( String2, " \n\r") ])))
                                    {
                                         *String1++ = 0;
                                         CreateNameNode( &Node, String2);
                                         if ( strchr( String2, '*') != NULL)
                                         {
                                             AddToList( Node, &MStarList);

                                         } else
                                         {
                                             AddToList( Node, &MatchList);
                                         }
                                    }
                                }
                            }
                            fclose( FileHandle) ;
                        }
                    }
                    fMatching   = TRUE;
                    Matches     = TRUE;
                    break;

                case 'n' :
                    fCreateNew = !NegationFlagSet;
                    NegationFlagSet = FALSE;
                    break;

                case 'o' :
                    fOpposite = !NegationFlagSet;
                    ProcessModeDefault = !fOpposite;
                    NegationFlagSet = FALSE;
                    break;

                case 'p' :


                    if ( NegationFlagSet) {
                        fprintf ( stderr, "can't use - on /p option\n");
                        Usage();
                    }

                    if ( *( TmpArg + 1) != '{')
                    {
                        fprintf ( stderr, "/p option improperly formatted\n");
                        Usage();
                    }

                    TmpArg++;

                    while ( *++TmpArg != '}')
                    {
                        switch ( *TmpArg)
                        {
                            case 'a' :
                                if ( NegationFlagSet)
                                {
                                    if ( !NegativeCompareAttributeSet)
                                    {
                                        NegativeCompareAttribute = FILE_ATTRIBUTE_ARCHIVE;
                                        NegativeCompareAttributeSet = TRUE;

                                    } else
                                    {
                                        NegativeCompareAttribute = NegativeCompareAttribute | FILE_ATTRIBUTE_ARCHIVE;
                                    }

                                } else
                                {
                                    if ( !CompareAttributeSet)
                                    {
                                        CompareAttribute = FILE_ATTRIBUTE_ARCHIVE;
                                        CompareAttributeSet = TRUE;

                                    } else
                                    {
                                        CompareAttribute = CompareAttribute | FILE_ATTRIBUTE_ARCHIVE;
                                    }
                                }
                                NegationFlagSet = FALSE;
                                break;

                            case 'r' :
                                if ( NegationFlagSet)
                                {
                                    if ( !NegativeCompareAttributeSet)
                                    {
                                        NegativeCompareAttribute = FILE_ATTRIBUTE_READONLY;
                                        NegativeCompareAttributeSet = TRUE;

                                    }  else
                                    {
                                        NegativeCompareAttribute = NegativeCompareAttribute | FILE_ATTRIBUTE_READONLY;
                                    }

                                } else
                                {
                                    if ( !CompareAttributeSet)
                                    {
                                        CompareAttribute = FILE_ATTRIBUTE_READONLY;
                                        CompareAttributeSet = TRUE;

                                    } else
                                    {
                                        CompareAttribute = CompareAttribute | FILE_ATTRIBUTE_READONLY;
                                    }
                                }
                                NegationFlagSet = FALSE;
                                break;

                            case 'h' :
                                if ( NegationFlagSet)
                                {
                                    if ( !NegativeCompareAttributeSet)
                                    {
                                        NegativeCompareAttribute = FILE_ATTRIBUTE_HIDDEN;
                                        NegativeCompareAttributeSet = TRUE;

                                    } else
                                    {
                                        NegativeCompareAttribute = NegativeCompareAttribute | FILE_ATTRIBUTE_HIDDEN;
                                    }

                                } else
                                {
                                    if ( !CompareAttributeSet)
                                    {
                                        CompareAttribute = FILE_ATTRIBUTE_HIDDEN;
                                        CompareAttributeSet = TRUE;

                                    } else
                                    {
                                        CompareAttribute = CompareAttribute | FILE_ATTRIBUTE_HIDDEN;
                                    }
                                }
                                NegationFlagSet = FALSE;
                                break;

                            case 's' :
                                if ( NegationFlagSet)
                                {
                                    if ( !NegativeCompareAttributeSet)
                                    {
                                        NegativeCompareAttribute = FILE_ATTRIBUTE_SYSTEM;
                                        NegativeCompareAttributeSet = TRUE;

                                    } else
                                    {
                                        NegativeCompareAttribute = NegativeCompareAttribute | FILE_ATTRIBUTE_SYSTEM;
                                    }

                                } else
                                {
                                    if ( !CompareAttributeSet)
                                    {
                                        CompareAttribute = FILE_ATTRIBUTE_SYSTEM;
                                        CompareAttributeSet = TRUE;

                                    } else
                                    {
                                        CompareAttribute = CompareAttribute | FILE_ATTRIBUTE_SYSTEM;
                                    }
                                }
                                NegationFlagSet = FALSE;
                                break;

                            case '-' :
                               NegationFlagSet = TRUE;
                               break;

                            default  :
                               fprintf( stderr, "/p option improperly formatted\n");
                               Usage();
                        }

                    }

                    if ( !CompareAttributeSet && !NegativeCompareAttributeSet)
                    {
                        fprintf( stderr, "no compare attributes not set\n");
                        Usage();
                    }
                    fSpecAttribs = TRUE;
                    NegationFlagSet = FALSE;
                    break;

                case 'r' :
                    fDoNotRecurse = !NegationFlagSet;
                    NegationFlagSet = FALSE;
                    break;

                case 's' :
                    fCheckSize = !NegationFlagSet;
                    NegationFlagSet = FALSE;
                    break;

                case 't' :

                    //
                    // Get Granularity parameter
                    //

                    if (
                        ( *( TmpArg + 1) == ':')
                                  &&
                        ( *( TmpArg + 2) != '\0')
                       )
                    {

                        sscanf( ( TmpArg + 2), "%d", &Granularity);

                        Granularity = Granularity*78125/65536;
                           // Conversion to seconds ^^^^^^^
                           //         10^7/2^23

                        while (isdigit( *( ++TmpArg + 1))) {}
                    }
                    fCheckTime = !NegationFlagSet;
                    NegationFlagSet = FALSE;
                    break;

                case 'u' :
                    fMultiThread = !NegationFlagSet;
                    NegationFlagSet = FALSE;
                    break;

                case 'v' :
                    fVerbose = !NegationFlagSet;
                    NegationFlagSet = FALSE;
                    break;

                case 'w' :
                    fDontLowerCase = !NegationFlagSet;
                    NegationFlagSet = FALSE;
                    break;

                case 'x' :
                    if ( NegationFlagSet) {
                        fprintf ( stderr, "can't use - on /x option\n");
                        Usage();
                    }

                    if (
                        ( *( TmpArg + 1) == ':')
                                &&
                        ( *( TmpArg + 2) != '\0')
                       )
                    {
                        ( ExcludeFile = TmpArg + 2);

                        while (isgraph( *( ++TmpArg + 1))) {}

                        if ( ( FileHandle = fopen( ExcludeFile, "r")) == NULL)
                        {
                            fprintf( stderr, "cannot open %s\n", ExcludeFile);
                            Usage();

                        } else
                        {
                            while ( fgets( String1   = String, MAX_PATH, FileHandle) != NULL)
                            {
                                 while ( *( String2 = &( String1[ strspn( String1, "\n\r") ])))
                                 {
                                     if ( *( String1 = &( String2[ strcspn ( String2, "\n\r") ])))
                                     {
                                         *String1++ = 0;
                                         CreateNameNode( &Node, String2);
                                         if ( strchr( String2, '*') != NULL)
                                         {
                                             AddToList( Node, &EStarList);

                                         } else
                                         {
                                             AddToList( Node, &ExcludeList);
                                         }
                                     }
                                 }
                            }
                            fclose( FileHandle) ;
                        }
                    }

                    fExclude    = TRUE;
                    Excludes    = TRUE;
                    break;

        case 'z' :
            fForce = !NegationFlagSet;
                    NegationFlagSet = FALSE;
                    break;

        case '$' :
            fTrySis = !NegationFlagSet;
            NegationFlagSet = FALSE;
                    break;

                case '/' :
                    NegationFlagSet = FALSE;
                    break;

                case '-' :
                    NegationFlagSet = TRUE;
                    break;

                default :
                    fprintf( stderr, "Don't know flag(s) %s\n", argv);
                    Usage();
            }
        }

    } else
    {
        return FALSE;
    }

    return TRUE;

} // IsFlag

BOOL Excluded( char *FileName, char *Path)
{
    char *PathPlusName;

    PathPlusName = COMBINETHREESTRINGS( Path, "\\", FileName);

    if (
         ( FindInMatchListTop( FileName, &ExcludeList))
                               ||
         ( FindInMatchListTop( PathPlusName, &ExcludeList))
                               ||
         ( FindInMatchListFront( FileName, &EStarList))
                               ||
         ( FindInMatchListFront( PathPlusName, &EStarList))

       )
    {
        FREE( PathPlusName);
        return TRUE;

    } else
    {
        FREE( PathPlusName);
        return FALSE;
    }

} // Excluded

BOOL Matched( char *FileName, char *Path)
{
    char *PathPlusName;

    PathPlusName = COMBINETHREESTRINGS( Path, "\\", FileName);

    if (
         ( FindInMatchListTop( FileName, &MatchList))
                               ||
         ( FindInMatchListTop( PathPlusName, &MatchList))
                               ||
         ( FindInMatchListFront( FileName, &MStarList))
                               ||
         ( FindInMatchListFront( PathPlusName, &MStarList))
       )
    {
        FREE( PathPlusName);
        return TRUE;

    } else
    {
        FREE( PathPlusName);
        return FALSE;
    }

} // Matched

BOOL MyCreatePath( char *Path, BOOL IsDirectory)
{
    char *ShorterPath, *LastSlash;

    ATTRIBUTE_TYPE Attributes;

    IF_GET_ATTR_FAILS( Path, Attributes)
    {
        if ( !IsDirectory || ( ( _mkdir( Path)) != 0) )
        {
            ShorterPath = MYSTRCAT( Path, "");

            LastSlash = strrchr( ShorterPath, '\\');

            if (
                ( LastSlash != NULL)
                        &&
                ( LastSlash != strchr( ShorterPath, '\\'))
               )
            {
                *LastSlash = '\0';

            } else
            {
                FREE( ShorterPath);
                return FALSE;
            }

            if ( MyCreatePath( ShorterPath, TRUE))
            {
                FREE( ShorterPath);

                if ( IsDirectory)
                {
                    return( ( _mkdir( Path)) == 0);

                } else
                {
                    return TRUE;
                }

            } else
            {
                _rmdir( ShorterPath);
                FREE( ShorterPath);
                return FALSE;
            }

        } else
        {
            return TRUE;
        }

    } else
    {
        return TRUE;
    }

} // MyCreatePath


BOOL
MyCopyFile(
    LPCSTR lpExistingFileName,
    LPCSTR lpNewFileName,
    BOOL bFailIfExists
    )
{
    BOOL ok;

    if (fTrySis) {
        ok = SisCopyFile( lpExistingFileName, lpNewFileName, bFailIfExists, &fTrySis);
        if (ok) {
            return TRUE;
        }
    }

    return CopyFile( lpExistingFileName, lpNewFileName, bFailIfExists);
}

int ParseArgsSub( int argc, char *argv[])
{
    int ArgCount, FlagCount;

    LinkedFileList Node;

    ArgCount  = 1;
    FlagCount = 0;

    fMatching = FALSE;
    fExclude = FALSE;

    do
    {
        if ( IsFlag( argv[ArgCount] ))
        {
            FlagCount++;

        } else // ( IsFlag( argv[ArgCount] ))
        {
            if ( ArgCount + 2 < argc)
            {
                if ( fMatching)
                {
                    CreateNameNode( &Node, argv[ArgCount]);
                    if ( strchr( argv[ArgCount], '*') != NULL)
                    {
                        AddToList( Node, &MStarList);

                    } else
                    {
                        AddToList( Node, &MatchList);
                    }
                }
                if ( fExclude)
                {
                    CreateNameNode( &Node, argv[ArgCount]);
                    if ( strchr( argv[ArgCount], '*') != NULL)
                    {
                        AddToList( Node, &EStarList);

                    } else
                    {
                        AddToList( Node, &ExcludeList);
                    }
                }
                if ( ( !fMatching) && ( !fExclude))
                {
                    fprintf( stderr, "Don't know option %s\n", argv[ArgCount]);
                    Usage();
                }
            }
        }
    } while ( ArgCount++ < argc - 1);

    return FlagCount;

} // ParseArgsSub

void ParseEnvArgs( void)
{
    int argc;
    char *argv[128];
    char env[MAX_PATH+2];
    char *p;

    int ArgCount, FlagCount;

    LinkedFileList Node;

    if ( !GetEnvironmentVariable( "COMPDIRCMD", env, MAX_PATH+2)) {
        return;
    }

    argc = 1;
    p = env;
    while ( (*p != 0) && isspace(*p)) {
        p++;
    }
    while ( *p) {
        argv[argc++] = p++;
        while ( (*p != 0) && !isspace(*p)) {
            p++;
        }
        if ( *p != 0) {
            *p++ = 0;
            while ( (*p != 0) && isspace(*p)) {
                p++;
            }
        }
    }

    ParseArgsSub( argc, argv);

} // ParseEnvArgs

void ParseArgs( int argc, char *argv[])
{
    int FlagCount;

    //
    // Check that number of arguments is three or more
    //
    if ( argc < 3)
    {
        fprintf( stderr, "Too few arguments\n");
        Usage();
    }

    FlagCount = ParseArgsSub( argc, argv);

    if ( ( fScript) && ( fVerbose))
    {
        fprintf( stderr, "Cannot do both script and verbose\n");
        Usage();
    }
    if ( ( fVerbose) && ( fExecute))
    {
        fprintf( stderr, "Cannot do both verbose and execute\n");
        Usage();
    }
    if ( ( fScript) && ( fExecute))
    {
        fprintf( stderr, "Cannot do both script and execute\n");
        Usage();
    }
    if ( ( fExclude) && ( fMatching))
    {
        fprintf( stderr, "Cannot do both match and exclude\n");
        Usage();
    }

    if ( ( fCreateNew) && ( !fExecute))
    {
        fprintf( stderr, "Cannot create new without execute\n");
        Usage();
    }
    if ( ( fCreateLink) && ( !fExecute))
    {
        fprintf( stderr, "Cannot do link without execute flag\n");
        Usage();
    }
    if ( ( fForce) && ( !fExecute))
    {
        fprintf( stderr, "Cannot do force without execute flag\n");
        Usage();
    }
    if ( ( fIgnoreRs) && ( !fCheckBits))
    {
        fprintf( stderr, "Cannot ignore rebase info w/o b flag\n");
        Usage();
    }
    if ( ( fBreakLinks) && ( !fExecute))
    {
        fprintf( stderr, "Cannot break links without execute flag\n");
        Usage();
    }
    if ( ( argc - FlagCount) <  3)
    {
        fprintf( stderr, "Too few arguments\n");
        Usage();
    }

    fChecking = fCheckAttribs | fCheckBits | fCheckSize | fCheckTime;

} // ParseArgs

void PrintFile( LinkedFileList File, char *Path, char *DiffPath)
{
    SYSTEMTIME SysTime;
    FILETIME LocalTime;

    if ( File != NULL)
    {
        if ( fVerbose)
        {
            FileTimeToLocalFileTime( &( *File).Time, &LocalTime);
            FileTimeToSystemTime( &LocalTime, &SysTime);

            fprintf ( stdout, "%-4s % 9ld  %2d-%02d-%d  %2d:%02d.%02d.%03d%c %s\n",
                      ( *File).Flag,
                      ( *File).SizeLow,
                      SysTime.wMonth, SysTime.wDay, SysTime.wYear,
                      ( SysTime.wHour > 12 ? ( SysTime.wHour)-12 : SysTime.wHour ),
                      SysTime.wMinute,
                      SysTime.wSecond,
                      SysTime.wMilliseconds,
                      ( SysTime.wHour >= 12 ? 'p' : 'a' ),
                      Path);
        } else
        {
            fprintf( stdout, "%-4s %s\n", ( *File).Flag, Path);
        }

        PrintFile( ( *File).DiffNode, DiffPath, NULL);
    }

} // PrintFile

void ProcessAdd( LinkedFileList List, char *String1, char *String2)
{
    PCOPY_REQUEST CopyRequest;
    LPSTR NewString1, NewString2;

    if ( fMultiThread)
    {
        NewString1 = _strdup( String1);
        NewString2 = _strdup( String2);
    }

    if ( fScript)
    {
        if ( ( (*List).Attributes & FILE_ATTRIBUTE_DIRECTORY))
        {
            if ( !fOpposite)
            {
                fprintf( stdout, "echo d | xcopy /cehikr \"%s\" \"%s\"\n", String1, String2);
            }

        } else
        {
            fprintf( stdout, "echo f | xcopy /cehikr \"%s\" \"%s\"\n", String1, String2);
        }
    }
    else if ( fExecute)
    {
        if ( List->Attributes & FILE_ATTRIBUTE_DIRECTORY)
        {
            if ( ( !fDoNotRecurse) && ( !fOpposite))
            {
                if ( !SparseTree)
                {
                    fprintf( stdout, "Making %s\t", String2);

                    if ( !MyCreatePath( String2, TRUE))
                    {
                        fprintf( stderr, "Unable to create path %s\n", String2);
                        fprintf( stdout, "\n");
                        ExitValue = 1;

                    } else
                    {
                        fprintf( stdout, "[OK]\n");
                        CompDir( String1, String2);
                    }

                } else
                {
                    CompDir( String1, String2);
                }
            }

        } else
        {
            if ( fMultiThread)
            {

                CopyRequest = LocalAlloc( LMEM_ZEROINIT, sizeof( *CopyRequest ));
                if ( CopyRequest == NULL)
                {
                    OutOfMem ();
                }

                CopyRequest->WorkItem.Reason = WORK_ITEM;
                CopyRequest->Destination     = NewString2;
                CopyRequest->FullPathSrc     = NewString1;
                CopyRequest->Attributes      = List->Attributes;
                CopyRequest->SizeLow         = List->SizeLow;
                QueueWorkItem( CDWorkQueue, &CopyRequest->WorkItem );
            } else
            {
                CopyNode( String2, List, String1);
                free( NewString1 );
                free( NewString2 );
            }
        }

    } else
    {
        if ( ( !fOpposite) || ( !( (*List).Attributes & FILE_ATTRIBUTE_DIRECTORY)))
        {
            PrintFile( List, String1, NULL);
        }
    }

} // ProcessAdd

void ProcessDel( LinkedFileList List, char *String)
{
    if ( fScript)
    {
        ( ( (*List).Attributes & FILE_ATTRIBUTE_DIRECTORY)) ?
        fprintf( stdout, "echo y | rd /s %s\n", String) :
        fprintf( stdout, "del /f %s\n", String);

    } else if ( fExecute)
    {
        fprintf( stdout, "Removing %s\t", String);

        if ( !DelNode( String))
        {
            fprintf( stderr, "Unable to remove %s\n", String);
            fprintf( stdout, "\n");
            ExitValue = 1;

        } else
        {
            fprintf( stdout, "[OK]\n");
        }

    } else
    {
        PrintFile( List, String, NULL);
    }

} // ProcessDel

void ProcessDiff( LinkedFileList List, char *String1, char *String2)
{
    PCOPY_REQUEST CopyRequest;
    LPSTR NewString1, NewString2;

    if ( fMultiThread)
    {
        NewString1 = _strdup( String1);
        NewString2 = _strdup( String2);
    }

    if ( strchr ( (*List).Flag, '@'))
    {
        if ( fScript)
        {
            if ( ( (*List).Attributes & FILE_ATTRIBUTE_DIRECTORY))
            {
                fprintf( stdout, "echo y | rd /s %s\n", String2);

            } else
            {
                fprintf( stdout, "del /f %s\n", String2);
            }
        }
        if ( fExecute)
        {
            fprintf( stdout, "Removing %s\t", String2);
            if ( !DelNode( String2))
            {
                fprintf( stderr, "Unable to remove %s\n", String2);
                fprintf( stdout, "\n");
                ExitValue = 1;

            } else
            {
                fprintf( stdout, "[OK]\n");
            }
        }
    }
    if ( fScript)
    {
        ( ( (*List).Attributes & FILE_ATTRIBUTE_DIRECTORY)) ?
        fprintf( stdout, "echo d | xcopy /cehikr \"%s\" \"%s\"\n", String1, String2) :
        fprintf( stdout, "echo f | xcopy /cehikr \"%s\" \"%s\"\n", String1, String2);

    } else if ( fExecute)
    {

        if ( List->Attributes & FILE_ATTRIBUTE_DIRECTORY)
        {
            CompDir( String1, String2);

        } else
        {
            if ( fMultiThread)
            {

                CopyRequest = LocalAlloc( LMEM_ZEROINIT, sizeof( *CopyRequest ) );
                if ( CopyRequest == NULL)
                {
                    OutOfMem ();
                }

                CopyRequest->WorkItem.Reason = WORK_ITEM;
                CopyRequest->Destination     = NewString2;
                CopyRequest->FullPathSrc     = NewString1;
                CopyRequest->Attributes      = List->Attributes;
                CopyRequest->SizeLow         = List->SizeLow;

                QueueWorkItem( CDWorkQueue, &CopyRequest->WorkItem );
            } else
            {
                CopyNode( String2, List, String1);
                free( NewString1 );
                free( NewString2 );
            }
        }

    } else
    {
        PrintFile( List, String1, String2);
    }

} // ProcessDiff

void ProcessLists( LinkedFileList AddList, LinkedFileList DelList, LinkedFileList DifList,
                  char *Path1, char *Path2                                               )
{
    LinkedFileList PlaceKeeper;
    char          *String1 = NULL;
    char          *String2 = NULL;
    char          *PathWithSlash1, *PathWithSlash2;

    ( Path1[strlen( Path1) - 1] == '\\') ? ( PathWithSlash1 = MYSTRCAT( Path1, "")) :
        ( PathWithSlash1 = MYSTRCAT( Path1, "\\"));

    ( Path2[strlen( Path2) - 1] == '\\') ? ( PathWithSlash2 = MYSTRCAT( Path2, "")) :
        ( PathWithSlash2 = MYSTRCAT( Path2, "\\"));

    String1 = LocalAlloc( LMEM_ZEROINIT, MAX_PATH);

    String2 = LocalAlloc( LMEM_ZEROINIT, MAX_PATH);

    if ( String1 == NULL)
    {
        OutOfMem();
    }

    if ( String2 == NULL)
    {
        OutOfMem();
    }

    if ( !fOnlyIfExists)
    {
        if ( AddList != NULL)
        {
            PlaceKeeper = ( *AddList).First;

        } else
        {
            PlaceKeeper = NULL;
        }

        while ( PlaceKeeper != NULL)
        {
            if ( ( *PlaceKeeper).Process)
            {
                if ( ExitValue == 0)
                {
                    if ( !fExecute)
                    {
                        ExitValue = 1;
                    }
                }

                _strrev( ( *PlaceKeeper).Name);

                strcat( strcpy( String1, PathWithSlash1), ( *PlaceKeeper).Name);

                strcat( strcpy( String2, PathWithSlash2), ( *PlaceKeeper).Name);

                if ( DealingWithDirectories)
                {
                   ProcessAdd( PlaceKeeper, String1, String2);

                } else
                {

                   ProcessAdd( PlaceKeeper, Path1, Path2);
                }
            }

            PlaceKeeper = ( *PlaceKeeper).Next;
        }
    }

    if ( ( !fDoNotDelete) && ( !fOnlyIfExists))
    {
        if ( DelList != NULL)
        {
            PlaceKeeper = ( *DelList).First;

        } else
        {
            PlaceKeeper = NULL;
        }

        while ( PlaceKeeper != NULL)
        {
            if ( ( *PlaceKeeper).Process)
            {
                if ( ExitValue == 0)
                {
                    if ( !fExecute)
                    {
                        ExitValue = 1;
                    }
                }

                _strrev( ( *PlaceKeeper).Name);

                strcat( strcpy( String2, PathWithSlash2), ( *PlaceKeeper).Name);

                ProcessDel( PlaceKeeper, String2);
            }

            PlaceKeeper = ( *PlaceKeeper).Next;
        }
    }

    if ( DifList != NULL)
    {
        PlaceKeeper = ( *DifList).First;

    } else
    {
        PlaceKeeper = NULL;
    }

    while ( PlaceKeeper != NULL)
    {

        if ( ( *PlaceKeeper).Process)
        {
            if ( ExitValue == 0)
            {
                if ( !fExecute)
                {
                    ExitValue = 1;
                }
            }

            _strrev( ( *PlaceKeeper).Name);

            strcat( strcpy( String1, PathWithSlash1), ( *PlaceKeeper).Name);

            strcat( strcpy( String2, PathWithSlash2), ( *PlaceKeeper).Name);

            if ( DealingWithDirectories)
            {
                ProcessDiff( PlaceKeeper, String1, String2);

            } else
            {
                ProcessDiff( PlaceKeeper, Path1, Path2);
            }
        }

        PlaceKeeper = ( *PlaceKeeper).Next;
    }

    LocalFree( String1);
    LocalFree( String2);

    FREE( PathWithSlash1);
    FREE( PathWithSlash2);

} // ProcessLists

void Usage( void)
{
    fprintf( stderr, "Usage: compdir [/abcdefghiklnoprstuvwz$] [/m {wildcard specs}] [/x {wildcard specs}] Path1 Path2 \n");
    fprintf( stderr, "    /a     checks for attribute difference       \n");
    fprintf( stderr, "    /b     checks for binary difference          \n");
    fprintf( stderr, "    /c     prints out script to make             \n");
    fprintf( stderr, "           directory2 look like directory1       \n");
    fprintf( stderr, "    /d     do not perform or denote deletions    \n");
    fprintf( stderr, "    /e     execution of tree duplication         \n");
    fprintf( stderr, "    /f     only update files that already exist  \n");
    fprintf( stderr, "    /g     ignore slm files, i.e slm.ini, slm.dif\n");
    fprintf( stderr, "    /h     don't copy attributes                 \n");
    fprintf( stderr, "    /i     ignore rebase and resource differences\n");
    fprintf( stderr, "    /k     break links if copying files (NT only)\n");
    fprintf( stderr, "    /l     use links instead of copies  (NT only)\n");
    fprintf( stderr, "    /m[:f] marks start of match list. f is a     \n");
    fprintf( stderr, "           match file                            \n");
    fprintf( stderr, "    /n     create second path if it doesn't exist\n");
    fprintf( stderr, "    /o     print files that are the same         \n");
    fprintf( stderr, "    /p{A}  only compare files with attribute A   \n");
    fprintf( stderr, "           where A is any combination of ahsr & -\n");
    fprintf( stderr, "    /r     do not recurse into subdirectories    \n");
    fprintf( stderr, "    /s     checks for size difference            \n");
    fprintf( stderr, "    /t[:#] checks for time-date difference;      \n");
    fprintf( stderr, "           takes margin-of-error parameter       \n");
    fprintf( stderr, "           in number of seconds.                 \n");
    fprintf( stderr, "    /u     uses multiple threads (Win32 only)    \n");
    fprintf( stderr, "    /v     prints verbose output                 \n");
    fprintf( stderr, "    /w     preserves case - not just lower case  \n");
    fprintf( stderr, "    /x[:f] marks start of exclude list. f is an  \n");
    fprintf( stderr, "           exclude file                          \n");
    fprintf( stderr, "    /z     forces copy or link without checking  \n");
    fprintf( stderr, "           criteria                              \n");
    fprintf( stderr, "    /$     create SIS links if possible          \n");
    fprintf( stderr, "    /?     prints this message                   \n");
    exit(1);

} // Usage
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cntrtext\unlodctr\unlodctr.c ===
/*++

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    unlodctr.c

Abstract:

    Program to remove the counter names belonging to the driver specified
        in the command line and update the registry accordingly

Author:

    Bob Watson (a-robw) 12 Feb 93

Revision History:

--*/
#define     UNICODE     1
#define     _UNICODE    1
//
//  Windows Include files
//
#include <windows.h>
#include <tchar.h>
#include <loadperf.h>

int
__cdecl main(
    int argc,
    char *argv[]
)
/*++

main

    entry point to Counter Name Unloader



Arguments

    argc
        # of command line arguments present

    argv
        array of pointers to command line strings

    (note that these are obtained from the GetCommandLine function in
    order to work with both UNICODE and ANSI strings.)

ReturnValue

    0 (ERROR_SUCCESS) if command was processed
    Non-Zero if command error was detected.

--*/
{

    LPTSTR  lpCommandLine;

    UNREFERENCED_PARAMETER (argc);
    UNREFERENCED_PARAMETER (argv);

    lpCommandLine = GetCommandLine(); // get command line

    return (int)UnloadPerfCounterTextStrings (
        lpCommandLine,
        FALSE);     // show text strings to console
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\compdir\comtoolz.c ===
#include "compdir.h"

#define printtext( Text) fprintf( stdout, Text);
#define printstring( String) fprintf( stdout, "%s\n",String);

#define Next( List) ( List == NULL) ? NULL : &(*List).Next

#define CALCULATE_HEIGHT( Node)                                                    \
                                                                                  \
    if ( (*Node).Left == NULL)                                                     \
        if ( (*Node).Right == NULL)                                                \
             (*Node).Height = 1;                                                   \
        else                                                                      \
             (*Node).Height = (*(*Node).Right).Height + 1;                         \
    else                                                                          \
        if ( (*Node).Right == NULL)                                                \
             (*Node).Height = (*(*Node).Left).Height + 1;                          \
        else                                                                      \
            (*Node).Height = ( (*(*Node).Right).Height > (*(*Node).Left).Height) ? \
                (*(*Node).Right).Height + 1 : (*(*Node).Left).Height + 1;

#define ROTATELEFT( List)                                                          \
                                                                                  \
    LinkedFileList TmpPtr;                                                        \
                                                                                  \
    TmpPtr = (**List).Right;                                                      \
    (**List).Right = (*TmpPtr).Left;                                              \
    (*TmpPtr).Left = (*List);                                                     \
    *List = TmpPtr;                                                               \
                                                                                  \
    if ( (*(**List).Left).Right != NULL)                                           \
         (*(**List).Left).Last = (*(*(**List).Left).Right).Last;                   \
    else                                                                          \
        (*(**List).Left).Last = (**List).Left;                                    \
    (**List).First = (*(**List).Left).First;                                      \
                                                                                  \
    CALCULATE_HEIGHT( (**List).Left);                                              \
                                                                                  \
    CALCULATE_HEIGHT(*List);

#define ROTATERIGHT( List)                                                         \
                                                                                  \
    LinkedFileList TmpPtr;                                                        \
                                                                                  \
    TmpPtr = (**List).Left;                                                       \
    (**List).Left = (*TmpPtr).Right;                                              \
    (*TmpPtr).Right = (*List);                                                    \
    *List = TmpPtr;                                                               \
                                                                                  \
    if ( (*(**List).Right).Left != NULL)                                           \
         (*(**List).Right).First = (*(*(**List).Right).Left).First;                \
    else                                                                          \
        (*(**List).Right).First = (**List).Right;                                 \
    (**List).Last = (*(**List).Right).Last;                                       \
                                                                                  \
    CALCULATE_HEIGHT( (**List).Right);                                             \
                                                                                  \
    CALCULATE_HEIGHT( *List);

#define ROTATEUPLEFT( List)                                                        \
                                                                                  \
    LinkedFileList TmpPtr;                                                        \
                                                                                  \
    TmpPtr = (*(**List).Right).Left;                                              \
    (*(**List).Right).Left = (*TmpPtr).Right;                                     \
    (*TmpPtr).Right = (**List).Right;                                             \
    (**List).Right = (*TmpPtr).Left;                                              \
    (*TmpPtr).Left = (*List);                                                     \
    *List = TmpPtr;                                                               \
                                                                                  \
    if ( (*(**List).Left).Right != NULL)                                           \
         (*(**List).Left).Last = (*(*(**List).Left).Right).Last;                   \
    else                                                                          \
        (*(**List).Left).Last = (**List).Left;                                    \
    (**List).First = (*(**List).Left).First;                                      \
                                                                                  \
    if ( (*(**List).Right).Left != NULL)                                           \
         (*(**List).Right).First = (*(*(**List).Right).Left).First;                \
    else                                                                          \
        (*(**List).Right).First = (**List).Right;                                 \
    (**List).Last = (*(**List).Right).Last;                                       \
                                                                                  \
    CALCULATE_HEIGHT( (**List).Left);                                              \
                                                                                  \
    CALCULATE_HEIGHT( (**List).Right);                                             \
                                                                                  \
    CALCULATE_HEIGHT( *List);

#define ROTATEUPRIGHT( List)                                                       \
                                                                                  \
    LinkedFileList TmpPtr;                                                        \
                                                                                  \
    TmpPtr = (*(**List).Left).Right;                                              \
    (*(**List).Left).Right = (*TmpPtr).Left;                                      \
    (*TmpPtr).Left = (**List).Left;                                               \
    (**List).Left = (*TmpPtr).Right;                                              \
    (*TmpPtr).Right = (*List);                                                    \
    *List = TmpPtr;                                                               \
                                                                                  \
    if ( (*(**List).Right).Left != NULL)                                           \
         (*(**List).Right).First = (*(*(**List).Right).Left).First;                \
    else                                                                          \
        (*(**List).Right).First = (**List).Right;                                 \
    (**List).Last = (*(**List).Right).Last;                                       \
                                                                                  \
    if ( (*(**List).Left).Right != NULL)                                           \
         (*(**List).Left).Last = (*(*(**List).Left).Right).Last;                   \
    else                                                                          \
        (*(**List).Left).Last = (**List).Left;                                    \
    (**List).First = (*(**List).Left).First;                                      \
                                                                                  \
    CALCULATE_HEIGHT( (**List).Right);                                             \
                                                                                  \
    CALCULATE_HEIGHT( (**List).Left);                                              \
                                                                                  \
    CALCULATE_HEIGHT( *List);




//
// Walk down list and add Nodes
//

BOOL AddToList( LinkedFileList Node, LinkedFileList *List)
{
    int Result;
    BOOL Changed    = FALSE;
    BOOL ChangedVal = FALSE;

    //
    // If Node is empty do nothing
    //

    if ( Node == NULL)
    {
        return Changed;
    }
    //
    // If list is empty just point to Node
    //

    if ( *List == NULL)
    {
        *List = Node;
        Changed = TRUE;

    //
    // Otherwise go down the list and add
    // in sorted order
    //

    } else
    {
        Result = _stricmp( (*Node).Name, (**List).Name);

        if ( Result < 0)
        {

            if ( (**List).Left == NULL)
            {
                (**List).Left = Node;
                (**List).First = (*Node).First;
                (*(*Node).Last).Next = *List;
                Changed = TRUE;
                CALCULATE_HEIGHT(*List);

            }  else
            {
                ChangedVal = AddToList( Node, &(**List).Left);
                if ( ChangedVal)
                {
                    if ( (**List).First != (*(**List).Left).First)
                    {
                        Changed = TRUE;
                        (**List).First = (*(**List).Left).First;
                    }
                    if ( (*(*(**List).Left).Last).Next != *List)
                    {
                        Changed = TRUE;
                        (*(*(**List).Left).Last).Next = *List;
                    }
                }
                Result = (**List).Height;
                CALCULATE_HEIGHT( *List);
                if ( (**List).Height != Result)
                {
                    Changed = TRUE;
                }
            }
            if ( Changed)
            {
                if ( (**List).Right == NULL)
                {
                    if ( (*(**List).Left).Height > 1 )
                    {
                        if ( (*(**List).Left).Left == NULL )
                        {
                            ROTATEUPRIGHT( List);
                            Changed = TRUE;

                        } else
                        {
                            ROTATERIGHT( List);
                            Changed = TRUE;
                        }
                    }

                } else if ( ( (*(**List).Left).Height - (*(**List).Right).Height) > 1)
                {
                    ROTATERIGHT( List);
                    Changed = TRUE;
                }
            }
        }
        else if ( Result > 0)
        {
            if ( (**List).Right == NULL)
            {

                (**List).Right = Node;
                (**List).Next = (*Node).First;
                (**List).Last = (*Node).Last;
                Changed = TRUE;
                CALCULATE_HEIGHT( *List);

            } else
            {
                ChangedVal = AddToList( Node, &(**List).Right);
                if ( ChangedVal)
                {
                    if ( (**List).Next != (*(**List).Right).First)
                    {
                        Changed = TRUE;
                        (**List).Next = (*(**List).Right).First;
                    }
                    if ( (**List).Last != (*(**List).Right).Last)
                    {
                        Changed = TRUE;
                        (**List).Last = (*(**List).Right).Last;
                    }
                }
                Result = (**List).Height;
                CALCULATE_HEIGHT( *List);
                if ( (**List).Height != Result)
                {
                    Changed = TRUE;
                }
            }
            if ( Changed)
            {
                if ( (**List).Left == NULL)
                {
                    if ( (*(**List).Right).Height > 1 )
                    {
                        if ( (*(**List).Right).Right == NULL )
                        {
                            ROTATEUPLEFT( List);
                            Changed = TRUE;

                        } else
                        {
                            ROTATELEFT( List);
                            Changed = TRUE;
                        }
                    }
                }
                else if ( ( (*(**List).Right).Height - (*(**List).Left).Height) > 1)
                {
                    ROTATELEFT( List);
                    Changed = TRUE;
                }
            }

        } else if ( Result == 0)
        {
            // Don't add if already here
        }

    
}

    return Changed;

} /* AddToList */

LPSTR CombineThreeStrings( char *FirstString, char *SecondString, char *ThirdString)
{
    char *String;

    String = malloc( strlen( FirstString) + strlen( SecondString) + strlen( ThirdString) + 1);
    if ( String == NULL)
    {
        OutOfMem();
    }

    strcpy( String, FirstString);
    strcpy( &(String[strlen( FirstString)]), SecondString);
    strcpy( &(String[strlen( FirstString) + strlen( SecondString)]), ThirdString);

    return( String);

} /* CombineThreeStrings */

void CreateNode( LinkedFileList *Node, WIN32_FIND_DATA *Buff)
{
    (*Node) = malloc( sizeof( struct NodeStruct));
    if ( (*Node) == NULL)
    {
        OutOfMem();
    }
    (**Node).Name = _strrev( _strdup( (*Buff).cFileName));
    if ( (**Node).Name == NULL)
    {
        OutOfMem();
    }
    if ( !fDontLowerCase)
    {
        _strlwr( (**Node).Name);
    }
    strcpy( (**Node).Flag, "");
    (**Node).Attributes = (*Buff).dwFileAttributes;
    if ( (*Buff).dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
    {
        strcpy( (**Node).Flag, "DIR");
    }
    (**Node).SizeHigh = (*Buff).nFileSizeHigh;
    (**Node).SizeLow = (*Buff).nFileSizeLow;
    (**Node).Time.dwLowDateTime = (*Buff).ftLastWriteTime.dwLowDateTime;
    (**Node).Time.dwHighDateTime = (*Buff).ftLastWriteTime.dwHighDateTime;
    (**Node).First    = (*Node);
    (**Node).Last     = (*Node);
    (**Node).Left     = NULL;
    (**Node).Next     = NULL;
    (**Node).Process  = ProcessModeDefault;
    (**Node).Right    = NULL;
    (**Node).DiffNode = NULL;
    (**Node).Height   = 1;

} /* CreateNode */


void CreateNameNode( LinkedFileList *Node, char *Name)
{
    (*Node) = malloc( sizeof( struct NodeStruct));
    if ( (*Node) == NULL)
    {
        OutOfMem();
    }
    (**Node).Name = _strdup( Name);
    if ( (**Node).Name == NULL)
    {
        OutOfMem();
    }
    if ( !fDontLowerCase)
    {
        _strlwr( (**Node).Name);
    }
    strcpy( (**Node).Flag, "");
    (**Node).Attributes = 0;
    (**Node).SizeHigh = 0;
    (**Node).SizeLow = 0;
    (**Node).Time.dwLowDateTime  = 0;
    (**Node).Time.dwHighDateTime = 0;
    (**Node).First    = (*Node);
    (**Node).Last     = (*Node);
    (**Node).Left     = NULL;
    (**Node).Next     = NULL;
    (**Node).Process  = TRUE;
    (**Node).Right    = NULL;
    (**Node).DiffNode = NULL;
    (**Node).Height   = 1;

} /* CreateNode */


void DuplicateNode( LinkedFileList FirstNode, LinkedFileList *SecondNode)
{
    (*SecondNode) = malloc( sizeof( struct NodeStruct));
    if ( (*SecondNode) == NULL)
    {
        OutOfMem();
    }
    (**SecondNode).Name = _strdup( (*FirstNode).Name);
    if ( (**SecondNode).Name == NULL)
    {
        OutOfMem();
    }
    if ( !fDontLowerCase)
    {
        _strlwr( (**SecondNode).Name);
    }
    strcpy( (**SecondNode).Flag, (*FirstNode).Flag);
    (**SecondNode).Attributes = (*FirstNode).Attributes;
    (**SecondNode).SizeHigh = (*FirstNode).SizeHigh;
    (**SecondNode).SizeLow  = (*FirstNode).SizeLow;
    (**SecondNode).Time.dwLowDateTime  = (*FirstNode).Time.dwLowDateTime;
    (**SecondNode).Time.dwHighDateTime = (*FirstNode).Time.dwHighDateTime;
    (**SecondNode).First    = (*SecondNode);
    (**SecondNode).Last     = (*SecondNode);
    (**SecondNode).Left     = NULL;
    (**SecondNode).Next     = NULL;
    (**SecondNode).Process  = ProcessModeDefault;
    (**SecondNode).Right    = NULL;
    (**SecondNode).DiffNode = NULL;
    (**SecondNode).Height   = 0;

} // DuplicateNode

LinkedFileList *FindInList( char *Name, LinkedFileList *List)
{
    int Result;
    LinkedFileList *tmpptr = List;

    while ( *tmpptr != NULL)
    {
        Result = _stricmp( (**tmpptr).Name, Name);
        if ( Result == 0)
        {
            return tmpptr;
        }
        if ( Result > 0)
        {
            tmpptr = &(**tmpptr).Left;
        }
        if ( Result < 0)
        {
            tmpptr = &(**tmpptr).Right;
        }
    }
    return NULL;

} /* FindInList */

BOOL FindInMatchListTop( char *Name, LinkedFileList *List)
{
    int Result;
    LinkedFileList *tmpptr = List;

    while ( *tmpptr != NULL)
    {
        Result = _stricmp( (**tmpptr).Name, Name);
        if ( Result == 0)
        {
            return TRUE;
        }
        if ( strchr( (**tmpptr).Name, '*') != NULL)
        {
            if ( Match( (**tmpptr).Name, Name))
            {
                return TRUE;
            }
        }
        if ( Result > 0)
        {
            tmpptr = &(**tmpptr).Left;
        }
        if ( Result < 0)
        {
            tmpptr = &(**tmpptr).Right;
        }
    }
    return FALSE;

} /* FindInList */

BOOL FindInMatchListFront( char *Name, LinkedFileList *List)
{
    LinkedFileList *tmpptr = List;

    if ( *tmpptr != NULL)
    {
       tmpptr = &(**tmpptr).First;
    }

    while ( *tmpptr != NULL)
    {
        if ( Match( (**tmpptr).Name, Name))
        {
            return TRUE;
        }

        tmpptr = &(**tmpptr).Next;
    }
    return FALSE;

} /* FindInList */

//
// Walk down list and free each entry
//

void FreeList( LinkedFileList *List)
{
    if ( (*List) != NULL)
    {
        FreeList( &(**List).Left);
        FreeList( &(**List).Right);
        FreeList( &(**List).DiffNode);
        free( (**List).Name);
        free( *List);
    }

} // FreeList

void PrintTree( LinkedFileList List, int Level)
{
    int Counter = 0;

    if ( List == NULL)
    {
        return;
    }

    PrintTree( (*List).Right, Level + 1);

    while ( Counter++ < Level)
    {
        fprintf( stdout, "       ");
    }

    fprintf( stdout, "%s %d\n", (*List).Name, (*List).Height);

    PrintTree( (*List).Left, Level + 1);

} // Print Tree

//
// This function is is the same as strcat except
// that it does the memory allocation for the string
//

LPSTR MyStrCat( char *FirstString, char *SecondString)
{
    char *String;

    String = malloc( strlen( FirstString) + strlen( SecondString) + 1);
    if ( String == NULL)
    {
        OutOfMem();
    }

    strcpy( String, FirstString);
    strcpy( &(String[strlen( FirstString)]), SecondString);

    return( String);

} /* MyStrCat */

BOOL Match( char *Pat, char* Text)
{
    switch ( *Pat)
    {
        case '\0':
            return *Text == '\0';
        case '?':
            return *Text != '\0' && Match( Pat + 1, Text + 1);
        case '*':
            do
            {
                if ( Match( Pat + 1, Text))
                {
                    return TRUE;
                }
            } while ( *Text++);
            return FALSE;
        default:
            return toupper( *Text) == toupper( *Pat) && Match( Pat + 1, Text + 1);
    }

} /* Match */

/*
LinkedFileList *Next( LinkedFileList List)
{
    if ( List == NULL)
    {
        return NULL;
    }

    return &(*List).Next;

} /* /* Next */

void OutOfMem( void)
{
    fprintf( stderr, "-out of memory-\n");
    exit(1);

} // OutOfMem
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\compdir\doscopy.c ===
#include <stdio.h>
#include <dos.h>
#include <windows.h>
#include <compdir.h>

BOOL BinaryCompare( char *file1, char *file2)
{
    register int char1, char2;
    FILE *filehandle1, *filehandle2;

    if ( (filehandle1 = fopen( file1, "rb")) == NULL)
    {
        fprintf( stderr, "cannot open %s\n", file1);
        return( FALSE);
    }
    if ( (filehandle2 = fopen( file2, "rb")) == NULL)
    {
        fprintf( stderr, "cannot open %s\n", file2);
        fclose( filehandle1);
        return( FALSE);
    }
    while ( TRUE)
    {
        if ( (char1 = getc( filehandle1)) != EOF)
        {
            if ( (char2 = getc( filehandle2)) != EOF)
            {
                if ( char1 != char2)
                {
                    fclose( filehandle1);
                    fclose( filehandle2);
                    return( FALSE);
                }

            } else
            {
                fclose( filehandle1);
                fclose( filehandle2);
                return( FALSE);
            }

        } else
        {
            if ( (char2 = getc( filehandle2)) == EOF)
            {
                fclose( filehandle1);
                fclose( filehandle2);
                return( TRUE);

            } else
            {
                fclose( filehandle1);
                fclose( filehandle2);
                return( FALSE);
            }
        }
    }
}

/* Copies one file to another (both specified by path). Dynamically
 * allocates memory for the file buffer. Returns TRUE if successful,
 * or FALSE if unsuccessful. This function uses _dos_ functions only;
 * standard C functions are not used.
 */
BOOL fastcopy( HANDLE hfSrcParm, HANDLE hfDstParm )
{
    char _far *buf = NULL;
    unsigned segbuf, count;

    /* Attempt to dynamically allocate all of memory (0xffff paragraphs).
     * This will fail, but will return the amount actually available
     * in segbuf. Then allocate this amount.
     */
    if ( _dos_allocmem( 0xffff, &segbuf ) )
    {
        count = segbuf;
        if ( _dos_allocmem( count, &segbuf ) )
        {
            return FALSE;
        }
    }
    FP_SEG( buf ) = segbuf;

    /* Read and write until there is nothing left. */
    while ( count )
    {
        /* Read and write input. */
        if ( ( _dos_read( hfSrcParm, buf, count, &count )) )
        {
	    _dos_freemem( segbuf );
            return FALSE;
        }
        if ( (_dos_write( hfDstParm, buf, count, &count )) )
        {
	    _dos_freemem( segbuf );
            return FALSE;
        }
    }
    /* Free memory. */
    _dos_freemem( segbuf );
    return TRUE;
}

BOOL FCopy( char *src, char *dst, BOOL Output)
{
    HANDLE srcfh, dstfh;
    BOOL result;
    ATTRIBUTE_TYPE Attributes;
    unsigned filedate, filetime;
    GET_ATTRIBUTES( src, Attributes);

    if ( Attributes == FILE_ATTRIBUTE_DIRECTORY)
    {
        if ( Output )
        {
            fprintf( stderr, "\nUnable to open source");
        }
	return FALSE;
    }

    if ( _dos_creatnew( src, _A_RDONLY, &srcfh) != 0)
    {
        if ( _dos_open( src, O_RDONLY, &srcfh) != 0)
        {
            if ( Output )
            {
               fprintf( stderr, "\nUnable to open source, error code %d", GetLastError() );
            }
            if ( srcfh != INVALID_HANDLE_VALUE)
            {
                CloseHandle( srcfh );
            }
            return FALSE;
        }
    }

    if ( _dos_getftime( srcfh, &filedate, &filetime) != 0)
    {
        if ( Output )
        {
           fprintf( stderr, "\nUnable to get time of source");
        }
        if ( srcfh != INVALID_HANDLE_VALUE)
        {
            CloseHandle( srcfh );
        }
	return FALSE;
    }

    if ( _dos_creatnew( dst, _A_NORMAL, &dstfh) != 0)
    {
        if ( _dos_open( dst,  O_RDWR,   &dstfh) != 0)
        {
            if ( Output )
            {
                fprintf( stderr, "\nUnable to create destination, error code %d", GetLastError() );
            }
            if ( srcfh != INVALID_HANDLE_VALUE)
            {
                CloseHandle( srcfh );
            }
            if ( dstfh != INVALID_HANDLE_VALUE)
            {
                CloseHandle( dstfh );
            }
            return FALSE;
        }
    }

    result = fastcopy( srcfh, dstfh );

    if ( !result)
    {
        if ( dstfh != INVALID_HANDLE_VALUE)
        {
            CloseHandle( dstfh );
            dstfh = INVALID_HANDLE_VALUE;
        }

        DeleteFile( dst );
        if ( srcfh != INVALID_HANDLE_VALUE)
        {
            CloseHandle( srcfh );
        }
        if ( Output )
        {
            fprintf( stderr, "\nUnable to copy file");
        }
        return FALSE;
    }

    if ( _dos_setftime( dstfh, filedate, filetime != 0))
    {
        if ( Output )
        {
           fprintf( stderr, "\nUnable to set time of destination");
        }
        if ( srcfh != INVALID_HANDLE_VALUE)
        {
            CloseHandle( srcfh );
        }
        if ( dstfh != INVALID_HANDLE_VALUE)
        {
            CloseHandle( dstfh );
        }
	return FALSE;
    }

    if ( srcfh != INVALID_HANDLE_VALUE)
    {
        CloseHandle( srcfh );
    }
    if ( dstfh != INVALID_HANDLE_VALUE)
    {
        CloseHandle( dstfh );
    }
    return TRUE;

} // FCopy
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\compdir\multithd.c ===
#include "compdir.h"

#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead) )

#define IsListEmpty(ListHead) (\
    ( ((ListHead)->Flink == (ListHead)) ? TRUE : FALSE ) )

#define RemoveHeadList(ListHead) \
    (ListHead)->Flink;\
    {\
        PLIST_ENTRY FirstEntry;\
        FirstEntry = (ListHead)->Flink;\
        FirstEntry->Flink->Blink = (ListHead);\
        (ListHead)->Flink = FirstEntry->Flink;\
    }

#define InsertTailList(ListHead,Entry) \
    (Entry)->Flink = (ListHead);\
    (Entry)->Blink = (ListHead)->Blink;\
    (ListHead)->Blink->Flink = (Entry);\
    (ListHead)->Blink = (Entry)

#define ARGUMENT_PRESENT( ArgumentPointer )    (\
    (LPSTR)(ArgumentPointer) != (LPSTR)(NULL) )

#define ROUND_UP( Size, Amount ) (((Size) + ((Amount) - 1)) & ~((Amount) - 1))

VOID
ProcessRequest(
    IN PWORK_QUEUE_ITEM WorkItem
    )

/*++

Routine Description:

    This function is called whenever a work item is removed from
    the work queue by one of the worker threads.  Which worker
    thread context this function is called in is arbitrary.

    This functions keeps a pointer to state information in
    thread local storage.

    This function is called once at the beginning with a
    special initialization call.  During this call, this
    function allocates space for state information and
    remembers the pointer to the state information in
    a Thread Local Storage (TLS) slot.

    This function is called once at the end with a special
    termination call.  During this call, this function
    frees the state information allocated during the
    initialization call.

    In between these two calls are zero or more calls to
    handle a work item.  The work item is a copy request
    which is handled by the ProcessCopyFile function.

Arguments:

    WorkItem - Supplies a pointer to the work item just removed
        from the work queue.  It is the responsibility of this
        routine to free the memory used to hold the work item.

Return Value:

    None.

--*/

{
    DWORD BytesWritten;
    PCOPY_REQUEST_STATE State;
    PCOPY_REQUEST CopyRequest;
    CHAR MessageBuffer[ 2 * MAX_PATH ];

    if (WorkItem->Reason == WORK_INITIALIZE_ITEM) {
        //
        // First time initialization call.  Allocate space for
        // state information.
        //

        State = LocalAlloc( LMEM_ZEROINIT,
                            sizeof( *State )
                          );

        if (State != NULL) {
            //
            // Now create a virtual buffer, with an initial commitment
            // of zero and a maximum commitment of 128KB.  This buffer
            // will be used to accumulate the output during the copy
            // operation.  This is so the output can be written to
            // standard output with a single write call, thus insuring
            // that it remains contiguous in the output stream, and is
            // not intermingled with the output of the other worker threads.
            //

            if (CreateVirtualBuffer( &State->Buffer, 0, 2 * 64 * 1024 )) {
                //
                // The CurrentOutput field of the state block is
                // a pointer to where the next output goes in the
                // buffer.  It is initialized here and reset each
                // time the buffer is flushed to standard output.
                //

                State->CurrentOutput = State->Buffer.Base;
                }
            else {
                LocalFree( State );
                State = NULL;
                }
            }

        //
        // Remember the pointer to the state informaiton
        // thread local storage.
        //

        TlsSetValue( TlsIndex, State );
        return;
        }

    //
    // Here to handle a work item or special terminate call.
    // Get the state pointer from thread local storage.
    //

    State = (PCOPY_REQUEST_STATE)TlsGetValue( TlsIndex );
    if (State == NULL) {
        return;
        }

    //
    // If this is the special terminate work item, free the virtual
    // buffer and state block allocated above and set the thread
    // local storage value to NULL.  Return to caller.
    //

    if (WorkItem->Reason == WORK_TERMINATE_ITEM) {
        FreeVirtualBuffer( &State->Buffer );
        LocalFree( State );
        TlsSetValue( TlsIndex, NULL );
        return;
        }

    //
    // If not an initialize or terminate work item, then must be a
    // copy request.  Calculate the address of the copy request
    // block, based on the position of the WorkItem field in the
    // COPY_REQUEST structure.
    //

    CopyRequest = CONTAINING_RECORD( WorkItem, COPY_REQUEST, WorkItem );

    //
    // Actual copy operation is protected by a try ... except
    // block so that any attempts to store into the virtual buffer
    // will be handled correctly by extending the virtual buffer.
    //

    _try {
        //
        // Perform the copy
        //
        ProcessCopyFile( CopyRequest, State );

        //
        // If any output was written to the virtual buffer,
        // flush the output to standard output.  Trim the
        // virtual buffer back to zero committed pages.
        //

        if (State->CurrentOutput > (LPSTR)State->Buffer.Base) {
            WriteFile( GetStdHandle( STD_OUTPUT_HANDLE ),
                       State->Buffer.Base,
                       (DWORD)(State->CurrentOutput - (LPSTR)State->Buffer.Base),
                       &BytesWritten,
                       NULL
                     );

            TrimVirtualBuffer( &State->Buffer );
            State->CurrentOutput = (LPSTR)State->Buffer.Base;
            }
        }

    _except( VirtualBufferExceptionFilter( GetExceptionCode(),
                                          GetExceptionInformation(),
                                          &State->Buffer
                                        )
          ) {

        //
        // We will get here if the exception filter was unable to
        // commit the memory.
        //

        WriteFile( GetStdHandle( STD_OUTPUT_HANDLE ),
                   MessageBuffer,
                   sprintf( MessageBuffer, "can't commit memory\n" ),
                   &BytesWritten,
                   NULL
                 );
        }

    //
    // Free the storage used by the CopyRequest
    //

    LocalFree( CopyRequest );

    //
    // All done with this request.  Return to the worker thread that
    // called us.
    //

    return;
}

VOID
ProcessCopyFile(
    IN PCOPY_REQUEST CopyRequest,
    IN PCOPY_REQUEST_STATE State
    )

/*++

Routine Description:

    This function performs the actual copy of the contents of the
    passed file for the copy string given on the command line.
    If we are using synchronous I/O, then do the read operation
    now.

    Copy the contents of the file for any matches, and accumulate
    the match output in the virtual buffer using sprintf, which is
    multi-thread safe, even with the single threaded version of
    the libraries.

Arguments:

    CopyRequest - Supplies a pointer to the copy request which
        contains the relevant information.

    State - Supplies a pointer to state information for the current
        thread.

Return Value:

    None.

--*/

{
    LPSTR FullPathSrc, Destination;
    BOOL pend, CanDetectFreeSpace = TRUE;
    int i;
    DWORD sizeround;
    DWORD BytesPerCluster;
    ATTRIBUTE_TYPE Attributes;

    int LastErrorGot;
    __int64 freespac;
    char root[5] = {'a',':','\\','\0'};
    DWORD cSecsPerClus, cBytesPerSec, cFreeClus, cTotalClus;

    Destination = CopyRequest->Destination;
    FullPathSrc = CopyRequest->FullPathSrc;

    root[0] = *Destination;

    if( !GetDiskFreeSpace( root, &cSecsPerClus, &cBytesPerSec, &cFreeClus, &cTotalClus ) ) {
        CanDetectFreeSpace = FALSE;
    }
    else {
        freespac = ( (__int64)cBytesPerSec * (__int64)cSecsPerClus * (__int64)cFreeClus );
        BytesPerCluster = cSecsPerClus * cBytesPerSec;
    }

    if (!fDontLowerCase) {
        _strlwr(FullPathSrc);
        _strlwr(Destination);
    }

    State->CurrentOutput += sprintf( State->CurrentOutput, "%s => %s\t", FullPathSrc, Destination);

    if (CanDetectFreeSpace) {

        sizeround =  CopyRequest->SizeLow;
        sizeround += BytesPerCluster - 1;
        sizeround /= BytesPerCluster;
        sizeround *= BytesPerCluster;

        if (freespac < sizeround) {
            State->CurrentOutput += sprintf( State->CurrentOutput, "not enough space\n");
            return;
        }
    }

    GET_ATTRIBUTES(Destination, Attributes);
    i = SET_ATTRIBUTES(Destination, Attributes & NONREADONLYSYSTEMHIDDEN );

    i = 1;

    do {

        if (!fCreateLink) {
            if (!fBreakLinks) {
                pend = MyCopyFile (FullPathSrc, Destination, FALSE);
            }
            else {
                _unlink(Destination);
                pend = MyCopyFile (FullPathSrc, Destination, FALSE);
            }
        }
        else {
            if (i == 1) {
                pend = MakeLink (FullPathSrc, Destination, FALSE);
            }
            else {
                pend = MakeLink (FullPathSrc, Destination, TRUE);
            }
        }

        if (SparseTree && !pend) {

            EnterCriticalSection( &CreatePathCriticalSection );

            if (!MyCreatePath(Destination, FALSE)) {
                State->CurrentOutput += sprintf( State->CurrentOutput, "Unable to create path %s", Destination);
                ExitValue = 1;
            }

            LeaveCriticalSection( &CreatePathCriticalSection );
        }

    } while ((i++ < 2) && (!pend) );

    if (!pend) {

        LastErrorGot = GetLastError ();

        if ((fCreateLink) && (LastErrorGot == 1)) {
            State->CurrentOutput += sprintf( State->CurrentOutput, "Can only make links on NTFS and OFS");
        }
        else if (fCreateLink) {
            State->CurrentOutput += sprintf( State->CurrentOutput, "(error = %d)", LastErrorGot);
        }
        else {
            State->CurrentOutput += sprintf( State->CurrentOutput, "Copy Error (error = %d)", LastErrorGot);
        }

        ExitValue = 1;
    }

    State->CurrentOutput += sprintf( State->CurrentOutput, "%s\n", pend == TRUE ? "[OK]" : "");

    free (CopyRequest->Destination);
    free (CopyRequest->FullPathSrc);

    //GET_ATTRIBUTES( FullPathSrc, Attributes);
    if ( !fDontCopyAttribs)
    {
        i = SET_ATTRIBUTES( Destination, CopyRequest->Attributes);
    }
    else
    {
        i = SET_ATTRIBUTES( Destination, FILE_ATTRIBUTE_ARCHIVE);
    }
}

PWORK_QUEUE
CreateWorkQueue(
    IN DWORD NumberOfWorkerThreads,
    IN PWORKER_ROUTINE WorkerRoutine
    )

/*++

Routine Description:

    This function creates a work queue, with the specified number of
    threads to service work items placed in the queue.  Work items
    are removed from the queue in the same order that they are placed
    in the queue.

Arguments:

    NumberOfWorkerThreads - Specifies how many threads this function
        should create to process work items placed in the queue.
        Must be greater than 0 and less than 128.

    WorkerRoutine - Specifies the address of a routine to call
        for each work item as it is removed from the queue.  The
        thread context the routine is called in is undefined.

Return Value:

    A pointer to the work queue.  Returns NULL if unable to create
    the work queue and its worker threads.  Extended error information
    is available from GetLastError()

--*/

{
    PWORK_QUEUE WorkQueue;
    HANDLE Thread;
    DWORD ThreadId;
    DWORD i;

    //
    // Allocate space for the work queue, which includes an
    // array of thread handles.
    //

    WorkQueue = LocalAlloc( LMEM_ZEROINIT,
                            sizeof( *WorkQueue ) +
                                (NumberOfWorkerThreads * sizeof( HANDLE ))
                          );
    if (WorkQueue == NULL) {
        return NULL;
        }

    //
    // The work queue is controlled by a counting semaphore that
    // is incremented each time a work item is placed in the queue
    // and decremented each time a worker thread wakes up to remove
    // an item from the queue.
    //

    if (WorkQueue->Semaphore = CreateSemaphore( NULL, 0, 100000, NULL )) {
        //
        // Mutual exclusion between the worker threads accessing
        // the work queue is done with a critical section.
        //

        InitializeCriticalSection( &WorkQueue->CriticalSection );

        //
        // The queue itself is just a doubly linked list, where
        // items are placed in the queue at the tail of the list
        // and removed from the queue from the head of the list.
        //

        InitializeListHead( &WorkQueue->Queue );

        //
        // Removed the address of the supplied worker function
        // in the work queue structure.
        //

        WorkQueue->WorkerRoutine = WorkerRoutine;

        //
        // Now create the requested number of worker threads.
        // The handle to each thread is remembered in an
        // array of thread handles in the work queue structure.
        //

        for (i=0; i<NumberOfWorkerThreads; i++) {
            Thread = CreateThread( NULL,
                                   0,
                                   (LPTHREAD_START_ROUTINE) WorkerThread,
                                   WorkQueue,
                                   0,
                                   &ThreadId
                                 );
            if (Thread == NULL) {
                break;
                }
            else {
                WorkQueue->NumberOfWorkerThreads++;
                WorkQueue->WorkerThreads[ i ] = Thread;
                SetThreadPriority( Thread, THREAD_PRIORITY_ABOVE_NORMAL );
                }
            }

        //
        // If we successfully created all of the worker threads
        // then return the address of the work queue structure
        // to indicate success.
        //

        if (i == NumberOfWorkerThreads) {
            return WorkQueue;
            }
        }

    //
    // Failed for some reason.  Destroy whatever we managed
    // to create and return failure to the caller.
    //

    DestroyWorkQueue( WorkQueue );
    return NULL;
}

VOID
DestroyWorkQueue(
    IN OUT PWORK_QUEUE WorkQueue
    )

/*++

Routine Description:

    This function destroys a work queue created with the CreateWorkQueue
    functions.  It attempts to shut down the worker threads cleanly
    by queueing a terminate work item to each worker thread.  It then
    waits for all the worker threads to terminate.  If the wait is
    not satisfied within 30 seconds, then it goes ahead and terminates
    all of the worker threads.

Arguments:

    WorkQueue - Supplies a pointer to the work queue to destroy.

Return Value:

    None.

--*/

{
    DWORD i;
    DWORD rc;

    //
    // If the semaphore handle field is not NULL, then there
    // may be threads to terminate.
    //

    if (WorkQueue->Semaphore != NULL) {
        //
        // Set the termiating flag in the work queue and
        // signal the counting semaphore by the number
        // worker threads so they will all wake up and
        // notice the terminating flag and exit.
        //

        EnterCriticalSection( &WorkQueue->CriticalSection );
        _try {
            WorkQueue->Terminating = TRUE;
            ReleaseSemaphore( WorkQueue->Semaphore,
                              WorkQueue->NumberOfWorkerThreads,
                              NULL
                            );
            }
        _finally {
            LeaveCriticalSection( &WorkQueue->CriticalSection );
            }

        //
        // Wait for all worker threads to wake up and see the
        // terminate flag and then terminate themselves.  Timeout
        // the wait after 30 seconds.
        //

        while (TRUE) {
            rc = WaitForMultipleObjectsEx( WorkQueue->NumberOfWorkerThreads,
                                           WorkQueue->WorkerThreads,
                                           TRUE,
                                           3600000,
                                           TRUE
                                         );
            if (rc == WAIT_IO_COMPLETION) {
                //
                // If we came out of the wait because an I/O
                // completion routine was called, reissue the
                // wait.
                //
                continue;
                }
            else {
                break;
                }
            }

        //
        // Now close our thread handles so they will actually
        // evaporate.  If the wait above was unsuccessful,
        // then first attempt to force the termination of
        // each worker thread prior to closing the handle.
        //

        for (i=0; i<WorkQueue->NumberOfWorkerThreads; i++) {
            if (rc != NO_ERROR) {
                TerminateThread( WorkQueue->WorkerThreads[ i ], rc );
                }

            CloseHandle( WorkQueue->WorkerThreads[ i ] );
            }

        //
        // All threads stopped, all thread handles closed.  Now
        // delete the critical section and close the semaphore
        // handle.
        //

        DeleteCriticalSection( &WorkQueue->CriticalSection );
        CloseHandle( WorkQueue->Semaphore );
        }

    //
    // Everything done, now free the memory used by the work queue.
    //

    LocalFree( WorkQueue );
    return;
}

BOOL
QueueWorkItem(
    IN OUT PWORK_QUEUE WorkQueue,
    IN PWORK_QUEUE_ITEM WorkItem
    )

/*++

Routine Description:

    This function queues a work item to the passed work queue that is
    processed by one of the worker threads associated with the queue.

Arguments:

    WorkQueue - Supplies a pointer to the work queue that is to
        receive the work item.

    WorkItem - Supplies a pointer to the work item to add the the queue.
        The work item structure contains a doubly linked list entry, the
        address of a routine to call and a parameter to pass to that
        routine.  It is the routine's responsibility to reclaim the
        storage occupied by the WorkItem structure.

Return Value:

    TRUE if operation was successful.  Otherwise returns FALSE and
    extended error information is available from GetLastError()

--*/

{
    BOOL Result;

    //
    // Acquire the work queue critical section and insert the work item
    // in the queue and release the semaphore if the work item is not
    // already in the list.
    //

    EnterCriticalSection( &WorkQueue->CriticalSection );
    Result = TRUE;
    _try {
        WorkItem->WorkQueue = WorkQueue;
        InsertTailList( &WorkQueue->Queue, &WorkItem->List );
        Result = ReleaseSemaphore( WorkQueue->Semaphore, 1, NULL );
        }
    _finally {
        LeaveCriticalSection( &WorkQueue->CriticalSection );
        }

    return Result;
}

DWORD
WorkerThread(
    LPVOID lpThreadParameter
    )
{
    PWORK_QUEUE WorkQueue = (PWORK_QUEUE)lpThreadParameter;
    DWORD rc;
    WORK_QUEUE_ITEM InitWorkItem;
    PWORK_QUEUE_ITEM WorkItem;

    //
    // Call the worker routine with an initialize work item
    // to give it a change to initialize some per thread
    // state that will passed to it for each subsequent
    // work item.
    //

    InitWorkItem.Reason = WORK_INITIALIZE_ITEM;
    (WorkQueue->WorkerRoutine)( &InitWorkItem );
    while( TRUE ) {
        _try {

            //
            // Wait until something is put in the queue (semaphore is
            // released), remove the item from the queue, mark it not
            // inserted, and execute the specified routine.
            //

            rc = WaitForSingleObjectEx( WorkQueue->Semaphore, 0xFFFFFFFF, TRUE );
            if (rc == WAIT_IO_COMPLETION) {
                continue;
                }

            EnterCriticalSection( &WorkQueue->CriticalSection );
            _try {
                if (WorkQueue->Terminating && IsListEmpty( &WorkQueue->Queue )) {
                    break;
                    }

                WorkItem = (PWORK_QUEUE_ITEM)RemoveHeadList( &WorkQueue->Queue );
                }
            _finally {
                LeaveCriticalSection( &WorkQueue->CriticalSection );
                }

            //
            // Execute the worker routine for this work item.
            //

            (WorkQueue->WorkerRoutine)( WorkItem );
            }
        _except( EXCEPTION_EXECUTE_HANDLER ) {
            //
            // Ignore any exceptions from worker routine.
            //
            }
        }

    InitWorkItem.Reason = WORK_TERMINATE_ITEM;
    (WorkQueue->WorkerRoutine)( &InitWorkItem );

    ExitThread( 0 );
    return 0;       // This will exit this thread
}

BOOL
CreateVirtualBuffer(
    OUT PVIRTUAL_BUFFER Buffer,
    IN SIZE_T CommitSize,
    IN SIZE_T ReserveSize OPTIONAL
    )

/*++

Routine Description:

    This function is called to create a virtual buffer.  A virtual
    buffer is a contiguous range of virtual memory, where some initial
    prefix portion of the memory is committed and the remainder is only
    reserved virtual address space.  A routine is provided to extend the
    size of the committed region incrementally or to trim the size of
    the committed region back to some specified amount.

Arguments:

    Buffer - Pointer to the virtual buffer control structure that is
        filled in by this function.

    CommitSize - Size of the initial committed portion of the buffer.
        May be zero.

    ReserveSize - Amount of virtual address space to reserve for the
        buffer.  May be zero, in which case amount reserved is the
        committed size plus one, rounded up to the next 64KB boundary.

Return Value:

    TRUE if operation was successful.  Otherwise returns FALSE and
    extended error information is available from GetLastError()

--*/

{
    SYSTEM_INFO SystemInformation;

    //
    // Query the page size from the system for rounding
    // our memory allocations.
    //

    GetSystemInfo( &SystemInformation );
    Buffer->PageSize = SystemInformation.dwPageSize;

    //
    // If the reserve size was not specified, default it by
    // rounding up the initial committed size to a 64KB
    // boundary.  This is because the Win32 Virtual Memory
    // API calls always allocate virtual address space on
    // 64KB boundaries, so we might well have it available
    // for commitment.
    //

    if (!ARGUMENT_PRESENT( ReserveSize )) {
        ReserveSize = ROUND_UP( CommitSize + 1, 0x10000 );
        }

    //
    // Attempt to reserve the address space.
    //

    Buffer->Base = VirtualAlloc( NULL,
                                 ReserveSize,
                                 MEM_RESERVE,
                                 PAGE_READWRITE
                               );
    if (Buffer->Base == NULL) {
        //
        // Unable to reserve address space, return failure.
        //

        return FALSE;
        }

    //
    // Attempt to commit some initial portion of the reserved region.
    //
    //

    CommitSize = ROUND_UP( CommitSize, Buffer->PageSize );
    if (CommitSize == 0 ||
        VirtualAlloc( Buffer->Base,
                      CommitSize,
                      MEM_COMMIT,
                      PAGE_READWRITE
                    ) != NULL
       ) {
        //
        // Either the size of the committed region was zero or the
        // commitment succeeded.  In either case calculate the
        // address of the first byte after the committed region
        // and the address of the first byte after the reserved
        // region and return successs.
        //

        Buffer->CommitLimit = (LPVOID)
            ((char *)Buffer->Base + CommitSize);

        Buffer->ReserveLimit = (LPVOID)
            ((char *)Buffer->Base + ReserveSize);

        return TRUE;
        }

    //
    // If unable to commit the memory, release the virtual address
    // range allocated above and return failure.
    //

    VirtualFree( Buffer->Base, 0, MEM_RELEASE );
    return FALSE;
}



BOOL
ExtendVirtualBuffer(
    IN PVIRTUAL_BUFFER Buffer,
    IN LPVOID Address
    )

/*++

Routine Description:

    This function is called to extend the committed portion of a virtual
    buffer.

Arguments:

    Buffer - Pointer to the virtual buffer control structure.

    Address - Byte at this address is committed, along with all memory
        from the beginning of the buffer to this address.  If the
        address is already within the committed portion of the virtual
        buffer, then this routine does nothing.  If outside the reserved
        portion of the virtual buffer, then this routine returns an
        error.

        Otherwise enough pages are committed so that the memory from the
        base of the buffer to the passed address is a contiguous region
        of committed memory.


Return Value:

    TRUE if operation was successful.  Otherwise returns FALSE and
    extended error information is available from GetLastError()

--*/

{
    SIZE_T NewCommitSize;
    LPVOID NewCommitLimit;

    //
    // See if address is within the buffer.
    //

    if (Address >= Buffer->Base && Address < Buffer->ReserveLimit) {
        //
        // See if the address is within the committed portion of
        // the buffer.  If so return success immediately.
        //

        if (Address < Buffer->CommitLimit) {
            return TRUE;
            }

        //
        // Address is within the reserved portion.  Determine how many
        // bytes are between the address and the end of the committed
        // portion of the buffer.  Round this size to a multiple of
        // the page size and this is the amount we will attempt to
        // commit.
        //

        NewCommitSize =
            (ROUND_UP( (DWORD_PTR)Address + 1, Buffer->PageSize ) -
             (DWORD_PTR)Buffer->CommitLimit
            );

        //
        // Attempt to commit the memory.
        //

        NewCommitLimit = VirtualAlloc( Buffer->CommitLimit,
                                       NewCommitSize,
                                       MEM_COMMIT,
                                       PAGE_READWRITE
                                     );
        if (NewCommitLimit != NULL) {
            //
            // Successful, so update the upper limit of the committed
            // region of the buffer and return success.
            //

            Buffer->CommitLimit = (LPVOID)
                ((DWORD_PTR)NewCommitLimit + NewCommitSize);

            return TRUE;
            }
        }

    //
    // Address is outside of the buffer, return failure.
    //

    return FALSE;
}


BOOL
TrimVirtualBuffer(
    IN PVIRTUAL_BUFFER Buffer
    )

/*++

Routine Description:

    This function is called to decommit any memory that has been
    committed for this virtual buffer.

Arguments:

    Buffer - Pointer to the virtual buffer control structure.

Return Value:

    TRUE if operation was successful.  Otherwise returns FALSE and
    extended error information is available from GetLastError()

--*/

{
    Buffer->CommitLimit = Buffer->Base;
    return VirtualFree( Buffer->Base, 0, MEM_DECOMMIT );
}



BOOL
FreeVirtualBuffer(
    IN PVIRTUAL_BUFFER Buffer
    )
/*++

Routine Description:

    This function is called to free all the memory that is associated
    with this virtual buffer.

Arguments:

    Buffer - Pointer to the virtual buffer control structure.

Return Value:

    TRUE if operation was successful.  Otherwise returns FALSE and
    extended error information is available from GetLastError()

--*/

{
    //
    // Decommit and release all virtual memory associated with
    // this virtual buffer.
    //

    return VirtualFree( Buffer->Base, 0, MEM_RELEASE );
}



int
VirtualBufferExceptionFilter(
    IN DWORD ExceptionCode,
    IN PEXCEPTION_POINTERS ExceptionInfo,
    IN OUT PVIRTUAL_BUFFER Buffer
    )

/*++

Routine Description:

    This function is an exception filter that handles exceptions that
    referenced uncommitted but reserved memory contained in the passed
    virtual buffer.  It this filter routine is able to commit the
    additional pages needed to allow the memory reference to succeed,
    then it will re-execute the faulting instruction.  If it is unable
    to commit the pages, it will execute the callers exception handler.

    If the exception is not an access violation or is an access
    violation but does not reference memory contained in the reserved
    portion of the virtual buffer, then this filter passes the exception
    on up the exception chain.

Arguments:

    ExceptionCode - Reason for the exception.

    ExceptionInfo - Information about the exception and the context
        that it occurred in.

    Buffer - Points to a virtual buffer control structure that defines
        the reserved memory region that is to be committed whenever an
        attempt is made to access it.

Return Value:

    Exception disposition code that tells the exception dispatcher what
    to do with this exception.  One of three values is returned:

        EXCEPTION_EXECUTE_HANDLER - execute the exception handler
            associated with the exception clause that called this filter
            procedure.

        EXCEPTION_CONTINUE_SEARCH - Continue searching for an exception
            handler to handle this exception.

        EXCEPTION_CONTINUE_EXECUTION - Dismiss this exception and return
            control to the instruction that caused the exception.


--*/

{
    LPVOID FaultingAddress;

    //
    // If this is an access violation touching memory within
    // our reserved buffer, but outside of the committed portion
    // of the buffer, then we are going to take this exception.
    //

    if (ExceptionCode == STATUS_ACCESS_VIOLATION) {
        //
        // Get the virtual address that caused the access violation
        // from the exception record.  Determine if the address
        // references memory within the reserved but uncommitted
        // portion of the virtual buffer.
        //

        FaultingAddress = (LPVOID)ExceptionInfo->ExceptionRecord->ExceptionInformation[ 1 ];
        if (FaultingAddress >= Buffer->CommitLimit &&
            FaultingAddress <= Buffer->ReserveLimit
           ) {
            //
            // This is our exception.  Try to extend the buffer
            // to including the faulting address.
            //

            if (ExtendVirtualBuffer( Buffer, FaultingAddress )) {
                //
                // Buffer successfully extended, so re-execute the
                // faulting instruction.
                //

                return EXCEPTION_CONTINUE_EXECUTION;
                }
            else {
                //
                // Unable to extend the buffer.  Stop copying
                // for exception handlers and execute the caller's
                // handler.
                //

                return EXCEPTION_EXECUTE_HANDLER;
                }
            }
        }

    //
    // Not an exception we care about, so pass it up the chain.
    //

    return EXCEPTION_CONTINUE_SEARCH;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\consume\disk.cxx ===
//                                          
// Universal Resource Consumer: Just an innocent stress program
// Copyright (c) Microsoft Corporation, 1997, 1998, 1999
//

//
// module: disk.cxx
// author: silviuc
// created: Mon Apr 13 14:02:12 1998
//

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <windows.h>

#include "error.hxx"
#include "disk.hxx"
#include "consume.hxx"

//
// Table of contents (local functions)
//

static DWORD ConvertToMbytes (PULARGE_INTEGER Size);

//
// Function:
//
//     ConsumeAllDiskSpace
//
// Description:
//
//     This function consumes all disk space on the current
//     partition (the one from which `consume' has been launched).
//

void ConsumeAllDiskSpace ()
{
    ULARGE_INTEGER TotalDiskSize;
    ULARGE_INTEGER FreeDiskSize;
    ULARGE_INTEGER UserFreeSize;
    ULARGE_INTEGER RequestSize;
    HANDLE File;
    HANDLE Mapping;
    BOOL Result;
    ULONG uLastBitMask;

    //
    // Get disk space information
    //

    Result = GetDiskFreeSpaceEx (
        NULL, // current directory
        & UserFreeSize,
        & TotalDiskSize,
        & FreeDiskSize);

    if (Result == FALSE) {
        Error ("GetDiskFreeSpaceEx() failed: error %u",
            GetLastError());
    }

    Message ("Total disk space:         %u Mb", ConvertToMbytes (& TotalDiskSize));
    Message ("Free disk space:          %u Mb", ConvertToMbytes (& FreeDiskSize));
    Message ("Free per user space:      %u Mb", ConvertToMbytes (& UserFreeSize));

    //
    // Compute the request size
    //

    RequestSize.QuadPart = UserFreeSize.QuadPart;
    Message ("Attempting to use:        %u Mb", ConvertToMbytes (& RequestSize));

    //
    // Don't allow a size that assigned to a LARGE_INTEGER will result
    // in a negative number
    //

    uLastBitMask = 1 << ( sizeof( uLastBitMask ) * 8 - 1 );
    RequestSize.HighPart &= ~uLastBitMask;

    //
    // Create a file
    //

    File = CreateFile (
        TEXT ("consume.dsk"),
        GENERIC_READ | GENERIC_WRITE,
        0,                              // no sharing
        NULL,                           // default security
        CREATE_ALWAYS,
        FILE_FLAG_DELETE_ON_CLOSE,
        NULL);                          // default template file

    if (File == INVALID_HANDLE_VALUE)
        Error ("CreateFile (`consume.dsk') failed: error %u",
            GetLastError());

    //
    // Create a mapping file on top of the file.
    //

    for ( ; RequestSize.QuadPart > 0 ; ) {
        Mapping = CreateFileMapping (
            File,
            NULL,                 // default security
            PAGE_READWRITE,       // protection
            RequestSize.HighPart,
            RequestSize.LowPart,
            NULL);                // no name

        if (Mapping != NULL)
            break;

        if ( RequestSize.QuadPart >  0x10000 ) {
            RequestSize.QuadPart -= 0x10000;
        }
        else {
            break;
        }

        Message ("Reattempting to use:      %u Mb", ConvertToMbytes (& RequestSize));
    }
}

//
// Function:
//
//     ConvertToMbytes
//
// Description:
//
//     Converts a size to Mbytes so that we can print more user-friendly
//     values.
//

static DWORD 
    ConvertToMbytes (

    PULARGE_INTEGER Size)
{
    return(DWORD)(Size->QuadPart >> 20);
}


//
// end of module: disk.cxx
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\consume\cputime.cxx ===
//
// Universal Resource Consumer: Just an innocent stress program
// Copyright (c) Microsoft Corporation, 1997, 1998, 1999
//

//
// module: cputime.cxx
// author: silviuc
// created: Wed Jun 17 18:48:56 1998
//

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <windows.h>

#include "error.hxx"
#include "cputime.hxx"
#include "consume.hxx"

//
// Function:
//
//     ThreadVirtualMemoryStuff
//
// Description:
//
//     This function is run by some consumer threads.
//     It is supposed to perform alloc/free cycles in order
//     to keep the memory manager busy.
//

#if _MSC_FULL_VER >= 13008827
#pragma warning(push)
#pragma warning(disable:4715)			// Not all control paths return (due to infinite loop)
#endif
static DWORD
ThreadVirtualMemoryStuff (LPVOID)
{
    PVOID Address;

    for ( ; ; )
      {
        //
        // Allocate a normal space 64K chunk, touch it in
        // one page and then free it.
        //

        Address = (PVOID)(UINT_PTR)(( rand() << 16) | rand());

        try
          {
            Address = VirtualAlloc (
                Address,
                0x10000,
                MEM_RESERVE | MEM_COMMIT,
                PAGE_READWRITE);

            if (Address) {

                *((DWORD *)Address) = 0xAABBCCDD;

                VirtualFree (
                    Address,
                    0,
                    MEM_RELEASE);
            }
          }
        catch (...)
          {
            Message ("VirtualAlloc/Free scenario raised exception");
          }

      } // for ( ; ; )

    //
    // Make compiler happy.
    //

    return 0;
}

#if _MSC_FULL_VER >= 13008827
#pragma warning(pop)
#endif

//
// Function:
//
//     ThreadVolumeInformationStuff
//
// Description:
//
//     This function is run by some consumer threads.
//     It is supposed to call GetVolumeInformation in a loop.
//     This makes some calls inside the I/O manager.
//

#if _MSC_FULL_VER >= 13008827
#pragma warning(push)
#pragma warning(disable:4715)			// Not all control paths return (due to infinite loop)
#endif
static DWORD
ThreadVolumeInformationStuff (LPVOID)
{
    for ( ; ; )
      {
        TCHAR Name [MAX_PATH];
        DWORD SerialNumber;
        DWORD MaxNameLength;
        DWORD FileSystemFlags;
        TCHAR FileSystemName [MAX_PATH];

        try {

            GetVolumeInformation (
                NULL,
                Name,
                MAX_PATH,
                & SerialNumber,
                & MaxNameLength,
                & FileSystemFlags,
                FileSystemName,
                MAX_PATH);
        }
        catch (...) {
            Message ("GetVolumeInformation scenario raised exception");
        }
      }

    //
    // Make compile rhappy.
    //

    return 0;
}
#if _MSC_FULL_VER >= 13008827
#pragma warning(pop)
#endif


//
// Global:
//
//     ThreadFunction
//
// Description:
//
//     This is a vector containing all thread functions available.
//     We will pick at random from here when we want to create
//     a thread.
//

static LPTHREAD_START_ROUTINE
ThreadFunction [] =
{
    ThreadVirtualMemoryStuff,
    ThreadVolumeInformationStuff
};

//
// Function:
//
//     ConsumeAllCpuTime
//
// Description:
//
//     This function will try to swamp the system with threads.
//     The "swamp" calculation is very simple. For every processor
//     we create 128 threads having normal priority.
//

void ConsumeAllCpuTime ()
{
    DWORD MaxThreadCount;
    DWORD MaxThreadFunction;
    SYSTEM_INFO SystemInfo;
    DWORD Index;

    //
    // Decide how many threads we should attempt to start.
    // Every processor will add 128 threads.
    //

    GetSystemInfo (& SystemInfo);
    MaxThreadCount = 128 * SystemInfo.dwNumberOfProcessors;
    Message ("Attempting to start %u threads ...", MaxThreadCount);

    //
    // Create all threads required. If we fail to create a thread due
    // to low memory conditions we will wait in a tight loop for better
    // conditions.
    //

    MaxThreadFunction = (sizeof ThreadFunction) / (sizeof ThreadFunction[0]);

    for (Index = 0; Index < MaxThreadCount; Index++)
      {
        HANDLE Thread;
        DWORD ThreadId;
        DWORD FunctionIndex;

        do
          {
            try {

                FunctionIndex = rand() % MaxThreadFunction;
                // Message ("Index function %u", FunctionIndex);

                Thread = CreateThread (
                    NULL,
                    0,
                    ThreadFunction [FunctionIndex],
                    NULL,
                    0,
                    & ThreadId);

                CloseHandle (Thread);
            }
            catch (...) {
                Message ("CreateThread() raised exception");
            }
          }
        while (Thread == NULL);

        printf (".");
      }

    printf("\n");
}

//
// end of module: cputime.cxx
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\consume\error.cxx ===
//
// Universal Resource Consumer: Just an innocent stress program
// Copyright (c) Microsoft Corporation, 1997, 1998, 1999
//

//
// module: error.cxx
// author: silviuc
// created: Fri Apr 10 14:30:35 1998
//

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <windows.h>

#include "error.hxx"

//
// Variable:
//
//     ReportingModuleInitialized
//
// Description:
//
//     This boolean is false if none of the error reporting
//     functions have been called. True otherwise. Every reporting
//     function checks this value first and if it is false, then it
//     initiates the module setup.
//

static BOOL ReportingModuleInitialized = FALSE;

//
// Variable:
//
//     ErrorReportingLock
//
// Description:
//
//     All error reporting functions acquire this lock before printing
//     anything.
//

static CRITICAL_SECTION ErrorReportingLock;

//
// Variable:
//
//     DebugReportingLock
//
// Description:
//
//     All debug reporting functions acquire this lock before printing
//     anything into debugger.
//

static CRITICAL_SECTION DebugReportingLock;

//
// Function:
//
//     CheckIfModuleIsInitialized
//
// Description:
//
//     This function is called whenever an error reporting function is called.
//     If module is not initialized then we do that.
//

static void
CheckIfModuleIsInitialized ()
{
    if (ReportingModuleInitialized == FALSE) {
        InitializeCriticalSection (& ErrorReportingLock);
        InitializeCriticalSection (& DebugReportingLock);
        ReportingModuleInitialized = TRUE;
    }
}

//
// Function:
//
//     Error
//
// Description:
//
//     Printf like function that prints an error message and exits
//     with error code 1.
//

void
__cdecl
Error (char *fmt, ...)
{
    va_list prms;

    CheckIfModuleIsInitialized ();
    EnterCriticalSection (& ErrorReportingLock);

    va_start (prms, fmt);
    printf ("Consume: Error: ");
    vprintf (fmt, prms);
    printf("\n");
    va_end (prms);

    LeaveCriticalSection (& ErrorReportingLock);
    exit (1);
}

//
// Function:
//
//     Warning
//
// Description:
//
//     Printf like function that print a warning message.
//

void
__cdecl
Warning (char *fmt, ...)
{
    va_list prms;

    CheckIfModuleIsInitialized ();
    EnterCriticalSection (& ErrorReportingLock);

    va_start (prms, fmt);
    printf ("Consume: Warning: ");
    vprintf (fmt, prms);
    printf("\n");
    va_end (prms);

    LeaveCriticalSection (& ErrorReportingLock);
}

//
// Function:
//
//     Message
//
// Description:
//
//     Printf like function that prints a message.
//

void
__cdecl
Message (char *fmt, ...)
{
    va_list prms;

    CheckIfModuleIsInitialized ();
    EnterCriticalSection (& ErrorReportingLock);

    va_start (prms, fmt);
    printf ("Consume: Message: ");
    vprintf (fmt, prms);
    printf("\n");
    va_end (prms);

    LeaveCriticalSection (& ErrorReportingLock);
}

//
// Function:
//
//     DebugMessage
//
// Description:
//
//     Printf like function that prints a message into debugger.
//

void
__cdecl
DebugMessage (char *fmt, ...)
{
    va_list prms;
    TCHAR Buffer [1024];
    TCHAR SecondBuffer [1024];

    CheckIfModuleIsInitialized ();
    EnterCriticalSection (& DebugReportingLock);

    va_start (prms, fmt);
    vsprintf (Buffer, fmt, prms);
    sprintf (SecondBuffer, "%s %s\n", "Consume: Debug: ", Buffer);
    OutputDebugString (SecondBuffer);
    va_end (prms);

    LeaveCriticalSection (& DebugReportingLock);
}

//
// end of module: error.cxx
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\consume\consume.cxx ===
//                                          
// Universal Resource Consumer: Just an innocent stress program
// Copyright (c) Microsoft Corporation, 1997, 1998, 1999
//

//
// module: consume.cxx
// author: silviuc
// created: Fri Apr 10 14:32:17 1998
//
// history:
//      johnfu  added/modfied -paged-pool and -nonpaged-pool
//              removed -paged-pool-bad and -nonpaged-pool-bad
//

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <time.h>
#include <windows.h>

#include "error.hxx"
#include "physmem.hxx"
#include "pagefile.hxx"
#include "pool.hxx"
#include "disk.hxx"
#include "cputime.hxx"
#include "consume.hxx"

#define Main main

VOID CreatePhysicalMemoryConsumers ();
VOID CreatePageFileConsumers ();
VOID CreateKernelPoolConsumers ();

//
// Table of contents (local functions)
//

static void SleepSomeTime (DWORD TimeOut, HANDLE Job);
static void Help ();

static char * * 
SearchCmdlineOption (

    char * Search,
    char * * Options);

#define SIZE_1_GB 0x40000000

//
// Function:
//
//     Main
//
// Description:
//
//     Main function.
//

void _cdecl
    Main (

    int argc,
    char *argv [])
{
    DWORD TimeOut = INFINITE;
    HANDLE Job = NULL;
    BOOL Result;
    
    //
    // Is help requested?
    //

    if (argc == 1 
        || (argc == 2 && strcmp (argv[1], "?") == 0)
        || (argc == 2 && strcmp (argv[1], "/?") == 0)
        || (argc == 2 && strcmp (argv[1], "-?") == 0)
        || (argc == 2 && strcmp (argv[1], "-h") == 0)
        || (argc == 2 && strcmp (argv[1], "/h") == 0)
        || (argc == 2 && strcmp (argv[1], "-help") == 0)) {
        Help ();
    }   

    //
    // Randomize the seed.
    //

    srand ((unsigned)time(0));

    //
    // Create a job object and assign it to itself. This will help
    // terminating baby consumer processes. However the assign will
    // fail if the consumer is already inside a job object (e.g. dks
    // scheduler).
    //

    Job = CreateJobObject (0, 0);
    Result = AssignProcessToJobObject (Job, GetCurrentProcess());

    if (Job && Result) {
        Message ("Successfully assigned process to a job object ...");
    }

    //
    // Figure out if a time out parameter has been specified.
    //

    {
        char * * Option;

        Option = SearchCmdlineOption ("-time", argv);

        if (Option && *(Option + 1)) {
            TimeOut = atoi (*(Option + 1));
            Message ("Time out after %u seconds.", TimeOut);
            TimeOut *= 1000;
        }
    }

    //
    // Parse command line. For every command we execute the consumption
    // scenario and then we sleep forever with the resource hold.
    //

    if (SearchCmdlineOption ("-disk-space", argv)) {
        ConsumeAllDiskSpace ();
        SleepSomeTime (TimeOut, Job);
    }
    else if (SearchCmdlineOption ("-cpu-time", argv)) {
        ConsumeAllCpuTime ();
        SleepSomeTime (TimeOut, Job);
    }
    else if (SearchCmdlineOption ("-kernel-pool", argv)) {
        CreateKernelPoolConsumers ();
        SleepSomeTime (TimeOut, Job);
    }
    else if (SearchCmdlineOption ("-physical-memory", argv)) {
        CreatePhysicalMemoryConsumers ();
        SleepSomeTime (TimeOut, Job);
    }
    else if (SearchCmdlineOption ("-page-file", argv)) {
        CreatePageFileConsumers ();
        SleepSomeTime (TimeOut, Job);
    }
    else if (SearchCmdlineOption ("-physical-memory-worker", argv)) {
        ConsumeAllPhysicalMemory ();
        SleepSomeTime (TimeOut, Job);
    }
    else if (SearchCmdlineOption ("-page-file-worker", argv)) {
        ConsumeAllPageFile ();
        SleepSomeTime (TimeOut, Job);
    }
    else if (SearchCmdlineOption ("-kernel-pool-worker", argv)) {
        ConsumeAllNonpagedPool ();
        SleepSomeTime (TimeOut, Job);
    }
    else {
        Help ();
    }
}

//
// Function:
//
//     SleepSomeTime
//
// Description:
//
//     Sleeps forever.
//

static void
    SleepSomeTime (
        
        DWORD TimeOut,
        HANDLE Job)
{
    Message ("Sleeping ...");
    fflush (stdout);

    if (TimeOut == INFINITE) {
        while (1) {
            Sleep (10000);
        }
    }
    else {

        Sleep (TimeOut);

        if (Job) {
            TerminateJobObject (Job, 0xAABBBBAA);
        }
    }
}

//
// Function:
//
//     Help
//
// Description:
//
//     Prints help information to stdout.
//

static void
    Help ()
{
    printf (
        "Universal Resource Consumer - Just an innocent stress program, v 0.1.0 \n"
        "Copyright (c) 1998, 1999, Microsoft Corporation                        \n"
        "                                                                       \n"
        "    consume RESOURCE [-time SECONDS]                                   \n"
        "                                                                       \n"
        "RESOURCE can be one of the following:                                  \n"
        "                                                                       \n"
        "    -physical-memory                                                   \n"
        "    -page-file                                                         \n"
        "    -disk-space                                                        \n"
        "    -cpu-time                                                          \n"
        "    -kernel-pool                                                       \n"
        "                                                                       \n");

    exit (1);
}

//
// Function:
//
//     SearchCmdlineOption
//
// Description:
//
//     Helper function for cmdline parsing.
//

static char * * 
SearchCmdlineOption (

    char * Search,
    char * * Options)
{
    for ( ; *Options; Options++) {
        if (_stricmp (Search, *Options) == 0) {
            return Options;
        }
    }

    return NULL;
}

//////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////// Baby consumer creation
//////////////////////////////////////////////////////////////////////

//
// Function:
//
//     CreateBabyConsumer
//
// Description:
//
//     This function calls CreateProcess() with the command line
//     specified. This is used by some consumers that cannot eat
//     completely a resource from only one process. Typical examples
//     are physical memory and page file. Essentially in one process
//     you can consume up to 2Gb therefore we need more processes
//     for machines that have more than 2Gb of RAM.
//

BOOL
    CreateBabyConsumer (

    LPTSTR CommandLine)
{
    BOOL Result;
    TCHAR CmdLine [MAX_PATH];
    STARTUPINFO StartInfo;
    PROCESS_INFORMATION ProcessInfo;

    strcpy (CmdLine, CommandLine);
    ZeroMemory (&StartInfo, sizeof StartInfo);
    ZeroMemory (&ProcessInfo, sizeof ProcessInfo);
    StartInfo.cb = sizeof StartInfo;

    Result = CreateProcess (
        NULL,
        CmdLine,
        NULL,
        NULL,
        0,
        CREATE_NEW_CONSOLE,
        NULL,
        NULL,
        & StartInfo,
        & ProcessInfo);

    CloseHandle (ProcessInfo.hThread);
    CloseHandle (ProcessInfo.hProcess);

    return Result;
}

//
// Function:
//
//     CreatePhysicalMemoryConsumers
// 
// Description:
//
//     This function launches enough physical memory
//     consumer processes to insure that the whole physical
//     memory gets used.
//

VOID
CreatePhysicalMemoryConsumers () 
{
    MEMORYSTATUSEX MemoryInfo;
    DWORD Consumers;
    DWORD Index;

    ZeroMemory (&MemoryInfo, sizeof MemoryInfo);
    MemoryInfo.dwLength = sizeof MemoryInfo;
    GlobalMemoryStatusEx (&MemoryInfo);

    //
    // We will attempt to create a consumer for every 256Mb of physical
    // memory.
    //

    Consumers = 1 + (DWORD)(MemoryInfo.ullTotalPhys / SIZE_1_GB) * 4;

    Message ("Total physical memory: %I64X", MemoryInfo.ullTotalPhys);
    Message ("Available physical memory: %I64X", MemoryInfo.ullAvailPhys);
    Message ("Will attempt to create %u baby consumers ...", Consumers);

    for (Index = 0; Index < Consumers; Index++)
        if (CreateBabyConsumer ("consume -physical-memory-worker") == FALSE)
            Warning ("Cannot create baby consumer `-physical-memory-worker'");
}

//
// Function:
//
//     CreatePageFileConsumers
// 
// Description:
//
//     This function launches enough page file
//     consumer processes to insure that the whole page file
//     gets used.
//

VOID
CreatePageFileConsumers ()
{
    MEMORYSTATUSEX MemoryInfo;
    DWORD Consumers;
    DWORD Index;

    ZeroMemory (&MemoryInfo, sizeof MemoryInfo);
    MemoryInfo.dwLength = sizeof MemoryInfo;
    GlobalMemoryStatusEx (&MemoryInfo);

    //
    // We will attempt to create a consumer for every 256Mb of page file
    //

    Consumers = 1 + (DWORD)(MemoryInfo.ullTotalPageFile / SIZE_1_GB) * 4;

    Message ("Total page file: %I64X", MemoryInfo.ullTotalPageFile);
    Message ("Available page file: %I64X", MemoryInfo.ullAvailPageFile);
    Message ("Will attempt to create %u baby consumers ...", Consumers);

    for (Index = 0; Index < Consumers; Index++)
        if (CreateBabyConsumer ("consume -page-file-worker") == FALSE)
            Warning ("Cannot create baby consumer `-page-file-worker'");
}

//
// Function:
//
//     CreateKernelPoolConsumers
// 
// Description:
//
//     This function launches enough kernel pool
//     consumer processes to insure that the whole 
//     non paged pool gets used.
//

VOID
CreateKernelPoolConsumers ()
{
    DWORD Consumers;
    DWORD Index;

    //
    // We will attempt to create 4 consumers
    //

    Consumers = 4;

    for (Index = 0; Index < Consumers; Index++)
        if (CreateBabyConsumer ("consume -kernel-pool-worker") == FALSE)
            Warning ("Cannot create baby consumer `-kernel-pool-worker'");
}

//
// end of module: consume.cxx
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\consume\pagefile.cxx ===
//                                          
// Universal Resource Consumer: Just an innocent stress program
// Copyright (c) Microsoft Corporation, 1997, 1998, 1999
//

//
// module: pagefile.cxx
// author: silviuc
// created: Fri Apr 10 16:01:57 1998
//

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <windows.h>

#include "error.hxx"
#include "pagefile.hxx"
#include "consume.hxx"

//
// Function:
//
//     ConsumeAllPageFile
//
// Description:
//
//     This function consumes as much page file as possible.
//     It remains active as a consumer of the page file. Whenever
//     it cannot allocate anymore it sleeps for a while then tries 
//     again.
//

void ConsumeAllPageFile ()
{
    MEMORYSTATUSEX MemoryInfo;
    LPVOID Region;
    SIZE_T RegionSize;
    DWORD Count;
    
    //
    // Try to eat page file. This will go on forever in the sense 
    // that the moment somebody frees some memory we will eat it 
    // immediately.
    //
    
    for (Count = 0, RegionSize = 0x100000; ; )
      {
        Region = VirtualAlloc (
            NULL,
            RegionSize,
            MEM_COMMIT,
            PAGE_READWRITE);

        if (Region == NULL)
          {
            Sleep (1000);
            
            //
            // We've got an allocation error. 
            // Switch to 64K chunks and try again.
            //

            RegionSize = 0x10000;
            continue;
          }
        else
          {
            if (++Count % 16 == 0)
                printf (".");
          }
      }
}

//
// end of module: pagefile.cxx
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\consume\pool.cxx ===
//                                          
// Universal Resource Consumer: Just an innocent stress program
// Copyright (c) Microsoft Corporation, 1997
//

//
// module: pool.cxx
// author: silviuc
// created: Fri Apr 10 16:44:29 1998
//


#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <windows.h>

#include "error.hxx"
#include "pool.hxx"
#include "consume.hxx"

//
// Function:
//
//     ConsumeAllNonpagedPool
//
// Description:
//
//     This function consumes as much non paged pool as possible.
//

void
ConsumeAllNonpagedPool ()
{
    DWORD Count;

    //
    // For ever loop to consume nonpaged pool
    //

    for (Count = 0; ; )
      {
        if (CreateEvent (0, 0, 0, 0) == NULL)
          {
            Sleep (1000);
          }
        else
          {
            if (++Count % 1024 == 0)
                printf (".");
          }
      }
}

//
// end of module: pool.cxx
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\compdir\link.c ===
#define UNICODE
#define _UNICODE

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <tchar.h>

#include "compdir.h"

#define SHARE_ALL   (FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE)
#define lstrchr wcschr

typedef VOID     (*RtlFreeUnicodeStringFunction)();
typedef ULONG    (*RtlNtStatusToDosErrorFunction)();
typedef NTSTATUS (*NtCloseFunction)();
typedef NTSTATUS (*NtSetInformationFileFunction)();
typedef VOID     (*RtlInitUnicodeStringFunction)();
typedef NTSTATUS (*NtOpenFileFunction)();
typedef BOOLEAN  (*RtlCreateUnicodeStringFromAsciizFunction)();
typedef NTSTATUS (*NtQueryInformationFileFunction)();
typedef NTSTATUS (*NtFsControlFileFunction)();
typedef NTSTATUS (*RtlDosPathNameToNtPathName_UFunction)();

RtlFreeUnicodeStringFunction             CDRtlFreeUnicodeString;
RtlNtStatusToDosErrorFunction            CDRtlNtStatusToDosError;
NtCloseFunction                          CDNtClose;
NtSetInformationFileFunction             CDNtSetInformationFile;
RtlInitUnicodeStringFunction             CDRtlInitUnicodeString;
NtOpenFileFunction                       CDNtOpenFile;
RtlCreateUnicodeStringFromAsciizFunction CDRtlCreateUnicodeStringFromAsciiz;
NtQueryInformationFileFunction           CDNtQueryInformationFile;
NtFsControlFileFunction                  CDNtFsControlFile;
RtlDosPathNameToNtPathName_UFunction     CDRtlDosPathNameToNtPathName_U;


BOOL InitializeNtDllFunctions()
{
    CDRtlFreeUnicodeString                 = (RtlFreeUnicodeStringFunction)             GetProcAddress( NtDll, "RtlFreeUnicodeString");
    if         (CDRtlFreeUnicodeString     == NULL) return FALSE;
    CDRtlNtStatusToDosError                = (RtlNtStatusToDosErrorFunction)            GetProcAddress( NtDll, "RtlNtStatusToDosError");
    if        (CDRtlNtStatusToDosError     == NULL) return FALSE;
    CDNtClose                              = (NtCloseFunction)                          GetProcAddress( NtDll, "NtClose");
    if                      (CDNtClose     == NULL) return FALSE;
    CDNtSetInformationFile                 = (NtSetInformationFileFunction)             GetProcAddress( NtDll, "NtSetInformationFile");
    if         (CDNtSetInformationFile     == NULL) return FALSE;
    CDRtlInitUnicodeString                 = (RtlInitUnicodeStringFunction)             GetProcAddress( NtDll, "RtlInitUnicodeString");
    if         (CDRtlInitUnicodeString     == NULL) return FALSE;
    CDNtOpenFile                           = (NtOpenFileFunction)                       GetProcAddress( NtDll, "NtOpenFile");
    if                   (CDNtOpenFile     == NULL) return FALSE;
    CDRtlCreateUnicodeStringFromAsciiz     = (RtlCreateUnicodeStringFromAsciizFunction) GetProcAddress( NtDll, "RtlCreateUnicodeStringFromAsciiz");
    if (CDRtlCreateUnicodeStringFromAsciiz == NULL) return FALSE;
    CDNtQueryInformationFile               = (NtQueryInformationFileFunction)           GetProcAddress( NtDll, "NtQueryInformationFile");
    if           (CDNtQueryInformationFile == NULL) return FALSE;
    CDNtFsControlFile = (NtFsControlFileFunction)GetProcAddress( NtDll, "NtFsControlFile");
    if (CDNtFsControlFile == NULL) return FALSE;
    CDRtlDosPathNameToNtPathName_U = (RtlDosPathNameToNtPathName_UFunction)GetProcAddress( NtDll, "RtlDosPathNameToNtPathName_U");
    if (CDRtlDosPathNameToNtPathName_U == NULL) return FALSE;
    return TRUE;
}

BOOL MakeLink( char *src, char *dst, BOOL Output)
{
    WCHAR                  OldNameBuf[MAX_PATH + 50];
    WCHAR                  NewNameBuf[MAX_PATH + 50];

    HANDLE                 FileHandle,
                           NewFileHandle,
                           RootDirHandle;

    NTSTATUS               Status;
    IO_STATUS_BLOCK        Iosb;
    OBJECT_ATTRIBUTES      Obj;

    PFILE_LINK_INFORMATION pLinkInfo;

    UNICODE_STRING         u,
                           uRel;

    WCHAR                  *pch, ch;
    UNICODE_STRING         uOldName;
    UNICODE_STRING         uNewName;

    UNICODE_STRING         uSrc, uDst;

    (CDRtlCreateUnicodeStringFromAsciiz)( &uSrc, src);
    (CDRtlCreateUnicodeStringFromAsciiz)( &uDst, dst);

    lstrcpy( OldNameBuf, L"\\??\\");
    lstrcat( OldNameBuf, uSrc.Buffer);
    (CDRtlInitUnicodeString)( &uOldName, OldNameBuf);

    lstrcpy( NewNameBuf, L"\\??\\");
    lstrcat( NewNameBuf, uDst.Buffer);
    (CDRtlInitUnicodeString)( &uNewName, NewNameBuf);

    //
    // Open the existing pathname.
    //

    InitializeObjectAttributes( &Obj, &uOldName, OBJ_CASE_INSENSITIVE, NULL, NULL);

    Status = (CDNtOpenFile)( &FileHandle, SYNCHRONIZE, &Obj, &Iosb,
        SHARE_ALL, FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT);

    if ( !NT_SUCCESS( Status))
    {
        SetLastError( ( CDRtlNtStatusToDosError)( Status));
        if ( Output)
        {
            fprintf( stderr, "Could not open %s", src);
        }
        return FALSE;
    }

    //
    // Now we need to get a handle on the root directory of the 'new'
    // pathname; we'll pass that in the link information, and the
    // rest of the path will be given relative to the root.  We
    // depend on paths looking like "\DosDevices\X:\path".
    //

    pch = lstrchr( uNewName.Buffer + 1, '\\');
    ASSERT( NULL != pch);
    pch = lstrchr( pch + 1, '\\');
    if (!pch) {
        SetLastError(ERROR_INVALID_PARAMETER);
        if ( Output)
        {
            fprintf( stderr, "Invalid path %S", uNewName.Buffer);
        }
        return FALSE;
    }
    ch = pch[1];
    pch[1] = '\0';
    uNewName.Length = (USHORT)(lstrlen( uNewName.Buffer) * sizeof( WCHAR));

    InitializeObjectAttributes( &Obj, &uNewName, OBJ_CASE_INSENSITIVE, NULL, NULL);

    Status = (CDNtOpenFile)( &RootDirHandle, SYNCHRONIZE, &Obj, &Iosb,
        SHARE_ALL, FILE_SYNCHRONOUS_IO_NONALERT | FILE_DIRECTORY_FILE);

    pch[1] = ch;

    if ( !NT_SUCCESS( Status))
    {
        SetLastError( (CDRtlNtStatusToDosError)( Status));
        if ( Output)
        {
            fprintf( stderr, "Could not get directory handle for %s", dst);
        }
        return FALSE;
    }

    //
    // Now get the path relative to the root.
    //

    (CDRtlInitUnicodeString)( &uRel, &pch[1]);

    pLinkInfo = _alloca( sizeof( *pLinkInfo) + uRel.Length);
    if ( NULL == pLinkInfo)
    {
        (CDNtClose)( RootDirHandle);
        (CDNtClose)( FileHandle);
        SetLastError( ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    RtlMoveMemory( pLinkInfo->FileName, uRel.Buffer, uRel.Length);
    pLinkInfo->FileNameLength = uRel.Length;

    pLinkInfo->ReplaceIfExists = TRUE;
    pLinkInfo->RootDirectory = RootDirHandle;

    Status = (CDNtSetInformationFile)( FileHandle, &Iosb, pLinkInfo,
        sizeof( *pLinkInfo) + uRel.Length, FileLinkInformation);

    // If file is already linked to an open file try to delete it

    if ( Status ==  STATUS_ACCESS_DENIED)
    {
        _unlink( dst);
        Status = (CDNtSetInformationFile)( FileHandle, &Iosb, pLinkInfo,
            sizeof( *pLinkInfo) + uRel.Length, FileLinkInformation);
    }

    (CDNtClose)( RootDirHandle);
    (CDNtClose)( FileHandle);

    if ( !NT_SUCCESS( Status))
    {
        SetLastError( (CDRtlNtStatusToDosError)( Status));
        if ( Output)
        {
            fprintf( stderr, "Could not create link for %s", dst);
        }
        return FALSE;
    }

    (CDRtlFreeUnicodeString)( &uSrc);
    (CDRtlFreeUnicodeString)( &uDst);

    return TRUE;


}

int NumberOfLinks( char *FileName)
{

    FILE_STANDARD_INFORMATION FileInfo;

    WCHAR                     FileNameBuf[MAX_PATH + 50];

    HANDLE                    FileHandle;

    NTSTATUS                  Status;

    IO_STATUS_BLOCK           Iosb;

    OBJECT_ATTRIBUTES         Obj;

    UNICODE_STRING            uPrelimFileName,
                              uFileName;

    (CDRtlCreateUnicodeStringFromAsciiz)( &uPrelimFileName, FileName);

    lstrcpy( FileNameBuf, L"\\??\\");
    lstrcat( FileNameBuf, uPrelimFileName.Buffer);
    (CDRtlInitUnicodeString)( &uFileName, FileNameBuf);

    InitializeObjectAttributes( &Obj, &uFileName, OBJ_CASE_INSENSITIVE, NULL, NULL);

    Status = (CDNtOpenFile)( &FileHandle, SYNCHRONIZE, &Obj, &Iosb,
        SHARE_ALL, FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT);

    if ( !NT_SUCCESS( Status))
    {
        SetLastError( (CDRtlNtStatusToDosError)( Status));
        return 0;
    }

    Status = (CDNtQueryInformationFile)( FileHandle, &Iosb, &FileInfo,
        sizeof( FileInfo), FileStandardInformation);

    (CDNtClose)( FileHandle);

    if ( !NT_SUCCESS( Status))
    {
        SetLastError( (CDRtlNtStatusToDosError)( Status));
        return 0;
    }

    return FileInfo.NumberOfLinks;


}

BOOL
SisCopyFile(
    LPCSTR lpExistingFileName,
    LPCSTR lpNewFileName,
    BOOL bFailIfExists,
    LPBOOL fTrySis
    )
{
    BOOL ok;
    DWORD err;
	NTSTATUS        Status;
	HANDLE          volHandle;
	UNICODE_STRING	srcFileName, dstFileName;
	UNICODE_STRING	srcDosFileName, dstDosFileName;
	PSI_COPYFILE	copyFile;
	UCHAR			Buffer[(sizeof(SI_COPYFILE) + MAX_PATH * 2) * sizeof(WCHAR)];
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK ioStatusBlock;
	int i;

	copyFile = (PSI_COPYFILE)Buffer;

    srcFileName.Buffer = NULL;
    dstFileName.Buffer = NULL;
    srcDosFileName.Buffer = NULL;
    srcDosFileName.Buffer = NULL;

    //
	// Convert the ansii names to unicode and place in the copyFile buffer.
    //

    ok = CDRtlCreateUnicodeStringFromAsciiz( &srcDosFileName, lpExistingFileName );
    if (!ok) {
        return FALSE;
    }
    ok = CDRtlDosPathNameToNtPathName_U( srcDosFileName.Buffer, &srcFileName, NULL, NULL );
    if (!ok) {
        goto error;
    }
    CDRtlFreeUnicodeString( &srcDosFileName );

    ok = CDRtlCreateUnicodeStringFromAsciiz( &dstDosFileName, lpNewFileName );
    if (!ok) {
        goto error;
    }
    ok = CDRtlDosPathNameToNtPathName_U( dstDosFileName.Buffer, &dstFileName, NULL, NULL );
    if (!ok) {
        goto error;
    }
    CDRtlFreeUnicodeString( &dstDosFileName );

	copyFile->SourceFileNameLength = srcFileName.Length + sizeof(WCHAR);
	copyFile->DestinationFileNameLength = dstFileName.Length + sizeof(WCHAR);
	copyFile->Flags = bFailIfExists ? 0 : COPYFILE_SIS_REPLACE;

	RtlCopyMemory(
		&copyFile->FileNameBuffer[0],
		srcFileName.Buffer,
		copyFile->SourceFileNameLength);

	RtlCopyMemory(
		&copyFile->FileNameBuffer[copyFile->SourceFileNameLength / sizeof(WCHAR)],
		dstFileName.Buffer,
		copyFile->DestinationFileNameLength);

    CDRtlFreeUnicodeString( &dstFileName );

#define	copyFileSize (FIELD_OFFSET(SI_COPYFILE, FileNameBuffer) +		\
					  copyFile->SourceFileNameLength +					\
					  copyFile->DestinationFileNameLength)

	//
	// Get a handle to the source file's containing directory to pass into
	// FSCTL_SIS_COPYFILE,
	//

    for (i = srcFileName.Length / sizeof(WCHAR) - 1;
		 i >= 0 && srcFileName.Buffer[i] != '\\';
		 --i)
		continue;

	srcFileName.Length = (USHORT)(i * sizeof(WCHAR));

    InitializeObjectAttributes(
        &objectAttributes,
        &srcFileName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL);

    //
    // Need to use NtOpenFile because Win32 doesn't let you open a directory.
    //
	Status = CDNtOpenFile(
                    &volHandle,
					GENERIC_READ | SYNCHRONIZE,
                    &objectAttributes,
                    &ioStatusBlock,
					SHARE_ALL,
					FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT);

    CDRtlFreeUnicodeString( &srcFileName );

	if (!NT_SUCCESS(Status)) {
        SetLastError(CDRtlNtStatusToDosError(Status));
        return FALSE;
	}

    //
    //  Invoke the SIS CopyFile FsCtrl.
    //

    Status = CDNtFsControlFile(
                 volHandle,
                 NULL,
                 NULL,
                 NULL,
                 &ioStatusBlock,
                 FSCTL_SIS_COPYFILE,
                 copyFile,		        // Input buffer
                 copyFileSize,			// Input buffer length
                 NULL,                  // Output buffer
                 0 );                   // Output buffer length

    CloseHandle( volHandle );

    if (NT_SUCCESS( Status )) {
        return TRUE;
    }

    if ((Status == STATUS_INVALID_DEVICE_REQUEST) || (Status == STATUS_INVALID_PARAMETER)) {
        *fTrySis = FALSE;
    }

    SetLastError(CDRtlNtStatusToDosError(Status));
    return FALSE;

error:

    err = GetLastError();

    CDRtlFreeUnicodeString( &srcDosFileName );
    CDRtlFreeUnicodeString( &dstDosFileName );
    CDRtlFreeUnicodeString( &srcFileName );
    CDRtlFreeUnicodeString( &dstDosFileName );

    SetLastError(err);

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\consume\physmem.cxx ===
//                                          
// Universal Resource Consumer: Just an innocent stress program
// Copyright (c) Microsoft Corporation, 1997, 1998, 1999
//

//
// module: physmem.cxx
// author: silviuc
// created: Fri Apr 10 14:05:05 1998
//

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <windows.h>

#include "error.hxx"
#include "physmem.hxx"
#include "consume.hxx"

//
// Local functions
//

BOOL
CheckMemoryRegion (

    LPVOID Address,
    SIZE_T Size);

//
// Function:
//
//     ConsumeAllPhysicalMemory
//
// Description:
//
//    This routine will consume all physical memory.
//    It will do so by increasing the working set size and locking the pages
//    in memory. 
//

void ConsumeAllPhysicalMemory ()
{
    BOOL Result;
    SIZE_T MinWsSize;
    SIZE_T MaxWsSize;
    SIZE_T RegionSize;
    LPVOID Region;
    
    //
    // For ever loop in which we try to grab as much physical memory 
    // as possible.
    //

    
    for (RegionSize = 0x100000; ; )
      {
        //
        // Eat more ...
        //

        Region = VirtualAlloc (NULL, RegionSize, MEM_COMMIT, PAGE_READWRITE);

        if (Region == NULL) {

            Sleep (1000);

            //
            // We've got an allocation error. 
            // Switch to 64K chunks and try again.
            //

            RegionSize = 0x10000;
            continue;
        }

        if (VirtualLock (Region, RegionSize) == FALSE) {

            VirtualFree (Region, 0, MEM_RELEASE);

            //
            // We have to increase the working set if possible.
            //

            Result = GetProcessWorkingSetSize(
                GetCurrentProcess(),
                &MinWsSize,
                &MaxWsSize);

            if (Result == FALSE)
              {
                Sleep (1000);
                continue;
              }
            
            MinWsSize += 0x10000;
            MaxWsSize += 0x10000;

            Result = SetProcessWorkingSetSize(
                GetCurrentProcess(),
                MinWsSize,
                MaxWsSize);
    
            if (Result == FALSE) {
                Sleep (1000);
            }

            continue;
          }
        else {

            //
            // Memory is allocated and locked. Touch it.
            //

            assert_ (Region != NULL);
            CheckMemoryRegion (Region, RegionSize);
        }

        printf (".");
      }
}

//
// Function:
//
//     CheckMemoryRegion 
//
// Description:
//
//     This function checks that the memory region is zeroed as
//     it should be when a region has just been allocated and
//     then reads and writes work properly.
//

BOOL
CheckMemoryRegion (

    LPVOID Address,
    SIZE_T Size)
{
    LPBYTE Start, End, Current;

    Current = Start = (LPBYTE) Address;
    End = Start + Size;

    for ( ; Current < End; Current += 1024) {

        if (*Current != 0 || (End - Current >= 1024 && *(Current + 1023) != 0)) {
            Message ("Page at %p not zeroed \n");
            return FALSE;
        }

        *Current = *(Current + 1023) = 0xAB;

        if (*Current != 0xAB || (End - Current >= 1024 && *(Current + 1023) != 0xAB)) {
            Message ("Page at %p has R/W error \n");
            return FALSE;
        }
    }

    return TRUE;
}

//
// end of module: physmem.cxx
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cp\cp.c ===
/* cp -  move from one file to another
 *
 * HISTORY:
 *
 *  3-Dec-90    w-barry   ported to Win32.
 * 07-Sep-90    w-wilson  ported to cruiser
 * 19-Mar-87    danl      exit with 1 on any errors
 *
*/


#include <ctype.h>
#include <fcntl.h>
#include <io.h>
#include <sys\types.h>
#include <sys\stat.h>
#include <malloc.h>
#include <dos.h>
#include <stdio.h>
#include <conio.h>
#include <process.h>
#include <windows.h>
#include <tools.h>
#include <string.h>


char src[MAX_PATH], dst[MAX_PATH], name[MAX_PATH];

__cdecl main (c, v)
int c;
char *v[];
{
    struct findType fbuf, dbuf;
    int i, t;
    HANDLE fh;
    char *s;
    flagType fAsk = FALSE;
    flagType fAppend = FALSE;
    int iRtn = 0;
    char *y;

    ConvertAppToOem( c, v );
    while (c > 1 && fSwitChr(*v[1])) {
        lower( v[1] );
        if (!strcmp( v[1]+1, "p" ))
            fAsk = TRUE;
        else
        if (!strcmp( v[1]+1, "a" ))
            fAppend = TRUE;
        else
            printf( "cp: invalid switch %s\n", v[1] );
        c--;
        v++;
        }

    if (c < 3) {
        printf ("Usage: cp [/p] [/a] file1 [ file2 ...] target\n");
        exit (1);
        }

    for (i=1; i<c; i++) {
        findpath (v[i], src, FALSE);
        pname (src);
        v[i] = _strdup (src);
        }

    if (rootpath (v[c-1], dst) == -1) {
        printf ("Cannot move to %s - %s\n", v[c-1], error ());
        exit (1);
    } else {
        if ( dst[0] == '\\' && dst[1] == '\\' ) {
            y = strbscan (&dst[3], "/\\");
            if ( *y != '\0' ) {
                y = strbscan( y+1, "/\\");
                if ( *y == '\0' ) {
                    strcat(dst, "\\" );
                }
            }
        }
    }

    if (fPathChr (dst[strlen(dst)-1])) {
        SETFLAG (fbuf.fbuf.dwFileAttributes, FILE_ATTRIBUTE_DIRECTORY);
    }
    else if( ffirst( dst, FILE_ATTRIBUTE_DIRECTORY, &fbuf ) ) {
        findclose( &fbuf );  /* Let next ffirst work */
        RSETFLAG (fbuf.fbuf.dwFileAttributes, FILE_ATTRIBUTE_DIRECTORY);
    }
    else if (TESTFLAG(fbuf.fbuf.dwFileAttributes, FILE_ATTRIBUTE_DIRECTORY)) {
        strcat (dst, "\\");
    }

    if (c != 3 && !TESTFLAG(fbuf.fbuf.dwFileAttributes, FILE_ATTRIBUTE_DIRECTORY)) {
        if (!fAppend) {
            printf ("Use /A switch to append more than 1 file to another file\n");
            exit (1);
            }
        if( ( fh = CreateFile( dst, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0 ) ) == (HANDLE)-1 ) {
            printf ("Cannot create %s - %s\n", dst, error ());
            exit (1);
        }

        for (i=1; i < c-1; i++) {
            if (rootpath (v[i], src) == -1) {
                printf ("Cannot move %s - %s\n", v[i], error ());
                iRtn = 1;
                continue;
                }
            printf( "%s", src );
            fflush( stdout );

            if (_access( src, 0 ) == -1) {
                printf( " - file not found\n" );
                iRtn = 1;
                continue;
                }
            if (s = fappend(src, fh)) {
                iRtn = 1;
                printf (" %s\n", s);
            }
            else
                printf (" [ok]\n");
            }

        CloseHandle( fh );
        }
    else
    for (i=1; i < c-1; i++) {

        if (rootpath (v[i], src) == -1) {
            printf ("Cannot move %s - %s\n", v[i], error ());
            iRtn = 1;
            continue;
            }

        if (_access( src, 0 ) == -1) {
            printf( "%s - file not found\n", src );
            iRtn = 1;
            continue;
            }
        strcpy (name, dst);
        if (TESTFLAG(fbuf.fbuf.dwFileAttributes, FILE_ATTRIBUTE_DIRECTORY)) {
            if (!fPathChr (name[strlen(name)-1]))
                strcat (name, "\\");
            upd (src, name, name);
            }

        if (!ffirst (name, -1, &dbuf) && fAsk) {

            printf( "%s (delete?)", name );
            fflush( stdout );
            t = _getch();
            t = tolower(t);
            if (t != 'y')
                if (t == 'p')
                    fAsk = FALSE;
                else {
                    printf( " - skipped\n" );
                    continue;
                    }
            printf( "\n" );
            }

        printf ("%s => %s", src, name);
        fflush (stdout);
        if (s = fcopy (src, name)) {
            iRtn = 1;
            printf (" %s\n", s);
        }
        else
            printf (" [ok]\n");
        }
    return( iRtn );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cpustres\cpustres.h ===
// CpuStres.h : main header file for the CpuStres application
//

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// CCpuStresApp:
// See CpuStres.cpp for the implementation of this class
//

class CCpuStresApp : public CWinApp
{
public:
	CCpuStresApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CCpuStresApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CCpuStresApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\copyfapi\copyfapi.cxx ===
//+============================================================================
//
//  CopyFAPI.cxx
//
//  This program provides a very simple wrapper of the CopyFileEx API
//  (and the PrivCopyFileEx in NT5) with no extra functionality.
//
//+============================================================================


#define UNICODE
#define _UNICODE

#include <windows.h>
#include <stdio.h>
#include <process.h>
#include <winbasep.h>




//+----------------------------------------------------------------------------
//
//  PromptForNotSupported
//
//  When the PrivCopyFileEx callback function is called to inform the caller
//  that something couldn't be copied, this routine is used to prompt the
//  user of this utility to see if we should continue.
//
//+----------------------------------------------------------------------------


struct
{
    WCHAR wc;
    DWORD dwProgress;
} rgPromptResponse[] = { {L'O', PROGRESS_CONTINUE},
                         {L'A', PROGRESS_CANCEL},
                         {L'S', PROGRESS_STOP},
                         {L'Q', PROGRESS_QUIET},
                         {L'N', PRIVPROGRESS_REASON_NOT_HANDLED} };

DWORD
PromptForNotSupported( LPWSTR pwszPrompt )
{
    WCHAR wc = 'z';
    HANDLE hKeyboard = INVALID_HANDLE_VALUE;
    ULONG KeyboardModeNew, KeyboardModeOld;

    hKeyboard = CreateFile( (LPWSTR)L"CONIN$",
                            GENERIC_READ | GENERIC_WRITE,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            NULL,
                            OPEN_EXISTING,
                            0,
                            NULL );
    
    if( INVALID_HANDLE_VALUE != hKeyboard
        &&
        !IsDebuggerPresent()
        &&
        GetConsoleMode( hKeyboard, &KeyboardModeOld ) )
    {
        KeyboardModeNew = KeyboardModeOld & ~(ENABLE_LINE_INPUT | ENABLE_PROCESSED_INPUT | ENABLE_ECHO_INPUT);
        SetConsoleMode( hKeyboard, KeyboardModeNew );
    }

    while(  TRUE )
    {
        for( int i = 0; i < sizeof(rgPromptResponse)/sizeof(rgPromptResponse[0]); i++ )
        {
            if( wc == rgPromptResponse[i].wc )
                return( rgPromptResponse[i].dwProgress );
        }

        wprintf( L"%s (cOntinue, cAncel, Stop, Quiet, Not handled) ", pwszPrompt );
        wc = getwchar();
        wprintf( L"\r" );
        wprintf( L"                                                                             \r" );
    }

    SetConsoleMode( hKeyboard, KeyboardModeOld );
    CloseHandle( hKeyboard );

    return( PROGRESS_CONTINUE );    // Should never execute
}



//+----------------------------------------------------------------------------
//
//  CopyFileProgressRoutine
//
//  This is the callback function given to CopyFileEx (if so desired by
//  the user).  It displays the progress information, and prompts the
//  user for permission to continue if something (e.g. ACLs) can't be 
//  copied.
//
//+----------------------------------------------------------------------------

DWORD
WINAPI
CopyFileProgressRoutine(
    LARGE_INTEGER TotalFileSize,
    LARGE_INTEGER TotalBytesTransferred,
    LARGE_INTEGER StreamSize,
    LARGE_INTEGER StreamBytesTransferred,
    DWORD dwStreamNumber,
    DWORD dwCallbackReason,
    HANDLE hSourceFile,
    HANDLE hDestinationFile,
    LPVOID lpData OPTIONAL
    )
{
    wprintf( L"Progress: %7I64i, %7I64i, %7I64i, %7I64i, %7d\n",
             TotalFileSize.QuadPart, TotalBytesTransferred.QuadPart,
             StreamSize, StreamBytesTransferred,
             dwStreamNumber );

    switch( dwCallbackReason )
    {
    case PRIVCALLBACK_STREAMS_NOT_SUPPORTED:
        return( PromptForNotSupported( L"Streams not supported" ));

    case PRIVCALLBACK_SECURITY_INFORMATION_NOT_SUPPORTED:
        return( PromptForNotSupported( L"Security info not supported" ));

    case PRIVCALLBACK_COMPRESSION_NOT_SUPPORTED:
        return( PromptForNotSupported( L"Compression not supported" ));

    case PRIVCALLBACK_COMPRESSION_FAILED:
        return( PromptForNotSupported( L"Compression failed" ));

    case PRIVCALLBACK_ENCRYPTION_NOT_SUPPORTED:
        return( PromptForNotSupported( L"Encryption not supported" ));

    case PRIVCALLBACK_CANT_ENCRYPT_SYSTEM_FILE:
        return( PromptForNotSupported( L"Can't encrypt a system file" ));

    case PRIVCALLBACK_ENCRYPTION_FAILED:
        return( PromptForNotSupported( L"Encryption failed" ));

    case PRIVCALLBACK_EAS_NOT_SUPPORTED:
        return( PromptForNotSupported( L"EAs not supported" ));

    case PRIVCALLBACK_SPARSE_NOT_SUPPORTED:
        return( PromptForNotSupported( L"Sparse not supported" ));

    case PRIVCALLBACK_SPARSE_FAILED:
        return( PromptForNotSupported( L"Sparse failed" ));

    case PRIVCALLBACK_DACL_ACCESS_DENIED:
        return( PromptForNotSupported( L"DACL access denied" ));

    case PRIVCALLBACK_OWNER_GROUP_ACCESS_DENIED:
        return( PromptForNotSupported( L"Owner/group access denied" ));

    case PRIVCALLBACK_OWNER_GROUP_FAILED:
        return( PromptForNotSupported( L"Owner/group failed" ));

    case PRIVCALLBACK_SACL_ACCESS_DENIED:
        return( PromptForNotSupported( L"SACL access denied" ));

    case CALLBACK_CHUNK_FINISHED:
    case CALLBACK_STREAM_SWITCH:
        return( PROGRESS_CONTINUE );
    
    default:
        return( PromptForNotSupported( L"<Unknown>" ));
    }

    return( PRIVPROGRESS_REASON_NOT_HANDLED );

}

void
Usage()
{
    printf( "\n  Purpose:   Call the CopyFile API\n"
              "  Usage:     CopyFAPI [options] <source> <dest>\n"
              "  Options:   -f  COPY_FILE_FAIL_IF_EXISTS\n"
              "             -r  COPY_FILE_RESTARTABLE\n"
              "             -e  COPY_FILE_ALLOW_DECRYPTED_DESTINATION\n"
              "             -m  PRIVCOPY_FILE_METADATA\n"
              "             -s  PRIVCOPY_FILE_SACL\n"
              "             -u  PRIVCOPY_FILE_SUPERSEDE\n"
              "             -o  PRIVCOPY_FILE_OWNER_GROUP\n"
              "             -d  PRIVCOPY_FILE_DIRECTORY\n"
              "             -b  PRIVCOPY_FILE_BACKUP_SEMANTICS\n"
              "             -c  Use the callback function\n"
              "  Note:      Since this simply calls the CopyFile API,\n"
              "             you must specify the file path (not just\n"
              "             the parent directory), and wildcards\n"
              "             are not allowed\n" );
}

typedef BOOL (__stdcall *PFNMoveFileIdentityW)(
    LPCWSTR lpOldFileName,
    LPCWSTR lpNewFileName,
    DWORD dwFlags
    );

typedef BOOL (__stdcall *PFNPrivCopyFileExW)(
    LPCWSTR lpExistingFileName,
    LPCWSTR lpNewFileName,
    LPPROGRESS_ROUTINE lpProgressRoutine OPTIONAL,
    LPVOID lpData OPTIONAL,
    LPBOOL pbCancel OPTIONAL,
    DWORD dwCopyFlags
    );




//+----------------------------------------------------------------------------
//
//  wmain
//
//  User parameters are mapped to CopyFileEx parameters, then the API
//  is called.
//
//+----------------------------------------------------------------------------

extern "C" void __cdecl
wmain( int cArgs, WCHAR *rgpwszArgs[] )
{
    LONG iArgs;
    DWORD dwCopyFileFlags = 0;
    BOOL fUseCallback = FALSE;

    cArgs--;
    iArgs = 1;
    while( cArgs > 0 )
    {
        if( L'-' != rgpwszArgs[iArgs][0]
            &&
            L'/' != rgpwszArgs[iArgs][0] )
        {
            break;
        }

        WCHAR wcUpper = towupper( rgpwszArgs[iArgs][1] );
        switch( wcUpper )
        {
        case 'F':
            dwCopyFileFlags |= COPY_FILE_FAIL_IF_EXISTS;
            break;

        case 'R':
            dwCopyFileFlags |= COPY_FILE_RESTARTABLE;
            break;

        case 'E':
            dwCopyFileFlags |= COPY_FILE_ALLOW_DECRYPTED_DESTINATION;
            break;

        case 'M':
            dwCopyFileFlags |= PRIVCOPY_FILE_METADATA;
            break;

        case 'S':
            dwCopyFileFlags |= PRIVCOPY_FILE_SACL;
            break;

        case 'U':
            dwCopyFileFlags |= PRIVCOPY_FILE_SUPERSEDE;
            break;

        case 'O':
            dwCopyFileFlags |= PRIVCOPY_FILE_OWNER_GROUP;
            break;

        case 'D':
            dwCopyFileFlags |= PRIVCOPY_FILE_DIRECTORY;
            break;

        case 'B':
            dwCopyFileFlags |= PRIVCOPY_FILE_BACKUP_SEMANTICS;
            break;

        case 'C':
            fUseCallback = TRUE;
            break;
             
        case 'X':
            dwCopyFileFlags |= 0x80;
            break;

        case 'P':
            dwCopyFileFlags |= 0x100;
            break;

        default:
            wprintf( L"Invalid option:  %c\n", wcUpper );
            Usage();
            exit(0);
        }

        iArgs++;
        cArgs--;
    }

    if( cArgs != 2 )
    {
        Usage();
        exit(0);
    }

    if( fUseCallback )
        wprintf( L"          cbTotal    cbCur    cbStm cbStmCur   StmNum\n" );

    try
    {
        if( PRIVCOPY_FILE_VALID_FLAGS & dwCopyFileFlags )
        {
            // We need to call the private API

            PFNPrivCopyFileExW pfnPrivCopyFileExW;
            pfnPrivCopyFileExW = (PFNPrivCopyFileExW) GetProcAddress( GetModuleHandle(L"kernel32.dll"),
                                                                      "PrivCopyFileExW" );
            if( NULL == pfnPrivCopyFileExW )
                throw L"Couldn't get PrivCopyFileExW export";

            if( !pfnPrivCopyFileExW( rgpwszArgs[iArgs], rgpwszArgs[iArgs+1],
                                     fUseCallback ? CopyFileProgressRoutine : NULL,
                                     NULL, NULL, dwCopyFileFlags ))
                throw L"PrivCopyFileEx failed";
            else
                wprintf( L"Succeeded\n" );
        }
        else
        {
            // We can use the public API

            if( !CopyFileExW( rgpwszArgs[iArgs], rgpwszArgs[iArgs+1],
                              fUseCallback ? CopyFileProgressRoutine : NULL,
                              NULL, NULL, dwCopyFileFlags ))
                throw L"CopyFileEx failed";
            else
                wprintf( L"Succeeded\n" );
        }
    }
    catch( const WCHAR *pwszError )
    {
        wprintf( L"Error:  %s (%lu)\n", pwszError, GetLastError() );
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cpuid\ia64\cpuidsup.s ===
//++
//
// Copyright (c) 2001  Microsoft Corporation
//
// Module Name:
//
//    cpuidsup.s
//
// Abstract:
//
//    This module implements CPUID enquiry for the cpuid program.
//
// Author:
//
//    Peter L. Johnston (peterj) 6-Apr-2001
//
// Environment:
//
//    User mode only
//
//--

#include "ksia64.h"

        .file     "cpuidsup.s"
        .text

        LEAF_ENTRY(ia64CPUID)

        mov     ret0 = cpuid[a0]
        LEAF_RETURN
        ;;

        LEAF_EXIT(ia64CPUID)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cpustres\cpustres.cpp ===
// CpuStres.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "CpuStres.h"
#include "StresDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CCpuStresApp

BEGIN_MESSAGE_MAP(CCpuStresApp, CWinApp)
	//{{AFX_MSG_MAP(CCpuStresApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CCpuStresApp construction

CCpuStresApp::CCpuStresApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CCpuStresApp object

CCpuStresApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CCpuStresApp initialization

BOOL CCpuStresApp::InitInstance()
{
	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

#if 0
#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif
#endif

	CStressDlg dlg;
	m_pMainWnd = &dlg;
	int nResponse = (int)dlg.DoModal();
	if (nResponse == IDOK)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with OK
	}
	else if (nResponse == IDCANCEL)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with Cancel
	}

	// Since the dialog has been closed, return FALSE so that we exit the
	//  application, rather than start the application's message pump.
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cpustres\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by CpuStres.rc
//
#define IDM_ABOUTBOX                    0x0010
#define IDD_ABOUTBOX                    100
#define IDS_ABOUTBOX                    101
#define IDD_CPU_STRESS_DIALOG              102
#define IDR_MAINFRAME                   128
#define IDC_1_PRIORITY                  1001
#define IDC_1_ACTIVITY                  1002
#define IDC_1_ACTIVE                    1003
#define IDC_2_PRIORITY                  1004
#define IDC_2_ACTIVITY                  1005
#define IDC_3_PRIORITY                  1007
#define IDC_3_ACTIVITY                  1008
#define IDC_USE_MEMORY                  1009
#define IDC_4_PRIORITY                  1010
#define IDC_4_ACTIVITY                  1011
#define IDC_2_ACTIVE                    1012
#define IDC_3_ACTIVE                    1013
#define IDC_4_ACTIVE                    1014
#define IDC_PROCESS_PRIORITY            1015
#define IDC_SHARED_MEM_SIZE             1016

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        130
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1017
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cpuid\cpuid.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    cpuid.c

Abstract:

    Originally written to test the fix to an OS bug but indended to be
    expanded as time allows to dump out as much useful stuff as we can.

Author:

    Peter L Johnston (peterj) July 14, 1999.

Revision History:

Notes:

--*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <winbase.h>

#if defined(_X86_)

typedef enum {
    CPU_NONE,
    CPU_INTEL,
    CPU_AMD,
    CPU_CYRIX,
    CPU_UNKNOWN
} CPU_VENDORS;


PUCHAR FeatureBitDescription[] = {
/*  0 */ "FPU    387 (Floating Point) instructions",
/*  1 */ "VME    Virtual 8086 Mode Enhancements",
/*  2 */ "DE     Debugging Extensions",
/*  3 */ "PSE    Page Size Extensions (4MB pages)",
/*  4 */ "TSC    Time Stamp Counter",
/*  5 */ "MSR    Model Specific Registers (RDMSR/WRMSR)",
/*  6 */ "PAE    Physical Address Extension (> 32 bit physical addressing)",
/*  7 */ "MCE    Machine Check Exception",
/*  8 */ "CX8    CMPXCHG8B (compare and exchange 8 byte)",
/*  9 */ "APIC   Advanced Programmable Interrupt Controller",
/* 10 */ "Reserved",
/* 11 */ "SEP    Fast System Call (SYSENTER/SYSEXIT)",
/* 12 */ "MTRR   Memory Type Range Registers",
/* 13 */ "PGE    PTE Global Flag",
/* 14 */ "MCA    Machine Check Architecture",
/* 15 */ "CMOV   Conditional Move and Compare",
/* 16 */ "PAT    Page Attribute Table",
/* 17 */ "PSE36  4MB pages can have 36 bit physical addresses",
/* 18 */ "PN     96 bit Processor Number",
/* 19 */ "CLFLSH Cache Line Flush",
/* 20 */ "Reserved",
/* 21 */ "DTS    Debug Trace Store",
/* 22 */ "ACPI   ACPI Thermal Throttle Registers",
/* 23 */ "MMX    Multi Media eXtensions",
/* 24 */ "FXSR   Fast Save/Restore (FXSAVE/FXRSTOR)",
/* 25 */ "XMM    Streaming Simd Extensions",
/* 26 */ "WNI    Willamette New Instructions",
/* 27 */ "SLFSNP Self Snoop",
/* 28 */ "JT     Jackson Technology (SMT)",
/* 29 */ "ATHROT Automatic Thermal Throttle",
/* 30 */ "IA64   64 Bit Intel Architecture",
/* 31 */ "Reserved"
    };


PUCHAR AMDExtendedFeatureBitDescription[] = {
/*  0 */ "FPU    387 (Floating Point) instructions",
/*  1 */ "VME    Virtual 8086 Mode Enhancements",
/*  2 */ "DE     Debugging Extensions",
/*  3 */ "PSE    Page Size Extensions (4MB pages)",
/*  4 */ "TSC    Time Stamp Counter",
/*  5 */ "MSR    Model Specific Registers (RDMSR/WRMSR)",
/*  6 */ "PAE    Physical Address Extension (> 32 bit physical addressing)",
/*  7 */ "MCE    Machine Check Exception",
/*  8 */ "CX8    CMPXCHG8B (compare and exchange 8 byte)",
/*  9 */ "APIC   Advanced Programmable Interrupt Controller",
/* 10 */ "Reserved",
/* 11 */ "       SYSCALL and SYSRET Instructions",
/* 12 */ "MTRR   Memory Type Range Registers",
/* 13 */ "PGE    PTE Global Flag",
/* 14 */ "MCA    Machine Check Architecture",
/* 15 */ "CMOV   Conditional Move and Compare",
/* 16 */ "PAT    Page Attribute Table",
/* 17 */ "PSE36  4MB pages can have 36 bit physical addresses",
/* 18 */ "Reserved",
/* 19 */ "Reserved",
/* 20 */ "Reserved",
/* 21 */ "Reserved",
/* 22 */ "       AMD MMX Instruction Extensions",
/* 23 */ "MMX    Multi Media eXtensions",
/* 24 */ "FXSR   Fast Save/Restore (FXSAVE/FXRSTOR)",
/* 25 */ "Reserved",
/* 26 */ "Reserved",
/* 27 */ "Reserved",
/* 28 */ "Reserved",
/* 29 */ "Reserved",
/* 30 */ "       AMD 3DNow! Instruction Extensions",
/* 31 */ "       3DNow! Instructions",
    };

PUCHAR BrandIndex[] = {
    "Intel Celeron",
    "Intel Pentium III",
    "Intel Pentium III XEON",
    "Reserved for future"
    "Reserved for future"
    "Reserved for future"
    "Reserved for future"
    "Reserved for future"
    "Intel Pentium 4"
    };

VOID
ExecuteCpuidFunction(
    IN  ULONG   Function,
    OUT PULONG  Results
    );

BOOLEAN
IsCpuidPresent(
    VOID
    );

PUCHAR
AMD_Associativity(
    ULONG Descriptor
    )
{
    switch (Descriptor) {
    case 0x0:  return"L2 Off";
    case 0x1:  return"Direct";
    case 0x2:  return" 2 way";
    case 0x4:  return" 4 way";
    case 0x6:  return" 8 way";
    case 0x8:  return"16 way";
    case 0xff: return"  Full";
    default:
         return"Reserved";
    }
}
VOID
AMD_DI_TLB(
    ULONG Format,
    ULONG TLBDesc
    )
{
    UCHAR Which = 'D';
    ULONG AssocIndex;
    ULONG Entries;

    if ((TLBDesc >> 16) == 0) {

        //
        // Unified.
        //

        TLBDesc <<= 16;
        Which = ' ';
    }
    do {
        if (Format == 1) {
            AssocIndex = TLBDesc >> 24;
            Entries = (TLBDesc >> 16) & 0xff;
        } else {
            AssocIndex = TLBDesc >> 28;
            Entries = (TLBDesc >> 16) & 0xfff;
        }
        printf(" %8s %4d entry %cTLB",
               AMD_Associativity(AssocIndex),
               Entries,
               Which
               );

        //
        // Repeat for lower half of descriptor.
        //

        TLBDesc <<= 16;
        Which = 'I';
    } while (TLBDesc);
    printf("\n");
}
VOID
AMD_Cache(
    ULONG Format,
    ULONG CacheDesc
    )
{
    ULONG Size;
    ULONG AssocIndex;
    ULONG LinesPerTag;
    ULONG LineSize;

    if (Format == 1) {
        Size = CacheDesc >> 24;
        AssocIndex = (CacheDesc >> 16) & 0xff;
        LinesPerTag = (CacheDesc >> 8) & 0xff;
        LineSize = CacheDesc & 0xff;
    } else {
        Size = CacheDesc >> 16;
        AssocIndex = (CacheDesc >> 12) & 0xf;
        LinesPerTag = (CacheDesc >> 8) & 0xf;
        LineSize = CacheDesc & 0xff;
    }
    printf(" %8s %5dKB (%d L/T)%3d bytes per line.\n",
           AMD_Associativity(AssocIndex),
           Size,
           LinesPerTag,
           LineSize
           );
}

#endif

#if defined(_IA64_)

ULONGLONG
ia64CPUID(
    ULONGLONG Index
    );

#endif

__cdecl
main(
    LONG    Argc,
    PUCHAR *Argv
    )
{
    ULONG   Processor;
    ULONG   Function;
    ULONG   MaxFunction;
    ULONG   Temp;
    ULONG   Temp2, Bit;
    HANDLE  ProcessHandle;
    HANDLE  ThreadHandle;

#if defined(_X86_)

    ULONG   Results[5];
    ULONG   Family = 0;
    ULONG   Model = 0;
    ULONG   Stepping = 0;
    ULONG   Generation = 0;
    BOOLEAN CpuidPresent;
    CPU_VENDORS Vendor = CPU_NONE;
    ULONG   ThreadAffinity;
    ULONG   SystemAffinity;
    ULONG   ProcessAffinity;

#endif

#if defined(_IA64_)

    ULONGLONG Result;
    ULONGLONG ThreadAffinity;
    ULONGLONG SystemAffinity;
    ULONGLONG ProcessAffinity;
    ULONGLONG VendorInformation[3];

#endif

    //
    // Make sure this process is set to run on any processor in
    // the system.
    //

    ProcessHandle = GetCurrentProcess();
    ThreadHandle = GetCurrentThread();

    if (!GetProcessAffinityMask(ProcessHandle,
                                &ProcessAffinity,
                                &SystemAffinity)) {
        printf("Fatal error: Unable to determine process affinity.\n");
        exit(1);
    }

    if (ProcessAffinity != SystemAffinity) {

        if (!SetProcessAffinityMask(ProcessHandle,
                                    SystemAffinity)) {
            printf("Warning: Unable to run on all processors\n");
            printf("         System  Affinity %08x\n", SystemAffinity);
            printf("       - Process Affinity %08x\n", ProcessAffinity);
            printf("         Will Try         %08x\n", 
                    SystemAffinity & ProcessAffinity);
            SystemAffinity &= ProcessAffinity;
        }
        ProcessAffinity = SystemAffinity;
    }
        
#if defined(_X86_)

    //
    // Cpuid returns 4 DWORDs of data.  In some cases this is string
    // data in which case it needs to be NULL terminated.
    //

    Results[4] = 0;

#endif

    //
    // For each CPU in the system, determine the availability of
    // the CPUID instruction and dump out anything useful it might
    // have to say.
    //

    for (ThreadAffinity = 1, Processor = 0;
         ThreadAffinity;
         ThreadAffinity <<= 1, Processor++) {
        if (!(ThreadAffinity & ProcessAffinity)) {

            //
            // Can't test this processor.
            //

            if (ThreadAffinity > ProcessAffinity) {

                //
                // Tested all the processors there are, we're done.
                //
        
                break;
            }

            continue;
        }

        //
        // Set affinity so this thread can only run on the processor
        // being tested.
        //

        if (!SetThreadAffinityMask(ThreadHandle,
                                   ThreadAffinity)) {

            printf(
                "** Could not set affinity %08x for processor %d, skipping.\n",
                ThreadAffinity,
                Processor);
            continue;
        }

#if defined(_X86_)

        CpuidPresent = IsCpuidPresent();
        if (CpuidPresent) {
            printf("++ Processor %d\n", Processor);
        } else {
            printf("-- No CPUID support, processor %d\n", Processor);
            continue;
        }

        //
        // CPUID is present, examine basic functions.
        //

        ExecuteCpuidFunction(0, Results);

        MaxFunction = Results[0];


        //
        // For reasons unclear to anyone, the Vendor ID string comes
        // back in the order EBX, EDX, ECX,... so switch the last two
        // results before printing it.
        //

        Temp = Results[3];
        Results[3] = Results[2];
        Results[2] = Temp;

        if (strcmp((PVOID)&Results[1], "GenuineIntel") == 0) {
            Vendor = CPU_INTEL;
        } else if (strcmp((PVOID)&Results[1], "AuthenticAMD") == 0) {
            Vendor = CPU_AMD;
        } else if (strcmp((PVOID)&Results[1], "CyrixInstead") == 0) {
            Vendor = CPU_CYRIX;
        } else {
            Vendor = CPU_UNKNOWN;
        }

        printf("   Vendor ID '%s', Maximum Supported Function %d.\n",
                (PUCHAR)(&Results[1]),
                MaxFunction);

        for (Function = 0; Function <= MaxFunction; Function++) {
            ExecuteCpuidFunction(Function, Results);
            printf("   F %d raw = %08x %08x %08x %08x\n",
                    Function,
                    Results[0],
                    Results[1],
                    Results[2],
                    Results[3]);
            //
            // Do some interpretation on the ones we know how to
            // deal with.
            //

            switch(Function) {
            case 0:

                //
                // Already handled as the main header (gave max func
                // and Vendor ID.
                //

                break;

            case 1:

                //
                // EAX = Type, Family, Model, Stepping.
                // EBX = Family != 0xf ?
                //       Yes = Reserved,
                //       No  = 0xAABBCCDD where
                //             AA = APIC ID
                //             BB = LP per PP
                //             CC = CLFLUSH line size (8 = 64 bytes)
                //             DD = Brand Index
                // ECX = Reserved
                // EDX = Feature Bits
                //

                //
                // Family Model Stepping
                //

                Temp = Results[0];
                Family   = (Temp >> 8) & 0xf;
                Model    = (Temp >> 4) & 0xf;
                Stepping =  Temp       & 0xf;
                printf("   Type = %d, Family = %d, Model = %d, Stepping = %d\n",
                       (Temp >> 12) & 0x3, Family, Model, Stepping);

                //
                // Willamette stuff
                //

                if ((Temp & 0xf00) == 0xf00) {
                    Temp = Results[1] & 0xff;
                    if (Temp) {
                            
                        //
                        // Indexes are a DISGUSTING way to get this info!!
                        //

                        printf("   Brand Index %02x %s processor\n",
                               Temp,
                               Temp < (sizeof(BrandIndex) / sizeof(PUCHAR)) ?
                               BrandIndex[Temp-1] :
                               BrandIndex[(sizeof(BrandIndex) / sizeof(PUCHAR)) -1]);
                    }
                    Temp = (Results[1] >> 8) & 0xff;
                    printf("   CLFLUSH line size (%x) = %d bytes\n",
                           Temp,
                           Temp << 3);    // ?? plj - nobasis
                    Temp = Results[1] >> 16;
                    printf("   LP per PP %d\n", Temp & 0xff);
                    printf("   APIC Id %02x\n", Temp >> 8);
                }

                //
                // Feature bits.
                //

                Temp = Results[3];
                if (Temp) {
                    printf("   Features\n");
                    for (Bit = 0, Temp2 = 1;
                         Temp;
                         Bit++, Temp2 <<= 1) {

                        if ((Temp2 & Temp) == 0) {

                            //
                            // Feature bit not set.
                            //

                            continue;
                        }
                        Temp ^= Temp2;
                        printf("   %08x  %s\n",
                               Temp2,
                               FeatureBitDescription[Bit]);
                    }
                }
                break;

            case 2:

                //
                // Get number of times we have to do function 2 again.
                // (Then replace iteration count with a NULL descr).
                //

                Temp = Results[0] & 0xff;

                if (Temp == 0) {

                    //
                    // If the count is 0, this processor doesn't do
                    // function 2, get out.
                    //

                    break;
                }
                Results[0] &= 0xffffff00;

                do {
                    ULONG i;

                    for (i = 0; i < 4; i++) {

                        Temp2 = Results[i];

                        if (Temp2 & 0x80000000) {

                            //
                            // Not valid, skip.
                            //

                            continue;
                        }

                        while (Temp2) {

                            UCHAR Descriptor = (UCHAR)(Temp2 & 0xff);
                            ULONG K, Way, Line, Level;
                            PUCHAR IorD = "";

                            Temp2 >>= 8;

                            if (((Descriptor > 0x40) && (Descriptor <= 0x47)) ||
                                ((Descriptor > 0x78) && (Descriptor <= 0x7c)) ||
                                ((Descriptor > 0x80) && (Descriptor <= 0x87))) {

                                //
                                // It's an L2 Descriptor.  (The following
                                // is peterj's wacky formula,... not 
                                // guaranteed forever but the nice people
                                // at Intel better pray I'm dead before
                                // they break it or I'll hunt them down).
                                //

                                Level = 2;
                                Way = Descriptor >= 0x79 ? 8 : 4;
                                K = 0x40 << (Descriptor & 0x7);
                                Line = 32;
                                if ((Descriptor & 0xf8) == 0x78) {
                                    Line = 128;
                                }
                            } else if ((Descriptor >= 0x50) &&
                                       (Descriptor <= 0x5d)) {
                                if (Descriptor & 0x8) {
                                    IorD = "D";
                                    K = 0x40 << (Descriptor - 0x5b);
                                } else {
                                    IorD = "I";
                                    K = 0x40 << (Descriptor - 0x50);
                                }
                                printf("   %02xH  %sTLB %d entry\n",
                                       Descriptor,
                                       IorD,
                                       K);
                                continue;
                            } else {
                                PUCHAR s = NULL;
                                switch (Descriptor) {
                                case 0x00:
                                    continue;
                                case 0x01:
                                    s = "ITLB 4KB pages, 4 way, 32 entry";
                                    break;
                                case 0x02:
                                    s = "ITLB 4MB pages, fully assoc, 2 entry";
                                    break;
                                case 0x03:
                                    s = "DTLB 4KB pages, 4 way, 64 entry";
                                    break;
                                case 0x04:
                                    s = "DTLB 4MB pages, 4 way, 8 entry";
                                    break;
                                case 0x06:
                                    s = "I-Cache 8KB, 4 way, 32B line";
                                    break;
                                case 0x08:
                                    s = "I-Cache 16KB, 4 way, 32B line";
                                    break;
                                case 0x0a:
                                    s = "D-Cache 8KB, 2 way, 32B line";
                                    break;
                                case 0x0c:
                                    s = "D-Cache 16KB, 2 or 4 way, 32B line";
                                    break;
                                case 0x22:
                                    K = 512; Level = 3; Way = 4; Line = 128;
                                    break;
                                case 0x23:
                                    K = 1024; Level = 3; Way = 8; Line = 128;
                                    break;
                                case 0x25:
                                    K = 2048; Level = 3; Way = 8; Line = 128;
                                    break;
                                case 0x29:
                                    K = 4096; Level = 3; Way = 8; Line = 128;
                                    break;
                                case 0x40:
                                    s = "No L3 Cache";
                                    break;
                                case 0x66:
                                    K = 8; Level = 1; Way = 4; Line = 64; IorD = "D";
                                    break;
                                case 0x67:
                                    K = 16; Level = 1; Way = 4; Line = 64; IorD = "D";
                                    break;
                                case 0x68:
                                    K = 32; Level = 1; Way = 4; Line = 64; IorD = "D";
                                    break;
                                case 0x70:
                                    K = 12; Level = 1; Way = 8; Line = 64; IorD = "I";
                                    break;
                                case 0x71:
                                    K = 16; Level = 1; Way = 8; Line = 64; IorD = "I";
                                    break;
                                case 0x72:
                                    K = 32; Level = 1; Way = 8; Line = 64; IorD = "I";
                                    break;
                                case 0x80:
                                    s = "No L2 Cache";
                                    break;
                                default:
                                    s = "Unknown Descriptor";
                                }
                                if (s) {
                                    printf("   %02xH  %s.\n", Descriptor, s);
                                    continue;
                                }
                            }
                            printf("   %02xH  L%d %sCache %dKB, %d way, %dB line\n",
                                   Descriptor,
                                   Level,
                                   IorD,
                                   K,
                                   Way,
                                   Line);
                        } // while more bytes in this register
                    }  // for each register

                    //
                    // If more iterations,... 
                    //

                    if (--Temp == 0) {
                        break;
                    }

                    ExecuteCpuidFunction(2, Results);
                    printf("   F %d raw = %08x %08x %08x %08x\n",
                            2,
                            Results[0],
                            Results[1],
                            Results[2],
                            Results[3]);
                } while (TRUE);
                break;
            }
        }

        //
        // Examine extended functions.
        //

        ExecuteCpuidFunction(0x80000000, Results);

        MaxFunction = Results[0];

        //
        // Ok, function numbers > MaxFunction (the basic one) by
        // definition return undefined results.   But, we are told
        // that if extended functions are not supported, the return
        // value for 0x80000000 will never have the top bit set.
        //

        if ((MaxFunction & 0x80000000) == 0) {
            printf("   This processor does not support Extended CPUID functions.\n");
            continue;
        }

        printf("   Maximum Supported Extended Function 0x%x.\n",
                MaxFunction);

        for (Function = 0x80000000; Function <= MaxFunction; Function++) {
            ExecuteCpuidFunction(Function, Results);
            printf("   F 0x%08x raw = %08x %08x %08x %08x\n",
                    Function,
                    Results[0],
                    Results[1],
                    Results[2],
                    Results[3]);
            switch (Function) {
            case 0x80000000:
                break;

            case 0x80000001:

                if (Vendor == CPU_AMD) {
                    //
                    // EAX = Generation, Model, Stepping.
                    // EBX = Reserved
                    // ECX = Reserved
                    // EDX = Feature Bits
                    //

                    //
                    // Generation Model Stepping
                    //

                    Temp = Results[0];
                    Generation = (Temp >> 8) & 0xf;
                    Model    = (Temp >> 4) & 0xf;
                    Stepping =  Temp       & 0xf;
                    printf("   Generation = %d, Model = %d, Stepping = %d\n",
                           Generation, Model, Stepping);

                    //
                    // Feature bits.
                    //

                    Temp = Results[3];
                    if (Temp) {
                        printf("   Features\n");
                        for (Bit = 0, Temp2 = 1;
                             Temp;
                             Bit++, Temp2 <<= 1) {

                            if ((Temp2 & Temp) == 0) {

                                //
                                // Feature bit not set.
                                //

                                continue;
                            }
                            Temp ^= Temp2;
                            printf("   %08x  %s\n",
                                   Temp2,
                                   AMDExtendedFeatureBitDescription[Bit]);
                        }
                    }
                }
                break;

            case 0x80000002:

                Temp2 = 1;

            case 0x80000003:

                Temp2++;

            case 0x80000004:

                Temp2++;

                printf("   Processor Name[%2d-%2d] = '%s'\n",
                       49 - (Temp2 * 16),
                       64 - (Temp2 * 16),
                       Results);
                Temp2 = 0;
                break;

            case 0x80000005:

                if (Vendor == CPU_AMD) {

                    if (Family == 6) {

                        //
                        // Athlon.
                        //

                        printf("   Large Page TLBs   :");
                        AMD_DI_TLB(1, Results[0]);

                    } else if (Family > 6) {
                        printf("   Family %d is a new AMD family which this program doesn't know about.\n");
                        break;
                    }

                    //
                    // Common to K5, K6 and Athlon
                    //

                    printf("   4KB   Page TLBs   :");
                    AMD_DI_TLB(1, Results[1]);
                    printf("   L1 D-Cache        :");
                    AMD_Cache(1, Results[2]);
                    printf("   L1 I-Cache        :");
                    AMD_Cache(1, Results[3]);
                }
                break;

            case 0x80000006:

                if (Vendor == CPU_AMD) {

                    if (Family == 6) {

                        //
                        // Athlon.
                        //

                        if (Results[0]) {
                            printf("   Large Page L2 TLB :");
                            AMD_DI_TLB(2, Results[0]);
                        }
                        if (Results[1]) {
                            printf("   4KB   Page L2 TLB :");
                            AMD_DI_TLB(2, Results[1]);
                        }
                        if ((Model == 3) && (Stepping == 0)) {
                            Results[2] &= 0xffff;
                            Results[2] |= 0x400000;
                        }
                    } else if (Family > 6) {
                        break;
                    }

                    //
                    // Common to K5, K6 and Athlon
                    //

                    printf("   L2 Cache          :");
                    AMD_Cache(2, Results[2]);
                }
                break;
            }
        }

#endif

#if defined(_IA64_)

        printf("++ Processor %d\n", Processor);

        //
        // On IA64, cpuid is implemented as a set of 64 bit registers.
        // Registers
        //     0 and 1 contain the Vendor Information.
        //     2 contains 0.
        //     3 most significant 24 bits are reserved, the low 5 bytes
        //       contain-
        //       39-32 archrev
        //       31-24 family
        //       23-16 model
        //       15-08 revision
        //       07-00 number       index of largest implemented register
        //     4 features
        //

        //
        // Until we have read register 3, set 3 as the maximum number.
        //

        MaxFunction = 3;

        for (Function = 0; Function <= MaxFunction; Function++) {

            Result = ia64CPUID(Function);

            printf("   F %d raw = %016I64x\n",
                    Function,
                    Result);

            //
            // Do some interpretation on the ones we know how to
            // deal with.
            //

            switch(Function) {
            case 0:
                VendorInformation[0] = Result;
                break;
            case 1:
                VendorInformation[1] = Result;
                VendorInformation[2] = 0;
                printf("   \"%s\"\n", (PUCHAR)VendorInformation);
                break;
            case 3:
                printf("   Architecture Revision = %d, Family = %d, Model = %d, Revision = %d\n",
                       (Result >> 32) & 0xff,
                       (Result >> 24) & 0xff,
                       (Result >> 16) & 0xff,
                       (Result >>  8) & 0xff);
                MaxFunction = (ULONG)Result & 0xff;
                printf("   Maximum Supported Function %d.\n",
                        MaxFunction);
                break;
            }
        }
#endif

    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cpuid\i386\cpuidsup.asm ===
title   "CPUID support functions"
;++
;
; Copyright (c) 1999  Microsoft Corporation
;
; Module Name:
;
;    cpuidsup.asm
;
; Abstract:
;
;    Implements functions to detect whether or not the CPUID instruction
;    is supported on this processor and to provide a simple method to use
;    CPUID from a C program.
;
; Author:
;
;    Peter Johnston (peterj) July 14, 1999
;
; Environment:
;
;    Any mode.
;
; Revision History:
;
;--
.586p

        .xlist
include ks386.inc
include callconv.inc            ; calling convention macros
        .list

_TEXT$01   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page
        subttl  "IsCpuidPresent"
;++
;
; BOOLEAN
; IsCpuidPresent(
;     VOID
;     )
;
; Routine Description:
;
;    If bit 21 of the EFLAGS register is writable, CPUID is supported on
;    this processor.   If not writable, CPUID is not supported.  
;
;    Note: It is expected that this routine is "locked" onto a single
;    processor when run.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    TRUE  if CPUID is supported, 
;    FALSE otherwise.
;
;--

EFLAGS_ID   equ 200000h             ; bit 21


cPublicProc _IsCpuidPresent ,0
        pushfd                      ; save EFLAGS
        pop     ecx                 ; get current value
        xor     ecx, EFLAGS_ID      ; flip bit 21
        push    ecx                 ; set flipped value in EFLAGS
        popfd
        pushfd                      ; read it back again
        pop     eax
        xor     eax, ecx            ; if new value is what we set
        shr     eax, 21             ; then these two are the same
        and     eax, 1              ; isolate bit 21 (in bit 0)
        xor     eax, 1              ; and flip it

        stdRET _IsCpuidPresent

stdENDP _IsCpuidPresent

        page
        subttl  "ExecuteCpuidFunction"
;++
;
; VOID
; ExecuteCpuidFunction(
;     ULONG     Function,
;     PULONG    Results
;     )
;
; Routine Description:
;
;    Execute the CPUID instruction, using the Function handed in and
;    return the 4 DWORD result.
;
;    Note: It is expected that this routine is "locked" onto a single
;    processor when run.
;
; Arguments:
;
;    Function   Integer function number to be the input argument for
;               the CPUID instruction.
;    Results    Pointer to the 4 DWORD array where the results are to
;               be returned.
;
; Return Value:
;
;    None.
;
;--


cPublicProc _ExecuteCpuidFunction ,2
        mov     eax, [esp+4]        ; set CPUID function
        push    esi                 ; save esi
        mov     esi, [esp+12]       ; get Results address
        push    ebx                 ; save ebx
        cpuid                       ; execute 
        mov     [esi+0], eax        ; eax -> Results[0]
        mov     [esi+4], ebx        ; ebx -> Results[1]
        mov     [esi+8], ecx        ; ecx -> Results[2]
        mov     [esi+12], edx       ; edx -> Results[3]

        pop     ebx                 ; restore ebx, esi
        pop     esi

        stdRET _ExecuteCpuidFunction

stdENDP _ExecuteCpuidFunction

_TEXT$01   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cpustres\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	HogProg.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cpustres\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

//#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows 95 Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\crash\crash\crashrc.h ===
#define ID_CRASH       IDOK
#define CRASHDLG       500
#define APPICON        501
#define CRASHDRVDRIVER 502
#define CRASHBMP       503
#define CRASHWAV       504
#define BINARY         1024
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\crash\crash\crash.c ===
#include <windows.h>
#include <winioctl.h>
#include <mmsystem.h>
#include <stdio.h>
#include <crashrc.h>
#include <stdlib.h>
#include <bugcodes.h>
#include "crashdrv.h"


#define SERVICE_NAME    "CrashDrv"
#define DRIVER_NAME     "\\systemroot\\system32\\drivers\\crashdrv.sys"
#define CRASHDRV_DEVICE "\\\\.\\CrashDrv"


HINSTANCE   hInst;
DWORD       IoctlBuf[16];
HBITMAP     hBmp;



BOOL    InstallDriver(VOID);
BOOL    CrashTheSystem(DWORD);
BOOL    StartCrashDrvService(VOID);
VOID    SyncAllVolumes(VOID);
BOOL    IsUserAdmin(VOID);


enum {
    CRASH_TYPE_BUGCHECK,
    CRASH_TYPE_STACK_OVERFLOW,
    CRASH_TYPE_IRQL,
    CRASH_TYPE_KMODE_EXCEPTION
};


VOID
Usage(
    )
{
    printf ("USAGE: crash <flags>\n");
    printf ("\n");
    printf ("       Where flags can be one of:\n");
    printf ("\n");
    printf ("        -bugcheck - Crash the system using KeBugCheckEx. This is the default.\n");
    printf ("        -stack-overflow - Crash the system by overflowing the kernel stack.\n");
    printf ("        -irql-not-less-or-equal - Crash the system by accessing a paged-out\n"
            "             page at DISPATCH_LEVEL IRQL.\n");
    printf ("        -kmode-exception-not-handled - Crash the system by a division by zero\n"
            "             error in a kernel thread.\n");
    printf ("\n");
    exit (1);
}

VOID
ParseArgs(
    IN int argc,
    IN char* argv [],
    OUT DWORD* CrashType
    )
{
    INT i;
    
    for (i = 1; i < argc; i++) {

        if (_stricmp (argv [i], "-bugcheck") == 0) {

            *CrashType = CRASH_TYPE_BUGCHECK;

        } else if (_stricmp (argv [i], "-stack-overflow") == 0) {

            *CrashType = CRASH_TYPE_STACK_OVERFLOW;

        } else if (_stricmp (argv [i], "-irql-not-less-or-equal") == 0) {

            *CrashType = CRASH_TYPE_IRQL;

        } else if (_stricmp (argv [i], "-kmode-exception-not-handled") == 0) {

            *CrashType = CRASH_TYPE_KMODE_EXCEPTION;

        } else {

            Usage ();
        }
    }
}
        

int _cdecl
main(
    int argc,
    char *argv[]
    )
{
    DWORD CrashType = CRASH_TYPE_BUGCHECK;
    
    if (!IsUserAdmin ()) {
        printf ("You must have administrator priveleges to crash the system\n");
        return 1;
    }

    ParseArgs (argc, argv, &CrashType);

    if (!CrashTheSystem (CrashType)) {
        printf ("An error occured while trying to crash the system\n");
        return 2;
    }

    return 0; // NOTREACHED
}

BOOL
CrashTheSystem(
    IN DWORD CrashType
    )
{
    HANDLE   hCrashDrv;
    DWORD    ReturnedByteCount;
    HGLOBAL  hResource;
    LPVOID   lpResource;
    DWORD    Ioctl;

    if (!StartCrashDrvService()) {
        return FALSE;
    }

    SyncAllVolumes();

    hCrashDrv = CreateFile( CRASHDRV_DEVICE,
                          GENERIC_READ | GENERIC_WRITE,
                          0,
                          NULL,
                          OPEN_EXISTING,
                          0,
                          NULL
                        );

    if (hCrashDrv == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    if (waveOutGetNumDevs()) {
        hResource = LoadResource(
            hInst,
            FindResource( hInst, MAKEINTRESOURCE(CRASHWAV), MAKEINTRESOURCE(BINARY) ) );
        if (hResource) {
            lpResource = LockResource( hResource );
            sndPlaySound( lpResource, SND_MEMORY );
            FreeResource( hResource );
        }
    }

    switch (CrashType) {

        case CRASH_TYPE_STACK_OVERFLOW:
            Ioctl = IOCTL_CRASHDRV_STACK_OVERFLOW;
            IoctlBuf [0] = 0;
            break;

        case CRASH_TYPE_IRQL:
            Ioctl = IOCTL_CRASHDRV_SPECIAL;
            IoctlBuf [0] = IRQL_NOT_LESS_OR_EQUAL;
            break;

        case CRASH_TYPE_KMODE_EXCEPTION:
            Ioctl = IOCTL_CRASHDRV_SPECIAL;
            IoctlBuf [0] = KMODE_EXCEPTION_NOT_HANDLED;
            break;

        case CRASH_TYPE_BUGCHECK:
        default:
            Ioctl = IOCTL_CRASHDRV_BUGCHECK;
            IoctlBuf [0] = 0;
            break;
    }


    if (!DeviceIoControl(
              hCrashDrv,
              Ioctl,
              NULL,
              0,
              IoctlBuf,
              sizeof(IoctlBuf),
              &ReturnedByteCount,
              NULL
              )) {
        return FALSE;
    }

    return TRUE;
}

BOOL
CopyResourceToDriver(
    VOID
    )
{
    HGLOBAL                hResource;
    LPVOID                 lpResource;
    DWORD                  size;
    PIMAGE_DOS_HEADER      dh;
    PIMAGE_NT_HEADERS      nh;
    PIMAGE_SECTION_HEADER  sh;
    HANDLE                 hFile;
    CHAR                   buf[MAX_PATH];


    hResource = LoadResource(
        hInst,
        FindResource( hInst, MAKEINTRESOURCE(CRASHDRVDRIVER), MAKEINTRESOURCE(BINARY) ) );

    if (!hResource) {
        return FALSE;
    }

    lpResource = LockResource( hResource );

    if (!lpResource) {
        FreeResource( hResource );
        return FALSE;
    }

    dh = (PIMAGE_DOS_HEADER) lpResource;
    nh = (PIMAGE_NT_HEADERS) (dh->e_lfanew + (DWORD_PTR)lpResource);
    sh = (PIMAGE_SECTION_HEADER) ((DWORD_PTR)nh + sizeof(IMAGE_NT_HEADERS) +
                                  ((nh->FileHeader.NumberOfSections - 1) *
                                  sizeof(IMAGE_SECTION_HEADER)));
    size = sh->PointerToRawData + sh->SizeOfRawData;

    GetEnvironmentVariable( "systemroot", buf, sizeof(buf) );
    strcat( buf, "\\system32\\drivers\\CrashDrv.sys" );

    hFile = CreateFile(
        buf,
        GENERIC_READ | GENERIC_WRITE,
        0,
        NULL,
        CREATE_ALWAYS,
        0,
        NULL
        );
    if (hFile == INVALID_HANDLE_VALUE) {
        FreeResource( hResource );
        return FALSE;
    }

    WriteFile( hFile, lpResource, size, &size, NULL );
    CloseHandle( hFile );

    FreeResource( hResource );

    return TRUE;
}

BOOL
InstallDriver(
    VOID
    )
{
    SC_HANDLE      hService;
    SC_HANDLE      hOldService;
    SERVICE_STATUS ServStat;


    if (!CopyResourceToDriver()) {
        return FALSE;
    }

    if( !( hService = OpenSCManager( NULL, NULL, SC_MANAGER_ALL_ACCESS ) ) ) {
        return FALSE;
    }
    if( hOldService = OpenService( hService, SERVICE_NAME, SERVICE_ALL_ACCESS ) ) {
        if( ! ControlService( hOldService, SERVICE_CONTROL_STOP, & ServStat ) ) {
            int fError = GetLastError();
            if( ( fError != ERROR_SERVICE_NOT_ACTIVE ) && ( fError != ERROR_INVALID_SERVICE_CONTROL ) ) {
                return FALSE;
            }
        }
        if( ! DeleteService( hOldService ) ) {
            return FALSE;
        }
        if( ! CloseServiceHandle( hOldService ) ) {
            return FALSE;
        }
    }
    if( ! CreateService( hService, SERVICE_NAME, SERVICE_NAME, SERVICE_ALL_ACCESS, SERVICE_KERNEL_DRIVER, SERVICE_DEMAND_START,
                         SERVICE_ERROR_NORMAL, DRIVER_NAME, "Extended base", NULL, NULL, NULL, NULL ) ) {
        int fError = GetLastError();
        if( fError != ERROR_SERVICE_EXISTS ) {
            return FALSE;
        }
    }

    return TRUE;
}


BOOL
StartCrashDrvService(
    VOID
    )
{
    SERVICE_STATUS ssStatus;
    DWORD          dwOldCheckPoint;
    DWORD          ec;
    SC_HANDLE      schService;
    SC_HANDLE      schSCManager;


    schSCManager = OpenSCManager( NULL, NULL, SC_MANAGER_ALL_ACCESS );
    if (schSCManager == NULL) {
        return FALSE;
    }

    schService = OpenService( schSCManager, "CrashDrv", SERVICE_ALL_ACCESS );
    if (schService == NULL) {
install_driver:
        if (InstallDriver()) {
            schService = OpenService( schSCManager, "CrashDrv", SERVICE_ALL_ACCESS );
            if (schService == NULL) {
                return FALSE;
            }
        } else {
            return FALSE;
        }
    }

    if (!StartService( schService, 0, NULL )) {
        ec = GetLastError();
        CloseServiceHandle( schService );
        if (ec  == ERROR_SERVICE_ALREADY_RUNNING) {
            return TRUE;
        }
        if (ec == ERROR_FILE_NOT_FOUND) {
            goto install_driver;
        }
        return FALSE;
    }

    if (!QueryServiceStatus( schService, &ssStatus)) {
        CloseServiceHandle( schService );
        return FALSE;
    }

    while (ssStatus.dwCurrentState != SERVICE_RUNNING) {
        dwOldCheckPoint = ssStatus.dwCheckPoint;
        Sleep(ssStatus.dwWaitHint);
        if (!QueryServiceStatus( schService, &ssStatus)) {
            break;
        }
        if (dwOldCheckPoint >= ssStatus.dwCheckPoint) {
            break;
        }
    }

    CloseServiceHandle(schService);

    return TRUE;
}


BOOL
SyncVolume(
    CHAR c
    )
{
    CHAR               VolumeName[16];
    HANDLE             hVolume;


    VolumeName[0]  = '\\';
    VolumeName[1]  = '\\';
    VolumeName[2]  = '.';
    VolumeName[3]  = '\\';
    VolumeName[4]  = c;
    VolumeName[5]  = ':';
    VolumeName[6]  = '\0';

    hVolume = CreateFile(
        VolumeName,
        GENERIC_READ | GENERIC_WRITE,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_EXISTING,
        0,
        NULL );

    if (hVolume == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    FlushFileBuffers( hVolume );

    CloseHandle( hVolume );

    return TRUE;
}


VOID
SyncAllVolumes(
    VOID
    )
{
    DWORD   i;


    for(i=2; i<26; i++){
        SyncVolume( (CHAR)((CHAR)i + (CHAR)'a') );
    }
}


BOOL
IsUserAdmin(
    VOID
    )

/*++

Routine Description:

    This routine returns TRUE if the caller's process is a
    member of the Administrators local group.

    Caller is NOT expected to be impersonating anyone and IS
    expected to be able to open their own process and process
    token.

Arguments:

    None.

Return Value:

    TRUE - Caller has Administrators local group.

    FALSE - Caller does not have Administrators local group.

--*/

{
    HANDLE Token;
    DWORD BytesRequired;
    PTOKEN_GROUPS Groups;
    BOOL b;
    DWORD i;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    PSID AdministratorsGroup;

    //
    // Open the process token.
    //
    if(!OpenProcessToken(GetCurrentProcess(),TOKEN_QUERY,&Token)) {
        return(GetLastError() == ERROR_CALL_NOT_IMPLEMENTED);   // Chicago
    }

    b = FALSE;
    Groups = NULL;

    //
    // Get group information.
    //
    if(!GetTokenInformation(Token,TokenGroups,NULL,0,&BytesRequired)
    && (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
    && (Groups = (PTOKEN_GROUPS)LocalAlloc(LPTR,BytesRequired))
    && GetTokenInformation(Token,TokenGroups,Groups,BytesRequired,&BytesRequired)) {

        b = AllocateAndInitializeSid(
                &NtAuthority,
                2,
                SECURITY_BUILTIN_DOMAIN_RID,
                DOMAIN_ALIAS_RID_ADMINS,
                0, 0, 0, 0, 0, 0,
                &AdministratorsGroup
                );

        if(b) {

            //
            // See if the user has the administrator group.
            //
            b = FALSE;
            for(i=0; i<Groups->GroupCount; i++) {
                if(EqualSid(Groups->Groups[i].Sid,AdministratorsGroup)) {
                    b = TRUE;
                    break;
                }
            }

            FreeSid(AdministratorsGroup);
        }
    }

    //
    // Clean up and return.
    //

    if(Groups) {
        LocalFree((HLOCAL)Groups);
    }

    CloseHandle(Token);

    return(b);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cpustres\stresdlg.h ===
// StresDlg.h : header file
//
#define SLOW_ACTIVITY	640
#define MEDIUM_ACTIVITY	320
#define HIGH_ACTIVITY	80
#define HOG_ACTIVITY	0

/////////////////////////////////////////////////////////////////////////////
// CStressDlg dialog

class CStressDlg : public CDialog
{
// Construction
public:
	CStressDlg(CWnd* pParent = NULL);	// standard constructor

// Dialog Data
	//{{AFX_DATA(CStressDlg)
	enum { IDD = IDD_CPU_STRESS_DIALOG };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CStressDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
public:
	DWORD	m_dwProcessPriority;
	DWORD	m_ActivityValue[4];
	DWORD	m_PriorityValue[4];
	DWORD	m_Active[4];
	HANDLE	m_ThreadHandle[4];
	DWORD	m_dwLoopValue;

    // working memory variables
    LPDWORD m_pMemory;  
    DWORD   m_dwVASize; // in DWORD elements
    DWORD   m_dwRandomScale;

protected:
	HICON	m_hIcon;

	void CreateWorkerThread (DWORD);
	void SetThreadActivity (CComboBox *, DWORD);
	void SetThreadPriorityLevel (CComboBox *, DWORD);
	DWORD OnePercentCalibration(DWORD);

	// Generated message map functions
	//{{AFX_MSG(CStressDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg void OnPaint();
	afx_msg HCURSOR OnQueryDragIcon();
	afx_msg void On1Active();
	afx_msg void OnSelchange1Activity();
	afx_msg void OnSelchange1Priority();
	afx_msg void On2Active();
	afx_msg void OnSelchange2Activity();
	afx_msg void OnSelchange2Priority();
	afx_msg void On3Active();
	afx_msg void OnSelchange3Activity();
	afx_msg void OnSelchange3Priority();
	afx_msg void On4Active();
	afx_msg void OnSelchange4Activity();
	afx_msg void OnSelchange4Priority();
	virtual void OnOK();
	afx_msg void OnSelchangeProcessPriority();
	afx_msg void OnKillfocusSharedMemSize();
	afx_msg void OnChangeSharedMemSize();
	afx_msg void OnUseMemory();
	afx_msg void OnClose();
	afx_msg void OnDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

typedef struct _ThreadInfoBlock {
	CStressDlg	*	Dlg;
	DWORD			dwId;
} THREAD_INFO_BLOCK, FAR * LPTHREAD_INFO_BLOCK;


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\cpustres\stresdlg.cpp ===
// StresDlg.cpp : implementation file
//

#include "stdafx.h"
#include "CpuStres.h"
#include "StresDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CStressDlg dialog
 
CStressDlg::CStressDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CStressDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CStressDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	// Note that LoadIcon does not require a subsequent DestroyIcon in Win32
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
	m_dwProcessPriority = NORMAL_PRIORITY_CLASS;

	m_ActivityValue[0] = SLOW_ACTIVITY;
	m_ActivityValue[1] = SLOW_ACTIVITY;
	m_ActivityValue[2] = SLOW_ACTIVITY;
	m_ActivityValue[3] = SLOW_ACTIVITY;

	m_PriorityValue[0] = THREAD_PRIORITY_NORMAL;
	m_PriorityValue[1] = THREAD_PRIORITY_NORMAL;
	m_PriorityValue[2] = THREAD_PRIORITY_NORMAL;
	m_PriorityValue[3] = THREAD_PRIORITY_NORMAL;

	m_Active[0] = TRUE;
	m_Active[1] = FALSE;
	m_Active[2] = FALSE;
	m_Active[3] = FALSE;
	
	m_ThreadHandle[0] = NULL;
	m_ThreadHandle[1] = NULL;
	m_ThreadHandle[2] = NULL;
	m_ThreadHandle[3] = NULL;

	m_dwLoopValue = 0x00010000;

    m_pMemory = NULL;
    m_dwVASize = 0;
    m_dwRandomScale = 1;
}   

void CStressDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CStressDlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CStressDlg, CDialog)
	//{{AFX_MSG_MAP(CStressDlg)
	ON_WM_SYSCOMMAND()
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	ON_BN_CLICKED(IDC_1_ACTIVE, On1Active)
	ON_CBN_SELCHANGE(IDC_1_ACTIVITY, OnSelchange1Activity)
	ON_CBN_SELCHANGE(IDC_1_PRIORITY, OnSelchange1Priority)
	ON_BN_CLICKED(IDC_2_ACTIVE, On2Active)
	ON_CBN_SELCHANGE(IDC_2_ACTIVITY, OnSelchange2Activity)
	ON_CBN_SELCHANGE(IDC_2_PRIORITY, OnSelchange2Priority)
	ON_BN_CLICKED(IDC_3_ACTIVE, On3Active)
	ON_CBN_SELCHANGE(IDC_3_ACTIVITY, OnSelchange3Activity)
	ON_CBN_SELCHANGE(IDC_3_PRIORITY, OnSelchange3Priority)
	ON_BN_CLICKED(IDC_4_ACTIVE, On4Active)
	ON_CBN_SELCHANGE(IDC_4_ACTIVITY, OnSelchange4Activity)
	ON_CBN_SELCHANGE(IDC_4_PRIORITY, OnSelchange4Priority)
	ON_CBN_SELCHANGE(IDC_PROCESS_PRIORITY, OnSelchangeProcessPriority)
	ON_EN_KILLFOCUS(IDC_SHARED_MEM_SIZE, OnKillfocusSharedMemSize)
	ON_EN_CHANGE(IDC_SHARED_MEM_SIZE, OnChangeSharedMemSize)
	ON_BN_CLICKED(IDC_USE_MEMORY, OnUseMemory)
	ON_WM_CLOSE()
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

// disable optimization since it will remove the "do-nothing" loops
#pragma optimize ("", off)
DWORD CStressDlg::OnePercentCalibration(DWORD dwLoopValue)
{
	// find how many loops consume 10% of this processor
	LARGE_INTEGER	liPerfFreq;
	LONGLONG		llOnePercent;
	LARGE_INTEGER	liStartTime;
	LARGE_INTEGER	liEndTime;
	LONGLONG		llDiff;
	LONGLONG		llMinDiff;
	DWORD			dwPriorityClass;
	DWORD			dwThreadPriority;
	HANDLE			hProcess;
	HANDLE			hThread;
	DWORD			dwLoopCounter;
	DWORD			dwReturn;
	LONGLONG		llResult;
	BOOL			bGoodSample = FALSE;
	DWORD			dwAttemptCount = 5;

	dwReturn = dwLoopValue;
	QueryPerformanceFrequency (&liPerfFreq);
	llOnePercent = liPerfFreq.QuadPart / 100;
	// the calibration run must take at least 50 ms
	llMinDiff = liPerfFreq.QuadPart / 20;

	hProcess = GetCurrentProcess();
	hThread = GetCurrentThread();
	dwPriorityClass = GetPriorityClass (hProcess);
	dwThreadPriority = GetThreadPriority (hThread);

	SetPriorityClass (hProcess, HIGH_PRIORITY_CLASS);
	SetThreadPriority (hThread, THREAD_PRIORITY_HIGHEST);

	while (!bGoodSample && dwAttemptCount) {
		// start timing
		QueryPerformanceCounter (&liStartTime);
		// do a trial loop
		for (dwLoopCounter = dwLoopValue; dwLoopCounter; dwLoopCounter--);
		// end timing
		QueryPerformanceCounter (&liEndTime);
		llDiff = liEndTime.QuadPart - liStartTime.QuadPart;
		if (llDiff > llMinDiff) {
			bGoodSample = TRUE;
		} else {
			// increase the loop counter value by a factor of 10
			dwLoopValue *= 10;
			dwAttemptCount--;
		}
	}
	// restore the priority since we're done with the critical part
	SetPriorityClass (hProcess, dwPriorityClass);
	SetThreadPriority (hThread, dwThreadPriority);

	if (!bGoodSample) {
		MessageBox("Unable to calibrate delay loop");
	} else {
		// findout what the 1% count is
			
		if (llDiff != llOnePercent) {
			// then adjust the initial loop value was too big so reduce
			llResult = llOnePercent * dwLoopValue / llDiff;
			if (llResult & 0xFFFFFFFF00000000) {
				// this processor is TOO FAST! so don't change. 
			} else {
				dwReturn = (DWORD)(llResult & 0x00000000FFFFFFFF);
			}
		}
	}
	return dwReturn;
}

DWORD WorkerProc (LPDWORD	dwArg)
{
	DWORD	dwLoopCounter;
	LPTHREAD_INFO_BLOCK	pInfo;
	DWORD	dwStartingValue;
    DWORD   dwLocalValue;
    DWORD   dwLocalIndex;

	pInfo = (LPTHREAD_INFO_BLOCK)dwArg;
	
	dwStartingValue = pInfo->Dlg->m_dwLoopValue;

    srand( (unsigned)time( NULL ) );

	while (pInfo->Dlg->m_Active[pInfo->dwId]) {
		for (dwLoopCounter = dwStartingValue; dwLoopCounter; dwLoopCounter--) {
            if (pInfo->Dlg->m_pMemory != NULL) {
                do {
                    dwLocalIndex = rand();
                    dwLocalIndex *= pInfo->Dlg->m_dwRandomScale;
                } while (dwLocalIndex >= pInfo->Dlg->m_dwVASize);
                pInfo->Dlg->m_pMemory[dwLocalIndex] = dwLocalIndex;
                dwLocalValue = pInfo->Dlg->m_pMemory[dwLocalIndex];
                // reduce loop iterations to account for 
                // accessing memory
                if (pInfo->Dlg->m_Active[pInfo->dwId]) {
                    if (dwLoopCounter > 20) {
                        dwLoopCounter -= 20;
                    } else {
                        dwLoopCounter = 1;
                    }
                } else {
                    break; // out of loop
                }
            }
        }
		if (pInfo->Dlg->m_ActivityValue[pInfo->dwId] > 0) {
			Sleep (pInfo->Dlg->m_ActivityValue[pInfo->dwId]);
		}
	}
    pInfo->Dlg->m_ThreadHandle[pInfo->dwId] = NULL;
	delete pInfo;
	return 0;
}
#pragma optimize ("", on)

void CStressDlg::CreateWorkerThread (DWORD dwId)
{
	DWORD	dwThreadId;
	LPTHREAD_INFO_BLOCK	pInfo;

	// then start a new thread
	pInfo = new THREAD_INFO_BLOCK;
    if (!pInfo) {
         return;
    }
	pInfo->Dlg = this;
	pInfo->dwId = dwId;
	m_Active[dwId] = TRUE;
	m_ThreadHandle[dwId] = CreateThread (
		NULL, 0, 
		(LPTHREAD_START_ROUTINE)WorkerProc,
		(LPVOID)pInfo, 0, &dwThreadId);
	if (m_ThreadHandle[dwId] == NULL) {
		m_Active[dwId] = FALSE;
        delete pInfo;
	} else {
		// establish thread priority
		SetThreadPriority (
			m_ThreadHandle[dwId],
			m_PriorityValue[dwId]);
	}
}

void CStressDlg::SetThreadActivity (CComboBox * cActivityCombo, DWORD dwId)
{
	switch (cActivityCombo->GetCurSel()) {
		case 0:
			m_ActivityValue[dwId] = SLOW_ACTIVITY;
			break;
		case 1:
			m_ActivityValue[dwId] = MEDIUM_ACTIVITY;
			break;
		case 2:
			m_ActivityValue[dwId] = HIGH_ACTIVITY;
			break;
		case 3:
			m_ActivityValue[dwId] = HOG_ACTIVITY;
			break;
	}
}

void CStressDlg::SetThreadPriorityLevel (CComboBox * cPriorityCombo, DWORD dwId)
{
    LONG    lLastError = ERROR_SUCCESS;

	switch (cPriorityCombo->GetCurSel()) {
		case 0:
			m_PriorityValue[dwId] = (DWORD)THREAD_PRIORITY_IDLE;
			break;
		case 1:
			m_PriorityValue[dwId] = (DWORD)THREAD_PRIORITY_LOWEST;
			break;
		case 2:
			m_PriorityValue[dwId] = (DWORD)THREAD_PRIORITY_BELOW_NORMAL;
			break;
		case 3:
			m_PriorityValue[dwId] = (DWORD)THREAD_PRIORITY_NORMAL;
			break;
		case 4:
			m_PriorityValue[dwId] = (DWORD)THREAD_PRIORITY_ABOVE_NORMAL;
			break;
		case 5:
			m_PriorityValue[dwId] = (DWORD)THREAD_PRIORITY_HIGHEST;
			break;
		case 6:
			m_PriorityValue[dwId] = (DWORD)THREAD_PRIORITY_TIME_CRITICAL;
			break;
	}
	if (m_ThreadHandle[dwId] != NULL) {
		if (!SetThreadPriority (m_ThreadHandle[dwId], m_PriorityValue[dwId])) {
            lLastError = GetLastError ();
        }
    } // else no thread open
}

/////////////////////////////////////////////////////////////////////////////
// CStressDlg message handlers

BOOL CStressDlg::OnInitDialog()
{
	CDialog::OnInitDialog();

	// Add "About..." menu item to system menu.

	// IDM_ABOUTBOX must be in the system command range.
	ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
	ASSERT(IDM_ABOUTBOX < 0xF000);

	CMenu* pSysMenu = GetSystemMenu(FALSE);
	CString strAboutMenu;
	strAboutMenu.LoadString(IDS_ABOUTBOX);
	if (!strAboutMenu.IsEmpty())
	{
		pSysMenu->AppendMenu(MF_SEPARATOR);
		pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
	}

	// calibrate loop counter
	m_dwLoopValue = OnePercentCalibration (m_dwLoopValue) * 10;

	// Set the icon for this dialog.  The framework does this automatically
	//  when the application's main window is not a dialog
	SetIcon(m_hIcon, TRUE);			// Set big icon
	SetIcon(m_hIcon, FALSE);		// Set small icon

	// set the priority of this thread to "highest" so the UI will be
	// responsive
	SetThreadPriority (GetCurrentThread(), THREAD_PRIORITY_HIGHEST);

	// enable thread 1 & disable all others
	((CComboBox *)GetDlgItem(IDC_PROCESS_PRIORITY))->SetCurSel(1);

	CheckDlgButton (IDC_1_ACTIVE, 1);
	((CComboBox *)GetDlgItem(IDC_1_PRIORITY))->SetCurSel(3);
	((CComboBox *)GetDlgItem(IDC_1_ACTIVITY))->SetCurSel(0);

	CheckDlgButton (IDC_2_ACTIVE, 0);
	((CComboBox *)GetDlgItem(IDC_2_PRIORITY))->SetCurSel(3);
	((CComboBox *)GetDlgItem(IDC_2_ACTIVITY))->SetCurSel(0);

	CheckDlgButton (IDC_3_ACTIVE, 0);
	((CComboBox *)GetDlgItem(IDC_3_PRIORITY))->SetCurSel(3);
	((CComboBox *)GetDlgItem(IDC_3_ACTIVITY))->SetCurSel(0);

	CheckDlgButton (IDC_4_ACTIVE, 0);
	((CComboBox *)GetDlgItem(IDC_4_PRIORITY))->SetCurSel(3);
	((CComboBox *)GetDlgItem(IDC_4_ACTIVITY))->SetCurSel(0);

	// set the process priority
	OnSelchangeProcessPriority();

	// start the first thread
	On1Active();

    // don't access memory by default
    CheckDlgButton (IDC_USE_MEMORY, 0);
    (GetDlgItem (IDC_SHARED_MEM_SIZE))->EnableWindow (FALSE);

	return TRUE;  // return TRUE  unless you set the focus to a control
}

void CStressDlg::OnSysCommand(UINT nID, LPARAM lParam)
{
	if ((nID & 0xFFF0) == IDM_ABOUTBOX)
	{
		CAboutDlg dlgAbout;
		dlgAbout.DoModal();
	}
	else
	{
		CDialog::OnSysCommand(nID, lParam);
	}
}

// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.

void CStressDlg::OnPaint() 
{
	if (IsIconic())
	{
		CPaintDC dc(this); // device context for painting

		SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

		// Center icon in client rectangle
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// Draw the icon
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialog::OnPaint();
	}
}

// The system calls this to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR CStressDlg::OnQueryDragIcon()
{
	return (HCURSOR) m_hIcon;
}

void CStressDlg::On1Active() 
{
	DWORD	dwId = 0;

	if (IsDlgButtonChecked(IDC_1_ACTIVE)) {
		if (m_ThreadHandle[dwId] == NULL) {
			CreateWorkerThread (dwId);
		} else {
			// thread is already running
		}
	} else {
		m_Active[dwId] = FALSE;
		m_ThreadHandle[dwId] = NULL;
	}
}

void CStressDlg::OnSelchange1Activity() 
{
	CComboBox * cActivityCombo;
	DWORD		dwId = 0;
	
	cActivityCombo = (CComboBox *)GetDlgItem (IDC_1_ACTIVITY);
	SetThreadActivity (cActivityCombo, dwId);
}

void CStressDlg::OnSelchange1Priority() 
{
	CComboBox * cPriorityCombo;
	DWORD		dwId = 0;
	
	cPriorityCombo = (CComboBox *)GetDlgItem (IDC_1_PRIORITY);
	SetThreadPriorityLevel (cPriorityCombo, dwId);
}

void CStressDlg::On2Active() 
{
	DWORD	dwId = 1;

	if (IsDlgButtonChecked(IDC_2_ACTIVE)) {
		if (m_ThreadHandle[dwId] == NULL) {
			CreateWorkerThread (dwId);
		} else {
			// thread is already running
		}
	} else {
		m_Active[dwId] = FALSE;
		m_ThreadHandle[dwId] = NULL;
	}
}

void CStressDlg::OnSelchange2Activity() 
{
	CComboBox * cActivityCombo;
	DWORD		dwId = 1;
	
	cActivityCombo = (CComboBox *)GetDlgItem (IDC_2_ACTIVITY);
	SetThreadActivity (cActivityCombo, dwId);
}

void CStressDlg::OnSelchange2Priority() 
{
	CComboBox * cPriorityCombo;
	DWORD		dwId = 1;
	
	cPriorityCombo = (CComboBox *)GetDlgItem (IDC_2_PRIORITY);
	SetThreadPriorityLevel (cPriorityCombo, dwId);
}

void CStressDlg::On3Active() 
{
	DWORD	dwId = 2;

	if (IsDlgButtonChecked(IDC_3_ACTIVE)) {
		if (m_ThreadHandle[dwId] == NULL) {
			CreateWorkerThread (dwId);
		} else {
			// thread is already running
		}
	} else {
		m_Active[dwId] = FALSE;
		m_ThreadHandle[dwId] = NULL;
	}
}

void CStressDlg::OnSelchange3Activity() 
{
	CComboBox * cActivityCombo;
	DWORD		dwId = 2;
	
	cActivityCombo = (CComboBox *)GetDlgItem (IDC_3_ACTIVITY);
	SetThreadActivity (cActivityCombo, dwId);
}

void CStressDlg::OnSelchange3Priority() 
{
	CComboBox * cPriorityCombo;
	DWORD		dwId = 2;
	
	cPriorityCombo = (CComboBox *)GetDlgItem (IDC_3_PRIORITY);
	SetThreadPriorityLevel (cPriorityCombo, dwId);
}

void CStressDlg::On4Active() 
{
	DWORD	dwId = 3;

	if (IsDlgButtonChecked(IDC_4_ACTIVE)) {
		if (m_ThreadHandle[dwId] == NULL) {
			CreateWorkerThread (dwId);
		} else {
			// thread is already running
		}
	} else {
		m_Active[dwId] = FALSE;
        CloseHandle (m_ThreadHandle[dwId]);
		m_ThreadHandle[dwId] = NULL;
	}
}

void CStressDlg::OnSelchange4Activity() 
{
	CComboBox * cActivityCombo;
	DWORD		dwId = 3;
	
	cActivityCombo = (CComboBox *)GetDlgItem (IDC_4_ACTIVITY);
	SetThreadActivity (cActivityCombo, dwId);
}

void CStressDlg::OnSelchange4Priority() 
{
	CComboBox * cPriorityCombo;
	DWORD		dwId = 3;
	
	cPriorityCombo = (CComboBox *)GetDlgItem (IDC_4_PRIORITY);
	SetThreadPriorityLevel (cPriorityCombo, dwId);
}

void CStressDlg::OnOK() 
{
	CDialog::OnOK();
}

void CStressDlg::OnSelchangeProcessPriority() 
{

	CComboBox * cPriorityCombo;
	DWORD	dwPriorityClass;
	
	cPriorityCombo = (CComboBox *)GetDlgItem (IDC_PROCESS_PRIORITY);

	switch (cPriorityCombo->GetCurSel()) {
		case 0:
			dwPriorityClass = IDLE_PRIORITY_CLASS;
			break;
		case 1:
			dwPriorityClass = NORMAL_PRIORITY_CLASS;
			break;
		case 2:
			dwPriorityClass = HIGH_PRIORITY_CLASS;
			break;
	}
	SetPriorityClass (GetCurrentProcess(), dwPriorityClass);
}

void CStressDlg::OnKillfocusSharedMemSize() 
{
    return;	
}

void CStressDlg::OnChangeSharedMemSize() 
{
    CString csMemSize;
    TCHAR   szOldValue[MAX_PATH];
    DWORD   dwMemSize;

    csMemSize.Empty();
    GetDlgItemText (IDC_SHARED_MEM_SIZE, csMemSize);
    dwMemSize = _tcstoul ((LPCTSTR)csMemSize, NULL, 10);
    dwMemSize *= 1024 / sizeof(DWORD);

    if (dwMemSize != m_dwVASize) {
        // threads must be stopped to change memory size
        if (m_Active[0] || m_Active[1] || m_Active[2] || m_Active[3]) {
            MessageBox (
                TEXT("All threads must be stopped before this value can be changed"));
            _stprintf (szOldValue, TEXT("%d"), ((m_dwVASize * sizeof(DWORD))/1024));
            (GetDlgItem(IDC_SHARED_MEM_SIZE))->SetWindowText(szOldValue);
            return;
        } else {
            if (m_pMemory != NULL) {
                delete (m_pMemory);
                m_pMemory = NULL;
                m_dwVASize = 0;
            }
            m_dwVASize = dwMemSize;
            m_pMemory = new DWORD[m_dwVASize];
            if (m_pMemory == NULL) {
                m_dwVASize = 0;
            }
        }
    }
}

void CStressDlg::OnUseMemory() 
{
    CString csMemSize;
    DWORD   dwMemSize;
    BOOL    bState;

    if (m_Active[0] || m_Active[1] || m_Active[2] || m_Active[3]) {
        MessageBox (TEXT("All threads must be stopped before this value can be changed"));
        bState = !IsDlgButtonChecked(IDC_USE_MEMORY); //revert state
    } else {
        if (IsDlgButtonChecked(IDC_USE_MEMORY)) {
            // if no memory is allocated, then allocate it
            if (m_pMemory != NULL) {
                delete (m_pMemory);
                m_pMemory = NULL;
                m_dwVASize = 0;
            }
            //get va size
            csMemSize.Empty();
            GetDlgItemText (IDC_SHARED_MEM_SIZE, csMemSize);
            dwMemSize = _tcstoul ((LPCTSTR)csMemSize, NULL, 10);
            m_dwVASize = dwMemSize * 1024 / sizeof(DWORD);
            m_pMemory = new DWORD[m_dwVASize];
            if (m_pMemory == NULL) {
                m_dwVASize = 0;
            } else {
                m_dwRandomScale = (m_dwVASize / RAND_MAX) + 1;
            }
            bState = TRUE;
        } else {
            // button is unchecked so free memory
            if (m_pMemory != NULL) {
                delete (m_pMemory);
                m_pMemory = NULL;
                m_dwVASize = 0;
            }
            bState = FALSE;
        }
    }
    CheckDlgButton (IDC_USE_MEMORY, bState);
    (GetDlgItem (IDC_SHARED_MEM_SIZE))->EnableWindow (bState);
}

void CStressDlg::OnClose() 
{
    // stop threads first
    m_Active[0] = FALSE;
    m_Active[1] = FALSE;
    m_Active[2] = FALSE;
    m_Active[3] = FALSE;

    // wait for the threads to finish
    while (m_ThreadHandle[0] || m_ThreadHandle[1] ||
        m_ThreadHandle[2] || m_ThreadHandle[3]) {
        Sleep(100);
    }

    // free memory block
    if (m_pMemory != NULL) {
        delete (m_pMemory);
        m_pMemory = NULL;
        m_dwVASize = 0;
    }
	
	CDialog::OnClose();
}

void CStressDlg::OnDestroy() 
{
	CDialog::OnDestroy();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\crash\driver\crashdrv.c ===
#include <ntddk.h>
#include <string.h>
#include "crashdrv.h"


#define MEMSIZE         4096
#define FCN(cc)         ((cc >> 2) & 0xFFFFFF)
#define DEVICE_NAME     L"\\Device\\CrashDrv"
#define DOSDEVICE_NAME  L"\\DosDevices\\CrashDrv"


typedef VOID (*PTESTFUNC)(PULONG ub);

PTESTFUNC tests[] =
    {
    NULL,
    CrashDrvBugCheck,
    CrashDrvStackOverFlow,
    CrashDrvSimpleTest,
    CrashDrvExceptionTest,
    CrashDrvHardError,
    CrashSpecial
    };

#define MaxTests  (sizeof(tests)/sizeof(PTESTFUNC))

ULONG   CrashDrvRequest;
KEVENT  CrashEvent;
ULONG   CrashRequest;
PULONG  Funk;


NTSTATUS
CrashDrvOpenClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
CrashDrvUnload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
CrashDrvIoControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
CrashThread(
    PVOID Context
    );



NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT   DriverObject,
    IN PUNICODE_STRING  RegistryPath
    )
{
    UNICODE_STRING      DeviceName;
    PDEVICE_OBJECT      deviceObject;
    NTSTATUS            status;
    UNICODE_STRING      LinkObject;
    WCHAR               LinkName[80];
    ULONG               DeviceSize;
    HANDLE              ThreadHandle;


    RtlInitUnicodeString( &DeviceName, DEVICE_NAME );
    status = IoCreateDevice( DriverObject,
                             0,
                             &DeviceName,
                             FILE_DEVICE_NULL,
                             0,
                             FALSE,
                             &deviceObject );
    if (!NT_SUCCESS( status )) {
        return status;
    }

    LinkName[0] = UNICODE_NULL;

    RtlInitUnicodeString(&LinkObject, LinkName);

    LinkObject.MaximumLength = sizeof(LinkName);

    RtlAppendUnicodeToString(&LinkObject, L"\\DosDevices");

    DeviceSize = sizeof(L"\\Device") - sizeof(UNICODE_NULL);
    DeviceName.Buffer += DeviceSize / sizeof(WCHAR);
    DeviceName.Length -= (USHORT)DeviceSize;

    RtlAppendUnicodeStringToString(&LinkObject, &DeviceName);

    DeviceName.Buffer -= DeviceSize / sizeof(WCHAR);
    DeviceName.Length += (USHORT)DeviceSize;

    status = IoCreateSymbolicLink(&LinkObject, &DeviceName);

    if (!NT_SUCCESS(status)) {
        IoDeleteDevice( deviceObject );
        return status;
    }

    DriverObject->MajorFunction[IRP_MJ_CREATE]         = CrashDrvOpenClose;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]          = CrashDrvOpenClose;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = CrashDrvIoControl;
    DriverObject->DriverUnload                         = CrashDrvUnload;

    KeInitializeEvent( &CrashEvent, NotificationEvent, FALSE );

    Funk = ExAllocatePool( PagedPool, MEMSIZE );

    status = PsCreateSystemThread(
        &ThreadHandle,
        0,
        NULL,
        0,
        NULL,
        CrashThread,
        NULL
        );

    return STATUS_SUCCESS;
}

NTSTATUS
CrashDrvOpenClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    NTSTATUS status = STATUS_SUCCESS;

    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;
    status = Irp->IoStatus.Status;
    IoCompleteRequest( Irp, 0 );

    return status;
}

VOID
CrashDrvUnload(
    IN PDRIVER_OBJECT DriverObject
    )
{
    PDEVICE_OBJECT currentDevice = DriverObject->DeviceObject;
    UNICODE_STRING fullLinkName;

    while (currentDevice) {

        RtlInitUnicodeString( &fullLinkName, DOSDEVICE_NAME );
        IoDeleteSymbolicLink(&fullLinkName);
        IoDeleteDevice(currentDevice);

        currentDevice = DriverObject->DeviceObject;

    }
}

NTSTATUS
CrashDrvIoControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
{
    NTSTATUS            Status = STATUS_SUCCESS;
    PIO_STACK_LOCATION  IrpSp  = IoGetCurrentIrpStackLocation(Irp);
    PULONG              ub;


    ub = (PULONG) MmGetSystemAddressForMdl( Irp->MdlAddress );

    if (IrpSp->Parameters.DeviceIoControl.IoControlCode == IOCTL_CRASHDRV_CHECK_REQUEST) {
        ub[0] = CrashDrvRequest;
        CrashDrvRequest = 0;
    } else {
        if (FCN(IrpSp->Parameters.DeviceIoControl.IoControlCode) > MaxTests) {
            DbgBreakPoint();
        } else {
            tests[FCN(IrpSp->Parameters.DeviceIoControl.IoControlCode)]( ub );
        }
    }

    Irp->IoStatus.Information = 0L;
    Irp->IoStatus.Status = Status;
    IoCompleteRequest( Irp, 0 );

    return Status;
}


VOID
CrashThread(
    PVOID Context
    )
{
    while( TRUE ) {
        KeWaitForSingleObject( &CrashEvent, Executive, KernelMode, FALSE, NULL );
        KeResetEvent( &CrashEvent );
        switch( CrashRequest ) {
            case KMODE_EXCEPTION_NOT_HANDLED:
                {
                    ULONG i,j;
                    i = 0;
                    j = 0;
                    i = j / i;
                }
                break;

            case IRQL_NOT_LESS_OR_EQUAL:
                {
                    KIRQL irql;
                    KeRaiseIrql( DISPATCH_LEVEL, &irql );
                    Funk[0] = 0;
                    KeLowerIrql( irql );
                }
                break;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\creatfil\creatf.h ===
/*** Creatf.H - Function declarations/defines for CreatF.C routines.
 *
 *
 * Title:
 *	Creatf external function declarations/defines
 *
 *      Copyright (c) 1993, Microsoft Corporation.
 *	HonWah Chan.
 *
 *
 * Modification History:
 *	93.5.17  HonWah Chan -- created
 *
 */



/* * * *  E x t e r n a l   F u n c t i o n   D e c l a r a t i o n s  * * * */

extern BOOL  Failed (RC rc, LPSTR lpstrFname, WORD lineno, LPSTR lpstrMsg);

extern void  DisplayUsage (void);

extern LPVOID MemoryAllocate (DWORD dwSize);

extern VOID MemoryFree (LPVOID lpMemory);

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\crash\driver\crashdrv.h ===
//
// CrashDrv driver/test constants
//

#define FILE_DEVICE_CRASHDRV              0x00008000


#define TEST_CHECK_REQUEST              0
#define TEST_BUGCHECK                   1
#define TEST_STACK_OVERFLOW             2
#define TEST_SIMPLE                     3
#define TEST_EXCEPTION                  4
#define TEST_HARDERR                    5
#define TEST_SPECIAL                    6

#define IOCTL_CRASHDRV_CHECK_REQUEST      CTL_CODE(FILE_DEVICE_CRASHDRV, TEST_CHECK_REQUEST,  METHOD_OUT_DIRECT,FILE_ANY_ACCESS)
#define IOCTL_CRASHDRV_BUGCHECK           CTL_CODE(FILE_DEVICE_CRASHDRV, TEST_BUGCHECK,       METHOD_OUT_DIRECT,FILE_ANY_ACCESS)
#define IOCTL_CRASHDRV_STACK_OVERFLOW     CTL_CODE(FILE_DEVICE_CRASHDRV, TEST_STACK_OVERFLOW, METHOD_OUT_DIRECT,FILE_ANY_ACCESS)
#define IOCTL_CRASHDRV_SIMPLE             CTL_CODE(FILE_DEVICE_CRASHDRV, TEST_SIMPLE,         METHOD_OUT_DIRECT,FILE_ANY_ACCESS)
#define IOCTL_CRASHDRV_EXCEPTION          CTL_CODE(FILE_DEVICE_CRASHDRV, TEST_EXCEPTION,      METHOD_OUT_DIRECT,FILE_ANY_ACCESS)
#define IOCTL_CRASHDRV_HARDERR            CTL_CODE(FILE_DEVICE_CRASHDRV, TEST_HARDERR,        METHOD_OUT_DIRECT,FILE_ANY_ACCESS)
#define IOCTL_CRASHDRV_SPECIAL            CTL_CODE(FILE_DEVICE_CRASHDRV, TEST_SPECIAL,        METHOD_OUT_DIRECT,FILE_ANY_ACCESS)


//
// prototypes
//

VOID
CrashDrvStackOverFlow(
    PULONG ub
    );

VOID
CrashDrvBugCheck(
    PULONG ub
    );

VOID
CrashDrvSimpleTest(
    PULONG ub
    );

VOID
CrashDrvExceptionTest(
    PULONG ub
    );

VOID
CrashDrvHardError(
    PULONG ub
    );

VOID
CrashSpecial(
    PULONG ub
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\creatfil\creatf.c ===
/*** CreatF.C - Utility functions for Win 32 Cache Flusher.
 *
 *
 * Title:
 *	CreatF - Create File Utility Routines
 *
 *      Copyright (c) 1993, Microsoft Corporation.
 *	HonWah Chan.
 *
 *
 * Description:
 *
 *	This file includes all the utility functions used by the Win 32
 *	Create File. (CreatF.c)
 *
 *
 * Design/Implementation Notes:
 *
 *
 * Modification History:
 * 93.05.17  HonWahChan -- created
 *
 */



/* * * * * * * * * * * * *  I N C L U D E    F I L E S  * * * * * * * * * * */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <malloc.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>


/* * * * * * * * * *  G L O B A L   D E C L A R A T I O N S  * * * * * * * * */
#include "Creatfil.h"



/* * * * * * * * * *  F U N C T I O N   P R O T O T Y P E S  * * * * * * * * */

#include "Creatf.h"



/* * * * * * * * * * *  G L O B A L    V A R I A B L E S  * * * * * * * * * */
/* none */



/* * * * * *  E X P O R T E D   G L O B A L    V A R I A B L E S  * * * * * */
/* none */





/*******************************  F a i l e d  *******************************
 *
 *      Failed(rc, lpstrFname, lineno, lpstrMsg) -
 *              Checks the RC for an error type if an error has occured,
 *              prints the appropriate error message.  It logs the error
 *              message to the testlog file.
 *
 *      ENTRY   rc         - return code from the last API call
 *              lpstrFname - contains file name of where error occured
 *              lineno     - contains line number of failed API call
 *              lpstrMsg   - contains a general purpose message about the error
 *
 *      EXIT    -none-
 *
 *      RETURN  TRUE  - if API failed
 *              FALSE - if API successful
 *
 *      WARNING:  
 *              -none-
 *
 *      COMMENT:  
 *              -none-
 *                
 */

BOOL Failed (RC rc, LPSTR lpstrFname, WORD lineno, LPSTR lpstrMsg)
{
    LPSTR lpstrErrMsg;


    if (rc != STATUS_SUCCESS) {

        switch (rc) {

            case (NTSTATUS)STATUS_INVALID_PARAMETER:
                lpstrErrMsg = "Invalid parameter";
                break;

            case STATUS_TIMEOUT:
                lpstrErrMsg = "TimeOut occured";
                break;

            case STATUS_INVALID_HANDLE:
                lpstrErrMsg = "Invalid handle";
                break;

            case STATUS_BUFFER_OVERFLOW:
                lpstrErrMsg = "Buffer overflow";
                break;

            case STATUS_ABANDONED:
                lpstrErrMsg = "Object abandoned";
                break;

            case ERROR_NOT_ENOUGH_MEMORY:
                lpstrErrMsg = "Not enough memory";
                break;

            case INPUTARGS_ERR:
                lpstrErrMsg = "Invalid number of input arguments";
                break;

            case FILESIZE_ERR:
                lpstrErrMsg = "Invalid file size argument";
                break;

            case INSUFMEM_ERR:
                lpstrErrMsg = "Insufficient Memory";
                break;

            case FCLOSE_ERR:
                lpstrErrMsg = "fclose() failed";
                break;

            case FOPEN_ERR:
                lpstrErrMsg = "fopen() failed";
                break;

            case FSEEK_ERR:
                lpstrErrMsg = "fseek() failed";
                break;

            case FWRITE_ERR:
                lpstrErrMsg = "WriteFile() failed";
                break;

            default:
                lpstrErrMsg = "";

        } /* switch(rc) */

        printf(" **************************\n");
        printf(" * FAILure --> Line=%d File=%s (pid=0x%lX tid=0x%lX)\n",
               lineno, lpstrFname, GetCurrentProcessId(),
               GetCurrentThreadId());
        printf(" * RC=0x%lX (%s)\n", rc, lpstrErrMsg);
        printf(" * %s\n", lpstrMsg);
        printf(" **************************\n");

        return(TRUE);

    } /* if(rc..) */

    return(FALSE);

} /* Failed() */





/**************************  D i s p l a y U s a g e  ************************
 *
 *      DisplayUsage() -
 *		Displays usgae for Create File
 *
 *      ENTRY   -none-
 *
 *      EXIT    -none-
 *
 *      RETURN  -none-
 *
 *      WARNING:
 *              -none-
 *
 *      COMMENT:  
 *              -none-
 *                
 */

void DisplayUsage (void)
{

    printf("\nUsage:  CreatFil <FileName> <FileSize>\n");
    printf("    CreatFil - Create a file with the specified File name with the specified file sizes in bytes\n");

    return;

} /* DisplayUsage() */

/*
 *      MemoryAllocate() -
 *          Allocate a memory with the specified size
 *
 *      ENTRY   dwSize - size of buffer to be allocated
 *
 *      EXIT    -none-
 *
 *      RETURN  -none-
 *
 *      WARNING:
 *              -none-
 *
 *      COMMENT:  
 *              -none-
 *                
 */

LPVOID MemoryAllocate (DWORD dwSize)
   {  // MemoryAllocate
   HGLOBAL        hMemory ;
   LPVOID         lpMemory ;

   hMemory = GlobalAlloc (GHND, dwSize) ;
   if (!hMemory)
      return (NULL) ;
   lpMemory = GlobalLock (hMemory) ;
   if (!lpMemory)
      GlobalFree (hMemory) ;
   return (lpMemory) ;
   }  // MemoryAllocate

/*
 *      MemoryFree() -
 *		      Free a previously allocated memory.
 *
 *      ENTRY   lpMemory - Buffer address to be freeed
 *
 *      EXIT    -none-
 *
 *      RETURN  -none-
 *
 *      WARNING:
 *              -none-
 *
 *      COMMENT:  
 *              -none-
 *                
 */

VOID MemoryFree (LPVOID lpMemory)
   {  // MemoryFree
   HGLOBAL        hMemory ;

   if (!lpMemory)
      return ;

   hMemory = GlobalHandle (lpMemory) ;

   if (hMemory)
      {  // if
      GlobalUnlock (hMemory) ;
      GlobalFree (hMemory) ;
      }  // if
   }  // MemoryFree
 

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\creatfil\creatfil.h ===
/*** creatfil.h- Public defines and structure definitions for create file
 *
 *
 * Title:
 *	Create File include file used by all
 *
 *      Copyright (c) 1993, Microsoft Corporation.
 *	HonWah Chan.
 *
 *
 * Modification History:
 *	93.05.17 - HonWah Chan -- Created
 *
 */



/* * * * * * * * *   N T   C o m m o n   D e f i n e s   * * * * * * * * * */

#define RC        NTSTATUS


/* * * * * * * *   C o m m o n   M i s c .   D e f i n e s   * * * * * * * */

   #define STATIC          // functions can easily become non-static by        
                           // changing this define to "".  Remember that
                           // static functions are not visiable by the
			   // kernel debugger.

   #define RESERVED_NULL NULL // Reserved null fields


// User defined error codes
//
#define INPUTARGS_ERR  0x7FFFFF02L  // Error code for invalid number of
                                    // input arguments
#define   FILEARG_ERR  0x7FFFFF03L  // Error code for invalid input file
                                    // argument
#define  FILESIZE_ERR  0x7FFFFF04L  // Error code for file size argument
#define  INSUFMEM_ERR  0x7FFFFF05L  // Error code indicating memory can't
                                    // be allocated by MALLOC/REALLOC
#define     FSEEK_ERR  0x7FFFFF07L  // Error code indicating fseek()
                                    // failure
#define    FCLOSE_ERR  0x7FFFFF08L  // Error code indicating fclose()
                                    // failure
#define    FWRITE_ERR  0x7FFFFF09L  // Error code indicating WriteFile()
                                    // failure
#define     FOPEN_ERR  0x7FFFFF0AL  // Error code indicating fopen()
                                    // failure


// Maximu length defines
//
#define  FNAME_LEN		  256	// Maximum file name langth
#define  LINE_LEN                128   // Maximum input line length

#define    ERR_NOFILE  0xFFFFFFFFL  // Failure from CreateFile

// String (EXEs & KEYs) constants
//
#define 	CREATFIL_EXE	     "CREATFIL.EXE"	// CREATFIL's binary name



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\crash\driver\tests.c ===
#include <ntosp.h>

extern KEVENT  CrashEvent;
extern ULONG   CrashRequest;

unsigned int fExcept1    = 0;
unsigned int cTry1       = 0;
unsigned int cRaise1pre  = 0;
unsigned int cRaise1post = 0;
unsigned int cExcept1    = 0;
unsigned int cFilter1    = 0;

unsigned int fExcept2    = 0;
unsigned int cTry2       = 0;
unsigned int cRaise2pre  = 0;
unsigned int cRaise2post = 0;
unsigned int cFinally2   = 0;

unsigned int fExcept3    = 0;
unsigned int cTry3       = 0;
unsigned int cRaise3pre  = 0;
unsigned int cRaise3post = 0;
unsigned int cExcept3    = 0;
unsigned int cFilter3    = 0;

unsigned int fExcept4    = 0;
unsigned int cTry4       = 0;
unsigned int cRaise4pre  = 0;
unsigned int cRaise4post = 0;
unsigned int cFinally4   = 0;

unsigned int fExcept5    = 0;
unsigned int cTry5       = 0;
unsigned int cRaise5pre  = 0;
unsigned int cRaise5post = 0;
unsigned int cExcept5    = 0;
unsigned int cFilter5    = 0;

unsigned long GlobalVar  = 0;

int ExceptFilterFn5 (int ExceptCode)
{
    DbgPrint( "CrashDrv exception filter\n" );
    cFilter5 ++;
    return ExceptCode == 0x00003344 ? EXCEPTION_EXECUTE_HANDLER    :
                                      EXCEPTION_CONTINUE_EXECUTION ;
}

void function5 ()
{
    _try
    {
        cTry5 ++;
        if (fExcept5)
        {
            cRaise5pre ++;
            ExRaiseStatus( fExcept4 );
            cRaise5post ++;
        }
    }
    _except (ExceptFilterFn5 (GetExceptionCode ()))
    {
        cExcept5 ++;
    }
}

void function4 ()
{
    _try
    {
        cTry4 ++;
        function5 ();
        if (fExcept4)
        {
            cRaise4pre ++;
            ExRaiseStatus( fExcept4 );
            cRaise4post ++;
        }
    }
    _finally
    {
        cFinally4 ++;
    }
}

int ExceptFilterFn3 (int ExceptCode)
{
    cFilter3 ++;
    return ExceptCode == 0x00005678 ? EXCEPTION_EXECUTE_HANDLER :
                                      EXCEPTION_CONTINUE_SEARCH ;
}

void function3 ()
{
    _try
    {
        cTry3 ++;
        function4 ();
        if (fExcept3)
        {
            cRaise3pre ++;
            ExRaiseStatus( fExcept3 );
            cRaise3post ++;
        }
    }
    _except (ExceptFilterFn3 (GetExceptionCode ()))
    {
        cExcept3 ++;
    }
}

void function2 ()
{
    _try
    {
        cTry2 ++;
        function3 ();
        if (fExcept2)
        {
            cRaise2pre ++;
            ExRaiseStatus( fExcept2 );
            cRaise2post ++;
        }
    }
    _finally
    {
        cFinally2 ++;
    }
}

int ExceptFilterMain (int ExceptCode)
{
    cFilter1 ++;
    return ExceptCode == 0x00001010 ? EXCEPTION_EXECUTE_HANDLER    :
           ExceptCode == 0x00005678 ? EXCEPTION_CONTINUE_EXECUTION :
                                      EXCEPTION_CONTINUE_SEARCH    ;
}

VOID
CrashDrvExceptionTest(
    PULONG ub
    )
{
    int i = 0;

    while ( i++ < 10 ) {
        _try {
            cTry1 ++;
            function2 ();
            if (fExcept1) {
                cRaise1pre ++;
                ExRaiseStatus( fExcept1 );
                cRaise1post ++;
            }
        }
        _except (ExceptFilterMain (GetExceptionCode ())) {
            cExcept1 ++;
        }
        fExcept1 = 0;
        fExcept2 = 0;
        fExcept3 = 0;
        fExcept4 = 0;
        fExcept5 = 0;
    }
}

VOID
CrashDrvSimpleTest(
    PULONG ub
    )
{
    int i = 0;
    int j = 0;
    int k = 0;
    GlobalVar = 69;
    i = 1;
    j = 2;
    k = 3;
}

#pragma warning(disable:4717) // disable recursion check

VOID
CrashDrvStackOverFlow(
    PULONG ub
    )
{
    struct {
        int a;
        int b;
        int c;
        int d;
        int e;
        int f;
        int g;
        int h;
        int i;
    } Foo;

    RtlFillMemory (&Foo, 'a', sizeof (Foo));

    CrashDrvStackOverFlow ((PVOID) &Foo);

    return;
}


VOID
CrashDrvBugCheck(
    PULONG ub
    )
{
    KeBugCheck( 0x69696969 );
}

VOID
CrashDrvHardError(
    PULONG ub
    )
{
    NTSTATUS Status;
    NTSTATUS ErrorCode;
    ULONG    Response;


    ErrorCode = STATUS_SYSTEM_PROCESS_TERMINATED;

    Status = ExRaiseHardError(
        ErrorCode,
        0,
        0,
        NULL,
        OptionShutdownSystem,
        &Response
        );

    return;
}


ULONG CurrentWatchPoint=0;

VOID
AsyncSetBreakPoint(
    ULONG LinearAddress
    )
{
#ifdef i386
    CurrentWatchPoint = LinearAddress;

    _asm {
            mov     eax, LinearAddress
            mov     dr0, eax
            mov     eax, 10303h
            mov     dr7, eax
    }
#endif
}

VOID
AsyncRemoveBreakPoint(
    ULONG LinearAddress
    )
{
#ifdef i386
    CurrentWatchPoint = 0;

    _asm {
            mov     eax, 0
            mov     dr7, eax
    }
#endif
}

#pragma optimize ( "", on )

VOID
CrashSpecial(
    PULONG ub
    )
{
    CrashRequest = ub[0];
    KeSetEvent( &CrashEvent, 0, FALSE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\ctlcode\ctlcode.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    CtlCode.c

Abstract:

    A user mode app that breaks down a CTL_CODE (from IOCTL Irp)
    Into its component parts of BASE, #, Method, and Access.

Environment:

    User mode only

Revision History:

    07-14-98 : Created by henrygab

--*/

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>
#include <math.h>

#include "CtlCode.h"

#if DBG
    #define DEBUG_BUFFER_LENGTH 1000
    ULONG DebugLevel = 0;
    UCHAR DebugBuffer[DEBUG_BUFFER_LENGTH];

    VOID
    __cdecl
    CtlCodeDebugPrint(
        ULONG DebugPrintLevel,
        PCCHAR DebugMessage,
        ...
        )
    {
        va_list ap;

        va_start(ap, DebugMessage);

        if ((DebugPrintLevel <= (DebugLevel & 0x0000ffff)) ||
            ((1 << (DebugPrintLevel + 15)) & DebugLevel)) {

            _vsnprintf(DebugBuffer, DEBUG_BUFFER_LENGTH, DebugMessage, ap);
            fprintf(stderr, DebugBuffer);

        }
        va_end(ap);
    }

    #define DebugPrint(x) CtlCodeDebugPrint x
#else
    #define DebugPrint(x)
#endif // DBG


VOID
DecodeIoctl(
    PCTL_CODE CtlCode
    );
BOOLEAN
IsHexNumber(
   const char *szExpression
   );
BOOLEAN
IsDecNumber(
   const char *szExpression
   );

//
// List of commands
// all command names are case sensitive
// arguments are passed into command routines
// list must be terminated with NULL command
// command will not be listed in help if description == NULL
//

ULONG32 ListCommand();

//
// prints an attenuation table based off cdrom standard volume
//

ULONG32 AttenuateCommand( int argc, char *argv[]);

VOID FindCommand(int argc, char *argv[]);
ULONG32 DecodeCommand(int argc, char *argv[]);
ULONG32 EncodeCommand(int argc, char *argv[]);



int __cdecl main(int argc, char *argv[])
/*++

Routine Description:

    Parses input, showing help or calling function requested appropriately

Return Value:

     0 - success
    -1 - insufficient arguments
    -2 - error opening device (DNE?)

--*/
{
    int i = 0;

    DebugPrint((3, "main => entering\n"));

    if (argc != 2 && argc != 5) {

        DebugPrint((3, "main => bad argc: %x, printing help\n", argc));
        printf("Usage: ctl_code [parameters]\n");
        return ListCommand();
    }

    if (!strcmp(argv[1], "-?") ||
        !strcmp(argv[1], "-h") ||
        !strcmp(argv[1], "/?") ||
        !strcmp(argv[1], "/h")
        ) {

        DebugPrint((3, "main => Help requested...\n"));
        ListCommand();
        return -1;

    }


    if (argc == 5) {

        DebugPrint((3, "main => encoding four args to one ioctl\n"));
        EncodeCommand((argc - 1), &(argv[1]));

    } else if (!IsHexNumber(argv[1])) {

        //
        // probably a string, so find matches?
        //

        DebugPrint((3, "main => non-hex argument, searching for matches\n"));
        FindCommand((argc - 1), &(argv[1]));

    } else {

        //
        // only one number passed in, so decode it
        //

        DebugPrint((3, "main => one hex argument, decoding\n"));
        DecodeCommand((argc - 1), &(argv[1]));

    }

    return 0;
}


ULONG32 ListCommand()
/*++

Routine Description:

    Prints out the command list (help)

Arguments:

    argc - unused
    argv - unused

Return Value:

    STATUS_SUCCESS

--*/

{
    printf("\n"
           "CtlCode encodes/decodes ioctls into their four parts\n"
           "(device type, function, method, access) and prints them out\n"
           "symbolically.  If encoding an ioctl, symbolic names can be\n"
           "used for many inputs:\n"
           "\tDevice Type (can drop the FILE_DEVICE prefix)\n"
           "\tFunction    (not applicable)\n"
           "\tMethods     (can drop the METHOD_ prefix)\n"
           "\tAccess      (can drop the FILE_ prefix and/or _ACCESS postfix)\n"
           "\n"
           "Also, any search string with only one match will give\n"
           "full information.  The following two commands are\n"
           "equivalent if no other ioctl has the substring 'UNLOAD':\n"
           "\tCtlCode.exe IOCTL_CDROM_UNLOAD_DRIVER\n"
           "\tCtlCode.exe UNLOAD\n"
           "\n"
           "All input and output is in hexadecimal"
           "    string   - prints all matches\n"
           "    #        - decodes the ioctl\n"
           "    # # # #  - encodes the ioctl base/#/method/access\n"
           );
    return 0;
}

VOID FindCommand(int argc, char *argv[])
{
    char * currentPosition;
    size_t arglen;
    BOOLEAN found;
    LONG i;
    LONG j;
    LONG numberOfMatches;
    LONG lastMatch;

    DebugPrint((3, "Find => entering\n"));

    if (argc != 1) {
        DebugPrint((0,
                    "Find !! Programming error               !!\n"
                    "Find !! should only pass in one string  !!\n"
                    "Find !! to match against.  Passed in %2x !!\n",
                    argc + 1
                    ));
        return;
    }

    numberOfMatches = 0;

    //
    // for each name in the table
    //

    for (j=0;TableIoctlValue[j].Name != NULL;j++) {

        currentPosition = TableIoctlValue[j].Name;
        found = FALSE;

        //
        // see if we can match it to any argument
        //
        DebugPrint((3, "Find => matching against table entry %x\n", j));

        arglen = strlen(argv[0]);

        //
        // accept partial matches to any substring
        //
        while (*currentPosition != 0) {

            if (_strnicmp(argv[0],
                          currentPosition,
                          arglen)==0) {
                found = TRUE;
                break; // out of while loop
            }
            currentPosition++;

        }

        //
        // if found, print it.
        //
        if (found) {

            if (numberOfMatches == 0) {

                //
                // don't print the first match right away,
                // as it may be the only match, which should
                // then be decoded
                //

                DebugPrint((3, "Find => First Match (%x) found\n", j));
                lastMatch = j;

            } else if (numberOfMatches == 1) {

                //
                // if this is the second match, print the header
                // and previous match info also
                //

                DebugPrint((3, "Find => Second Match (%x) found\n", j));
                printf("Found the following matches:\n");
                printf("\t%-40s - %16x\n",
                       TableIoctlValue[lastMatch].Name,
                       TableIoctlValue[lastMatch].Code);
                printf("\t%-40s - %16x\n",
                       TableIoctlValue[j].Name,
                       TableIoctlValue[j].Code);
            } else {

                DebugPrint((3, "Find => Another Match (%x) found\n", j));
                printf("\t%-40s - %16x\n",
                       TableIoctlValue[j].Name,
                       TableIoctlValue[j].Code);

            }

            numberOfMatches++;
        } // end if (found) {}

    } // end of loop through table

    DebugPrint((2, "Find => Found %x matches total\n", numberOfMatches));

    //
    // if didn't find any matches, tell them so.
    //
    if (numberOfMatches == 0) {
        printf("No matches found.\n");
    } else if (numberOfMatches == 1) {
        DebugPrint((2, "Find => Decoding ioctl at index (%x)\n", lastMatch));
        DecodeIoctl((PVOID)&(TableIoctlValue[lastMatch].Code));
    }

}
ULONG32 EncodeCommand(int argc, char *argv[])
/*++

Routine Description:

    Change four components into a Ctl_Code

Arguments:

    argc - the number of additional arguments.  prompt if zero
    argv - the additional arguments

Return Value:

    STATUS_SUCCESS if successful

--*/
{
    CTL_CODE maxValues;
    CTL_CODE encoded;
    ULONG temp;

    encoded.Code = 0;
    maxValues.Code = -1; // all 1's

    DebugPrint((3, "Encode => entering\n"));

    // device type
    if (IsHexNumber(argv[0])) {

        //
        // read and verify the hex number
        //
        DebugPrint((3, "Encode => arg 1 is hex\n"));

        temp = strtol(argv[0], (char**)NULL, 0x10);
        if (temp > maxValues.DeviceType) {
            printf("Max Device Type: %x\n", maxValues.DeviceType);
            return STATUS_SUCCESS;
        }
        encoded.DeviceType = temp;

    } else {

        //
        // read and match the device type
        //

        DebugPrint((3, "Encode => arg 1 is non-hex, attempting "
                    "string match\n"));

        for (temp = 0; temp < MAX_IOCTL_DEVICE_TYPE; temp++) {

            if (_stricmp(TableIoctlDeviceType[temp].Name, argv[0]) == 0) {
                DebugPrint((2, "Encode => arg 1 matched index %x (full)\n",
                            temp));
                encoded.DeviceType = TableIoctlDeviceType[temp].Value;
                break;
            }

            //
            // no need to have common prefixes
            //
            if ((strlen(TableIoctlDeviceType[temp].Name) > strlen("FILE_DEVICE_"))
                &&
                (_stricmp(TableIoctlDeviceType[temp].Name + strlen("FILE_DEVICE_"),argv[0]) == 0)
                ) {
                DebugPrint((2, "Encode => arg 1 matched index %x "
                            "(dropped prefix)\n", temp));
                encoded.DeviceType = TableIoctlDeviceType[temp].Value;
                break;
            }

        }

        if (temp == MAX_IOCTL_DEVICE_TYPE) {
            printf("Device Type %s unknown.  Known Device Types:\n");
            for (temp = 0; temp < MAX_IOCTL_DEVICE_TYPE; temp++) {
                printf("\t%s\n", TableIoctlDeviceType[temp].Name);
            }
            return STATUS_SUCCESS;
        }

        DebugPrint((3, "Encode => arg 1 matched string index %x\n", temp));

    }

    // function number
    if (IsHexNumber(argv[1])) {

        DebugPrint((3, "Encode => arg 2 is hex\n"));

        //
        // read and verify the hex number
        //

        temp = strtol(argv[1], (char**)NULL, 0x10);
        if (temp > maxValues.Function) {
            printf("Max Function: %x\n", maxValues.Function);
            return STATUS_SUCCESS;
        }
        encoded.Function = temp;

    } else {

        printf("Function: must be a hex number\n");
        return STATUS_SUCCESS;
    }

    // method
    if (IsHexNumber(argv[2])) {

        DebugPrint((3, "Encode => arg 3 is hex\n"));

        //
        // read and verify the hex number
        //

        temp = strtol(argv[2], (char**)NULL, 0x10);
        if (temp > maxValues.Method) {
            printf("Max Method: %x\n", maxValues.Method);
            return STATUS_SUCCESS;
        }
        encoded.Method = temp;

    } else {


        DebugPrint((3, "Encode => arg 3 is non-hex, attempting string "
                    "match\n"));

        //
        // read and match the method
        //

        for (temp = 0; temp < MAX_IOCTL_METHOD; temp++) {

            if (_stricmp(TableIoctlMethod[temp].Name, argv[2]) == 0) {
                DebugPrint((2, "Encode => arg 3 matched index %x\n", temp));
                encoded.Method = TableIoctlMethod[temp].Value;
                break;
            }

            //
            // no need to have common prefixes
            //
            if ((strlen(TableIoctlMethod[temp].Name) > strlen("METHOD_"))
                &&
                (_stricmp(TableIoctlMethod[temp].Name + strlen("METHOD_"),argv[2]) == 0)
                ) {
                DebugPrint((2, "Encode => arg 3 matched index %x "
                            "(dropped prefix)\n", temp));
                encoded.Method = TableIoctlMethod[temp].Value;
                break;
            }


        } // end ioctl_method loop

        if (temp == MAX_IOCTL_METHOD) {
            printf("Method %s unknown.  Known methods:\n", argv[2]);
            for (temp = 0; temp < MAX_IOCTL_METHOD; temp++) {
                printf("\t%s\n", TableIoctlMethod[temp].Name);
            }
            return STATUS_SUCCESS;
        }

    }

    // access
    if (IsHexNumber(argv[3])) {

        //
        // read and verify the hex number
        //

        DebugPrint((3, "Encode => arg 4 is hex\n"));

        temp = strtol(argv[3], (char**)NULL, 0x10);
        if (temp > maxValues.Access) {
            printf("Max Device Type: %x\n", maxValues.Access);
            return STATUS_SUCCESS;
        }
        encoded.Access = temp;

    } else {

        DebugPrint((3, "Encode => arg 4 is non-hex, attempting to "
                    "match strings\n", temp));


        //
        // read and match the access type
        //

        DebugPrint((4, "Encode => Trying to match %s\n", argv[3]));

        for (temp = 0; temp < MAX_IOCTL_ACCESS; temp++) {

            int tLen;
            size_t tDrop;
            char *string;
            char *match;

            //
            // match the whole string?
            //

            string = argv[3];
            match = TableIoctlAccess[temp].Name;

            DebugPrint((4, "Encode ?? test match against %s\n", match));

            if (_stricmp(match, string) == 0) {
                DebugPrint((2, "Encode => arg 4 matched index %x (full)\n",
                            temp));
                encoded.Access = TableIoctlAccess[temp].Value;
                break;
            }

            //
            // maybe match without the trailing _ACCESS?
            //

            tLen = strlen(match) - strlen("_ACCESS");

            DebugPrint((4, "Encode ?? test match against %s (%x chars)\n",
                        match, tLen));

            if (_strnicmp(match, string, tLen) == 0) {
                DebugPrint((2, "Encode => arg 4 matched index %x "
                            "(dropped postfix)\n", temp));
                encoded.Access = TableIoctlAccess[temp].Value;
                break;
            }

            //
            // no need to have common prefixes
            //

            match += strlen("FILE_");

            DebugPrint((4, "Encode ?? test match against %s\n", match));

            if (_stricmp(match, string) == 0) {
                DebugPrint((2, "Encode => arg 4 matched index %x "
                            "(dropped prefix)\n", temp));
                encoded.Access = TableIoctlAccess[temp].Value;
                break;
            }

            tLen = strlen(match) - strlen("_ACCESS");

            //
            // maybe match without prefix or suffix?
            //

            DebugPrint((4, "Encode ?? test match against %s (%x chars)\n",
                        match, tLen));

            if (_strnicmp(match, string, tLen) == 0) {
                DebugPrint((2, "Encode => arg 4 matched index %x "
                            "(dropped prefix and postfix)\n", temp));
                encoded.Access = TableIoctlAccess[temp].Value;
                break;
            }

        } // end ioctl_access loop


        if (temp == MAX_IOCTL_ACCESS) {
            printf("Access %s unknown.  Known Access Types:\n", argv[3]);
            for (temp = 0; temp < MAX_IOCTL_ACCESS; temp++) {
                printf("\t%s\n", TableIoctlAccess[temp].Name);
            }
            return STATUS_SUCCESS;
        }

    }

    DecodeIoctl(&encoded);

    //
    // file type of 0 == unknown type
    //

    return STATUS_SUCCESS;
}


ULONG32 DecodeCommand(int argc, char *argv[])
/*++

Routine Description:

    Change a Ctl_Code into four components

Arguments:

    argc - the number of additional arguments.  prompt if zero
    argv - the additional arguments

Return Value:

    STATUS_SUCCESS if successful

--*/
{
    CTL_CODE ctlCode;
    ULONG i;

    DebugPrint((3, "Decode => Entering\n"));

    ctlCode.Code = strtol(argv[0], (char**)NULL, 0x10);

    DecodeIoctl(&ctlCode);

    return STATUS_SUCCESS;
}

VOID
DecodeIoctl(
    PCTL_CODE CtlCode
    )
{
    ULONG i;

    for (i = 0; TableIoctlValue[i].Name != NULL; i++) {
        if (TableIoctlValue[i].Code == CtlCode->Code) break;
    }

    printf("     Ioctl: %08x     %s\n",
           CtlCode->Code,
           (TableIoctlValue[i].Name ? TableIoctlValue[i].Name : "Unknown")
           );

    printf("DeviceType: %04x - ", CtlCode->DeviceType);
    if (CtlCode->DeviceType > MAX_IOCTL_DEVICE_TYPE) {
        printf("Unknown\n");
    } else {
        printf("%s\n", TableIoctlDeviceType[ CtlCode->DeviceType ]);
    }

    printf("  Function: %04x \n", CtlCode->Function);

    printf("    Method: %04x - %s\n",
           CtlCode->Method,
           TableIoctlMethod[CtlCode->Method]
           );

    printf("    Access: %04x - %s\n",
           CtlCode->Access,
           TableIoctlAccess[CtlCode->Access]
           );


    return;
}


ULONG32 AttenuateCommand( int argc, char *argv[])
{
    LONG32 i;
    LONG32 j;
    long double val[] = {
        0xff, 0xf0, 0xe0, 0xc0,
        0x80, 0x40, 0x20, 0x10,
        0x0f, 0x0e, 0x0c, 0x08,
        0x04, 0x02, 0x01, 0x00
    };
    long double temp;

    printf( "\nATTENUATION AttenuationTable[] = {\n" );

    for ( i=0; i < sizeof(val)/sizeof(val[0]); i++ ) {
        temp = val[i];
        temp = 20 * log10( temp / 256.0 );
        temp = temp * 65536;
        printf( "    { 0x%08x, 0x%02x },\n", (LONG)temp, (LONG)val[i] );

    }
    printf( "};\n" );

    return STATUS_SUCCESS;

}

BOOLEAN
IsHexNumber(
   const char *szExpression
   )
{
   if (!szExpression[0]) {
      return FALSE ;
   }

   for(;*szExpression; szExpression++) {

      if      ((*szExpression)< '0') { return FALSE ; }
      else if ((*szExpression)> 'f') { return FALSE ; }
      else if ((*szExpression)>='a') { continue ;     }
      else if ((*szExpression)> 'F') { return FALSE ; }
      else if ((*szExpression)<='9') { continue ;     }
      else if ((*szExpression)>='A') { continue ;     }
      else                           { return FALSE ; }
   }
   return TRUE ;
}


BOOLEAN
IsDecNumber(
   const char *szExpression
   )
{
   if (!szExpression[0]) {
      return FALSE ;
   }

   while(*szExpression) {

      if      ((*szExpression)<'0') { return FALSE ; }
      else if ((*szExpression)>'9') { return FALSE ; }
      szExpression ++ ;
   }
   return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\creatfil\creatfil.c ===
/*** creatfil.C - Win 32 create file
 *
 *
 * Title:
 *
 *	creatfil - Win 32 Create File Main File
 *
 *      Copyright (c) 1993, Microsoft Corporation.
 *	HonWah Chan
 *
 *
 * Description:
 *
 *	This is the main part of the create file tool.
 *	It takes as a parameter a file name and file size.
 *
 *	     Usage:  creatfil filename filesize
 *
 *			filename: name of file to create
 *       filesize: size of file in KBytes
 *
 *
 *	The Cache Flusher is organized as follows:
 *
 *	     o creatfil.c ........ Tools main body
 *	     o creatfil.h
 *
 *	     o creatf.c ..... create file utility routines
 *	     o creatf.h
 *
 *
 *
 *
 *
 *
 * Modification History:
 *
 *	93.05.17  HonWah Chan -- Created
 *           
 *
 */

char *VERSION = "1.0 (93.05.17)";

// default filesize
#define DEFAULT_SIZE  (1024 * 1024)
#define BUFFER_SIZE   (5 * 1024)
#define MAX_FILE_SIZE (4 * 1024 * 1024)
/* * * * * * * * * * * * *  I N C L U D E    F I L E S  * * * * * * * * * * */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <malloc.h>
#include <time.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include "creatfil.h"
#include "creatf.h"



/* * * * * * * * * *  G L O B A L   D E C L A R A T I O N S  * * * * * * * * */
/* none */


/* * * * * * * * * *  F U N C T I O N   P R O T O T Y P E S  * * * * * * * * */

RC __cdecl main       (int argc, char *argv[]);
VOID ParseCmdLine   (int argc, char *argv[], char *pFileName, DWORD *pFileSize);
VOID CreateTheFile  (char *pFileName, DWORD dFileSize);
VOID Usage          (char *argv[]);
VOID WriteToFile    (HANDLE hFileHandle, DWORD dFileSize);


/* * * * * * * * * * *  G L O B A L    V A R I A B L E S  * * * * * * * * * */
/* none */

/* * * * * *  E X P O R T E D   G L O B A L    V A R I A B L E S  * * * * * */
/* none */





/*********************************  m a i n  **********************************
 *
 *      main(argc, argv)
 *
 *      ENTRY   argc - number of input arguments
 *              argv - contains command line arguments
 *
 *      EXIT    -none-
 *
 *      RETURN  rc - return code in case of failure
 *              STATUS_SUCCESS - if successful
 *
 *      WARNING:  
 *              -none-
 *
 *      COMMENT:  
 *              -none-
 *                
 */

RC __cdecl main (int argc, char *argv[]) 
{
   char   FileName[FNAME_LEN];
   DWORD  dFileSize;
		
   ParseCmdLine (argc, argv, FileName, &dFileSize);
   CreateTheFile (FileName, dFileSize) ;
   ExitProcess(STATUS_SUCCESS);
   return (STATUS_SUCCESS);
} /* main() */






/************************  R e a d P a r a m e t e r s  ************************
 *
 *	parseCmdLine(argc, argv, pFIleName, pdFileSize) -
 *		For Parsing the command line switches
 *
 *      ENTRY   argc - number of input arguments (const input)
 *              argv - contains command line arguments (const input)
 *
 *      EXIT    pFileName  - FileName 
 *              pdFIleSize - FileSize
 *
 *      RETURN  -none-
 *
 *      WARNING:
 *              -none-
 *
 *      COMMENT:  
 *              -none-
 *                
 */

VOID ParseCmdLine (int argc, char *argv[], char *pFileName, DWORD *pFileSize)
{
 
   if (argc < 2 ||
      (argv[1][0] == '-' || argv[1][0] == '/') && argv[1][1] == '?')
      {    /* process options */
      Usage (argv);
      }
   else
      {
      // get filename and filesize
      strcpy (pFileName, argv[1]);

      if (argc <= 2)
         {
         *pFileSize = DEFAULT_SIZE;
         }
      else
         {
         *pFileSize = 0;
         if (sscanf(argv[2], "%d", pFileSize) != 1) 
         {
             Failed(FILESIZE_ERR, __FILE__, __LINE__, " ");
             exit(1);
         }

         if (*pFileSize == 0 || *pFileSize > MAX_FILE_SIZE)
            {
         	Failed(FILESIZE_ERR, __FILE__, __LINE__, " ");
            exit(1);
            }
         else
            {
            *pFileSize *= 1024;
            }
         }
      }
}

/*
 *
 *    CreateTheFile   - create the file using the filename and filesize.
 *
 *    Accepts - pFileName - char *[]
 *              dFileSize - DWORD
 *
 *    Returns - nothing.
 *
 */
 
VOID CreateTheFile (char *pFileName, DWORD dFileSize)
{
	RC       rc;
   HANDLE   hFileHandle;
	char     achErrMsg[LINE_LEN];

   hFileHandle = (HANDLE) CreateFile (pFileName,
      GENERIC_WRITE,
      0,                       
      NULL, CREATE_ALWAYS,                   
      FILE_ATTRIBUTE_NORMAL, NULL);

   if (hFileHandle == INVALID_HANDLE_VALUE || hFileHandle == 0)
      {
      // Could not create the file
      rc = GetLastError();

      if (!(rc == ERROR_FILE_EXISTS || rc == ERROR_ACCESS_DENIED))
         {
   		sprintf(achErrMsg,
	   		"CreateFile() - Error creating %s: %lu",
		   	pFileName, rc);
   		Failed(FILEARG_ERR, __FILE__, __LINE__, achErrMsg);
	   	return;
         }
      }
   else
      {
      // fill the filesize.
      WriteToFile (hFileHandle, dFileSize);
      }

   CloseHandle (hFileHandle);
}

/*
 *
 *    WriteToFile   - write dFileSize bytes to the file.
 *
 *    Accepts - hFileHandle - handle of the file
 *              dFileSize   - size of data to write to file
 *
 *    Returns - nothing.
 *
 */
VOID WriteToFile    (HANDLE hFileHandle, DWORD dFileSize)
{
   BOOL           bSuccess;
   DWORD          nAmtToWrite, nAmtWritten;
   LPVOID         lpMemory;
   DWORD          BufferSize = BUFFER_SIZE;
	char           achErrMsg[LINE_LEN];

   if (dFileSize < BUFFER_SIZE)
      {
      BufferSize = dFileSize;
      }
   lpMemory = (LPVOID) MemoryAllocate (BufferSize);

   if (lpMemory == NULL)
      {
   	Failed(ERROR_NOT_ENOUGH_MEMORY, __FILE__, __LINE__, " ");
      return;
      }

   while (dFileSize)
      {
      if (dFileSize > BUFFER_SIZE)
         {
         dFileSize -= BUFFER_SIZE;
         nAmtToWrite = BUFFER_SIZE;
         }
      else
         {
         nAmtToWrite = dFileSize;
         dFileSize = 0;
         }

      bSuccess = WriteFile (hFileHandle, lpMemory, nAmtToWrite, &nAmtWritten, NULL);
      if (!bSuccess || (nAmtWritten != nAmtToWrite))
         {
         // write error, stop.
      	Failed(FWRITE_ERR, __FILE__, __LINE__, " ");
         MemoryFree (lpMemory);
         return;
         }
      }

   MemoryFree (lpMemory);
}


/*
 *
 *    Usage   - generates a usage message and terminates program.
 *
 *    Accepts - argv     - char *[]
 *
 *    Returns - nothing.
 *
 */
 
VOID Usage (char *argv[])
{
   printf( "Usage: ");
   printf( "%s FileName [FileSize]\n", argv[0]);
   printf( "\t-? :  This message\n");
   printf( "\t-FileName -- name of the new file\n");
   printf( "\t-FileSize -- size of file in KBytes, default is 1024 KBytes\n");
   exit (1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\ctlcode\ctlcode.h ===
//
// Method and Access are filled tables, so directly index them
//

#include <wdm.h>       // CTL_CODE definition

//
// allow easy access to parts of the ctl code
//

typedef union _CTL_CODE {
    ULONG32 Code;
    struct {
        ULONG32 Method     :2;
        ULONG32 Function   :12;
        ULONG32 Access     :2;
        ULONG32 DeviceType :16;
    };
} CTL_CODE, *PCTL_CODE;

typedef struct _IOCTL_DEVICE_TYPE {
    PUCHAR  Name;
    ULONG32 Value;
} IOCTL_DEVICE_TYPE, *PIOCTL_DEVICE_TYPE;

typedef struct _IOCTL_METHOD {
    PUCHAR  Name;
    ULONG32 Value;
} IOCTL_METHOD, *PIOCTL_METHOD;

typedef struct _IOCTL_ACCESS {
    PUCHAR  Name;
    ULONG32 Value;
} IOCTL_ACCESS, *PIOCTL_ACCESS;

typedef struct _IOCTL_VALUE {
    PUCHAR         Name;
    ULONG32        Code;
} IOCTL_VALUE, *PIOCTL_VALUE;

#define SeedIoctlBase(_I)   { #_I, _I }
#define SeedIoctlMethod(_I) { #_I, _I }
#define SeedIoctlAccess(_I) { #_I, _I }
#define SeedIoctlValue(_I)  { #_I, _I }

//
// code depends upon the fact that these are
// in numeric order, without any skipped values
// the index into the array is also the value.
//


IOCTL_METHOD TableIoctlMethod[] = {
    SeedIoctlMethod(METHOD_BUFFERED),
    SeedIoctlMethod(METHOD_IN_DIRECT),
    SeedIoctlMethod(METHOD_OUT_DIRECT),
    SeedIoctlMethod(METHOD_NEITHER),
    {NULL, 0}
};

IOCTL_ACCESS TableIoctlAccess[] = {
    SeedIoctlAccess(FILE_ANY_ACCESS),
    SeedIoctlAccess(FILE_READ_ACCESS),
    SeedIoctlAccess(FILE_WRITE_ACCESS),
    {"FILE_READ_ACCESS | FILE_WRITE_ACCESS", 3},  // hack, cough
    {NULL, 0}
};

IOCTL_DEVICE_TYPE TableIoctlDeviceType[] = {
    {"Zero (invalid)", 0},
    SeedIoctlBase(FILE_DEVICE_BEEP),
    SeedIoctlBase(FILE_DEVICE_CD_ROM),
    SeedIoctlBase(FILE_DEVICE_CD_ROM_FILE_SYSTEM),
    SeedIoctlBase(FILE_DEVICE_CONTROLLER),
    SeedIoctlBase(FILE_DEVICE_DATALINK),
    SeedIoctlBase(FILE_DEVICE_DFS),
    SeedIoctlBase(FILE_DEVICE_DISK),
    SeedIoctlBase(FILE_DEVICE_DISK_FILE_SYSTEM),
    SeedIoctlBase(FILE_DEVICE_FILE_SYSTEM),
    SeedIoctlBase(FILE_DEVICE_INPORT_PORT),
    SeedIoctlBase(FILE_DEVICE_KEYBOARD),
    SeedIoctlBase(FILE_DEVICE_MAILSLOT),
    SeedIoctlBase(FILE_DEVICE_MIDI_IN),
    SeedIoctlBase(FILE_DEVICE_MIDI_OUT),
    SeedIoctlBase(FILE_DEVICE_MOUSE),
    SeedIoctlBase(FILE_DEVICE_MULTI_UNC_PROVIDER),
    SeedIoctlBase(FILE_DEVICE_NAMED_PIPE),
    SeedIoctlBase(FILE_DEVICE_NETWORK),
    SeedIoctlBase(FILE_DEVICE_NETWORK_BROWSER),
    SeedIoctlBase(FILE_DEVICE_NETWORK_FILE_SYSTEM),
    SeedIoctlBase(FILE_DEVICE_NULL),
    SeedIoctlBase(FILE_DEVICE_PARALLEL_PORT),
    SeedIoctlBase(FILE_DEVICE_PHYSICAL_NETCARD),
    SeedIoctlBase(FILE_DEVICE_PRINTER),
    SeedIoctlBase(FILE_DEVICE_SCANNER),
    SeedIoctlBase(FILE_DEVICE_SERIAL_MOUSE_PORT),
    SeedIoctlBase(FILE_DEVICE_SERIAL_PORT),
    SeedIoctlBase(FILE_DEVICE_SCREEN),
    SeedIoctlBase(FILE_DEVICE_SOUND),
    SeedIoctlBase(FILE_DEVICE_STREAMS),
    SeedIoctlBase(FILE_DEVICE_TAPE),
    SeedIoctlBase(FILE_DEVICE_TAPE_FILE_SYSTEM),
    SeedIoctlBase(FILE_DEVICE_TRANSPORT),
    SeedIoctlBase(FILE_DEVICE_UNKNOWN),
    SeedIoctlBase(FILE_DEVICE_VIDEO),
    SeedIoctlBase(FILE_DEVICE_VIRTUAL_DISK),
    SeedIoctlBase(FILE_DEVICE_WAVE_IN),
    SeedIoctlBase(FILE_DEVICE_WAVE_OUT),
    SeedIoctlBase(FILE_DEVICE_8042_PORT),
    SeedIoctlBase(FILE_DEVICE_NETWORK_REDIRECTOR),
    SeedIoctlBase(FILE_DEVICE_BATTERY),
    SeedIoctlBase(FILE_DEVICE_BUS_EXTENDER),
    SeedIoctlBase(FILE_DEVICE_MODEM),
    SeedIoctlBase(FILE_DEVICE_VDM),
    SeedIoctlBase(FILE_DEVICE_MASS_STORAGE),
    SeedIoctlBase(FILE_DEVICE_SMB),
    SeedIoctlBase(FILE_DEVICE_KS),
    SeedIoctlBase(FILE_DEVICE_CHANGER),
    SeedIoctlBase(FILE_DEVICE_SMARTCARD),
    SeedIoctlBase(FILE_DEVICE_ACPI),
    SeedIoctlBase(FILE_DEVICE_DVD),
    SeedIoctlBase(FILE_DEVICE_FULLSCREEN_VIDEO),
    SeedIoctlBase(FILE_DEVICE_DFS_FILE_SYSTEM),
    SeedIoctlBase(FILE_DEVICE_DFS_VOLUME),
    SeedIoctlBase(FILE_DEVICE_SERENUM),
    SeedIoctlBase(FILE_DEVICE_TERMSRV),
    SeedIoctlBase(FILE_DEVICE_KSEC),
    {NULL, 0}
};

//
// max must subtract one null-termination
//

#define MAX_IOCTL_METHOD ((sizeof(TableIoctlMethod)/sizeof(IOCTL_METHOD)-1))
#define MAX_IOCTL_ACCESS ((sizeof(TableIoctlAccess)/sizeof(IOCTL_ACCESS)-1))
#define MAX_IOCTL_DEVICE_TYPE ((sizeof(TableIoctlDeviceType)/sizeof(IOCTL_DEVICE_TYPE)-1))


//
// seed all the ioctls from the sdk
//
#include "batclass.h"
#include "dfsfsctl.h"
#include "gameport.h"
#include "hidclass.h"
#include "mountmgr.h"
#include "ntddaux.h"
#include "ntddbeep.h"
#include "ntddbrow.h"
#include "ntddcdrm.h"
#include "ntddcdvd.h"
#include "ntddchgr.h"
#include "ntdddisk.h"
#include "ntdddlc.h"
#include "ntddfs.h"
//#include "ntddip.h"
#include "ntddjoy.h"
#include "ntddkbd.h"
#include "ntddksec.h"
#include "ntddmidi.h"
#include "ntddmodm.h"
#include "ntddmou.h"
#include "ntddmup.h"
#include "ntddndis.h"
#include "ntddnpfs.h"
#include "ntddnull.h"
#include "ntddpar.h"
#include "ntddpcm.h"
#include "ntddrdr.h"
#include "ntddscsi.h"
#include "ntddser.h"
#include "ntddsnd.h"
#include "ntddstor.h"
#include "ntddstrm.h"
#include "ntddtape.h"
#include "ntddtdi.h"
#include "ntddtime.h"
#include "ntddtx.h"
#include "ntddvdeo.h"
#include "ntddvdsk.h"
#include "ntddvol.h"
#include "ntddwave.h"
#include "scsiscan.h"
#include "swenum.h"
#include "usbioctl.h"
#include "usbscan.h"
#include "wdm.h"
#include "winsmcrd.h"

#include "wmistr.h"
#include "wmiumkm.h"


// #include "i2osmi.h"     // can't find "I2OUtil.h"
// #include "hydra\ica*"   // bad definitions

#include "sdkioctl.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\custcon\custcon.cpp ===
//////////////////////////////////////////////////////////////////////
//
// custcon.cpp : AvP[VpNX`sB
//
// 1998 Jun, Hiro Yamamoto
//

#include "stdafx.h"
#include "custcon.h"
#include "custconDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CCustconApp

BEGIN_MESSAGE_MAP(CCustconApp, CWinApp)
    //{{AFX_MSG_MAP(CCustconApp)
    //}}AFX_MSG
    ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CCustconApp NX\z

CCustconApp::CCustconApp()
{
}

/////////////////////////////////////////////////////////////////////////////
// B CCustconApp IuWFNg

CCustconApp theApp;

int gExMode;

/////////////////////////////////////////////////////////////////////////////
// CCustconApp NX

inline bool strequ(LPCTSTR a, LPCTSTR b)
{
    return !_tcscmp(a, b);
}

BOOL CCustconApp::InitInstance()
{
#ifdef _AFXDLL
    Enable3dControls();         // L DLL  MFC gR[B
#else
    Enable3dControlsStatic();   // MFC INR[B
#endif

    //
    // Parse command line
    //

    if (strequ(m_lpCmdLine, _T("-e"))) {
        gExMode = 1;
    }

    CCustconDlg dlg;
    m_pMainWnd = &dlg;
    dlg.DoModal();
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\ctlcode\sdkioctl.h ===
/*++

NOTE: The table below *MUST* be kept sorted in order for the utility
to work properly.  feel free to add your own new ioctls, but only if
you can get the tool to compile.  i had to originally exclude a few
ioctls because i was unable to determine a method which define'd them
and did not cause error messages due to redefine'd structs, typedefs,
etc.

thanks!

--*/

IOCTL_VALUE TableIoctlValue[] = {
    SeedIoctlValue(IOCTL_ABORT_PIPE),
    SeedIoctlValue(IOCTL_AUX_GET_CAPABILITIES),
    SeedIoctlValue(IOCTL_AUX_GET_VOLUME),
    SeedIoctlValue(IOCTL_AUX_SET_VOLUME),
    SeedIoctlValue(IOCTL_BATTERY_QUERY_INFORMATION),
    SeedIoctlValue(IOCTL_BATTERY_QUERY_STATUS),
    SeedIoctlValue(IOCTL_BATTERY_QUERY_TAG),
    SeedIoctlValue(IOCTL_BATTERY_SET_INFORMATION),
    SeedIoctlValue(IOCTL_BEEP_SET),
    SeedIoctlValue(IOCTL_CANCEL_DEVICE_WAKE),
    SeedIoctlValue(IOCTL_CANCEL_GET_SEND_MESSAGE),
    SeedIoctlValue(IOCTL_CANCEL_IO),
    SeedIoctlValue(IOCTL_CDROM_CHECK_VERIFY),
    SeedIoctlValue(IOCTL_CDROM_DISK_TYPE),
    SeedIoctlValue(IOCTL_CDROM_EJECT_MEDIA),
    SeedIoctlValue(IOCTL_CDROM_FIND_NEW_DEVICES),
    SeedIoctlValue(IOCTL_CDROM_GET_CONTROL),
    SeedIoctlValue(IOCTL_CDROM_GET_DRIVE_GEOMETRY),
    SeedIoctlValue(IOCTL_CDROM_GET_LAST_SESSION),
    SeedIoctlValue(IOCTL_CDROM_GET_VOLUME),
    SeedIoctlValue(IOCTL_CDROM_LOAD_MEDIA),
    SeedIoctlValue(IOCTL_CDROM_MEDIA_REMOVAL),
    SeedIoctlValue(IOCTL_CDROM_PAUSE_AUDIO),
    SeedIoctlValue(IOCTL_CDROM_PLAY_AUDIO_MSF),
    SeedIoctlValue(IOCTL_CDROM_RAW_READ),
    SeedIoctlValue(IOCTL_CDROM_READ_Q_CHANNEL),
    SeedIoctlValue(IOCTL_CDROM_READ_TOC),
    SeedIoctlValue(IOCTL_CDROM_READ_TOC_EX),
    SeedIoctlValue(IOCTL_CDROM_RELEASE),
    SeedIoctlValue(IOCTL_CDROM_RESERVE),
    SeedIoctlValue(IOCTL_CDROM_RESUME_AUDIO),
    SeedIoctlValue(IOCTL_CDROM_SEEK_AUDIO_MSF),
    SeedIoctlValue(IOCTL_CDROM_SET_VOLUME),
    SeedIoctlValue(IOCTL_CDROM_SIMBAD),
    SeedIoctlValue(IOCTL_CDROM_STOP_AUDIO),
    SeedIoctlValue(IOCTL_CDROM_UNLOAD_DRIVER),
    SeedIoctlValue(IOCTL_CHANGER_EXCHANGE_MEDIUM),
    SeedIoctlValue(IOCTL_CHANGER_GET_ELEMENT_STATUS),
    SeedIoctlValue(IOCTL_CHANGER_GET_PARAMETERS),
    SeedIoctlValue(IOCTL_CHANGER_GET_PRODUCT_DATA),
    SeedIoctlValue(IOCTL_CHANGER_GET_STATUS),
    SeedIoctlValue(IOCTL_CHANGER_INITIALIZE_ELEMENT_STATUS),
    SeedIoctlValue(IOCTL_CHANGER_MOVE_MEDIUM),
    SeedIoctlValue(IOCTL_CHANGER_QUERY_VOLUME_TAGS),
    SeedIoctlValue(IOCTL_CHANGER_REINITIALIZE_TRANSPORT),
    SeedIoctlValue(IOCTL_CHANGER_SET_ACCESS),
    SeedIoctlValue(IOCTL_CHANGER_SET_POSITION),
    SeedIoctlValue(IOCTL_DISK_CHECK_VERIFY),
    SeedIoctlValue(IOCTL_DISK_CREATE_DISK),
    SeedIoctlValue(IOCTL_DISK_CONTROLLER_NUMBER),
    SeedIoctlValue(IOCTL_DISK_DELETE_DRIVE_LAYOUT),
    SeedIoctlValue(IOCTL_DISK_EJECT_MEDIA),
    SeedIoctlValue(IOCTL_DISK_FIND_NEW_DEVICES),
    SeedIoctlValue(IOCTL_DISK_FORMAT_DRIVE),
    SeedIoctlValue(IOCTL_DISK_FORMAT_TRACKS),
    SeedIoctlValue(IOCTL_DISK_FORMAT_TRACKS_EX),
    SeedIoctlValue(IOCTL_DISK_GET_CACHE_INFORMATION),
    SeedIoctlValue(IOCTL_DISK_GET_DRIVE_GEOMETRY),
    SeedIoctlValue(IOCTL_DISK_GET_DRIVE_GEOMETRY_EX),
    SeedIoctlValue(IOCTL_DISK_GET_DRIVE_LAYOUT),
    SeedIoctlValue(IOCTL_DISK_GET_DRIVE_LAYOUT_EX),
    SeedIoctlValue(IOCTL_DISK_GET_LENGTH_INFO),
    SeedIoctlValue(IOCTL_DISK_GET_MEDIA_TYPES),
    SeedIoctlValue(IOCTL_DISK_GET_PARTITION_INFO),
    SeedIoctlValue(IOCTL_DISK_GET_PARTITION_INFO_EX),
    SeedIoctlValue(IOCTL_DISK_GROW_PARTITION),
    SeedIoctlValue(IOCTL_DISK_HISTOGRAM_DATA),
    SeedIoctlValue(IOCTL_DISK_HISTOGRAM_RESET),
    SeedIoctlValue(IOCTL_DISK_HISTOGRAM_STRUCTURE),
    SeedIoctlValue(IOCTL_DISK_INTERNAL_CLEAR_VERIFY),
    SeedIoctlValue(IOCTL_DISK_INTERNAL_SET_NOTIFY),
    SeedIoctlValue(IOCTL_DISK_INTERNAL_SET_VERIFY),
    SeedIoctlValue(IOCTL_DISK_IS_WRITABLE),
    SeedIoctlValue(IOCTL_DISK_LOAD_MEDIA),
    SeedIoctlValue(IOCTL_DISK_LOGGING),
    SeedIoctlValue(IOCTL_DISK_MEDIA_REMOVAL),
    SeedIoctlValue(IOCTL_DISK_PERFORMANCE),
    SeedIoctlValue(IOCTL_DISK_REASSIGN_BLOCKS),
    SeedIoctlValue(IOCTL_DISK_RELEASE),
    SeedIoctlValue(IOCTL_DISK_REQUEST_DATA),
    SeedIoctlValue(IOCTL_DISK_REQUEST_STRUCTURE),
    SeedIoctlValue(IOCTL_DISK_RESERVE),
    SeedIoctlValue(IOCTL_DISK_SENSE_DEVICE),
    SeedIoctlValue(IOCTL_DISK_SET_CACHE_INFORMATION),
    SeedIoctlValue(IOCTL_DISK_SET_DRIVE_LAYOUT),
    SeedIoctlValue(IOCTL_DISK_SET_DRIVE_LAYOUT_EX),
    SeedIoctlValue(IOCTL_DISK_SET_PARTITION_INFO),
    SeedIoctlValue(IOCTL_DISK_SET_PARTITION_INFO_EX),
    SeedIoctlValue(IOCTL_DISK_SIMBAD),
    SeedIoctlValue(IOCTL_DISK_UPDATE_DRIVE_SIZE),
    SeedIoctlValue(IOCTL_DISK_VERIFY),
    SeedIoctlValue(IOCTL_DLC_BUFFER_CREATE),
    SeedIoctlValue(IOCTL_DLC_BUFFER_FREE),
    SeedIoctlValue(IOCTL_DLC_BUFFER_GET),
    SeedIoctlValue(IOCTL_DLC_CLOSE_ADAPTER),
    SeedIoctlValue(IOCTL_DLC_CLOSE_DIRECT),
    SeedIoctlValue(IOCTL_DLC_CLOSE_SAP),
    SeedIoctlValue(IOCTL_DLC_CLOSE_STATION),
    SeedIoctlValue(IOCTL_DLC_COMPLETE_COMMAND),
    SeedIoctlValue(IOCTL_DLC_CONNECT_STATION),
    SeedIoctlValue(IOCTL_DLC_FLOW_CONTROL),
    SeedIoctlValue(IOCTL_DLC_LAST_COMMAND),
    SeedIoctlValue(IOCTL_DLC_MAX),
    SeedIoctlValue(IOCTL_DLC_OPEN_ADAPTER),
    SeedIoctlValue(IOCTL_DLC_OPEN_DIRECT),
    SeedIoctlValue(IOCTL_DLC_OPEN_SAP),
    SeedIoctlValue(IOCTL_DLC_OPEN_STATION),
    SeedIoctlValue(IOCTL_DLC_QUERY_INFORMATION),
    SeedIoctlValue(IOCTL_DLC_READ),
    SeedIoctlValue(IOCTL_DLC_READ_CANCEL),
    SeedIoctlValue(IOCTL_DLC_READ2),
    SeedIoctlValue(IOCTL_DLC_REALLOCTE_STATION),
    SeedIoctlValue(IOCTL_DLC_RECEIVE),
    SeedIoctlValue(IOCTL_DLC_RECEIVE_CANCEL),
    SeedIoctlValue(IOCTL_DLC_RECEIVE2),
    SeedIoctlValue(IOCTL_DLC_RESET),
    SeedIoctlValue(IOCTL_DLC_SET_EXCEPTION_FLAGS),
    SeedIoctlValue(IOCTL_DLC_SET_INFORMATION),
    SeedIoctlValue(IOCTL_DLC_TIMER_CANCEL),
    SeedIoctlValue(IOCTL_DLC_TIMER_CANCEL_GROUP),
    SeedIoctlValue(IOCTL_DLC_TIMER_SET),
    SeedIoctlValue(IOCTL_DLC_TRACE_INITIALIZE),
    SeedIoctlValue(IOCTL_DLC_TRANSMIT),
    SeedIoctlValue(IOCTL_DLC_TRANSMIT2),
    SeedIoctlValue(IOCTL_DVD_END_SESSION),
    SeedIoctlValue(IOCTL_DVD_GET_REGION),
    SeedIoctlValue(IOCTL_DVD_READ_KEY),
    SeedIoctlValue(IOCTL_DVD_READ_STRUCTURE),
    SeedIoctlValue(IOCTL_DVD_SEND_KEY),
    SeedIoctlValue(IOCTL_DVD_SEND_KEY2),
    SeedIoctlValue(IOCTL_DVD_SET_READ_AHEAD),
    SeedIoctlValue(IOCTL_DVD_START_SESSION),
    SeedIoctlValue(IOCTL_FSVIDEO_COPY_FRAME_BUFFER),
    SeedIoctlValue(IOCTL_FSVIDEO_REVERSE_MOUSE_POINTER),
    SeedIoctlValue(IOCTL_FSVIDEO_SET_CURRENT_MODE),
    SeedIoctlValue(IOCTL_FSVIDEO_SET_CURSOR_POSITION),
    SeedIoctlValue(IOCTL_FSVIDEO_SET_SCREEN_INFORMATION),
    SeedIoctlValue(IOCTL_FSVIDEO_WRITE_TO_FRAME_BUFFER),
    SeedIoctlValue(IOCTL_GAMEENUM_ACQUIRE_ACCESSORS),
    SeedIoctlValue(IOCTL_GAMEENUM_EXPOSE_HARDWARE),
    SeedIoctlValue(IOCTL_GAMEENUM_EXPOSE_SIBLING),
    SeedIoctlValue(IOCTL_GAMEENUM_PORT_DESC),
    SeedIoctlValue(IOCTL_GAMEENUM_PORT_PARAMETERS),
    SeedIoctlValue(IOCTL_GAMEENUM_REMOVE_HARDWARE),
    SeedIoctlValue(IOCTL_GAMEENUM_REMOVE_SELF),
    SeedIoctlValue(IOCTL_GET_CHANNEL_ALIGN_RQST),
    SeedIoctlValue(IOCTL_GET_DEVICE_DESCRIPTOR),
    SeedIoctlValue(IOCTL_GET_HCD_DRIVERKEY_NAME),
    SeedIoctlValue(IOCTL_GET_NUM_DEVICE_INPUT_BUFFERS),
    SeedIoctlValue(IOCTL_GET_PHYSICAL_DESCRIPTOR),
    SeedIoctlValue(IOCTL_GET_PIPE_CONFIGURATION),
    SeedIoctlValue(IOCTL_GET_TUPLE_DATA),
    SeedIoctlValue(IOCTL_GET_USB_DESCRIPTOR),
    SeedIoctlValue(IOCTL_GET_VERSION),
    SeedIoctlValue(IOCTL_HID_FLUSH_QUEUE),
    SeedIoctlValue(IOCTL_HID_GET_COLLECTION_DESCRIPTOR),
    SeedIoctlValue(IOCTL_HID_GET_COLLECTION_INFORMATION),
    SeedIoctlValue(IOCTL_HID_GET_DRIVER_CONFIG),
    SeedIoctlValue(IOCTL_HID_GET_FEATURE),
    SeedIoctlValue(IOCTL_HID_GET_HARDWARE_ID),
    SeedIoctlValue(IOCTL_HID_GET_INDEXED_STRING),
    SeedIoctlValue(IOCTL_HID_GET_MANUFACTURER_STRING),
    SeedIoctlValue(IOCTL_HID_GET_POLL_FREQUENCY_MSEC),
    SeedIoctlValue(IOCTL_HID_GET_PRODUCT_STRING),
    SeedIoctlValue(IOCTL_HID_GET_SERIALNUMBER_STRING),
    SeedIoctlValue(IOCTL_HID_SET_DRIVER_CONFIG),
    SeedIoctlValue(IOCTL_HID_SET_FEATURE),
    SeedIoctlValue(IOCTL_HID_SET_POLL_FREQUENCY_MSEC),
    SeedIoctlValue(IOCTL_IDE_PASS_THROUGH),
    SeedIoctlValue(IOCTL_IEEE1284_GET_MODE),
    SeedIoctlValue(IOCTL_IEEE1284_NEGOTIATE),
    SeedIoctlValue(IOCTL_INDEX),
    SeedIoctlValue(IOCTL_INTERNAL_SERENUM_REMOVE_SELF),
    SeedIoctlValue(IOCTL_INTERNAL_USB_CYCLE_PORT),
    SeedIoctlValue(IOCTL_INTERNAL_USB_ENABLE_PORT),
    SeedIoctlValue(IOCTL_INTERNAL_USB_GET_BUS_INFO),
    SeedIoctlValue(IOCTL_INTERNAL_USB_GET_BUSGUID_INFO),
    SeedIoctlValue(IOCTL_INTERNAL_USB_GET_CONTROLLER_NAME),
    SeedIoctlValue(IOCTL_INTERNAL_USB_GET_HUB_COUNT),
    SeedIoctlValue(IOCTL_INTERNAL_USB_GET_HUB_NAME),
    SeedIoctlValue(IOCTL_INTERNAL_USB_GET_PARENT_HUB_INFO),
    SeedIoctlValue(IOCTL_INTERNAL_USB_GET_PORT_STATUS),
    SeedIoctlValue(IOCTL_INTERNAL_USB_GET_ROOTHUB_PDO),
    SeedIoctlValue(IOCTL_INTERNAL_USB_RESET_PORT),
    SeedIoctlValue(IOCTL_INTERNAL_USB_SUBMIT_URB),
    SeedIoctlValue(IOCTL_JOY_GET_JOYREGHWCONFIG),
    SeedIoctlValue(IOCTL_JOY_GET_STATISTICS),
    SeedIoctlValue(IOCTL_KEYBOARD_INSERT_DATA),
    SeedIoctlValue(IOCTL_KEYBOARD_QUERY_ATTRIBUTES),
    SeedIoctlValue(IOCTL_KEYBOARD_QUERY_IME_STATUS),
    SeedIoctlValue(IOCTL_KEYBOARD_QUERY_INDICATOR_TRANSLATION),
    SeedIoctlValue(IOCTL_KEYBOARD_QUERY_INDICATORS),
    SeedIoctlValue(IOCTL_KEYBOARD_QUERY_TYPEMATIC),
    SeedIoctlValue(IOCTL_KEYBOARD_SET_IME_STATUS),
    SeedIoctlValue(IOCTL_KEYBOARD_SET_INDICATORS),
    SeedIoctlValue(IOCTL_KEYBOARD_SET_TYPEMATIC),
    SeedIoctlValue(IOCTL_KSEC_CONNECT_LSA),
    SeedIoctlValue(IOCTL_KSEC_RNG),
    SeedIoctlValue(IOCTL_KSEC_RNG_REKEY),
    SeedIoctlValue(IOCTL_LMDR_ADD_NAME),
    SeedIoctlValue(IOCTL_LMDR_ADD_NAME_DOM),
    SeedIoctlValue(IOCTL_LMDR_BECOME_BACKUP),
    SeedIoctlValue(IOCTL_LMDR_BECOME_MASTER),
    SeedIoctlValue(IOCTL_LMDR_BIND_TO_TRANSPORT),
    SeedIoctlValue(IOCTL_LMDR_BIND_TO_TRANSPORT_DOM),
    SeedIoctlValue(IOCTL_LMDR_BROWSER_PNP_ENABLE),
    SeedIoctlValue(IOCTL_LMDR_BROWSER_PNP_READ),
    SeedIoctlValue(IOCTL_LMDR_CHANGE_ROLE),
    SeedIoctlValue(IOCTL_LMDR_DEBUG_CALL),
    SeedIoctlValue(IOCTL_LMDR_DELETE_NAME),
    SeedIoctlValue(IOCTL_LMDR_DELETE_NAME_DOM),
    SeedIoctlValue(IOCTL_LMDR_ENABLE_DISABLE_TRANSPORT),
    SeedIoctlValue(IOCTL_LMDR_ENUMERATE_NAMES),
    SeedIoctlValue(IOCTL_LMDR_ENUMERATE_SERVERS),
    SeedIoctlValue(IOCTL_LMDR_ENUMERATE_TRANSPORTS),
    SeedIoctlValue(IOCTL_LMDR_GET_BROWSER_SERVER_LIST),
    SeedIoctlValue(IOCTL_LMDR_GET_MASTER_NAME),
    SeedIoctlValue(IOCTL_LMDR_IP_ADDRESS_CHANGED),
    SeedIoctlValue(IOCTL_LMDR_NETLOGON_MAILSLOT_ENABLE),
    SeedIoctlValue(IOCTL_LMDR_NETLOGON_MAILSLOT_READ),
    SeedIoctlValue(IOCTL_LMDR_NEW_MASTER_NAME),
    SeedIoctlValue(IOCTL_LMDR_QUERY_STATISTICS),
    SeedIoctlValue(IOCTL_LMDR_RENAME_DOMAIN),
    SeedIoctlValue(IOCTL_LMDR_RESET_STATISTICS),
    SeedIoctlValue(IOCTL_LMDR_START),
    SeedIoctlValue(IOCTL_LMDR_STOP),
    SeedIoctlValue(IOCTL_LMDR_UNBIND_FROM_TRANSPORT),
    SeedIoctlValue(IOCTL_LMDR_UNBIND_FROM_TRANSPORT_DOM),
    SeedIoctlValue(IOCTL_LMDR_UPDATE_STATUS),
    SeedIoctlValue(IOCTL_LMDR_WAIT_FOR_MASTER_ANNOUNCE),
    SeedIoctlValue(IOCTL_LMDR_WRITE_MAILSLOT),
    SeedIoctlValue(IOCTL_MIDI_CACHE_DRUM_PATCHES),
    SeedIoctlValue(IOCTL_MIDI_CACHE_PATCHES),
    SeedIoctlValue(IOCTL_MIDI_GET_CAPABILITIES),
    SeedIoctlValue(IOCTL_MIDI_GET_STATE),
    SeedIoctlValue(IOCTL_MIDI_GET_VOLUME),
    SeedIoctlValue(IOCTL_MIDI_PLAY),
    SeedIoctlValue(IOCTL_MIDI_RECORD),
    SeedIoctlValue(IOCTL_MIDI_SET_STATE),
    SeedIoctlValue(IOCTL_MIDI_SET_VOLUME),
    SeedIoctlValue(IOCTL_MODEM_CHECK_FOR_MODEM),
    SeedIoctlValue(IOCTL_MODEM_GET_DLE),
    SeedIoctlValue(IOCTL_MODEM_GET_MESSAGE),
    SeedIoctlValue(IOCTL_MODEM_GET_PASSTHROUGH),
    SeedIoctlValue(IOCTL_MODEM_SEND_GET_MESSAGE),
    SeedIoctlValue(IOCTL_MODEM_SEND_LOOPBACK_MESSAGE),
    SeedIoctlValue(IOCTL_MODEM_SEND_MESSAGE),
    SeedIoctlValue(IOCTL_MODEM_SET_DLE_MONITORING),
    SeedIoctlValue(IOCTL_MODEM_SET_DLE_SHIELDING),
    SeedIoctlValue(IOCTL_MODEM_SET_MIN_POWER),
    SeedIoctlValue(IOCTL_MODEM_SET_PASSTHROUGH),
    SeedIoctlValue(IOCTL_MODEM_STOP_WAVE_RECEIVE),
    SeedIoctlValue(IOCTL_MODEM_WATCH_FOR_RESUME),
    SeedIoctlValue(IOCTL_MOUNTDEV_QUERY_DEVICE_NAME),
    SeedIoctlValue(IOCTL_MOUNTMGR_AUTO_DL_ASSIGNMENTS),
    SeedIoctlValue(IOCTL_MOUNTMGR_CHANGE_NOTIFY),
    SeedIoctlValue(IOCTL_MOUNTMGR_CHECK_UNPROCESSED_VOLUMES),
    SeedIoctlValue(IOCTL_MOUNTMGR_CREATE_POINT),
    SeedIoctlValue(IOCTL_MOUNTMGR_DELETE_POINTS),
    SeedIoctlValue(IOCTL_MOUNTMGR_DELETE_POINTS_DBONLY),
    SeedIoctlValue(IOCTL_MOUNTMGR_KEEP_LINKS_WHEN_OFFLINE),
    SeedIoctlValue(IOCTL_MOUNTMGR_NEXT_DRIVE_LETTER),
    SeedIoctlValue(IOCTL_MOUNTMGR_QUERY_POINTS),
    SeedIoctlValue(IOCTL_MOUNTMGR_VOLUME_ARRIVAL_NOTIFICATION),
    SeedIoctlValue(IOCTL_MOUNTMGR_VOLUME_MOUNT_POINT_CREATED),
    SeedIoctlValue(IOCTL_MOUSE_INSERT_DATA),
    SeedIoctlValue(IOCTL_MOUSE_QUERY_ATTRIBUTES),
    SeedIoctlValue(IOCTL_NDIS_ADD_TDI_DEVICE),
    SeedIoctlValue(IOCTL_NDIS_DO_PNP_OPERATION),
    SeedIoctlValue(IOCTL_NDIS_ENUMERATE_INTERFACES),
    SeedIoctlValue(IOCTL_NDIS_GET_LOG_DATA),
    SeedIoctlValue(IOCTL_NDIS_QUERY_ALL_STATS),
    SeedIoctlValue(IOCTL_NDIS_QUERY_GLOBAL_STATS),
    SeedIoctlValue(IOCTL_NDIS_QUERY_SELECTED_STATS),
    SeedIoctlValue(IOCTL_PAR_ECP_HOST_RECOVERY),
    SeedIoctlValue(IOCTL_PAR_GET_DEFAULT_MODES),
    SeedIoctlValue(IOCTL_PAR_GET_DEVICE_CAPS),
    SeedIoctlValue(IOCTL_PAR_GET_READ_ADDRESS),
    SeedIoctlValue(IOCTL_PAR_GET_WRITE_ADDRESS),
    SeedIoctlValue(IOCTL_PAR_PING),
    SeedIoctlValue(IOCTL_PAR_QUERY_DEVICE_ID),
    SeedIoctlValue(IOCTL_PAR_QUERY_DEVICE_ID_SIZE),
    SeedIoctlValue(IOCTL_PAR_QUERY_INFORMATION),
    SeedIoctlValue(IOCTL_PAR_QUERY_RAW_DEVICE_ID),
    SeedIoctlValue(IOCTL_PAR_SET_INFORMATION),
    SeedIoctlValue(IOCTL_PAR_SET_READ_ADDRESS),
    SeedIoctlValue(IOCTL_PAR_SET_WRITE_ADDRESS),
    SeedIoctlValue(IOCTL_PAR_TEST),
    SeedIoctlValue(IOCTL_QUERY_DEVICE_POWER_STATE),
    SeedIoctlValue(IOCTL_READ_REGISTERS),
    SeedIoctlValue(IOCTL_REDIR_QUERY_PATH),
    SeedIoctlValue(IOCTL_RESET_PIPE),
    SeedIoctlValue(IOCTL_SCSI_FREE_DUMP_POINTERS),
    SeedIoctlValue(IOCTL_SCSI_GET_ADDRESS),
    SeedIoctlValue(IOCTL_SCSI_GET_CAPABILITIES),
    SeedIoctlValue(IOCTL_SCSI_GET_DUMP_POINTERS),
    SeedIoctlValue(IOCTL_SCSI_GET_INQUIRY_DATA),
    SeedIoctlValue(IOCTL_SCSI_MINIPORT),
    SeedIoctlValue(IOCTL_SCSI_PASS_THROUGH),
    SeedIoctlValue(IOCTL_SCSI_PASS_THROUGH_DIRECT),
    SeedIoctlValue(IOCTL_SCSI_RESCAN_BUS),
    SeedIoctlValue(IOCTL_SCSISCAN_CMD),
    SeedIoctlValue(IOCTL_SCSISCAN_GET_INFO),
    SeedIoctlValue(IOCTL_SCSISCAN_LOCKDEVICE),
    SeedIoctlValue(IOCTL_SCSISCAN_SET_TIMEOUT),
    SeedIoctlValue(IOCTL_SCSISCAN_UNLOCKDEVICE),
    SeedIoctlValue(IOCTL_SEND_USB_REQUEST),
    SeedIoctlValue(IOCTL_SERENUM_EXPOSE_HARDWARE),
    SeedIoctlValue(IOCTL_SERENUM_GET_PORT_NAME),
    SeedIoctlValue(IOCTL_SERENUM_PORT_DESC),
    SeedIoctlValue(IOCTL_SERENUM_REMOVE_HARDWARE),
    SeedIoctlValue(IOCTL_SERIAL_CLEAR_STATS),
    SeedIoctlValue(IOCTL_SERIAL_CLR_DTR),
    SeedIoctlValue(IOCTL_SERIAL_CLR_RTS),
    SeedIoctlValue(IOCTL_SERIAL_CONFIG_SIZE),
    SeedIoctlValue(IOCTL_SERIAL_GET_BAUD_RATE),
    SeedIoctlValue(IOCTL_SERIAL_GET_CHARS),
    SeedIoctlValue(IOCTL_SERIAL_GET_COMMCONFIG),
    SeedIoctlValue(IOCTL_SERIAL_GET_COMMSTATUS),
    SeedIoctlValue(IOCTL_SERIAL_GET_DTRRTS),
    SeedIoctlValue(IOCTL_SERIAL_GET_HANDFLOW),
    SeedIoctlValue(IOCTL_SERIAL_GET_LINE_CONTROL),
    SeedIoctlValue(IOCTL_SERIAL_GET_MODEM_CONTROL),
    SeedIoctlValue(IOCTL_SERIAL_GET_MODEMSTATUS),
    SeedIoctlValue(IOCTL_SERIAL_GET_PROPERTIES),
    SeedIoctlValue(IOCTL_SERIAL_GET_STATS),
    SeedIoctlValue(IOCTL_SERIAL_GET_TIMEOUTS),
    SeedIoctlValue(IOCTL_SERIAL_GET_WAIT_MASK),
    SeedIoctlValue(IOCTL_SERIAL_IMMEDIATE_CHAR),
    SeedIoctlValue(IOCTL_SERIAL_INTERNAL_BASIC_SETTINGS),
    SeedIoctlValue(IOCTL_SERIAL_INTERNAL_CANCEL_WAIT_WAKE),
    SeedIoctlValue(IOCTL_SERIAL_INTERNAL_DO_WAIT_WAKE),
    SeedIoctlValue(IOCTL_SERIAL_INTERNAL_RESTORE_SETTINGS),
    SeedIoctlValue(IOCTL_SERIAL_LSRMST_INSERT),
    SeedIoctlValue(IOCTL_SERIAL_LSRMST_INSERT),
    SeedIoctlValue(IOCTL_SERIAL_PURGE),
    SeedIoctlValue(IOCTL_SERIAL_RESET_DEVICE),
    SeedIoctlValue(IOCTL_SERIAL_SET_BAUD_RATE),
    SeedIoctlValue(IOCTL_SERIAL_SET_BREAK_OFF),
    SeedIoctlValue(IOCTL_SERIAL_SET_BREAK_ON),
    SeedIoctlValue(IOCTL_SERIAL_SET_CHARS),
    SeedIoctlValue(IOCTL_SERIAL_SET_COMMCONFIG),
    SeedIoctlValue(IOCTL_SERIAL_SET_DTR),
    SeedIoctlValue(IOCTL_SERIAL_SET_FIFO_CONTROL),
    SeedIoctlValue(IOCTL_SERIAL_SET_HANDFLOW),
    SeedIoctlValue(IOCTL_SERIAL_SET_LINE_CONTROL),
    SeedIoctlValue(IOCTL_SERIAL_SET_MODEM_CONTROL),
    SeedIoctlValue(IOCTL_SERIAL_SET_QUEUE_SIZE),
    SeedIoctlValue(IOCTL_SERIAL_SET_RTS),
    SeedIoctlValue(IOCTL_SERIAL_SET_TIMEOUTS),
    SeedIoctlValue(IOCTL_SERIAL_SET_WAIT_MASK),
    SeedIoctlValue(IOCTL_SERIAL_SET_XOFF),
    SeedIoctlValue(IOCTL_SERIAL_SET_XON),
    SeedIoctlValue(IOCTL_SERIAL_WAIT_ON_MASK),
    SeedIoctlValue(IOCTL_SERIAL_XOFF_COUNTER),
    SeedIoctlValue(IOCTL_SET_DEVICE_WAKE),
    SeedIoctlValue(IOCTL_SET_DEVICE_WAKE),
    SeedIoctlValue(IOCTL_SET_NUM_DEVICE_INPUT_BUFFERS),
    SeedIoctlValue(IOCTL_SET_SERVER_STATE),
    SeedIoctlValue(IOCTL_SMARTCARD_CONFISCATE),
    SeedIoctlValue(IOCTL_SMARTCARD_EJECT),
    SeedIoctlValue(IOCTL_SMARTCARD_GET_ATTRIBUTE),
    SeedIoctlValue(IOCTL_SMARTCARD_GET_LAST_ERROR),
    SeedIoctlValue(IOCTL_SMARTCARD_GET_PERF_CNTR),
    SeedIoctlValue(IOCTL_SMARTCARD_GET_STATE),
    SeedIoctlValue(IOCTL_SMARTCARD_IS_ABSENT),
    SeedIoctlValue(IOCTL_SMARTCARD_IS_PRESENT),
    SeedIoctlValue(IOCTL_SMARTCARD_POWER),
    SeedIoctlValue(IOCTL_SMARTCARD_SET_ATTRIBUTE),
    SeedIoctlValue(IOCTL_SMARTCARD_SET_PROTOCOL),
    SeedIoctlValue(IOCTL_SMARTCARD_SWALLOW),
    SeedIoctlValue(IOCTL_SMARTCARD_TRANSMIT),
    SeedIoctlValue(IOCTL_SOCKET_INFORMATION),
    SeedIoctlValue(IOCTL_SOUND_GET_CHANGED_VOLUME),
    SeedIoctlValue(IOCTL_STORAGE_CHECK_VERIFY),
    SeedIoctlValue(IOCTL_STORAGE_CHECK_VERIFY2),
    SeedIoctlValue(IOCTL_STORAGE_EJECT_MEDIA),
    SeedIoctlValue(IOCTL_STORAGE_EJECTION_CONTROL),
    SeedIoctlValue(IOCTL_STORAGE_FIND_NEW_DEVICES),
    SeedIoctlValue(IOCTL_STORAGE_GET_DEVICE_NUMBER),
    SeedIoctlValue(IOCTL_STORAGE_GET_MEDIA_SERIAL_NUMBER),
    SeedIoctlValue(IOCTL_STORAGE_GET_MEDIA_TYPES),
    SeedIoctlValue(IOCTL_STORAGE_GET_MEDIA_TYPES_EX),
    SeedIoctlValue(IOCTL_STORAGE_LOAD_MEDIA),
    SeedIoctlValue(IOCTL_STORAGE_LOAD_MEDIA2),
    SeedIoctlValue(IOCTL_STORAGE_MCN_CONTROL),
    SeedIoctlValue(IOCTL_STORAGE_MEDIA_REMOVAL),
    SeedIoctlValue(IOCTL_STORAGE_PREDICT_FAILURE),
    SeedIoctlValue(IOCTL_STORAGE_QUERY_PROPERTY),
    SeedIoctlValue(IOCTL_STORAGE_RELEASE),
    SeedIoctlValue(IOCTL_STORAGE_RESERVE),
    SeedIoctlValue(IOCTL_STORAGE_RESET_BUS),
    SeedIoctlValue(IOCTL_STORAGE_RESET_DEVICE),
    SeedIoctlValue(IOCTL_STORAGE_SET_READ_AHEAD),
    SeedIoctlValue(IOCTL_STREAMS_GETMSG),
    SeedIoctlValue(IOCTL_STREAMS_IOCTL),
    SeedIoctlValue(IOCTL_STREAMS_POLL),
    SeedIoctlValue(IOCTL_STREAMS_PUTMSG),
    SeedIoctlValue(IOCTL_STREAMS_TDI_TEST),
    SeedIoctlValue(IOCTL_SWENUM_GET_BUS_ID),
    SeedIoctlValue(IOCTL_SWENUM_INSTALL_INTERFACE),
    SeedIoctlValue(IOCTL_SWENUM_REMOVE_INTERFACE),
    SeedIoctlValue(IOCTL_TAPE_CHECK_VERIFY),
    SeedIoctlValue(IOCTL_TAPE_CREATE_PARTITION),
    SeedIoctlValue(IOCTL_TAPE_EJECT_MEDIA),
    SeedIoctlValue(IOCTL_TAPE_ERASE),
    SeedIoctlValue(IOCTL_TAPE_FIND_NEW_DEVICES),
    SeedIoctlValue(IOCTL_TAPE_GET_DRIVE_PARAMS),
    SeedIoctlValue(IOCTL_TAPE_GET_MEDIA_PARAMS),
    SeedIoctlValue(IOCTL_TAPE_GET_POSITION),
    SeedIoctlValue(IOCTL_TAPE_GET_STATUS),
    SeedIoctlValue(IOCTL_TAPE_LOAD_MEDIA),
    SeedIoctlValue(IOCTL_TAPE_MEDIA_REMOVAL),
    SeedIoctlValue(IOCTL_TAPE_PREPARE),
    SeedIoctlValue(IOCTL_TAPE_RELEASE),
    SeedIoctlValue(IOCTL_TAPE_RESERVE),
    SeedIoctlValue(IOCTL_TAPE_SET_DRIVE_PARAMS),
    SeedIoctlValue(IOCTL_TAPE_SET_MEDIA_PARAMS),
    SeedIoctlValue(IOCTL_TAPE_SET_POSITION),
    SeedIoctlValue(IOCTL_TAPE_WRITE_MARKS),
    SeedIoctlValue(IOCTL_TDI_ACCEPT),
    SeedIoctlValue(IOCTL_TDI_ACTION),
    SeedIoctlValue(IOCTL_TDI_ASSOCIATE_ADDRESS),
    SeedIoctlValue(IOCTL_TDI_CONNECT),
    SeedIoctlValue(IOCTL_TDI_DISASSOCIATE_ADDRESS),
    SeedIoctlValue(IOCTL_TDI_DISCONNECT),
    SeedIoctlValue(IOCTL_TDI_LISTEN),
    SeedIoctlValue(IOCTL_TDI_QUERY_INFORMATION),
    SeedIoctlValue(IOCTL_TDI_RECEIVE),
    SeedIoctlValue(IOCTL_TDI_RECEIVE_DATAGRAM),
    SeedIoctlValue(IOCTL_TDI_SEND),
    SeedIoctlValue(IOCTL_TDI_SEND_DATAGRAM),
    SeedIoctlValue(IOCTL_TDI_SET_EVENT_HANDLER),
    SeedIoctlValue(IOCTL_TDI_SET_INFORMATION),
    SeedIoctlValue(IOCTL_TIMER_BEGIN_MIN_PERIOD),
    SeedIoctlValue(IOCTL_TIMER_END_MIN_PERIOD),
    SeedIoctlValue(IOCTL_TIMER_GET_DEV_CAPS),
    SeedIoctlValue(IOCTL_TIMER_GET_TIME),
    SeedIoctlValue(IOCTL_TIMER_RESET),
    SeedIoctlValue(IOCTL_TIMER_RESET_EVENT),
    SeedIoctlValue(IOCTL_TIMER_SET_TIMER_EVENT),
    SeedIoctlValue(IOCTL_TRNXT_READ),
    SeedIoctlValue(IOCTL_TRNXT_XCEIVE),
    SeedIoctlValue(IOCTL_USB_DIAG_IGNORE_HUBS_OFF),
    SeedIoctlValue(IOCTL_USB_DIAG_IGNORE_HUBS_ON),
    SeedIoctlValue(IOCTL_USB_DIAGNOSTIC_MODE_OFF),
    SeedIoctlValue(IOCTL_USB_DIAGNOSTIC_MODE_ON),
    SeedIoctlValue(IOCTL_USB_GET_DESCRIPTOR_FROM_NODE_CONNECTION),
    SeedIoctlValue(IOCTL_USB_GET_NODE_CONNECTION_DRIVERKEY_NAME),
    SeedIoctlValue(IOCTL_USB_GET_NODE_CONNECTION_INFORMATION),
    SeedIoctlValue(IOCTL_USB_GET_NODE_CONNECTION_NAME),
    SeedIoctlValue(IOCTL_USB_GET_NODE_INFORMATION),
    SeedIoctlValue(IOCTL_USB_GET_ROOT_HUB_NAME),
    SeedIoctlValue(IOCTL_USB_HCD_GET_STATS_1),
    SeedIoctlValue(IOCTL_USB_HCD_GET_STATS_2),
    SeedIoctlValue(IOCTL_VIDEO_DISABLE_CURSOR),
    SeedIoctlValue(IOCTL_VIDEO_DISABLE_POINTER),
    SeedIoctlValue(IOCTL_VIDEO_DISABLE_VDM),
    SeedIoctlValue(IOCTL_VIDEO_ENABLE_CURSOR),
    SeedIoctlValue(IOCTL_VIDEO_ENABLE_POINTER),
    SeedIoctlValue(IOCTL_VIDEO_ENABLE_VDM),
    SeedIoctlValue(IOCTL_VIDEO_ENUM_MONITOR_PDO),
    SeedIoctlValue(IOCTL_VIDEO_FREE_PUBLIC_ACCESS_RANGES),
    SeedIoctlValue(IOCTL_VIDEO_GET_BANK_SELECT_CODE),
    SeedIoctlValue(IOCTL_VIDEO_GET_CHILD_STATE),
    SeedIoctlValue(IOCTL_VIDEO_GET_OUTPUT_DEVICE_POWER_STATE),
    SeedIoctlValue(IOCTL_VIDEO_GET_POWER_MANAGEMENT),
    SeedIoctlValue(IOCTL_VIDEO_HANDLE_VIDEOPARAMETERS),
    SeedIoctlValue(IOCTL_VIDEO_INIT_WIN32K_CALLBACKS),
    SeedIoctlValue(IOCTL_VIDEO_LOAD_AND_SET_FONT),
    SeedIoctlValue(IOCTL_VIDEO_MAP_VIDEO_MEMORY),
    SeedIoctlValue(IOCTL_VIDEO_MONITOR_DEVICE),
    SeedIoctlValue(IOCTL_VIDEO_QUERY_AVAIL_MODES),
    SeedIoctlValue(IOCTL_VIDEO_QUERY_COLOR_CAPABILITIES),
    SeedIoctlValue(IOCTL_VIDEO_QUERY_CURRENT_MODE),
    SeedIoctlValue(IOCTL_VIDEO_QUERY_CURSOR_ATTR),
    SeedIoctlValue(IOCTL_VIDEO_QUERY_CURSOR_POSITION),
    SeedIoctlValue(IOCTL_VIDEO_QUERY_NUM_AVAIL_MODES),
    SeedIoctlValue(IOCTL_VIDEO_QUERY_POINTER_ATTR),
    SeedIoctlValue(IOCTL_VIDEO_QUERY_POINTER_CAPABILITIES),
    SeedIoctlValue(IOCTL_VIDEO_QUERY_POINTER_POSITION),
    SeedIoctlValue(IOCTL_VIDEO_QUERY_PUBLIC_ACCESS_RANGES),
    SeedIoctlValue(IOCTL_VIDEO_REGISTER_VDM),
    SeedIoctlValue(IOCTL_VIDEO_RESET_DEVICE),
    SeedIoctlValue(IOCTL_VIDEO_RESTORE_HARDWARE_STATE),
    SeedIoctlValue(IOCTL_VIDEO_SAVE_HARDWARE_STATE),
    SeedIoctlValue(IOCTL_VIDEO_SET_CHILD_STATE_CONFIGURATION),
    SeedIoctlValue(IOCTL_VIDEO_SET_COLOR_LUT_DATA),
    SeedIoctlValue(IOCTL_VIDEO_SET_COLOR_REGISTERS),
    SeedIoctlValue(IOCTL_VIDEO_SET_CURRENT_MODE),
    SeedIoctlValue(IOCTL_VIDEO_SET_CURSOR_ATTR),
    SeedIoctlValue(IOCTL_VIDEO_SET_CURSOR_POSITION),
    SeedIoctlValue(IOCTL_VIDEO_SET_OUTPUT_DEVICE_POWER_STATE),
    SeedIoctlValue(IOCTL_VIDEO_SET_PALETTE_REGISTERS),
    SeedIoctlValue(IOCTL_VIDEO_SET_POINTER_ATTR),
    SeedIoctlValue(IOCTL_VIDEO_SET_POINTER_POSITION),
    SeedIoctlValue(IOCTL_VIDEO_SET_POWER_MANAGEMENT),
    SeedIoctlValue(IOCTL_VIDEO_SHARE_VIDEO_MEMORY),
    SeedIoctlValue(IOCTL_VIDEO_UNMAP_VIDEO_MEMORY),
    SeedIoctlValue(IOCTL_VIDEO_UNSHARE_VIDEO_MEMORY),
    SeedIoctlValue(IOCTL_VIDEO_VALIDATE_CHILD_STATE_CONFIGURATION),
    SeedIoctlValue(IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS),
    SeedIoctlValue(IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS),
    SeedIoctlValue(IOCTL_VOLUME_IS_IO_CAPABLE),
    SeedIoctlValue(IOCTL_VOLUME_IS_OFFLINE),
    SeedIoctlValue(IOCTL_VOLUME_LOGICAL_TO_PHYSICAL),
    SeedIoctlValue(IOCTL_VOLUME_OFFLINE),
    SeedIoctlValue(IOCTL_VOLUME_ONLINE),
    SeedIoctlValue(IOCTL_VOLUME_PHYSICAL_TO_LOGICAL),
    SeedIoctlValue(IOCTL_VOLUME_QUERY_FAILOVER_SET),
    SeedIoctlValue(IOCTL_VOLUME_QUERY_VOLUME_NUMBER),
    SeedIoctlValue(IOCTL_VOLUME_SUPPORTS_ONLINE_OFFLINE),
    SeedIoctlValue(IOCTL_WAIT_ON_DEVICE_EVENT),
    SeedIoctlValue(IOCTL_WAVE_BREAK_LOOP),
    SeedIoctlValue(IOCTL_WAVE_GET_CAPABILITIES),
    SeedIoctlValue(IOCTL_WAVE_GET_PITCH),
    SeedIoctlValue(IOCTL_WAVE_GET_PLAYBACK_RATE),
    SeedIoctlValue(IOCTL_WAVE_GET_POSITION),
    SeedIoctlValue(IOCTL_WAVE_GET_STATE),
    SeedIoctlValue(IOCTL_WAVE_GET_VOLUME),
    SeedIoctlValue(IOCTL_WAVE_PLAY),
    SeedIoctlValue(IOCTL_WAVE_QUERY_FORMAT),
    SeedIoctlValue(IOCTL_WAVE_RECORD),
    SeedIoctlValue(IOCTL_WAVE_SET_FORMAT),
    SeedIoctlValue(IOCTL_WAVE_SET_LOW_PRIORITY),
    SeedIoctlValue(IOCTL_WAVE_SET_PITCH),
    SeedIoctlValue(IOCTL_WAVE_SET_PLAYBACK_RATE),
    SeedIoctlValue(IOCTL_WAVE_SET_STATE),
    SeedIoctlValue(IOCTL_WAVE_SET_VOLUME),
    SeedIoctlValue(IOCTL_WMI_CHECK_ACCESS),
    SeedIoctlValue(IOCTL_WMI_DISABLE_COLLECTION),
    SeedIoctlValue(IOCTL_WMI_DISABLE_EVENT),
    SeedIoctlValue(IOCTL_WMI_ENABLE_COLLECTION),
    SeedIoctlValue(IOCTL_WMI_ENABLE_EVENT),
    SeedIoctlValue(IOCTL_WMI_EXECUTE_METHOD),
    SeedIoctlValue(IOCTL_WMI_GENERATE_EVENT),
    SeedIoctlValue(IOCTL_WMI_GET_ALL_REGISTRANT),
    SeedIoctlValue(IOCTL_WMI_GET_NEXT_REGISTRANT),
    SeedIoctlValue(IOCTL_WMI_GET_REGINFO),
    SeedIoctlValue(IOCTL_WMI_GET_VERSION),
    SeedIoctlValue(IOCTL_WMI_NOTIFY_USER),
    SeedIoctlValue(IOCTL_WMI_OPEN_GUID),
    SeedIoctlValue(IOCTL_WMI_QUERY_ALL_DATA),
    SeedIoctlValue(IOCTL_WMI_QUERY_LOGGER),
    SeedIoctlValue(IOCTL_WMI_QUERY_SINGLE_INSTANCE),
    SeedIoctlValue(IOCTL_WMI_READ_NOTIFICATIONS),
    SeedIoctlValue(IOCTL_WMI_SET_SINGLE_INSTANCE),
    SeedIoctlValue(IOCTL_WMI_SET_SINGLE_ITEM),
    SeedIoctlValue(IOCTL_WMI_START_LOGGER),
    SeedIoctlValue(IOCTL_WMI_STOP_LOGGER),
    SeedIoctlValue(IOCTL_WMI_TRACE_EVENT),
    SeedIoctlValue(IOCTL_WMI_TRACE_MESSAGE),
    SeedIoctlValue(IOCTL_WMI_TRANSLATE_FILE_HANDLE),
    SeedIoctlValue(IOCTL_WMI_UPDATE_LOGGER),
    SeedIoctlValue(IOCTL_WRITE_REGISTERS),
    {NULL, 0 }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\custcon\custcon.h ===
//////////////////////////////////////////////////////////////////////
//
// custcon.h : CUSTCON AvP[VC wb_[ t@CB
//

#if !defined(AFX_CUSTCON_H__106594D5_028D_11D2_8D1D_0000C06C2A54__INCLUDED_)
#define AFX_CUSTCON_H__106594D5_028D_11D2_8D1D_0000C06C2A54__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef __AFXWIN_H__
    #error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"       // C V{

/////////////////////////////////////////////////////////////////////////////
// CCustconApp:
// NX` custcon.cpp t@CQB
//

class CCustconApp : public CWinApp
{
public:
    CCustconApp();

// I[o[Ch
    // ClassWizard zI[o[ChB
    //{{AFX_VIRTUAL(CCustconApp)
    public:
    virtual BOOL InitInstance();
    //}}AFX_VIRTUAL

// Cve[V

    //{{AFX_MSG(CCustconApp)
        //  - ClassWizard uoB
        //        uR[hWB
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

extern int gExMode;     // default mode

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio OsO}B

#endif // !defined(AFX_CUSTCON_H__106594D5_028D_11D2_8D1D_0000C06C2A54__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\custcon\aboutdlg.h ===
// AboutDlg.h

#ifndef _ABOUTDLG_H
#define _ABOUTDLG_H

class CAboutDlg : public CDialog
{
public:
    CAboutDlg();

// _CAO f[^
    //{{AFX_DATA(CAboutDlg)
    enum { IDD = IDD_ABOUTBOX };
    //}}AFX_DATA

    // ClassWizard zI[o[Ch
    //{{AFX_VIRTUAL(CAboutDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV T|[g
    //}}AFX_VIRTUAL

// Cve[V
protected:
    //{{AFX_MSG(CAboutDlg)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\custcon\custcondlg.h ===
//////////////////////////////////////////////////////////////////////
//
// custconDlg.h : wb_[ t@C
//

#if !defined(AFX_CUSTCONDLG_H__106594D7_028D_11D2_8D1D_0000C06C2A54__INCLUDED_)
#define AFX_CUSTCONDLG_H__106594D7_028D_11D2_8D1D_0000C06C2A54__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
// CCustconDlg dialog

class CCustconDlg : public CDialog
{
// \z
public:
    CCustconDlg(CWnd* pParent = NULL);  // WRXgN^

// Dialog Data
    //{{AFX_DATA(CCustconDlg)
    enum { IDD = IDD_CUSTCON_DIALOG };
    CEdit   m_wordDelimCtrl;
    //}}AFX_DATA

    // ClassWizard zI[o[ChB
    //{{AFX_VIRTUAL(CCustconDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV T|[g
    virtual void OnOK();
    virtual void OnCancel();
    //}}AFX_VIRTUAL

// Cve[V
protected:
    HICON m_hIcon;

    // bZ[W }bv
    //{{AFX_MSG(CCustconDlg)
    virtual BOOL OnInitDialog();
    afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
    afx_msg void OnPaint();
    afx_msg HCURSOR OnQueryDragIcon();
    afx_msg void OnApply();
    afx_msg void OnDefaultValue();
    afx_msg void OnChangeWordDelim();
    afx_msg void OnUseExtendedEditKey();
    afx_msg void OnTrimLeadingZeros();
    afx_msg void OnReset();
    //}}AFX_MSG
    afx_msg void OnSelChange(UINT id);
    DECLARE_MESSAGE_MAP()

protected:
    void InitContents(BOOL isDefault);
    void CharInUse(UINT id, TCHAR c);
    void CharReturn(UINT id, TCHAR c);

    bool Update();

    int m_cWordDelimChanging;
    void EnableApply(BOOL fEnable = TRUE);

protected:
    CFont m_font;   // font for word delimiter edit control
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio OsO}B

#endif // !defined(AFX_CUSTCONDLG_H__106594D7_028D_11D2_8D1D_0000C06C2A54__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\custcon\aboutdlg.cpp ===
//////////////////////////////////////////////////////////////////////
//
// AboutDlg.cpp
//
// 1998 Jun, Hiro Yamamoto
//

#include "stdafx.h"
#include "custcon.h"
#include "AboutDlg.h"
#include <malloc.h>

/////////////////////////////////////////////////////////////////////////////
// AvP[Vo[Wg CAboutDlg _CAO

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
    //{{AFX_DATA_INIT(CAboutDlg)
    //}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CAboutDlg)
    //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
    //{{AFX_MSG_MAP(CAboutDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

struct FullVersion {
public:
	DWORD m_ms;
	DWORD m_ls;
public:
	FullVersion(DWORD ms, DWORD ls) : m_ms(ms), m_ls(ls) { }
};


FullVersion GetVersionInfo()
{
    TCHAR path[MAX_PATH];
    path[::GetModuleFileName(AfxGetInstanceHandle(), path, sizeof path / sizeof path[0])] = 0;

    DWORD dummy;
	DWORD size = GetFileVersionInfoSize(path, &dummy);
    ASSERT(size != 0);  // 0 means error
    LPVOID lpData = alloca(size);
    ASSERT(lpData);
	VERIFY( GetFileVersionInfo(path, 0, size, lpData) );
    LPVOID lpBuffer = NULL;
	UINT vSize;
    VERIFY( VerQueryValue(lpData, _T("\\"), &lpBuffer, &vSize) );
    if (lpBuffer) {
        VS_FIXEDFILEINFO* info = (VS_FIXEDFILEINFO*)lpBuffer;
    
        return FullVersion(info->dwProductVersionMS, info->dwProductVersionLS);
    } else {
        return FullVersion(0, 0);
    }
}

BOOL CAboutDlg::OnInitDialog()
{
	CDialog::OnInitDialog();
	
	FullVersion version = GetVersionInfo();
	CString format;
	format.LoadString(IDS_VERSION_TEMPLATE);
	CString buf;
	buf.Format(format, HIWORD(version.m_ms), LOWORD(version.m_ms), HIWORD(version.m_ls), LOWORD(version.m_ls));
	SetDlgItemText(IDC_MAIN_TITLE, buf);
	
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\custcon\custcondlg.cpp ===
//////////////////////////////////////////////////////////////////////
//
// custconDlg.cpp : Implementation file
// 1998 Jun, Hiro Yamamoto
//
//

#include "stdafx.h"
#include "custcon.h"
#include "custconDlg.h"
#include "Registry.h"
#include "AboutDlg.h"
#include "KeyDef.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define IDC_CTRL_END    IDC_PAUSE

/////////////////////////////////////////////////////////////////////////////
// CCustconDlg _CAO

CCustconDlg::CCustconDlg(CWnd* pParent /*=NULL*/)
    : CDialog(CCustconDlg::IDD, pParent)
{
    //{{AFX_DATA_INIT(CCustconDlg)
    //}}AFX_DATA_INIT
    m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);

    m_cWordDelimChanging = 0;
}

void CCustconDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CCustconDlg)
    DDX_Control(pDX, IDC_WORD_DELIM, m_wordDelimCtrl);
    //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CCustconDlg, CDialog)
    //{{AFX_MSG_MAP(CCustconDlg)
    ON_WM_SYSCOMMAND()
    ON_WM_PAINT()
    ON_WM_QUERYDRAGICON()
    ON_BN_CLICKED(IDC_APPLY, OnApply)
    ON_BN_CLICKED(IDC_DEFAULT_VALUE, OnDefaultValue)
    ON_EN_CHANGE(IDC_WORD_DELIM, OnChangeWordDelim)
    ON_BN_CLICKED(IDC_USE_EXTENDED_EDIT_KEY, OnUseExtendedEditKey)
    ON_BN_CLICKED(IDC_TRIM_LEADING_ZEROS, OnTrimLeadingZeros)
    ON_BN_CLICKED(IDC_RESET, OnReset)
    //}}AFX_MSG_MAP
    ON_CONTROL_RANGE(CBN_SELCHANGE, IDC_A, IDC_Z, OnSelChange)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CCustconDlg members

BOOL CCustconDlg::OnInitDialog()
{
    CDialog::OnInitDialog();

    // "o[W..." j[VXe j[B

    // IDM_ABOUTBOX R}h j[B
    ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
    ASSERT(IDM_ABOUTBOX < 0xF000);

    CMenu* pSysMenu = GetSystemMenu(FALSE);
    if (pSysMenu != NULL)
    {
        CString strAboutMenu;
        strAboutMenu.LoadString(IDS_ABOUTBOX);
        if (!strAboutMenu.IsEmpty())
        {
            pSysMenu->AppendMenu(MF_SEPARATOR);
            pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
        }
    }

    // _CAOpACRBt[[NAvP[VC
    // EBhE_CAOIB
    SetIcon(m_hIcon, TRUE);         // ACR
    SetIcon(m_hIcon, FALSE);        // ACR

    InitContents(FALSE);    // use default value

    ASSERT(m_wordDelimCtrl.GetSafeHwnd());
    m_wordDelimCtrl.LimitText(63);

    CWnd* wnd = GetDlgItem(IDC_WORD_DELIM);
    ASSERT(wnd);
    CFont* font = wnd->GetFont();
    LOGFONT lf;
    VERIFY( font->GetLogFont(&lf) );
    _tcscpy(lf.lfFaceName, _T("Courier New"));
    VERIFY( m_font.CreateFontIndirect(&lf) );
    wnd->SetFont(&m_font);

    return TRUE;  // TRUE Rg[tH[JXB
}

void CCustconDlg::OnSysCommand(UINT nID, LPARAM lParam)
{
    if ((nID & 0xFFF0) == IDM_ABOUTBOX)
    {
        CAboutDlg dlgAbout;
        dlgAbout.DoModal();
    }
    else
    {
        CDialog::OnSysCommand(nID, lParam);
    }
}

// _CAO{bNX{^AACR`
// R[hLqKvBMFC AvP[V document/view
// fgAt[[NIB

void CCustconDlg::OnPaint()
{
    if (IsIconic())
    {
        CPaintDC dc(this); // `pfoCX ReLXg

        SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

        // NCAg`
        int cxIcon = GetSystemMetrics(SM_CXICON);
        int cyIcon = GetSystemMetrics(SM_CYICON);
        CRect rect;
        GetClientRect(&rect);
        int x = (rect.Width() - cxIcon + 1) / 2;
        int y = (rect.Height() - cyIcon + 1) / 2;

        // ACR`B
        dc.DrawIcon(x, y, m_hIcon);
    }
    else
    {
        CDialog::OnPaint();
    }
}

// VXeA[U[EBhEhbOA
// J[\\oB
HCURSOR CCustconDlg::OnQueryDragIcon()
{
    return (HCURSOR) m_hIcon;
}

void CCustconDlg::OnOK()
{
    if (!Update()) {
        GetDlgItem(IDCANCEL)->EnableWindow();
        return;
    }
    CDialog::OnOK();
}

void CCustconDlg::OnCancel()
{
    if (GetDlgItem(IDCANCEL)->IsWindowEnabled())
        CDialog::OnCancel();
}

enum {
    CMD_NOTCMDCOMMAND = 0,
    CMD_FILENAME_COMPLETION = 1,
} CmdExeFunction;

static const struct InternalKeyDef {
    LPCTSTR text;
    WORD mod;
    BYTE vkey;
    BYTE cmd;   // not zero if this functionality is actually of cmd.exe.
} texts[] = {
    { _T(" "),                  0,                  0, },
    { _T("Left"),               0,                  VK_LEFT, },
    { _T("Right"),              0,                  VK_RIGHT, },
    { _T("Up"),                 0,                  VK_UP, },
    { _T("Down"),               0,                  VK_DOWN, },
    { _T("Beginning of line"),  0,                  VK_HOME, },
    { _T("End of line"),        0,                  VK_END, },
    { _T("Del char fwd"),       0,                  VK_DELETE, },
    { _T("Del char bwd"),       0,                  VK_BACK, },
    { _T("Del line"),           0,                  VK_ESCAPE, },
    { _T("Pause"),              0,                  VK_PAUSE, },
    { _T("History call"),       0,                  VK_F8, },

    { _T("Word left"),          LEFT_CTRL_PRESSED,  VK_LEFT, },
    { _T("Word right"),         LEFT_CTRL_PRESSED,  VK_RIGHT, },
    { _T("Del line bwd"),       LEFT_CTRL_PRESSED,  VK_HOME, },
    { _T("Del line fwd"),       LEFT_CTRL_PRESSED,  VK_END, },
    { _T("Del word bwd"),       LEFT_CTRL_PRESSED,  VK_BACK, },
    { _T("Del word fwd"),       LEFT_CTRL_PRESSED,  VK_DELETE, },

    { _T("Complete(*) filename"),
                                LEFT_CTRL_PRESSED,  _T('I'),    CMD_FILENAME_COMPLETION, },
};

#define COMPLETION_TEXT_INDEX   (array_size(texts) - 1)

void CCustconDlg::InitContents(BOOL isDefault)
{
    static bool is1st = true;

    CConRegistry reg;

    UINT chkByDefault = gExMode ? 1 : 0;

    CheckDlgButton(IDC_USE_EXTENDED_EDIT_KEY, isDefault ? chkByDefault : reg.ReadMode() != 0);
    CheckDlgButton(IDC_TRIM_LEADING_ZEROS, isDefault ? chkByDefault : reg.ReadTrimLeadingZeros() != 0);

    if (is1st) {
        //
        // Setup comobo boxes
        //
        for (UINT id = IDC_A; id <= IDC_Z; ++id) {
            CComboBox* combo = (CComboBox*)GetDlgItem(id);
            if (combo) {
                for (int i = 0; i < array_size(texts); ++i) {
                    int n = combo->AddString(texts[i].text);
                    combo->SetItemDataPtr(n, (void*)&texts[i]);
                }
            }
        }
    }

    const ExtKeyDef* pKeyDef = gExMode == 0 ? gaDefaultKeyDef : gaDefaultKeyDef2;
    ExtKeyDefBuf regKeyDef;
    CmdExeFunctions cmdExeFunctions = { 0x9, };
    if (!isDefault) {
        if (reg.ReadCustom(&regKeyDef))
            pKeyDef = regKeyDef.table;

        reg.ReadCmdFunctions(&cmdExeFunctions);
    }
    for (UINT i = 0; i <= 'Z' - 'A'; ++i, ++pKeyDef) {
        CComboBox* combo = (CComboBox*)GetDlgItem(i + IDC_A);
        if (combo == NULL)
            continue;
        if (cmdExeFunctions.dwFilenameCompletion == i + 1) {
            //
            // If this is filename completion key
            //
            TRACE1("i=%d matches.\n", i);
            VERIFY( combo->SelectString(-1, texts[COMPLETION_TEXT_INDEX].text) >= 0);
        }
        else {
            for (int j = 0; j < array_size(texts); ++j) {
                if (pKeyDef->keys[0].wVirKey == texts[j].vkey && pKeyDef->keys[0].wMod == texts[j].mod) {
                    VERIFY( combo->SelectString(-1, texts[j].text) >= 0);
                }
            }
        }
    }

    static const TCHAR defaultDelim[] = _T("\\" L"+!:=/.<>[];|&");
    LPCTSTR p = defaultDelim;
    CString delimInReg;
    if (!isDefault) {
        delimInReg = reg.ReadWordDelim();
        if (delimInReg != CConRegistry::m_err)
            p = delimInReg;
    }
    ++m_cWordDelimChanging;
    m_wordDelimCtrl.SetWindowText(p);
    --m_cWordDelimChanging;

    is1st = false;
}

bool RunCmd()
{
    STARTUPINFO startupInfo = {
        sizeof startupInfo,
        NULL, /*lpDesktop=*/NULL, /*lpTitle=*/_T("Update cmd"),
        0, 0, 0, 0,
        /*dwXCountChars=*/10, /*dwYCountChars=*/10,
        /*dwFillAttribute=*/0,
        /*dwFlags=*/STARTF_USEFILLATTRIBUTE | STARTF_USECOUNTCHARS | STARTF_USESHOWWINDOW,
        /*wShowWindow=*/SW_HIDE,
        /*cbReserved2=*/0,
    };
    PROCESS_INFORMATION processInfo;

    TCHAR path[_MAX_PATH];
    GetSystemDirectory(path, _MAX_PATH);
    _tcscat(path, _T("\\cmd.exe"));

    if (!CreateProcess(
            path, _T("cmd /c echo hello"),
            NULL, NULL,
            FALSE,
            CREATE_NEW_CONSOLE | NORMAL_PRIORITY_CLASS,
            NULL,
            NULL,
            &startupInfo,
            &processInfo)) {
        DWORD err = GetLastError();
        TRACE1("error code = %d\n", err);
        AfxMessageBox(_T("Could not run cmd.exe"));
        return false;
    }

    CloseHandle(processInfo.hProcess);
    CloseHandle(processInfo.hThread);
    return true;
}


bool CCustconDlg::Update()
{
    CConRegistry reg;

    //
    // To cheat the registry manager to skip the write when
    // values match, set the opposite value first and then
    // set the right one.
    //
    DWORD dwUseExKey = IsDlgButtonChecked(IDC_USE_EXTENDED_EDIT_KEY);
    if (!reg.WriteMode(!dwUseExKey) || !reg.WriteMode(dwUseExKey)) {
        return false;
    }

    if (!reg.WriteTrimLeadingZeros(IsDlgButtonChecked(IDC_TRIM_LEADING_ZEROS)))
        return false;

    //
    // Write custom extended keys
    //
    ExtKeyDefBuf value;

    memset(&value, 0, sizeof value);

    CmdExeFunctions cmdExeFunctions = { 0, };
    DWORD cmdFilenameCompletion = 0;

    for (int i = 0; i <= 'Z' - 'A'; ++i) {
        CComboBox* combo = (CComboBox*)GetDlgItem(IDC_A + i);
        if (combo == NULL)
            continue;
        int n = combo->GetCurSel();
        ASSERT(n >= 0);

        const InternalKeyDef* ikeydef = (const InternalKeyDef*)combo->GetItemDataPtr(n);
        ASSERT(ikeydef);

        switch (ikeydef->cmd) {
        case CMD_NOTCMDCOMMAND:
            value.table[i].keys[0].wMod = ikeydef->mod;
            value.table[i].keys[0].wVirKey = ikeydef->vkey;
            if (value.table[i].keys[0].wVirKey == VK_BACK && value.table[i].keys[0].wMod) {
                value.table[i].keys[0].wUnicodeChar = EXTKEY_ERASE_PREV_WORD;   // for back space special !
            }
            if (value.table[i].keys[0].wVirKey) {
                value.table[i].keys[1].wMod = LEFT_CTRL_PRESSED;
                value.table[i].keys[1].wVirKey = value.table[i].keys[0].wVirKey;
            }
            break;

        case CMD_FILENAME_COMPLETION:
            cmdExeFunctions.dwFilenameCompletion = i + 1;  // Ctrl + something
            break;
        }
    }
    BYTE* lpb = (BYTE*)&value.table[0];
    ASSERT(value.dwCheckSum == 0);
    for (i = 0; i < sizeof value.table; ++i) {
        value.dwCheckSum += lpb[i];
    }
    if (!reg.WriteCustom(&value) || !reg.WriteCmdFunctions(&cmdExeFunctions)) {
        return false;
    }

    CString buf;
    GetDlgItem(IDC_WORD_DELIM)->GetWindowText(buf);
    reg.WriteWordDelim(buf);

    EnableApply(FALSE);

    return RunCmd();
}


//
// Control exclusive selection etc.
//
void CCustconDlg::OnSelChange(UINT id)
{
    CComboBox* myself = (CComboBox*)GetDlgItem(id);
    ASSERT(myself);
    const InternalKeyDef* mykeydef = (const InternalKeyDef*)myself->GetItemDataPtr(myself->GetCurSel());
    if (mykeydef->cmd != CMD_NOTCMDCOMMAND) {
        for (unsigned i = 0; i <= 'Z' - 'A'; ++i) {
            if (IDC_A + i != id) {
                CComboBox* combo = (CComboBox*)GetDlgItem(IDC_A + i);
                if (combo == NULL)
                    continue;
                int n = combo->GetCurSel();
                ASSERT(n >= 0);

                const InternalKeyDef* ikeydef = (const InternalKeyDef*)combo->GetItemDataPtr(n);
                ASSERT(ikeydef);

                switch (ikeydef->cmd) {
                case CMD_NOTCMDCOMMAND:
                    break;

                default:
                    if (ikeydef->cmd == mykeydef->cmd) {
                        //
                        // Cmd function is exclusive.
                        //
                        combo->SetCurSel(0);
                    }
                    break;
                }
            }
        }
    }
    EnableApply();
}

//
// Enable or disable Apply button, if it's not yet.
//

void CCustconDlg::EnableApply(BOOL fEnable)
{
    CWnd* apply = GetDlgItem(IDC_APPLY);
    ASSERT(apply);
    if (apply->IsWindowEnabled() != fEnable)
        apply->EnableWindow(fEnable);
}

//
// "Apply" button hanlder.
//
// Firstly check and write the registry entry,
// then invoke dummy console window to let console know
// the change and let it update itself.
//

void CCustconDlg::OnApply()
{
    if (!Update())
        return;
    CWnd* wnd = GetDlgItem(IDCANCEL);
    ASSERT(wnd);
    wnd->EnableWindow(FALSE);
    CButton* ok = (CButton*)GetDlgItem(IDOK);
    ASSERT(ok);
    ok->SetWindowText(_T("Cl&ose"));
}

void CCustconDlg::OnDefaultValue()
{
    InitContents(TRUE);
    EnableApply();
}


//
// If user changes the setttings, enable "Apply" button
//

void CCustconDlg::OnChangeWordDelim()
{
    if (!m_cWordDelimChanging)
        EnableApply();
}

void CCustconDlg::OnUseExtendedEditKey()
{
    EnableApply();
}

void CCustconDlg::OnTrimLeadingZeros()
{
    EnableApply();
}

void CCustconDlg::OnReset()
{
    for (UINT id = IDC_A; id <= IDC_Z; ++id) {
        CComboBox* combo = (CComboBox*)GetDlgItem(id);
        if (combo) {
            combo->SetCurSel(0);
        }
    }
    GetDlgItem(IDC_WORD_DELIM)->SetWindowText(_T(""));
    CheckDlgButton(IDC_USE_EXTENDED_EDIT_KEY, 0);
    CheckDlgButton(IDC_TRIM_LEADING_ZEROS, 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\custcon\keydef.h ===
//
// keyDef.h
//


#ifndef KEYDEF_H
#define KEYDEF_H

extern const ExtKeyDef gaDefaultKeyDef['Z' - 'A' + 1];
extern const ExtKeyDef gaDefaultKeyDef2['Z' - 'A' + 1];


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\custcon\keydef.cpp ===
//
// KeyDef.h
//

#include "stdafx.h"
#include "Keydef.h"


const ExtKeyDef gaDefaultKeyDef['Z' - 'A' + 1] = {
    {   // A
        0,                  VK_HOME,        0,      // Ctrl
        LEFT_CTRL_PRESSED,  VK_HOME,        0,      // Alt
        0,                  0,              0,      // Ctrl+Alt
    },
    {   // B
        0,                  VK_LEFT,        0,      // Ctrl
        LEFT_CTRL_PRESSED,  VK_LEFT,        0,      // Alt
    },
    {   // C
        0,
    },
    {   // D
        0,                  VK_DELETE,      0,      // Ctrl
        LEFT_CTRL_PRESSED,  VK_DELETE,      0,      // Alt
        0,                  0,              0,      // Ctrl+Alt
    },
    {   // E
        0,                  VK_END,         0,      // Ctrl
        LEFT_CTRL_PRESSED,  VK_END,         0,      // Alt
        0,                  0,              0,      // Ctrl+Alt
    },
    {   // F
        0,                  VK_RIGHT,       0,      // Ctrl
        LEFT_CTRL_PRESSED,  VK_RIGHT,       0,      // Alt
        0,                  0,              0,      // Ctrl+Alt
    },
    {   // G
        0,
    },
    {   // H
        0,
    },
    {   // I
        LEFT_CTRL_PRESSED,  _T('I'),        0,      // Ctrl
    },
    {   // J
        0,
    },
    {   // K
        LEFT_CTRL_PRESSED,  VK_END,         0,      // Ctrl
    },
    {   // L
        0,
    },
    {   // M
        0,
    },
    {   // N
        0,                  VK_DOWN,        0,      // Ctrl
    },
    {   // O
        0,
    },
    {   // P
        0,                  VK_UP,          0,      // Ctrl
    },
    {   // Q
        0,
    },
    {   // R
        0,                  VK_F8,          0,      // Ctrl
    },
    {   // S
        0,                  VK_PAUSE,       0,      // Ctrl
    },
    {   // T
        LEFT_CTRL_PRESSED,  VK_DELETE,      0,      // Ctrl
    },
    {   // U
        0,                  VK_ESCAPE,      0,      // Ctrl
    },
    {   // V
        0,
    },
    {   // W
        LEFT_CTRL_PRESSED,  VK_BACK,        0x7f,    // Ctrl
    },
    {   // X
        0,
    },
    {   // Y
        0,
    },
    {   // Z
        0,
    },
};

const ExtKeyDef gaDefaultKeyDef2['Z' - 'A' + 1] = {
    {   // A
        LEFT_CTRL_PRESSED,  VK_LEFT,        0,      // Ctrl
        0,                  0,              0,      // Alt
        0,                  0,              0,      // Ctrl+Alt
    },
    {   // B
        0,                  VK_HOME,        0,      // Ctrl
    },
    {   // C
        0,
    },
    {   // D
        0,                  VK_RIGHT,       0,      // Ctrl
    },
    {   // E
        0,                  VK_UP,          0,      // Ctrl
    },
    {   // F
        LEFT_CTRL_PRESSED,  VK_RIGHT,       0,      // Ctrl
    },
    {   // G
        0,                  VK_DELETE,      0,      // Ctrl
    },
    {   // H
        0,
    },
    {   // I
        0,
    },
    {   // J
        0,                  VK_PAUSE,       0,      // Ctrl
    },
    {   // K
        LEFT_CTRL_PRESSED,  VK_END,         0,      // Ctrl
    },
    {   // L
        0,
    },
    {   // M
        0,
    },
    {   // N
        0,                  VK_DOWN,        0,      // Ctrl
    },
    {   // O
        0,
    },
    {   // P
        0,                  VK_UP,          0,      // Ctrl
    },
    {   // Q
        0,                  VK_END,         0,      // Ctrl
    },
    {   // R
        0,                  VK_F8,          0,      // Ctrl
    },
    {   // S
        0,                  VK_LEFT,        0,      // Ctrl
    },
    {   // T
        LEFT_CTRL_PRESSED,  VK_DELETE,      0,      // Ctrl
    },
    {   // U
        0,                  VK_ESCAPE,      0,      // Ctrl
    },
    {   // V
        0,                  VK_PAUSE,       0,      // Ctrl
    },
    {   // W
        LEFT_CTRL_PRESSED,  VK_BACK,        0x7f,   // Ctrl
    },
    {   // X
        0,                  VK_DOWN,        0,      // Ctrl
    },
    {   // Y
        0,                  VK_ESCAPE,      0,      // Ctrl
    },
    {   // Z
        0,
    },
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\custcon\registry.h ===
//////////////////////////////////////////////////////////////////////
//
// Registry.h: Registry NXC^[tFCX
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_REGISTRY_H__78045FC5_02E1_11D2_8D1E_0000C06C2A54__INCLUDED_)
#define AFX_REGISTRY_H__78045FC5_02E1_11D2_8D1E_0000C06C2A54__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

struct CmdExeFunctions {
    DWORD dwFilenameCompletion;
};


class CConRegistry
{
public:
    CConRegistry();
    virtual ~CConRegistry();

public:
    static const CString m_err;
public:
    bool ReadCustom(ExtKeyDefBuf*);
    bool WriteCustom(const ExtKeyDefBuf*);

    DWORD ReadMode();
    bool WriteMode(DWORD);

    CString ReadWordDelim();
    bool WriteWordDelim(const CString&);

    DWORD ReadTrimLeadingZeros();
    bool WriteTrimLeadingZeros(DWORD);


    bool ReadCmdFunctions(CmdExeFunctions*);
    bool WriteCmdFunctions(const CmdExeFunctions*);

protected:
    void WriteError(LPCTSTR subkey);
    CString ReadString(LPCTSTR subkey);
    bool WriteString(LPCTSTR subkey, const CString& str);
    DWORD ReadDWORD(LPCTSTR subkey);
    bool WriteDWORD(LPCTSTR subkey, DWORD value);
protected:
    HKEY m_hkey;
    HKEY m_cmdKey;
};


#endif // !defined(AFX_REGISTRY_H__78045FC5_02E1_11D2_8D1E_0000C06C2A54__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\custcon\registry.cpp ===
//////////////////////////////////////////////////////////////////////
//
// Registry.cpp: Registry NXCve[V
//
// 1998 Jun, Hiro Yamamoto
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "custcon.h"
#include "Registry.h"
#include "KeyDef.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// \z/
//////////////////////////////////////////////////////////////////////

CConRegistry::CConRegistry()
{
    if (RegOpenKeyEx(HKEY_CURRENT_USER, _T("Console"), 0, KEY_ALL_ACCESS, &m_hkey) != ERROR_SUCCESS ||
            RegOpenKeyEx(HKEY_CURRENT_USER, _T("Software\\Microsoft\\Command Processor"), 0, KEY_ALL_ACCESS, &m_cmdKey) != ERROR_SUCCESS) {
        AfxMessageBox(IDP_FAILED_TO_OPEN_REGISTRY);
        AfxAbort(); // exodus
    }
}

CConRegistry::~CConRegistry()
{
    ASSERT(m_hkey);
    VERIFY( RegCloseKey(m_hkey) == ERROR_SUCCESS );
    VERIFY( RegCloseKey(m_cmdKey) == ERROR_SUCCESS );
}

const CString CConRegistry::m_err(_T("\xffff"));

//////////////////////////////////////////////////////////////////////
// Members
//////////////////////////////////////////////////////////////////////

CString CConRegistry::ReadString(LPCTSTR subkey)
{
    ASSERT(m_hkey);
    if (m_hkey == NULL)
        return m_err;

    DWORD size = 0;
    DWORD type;
    if (RegQueryValueEx(m_hkey, subkey, NULL, &type, NULL, &size) != ERROR_SUCCESS) {
        TRACE2("Reg::ReadString() error accessing \"%s\". err=%d\n", subkey, ::GetLastError());
        return m_err;
    }
    if (type != REG_SZ) {
        TRACE1("Reg::ReadString() -- type(%d) is not REG_SZ.\n", type);
        return m_err;
    }
    CString tmp;
    LPTSTR buf = tmp.GetBuffer(size);
    VERIFY( RegQueryValueEx(m_hkey, subkey, NULL, &type, (LPBYTE)buf, &size) == ERROR_SUCCESS );
    tmp.ReleaseBuffer();
    return tmp;
}

bool CConRegistry::WriteString(LPCTSTR subkey, const CString& value)
{
    ASSERT(m_hkey);
    if (m_hkey == NULL)
        return false;

    if (RegSetValueEx(m_hkey, subkey, 0, REG_SZ, (LPBYTE)(LPCTSTR)value, (value.GetLength() + 1) * sizeof(TCHAR)) != ERROR_SUCCESS) {
        WriteError(subkey);
        return false;
    }
    return true;
}

DWORD CConRegistry::ReadDWORD(LPCTSTR subkey)
{
    DWORD value;
    DWORD type;
    DWORD size = sizeof value;
    if (RegQueryValueEx(m_hkey, subkey, NULL, &type, (LPBYTE)&value, &size) != ERROR_SUCCESS) {
        return 0;
    }
    if (type != REG_DWORD)
        return 0;
    return value;
}

bool CConRegistry::WriteDWORD(LPCTSTR subkey, DWORD value)
{
    if (RegSetValueEx(m_hkey, subkey, 0, REG_DWORD, (LPBYTE)&value, sizeof value) != ERROR_SUCCESS) {
        WriteError(subkey);
        return false;
    }
    return true;
}

void CConRegistry::WriteError(LPCTSTR subkey)
{
    CString buf;
    buf.Format(_T("Registry write operation (%s) failed.\r\nErr code=%d"), subkey, ::GetLastError());
    AfxMessageBox(buf);
}

//////////////////////////////////////////////////////////

bool CConRegistry::ReadCustom(ExtKeyDefBuf* buf)
{
    ASSERT(m_hkey);
    if (m_hkey == NULL)
        return false;

    DWORD size;
    DWORD type;
    if (RegQueryValueEx(m_hkey, CONSOLE_REGISTRY_EXTENDEDEDITKEY_CUSTOM, NULL, &type, NULL, &size) != ERROR_SUCCESS) {
        TRACE2("Reg::ReadCuston() error accessing \"%s\". err=%d\n", CONSOLE_REGISTRY_EXTENDEDEDITKEY_CUSTOM, ::GetLastError());
        return false;
    }
    if (type != REG_BINARY) {
        TRACE1("Reg::ReadString() -- type(%d) is not REG_SZ.\n", type);
        return false;
    }
    if (size != sizeof *buf) {
        TRACE1("Reg:ReadCuston() -- size(%d) is different.\n", size);
        return false;
    }

    VERIFY( RegQueryValueEx(m_hkey, CONSOLE_REGISTRY_EXTENDEDEDITKEY_CUSTOM, NULL, &type, (LPBYTE)buf, &size) == ERROR_SUCCESS );

    return true;
}

bool CConRegistry::WriteCustom(const ExtKeyDefBuf* buf)
{
    ASSERT(m_hkey);
    if (m_hkey == NULL)
        return false;

    if (RegSetValueEx(m_hkey, CONSOLE_REGISTRY_EXTENDEDEDITKEY_CUSTOM, 0, REG_BINARY, (LPBYTE)buf, sizeof *buf) != ERROR_SUCCESS) {
        WriteError(CONSOLE_REGISTRY_EXTENDEDEDITKEY_CUSTOM);
        return false;
    }

    return true;
}


DWORD CConRegistry::ReadMode()
{
    return ReadDWORD(CONSOLE_REGISTRY_EXTENDEDEDITKEY);
}

bool CConRegistry::WriteMode(DWORD value)
{
    return WriteDWORD(CONSOLE_REGISTRY_EXTENDEDEDITKEY, value);
}


CString CConRegistry::ReadWordDelim()
{
    return ReadString(CONSOLE_REGISTRY_WORD_DELIM);
}

bool CConRegistry::WriteWordDelim(const CString& value)
{
    return WriteString(CONSOLE_REGISTRY_WORD_DELIM, value);
}


DWORD CConRegistry::ReadTrimLeadingZeros()
{
    return ReadDWORD(CONSOLE_REGISTRY_TRIMZEROHEADINGS);
}

bool CConRegistry::WriteTrimLeadingZeros(DWORD value)
{
    return WriteDWORD(CONSOLE_REGISTRY_TRIMZEROHEADINGS, value);
}

#define CMD_REGISTRY_FILENAME_COMPLETION    _T("CompletionChar")

bool CConRegistry::ReadCmdFunctions(CmdExeFunctions* func)
{
    DWORD size = sizeof(func->dwFilenameCompletion);
    DWORD type;
    return RegQueryValueEx(m_cmdKey, CMD_REGISTRY_FILENAME_COMPLETION, NULL, &type, (LPBYTE)&func->dwFilenameCompletion, &size) == ERROR_SUCCESS;
}

bool CConRegistry::WriteCmdFunctions(const CmdExeFunctions* func)
{
    return RegSetValueEx(m_cmdKey, CMD_REGISTRY_FILENAME_COMPLETION, 0, REG_DWORD, (LPBYTE)&func->dwFilenameCompletion, sizeof func->dwFilenameCompletion) == ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\custcon\stdafx.h ===
//////////////////////////////////////////////////////////////////////
// stdafx.h : WVXe CN[h t@CA
//            QAX
//            vWFNgpCN[h t@CLqB
//

#if !defined(AFX_STDAFX_H__106594D9_028D_11D2_8D1D_0000C06C2A54__INCLUDED_)
#define AFX_STDAFX_H__106594D9_028D_11D2_8D1D_0000C06C2A54__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define VC_EXTRALEAN        // Windows wb_[wgpX^btOB

#include <afxwin.h>         // MFC RAWR|[lg
#include <afxext.h>         // MFC g
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>         // MFC  Windows R Rg[ T|[g
#endif // _AFX_NO_AFXCMN_SUPPORT

#include "winconp.h"

#ifndef array_size
#define array_size(x)   (sizeof(x) / sizeof(x[0]))
#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio OsO}B

#endif // !defined(AFX_STDAFX_H__106594D9_028D_11D2_8D1D_0000C06C2A54__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\custcon\stdafx.cpp ===
// stdafx.cpp : WCN[ht@C\[X t@C
//  custcon.pch : vRpCwb_[
//  stdafx.obj : vRpC^Cv

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\custcon\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by custcon.rc
//
#define IDM_ABOUTBOX                    0x0010
#define IDD_ABOUTBOX                    100
#define IDS_ABOUTBOX                    101
#define IDD_CUSTCON_FORM                101
#define IDD_CUSTCON_DIALOG              102
#define IDD_CUSTCON_FORM1               102
#define IDS_VERSION_TEMPLATE            102
#define IDD_CUSTCON_DIALOG1             103
#define IDP_FAILED_TO_OPEN_REGISTRY     103
#define IDD_CUSTCON_DIALOG2             104
#define IDD_CUSTCON_DIALOG_FULLOPEN     104
#define IDD_CUSTCON_DIALOG3             105
#define IDR_MAINFRAME                   128
#define IDR_CUSTCOTYPE                  129
#define IDD_DIALOG1                     129
#define IDD_DIALOG2                     130
#define IDC_ENABLE_ESC                  1000
#define IDC_ENABLE_END                  1001
#define IDC_ENABLE_HOME                 1002
#define IDC_ENABLE_LEFT                 1003
#define IDC_ENABLE_UP                   1004
#define IDC_ENABLE_RIGHT                1005
#define IDC_ENABLE_DOWN                 1006
#define IDC_ENABLE_DELETE               1007
#define IDC_ENABLE_F8                   1008
#define IDC_ENABLE_CTRL_LEFT            1009
#define IDC_ENABLE_CTRL_RIGHT           1010
#define IDC_ENABLE_DELETE_EOL           1011
#define IDC_ENABLE_DELETE_WORD_FWD      1012
#define IDC_ENABLE_DELETE_WORD_BWD      1013
#define IDC_APPLY                       1015
#define IDC_DEFAULT_VALUE               1016
#define IDC_USE_EXTENDED_EDIT_KEY       1017
#define IDC_CHECK1                      1020
#define IDC_CHECK2                      1021
#define IDC_RESET                       1021
#define IDC_CHECK3                      1022
#define IDC_MAIN_TITLE                  1022
#define IDC_CHECK4                      1023
#define IDC_CHECK5                      1024
#define IDC_CHECK6                      1025
#define IDC_CHECK7                      1026
#define IDC_CHECK8                      1027
#define IDC_CHECK9                      1028
#define IDC_CHECK10                     1029
#define IDC_CHECK11                     1030
#define IDC_CHECK12                     1031
#define IDC_CHECK13                     1032
#define IDC_CHECK14                     1033
#define IDC_CHECK15                     1034
#define IDC_CHECK16                     1035
#define IDC_CHECK17                     1036
#define IDC_CHECK18                     1037
#define IDC_CHECK19                     1038
#define IDC_CHECK20                     1039
#define IDC_CHECK21                     1040
#define IDC_CHECK22                     1041
#define IDC_CHECK23                     1042
#define IDC_CHECK24                     1043
#define IDC_CHECK25                     1044
#define IDC_ESC                         2000
#define IDC_END                         2001
#define IDC_HOME                        2002
#define IDC_LEFT                        2003
#define IDC_UP                          2004
#define IDC_RIGHT                       2005
#define IDC_DOWN                        2006
#define IDC_DELETE                      2007
#define IDC_F8                          2008
#define IDC_CTRL_LEFT                   2009
#define IDC_CTRL_RIGHT                  2010
#define IDC_DELETE_EOL                  2011
#define IDC_DELETE_WORD_FWD             2012
#define IDC_DELETE_WORD_BWD             2013
#define IDC_PAUSE                       2014
#define IDC_ALT_END                     3001
#define IDC_ALT_HOME                    3002
#define IDC_ALT_LEFT                    3003
#define IDC_ALT_RIGHT                   3005
#define IDC_ALT_CTRL_LEFT               3009
#define IDC_ALT_CTRL_RIGHT              3010
#define IDC_WORD_DELIM                  4000
#define IDC_TRIM_LEADING_ZEROS          4001
#define IDC_A                           5000
#define IDC_B                           5001
#define IDC_C                           5002
#define IDC_D                           5003
#define IDC_E                           5004
#define IDC_F                           5005
#define IDC_G                           5006
#define IDC_H                           5007
#define IDC_I                           5008
#define IDC_J                           5009
#define IDC_K                           5010
#define IDC_L                           5011
#define IDC_M                           5012
#define IDC_N                           5013
#define IDC_O                           5014
#define IDC_P                           5015
#define IDC_Q                           5016
#define IDC_R                           5017
#define IDC_S                           5018
#define IDC_T                           5019
#define IDC_U                           5020
#define IDC_V                           5021
#define IDC_W                           5022
#define IDC_X                           5023
#define IDC_Y                           5024
#define IDC_Z                           5025
#define IDC_CTRL_A                      6000
#define IDC_CTRL_B                      6001
#define IDC_CTRL_C                      6002
#define IDC_CTRL_D                      6003
#define IDC_CTRL_E                      6004
#define IDC_CTRL_F                      6005
#define IDC_CTRL_G                      6006
#define IDC_CTRL_H                      6007
#define IDC_CTRL_I                      6008
#define IDC_CTRL_J                      6009
#define IDC_CTRL_K                      6010
#define IDC_CTRL_L                      6011
#define IDC_CTRL_M                      6012
#define IDC_CTRL_N                      6013
#define IDC_CTRL_O                      6014
#define IDC_CTRL_P                      6015
#define IDC_CTRL_Q                      6016
#define IDC_CTRL_R                      6017
#define IDC_CTRL_S                      6018
#define IDC_CTRL_T                      6019
#define IDC_CTRL_U                      6020
#define IDC_CTRL_V                      6021
#define IDC_CTRL_W                      6022
#define IDC_CTRL_X                      6023
#define IDC_CTRL_Y                      6024
#define IDC_CTRL_Z                      6025

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        132
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1023
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\dbmon\dbmon.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    dbmon.c

Abstract:

    A simple program to print strings passed to OutputDebugString when
    the app printing the strings is not being debugged.

Author:

    Kent Forschmiedt (kentf) 30-Sep-1994

Revision History:

--*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>

int _cdecl
main(
    int argc,
    char ** argv
    )
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    HANDLE AckEvent;
    HANDLE ReadyEvent;
    HANDLE SharedFile;
    LPVOID SharedMem;
    LPSTR  String;
    DWORD  ret;
    DWORD  LastPid;
    LPDWORD pThisPid;
    BOOL    DidCR;

    SECURITY_ATTRIBUTES sa;
    SECURITY_DESCRIPTOR sd;

    sa.nLength = sizeof(SECURITY_ATTRIBUTES);
    sa.bInheritHandle = TRUE;
    sa.lpSecurityDescriptor = &sd;

    if(!InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION)) {
        fprintf(stderr,"unable to InitializeSecurityDescriptor, err == %d\n",
            GetLastError());
        exit(1);
    }

    if(!SetSecurityDescriptorDacl(&sd, TRUE, (PACL)NULL, FALSE)) {
        fprintf(stderr,"unable to SetSecurityDescriptorDacl, err == %d\n",
            GetLastError());
        exit(1);
    }

    AckEvent = CreateEvent(&sa, FALSE, FALSE, "DBWIN_BUFFER_READY");

    if (!AckEvent) {
        fprintf(stderr,
                "dbmon: Unable to create synchronization object, err == %d\n",
                GetLastError());
        exit(1);
    }

    if (GetLastError() == ERROR_ALREADY_EXISTS) {
        fprintf(stderr, "dbmon: already running\n");
        exit(1);
    }

    ReadyEvent = CreateEvent(&sa, FALSE, FALSE, "DBWIN_DATA_READY");

    if (!ReadyEvent) {
        fprintf(stderr,
                "dbmon: Unable to create synchronization object, err == %d\n",
                GetLastError());
        exit(1);
    }

    SharedFile = CreateFileMapping(
                        (HANDLE)-1,
                        &sa,
                        PAGE_READWRITE,
                        0,
                        4096,
                        "DBWIN_BUFFER");

    if (!SharedFile) {
        fprintf(stderr,
                "dbmon: Unable to create file mapping object, err == %d\n",
                GetLastError());
        exit(1);
    }

    SharedMem = MapViewOfFile(
                        SharedFile,
                        FILE_MAP_READ,
                        0,
                        0,
                        512);

    if (!SharedMem) {
        fprintf(stderr,
                "dbmon: Unable to map shared memory, err == %d\n",
                GetLastError());
        exit(1);
    }

    String = (LPSTR)SharedMem + sizeof(DWORD);
    pThisPid = SharedMem;

    LastPid = 0xffffffff;
    DidCR = TRUE;

    SetEvent(AckEvent);

    for (;;) {

        ret = WaitForSingleObject(ReadyEvent, INFINITE);

        if (ret != WAIT_OBJECT_0) {

            fprintf(stderr, "dbmon: wait failed; err == %d\n", GetLastError());
            exit(1);

        } else {

            if (LastPid != *pThisPid) {
                LastPid = *pThisPid;
                if (!DidCR) {
                    putchar('\n');
                    DidCR = TRUE;
                }
            }

            if (DidCR) {
                printf("%3u: ", LastPid);
            }

            printf("%s", String);
            DidCR = (*String && (String[strlen(String) - 1] == '\n'));
            SetEvent(AckEvent);

        }

    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\dbwin32\dbwin32.h ===
#define INITIAL_LIST_SIZE 32
#define LIST_CHUNK_SIZE 10

#define WM_SENDTEXT WM_USER
#define WM_ENDTHREAD (WM_USER+1)

#define DBO_OUTPUTDEBUGSTRING	0x0001
#define DBO_EXCEPTIONS			0x0002
#define DBO_PROCESSCREATE		0x0004
#define DBO_PROCESSEXIT			0x0008
#define DBO_THREADCREATE		0x0010
#define DBO_THREADEXIT			0x0020
#define DBO_DLLLOAD				0x0040
#define DBO_DLLUNLOAD			0x0080
#define DBO_RIP					0x0100
#define DBO_ALL					0xFFFF

struct AttachInfo
{
	DWORD dwProcess;
	HWND hwndFrame;
};

struct ExecInfo
{
	LPSTR lpszCommandLine;
	HWND hwndFrame;
};

struct SystemWindowInfo
{
	HWND hwndFrame;
};

struct StringInfo
{
	DWORD dwProcess;
	DWORD dwThread;
	DWORD dwParentProcess;
	LPCSTR lpszText;
	int cLines;
};

class GrowableList
{
public:
	GrowableList(int cbSizeIn);
	virtual ~GrowableList();

	int Count();
	BOOL FindItem(void *pvFind, int *piFound = NULL);
	void GetItem(int iItem, void *pvItem);
	void InsertItem(void *pvItem);
	void RemoveItem(void *pvItem);
	void RemoveItem(int iItem);

protected:
	virtual BOOL IsEqual(void *pv1, void *pv2) = 0;

	int cbSize;
	int cItemsCur;
	int cItemsMax;
	void *pvData;
};

void __cdecl AttachThread(void *pv);
void __cdecl ExecThread(void *pv);
void __cdecl SystemThread(void *pv);

#ifdef _DBDBG32_

#define EXCEPTION_VDM_EVENT 0x40000005L

#define BUF_SIZE 1024
#define MODULE_SIZE 32

struct ProcessInfo
{
	DWORD dwProcess;
	HANDLE hProcess;
	char rgchModule[MODULE_SIZE];
};

class ProcessList : public GrowableList
{
public:
	ProcessList();
	~ProcessList();

protected:
	virtual BOOL IsEqual(void *pv1, void *pv2);
};

struct ThreadInfo
{
	DWORD dwProcess;
	DWORD dwThread;
};

class ThreadList : public GrowableList
{
public:
	ThreadList();
	~ThreadList();

protected:
	virtual BOOL IsEqual(void *pv1, void *pv2);
};

struct DllInfo
{
	DWORD dwProcess;
	LPVOID lpBaseOfDll;
	char rgchModule[MODULE_SIZE];
};

class DllList : public GrowableList
{
public:
	DllList();
	~DllList();

protected:
	virtual BOOL IsEqual(void *pv1, void *pv2);
};

void __cdecl DebugThread(HWND hwndFrame, DWORD dwProcess);
void SendText(HWND hwndFrame, DEBUG_EVENT *pDebugEvent, DWORD dwParentProcess,
		LPCSTR lpszText, WORD wEvent);

void ProcessExceptionEvent(EXCEPTION_DEBUG_INFO *pException, LPSTR lpszBuf);

void GetModuleName(HANDLE hFile, HANDLE hProcess, DWORD_PTR BaseOfImage, LPSTR lpszBuf);

#endif	// _DBDBG32_

#ifdef _DBWIN32_

#define MAX_LINES 500

#define MAX_HISTORY 5

#define INACTIVE_MINIMIZE 0
#define INACTIVE_NONE 1
#define INACTIVE_CLOSE 2

struct DbWin32Options
{
	RECT rcWindow;
	int nShowCmd;
	BOOL fOnTop;
	BOOL fChildMax;
	int nInactive;
	BOOL fNewOnProcess;
	BOOL fNewOnThread;
	WORD wFilter;
	CString rgstCommandLine[MAX_HISTORY];
};

class DbWin32Child;

struct WindowInfo
{
	DWORD dwProcess;
	DWORD dwThread;
	DbWin32Child *pwndChild;
};

class WindowList : public GrowableList
{
public:
	WindowList();
	~WindowList();

protected:
	virtual BOOL IsEqual(void *pv1, void *pv2);
};

class DbWin32App : public CWinApp
{
public:
	DbWin32App();
	~DbWin32App();

	void ReadOptions();
	void WriteOptions(WINDOWPLACEMENT *pwpl);

protected:
	virtual BOOL InitInstance();

	DbWin32Options dbo;
};

class DbWin32Edit : public CEdit
{
public:
	DbWin32Edit();
	~DbWin32Edit();

	BOOL Create(CWnd *pwndParent);
};

class DbWin32Child : public CMDIChildWnd
{
public:
	DbWin32Child(WORD wFilterIn);
	~DbWin32Child();

	void AddText(WORD wEvent, LPCSTR lpszText, int cLines, BOOL fSetTitle);

protected:
	DbWin32Edit wndEdit;
	CFont fontCur;
	WORD wFilter;

private:
	// Windows messages
	afx_msg int OnCreate(LPCREATESTRUCT lpcs);
	afx_msg void OnDestroy();
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnMDIActivate(BOOL bActivate, CWnd *pwndActivate, CWnd *pwndDeactivate);
	afx_msg BOOL OnNcActivate(BOOL bActivate);
	// Command handlers
	afx_msg void OnFileSaveBuffer();
	afx_msg void OnEditCopy();
	afx_msg void OnEditClearBuffer();
	afx_msg void OnEditSelectAll();
	// Idle update handlers
	// Notification messages
	afx_msg void OnMaxText();
	DECLARE_MESSAGE_MAP()
};

class DbWin32Frame : public CMDIFrameWnd
{
public:
	DbWin32Frame(DbWin32Options *pdbo);
	~DbWin32Frame();

	void ExecProcess(LPCSTR lpszCommandLine);

	void ChildMaximized(BOOL fMax);

	void FileSystem();

protected:
	virtual BOOL PreCreateWindow(CREATESTRUCT &cs);

	WindowList wl;
	DbWin32Child *pwndSystem;
	DbWin32Options *pdbo;
	BOOL fInCreate;
	BOOL fNT351;

private:
	// Windows messages
	afx_msg void OnDestroy();
	afx_msg LRESULT OnSendText(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnEndThread(WPARAM wParam, LPARAM lParam);
	// Command handlers
	afx_msg void OnFileRun();
	afx_msg void OnFileAttach();
	afx_msg void OnFileSystem();
	afx_msg void OnFileExit();
	afx_msg void OnOptions();
	afx_msg void OnAbout();
	// Idle update handlers
	afx_msg void OnUpdateFileSystem(CCmdUI *pCmdUI);
	DECLARE_MESSAGE_MAP()
};

class DbWin32RunDlg : public CDialog
{
public:
	DbWin32RunDlg(CString *pstIn);
	~DbWin32RunDlg();

	CString &GetCommandLine();

protected:
	virtual BOOL OnInitDialog();

	CString *pst;
	CString stCommandLine;

private:
	// Windows messages
	afx_msg void OnEditChange();
	afx_msg void OnSelChange();
	afx_msg void OnBrowse();
	// Command handlers
	// Idle update handlers
	DECLARE_MESSAGE_MAP()
};

class DbWin32AttachDlg : public CDialog
{
public:
	DbWin32AttachDlg(WindowList *pwlIn);
	~DbWin32AttachDlg();

	DWORD GetSelectedProcess();

protected:
	virtual BOOL OnInitDialog();
	virtual void OnOK();

	WindowList *pwl;
	DWORD dwProcess;

private:
	// Windows messages
	afx_msg void OnDoubleClick();
	// Command handlers
	// Idle update handlers
	DECLARE_MESSAGE_MAP()
};

class DbWin32OptionsDlg : public CDialog
{
public:
	DbWin32OptionsDlg(DbWin32Options *pdboIn);
	~DbWin32OptionsDlg();

protected:
	virtual BOOL OnInitDialog();
	virtual void OnOK();

	DbWin32Options *pdbo;

private:
	afx_msg void OnClicked();
	DECLARE_MESSAGE_MAP()
};

inline CString &DbWin32RunDlg::GetCommandLine()
{
	return(stCommandLine);
}

inline DWORD DbWin32AttachDlg::GetSelectedProcess()
{
	return(dwProcess);
}

#endif // _DBWIN32_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\dbwin32\dbwin32.cpp ===
#pragma warning(disable:4135)
#include <afxwin.h>
#include <afxdlgs.h>
#pragma warning(default:4135)
#include <process.h>
#include "resource.h"
#define _DBWIN32_
#include "dbwin32.h"

char szCompany[] = "Microsoft";
char szApplication[] = "DbWin32";
char szIniSection1[] = "Window";
char szIniSection2[] = "Options";
char szKey1[] = "X";
char szKey2[] = "Y";
char szKey3[] = "Width";
char szKey4[] = "Height";
char szKey5[] = "State";
char szKey6[] = "OnTop";
char szKey7[] = "ChildMaximized";
char szKey8[] = "InactiveWindows";
char szKey9[] = "NewWindowOnProcess";
char szKey10[] = "NewWindowOnThread";
char szKey11[] = "EventFilter";
char *rgpszHistoryKeys[MAX_HISTORY] = {"LastCommandLine1", "LastCommandLine2",
		"LastCommandLine3", "LastCommandLine4", "LastCommandLine5"};

GrowableList::GrowableList(int cbSizeIn)
{
	cbSize = cbSizeIn;
	cItemsCur = 0;
	cItemsMax = INITIAL_LIST_SIZE;
	pvData = malloc(cbSize * INITIAL_LIST_SIZE);
}

GrowableList::~GrowableList()
{
	free(pvData);
}

int GrowableList::Count()
{
	return(cItemsCur);
}

BOOL GrowableList::FindItem(void *pvItem, int *piFound)
{
	int iItem;
	BYTE *pbItem;

	for (iItem = 0, pbItem = (BYTE *)pvData; ((iItem < cItemsCur) &&
			!IsEqual(pvItem, pbItem)); iItem++, pbItem += cbSize);
	if (iItem == cItemsCur)
		return(FALSE);
	memcpy(pvItem, pbItem, cbSize);
	if (piFound)
		*piFound = iItem;
	return(TRUE);
}

void GrowableList::GetItem(int iItem, void *pvItem)
{
	BYTE *pbItem = (BYTE *)pvData;

	pbItem += (cbSize * iItem);
	memcpy(pvItem, pbItem, cbSize);
}

void GrowableList::InsertItem(void *pvItem)
{
    void *pvNew;
    BYTE *pbNew;

    if (!FindItem(pvItem))
    {
        if (cItemsCur == cItemsMax)
        {
            cItemsMax += LIST_CHUNK_SIZE;
            pvNew = malloc(cbSize * cItemsMax);
            if (!pvNew)
            {
                return;
            }
            memcpy(pvNew, pvData, (cbSize * (cItemsMax - LIST_CHUNK_SIZE)));
            free(pvData);
            pvData = pvNew;
        }
        pbNew = (BYTE *)pvData;
        pbNew += (cbSize * cItemsCur);
        cItemsCur++;
        memcpy(pbNew, pvItem, cbSize);
    }
}

void GrowableList::RemoveItem(void *pvItem)
{
	int iItem;

	if (FindItem(pvItem, &iItem))
		RemoveItem(iItem);
}

void GrowableList::RemoveItem(int iItem)
{
	BYTE *pbSrc, *pbDest;

	if (iItem != (cItemsCur - 1))
		{
		pbDest = (BYTE *)pvData;
		pbDest += (cbSize * iItem);
		pbSrc = pbDest + cbSize;
		memmove(pbDest, pbSrc, (cbSize * (cItemsCur - iItem - 1)));
		}
	cItemsCur--;
}

WindowList::WindowList() : GrowableList(sizeof(WindowInfo))
{
}

WindowList::~WindowList()
{
}

BOOL WindowList::IsEqual(void *pv1, void *pv2)
{
	return(!memcmp(pv1, pv2, (2 * sizeof(DWORD))));
}

DbWin32App::DbWin32App()
{
}

DbWin32App::~DbWin32App()
{
}

BOOL DbWin32App::InitInstance()
{
	if (!CWinApp::InitInstance())
		return(FALSE);
	SetRegistryKey(szCompany);
	m_pszProfileName = szApplication;
	Enable3dControls();
	m_pMainWnd = new DbWin32Frame(&dbo);
	((DbWin32Frame *)m_pMainWnd)->LoadFrame(IDR_MAIN, WS_OVERLAPPEDWINDOW | WS_VISIBLE);
	if (m_lpCmdLine && *m_lpCmdLine)
		((DbWin32Frame *)m_pMainWnd)->ExecProcess(m_lpCmdLine);
	else
		((DbWin32Frame *)m_pMainWnd)->FileSystem();
	return(TRUE);
}

void DbWin32App::ReadOptions()
{
	int	wMaxWidth, wMaxHeight, iKey;

	wMaxWidth = GetSystemMetrics(SM_CXSCREEN);
	wMaxHeight = GetSystemMetrics(SM_CYSCREEN);
	dbo.rcWindow.left = GetProfileInt(szIniSection1, szKey1, wMaxWidth/5);
	dbo.rcWindow.top = GetProfileInt(szIniSection1, szKey2, wMaxHeight/5);
	dbo.rcWindow.right = GetProfileInt(szIniSection1, szKey3, wMaxWidth/2)-1;
	dbo.rcWindow.bottom = GetProfileInt(szIniSection1, szKey4, wMaxHeight/2)-1;
	if (dbo.rcWindow.right < 0)
		dbo.rcWindow.right = wMaxWidth/2;
	if (dbo.rcWindow.bottom < 0)
		dbo.rcWindow.bottom = wMaxHeight/2;
	if (dbo.rcWindow.left < 0 || dbo.rcWindow.left > wMaxWidth)
		dbo.rcWindow.left = wMaxWidth/5;
	dbo.rcWindow.right += dbo.rcWindow.left;
	if (dbo.rcWindow.right > wMaxWidth)
		dbo.rcWindow.right = wMaxWidth;
	if (dbo.rcWindow.top < 0 || dbo.rcWindow.top > wMaxHeight)
		dbo.rcWindow.top = wMaxHeight /5;
	dbo.rcWindow.bottom += dbo.rcWindow.top;
	if (dbo.rcWindow.bottom > wMaxHeight)
		dbo.rcWindow.bottom = wMaxHeight;
	dbo.nShowCmd = GetProfileInt(szIniSection1, szKey5, 0);
	if (dbo.nShowCmd < 0)
		dbo.nShowCmd = WS_MINIMIZE;
	else if (dbo.nShowCmd > 0)
		dbo.nShowCmd = WS_MAXIMIZE;
	dbo.fOnTop = GetProfileInt(szIniSection1, szKey6, FALSE);
	dbo.fChildMax = GetProfileInt(szIniSection1, szKey7, FALSE);
	dbo.nInactive = GetProfileInt(szIniSection2, szKey8, INACTIVE_MINIMIZE);
	dbo.fNewOnProcess = GetProfileInt(szIniSection2, szKey9, TRUE);
	dbo.fNewOnThread = GetProfileInt(szIniSection2, szKey10, FALSE);
	dbo.wFilter = (WORD)GetProfileInt(szIniSection2, szKey11, DBO_ALL);
	for (iKey = 0; iKey < MAX_HISTORY; iKey++)
		dbo.rgstCommandLine[iKey] = GetProfileString(szIniSection2,
				rgpszHistoryKeys[iKey]);
}

void DbWin32App::WriteOptions(WINDOWPLACEMENT *pwpl)
{
	int wState, iKey;

	if (pwpl)
		{
		if (pwpl->showCmd == SW_SHOWMAXIMIZED)
			wState = 1;
		else if (pwpl->showCmd == SW_SHOWMINIMIZED)
			wState = -1;
		else
			wState = 0;
		WriteProfileInt(szIniSection1, szKey1, (int) pwpl->rcNormalPosition.left);
		WriteProfileInt(szIniSection1, szKey2, (int) pwpl->rcNormalPosition.top);
		WriteProfileInt(szIniSection1, szKey3,
				pwpl->rcNormalPosition.right-pwpl->rcNormalPosition.left+1);
		WriteProfileInt(szIniSection1, szKey4,
				pwpl->rcNormalPosition.bottom-pwpl->rcNormalPosition.top+1);
		WriteProfileInt(szIniSection1, szKey5, wState);
		}
	WriteProfileInt(szIniSection1, szKey6, dbo.fOnTop);
	WriteProfileInt(szIniSection1, szKey7, dbo.fChildMax);
	WriteProfileInt(szIniSection2, szKey8, dbo.nInactive);
	WriteProfileInt(szIniSection2, szKey9, dbo.fNewOnProcess);
	WriteProfileInt(szIniSection2, szKey10, dbo.fNewOnThread);
	WriteProfileInt(szIniSection2, szKey11, dbo.wFilter);
	for (iKey = 0; iKey < MAX_HISTORY; iKey++)
		WriteProfileString(szIniSection2, rgpszHistoryKeys[iKey],
				dbo.rgstCommandLine[iKey]);
}

static NEAR DbWin32App theApp;

DbWin32Edit::DbWin32Edit()
{
}

DbWin32Edit::~DbWin32Edit()
{
}

BOOL DbWin32Edit::Create(CWnd *pwndParent)
{
	CRect rc;

	return(CEdit::Create(WS_CHILD | WS_VISIBLE | WS_BORDER | WS_VSCROLL |
			WS_HSCROLL | ES_AUTOHSCROLL | ES_AUTOVSCROLL | ES_MULTILINE,
			rc, pwndParent, 100));
}

BEGIN_MESSAGE_MAP(DbWin32Child, CMDIChildWnd)
	// Windows messages
	ON_WM_CREATE()
	ON_WM_SIZE()
	ON_WM_MDIACTIVATE()
	ON_WM_NCACTIVATE()
	// Command handlers
	ON_COMMAND(CMD_FILESAVEBUFFER, OnFileSaveBuffer)
	ON_COMMAND(CMD_EDITCOPY, OnEditCopy)
	ON_COMMAND(CMD_EDITCLEARBUFFER, OnEditClearBuffer)
	ON_COMMAND(CMD_EDITSELECTALL, OnEditSelectAll)
	// Idle update handlers
	// Notification messages
	ON_EN_MAXTEXT(100, OnMaxText)
END_MESSAGE_MAP()

DbWin32Child::DbWin32Child(WORD wFilterIn)
{
	wFilter = wFilterIn;
}

DbWin32Child::~DbWin32Child()
{
}

void DbWin32Child::AddText(WORD wEvent, LPCSTR lpszText, int cLines, BOOL fSetTitle)
{
	int cLinesNew;
	CString st;

	if (!m_hWnd)
		return;
	if (fSetTitle && !strncmp(lpszText, "Create Process", 14))
		{
		st = lpszText;
		SetWindowText(st.Mid(16, st.GetLength() - 18));
		}
	if (fSetTitle && !strncmp(lpszText, "Create Thread", 13))
		{
		st = lpszText;
		SetWindowText(st.Mid(15, st.GetLength() - 17));
		}
	if (wEvent & wFilter)
		{
		cLinesNew = wndEdit.GetLineCount() + cLines;
		if (cLinesNew > MAX_LINES)
			{
			wndEdit.SetSel(0, wndEdit.LineIndex(cLinesNew + 50 - MAX_LINES), TRUE);
			wndEdit.ReplaceSel("");
			}
		wndEdit.SetSel(0x7FFF7FFF);
		wndEdit.ReplaceSel(lpszText);
		wndEdit.SetSel(0x7FFF7FFF);
		}
}

int DbWin32Child::OnCreate(LPCREATESTRUCT lpcs)
{
	LOGFONT lf;

	if (CMDIChildWnd::OnCreate(lpcs) == -1)
		return(-1);
	m_hMenuShared = ::LoadMenu(AfxGetInstanceHandle(), MAKEINTRESOURCE(IDR_CHILD));
	wndEdit.Create(this);
	SystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(lf), &lf, FALSE);
	fontCur.CreateFontIndirect(&lf);
	wndEdit.SetFont(&fontCur);
	wndEdit.ShowWindow(SW_SHOWNORMAL);
	return(0);
}

void DbWin32Child::OnSize(UINT nType, int cx, int cy)
{
	CRect rc;

	((DbWin32Frame *)GetMDIFrame())->ChildMaximized(nType == SIZE_MAXIMIZED);
	GetClientRect(rc);
	rc.InflateRect(1, 1);
	wndEdit.MoveWindow(rc, TRUE);
	CMDIChildWnd::OnSize(nType, cx, cy);
}

void DbWin32Child::OnMDIActivate(BOOL fActivate, CWnd *pwndActivate, CWnd *pwndDeactivate)
{
	if (fActivate)
		wndEdit.SetFocus();
	CMDIChildWnd::OnMDIActivate(fActivate, pwndActivate, pwndDeactivate);
}

BOOL DbWin32Child::OnNcActivate(BOOL fActivate)
{
	if (fActivate)
		wndEdit.SetFocus();
	return(CMDIChildWnd::OnNcActivate(fActivate));
}

void DbWin32Child::OnFileSaveBuffer()
{
	CFile file;
	int cch;
	void *pv;
	CFileDialog dlgFile(FALSE, NULL, NULL, OFN_OVERWRITEPROMPT | OFN_HIDEREADONLY |
			OFN_PATHMUSTEXIST, "All|*.*||", GetMDIFrame());

	if (dlgFile.DoModal() == IDOK)
		if (file.Open(dlgFile.GetPathName(), CFile::modeCreate | CFile::modeWrite))
			{
			cch = wndEdit.GetWindowTextLength();
			if (cch)
				{
				pv = GlobalAlloc(GMEM_FIXED, cch + 1);
				if (pv)
					{
					cch = wndEdit.GetWindowText((LPTSTR)pv, cch + 1);
					file.Write(pv, cch);
					file.Close();
					GlobalFree(pv);
					}
				}
			}
}

void DbWin32Child::OnEditCopy()
{
	wndEdit.Copy();
}

void DbWin32Child::OnEditClearBuffer()
{
	OnEditSelectAll();
	wndEdit.ReplaceSel("");
}

void DbWin32Child::OnEditSelectAll()
{
	wndEdit.SetSel(0, -1, FALSE);
}

void DbWin32Child::OnMaxText()
{
	MessageBox("Help! I'm out of space!", "DbWin32", MB_ICONEXCLAMATION | MB_OK);
}

BEGIN_MESSAGE_MAP(DbWin32Frame, CMDIFrameWnd)
	// Windows messages
	ON_WM_DESTROY()
	ON_MESSAGE(WM_SENDTEXT, OnSendText)
	ON_MESSAGE(WM_ENDTHREAD, OnEndThread)
	// Command handlers
	ON_COMMAND(CMD_FILERUN, OnFileRun)
	ON_COMMAND(CMD_FILEATTACH, OnFileAttach)
	ON_COMMAND(CMD_FILESYSTEM, OnFileSystem)
	ON_COMMAND(CMD_FILEEXIT, OnFileExit)
	ON_COMMAND(CMD_OPTIONS, OnOptions)
	ON_COMMAND(CMD_ABOUT, OnAbout)
	// Idle update handlers
	ON_UPDATE_COMMAND_UI(CMD_FILESYSTEM, OnUpdateFileSystem)
END_MESSAGE_MAP()

DbWin32Frame::DbWin32Frame(DbWin32Options *pdboIn)
{
	OSVERSIONINFO osvi;

	pwndSystem = NULL;
	pdbo = pdboIn;
	fInCreate = FALSE;
	fNT351 = FALSE;
	osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	if (GetVersionEx(&osvi))
		{
		if ((osvi.dwPlatformId == VER_PLATFORM_WIN32_NT) && ((osvi.dwMajorVersion > 3) || (osvi.dwMinorVersion > 5)))
			fNT351 = TRUE;
		}
}

DbWin32Frame::~DbWin32Frame()
{
}

void DbWin32Frame::ExecProcess(LPCSTR lpszCommandLine)
{
	int iKey;
	ExecInfo *pei;

	for (iKey = 0; iKey < MAX_HISTORY; iKey++)
		if (pdbo->rgstCommandLine[iKey] == lpszCommandLine)
			break;
	if (iKey == MAX_HISTORY)
		{
		for (iKey = MAX_HISTORY - 1; iKey > 0; iKey--)
			pdbo->rgstCommandLine[iKey] = pdbo->rgstCommandLine[iKey-1];
		pdbo->rgstCommandLine[0] = lpszCommandLine;
		}
	pei = new ExecInfo;
	pei->lpszCommandLine = _strdup(lpszCommandLine);
	pei->hwndFrame = GetSafeHwnd();
	_beginthread(ExecThread, 0, pei);
}

void DbWin32Frame::ChildMaximized(BOOL fMax)
{
	if (!fInCreate)
		pdbo->fChildMax = fMax;
}

void DbWin32Frame::FileSystem()
{
	if (fNT351)
		OnFileSystem();
}

BOOL DbWin32Frame::PreCreateWindow(CREATESTRUCT &cs)
{
	((DbWin32App *)AfxGetApp())->ReadOptions();
	cs.cy = (int)(pdbo->rcWindow.bottom - pdbo->rcWindow.top);
	cs.cx = (int)(pdbo->rcWindow.right - pdbo->rcWindow.left);
	cs.y = (int)pdbo->rcWindow.top;
	cs.x = (int)pdbo->rcWindow.left;
	cs.style |= pdbo->nShowCmd;
	if (pdbo->fOnTop)
		cs.dwExStyle |= WS_EX_TOPMOST;
	return(CMDIFrameWnd::PreCreateWindow(cs));
}

void DbWin32Frame::OnDestroy()
{
	WINDOWPLACEMENT wpl;

	wpl.length = sizeof(WINDOWPLACEMENT);
	wpl.rcNormalPosition.top = wpl.rcNormalPosition.left = 0;
	if (GetWindowPlacement(&wpl))
		((DbWin32App *)AfxGetApp())->WriteOptions(&wpl);
	else
		((DbWin32App *)AfxGetApp())->WriteOptions(NULL);
}

LRESULT DbWin32Frame::OnSendText(WPARAM wParam, LPARAM lParam)
{
	StringInfo *psi = (StringInfo *)lParam;
	WindowInfo wi;
	BOOL fCreated = FALSE;

	wi.dwProcess = psi->dwProcess;
	wi.dwThread = psi->dwThread;
	if (!wi.dwProcess && !wi.dwThread)
		wi.pwndChild = pwndSystem;
	else
		{
		wi.pwndChild = NULL;
		if (!wl.FindItem(&wi))
			if (pdbo->fNewOnThread)
				fCreated = TRUE;
			else
				{
				wi.dwThread = 0;
				if (!wl.FindItem(&wi))
					if (pdbo->fNewOnProcess)
						fCreated = TRUE;
					else
						{
						wi.dwProcess = psi->dwParentProcess;
						if (!wl.FindItem(&wi))
							fCreated = TRUE;
						}
				}
		if (fCreated)
			{
			wi.pwndChild = new DbWin32Child(pdbo->wFilter);
			fInCreate = TRUE;
			wi.pwndChild->LoadFrame(IDR_CHILD,
					WS_OVERLAPPEDWINDOW | WS_VISIBLE, this);
			fInCreate = FALSE;
			if (pdbo->fChildMax)
				MDIMaximize(wi.pwndChild);
			wl.InsertItem(&wi);
			}
		}
	ASSERT(wi.pwndChild);
	wi.pwndChild->AddText((WORD)wParam, psi->lpszText, psi->cLines, fCreated);
	free((void *)(psi->lpszText));
	delete psi;
	return(0);
}

LRESULT DbWin32Frame::OnEndThread(WPARAM wParam, LPARAM lParam)
{
	CString st;
	WindowInfo wi;
	int iItem;

	wi.dwProcess = (DWORD)lParam;
	wi.dwThread = (DWORD)wParam;
	if (wl.FindItem(&wi, &iItem))
		{
		wi.pwndChild->GetWindowText(st);
		st += " [Inactive]";
		wi.pwndChild->SetWindowText(st);
		switch (pdbo->nInactive)
			{
		case INACTIVE_CLOSE:
			wi.pwndChild->MDIDestroy();
			break;
		case INACTIVE_NONE:
			break;
		default:
			wi.pwndChild->ShowWindow(SW_MINIMIZE);
			break;
			}
		wl.RemoveItem(iItem);
		}
	return(0L);
}

void DbWin32Frame::OnFileRun()
{
	DbWin32RunDlg dlgRun(pdbo->rgstCommandLine);

	if (dlgRun.DoModal() == IDOK)
		ExecProcess(dlgRun.GetCommandLine());
}

void DbWin32Frame::OnFileAttach()
{
	AttachInfo *pai;
	DbWin32AttachDlg dlgAttach(&wl);

	if (dlgAttach.DoModal() == IDOK)
		{
		pai = new AttachInfo;
		pai->dwProcess = dlgAttach.GetSelectedProcess();
		pai->hwndFrame = GetSafeHwnd();
		_beginthread(AttachThread, 0, pai);
		}
}

void DbWin32Frame::OnFileSystem()
{
	if (!fNT351)
		{
		MessageBeep(MB_ICONEXCLAMATION);
		MessageBox("Not available on this platform.", "DbWin32",
				MB_ICONEXCLAMATION | MB_OK);
		return;
		}
	if (pwndSystem)
		{
		MDIActivate(pwndSystem);
		return;
		}
	pwndSystem = new DbWin32Child(DBO_OUTPUTDEBUGSTRING);
	fInCreate = TRUE;
	pwndSystem->LoadFrame(IDR_CHILD, WS_OVERLAPPEDWINDOW | WS_VISIBLE, this);
	fInCreate = FALSE;
	pwndSystem->SetWindowText("System Window");
	if (pdbo->fChildMax)
		MDIMaximize(pwndSystem);
	_beginthread(SystemThread, 0, GetSafeHwnd());
}

void DbWin32Frame::OnFileExit()
{
	OnClose();
}

void DbWin32Frame::OnOptions()
{
	DbWin32OptionsDlg dlgOptions(pdbo);

	dlgOptions.DoModal();
}

void DbWin32Frame::OnAbout()
{
	CDialog dlgAbout(IDR_ABOUTDLG);

	dlgAbout.DoModal();
}

void DbWin32Frame::OnUpdateFileSystem(CCmdUI *pCmdUI)
{
	pCmdUI->Enable(!pwndSystem && fNT351);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\dbwin32\dbdbg32.cpp ===
#include <windows.h>
#include <malloc.h>
#include <stddef.h>
#include <process.h>
#define _DBDBG32_
#include "dbwin32.h"

ProcessList::ProcessList() : GrowableList(sizeof(ProcessInfo))
{
}

ProcessList::~ProcessList()
{
}

BOOL ProcessList::IsEqual(void *pv1, void *pv2)
{
	return(!memcmp(pv1, pv2, sizeof(DWORD)));
}

ThreadList::ThreadList() : GrowableList(sizeof(ThreadInfo))
{
}

ThreadList::~ThreadList()
{
}

BOOL ThreadList::IsEqual(void *pv1, void *pv2)
{
	return(!memcmp(pv1, pv2, sizeof(ThreadInfo)));
}

DllList::DllList() : GrowableList(sizeof(DllInfo))
{
}

DllList::~DllList()
{
}

BOOL DllList::IsEqual(void *pv1, void *pv2)
{
	return(!memcmp(pv1, pv2, (sizeof(DWORD) + sizeof(LPVOID))));
}

void __cdecl AttachThread(void *pv)
{
	AttachInfo *pai = (AttachInfo *)pv;

	if (DebugActiveProcess(pai->dwProcess))
		DebugThread(pai->hwndFrame, pai->dwProcess);
	else
		{
		MessageBeep(MB_ICONEXCLAMATION);
		MessageBox(pai->hwndFrame, "Unable to attach to process.", "DbWin32",
				MB_ICONEXCLAMATION | MB_OK);
		}
	delete pai;
}

void __cdecl ExecThread(void *pv)
{
	ExecInfo *pei = (ExecInfo *)pv;
	STARTUPINFO si;
	PROCESS_INFORMATION pi;

	memset(&si, 0, sizeof(STARTUPINFO));
	si.cb = sizeof(STARTUPINFO);
	si.wShowWindow = SW_SHOWDEFAULT;
	pi.hProcess = NULL;
	if (CreateProcess(NULL, pei->lpszCommandLine, NULL, NULL, TRUE,
			DEBUG_PROCESS | CREATE_NEW_CONSOLE,	NULL, NULL, &si, &pi))
		{
		CloseHandle(pi.hProcess);
		CloseHandle(pi.hThread);
		DebugThread(pei->hwndFrame, pi.dwProcessId);
		}
	else
		{
		MessageBeep(MB_ICONEXCLAMATION);
		MessageBox(pei->hwndFrame, "Unable to execute process.", "DbWin32",
				MB_ICONEXCLAMATION | MB_OK);
		}
	free((void *)(pei->lpszCommandLine));
	delete pei;
}

void __cdecl SystemThread(void *pv)
{
	BOOL fFailed = TRUE;
	DWORD dwRet;
	HANDLE hevtBuffer = NULL, hevtData = NULL;
	HANDLE hfileShared = NULL;
	HWND hwndFrame = (HWND)pv;
	LPVOID lpvBuffer = NULL;
	LPSTR lpszText = NULL;
	DEBUG_EVENT DebugEvent;

	hevtBuffer = CreateEvent(NULL, FALSE, FALSE, "DBWIN_BUFFER_READY");
	if (hevtBuffer)
		hevtData = CreateEvent(NULL, FALSE, FALSE, "DBWIN_DATA_READY");
	if (hevtBuffer && hevtData)
		hfileShared = CreateFileMapping((HANDLE)-1, NULL, PAGE_READWRITE, 0,
				4096, "DBWIN_BUFFER");
	if (hevtBuffer && hevtData && hfileShared)
		lpvBuffer = MapViewOfFile(hfileShared, FILE_MAP_READ, 0, 0, 512);
	if (hevtBuffer && hevtData && hfileShared && lpvBuffer)
		{
		fFailed = FALSE;
		lpszText = (LPSTR)lpvBuffer + sizeof(DWORD);
		DebugEvent.dwDebugEventCode = OUTPUT_DEBUG_STRING_EVENT;
		DebugEvent.dwProcessId = DebugEvent.dwThreadId = 0;
		SetEvent(hevtBuffer);
		}
	else
		{
		MessageBeep(MB_ICONEXCLAMATION);
		MessageBox(hwndFrame, "Unable to open System Window.", "DbWin32",
				MB_ICONEXCLAMATION | MB_OK);
		}
	while (!fFailed)
		{
		dwRet = WaitForSingleObject(hevtData, INFINITE);
		if (dwRet != WAIT_OBJECT_0)
			{
			SendText(hwndFrame, &DebugEvent, 0,
					"--------        DbWin32 ERROR!       --------\r\n",
					DBO_OUTPUTDEBUGSTRING);
			SendText(hwndFrame, &DebugEvent, 0,
					"-------- Shutting down System Window --------\r\n",
					DBO_OUTPUTDEBUGSTRING);
			fFailed = TRUE;
			}
		else
			{
			SendText(hwndFrame, &DebugEvent, 0, lpszText,
					DBO_OUTPUTDEBUGSTRING);
			SetEvent(hevtBuffer);
			}
		}
	if (hfileShared)
		CloseHandle(hfileShared);
	if (hevtData)
		CloseHandle(hevtData);
	if (hevtBuffer)
		CloseHandle(hevtBuffer);
}

void __cdecl DebugThread(HWND hwndFrame, DWORD dwProcess)
{
	char DisplayBuffer[BUF_SIZE];
	WORD wEvent;
	DWORD dwContinue;
    SIZE_T dwRead;
	ProcessList pl;
	ProcessInfo pi;
	ThreadList tl;
	ThreadInfo ti;
	DllList dl;
	DllInfo di;
	int iItem;
	BOOL fDone = FALSE;
	DEBUG_EVENT DebugEvent;
	EXCEPTION_DEBUG_INFO *pException = &DebugEvent.u.Exception;
	CREATE_THREAD_DEBUG_INFO *pCreateThread = &DebugEvent.u.CreateThread;
	CREATE_PROCESS_DEBUG_INFO *pCreateProcessInfo = &DebugEvent.u.CreateProcessInfo;
	EXIT_THREAD_DEBUG_INFO *pExitThread = &DebugEvent.u.ExitThread;
	EXIT_PROCESS_DEBUG_INFO *pExitProcess = &DebugEvent.u.ExitProcess;
	LOAD_DLL_DEBUG_INFO *pLoadDll = &DebugEvent.u.LoadDll;
	UNLOAD_DLL_DEBUG_INFO *pUnloadDll = &DebugEvent.u.UnloadDll;
	OUTPUT_DEBUG_STRING_INFO *pDebugString = &DebugEvent.u.DebugString;
	RIP_INFO *pRipInfo = &DebugEvent.u.RipInfo;

	while (!fDone && WaitForDebugEvent(&DebugEvent, INFINITE))
		{
		*DisplayBuffer = '\0';
		dwContinue = DBG_CONTINUE;
		switch (DebugEvent.dwDebugEventCode)
			{
		case EXCEPTION_DEBUG_EVENT:
			ProcessExceptionEvent(pException, DisplayBuffer);
			if (pException->ExceptionRecord.ExceptionCode != EXCEPTION_BREAKPOINT)
				dwContinue = DBG_EXCEPTION_NOT_HANDLED;
			wEvent = DBO_EXCEPTIONS;
			break;
		case CREATE_THREAD_DEBUG_EVENT:
			ti.dwProcess = DebugEvent.dwProcessId;
			ti.dwThread = DebugEvent.dwThreadId;
			tl.InsertItem(&ti);
			wsprintf(DisplayBuffer, "Create Thread: PID 0x%X - TID 0x%X\r\n",
					ti.dwProcess, ti.dwThread);
			wEvent = DBO_THREADCREATE;
			break;
		case CREATE_PROCESS_DEBUG_EVENT:
			ti.dwProcess = pi.dwProcess = DebugEvent.dwProcessId;
			ti.dwThread = DebugEvent.dwThreadId;
			tl.InsertItem(&ti);
			pi.hProcess = pCreateProcessInfo->hProcess;
			GetModuleName(pCreateProcessInfo->hFile, pi.hProcess,
					(DWORD_PTR)pCreateProcessInfo->lpBaseOfImage, pi.rgchModule);
			pl.InsertItem(&pi);
			wsprintf(DisplayBuffer, "Create Process: PID 0x%X - %s\r\n",
					pi.dwProcess, pi.rgchModule);
			wEvent = DBO_PROCESSCREATE;
			break;
		case EXIT_THREAD_DEBUG_EVENT:
			ti.dwProcess = DebugEvent.dwProcessId;
			ti.dwThread = DebugEvent.dwThreadId;
			tl.RemoveItem(&ti);
			wsprintf(DisplayBuffer, "Exit Thread: PID 0x%X - TID 0x%X - dwReturnCode %d\r\n",
					ti.dwProcess, ti.dwThread, pExitThread->dwExitCode);
			wEvent = DBO_THREADEXIT;
			break;
		case EXIT_PROCESS_DEBUG_EVENT:
			pi.dwProcess = DebugEvent.dwProcessId;
                        if (pl.FindItem(&pi, &iItem))
                        {
                            pl.RemoveItem(iItem);
                        }
			wsprintf(DisplayBuffer, "Exit Process: PID 0x%X - %s - dwReturnCode %d\r\n",
					pi.dwProcess, pi.rgchModule, pExitProcess->dwExitCode);
			if (pi.dwProcess == dwProcess)
				fDone = TRUE;
			wEvent = DBO_PROCESSEXIT;
			break;
		case LOAD_DLL_DEBUG_EVENT:
			di.dwProcess = pi.dwProcess = DebugEvent.dwProcessId;
			pl.FindItem(&pi);
			di.lpBaseOfDll = pLoadDll->lpBaseOfDll;
			GetModuleName(pLoadDll->hFile, pi.hProcess, (DWORD_PTR)di.lpBaseOfDll,
					di.rgchModule);
			dl.InsertItem(&di);
			wsprintf(DisplayBuffer, "DLL Load: %s\r\n", di.rgchModule);
			wEvent = DBO_DLLLOAD;
			break;
		case UNLOAD_DLL_DEBUG_EVENT:
			di.dwProcess = DebugEvent.dwProcessId;
			di.lpBaseOfDll = pUnloadDll->lpBaseOfDll;
                        if (dl.FindItem(&di, &iItem))
                        {
                            dl.RemoveItem(iItem);
                        }
			wsprintf(DisplayBuffer, "Dll Unload: %s\r\n", di.rgchModule);
			wEvent = DBO_DLLUNLOAD;
			break;
		case OUTPUT_DEBUG_STRING_EVENT:
			pi.dwProcess = DebugEvent.dwProcessId;
			pl.FindItem(&pi);
			if (!ReadProcessMemory(pi.hProcess,
					pDebugString->lpDebugStringData, DisplayBuffer,
					pDebugString->nDebugStringLength, &dwRead))
				dwRead = 0;
			DisplayBuffer[dwRead] = '\0';
			wEvent = DBO_OUTPUTDEBUGSTRING;
			break;
		case RIP_EVENT:
			wsprintf(DisplayBuffer, "RIP: dwError %d - dwType %d\r\n",
					pRipInfo->dwError, pRipInfo->dwType);
			wEvent = DBO_RIP;
			break;
		// No events should reach here.
		default:
			wsprintf(DisplayBuffer, "Unknown Event: 0x%X\r\n",
					DebugEvent.dwDebugEventCode);
			wEvent = DBO_ALL;
			break;
			}
		if (*DisplayBuffer)
			SendText(hwndFrame, &DebugEvent, dwProcess, DisplayBuffer, wEvent);
		if (DebugEvent.dwDebugEventCode == EXIT_THREAD_DEBUG_EVENT)
			PostMessage(hwndFrame, WM_ENDTHREAD, (WPARAM)ti.dwThread,
					ti.dwProcess);
		if (DebugEvent.dwDebugEventCode == EXIT_PROCESS_DEBUG_EVENT)
			{
			if (fDone)
				{
				for (iItem = tl.Count(); iItem > 0; iItem--)
					{
					tl.GetItem(iItem - 1, &ti);
					PostMessage(hwndFrame, WM_ENDTHREAD, (WPARAM)ti.dwThread, ti.dwProcess);
					}
				for (iItem = pl.Count(); iItem > 0; iItem--)
					{
					pl.GetItem(iItem - 1, &pi);
					PostMessage(hwndFrame, WM_ENDTHREAD, 0, pi.dwProcess);
					}
				}
			PostMessage(hwndFrame, WM_ENDTHREAD, 0, DebugEvent.dwProcessId);
			}
		ContinueDebugEvent(DebugEvent.dwProcessId, DebugEvent.dwThreadId, dwContinue);
	    }
}

void SendText(HWND hwndFrame, DEBUG_EVENT *pDebugEvent, DWORD dwParentProcess,
		LPCSTR lpszText, WORD wEvent)
{
    char rgchText[BUF_SIZE], *pch = rgchText;
    StringInfo *psi;

    psi = new StringInfo;
    // Niceify the text
    if (pDebugEvent->dwDebugEventCode == OUTPUT_DEBUG_STRING_EVENT)
    {
        psi->cLines = 0;
        while (*lpszText != '\0')
        {
            if ((*lpszText == 0x0d) || (*lpszText == 0x0a))
            {
                *pch++ = 0x0d;
                *pch++ = 0x0a;
                while ((*lpszText == 0x0d) || (*lpszText == 0x0a))
                        lpszText++;
                psi->cLines++;
            }
            else
            {
                *pch++ = *lpszText++;
            }
        }
        *pch = '\0';
        psi->lpszText = _strdup(rgchText);
    }
    else
    {
        psi->cLines = 1;
        psi->lpszText = _strdup(lpszText);
    }
    psi->dwProcess = pDebugEvent->dwProcessId;
    psi->dwThread = pDebugEvent->dwThreadId;
    psi->dwParentProcess = dwParentProcess;
    PostMessage(hwndFrame, WM_SENDTEXT, wEvent, (LPARAM)psi);
}

void ProcessExceptionEvent(EXCEPTION_DEBUG_INFO *pException, LPSTR lpszBuf)
{
	if (pException->dwFirstChance)
		strcpy(lpszBuf, "First");
	else
		strcpy(lpszBuf, "Second");
	strcat(lpszBuf, " chance exception: ");
	switch (pException->ExceptionRecord.ExceptionCode)
		{
	//--standard exceptions
	case EXCEPTION_ACCESS_VIOLATION:
		strcat(lpszBuf, "Access Violation");
		break;
	case EXCEPTION_DATATYPE_MISALIGNMENT:
		strcat(lpszBuf, "Datatype Misalignment");
		break;
	case EXCEPTION_BREAKPOINT:
		strcat(lpszBuf, "Breakpoint");
		break;
	case EXCEPTION_SINGLE_STEP:
		strcat(lpszBuf, "Single Step");
		break;
	case EXCEPTION_ARRAY_BOUNDS_EXCEEDED:
		strcat(lpszBuf, "Array Bound Exceeded");
		break;
	case EXCEPTION_FLT_DENORMAL_OPERAND:
		strcat(lpszBuf, "FP-Denormal Operand");
		break;
	case EXCEPTION_FLT_DIVIDE_BY_ZERO:
		strcat(lpszBuf, "FP-Divide By Zero");
		break;
	case EXCEPTION_FLT_INEXACT_RESULT:
		strcat(lpszBuf, "FP-Inexact Result");
		break;
	case EXCEPTION_FLT_INVALID_OPERATION:
		strcat(lpszBuf, "FP-Invalid Operation");
		break;
	case EXCEPTION_FLT_OVERFLOW:
		strcat(lpszBuf, "FP-Overflow");
		break;
	case EXCEPTION_FLT_STACK_CHECK:
		strcat(lpszBuf, "FP-Stack Check");
		break;
	case EXCEPTION_FLT_UNDERFLOW:
		strcat(lpszBuf, "FP-Underflow");
		break;
	case EXCEPTION_INT_DIVIDE_BY_ZERO:
		strcat(lpszBuf, "INT-Divide By Zero");
		break;
	case EXCEPTION_INT_OVERFLOW:
		strcat(lpszBuf, "INT-Overflow");
		break;
	case EXCEPTION_PRIV_INSTRUCTION:
		strcat(lpszBuf, "Privileged Instruction");
		break;
	case EXCEPTION_IN_PAGE_ERROR:
		strcat(lpszBuf, "In Page Error");
		break;
	//-- Debug exceptions
	case DBG_TERMINATE_THREAD:
		strcat(lpszBuf, "DBG-Terminate Thread");
		break;
	case DBG_TERMINATE_PROCESS:
		strcat(lpszBuf, "DBG-Terminate Process");
		break;
	case DBG_CONTROL_C:
		strcat(lpszBuf, "DBG-Control+C");
		break;
	case DBG_CONTROL_BREAK:
		strcat(lpszBuf, "DBG-Control+Break");
		break;
	//-- RPC exceptions (some)
	case RPC_S_UNKNOWN_IF:
		strcat(lpszBuf, "RPC-Unknown Interface");
		break;
	case RPC_S_SERVER_UNAVAILABLE:
		strcat(lpszBuf, "RPC-Server Unavailable");
		break;
	//-- VDM exceptions (minimal information)
	case EXCEPTION_VDM_EVENT:  // see dbwin32.h for definition
		strcat(lpszBuf, "VDM");
		break;
	default:
		char rgchTmp[25];
		wsprintf(rgchTmp, "Unknown-[0x%X]", pException->ExceptionRecord.ExceptionCode);
		strcat(lpszBuf, rgchTmp);
		break;
		}
	strcat(lpszBuf, "\r\n");
}

#define IMAGE_SECOND_HEADER_OFFSET (15 * sizeof(ULONG))
#define IMAGE_EXPORT_TABLE_RVA_OFFSET (30 * sizeof(DWORD))
#define IMAGE_NAME_RVA_OFFSET offsetof(IMAGE_EXPORT_DIRECTORY, Name)

void GetModuleName(HANDLE hFile, HANDLE hProcess, DWORD_PTR BaseOfImage, LPSTR lpszBuf)
{
    DWORD dwRead = 0;
    WORD DosSignature;
    DWORD NtSignature, PeHeader, ExportTableRVA, NameRVA;

    strcpy(lpszBuf, "<unknown>");
    if (!hFile)
        return;
    if (GetFileType(hFile) != FILE_TYPE_DISK)
        return;
    SetFilePointer(hFile, 0L, NULL, FILE_BEGIN);
    if (!ReadFile(hFile, &DosSignature, sizeof(DosSignature), &dwRead, NULL))
        return;
    if (DosSignature != IMAGE_DOS_SIGNATURE)
        return;
    SetFilePointer(hFile, IMAGE_SECOND_HEADER_OFFSET, NULL, FILE_BEGIN);
    if (!ReadFile(hFile, &PeHeader, sizeof(PeHeader), &dwRead, NULL))
        return;
    SetFilePointer(hFile, PeHeader, NULL, FILE_BEGIN);
    if (!ReadFile(hFile, &NtSignature, sizeof(NtSignature), &dwRead, NULL))
        return;
    if (NtSignature != IMAGE_NT_SIGNATURE)
            return;
    SetFilePointer(hFile, PeHeader + IMAGE_EXPORT_TABLE_RVA_OFFSET, NULL, FILE_BEGIN);
    if (!ReadFile(hFile, &ExportTableRVA, sizeof(ExportTableRVA), &dwRead, NULL))
        return;
    if (!ExportTableRVA)
        return;
    ReadProcessMemory(hProcess, (LPVOID)(BaseOfImage + ExportTableRVA +
                    IMAGE_NAME_RVA_OFFSET), &NameRVA, sizeof(NameRVA), NULL);
    ReadProcessMemory(hProcess, (LPVOID)(BaseOfImage + NameRVA), lpszBuf, MODULE_SIZE, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\dbwin32\dbdlg32.cpp ===
#pragma warning(disable:4135)
#include <afxwin.h>
#pragma warning(default:4135)
#include <afxdlgs.h>
#include "resource.h"
#define _DBWIN32_
#include "dbwin32.h"

BEGIN_MESSAGE_MAP(DbWin32RunDlg, CDialog)
	// Windows messages
	ON_CBN_EDITCHANGE(IDC_COMMANDLINE, OnEditChange)
	ON_CBN_SELCHANGE(IDC_COMMANDLINE, OnSelChange)
	ON_BN_CLICKED(IDC_BROWSE, OnBrowse)
	// Command handlers
	// Idle update handlers
END_MESSAGE_MAP()

DbWin32RunDlg::DbWin32RunDlg(CString *pstIn) : CDialog(IDR_RUNDLG)
{
	pst = pstIn;
}

DbWin32RunDlg::~DbWin32RunDlg()
{
}

BOOL DbWin32RunDlg::OnInitDialog()
{
	int iSt;
	CComboBox *pcb = (CComboBox *)GetDlgItem(IDC_COMMANDLINE);

	for (iSt = 0; iSt < MAX_HISTORY; iSt++)
		if (!pst[iSt].IsEmpty())
			pcb->AddString(pst[iSt]);
	if (pcb->GetCount())
		{
		pcb->SetCurSel(0);
		OnSelChange();
		}
	return(CDialog::OnInitDialog());
}

void DbWin32RunDlg::OnEditChange()
{
	CComboBox *pcb = (CComboBox *)GetDlgItem(IDC_COMMANDLINE);
	CButton *pbutton = (CButton *)GetDlgItem(IDOK);

	pcb->GetWindowText(stCommandLine);
	pbutton->EnableWindow(!stCommandLine.IsEmpty());
}

void DbWin32RunDlg::OnSelChange()
{
	CComboBox *pcb = (CComboBox *)GetDlgItem(IDC_COMMANDLINE);
	CButton *pbutton = (CButton *)GetDlgItem(IDOK);

	pcb->GetLBText(pcb->GetCurSel(), stCommandLine);
	pbutton->EnableWindow(!stCommandLine.IsEmpty());
}

void DbWin32RunDlg::OnBrowse()
{
	CComboBox *pcb = (CComboBox *)GetDlgItem(IDC_COMMANDLINE);
	CFileDialog fdlg(TRUE, NULL, NULL, OFN_FILEMUSTEXIST | OFN_HIDEREADONLY |
			OFN_NOCHANGEDIR | OFN_PATHMUSTEXIST, "Executable Files|*.exe||",
			this);

	if (fdlg.DoModal() == IDOK)
		{
		pcb->SetWindowText(fdlg.GetPathName());
		OnEditChange();
		}
}

struct EnumInfo
{
	CListBox *plb;
	WindowList *pwl;
	DWORD dwProcessCur;
};

BOOL CALLBACK EnumProc(HWND hWnd, LPARAM lParam)
{
	int iItem;
	DWORD dwProcess;
	char szTitle[256];
	WindowInfo wi;
	EnumInfo *pei = (EnumInfo *)lParam;

	if (hWnd)
		{
		GetWindowText(hWnd, szTitle, sizeof(szTitle));
		if (*szTitle)
			{
			GetWindowThreadProcessId(hWnd, &dwProcess);
			if (dwProcess != pei->dwProcessCur)
				{
				wi.dwProcess = 0;
				for (iItem = 0; (iItem < pei->pwl->Count()) &&
						(wi.dwProcess != dwProcess); iItem++)
					pei->pwl->GetItem(iItem, &wi);
				if (iItem == pei->pwl->Count())
					{
					iItem = pei->plb->AddString(szTitle);
					pei->plb->SetItemData(iItem, dwProcess);
					}
				}
			}
		}
	return(TRUE);
}

BEGIN_MESSAGE_MAP(DbWin32AttachDlg, CDialog)
	// Windows messages
	ON_LBN_DBLCLK(IDC_PROCESS, OnDoubleClick)
	// Command handlers
	// Idle update handlers
END_MESSAGE_MAP()

DbWin32AttachDlg::DbWin32AttachDlg(WindowList *pwlIn) : CDialog(IDR_ATTACHDLG)
{
	pwl = pwlIn;
}

DbWin32AttachDlg::~DbWin32AttachDlg()
{
}

BOOL DbWin32AttachDlg::OnInitDialog()
{
	EnumInfo ei;
	CListBox *plb = (CListBox *)GetDlgItem(IDC_PROCESS);

	CDialog::OnInitDialog();
	plb->ResetContent();
	ei.plb = plb;
	ei.pwl = pwl;
	ei.dwProcessCur = GetCurrentProcessId();
	EnumWindows(EnumProc, (LPARAM)&ei);
	plb->SetCurSel(0);
	return(TRUE);
}

void DbWin32AttachDlg::OnOK()
{
	CListBox *plb = (CListBox *)GetDlgItem(IDC_PROCESS);

	dwProcess = (DWORD)plb->GetItemData(plb->GetCurSel());
	CDialog::OnOK();
}

void DbWin32AttachDlg::OnDoubleClick()
{
	OnOK();
}

BEGIN_MESSAGE_MAP(DbWin32OptionsDlg, CDialog)
	// Windows messages
	// Command handlers
	ON_CONTROL(BN_CLICKED, IDC_NEWPROCESS, OnClicked)
	// Idle update handlers
END_MESSAGE_MAP()

DbWin32OptionsDlg::DbWin32OptionsDlg(DbWin32Options *pdboIn) : CDialog(IDR_OPTIONSDLG)
{
	pdbo = pdboIn;
}

DbWin32OptionsDlg::~DbWin32OptionsDlg()
{
}

BOOL DbWin32OptionsDlg::OnInitDialog()
{
	CDialog::OnInitDialog();
	((CButton *)GetDlgItem(IDC_NEWPROCESS))->SetCheck(pdbo->fNewOnProcess ? 1 : 0);
	((CButton *)GetDlgItem(IDC_NEWTHREAD))->SetCheck(pdbo->fNewOnThread ? 1 : 0);
	GetDlgItem(IDC_NEWTHREAD)->EnableWindow(pdbo->fNewOnProcess);
	((CButton *)GetDlgItem(IDC_ONTOP))->SetCheck(pdbo->fOnTop ? 1 : 0);
	((CButton *)GetDlgItem(IDC_MINIMIZE))->SetCheck((pdbo->nInactive == INACTIVE_MINIMIZE) ? 1 : 0);
	((CButton *)GetDlgItem(IDC_NONE))->SetCheck((pdbo->nInactive == INACTIVE_NONE) ? 1 : 0);
	((CButton *)GetDlgItem(IDC_CLOSE))->SetCheck((pdbo->nInactive == INACTIVE_CLOSE) ? 1 : 0);
	((CButton *)GetDlgItem(IDC_FILTER_OUTPUT))->SetCheck((pdbo->wFilter & DBO_OUTPUTDEBUGSTRING) ? 1 : 0);
	((CButton *)GetDlgItem(IDC_FILTER_EXCEPTIONS))->SetCheck((pdbo->wFilter & DBO_EXCEPTIONS) ? 1 : 0);
	((CButton *)GetDlgItem(IDC_FILTER_PROCESSCREATE))->SetCheck((pdbo->wFilter & DBO_PROCESSCREATE) ? 1 : 0);
	((CButton *)GetDlgItem(IDC_FILTER_PROCESSEXIT))->SetCheck((pdbo->wFilter & DBO_PROCESSEXIT) ? 1 : 0);
	((CButton *)GetDlgItem(IDC_FILTER_THREADCREATE))->SetCheck((pdbo->wFilter & DBO_THREADCREATE) ? 1 : 0);
	((CButton *)GetDlgItem(IDC_FILTER_THREADEXIT))->SetCheck((pdbo->wFilter & DBO_THREADEXIT) ? 1 : 0);
	((CButton *)GetDlgItem(IDC_FILTER_DLLLOAD))->SetCheck((pdbo->wFilter & DBO_DLLLOAD) ? 1 : 0);
	((CButton *)GetDlgItem(IDC_FILTER_DLLUNLOAD))->SetCheck((pdbo->wFilter & DBO_DLLUNLOAD) ? 1 : 0);
	((CButton *)GetDlgItem(IDC_FILTER_RIP))->SetCheck((pdbo->wFilter & DBO_RIP) ? 1 : 0);
	return(TRUE);
}

void DbWin32OptionsDlg::OnOK()
{
	pdbo->fNewOnProcess = ((CButton *)GetDlgItem(IDC_NEWPROCESS))->GetCheck();
	pdbo->fNewOnThread = ((CButton *)GetDlgItem(IDC_NEWTHREAD))->GetCheck();
	pdbo->fOnTop = ((CButton *)GetDlgItem(IDC_ONTOP))->GetCheck();
	if (((CButton *)GetDlgItem(IDC_NONE))->GetCheck())
		pdbo->nInactive = INACTIVE_NONE;
	else if (((CButton *)GetDlgItem(IDC_CLOSE))->GetCheck())
		pdbo->nInactive = INACTIVE_CLOSE;
	else
		pdbo->nInactive = INACTIVE_MINIMIZE;
	pdbo->wFilter = 0;
	if (((CButton *)GetDlgItem(IDC_FILTER_OUTPUT))->GetCheck())
		pdbo->wFilter = DBO_OUTPUTDEBUGSTRING;
	if (((CButton *)GetDlgItem(IDC_FILTER_EXCEPTIONS))->GetCheck())
		pdbo->wFilter |= DBO_EXCEPTIONS;
	if (((CButton *)GetDlgItem(IDC_FILTER_PROCESSCREATE))->GetCheck())
		pdbo->wFilter |= DBO_PROCESSCREATE;
	if (((CButton *)GetDlgItem(IDC_FILTER_PROCESSEXIT))->GetCheck())
		pdbo->wFilter |= DBO_PROCESSEXIT;
	if (((CButton *)GetDlgItem(IDC_FILTER_THREADCREATE))->GetCheck())
		pdbo->wFilter |= DBO_THREADCREATE;
	if (((CButton *)GetDlgItem(IDC_FILTER_THREADEXIT))->GetCheck())
		pdbo->wFilter |= DBO_THREADEXIT;
	if (((CButton *)GetDlgItem(IDC_FILTER_DLLLOAD))->GetCheck())
		pdbo->wFilter |= DBO_DLLLOAD;
	if (((CButton *)GetDlgItem(IDC_FILTER_DLLUNLOAD))->GetCheck())
		pdbo->wFilter |= DBO_DLLUNLOAD;
	if (((CButton *)GetDlgItem(IDC_FILTER_RIP))->GetCheck())
		pdbo->wFilter |= DBO_RIP;
	CDialog::OnOK();
}

void DbWin32OptionsDlg::OnClicked()
{
	BOOL fNewOnProcess = ((CButton *)GetDlgItem(IDC_NEWPROCESS))->GetCheck();

	((CButton *)GetDlgItem(IDC_NEWTHREAD))->SetCheck(0);
	GetDlgItem(IDC_NEWTHREAD)->EnableWindow(fNewOnProcess);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\dbwin32\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by dbwin32.rc
//
#define IDR_MAIN                        1000
#define CMD_FILERUN                     1001
#define CMD_FILEATTACH                  1002
#define CMD_FILESYSTEM					1003
#define CMD_FILEEXIT                    1004
#define CMD_OPTIONS                     1101
#define CMD_ABOUT                       1201
#define IDR_CHILD                       2000
#define CMD_FILESAVEBUFFER              2001
#define CMD_EDITCOPY                    2101
#define CMD_EDITCLEARBUFFER             2102
#define CMD_EDITSELECTALL               2103
#define IDR_ABOUTDLG                    3000
#define IDR_ATTACHDLG                   4000
#define IDC_PROCESS                     4001
#define IDR_RUNDLG                      5000
#define IDC_COMMANDLINE                 5001
#define IDC_BROWSE						5002
#define IDR_OPTIONSDLG                  6000
#define IDC_ONTOP                       6001
#define IDC_MINIMIZE                    6002
#define IDC_NONE                        6003
#define IDC_CLOSE                       6004
#define IDC_NEWPROCESS                  6005
#define IDC_NEWTHREAD                   6006
#define IDC_FILTER_OUTPUT               6007
#define IDC_FILTER_EXCEPTIONS           6008
#define IDC_FILTER_PROCESSCREATE        6009
#define IDC_FILTER_PROCESSEXIT          6010
#define IDC_FILTER_THREADCREATE         6011
#define IDC_FILTER_THREADEXIT           6012
#define IDC_FILTER_DLLLOAD              6013
#define IDC_FILTER_DLLUNLOAD            6014
#define IDC_FILTER_RIP                  6015

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        107
#define _APS_NEXT_COMMAND_VALUE         112
#define _APS_NEXT_CONTROL_VALUE         6032
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\condbg\conio.hpp ===
//----------------------------------------------------------------------------
//
// Console input and output.
//
// Copyright (C) Microsoft Corporation, 1999-2000.
//
//----------------------------------------------------------------------------

#ifndef __CONIO_HPP__
#define __CONIO_HPP__

class DefInputCallbacks :
    public IDebugInputCallbacks
{
public:
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        IN REFIID InterfaceId,
        OUT PVOID* Interface
        );
    STDMETHOD_(ULONG, AddRef)(
        THIS
        );
    STDMETHOD_(ULONG, Release)(
        THIS
        );
};

class ConInputCallbacks : public DefInputCallbacks
{
public:
    // IDebugInputCallbacks.
    STDMETHOD(StartInput)(
        THIS_
        IN ULONG BufferSize
        );
    STDMETHOD(EndInput)(
        THIS
        );
};

class DefOutputCallbacks :
    public IDebugOutputCallbacks
{
public:
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        IN REFIID InterfaceId,
        OUT PVOID* Interface
        );
    STDMETHOD_(ULONG, AddRef)(
        THIS
        );
    STDMETHOD_(ULONG, Release)(
        THIS
        );
};

class ConOutputCallbacks : public DefOutputCallbacks
{
public:
    // IDebugOutputCallbacks.
    STDMETHOD(Output)(
        THIS_
        IN ULONG Mask,
        IN PCSTR Text
        );
};

// Maximum command string.  DbgPrompt has a limit of 512
// characters so that would be one potential limit.  We
// have users who want to use longer command lines, though,
// such as Autodump which scripts the debugger with very long
// sx commands.  The other obvious limit is MAX_SYMBOL_LEN
// since it makes sense that you should be able to give a
// command with a full symbol name, so use that.
#define MAX_COMMAND 4096
#define MAX_DBG_PROMPT_COMMAND 512

extern HANDLE g_ConInput, g_ConOutput;
extern HANDLE g_PromptInput;
extern HANDLE g_PipeWrite;
extern ConInputCallbacks g_ConInputCb;
extern ConOutputCallbacks g_ConOutputCb;
extern IDebugClient* g_ConClient;
extern IDebugControl* g_ConControl;

void InitializeIo(PCSTR InputFile);
void CreateConsole(void);
BOOL ConIn(PSTR Buffer, ULONG BufferSize, BOOL Wait);
void ConOut(PCSTR Format, ...);
void ConOutStr(PCSTR Str);
void DECLSPEC_NORETURN ExitDebugger(ULONG Code);
void DECLSPEC_NORETURN ErrorExit(PCSTR Format, ...);
void CreateInputThread(void);

#endif // #ifndef __CONIO_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\condbg\engine.cpp ===
//----------------------------------------------------------------------------
//
// Debug engine glue.
//
// Copyright (C) Microsoft Corporation, 1999-2001.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

#include "conio.hpp"
#include "engine.hpp"
#include "main.hpp"

// Global execution control.
BOOL g_Exit;

ULONG g_PlatformId;

// Debug engine interfaces.
IDebugClient* g_DbgClient;
IDebugClient2* g_DbgClient2;
IDebugControl* g_DbgControl;
IDebugSymbols* g_DbgSymbols;
IDebugRegisters* g_DbgRegisters;

ULONG g_ExecStatus;
ULONG g_LastProcessExitCode;
BOOL g_Restarting;

#define NTDLL_CALL_NAMES \
    (sizeof(g_NtDllCallNames) / sizeof(g_NtDllCallNames[0]))

// These names must match the ordering in the NTDLL_CALLS structure.
char* g_NtDllCallNames[] =
{
    "DbgPrint",
    "DbgPrompt",
};

#define NTDLL_CALL_PROCS (sizeof(g_NtDllCalls) / sizeof(FARPROC))

NTDLL_CALLS g_NtDllCalls;

//----------------------------------------------------------------------------
//
// Event callbacks.
//
//----------------------------------------------------------------------------

class EventCallbacks : public DebugBaseEventCallbacks
{
public:
    // IUnknown.
    STDMETHOD_(ULONG, AddRef)(
        THIS
        );
    STDMETHOD_(ULONG, Release)(
        THIS
        );

    // IDebugEventCallbacks.
    STDMETHOD(GetInterestMask)(
        THIS_
        OUT PULONG Mask
        );
    
    STDMETHOD(ExitProcess)(
        THIS_
        IN ULONG ExitCode
        );
    STDMETHOD(ChangeEngineState)(
        THIS_
        IN ULONG Flags,
        IN ULONG64 Argument
        );
};

STDMETHODIMP_(ULONG)
EventCallbacks::AddRef(
    THIS
    )
{
    // This class is designed to be static so
    // there's no true refcount.
    return 1;
}

STDMETHODIMP_(ULONG)
EventCallbacks::Release(
    THIS
    )
{
    // This class is designed to be static so
    // there's no true refcount.
    return 0;
}

STDMETHODIMP
EventCallbacks::GetInterestMask(
    THIS_
    OUT PULONG Mask
    )
{
    *Mask = DEBUG_EVENT_EXIT_PROCESS | DEBUG_EVENT_CHANGE_ENGINE_STATE;
    return S_OK;
}

STDMETHODIMP
EventCallbacks::ExitProcess(
    THIS_
    IN ULONG ExitCode
    )
{
    g_LastProcessExitCode = ExitCode;
    return DEBUG_STATUS_NO_CHANGE;
}

STDMETHODIMP
EventCallbacks::ChangeEngineState(
    THIS_
    IN ULONG Flags,
    IN ULONG64 Argument
    )
{
    if (Flags & DEBUG_CES_EXECUTION_STATUS)
    {
        g_ExecStatus = (ULONG)Argument;

        // If this notification came from a wait completing
        // we want to wake up the input thread so that new
        // commands can be processed.  If it came from inside
        // a wait we don't want to ask for input as the engine
        // may go back to running at any time.
        if ((Argument & DEBUG_STATUS_INSIDE_WAIT) == 0)
        {
            if (g_IoMode == IO_NONE)
            {
                // Wake up the main loop.
                g_DbgClient->ExitDispatch(g_DbgClient);
            }
            else if (g_ConClient != NULL)
            {
                g_ConClient->ExitDispatch(g_DbgClient);
            }
        }
    }
    
    return S_OK;
}

EventCallbacks g_EventCb;

//----------------------------------------------------------------------------
//
// Functions.
//
//----------------------------------------------------------------------------

ULONG NTAPI
Win9xDbgPrompt(char *Prompt, char *Buffer, ULONG BufferLen)
{
    ULONG Len;
    
    // XXX drewb - Is there a real equivalent of DbgPrompt?

    if (BufferLen == 0)
    {
        return 0;
    }
    Buffer[0] = 0;
    
    printf("%s", Prompt);
    if (fgets(Buffer, BufferLen, stdin))
    {
        Len = strlen(Buffer);
        while (Len > 0 && isspace(Buffer[Len - 1]))
        {
            Len--;
        }

        if (Len > 0)
        {
            Buffer[Len] = 0;
        }
    }
    else
    {
        Len = 0;
    }
    
    return Len;
}

ULONG __cdecl
Win9xDbgPrint( char *Text, ... )
{
    char Temp[1024];
    va_list Args;

    va_start(Args, Text);
    _vsnprintf(Temp, sizeof(Temp), Text, Args);
    va_end(Args);
    OutputDebugString(Temp);

    return 0;
}

void
InitDynamicCalls(void)
{
    HINSTANCE NtDll;
    ULONG i;
    char** Name;
    FARPROC* Proc;
    
    if (g_PlatformId != VER_PLATFORM_WIN32_NT)
    {
        g_NtDllCalls.DbgPrint = Win9xDbgPrint;
        g_NtDllCalls.DbgPrompt = Win9xDbgPrompt;
        return;
    }
    
    //
    // Dynamically link NT calls.
    //
    
    if (NTDLL_CALL_NAMES != NTDLL_CALL_PROCS)
    {
        ErrorExit("NtDllCalls mismatch\n");
    }

    NtDll = LoadLibrary("ntdll.dll");
    if (NtDll == NULL)
    {
        ErrorExit("%s: Unable to load ntdll\n", g_DebuggerName);
    }
    
    Name = g_NtDllCallNames;
    Proc = (FARPROC*)&g_NtDllCalls;

    for (i = 0; i < NTDLL_CALL_PROCS; i++)
    {
        *Proc = GetProcAddress(NtDll, *Name);
        if (*Proc == NULL)
        {
            ErrorExit("%s: Unable to link ntdll!%s\n",
                      g_DebuggerName, *Name);
        }

        Proc++;
        Name++;
    }

    // If DbgPrintReturnControlC exists use it instead of
    // normal DbgPrint.
    FARPROC DpRetCc;

    DpRetCc = GetProcAddress(NtDll, "DbgPrintReturnControlC");
    if (DpRetCc != NULL)
    {
        Proc = (FARPROC*)&g_NtDllCalls.DbgPrint;
        *Proc = DpRetCc;
    }
}    

void
DefaultEngineInitialize(void)
{
    HRESULT Hr;
    OSVERSIONINFO OsVersionInfo;

    OsVersionInfo.dwOSVersionInfoSize = sizeof(OsVersionInfo);
    GetVersionEx(&OsVersionInfo);
    g_PlatformId = OsVersionInfo.dwPlatformId;

    if ((Hr = g_DbgClient->QueryInterface(IID_IDebugControl,
                                          (void **)&g_DbgControl)) != S_OK ||
        (Hr = g_DbgClient->QueryInterface(IID_IDebugSymbols,
                                          (void **)&g_DbgSymbols)) != S_OK ||
        (Hr = g_DbgClient->QueryInterface(IID_IDebugRegisters,
                                          (void **)&g_DbgRegisters)) != S_OK)
    {
        ErrorExit("Debug engine base queries failed, %s\n    \"%s\"\n",
                  FormatStatusCode(Hr), FormatStatus(Hr));
    }

    // Queries for higher-version interfaces.  These can
    // fail if this executable is run against an older engine.
    // This is highly unlikely since everything is shipped
    // as a set, but handle it anyway.
    if ((Hr = g_DbgClient->QueryInterface(IID_IDebugClient2,
                                          (void **)&g_DbgClient2)) != S_OK &&
        Hr != E_NOINTERFACE &&
        Hr != RPC_E_VERSION_MISMATCH)
    {
        ErrorExit("Debug engine base queries failed, %s\n    \"%s\"\n",
                  FormatStatusCode(Hr), FormatStatus(Hr));
    }
    
    g_DbgClient->SetInputCallbacks(&g_ConInputCb);
    g_DbgClient->SetOutputCallbacks(&g_ConOutputCb);
    g_DbgClient->SetEventCallbacks(&g_EventCb);

    if (!g_RemoteClient)
    {
        //
        // Check environment variables to determine if any logfile needs to be
        // opened.
        //

        PSTR LogFile;
        BOOL Append;
    
        LogFile = getenv("_NT_DEBUG_LOG_FILE_APPEND");
        if (LogFile != NULL)
        {
            Append = TRUE;
        }
        else
        {
            Append = FALSE;
            LogFile = getenv("_NT_DEBUG_LOG_FILE_OPEN");
        }
        if (LogFile != NULL)
        {
            g_DbgControl->OpenLogFile(LogFile, Append);
        }
    }

    InitDynamicCalls();
}

void
CreateEngine(PCSTR RemoteOptions)
{
    HRESULT Hr;
    
    if ((Hr = DebugCreate(IID_IDebugClient,
                          (void **)&g_DbgClient)) != S_OK)
    {
        ErrorExit("DebugCreate failed, %s\n    \"%s\"\n",
                  FormatStatusCode(Hr), FormatStatus(Hr));
    }

    if (RemoteOptions != NULL)
    {
        if ((Hr = g_DbgClient->StartServer(RemoteOptions)) != S_OK)
        {
            ErrorExit("StartServer failed, %s\n    \"%s\"\n",
                      FormatStatusCode(Hr), FormatStatus(Hr));
        }
    }
    
    DefaultEngineInitialize();
}

void
ConnectEngine(PCSTR RemoteOptions)
{
    HRESULT Hr;

    if ((Hr = DebugConnect(RemoteOptions, IID_IDebugClient,
                           (void **)&g_DbgClient)) != S_OK)
    {
        ErrorExit("DebugCreate failed, %s\n    \"%s\"\n",
                  FormatStatusCode(Hr), FormatStatus(Hr));
    }
        
    DefaultEngineInitialize();
}

void
InitializeSession(void)
{
    HRESULT Hr;

    if (g_DumpFile != NULL)
    {
        if (g_DumpPageFile != NULL)
        {
            if (g_DbgClient2 == NULL)
            {
                ErrorExit("Debugger does not support extra dump files\n");
            }
            
            if ((Hr = g_DbgClient2->AddDumpInformationFile
                 (g_DumpPageFile, DEBUG_DUMP_FILE_PAGE_FILE_DUMP)) != S_OK)
            {
                ErrorExit("Unable to use '%s', %s\n    \"%s\"\n",
                          g_DumpPageFile,
                          FormatStatusCode(Hr), FormatStatus(Hr));
            }
        }
        
        Hr = g_DbgClient->OpenDumpFile(g_DumpFile);
    }
    else if (g_CommandLine != NULL ||
             g_PidToDebug != 0 ||
             g_ProcNameToDebug != NULL)
    {
        ULONG64 Server = 0;
        
        if (g_ProcessServer != NULL)
        {
            Hr = g_DbgClient->ConnectProcessServer(g_ProcessServer,
                                                   &Server);
            if (Hr != S_OK)
            {
                ErrorExit("Unable to connect to process server, %s\n"
                          "    \"%s\"\n", FormatStatusCode(Hr),
                          FormatStatus(Hr));
            }
        }

        ULONG Pid;
        
        if (g_ProcNameToDebug != NULL)
        {
            Hr = g_DbgClient->GetRunningProcessSystemIdByExecutableName
                (Server, g_ProcNameToDebug, DEBUG_GET_PROC_ONLY_MATCH, &Pid);
            if (Hr != S_OK)
            {
                ErrorExit("Unable to find process '%s', %s\n    \"%s\"\n",
                          g_ProcNameToDebug, FormatStatusCode(Hr),
                          FormatStatus(Hr));
            }
        }
        else
        {
            Pid = g_PidToDebug;
        }
        
        Hr = g_DbgClient->CreateProcessAndAttach(Server,
                                                 g_CommandLine, g_CreateFlags,
                                                 Pid, g_AttachProcessFlags);

        if (g_DetachOnExitRequired &&
            g_DbgClient->
            AddProcessOptions(DEBUG_PROCESS_DETACH_ON_EXIT) != S_OK)
        {
            ErrorExit("%s: The system does not support detach on exit\n",
                      g_DebuggerName);
        }
        else if (g_DetachOnExitImplied)
        {
            // The detach-on-exit is not required so don't check for
            // failures.  This is necessary for the -- case where
            // detach-on-exit is implied but must work on systems
            // with and without the detach-on-exit support.
            g_DbgClient->AddProcessOptions(DEBUG_PROCESS_DETACH_ON_EXIT);
        }
        
        if (Server != 0)
        {
            g_DbgClient->DisconnectProcessServer(Server);
        }
    }
    else
    {
        Hr = g_DbgClient->AttachKernel(g_AttachKernelFlags, g_ConnectOptions);
    }
    if (Hr != S_OK)
    {
        ErrorExit("Debuggee initialization failed, %s\n    \"%s\"\n",
                  FormatStatusCode(Hr), FormatStatus(Hr));
    }
}

BOOL WINAPI
InterruptHandler(
    IN ULONG CtrlType
    )
{
    if (CtrlType == CTRL_C_EVENT || CtrlType == CTRL_BREAK_EVENT)
    {
        PDEBUG_CONTROL Control =
            g_RemoteClient ? g_ConControl : g_DbgControl;
        if (Control != NULL)
        {
            Control->SetInterrupt(DEBUG_INTERRUPT_ACTIVE);
        }
        else
        {
            ConOut("Debugger not initialized, cannot interrupt\n");
        }
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

BOOL
APIENTRY
MyCreatePipeEx(
    OUT LPHANDLE lpReadPipe,
    OUT LPHANDLE lpWritePipe,
    IN LPSECURITY_ATTRIBUTES lpPipeAttributes,
    IN DWORD nSize,
    DWORD dwReadMode,
    DWORD dwWriteMode
    )

/*++

Routine Description:

    The CreatePipeEx API is used to create an anonymous pipe I/O device.
    Unlike CreatePipe FILE_FLAG_OVERLAPPED may be specified for one or
    both handles.
    Two handles to the device are created.  One handle is opened for
    reading and the other is opened for writing.  These handles may be
    used in subsequent calls to ReadFile and WriteFile to transmit data
    through the pipe.

Arguments:

    lpReadPipe - Returns a handle to the read side of the pipe.  Data
        may be read from the pipe by specifying this handle value in a
        subsequent call to ReadFile.

    lpWritePipe - Returns a handle to the write side of the pipe.  Data
        may be written to the pipe by specifying this handle value in a
        subsequent call to WriteFile.

    lpPipeAttributes - An optional parameter that may be used to specify
        the attributes of the new pipe.  If the parameter is not
        specified, then the pipe is created without a security
        descriptor, and the resulting handles are not inherited on
        process creation.  Otherwise, the optional security attributes
        are used on the pipe, and the inherit handles flag effects both
        pipe handles.

    nSize - Supplies the requested buffer size for the pipe.  This is
        only a suggestion and is used by the operating system to
        calculate an appropriate buffering mechanism.  A value of zero
        indicates that the system is to choose the default buffering
        scheme.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    static ULONG PipeSerialNumber;
    HANDLE ReadPipeHandle, WritePipeHandle;
    DWORD dwError;
    UCHAR PipeNameBuffer[ MAX_PATH ];

    //
    // Only one valid OpenMode flag - FILE_FLAG_OVERLAPPED
    //

    if ((dwReadMode | dwWriteMode) & (~FILE_FLAG_OVERLAPPED)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    //  Set the default timeout to 120 seconds
    //

    if (nSize == 0) {
        nSize = 4096;
        }

    sprintf( (char *)PipeNameBuffer,
             "\\\\.\\Pipe\\Win32PipesEx.%08x.%08x",
             GetCurrentProcessId(),
             PipeSerialNumber++
           );

    ReadPipeHandle = CreateNamedPipeA(
                         (char *)PipeNameBuffer,
                         PIPE_ACCESS_INBOUND | dwReadMode,
                         PIPE_TYPE_BYTE | PIPE_WAIT,
                         1,             // Number of pipes
                         nSize,         // Out buffer size
                         nSize,         // In buffer size
                         120 * 1000,    // Timeout in ms
                         lpPipeAttributes
                         );

    if (ReadPipeHandle == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    WritePipeHandle = CreateFileA(
                        (char *)PipeNameBuffer,
                        GENERIC_WRITE,
                        0,                         // No sharing
                        lpPipeAttributes,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL | dwWriteMode,
                        NULL                       // Template file
                      );

    if (INVALID_HANDLE_VALUE == WritePipeHandle) {
        dwError = GetLastError();
        CloseHandle( ReadPipeHandle );
        SetLastError(dwError);
        return FALSE;
    }

    *lpReadPipe = ReadPipeHandle;
    *lpWritePipe = WritePipeHandle;
    return( TRUE );
}

void
StartRemote(
    PCSTR Args
    )

/*++

Routine Description:

    "remotes" the current debugger by starting a copy of remote.exe in a
    special mode that causes it to attach to us, the debugger, as its
    "child" process.

Arguments:

    Args - Name of the pipe to use for this remote session, e.g. "ntsd" means
           to connect one would use "remote /c machinename ntsd".

Return Value:

    None.

--*/

{
    static BOOL fRemoteIsRunning;
    HANDLE hRemoteChildProcess;
    HANDLE hOrgStdIn;
    HANDLE hOrgStdOut;
    HANDLE hOrgStdErr;
    HANDLE hNewStdIn;
    HANDLE hRemoteWriteChildStdIn;
    HANDLE hNewStdOut;
    HANDLE hRemoteReadChildStdOut;
    HANDLE hNewStdErr;
    SECURITY_ATTRIBUTES sa;
    STARTUPINFO si;
    PROCESS_INFORMATION pi;
    char szCmd[64];

    if (Args == NULL)
    {
        goto DotRemoteUsage;
    }
    
    while (*Args == ' ' || *Args == '\t')
    {
        Args++;
    }

    if (!Args[0])
    {
        goto DotRemoteUsage;
    }

    if (g_PipeWrite != NULL)
    {
        ConOut("An input thread has already been started so .remote\n");
        ConOut("cannot be used.  Either start the debugger with\n");
        ConOut("remote.exe, such as remote /s \"kd\" pipe; or use\n");
        ConOut("debugger remoting with -server/-client/.server.\n");
        return;
    }
    
    if (fRemoteIsRunning)
    {
        ConOut(".remote: can't .remote twice.\n");
        goto Cleanup;
    }

    if (g_IoMode != IO_CONSOLE)
    {
        ConOut(".remote: can't .remote when using -d.  "
               "Remote the kernel debugger instead.\n");
        goto Cleanup;
    }

    ConOut("Starting remote with pipename '%s'\n", Args);

    //
    // We'll pass remote.exe inheritable handles to this process,
    // our standard in/out handles (for it to use as stdin/stdout),
    // and pipe handles for it to write to our new stdin and read
    // from our new stdout.
    //

    //
    // Get an inheritable handle to our process.
    //

    if ( ! DuplicateHandle(
               GetCurrentProcess(),           // src process
               GetCurrentProcess(),           // src handle
               GetCurrentProcess(),           // targ process
               &hRemoteChildProcess,          // targ handle
               0,                             // access
               TRUE,                          // inheritable
               DUPLICATE_SAME_ACCESS          // options
               ))
    {
        ConOut(".remote: Unable to duplicate process handle.\n");
        goto Cleanup;
    }

    //
    // Get inheritable copies of our current stdin, stdout, stderr which
    // we'll use for same for remote.exe when we spawn it.
    //

    hOrgStdIn = g_ConInput;
    hOrgStdOut = g_ConOutput;
    hOrgStdErr = GetStdHandle(STD_ERROR_HANDLE);

    sa.nLength = sizeof(sa);
    sa.lpSecurityDescriptor = NULL;
    sa.bInheritHandle = TRUE;

    //
    // Create remote->ntsd pipe, our end of which will be our
    // new stdin.  The remote.exe end needs to be opened
    // for overlapped I/O, so yet another copy of MyCreatePipeEx
    // spreads through our source base.
    //

    if ( ! MyCreatePipeEx(
               &hNewStdIn,                 // read handle
               &hRemoteWriteChildStdIn,    // write handle
               &sa,                        // security
               0,                          // size
               0,                          // read handle overlapped?
               FILE_FLAG_OVERLAPPED        // write handle overlapped?
               ))
    {
        ConOut(".remote: Unable to create stdin pipe.\n");
        CloseHandle(hRemoteChildProcess);
        goto Cleanup;
    }

    //
    // We don't want remote.exe to inherit our end of the pipe
    // so duplicate it to a non-inheritable one.
    //

    if ( ! DuplicateHandle(
               GetCurrentProcess(),           // src process
               hNewStdIn,                     // src handle
               GetCurrentProcess(),           // targ process
               &hNewStdIn,                    // targ handle
               0,                             // access
               FALSE,                         // inheritable
               DUPLICATE_SAME_ACCESS |
               DUPLICATE_CLOSE_SOURCE         // options
               ))
    {
        ConOut(".remote: Unable to duplicate stdout handle.\n");
        CloseHandle(hRemoteChildProcess);
        CloseHandle(hRemoteWriteChildStdIn);
        goto Cleanup;
    }

    //
    // Create ntsd->remote pipe, our end of which will be our
    // new stdout and stderr.
    //

    if ( ! MyCreatePipeEx(
               &hRemoteReadChildStdOut,    // read handle
               &hNewStdOut,                // write handle
               &sa,                        // security
               0,                          // size
               FILE_FLAG_OVERLAPPED,       // read handle overlapped?
               0                           // write handle overlapped?
               ))
    {
        ConOut(".remote: Unable to create stdout pipe.\n");
        CloseHandle(hRemoteChildProcess);
        CloseHandle(hRemoteWriteChildStdIn);
        CloseHandle(hNewStdIn);
        goto Cleanup;
    }

    //
    // We don't want remote.exe to inherit our end of the pipe
    // so duplicate it to a non-inheritable one.
    //

    if ( ! DuplicateHandle(
               GetCurrentProcess(),           // src process
               hNewStdOut,                    // src handle
               GetCurrentProcess(),           // targ process
               &hNewStdOut,                   // targ handle
               0,                             // access
               FALSE,                         // inheritable
               DUPLICATE_SAME_ACCESS |
               DUPLICATE_CLOSE_SOURCE         // options
               ))
    {
        ConOut(".remote: Unable to duplicate stdout handle.\n");
        CloseHandle(hRemoteChildProcess);
        CloseHandle(hRemoteWriteChildStdIn);
        CloseHandle(hNewStdIn);
        CloseHandle(hRemoteReadChildStdOut);
        goto Cleanup;
    }

    //
    // Duplicate our new stdout to a new stderr.
    //

    if ( ! DuplicateHandle(
               GetCurrentProcess(),           // src process
               hNewStdOut,                    // src handle
               GetCurrentProcess(),           // targ process
               &hNewStdErr,                   // targ handle
               0,                             // access
               FALSE,                         // inheritable
               DUPLICATE_SAME_ACCESS          // options
               ))
    {
        ConOut(".remote: Unable to duplicate stdout handle.\n");
        CloseHandle(hRemoteChildProcess);
        CloseHandle(hRemoteWriteChildStdIn);
        CloseHandle(hNewStdIn);
        CloseHandle(hRemoteReadChildStdOut);
        CloseHandle(hNewStdOut);
        goto Cleanup;
    }

    //
    // We now have all the handles we need.  Let's launch remote.
    //

    sprintf(
        szCmd,
        "remote.exe /a %d %d %d %s %s",
        HandleToUlong(hRemoteChildProcess),
        HandleToUlong(hRemoteWriteChildStdIn),
        HandleToUlong(hRemoteReadChildStdOut),
        g_DebuggerName,
        Args
        );

    ZeroMemory(&si, sizeof(si));
    si.cb            = sizeof(si);
    si.dwFlags       = STARTF_USESTDHANDLES;
    si.hStdInput     = hOrgStdIn;
    si.hStdOutput    = hOrgStdOut;
    si.hStdError     = hOrgStdErr;
    si.wShowWindow   = SW_SHOW;

    //
    // Create Child Process
    //

    if ( ! CreateProcess(
               NULL,
               szCmd,
               NULL,
               NULL,
               TRUE,
               GetPriorityClass( GetCurrentProcess() ),
               NULL,
               NULL,
               &si,
               &pi))
    {
        if (GetLastError() == ERROR_FILE_NOT_FOUND)
        {
            ConOut("remote.exe not found\n");
        }
        else
        {
            ConOut("CreateProcess(%s) failed, error %d.\n",
                   szCmd, GetLastError());
        }

        CloseHandle(hRemoteChildProcess);
        CloseHandle(hRemoteWriteChildStdIn);
        CloseHandle(hNewStdIn);
        CloseHandle(hRemoteReadChildStdOut);
        CloseHandle(hNewStdOut);
        CloseHandle(hNewStdErr);
        goto Cleanup;
    }

    CloseHandle(hRemoteChildProcess);
    CloseHandle(hRemoteWriteChildStdIn);
    CloseHandle(hRemoteReadChildStdOut);
    CloseHandle(pi.hThread);
    CloseHandle(pi.hProcess);

    //
    // Switch to using the new handles.  Might be nice to
    // start a thread here to watch for remote.exe dying
    // and switch back to the old handles.
    //

    // CloseHandle(hOrgStdIn);
    if (g_PromptInput == g_ConInput)
    {
        g_PromptInput = hNewStdIn;
    }
    g_ConInput = hNewStdIn;
    SetStdHandle(STD_INPUT_HANDLE, hNewStdIn);

    // CloseHandle(hOrgStdOut);
    g_ConOutput = hNewStdOut;
    SetStdHandle(STD_OUTPUT_HANDLE, hNewStdOut);

    // CloseHandle(hOrgStdErr);
    SetStdHandle(STD_ERROR_HANDLE, hNewStdErr);

    fRemoteIsRunning = TRUE;

    ConOut("%s: now running under remote.exe pipename %s\n",
           g_DebuggerName, Args);

  Cleanup:
    return;

DotRemoteUsage:
    ConOut("Usage: .remote pipename\n");
}

BOOL
UiCommand(PSTR Command)
{
    char Term;
    PSTR Scan, Arg;

    //
    // Check and see if this is a UI command
    // vs. a command that should go to the engine.
    //
    
    while (isspace(*Command))
    {
        Command++;
    }
    Scan = Command;
    while (*Scan && !isspace(*Scan))
    {
        Scan++;
    }
    Term = *Scan;
    *Scan = 0;

    // Advance to next nonspace char for arguments.
    if (Term != 0)
    {
        Arg = Scan + 1;
        while (isspace(*Arg))
        {
            Arg++;
        }
        if (*Arg == 0)
        {
            Arg = NULL;
        }
    }
    else
    {
        Arg = NULL;
    }

    if (!_strcmpi(Command, ".hh"))
    {
        if (Arg == NULL)
        {
            OpenHelpTopic(HELP_TOPIC_TABLE_OF_CONTENTS);
        }
        else
        {
            OpenHelpIndex(Arg);
        }
    }
    else if (!_strcmpi(Command, ".remote"))
    {
        StartRemote(Arg);
    }
    else if (!_strcmpi(Command, ".restart"))
    {
        if (g_RemoteClient)
        {
            ConOut("Only the primary debugger can restart\n");
        }
        else if (g_PidToDebug != 0 ||
                 g_ProcNameToDebug != NULL)
        {
            ConOut("Process attaches cannot be restarted.  If you want to\n"
                   "restart the process, use !peb to get what command line\n"
                   "to use and other initialization information.\n");
        }
        else
        {
            g_DbgClient->EndSession(DEBUG_END_ACTIVE_TERMINATE);
            g_Restarting = TRUE;
        }
    }
    else if (!_strcmpi(Command, ".server"))
    {
        // We need to start a separate input thread when
        // using remoting but we do not actually handle
        // the command.
        CreateInputThread();
        *Scan = Term;
        return FALSE;
    }
    else if (Command[0] == '$' && Command[1] == '<')
    {
        *Scan = Term;
        if (g_NextOldInputFile >= MAX_INPUT_NESTING)
        {
            ConOut("Scripts too deeply nested\n");
        }
        else
        {
            FILE* Script = fopen(Command + 2, "r");
            if (Script == NULL)
            {
                ConOut("Unable to open '%s'\n", Command + 2);
            }
            else
            {
                g_OldInputFiles[g_NextOldInputFile++] = g_InputFile;
                g_InputFile = Script;
            }
        }
    }
    else
    {
        *Scan = Term;
        return FALSE;
    }

    return TRUE;
}

BOOL
CallBugCheckExtension(
    void
    )
{
    HRESULT Status = E_FAIL;

    ULONG Code;
    ULONG64 Args[4];

    // Run the bugcheck analyzers if this dump has a bugcheck.
    if (g_DbgControl->ReadBugCheckData(&Code, &Args[0], &Args[1], &Args[2], &Args[3]) != S_OK ||
        Code == 0)
    {
        return FALSE;
    }

    if (g_DbgClient != NULL)
    {
        char ExtName[32];

        // Extension name has to be in writable memory as it
        // gets lower-cased.
        strcpy(ExtName, "AnalyzeBugCheck");
        
        // See if any existing extension DLLs are interested
        // in analyzing this bugcheck.
        Status = g_DbgControl->CallExtension(NULL, ExtName, "");
    }

    if (Status != S_OK)
    {
        if (g_DbgClient == NULL)
        {
            ConOut("WARNING: Unable to locate a client for "
                    "bugcheck analysis\n");
        }
        
        ConOut("*******************************************************************************\n");
        ConOut("*                                                                             *\n");
        ConOut("*                        Bugcheck Analysis                                    *\n");
        ConOut("*                                                                             *\n");
        ConOut("*******************************************************************************\n");

        g_DbgControl->Execute(DEBUG_OUTCTL_AMBIENT, ".bugcheck", DEBUG_EXECUTE_DEFAULT);
        ConOut("\n");
        g_DbgControl->Execute(DEBUG_OUTCTL_AMBIENT, "kb", DEBUG_EXECUTE_DEFAULT);
        ConOut("\n");
    } else 
    {
        return TRUE;
    }

    return FALSE;
}

BOOL
MainLoop(void)
{
    HRESULT Hr;
    BOOL SessionEnded = FALSE;
    ULONG64 InstructionOffset;
    DEBUG_STACK_FRAME StkFrame;
    ULONG Class, Qual;

    if (!SetConsoleCtrlHandler(InterruptHandler, TRUE))
    {
        ConOut("Warning: unable to set Control-C handler.\n");
    }

    // Get initial status.
    g_DbgControl->GetExecutionStatus(&g_ExecStatus);
    g_DbgControl->GetDebuggeeType(&Class, &Qual);
    
    while (!g_Exit)
    {
        if (!g_RemoteClient)
        {
            Hr = g_DbgControl->WaitForEvent(DEBUG_WAIT_DEFAULT, INFINITE);
            
            if (FAILED(Hr))
            {
                // The debug session may have ended.  If so, just exit.
                if (g_DbgControl->GetExecutionStatus(&g_ExecStatus) == S_OK &&
                    g_ExecStatus == DEBUG_STATUS_NO_DEBUGGEE)
                {
                    SessionEnded = TRUE;
                    break;
                }
                
                // Inform the user of the failure and go to
                // command processing.
                ConOut("WaitForEvent failed, %s\n    \"%s\"\n",
                       FormatStatusCode(Hr), FormatStatus(Hr));
            }

            // By far the most likely reason for WaitForEvent to
            // fail on a dump is bad symbols, which would produce
            // further errors when trying to use processor state.
            // Avoid doing so in the dump case.
            if (FAILED(Hr) && g_DumpFile != NULL)
            {
                ConOut("When WaitForEvent fails on dump files the "
                       "current state is not displayed\n");
            }
            else
            {
                BOOL DisplayRegs = TRUE;

                if (Class == DEBUG_CLASS_KERNEL &&
                    (Qual == DEBUG_DUMP_SMALL || Qual == DEBUG_DUMP_DEFAULT ||
                     Qual == DEBUG_DUMP_FULL)) 
                {
                    if (CallBugCheckExtension())
                    {
                        DisplayRegs = FALSE;
                    }
                }

                if (DisplayRegs) 
                {
                    // Dump registers and such.
                    g_DbgControl->OutputCurrentState(DEBUG_OUTCTL_ALL_CLIENTS,
                                                     DEBUG_CURRENT_DEFAULT);
                }
            }
        
        }

        while (!g_Exit && g_ExecStatus == DEBUG_STATUS_BREAK)
        {
            if (g_IoMode == IO_NONE)
            {
                // This is a pure remoting server with no
                // local user.  Just wait for a remote client
                // to get things running again.
                Hr = g_DbgClient->DispatchCallbacks(INFINITE);
                if (Hr != S_OK)
                {
                    OutputDebugString("Unable to dispatch callbacks\n");
                    ExitDebugger(Hr);
                }
            }
            else
            {
                char Command[MAX_COMMAND];
            
                g_DbgControl->OutputPrompt(DEBUG_OUTCTL_THIS_CLIENT |
                                           DEBUG_OUTCTL_NOT_LOGGED, " ");
                if (ConIn(Command, sizeof(Command), TRUE))
                {
                    if (g_RemoteClient)
                    {
                        // Identify self before command.
                        g_DbgClient->
                            OutputIdentity(DEBUG_OUTCTL_ALL_OTHER_CLIENTS,
                                           DEBUG_OUTPUT_IDENTITY_DEFAULT,
                                           "[%s] ");
                    }
                
                    g_DbgControl->OutputPrompt(DEBUG_OUTCTL_ALL_OTHER_CLIENTS,
                                               " %s\n", Command);
                
                    // Intercept and handle UI commands.
                    if (!UiCommand(Command))
                    {
                        // Must be an engine command.
                        g_DbgControl->Execute(DEBUG_OUTCTL_ALL_CLIENTS,
                                              Command,
                                              DEBUG_EXECUTE_NOT_LOGGED);
                    }
                }
            }
        }

        if (g_Restarting)
        {
            InitializeSession();
            g_Restarting = FALSE;
            continue;
        }
        
        if (Class != DEBUG_CLASS_USER_WINDOWS)
        {
            // The kernel debugger doesn't exit when the machine reboots.
            g_Exit = FALSE;
        }
        else
        {
            g_Exit = g_ExecStatus == DEBUG_STATUS_NO_DEBUGGEE;
            if (g_Exit)
            {
                SessionEnded = TRUE;
                break;
            }
        }
        
        if (g_RemoteClient)
        {
            Hr = g_DbgClient->DispatchCallbacks(INFINITE);
            if (Hr != S_OK)
            {
                OutputDebugString("Unable to dispatch callbacks\n");
                ExitDebugger(Hr);
            }
        }
    }

    return SessionEnded;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\breakin\breakin.c ===
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>

#define STACKSIZE 32768

typedef BOOL (* LPDEBUG_BREAK_PROCESS_ROUTINE) (
    HANDLE Process
    );


VOID
DebugPriv(
         VOID
         )
{
    HANDLE Token ;
    UCHAR Buf[ sizeof( TOKEN_PRIVILEGES ) + sizeof( LUID_AND_ATTRIBUTES ) ];
    UCHAR Buf2[ sizeof( Buf ) ];
    PTOKEN_PRIVILEGES Privs ;
    PTOKEN_PRIVILEGES NewPrivs ;
    DWORD size ;

    if (OpenProcessToken( GetCurrentProcess(),
                          MAXIMUM_ALLOWED,
                          &Token )) {
        Privs = (PTOKEN_PRIVILEGES) Buf ;

        Privs->PrivilegeCount = 1 ;
        Privs->Privileges[0].Luid.LowPart = 20L ;
        Privs->Privileges[0].Luid.HighPart = 0 ;
        Privs->Privileges[0].Attributes = SE_PRIVILEGE_ENABLED ;

        NewPrivs = (PTOKEN_PRIVILEGES) Buf2 ;

        AdjustTokenPrivileges( Token,
                               FALSE,
                               Privs,
                               sizeof( Buf2 ),
                               NewPrivs,
                               &size );

        CloseHandle( Token );
    }
}

int
__cdecl
main(
    int argc,
    char **argv
    )
{
    LPTHREAD_START_ROUTINE DbgBreakPoint;
    LPDEBUG_BREAK_PROCESS_ROUTINE DebugBreakProcessRoutine;
    HANDLE ntdll, kernel32;
    ULONG ProcessId;
    ULONG ThreadId;
    HANDLE Process;
    HANDLE Thread;

    if (argc != 2) {
        usage:
        fprintf(stderr, "usage: breakin <pid>\n");
        exit(1);
    }

    ProcessId = atoi(argv[1]);

    if (ProcessId == 0) {
        goto usage;
    }

    DebugPriv();

    Process = OpenProcess(
                         PROCESS_ALL_ACCESS,
                         FALSE,
                         ProcessId
                         );
    if (Process) {

        kernel32 = GetModuleHandle("kernel32.dll");

        if (kernel32) {

            DebugBreakProcessRoutine = (LPDEBUG_BREAK_PROCESS_ROUTINE)GetProcAddress(kernel32, "DebugBreakProcess");

            if (DebugBreakProcessRoutine) {

                if (!(*DebugBreakProcessRoutine)(Process)) {

                    printf("DebugBreakProcess failed %d\n", GetLastError());
                }

                CloseHandle(Process);

                return 0;
            }
        }
        
        ntdll = GetModuleHandle("ntdll.dll");

        if (ntdll) {

            DbgBreakPoint = (LPTHREAD_START_ROUTINE)GetProcAddress(ntdll, "DbgBreakPoint");

            if (DbgBreakPoint) {

                Thread = CreateRemoteThread(
                                           Process,
                                           NULL,
                                           STACKSIZE,
                                           DbgBreakPoint,
                                           NULL,
                                           0,
                                           &ThreadId
                                           );
                if (Thread){
                    CloseHandle(Thread);
                }
            }
        }

        CloseHandle(Process);

    } else {

        printf("Open process failed %d\n", GetLastError());
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\dc\dc.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

	dc.cpp

 Abstract:

	Command line utility for dumping importing information from DLL's
	and executables.

	Command Line Options:
	/v			Verbose mode
	/s:Func		Only display functions matching search string "Func"
	/o:File		Send output to File
	/f			Sort by function, not by module.

 History:

    05/10/2000 t-michkr  Created

--*/

#include <windows.h>
#include <assert.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>

// For some reason, this is needed to compile in
// the sdktools tree.
#define strdup		_strdup
#define stricmp		_stricmp
#define strnicmp	_strnicmp

// Structure containing all info relevent to an imported function.
struct SFunction
{
	// The name this function is imported by.
	char* m_szName;

	// Ordinal number, Win3.1 compatibility.
	int m_iOrdinal;

	// Lookup index into a DLL's export table
	// for quick patching.
	int m_iHint;

	// Starting address of the function.
	DWORD m_dwAddress;

	// Whether or not it is a delayed import.
	bool m_fDelayedImport;

	// Forwarded function name
	char* m_szForward;

	// Link to next function
	SFunction* m_pNext;

	SFunction()
	{
		m_szName = m_szForward = 0;
		m_iOrdinal = m_iHint = -1;
		m_dwAddress = static_cast<DWORD>(-1);
		m_fDelayedImport = false;
		m_pNext = 0;
	}
};

// A module used by the executable (ie, DLL's)
struct SModule
{
	// The name of this module
	char* m_szName;

	// All functions imported from this module
	SFunction* m_pFunctions;

	// Link to next module
	SModule* m_pNext;

	SModule()
	{
		m_szName = 0;
		m_pFunctions = 0;
		m_pNext = 0;
	}
};

// All modules imported by the executable.
SModule* g_pModules = 0;

void InsertFunctionSorted(SModule* pMod, SFunction* pFunc)
{

	// Special case, insert at front
	if(pMod->m_pFunctions == 0 
		|| stricmp(pMod->m_pFunctions->m_szName, pFunc->m_szName) > 0)
	{
		pFunc->m_pNext = pMod->m_pFunctions;
		pMod->m_pFunctions = pFunc;
		return;
	}

	SFunction* pfPrev = pMod->m_pFunctions;
	SFunction* pfTemp = pMod->m_pFunctions->m_pNext;
	while(pfTemp)
	{
		if(stricmp(pfTemp->m_szName, pFunc->m_szName) > 0)
		{
			pFunc->m_pNext = pfTemp;
			pfPrev->m_pNext = pFunc;
			return;
		}
		pfPrev = pfTemp;
		pfTemp = pfTemp->m_pNext;
	}

	// Insert at end.
	pFunc->m_pNext = 0;
	pfPrev->m_pNext = pFunc;
}

void InsertModuleSorted(SModule* pMod)
{
	// Special case, insert at front
	if(g_pModules == 0 
		|| stricmp(g_pModules->m_szName, pMod->m_szName) > 0)
	{
		pMod->m_pNext = g_pModules;
		g_pModules = pMod;		
		return;
	}

	SModule* pmPrev = g_pModules;
	SModule* pmTemp = g_pModules->m_pNext;
	while(pmTemp)
	{
		if(stricmp(pmTemp->m_szName, pMod->m_szName) > 0)
		{
			pMod->m_pNext = pmTemp;
			pmPrev->m_pNext = pMod;
			return;
		}
		pmPrev = pmTemp;
		pmTemp = pmTemp->m_pNext;
	}

	// Insert at end.
	pMod->m_pNext = 0;
	pmPrev->m_pNext = pMod;
}

// Print a message about the last error that occurred.
void PrintLastError()
{
	// Get the message string
	void* pvMsgBuf;
	FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |  
		FORMAT_MESSAGE_FROM_SYSTEM | 
		FORMAT_MESSAGE_IGNORE_INSERTS, 0, GetLastError(), 
		MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
		reinterpret_cast<PTSTR>(&pvMsgBuf),0, 0);

	// Print it.
	fprintf(stderr, "%s\n", pvMsgBuf);
	
	// Free the buffer.
	LocalFree(pvMsgBuf);
}

/*************************************************************************
*   LinkName2Name
*
*************************************************************************/
void
LinkName2Name(
    char* szLinkName,
    char* szName)
{
    /*
     * the link name is expected like ?Function@Class@@Params
     * to be converted to Class::Function
     */

    static CHAR arrOperators[][8] =
    {
        "",
        "",
        "new",
        "delete",
        "=",
        ">>",
        "<<",
        "!",
        "==",
        "!="
    };

    DWORD dwCrr = 0;
    DWORD dwCrrFunction = 0;
    DWORD dwCrrClass = 0;
    DWORD dwSize;
    BOOL  fIsCpp = FALSE;
    BOOL  fHasClass = FALSE;
    BOOL  fIsContructor = FALSE;
    BOOL  fIsDestructor = FALSE;
  
    BOOL  fIsOperator = FALSE;
    DWORD dwOperatorIndex = 0;
	char szFunction[1024];
	char szClass[1024];

    if (*szLinkName == '@')
        szLinkName++;

    dwSize = lstrlen(szLinkName);

    /*
     * skip '?'
     */
    while (dwCrr < dwSize) {
        if (szLinkName[dwCrr] == '?') {

            dwCrr++;
            fIsCpp = TRUE;
        }
        break;
    }

    /*
     * check to see if this is a special function (like ??0)
     */
    if (fIsCpp) {

        if (szLinkName[dwCrr] == '?') {

            dwCrr++;

            /*
             * the next digit should tell as the function type
             */
            if (isdigit(szLinkName[dwCrr])) {

                switch (szLinkName[dwCrr]) {

                case '0':
                    fIsContructor = TRUE;
                    break;
                case '1':
                    fIsDestructor = TRUE;
                    break;
                default:
                    fIsOperator = TRUE;
                    dwOperatorIndex = szLinkName[dwCrr] - '0';
                    break;
                }
                dwCrr++;
            }
        }
    }

    /*
     * get the function name
     */
    while (dwCrr < dwSize) {

        if (szLinkName[dwCrr] != '@') {

            szFunction[dwCrrFunction] = szLinkName[dwCrr];
            dwCrrFunction++;
            dwCrr++;
        } else {
            break;
        }
    }
    szFunction[dwCrrFunction] = '\0';

    if (fIsCpp) {
        /*
         * skip '@'
         */
        if (dwCrr < dwSize) {

            if (szLinkName[dwCrr] == '@') {
                dwCrr++;
            }
        }

        /*
         * get the class name (if any)
         */
        while (dwCrr < dwSize) {

            if (szLinkName[dwCrr] != '@') {

                fHasClass = TRUE;
                szClass[dwCrrClass] = szLinkName[dwCrr];
                dwCrrClass++;
                dwCrr++;
            } else {
                break;
            }
        }
        szClass[dwCrrClass] = '\0';
    }

    /*
     * print the new name
     */
    if (fIsContructor) {
        sprintf(szName, "%s::%s", szFunction, szFunction);
    } else if (fIsDestructor) {
        sprintf(szName, "%s::~%s", szFunction, szFunction);
    } else if (fIsOperator) {
        sprintf(szName, "%s::operator %s", szFunction, arrOperators[dwOperatorIndex]);
    } else if (fHasClass) {
        sprintf(szName, "%s::%s", szClass, szFunction);
    } else {
        sprintf(szName, "%s", szFunction);
    }
}

// Get function forwarding information for
// imported functions.
// This is done by loading the module and sniffing
// its export table.
bool GetForwardFunctions(SModule* pModule)
{
	// Open the DLL module.
	char szFileName[1024];
	char* pstr;

	// Search the path and windows directories for it.
	if(SearchPath(0, pModule->m_szName, 0, 1024, szFileName, &pstr)==0)
		return false;

	HANDLE hFile = CreateFile(szFileName, GENERIC_READ, FILE_SHARE_READ,
		0, OPEN_EXISTING, 0, 0);

	if(hFile == INVALID_HANDLE_VALUE)
	{
		PrintLastError();
		return false;
	}

	HANDLE hMap = CreateFileMapping(hFile, 0, PAGE_READONLY, 0, 0, 0);

	if(hMap == 0)
	{
		PrintLastError();
		return false;
	}

	void* pvFileBase = MapViewOfFile(hMap, FILE_MAP_READ, 0, 0, 0);
	if(!pvFileBase)
	{
		PrintLastError();
		return false;
	}

	// Get the MS-DOS compatible header
	PIMAGE_DOS_HEADER pidh = reinterpret_cast<PIMAGE_DOS_HEADER>(pvFileBase);
	if(pidh->e_magic != IMAGE_DOS_SIGNATURE)
	{
		fprintf(stderr, "File is not a valid executable\n");
		return false;
	}

	// Get the NT header
	PIMAGE_NT_HEADERS pinth = reinterpret_cast<PIMAGE_NT_HEADERS>(
		reinterpret_cast<DWORD>(pvFileBase) + pidh->e_lfanew);

	if(pinth->Signature != IMAGE_NT_SIGNATURE)
	{
		// Not a valid Win32 executable, may be a Win16 or OS/2 exe
		fprintf(stderr, "File is not a valid executable\n");
		return false;
	}


	// Get the other headers
	PIMAGE_FILE_HEADER pifh = &pinth->FileHeader;
	PIMAGE_OPTIONAL_HEADER pioh = &pinth->OptionalHeader;
	PIMAGE_SECTION_HEADER pish = IMAGE_FIRST_SECTION(pinth);

	// If no exports, we're done.
	if(pioh->DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size == 0)
		return true;

	DWORD dwVAImageDir = 
		pioh->DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;

	
	// Locate the section with this image directory.
	for(int i = 0; i < pifh->NumberOfSections; i++)
	{
		if( (dwVAImageDir >= pish[i].VirtualAddress) &&
			(dwVAImageDir < (pish[i].VirtualAddress + pish[i].SizeOfRawData)))
		{
			pish = &pish[i];
			break;
		}
	}

	if(i == pifh->NumberOfSections)
	{
		fprintf(stderr, "Could not locate export directory section\n");
		return false;
	}

	DWORD dwBase = reinterpret_cast<DWORD>(pvFileBase) + 
		pish->PointerToRawData - pish->VirtualAddress;

	PIMAGE_EXPORT_DIRECTORY pied = 
		reinterpret_cast<PIMAGE_EXPORT_DIRECTORY>(dwBase + dwVAImageDir);

	DWORD* pdwNames = reinterpret_cast<DWORD*>(dwBase + 
		pied->AddressOfNames);

	WORD* pwOrdinals = reinterpret_cast<WORD*>(dwBase +
		pied->AddressOfNameOrdinals);

	DWORD* pdwAddresses = reinterpret_cast<DWORD*>(dwBase + 
		pied->AddressOfFunctions);

	for(unsigned hint = 0; hint < pied->NumberOfNames; hint++)
	{
		char* szFunction = reinterpret_cast<PSTR>(dwBase + pdwNames[hint]);

		// Duck out early if this function isn't used in the executable.
		SFunction* pFunc = pModule->m_pFunctions;
		while(pFunc)
		{
			if(strcmp(pFunc->m_szName, szFunction)==0)
				break;

			pFunc = pFunc->m_pNext;
		}

		if(pFunc == 0)
			continue;

		int ordinal = pied->Base + static_cast<DWORD>(pwOrdinals[hint]);
		DWORD dwAddress = pdwAddresses[ordinal-pied->Base];

		// Check if this function has been forwarded to another DLL
		if( ((dwAddress) >= dwVAImageDir) && 
			((dwAddress) < 
			(dwVAImageDir + pioh->DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size)))
		{
			char* szForward = reinterpret_cast<char*>(dwBase + dwAddress);

			pFunc->m_szForward = strdup(szForward);
		}
	}
	UnmapViewOfFile(pvFileBase);

	CloseHandle(hMap);
	CloseHandle(hFile);
	return true;
}

// Look through the import directory, and build a list of all imported functions
bool ParseImportDirectory(PIMAGE_FILE_HEADER pifh, PIMAGE_OPTIONAL_HEADER pioh, 
						  PIMAGE_SECTION_HEADER pish, void* pvFileBase,
						  bool fDelayed)
{	
	// Get which directory we want (normal imports or delayed imports)
	DWORD dwDir = (fDelayed) ? 
			IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT : IMAGE_DIRECTORY_ENTRY_IMPORT;

	// Bail if no imports
	if(pioh->DataDirectory[dwDir].Size == 0)
		return true;
	
	// Locate the import directory in the image.
	PIMAGE_SECTION_HEADER pishImportDirectory = 0;

	DWORD dwVAImageDir = pioh->DataDirectory[dwDir].VirtualAddress;
	for(int i = 0; i < pifh->NumberOfSections; i++)
	{
		if((dwVAImageDir >= pish[i].VirtualAddress) &&
			dwVAImageDir < (pish[i].VirtualAddress + pish[i].SizeOfRawData))
		{
			// This is it.
			pishImportDirectory = &pish[i];
			break;
		}
	}

	if(pishImportDirectory == 0)
	{
		fprintf(stderr, "Cannot locate %s%s\n",((fDelayed) ? "delayed " : ""),
			"import directory section");

		return false;
	}

	// Get the base address for the image.
	DWORD dwBase = reinterpret_cast<DWORD>(pvFileBase) 
		+ pishImportDirectory->PointerToRawData 
		- pishImportDirectory->VirtualAddress;

	// Get the import descriptor array
	PIMAGE_IMPORT_DESCRIPTOR piid = 
		reinterpret_cast<PIMAGE_IMPORT_DESCRIPTOR>(dwBase + dwVAImageDir);

	// Loop through all imported modules
	while(piid->FirstThunk || piid->OriginalFirstThunk)
	{
		SModule* psm = new SModule;
		psm->m_szName = strdup(reinterpret_cast<char*>(dwBase + piid->Name));

		// Check if it is already in the list
		SModule* pTemp = g_pModules;
		while(pTemp)
		{
			if(strcmp(pTemp->m_szName, psm->m_szName) == 0)
				break;

			pTemp = pTemp->m_pNext;
		}

		// If not, insert it
		if(pTemp == 0)
		{
			InsertModuleSorted(psm);
		}
		else
		{
			// Otherwise, get rid of it.
			pTemp = g_pModules;
			while(pTemp)
			{
				if(strcmp(pTemp->m_szName, psm->m_szName)==0)
					break;

				pTemp = pTemp->m_pNext;
			}
			assert(pTemp);
			free(psm->m_szName);
			delete psm;
			psm = pTemp;
		}

		// Get the function imports from this module.
		PIMAGE_THUNK_DATA pitdf = 0;
		PIMAGE_THUNK_DATA pitda = 0;
		
		// Check for MS or Borland format
		if(piid->OriginalFirstThunk)
		{
			// MS format, function array is in original first thunk.
			pitdf = reinterpret_cast<PIMAGE_THUNK_DATA>(dwBase +
				piid->OriginalFirstThunk);

			// If the time stamp is set, the module has been bound,
			// and first thunk is the bound address array.
			if(piid->TimeDateStamp)
			{
				pitda = reinterpret_cast<PIMAGE_THUNK_DATA>(dwBase +
					piid->FirstThunk);
			}
		}
		else
		{
			// Borland format uses first thunk for function array
			pitdf = reinterpret_cast<PIMAGE_THUNK_DATA>(dwBase + 
				piid->FirstThunk);
		}

		while(pitdf->u1.Ordinal)
		{
			SFunction* psf = new SFunction;			

			if(IMAGE_SNAP_BY_ORDINAL(pitdf->u1.Ordinal))
			{
				psf->m_iOrdinal = static_cast<int>(IMAGE_ORDINAL(pitdf->u1.Ordinal));
				psf->m_iHint = -1;

				char szTemp[1024];
				sprintf(szTemp, "Unnamed%6d", psf->m_iOrdinal);
				
				psf->m_szName = strdup(szTemp);
			}
			else
			{
				PIMAGE_IMPORT_BY_NAME piibn = 
					reinterpret_cast<PIMAGE_IMPORT_BY_NAME>(dwBase + 
					(DWORD)(pitdf->u1.AddressOfData));
				char* szName = reinterpret_cast<char*>(piibn->Name);
				char szBuffer[512];
				LinkName2Name(szName, szBuffer);
				psf->m_szName = strdup(szBuffer);				

				psf->m_iOrdinal = -1;
				psf->m_iHint = piibn->Hint;
			}

			psf->m_fDelayedImport = fDelayed;
			psf->m_dwAddress = pitda ? (DWORD) pitda->u1.Function : 
				reinterpret_cast<DWORD>(INVALID_HANDLE_VALUE);
		
			// Do a sorted insert of the function
			InsertFunctionSorted(psm, psf);
			
			// Go to next function
			pitdf++;

			if(pitda)
				pitda++;
		}		

		// Go to next entry
		piid++;		
	}

	return true;
}

bool GetImports(char* szExecutable)
{
	// Open the file
	HANDLE hFile = CreateFile(szExecutable, GENERIC_READ, FILE_SHARE_READ, 0,
		OPEN_EXISTING, 0, 0);
	if(hFile == INVALID_HANDLE_VALUE)
	{
		PrintLastError();
		return false;
	}

	// Map this file into memory
	HANDLE hMap = CreateFileMapping(hFile, 0, PAGE_READONLY, 0, 0, 0);
	if(hMap == 0)
	{
		PrintLastError();
		return false;
	}

	void* pvFileBase;
	pvFileBase = MapViewOfFile(hMap, FILE_MAP_READ, 0, 0, 0);
	if(pvFileBase == 0)
	{
		PrintLastError();
		return false;
	}

	// Get the MS-DOS compatible header
	PIMAGE_DOS_HEADER pidh = reinterpret_cast<PIMAGE_DOS_HEADER>(pvFileBase);
	if(pidh->e_magic != IMAGE_DOS_SIGNATURE)
	{
		fprintf(stderr,"File is not a valid executable\n");
		return false;
	}

	// Get the NT header
	PIMAGE_NT_HEADERS pinth = reinterpret_cast<PIMAGE_NT_HEADERS>(
		reinterpret_cast<DWORD>(pvFileBase) + pidh->e_lfanew);

	if(pinth->Signature != IMAGE_NT_SIGNATURE)
	{
		// Not a valid Win32 executable, may be a Win16 or OS/2 exe
		fprintf(stderr, "File is not a valid executable\n");
		return false;
	}


	// Get the other headers
	PIMAGE_FILE_HEADER pifh = &pinth->FileHeader;
	PIMAGE_OPTIONAL_HEADER pioh = &pinth->OptionalHeader;
	PIMAGE_SECTION_HEADER pish = IMAGE_FIRST_SECTION(pinth);

	// Get normal imports
	if(!ParseImportDirectory(pifh, pioh, pish, pvFileBase, false))
	{
		return false;
	}
	
	// Get delayed imports
	if(!ParseImportDirectory(pifh, pioh, pish, pvFileBase, true))
	{
		return false;
	}

	// Resolve forwarded functions
	SModule* pModule = g_pModules;
	while(pModule)
	{
		GetForwardFunctions(pModule);
		pModule = pModule->m_pNext;
	}

	// We're done with the file.
	if(!UnmapViewOfFile(pvFileBase))
	{
		PrintLastError();
		return false;
	}

	CloseHandle(hMap);
	CloseHandle(hFile);

	return true;
}

// Return true if function name matches search string, false otherwise.
bool MatchFunction(const char* szFunc, const char* szSearch)
{
	if(strcmp(szSearch, "*") == 0)
		return true;

	while(*szSearch != '\0' && *szFunc != '\0')
	{
		// If we get a ?, we don't care and move on to the next
		// character.
		if(*szSearch == '?')
		{
			szSearch++;
			szFunc++;
			continue;
		}

		// If we have a wildcard, move to next search string and search for substring
		if(*szSearch == '*')
		{
			const char* szCurrSearch;
			szSearch++;

			if(*szSearch == '\0')
				return true;

			// Don't change starting point.
			szCurrSearch = szSearch;
			for(;;)
			{
				// We're done if we hit another wildcard
				if(*szCurrSearch == '*' ||
					*szCurrSearch == '?')
				{
					// Update the permanent search position.
					szSearch = szCurrSearch;
					break;
				}
				// At end of both strings, return true.
				if((*szCurrSearch == '\0') && (*szFunc == '\0'))
					return true;

				// We never found it
				if(*szFunc == '\0')						
					return false;

				// If it doesn't match, start over
				if(toupper(*szFunc) != toupper(*szCurrSearch))
				{
					// If mismatch on first character
					// of search string, move to next
					// character in function string.
					if(szCurrSearch == szSearch)
						szFunc++;
					else
						szCurrSearch = szSearch;
				}
				else
				{
					szFunc++;
					szCurrSearch++;
				}
			}
		}
		else
		{
			if(toupper(*szFunc) != toupper(*szSearch))
			{
				return false;
			}

			szFunc++;
			szSearch++;
		}
	}

	if((*szFunc == 0) && ((*szSearch == '\0') || (strcmp(szSearch,"*")==0)))
		return true;
	else
		return false;
}

void PrintModule(SModule* pMod, char* szSearch, bool fVerbose, FILE* pfOut)
{
	bool fModNamePrinted = false;

	SFunction* pFunc = pMod->m_pFunctions;
	while(pFunc)
	{
		if(!MatchFunction(pFunc->m_szName, szSearch))
		{
			pFunc = pFunc->m_pNext;
			continue;
		}

		if(!fModNamePrinted)
		{
			fModNamePrinted = true;
			fprintf(pfOut, "\n%s:\n", pMod->m_szName);

			if(fVerbose)
				fprintf(pfOut, "%-42s%-8s%-5s%-12s%s\n", "Function", "Ordinal", 
					"Hint", "Address", "Delayed");
		}

		if(fVerbose)
		{
			fprintf(pfOut,"%-45s", (pFunc->m_szForward == 0)
				? pFunc->m_szName : pFunc->m_szForward);

			if(pFunc->m_iOrdinal==-1)
				fprintf(pfOut, "%-5s", "N/A");
			else
				fprintf(pfOut, "%-5d", pFunc->m_iOrdinal);					

			if(pFunc->m_iHint == -1)
				fprintf(pfOut, "%-5s", "N/A");
			else
				fprintf(pfOut, "%-5d", pFunc->m_iHint);


			if(pFunc->m_dwAddress == static_cast<DWORD>(-1))
				fprintf(pfOut, "%-12s", "Not Bound");
			else
				fprintf(pfOut, "%-#12x", pFunc->m_dwAddress);

			fprintf(pfOut,"%s\n", pFunc->m_fDelayedImport ? "Yes" : "No");
			
		}
		else
			fprintf(pfOut, "%s\n", pFunc->m_szName);

		pFunc = pFunc->m_pNext;
	}
}

int _cdecl main(int argc, char** argv)
{
	if(argc < 2)
	{
		fprintf(stderr,"Usage: dc executable [/v /s: func /f]\n");
		return 0;
	}

	// Parse command line
	char* szFileName = argv[1];
	if( (strnicmp(szFileName, "/?", 2) == 0) || 
		(strncmp(szFileName, "/h", 2) == 0))
	{
		printf("Usage: dc executable [/v /s: func /f]\n");
		printf("executable:\t\tName of executable file to check\n");
		printf("/v:\t\t\tVerbose\n");
		printf("/s: func\t\tDisplay all functions matching func search string");
		printf(", * and ? allowed.\n");
		printf("/f:\t\t\tDisplay alphabetically by function, not module.\n");
		printf("/o: File\t\tRedirect all output to File.\n");
		return 0;
	}

	FILE* pfOutput = 0;	

	// If no extension, just add .exe
	if(strchr(szFileName, '.') == 0)		
	{
		szFileName = new char[strlen(argv[1]) + 5];
		strcpy(szFileName, argv[1]);
		strcat(szFileName, ".exe");
	}

	bool fVerbose = false;
	bool fUseStdout = true;
	char* szSearch = "*";
	bool fSortByFunction = false;

	// Get flags.
	for(int i = 2; i < argc; i++)
	{
		char* szFlag = argv[i];
		if(stricmp(szFlag, "/v") == 0)
		{
			fVerbose = true;
		}
		else if(strnicmp(szFlag, "/s:", 3) == 0)
		{
			if((i == argc-1) && (strlen(szFlag) <= 3))
			{
				fprintf(stderr,"Missing search string\n");
				return 0;
			}

			if(strlen(szFlag) > 3)
			{
				szSearch = strdup(&szFlag[3]);
			}
			else
			{
				szSearch = argv[i+1];
				i++;
			}
		}
		else if(stricmp(szFlag, "/f") == 0)
		{
			fSortByFunction = true;
		}
		else if( (strnicmp(szFlag, "/h",2) == 0) ||
			(strnicmp(szFlag, "/?",2) == 0))
		{
			printf("Usage: dc executable [/v /s: func /f]\n");
			printf("executable:\t\tName of executable file to check\n");
			printf("/v:\t\t\tVerbose\n");
			printf("/s: func\t\tDisplay all functions matching func search string");
			printf(", * and ? allowed.\n");
			printf("/f:\t\t\tDisplay alphabetically by function, not module.\n");
			printf("/o: File\t\tRedirect all output to File.\n");
			return 0;
		}
		else if(strnicmp(szFlag, "/o:", 3) == 0)
		{
			fUseStdout = false;
			if( (i == argc-1) && (strlen(szFlag) <= 3))
			{
				fprintf(stderr, "Missing output file name\n");
				return 0;
			}
			if(strlen(szFlag) > 3)
			{
				pfOutput = fopen(&szFlag[3], "wt");
			}
			else
			{
				pfOutput = fopen(argv[i+1], "wt");
				i++;
			}
		}
		else
		{
			fprintf(stderr,"Unknown command line option, %s\n", szFlag);
			return 0;
		}

	}

	if(fUseStdout)
		pfOutput = stdout;

	if(!pfOutput)
	{
		fprintf(stderr,"Unable to open output file\n");
		return 0;
	}

	// We wrap this code in a try block, because
	// we map the file into memory.  If the file
	// is invalid and if the pointers in it are garbage,
	// we should get an access violation, which is caught.
	try
	{
		if(!GetImports(szFileName))
		{
			return 0;
		}
	}
	catch(...)
	{
		fprintf(stderr, "Invalid executable file\n");
		return 0;
	}

	if(fSortByFunction)
	{
		// Create a global list of functions
		SModule* pGlobal = new SModule;
		pGlobal->m_szName = "All Imported Functions";

		SModule* pMod = g_pModules;
		while(pMod)
		{
			SFunction* pFunc = pMod->m_pFunctions;
			while(pFunc)
			{
				// Create a copy of this function
				// This is a shallow copy, but
				// it should be ok, since we don't
				// delete the original
				SFunction* pNew = new SFunction;
				memcpy(pNew, pFunc, sizeof(*pFunc));

				InsertFunctionSorted(pGlobal, pNew);				
		
				pFunc = pFunc->m_pNext;
			}
			pMod = pMod->m_pNext;
		}		

		PrintModule(pGlobal, szSearch, fVerbose, pfOutput);
	
	}
	else
	{
		SModule* pMod = g_pModules;
		while(pMod)
		{
			PrintModule(pMod, szSearch, fVerbose, pfOutput);
			pMod = pMod->m_pNext;
		}
	}

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\condbg\ini.hpp ===
//----------------------------------------------------------------------------
//
// .ini file support.
//
// Copyright (C) Microsoft Corporation, 1999-2000.
//
//----------------------------------------------------------------------------

#ifndef _INI_HPP_
#define _INI_HPP_

#define INI_DIR         "Init"
#define INI_FILE        "\\TOOLS.INI"

#define NTINI_DEBUGCHILDREN         1
#define NTINI_DEBUGOUTPUT           2
#define NTINI_STOPFIRST             3
#define NTINI_VERBOSEOUTPUT         4
#define NTINI_LAZYLOAD              5
#define NTINI_TRUE                  6
#define NTINI_FALSE                 7
#define NTINI_USERREG0              8
#define NTINI_USERREG1              9
#define NTINI_USERREG2              10
#define NTINI_USERREG3              11
#define NTINI_USERREG4              12
#define NTINI_USERREG5              13
#define NTINI_USERREG6              14
#define NTINI_USERREG7              15
#define NTINI_USERREG8              16
#define NTINI_USERREG9              17
#define NTINI_STOPONPROCESSEXIT     18
#define NTINI_SXD                   19
#define NTINI_SXE                   20
#define NTINI_INIFILE               21
#define NTINI_DEFAULTEXT            22
#define NTINI_LINES                 23
#define NTINI_SRCOPT                24
#define NTINI_SRCPATHA              25
#define NTINI_INVALID               26
#define NTINI_END                   27

void ReadIniFile(PULONG DebugType);

#endif // #ifndef _INI_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\condbg\conio.cpp ===
//----------------------------------------------------------------------------
//
// Console input and output.
//
// Copyright (C) Microsoft Corporation, 1999-2000.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

#include <stdarg.h>
#include <process.h>

#include "conio.hpp"
#include "engine.hpp"
#include "main.hpp"

#define CONTROL_A   1
#define CONTROL_B   2
#define CONTROL_D   4
#define CONTROL_E   5
#define CONTROL_F   6
#define CONTROL_K   11
#define CONTROL_P   16
#define CONTROL_R   18
#define CONTROL_V   22
#define CONTROL_W   23
#define CONTROL_X   24

HANDLE g_ConInput, g_ConOutput;
HANDLE g_PromptInput;
HANDLE g_AllowInput;

ConInputCallbacks g_ConInputCb;
ConOutputCallbacks g_ConOutputCb;

BOOL g_ConInitialized;
char g_Buffer[MAX_COMMAND];
LONG g_Lines;

HANDLE g_PipeWrite;
OVERLAPPED g_PipeWriteOverlapped;

CRITICAL_SECTION g_InputLock;
BOOL g_InputStarted;

// Input thread interfaces for direct input thread calls.
IDebugClient* g_ConClient;
IDebugControl* g_ConControl;

//----------------------------------------------------------------------------
//
// Default input callbacks implementation, provides IUnknown.
//
//----------------------------------------------------------------------------

STDMETHODIMP
DefInputCallbacks::QueryInterface(
    THIS_
    IN REFIID InterfaceId,
    OUT PVOID* Interface
    )
{
    *Interface = NULL;

    if (IsEqualIID(InterfaceId, IID_IUnknown) ||
        IsEqualIID(InterfaceId, IID_IDebugInputCallbacks))
    {
        *Interface = (IDebugInputCallbacks *)this;
        AddRef();
        return S_OK;
    }
    else
    {
        return E_NOINTERFACE;
    }
}

STDMETHODIMP_(ULONG)
DefInputCallbacks::AddRef(
    THIS
    )
{
    // This class is designed to be static so
    // there's no true refcount.
    return 1;
}

STDMETHODIMP_(ULONG)
DefInputCallbacks::Release(
    THIS
    )
{
    // This class is designed to be static so
    // there's no true refcount.
    return 0;
}

//----------------------------------------------------------------------------
//
// Console input callbacks.
//
//----------------------------------------------------------------------------

STDMETHODIMP
ConInputCallbacks::StartInput(
    THIS_
    IN ULONG BufferSize
    )
{
    if (g_IoMode == IO_NONE)
    {
        // Ignore input requests.
        return S_OK;
    }
    
    EnterCriticalSection(&g_InputLock);

    if (g_ConControl == NULL)
    {
        // If we're not remoted we aren't running a separate input
        // thread so we need to block here until we get some input.
        while (!ConIn(g_Buffer, sizeof(g_Buffer), TRUE))
        {
            ; // Wait.
        }
        g_DbgControl->ReturnInput(g_Buffer);
    }
    else if (ConIn(g_Buffer, sizeof(g_Buffer), FALSE))
    {
        g_ConControl->ReturnInput(g_Buffer);
    }
    else
    {
        g_InputStarted = TRUE;
        
#ifndef KERNEL
        // Wake up the input thread if necessary.
        SetEvent(g_AllowInput);
#endif
    }

    LeaveCriticalSection(&g_InputLock);
    return S_OK;
}

STDMETHODIMP
ConInputCallbacks::EndInput(
    THIS
    )
{
    g_InputStarted = FALSE;
    return S_OK;
}

//----------------------------------------------------------------------------
//
// Default output callbacks implementation, provides IUnknown.
//
//----------------------------------------------------------------------------

STDMETHODIMP
DefOutputCallbacks::QueryInterface(
    THIS_
    IN REFIID InterfaceId,
    OUT PVOID* Interface
    )
{
    *Interface = NULL;

    if (IsEqualIID(InterfaceId, IID_IUnknown) ||
        IsEqualIID(InterfaceId, IID_IDebugOutputCallbacks))
    {
        *Interface = (IDebugOutputCallbacks *)this;
        AddRef();
        return S_OK;
    }
    else
    {
        return E_NOINTERFACE;
    }
}

STDMETHODIMP_(ULONG)
DefOutputCallbacks::AddRef(
    THIS
    )
{
    // This class is designed to be static so
    // there's no true refcount.
    return 1;
}

STDMETHODIMP_(ULONG)
DefOutputCallbacks::Release(
    THIS
    )
{
    // This class is designed to be static so
    // there's no true refcount.
    return 0;
}

//----------------------------------------------------------------------------
//
// Console output callbacks.
//
//----------------------------------------------------------------------------

STDMETHODIMP
ConOutputCallbacks::Output(
    THIS_
    IN ULONG Mask,
    IN PCSTR Text
    )
{
    ConOutStr(Text);
    return S_OK;
}

//----------------------------------------------------------------------------
//
// Functions
//
//----------------------------------------------------------------------------

void
InitializeIo(PCSTR InputFile)
{
    __try
    {
        InitializeCriticalSection(&g_InputLock);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        ErrorExit("Unable to initialize lock\n");
    }
    
    // The input file may not exist so there's no
    // check for failure.
    g_InputFile = fopen(InputFile, "r");
}
    
void
CreateConsole(void)
{
    if (g_ConInitialized)
    {
        return;
    }
    
    // Set this early to prevent an init call from Exit in
    // case an Exit call is made inside this routine.
    g_ConInitialized = TRUE;
    
#ifdef INHERIT_CONSOLE
    
    g_ConInput = GetStdHandle(STD_INPUT_HANDLE);
    g_ConOutput = GetStdHandle(STD_OUTPUT_HANDLE);
    
#else

    SECURITY_ATTRIBUTES Security;
    
    if (!AllocConsole())
    {
        ErrorExit("AllocConsole failed, %d\n", GetLastError());
    }

    ZeroMemory(&Security, sizeof(Security));
    Security.nLength = sizeof(Security);
    Security.bInheritHandle = TRUE;

    g_ConInput = CreateFile( "CONIN$",
                             GENERIC_READ,
                             FILE_SHARE_READ | FILE_SHARE_WRITE,
                             &Security,
                             OPEN_EXISTING,
                             0,
                             NULL
                             );
    if (g_ConInput == INVALID_HANDLE_VALUE)
    {
        ErrorExit("Create CONIN$ failed, %d\n", GetLastError());
    }

    g_ConOutput = CreateFile( "CONOUT$",
                              GENERIC_WRITE | GENERIC_READ,
                              FILE_SHARE_READ | FILE_SHARE_WRITE,
                              &Security,
                              OPEN_EXISTING,
                              0,
                              NULL
                              );
    if (g_ConOutput == INVALID_HANDLE_VALUE)
    {
        ErrorExit("Create CONOUT$ failed, %d\n", GetLastError());
    }
    
#endif

    g_PromptInput = g_ConInput;
}

void
ReadPromptInputChars(PSTR Buffer, ULONG BufferSize)
{
    ULONG Len;
    ULONG Read;
    
    // Reading from another source.  Read character by
    // character until a line is read.
    Len = 0;
    while (Len < BufferSize)
    {
        if (!ReadFile(g_PromptInput, &Buffer[Len], sizeof(Buffer[0]),
                      &Read, NULL) ||
            Read != sizeof(Buffer[0]))
        {
            OutputDebugString("Unable to read input\n");
            ExitDebugger(E_FAIL);
        }
                
        if (Buffer[Len] == '\n')
        {
            InterlockedDecrement(&g_Lines);
            break;
        }

        // Ignore carriage returns.
        if (Buffer[Len] != '\r')
        {
            // Prevent buffer overflow.
            if (Len == BufferSize - 1)
            {
                break;
            }
                    
            Len++;
        }
    }

    Buffer[Len] = '\0';
}

BOOL
CheckForControlCommands(PDEBUG_CLIENT Client, PDEBUG_CONTROL Control,
                        char Char)
{
    HRESULT Hr;
    ULONG OutMask;
    PCHAR DebugAction;
    ULONG EngOptions;
    
    switch(Char)
    {
    case CONTROL_B:
    case CONTROL_X:
        if (!g_RemoteClient && Client != NULL)
        {
            // Force servers to get cleaned up.
            Client->EndSession(DEBUG_END_REENTRANT);
        }
        ExitProcess(S_OK);

    case CONTROL_F:
        //
        // Force a breakin like Ctrl-C would do.
        // The advantage is this will work when kd is being debugged.
        //

        Control->SetInterrupt(DEBUG_INTERRUPT_ACTIVE);
        return TRUE;

    case CONTROL_P:
        // Launch cdb on this debugger.
        char PidStr[32];
        sprintf(PidStr, "\"cdb -p %d\"", GetCurrentProcessId());
        _spawnlp(_P_NOWAIT,
                 "cmd.exe", "/c", "start",
                 "remote", "/s", PidStr, "cdb_pipe",
                 NULL);
        return TRUE;

    case CONTROL_V:
        Client->GetOtherOutputMask(g_DbgClient, &OutMask);
        OutMask ^= DEBUG_OUTPUT_VERBOSE;
        Client->SetOtherOutputMask(g_DbgClient, OutMask);
        Control->SetLogMask(OutMask);
        ConOut("Verbose mode %s.\n",
               (OutMask & DEBUG_OUTPUT_VERBOSE) ? "ON" : "OFF");
        return TRUE;

    case CONTROL_W:
        Hr = Control->OutputVersionInformation(DEBUG_OUTCTL_AMBIENT);
        if (Hr == HRESULT_FROM_WIN32(ERROR_BUSY))
        {
            ConOut("Engine is busy, try again\n");
        }
        else if (Hr != S_OK)
        {
            ConOut("Unable to show version information, 0x%X\n", Hr);
        }
        return TRUE;

#ifdef KERNEL
            
    case CONTROL_A:
        Client->SetKernelConnectionOptions("cycle_speed");
        return TRUE;

    case CONTROL_D:
        Client->GetOtherOutputMask(g_DbgClient, &OutMask);
        OutMask ^= DEBUG_IOUTPUT_KD_PROTOCOL;
        Client->SetOtherOutputMask(g_DbgClient, OutMask);
        Control->SetLogMask(OutMask);
        return TRUE;

    case CONTROL_K:
        //
        // Toggle between the following possibilities-
        //
        // (0) no breakin
        // (1) -b style (same as Control-C up the wire)
        // (2) -d style (stop on first dll load).
        //
        // NB -b and -d could both be on the command line
        // but become mutually exclusive via this method.
        // (Maybe should be a single enum type).
        //

        Control->GetEngineOptions(&EngOptions);
        if (EngOptions & DEBUG_ENGOPT_INITIAL_BREAK)
        {
            //
            // Was type 1, go to type 2.
            //

            EngOptions |= DEBUG_ENGOPT_INITIAL_MODULE_BREAK;
            EngOptions &= ~DEBUG_ENGOPT_INITIAL_BREAK;

            DebugAction = "breakin on first symbol load";
        }
        else if (EngOptions & DEBUG_ENGOPT_INITIAL_MODULE_BREAK)
        {
            //
            // Was type 2, go to type 0.
            //
            
            EngOptions &= ~DEBUG_ENGOPT_INITIAL_MODULE_BREAK;
            DebugAction = "NOT breakin";
        }
        else
        {
            //
            // Was type 0, go to type 1.
            //

            EngOptions |= DEBUG_ENGOPT_INITIAL_BREAK;
            DebugAction = "request initial breakpoint";
        }
        Control->SetEngineOptions(EngOptions);
        ConOut("Will %s at next boot.\n", DebugAction);
        return TRUE;

    case CONTROL_R:
        Client->SetKernelConnectionOptions("resync");
        return TRUE;

#endif // #ifdef KERNEL
    }

    return FALSE;
}

BOOL
ConIn(PSTR Buffer, ULONG BufferSize, BOOL Wait)
{
    if (g_InitialCommand != NULL)
    {
        ConOut("%s: Reading initial command '%s'\n",
               g_DebuggerName, g_InitialCommand);
        strncpy(Buffer, g_InitialCommand, BufferSize);
        Buffer[BufferSize - 1] = 0;
        g_InitialCommand = NULL;
        return TRUE;
    }

    while (g_InputFile && g_InputFile != stdin)
    {
        if (fgets(Buffer, BufferSize, g_InputFile))
        {
            ConOut("%s", Buffer);
            Buffer[strlen(Buffer) - 1] = 0;
            return TRUE;
        }
        else
        {
            fclose(g_InputFile);
            if (g_NextOldInputFile > 0)
            {
                g_InputFile = g_OldInputFiles[--g_NextOldInputFile];
            }
            else
            {
                g_InputFile = stdin;
            }
        }
    }
    if (g_InputFile == NULL)
    {
        g_InputFile = stdin;
    }

    switch(g_IoMode)
    {
    case IO_NONE:
        return FALSE;
        
    case IO_DEBUG:
        if (!Wait)
        {
            return FALSE;
        }
        
        g_NtDllCalls.DbgPrompt("", Buffer,
                               min(BufferSize, MAX_DBG_PROMPT_COMMAND));
        break;

    case IO_CONSOLE:
        ULONG Len;
    
        if (g_PromptInput == g_ConInput)
        {
            if (!Wait)
            {
                return FALSE;
            }
            
            // Reading from the console so we can assume we'll
            // read a line.
            for (;;)
            {
                if (!ReadFile(g_PromptInput, Buffer, BufferSize, &Len, NULL))
                {
                    OutputDebugString("Unable to read input\n");
                    ExitDebugger(E_FAIL);
                }

                // At a minimum a read should have CRLF.  If it
                // doesn't assume that something weird happened
                // and ignore the read.
                if (Len >= 2)
                {
                    break;
                }

                Sleep(50);
            }
        
            // Remove CR LF.
            Len -= 2;
            Buffer[Len] = '\0';

            // Edit out any special characters.
            for (ULONG i = 0; i < Len; i++)
            {
                if (CheckForControlCommands(g_DbgClient, g_DbgControl,
                                            Buffer[i]))
                {
                    Buffer[i] = ' ';
                }
            }
        }
        else
        {
#ifndef KERNEL
            if (g_Lines == 0)
            {
                // Allow the input thread to read the console.
                SetEvent(g_AllowInput);
            }
#endif

            while (g_Lines == 0)
            {
                if (!Wait)
                {
                    return FALSE;
                }
                
                // Wait for the input thread to notify us that
                // a line of input is available.  While we're waiting,
                // let the engine process callbacks provoked by
                // other clients.
                HRESULT Hr = g_DbgClient->DispatchCallbacks(INFINITE);
                if (Hr != S_OK)
                {
                    OutputDebugString("Unable to dispatch callbacks\n");
                    ExitDebugger(Hr);
                }

                // Some other client may have started execution in
                // which case we want to stop waiting for input.
                if (g_ExecStatus != DEBUG_STATUS_BREAK)
                {
#ifndef KERNEL
                    // XXX drewb - Need a way to turn input off.
#endif
                    
                    return FALSE;
                }
            }

            ReadPromptInputChars(Buffer, BufferSize);
        }
        break;
    }

    return TRUE;
}

void
ConOutStr(PCSTR Str)
{
    switch(g_IoMode)
    {
    case IO_NONE:
        // Throw it away.
        break;

    case IO_DEBUG:
        //
        // Send the output to the kernel debugger but note that we
        // want any control C processing to be done locally rather
        // than in the kernel.
        //

        if (g_NtDllCalls.DbgPrint("%s", Str) == STATUS_BREAKPOINT &&
            g_DbgControl != NULL)
        {
            g_DbgControl->SetInterrupt(DEBUG_INTERRUPT_PASSIVE);
        }
        break;

    case IO_CONSOLE:
        if (g_ConOutput != NULL)
        {
            ULONG Written;
            WriteFile(g_ConOutput, Str, strlen(Str), &Written, NULL);
        }
        else
        {
            OutputDebugString(Str);
        }
        break;
    }
}

void
ConOut(PCSTR Format, ...)
{
    DWORD Len;
    va_list Args;
    
    // If no attempt has been made to create a console
    // go ahead and try now.
    if (g_IoMode == IO_CONSOLE && !g_ConInitialized)
    {
        CreateConsole();
    }
    
    va_start(Args, Format);
    Len = _vsnprintf(g_Buffer, sizeof(g_Buffer), Format, Args);
    if (Len == -1)
    {
        Len = sizeof(g_Buffer);
        g_Buffer[sizeof(g_Buffer) - 1] = 0;
    }
    va_end(Args);

    ConOutStr(g_Buffer);
}

void
ExitDebugger(ULONG Code)
{
    if (g_DbgClient != NULL && !g_RemoteClient)
    {
        g_DbgClient->EndSession(DEBUG_END_PASSIVE);
        // Force servers to get cleaned up.
        g_DbgClient->EndSession(DEBUG_END_REENTRANT);
    }

    ExitProcess(Code);
}

void
ErrorExit(PCSTR Format, ...)
{
    if (Format != NULL)
    {
        DWORD Len;
        va_list Args;

        // If no attempt has been made to create a console
        // go ahead and try now.
        if (g_IoRequested == IO_CONSOLE && !g_ConInitialized)
        {
            CreateConsole();
        }
            
        va_start(Args, Format);
        Len = _vsnprintf(g_Buffer, sizeof(g_Buffer), Format, Args);
        va_end(Args);

        if (g_ConOutput != NULL)
        {
            WriteFile(g_ConOutput, g_Buffer, Len, &Len, NULL);
        }
        else
        {
            OutputDebugString(g_Buffer);
        }
    }

#ifndef INHERIT_CONSOLE
    if (g_IoRequested == IO_CONSOLE)
    {
        ConOut("%s: exiting - press enter ---", g_DebuggerName);
        g_InitialCommand = NULL;
        g_InputFile = NULL;
        ConIn(g_Buffer, sizeof(g_Buffer), TRUE);
    }
#endif
    
    ExitDebugger(E_FAIL);
}

DWORD WINAPI
InputThreadLoop(PVOID Param)
{
    DWORD Read;
    BOOL Status;
    UCHAR Char;
    BOOL NewLine = TRUE;
    BOOL SpecialChar = FALSE;
    HANDLE ConIn = g_ConInput;
    HRESULT Hr;
    BOOL ShowInputError = TRUE;

    // Create interfaces usable on this thread.
    if ((Hr = g_DbgClient->CreateClient(&g_ConClient) != S_OK) ||
        (Hr = g_ConClient->QueryInterface(IID_IDebugControl,
                                          (void **)&g_ConControl)) != S_OK)
    {
        ConOut("%s: Unable to create input thread interfaces, 0x%X\n",
               g_DebuggerName, Hr);
        if (!g_RemoteClient)
        {
            // Force servers to get cleaned up.
            g_DbgClient->EndSession(DEBUG_END_REENTRANT);
        }
        ExitProcess(E_FAIL);
    }
    
    //
    // Capture all typed input immediately.
    // Stuff the characters into an anonymous pipe, from which
    // ConIn will read them.
    //

    for (;;)
    {
#ifndef KERNEL
        // The debugger should only read the console when the
        // debuggee isn't running to avoid eating up input 
        // intended for the debuggee.
        if (!g_RemoteClient && NewLine)
        {
            if (WaitForSingleObject(g_AllowInput,
                                    INFINITE) != WAIT_OBJECT_0)
            {
                ConOut("%s: Failed to wait for input window, %d\n",
                       GetLastError());
            }
            
            NewLine = FALSE;
        }
#endif
        
        Status = ReadFile(ConIn, &Char, sizeof(Char), &Read, NULL);
        if (!Status || Read != sizeof(Char))
        {
            if (ShowInputError &&
                GetLastError() != ERROR_OPERATION_ABORTED &&
                GetLastError() != ERROR_IO_PENDING)
            {
                ConOut("%s: Could not read from console, %d\n",
                       g_DebuggerName, GetLastError());
                ShowInputError = FALSE;
            }

            // The most common cause of a console read failure
            // is killing remote with @K.  Give things some
            // time to kill this process.
            // If this is a remote server it's possible that
            // the debugger was run without a valid console
            // and is just being accessed via remoting.
            // Sleep longer in that case since errors will
            // probably always occur.
            Sleep(!g_RemoteClient && g_RemoteOptions != NULL ?
                  1000 : 50);
            continue;
        }

        // We successfully got some input so if it
        // fails later we should show a fresh error.
        ShowInputError = TRUE;
        
        if (CheckForControlCommands(g_ConClient, g_ConControl, Char))
        {
            SpecialChar = TRUE;
            continue;
        }
            
        if (SpecialChar && Char == '\r')
        {
            // If we get a CR immediately after a special
            // char turn it into a space so that it doesn't cause
            // a command repeat.
            Char = ' ';
        }
            
        SpecialChar = FALSE;

        ULONG Len;
        Status = WriteFile(g_PipeWrite, &Char, sizeof(Char), &Len,
                           &g_PipeWriteOverlapped);
        if (!Status && GetLastError() != ERROR_IO_PENDING)
        {
            ConOut("%s: Could not write to pipe, %d\n",
                   g_DebuggerName, GetLastError());
        }
        else if (Char == '\n')
        {
            EnterCriticalSection(&g_InputLock);
            
            InterlockedIncrement(&g_Lines);
                
            // If input is needed send it directly
            // to the engine.
            if (g_InputStarted)
            {
                ReadPromptInputChars(g_Buffer, sizeof(g_Buffer));
                g_ConControl->ReturnInput(g_Buffer);
                g_InputStarted = FALSE;
            }
            else
            {
                // Wake up the engine thread when a line of
                // input is present.
                g_ConClient->ExitDispatch(g_DbgClient);
            }
            
            LeaveCriticalSection(&g_InputLock);
                
            NewLine = TRUE;
        }
    }

    return 0;
}

void
CreateInputThread(void)
{
    HANDLE Thread;
    DWORD ThreadId;
    CHAR PipeName[256];

    if (g_PipeWrite != NULL)
    {
        // Input thread already exists.
        return;
    }

#ifndef KERNEL
    g_AllowInput = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (g_AllowInput == NULL)
    {
        ErrorExit("Unable to create input event, %d\n", GetLastError());
    }
#endif
    
    _snprintf(PipeName,
              sizeof(PipeName),
              "\\\\.\\pipe\\Dbg%d",
              GetCurrentProcessId());
    g_PipeWrite = CreateNamedPipe(PipeName,
                                  PIPE_ACCESS_DUPLEX |
                                  FILE_FLAG_OVERLAPPED,
                                  PIPE_TYPE_BYTE | PIPE_READMODE_BYTE |
                                  PIPE_WAIT,
                                  2,
                                  2000,
                                  2000,
                                  NMPWAIT_WAIT_FOREVER,
                                  NULL);
    if (g_PipeWrite == INVALID_HANDLE_VALUE)
    {
        ErrorExit("Failed to create input pipe, %d\n",
                  GetLastError());
    }

    g_PromptInput = CreateFile(PipeName,
                               GENERIC_READ,
                               FILE_SHARE_READ,
                               NULL,
                               OPEN_EXISTING,
                               FILE_ATTRIBUTE_NORMAL,
                               NULL);
    if (g_PromptInput == INVALID_HANDLE_VALUE)
    {
        ErrorExit("Failed to create read pipe, %d\n",
                  GetLastError());
    }

    Thread = CreateThread(NULL,
                          16000, // THREAD_STACK_SIZE
                          InputThreadLoop,
                          NULL,
                          THREAD_SET_INFORMATION,
                          &ThreadId);
    if (Thread == NULL)
    {
        ErrorExit("Failed to create input thread, %d\n",
                  GetLastError());
    }
    else
    {
        if (!SetThreadPriority(Thread, THREAD_PRIORITY_ABOVE_NORMAL))
        {
            ErrorExit("Failed to raise the input thread priority, %d\n",
                      GetLastError());
        }
    }

    CloseHandle(Thread);

    // Wait for thread initialization.  Callbacks are
    // already registered so we need to dispatch them
    // while waiting.
    while (g_ConControl == NULL)
    {
        g_DbgClient->DispatchCallbacks(50);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\condbg\ini.cpp ===
//----------------------------------------------------------------------------
//
// .ini file support.
//
// Copyright (C) Microsoft Corporation, 1999-2000.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

#include "conio.hpp"
#include "engine.hpp"
#include "ini.hpp"
#include "main.hpp"

#define INI_SECTION_DEFAULT "dbgeng"

static char *(g_Tokens[]) =
{
    "debugchildren",
    "debugoutput",
    "stopfirst",
    "verboseoutput",
    "lazyload",
    "true",
    "false",
    "$u0",
    "$u1",
    "$u2",
    "$u3",
    "$u4",
    "$u5",
    "$u6",
    "$u7",
    "$u8",
    "$u9",
    "stoponprocessexit",
    "sxd",
    "sxe",
    "inifile",
    "setdll",
    "lines",
    "srcopt",
    "srcpath+"
};

int
GetIniToken(
    PSTR* ppsz,
    PSTR limit
    )
{
    PSTR psz = *ppsz;
    int  token;

    while ((*psz == ' ' || *psz == '\t' || *psz == ':') &&
           *psz && psz < limit)
    {
        psz++;
    }
    if (psz >= limit)
    {
        return 0;
    }
    *ppsz = psz;
    while (*psz != ' ' && *psz != '\t' && *psz != ':' && *psz != '\n' &&
           *psz != '\r'&& *psz && psz < limit)
    {
        *psz = (char)tolower(*psz);
        psz++;
    }
    *psz = 0;
    if (**ppsz == '[')
    {
        return NTINI_END;
    }
    
    for (token = 1; token < NTINI_INVALID; token++)
    {
        if (!strcmp(*ppsz, g_Tokens[token-1]))
        {
            break;
        }
    }
    *ppsz = psz + 1;
    return token;
}

BOOL
FindIniSection(FILE* File, PSTR Section)
{
    char Ch, Tst;
    ULONG Index = 0;
    
    Ch = *Section;
    while (Ch && !feof(File))
    {
        Tst = (char)fgetc(File);
        if ((char)tolower(Ch) == (char)tolower(Tst))
        {
            Ch = Section[++Index];
        }
        else
        {
            Ch = Section[Index = 0];
        }
    }

    return Ch == 0;
}

void
ReadIniFile(
    PULONG debugType
    )
{
    FILE*       file;
    char        pszName[256];
    char        rchBuf[_MAX_PATH];
    PSTR        pszMark;
    PSTR        pchCur;
    DWORD       length;
    int         index;
    int         token, value;

    length = GetEnvironmentVariable(INI_DIR,
                                    pszName,
                                    sizeof(pszName) - sizeof(INI_FILE));
    if (length == 0)
    {
        return;
    }

    strcpy(pszName + length, INI_FILE);

    if (!(file = fopen(pszName, "r")))
    {
        return;
    }

    // Look for a section specific to this debugger first.
    if (!FindIniSection(file, g_DebuggerName))
    {
        // Didn't find a specific section, look for
        // the generic debugger settings section.
        rewind(file);
        if (!FindIniSection(file, INI_SECTION_DEFAULT))
        {
            fclose(file);
            return;
        }
    }

    // Now just read the lines in
    do
    {
        PSTR psz = rchBuf;

        if (!fgets(rchBuf, sizeof(rchBuf), file))
        {
            break;
        }

        for (index = 0; rchBuf[index] && rchBuf[index] > 26; index++)
        {
            ;
        }
        rchBuf[index] = 0;

        token = GetIniToken(&psz, rchBuf + sizeof(rchBuf));
        if (token >= NTINI_USERREG0 && token <= NTINI_USERREG9)
        {
            while ((*psz == ' ' || *psz == '\t' || *psz == ':') && *psz)
            {
                psz++;
            }
            if (*psz)
            {
                g_DbgControl->SetTextMacro(token - NTINI_USERREG0, psz);
            }
            continue;
        }

        switch (token)
        {
        case NTINI_SXD:
        case NTINI_SXE:
            ExecuteCmd("sx", *(psz - 2), ' ', psz);
            continue;
        case NTINI_INIFILE:
            g_InitialInputFile = (PSTR)calloc(1, strlen(psz) + 1);
            if (!g_InitialInputFile)
            {
                ErrorExit("%s: Input file memory allocation failed\n",
                          g_DebuggerName);
            }
            strcpy(g_InitialInputFile, psz);
            continue;
        case NTINI_DEFAULTEXT:
            ULONG64 Handle;
            
            g_DbgControl->AddExtension(psz, DEBUG_EXTENSION_AT_ENGINE,
                                       &Handle);
            continue;
        case NTINI_SRCOPT:
            while ((*psz == ' ' || *psz == '\t' || *psz == ':') && *psz)
            {
                psz++;
            }
            ExecuteCmd("l+", 0, 0, psz);
            continue;
        case NTINI_SRCPATHA:
            ExecuteCmd(".srcpath+", 0, ' ', psz);
            continue;
        }

        value = GetIniToken(&psz, rchBuf + sizeof(rchBuf)) != NTINI_FALSE;
        switch (token)
        {
        case NTINI_STOPONPROCESSEXIT:
            if (value)
            {
                g_DbgControl->AddEngineOptions(DEBUG_ENGOPT_FINAL_BREAK);
            }
            else
            {
                g_DbgControl->RemoveEngineOptions(DEBUG_ENGOPT_FINAL_BREAK);
            }
            break;
        case NTINI_DEBUGCHILDREN:
            if (value)
            {
                *debugType = DEBUG_PROCESS;
            }
            break;
        case NTINI_DEBUGOUTPUT:
            if (value)
            {
                g_IoMode = IO_DEBUG;
            }
            else
            {
                g_IoMode = IO_CONSOLE;
            }
            break;
        case NTINI_STOPFIRST:
            if (value)
            {
                g_DbgControl->AddEngineOptions(DEBUG_ENGOPT_INITIAL_BREAK);
            }
            else
            {
                g_DbgControl->RemoveEngineOptions(DEBUG_ENGOPT_INITIAL_BREAK);
            }
            break;
        case NTINI_VERBOSEOUTPUT:
            ULONG OutMask;
            g_DbgClient->GetOutputMask(&OutMask);
            if (value)
            {
                OutMask |= DEBUG_OUTPUT_VERBOSE;
            }
            else
            {
                OutMask &= ~DEBUG_OUTPUT_VERBOSE;
            }
            g_DbgClient->SetOutputMask(OutMask);
            g_DbgControl->SetLogMask(OutMask);
            break;
        case NTINI_LAZYLOAD:
            if (value)
            {
                g_DbgSymbols->AddSymbolOptions(SYMOPT_DEFERRED_LOADS);
            }
            else
            {
                g_DbgSymbols->RemoveSymbolOptions(SYMOPT_DEFERRED_LOADS);
            }
            break;
        case NTINI_LINES:
            if (value)
            {
                g_DbgSymbols->AddSymbolOptions(SYMOPT_LOAD_LINES);
            }
            else
            {
                g_DbgSymbols->RemoveSymbolOptions(SYMOPT_LOAD_LINES);
            }
            break;
        }
    }
    while (token != NTINI_END);
    fclose(file);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\condbg\engine.hpp ===
//----------------------------------------------------------------------------
//
// Debug engine glue.
//
// Copyright (C) Microsoft Corporation, 1999-2000.
//
//----------------------------------------------------------------------------

#ifndef __ENGINE_HPP__
#define __ENGINE_HPP__

// Certain calls are dynamically linked so that the user-mode
// code can be used on Win9x.
struct NTDLL_CALLS
{
    ULONG (__cdecl* DbgPrint)
        (PCH Format, ...);
    ULONG (NTAPI* DbgPrompt)
        (PCH Prompt, PCH Response, ULONG MaximumResponseLength);
};

extern NTDLL_CALLS g_NtDllCalls;

extern BOOL g_Exit;
extern ULONG g_PlatformId;
extern IDebugClient* g_DbgClient;
extern IDebugClient2* g_DbgClient2;
extern IDebugControl* g_DbgControl;
extern IDebugSymbols* g_DbgSymbols;
extern ULONG g_ExecStatus;
extern ULONG g_LastProcessExitCode;

void CreateEngine(PCSTR RemoteOptions);
void ConnectEngine(PCSTR RemoteOptions);
void InitializeSession(void);
BOOL MainLoop(void);

#endif // #ifndef __ENGINE_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\condbg\main.hpp ===
//----------------------------------------------------------------------------
//
// Command-line parsing and main routine.
//
// Copyright (C) Microsoft Corporation, 1999-2001.
//
//----------------------------------------------------------------------------

#ifndef __MAIN_HPP__
#define __MAIN_HPP__

#define MAX_INPUT_NESTING 32

enum
{
    IO_CONSOLE,
    IO_DEBUG,
    IO_NONE,
};

extern BOOL g_RemoteClient;
extern BOOL g_DetachOnExitRequired;
extern BOOL g_DetachOnExitImplied;

extern PSTR g_DumpFile;
extern PSTR g_DumpPageFile;
extern PSTR g_InitialCommand;
extern PSTR g_ConnectOptions;
extern PSTR g_CommandLine;
extern PSTR g_RemoteOptions;
extern PSTR g_ProcessServer;
extern PSTR g_ProcNameToDebug;

extern ULONG g_IoRequested;
extern ULONG g_IoMode;
extern ULONG g_CreateFlags;
extern ULONG g_AttachKernelFlags;
extern ULONG g_PidToDebug;
extern ULONG g_AttachProcessFlags;

extern PSTR g_DebuggerName;
extern PSTR g_InitialInputFile;
extern FILE* g_InputFile;
extern FILE* g_OldInputFiles[];
extern ULONG g_NextOldInputFile;

void ExecuteCmd(PSTR Cmd, char CmdExtra, char Sep, PSTR Args);

#endif // #ifndef __MAIN_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\condbg\pch.cpp ===
//----------------------------------------------------------------------------
//
// Precompiled header.
//
// Copyright (C) Microsoft Corporation, 1999-2000.
//
//----------------------------------------------------------------------------

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include <windows.h>
#include <dbghelp.h>
#define INITGUID
#include <dbgeng.h>

#include <dhhelp.h>
#include <cmnutil.hpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\dbg-common\cab.cpp ===
//----------------------------------------------------------------------------
//
// CAB file manipulation for extracting dump files
// from dump CABs.
//
// Copyright (C) Microsoft Corporation, 2001.
//
//----------------------------------------------------------------------------

#include "pch.hpp"
#pragma hdrstop

#include <io.h>
#include <fcntl.h>
#include <sys\stat.h>
#include <share.h>

#include <fdi.h>

#include "cmnutil.hpp"

#define FDI_HR(Code) MAKE_HRESULT(SEVERITY_ERROR, 0xfd1, ((Code) & 0xffff))

struct FDI_CB_STATE
{
    PSTR DmpFile;
    PSTR DstDir;
    ULONG FileFlags;
    INT_PTR DmpFh;
};

PSTR
FdiPathTail(PSTR Path)
{
    PSTR Tail = strrchr(Path, '\\');
    if (Tail == NULL)
    {
        Tail = strrchr(Path, '/');
        if (Tail == NULL)
        {
            Tail = strrchr(Path, ':');
        }
    }
    return Tail ? Tail + 1 : Path;
}

FNALLOC(FdiAlloc)
{
    return malloc(cb);
}

FNFREE(FdiFree)
{
    free(pv);
}

FNOPEN(FdiOpen)
{
    return _open(pszFile, oflag, pmode);
}

FNREAD(FdiRead)
{
    return _read((int)hf, pv, cb);
}

FNWRITE(FdiWrite)
{
    return _write((int)hf, pv, cb);
}

FNCLOSE(FdiClose)
{
    return _close((int)hf);
}

FNSEEK(FdiSeek)
{
    return _lseek((int)hf, dist, seektype);
}

FNFDINOTIFY(FdiNotify)
{
    FDI_CB_STATE* CbState = (FDI_CB_STATE*)pfdin->pv;
    PSTR Scan;
    
    switch(fdint)
    {
    case fdintCOPY_FILE:
        if (CbState->DmpFh >= 0)
        {
            return 0;
        }
        
        Scan = strrchr(pfdin->psz1, '.');
        if (Scan == NULL ||
            (_stricmp(Scan, ".dmp") != 0 &&
             _stricmp(Scan, ".mdmp") != 0))
        {
            return 0;
        }

        Scan = FdiPathTail(pfdin->psz1);
        if (*CbState->DstDir)
        {
            sprintf(CbState->DmpFile, "%s\\%s", CbState->DstDir, Scan);
        }
        else
        {
            strcpy(CbState->DmpFile, Scan);
        }

        CbState->DmpFh = FdiOpen(CbState->DmpFile,
                                 _O_BINARY | _O_WRONLY | CbState->FileFlags,
                                 _S_IREAD | _S_IWRITE);
        return CbState->DmpFh;

    case fdintCLOSE_FILE_INFO:
        // Leave the file open.
        return TRUE;
    }

    return 0;
}

HRESULT
ExpandDumpCab(PCSTR CabFile, ULONG FileFlags,
              PSTR DmpFile, INT_PTR* DmpFh)
{
    FDI_CB_STATE CbState;
    HFDI Context;
    ERF Err;
    BOOL Status;
    PSTR Env;

    Env = getenv("TMP");
    if (Env == NULL)
    {
        Env = getenv("TEMP");
        if (Env == NULL)
        {
            Env = "";
        }
    }
    
    CbState.DmpFile = DmpFile;
    CbState.DstDir = Env;
    CbState.FileFlags = FileFlags;
    CbState.DmpFh = -1;
    
    Context = FDICreate(FdiAlloc, FdiFree,
                        FdiOpen, FdiRead, FdiWrite, FdiClose, FdiSeek,
                        cpuUNKNOWN, &Err);
    if (Context == NULL)
    {
        return FDI_HR(Err.erfOper);
    }

    Status = FDICopy(Context, "", (PSTR)CabFile, 0,
                     FdiNotify, NULL, &CbState);

    FDIDestroy(Context);

    if (!Status)
    {
        return FDI_HR(Err.erfOper);
    }

    *DmpFh = CbState.DmpFh;
    return (CbState.DmpFh >= 0) ? S_OK : E_NOINTERFACE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\condbg\main.cpp ===
//----------------------------------------------------------------------------
//
// Command-line parsing and main routine.
//
// Copyright (C) Microsoft Corporation, 1999-2001.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

#include "conio.hpp"
#include "engine.hpp"
#include "ini.hpp"
#include "main.hpp"

// Values set from command-line arguments.
BOOL g_RemoteClient;
BOOL g_DetachOnExitRequired;
BOOL g_DetachOnExitImplied;

PSTR g_DumpFile;
PSTR g_DumpPageFile;
PSTR g_InitialCommand;
PSTR g_ConnectOptions;
PSTR g_CommandLine;
PSTR g_RemoteOptions;
PSTR g_ProcessServer;
PSTR g_ProcNameToDebug;

ULONG g_IoRequested = IO_CONSOLE;
ULONG g_IoMode;
ULONG g_CreateFlags = DEBUG_ONLY_THIS_PROCESS;
ULONG g_AttachKernelFlags = DEBUG_ATTACH_KERNEL_CONNECTION;
ULONG g_PidToDebug;
ULONG64 g_EventToSignal;
ULONG g_HistoryLines = 10000;
ULONG g_AttachProcessFlags = DEBUG_ATTACH_DEFAULT;

PSTR g_DebuggerName = DEBUGGER_NAME;
PSTR g_InitialInputFile = "ntsd.ini";
FILE* g_InputFile;
FILE* g_OldInputFiles[MAX_INPUT_NESTING];
ULONG g_NextOldInputFile;

// Command line temporaries.
int g_Argc;
PSTR* g_Argv;
PSTR g_CurArg = "program name";
PSTR g_CmdStr, g_PrevCmdStr;

void
ExecuteCmd(PSTR Cmd, char CmdExtra, char Sep, PSTR Args)
{
    PSTR CmdLine;
    char Buffer[MAX_PATH * 2];

    strcpy(Buffer, Cmd);
    CmdLine = Buffer + strlen(Buffer);
    if (CmdExtra)
    {
        *CmdLine++ = CmdExtra;
    }
    if (Sep)
    {
        *CmdLine++ = Sep;
    }
    strcpy(CmdLine, Args);

    g_DbgControl->Execute(DEBUG_OUTCTL_IGNORE, Buffer,
                          DEBUG_EXECUTE_NOT_LOGGED);
}

char BlanksForPadding[] =
    "                                           "
    "                                           "
    "                                           ";

void
Usage(void)
{
    // Dump an initial debug message about the invalid command
    // line.  This will show up on kd if kd is hooked up,
    // handling the case of an ntsd -d with bad parameters
    // where the console may not be useful.
    OutputDebugStringA(g_DebuggerName);
    OutputDebugStringA(": Bad command line: '");
    OutputDebugStringA(GetCommandLineA());
    OutputDebugStringA("'\n");
    
    int cbPrefix;

    cbPrefix = 7 + strlen(g_DebuggerName);
    ConOut( "usage: %s", g_DebuggerName );

#ifndef KERNEL
    
    ConOut( " [-?] [-2] [-d] [-g] [-G] [-myob] [-lines] [-n] [-o] [-s] [-v] [-w] \n" );
    ConOut( "%.*s [-r BreakErrorLevel]  [-t PrintErrorLevel]\n", cbPrefix, BlanksForPadding );
    ConOut( "%.*s [-hd] [-pd] [-pe] [-pt #] [-pv] [-x | -x{e|d|n|i} <event>] \n", cbPrefix, BlanksForPadding );
    ConOut( "%.*s [-- | -p pid | -pn name | command-line | -z CrashDmpFile]\n", cbPrefix, BlanksForPadding );
    ConOut( "%.*s [-zp CrashPageFile] [-premote transport] [-robp]\n", cbPrefix, BlanksForPadding );

#else // #ifndef KERNEL
    
    ConOut(" [-?] [-b | -x] [-d] [-m] [-myob] [-lines] [-n] [-r] [-s] [-v] \n" );
    ConOut("%.*s [-k ConnectOptions] [-kl] [-kx ConnectOptions]\n", cbPrefix, BlanksForPadding );
    ConOut("%.*s [-z CrashDmpFile] [-zp CrashPageFile]\n", cbPrefix, BlanksForPadding );

#endif

    ConOut("%.*s [-aDllName] [-c \"command\"] [-i ImagePath] [-y SymbolsPath] \n", cbPrefix, BlanksForPadding );
    ConOut("%.*s [-clines #] [-srcpath SourcePath] [-QR \\\\machine] [-wake <pid>]\n", cbPrefix, BlanksForPadding );
    ConOut("%.*s [-remote transport:server=name,portid] [-server transport:portid]\n", cbPrefix, BlanksForPadding );
    ConOut("%.*s [-ses] [-sfce] [-sicv] [-snul] [-noio] [-failinc] [-noshell]\n", cbPrefix, BlanksForPadding );
    ConOut( "\n" );

    cbPrefix = 7;
    ConOut( "where: " );

    ConOut( "-? displays this help text\n" );

#ifndef KERNEL
    ConOut( "%.*scommand-line is the command to run under the debugger\n", cbPrefix, BlanksForPadding );
    ConOut( "%.*s-- is the same as -G -g -o -p -1 -d -pd\n", cbPrefix, BlanksForPadding );
#endif

    ConOut( "%.*s-aDllName sets the default extension DLL\n", cbPrefix, BlanksForPadding );

#ifdef KERNEL
    ConOut("%.*s-b Break into kernel when connection is established\n", cbPrefix, BlanksForPadding);
#endif

    ConOut("%.*s-c executes the following debugger command\n", cbPrefix, BlanksForPadding );
    ConOut("%.*s-clines number of lines of output history retrieved by a remote client\n", cbPrefix, BlanksForPadding );
    ConOut("%.*s-failinc causes incomplete symbol and module loads to fail\n", cbPrefix, BlanksForPadding );

#ifndef KERNEL
    
    ConOut( "%.*s-d sends all debugger output to kernel debugger via DbgPrint\n", cbPrefix, BlanksForPadding );
    ConOut( "%.*s   -d cannot be used with debugger remoting\n", cbPrefix, BlanksForPadding );
    ConOut( "%.*s   -d can only be used when the kernel debugger is enabled\n", cbPrefix, BlanksForPadding );
    ConOut( "%.*s-g ignores initial breakpoint in debuggee\n", cbPrefix, BlanksForPadding );
    ConOut( "%.*s-G ignores final breakpoint at process termination\n", cbPrefix, BlanksForPadding );
    ConOut( "%.*s-hd specifies that the debug heap should not be used\n", cbPrefix, BlanksForPadding );
    ConOut( "%.*s    for created processes.  This only works on Windows Whistler.\n", cbPrefix, BlanksForPadding );
    ConOut( "%.*s-o debugs all processes launched by debuggee\n", cbPrefix, BlanksForPadding );
    ConOut( "%.*s-p pid specifies the decimal process Id to attach to\n", cbPrefix, BlanksForPadding );
    ConOut( "%.*s-pd specifies that the debugger should automatically detach\n", cbPrefix, BlanksForPadding );
    ConOut( "%.*s-pe specifies that any attach should be to an existing debug port\n", cbPrefix, BlanksForPadding );
    ConOut( "%.*s-pn name specifies the name of the process to attach to\n", cbPrefix, BlanksForPadding );
    ConOut( "%.*s-pt # specifies the interrupt timeout\n", cbPrefix, BlanksForPadding );
    ConOut( "%.*s-pv specifies that any attach should be noninvasive\n", cbPrefix, BlanksForPadding );
    ConOut( "%.*s-r specifies the (0-3) error level to break on (SeeSetErrorLevel)\n", cbPrefix, BlanksForPadding );
    ConOut( "%.*s-robp allows breakpoints to be set in read-only memory\n", cbPrefix, BlanksForPadding );
    ConOut( "%.*s-t specifies the (0-3) error level to display (SeeSetErrorLevel)\n", cbPrefix, BlanksForPadding );
    ConOut( "%.*s-w specifies to debug 16 bit applications in a separate VDM\n", cbPrefix, BlanksForPadding );
    ConOut( "%.*s-x sets second-chance break on AV exceptions\n", cbPrefix, BlanksForPadding );
    ConOut( "%.*s-x{e|d|n|i} <event> sets the break status for the specified event\n", cbPrefix, BlanksForPadding );
    ConOut( "%.*s-2 creates a separate console window for debuggee\n", cbPrefix, BlanksForPadding );

#else // #ifndef KERNEL

    ConOut("%.*s-d Breaks into kernel on first module load\n", cbPrefix, BlanksForPadding);
    ConOut("%.*s-k Tell the debugger how to connect to the target\n", cbPrefix, BlanksForPadding);
    ConOut("%.*s   serial:modem connects through a modem\n", cbPrefix, BlanksForPadding);
    ConOut("%.*s   com:port=id,baud=rate connects through a COM port\n", cbPrefix, BlanksForPadding);
    ConOut("%.*s       id: com port name, of the form com2 or \\\\.\\com12 \n", cbPrefix, BlanksForPadding);
    ConOut("%.*s       rate: valid baudrate value, such as 57600 \n", cbPrefix, BlanksForPadding);
    ConOut("%.*s   1394:channel=chan connects over 1394\n", cbPrefix, BlanksForPadding);
    ConOut("%.*s       chan: 1394 channel number, must match channel used at boot\n", cbPrefix, BlanksForPadding);
    ConOut("%.*s-kl Tell the debugger to connect to the local machine\n", cbPrefix, BlanksForPadding);
    ConOut("%.*s-kx Tell the debugger to connect to an eXDI driver\n", cbPrefix, BlanksForPadding);
    ConOut("%.*s-m Serial port is a modem, watch for carrier detect\n", cbPrefix, BlanksForPadding);
    ConOut("%.*s-r Display registers\n", cbPrefix, BlanksForPadding);
    ConOut("%.*s-x Same as -b, except uses an initial command of eb NtGlobalFlag 9;g\n", cbPrefix, BlanksForPadding);
    
#endif // #ifndef KERNEL
    
    ConOut("%.*s-i ImagePath specifies the location of the executables that generated\n", cbPrefix, BlanksForPadding);
    ConOut("%.*s   the fault (see _NT_EXECUTABLE_IMAGE_PATH)\n", cbPrefix, BlanksForPadding);
    ConOut("%.*s-lines requests that line number information be used if present\n", cbPrefix, BlanksForPadding );
    ConOut("%.*s-myob ignores version mismatches in DBGHELP.DLL\n", cbPrefix, BlanksForPadding );
    ConOut("%.*s-n enables verbose output from symbol handler\n", cbPrefix, BlanksForPadding );
    ConOut("%.*s-noio disables all I/O for dedicated remoting servers\n", cbPrefix, BlanksForPadding );
    ConOut("%.*s-noshell disables the .shell (!!) command\n", cbPrefix, BlanksForPadding );
    ConOut("%.*s-QR <\\\\machine> queries for remote servers\n", cbPrefix, BlanksForPadding );
    ConOut("%.*s-s disables lazy symbol loading\n", cbPrefix, BlanksForPadding );
    ConOut("%.*s-ses enables strict symbol loading\n", cbPrefix, BlanksForPadding );
    ConOut("%.*s-sfce fails critical errors encountered during file searching\n", cbPrefix, BlanksForPadding );
    ConOut("%.*s-sicv ignores the CV record when symbol loading\n", cbPrefix, BlanksForPadding );
    ConOut("%.*s-snul disables automatic symbol loading for unqualified names\n", cbPrefix, BlanksForPadding );
    ConOut("%.*s-srcpath <SourcePath> specifies the source search path\n", cbPrefix, BlanksForPadding );
    ConOut("%.*s-v enables verbose output from debugger\n", cbPrefix, BlanksForPadding );
    ConOut("%.*s-wake <pid> wakes up a sleeping debugger and exits\n", cbPrefix, BlanksForPadding );
    ConOut("%.*s-y <SymbolsPath> specifies the symbol search path (see _NT_SYMBOL_PATH)\n", cbPrefix, BlanksForPadding);
    ConOut("%.*s-z <CrashDmpFile> specifies the name of a crash dump file to debug\n", cbPrefix, BlanksForPadding);
    ConOut("%.*s-zp <CrashPageFile> specifies the name of a page.dmp file\n", cbPrefix, BlanksForPadding);
    ConOut("%.*s                    to use with a crash dump\n", cbPrefix, BlanksForPadding);
    ConOut("%.*s-remote lets you connect to a debugger session started with -server \n", cbPrefix, BlanksForPadding);
    ConOut("%.*s        must be the first argument if present\n", cbPrefix, BlanksForPadding);
    ConOut("%.*s        transport: tcp | npipe | ssl | spipe | 1394 | com\n", cbPrefix, BlanksForPadding);
    ConOut("%.*s        name: machine name on which the debug server was created\n", cbPrefix, BlanksForPadding);
    ConOut("%.*s        portid: id of the port the debugger server was created on\n", cbPrefix, BlanksForPadding);
    ConOut("%.*s            for tcp use:  port=<socket port #>\n", cbPrefix, BlanksForPadding);
    ConOut("%.*s            for npipe use:  pipe=<name of pipe>\n", cbPrefix, BlanksForPadding);
    ConOut("%.*s            for 1394 use:  channel=<channel #>\n", cbPrefix, BlanksForPadding);
    ConOut("%.*s            for com use:  port=<COM port>,baud=<baud rate>,\n", cbPrefix, BlanksForPadding);
    ConOut("%.*s                          channel=<channel #>\n", cbPrefix, BlanksForPadding);
    ConOut("%.*s            for ssl and spipe see the documentation\n", cbPrefix, BlanksForPadding);
    ConOut("%.*s        example: ... -remote npipe:server=yourmachine,pipe=foobar \n", cbPrefix, BlanksForPadding);
    ConOut("%.*s-server creates a debugger session other people can connect to\n", cbPrefix, BlanksForPadding);
    ConOut("%.*s        must be the first argument if present\n", cbPrefix, BlanksForPadding);
    ConOut("%.*s        transport: tcp | npipe | ssl | spipe | 1394 | com\n", cbPrefix, BlanksForPadding);
    ConOut("%.*s        portid: id of the port remote users can connect to\n", cbPrefix, BlanksForPadding);
    ConOut("%.*s            for tcp use:  port=<socket port #>\n", cbPrefix, BlanksForPadding);
    ConOut("%.*s            for npipe use:  pipe=<name of pipe>\n", cbPrefix, BlanksForPadding);
    ConOut("%.*s            for 1394 use:  channel=<channel #>\n", cbPrefix, BlanksForPadding);
    ConOut("%.*s            for com use:  port=<COM port>,baud=<baud rate>,\n", cbPrefix, BlanksForPadding);
    ConOut("%.*s                          channel=<channel #>\n", cbPrefix, BlanksForPadding);
    ConOut("%.*s            for ssl and spipe see the documentation\n", cbPrefix, BlanksForPadding);
    ConOut("%.*s        example: ... -server npipe:pipe=foobar \n", cbPrefix, BlanksForPadding);
#ifndef KERNEL
    ConOut( "%.*s-premote transport specifies the process server to connect to\n", cbPrefix, BlanksForPadding );
    ConOut("%.*s       transport arguments are given as with remoting\n", cbPrefix, BlanksForPadding);
#endif
    ConOut("\n");
    
    ConOut("Environment Variables:\n\n");
    ConOut("    _NT_SYMBOL_PATH=[Drive:][Path]\n");
    ConOut("        Specify symbol image path.\n\n");
    ConOut("    _NT_ALT_SYMBOL_PATH=[Drive:][Path]\n");
    ConOut("        Specify an alternate symbol image path.\n\n");
    ConOut("    _NT_DEBUGGER_EXTENSION_PATH=[Drive:][Path]\n");
    ConOut("        Specify a path which should be searched first for extensions dlls\n\n");
    ConOut("    _NT_EXECUTABLE_IMAGE_PATH=[Drive:][Path]\n");
    ConOut("        Specify executable image path.\n\n");
    ConOut("    _NT_SOURCE_PATH=[Drive:][Path]\n");
    ConOut("        Specify source file path.\n\n");
    ConOut("    _NT_DEBUG_LOG_FILE_OPEN=filename\n");
    ConOut("        If specified, all output will be written to this file from offset 0.\n\n");
    ConOut("    _NT_DEBUG_LOG_FILE_APPEND=filename\n");
    ConOut("        If specified, all output will be APPENDed to this file.\n\n");
    ConOut("    _NT_DEBUG_HISTORY_SIZE=size\n");
    ConOut("        Specifies the size of a server's output history in kilobytes\n");

#ifdef KERNEL
    ConOut("    _NT_DEBUG_BUS=1394\n");
    ConOut("        Specifies the type of BUS the kernel debugger will use to communicate with the target\n\n");
    ConOut("    _NT_DEBUG_1394_CHANNEL=number\n");
    ConOut("        Specifies the channel to be used over the 1394 bus\n\n");
    ConOut("    _NT_DEBUG_PORT=com[1|2|...]\n");
    ConOut("        Specify which com port to use. (Default = com1)\n\n");
    ConOut("    _NT_DEBUG_BAUD_RATE=baud rate\n");
    ConOut("        Specify the baud rate used by debugging serial port. (Default = 19200)\n\n");
    ConOut("    _NT_DEBUG_CACHE_SIZE=x\n");
    ConOut("        If specified, gives the number of bytes cached on debugger side\n");
    ConOut("        of kernel debugger serial connection (default is 102400).\n\n");
    ConOut("    KDQUIET=anything\n" );
    ConOut("        If defined, disables obnoxious warning message displayed when user\n");
    ConOut("        presses Ctrl-C\n\n");
#endif

    ConOut("\n");
    ConOut("Control Keys:\n\n");
#ifdef KERNEL
    ConOut("     <Ctrl-A><Enter> Toggle BaudRate\n");
#endif
    ConOut("     <Ctrl-B><Enter> Quit debugger\n");
    ConOut("     <Ctrl-C>        Break into Target\n");
#ifdef KERNEL
    ConOut("     <Ctrl-D><Enter> Display debugger debugging information\n");
    ConOut("     <Ctrl-F><Enter> Force a break into the kernel (same as Ctrl-C)\n");
#else
    ConOut("     <Ctrl-F><Enter> Force a break into debuggee (same as Ctrl-C)\n");
#endif
#ifdef KERNEL
    ConOut("     <Ctrl-K><Enter> Toggle Initial Breakpoint\n");
#endif
    ConOut("     <Ctrl-P><Enter> Debug Current debugger\n");
#ifdef KERNEL
    ConOut("     <Ctrl-R><Enter> Resynchronize target and host\n");
#endif
    ConOut("     <Ctrl-V><Enter> Toggle Verbose mode\n");
    ConOut("     <Ctrl-W><Enter> Print version information\n");
}

PSTR
GetArg(void)
{
    if (g_Argc == 0)
    {
        Usage();
        ErrorExit("Missing argument for %s\n", g_CurArg);
    }

    g_Argc--;
    g_CurArg = *g_Argv;
    g_Argv++;

    // Move forward in the command string to skip over
    // the argument just consumed from argv.  This is complicated
    // by quoting that may be present in the command string
    // that was filtered by the CRT.

    while (*g_CmdStr == ' ' || *g_CmdStr == '\t')
    {
        g_CmdStr++;
    }
    g_PrevCmdStr = g_CmdStr;

    int NumSlash;
    BOOL InQuote = FALSE;
        
    for (;;)
    {
        // Rules: 2N backslashes + " ==> N backslashes and begin/end quote
        // 2N+1 backslashes + " ==> N backslashes + literal "
        // N backslashes ==> N backslashes
        NumSlash = 0;
        while (*g_CmdStr == '\\')
        {
            // Count number of backslashes for use below
            ++g_CmdStr;
            ++NumSlash;
        }
        if (*g_CmdStr == '"')
        {
            // Of 2N backslashes before, start/end quote, otherwise
            // copy literally
            if (NumSlash % 2 == 0)
            {
                if (InQuote)
                {
                    if (g_CmdStr[1] == '"')
                    {
                        // Double quote inside quoted string
                        g_CmdStr++;
                    }
                }

                InQuote = !InQuote;
            }
        }

        // If at end of arg, break loop
        if (*g_CmdStr == 0 ||
            (!InQuote && (*g_CmdStr == ' ' || *g_CmdStr == '\t')))
        {
            break;
        }
            
        ++g_CmdStr;
    }
    
    return g_CurArg;
}

void
ParseCommandLine(int Argc, PCHAR* Argv, PSTR CmdStr)
{
    PSTR Arg;
    BOOL ShowUsage = FALSE;
    ULONG OutMask;
    ULONG SystemErrorBreak;
    ULONG SystemErrorOutput;
    BOOL CheckMoreArgs = FALSE;
    
    g_Argc = Argc;
    g_Argv = Argv;
    g_CmdStr = CmdStr;

    // Skip program name.
    GetArg();

    // Check for remote arguments.  They must
    // be the first arguments if present at all.
    if (g_Argc > 0)
    {
        if (!_strcmpi(*g_Argv, "-remote"))
        {
            GetArg();
            g_RemoteOptions = GetArg();
            g_RemoteClient = TRUE;
            ConnectEngine(g_RemoteOptions);
        }
        else if (!_strcmpi(*g_Argv, "-server"))
        {
            GetArg();
            g_RemoteOptions = GetArg();
        }
    }

    if (g_DbgClient == NULL)
    {
        // We didn't connect to a remote session so create
        // a new local session.
        CreateEngine(g_RemoteOptions);
    }

    if (!g_RemoteClient)
    {
        // Establish defaults.
#ifdef KERNEL
        g_DbgControl->SetEngineOptions(0);
#else
        g_DbgControl->SetEngineOptions(DEBUG_ENGOPT_INITIAL_BREAK |
                                       DEBUG_ENGOPT_FINAL_BREAK);
#endif
        
        g_DbgSymbols->SetSymbolOptions(SYMOPT_CASE_INSENSITIVE |
                                       SYMOPT_UNDNAME |
                                       SYMOPT_NO_CPP |
                                       SYMOPT_OMAP_FIND_NEAREST |
                                       SYMOPT_DEFERRED_LOADS);
    
        // Process the ini file for the base settings.
        ReadIniFile(&g_CreateFlags);
    }

    g_DbgClient->GetOutputMask(&OutMask);
    
    // Now process command line arguments.
    while (g_Argc > 0)
    {
        if (!CheckMoreArgs || !Arg[1])
        {
            Arg = GetArg();

            if (Arg[0] != '-' && Arg[0] != '/')
            {
                // Put argument back.
                g_Argv--;
                g_Argc++;
                g_CmdStr = g_PrevCmdStr;
                break;
            }

            // -remote and -server must be the first
            // arguments.  Check for them later to
            // give a specific error message.
            if (!_strcmpi(Arg, "-remote") ||
                !_strcmpi(Arg, "-server"))
            {
                ConOut("%s: %s must be the first argument\n",
                       g_DebuggerName, Arg);
                ShowUsage = TRUE;
                break;
            }
        }

        CheckMoreArgs = FALSE;
        Arg++;

        switch(tolower(Arg[0]))
        {
        case '?':
            ShowUsage = TRUE;
            break;

        case 'a':
            ULONG64 Handle;
            
            g_DbgControl->AddExtension(Arg + 1, DEBUG_EXTENSION_AT_ENGINE,
                                       &Handle);
            break;

        case 'c':
            if (!_stricmp(Arg, "clines"))
            {
                g_HistoryLines = atoi(GetArg());
            }
            else
            {
                g_InitialCommand = GetArg();
            }
            break;

        case 'f':
            if (!_stricmp(Arg, "failinc"))
            {
                g_DbgControl->
                    AddEngineOptions(DEBUG_ENGOPT_FAIL_INCOMPLETE_INFORMATION);
                g_DbgSymbols->
                    AddSymbolOptions(SYMOPT_EXACT_SYMBOLS);
            }
            else
            {
                goto BadSwitch;
            }
            break;
                
        case 'g':
            if (Arg[0] == 'g')
            {
                g_DbgControl->RemoveEngineOptions(DEBUG_ENGOPT_INITIAL_BREAK);
            }
            else
            {
                g_DbgControl->RemoveEngineOptions(DEBUG_ENGOPT_FINAL_BREAK);
            }
            CheckMoreArgs = TRUE;
            break;

        case 'i':
            g_DbgSymbols->SetImagePath(GetArg());
            break;
            
        case 'l':
            if (_stricmp(Arg, "lines") == 0)
            {
                g_DbgSymbols->AddSymbolOptions(SYMOPT_LOAD_LINES);
                break;
            }
            else
            {
                goto BadSwitch;
            }

        case 'm':
            if (_stricmp(Arg, "myob") == 0)
            {
                g_DbgControl->
                    AddEngineOptions(DEBUG_ENGOPT_IGNORE_DBGHELP_VERSION);
                break;
            }
#ifdef KERNEL
            else if (Arg[1] == 0 && !g_RemoteClient)
            {
                g_ConnectOptions = "com:modem";
            }
#endif
            else
            {
                goto BadSwitch;
            }

        case 'n':
            if (_strnicmp (Arg, "netsyms", 7) == 0)
            {
                //
                // undocumented
                // netsyms:{yes|no} allow or disallow loading symbols from a network path
                //

                Arg += 8;  // skip over ':' as well.
                if (_stricmp (Arg, "no") == 0)
                {
                    g_DbgControl->
                        RemoveEngineOptions(DEBUG_ENGOPT_ALLOW_NETWORK_PATHS);
                    g_DbgControl->
                        AddEngineOptions(DEBUG_ENGOPT_DISALLOW_NETWORK_PATHS);
                }
                else if (_stricmp (Arg, "yes") == 0)
                {
                    g_DbgControl->RemoveEngineOptions
                        (DEBUG_ENGOPT_DISALLOW_NETWORK_PATHS);
                    g_DbgControl->
                        AddEngineOptions(DEBUG_ENGOPT_ALLOW_NETWORK_PATHS);
                }
                break;
            }
            else if (g_RemoteOptions != NULL && !g_RemoteClient &&
                     !_stricmp(Arg, "noio"))
            {
                g_IoRequested = IO_NONE;
            }
            else if (!_stricmp(Arg, "noshell"))
            {
                g_DbgControl->
                    AddEngineOptions(DEBUG_ENGOPT_DISALLOW_SHELL_COMMANDS);
            }
            else if (Arg[1] == 0)
            {
                g_DbgSymbols->AddSymbolOptions(SYMOPT_DEBUG);
                break;
            }
            else
            {
                goto BadSwitch;
            }
            break;

        case 'q':
            if (Arg[0] != 'Q' || Arg[1] != 'R')
            {
                goto BadSwitch;
            }

            Arg = GetArg();
            ConOut("Servers on %s:\n", Arg);
            if (g_DbgClient->OutputServers(DEBUG_OUTCTL_ALL_CLIENTS, Arg,
                                           DEBUG_SERVERS_ALL) != S_OK)
            {
                ConOut("Unable to query %s\n", Arg);
            }
            ExitDebugger(0);

        case 's':
            if (!_stricmp(Arg, "srcpath"))
            {
                g_DbgSymbols->SetSourcePath(GetArg());
            }
            else if (!_stricmp(Arg, "ses"))
            {
                g_DbgSymbols->AddSymbolOptions(SYMOPT_EXACT_SYMBOLS);
            }
            else if (!_stricmp(Arg, "sfce"))
            {
                g_DbgSymbols->AddSymbolOptions(SYMOPT_FAIL_CRITICAL_ERRORS);
            }
            else if (!_stricmp(Arg, "sicv"))
            {
                g_DbgSymbols->AddSymbolOptions(SYMOPT_IGNORE_CVREC);
            }
            else if (!_stricmp(Arg, "snul"))
            {
                g_DbgSymbols->AddSymbolOptions(SYMOPT_NO_UNQUALIFIED_LOADS);
            }
            else
            {
                g_DbgSymbols->RemoveSymbolOptions(SYMOPT_DEFERRED_LOADS);
                CheckMoreArgs = TRUE;
            }
            break;

        case 'v':
            OutMask |= DEBUG_OUTPUT_VERBOSE;
            g_DbgClient->SetOutputMask(OutMask);
            g_DbgControl->SetLogMask(OutMask);
            CheckMoreArgs = TRUE;
            break;

        case 'y':
            g_DbgSymbols->SetSymbolPath(GetArg());
            break;

        case 'z':
            if (g_RemoteClient)
            {
                goto BadSwitch;
            }

            if (Arg[1] == 'p')
            {
                g_DumpPageFile = GetArg();
            }
            else if (Arg[1])
            {
                goto BadSwitch;
            }
            else
            {
                g_DumpFile = GetArg();
            }
            break;
            
#ifndef KERNEL
        case '2':
            if (g_RemoteClient)
            {
                goto BadSwitch;
            }
            
            g_CreateFlags |= CREATE_NEW_CONSOLE;
            break;

        case '-':
            if (g_RemoteClient)
            {
                goto BadSwitch;
            }
            
            // '--' is the equivalent of -G -g -o -p -1 -netsyms:no -d -pd

            if (g_PidToDebug || g_ProcNameToDebug != NULL)
            {
                ErrorExit("%s: attach process redefined\n", g_DebuggerName);
            }

            g_CreateFlags |= DEBUG_PROCESS;
            g_CreateFlags &= ~DEBUG_ONLY_THIS_PROCESS;
            g_DbgSymbols->AddSymbolOptions(SYMOPT_DEFERRED_LOADS);
            g_DbgControl->RemoveEngineOptions(DEBUG_ENGOPT_INITIAL_BREAK |
                                              DEBUG_ENGOPT_FINAL_BREAK);
            g_IoRequested = IO_DEBUG;
            g_PidToDebug = CSRSS_PROCESS_ID;
            g_ProcNameToDebug = NULL;
            g_DetachOnExitImplied = TRUE;
            break;

        case 'd':
            if (g_RemoteOptions != NULL)
            {
                ErrorExit("%s: Cannot use -d with debugger remoting\n",
                          g_DebuggerName);
            }
            
            g_IoRequested = IO_DEBUG;
            CheckMoreArgs = TRUE;
            break;

        case 'e':
            //
            // undocumented
            //

            if (g_RemoteClient)
            {
                goto BadSwitch;
            }
            
            if (g_EventToSignal)
            {
                ErrorExit("%s: Event to signal redefined\n", g_DebuggerName);
            }

            // event to signal takes decimal argument
            Arg = GetArg();
            sscanf(Arg, "%I64d", &g_EventToSignal);
            if (!g_EventToSignal)
            {
                ErrorExit("%s: bad EventToSignal '%s'\n",
                          g_DebuggerName, Arg);
            }
            g_DbgControl->SetNotifyEventHandle(g_EventToSignal);
            break;

        case 'h':
            if (Arg[1] == 'd')
            {
                g_CreateFlags |= DEBUG_CREATE_PROCESS_NO_DEBUG_HEAP;
            }
            else
            {
                goto BadSwitch;
            }
            break;
            
        case 'o':
            if (g_RemoteClient)
            {
                goto BadSwitch;
            }
            
            g_CreateFlags |= DEBUG_PROCESS;
            g_CreateFlags &= ~DEBUG_ONLY_THIS_PROCESS;
            CheckMoreArgs = TRUE;
            break;

        case 'p':
            if (g_RemoteClient)
            {
                goto BadSwitch;
            }

            if (!_stricmp(Arg, "premote"))
            {
                g_ProcessServer = GetArg();
                break;
            }
            else if (Arg[1] == 'd')
            {
                g_DetachOnExitRequired = TRUE;
                break;
            }
            else if (Arg[1] == 'e')
            {
                g_AttachProcessFlags = DEBUG_ATTACH_EXISTING;
                break;
            }
            else if (Arg[1] == 't')
            {
                g_DbgControl->SetInterruptTimeout(atoi(GetArg()));
                break;
            }
            else if (Arg[1] == 'v')
            {
                g_AttachProcessFlags = DEBUG_ATTACH_NONINVASIVE;
                break;
            }
                
            if (g_PidToDebug || g_ProcNameToDebug != NULL)
            {
                ErrorExit("%s: attach process redefined\n", g_DebuggerName);
            }

            if (Arg[1] == 'n')
            {
                // Process name.
                g_ProcNameToDebug = GetArg();
                g_PidToDebug = 0;
            }
            else
            {
                // pid debug takes decimal argument
                g_ProcNameToDebug = NULL;
                
                Arg = GetArg();
                if (Arg[0] == '-' && Arg[1] == '1' && Arg[2] == 0)
                {
                    g_IoRequested = IO_DEBUG;
                    g_PidToDebug = CSRSS_PROCESS_ID;
                }
                else
                {
                    PSTR End;
                    
                    if (Arg[0] == '0' &&
                        (Arg[1] == 'x' || Arg[1] == 'X'))
                    {
                        g_PidToDebug = strtoul(Arg, &End, 0);
                    }
                    else
                    {
                        g_PidToDebug = strtoul(Arg, &End, 10);
                    }
                }

                if (!g_PidToDebug)
                {
                    ErrorExit("%s: bad pid '%s'\n", g_DebuggerName, Arg);
                }
            }
            break;

        case 'r':
            if (!_stricmp(Arg, "robp"))
            {
                g_DbgControl->
                    AddEngineOptions(DEBUG_ENGOPT_ALLOW_READ_ONLY_BREAKPOINTS);
                break;
            }
            else if (Arg[1] != 0)
            {
                goto BadSwitch;
            }
            
            // Rip flags takes single-char decimal argument
            Arg = GetArg();
            SystemErrorBreak = strtoul(Arg, &Arg, 10);
            if (SystemErrorBreak > 3)
            {
                ErrorExit("%s: bad Rip level '%ld'\n",
                          g_DebuggerName, SystemErrorBreak);
                SystemErrorBreak = 0;
            }
            else
            {
                SystemErrorOutput = SystemErrorBreak;
            }
            g_DbgControl->SetSystemErrorControl(SystemErrorOutput,
                                                SystemErrorBreak);
            break;

        case 't':
            // Rip flags takes single-char decimal argument
            Arg = GetArg();
            SystemErrorOutput = strtoul(Arg, &Arg, 10);
            if (SystemErrorOutput > 3)
            {
                ErrorExit("%s: bad Rip level '%ld'\n",
                          g_DebuggerName, SystemErrorOutput);
                SystemErrorOutput = 0;
            }
            g_DbgControl->SetSystemErrorControl(SystemErrorOutput,
                                                SystemErrorBreak);
            break;

        case 'x':
            if (Arg[1] == 0)
            {
                g_DbgControl->Execute(DEBUG_OUTCTL_IGNORE, "sxd av",
                                      DEBUG_EXECUTE_NOT_LOGGED);
            }
            else
            {
                // Turn "-x. arg" into "sx. arg" and execute
                // it to update the engine state.
                ExecuteCmd("sx", Arg[1], ' ', GetArg());
            }
            break;

        case 'w':
            if (!_stricmp(Arg, "wake"))
            {
                ULONG Pid = strtoul(GetArg(), &Arg, 10);
                if (!SetPidEvent(Pid, OPEN_EXISTING))
                {
                    ErrorExit("Process %d is not a sleeping debugger\n", Pid);
                }
                else
                {
                    ExitDebugger(0);
                }
            }
            
            if (g_RemoteClient)
            {
                goto BadSwitch;
            }
            
            g_CreateFlags |= CREATE_SEPARATE_WOW_VDM;
            CheckMoreArgs = TRUE;
            break;

#else // #ifndef KERNEL
            
        case 'b':
            g_DbgControl->AddEngineOptions(DEBUG_ENGOPT_INITIAL_BREAK);
            if (g_RemoteClient)
            {
                // The engine may already be waiting so just ask
                // for a breakin immediately.
                g_DbgControl->SetInterrupt(DEBUG_INTERRUPT_ACTIVE);
            }
            CheckMoreArgs = TRUE;
            break;

        case 'd':
            g_DbgControl->AddEngineOptions(DEBUG_ENGOPT_INITIAL_MODULE_BREAK);
            CheckMoreArgs = TRUE;
            break;

        case 'k':
            if (tolower(Arg[1]) == 'l')
            {
                g_AttachKernelFlags = DEBUG_ATTACH_LOCAL_KERNEL;
            }
            else if (tolower(Arg[1]) == 'x')
            {
                g_AttachKernelFlags = DEBUG_ATTACH_EXDI_DRIVER;
                g_ConnectOptions = GetArg();
            }
            else
            {
                g_ConnectOptions = GetArg();
            }
            break;

        case 'p':
            goto BadSwitch;
                
        case 'r':
            OutMask ^= DEBUG_OUTPUT_PROMPT_REGISTERS;
            g_DbgClient->SetOutputMask(OutMask);
            g_DbgControl->SetLogMask(OutMask);
            CheckMoreArgs = TRUE;
            break;
                
        case 'w':
            if (!_stricmp(Arg, "wake"))
            {
                ULONG Pid = strtoul(GetArg(), &Arg, 10);
                if (!SetPidEvent(Pid, OPEN_EXISTING))
                {
                    ErrorExit("Process %d is not a sleeping debugger\n", Pid);
                }
                else
                {
                    ExitDebugger(0);
                }
            }
            goto BadSwitch;
            
        case 'x':
            g_DbgControl->AddEngineOptions(DEBUG_ENGOPT_INITIAL_BREAK);
            g_InitialCommand = "eb nt!NtGlobalFlag 9;g";
            CheckMoreArgs = TRUE;
            break;

#endif // #ifndef KERNEL

        default:
        BadSwitch:
            ConOut("%s: Invalid switch '%c'\n", g_DebuggerName, Arg[0]);
            ShowUsage = TRUE;
            break;
        }
    }

#ifndef KERNEL
    if (g_RemoteClient)
    {
        if (g_Argc > 0)
        {
            ShowUsage = TRUE;
        }
    }
    else if (g_Argc > 0)
    {
        // Assume remaining arguments are a process execution
        // command line.
        g_CommandLine = g_CmdStr;
    }
    else if ((g_PidToDebug == 0) && (g_ProcNameToDebug == NULL) &&
             (g_DumpFile == NULL))
    {
        // User-mode debuggers require a dump file,
        // process attachment or created process.
        ShowUsage = TRUE;
    }
#else
    if (g_Argc > 0)
    {
        // Kernel debuggers can't start user-mode processes.
        ShowUsage = TRUE;
    }
#endif
    
    if (ShowUsage)
    {
        Usage();
        ErrorExit(NULL);
    }
}

int
__cdecl
main (
    int Argc,
    PCHAR* Argv
    )
{
    HRESULT Hr;

    MakeHelpFileName("debugger.chm");
    
    ParseCommandLine(Argc, Argv, GetCommandLine());

    InitializeIo(g_InitialInputFile);

#ifndef KERNEL
    if (g_DumpFile == NULL)
    {
        // Increase the priority for live debugging so
        // that the debugger is responsive for break-in.
        SetPriorityClass(GetCurrentProcess(), HIGH_PRIORITY_CLASS);
    }
#endif
    
    g_IoMode = g_IoRequested;
    switch(g_IoMode)
    {
    case IO_DEBUG:
        if (g_DbgClient2 != NULL)
        {
            if (g_DbgClient2->IsKernelDebuggerEnabled() != S_OK)
            {
                Usage();
                ErrorExit(NULL);
            }
        }
        
        SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL);
        break;

    case IO_CONSOLE:
        CreateConsole();
        break;
    }

    // XXX drewb - Win9x doesn't support named pipes so
    // the separate input thread currently can't be used.
    // This makes remoting work very poorly and so should
    // be fixed by creating a simple internal pipe implementation.
    if (g_PlatformId == VER_PLATFORM_WIN32_NT)
    {
        if (g_IoMode != IO_NONE)
        {
            // Don't bother creating a separate thread for non-remoted
            // ntsd and cdb.  This avoids problems with .remote
            // and multiple threads reading the console.
#ifndef KERNEL
            if (g_RemoteOptions != NULL)
#endif
            {
                CreateInputThread();
            }
        }
    }
    else if (g_RemoteOptions != NULL)
    {
        ErrorExit("Remoting is not currently supported on Win9x\n");
    }
    
    if (!g_RemoteClient)
    {
        if (g_RemoteOptions)
        {
            ConOut("Server started with '%s'\n", g_RemoteOptions);
        }
        
        InitializeSession();
    }
    else
    {
        ConOut("Connected to server with '%s'\n", g_RemoteOptions);
        // Use a heuristic of 45 characters per line.
        g_DbgClient->ConnectSession(DEBUG_CONNECT_SESSION_DEFAULT,
                                    g_HistoryLines * 45);
    }

    ULONG Code = S_OK;
    
    if (MainLoop())
    {
        // The session ended so return the exit code of the
        // last process that exited.
        Code = g_LastProcessExitCode;
    }
    
    ExitDebugger(Code);
    return Code;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\dbg-common\cmnutil.cpp ===
//----------------------------------------------------------------------------
//
// General utility routines.
//
// Copyright (C) Microsoft Corporation, 2000-2001.
//
//----------------------------------------------------------------------------

#include "pch.hpp"
#include <common.ver>

#include <wininet.h>
#include <dbghelp.h>

#include "cmnutil.hpp"

#ifdef NT_NATIVE
#include "ntnative.h"
#endif

// Formatted codes are pretty small and there's usually only
// one in a message.
#define MAX_FORMAT_CODE_STRINGS 2
#define MAX_FORMAT_CODE_BUFFER 64

char g_FormatCodeBuffer[MAX_FORMAT_CODE_STRINGS][MAX_FORMAT_CODE_BUFFER];
ULONG g_NextFormatCodeBuffer = MAX_FORMAT_CODE_STRINGS;

// Security attributes with a NULL DACL to explicitly
// allow anyone access.
PSECURITY_DESCRIPTOR g_AllAccessSecDesc;
SECURITY_ATTRIBUTES g_AllAccessSecAttr;

PSTR
FormatStatusCode(HRESULT Status)
{
    PSTR Buf;
    DWORD Len = 0;

    g_NextFormatCodeBuffer = (g_NextFormatCodeBuffer + 1) &
        (MAX_FORMAT_CODE_STRINGS - 1);
    Buf = g_FormatCodeBuffer[g_NextFormatCodeBuffer];

    if (Status & FACILITY_NT_BIT)
    {
        sprintf(Buf, "NTSTATUS 0x%08X", Status & ~FACILITY_NT_BIT);
    }
    else if (HRESULT_FACILITY(Status) == FACILITY_WIN32)
    {
        sprintf(Buf, "Win32 error %d", HRESULT_CODE(Status));
    }
    else
    {
        sprintf(Buf, "HRESULT 0x%08X", Status);
    }

    return Buf;
}

#ifndef NT_NATIVE

// Generally there's only one status per output message so
// only keep space for a small number of strings.  Each string
// can be verbose plus it can contain inserts which may be large
// so each string buffer needs to be roomy.
#define MAX_FORMAT_STATUS_STRINGS 2
#define MAX_FORMAT_STATUS_BUFFER 512

char g_FormatStatusBuffer[MAX_FORMAT_STATUS_STRINGS][MAX_FORMAT_STATUS_BUFFER];
ULONG g_NextFormatStatusBuffer = MAX_FORMAT_STATUS_STRINGS;

PSTR
FormatStatusArgs(HRESULT Status, PVOID Arguments)
{
    PSTR Buf;
    DWORD Len = 0;

    g_NextFormatStatusBuffer = (g_NextFormatStatusBuffer + 1) &
        (MAX_FORMAT_STATUS_STRINGS - 1);
    Buf = g_FormatStatusBuffer[g_NextFormatStatusBuffer];

    // If the caller passed in arguments allow format inserts
    // to be processed.
    if (Arguments != NULL)
    {
        Len = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM |
                            FORMAT_MESSAGE_ARGUMENT_ARRAY, NULL, Status,
                            0, Buf, MAX_FORMAT_STATUS_BUFFER,
                            (va_list*)Arguments);
    }

    // If no arguments were passed or FormatMessage failed when
    // used with arguments try it without format inserts.
    if (Len == 0)
    {
        Len = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM |
                            FORMAT_MESSAGE_IGNORE_INSERTS, NULL, Status,
                            0, Buf, MAX_FORMAT_STATUS_BUFFER, NULL);
    }
    
    if (Len > 0)
    {
        while (Len > 0 && isspace(Buf[Len - 1]))
        {
            Buf[--Len] = 0;
        }
    }

    if (Len > 0)
    {
        return Buf;
    }
    else
    {
        return "<Unable to get error code text>";
    }
}

BOOL
InstallAsAeDebug(PCSTR Append)
{
    PCSTR KeyName;
    HKEY Key;
    LONG Status;
    OSVERSIONINFO OsVer;
    char Value[MAX_PATH * 2];

    OsVer.dwOSVersionInfoSize = sizeof(OsVer);
    if (!GetVersionEx(&OsVer))
    {
        return FALSE;
    }

    if (GetModuleFileName(NULL, Value, sizeof(Value) - 16) == 0)
    {
        return FALSE;
    }

    strcat(Value, " -p %ld -e %ld -g");
    if (Append != NULL)
    {
        if (strlen(Value) + strlen(Append) + 2 > sizeof(Value))
        {
            return FALSE;
        }
        
        strcat(Value, " ");
        strcat(Value, Append);
    }
    
    KeyName = OsVer.dwPlatformId == VER_PLATFORM_WIN32_NT ?
        "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\AeDebug" :
        "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\AeDebug";
        
    Status = RegOpenKeyEx(HKEY_LOCAL_MACHINE, KeyName,
                          0, KEY_READ | KEY_WRITE, &Key);
    if (Status == ERROR_SUCCESS)
    {
        Status = RegSetValueEx(Key, "Debugger", 0, REG_SZ,
                               (PUCHAR)Value, strlen(Value) + 1);
        RegCloseKey(Key);
    }

    return Status == ERROR_SUCCESS;
}

HANDLE
CreatePidEvent(ULONG Pid, ULONG CreateOrOpen)
{
    HANDLE Event;
    char Name[32];

    sprintf(Name, "DbgEngEvent_%08X", Pid);
    Event = CreateEvent(NULL, FALSE, FALSE, Name);
    if (Event != NULL)
    {
        if (GetLastError() == ERROR_ALREADY_EXISTS)
        {
            if (CreateOrOpen == CREATE_NEW)
            {
                CloseHandle(Event);
                Event = NULL;
            }
        }
        else if (CreateOrOpen == OPEN_EXISTING)
        {
            CloseHandle(Event);
            Event = NULL;
        }
    }
    return Event;
}

BOOL
SetPidEvent(ULONG Pid, ULONG CreateOrOpen)
{
    BOOL Status;
    HANDLE Event = CreatePidEvent(Pid, CreateOrOpen);
    if (Event != NULL)
    {
        Status = SetEvent(Event);
        CloseHandle(Event);
    }
    else
    {
        Status = FALSE;
    }
    return Status;
}

HRESULT
EnableDebugPrivilege(void)
{
    OSVERSIONINFO OsVer;

    OsVer.dwOSVersionInfoSize = sizeof(OsVer);
    if (!GetVersionEx(&OsVer))
    {
        return WIN32_LAST_STATUS();
    }
    if (OsVer.dwPlatformId != VER_PLATFORM_WIN32_NT)
    {
        return S_OK;
    }

    HRESULT           Status = S_OK;
    HANDLE            Token;
    PTOKEN_PRIVILEGES NewPrivileges;
    BYTE              OldPriv[1024];
    ULONG             cbNeeded;
    LUID              LuidPrivilege;
    static            s_PrivilegeEnabled = FALSE;

    if (s_PrivilegeEnabled)
    {
        return S_OK;
    }

    //
    // Make sure we have access to adjust and to get the
    // old token privileges
    //
    if (!OpenProcessToken(GetCurrentProcess(),
                          TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                          &Token))
    {
        Status = WIN32_LAST_STATUS();
        goto EH_Exit;
    }

    cbNeeded = 0;

    //
    // Initialize the privilege adjustment structure
    //

    LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &LuidPrivilege);

    NewPrivileges = (PTOKEN_PRIVILEGES)
        calloc(1, sizeof(TOKEN_PRIVILEGES) +
               (1 - ANYSIZE_ARRAY) * sizeof(LUID_AND_ATTRIBUTES));
    if (NewPrivileges == NULL)
    {
        Status = E_OUTOFMEMORY;
        goto EH_Token;
    }

    NewPrivileges->PrivilegeCount = 1;
    NewPrivileges->Privileges[0].Luid = LuidPrivilege;
    NewPrivileges->Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    //
    // Enable the privilege
    //

    if (!AdjustTokenPrivileges( Token,
                                FALSE,
                                NewPrivileges,
                                sizeof(OldPriv),
                                (PTOKEN_PRIVILEGES)OldPriv,
                                &cbNeeded ))
    {
        //
        // If the stack was too small to hold the privileges
        // then allocate off the heap
        //
        if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
        {
            PBYTE pbOldPriv;
            BOOL Adjusted;

            pbOldPriv = (PUCHAR)calloc(1, cbNeeded);
            if (pbOldPriv == NULL)
            {
                Status = E_OUTOFMEMORY;
                goto EH_NewPriv;
            }

            Adjusted = AdjustTokenPrivileges( Token,
                                              FALSE,
                                              NewPrivileges,
                                              cbNeeded,
                                              (PTOKEN_PRIVILEGES)pbOldPriv,
                                              &cbNeeded );

            free(pbOldPriv);

            if (!Adjusted)
            {
                Status = WIN32_LAST_STATUS();
            }
        }
    }

 EH_NewPriv:
    free(NewPrivileges);
 EH_Token:
    CloseHandle(Token);
 EH_Exit:
    if (Status == S_OK)
    {
        s_PrivilegeEnabled = TRUE;
    }
    return Status;
}

#else // #ifndef NT_NATIVE

HRESULT
EnableDebugPrivilege(void)
{
    HRESULT           Status = S_OK;
    HANDLE            Token;
    PTOKEN_PRIVILEGES NewPrivileges;
    BYTE              OldPriv[1024];
    ULONG             cbNeeded;
    LUID              LuidPrivilege;
    NTSTATUS          NtStatus;
    static            s_PrivilegeEnabled = FALSE;

    if (s_PrivilegeEnabled)
    {
        return S_OK;
    }

    //
    // Make sure we have access to adjust and to get the
    // old token privileges
    //
    if (!NT_SUCCESS(NtStatus =
                    NtOpenProcessToken(NtCurrentProcess(),
                                       TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                                       &Token)))
    {
        Status = HRESULT_FROM_NT(NtStatus);
        goto EH_Exit;
    }

    cbNeeded = 0;

    //
    // Initialize the privilege adjustment structure
    //

    LuidPrivilege = RtlConvertUlongToLuid(SE_DEBUG_PRIVILEGE);

    NewPrivileges = (PTOKEN_PRIVILEGES)
        RtlAllocateHeap(RtlProcessHeap(), HEAP_ZERO_MEMORY,
                        sizeof(TOKEN_PRIVILEGES) +
                        (1 - ANYSIZE_ARRAY) * sizeof(LUID_AND_ATTRIBUTES));
    if (NewPrivileges == NULL)
    {
        Status = E_OUTOFMEMORY;
        goto EH_Token;
    }

    NewPrivileges->PrivilegeCount = 1;
    NewPrivileges->Privileges[0].Luid = LuidPrivilege;
    NewPrivileges->Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    //
    // Enable the privilege
    //

    if (!NT_SUCCESS(NtStatus =
                    NtAdjustPrivilegesToken(Token,
                                            FALSE,
                                            NewPrivileges,
                                            sizeof(OldPriv),
                                            (PTOKEN_PRIVILEGES)OldPriv,
                                            &cbNeeded)))
    {
        //
        // If the stack was too small to hold the privileges
        // then allocate off the heap
        //
        if (NtStatus == STATUS_BUFFER_OVERFLOW)
        {
            PBYTE pbOldPriv;

            pbOldPriv = (PUCHAR)RtlAllocateHeap(RtlProcessHeap(),
                                                HEAP_ZERO_MEMORY, cbNeeded);
            if (pbOldPriv == NULL)
            {
                Status = E_OUTOFMEMORY;
                goto EH_NewPriv;
            }

            NtStatus = NtAdjustPrivilegesToken(Token,
                                               FALSE,
                                               NewPrivileges,
                                               cbNeeded,
                                               (PTOKEN_PRIVILEGES)pbOldPriv,
                                               &cbNeeded);

            free(pbOldPriv);

            if (!NT_SUCCESS(NtStatus))
            {
                Status = HRESULT_FROM_NT(NtStatus);
            }
        }
    }

 EH_NewPriv:
    free(NewPrivileges);
 EH_Token:
    NtClose(Token);
 EH_Exit:
    if (Status == S_OK)
    {
        s_PrivilegeEnabled = TRUE;
    }
    return Status;
}

#endif // #ifndef NT_NATIVE

//
// Copies the input data to the output buffer.
// Handles optionality of the buffer pointer and output length
// parameter.  Trims the data to fit the buffer.
// Returns S_FALSE if only a part of the data is copied.
//
HRESULT
FillDataBuffer(PVOID Data, ULONG DataLen,
               PVOID Buffer, ULONG BufferLen, PULONG BufferUsed)
{
    ULONG Len;
    HRESULT Status;

    if (DataLen > BufferLen && Buffer != NULL)
    {
        Len = BufferLen;
        Status = S_FALSE;
    }
    else
    {
        Len = DataLen;
        Status = S_OK;
    }

    if (Buffer != NULL && BufferLen > 0 && Data != NULL && Len > 0)
    {
        memcpy(Buffer, Data, Len);
    }

    if (BufferUsed != NULL)
    {
        *BufferUsed = DataLen;
    }

    return Status;
}

//
// Copies the input string to the output buffer.
// Handles optionality of the buffer pointer and output length
// parameter.  Trims the string to fit the buffer and guarantees
// termination of the string in the buffer if anything fits.
// Returns S_FALSE if only a partial string is copied.
//
// If the input string length is zero the routine strlens.
//
HRESULT
FillStringBuffer(PCSTR String, ULONG StringLenIn,
                 PSTR Buffer, ULONG BufferLen, PULONG StringLenOut)
{
    ULONG Len;
    HRESULT Status;

    if (StringLenIn == 0)
    {
        if (String != NULL)
        {
            StringLenIn = strlen(String) + 1;
        }
        else
        {
            StringLenIn = 1;
        }
    }

    if (BufferLen == 0)
    {
        Len = 0;
        Status = Buffer != NULL ? S_FALSE : S_OK;
    }
    else if (StringLenIn >= BufferLen)
    {
        Len = BufferLen - 1;
        Status = StringLenIn > BufferLen ? S_FALSE : S_OK;
    }
    else
    {
        Len = StringLenIn - 1;
        Status = S_OK;
    }

    if (Buffer != NULL && BufferLen > 0)
    {
        if (String != NULL)
        {
            memcpy(Buffer, String, Len);
        }

        Buffer[Len] = 0;
    }

    if (StringLenOut != NULL)
    {
        *StringLenOut = StringLenIn;
    }

    return Status;
}

HRESULT
AppendToStringBuffer(HRESULT Status, PCSTR String, BOOL First,
                     PSTR* Buffer, ULONG* BufferLen, PULONG LenOut)
{
    ULONG Len = strlen(String) + 1;

    if (LenOut)
    {
        // If this is the first string we need to add
        // on space for the terminator.  For later
        // strings we only need to add the string
        // characters.
        *LenOut += First ? Len : Len - 1;
    }
    
    // If there's no buffer we can skip writeback and pointer update.
    if (!*Buffer)
    {
        return Status;
    }

    // Fit as much of the string into the buffer as possible.
    if (Len > *BufferLen)
    {
        Status = S_FALSE;
        Len = *BufferLen;
    }
    memcpy(*Buffer, String, Len);

    // Update the buffer pointer to point to the terminator
    // for further appends.  Update the size similarly.
    *Buffer += Len - 1;
    *BufferLen -= Len - 1;

    return Status;
}

void
Win32ToNtTimeout(ULONG Win32Timeout, PLARGE_INTEGER NtTimeout)
{
    if (Win32Timeout == INFINITE)
    {
        NtTimeout->LowPart = 0;
        NtTimeout->HighPart = 0x80000000;
    }
    else
    {
        NtTimeout->QuadPart = UInt32x32To64(Win32Timeout, 10000);
        NtTimeout->QuadPart *= -1;
    }
}

HRESULT
InitializeAllAccessSecObj(void)
{
    if (g_AllAccessSecDesc != NULL)
    {
        // Already initialized.
        return S_OK;
    }
    
    g_AllAccessSecDesc =
        (PSECURITY_DESCRIPTOR)malloc(SECURITY_DESCRIPTOR_MIN_LENGTH);
    if (g_AllAccessSecDesc == NULL)
    {
        return E_OUTOFMEMORY;
    }

    if (!InitializeSecurityDescriptor(g_AllAccessSecDesc,
                                      SECURITY_DESCRIPTOR_REVISION) ||
        !SetSecurityDescriptorDacl(g_AllAccessSecDesc, TRUE, NULL, FALSE))
    {
        free(g_AllAccessSecDesc);
        g_AllAccessSecDesc = NULL;
        return WIN32_LAST_STATUS();
    }

    g_AllAccessSecAttr.nLength = sizeof(g_AllAccessSecAttr);
    g_AllAccessSecAttr.lpSecurityDescriptor = g_AllAccessSecDesc;
    g_AllAccessSecAttr.bInheritHandle = FALSE;

    return S_OK;
}

void
DeleteAllAccessSecObj(void)
{
    free(g_AllAccessSecDesc);
    g_AllAccessSecDesc = NULL;
    ZeroMemory(&g_AllAccessSecAttr, sizeof(g_AllAccessSecAttr));
}

HRESULT
QueryVersionDataBuffer(PVOID VerData, PCSTR Item,
                       PVOID Buffer, ULONG BufferSize, PULONG DataSize)
{
#ifndef NT_NATIVE
    PVOID Val;
    UINT ValSize;

    if (::VerQueryValue(VerData, (PSTR)Item, &Val, &ValSize))
    {
        return FillDataBuffer(Val, ValSize,
                              Buffer, BufferSize, DataSize);
    }
    else
    {
        return WIN32_LAST_STATUS();
    }
#else // #ifndef NT_NATIVE
    return E_UNEXPECTED;
#endif // #ifndef NT_NATIVE
}

PVOID
GetAllFileVersionInfo(PSTR VerFile)
{
#ifndef NT_NATIVE
    DWORD VerHandle;
    DWORD VerSize = ::GetFileVersionInfoSize(VerFile, &VerHandle);
    if (VerSize == 0)
    {
        return NULL;
    }

    PVOID Buffer = malloc(VerSize);
    if (Buffer == NULL)
    {
        return NULL;
    }

    if (!::GetFileVersionInfo(VerFile, VerHandle, VerSize, Buffer))
    {
        free(Buffer);
        Buffer = NULL;
    }

    return Buffer;
#else // #ifndef NT_NATIVE
    return NULL;
#endif // #ifndef NT_NATIVE
}

BOOL
GetFileStringFileInfo(PSTR VerFile, PCSTR SubItem,
                      PSTR Buffer, ULONG BufferSize)
{
#ifndef NT_NATIVE
    BOOL Status = FALSE;
    PVOID AllInfo = GetAllFileVersionInfo(VerFile);
    if (AllInfo == NULL)
    {
        return Status;
    }

    // XXX drewb - Probably should do a more clever
    // enumeration of languages.
    char ValName[64];
    sprintf(ValName, "\\StringFileInfo\\%04x%04x\\%s",
            VER_VERSION_TRANSLATION, SubItem);
    
    Status = SUCCEEDED(QueryVersionDataBuffer(AllInfo, ValName,
                                              Buffer, BufferSize, NULL));

    free(AllInfo);
    return Status;
#else // #ifndef NT_NATIVE
    return FALSE;
#endif // #ifndef NT_NATIVE
}

BOOL
IsUrlPathComponent(PCSTR Path)
{
    return
        strncmp(Path, "ftp://", 6) == 0 ||
        strncmp(Path, "http://", 7) == 0 ||
        strncmp(Path, "https://", 8) == 0 ||
        strncmp(Path, "gopher://", 9) == 0;
}

#ifndef NT_NATIVE

BOOL
PathFileExists(PCSTR Path, ULONG SymOpt, FILE_IO_TYPE* IoType)
{
    BOOL Exists = FALSE;

    if (IsUrlPathComponent(Path))
    {
        PathFile* File;
        
        if (OpenPathFile(Path, SymOpt, &File) == S_OK)
        {
            *IoType = File->m_IoType;
            delete File;
            Exists = TRUE;
        }
    }
    else
    {
        DWORD OldMode;
    
        if (SymOpt & SYMOPT_FAIL_CRITICAL_ERRORS)
        {
            OldMode = SetErrorMode(SEM_FAILCRITICALERRORS);
        }

        *IoType = FIO_WIN32;
        Exists = GetFileAttributes(Path) != -1;
        
        if (SymOpt & SYMOPT_FAIL_CRITICAL_ERRORS)
        {
            SetErrorMode(OldMode);
        }
    }

    return Exists;
}

PathFile::~PathFile(void)
{
}

class Win32PathFile : public PathFile
{
public:
    Win32PathFile(void)
        : PathFile(FIO_WIN32)
    {
        m_Handle = NULL;
    }
    virtual ~Win32PathFile(void)
    {
        if (m_Handle)
        {
            CloseHandle(m_Handle);
        }
    }

    virtual HRESULT Open(PCSTR Path, ULONG SymOpt)
    {
        DWORD OldMode;
        HRESULT Status;
    
        if (SymOpt & SYMOPT_FAIL_CRITICAL_ERRORS)
        {
            OldMode = SetErrorMode(SEM_FAILCRITICALERRORS);
        }

        m_Handle = CreateFile(Path, GENERIC_READ, FILE_SHARE_READ,
                              NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                              NULL);
        if (m_Handle == NULL || m_Handle == INVALID_HANDLE_VALUE)
        {
            m_Handle = NULL;
            Status = WIN32_LAST_STATUS();
        }
        else
        {
            Status = S_OK;
        }
        
        if (SymOpt & SYMOPT_FAIL_CRITICAL_ERRORS)
        {
            SetErrorMode(OldMode);
        }

        return Status;
    }
    virtual HRESULT QueryDataAvailable(PULONG Avail)
    {
        LARGE_INTEGER Cur, End;

        Cur.HighPart = 0;
        End.HighPart = 0;
        if ((Cur.LowPart =
             SetFilePointer(m_Handle, 0, &Cur.HighPart, FILE_CURRENT)) ==
            INVALID_SET_FILE_POINTER ||
            (End.LowPart =
             SetFilePointer(m_Handle, 0, &End.HighPart, FILE_END)) ==
            INVALID_SET_FILE_POINTER ||
            SetFilePointer(m_Handle, Cur.LowPart, &Cur.HighPart, FILE_BEGIN) ==
            INVALID_SET_FILE_POINTER)
        {
            return WIN32_LAST_STATUS();
        }

        End.QuadPart -= Cur.QuadPart;
        if (End.HighPart < 0)
        {
            // Shouldn't be possible, but check anyway.
            return E_FAIL;
        }
        
        // Limit max data available to 32-bit quantity.
        if (End.HighPart > 0)
        {
            *Avail = 0xffffffff;
        }
        else
        {
            *Avail = End.LowPart;
        }
        return S_OK;
    }
    virtual HRESULT GetLastWriteTime(PFILETIME Time)
    {
        // If we can't get the write time try and get
        // the create time.
        if (!GetFileTime(m_Handle, NULL, NULL, Time))
        {
            if (!GetFileTime(m_Handle, Time, NULL, NULL))
            {
                return WIN32_LAST_STATUS();
            }
        }

        return S_OK;
    }
    virtual HRESULT Read(PVOID Buffer, ULONG BufferLen, PULONG Done)
    {
        if (!ReadFile(m_Handle, Buffer, BufferLen, Done, NULL))
        {
            return WIN32_LAST_STATUS();
        }
            
        return S_OK;
    }

private:
    HANDLE m_Handle;
};

class WinInetPathFile : public PathFile
{
public:
    WinInetPathFile(void)
        : PathFile(FIO_WININET)
    {
        m_InetHandle = NULL;
        m_Handle = NULL;
        m_InitialDataLen = 0;
    }
    virtual ~WinInetPathFile(void)
    {
        if (m_Handle)
        {
            InternetCloseHandle(m_Handle);
        }
        if (m_InetHandle)
        {
            InternetCloseHandle(m_InetHandle);
        }
    }

    virtual HRESULT Open(PCSTR Path, ULONG SymOpt)
    {
        HRESULT Status;

        m_InetHandle = InternetOpen("DebugEngine",
                                    INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL,
                                    0);
        if (m_InetHandle == NULL)
        {
            return WIN32_LAST_STATUS();
        }
        m_Handle = InternetOpenUrl(m_InetHandle, Path, NULL, 0,
                                   INTERNET_FLAG_NO_UI |
                                   INTERNET_FLAG_NO_AUTO_REDIRECT, 0);
        if (m_Handle == NULL)
        {
            Status = WIN32_LAST_STATUS();
            goto Fail;
        }

        // Servers can return 404 - Not Found pages in
        // response to missing URLs so read the first
        // piece of data and fail if it's HTML.
        if (!InternetReadFile(m_Handle, m_InitialData,
                              sizeof(m_InitialData), &m_InitialDataLen))
        {
            Status = WIN32_LAST_STATUS();
            goto Fail;
        }
        
        if (m_InitialDataLen >= 14 &&
            memcmp(m_InitialData, "<!DOCTYPE HTML", 14) == 0)
        {
            Status = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
            goto Fail;
        }

        return S_OK;

    Fail:
        m_InitialDataLen = 0;
        if (m_Handle)
        {
            InternetCloseHandle(m_Handle);
            m_Handle = NULL;
        }
        if (m_InetHandle)
        {
            InternetCloseHandle(m_InetHandle);
            m_InetHandle = NULL;
        }
        return Status;
    }
    virtual HRESULT QueryDataAvailable(PULONG Avail)
    {
        if (m_InitialDataLen > 0)
        {
            *Avail = m_InitialDataLen;
            return S_OK;
        }
        
        if (!InternetQueryDataAvailable(m_Handle, Avail, 0, 0))
        {
            return WIN32_LAST_STATUS();
        }

        return S_OK;
    }
    virtual HRESULT GetLastWriteTime(PFILETIME Time)
    {
        // Don't know of a way to get this.
        return E_NOTIMPL;
    }
    virtual HRESULT Read(PVOID Buffer, ULONG BufferLen, PULONG Done)
    {
        *Done = 0;
        
        if (m_InitialDataLen > 0)
        {
            ULONG Len = min(BufferLen, m_InitialDataLen);
            if (Len > 0)
            {
                memcpy(Buffer, m_InitialData, Len);
                Buffer = (PVOID)((PUCHAR)Buffer + Len);
                BufferLen -= Len;
                *Done += Len;
                m_InitialDataLen -= Len;
                if (m_InitialDataLen > 0)
                {
                    memmove(m_InitialData, m_InitialData + Len,
                            m_InitialDataLen);
                }
            }
        }
        
        if (BufferLen > 0)
        {
            ULONG _Done;

            if (!InternetReadFile(m_Handle, Buffer, BufferLen, &_Done))
            {
                return WIN32_LAST_STATUS();
            }

            *Done += _Done;
        }

        return S_OK;
    }

private:
    HANDLE m_Handle, m_InetHandle;
    BYTE m_InitialData[16];
    ULONG m_InitialDataLen;
};

HRESULT
OpenPathFile(PCSTR Path, ULONG SymOpt, PathFile** File)
{
    HRESULT Status;
    PathFile* Attempt;
    
    if (IsUrlPathComponent(Path))
    {
        Attempt = new WinInetPathFile;
    }
    else
    {
        Attempt = new Win32PathFile;
    }
    
    if (Attempt == NULL)
    {
        Status = E_OUTOFMEMORY;
    }
    else
    {
        Status = Attempt->Open(Path, SymOpt);
        if (Status != S_OK)
        {
            delete Attempt;
        }
        else
        {
            *File = Attempt;
        }
    }

    return Status;
}

#endif // #ifndef NT_NATIVE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\condbg\sources.inc ===
TARGETNAME = $(DEBUGGER_NAME)
TARGETPATH = obj
TARGETTYPE = PROGRAM

INCLUDES = ..;..\..\dbg-common

C_DEFINES = $(C_DEFINES) \
        -DDEBUGGER_NAME=\"$(DEBUGGER_NAME)\"
        
SOURCES = \
        ..\conio.cpp\
        ..\engine.cpp\
        ..\ini.cpp\
        ..\main.cpp\
        $(DEBUGGER_NAME).rc

NO_NTDLL = 1

USE_MSVCRT = 1
!if "$(DEBUGGER_NAME)" == "ntsd"
UMTYPE = windows
# Avoid running out of stack during stress
LINKER_STACKCOMMITSIZE=65536
!else
UMTYPE = console
C_DEFINES = $(C_DEFINES) -DINHERIT_CONSOLE
!endif

TARGETLIBS = $(TARGETLIBS) \
        $(SDK_LIB_PATH)\dbgeng.lib\
        $(SDK_LIB_PATH)\uuid.lib\
        $(SDK_LIB_PATH)\user32.lib\
        $(SDK_LIB_PATH)\version.lib\
        $(SDK_LIB_PATH)\htmlhelp.lib\
        $(SDK_LIB_PATH)\wininet.lib\
        $(DEBUGGER_LIBS)\*\dbglib.lib

PRECOMPILED_INCLUDE = ..\pch.cpp

DELAYLOAD = user32.dll
DLOAD_ERROR_HANDLER = Downlevel_DelayLoadFailureHook
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\dbg-common\cvconst.h ===
// cvconst.h - codeview constant definitions
//-----------------------------------------------------------------
// Microsoft Confidential
// Copyright 1993-2000 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------
#ifndef _CVCONST_H_
#define _CVCONST_H_



//      Enumeration for function call type


typedef enum CV_call_e {
    CV_CALL_NEAR_C      = 0x00, // near right to left push, caller pops stack
    CV_CALL_FAR_C       = 0x01, // far right to left push, caller pops stack
    CV_CALL_NEAR_PASCAL = 0x02, // near left to right push, callee pops stack
    CV_CALL_FAR_PASCAL  = 0x03, // far left to right push, callee pops stack
    CV_CALL_NEAR_FAST   = 0x04, // near left to right push with regs, callee pops stack
    CV_CALL_FAR_FAST    = 0x05, // far left to right push with regs, callee pops stack
    CV_CALL_SKIPPED     = 0x06, // skipped (unused) call index
    CV_CALL_NEAR_STD    = 0x07, // near standard call
    CV_CALL_FAR_STD     = 0x08, // far standard call
    CV_CALL_NEAR_SYS    = 0x09, // near sys call
    CV_CALL_FAR_SYS     = 0x0a, // far sys call
    CV_CALL_THISCALL    = 0x0b, // this call (this passed in register)
    CV_CALL_MIPSCALL    = 0x0c, // Mips call
    CV_CALL_GENERIC     = 0x0d, // Generic call sequence
    CV_CALL_ALPHACALL   = 0x0e, // Alpha call
    CV_CALL_PPCCALL     = 0x0f, // PPC call
    CV_CALL_SHCALL      = 0x10, // Hitachi SuperH call
    CV_CALL_ARMCALL     = 0x11, // ARM call
    CV_CALL_AM33CALL    = 0x12, // AM33 call
    CV_CALL_TRICALL     = 0x13, // TriCore Call
    CV_CALL_SH5CALL     = 0x14, // Hitachi SuperH-5 call
    CV_CALL_M32RCALL    = 0x15, // M32R Call
    CV_CALL_RESERVED    = 0x16  // first unused call enumeration
} CV_call_e;




//      Values for the access protection of class attributes


typedef enum CV_access_e {
    CV_private   = 1,
    CV_protected = 2,
    CV_public    = 3
} CV_access_e;

typedef enum THUNK_ORDINAL {
    THUNK_ORDINAL_NOTYPE,       // standard thunk
    THUNK_ORDINAL_ADJUSTOR,     // "this" adjustor thunk
    THUNK_ORDINAL_VCALL,        // virtual call thunk
    THUNK_ORDINAL_PCODE,        // pcode thunk
    THUNK_ORDINAL_LOAD,         // thunk which loads the address to jump to
                                //  via unknown means...

 // trampoline thunk ordinals	- only for use in Trampoline thunk symbols
    THUNK_ORDINAL_TRAMP_INCREMENTAL,
    THUNK_ORDINAL_TRAMP_BRANCHISLAND,

} THUNK_ORDINAL;


enum CV_SourceChksum_t {
    CHKSUM_TYPE_NONE = 0,        // indicates no checksum is available
    CHKSUM_TYPE_MD5
};

//
// DIA enums
//

enum SymTagEnum
{
	SymTagNull,
	SymTagExe,
	SymTagCompiland, 
	SymTagCompilandDetails, 
	SymTagCompilandEnv,
	SymTagFunction, 
	SymTagBlock,
	SymTagData,
	SymTagReserved, 
	SymTagLabel, 
	SymTagPublicSymbol, 
	SymTagUDT, 
	SymTagEnum, 
	SymTagFunctionType, 
	SymTagPointerType, 
	SymTagArrayType, 
	SymTagBaseType, 
	SymTagTypedef, 
	SymTagBaseClass,
	SymTagFriend,
	SymTagFunctionArgType, 
	SymTagFuncDebugStart, 
	SymTagFuncDebugEnd,
    SymTagUsingNamespace, 
    SymTagVTableShape,
    SymTagVTable,
	SymTagCustom,
    SymTagThunk,
	SymTagCustomType,
    SymTagManagedType,
    SymTagDimension,
	SymTagMax
};

enum LocationType
{
	LocIsNull,
	LocIsStatic,
	LocIsTLS, 
	LocIsRegRel, 
	LocIsThisRel, 
	LocIsEnregistered, 
	LocIsBitField,
    LocIsSlot,
    LocIsIlRel,
    LocInMetaData,
    LocIsConstant,
	LocTypeMax
};

enum DataKind
{
    DataIsUnknown,
    DataIsLocal,
    DataIsStaticLocal,
    DataIsParam,
    DataIsObjectPtr,
    DataIsFileStatic,
    DataIsGlobal,
    DataIsMember,
    DataIsStaticMember,
    DataIsConstant
};

enum BasicType 
{
	btNoType = 0,
	btVoid = 1,
	btChar = 2,
	btWChar = 3,
	btInt = 6,
	btUInt = 7,
	btFloat = 8,
	btBCD = 9,
	btBool = 10,	
	btCurrency = 25,
	btDate = 26,
	btVariant = 27,
	btComplex = 28,
	btBit = 29,
	btBSTR = 30,
    btHresult = 31
};


//  enum describing the compile flag source language


typedef enum CV_CFL_LANG {
    CV_CFL_C        = 0x00,
    CV_CFL_CXX      = 0x01,
    CV_CFL_FORTRAN  = 0x02,
    CV_CFL_MASM     = 0x03,
    CV_CFL_PASCAL   = 0x04,
    CV_CFL_BASIC    = 0x05,
    CV_CFL_COBOL    = 0x06,
    CV_CFL_LINK     = 0x07,
    CV_CFL_CVTRES   = 0x08,
    CV_CFL_CVTPGD   = 0x09,
} CV_CFL_LANG;


//  enum describing target processor


typedef enum CV_CPU_TYPE_e {
    CV_CFL_8080         = 0x00,
    CV_CFL_8086         = 0x01,
    CV_CFL_80286        = 0x02,
    CV_CFL_80386        = 0x03,
    CV_CFL_80486        = 0x04,
    CV_CFL_PENTIUM      = 0x05,
    CV_CFL_PENTIUMII    = 0x06,
    CV_CFL_PENTIUMPRO   = CV_CFL_PENTIUMII,
    CV_CFL_PENTIUMIII   = 0x07,
    CV_CFL_MIPS         = 0x10,
    CV_CFL_MIPSR4000    = CV_CFL_MIPS,  // don't break current code
    CV_CFL_MIPS16       = 0x11,
    CV_CFL_MIPS32       = 0x12,
    CV_CFL_MIPS64       = 0x13,
    CV_CFL_MIPSI        = 0x14,
    CV_CFL_MIPSII       = 0x15,
    CV_CFL_MIPSIII      = 0x16,
    CV_CFL_MIPSIV       = 0x17,
    CV_CFL_MIPSV        = 0x18,
    CV_CFL_M68000       = 0x20,
    CV_CFL_M68010       = 0x21,
    CV_CFL_M68020       = 0x22,
    CV_CFL_M68030       = 0x23,
    CV_CFL_M68040       = 0x24,
    CV_CFL_ALPHA        = 0x30,
    CV_CFL_ALPHA_21064  = 0x30,
    CV_CFL_ALPHA_21164  = 0x31,
    CV_CFL_ALPHA_21164A = 0x32,
    CV_CFL_ALPHA_21264  = 0x33,
    CV_CFL_ALPHA_21364  = 0x34,
    CV_CFL_PPC601       = 0x40,
    CV_CFL_PPC603       = 0x41,
    CV_CFL_PPC604       = 0x42,
    CV_CFL_PPC620       = 0x43,
    CV_CFL_PPCFP        = 0x44,
    CV_CFL_SH3          = 0x50,
    CV_CFL_SH3E         = 0x51,
    CV_CFL_SH3DSP       = 0x52,
    CV_CFL_SH4          = 0x53,
    CV_CFL_SHMEDIA      = 0x54,
    CV_CFL_ARM3         = 0x60,
    CV_CFL_ARM4         = 0x61,
    CV_CFL_ARM4T        = 0x62,
    CV_CFL_ARM5         = 0x63,
    CV_CFL_ARM5T        = 0x64,
    CV_CFL_OMNI         = 0x70,
    CV_CFL_IA64         = 0x80,
    CV_CFL_IA64_1       = 0x80,
    CV_CFL_IA64_2       = 0x81,
    CV_CFL_CEE          = 0x90,
    CV_CFL_AM33         = 0xA0,
    CV_CFL_M32R         = 0xB0,
    CV_CFL_TRICORE      = 0xC0,
    CV_CFL_RESERVED1    = 0xD0,
} CV_CPU_TYPE_e;

typedef enum CV_HREG_e {
    // Register subset shared by all processor types,
    // must not overlap with any of the ranges below, hence the high values

    CV_ALLREG_ERR   =   30000,
    CV_ALLREG_TEB   =   30001,
    CV_ALLREG_TIMER =   30002,
    CV_ALLREG_EFAD1 =   30003,
    CV_ALLREG_EFAD2 =   30004,
    CV_ALLREG_EFAD3 =   30005,
    CV_ALLREG_VFRAME=   30006,
    CV_ALLREG_HANDLE=   30007,
    CV_ALLREG_PARAMS=   30008,
    CV_ALLREG_LOCALS=   30009,


    //  Register set for the Intel 80x86 and ix86 processor series
    //  (plus PCODE registers)

    CV_REG_NONE     =   0,
    CV_REG_AL       =   1,
    CV_REG_CL       =   2,
    CV_REG_DL       =   3,
    CV_REG_BL       =   4,
    CV_REG_AH       =   5,
    CV_REG_CH       =   6,
    CV_REG_DH       =   7,
    CV_REG_BH       =   8,
    CV_REG_AX       =   9,
    CV_REG_CX       =  10,
    CV_REG_DX       =  11,
    CV_REG_BX       =  12,
    CV_REG_SP       =  13,
    CV_REG_BP       =  14,
    CV_REG_SI       =  15,
    CV_REG_DI       =  16,
    CV_REG_EAX      =  17,
    CV_REG_ECX      =  18,
    CV_REG_EDX      =  19,
    CV_REG_EBX      =  20,
    CV_REG_ESP      =  21,
    CV_REG_EBP      =  22,
    CV_REG_ESI      =  23,
    CV_REG_EDI      =  24,
    CV_REG_ES       =  25,
    CV_REG_CS       =  26,
    CV_REG_SS       =  27,
    CV_REG_DS       =  28,
    CV_REG_FS       =  29,
    CV_REG_GS       =  30,
    CV_REG_IP       =  31,
    CV_REG_FLAGS    =  32,
    CV_REG_EIP      =  33,
    CV_REG_EFLAGS   =  34,
    CV_REG_TEMP     =  40,          // PCODE Temp
    CV_REG_TEMPH    =  41,          // PCODE TempH
    CV_REG_QUOTE    =  42,          // PCODE Quote
    CV_REG_PCDR3    =  43,          // PCODE reserved
    CV_REG_PCDR4    =  44,          // PCODE reserved
    CV_REG_PCDR5    =  45,          // PCODE reserved
    CV_REG_PCDR6    =  46,          // PCODE reserved
    CV_REG_PCDR7    =  47,          // PCODE reserved
    CV_REG_CR0      =  80,          // CR0 -- control registers
    CV_REG_CR1      =  81,
    CV_REG_CR2      =  82,
    CV_REG_CR3      =  83,
    CV_REG_CR4      =  84,          // Pentium
    CV_REG_DR0      =  90,          // Debug register
    CV_REG_DR1      =  91,
    CV_REG_DR2      =  92,
    CV_REG_DR3      =  93,
    CV_REG_DR4      =  94,
    CV_REG_DR5      =  95,
    CV_REG_DR6      =  96,
    CV_REG_DR7      =  97,
    CV_REG_GDTR     =  110,
    CV_REG_GDTL     =  111,
    CV_REG_IDTR     =  112,
    CV_REG_IDTL     =  113,
    CV_REG_LDTR     =  114,
    CV_REG_TR       =  115,

    CV_REG_PSEUDO1  =  116,
    CV_REG_PSEUDO2  =  117,
    CV_REG_PSEUDO3  =  118,
    CV_REG_PSEUDO4  =  119,
    CV_REG_PSEUDO5  =  120,
    CV_REG_PSEUDO6  =  121,
    CV_REG_PSEUDO7  =  122,
    CV_REG_PSEUDO8  =  123,
    CV_REG_PSEUDO9  =  124,

    CV_REG_ST0      =  128,
    CV_REG_ST1      =  129,
    CV_REG_ST2      =  130,
    CV_REG_ST3      =  131,
    CV_REG_ST4      =  132,
    CV_REG_ST5      =  133,
    CV_REG_ST6      =  134,
    CV_REG_ST7      =  135,
    CV_REG_CTRL     =  136,
    CV_REG_STAT     =  137,
    CV_REG_TAG      =  138,
    CV_REG_FPIP     =  139,
    CV_REG_FPCS     =  140,
    CV_REG_FPDO     =  141,
    CV_REG_FPDS     =  142,
    CV_REG_ISEM     =  143,
    CV_REG_FPEIP    =  144,
    CV_REG_FPEDO    =  145,

    CV_REG_MM0      =  146,
    CV_REG_MM1      =  147,
    CV_REG_MM2      =  148,
    CV_REG_MM3      =  149,
    CV_REG_MM4      =  150,
    CV_REG_MM5      =  151,
    CV_REG_MM6      =  152,
    CV_REG_MM7      =  153,

    CV_REG_XMM0     =  154, // KATMAI registers
    CV_REG_XMM1     =  155,
    CV_REG_XMM2     =  156,
    CV_REG_XMM3     =  157,
    CV_REG_XMM4     =  158,
    CV_REG_XMM5     =  159,
    CV_REG_XMM6     =  160,
    CV_REG_XMM7     =  161,

    CV_REG_XMM00    =  162, // KATMAI sub-registers
    CV_REG_XMM01    =  163,
    CV_REG_XMM02    =  164,
    CV_REG_XMM03    =  165,
    CV_REG_XMM10    =  166,
    CV_REG_XMM11    =  167,
    CV_REG_XMM12    =  168,
    CV_REG_XMM13    =  169,
    CV_REG_XMM20    =  170,
    CV_REG_XMM21    =  171,
    CV_REG_XMM22    =  172,
    CV_REG_XMM23    =  173,
    CV_REG_XMM30    =  174,
    CV_REG_XMM31    =  175,
    CV_REG_XMM32    =  176,
    CV_REG_XMM33    =  177,
    CV_REG_XMM40    =  178,
    CV_REG_XMM41    =  179,
    CV_REG_XMM42    =  180,
    CV_REG_XMM43    =  181,
    CV_REG_XMM50    =  182,
    CV_REG_XMM51    =  183,
    CV_REG_XMM52    =  184,
    CV_REG_XMM53    =  185,
    CV_REG_XMM60    =  186,
    CV_REG_XMM61    =  187,
    CV_REG_XMM62    =  188,
    CV_REG_XMM63    =  189,
    CV_REG_XMM70    =  190,
    CV_REG_XMM71    =  191,
    CV_REG_XMM72    =  192,
    CV_REG_XMM73    =  193,

    CV_REG_XMM0L    =  194, 
    CV_REG_XMM1L    =  195,
    CV_REG_XMM2L    =  196,
    CV_REG_XMM3L    =  197,
    CV_REG_XMM4L    =  198,
    CV_REG_XMM5L    =  199,
    CV_REG_XMM6L    =  200,
    CV_REG_XMM7L    =  201,
    
    CV_REG_XMM0H    =  202, 
    CV_REG_XMM1H    =  203,
    CV_REG_XMM2H    =  204,
    CV_REG_XMM3H    =  205,
    CV_REG_XMM4H    =  206,
    CV_REG_XMM5H    =  207,
    CV_REG_XMM6H    =  208,
    CV_REG_XMM7H    =  209,

    CV_REG_MXCSR    =  211, // XMM status register

    CV_REG_EDXEAX   =  212,	// EDX:EAX pair

    CV_REG_EMM0L    =  220, // XMM sub-registers (WNI integer)
    CV_REG_EMM1L    =  221,
    CV_REG_EMM2L    =  222,
    CV_REG_EMM3L    =  223,
    CV_REG_EMM4L    =  224,
    CV_REG_EMM5L    =  225,
    CV_REG_EMM6L    =  226,
    CV_REG_EMM7L    =  227,

    CV_REG_EMM0H    =  228, 
    CV_REG_EMM1H    =  229,
    CV_REG_EMM2H    =  230,
    CV_REG_EMM3H    =  231,
    CV_REG_EMM4H    =  232,
    CV_REG_EMM5H    =  233,
    CV_REG_EMM6H    =  234,
    CV_REG_EMM7H    =  235,

    // do not change the order of these regs, first one must be even too
    CV_REG_MM00     =  236,
    CV_REG_MM01     =  237,
    CV_REG_MM10     =  238,
    CV_REG_MM11     =  239,
    CV_REG_MM20     =  240,
    CV_REG_MM21     =  241,
    CV_REG_MM30     =  242,
    CV_REG_MM31     =  243,
    CV_REG_MM40     =  244,
    CV_REG_MM41     =  245,
    CV_REG_MM50     =  246,
    CV_REG_MM51     =  247,
    CV_REG_MM60     =  248,
    CV_REG_MM61     =  249,
    CV_REG_MM70     =  250,
    CV_REG_MM71     =  251,

    // registers for the 68K processors

    CV_R68_D0       =    0,
    CV_R68_D1       =    1,
    CV_R68_D2       =    2,
    CV_R68_D3       =    3,
    CV_R68_D4       =    4,
    CV_R68_D5       =    5,
    CV_R68_D6       =    6,
    CV_R68_D7       =    7,
    CV_R68_A0       =    8,
    CV_R68_A1       =    9,
    CV_R68_A2       =   10,
    CV_R68_A3       =   11,
    CV_R68_A4       =   12,
    CV_R68_A5       =   13,
    CV_R68_A6       =   14,
    CV_R68_A7       =   15,
    CV_R68_CCR      =   16,
    CV_R68_SR       =   17,
    CV_R68_USP      =   18,
    CV_R68_MSP      =   19,
    CV_R68_SFC      =   20,
    CV_R68_DFC      =   21,
    CV_R68_CACR     =   22,
    CV_R68_VBR      =   23,
    CV_R68_CAAR     =   24,
    CV_R68_ISP      =   25,
    CV_R68_PC       =   26,
    //reserved  27
    CV_R68_FPCR     =   28,
    CV_R68_FPSR     =   29,
    CV_R68_FPIAR    =   30,
    //reserved  31
    CV_R68_FP0      =   32,
    CV_R68_FP1      =   33,
    CV_R68_FP2      =   34,
    CV_R68_FP3      =   35,
    CV_R68_FP4      =   36,
    CV_R68_FP5      =   37,
    CV_R68_FP6      =   38,
    CV_R68_FP7      =   39,
    //reserved  40
    CV_R68_MMUSR030 =   41,
    CV_R68_MMUSR    =   42,
    CV_R68_URP      =   43,
    CV_R68_DTT0     =   44,
    CV_R68_DTT1     =   45,
    CV_R68_ITT0     =   46,
    CV_R68_ITT1     =   47,
    //reserved  50
    CV_R68_PSR      =   51,
    CV_R68_PCSR     =   52,
    CV_R68_VAL      =   53,
    CV_R68_CRP      =   54,
    CV_R68_SRP      =   55,
    CV_R68_DRP      =   56,
    CV_R68_TC       =   57,
    CV_R68_AC       =   58,
    CV_R68_SCC      =   59,
    CV_R68_CAL      =   60,
    CV_R68_TT0      =   61,
    CV_R68_TT1      =   62,
    //reserved  63
    CV_R68_BAD0     =   64,
    CV_R68_BAD1     =   65,
    CV_R68_BAD2     =   66,
    CV_R68_BAD3     =   67,
    CV_R68_BAD4     =   68,
    CV_R68_BAD5     =   69,
    CV_R68_BAD6     =   70,
    CV_R68_BAD7     =   71,
    CV_R68_BAC0     =   72,
    CV_R68_BAC1     =   73,
    CV_R68_BAC2     =   74,
    CV_R68_BAC3     =   75,
    CV_R68_BAC4     =   76,
    CV_R68_BAC5     =   77,
    CV_R68_BAC6     =   78,
    CV_R68_BAC7     =   79,

     // Register set for the MIPS 4000

    CV_M4_NOREG     =   CV_REG_NONE,

    CV_M4_IntZERO   =   10,      /* CPU REGISTER */
    CV_M4_IntAT     =   11,
    CV_M4_IntV0     =   12,
    CV_M4_IntV1     =   13,
    CV_M4_IntA0     =   14,
    CV_M4_IntA1     =   15,
    CV_M4_IntA2     =   16,
    CV_M4_IntA3     =   17,
    CV_M4_IntT0     =   18,
    CV_M4_IntT1     =   19,
    CV_M4_IntT2     =   20,
    CV_M4_IntT3     =   21,
    CV_M4_IntT4     =   22,
    CV_M4_IntT5     =   23,
    CV_M4_IntT6     =   24,
    CV_M4_IntT7     =   25,
    CV_M4_IntS0     =   26,
    CV_M4_IntS1     =   27,
    CV_M4_IntS2     =   28,
    CV_M4_IntS3     =   29,
    CV_M4_IntS4     =   30,
    CV_M4_IntS5     =   31,
    CV_M4_IntS6     =   32,
    CV_M4_IntS7     =   33,
    CV_M4_IntT8     =   34,
    CV_M4_IntT9     =   35,
    CV_M4_IntKT0    =   36,
    CV_M4_IntKT1    =   37,
    CV_M4_IntGP     =   38,
    CV_M4_IntSP     =   39,
    CV_M4_IntS8     =   40,
    CV_M4_IntRA     =   41,
    CV_M4_IntLO     =   42,
    CV_M4_IntHI     =   43,

    CV_M4_Fir       =   50,
    CV_M4_Psr       =   51,

    CV_M4_FltF0     =   60,      /* Floating point registers */
    CV_M4_FltF1     =   61,
    CV_M4_FltF2     =   62,
    CV_M4_FltF3     =   63,
    CV_M4_FltF4     =   64,
    CV_M4_FltF5     =   65,
    CV_M4_FltF6     =   66,
    CV_M4_FltF7     =   67,
    CV_M4_FltF8     =   68,
    CV_M4_FltF9     =   69,
    CV_M4_FltF10    =   70,
    CV_M4_FltF11    =   71,
    CV_M4_FltF12    =   72,
    CV_M4_FltF13    =   73,
    CV_M4_FltF14    =   74,
    CV_M4_FltF15    =   75,
    CV_M4_FltF16    =   76,
    CV_M4_FltF17    =   77,
    CV_M4_FltF18    =   78,
    CV_M4_FltF19    =   79,
    CV_M4_FltF20    =   80,
    CV_M4_FltF21    =   81,
    CV_M4_FltF22    =   82,
    CV_M4_FltF23    =   83,
    CV_M4_FltF24    =   84,
    CV_M4_FltF25    =   85,
    CV_M4_FltF26    =   86,
    CV_M4_FltF27    =   87,
    CV_M4_FltF28    =   88,
    CV_M4_FltF29    =   89,
    CV_M4_FltF30    =   90,
    CV_M4_FltF31    =   91,
    CV_M4_FltFsr    =   92,


    // Register set for the ALPHA AXP

    CV_ALPHA_NOREG  = CV_REG_NONE,

    CV_ALPHA_FltF0  =   10,   // Floating point registers
    CV_ALPHA_FltF1  =   11,
    CV_ALPHA_FltF2  =   12,
    CV_ALPHA_FltF3  =   13,
    CV_ALPHA_FltF4  =   14,
    CV_ALPHA_FltF5  =   15,
    CV_ALPHA_FltF6  =   16,
    CV_ALPHA_FltF7  =   17,
    CV_ALPHA_FltF8  =   18,
    CV_ALPHA_FltF9  =   19,
    CV_ALPHA_FltF10 =   20,
    CV_ALPHA_FltF11 =   21,
    CV_ALPHA_FltF12 =   22,
    CV_ALPHA_FltF13 =   23,
    CV_ALPHA_FltF14 =   24,
    CV_ALPHA_FltF15 =   25,
    CV_ALPHA_FltF16 =   26,
    CV_ALPHA_FltF17 =   27,
    CV_ALPHA_FltF18 =   28,
    CV_ALPHA_FltF19 =   29,
    CV_ALPHA_FltF20 =   30,
    CV_ALPHA_FltF21 =   31,
    CV_ALPHA_FltF22 =   32,
    CV_ALPHA_FltF23 =   33,
    CV_ALPHA_FltF24 =   34,
    CV_ALPHA_FltF25 =   35,
    CV_ALPHA_FltF26 =   36,
    CV_ALPHA_FltF27 =   37,
    CV_ALPHA_FltF28 =   38,
    CV_ALPHA_FltF29 =   39,
    CV_ALPHA_FltF30 =   40,
    CV_ALPHA_FltF31 =   41,

    CV_ALPHA_IntV0  =   42,   // Integer registers
    CV_ALPHA_IntT0  =   43,
    CV_ALPHA_IntT1  =   44,
    CV_ALPHA_IntT2  =   45,
    CV_ALPHA_IntT3  =   46,
    CV_ALPHA_IntT4  =   47,
    CV_ALPHA_IntT5  =   48,
    CV_ALPHA_IntT6  =   49,
    CV_ALPHA_IntT7  =   50,
    CV_ALPHA_IntS0  =   51,
    CV_ALPHA_IntS1  =   52,
    CV_ALPHA_IntS2  =   53,
    CV_ALPHA_IntS3  =   54,
    CV_ALPHA_IntS4  =   55,
    CV_ALPHA_IntS5  =   56,
    CV_ALPHA_IntFP  =   57,
    CV_ALPHA_IntA0  =   58,
    CV_ALPHA_IntA1  =   59,
    CV_ALPHA_IntA2  =   60,
    CV_ALPHA_IntA3  =   61,
    CV_ALPHA_IntA4  =   62,
    CV_ALPHA_IntA5  =   63,
    CV_ALPHA_IntT8  =   64,
    CV_ALPHA_IntT9  =   65,
    CV_ALPHA_IntT10 =   66,
    CV_ALPHA_IntT11 =   67,
    CV_ALPHA_IntRA  =   68,
    CV_ALPHA_IntT12 =   69,
    CV_ALPHA_IntAT  =   70,
    CV_ALPHA_IntGP  =   71,
    CV_ALPHA_IntSP  =   72,
    CV_ALPHA_IntZERO =  73,


    CV_ALPHA_Fpcr   =   74,   // Control registers
    CV_ALPHA_Fir    =   75,
    CV_ALPHA_Psr    =   76,
    CV_ALPHA_FltFsr =   77,
    CV_ALPHA_SoftFpcr =   78,

    // Register Set for Motorola/IBM PowerPC

    /*
    ** PowerPC General Registers ( User Level )
    */
    CV_PPC_GPR0     =  1,
    CV_PPC_GPR1     =  2,
    CV_PPC_GPR2     =  3,
    CV_PPC_GPR3     =  4,
    CV_PPC_GPR4     =  5,
    CV_PPC_GPR5     =  6,
    CV_PPC_GPR6     =  7,
    CV_PPC_GPR7     =  8,
    CV_PPC_GPR8     =  9,
    CV_PPC_GPR9     = 10,
    CV_PPC_GPR10    = 11,
    CV_PPC_GPR11    = 12,
    CV_PPC_GPR12    = 13,
    CV_PPC_GPR13    = 14,
    CV_PPC_GPR14    = 15,
    CV_PPC_GPR15    = 16,
    CV_PPC_GPR16    = 17,
    CV_PPC_GPR17    = 18,
    CV_PPC_GPR18    = 19,
    CV_PPC_GPR19    = 20,
    CV_PPC_GPR20    = 21,
    CV_PPC_GPR21    = 22,
    CV_PPC_GPR22    = 23,
    CV_PPC_GPR23    = 24,
    CV_PPC_GPR24    = 25,
    CV_PPC_GPR25    = 26,
    CV_PPC_GPR26    = 27,
    CV_PPC_GPR27    = 28,
    CV_PPC_GPR28    = 29,
    CV_PPC_GPR29    = 30,
    CV_PPC_GPR30    = 31,
    CV_PPC_GPR31    = 32,

    /*
    ** PowerPC Condition Register ( User Level )
    */
    CV_PPC_CR       = 33,
    CV_PPC_CR0      = 34,
    CV_PPC_CR1      = 35,
    CV_PPC_CR2      = 36,
    CV_PPC_CR3      = 37,
    CV_PPC_CR4      = 38,
    CV_PPC_CR5      = 39,
    CV_PPC_CR6      = 40,
    CV_PPC_CR7      = 41,

    /*
    ** PowerPC Floating Point Registers ( User Level )
    */
    CV_PPC_FPR0     = 42,
    CV_PPC_FPR1     = 43,
    CV_PPC_FPR2     = 44,
    CV_PPC_FPR3     = 45,
    CV_PPC_FPR4     = 46,
    CV_PPC_FPR5     = 47,
    CV_PPC_FPR6     = 48,
    CV_PPC_FPR7     = 49,
    CV_PPC_FPR8     = 50,
    CV_PPC_FPR9     = 51,
    CV_PPC_FPR10    = 52,
    CV_PPC_FPR11    = 53,
    CV_PPC_FPR12    = 54,
    CV_PPC_FPR13    = 55,
    CV_PPC_FPR14    = 56,
    CV_PPC_FPR15    = 57,
    CV_PPC_FPR16    = 58,
    CV_PPC_FPR17    = 59,
    CV_PPC_FPR18    = 60,
    CV_PPC_FPR19    = 61,
    CV_PPC_FPR20    = 62,
    CV_PPC_FPR21    = 63,
    CV_PPC_FPR22    = 64,
    CV_PPC_FPR23    = 65,
    CV_PPC_FPR24    = 66,
    CV_PPC_FPR25    = 67,
    CV_PPC_FPR26    = 68,
    CV_PPC_FPR27    = 69,
    CV_PPC_FPR28    = 70,
    CV_PPC_FPR29    = 71,
    CV_PPC_FPR30    = 72,
    CV_PPC_FPR31    = 73,

    /*
    ** PowerPC Floating Point Status and Control Register ( User Level )
    */
    CV_PPC_FPSCR    = 74,

    /*
    ** PowerPC Machine State Register ( Supervisor Level )
    */
    CV_PPC_MSR      = 75,

    /*
    ** PowerPC Segment Registers ( Supervisor Level )
    */
    CV_PPC_SR0      = 76,
    CV_PPC_SR1      = 77,
    CV_PPC_SR2      = 78,
    CV_PPC_SR3      = 79,
    CV_PPC_SR4      = 80,
    CV_PPC_SR5      = 81,
    CV_PPC_SR6      = 82,
    CV_PPC_SR7      = 83,
    CV_PPC_SR8      = 84,
    CV_PPC_SR9      = 85,
    CV_PPC_SR10     = 86,
    CV_PPC_SR11     = 87,
    CV_PPC_SR12     = 88,
    CV_PPC_SR13     = 89,
    CV_PPC_SR14     = 90,
    CV_PPC_SR15     = 91,

    /*
    ** For all of the special purpose registers add 100 to the SPR# that the
    ** Motorola/IBM documentation gives with the exception of any imaginary
    ** registers.
    */

    /*
    ** PowerPC Special Purpose Registers ( User Level )
    */
    CV_PPC_PC       = 99,     // PC (imaginary register)

    CV_PPC_MQ       = 100,    // MPC601
    CV_PPC_XER      = 101,
    CV_PPC_RTCU     = 104,    // MPC601
    CV_PPC_RTCL     = 105,    // MPC601
    CV_PPC_LR       = 108,
    CV_PPC_CTR      = 109,

    CV_PPC_COMPARE  = 110,    // part of XER (internal to the debugger only)
    CV_PPC_COUNT    = 111,    // part of XER (internal to the debugger only)

    /*
    ** PowerPC Special Purpose Registers ( Supervisor Level )
    */
    CV_PPC_DSISR    = 118,
    CV_PPC_DAR      = 119,
    CV_PPC_DEC      = 122,
    CV_PPC_SDR1     = 125,
    CV_PPC_SRR0     = 126,
    CV_PPC_SRR1     = 127,
    CV_PPC_SPRG0    = 372,
    CV_PPC_SPRG1    = 373,
    CV_PPC_SPRG2    = 374,
    CV_PPC_SPRG3    = 375,
    CV_PPC_ASR      = 280,    // 64-bit implementations only
    CV_PPC_EAR      = 382,
    CV_PPC_PVR      = 287,
    CV_PPC_BAT0U    = 628,
    CV_PPC_BAT0L    = 629,
    CV_PPC_BAT1U    = 630,
    CV_PPC_BAT1L    = 631,
    CV_PPC_BAT2U    = 632,
    CV_PPC_BAT2L    = 633,
    CV_PPC_BAT3U    = 634,
    CV_PPC_BAT3L    = 635,
    CV_PPC_DBAT0U   = 636,
    CV_PPC_DBAT0L   = 637,
    CV_PPC_DBAT1U   = 638,
    CV_PPC_DBAT1L   = 639,
    CV_PPC_DBAT2U   = 640,
    CV_PPC_DBAT2L   = 641,
    CV_PPC_DBAT3U   = 642,
    CV_PPC_DBAT3L   = 643,

    /*
    ** PowerPC Special Purpose Registers Implementation Dependent ( Supervisor Level )
    */

    /*
    ** Doesn't appear that IBM/Motorola has finished defining these.
    */

    CV_PPC_PMR0     = 1044,   // MPC620,
    CV_PPC_PMR1     = 1045,   // MPC620,
    CV_PPC_PMR2     = 1046,   // MPC620,
    CV_PPC_PMR3     = 1047,   // MPC620,
    CV_PPC_PMR4     = 1048,   // MPC620,
    CV_PPC_PMR5     = 1049,   // MPC620,
    CV_PPC_PMR6     = 1050,   // MPC620,
    CV_PPC_PMR7     = 1051,   // MPC620,
    CV_PPC_PMR8     = 1052,   // MPC620,
    CV_PPC_PMR9     = 1053,   // MPC620,
    CV_PPC_PMR10    = 1054,   // MPC620,
    CV_PPC_PMR11    = 1055,   // MPC620,
    CV_PPC_PMR12    = 1056,   // MPC620,
    CV_PPC_PMR13    = 1057,   // MPC620,
    CV_PPC_PMR14    = 1058,   // MPC620,
    CV_PPC_PMR15    = 1059,   // MPC620,

    CV_PPC_DMISS    = 1076,   // MPC603
    CV_PPC_DCMP     = 1077,   // MPC603
    CV_PPC_HASH1    = 1078,   // MPC603
    CV_PPC_HASH2    = 1079,   // MPC603
    CV_PPC_IMISS    = 1080,   // MPC603
    CV_PPC_ICMP     = 1081,   // MPC603
    CV_PPC_RPA      = 1082,   // MPC603

    CV_PPC_HID0     = 1108,   // MPC601, MPC603, MPC620
    CV_PPC_HID1     = 1109,   // MPC601
    CV_PPC_HID2     = 1110,   // MPC601, MPC603, MPC620 ( IABR )
    CV_PPC_HID3     = 1111,   // Not Defined
    CV_PPC_HID4     = 1112,   // Not Defined
    CV_PPC_HID5     = 1113,   // MPC601, MPC604, MPC620 ( DABR )
    CV_PPC_HID6     = 1114,   // Not Defined
    CV_PPC_HID7     = 1115,   // Not Defined
    CV_PPC_HID8     = 1116,   // MPC620 ( BUSCSR )
    CV_PPC_HID9     = 1117,   // MPC620 ( L2CSR )
    CV_PPC_HID10    = 1118,   // Not Defined
    CV_PPC_HID11    = 1119,   // Not Defined
    CV_PPC_HID12    = 1120,   // Not Defined
    CV_PPC_HID13    = 1121,   // MPC604 ( HCR )
    CV_PPC_HID14    = 1122,   // Not Defined
    CV_PPC_HID15    = 1123,   // MPC601, MPC604, MPC620 ( PIR )

    //
    // JAVA VM registers
    //

    CV_JAVA_PC      = 1,

    //
    // Register set for the Hitachi SH3
    //

    CV_SH3_NOREG    =   CV_REG_NONE,

    CV_SH3_IntR0    =   10,   // CPU REGISTER
    CV_SH3_IntR1    =   11,
    CV_SH3_IntR2    =   12,
    CV_SH3_IntR3    =   13,
    CV_SH3_IntR4    =   14,
    CV_SH3_IntR5    =   15,
    CV_SH3_IntR6    =   16,
    CV_SH3_IntR7    =   17,
    CV_SH3_IntR8    =   18,
    CV_SH3_IntR9    =   19,
    CV_SH3_IntR10   =   20,
    CV_SH3_IntR11   =   21,
    CV_SH3_IntR12   =   22,
    CV_SH3_IntR13   =   23,
    CV_SH3_IntFp    =   24,
    CV_SH3_IntSp    =   25,
    CV_SH3_Gbr      =   38,
    CV_SH3_Pr       =   39,
    CV_SH3_Mach     =   40,
    CV_SH3_Macl     =   41,

    CV_SH3_Pc       =   50,
    CV_SH3_Sr       =   51,

    CV_SH3_BarA     =   60,
    CV_SH3_BasrA    =   61,
    CV_SH3_BamrA    =   62,
    CV_SH3_BbrA     =   63,
    CV_SH3_BarB     =   64,
    CV_SH3_BasrB    =   65,
    CV_SH3_BamrB    =   66,
    CV_SH3_BbrB     =   67,
    CV_SH3_BdrB     =   68,
    CV_SH3_BdmrB    =   69,
    CV_SH3_Brcr     =   70,

    //
    // Additional registers for Hitachi SH processors
    //

    CV_SH_Fpscr    =   75,    // floating point status/control register
    CV_SH_Fpul     =   76,    // floating point communication register

    CV_SH_FpR0     =   80,    // Floating point registers
    CV_SH_FpR1     =   81,
    CV_SH_FpR2     =   82,
    CV_SH_FpR3     =   83,
    CV_SH_FpR4     =   84,
    CV_SH_FpR5     =   85,
    CV_SH_FpR6     =   86,
    CV_SH_FpR7     =   87,
    CV_SH_FpR8     =   88,
    CV_SH_FpR9     =   89,
    CV_SH_FpR10    =   90,
    CV_SH_FpR11    =   91,
    CV_SH_FpR12    =   92,
    CV_SH_FpR13    =   93,
    CV_SH_FpR14    =   94,
    CV_SH_FpR15    =   95,

    CV_SH_XFpR0    =   96,
    CV_SH_XFpR1    =   97,
    CV_SH_XFpR2    =   98,
    CV_SH_XFpR3    =   99,
    CV_SH_XFpR4    =  100,
    CV_SH_XFpR5    =  101,
    CV_SH_XFpR6    =  102,
    CV_SH_XFpR7    =  103,
    CV_SH_XFpR8    =  104,
    CV_SH_XFpR9    =  105,
    CV_SH_XFpR10   =  106,
    CV_SH_XFpR11   =  107,
    CV_SH_XFpR12   =  108,
    CV_SH_XFpR13   =  109,
    CV_SH_XFpR14   =  110,
    CV_SH_XFpR15   =  111,

    //
    // Register set for the ARM processor.
    //

    CV_ARM_NOREG    =   CV_REG_NONE,

    CV_ARM_R0       =   10,
    CV_ARM_R1       =   11,
    CV_ARM_R2       =   12,
    CV_ARM_R3       =   13,
    CV_ARM_R4       =   14,
    CV_ARM_R5       =   15,
    CV_ARM_R6       =   16,
    CV_ARM_R7       =   17,
    CV_ARM_R8       =   18,
    CV_ARM_R9       =   19,
    CV_ARM_R10      =   20,
    CV_ARM_R11      =   21, // Frame pointer, if allocated
    CV_ARM_R12      =   22,
    CV_ARM_SP       =   23, // Stack pointer
    CV_ARM_LR       =   24, // Link Register
    CV_ARM_PC       =   25, // Program counter
    CV_ARM_CPSR     =   26, // Current program status register

    //
    // Register set for Intel IA64
    //

    CV_IA64_NOREG   =   CV_REG_NONE,

    // Branch Registers

    CV_IA64_Br0     =   512,
    CV_IA64_Br1     =   513,
    CV_IA64_Br2     =   514,
    CV_IA64_Br3     =   515,
    CV_IA64_Br4     =   516,
    CV_IA64_Br5     =   517,
    CV_IA64_Br6     =   518,
    CV_IA64_Br7     =   519,

    // Predicate Registers

    CV_IA64_P0	  =   704,
    CV_IA64_P1    =   705,
    CV_IA64_P2    =   706,
    CV_IA64_P3    =   707,
    CV_IA64_P4    =   708,
    CV_IA64_P5    =   709,
    CV_IA64_P6    =   710,
    CV_IA64_P7    =   711,
    CV_IA64_P8    =   712,
    CV_IA64_P9    =   713,
    CV_IA64_P10   =   714,
    CV_IA64_P11   =   715,
    CV_IA64_P12   =   716,
    CV_IA64_P13   =   717,
    CV_IA64_P14   =   718,
    CV_IA64_P15   =   719,
    CV_IA64_P16   =   720,
    CV_IA64_P17   =   721,
    CV_IA64_P18   =   722,
    CV_IA64_P19   =   723,
    CV_IA64_P20   =   724,
    CV_IA64_P21   =   725,
    CV_IA64_P22   =   726,
    CV_IA64_P23   =   727,
    CV_IA64_P24   =   728,
    CV_IA64_P25   =   729,
    CV_IA64_P26   =   730,
    CV_IA64_P27   =   731,
    CV_IA64_P28   =   732,
    CV_IA64_P29   =   733,
    CV_IA64_P30   =   734,
    CV_IA64_P31   =   735,
    CV_IA64_P32   =   736,
    CV_IA64_P33   =   737,
    CV_IA64_P34   =   738,
    CV_IA64_P35   =   739,
    CV_IA64_P36   =   740,
    CV_IA64_P37   =   741,
    CV_IA64_P38   =   742,
    CV_IA64_P39   =   743,
    CV_IA64_P40   =   744,
    CV_IA64_P41   =   745,
    CV_IA64_P42   =   746,
    CV_IA64_P43   =   747,
    CV_IA64_P44   =   748,
    CV_IA64_P45   =   749,
    CV_IA64_P46   =   750,
    CV_IA64_P47   =   751,
    CV_IA64_P48   =   752,
    CV_IA64_P49   =   753,
    CV_IA64_P50   =   754,
    CV_IA64_P51   =   755,
    CV_IA64_P52   =   756,
    CV_IA64_P53   =   757,
    CV_IA64_P54   =   758,
    CV_IA64_P55   =   759,
    CV_IA64_P56   =   760,
    CV_IA64_P57   =   761,
    CV_IA64_P58   =   762,
    CV_IA64_P59   =   763,
    CV_IA64_P60   =   764,
    CV_IA64_P61   =   765,
    CV_IA64_P62   =   766,
    CV_IA64_P63   =   767,

    CV_IA64_Preds   =   768,

    // Banked General Registers

    CV_IA64_IntH0   =   832,
    CV_IA64_IntH1   =   833,
    CV_IA64_IntH2   =   834,
    CV_IA64_IntH3   =   835,
    CV_IA64_IntH4   =   836,
    CV_IA64_IntH5   =   837,
    CV_IA64_IntH6   =   838,
    CV_IA64_IntH7   =   839,
    CV_IA64_IntH8   =   840,
    CV_IA64_IntH9   =   841,
    CV_IA64_IntH10  =   842,
    CV_IA64_IntH11  =   843,
    CV_IA64_IntH12  =   844,
    CV_IA64_IntH13  =   845,
    CV_IA64_IntH14  =   846,
    CV_IA64_IntH15  =   847,

    // Special Registers

    CV_IA64_Ip      =   1016,
    CV_IA64_Umask   =   1017,
    CV_IA64_Cfm     =   1018,
    CV_IA64_Psr     =   1019,

    // Banked General Registers

    CV_IA64_Nats    =   1020,
    CV_IA64_Nats2   =   1021,
    CV_IA64_Nats3   =   1022,

    // General-Purpose Registers

    // Integer registers
    CV_IA64_IntR0   =   1024,
    CV_IA64_IntR1   =   1025,
    CV_IA64_IntR2   =   1026,
    CV_IA64_IntR3   =   1027,
    CV_IA64_IntR4   =   1028,
    CV_IA64_IntR5   =   1029,
    CV_IA64_IntR6   =   1030,
    CV_IA64_IntR7   =   1031,
    CV_IA64_IntR8   =   1032,
    CV_IA64_IntR9   =   1033,
    CV_IA64_IntR10  =   1034,
    CV_IA64_IntR11  =   1035,
    CV_IA64_IntR12  =   1036,
    CV_IA64_IntR13  =   1037,
    CV_IA64_IntR14  =   1038,
    CV_IA64_IntR15  =   1039,
    CV_IA64_IntR16  =   1040,
    CV_IA64_IntR17  =   1041,
    CV_IA64_IntR18  =   1042,
    CV_IA64_IntR19  =   1043,
    CV_IA64_IntR20  =   1044,
    CV_IA64_IntR21  =   1045,
    CV_IA64_IntR22  =   1046,
    CV_IA64_IntR23  =   1047,
    CV_IA64_IntR24  =   1048,
    CV_IA64_IntR25  =   1049,
    CV_IA64_IntR26  =   1050,
    CV_IA64_IntR27  =   1051,
    CV_IA64_IntR28  =   1052,
    CV_IA64_IntR29  =   1053,
    CV_IA64_IntR30  =   1054,
    CV_IA64_IntR31  =   1055,

    // Register Stack
    CV_IA64_IntR32  =   1056,
    CV_IA64_IntR33  =   1057,
    CV_IA64_IntR34  =   1058,
    CV_IA64_IntR35  =   1059,
    CV_IA64_IntR36  =   1060,
    CV_IA64_IntR37  =   1061,
    CV_IA64_IntR38  =   1062,
    CV_IA64_IntR39  =   1063,
    CV_IA64_IntR40  =   1064,
    CV_IA64_IntR41  =   1065,
    CV_IA64_IntR42  =   1066,
    CV_IA64_IntR43  =   1067,
    CV_IA64_IntR44  =   1068,
    CV_IA64_IntR45  =   1069,
    CV_IA64_IntR46  =   1070,
    CV_IA64_IntR47  =   1071,
    CV_IA64_IntR48  =   1072,
    CV_IA64_IntR49  =   1073,
    CV_IA64_IntR50  =   1074,
    CV_IA64_IntR51  =   1075,
    CV_IA64_IntR52  =   1076,
    CV_IA64_IntR53  =   1077,
    CV_IA64_IntR54  =   1078,
    CV_IA64_IntR55  =   1079,
    CV_IA64_IntR56  =   1080,
    CV_IA64_IntR57  =   1081,
    CV_IA64_IntR58  =   1082,
    CV_IA64_IntR59  =   1083,
    CV_IA64_IntR60  =   1084,
    CV_IA64_IntR61  =   1085,
    CV_IA64_IntR62  =   1086,
    CV_IA64_IntR63  =   1087,
    CV_IA64_IntR64  =   1088,
    CV_IA64_IntR65  =   1089,
    CV_IA64_IntR66  =   1090,
    CV_IA64_IntR67  =   1091,
    CV_IA64_IntR68  =   1092,
    CV_IA64_IntR69  =   1093,
    CV_IA64_IntR70  =   1094,
    CV_IA64_IntR71  =   1095,
    CV_IA64_IntR72  =   1096,
    CV_IA64_IntR73  =   1097,
    CV_IA64_IntR74  =   1098,
    CV_IA64_IntR75  =   1099,
    CV_IA64_IntR76  =   1100,
    CV_IA64_IntR77  =   1101,
    CV_IA64_IntR78  =   1102,
    CV_IA64_IntR79  =   1103,
    CV_IA64_IntR80  =   1104,
    CV_IA64_IntR81  =   1105,
    CV_IA64_IntR82  =   1106,
    CV_IA64_IntR83  =   1107,
    CV_IA64_IntR84  =   1108,
    CV_IA64_IntR85  =   1109,
    CV_IA64_IntR86  =   1110,
    CV_IA64_IntR87  =   1111,
    CV_IA64_IntR88  =   1112,
    CV_IA64_IntR89  =   1113,
    CV_IA64_IntR90  =   1114,
    CV_IA64_IntR91  =   1115,
    CV_IA64_IntR92  =   1116,
    CV_IA64_IntR93  =   1117,
    CV_IA64_IntR94  =   1118,
    CV_IA64_IntR95  =   1119,
    CV_IA64_IntR96  =   1120,
    CV_IA64_IntR97  =   1121,
    CV_IA64_IntR98  =   1122,
    CV_IA64_IntR99  =   1123,
    CV_IA64_IntR100 =   1124,
    CV_IA64_IntR101 =   1125,
    CV_IA64_IntR102 =   1126,
    CV_IA64_IntR103 =   1127,
    CV_IA64_IntR104 =   1128,
    CV_IA64_IntR105 =   1129,
    CV_IA64_IntR106 =   1130,
    CV_IA64_IntR107 =   1131,
    CV_IA64_IntR108 =   1132,
    CV_IA64_IntR109 =   1133,
    CV_IA64_IntR110 =   1134,
    CV_IA64_IntR111 =   1135,
    CV_IA64_IntR112 =   1136,
    CV_IA64_IntR113 =   1137,
    CV_IA64_IntR114 =   1138,
    CV_IA64_IntR115 =   1139,
    CV_IA64_IntR116 =   1140,
    CV_IA64_IntR117 =   1141,
    CV_IA64_IntR118 =   1142,
    CV_IA64_IntR119 =   1143,
    CV_IA64_IntR120 =   1144,
    CV_IA64_IntR121 =   1145,
    CV_IA64_IntR122 =   1146,
    CV_IA64_IntR123 =   1147,
    CV_IA64_IntR124 =   1148,
    CV_IA64_IntR125 =   1149,
    CV_IA64_IntR126 =   1150,
    CV_IA64_IntR127 =   1151,

    // Floating-Point Registers

    // Low Floating Point Registers
    CV_IA64_FltF0   =   2048,
    CV_IA64_FltF1   =   2049,
    CV_IA64_FltF2   =   2050,
    CV_IA64_FltF3   =   2051,
    CV_IA64_FltF4   =   2052,
    CV_IA64_FltF5   =   2053,
    CV_IA64_FltF6   =   2054,
    CV_IA64_FltF7   =   2055,
    CV_IA64_FltF8   =   2056,
    CV_IA64_FltF9   =   2057,
    CV_IA64_FltF10  =   2058,
    CV_IA64_FltF11  =   2059,
    CV_IA64_FltF12  =   2060,
    CV_IA64_FltF13  =   2061,
    CV_IA64_FltF14  =   2062,
    CV_IA64_FltF15  =   2063,
    CV_IA64_FltF16  =   2064,
    CV_IA64_FltF17  =   2065,
    CV_IA64_FltF18  =   2066,
    CV_IA64_FltF19  =   2067,
    CV_IA64_FltF20  =   2068,
    CV_IA64_FltF21  =   2069,
    CV_IA64_FltF22  =   2070,
    CV_IA64_FltF23  =   2071,
    CV_IA64_FltF24  =   2072,
    CV_IA64_FltF25  =   2073,
    CV_IA64_FltF26  =   2074,
    CV_IA64_FltF27  =   2075,
    CV_IA64_FltF28  =   2076,
    CV_IA64_FltF29  =   2077,
    CV_IA64_FltF30  =   2078,
    CV_IA64_FltF31  =   2079,

    // High Floating Point Registers
    CV_IA64_FltF32  =   2080,
    CV_IA64_FltF33  =   2081,
    CV_IA64_FltF34  =   2082,
    CV_IA64_FltF35  =   2083,
    CV_IA64_FltF36  =   2084,
    CV_IA64_FltF37  =   2085,
    CV_IA64_FltF38  =   2086,
    CV_IA64_FltF39  =   2087,
    CV_IA64_FltF40  =   2088,
    CV_IA64_FltF41  =   2089,
    CV_IA64_FltF42  =   2090,
    CV_IA64_FltF43  =   2091,
    CV_IA64_FltF44  =   2092,
    CV_IA64_FltF45  =   2093,
    CV_IA64_FltF46  =   2094,
    CV_IA64_FltF47  =   2095,
    CV_IA64_FltF48  =   2096,
    CV_IA64_FltF49  =   2097,
    CV_IA64_FltF50  =   2098,
    CV_IA64_FltF51  =   2099,
    CV_IA64_FltF52  =   2100,
    CV_IA64_FltF53  =   2101,
    CV_IA64_FltF54  =   2102,
    CV_IA64_FltF55  =   2103,
    CV_IA64_FltF56  =   2104,
    CV_IA64_FltF57  =   2105,
    CV_IA64_FltF58  =   2106,
    CV_IA64_FltF59  =   2107,
    CV_IA64_FltF60  =   2108,
    CV_IA64_FltF61  =   2109,
    CV_IA64_FltF62  =   2110,
    CV_IA64_FltF63  =   2111,
    CV_IA64_FltF64  =   2112,
    CV_IA64_FltF65  =   2113,
    CV_IA64_FltF66  =   2114,
    CV_IA64_FltF67  =   2115,
    CV_IA64_FltF68  =   2116,
    CV_IA64_FltF69  =   2117,
    CV_IA64_FltF70  =   2118,
    CV_IA64_FltF71  =   2119,
    CV_IA64_FltF72  =   2120,
    CV_IA64_FltF73  =   2121,
    CV_IA64_FltF74  =   2122,
    CV_IA64_FltF75  =   2123,
    CV_IA64_FltF76  =   2124,
    CV_IA64_FltF77  =   2125,
    CV_IA64_FltF78  =   2126,
    CV_IA64_FltF79  =   2127,
    CV_IA64_FltF80  =   2128,
    CV_IA64_FltF81  =   2129,
    CV_IA64_FltF82  =   2130,
    CV_IA64_FltF83  =   2131,
    CV_IA64_FltF84  =   2132,
    CV_IA64_FltF85  =   2133,
    CV_IA64_FltF86  =   2134,
    CV_IA64_FltF87  =   2135,
    CV_IA64_FltF88  =   2136,
    CV_IA64_FltF89  =   2137,
    CV_IA64_FltF90  =   2138,
    CV_IA64_FltF91  =   2139,
    CV_IA64_FltF92  =   2140,
    CV_IA64_FltF93  =   2141,
    CV_IA64_FltF94  =   2142,
    CV_IA64_FltF95  =   2143,
    CV_IA64_FltF96  =   2144,
    CV_IA64_FltF97  =   2145,
    CV_IA64_FltF98  =   2146,
    CV_IA64_FltF99  =   2147,
    CV_IA64_FltF100 =   2148,
    CV_IA64_FltF101 =   2149,
    CV_IA64_FltF102 =   2150,
    CV_IA64_FltF103 =   2151,
    CV_IA64_FltF104 =   2152,
    CV_IA64_FltF105 =   2153,
    CV_IA64_FltF106 =   2154,
    CV_IA64_FltF107 =   2155,
    CV_IA64_FltF108 =   2156,
    CV_IA64_FltF109 =   2157,
    CV_IA64_FltF110 =   2158,
    CV_IA64_FltF111 =   2159,
    CV_IA64_FltF112 =   2160,
    CV_IA64_FltF113 =   2161,
    CV_IA64_FltF114 =   2162,
    CV_IA64_FltF115 =   2163,
    CV_IA64_FltF116 =   2164,
    CV_IA64_FltF117 =   2165,
    CV_IA64_FltF118 =   2166,
    CV_IA64_FltF119 =   2167,
    CV_IA64_FltF120 =   2168,
    CV_IA64_FltF121 =   2169,
    CV_IA64_FltF122 =   2170,
    CV_IA64_FltF123 =   2171,
    CV_IA64_FltF124 =   2172,
    CV_IA64_FltF125 =   2173,
    CV_IA64_FltF126 =   2174,
    CV_IA64_FltF127 =   2175,

    // Application Registers

    CV_IA64_ApKR0   =   3072,
    CV_IA64_ApKR1   =   3073,
    CV_IA64_ApKR2   =   3074,
    CV_IA64_ApKR3   =   3075,
    CV_IA64_ApKR4   =   3076,
    CV_IA64_ApKR5   =   3077,
    CV_IA64_ApKR6   =   3078,
    CV_IA64_ApKR7   =   3079,
    CV_IA64_AR8     =   3080,
    CV_IA64_AR9     =   3081,
    CV_IA64_AR10    =   3082,
    CV_IA64_AR11    =   3083,
    CV_IA64_AR12    =   3084,
    CV_IA64_AR13    =   3085,
    CV_IA64_AR14    =   3086,
    CV_IA64_AR15    =   3087,
    CV_IA64_RsRSC   =   3088,
    CV_IA64_RsBSP   =   3089,
    CV_IA64_RsBSPSTORE  =   3090,
    CV_IA64_RsRNAT  =   3091,
    CV_IA64_AR20    =   3092,
    CV_IA64_StFCR   =   3093,
    CV_IA64_AR22    =   3094,
    CV_IA64_AR23    =   3095,
    CV_IA64_EFLAG   =   3096,
    CV_IA64_CSD     =   3097,
    CV_IA64_SSD     =   3098,
    CV_IA64_CFLG    =   3099,
    CV_IA64_StFSR   =   3100,
    CV_IA64_StFIR   =   3101,
    CV_IA64_StFDR   =   3102,
    CV_IA64_AR31    =   3103,
    CV_IA64_ApCCV   =   3104,
    CV_IA64_AR33    =   3105,
    CV_IA64_AR34    =   3106,
    CV_IA64_AR35    =   3107,
    CV_IA64_ApUNAT  =   3108,
    CV_IA64_AR37    =   3109,
    CV_IA64_AR38    =   3110,
    CV_IA64_AR39    =   3111,
    CV_IA64_StFPSR  =   3112,
    CV_IA64_AR41    =   3113,
    CV_IA64_AR42    =   3114,
    CV_IA64_AR43    =   3115,
    CV_IA64_ApITC   =   3116,
    CV_IA64_AR45    =   3117,
    CV_IA64_AR46    =   3118,
    CV_IA64_AR47    =   3119,
    CV_IA64_AR48    =   3120,
    CV_IA64_AR49    =   3121,
    CV_IA64_AR50    =   3122,
    CV_IA64_AR51    =   3123,
    CV_IA64_AR52    =   3124,
    CV_IA64_AR53    =   3125,
    CV_IA64_AR54    =   3126,
    CV_IA64_AR55    =   3127,
    CV_IA64_AR56    =   3128,
    CV_IA64_AR57    =   3129,
    CV_IA64_AR58    =   3130,
    CV_IA64_AR59    =   3131,
    CV_IA64_AR60    =   3132,
    CV_IA64_AR61    =   3133,
    CV_IA64_AR62    =   3134,
    CV_IA64_AR63    =   3135,
    CV_IA64_RsPFS   =   3136,
    CV_IA64_ApLC    =   3137,
    CV_IA64_ApEC    =   3138,
    CV_IA64_AR67    =   3139,
    CV_IA64_AR68    =   3140,
    CV_IA64_AR69    =   3141,
    CV_IA64_AR70    =   3142,
    CV_IA64_AR71    =   3143,
    CV_IA64_AR72    =   3144,
    CV_IA64_AR73    =   3145,
    CV_IA64_AR74    =   3146,
    CV_IA64_AR75    =   3147,
    CV_IA64_AR76    =   3148,
    CV_IA64_AR77    =   3149,
    CV_IA64_AR78    =   3150,
    CV_IA64_AR79    =   3151,
    CV_IA64_AR80    =   3152,
    CV_IA64_AR81    =   3153,
    CV_IA64_AR82    =   3154,
    CV_IA64_AR83    =   3155,
    CV_IA64_AR84    =   3156,
    CV_IA64_AR85    =   3157,
    CV_IA64_AR86    =   3158,
    CV_IA64_AR87    =   3159,
    CV_IA64_AR88    =   3160,
    CV_IA64_AR89    =   3161,
    CV_IA64_AR90    =   3162,
    CV_IA64_AR91    =   3163,
    CV_IA64_AR92    =   3164,
    CV_IA64_AR93    =   3165,
    CV_IA64_AR94    =   3166,
    CV_IA64_AR95    =   3167,
    CV_IA64_AR96    =   3168,
    CV_IA64_AR97    =   3169,
    CV_IA64_AR98    =   3170,
    CV_IA64_AR99    =   3171,
    CV_IA64_AR100   =   3172,
    CV_IA64_AR101   =   3173,
    CV_IA64_AR102   =   3174,
    CV_IA64_AR103   =   3175,
    CV_IA64_AR104   =   3176,
    CV_IA64_AR105   =   3177,
    CV_IA64_AR106   =   3178,
    CV_IA64_AR107   =   3179,
    CV_IA64_AR108   =   3180,
    CV_IA64_AR109   =   3181,
    CV_IA64_AR110   =   3182,
    CV_IA64_AR111   =   3183,
    CV_IA64_AR112   =   3184,
    CV_IA64_AR113   =   3185,
    CV_IA64_AR114   =   3186,
    CV_IA64_AR115   =   3187,
    CV_IA64_AR116   =   3188,
    CV_IA64_AR117   =   3189,
    CV_IA64_AR118   =   3190,
    CV_IA64_AR119   =   3191,
    CV_IA64_AR120   =   3192,
    CV_IA64_AR121   =   3193,
    CV_IA64_AR122   =   3194,
    CV_IA64_AR123   =   3195,
    CV_IA64_AR124   =   3196,
    CV_IA64_AR125   =   3197,
    CV_IA64_AR126   =   3198,
    CV_IA64_AR127   =   3199,

    // CPUID Registers

    CV_IA64_CPUID0  =   3328,
    CV_IA64_CPUID1  =   3329,
    CV_IA64_CPUID2  =   3330,
    CV_IA64_CPUID3  =   3331,
    CV_IA64_CPUID4  =   3332,
    
    // Control Registers

    CV_IA64_ApDCR   =   4096,
    CV_IA64_ApITM   =   4097,
    CV_IA64_ApIVA   =   4098,
    CV_IA64_CR3     =   4099,
    CV_IA64_CR4     =   4100,
    CV_IA64_CR5     =   4101,
    CV_IA64_CR6     =   4102,
    CV_IA64_CR7     =   4103,
    CV_IA64_ApPTA   =   4104,
    CV_IA64_ApGPTA  =   4105,
    CV_IA64_CR10    =   4106,
    CV_IA64_CR11    =   4107,
    CV_IA64_CR12    =   4108,
    CV_IA64_CR13    =   4109,
    CV_IA64_CR14    =   4110,
    CV_IA64_CR15    =   4111,
    CV_IA64_StIPSR  =   4112,
    CV_IA64_StISR   =   4113,
    CV_IA64_CR18    =   4114,
    CV_IA64_StIIP   =   4115,
    CV_IA64_StIFA   =   4116,
    CV_IA64_StITIR  =   4117,
    CV_IA64_StIIPA  =   4118,
    CV_IA64_StIFS   =   4119,
    CV_IA64_StIIM   =   4120,
    CV_IA64_StIHA   =   4121,
    CV_IA64_CR26    =   4122,
    CV_IA64_CR27    =   4123,
    CV_IA64_CR28    =   4124,
    CV_IA64_CR29    =   4125,
    CV_IA64_CR30    =   4126,
    CV_IA64_CR31    =   4127,
    CV_IA64_CR32    =   4128,
    CV_IA64_CR33    =   4129,
    CV_IA64_CR34    =   4130,
    CV_IA64_CR35    =   4131,
    CV_IA64_CR36    =   4132,
    CV_IA64_CR37    =   4133,
    CV_IA64_CR38    =   4134,
    CV_IA64_CR39    =   4135,
    CV_IA64_CR40    =   4136,
    CV_IA64_CR41    =   4137,
    CV_IA64_CR42    =   4138,
    CV_IA64_CR43    =   4139,
    CV_IA64_CR44    =   4140,
    CV_IA64_CR45    =   4141,
    CV_IA64_CR46    =   4142,
    CV_IA64_CR47    =   4143,
    CV_IA64_CR48    =   4144,
    CV_IA64_CR49    =   4145,
    CV_IA64_CR50    =   4146,
    CV_IA64_CR51    =   4147,
    CV_IA64_CR52    =   4148,
    CV_IA64_CR53    =   4149,
    CV_IA64_CR54    =   4150,
    CV_IA64_CR55    =   4151,
    CV_IA64_CR56    =   4152,
    CV_IA64_CR57    =   4153,
    CV_IA64_CR58    =   4154,
    CV_IA64_CR59    =   4155,
    CV_IA64_CR60    =   4156,
    CV_IA64_CR61    =   4157,
    CV_IA64_CR62    =   4158,
    CV_IA64_CR63    =   4159,
    CV_IA64_SaLID   =   4160,
    CV_IA64_SaIVR   =   4161,
    CV_IA64_SaTPR   =   4162,
    CV_IA64_SaEOI   =   4163,
    CV_IA64_SaIRR0  =   4164,
    CV_IA64_SaIRR1  =   4165,
    CV_IA64_SaIRR2  =   4166,
    CV_IA64_SaIRR3  =   4167,
    CV_IA64_SaITV   =   4168,
    CV_IA64_SaPMV   =   4169,
    CV_IA64_SaCMCV  =   4170,
    CV_IA64_CR75    =   4171,
    CV_IA64_CR76    =   4172,
    CV_IA64_CR77    =   4173,
    CV_IA64_CR78    =   4174,
    CV_IA64_CR79    =   4175,
    CV_IA64_SaLRR0  =   4176,
    CV_IA64_SaLRR1  =   4177,
    CV_IA64_CR82    =   4178,
    CV_IA64_CR83    =   4179,
    CV_IA64_CR84    =   4180,
    CV_IA64_CR85    =   4181,
    CV_IA64_CR86    =   4182,
    CV_IA64_CR87    =   4183,
    CV_IA64_CR88    =   4184,
    CV_IA64_CR89    =   4185,
    CV_IA64_CR90    =   4186,
    CV_IA64_CR91    =   4187,
    CV_IA64_CR92    =   4188,
    CV_IA64_CR93    =   4189,
    CV_IA64_CR94    =   4190,
    CV_IA64_CR95    =   4191,
    CV_IA64_CR96    =   4192,
    CV_IA64_CR97    =   4193,
    CV_IA64_CR98    =   4194,
    CV_IA64_CR99    =   4195,
    CV_IA64_CR100   =   4196,
    CV_IA64_CR101   =   4197,
    CV_IA64_CR102   =   4198,
    CV_IA64_CR103   =   4199,
    CV_IA64_CR104   =   4200,
    CV_IA64_CR105   =   4201,
    CV_IA64_CR106   =   4202,
    CV_IA64_CR107   =   4203,
    CV_IA64_CR108   =   4204,
    CV_IA64_CR109   =   4205,
    CV_IA64_CR110   =   4206,
    CV_IA64_CR111   =   4207,
    CV_IA64_CR112   =   4208,
    CV_IA64_CR113   =   4209,
    CV_IA64_CR114   =   4210,
    CV_IA64_CR115   =   4211,
    CV_IA64_CR116   =   4212,
    CV_IA64_CR117   =   4213,
    CV_IA64_CR118   =   4214,
    CV_IA64_CR119   =   4215,
    CV_IA64_CR120   =   4216,
    CV_IA64_CR121   =   4217,
    CV_IA64_CR122   =   4218,
    CV_IA64_CR123   =   4219,
    CV_IA64_CR124   =   4220,
    CV_IA64_CR125   =   4221,
    CV_IA64_CR126   =   4222,
    CV_IA64_CR127   =   4223,

    // Protection Key Registers

    CV_IA64_Pkr0    =   5120,
    CV_IA64_Pkr1    =   5121,
    CV_IA64_Pkr2    =   5122,
    CV_IA64_Pkr3    =   5123,
    CV_IA64_Pkr4    =   5124,
    CV_IA64_Pkr5    =   5125,
    CV_IA64_Pkr6    =   5126,
    CV_IA64_Pkr7    =   5127,
    CV_IA64_Pkr8    =   5128,
    CV_IA64_Pkr9    =   5129,
    CV_IA64_Pkr10   =   5130,
    CV_IA64_Pkr11   =   5131,
    CV_IA64_Pkr12   =   5132,
    CV_IA64_Pkr13   =   5133,
    CV_IA64_Pkr14   =   5134,
    CV_IA64_Pkr15   =   5135,

    // Region Registers

    CV_IA64_Rr0     =   6144,
    CV_IA64_Rr1     =   6145,
    CV_IA64_Rr2     =   6146,
    CV_IA64_Rr3     =   6147,
    CV_IA64_Rr4     =   6148,
    CV_IA64_Rr5     =   6149,
    CV_IA64_Rr6     =   6150,
    CV_IA64_Rr7     =   6151,

    // Performance Monitor Data Registers

    CV_IA64_PFD0    =   7168,
    CV_IA64_PFD1    =   7169,
    CV_IA64_PFD2    =   7170,
    CV_IA64_PFD3    =   7171,
    CV_IA64_PFD4    =   7172,
    CV_IA64_PFD5    =   7173,
    CV_IA64_PFD6    =   7174,
    CV_IA64_PFD7    =   7175,

    // Performance Monitor Config Registers

    CV_IA64_PFC0    =   7424,
    CV_IA64_PFC1    =   7425,
    CV_IA64_PFC2    =   7426,
    CV_IA64_PFC3    =   7427,
    CV_IA64_PFC4    =   7428,
    CV_IA64_PFC5    =   7429,
    CV_IA64_PFC6    =   7430,
    CV_IA64_PFC7    =   7431,

    // Instruction Translation Registers

    CV_IA64_TrI0    =   8192,
    CV_IA64_TrI1    =   8193,
    CV_IA64_TrI2    =   8194,
    CV_IA64_TrI3    =   8195,
    CV_IA64_TrI4    =   8196,
    CV_IA64_TrI5    =   8197,
    CV_IA64_TrI6    =   8198,
    CV_IA64_TrI7    =   8199,

    // Data Translation Registers

    CV_IA64_TrD0    =   8320,
    CV_IA64_TrD1    =   8321,
    CV_IA64_TrD2    =   8322,
    CV_IA64_TrD3    =   8323,
    CV_IA64_TrD4    =   8324,
    CV_IA64_TrD5    =   8325,
    CV_IA64_TrD6    =   8326,
    CV_IA64_TrD7    =   8327,

    // Instruction Breakpoint Registers

    CV_IA64_DbI0    =   8448,
    CV_IA64_DbI1    =   8449,
    CV_IA64_DbI2    =   8450,
    CV_IA64_DbI3    =   8451,
    CV_IA64_DbI4    =   8452,
    CV_IA64_DbI5    =   8453,
    CV_IA64_DbI6    =   8454,
    CV_IA64_DbI7    =   8455,

    // Data Breakpoint Registers

    CV_IA64_DbD0    =   8576,
    CV_IA64_DbD1    =   8577,
    CV_IA64_DbD2    =   8578,
    CV_IA64_DbD3    =   8579,
    CV_IA64_DbD4    =   8580,
    CV_IA64_DbD5    =   8581,
    CV_IA64_DbD6    =   8582,
    CV_IA64_DbD7    =   8583,

    //
    // Register set for the TriCore processor.
    //

    CV_TRI_NOREG    =   CV_REG_NONE,

    // General Purpose Data Registers

    CV_TRI_D0   =   10,
    CV_TRI_D1   =   11,
    CV_TRI_D2   =   12,
    CV_TRI_D3   =   13,
    CV_TRI_D4   =   14,
    CV_TRI_D5   =   15,
    CV_TRI_D6   =   16,
    CV_TRI_D7   =   17,
    CV_TRI_D8   =   18,
    CV_TRI_D9   =   19,
    CV_TRI_D10  =   20,
    CV_TRI_D11  =   21,
    CV_TRI_D12  =   22,
    CV_TRI_D13  =   23,
    CV_TRI_D14  =   24,
    CV_TRI_D15  =   25,

    // General Purpose Address Registers

    CV_TRI_A0   =   26,
    CV_TRI_A1   =   27,
    CV_TRI_A2   =   28,
    CV_TRI_A3   =   29,
    CV_TRI_A4   =   30,
    CV_TRI_A5   =   31,
    CV_TRI_A6   =   32,
    CV_TRI_A7   =   33,
    CV_TRI_A8   =   34,
    CV_TRI_A9   =   35,
    CV_TRI_A10  =   36,
    CV_TRI_A11  =   37,
    CV_TRI_A12  =   38,
    CV_TRI_A13  =   39,
    CV_TRI_A14  =   40,
    CV_TRI_A15  =   41,

    // Extended (64-bit) data registers

    CV_TRI_E0   =   42,
    CV_TRI_E2   =   43,
    CV_TRI_E4   =   44,
    CV_TRI_E6   =   45,
    CV_TRI_E8   =   46,
    CV_TRI_E10  =   47,
    CV_TRI_E12  =   48,
    CV_TRI_E14  =   49,

    // Extended (64-bit) address registers

    CV_TRI_EA0  =   50,
    CV_TRI_EA2  =   51,
    CV_TRI_EA4  =   52,
    CV_TRI_EA6  =   53,
    CV_TRI_EA8  =   54,
    CV_TRI_EA10 =   55,
    CV_TRI_EA12 =   56,
    CV_TRI_EA14 =   57,
    
    CV_TRI_PSW  =   58,
    CV_TRI_PCXI =   59,
    CV_TRI_PC   =   60,
    CV_TRI_FCX  =   61,
    CV_TRI_LCX  =   62,
    CV_TRI_ISP  =   63,
    CV_TRI_ICR  =   64,
    CV_TRI_BIV  =   65,
    CV_TRI_BTV  =   66,
    CV_TRI_SYSCON   =   67,
    CV_TRI_DPRx_0   =   68,
    CV_TRI_DPRx_1   =   69,
    CV_TRI_DPRx_2   =   70,
    CV_TRI_DPRx_3   =   71,
    CV_TRI_CPRx_0   =   68,
    CV_TRI_CPRx_1   =   69,
    CV_TRI_CPRx_2   =   70,
    CV_TRI_CPRx_3   =   71,
    CV_TRI_DPMx_0   =   68,
    CV_TRI_DPMx_1   =   69,
    CV_TRI_DPMx_2   =   70,
    CV_TRI_DPMx_3   =   71,
    CV_TRI_CPMx_0   =   68,
    CV_TRI_CPMx_1   =   69,
    CV_TRI_CPMx_2   =   70,
    CV_TRI_CPMx_3   =   71,
    CV_TRI_DBGSSR   =   72,
    CV_TRI_EXEVT    =   73,
    CV_TRI_SWEVT    =   74,
    CV_TRI_CREVT    =   75,
    CV_TRI_TRnEVT   =   76,
    CV_TRI_MMUCON   =   77,
    CV_TRI_ASI      =   78,
    CV_TRI_TVA      =   79,
    CV_TRI_TPA      =   80,
    CV_TRI_TPX      =   81,
    CV_TRI_TFA      =   82,

    //
    // Register set for the AM33 and related processors.
    //

    CV_AM33_NOREG   =   CV_REG_NONE,

    // "Extended" (general purpose integer) registers
    CV_AM33_E0      =   10,
    CV_AM33_E1      =   11,
    CV_AM33_E2      =   12,
    CV_AM33_E3      =   13,
    CV_AM33_E4      =   14,
    CV_AM33_E5      =   15,
    CV_AM33_E6      =   16,
    CV_AM33_E7      =   17,

    // Address registers
    CV_AM33_A0      =   20,
    CV_AM33_A1      =   21,
    CV_AM33_A2      =   22,
    CV_AM33_A3      =   23,

    // Integer data registers
    CV_AM33_D0      =   30,
    CV_AM33_D1      =   31,
    CV_AM33_D2      =   32,
    CV_AM33_D3      =   33,

    // (Single-precision) floating-point registers
    CV_AM33_FS0     =   40,
    CV_AM33_FS1     =   41,
    CV_AM33_FS2     =   42,
    CV_AM33_FS3     =   43,
    CV_AM33_FS4     =   44,
    CV_AM33_FS5     =   45,
    CV_AM33_FS6     =   46,
    CV_AM33_FS7     =   47,
    CV_AM33_FS8     =   48,
    CV_AM33_FS9     =   49,
    CV_AM33_FS10    =   50,
    CV_AM33_FS11    =   51,
    CV_AM33_FS12    =   52,
    CV_AM33_FS13    =   53,
    CV_AM33_FS14    =   54,
    CV_AM33_FS15    =   55,
    CV_AM33_FS16    =   56,
    CV_AM33_FS17    =   57,
    CV_AM33_FS18    =   58,
    CV_AM33_FS19    =   59,
    CV_AM33_FS20    =   60,
    CV_AM33_FS21    =   61,
    CV_AM33_FS22    =   62,
    CV_AM33_FS23    =   63,
    CV_AM33_FS24    =   64,
    CV_AM33_FS25    =   65,
    CV_AM33_FS26    =   66,
    CV_AM33_FS27    =   67,
    CV_AM33_FS28    =   68,
    CV_AM33_FS29    =   69,
    CV_AM33_FS30    =   70,
    CV_AM33_FS31    =   71,

    // Special purpose registers

    // Stack pointer
    CV_AM33_SP      =   80,

    // Program counter
    CV_AM33_PC      =   81,

    // Multiply-divide/accumulate registers
    CV_AM33_MDR     =   82,
    CV_AM33_MDRQ    =   83,
    CV_AM33_MCRH    =   84,
    CV_AM33_MCRL    =   85,
    CV_AM33_MCVF    =   86,

    // CPU status words
    CV_AM33_EPSW    =   87,
    CV_AM33_FPCR    =   88,

    // Loop buffer registers
    CV_AM33_LIR     =   89,
    CV_AM33_LAR     =   90,

    //
    // Register set for the Mitsubishi M32R
    //

    CV_M32R_NOREG    =   CV_REG_NONE,

    CV_M32R_R0    =   10,
    CV_M32R_R1    =   11,
    CV_M32R_R2    =   12,
    CV_M32R_R3    =   13,
    CV_M32R_R4    =   14,
    CV_M32R_R5    =   15,
    CV_M32R_R6    =   16,
    CV_M32R_R7    =   17,
    CV_M32R_R8    =   18,
    CV_M32R_R9    =   19,
    CV_M32R_R10   =   20,
    CV_M32R_R11   =   21,
    CV_M32R_R12   =   22,   // Gloabal Pointer, if used
    CV_M32R_R13   =   23,   // Frame Pointer, if allocated
    CV_M32R_R14   =   24,   // Link Register
    CV_M32R_R15   =   25,   // Stack Pointer    
    CV_M32R_PSW   =   26,   // Preocessor Status Register
    CV_M32R_CBR   =   27,   // Condition Bit Register
    CV_M32R_SPI   =   28,   // Interrupt Stack Pointer
    CV_M32R_SPU   =   29,   // User Stack Pointer
    CV_M32R_SPO   =   30,   // OS Stack Pointer
    CV_M32R_BPC   =   31,   // Backup Program Counter
    CV_M32R_ACHI  =   32,   // Accumulator High
    CV_M32R_ACLO  =   33,   // Accumulator Low
    CV_M32R_PC    =   34,   // Program Counter

} CV_HREG_e;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\dbg-common\dbgimage.h ===
//----------------------------------------------------------------------------
//
// Image Support.
//
// Copyright (C) Microsoft Corporation, 2000.
//
//----------------------------------------------------------------------------

// for reading debug directory info

#define NB10_SIG        ((DWORD)'01BN')
#define RSDS_SIG        ((DWORD)'SDSR')

typedef struct _NB10I              // NB10 debug info
{
    DWORD   dwSig;                 // NB10
    DWORD   dwOffset;              // offset, always 0
    ULONG   sig;
    ULONG   age;
    char    szPdb[_MAX_PATH];
} NB10I, *PNB10I;

typedef struct _NB10I_HEADER       // NB10 debug info
{
    DWORD   dwSig;                 // NB10
    DWORD   dwOffset;              // offset, always 0
    ULONG   sig;
    ULONG   age;
} NB10IH, *PNB10IH;

typedef struct _RSDSI              // RSDS debug info
{
    DWORD   dwSig;                 // RSDS
    GUID    guidSig;
    DWORD   age;
    char    szPdb[_MAX_PATH * 3];
} RSDSI, *PRSDSI;

typedef struct _RSDSI_HEADER       // RSDS debug info
{
    DWORD   dwSig;                 // RSDS
    GUID    guidSig;
    DWORD   age;
} RSDSIH, *PRSDSIH;

typedef union _CVDD
{
    DWORD   dwSig;
    NB10I   nb10i;
    RSDSI   rsdsi;
    NB10IH  nb10ih;
    RSDSIH  rsdsih;
} CVDD, *PCVDD;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\dbg-common\dbhpriv.h ===
/*
 * private stuff in dbghelp
 */

#ifdef __cplusplus
extern "C" {
#endif
  
BOOL
IMAGEAPI
dbghelp(
    IN     HANDLE hp,
    IN OUT PVOID  data
    );

enum {
    dbhNone = 0,
    dbhModSymInfo,
    dbhDiaVersion,
    dbhNumFunctions
};

typedef struct _DBH_MODSYMINFO {
    DWORD   function;
    DWORD   sizeofstruct;
    DWORD64 addr;
    DWORD   type;
    char    file[MAX_PATH + 1];
} DBH_MODSYMINFO, *PDBH_MODSYMINFO;

typedef struct _DBH_DIAVERSION {
    DWORD   function;
    DWORD   sizeofstruct;
    DWORD   ver;
} DBH_DIAVERSION, *PDBH_DIAVERSION;

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\dbg-common\dhhelp.h ===
//----------------------------------------------------------------------------
//
// Help support.
//
// Copyright (C) Microsoft Corporation, 2000-2001.
//
//----------------------------------------------------------------------------

#ifndef _DHHELP_H_
#define _DHHELP_H_

#include <dhtopics.h>

#define HELP_TOPIC_TABLE_OF_CONTENTS 1

enum
{
    HELP_SUCCESS,
    HELP_NO_SUCH_PAGE,
    HELP_FAILURE
};

extern CHAR g_HelpFileName[];

void MakeHelpFileName(PSTR File);
ULONG OpenHelpTopic(ULONG PageConstant);
ULONG OpenHelpIndex(PCSTR IndexText);
ULONG OpenHelpSearch(PCSTR SearchText);
BOOL SpawnHelp(ULONG Topic);

#endif // #ifndef _DHHELP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\dbg-common\cmnutil.hpp ===
//----------------------------------------------------------------------------
//
// General utility routines.
//
// Copyright (C) Microsoft Corporation, 2000-2001.
//
//----------------------------------------------------------------------------

#ifndef __CMNUTIL_HPP__
#define __CMNUTIL_HPP__

#define DIMAT(Array, EltType) (sizeof(Array) / sizeof(EltType))
#define DIMA(Array) DIMAT(Array, (Array)[0])

#define CSRSS_PROCESS_ID ((ULONG)-1)

// Converts an NTSTATUS into an HRESULT with success check.
#define CONV_NT_STATUS(Status) \
    (NT_SUCCESS(Status) ? S_OK : HRESULT_FROM_NT(Status))

// Converts a Win32 status into an HRESULT with a guarantee it's
// an error code.  This avoids problems with routines which
// don't set a last error.
#define WIN32_STATUS(Err) ((Err) == 0 ? E_FAIL : HRESULT_FROM_WIN32(Err))
#define WIN32_LAST_STATUS() WIN32_STATUS(GetLastError())

// Converts a BOOL into an HRESULT with success check.
#define CONV_W32_STATUS(Status) \
    ((Status) ? S_OK : WIN32_LAST_STATUS())

//----------------------------------------------------------------------------
//
// Assertions.
//
//----------------------------------------------------------------------------

#if DBG

void DbgAssertionFailed(PCSTR File, int Line, PCSTR Str);
                     
#define DBG_ASSERT(Expr) \
    if (!(Expr)) \
    { \
        DbgAssertionFailed(__FILE__, __LINE__, #Expr); \
    } \
    else 0

#else

#define DBG_ASSERT(Expr)

#endif

//----------------------------------------------------------------------------
//
// COM help.
//
//----------------------------------------------------------------------------

// Wrapper that can be locally implemented if necessary to
// remove usage of ole32.dll on platforms where IsEqualIID
// is not inlined.
#define DbgIsEqualIID(Id1, Id2) \
    IsEqualIID(Id1, Id2)

// Safely releases and NULLs an interface pointer.
#define RELEASE(pUnk) \
    ((pUnk) != NULL ? ((pUnk)->Release(), (pUnk) = NULL) : NULL)

// Transfers an interface pointer into a holder that may or
// may not already hold and interface.
#define TRANSFER(pOld, pNew) \
    (((pNew) != NULL ? (pNew)->AddRef() : 0), \
     ((pOld) != NULL ? (pOld)->Release() : 0), \
     (pOld) = (pNew))

//----------------------------------------------------------------------------
//
// Utility functions.
//
//----------------------------------------------------------------------------

extern PSECURITY_DESCRIPTOR g_AllAccessSecDesc;
extern SECURITY_ATTRIBUTES g_AllAccessSecAttr;

PSTR FormatStatusCode(HRESULT Status);

#define FormatStatus(Status) FormatStatusArgs(Status, NULL)
PSTR FormatStatusArgs(HRESULT Status, PVOID Arguments);

BOOL InstallAsAeDebug(PCSTR Append);

HANDLE CreatePidEvent(ULONG Pid, ULONG CreateOrOpen);
BOOL SetPidEvent(ULONG Pid, ULONG CreateOrOpen);

HRESULT EnableDebugPrivilege(void);

HRESULT FillDataBuffer(PVOID Data, ULONG DataLen,
                       PVOID Buffer, ULONG BufferLen, PULONG BufferUsed);
HRESULT FillStringBuffer(PCSTR String, ULONG StringLenIn,
                         PSTR Buffer, ULONG BufferLen, PULONG StringLenOut);
HRESULT AppendToStringBuffer(HRESULT Status, PCSTR String, BOOL First,
                             PSTR* Buffer, ULONG* BufferLen, PULONG LenOut);

void Win32ToNtTimeout(ULONG Win32Timeout, PLARGE_INTEGER NtTimeout);

HRESULT InitializeAllAccessSecObj(void);
void DeleteAllAccessSecObj(void);

#define BASE_YEAR_ADJUSTMENT 11644473600

// Convert to seconds and then from base year 1601 to base year 1970.
#define FileTimeToTimeDateStamp(FileTime)   \
    (ULONG)(((FileTime) / 10000000) - BASE_YEAR_ADJUSTMENT)

// Adjust date back to 1601 from 1970 and convert to 100 nanoseconds
#define TimeDateStampToFileTime(TimeDate)  \
    (((ULONG64)(TimeDate) + BASE_YEAR_ADJUSTMENT) * 10000000)

// Convert to seconds
#define FileTimeToTime(FileTime)   \
    (ULONG)((FileTime) / 10000000)

// Convert to seconds .
#define TimeToFileTime(TimeDate)   \
    ((ULONG64)(TimeDate) * 10000000)

HRESULT QueryVersionDataBuffer(PVOID VerData, PCSTR Item,
                               PVOID Buffer, ULONG BufferSize,
                               PULONG DataSize);
PVOID GetAllFileVersionInfo(PSTR VerFile);
BOOL  GetFileStringFileInfo(PSTR VerFile, PCSTR SubItem,
                            PSTR Buffer, ULONG BufferSize);

HRESULT ExpandDumpCab(PCSTR CabFile, ULONG FileFlags,
                      PSTR DmpFile, INT_PTR* DmpFh);

enum FILE_IO_TYPE
{
    FIO_WIN32,
    FIO_WININET,
};

class PathFile
{
public:
    PathFile(FILE_IO_TYPE IoType)
    {
        m_IoType = IoType;
    }
    virtual ~PathFile(void);

    virtual HRESULT Open(PCSTR Path, ULONG SymOpt) = 0;
    virtual HRESULT QueryDataAvailable(PULONG Avail) = 0;
    virtual HRESULT GetLastWriteTime(PFILETIME Time) = 0;
    virtual HRESULT Read(PVOID Buffer, ULONG BufferLen, PULONG Done) = 0;

    FILE_IO_TYPE m_IoType;
};

BOOL IsUrlPathComponent(PCSTR Path);

#ifndef NT_NATIVE

BOOL PathFileExists(PCSTR Path, ULONG SymOpt, FILE_IO_TYPE* IoType);
HRESULT OpenPathFile(PCSTR Path, ULONG SymOpt, PathFile** File);

#endif

#endif // #ifndef __CMNUTIL_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\dbg-common\dbgver.h ===
//----------------------------------------------------------------------------
//
// Debugger package binary version information.
//
// Copyright (C) Microsoft Corporation, 2000.
//
//----------------------------------------------------------------------------

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef OFFICIAL_BUILD
#include <ntverp.h>
#else

#define VER_PRODUCTMAJORVERSION     3
#define VER_PRODUCTMINORVERSION     0
#define VER_PRODUCTBUILD            15
#define VER_PRODUCTBUILD_QFE        0
#define VER_PRODUCTVERSION_W        (0x0100)
#define VER_PRODUCTVERSION_DW       (0x01000000 | VER_PRODUCTBUILD)

#define VER_PRODUCTBETA_STR         ""

#define VER_PRODUCTVERSION_MAJORMINOR2(x,y) #x "." #y
#define VER_PRODUCTVERSION_MAJORMINOR1(x,y) VER_PRODUCTVERSION_MAJORMINOR2(x, y)
#define VER_PRODUCTVERSION_STRING   VER_PRODUCTVERSION_MAJORMINOR1(VER_PRODUCTMAJORVERSION, VER_PRODUCTMINORVERSION)

#define VER_PRODUCTVERSION          VER_PRODUCTMAJORVERSION,VER_PRODUCTMINORVERSION,VER_PRODUCTBUILD,VER_PRODUCTBUILD_QFE

#if     (VER_PRODUCTBUILD < 10)
#define VER_BPAD "000"
#elif   (VER_PRODUCTBUILD < 100)
#define VER_BPAD "00"
#elif   (VER_PRODUCTBUILD < 1000)
#define VER_BPAD "0"
#else
#define VER_BPAD
#endif

#define VER_PRODUCTVERSION_STR2(x,y) VER_PRODUCTVERSION_STRING "." VER_BPAD #x "." #y
#define VER_PRODUCTVERSION_STR1(x,y) VER_PRODUCTVERSION_STR2(x, y)
#define VER_PRODUCTVERSION_STR       VER_PRODUCTVERSION_STR1(VER_PRODUCTBUILD, VER_PRODUCTBUILD_QFE)

/*--------------------------------------------------------------*/
/* the following section defines values used in the version     */
/* data structure for all files, and which do not change.       */
/*--------------------------------------------------------------*/

/* default is nodebug */
#if DBG
#define VER_DEBUG                   VS_FF_DEBUG
#else
#define VER_DEBUG                   0
#endif

/* default is prerelease */
#if BETA
#define VER_PRERELEASE              VS_FF_PRERELEASE
#else
#define VER_PRERELEASE              0
#endif

#if OFFICIAL_BUILD
#define VER_PRIVATE                 0
#else
#define VER_PRIVATE                 VS_FF_PRIVATEBUILD
#endif

#define VER_FILEFLAGSMASK           VS_FFI_FILEFLAGSMASK
#define VER_FILEOS                  VOS_NT_WINDOWS32
#define VER_FILEFLAGS               (VER_PRERELEASE|VER_DEBUG|VER_PRIVATE)

#define VER_COMPANYNAME_STR         "Microsoft Corporation"
#define VER_PRODUCTNAME_STR         "Debugging Tools for Windows(R)"
#define VER_LEGALTRADEMARKS_STR     \
"Microsoft(R) is a registered trademark of Microsoft Corporation. Windows (R) is a registered trademark of Microsoft Corporation."

#endif

#include <common.ver>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\dbg-common\dhtopics.h ===
#ifndef __VBHELP_4A7B8060_DEDB_499C_AEE3_A1058BC1CE1A_DEFINED__
#define __VBHELP_4A7B8060_DEDB_499C_AEE3_A1058BC1CE1A_DEFINED__

#define HELP_TOPIC_LEGAL_INFORMATION 1                          //  Legal Information
#define HELP_TOPIC_JUNK_02 2                                    //  Using Breakpoints
#define HELP_TOPIC_JUNK_03 3                                    //  Controlling Exceptions and Events
#define HELP_TOPIC_JUNK_06 4                                    //  Controlling Processes and Threads
#define HELP_TOPIC_JUNK_05 5                                    //  Crashing and Rebooting the Target Computer
#define HELP_TOPIC_JUNK_04 6                                    //  Synchronizing with the Target Computer
#define HELP_TOPIC_JUNK_07 7                                    //  Ending the Debugging Session
#define HELP_TOPIC_REMOTE_DEBUGGING 8                           //  Remote Debugging
#define HELP_TOPIC_REMOTE_DEBUGGING_THROUGH_THE_DEBUGGER 9      //  Remote Debugging Through the Debugger
#define HELP_TOPIC_REMOTE_DEBUGGING_THROUGH_REMOTE_EXE 10       //  Remote Debugging Through Remote.exe
#define HELP_TOPIC_COMMAND_LINE 11                              //  Command-Line Options
#define HELP_TOPIC_COMMAND_LINE_CDB 12                          //  CDB Command-Line Options
#define HELP_TOPIC_COMMAND_LINE_NTSD 13                         //  CDB Command-Line Options
#define HELP_TOPIC_COMMAND_LINE_KD 14                           //  KD Command-Line Options
#define HELP_TOPIC_COMMAND_LINE_WINDBG 15                       //  WinDbg Command-Line Options
#define HELP_TOPIC_COMMAND_LINE_DR_WATSON 16                    //  Dr. Watson Command-Line Options
#define HELP_TOPIC_COMMAND_LINE_SYMSTORE 17                     //  SymStore Command-Line Options
#define HELP_TOPIC_WINDOW_COMMAND 18                            //  The Debugger Command Window
#define HELP_TOPIC_WINDOW_WATCH 19                              //  The Watch Window
#define HELP_TOPIC_WINDOW_LOCALS 20                             //  The Locals Window
#define HELP_TOPIC_WINDOW_REGISTERS 21                          //  The Registers Window
#define HELP_TOPIC_POPUP_REGISTERS 22                           //  The Registers Window
#define HELP_TOPIC_WINDOW_MEMORY 23                             //  The Memory Window
#define HELP_TOPIC_WINDOW_CALLS 24                              //  The Calls Window
#define HELP_TOPIC_WINDOW_DISASSEMBLY 25                        //  The Disassembly Window
#define HELP_TOPIC_WINDOW_SOURCE 26                             //  Source Windows
#define HELP_TOPIC_POPUP_ATTACH_TO_PROCESS 27                   //  File | Attach to a Process
#define HELP_TOPIC_POPUP_CONNECT_TO_REMOTE_SESSION 28           //  File | Connect to Remote Session
#define HELP_TOPIC_POPUP_KERNEL_DEBUGGING 29                    //  File | Kernel Debug
#define HELP_TOPIC_POPUP_SYMBOL_PATH 30                         //  File | Symbol File Path
#define HELP_TOPIC_POPUP_SOURCE_PATH 31                         //  File | Source File Path
#define HELP_TOPIC_POPUP_IMAGE_PATH 32                          //  File | Image File Path
#define HELP_TOPIC_POPUP_OPEN_WORKSPACE 33                      //  File | Open Workspace
#define HELP_TOPIC_POPUP_SAVE_WORKSPACE_AS 34                   //  File | Save Workspace As
#define HELP_TOPIC_POPUP_CLEAR_WORKSPACE 35                     //  File | Clear Workspace
#define HELP_TOPIC_POPUP_ADD_TO_COMMAND_OUTPUT 36               //  Edit | Add to Command Output
#define HELP_TOPIC_POPUP_GO_TO_ADDRESS 37                       //  Edit | Go to Address
#define HELP_TOPIC_POPUP_GO_TO_LINE 38                          //  Edit | Go to Line
#define HELP_TOPIC_POPUP_BREAKPOINTS 39                         //  Edit | Breakpoints
#define HELP_TOPIC_POPUP_LOG_FILE 40                            //  Edit | Open/Close Log File
#define HELP_TOPIC_POPUP_OPTIONS 41                             //  View | Options
#define HELP_TOPIC_POPUP_EVENT_FILTERS 42                       //  Debug | Event Filters
#define HELP_TOPIC_POPUP_PROCESSES_AND_THREADS 43               //  Debug | Processes and Threads
#define HELP_TOPIC_POPUP_MODULES 44                             //  Debug | Modules

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\dbg-common\dhhelp.cpp ===
//----------------------------------------------------------------------------
//
// Help support.
//
// Copyright (C) Microsoft Corporation, 2000-2001.
//
//----------------------------------------------------------------------------

#include "pch.hpp"

#include <htmlhelp.h>

#include "dhhelp.h"

CHAR g_HelpFileName[MAX_PATH] = "debugger.chm";

void
MakeHelpFileName(PSTR File)
{
    PSTR Tmp = NULL;

    //
    //  Get the file name for the base module.
    //

    if (GetModuleFileName(GetModuleHandle(NULL), g_HelpFileName,
                          MAX_PATH - 5))
    {
        // Remove the executable name.
        Tmp = strrchr(g_HelpFileName, '\\');
    }

    if (Tmp == NULL)
    {
        // Error.  Use the current directory.
        Tmp = g_HelpFileName;
        *Tmp++ = '.';
    }

    *Tmp++ = '\\';
    strcpy(Tmp, File);
}

/*** OpenHelpTopic   -  opens the .chm and selects the specified topic
*
*   Purpose:
*       This opens the Help File and displays the specified page.
*       (This help file's name is stored as g_HelpFileName, but
*       this string will presumably always be "debugger.chm".)
*       If the .chm has already been opened for context-sensitive
*       help, the already-existing .chm will be used.
*
*       This function should be called when you know exactly what
*       page is needed -- for instance, if a "Help" button is pressed.
*
*   Input:
*       PageConstant -- this is one of the topic constants defined
*                       in the header file generated when the .chm
*                       is built -- these constants will always
*                       be of the form "help_topic_xxxxx"
*
*   Returns:
*       0 - debugger.chm opened and page displayed correctly
*       1 - debugger.chm opened, but specified page not found
*       2 - debugger.chm not opened (probably the file wasn't found)
*
*   Exceptions:
*       None
*
*************************************************************************/

ULONG
OpenHelpTopic(ULONG PageConstant)
{
    HWND helpfileHwnd;
    HWND returnedHwnd;

    //  If we knew we were in WinDbg, we could use WinDbg's HWND,
    //  but we could be in a console debugger.

    helpfileHwnd = GetDesktopWindow();

    //  Make "Contents" the active panel in debugger.chm

    returnedHwnd =
        HtmlHelp(helpfileHwnd,
                 g_HelpFileName,
                 HH_DISPLAY_TOC,
                 0);
    if (returnedHwnd == NULL)
    {
        return HELP_FAILURE;
    }

    //  Select the proper page

    returnedHwnd =
        HtmlHelp(helpfileHwnd,
                 g_HelpFileName,
                 HH_HELP_CONTEXT,
                 PageConstant);
    if (returnedHwnd == NULL)
    {
        return HELP_NO_SUCH_PAGE;
    }
    
    return HELP_SUCCESS;
}


/*** OpenHelpIndex   -  opens the .chm and searches for the specified text
*
*   Purpose:
*       This opens the Help File and looks up the specified text in
*       the Index.  (This help file's name is stored as g_HelpFileName,
*       but this string will presumably always be "debugger.chm".)
*       If the .chm has already been opened for context-sensitive
*       help, the already-existing .chm will be used.
*
*       This function should be called when you don't know exactly
*       which page is needed -- for instance, if someone types
*       "help bp" or "help breakpoints" in the Command window.
*
*   Input:
*       IndexText  --  any text string  (even ""); this string will
*                      appear in the Index panel of the .chm
*
*   Returns:
*       0 - debugger.chm opened and index search displayed correctly
*       2 - debugger.chm not opened (probably the file wasn't found)
*
*   Exceptions:
*       None
*
*************************************************************************/

ULONG
OpenHelpIndex(PCSTR IndexText)
{
    HWND helpfileHwnd;
    HWND returnedHwnd;

    //  If we knew we were in WinDbg, we could use WinDbg's HWND,
    //  but we could be in a console debugger.

    helpfileHwnd = GetDesktopWindow();

    //  Select the Index panel and clip IndexText into it.

    returnedHwnd =
        HtmlHelp(helpfileHwnd,
                 g_HelpFileName,
                 HH_DISPLAY_INDEX,
                 (DWORD_PTR)IndexText);
    if (returnedHwnd == NULL)
    {
        return HELP_FAILURE;
    }
    
    return HELP_SUCCESS;
}

ULONG
OpenHelpSearch(PCSTR SearchText)
{
    HWND helpfileHwnd;
    HWND returnedHwnd;
    HH_FTS_QUERY Query;

    //  If we knew we were in WinDbg, we could use WinDbg's HWND,
    //  but we could be in a console debugger.

    helpfileHwnd = GetDesktopWindow();

    //  Select the Search panel.

    ZeroMemory(&Query, sizeof(Query));
    Query.cbStruct = sizeof(Query);
    Query.pszSearchQuery = SearchText;
    
    returnedHwnd =
        HtmlHelp(helpfileHwnd,
                 g_HelpFileName,
                 HH_DISPLAY_SEARCH,
                 (DWORD_PTR)&Query);
    if (returnedHwnd == NULL)
    {
        return HELP_FAILURE;
    }
    
    return HELP_SUCCESS;
}

BOOL
SpawnHelp(ULONG Topic)
{
    CHAR StartHelpCommand[MAX_PATH + 32];
    PROCESS_INFORMATION ProcInfo = {0};
    STARTUPINFO SI = {0};

    // Start help with the given arguments.

    sprintf(StartHelpCommand, "hh.exe -mapid %d ", Topic);
    strcat(StartHelpCommand, g_HelpFileName);
        
    return CreateProcess(NULL,
                         StartHelpCommand,
                         NULL,
                         NULL,
                         FALSE,
                         CREATE_BREAKAWAY_FROM_JOB,
                         NULL,
                         NULL,
                         &SI,
                         &ProcInfo);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\dbg-common\dllimp.h ===
//----------------------------------------------------------------------------
//
// Certain calls are dynamically linked so that the user-mode
// DLL can be used on Win9x and NT4.
//
// Copyright (C) Microsoft Corporation, 2000-2001.
//
//----------------------------------------------------------------------------

#ifndef __DLLIMP_H__
#define __DLLIMP_H__

#include <security.h>
#include <schannel.h>
#include <tlhelp32.h>

struct DYNAMIC_CALL_NAME
{
    PCSTR Name;
    BOOL Required;
};
struct DYNAMIC_CALLS_DESC
{
    PCSTR DllName;
    ULONG Count;
    DYNAMIC_CALL_NAME* Names;
    FARPROC* Procs;
    HINSTANCE Dll;
    BOOL Initialized;
};

// Calls from ntdll.dll.
typedef struct _NTDLL_CALLS
{
    HANDLE (NTAPI* CsrGetProcessId)
        (VOID);
    VOID (NTAPI* DbgBreakPoint)
        (VOID);
    ULONG (__cdecl* DbgPrint)
        (PCH Format, ...);
    ULONG (NTAPI* DbgPrompt)
        (PCH Prompt, PCH Response, ULONG MaximumResponseLength);
    NTSTATUS (NTAPI* DbgUiConvertStateChangeStructure)
        (IN PDBGUI_WAIT_STATE_CHANGE StateChange,
         OUT struct _DEBUG_EVENT *DebugEvent);
    HANDLE (NTAPI* DbgUiGetThreadDebugObject)
        (VOID);
    NTSTATUS (NTAPI* DbgUiIssueRemoteBreakin)
        (IN HANDLE Process);
    VOID (NTAPI* DbgUiSetThreadDebugObject)
        (IN HANDLE DebugObject);
    NTSTATUS (NTAPI* NtAllocateVirtualMemory)
        (IN HANDLE ProcessHandle, IN OUT PVOID *BaseAddress,
         IN ULONG_PTR ZeroBits, IN OUT PSIZE_T RegionSize,
         IN ULONG AllocationType, IN ULONG Protect);
    NTSTATUS (NTAPI* NtClose)
        (IN HANDLE Handle);
    NTSTATUS (NTAPI* NtCreateDebugObject)
        (OUT PHANDLE DebugObjectHandle, IN ACCESS_MASK DesiredAccess,
         IN POBJECT_ATTRIBUTES ObjectAttributes, IN ULONG Flags);
    NTSTATUS (NTAPI* NtDebugActiveProcess)
        (IN HANDLE ProcessHandle, IN HANDLE DebugObjectHandle);
    NTSTATUS (NTAPI* NtDebugContinue)
        (IN HANDLE DebugObjectHandle, IN PCLIENT_ID ClientId,
         IN NTSTATUS ContinueStatus);
    NTSTATUS (NTAPI* NtFreeVirtualMemory)
        (IN HANDLE ProcessHandle, IN OUT PVOID *BaseAddress,
         IN OUT PSIZE_T RegionSize, IN ULONG FreeType);
    NTSTATUS (NTAPI* NtOpenProcess)
        (OUT PHANDLE ProcessHandle, IN ACCESS_MASK DesiredAccess,
         IN POBJECT_ATTRIBUTES ObjectAttributes,
         IN PCLIENT_ID ClientId OPTIONAL);
    NTSTATUS (NTAPI* NtOpenThread)
        (OUT PHANDLE ThreadHandle, IN ACCESS_MASK DesiredAccess,
         IN POBJECT_ATTRIBUTES ObjectAttributes,
         IN PCLIENT_ID ClientId OPTIONAL);
    NTSTATUS (NTAPI* NtQueryInformationProcess)
        (IN HANDLE ProcessHandle, IN PROCESSINFOCLASS ProcessInformationClass,
         OUT PVOID ProcessInformation, IN ULONG ProcessInformationLength,
         OUT PULONG ReturnLength OPTIONAL);
    NTSTATUS (NTAPI* NtQueryInformationThread)
        (IN HANDLE ThreadHandle, IN THREADINFOCLASS ThreadInformationClass,
         OUT PVOID ThreadInformation, IN ULONG ThreadInformationLength,
         OUT PULONG ReturnLength OPTIONAL);
    NTSTATUS (NTAPI* NtQueryObject)
        (IN HANDLE Handle, IN OBJECT_INFORMATION_CLASS ObjectInformationClass,
         OUT PVOID ObjectInformation, IN ULONG Length,
         OUT PULONG ReturnLength OPTIONAL);
    NTSTATUS (NTAPI* NtQuerySystemInformation)
        (IN SYSTEM_INFORMATION_CLASS SystemInformationClass,
         OUT PVOID SystemInformation, IN ULONG SystemInformationLength,
         OUT PULONG ReturnLength OPTIONAL);
    NTSTATUS (NTAPI* NtRemoveProcessDebug)
        (IN HANDLE ProcessHandle, IN HANDLE DebugObjectHandle);
    NTSTATUS (NTAPI* NtSetInformationDebugObject)
        (IN HANDLE DebugObjectHandle,
         IN DEBUGOBJECTINFOCLASS DebugObjectInformationClass,
         IN PVOID DebugInformation, IN ULONG DebugInformationLength,
         OUT PULONG ReturnLength OPTIONAL);
    NTSTATUS (NTAPI* NtSetInformationProcess)
        (IN HANDLE ProcessHandle,
         IN PROCESSINFOCLASS ProcessInformationClass,
         IN PVOID ProcessInformation, IN ULONG ProcessInformationLength);
    NTSTATUS (NTAPI* NtSystemDebugControl)
        (IN SYSDBG_COMMAND Command, IN PVOID InputBuffer,
         IN ULONG InputBufferLength, OUT PVOID OutputBuffer,
         IN ULONG OutputBufferLength, OUT PULONG ReturnLength);
    NTSTATUS (NTAPI* NtWaitForDebugEvent)
        (IN HANDLE DebugObjectHandle, IN BOOLEAN Alertable,
         IN PLARGE_INTEGER Timeout OPTIONAL,
         OUT PDBGUI_WAIT_STATE_CHANGE WaitStateChange);
    BOOLEAN (NTAPI* RtlFreeHeap)
        (IN PVOID HeapHandle, IN ULONG Flags, IN PVOID BaseAddress);
    PLIST_ENTRY (NTAPI* RtlGetFunctionTableListHead)
        (VOID);
    BOOLEAN (NTAPI* RtlTryEnterCriticalSection)
        (PRTL_CRITICAL_SECTION CriticalSection);
    NTSTATUS (NTAPI* RtlUnicodeStringToAnsiString)
        (PANSI_STRING DestinationString, PCUNICODE_STRING SourceString,
         BOOLEAN AllocateDestinationString);
} NTDLL_CALLS;
extern NTDLL_CALLS g_NtDllCalls;
extern DYNAMIC_CALLS_DESC g_NtDllCallsDesc;

// Calls from kernel32.dll.
typedef struct _KERNEL32_CALLS
{
    HANDLE (WINAPI* CreateToolhelp32Snapshot)
        (DWORD dwFlags, DWORD th32ProcessID);
    BOOL (WINAPI* DebugActiveProcessStop)
        (DWORD ProcessId);
    VOID (WINAPI* DebugBreak)
        (VOID);
    BOOL (WINAPI* DebugBreakProcess)
        (HANDLE Process);
    BOOL (WINAPI* DebugSetProcessKillOnExit)
        (BOOL KillOnExit);
    BOOL (WINAPI* Module32First)
        (HANDLE hSnapshot, LPMODULEENTRY32 lpme);
    BOOL (WINAPI* Module32Next)
        (HANDLE hSnapshot, LPMODULEENTRY32 lpme);
    BOOL (WINAPI* Process32First)
        (HANDLE hSnapshot, LPPROCESSENTRY32 lppe);
    BOOL (WINAPI* Process32Next)
        (HANDLE hSnapshot, LPPROCESSENTRY32 lppe);
    BOOL (WINAPI* Thread32First)
        (HANDLE hSnapshot, LPTHREADENTRY32 lpte);
    BOOL (WINAPI* Thread32Next)
        (HANDLE hSnapshot, LPTHREADENTRY32 lpte);
} KERNEL32_CALLS;
extern KERNEL32_CALLS g_Kernel32Calls;
extern DYNAMIC_CALLS_DESC g_Kernel32CallsDesc;

// Calls from user32.dll.
typedef struct _USER32_CALLS
{
    void (WINAPI* PrivateKDBreakPoint)
        (void);
} USER32_CALLS;
extern USER32_CALLS g_User32Calls;
extern DYNAMIC_CALLS_DESC g_User32CallsDesc;

// Calls from ole32.dll.
typedef struct _OLE32_CALLS
{
    HRESULT (STDAPICALLTYPE* CLSIDFromString)
        (IN LPOLESTR lpsz, OUT LPCLSID pclsid);
    HRESULT (STDAPICALLTYPE* CoCreateInstance)
        (IN REFCLSID rclsid, IN LPUNKNOWN pUnkOuter,
         IN DWORD dwClsContext, IN REFIID riid, OUT LPVOID FAR* ppv);
    HRESULT (STDAPICALLTYPE* CoInitializeEx)
        (void * pvReserved, DWORD dwCoInit);
    void (STDAPICALLTYPE* CoUninitialize)
        (void);
} OLE32_CALLS;
extern OLE32_CALLS g_Ole32Calls;
extern DYNAMIC_CALLS_DESC g_Ole32CallsDesc;

// Calls from oleaut32.dll.
typedef struct _OLEAUT32_CALLS
{
    void (STDAPICALLTYPE* SysFreeString)
        (BSTR Str);
} OLEAUT32_CALLS;
extern OLEAUT32_CALLS g_OleAut32Calls;
extern DYNAMIC_CALLS_DESC g_OleAut32CallsDesc;

// Calls from security.dll.
extern SecurityFunctionTable g_SecurityFunc;

// Calls from crypt32.dll.
typedef struct _CRYPT32_CALLS
{
    PCCERT_CONTEXT (WINAPI* CertFindCertificateInStore)
        (IN HCERTSTORE hCertStore,
         IN DWORD dwCertEncodingType,
         IN DWORD dwFindFlags,
         IN DWORD dwFindType,
         IN const void *pvFindPara,
         IN PCCERT_CONTEXT pPrevCertContext);
    PCCERT_CHAIN_CONTEXT (WINAPI* CertFindChainInStore)
        (IN HCERTSTORE hCertStore,
         IN DWORD dwCertEncodingType,
         IN DWORD dwFindFlags,
         IN DWORD dwFindType,
         IN const void *pvFindPara,
         IN PCCERT_CHAIN_CONTEXT pPrevChainContext);
    VOID (WINAPI* CertFreeCertificateChain)
        (IN PCCERT_CHAIN_CONTEXT pChainContext);
    BOOL (WINAPI* CertFreeCertificateContext)
        (IN PCCERT_CONTEXT pCertContext);
    BOOL (WINAPI* CertGetCertificateChain)
        (IN OPTIONAL HCERTCHAINENGINE hChainEngine,
         IN PCCERT_CONTEXT pCertContext,
         IN OPTIONAL LPFILETIME pTime,
         IN OPTIONAL HCERTSTORE hAdditionalStore,
         IN PCERT_CHAIN_PARA pChainPara,
         IN DWORD dwFlags,
         IN LPVOID pvReserved,
         OUT PCCERT_CHAIN_CONTEXT* ppChainContext);
    HCERTSTORE (WINAPI* CertOpenStore)
        (IN LPCSTR lpszStoreProvider,
         IN DWORD dwEncodingType,
         IN HCRYPTPROV hCryptProv,
         IN DWORD dwFlags,
         IN const void *pvPara);
    HCERTSTORE (WINAPI* CertOpenSystemStoreA)
        (HCRYPTPROV      hProv,
         LPCSTR            szSubsystemProtocol);
    BOOL (WINAPI* CertVerifyCertificateChainPolicy)
        (IN LPCSTR pszPolicyOID,
         IN PCCERT_CHAIN_CONTEXT pChainContext,
         IN PCERT_CHAIN_POLICY_PARA pPolicyPara,
         IN OUT PCERT_CHAIN_POLICY_STATUS pPolicyStatus);
} CRYPT32_CALLS;
extern CRYPT32_CALLS g_Crypt32Calls;
extern DYNAMIC_CALLS_DESC g_Crypt32CallsDesc;

// Calls from advapi32.dll.
typedef struct _ADVAPI32_CALLS
{
    BOOL (WINAPI* EnumServicesStatusExA)
        (SC_HANDLE                  hSCManager,
         SC_ENUM_TYPE               InfoLevel,
         DWORD                      dwServiceType,
         DWORD                      dwServiceState,
         LPBYTE                     lpServices,
         DWORD                      cbBufSize,
         LPDWORD                    pcbBytesNeeded,
         LPDWORD                    lpServicesReturned,
         LPDWORD                    lpResumeHandle,
         LPCSTR                     pszGroupName);
    SC_HANDLE (WINAPI* OpenSCManagerA)
        (LPCSTR lpMachineName, LPCSTR lpDatabaseName, DWORD dwDesiredAccess);
} ADVAPI32_CALLS;
extern ADVAPI32_CALLS g_Advapi32Calls;
extern DYNAMIC_CALLS_DESC g_Advapi32CallsDesc;

HRESULT InitDynamicCalls(DYNAMIC_CALLS_DESC* Desc);

#endif // #ifndef __DLLIMP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\dbg-common\float10.cpp ===
/***
*float10.c - floating point output for 10-byte long double
*
*	Copyright (c) 1991-1991, Microsoft Corporation.	All rights reserved.
*
*Purpose:
*   Support conversion of a long double into a string
*
*Revision History:
*   07/15/91	GDP	Initial version in C (ported from assembly)
*   01/23/92	GDP	Support MIPS encoding for NaN
*   05-26-92       GWK     Windbg srcs
*
******************************************************************************/

#include "pch.hpp"

#include <math.h>

#include "float10.h"

typedef LONG s_long;
typedef ULONG u_long;
typedef SHORT s_short;
typedef USHORT u_short;

#define L_END

#define PTR_LD(x) ((u_char  *)(&(x)->ld))

#define PTR_12(x) ((u_char  *)(&(x)->ld12))

#define MAX_USHORT  ((u_short)0xffff)
#define MSB_USHORT  ((u_short)0x8000)
#define MAX_ULONG   ((u_long)0xffffffff)
#define MSB_ULONG   ((u_long)0x80000000)

#define TMAX10 5200	  /* maximum temporary decimal exponent */
#define TMIN10 -5200	  /* minimum temporary decimal exponent */
#define LD_MAX_EXP_LEN 4  /* maximum number of decimal exponent digits */
#define LD_MAX_MAN_LEN 24  /* maximum length of mantissa (decimal)*/
#define LD_MAX_MAN_LEN1 25 /* MAX_MAN_LEN+1 */

#define LD_BIAS	0x3fff	  /* exponent bias for long double */
#define LD_BIASM1 0x3ffe  /* LD_BIAS - 1 */
#define LD_MAXEXP 0x7fff  /* maximum biased exponent */

#define D_BIAS	0x3ff	 /* exponent bias for double */
#define D_BIASM1 0x3fe	/* D_BIAS - 1 */
#define D_MAXEXP 0x7ff	/* maximum biased exponent */



/* Recognizing special patterns in the mantissa field */
#define _EXP_SP  0x7fff
#define NAN_BIT (1<<30)

#define _IS_MAN_INF(signbit, manhi, manlo) \
	( (manhi)==MSB_ULONG && (manlo)==0x0 )

#define _IS_MAN_IND(signbit, manhi, manlo) \
	((signbit) && (manhi)==0xc0000000 && (manlo)==0)

#define _IS_MAN_QNAN(signbit, manhi, manlo) \
	( (manhi)&NAN_BIT )

#define _IS_MAN_SNAN(signbit, manhi, manlo) \
	(!( _IS_MAN_INF(signbit, manhi, manlo) || \
	   _IS_MAN_QNAN(signbit, manhi, manlo) ))

/*
 * Manipulation of a 12-byte long double number (an ordinary
 * 10-byte long double plus two extra bytes of mantissa).
 */

/* a pointer to the exponent/sign portion */
#define U_EXP_12(p) ((u_short *)(PTR_12(p)+10))

/* a pointer to the 4 hi-order bytes of the mantissa */
#define UL_MANHI_12(p) ((u_long UNALIGNED *)(PTR_12(p)+6))

/* a pointer to the 4 lo-order bytes of the ordinary (8-byte) mantissa */
#define UL_MANLO_12(p) ((u_long UNALIGNED *)(PTR_12(p)+2))

/* a pointer to the 2 extra bytes of the mantissa */
#define U_XT_12(p) ((u_short *)PTR_12(p))

/* a pointer to the 4 lo-order bytes of the extended (10-byte) mantissa */
#define UL_LO_12(p) ((u_long UNALIGNED *)PTR_12(p))

/* a pointer to the 4 mid-order bytes of the extended (10-byte) mantissa */
#define UL_MED_12(p) ((u_long UNALIGNED *)(PTR_12(p)+4))

/* a pointer to the 4 hi-order bytes of the extended long double */
#define UL_HI_12(p) ((u_long UNALIGNED *)(PTR_12(p)+8))

/* a pointer to the byte of order i (LSB=0, MSB=9)*/
#define UCHAR_12(p,i) ((u_char *)PTR_12(p)+(i))

/* a pointer to a u_short with offset i */
#define USHORT_12(p,i) ((u_short *)((u_char  *)PTR_12(p)+(i)))

/* a pointer to a u_long with offset i */
#define ULONG_12(p,i) ((u_long UNALIGNED *)((u_char  *)PTR_12(p)+(i)))

/* a pointer to the 10 MSBytes of a 12-byte long double */
#define TEN_BYTE_PART(p) ((u_char *)PTR_12(p)+2)

/*
 * Manipulation of a 10-byte long double number
 */
#define U_EXP_LD(p) ((u_short *)(PTR_LD(p)+8))
#define UL_MANHI_LD(p) ((u_long UNALIGNED *)(PTR_LD(p)+4))
#define UL_MANLO_LD(p) ((u_long UNALIGNED *)PTR_LD(p))

/*
 * Manipulation of a 64bit IEEE double
 */
#define U_SHORT4_D(p) ((u_short *)(p) + 3)
#define UL_HI_D(p) ((u_long UNALIGNED *)(p) + 1)
#define UL_LO_D(p) ((u_long UNALIGNED *)(p))

#define PUT_INF_12(p,sign) \
		  *UL_HI_12(p) = (sign)?0xffff8000:0x7fff8000; \
		  *UL_MED_12(p) = 0; \
		  *UL_LO_12(p) = 0;

#define PUT_ZERO_12(p) *UL_HI_12(p) = 0; \
		  *UL_MED_12(p) = 0; \
		  *UL_LO_12(p) = 0;

#define ISZERO_12(p) ((*UL_HI_12(p)&0x7fffffff) == 0 && \
		      *UL_MED_12(p) == 0 && \
		      *UL_LO_12(p) == 0 )

#define PUT_INF_LD(p,sign) \
		  *U_EXP_LD(p) = (sign)?0xffff:0x7fff; \
		  *UL_MANHI_LD(p) = 0x8000; \
		  *UL_MANLO_LD(p) = 0;

#define PUT_ZERO_LD(p) *U_EXP_LD(p) = 0; \
		  *UL_MANHI_LD(p) = 0; \
		  *UL_MANLO_LD(p) = 0;

#define ISZERO_LD(p) ((*U_EXP_LD(p)&0x7fff) == 0 && \
		      *UL_MANHI_LD(p) == 0 && \
		      *UL_MANLO_LD(p) == 0 )

/* Format: A 10 byte long double + 2 bytes of extra precision
 * If the extra precision is desired, the 10-byte long double
 * should be "unrounded" first.
 * This may change in later versions
 */

#ifdef L_END

_ULDBL12 _pow10pos[] = {
 /*P0001*/ {{0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xA0,0x02,0x40}},
 /*P0002*/ {{0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xC8,0x05,0x40}},
 /*P0003*/ {{0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFA,0x08,0x40}},
 /*P0004*/ {{0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x9C,0x0C,0x40}},
 /*P0005*/ {{0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00,0x50,0xC3,0x0F,0x40}},
 /*P0006*/ {{0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x00,0x24,0xF4,0x12,0x40}},
 /*P0007*/ {{0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x80,0x96,0x98,0x16,0x40}},
 /*P0008*/ {{0x00,0x00, 0x00,0x00,0x00,0x00,0x00,0x20,0xBC,0xBE,0x19,0x40}},
 /*P0016*/ {{0x00,0x00, 0x00,0x00,0x00,0x04,0xBF,0xC9,0x1B,0x8E,0x34,0x40}},
 /*P0024*/ {{0x00,0x00, 0x00,0xA1,0xED,0xCC,0xCE,0x1B,0xC2,0xD3,0x4E,0x40}},
 /*P0032*/ {{0x20,0xF0, 0x9E,0xB5,0x70,0x2B,0xA8,0xAD,0xC5,0x9D,0x69,0x40}},
 /*P0040*/ {{0xD0,0x5D, 0xFD,0x25,0xE5,0x1A,0x8E,0x4F,0x19,0xEB,0x83,0x40}},
 /*P0048*/ {{0x71,0x96, 0xD7,0x95,0x43,0x0E,0x05,0x8D,0x29,0xAF,0x9E,0x40}},
 /*P0056*/ {{0xF9,0xBF, 0xA0,0x44,0xED,0x81,0x12,0x8F,0x81,0x82,0xB9,0x40}},
 /*P0064*/ {{0xBF,0x3C, 0xD5,0xA6,0xCF,0xFF,0x49,0x1F,0x78,0xC2,0xD3,0x40}},
 /*P0128*/ {{0x6F,0xC6, 0xE0,0x8C,0xE9,0x80,0xC9,0x47,0xBA,0x93,0xA8,0x41}},
 /*P0192*/ {{0xBC,0x85, 0x6B,0x55,0x27,0x39,0x8D,0xF7,0x70,0xE0,0x7C,0x42}},
 /*P0256*/ {{0xBC,0xDD, 0x8E,0xDE,0xF9,0x9D,0xFB,0xEB,0x7E,0xAA,0x51,0x43}},
 /*P0320*/ {{0xA1,0xE6, 0x76,0xE3,0xCC,0xF2,0x29,0x2F,0x84,0x81,0x26,0x44}},
 /*P0384*/ {{0x28,0x10, 0x17,0xAA,0xF8,0xAE,0x10,0xE3,0xC5,0xC4,0xFA,0x44}},
 /*P0448*/ {{0xEB,0xA7, 0xD4,0xF3,0xF7,0xEB,0xE1,0x4A,0x7A,0x95,0xCF,0x45}},
 /*P0512*/ {{0x65,0xCC, 0xC7,0x91,0x0E,0xA6,0xAE,0xA0,0x19,0xE3,0xA3,0x46}},
 /*P1024*/ {{0x0D,0x65, 0x17,0x0C,0x75,0x81,0x86,0x75,0x76,0xC9,0x48,0x4D}},
 /*P1536*/ {{0x58,0x42, 0xE4,0xA7,0x93,0x39,0x3B,0x35,0xB8,0xB2,0xED,0x53}},
 /*P2048*/ {{0x4D,0xA7, 0xE5,0x5D,0x3D,0xC5,0x5D,0x3B,0x8B,0x9E,0x92,0x5A}},
 /*P2560*/ {{0xFF,0x5D, 0xA6,0xF0,0xA1,0x20,0xC0,0x54,0xA5,0x8C,0x37,0x61}},
 /*P3072*/ {{0xD1,0xFD, 0x8B,0x5A,0x8B,0xD8,0x25,0x5D,0x89,0xF9,0xDB,0x67}},
 /*P3584*/ {{0xAA,0x95, 0xF8,0xF3,0x27,0xBF,0xA2,0xC8,0x5D,0xDD,0x80,0x6E}},
 /*P4096*/ {{0x4C,0xC9, 0x9B,0x97,0x20,0x8A,0x02,0x52,0x60,0xC4,0x25,0x75}}
};

_ULDBL12 _pow10neg[] = {
 /*N0001*/ {{0xCD,0xCC, 0xCD,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xFB,0x3F}},
 /*N0002*/ {{0x71,0x3D, 0x0A,0xD7,0xA3,0x70,0x3D,0x0A,0xD7,0xA3,0xF8,0x3F}},
 /*N0003*/ {{0x5A,0x64, 0x3B,0xDF,0x4F,0x8D,0x97,0x6E,0x12,0x83,0xF5,0x3F}},
 /*N0004*/ {{0xC3,0xD3, 0x2C,0x65,0x19,0xE2,0x58,0x17,0xB7,0xD1,0xF1,0x3F}},
 /*N0005*/ {{0xD0,0x0F, 0x23,0x84,0x47,0x1B,0x47,0xAC,0xC5,0xA7,0xEE,0x3F}},
 /*N0006*/ {{0x40,0xA6, 0xB6,0x69,0x6C,0xAF,0x05,0xBD,0x37,0x86,0xEB,0x3F}},
 /*N0007*/ {{0x33,0x3D, 0xBC,0x42,0x7A,0xE5,0xD5,0x94,0xBF,0xD6,0xE7,0x3F}},
 /*N0008*/ {{0xC2,0xFD, 0xFD,0xCE,0x61,0x84,0x11,0x77,0xCC,0xAB,0xE4,0x3F}},
 /*N0016*/ {{0x2F,0x4C, 0x5B,0xE1,0x4D,0xC4,0xBE,0x94,0x95,0xE6,0xC9,0x3F}},
 /*N0024*/ {{0x92,0xC4, 0x53,0x3B,0x75,0x44,0xCD,0x14,0xBE,0x9A,0xAF,0x3F}},
 /*N0032*/ {{0xDE,0x67, 0xBA,0x94,0x39,0x45,0xAD,0x1E,0xB1,0xCF,0x94,0x3F}},
 /*N0040*/ {{0x24,0x23, 0xC6,0xE2,0xBC,0xBA,0x3B,0x31,0x61,0x8B,0x7A,0x3F}},
 /*N0048*/ {{0x61,0x55, 0x59,0xC1,0x7E,0xB1,0x53,0x7C,0x12,0xBB,0x5F,0x3F}},
 /*N0056*/ {{0xD7,0xEE, 0x2F,0x8D,0x06,0xBE,0x92,0x85,0x15,0xFB,0x44,0x3F}},
 /*N0064*/ {{0x24,0x3F, 0xA5,0xE9,0x39,0xA5,0x27,0xEA,0x7F,0xA8,0x2A,0x3F}},
 /*N0128*/ {{0x7D,0xAC, 0xA1,0xE4,0xBC,0x64,0x7C,0x46,0xD0,0xDD,0x55,0x3E}},
 /*N0192*/ {{0x63,0x7B, 0x06,0xCC,0x23,0x54,0x77,0x83,0xFF,0x91,0x81,0x3D}},
 /*N0256*/ {{0x91,0xFA, 0x3A,0x19,0x7A,0x63,0x25,0x43,0x31,0xC0,0xAC,0x3C}},
 /*N0320*/ {{0x21,0x89, 0xD1,0x38,0x82,0x47,0x97,0xB8,0x00,0xFD,0xD7,0x3B}},
 /*N0384*/ {{0xDC,0x88, 0x58,0x08,0x1B,0xB1,0xE8,0xE3,0x86,0xA6,0x03,0x3B}},
 /*N0448*/ {{0xC6,0x84, 0x45,0x42,0x07,0xB6,0x99,0x75,0x37,0xDB,0x2E,0x3A}},
 /*N0512*/ {{0x33,0x71, 0x1C,0xD2,0x23,0xDB,0x32,0xEE,0x49,0x90,0x5A,0x39}},
 /*N1024*/ {{0xA6,0x87, 0xBE,0xC0,0x57,0xDA,0xA5,0x82,0xA6,0xA2,0xB5,0x32}},
 /*N1536*/ {{0xE2,0x68, 0xB2,0x11,0xA7,0x52,0x9F,0x44,0x59,0xB7,0x10,0x2C}},
 /*N2048*/ {{0x25,0x49, 0xE4,0x2D,0x36,0x34,0x4F,0x53,0xAE,0xCE,0x6B,0x25}},
 /*N2560*/ {{0x8F,0x59, 0x04,0xA4,0xC0,0xDE,0xC2,0x7D,0xFB,0xE8,0xC6,0x1E}},
 /*N3072*/ {{0x9E,0xE7, 0x88,0x5A,0x57,0x91,0x3C,0xBF,0x50,0x83,0x22,0x18}},
 /*N3584*/ {{0x4E,0x4B, 0x65,0x62,0xFD,0x83,0x8F,0xAF,0x06,0x94,0x7D,0x11}},
 /*N4096*/ {{0xE4,0x2D, 0xDE,0x9F,0xCE,0xD2,0xC8,0x04,0xDD,0xA6,0xD8,0x0A}}
};

#endif

int __addl(u_long x, u_long y, u_long UNALIGNED *sum)
{
    u_long r;
    int carry=0;
    r = x+y;
    if (r < x || r < y)
	carry++;
    *sum = r;
    return carry;
}

/***
*void __add_12(_ULDBL12 *x, _ULDBL12 *y) -	_ULDBL12 addition
*
*Purpose: add two _ULDBL12 numbers. The numbers are added
*   as 12-byte integers. Overflow is ignored.
*
*Entry: x,y: pointers to the operands
*
*Exit: *x receives the sum
*
*Exceptions:
*
*******************************************************************************/

void __add_12(_ULDBL12 *x, _ULDBL12 *y)
{
    int c0,c1,c2;
    c0 = __addl(*UL_LO_12(x),*UL_LO_12(y),UL_LO_12(x));
    if (c0) {
	c1 = __addl(*UL_MED_12(x),(u_long)1,UL_MED_12(x));
	if (c1) {
	    (*UL_HI_12(x))++;
	}
    }
    c2 = __addl(*UL_MED_12(x),*UL_MED_12(y),UL_MED_12(x));
    if (c2) {
	(*UL_HI_12(x))++;
    }
    /* ignore next carry -- assume no overflow will occur */
    (void) __addl(*UL_HI_12(x),*UL_HI_12(y),UL_HI_12(x));
}





/***
*void __shl_12(_ULDBL12 *x) - _ULDBL12 shift left
*void __shr_12(_ULDBL12 *x) - _ULDBL12 shift right
*
*Purpose: Shift a _ULDBL12 number one bit to the left (right). The number
*   is shifted as a 12-byte integer. The MSB is lost.
*
*Entry: x: a pointer to the operand
*
*Exit: *x is shifted one bit to the left (or right)
*
*Exceptions:
*
*******************************************************************************/

void __shl_12(_ULDBL12 *p)
{
    u_long c0,c1;

    c0 = *UL_LO_12(p) & MSB_ULONG ? 1: 0;
    c1 = *UL_MED_12(p) & MSB_ULONG ? 1: 0;
    *UL_LO_12(p) <<= 1;
    *UL_MED_12(p) = *UL_MED_12(p)<<1 | c0;
    *UL_HI_12(p) = *UL_HI_12(p)<<1 | c1;
}

void __shr_12(_ULDBL12 *p)
{
    u_long c2,c1;
    c2 = *UL_HI_12(p) & 0x1 ? MSB_ULONG: 0;
    c1 = *UL_MED_12(p) & 0x1 ? MSB_ULONG: 0;
    *UL_HI_12(p) >>= 1;
    *UL_MED_12(p) = *UL_MED_12(p)>>1 | c2;
    *UL_LO_12(p) = *UL_LO_12(p)>>1 | c1;
}

/***
*void  __ld12mul(_ULDBL12 *px, _ULDBL12 *py) -
*   _ULDBL12 multiplication
*
*Purpose: multiply two _ULDBL12 numbers
*
*Entry: px,py: pointers to the _ULDBL12 operands
*
*Exit: *px contains the product
*
*Exceptions:
*
*******************************************************************************/

void  __ld12mul(_ULDBL12 *px, _ULDBL12 *py)
{
    u_short sign = 0;
    u_short sticky_bits = 0;
    _ULDBL12 tempman; /*this is actually a 12-byte mantissa,
			 not a 12-byte long double */
    int i;
    u_short expx, expy, expsum;
    int roffs,poffs,qoffs;
    int sticky;

    *UL_LO_12(&tempman) = 0;
    *UL_MED_12(&tempman) = 0;
    *UL_HI_12(&tempman) = 0;

    expx = *U_EXP_12(px);
    expy = *U_EXP_12(py);

    sign = (expx ^ expy) & (u_short)0x8000;
    expx &= 0x7fff;
    expy &= 0x7fff;
    expsum = expx+expy;
    if (expx >= LD_MAXEXP
	|| expy >= LD_MAXEXP
	|| expsum > LD_MAXEXP+ LD_BIASM1){
	/* overflow to infinity */
	PUT_INF_12(px,sign);
	return;
    }
    if (expsum <= LD_BIASM1-63) {
	/* underflow to zero */
	PUT_ZERO_12(px);
	return;
    }
    if (expx == 0) {
	/*
	 * If this is a denormal temp real then the mantissa
	 * was shifted right once to set bit 63 to zero.
	 */
	expsum++; /* Correct for this */
	if (ISZERO_12(px)) {
	    /* put positive sign */
	    *U_EXP_12(px) = 0;
	    return;
	}
    }
    if (expy == 0) {
	expsum++; /* because arg2 is denormal */
	if (ISZERO_12(py)) {
	    PUT_ZERO_12(px);
	    return;
	}
    }

    roffs = 0;
    for (i=0;i<5;i++) {
	int j;
	poffs = i<<1;
	qoffs = 8;
	for (j=5-i;j>0;j--) {
	    u_long prod;
#ifdef MIPS
	    /* a variable to hold temprary sums */
	    u_long sum;
#endif
	    int carry;
	    u_short *p, *q;
	    u_long UNALIGNED *r;
	    p = USHORT_12(px,poffs);
	    q = USHORT_12(py,qoffs);
	    r = ULONG_12(&tempman,roffs);
	    prod = (u_long)*p * (u_long)*q;
#ifdef MIPS
	    /* handle misalignment problems */
	    if (i&0x1){ /* i is odd */
                carry = __addl(*MIPSALIGN(r), prod, &sum);
                *MIPSALIGN(r) =  sum;
	    }
	    else /* i is even */
		carry = __addl(*r, prod, r);
#else
	    carry = __addl(*r,prod,r);
#endif
	    if (carry) {
		/* roffs should be less than 8 in this case */
		(*USHORT_12(&tempman,roffs+4))++;
	    }
	    poffs+=2;
	    qoffs-=2;
	}
	roffs+=2;
    }

    expsum -= LD_BIASM1;

    /* normalize */
    while ((s_short)expsum > 0 &&
	   ((*UL_HI_12(&tempman) & MSB_ULONG) == 0)) {
	 __shl_12(&tempman);
	 expsum--;
    }

    if ((s_short)expsum <= 0) {
	expsum--;
        sticky = 0;
	while ((s_short)expsum < 0) {
	    if (*U_XT_12(&tempman) & 0x1)
		sticky++;
	    __shr_12(&tempman);
	    expsum++;
	}
	if (sticky)
	    *U_XT_12(&tempman) |= 0x1;
    }

    if (*U_XT_12(&tempman) > 0x8000 ||
	 ((*UL_LO_12(&tempman) & 0x1ffff) == 0x18000)) {
	/* round up */
	if (*UL_MANLO_12(&tempman) == MAX_ULONG) {
	    *UL_MANLO_12(&tempman) = 0;
	    if (*UL_MANHI_12(&tempman) == MAX_ULONG) {
		*UL_MANHI_12(&tempman) = 0;
		if (*U_EXP_12(&tempman) == MAX_USHORT) {
		    /* 12-byte mantissa overflow */
		    *U_EXP_12(&tempman) = MSB_USHORT;
		    expsum++;
		}
		else
		    (*U_EXP_12(&tempman))++;
	    }
	    else
		(*UL_MANHI_12(&tempman))++;
	}
	else
	    (*UL_MANLO_12(&tempman))++;
    }


    /* check for exponent overflow */
    if (expsum >= 0x7fff){
	PUT_INF_12(px, sign);
	return;
    }

    /* put result in px */
    *U_XT_12(px) = *USHORT_12(&tempman,2);
    *UL_MANLO_12(px) = *UL_MED_12(&tempman);
    *UL_MANHI_12(px) = *UL_HI_12(&tempman);
    *U_EXP_12(px) = expsum | sign;
}



void __multtenpow12(_ULDBL12 *pld12, int pow, unsigned mult12)
{
    _ULDBL12 *pow_10p = _pow10pos-8;
    if (pow == 0)
	return;
    if (pow < 0) {
	pow = -pow;
	pow_10p = _pow10neg-8;
    }

    if (!mult12)
	*U_XT_12(pld12) = 0;


    while (pow) {
	int last3; /* the 3 LSBits of pow */
	_ULDBL12 unround;
	_ULDBL12 *py;

	pow_10p += 7;
	last3 = pow & 0x7;
	pow >>= 3;
	if (last3 == 0)
	    continue;
	py = pow_10p + last3;

#ifdef _ULDSUPPORT
	if (mult12) {
#endif
	    /* do an exact 12byte multiplication */
	    if (*U_XT_12(py) >= 0x8000) {
		/* copy number */
		unround = *py;
		/* unround adjacent byte */
		(*UL_MANLO_12(&unround))--;
		/* point to new operand */
		py = &unround;
	    }
	    __ld12mul(pld12,py);
#ifdef _ULDSUPPORT
	}
	else {
	    /* do a 10byte multiplication */
	    py = (_ULDBL12 *)TEN_BYTE_PART(py);
	    *(long double *)TEN_BYTE_PART(pld12) *=
		*(long double *)py;
	}
#endif
    }
}






/***
*void  __mtold12(char *manptr,unsigned manlen,_ULDBL12 *ld12) -
*   convert a mantissa into a _ULDBL12
*
*Purpose: convert a mantissa into a _ULDBL12. The mantissa is
*   in the form of an array of manlen BCD digits and is
*   considered to be an integer.
*
*Entry: manptr: the array containing the packed BCD digits of the mantissa
*	manlen: the size of the array
*	ld12: a pointer to the long double where the result will be stored
*
*Exit:
*	ld12 gets the result of the conversion
*
*Exceptions:
*
*******************************************************************************/

void  __mtold12(char *manptr,
			 unsigned manlen,
			 _ULDBL12 *ld12)
{
    _ULDBL12 tmp;
    u_short expn = LD_BIASM1+80;

    *UL_LO_12(ld12) = 0;
    *UL_MED_12(ld12) = 0;
    *UL_HI_12(ld12) = 0;
    for (;manlen>0;manlen--,manptr++){
	tmp = *ld12;
	__shl_12(ld12);
	__shl_12(ld12);
	__add_12(ld12,&tmp);
	__shl_12(ld12);	       /* multiply by 10 */
	*UL_LO_12(&tmp) = (u_long)*manptr;
	*UL_MED_12(&tmp) = 0;
	*UL_HI_12(&tmp) = 0;
	__add_12(ld12,&tmp);
    }

    /* normalize mantissa -- first shift word by word */
    while (*UL_HI_12(ld12) == 0) {
	*UL_HI_12(ld12) = *UL_MED_12(ld12) >> 16;
	*UL_MED_12(ld12) = *UL_MED_12(ld12) << 16 | *UL_LO_12(ld12) >> 16;
	(*UL_LO_12(ld12)) <<= 16;
	expn -= 16;
    }
    while ((*UL_HI_12(ld12) & 0x8000) == 0) {
	__shl_12(ld12);
	expn--;
    }
    *U_EXP_12(ld12) = expn;
}

#define STRCPY strcpy

#define PUT_ZERO_FOS(fos)	 \
		fos->exp = 1,	 \
		fos->sign = ' ', \
		fos->ManLen = 1, \
		fos->man[0] = '0',\
		fos->man[1] = 0;

#define SNAN_STR      "1#SNAN"
#define SNAN_STR_LEN  6
#define QNAN_STR      "1#QNAN"
#define QNAN_STR_LEN  6
#define INF_STR	      "1#INF"
#define INF_STR_LEN   5
#define IND_STR	      "1#IND"
#define IND_STR_LEN   5

/***
char * _uldtoa (_ULDOUBLE *px,
*               int maxchars,
*               char *ldtext)
*
*
*Purpose:
*   Return pointer to filled in string "ldtext" for
*   a given _UDOUBLE ponter px
*   with a maximum character width of maxchars
*
*Entry:
*   _ULDOUBLE * px:  a pointer to the long double to be converted into a string
*   int maxchars: number of digits allowed in the output format.
*
*   (default is 'e' format)
*
*   char * ldtext: a pointer to the output string
*
*Exit:
*    returns pointer to the output string
*
*Exceptions:
*
*******************************************************************************/


char * _uldtoa (_ULDOUBLE *px, int maxchars, char *ldtext)
{
    char        in_str [250];
    char        in_str2 [250];
    char        cExp[20];
    FOS         foss;
    char *      lpszMan;
    char *      lpIndx;
    int         nErr;
    int         len1,  len2;

    maxchars -= 9;    /* sign, dot, E+0001 */

    nErr = $I10_OUTPUT (*px, maxchars, 0, &foss);

    lpszMan = foss.man;
 		  
    ldtext[0] = foss.sign;
    ldtext[1] = *lpszMan;
    ldtext[2] = '.';
    ldtext[3] = '\0';

    maxchars += 2;               /* sign, dot */

    lpszMan++;
    strcat (ldtext, lpszMan);

    len1 = strlen (ldtext);  // for 'e'


    strcpy (cExp, "e");

    foss.exp -= 1;              /* Adjust for the shift decimal shift above */
    _itoa (foss.exp, in_str, 10);

	 
    if (foss.exp < 0) {
        strcat (cExp, "-");

        strcpy (in_str2, &in_str[1]);
        strcpy (in_str, in_str2);
 		  
        while (strlen(in_str) < 4) {
            strcpy (in_str2, in_str);
            strcpy (in_str,"0");
            strcat (in_str,in_str2);
        }
    } else {
        while (strlen(in_str) < 4) {
            strcpy (in_str2, in_str);
            strcpy (in_str,"0");
            strcat (in_str,in_str2);
        }
    }

    if (foss.exp >= 0) {
        strcat (cExp, "+");
    }

    strcat (cExp, in_str);

    len2 = strlen (cExp);

    if (len1 == maxchars) {
        ;
    } 
    else if (len1 < maxchars) {
        do {
            strcat (ldtext,"0");
            len1++;
        } while (len1 < maxchars);
    }
    else {
        lpIndx = &ldtext[len1 - 1]; // point to last char and round
        do {
            *lpIndx = '\0';
            lpIndx--;
            len1--;           //NOTENOTE v-griffk we really need to round
        } while (len1 > maxchars);
    }
    
    strcat (ldtext, cExp);
    return ldtext;
}


/***
*int  _$i10_output(_ULDOUBLE ld,
*	    int ndigits,
*	    unsigned output_flags,
*	    FOS *fos) - output conversion of a 10-byte _ULDOUBLE
*
*Purpose:
*   Fill in a FOS structure for a given _ULDOUBLE
*
*Entry:
*   _ULDOUBLE ld:  The long double to be converted into a string
*   int ndigits: number of digits allowed in the output format.
*   unsigned output_flags: The following flags can be used:
*	SO_FFORMAT: Indicates 'f' format
*	(default is 'e' format)
*   FOS *fos: the structure that i10_output will fill in
*
*Exit:
*   modifies *fos
*   return 1 if original number was ok, 0 otherwise (infinity, NaN, etc)
*
*Exceptions:
*
*******************************************************************************/


int  $I10_OUTPUT(_ULDOUBLE ld, int ndigits,
		    unsigned output_flags, FOS *fos)
{
    u_short expn;
    u_long manhi,manlo;
    u_short sign;

    /* useful constants (see algorithm explanation below) */
    u_short const log2hi = 0x4d10;
    u_short const log2lo = 0x4d;
    u_short const log4hi = 0x9a;
    u_long const c = 0x134312f4;
#if defined(L_END)
    _ULDBL12 ld12_one_tenth = {
	   {0xcc,0xcc,0xcc,0xcc,0xcc,0xcc,
	    0xcc,0xcc,0xcc,0xcc,0xfb,0x3f}
    };
#elif defined(B_END)
    _ULDBL12 ld12_one_tenth = {
	   {0x3f,0xfb,0xcc,0xcc,0xcc,0xcc,
	    0xcc,0xcc,0xcc,0xcc,0xcc,0xcc}
    };
#endif

    _ULDBL12 ld12; /* space for a 12-byte long double */
    _ULDBL12 tmp12;
    u_short hh,ll; /* the bytes of the exponent grouped in 2 words*/
    u_short mm; /* the two MSBytes of the mantissa */
    s_long r; /* the corresponding power of 10 */
    s_short ir; /* ir = floor(r) */
    int retval = 1; /* assume valid number */
    char round; /* an additional character at the end of the string */
    char *p;
    int i;
    int ub_exp;
    int digcount;

    /* grab the components of the long double */
    expn = *U_EXP_LD(&ld);
    manhi = *UL_MANHI_LD(&ld);
    manlo = *UL_MANLO_LD(&ld);
    sign = expn & MSB_USHORT;
    expn &= 0x7fff;

    if (sign)
	fos->sign = '-';
    else
	fos->sign = ' ';

    if (expn==0 && manhi==0 && manlo==0) {
	PUT_ZERO_FOS(fos);
	return 1;
    }

    if (expn == 0x7fff) {
	fos->exp = 1; /* set a positive exponent for proper output */

	/* check for special cases */
	if (_IS_MAN_SNAN(sign, manhi, manlo)) {
	    /* signaling NAN */
	    STRCPY(fos->man,SNAN_STR);
	    fos->ManLen = SNAN_STR_LEN;
	    retval = 0;
	}
	else if (_IS_MAN_IND(sign, manhi, manlo)) {
	    /* indefinite */
	    STRCPY(fos->man,IND_STR);
	    fos->ManLen = IND_STR_LEN;
	    retval = 0;
	}
	else if (_IS_MAN_INF(sign, manhi, manlo)) {
	    /* infinity */
	    STRCPY(fos->man,INF_STR);
	    fos->ManLen = INF_STR_LEN;
	    retval = 0;
	}
	else {
	    /* quiet NAN */
	    STRCPY(fos->man,QNAN_STR);
	    fos->ManLen = QNAN_STR_LEN;
	    retval = 0;
	}
    }
    else {
       /*
	*    Algorithm for the decoding of a valid real number x
	*
	* In the  following  INT(r)  is	the largest integer less than or
	* equal to r (i.e. r rounded toward -infinity).	We want a result
	* r equal  to  1  + log(x), because then x = mantissa
	* * 10^(INT(r)) so that	.1  <=	mantissa  <  1.   Unfortunately,
	* we cannot  compute  s	exactly  so  we must alter the procedure
	* slightly.  We will  instead  compute	an  estimate  r	of  1  +
	* log(x) which	is  always  low.   This	will either result
	* in the correctly normalized number on	the  top  of  the  stack
	* or perhaps  a	number	which  is  a factor of 10 too large.  We
	* will then check to see that if  x  is	larger	 than  one
	* and if so multiply x by 1/10.
	*
	* We will  use	a  low	precision  (fixed  point 24 bit) estimate
	* of of 1 + log base 10 of x.  We  have	approximately  .mm
	* * 2^hhll  on	the  top of the stack where m, h, and l represent
	* hex digits,  mm  represents  the  high  2  hex  digits  of  the
	* mantissa, hh	represents the high 2 hex digits of the exponent,
	* and ll represents the low 2 hex digits of the exponent.   Since
	* .mm is  a  truncated	representation	of the mantissa, using it
	* in this  monotonically  increasing   polynomial   approximation
	* of the  logarithm  will  naturally  give  a  low result.  Let's
	* derive a formula for a lower	bound  r  on  1	+  log(x):
	*
	*      .4D104D42H < log(2)=.30102999...(base 10) < .4D104D43H
	*	  .9A20H < log(4)=.60205999...(base 10) < .9A21H
	*
	*  1/2 <= .mm < 1
	*  ==>	log(.mm) >= .mm * log(4) - log(4)
	*
	* Substituting in  truncated  hex  constants in the formula above
	* gives r = 1 + .4D104DH * hhll.  + .9AH *  .mm	-  .9A21H.   Now
	* multiplication of  hex  digits  5  and 6 of log(2) by ll has an
	* insignificant effect on the first 24	bits  of  the  result  so
	* it will  not	be  calculated.	 This  gives  the expression r =
	* 1 + .4D10H * hhll.  +	.4DH  *  .hh  +  .9A  *  .mm  -  .9A21H.
	* Finally we  must  add	terms to our formula to subtract out the
	* effect of the exponent bias.	We obtain the following	formula:
	*
	*			(implied decimal point)
	*   <				  >.<				   >
	*   |3|3|2|2|2|2|2|2|2|2|2|2|1|1|1|1|1|1|1|1|1|1|0|0|0|0|0|0|0|0|0|0|
	*   |1|0|9|8|7|6|5|4|3|2|1|0|9|8|7|6|5|4|3|2|1|0|9|8|7|6|5|4|3|2|1|0|
	* + <		  1		  >
	* + <			    .4D10H * hhll.			   >
	* +				    <	    .00004DH * hh00.	   >
	* +				    <	       .9AH * .mm	   >
	* -				    <		 .9A21H 	   >
	* - <			    .4D10H * 3FFEH			   >
	* -				    <	    .00004DH * 3F00H	   >
	*
	*  ==>	r = .4D10H * hhll. + .4DH * .hh + .9AH * .mm - 1343.12F4H
	*
	* The difference  between  the	lower bound r and the upper bound
	* s is calculated as follows:
	*
	*  .937EH < 1/ln(10)-log(1/ln(4))=.57614993...(base 10) < .937FH
	*
	*  1/2 <= .mm < 1
	*  ==>	log(.mm) <= .mm * log(4) - [1/ln(10) - log(1/ln(4))]
	*
	* so tenatively	s  =  r  +  log(4)  - [1/ln(10) - log(1/ln(4))],
	* but we must also add in terms to ensure we will have	an  upper
	* bound even  after  the  truncation  of various values.  Because
	* log(2) * hh00.  is truncated	to  .4D104DH  *	hh00.	we  must
	* add .0043H,  because	log(2)	*  ll.	is truncated to .4D10H *
	* ll.  we  must	add  .0005H,  because  <mantissa>  *  log(4)  is
	* truncated to .mm * .9AH we must add .009AH and .0021H.
	*
	* Thus s = r - .937EH + .9A21H + .0043H + .0005H + .009AH + .0021H
	*	= r + .07A6H
	*  ==>	s = .4D10H * hhll. + .4DH * .hh + .9AH * .mm - 1343.0B4EH
	*
	* r is	equal  to  1  +	log(x) more than (10000H - 7A6H) /
	* 10000H = 97% of the time.
	*
	* In the above formula, a u_long is use to accomodate r, and
	* there is an implied decimal point in the middle.
	*/

	hh = expn >> 8;
	ll = expn & (u_short)0xff;
	mm = (u_short) (manhi >> 24);
	r = (s_long)log2hi*(s_long)expn + log2lo*hh + log4hi*mm - c;
	ir = (s_short)(r >> 16);

       /*
	*
	* We stated that we wanted to normalize x so that
	*
	*  .1 <= x < 1
	*
	* This was	a  slight  oversimplification.	 Actually  we  want a
	* number which when rounded to 16 significant digits  is  in  the
	* desired range.   To  do  this we must normalize x so that
	*
	*  .1 - 5*10^(-18) <= x < 1 - 5*10^(-17)
	*
	* and then round.
	*
	* If we  had f = INT(1+log(x)) we could multiply by 10^(-f)
	* to get x into the desired range.	We do  not  quite  have
	* f but  we  do  have  INT(r)  from  the last step which is equal
	* to f 97% of the time and 1 less than f the rest  of  the	time.
	* We can  multiply	by  10^-[INT(r)] and if the result is greater
	* than 1 - 5*10^(-17) we can then multiply by 1/10.   This	final
	* result will lie in the proper range.
	*/

	/* convert _ULDOUBLE to _ULDBL12) */
	*U_EXP_12(&ld12) = expn;
	*UL_MANHI_12(&ld12) = manhi;
	*UL_MANLO_12(&ld12) = manlo;
	*U_XT_12(&ld12) = 0;

	/* multiply by 10^(-ir) */
	__multtenpow12(&ld12,-ir,1);

	/* if ld12 >= 1.0 then divide by 10.0 */
	if (*U_EXP_12(&ld12) >= 0x3fff) {
	    ir++;
	    __ld12mul(&ld12,&ld12_one_tenth);
	}

	fos->exp = ir;
	if (output_flags & SO_FFORMAT){
	    /* 'f' format, add exponent to ndigits */
	    ndigits += ir;
	    if (ndigits <= 0) {
		/* return 0 */
		PUT_ZERO_FOS(fos);
		return 1;
	    }
	}
	if (ndigits > MAX_MAN_DIGITS)
	    ndigits = MAX_MAN_DIGITS;

	ub_exp = *U_EXP_12(&ld12) - 0x3ffe; /* unbias exponent */
	*U_EXP_12(&ld12) = 0;

	/*
	 * Now the mantissa has to be converted to fixed point.
	 * Then we will use the MSB of ld12 for generating
	 * the decimal digits. The next 11 bytes will hold
	 * the mantissa (after it has been converted to
	 * fixed point).
	 */

	for (i=0;i<8;i++)
	    __shl_12(&ld12); /* make space for an extra byte,
			      in case we shift right later */
	if (ub_exp < 0) {
	    int shift_count = (-ub_exp) & 0xff;
	    for (;shift_count>0;shift_count--)
		__shr_12(&ld12);
	}

	p = fos->man;
	for(digcount=ndigits+1;digcount>0;digcount--) {
	    tmp12 = ld12;
	    __shl_12(&ld12);
	    __shl_12(&ld12);
	    __add_12(&ld12,&tmp12);
	    __shl_12(&ld12);	/* ld12 *= 10 */

	    /* Now we have the first decimal digit in the msbyte of exponent */
	    *p++ = (char) (*UCHAR_12(&ld12,11) + '0');
	    *UCHAR_12(&ld12,11) = 0;
	}

	round = *(--p);
	p--; /* p points now to the last character of the string
		   excluding the rounding digit */
	if (round >= '5') {
	    /* look for a non-9 digit starting from the end of string */
	    for (;p>=fos->man && *p=='9';p--) {
		*p = '0';
	    }
	    if (p < fos->man){
		p++;
		fos->exp ++;
	    }
	    (*p)++;
	}
	else {
	    /* remove zeros */
	    for (;p>=fos->man && *p=='0';p--);
	    if (p < fos->man) {
		/* return 0 */
		PUT_ZERO_FOS(fos);
		return 1;
	    }
	}
	fos->ManLen = (char) (p - fos->man + 1);
	fos->man[fos->ManLen] = '\0';
    }
    return retval;
}

/***
*strgtold.c - conversion of a string into a long double
*
*	Copyright (c) 1991-1991, Microsoft Corporation.	All rights reserved.
*
*Purpose: convert a fp constant into a 10 byte long double (IEEE format)
*
*Revision History:
*   7-17-91	GDP	Initial version (ported from assembly)
*   4-03-92	GDP	Preserve sign of -0
*   4-30-92	GDP	Now returns _ULDBL12 instead of _ULDOUBLE
*   05-26-92       GWK     Windbg srcs
*
*******************************************************************************/

/* local macros */
#define ISNZDIGIT(x) ((x)>='1' && (x)<='9' )

//NOTENOTE the following takes the place of the isdigit() macro
//       which does not work for a yet to be determined reason
#define ISADIGIT(x) ((x)>='0' && (x)<='9' )

#define ISWHITE(x) ((x)==' ' || (x)=='\t' || (x)=='\n' || (x)=='\r' )




/****
*unsigned int __strgtold( _ULDBL12 *pld12,
*			  char * * pEndPtr,
*			  char * str,
*			  int Mult12 )
*
*Purpose:
*   converts a character string into a long double
*
*Entry:
*   pld12   - pointer to the _ULDBL12 where the result should go.
*   pEndStr - pointer to a far pointer that will be set to the end of string.
*   str     - pointer to the string to be converted.
*   Mult12  - set to non zero if the _ULDBL12 multiply should be used instead of
*		the long double mulitiply.
*
*Exit:
*   Returns the SLD_* flags or'ed together.
*
*Uses:
*
*Exceptions:
*
********************************************************************************/

unsigned int
__strgtold12(_ULDBL12 *pld12,
	    char * *p_end_ptr,
	    char *str,
	    int mult12)
{
    typedef enum {
	S_INIT,  /* initial state */
	S_EAT0L, /* eat 0's at the left of mantissa */
	S_SIGNM, /* just read sign of mantissa */
	S_GETL,  /* get integer part of mantissa */
	S_GETR,  /* get decimal part of mantissa */
	S_POINT, /* just found decimal point */
	S_E,	 /* just found	'E', or 'e', etc  */
	S_SIGNE, /* just read sign of exponent */
	S_EAT0E, /* eat 0's at the left of exponent */
	S_GETE,  /* get exponent */
	S_END	 /* final state */
    } state_t;

    /* this will accomodate the digits of the mantissa in BCD form*/
    static char buf[LD_MAX_MAN_LEN1];
    char *manp = buf;

    /* a temporary _ULDBL12 */
    _ULDBL12 tmpld12;

    u_short man_sign = 0; /* to be ORed with result */
    int exp_sign = 1; /* default sign of exponent (values: +1 or -1)*/
    /* number of decimal significant mantissa digits so far*/
    unsigned manlen = 0;
    int found_digit = 0;
    int overflow = 0;
    int underflow = 0;
    int pow = 0;
    int exp_adj = 0;  /* exponent adjustment */
    u_long ul0,ul1;
    u_short u,uexp;

    unsigned int result_flags = 0;

    state_t state = S_INIT;

    char c;  /* the current input symbol */
    char *p; /* a pointer to the next input symbol */
    char *savedp;

    for(savedp=p=str;ISWHITE(*p);p++); /* eat up white space */

    while (state != S_END) {
	c = *p++;
	switch (state) {
	case S_INIT:
	    if (ISNZDIGIT(c)) {
		state = S_GETL;
		p--;
	    }
	    else
		switch (c) {
		case '0':
		    state = S_EAT0L;
		    break;
		case '+':
		    state = S_SIGNM;
		    man_sign = 0x0000;
		    break;
		case '-':
		    state = S_SIGNM;
		    man_sign = 0x8000;
		    break;
		case '.':
		    state = S_POINT;
		    break;
		default:
		    state = S_END;
		    p--;
		    break;
		}
	    break;
	case S_EAT0L:
	    found_digit = 1;
	    if (ISNZDIGIT(c)) {
		state = S_GETL;
		p--;
	    }
	    else
		switch (c) {
		case '0':
		    state = S_EAT0L;
		    break;
		case 'E':
		case 'e':
		case 'D':
		case 'd':
		    state = S_E;
		    break;
		case '.':
		    state = S_GETR;
		    break;
		default:
		    state = S_END;
		    p--;
		}
	    break;
	case S_SIGNM:
	    if (ISNZDIGIT(c)) {
		state = S_GETL;
		p--;
	    }
	    else
		switch (c) {
		case '0':
		    state = S_EAT0L;
		    break;
		case '.':
		    state = S_POINT;
		    break;
		default:
		    state = S_END;
		    p = savedp;
		}
	    break;
	case S_GETL:
	    found_digit = 1;
	    for (;ISADIGIT(c);c=*p++) {
		if (manlen < LD_MAX_MAN_LEN+1){
		    manlen++;
		    *manp++ = c - (char)'0';
		}
		else
		   exp_adj++;
	    }
	    switch (c) {
	    case '.':
		state = S_GETR;
		break;
	    case 'E':
	    case 'e':
	    case 'D':
	    case 'd':
		state = S_E;
		break;
	    default:
		state = S_END;
		p--;
	    }
	break;
	case S_GETR:
	    found_digit = 1;
	    if (manlen == 0)
		for (;c=='0';c=*p++)
		    exp_adj--;
	    for(;ISADIGIT(c);c=*p++){
		if (manlen < LD_MAX_MAN_LEN+1){
		    manlen++;
		    *manp++ = c - (char)'0';
		    exp_adj--;
		}
	    }
	    switch (c){
	    case 'E':
	    case 'e':
	    case 'D':
	    case 'd':
		state = S_E;
		break;
	    default:
		state = S_END;
		p--;
	    }
	    break;
	case S_POINT:
	    if (ISADIGIT(c)){
		state = S_GETR;
		p--;
	    }
	    else{
		state = S_END;
		p = savedp;
	    }
	    break;
	case S_E:
	    savedp = p-2; /* savedp points to 'E' */
	    if (ISNZDIGIT(c)){
		state = S_GETE;
		p--;
	    }
	    else
		switch (c){
		case '0':
		    state = S_EAT0E;
		    break;
		case '-':
		    state = S_SIGNE;
		    exp_sign = -1;
		    break;
		case '+':
		    state = S_SIGNE;
		    break;
		default:
		    state = S_END;
		    p = savedp;
		}
	break;
	case S_EAT0E:
	    for(;c=='0';c=*p++);
	    if (ISNZDIGIT(c)){
		state = S_GETE;
		p--;
	    }
	    else {
		state = S_END;
		p--;
	    }
	    break;
	case S_SIGNE:
	    if (ISNZDIGIT(c)){
		state = S_GETE;
		p--;
	    }
	    else
		switch (c){
		case '0':
		    state = S_EAT0E;
		    break;
		default:
		    state = S_END;
		    p = savedp;
		}
	    break;
	case S_GETE:
	    {
		long longpow=0; /* TMAX10*10 should fit in a long */
		for(;ISADIGIT(c);c=*p++){
		    longpow = longpow*10 + (c - '0');
		    if (longpow > TMAX10){
			longpow = TMAX10+1; /* will force overflow */
			break;
		    }
		}
		pow = (int)longpow;
	    }
	    for(;ISADIGIT(c);c=*p++); /* eat up remaining digits */
	    state = S_END;
	    p--;
	    break;
	}  /* switch */
    }  /* while */

    *p_end_ptr = p;	/* set end pointer */

    /*
     * Compute result
     */

    if (found_digit && !overflow && !underflow) {
	if (manlen>LD_MAX_MAN_LEN){
	    if (buf[LD_MAX_MAN_LEN-1]>=5) {
	       /*
		* Round mantissa to MAX_MAN_LEN digits
		* It's ok to round 9 to 0ah
		*/
		buf[LD_MAX_MAN_LEN-1]++;
	    }
	    manlen = LD_MAX_MAN_LEN;
	    manp--;
	    exp_adj++;
	}
	if (manlen>0) {
	   /*
	    * Remove trailing zero's from mantissa
	    */
	    for(manp--;*manp==0;manp--) {
		/* there is at least one non-zero digit */
		manlen--;
		exp_adj++;
	    }
	    __mtold12(buf,manlen,&tmpld12);

	    if (exp_sign < 0)
		pow = -pow;
	    pow += exp_adj;
	    if (pow > TMAX10)
		overflow = 1;
	    else if (pow < TMIN10)
		underflow = 1;
	    else {
		__multtenpow12(&tmpld12,pow,mult12);

		u = *U_XT_12(&tmpld12);
		ul0 =*UL_MANLO_12(&tmpld12);
		ul1 = *UL_MANHI_12(&tmpld12);
		uexp = *U_EXP_12(&tmpld12);

	    }
	}
	else {
	    /* manlen == 0, so	return 0 */
	    u = (u_short)0;
	    ul0 = ul1 = uexp = 0;
	}
    }

    if (!found_digit) {
       /* return 0 */
       u = (u_short)0;
       ul0 = ul1 = uexp = 0;
       result_flags |= SLD_NODIGITS;
    }
    else if (overflow) {
	/* return +inf or -inf */
	uexp = (u_short)0x7fff;
	ul1 = 0x80000000;
	ul0 = 0;
	u = (u_short)0;
	result_flags |= SLD_OVERFLOW;
    }
    else if (underflow) {
       /* return 0 */
       u = (u_short)0;
       ul0 = ul1 = uexp = 0;
       result_flags |= SLD_UNDERFLOW;
    }

    /*
     * Assemble	result
     */

    *U_XT_12(pld12) = u;
    *UL_MANLO_12(pld12) = ul0;
    *UL_MANHI_12(pld12) = ul1;
    *U_EXP_12(pld12) = uexp | man_sign;

    return result_flags;
}

/***
* intrncvt.c - internal floating point conversions
*
*	Copyright (c) 1992-1992, Microsoft Corporation.	All rights reserved.
*
*Purpose:
*   All fp string conversion routines use the same core conversion code
*   that converts strings into an internal long double representation
*   with an 80-bit mantissa field. The mantissa is represented
*   as an array (man) of 32-bit unsigned longs, with man[0] holding
*   the high order 32 bits of the mantissa. The binary point is assumed
*   to be between the MSB and MSB-1 of man[0].
*
*   Bits are counted as follows:
*
*
*     +-- binary point
*     |
*     v 		 MSB	       LSB
*   ----------------	 ------------------	 --------------------
*   |0 1    .... 31|	 | 32 33 ...	63|	 | 64 65 ...	  95|
*   ----------------	 ------------------	 --------------------
*
*   man[0]		    man[1]		     man[2]
*
*   This file provides the final conversion routines from this internal
*   form to the single, double, or long double precision floating point
*   format.
*
*   All these functions do not handle NaNs (it is not necessary)
*
*
*Revision History:
*   04-29-92	GDP	written
*   05-26-92       GWK     Windbg srcs
*
*******************************************************************************/


#define INTRNMAN_LEN  3	      /* internal mantissa length in int's */

//
//  internal mantissaa representation
//  for string conversion routines
//

typedef u_long *intrnman;


typedef struct {
   int max_exp;      // maximum base 2 exponent (reserved for special values)
   int min_exp;      // minimum base 2 exponent (reserved for denormals)
   int precision;    // bits of precision carried in the mantissa
   int exp_width;    // number of bits for exponent
   int format_width; // format width in bits
   int bias;	     // exponent bias
} FpFormatDescriptor;



static FpFormatDescriptor
DoubleFormat = {
    0x7ff - 0x3ff,  //	1024, maximum base 2 exponent (reserved for special values)
    0x0   - 0x3ff,  // -1023, minimum base 2 exponent (reserved for denormals)
    53, 	    // bits of precision carried in the mantissa
    11, 	    // number of bits for exponent
    64, 	    // format width in bits
    0x3ff,	    // exponent bias
};

static FpFormatDescriptor
FloatFormat = {
    0xff - 0x7f,    //	128, maximum base 2 exponent (reserved for special values)
    0x0  - 0x7f,    // -127, minimum base 2 exponent (reserved for denormals)
    24, 	    // bits of precision carried in the mantissa
    8,		    // number of bits for exponent
    32, 	    // format width in bits
    0x7f,	    // exponent bias
};



//
// function prototypes
//

int _RoundMan (intrnman man, int nbit);
int _ZeroTail (intrnman man, int nbit);
int _IncMan (intrnman man, int nbit);
void _CopyMan (intrnman dest, intrnman src);
void _CopyMan (intrnman dest, intrnman src);
void _FillZeroMan(intrnman man);
void _Shrman (intrnman man, int n);

INTRNCVT_STATUS _ld12cvt(_ULDBL12 *pld12, void *d, FpFormatDescriptor *format);

/***
* _ZeroTail - check if a mantissa ends in 0's
*
*Purpose:
*   Return TRUE if all mantissa bits after nbit (including nbit) are 0,
*   otherwise return FALSE
*
*
*Entry:
*   man: mantissa
*   nbit: order of bit where the tail begins
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/
int _ZeroTail (intrnman man, int nbit)
{
    int nl = nbit / 32;
    int nb = 31 - nbit % 32;


    //
    //		     |<---- tail to be checked --->
    //
    //	--  ------------------------	       ----
    //	|...	|		  |  ...	  |
    //	--  ------------------------	       ----
    //	^	^    ^
    //	|	|    |<----nb----->
    //	man	nl   nbit
    //



    u_long bitmask = ~(MAX_ULONG << nb);

    if (man[nl] & bitmask)
	return 0;

    nl++;

    for (;nl < INTRNMAN_LEN; nl++)
	if (man[nl])
	    return 0;

    return 1;
}




/***
* _IncMan - increment mantissa
*
*Purpose:
*
*
*Entry:
*   man: mantissa in internal long form
*   nbit: order of bit that specifies the end of the part to be incremented
*
*Exit:
*   returns 1 on overflow, 0 otherwise
*
*Exceptions:
*
*******************************************************************************/

int _IncMan (intrnman man, int nbit)
{
    int nl = nbit / 32;
    int nb = 31 - nbit % 32;

    //
    //	|<--- part to be incremented -->|
    //
    //	--	       ---------------------------     ----
    //	|...		  |			|   ...	  |
    //	--	       ---------------------------     ----
    //	^		  ^		^
    //	|		  |		|<--nb-->
    //	man		  nl		nbit
    //

    u_long one = (u_long) 1 << nb;
    int carry;

    carry = __addl(man[nl], one, &man[nl]);

    nl--;

    for (; nl >= 0 && carry; nl--) {
	carry = (u_long) __addl(man[nl], (u_long) 1, &man[nl]);
    }

    return carry;
}




/***
* _RoundMan -  round mantissa
*
*Purpose:
*   round mantissa to nbit precision
*
*
*Entry:
*   man: mantissa in internal form
*   precision: number of bits to be kept after rounding
*
*Exit:
*   returns 1 on overflow, 0 otherwise
*
*Exceptions:
*
*******************************************************************************/

int _RoundMan (intrnman man, int precision)
{
    int i,rndbit,nl,nb;
    u_long rndmask;
    int nbit;
    int retval = 0;

    //
    // The order of the n'th bit is n-1, since the first bit is bit 0
    // therefore decrement precision to get the order of the last bit
    // to be kept
    //
    nbit = precision - 1;

    rndbit = nbit+1;

    nl = rndbit / 32;
    nb = 31 - rndbit % 32;

    //
    // Get value of round bit
    //

    rndmask = (u_long)1 << nb;

    if ((man[nl] & rndmask) &&
	 !_ZeroTail(man, rndbit+1)) {

	//
	// round up
	//

	retval = _IncMan(man, nbit);
    }


    //
    // fill rest of mantissa with zeroes
    //

    man[nl] &= MAX_ULONG << nb;
    for(i=nl+1; i<INTRNMAN_LEN; i++) {
	man[i] = (u_long)0;
    }

    return retval;
}


/***
* _CopyMan - copy mantissa
*
*Purpose:
*    copy src to dest
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/
void _CopyMan (intrnman dest, intrnman src)
{
    u_long *p, *q;
    int i;

    p = src;
    q = dest;

    for (i=0; i < INTRNMAN_LEN; i++) {
	*q++ = *p++;
    }
}



/***
* _FillZeroMan - fill mantissa with zeroes
*
*Purpose:
*
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/
void _FillZeroMan(intrnman man)
{
    int i;
    for (i=0; i < INTRNMAN_LEN; i++)
	man[i] = (u_long)0;
}



/***
* _IsZeroMan - check if mantissa is zero
*
*Purpose:
*
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/
int _IsZeroMan(intrnman man)
{
    int i;
    for (i=0; i < INTRNMAN_LEN; i++)
	if (man[i])
	    return 0;

    return 1;
}





/***
* _ShrMan - shift mantissa to the right
*
*Purpose:
*  shift man by n bits to the right
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/
void _ShrMan (intrnman man, int n)
{
    int i, n1, n2, mask;
    int carry_from_left;

    //
    // declare this as volatile in order to work around a C8
    // optimization bug
    //

    volatile int carry_to_right;

    n1 = n / 32;
    n2 = n % 32;

    mask = ~(MAX_ULONG << n2);


    //
    // first deal with shifts by less than 32 bits
    //

    carry_from_left = 0;
    for (i=0; i<INTRNMAN_LEN; i++) {

	carry_to_right = man[i] & mask;

	man[i] >>= n2;

	man[i] |= carry_from_left;

	carry_from_left = carry_to_right << (32 - n2);
    }


    //
    // now shift whole 32-bit ints
    //

    for (i=INTRNMAN_LEN-1; i>=0; i--) {
	if (i >= n1) {
	    man[i] = man[i-n1];
	}
	else {
	    man[i] = 0;
	}
    }
}




/***
* _ld12tocvt - _ULDBL12 floating point conversion
*
*Purpose:
*   convert a internal _LBL12 structure into an IEEE floating point
*   representation
*
*
*Entry:
*   pld12:  pointer to the _ULDBL12
*   format: pointer to the format descriptor structure
*
*Exit:
*   *d contains the IEEE representation
*   returns the INTRNCVT_STATUS
*
*Exceptions:
*
*******************************************************************************/
INTRNCVT_STATUS _ld12cvt(_ULDBL12 *pld12, void *d, FpFormatDescriptor *format)
{
    u_long man[INTRNMAN_LEN];
    u_long saved_man[INTRNMAN_LEN];
    u_long msw;
    unsigned int bexp;			// biased exponent
    int exp_shift;
    int exponent, sign;
    INTRNCVT_STATUS retval;

    exponent = (*U_EXP_12(pld12) & 0x7fff) - 0x3fff;   // unbias exponent
    sign = *U_EXP_12(pld12) & 0x8000;

    //
    // bexp is the final biased value of the exponent to be used
    // Each of the following blocks should provide appropriate
    // values for man, bexp and retval. The mantissa is also
    // shifted to the right, leaving space for the exponent
    // and sign to be inserted
    //


    if (exponent == 0 - 0x3fff) {

	// either a denormal or zero
	bexp = 0;
        _FillZeroMan(man);

	if (ISZERO_12(pld12)) {

	    retval = INTRNCVT_OK;
	}
	else {

	    // denormal has been flushed to zero

	    retval = INTRNCVT_UNDERFLOW;
	}
    }
    else {

	man[0] = *UL_MANHI_12(pld12);
	man[1] = *UL_MANLO_12(pld12);
	man[2] = *U_XT_12(pld12) << 16;

	// save mantissa in case it needs to be rounded again
	// at a different point (e.g., if the result is a denormal)

	_CopyMan(saved_man, man);

	if (_RoundMan(man, format->precision)) {
	    exponent ++;
	}

	if (exponent < format->min_exp - format->precision ) {

	    //
	    // underflow that produces a zero
	    //

	    _FillZeroMan(man);
	    bexp = 0;
	    retval = INTRNCVT_UNDERFLOW;
	}

	else if (exponent <= format->min_exp) {

	    //
	    // underflow that produces a denormal
	    //
	    //

	    // The (unbiased) exponent will be MIN_EXP
	    // Find out how much the mantissa should be shifted
	    // One shift is done implicitly by moving the
	    // binary point one bit to the left, i.e.,
	    // we treat the mantissa as .ddddd instead of d.dddd
	    // (where d is a binary digit)

	    int shift = format->min_exp - exponent;

	    // The mantissa should be rounded again, so it
	    // has to be restored

	    _CopyMan(man,saved_man);

	    _ShrMan(man, shift);
	    _RoundMan(man, format->precision); // need not check for carry

	    // make room for the exponent + sign

	    _ShrMan(man, format->exp_width + 1);

	    bexp = 0;
	    retval = INTRNCVT_UNDERFLOW;

	}

	else if (exponent >= format->max_exp) {

	    //
	    // overflow, return infinity
	    //

	    _FillZeroMan(man);
	    man[0] |= (1 << 31); // set MSB

	    // make room for the exponent + sign

	    _ShrMan(man, (format->exp_width + 1) - 1);

	    bexp = format->max_exp + format->bias;

	    retval = INTRNCVT_OVERFLOW;
	}

	else {

	    //
	    // valid, normalized result
	    //

	    bexp = exponent + format->bias;


	    // clear implied bit

	    man[0] &= (~( 1 << 31));

	    //
	    // shift right to make room for exponent + sign
	    //

	    _ShrMan(man, (format->exp_width + 1) - 1);

	    retval = INTRNCVT_OK;

	}
    }


    exp_shift = 32 - (format->exp_width + 1);
    msw =  man[0] |
	   (bexp << exp_shift) |
	   (sign ? 1<<31 : 0);

    if (format->format_width == 64) {

	*UL_HI_D(d) = msw;
	*UL_LO_D(d) = man[1];
    }

    else if (format->format_width == 32) {

	*(u_long *)d = msw;

    }

    return retval;
}


/***
* _ld12tod - convert _ULDBL12 to double
*
*Purpose:
*
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/
INTRNCVT_STATUS _ld12tod(_ULDBL12 *pld12, UDOUBLE *d)
{
    return _ld12cvt(pld12, d, &DoubleFormat);
}



/***
* _ld12tof - convert _ULDBL12 to float
*
*Purpose:
*
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/
INTRNCVT_STATUS _ld12tof(_ULDBL12 *pld12, FLOAT *f)
{
    return _ld12cvt(pld12, f, &FloatFormat);
}


/***
* _ld12told - convert _ULDBL12 to 80 bit long double
*
*Purpose:
*
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/
void _ld12told(_ULDBL12 *pld12, _ULDOUBLE *pld)
{

    //
    // This implementation is based on the fact that the _ULDBL12 format is
    // identical to the long double and has 2 extra bytes of mantissa
    //

    u_short exp, sign;
    u_long man[INTRNMAN_LEN];

    exp = *U_EXP_12(pld12) & (u_short)0x7fff;
    sign = *U_EXP_12(pld12) & (u_short)0x8000;

    man[0] = *UL_MANHI_12(pld12);
    man[1] = *UL_MANLO_12(pld12);
    man[2] = *U_XT_12(pld12) << 16;

    if (_RoundMan(man, 64))
	exp ++;

    *UL_MANHI_LD(pld) = man[0];
    *UL_MANLO_LD(pld) = man[1];
    *U_EXP_LD(pld) = sign | exp;
}


void _atodbl(UDOUBLE *d, char *str)
{
    char *EndPtr;
    _ULDBL12 ld12;

    __strgtold12(&ld12, &EndPtr, str, 0 );
    _ld12tod(&ld12, d);
}


void _atoldbl(_ULDOUBLE *ld, char *str)
{
    char *EndPtr;
    _ULDBL12 ld12;

    __strgtold12(&ld12, &EndPtr, str, 0 );
    _ld12told(&ld12, ld);
}


void _atoflt(FLOAT *f, char *str)
{
    char *EndPtr;
    _ULDBL12 ld12;

    __strgtold12(&ld12, &EndPtr, str, 0 );
    _ld12tof(&ld12, f);
}

double 
Float82ToDouble(const FLOAT128* FpReg82)
{
    double f = 0.0;

    FLOAT82_FORMAT* f82 = (FLOAT82_FORMAT*)FpReg82;
    ULONG64 mant = f82->significand;

    if (mant) 
    {
        int exp = (f82->exponent ? (f82->exponent - 0xffff) : -0x3ffe) - 63;

        // try to minimize abs(iExp)
        while (exp > 0 && mant && !(mant & (ULONG64(1)<<63)))
        {
            mant <<= 1;
            --exp;
        }
        while (exp < 0 && mant && !(mant & 1)) 
        {
            mant >>= 1;
            ++exp;
        }

        f = ldexp(double(mant), exp);
        if (f82->sign)
        {
            f = -f;
        }
    }
    return f;
}

void 
DoubleToFloat82(double f, FLOAT128* FpReg82)
{
    ZeroMemory(FpReg82, sizeof(FLOAT128));
    FLOAT82_FORMAT* f82 = (FLOAT82_FORMAT*)FpReg82;

    // Normalize
    int exp;
    f = frexp(f, &exp);
    
    if (f < 0) 
    {
        f82->sign = 1;
        f = -f;
    }

    // shift fraction into integer part
    ULONG64 mant;
    while (double(mant = ULONG64(f)) < f)
    {
        f = f * 2.0;
        --exp;
    }

    f82->exponent = exp + 0xffff + 0x3f;
    f82->significand = mant;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\dbg-common\float10.h ===
//----------------------------------------------------------------------------
//
// float10.h
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _FLOAT10_H_
#define _FLOAT10_H_

typedef struct {
	double x;
} UDOUBLE;


#pragma pack(4)
typedef UCHAR u_char;
typedef struct {
    u_char ld[10];
} _ULDOUBLE;
#pragma pack()

#pragma pack(4)
typedef struct {
    u_char ld12[12];
} _ULDBL12;
#pragma pack()

#define MAX_MAN_DIGITS 21

#define MAX_10_LEN  30  //max length of string including NULL

// specifies '%f' format

#define SO_FFORMAT 1

typedef  struct _FloatOutStruct {
		    short   exp;
		    char    sign;
		    char    ManLen;
		    char    man[MAX_MAN_DIGITS+1];
		    } FOS;

char * _uldtoa (_ULDOUBLE *px, int maxchars, char *ldtext);

int    $I10_OUTPUT(_ULDOUBLE ld, int ndigits,
                   unsigned output_flags, FOS	*fos);

//
// return values for strgtold12 routine
//

#define SLD_UNDERFLOW 1
#define SLD_OVERFLOW 2
#define SLD_NODIGITS 4

//
// return values for internal conversion routines
// (12-byte to long double, double, or float)
//

typedef enum {
    INTRNCVT_OK,
    INTRNCVT_OVERFLOW,
    INTRNCVT_UNDERFLOW
} INTRNCVT_STATUS;

unsigned int
__strgtold12(_ULDBL12 *pld12,
             char * *p_end_ptr,
             char *str,
             int mult12);

INTRNCVT_STATUS _ld12tod(_ULDBL12 *pld12, UDOUBLE *d);
void _ld12told(_ULDBL12 *pld12, _ULDOUBLE *pld);

void _atodbl(UDOUBLE *d, char *str);
void _atoldbl(_ULDOUBLE *ld, char *str);

//
// Simple FLOAT86 utilities
//

typedef struct {
    ULONG64 significand : 64;
    UINT    exponent    : 17;
    UINT    sign        : 1;
} FLOAT82_FORMAT;

double 
Float82ToDouble(const FLOAT128* FpReg82);

void 
DoubleToFloat82(double f, FLOAT128* FpReg82);

#endif // #ifndef _FLOAT10_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\dbg-common\emver.h ===
//----------------------------------------------------------------------------
//
// Debugger package binary version information.
//
// Copyright (C) Microsoft Corporation, 2000.
//
//----------------------------------------------------------------------------

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef OFFICIAL_BUILD
#include <ntverp.h>
#else

#define VER_PRODUCTMAJORVERSION     8
#define VER_PRODUCTMINORVERSION     0
#define VER_PRODUCTBUILD            2440
#define VER_PRODUCTBUILD_QFE        0
#define VER_PRODUCTVERSION_W        (0x0100)
#define VER_PRODUCTVERSION_DW       (0x01000000 | VER_PRODUCTBUILD)

#define VER_PRODUCTBETA_STR         ""

#define VER_PRODUCTVERSION_MAJORMINOR2(x,y) #x "." #y
#define VER_PRODUCTVERSION_MAJORMINOR1(x,y) VER_PRODUCTVERSION_MAJORMINOR2(x, y)
#define VER_PRODUCTVERSION_STRING   VER_PRODUCTVERSION_MAJORMINOR1(VER_PRODUCTMAJORVERSION, VER_PRODUCTMINORVERSION)

#define VER_PRODUCTVERSION          VER_PRODUCTMAJORVERSION,VER_PRODUCTMINORVERSION,VER_PRODUCTBUILD,VER_PRODUCTBUILD_QFE

#if     (VER_PRODUCTBUILD < 10)
#define VER_BPAD "000"
#elif   (VER_PRODUCTBUILD < 100)
#define VER_BPAD "00"
#elif   (VER_PRODUCTBUILD < 1000)
#define VER_BPAD "0"
#else
#define VER_BPAD
#endif

#define VER_PRODUCTVERSION_STR2(x,y) VER_PRODUCTVERSION_STRING "." VER_BPAD #x "." #y
#define VER_PRODUCTVERSION_STR1(x,y) VER_PRODUCTVERSION_STR2(x, y)
#define VER_PRODUCTVERSION_STR       VER_PRODUCTVERSION_STR1(VER_PRODUCTBUILD, VER_PRODUCTBUILD_QFE)

/*--------------------------------------------------------------*/
/* the following section defines values used in the version     */
/* data structure for all files, and which do not change.       */
/*--------------------------------------------------------------*/

/* default is nodebug */
#if DBG
#define VER_DEBUG                   VS_FF_DEBUG
#else
#define VER_DEBUG                   0
#endif

/* default is prerelease */
#if BETA
#define VER_PRERELEASE              VS_FF_PRERELEASE
#else
#define VER_PRERELEASE              0
#endif

#if OFFICIAL_BUILD
#define VER_PRIVATE                 0
#else
#define VER_PRIVATE                 VS_FF_PRIVATEBUILD
#endif

#define VER_FILEFLAGSMASK           VS_FFI_FILEFLAGSMASK
#define VER_FILEOS                  VOS_NT_WINDOWS32
#define VER_FILEFLAGS               (VER_PRERELEASE|VER_DEBUG|VER_PRIVATE)

#define VER_COMPANYNAME_STR         "Microsoft Corporation"
#define VER_PRODUCTNAME_STR         "Debugging Tools for Windows(R)"
#define VER_LEGALTRADEMARKS_STR     \
"Microsoft(R) is a registered trademark of Microsoft Corporation. Windows (R) is a registered trademark of Microsoft Corporation."

#endif

#include <common.ver>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\dbg-common\ntnative.cpp ===
//----------------------------------------------------------------------------
//
// Support routines for NT-native binaries.
//
// Copyright (C) Microsoft Corporation, 2000-2001.
//
//----------------------------------------------------------------------------

#include "pch.hpp"

#ifdef NT_NATIVE

#define _CRTIMP
#include <time.h>
#include <ntddser.h>

#include "ntnative.h"
#include "cmnutil.hpp"

void* __cdecl operator new(size_t Bytes)
{
    return RtlAllocateHeap(RtlProcessHeap(), 0, Bytes);
}

void __cdecl operator delete(void* Ptr)
{
    RtlFreeHeap(RtlProcessHeap(), 0, Ptr);
}

int __cdecl _purecall(void)
{
    return 0;
}

int __cdecl atexit(void (__cdecl* func)(void))
{
    return 1;
}

#define BASE_YEAR_ADJUSTMENT 11644473600

time_t __cdecl time(time_t* timer)
{
    LARGE_INTEGER SystemTime;

    //
    // Read system time from shared region.
    //

    do
    {
        SystemTime.HighPart = USER_SHARED_DATA->SystemTime.High1Time;
        SystemTime.LowPart = USER_SHARED_DATA->SystemTime.LowPart;
    } while (SystemTime.HighPart != USER_SHARED_DATA->SystemTime.High2Time);

    // Convert to seconds.
    ULONG64 TimeDate = SystemTime.QuadPart / 10000000;
    // Convert from base year 1601 to base year 1970.
    return (ULONG)(TimeDate - BASE_YEAR_ADJUSTMENT);
}

#ifdef _X86_

LONG WINAPI
InterlockedIncrement(
    IN OUT LONG volatile *lpAddend
    )
{
    __asm
    {
        mov     ecx,lpAddend            ; get pointer to addend variable
        mov     eax,1                   ; set increment value
   lock xadd    [ecx],eax               ; interlocked increment
        inc     eax                     ; adjust return value
    }
}

LONG WINAPI
InterlockedDecrement(
    IN OUT LONG volatile *lpAddend
    )
{
    __asm
    {
        mov     ecx,lpAddend            ; get pointer to addend variable
        mov     eax,-1                  ; set decrement value
   lock xadd    [ecx],eax               ; interlocked decrement
        dec     eax                     ; adjust return value
    }
}

LONG WINAPI
InterlockedExchange(
   IN OUT LONG volatile *Target,
   IN LONG Value
   )
{
    __asm
    {
        mov     ecx, [esp+4]                ; (ecx) = Target
        mov     edx, [esp+8]                ; (edx) = Value
        mov     eax, [ecx]                  ; get comperand value
Ixchg:
   lock cmpxchg [ecx], edx                  ; compare and swap
        jnz     Ixchg                       ; if nz, exchange failed
    }
}

#endif // #ifdef _X86_

DWORD WINAPI
GetLastError(
    VOID
    )
{
    return (DWORD)NtCurrentTeb()->LastErrorValue;
}

VOID WINAPI
SetLastError(
    DWORD dwErrCode
    )
{
    NtCurrentTeb()->LastErrorValue = (LONG)dwErrCode;
}

void
BaseSetLastNTError(NTSTATUS NtStatus)
{
    SetLastError(RtlNtStatusToDosError(NtStatus));
}

void WINAPI
Sleep(DWORD Milliseconds)
{
    LARGE_INTEGER Timeout;

    Win32ToNtTimeout(Milliseconds, &Timeout);
    NtDelayExecution(FALSE, &Timeout);
}

HANDLE WINAPI
OpenProcess(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    DWORD dwProcessId
    )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    CLIENT_ID ClientId;

    ClientId.UniqueThread = NULL;
    ClientId.UniqueProcess = LongToHandle(dwProcessId);

    InitializeObjectAttributes(
        &Obja,
        NULL,
        (bInheritHandle ? OBJ_INHERIT : 0),
        NULL,
        NULL
        );
    Status = NtOpenProcess(
                &Handle,
                (ACCESS_MASK)dwDesiredAccess,
                &Obja,
                &ClientId
                );
    if ( NT_SUCCESS(Status) )
    {
        BaseSetLastNTError(Status);
        return Handle;
    }
    else
    {
        return NULL;
    }
}

BOOL
CloseHandle(
    HANDLE hObject
    )
{
    return NT_SUCCESS(NtClose(hObject));
}

int
WINAPI
MultiByteToWideChar(
    IN UINT     CodePage,
    IN DWORD    dwFlags,
    IN LPCSTR   lpMultiByteStr,
    IN int      cbMultiByte,
    OUT LPWSTR  lpWideCharStr,
    IN int      cchWideChar)
{
    if (CodePage != CP_ACP || dwFlags != 0)
    {
        return 0;
    }

    UNICODE_STRING Wide;
    ANSI_STRING Ansi;

    RtlInitAnsiString(&Ansi, lpMultiByteStr);
    Wide.Buffer = lpWideCharStr;
    Wide.MaximumLength = (USHORT)cchWideChar;
    if (!NT_SUCCESS(RtlAnsiStringToUnicodeString(&Wide, &Ansi, FALSE)))
    {
        return 0;
    }
    else
    {
        return Wide.Length / sizeof(WCHAR) + 1;
    }
}

int
WINAPI
WideCharToMultiByte(
    IN UINT     CodePage,
    IN DWORD    dwFlags,
    IN LPCWSTR  lpWideCharStr,
    IN int      cchWideChar,
    OUT LPSTR   lpMultiByteStr,
    IN int      cbMultiByte,
    IN LPCSTR   lpDefaultChar,
    OUT LPBOOL  lpUsedDefaultChar)
{
    if (CodePage != CP_ACP || dwFlags != 0 || lpDefaultChar != NULL ||
        lpUsedDefaultChar != NULL)
    {
        return 0;
    }

    UNICODE_STRING Wide;
    ANSI_STRING Ansi;

    RtlInitUnicodeString(&Wide, lpWideCharStr);
    Ansi.Buffer = lpMultiByteStr;
    Ansi.MaximumLength = (USHORT)cbMultiByte;
    if (!NT_SUCCESS(RtlUnicodeStringToAnsiString(&Ansi, &Wide, FALSE)))
    {
        return 0;
    }
    else
    {
        return Ansi.Length + 1;
    }
}

DWORD
WINAPI
SuspendThread(
    IN HANDLE hThread
    )
{
    DWORD PrevCount;
    NTSTATUS NtStatus;

    NtStatus = NtSuspendThread(hThread, &PrevCount);
    if (NT_SUCCESS(NtStatus))
    {
        return PrevCount;
    }
    else
    {
        BaseSetLastNTError(NtStatus);
        return -1;
    }
}

DWORD
WINAPI
ResumeThread(
    IN HANDLE hThread
    )
{
    DWORD PrevCount;
    NTSTATUS NtStatus;

    NtStatus = NtResumeThread(hThread, &PrevCount);
    if (NT_SUCCESS(NtStatus))
    {
        return PrevCount;
    }
    else
    {
        BaseSetLastNTError(NtStatus);
        return -1;
    }
}

DWORD
WINAPI
GetCurrentThreadId(void)
{
    return HandleToUlong(NtCurrentTeb()->ClientId.UniqueThread);
}

DWORD
WINAPI
GetCurrentProcessId(void)
{
    return HandleToUlong(NtCurrentTeb()->ClientId.UniqueProcess);
}

HANDLE
WINAPI
GetCurrentProcess(void)
{
    return NtCurrentProcess();
}

BOOL
WINAPI
ReadProcessMemory(
    HANDLE hProcess,
    LPCVOID lpBaseAddress,
    LPVOID lpBuffer,
    SIZE_T nSize,
    SIZE_T *lpNumberOfBytesRead
    )
{
    NTSTATUS Status;
    SIZE_T NtNumberOfBytesRead;

    Status = NtReadVirtualMemory(hProcess,
                                 (PVOID)lpBaseAddress,
                                 lpBuffer,
                                 nSize,
                                 &NtNumberOfBytesRead
                                 );

    if ( lpNumberOfBytesRead != NULL )
    {
        *lpNumberOfBytesRead = NtNumberOfBytesRead;
    }

    if ( !NT_SUCCESS(Status) )
    {
        BaseSetLastNTError(Status);
        return FALSE;
    }
    else
    {
        return TRUE;
    }
}

BOOL
WINAPI
WriteProcessMemory(
    HANDLE hProcess,
    LPVOID lpBaseAddress,
    LPCVOID lpBuffer,
    SIZE_T nSize,
    SIZE_T *lpNumberOfBytesWritten
    )
{
    NTSTATUS Status, xStatus;
    ULONG OldProtect;
    SIZE_T RegionSize;
    PVOID Base;
    SIZE_T NtNumberOfBytesWritten;

    //
    // Set the protection to allow writes
    //

    RegionSize =  nSize;
    Base = lpBaseAddress;
    Status = NtProtectVirtualMemory(hProcess,
                                    &Base,
                                    &RegionSize,
                                    PAGE_EXECUTE_READWRITE,
                                    &OldProtect
                                    );
    if ( NT_SUCCESS(Status) )
    {
        //
        // See if previous protection was writable. If so,
        // then reset protection and do the write.
        // Otherwise, see if previous protection was read-only or
        // no access. In this case, don't do the write, just fail
        //

        if ( (OldProtect & PAGE_READWRITE) == PAGE_READWRITE ||
             (OldProtect & PAGE_WRITECOPY) == PAGE_WRITECOPY ||
             (OldProtect & PAGE_EXECUTE_READWRITE) == PAGE_EXECUTE_READWRITE ||
             (OldProtect & PAGE_EXECUTE_WRITECOPY) == PAGE_EXECUTE_WRITECOPY )
        {
            Status = NtProtectVirtualMemory(hProcess,
                                            &Base,
                                            &RegionSize,
                                            OldProtect,
                                            &OldProtect
                                            );
            Status = NtWriteVirtualMemory(hProcess,
                                          lpBaseAddress,
                                          lpBuffer,
                                          nSize,
                                          &NtNumberOfBytesWritten
                                          );

            if ( lpNumberOfBytesWritten != NULL )
            {
                *lpNumberOfBytesWritten = NtNumberOfBytesWritten;
            }

            if ( !NT_SUCCESS(Status) )
            {
                BaseSetLastNTError(Status);
                return FALSE;
            }
            NtFlushInstructionCache(hProcess,lpBaseAddress,nSize);
            return TRUE;
        }
        else
        {
            //
            // See if the previous protection was read only or no access. If
            // this is the case, restore the previous protection and return
            // an access violation error.
            //
            if ( (OldProtect & PAGE_NOACCESS) == PAGE_NOACCESS ||
                 (OldProtect & PAGE_READONLY) == PAGE_READONLY )
            {
                Status = NtProtectVirtualMemory(hProcess,
                                                &Base,
                                                &RegionSize,
                                                OldProtect,
                                                &OldProtect
                                                );
                BaseSetLastNTError(STATUS_ACCESS_VIOLATION);
                return FALSE;
            }
            else
            {
                //
                // The previous protection must have been code and the caller
                // is trying to set a breakpoint or edit the code. Do the write
                // and then restore the previous protection.
                //

                Status = NtWriteVirtualMemory(hProcess,
                                              lpBaseAddress,
                                              lpBuffer,
                                              nSize,
                                              &NtNumberOfBytesWritten
                                              );

                if ( lpNumberOfBytesWritten != NULL )
                {
                    *lpNumberOfBytesWritten = NtNumberOfBytesWritten;
                }

                xStatus = NtProtectVirtualMemory(hProcess,
                                                 &Base,
                                                 &RegionSize,
                                                 OldProtect,
                                                 &OldProtect
                                                 );
                if ( !NT_SUCCESS(Status) )
                {
                    BaseSetLastNTError(STATUS_ACCESS_VIOLATION);
                    return STATUS_ACCESS_VIOLATION;
                }
                NtFlushInstructionCache(hProcess,lpBaseAddress,nSize);
                return TRUE;
            }
        }
    }
    else
    {
        BaseSetLastNTError(Status);
        return FALSE;
    }
}

BOOL
DuplicateHandle(
    HANDLE hSourceProcessHandle,
    HANDLE hSourceHandle,
    HANDLE hTargetProcessHandle,
    LPHANDLE lpTargetHandle,
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    DWORD dwOptions
    )
{
    NTSTATUS Status;

    Status = NtDuplicateObject(hSourceProcessHandle,
                               hSourceHandle,
                               hTargetProcessHandle,
                               lpTargetHandle,
                               (ACCESS_MASK)dwDesiredAccess,
                               bInheritHandle ? OBJ_INHERIT : 0,
                               dwOptions
                               );
    if ( NT_SUCCESS(Status) )
    {
        return TRUE;
    }
    else
    {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return FALSE;
}

BOOL
APIENTRY
GetThreadContext(
    HANDLE hThread,
    LPCONTEXT lpContext
    )
{
    NTSTATUS Status;

    Status = NtGetContextThread(hThread,lpContext);

    if ( !NT_SUCCESS(Status) )
    {
        BaseSetLastNTError(Status);
        return FALSE;
    }
    else
    {
        return TRUE;
    }
}

BOOL
APIENTRY
SetThreadContext(
    HANDLE hThread,
    CONST CONTEXT *lpContext
    )
{
    NTSTATUS Status;

    Status = NtSetContextThread(hThread,(PCONTEXT)lpContext);

    if ( !NT_SUCCESS(Status) )
    {
        BaseSetLastNTError(Status);
        return FALSE;
    }
    else
    {
        return TRUE;
    }
}

BOOL
APIENTRY
GetThreadSelectorEntry(
    HANDLE hThread,
    DWORD dwSelector,
    LPLDT_ENTRY lpSelectorEntry
    )
{
#if defined(i386)

    DESCRIPTOR_TABLE_ENTRY DescriptorEntry;
    NTSTATUS Status;

    DescriptorEntry.Selector = dwSelector;
    Status = NtQueryInformationThread(hThread,
                                      ThreadDescriptorTableEntry,
                                      &DescriptorEntry,
                                      sizeof(DescriptorEntry),
                                      NULL
                                      );
    if ( !NT_SUCCESS(Status) )
    {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    *lpSelectorEntry = DescriptorEntry.Descriptor;
    return TRUE;

#else
    BaseSetLastNTError(STATUS_NOT_SUPPORTED);
    return FALSE;
#endif // i386
}

BOOL
WINAPI
SetEnvironmentVariableA(
    LPCSTR lpName,
    LPCSTR lpValue
    )
{
    NTSTATUS Status;
    STRING Name;
    STRING Value;
    UNICODE_STRING UnicodeName;
    UNICODE_STRING UnicodeValue;

    RtlInitString( &Name, lpName );
    Status = RtlAnsiStringToUnicodeString(&UnicodeName, &Name, TRUE);
    if ( !NT_SUCCESS(Status) )
    {
        BaseSetLastNTError( Status );
        return FALSE;
    }

    if (ARGUMENT_PRESENT( lpValue ))
    {
        RtlInitString( &Value, lpValue );
        Status = RtlAnsiStringToUnicodeString(&UnicodeValue, &Value, TRUE);
        if ( !NT_SUCCESS(Status) )
        {
            BaseSetLastNTError( Status );
            RtlFreeUnicodeString(&UnicodeName);
            return FALSE;
        }
        Status = RtlSetEnvironmentVariable( NULL, &UnicodeName, &UnicodeValue);
        RtlFreeUnicodeString(&UnicodeValue);
    }
    else
    {
        Status = RtlSetEnvironmentVariable( NULL, &UnicodeName, NULL);
    }
    RtlFreeUnicodeString(&UnicodeName);

    if (NT_SUCCESS( Status ))
    {
        return( TRUE );
    }
    else
    {
        BaseSetLastNTError( Status );
        return( FALSE );
    }
}

BOOL
WINAPI
TerminateProcess(
    HANDLE hProcess,
    UINT uExitCode
    )
{
    NTSTATUS Status;

    if ( hProcess == NULL )
    {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }
    Status = NtTerminateProcess(hProcess,(NTSTATUS)uExitCode);
    if ( NT_SUCCESS(Status) )
    {
        return TRUE;
    }
    else
    {
        BaseSetLastNTError(Status);
        return FALSE;
    }
}

BOOL
WINAPI
GetExitCodeProcess(
    HANDLE hProcess,
    LPDWORD lpExitCode
    )
{
    NTSTATUS Status;
    PROCESS_BASIC_INFORMATION BasicInformation;

    Status = NtQueryInformationProcess(hProcess,
                                       ProcessBasicInformation,
                                       &BasicInformation,
                                       sizeof(BasicInformation),
                                       NULL
                                       );

    if ( NT_SUCCESS(Status) )
    {
        *lpExitCode = BasicInformation.ExitStatus;
        return TRUE;
    }
    else
    {
        BaseSetLastNTError(Status);
        return FALSE;
    }
}

HANDLE
WINAPI
NtNativeCreateFileW(
    LPCWSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile,
    BOOL TranslatePath
    )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    UNICODE_STRING FileName;
    IO_STATUS_BLOCK IoStatusBlock;
    BOOLEAN TranslationStatus;
    RTL_RELATIVE_NAME RelativeName;
    PVOID FreeBuffer;
    ULONG CreateDisposition;
    ULONG CreateFlags = 0;
    FILE_ALLOCATION_INFORMATION AllocationInfo;
    PUNICODE_STRING lpConsoleName;
    BOOL bInheritHandle;
    BOOL EndsInSlash;
    DWORD SQOSFlags;
    BOOLEAN ContextTrackingMode = FALSE;
    BOOLEAN EffectiveOnly = FALSE;
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel = SecurityAnonymous;
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;

    if (ARGUMENT_PRESENT(hTemplateFile))
    {
        return INVALID_HANDLE_VALUE;
    }

    switch ( dwCreationDisposition )
    {
    case CREATE_NEW        :
        CreateDisposition = FILE_CREATE;
        break;
    case CREATE_ALWAYS     :
        CreateDisposition = FILE_OVERWRITE_IF;
        break;
    case OPEN_EXISTING     :
        CreateDisposition = FILE_OPEN;
        break;
    case OPEN_ALWAYS       :
        CreateDisposition = FILE_OPEN_IF;
        break;
    case TRUNCATE_EXISTING :
        CreateDisposition = FILE_OPEN;
        if ( !(dwDesiredAccess & GENERIC_WRITE) )
        {
            BaseSetLastNTError(STATUS_INVALID_PARAMETER);
            return INVALID_HANDLE_VALUE;
        }
        break;
    default :
        BaseSetLastNTError(STATUS_INVALID_PARAMETER);
        return INVALID_HANDLE_VALUE;
    }

    RtlInitUnicodeString(&FileName,lpFileName);

    if (TranslatePath)
    {
        TranslationStatus = RtlDosPathNameToNtPathName_U(lpFileName,
                                                         &FileName,
                                                         NULL,
                                                         &RelativeName
                                                         );

        if ( !TranslationStatus )
        {
            SetLastError(ERROR_PATH_NOT_FOUND);
            return INVALID_HANDLE_VALUE;
        }

        FreeBuffer = FileName.Buffer;
        
        if ( RelativeName.RelativeName.Length )
        {
            FileName = *(PUNICODE_STRING)&RelativeName.RelativeName;
        }
        else
        {
            RelativeName.ContainingDirectory = NULL;
        }
    }
    else
    {
        FreeBuffer = NULL;
        RelativeName.ContainingDirectory = NULL;
    }

    InitializeObjectAttributes(&Obja,
                               &FileName,
                               dwFlagsAndAttributes & FILE_FLAG_POSIX_SEMANTICS ? 0 : OBJ_CASE_INSENSITIVE,
                               RelativeName.ContainingDirectory,
                               NULL
                               );

    SQOSFlags = dwFlagsAndAttributes & SECURITY_VALID_SQOS_FLAGS;

    if ( SQOSFlags & SECURITY_SQOS_PRESENT )
    {
        SQOSFlags &= ~SECURITY_SQOS_PRESENT;

        if (SQOSFlags & SECURITY_CONTEXT_TRACKING)
        {
            SecurityQualityOfService.ContextTrackingMode = (SECURITY_CONTEXT_TRACKING_MODE) TRUE;
            SQOSFlags &= ~SECURITY_CONTEXT_TRACKING;
        }
        else
        {
            SecurityQualityOfService.ContextTrackingMode = (SECURITY_CONTEXT_TRACKING_MODE) FALSE;
        }

        if (SQOSFlags & SECURITY_EFFECTIVE_ONLY)
        {
            SecurityQualityOfService.EffectiveOnly = TRUE;
            SQOSFlags &= ~SECURITY_EFFECTIVE_ONLY;
        }
        else
        {
            SecurityQualityOfService.EffectiveOnly = FALSE;
        }

        SecurityQualityOfService.ImpersonationLevel = (SECURITY_IMPERSONATION_LEVEL)(SQOSFlags >> 16);
    }
    else
    {
        SecurityQualityOfService.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
        SecurityQualityOfService.ImpersonationLevel = SecurityImpersonation;
        SecurityQualityOfService.EffectiveOnly = TRUE;
    }

    SecurityQualityOfService.Length = sizeof( SECURITY_QUALITY_OF_SERVICE );
    Obja.SecurityQualityOfService = &SecurityQualityOfService;

    if ( ARGUMENT_PRESENT(lpSecurityAttributes) )
    {
        Obja.SecurityDescriptor = lpSecurityAttributes->lpSecurityDescriptor;
        if ( lpSecurityAttributes->bInheritHandle )
        {
            Obja.Attributes |= OBJ_INHERIT;
        }
    }

    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_NO_BUFFERING ? FILE_NO_INTERMEDIATE_BUFFERING : 0 );
    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_WRITE_THROUGH ? FILE_WRITE_THROUGH : 0 );
    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_OVERLAPPED ? 0 : FILE_SYNCHRONOUS_IO_NONALERT );
    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_SEQUENTIAL_SCAN ? FILE_SEQUENTIAL_ONLY : 0 );
    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_RANDOM_ACCESS ? FILE_RANDOM_ACCESS : 0 );
    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_BACKUP_SEMANTICS ? FILE_OPEN_FOR_BACKUP_INTENT : 0 );

    if ( dwFlagsAndAttributes & FILE_FLAG_DELETE_ON_CLOSE )
    {
        CreateFlags |= FILE_DELETE_ON_CLOSE;
        dwDesiredAccess |= DELETE;
    }

    if ( dwFlagsAndAttributes & FILE_FLAG_OPEN_REPARSE_POINT )
    {
        CreateFlags |= FILE_OPEN_REPARSE_POINT;
    }

    if ( dwFlagsAndAttributes & FILE_FLAG_OPEN_NO_RECALL )
    {
        CreateFlags |= FILE_OPEN_NO_RECALL;
    }

    //
    // Backup semantics allow directories to be opened
    //

    if ( !(dwFlagsAndAttributes & FILE_FLAG_BACKUP_SEMANTICS) )
    {
        CreateFlags |= FILE_NON_DIRECTORY_FILE;
    }
    else
    {
        //
        // Backup intent was specified... Now look to see if we are to allow
        // directory creation
        //

        if ( (dwFlagsAndAttributes & FILE_ATTRIBUTE_DIRECTORY  ) &&
             (dwFlagsAndAttributes & FILE_FLAG_POSIX_SEMANTICS ) &&
             (CreateDisposition == FILE_CREATE) )
        {
            CreateFlags |= FILE_DIRECTORY_FILE;
        }
    }

    Status = NtCreateFile(&Handle,
                          (ACCESS_MASK)dwDesiredAccess | SYNCHRONIZE | FILE_READ_ATTRIBUTES,
                          &Obja,
                          &IoStatusBlock,
                          NULL,
                          dwFlagsAndAttributes & (FILE_ATTRIBUTE_VALID_FLAGS & ~FILE_ATTRIBUTE_DIRECTORY),
                          dwShareMode,
                          CreateDisposition,
                          CreateFlags,
                          NULL,
                          0
                          );

    if (FreeBuffer != NULL)
    {
        RtlFreeHeap(RtlProcessHeap(), 0,FreeBuffer);
    }

    if ( !NT_SUCCESS(Status) )
    {
        BaseSetLastNTError(Status);
        if ( Status == STATUS_OBJECT_NAME_COLLISION )
        {
            SetLastError(ERROR_FILE_EXISTS);
        }
        else if ( Status == STATUS_FILE_IS_A_DIRECTORY )
        {
            SetLastError(ERROR_ACCESS_DENIED);
        }
        return INVALID_HANDLE_VALUE;
    }

    //
    // if NT returns supersede/overwritten, it means that a create_always, openalways
    // found an existing copy of the file. In this case ERROR_ALREADY_EXISTS is returned
    //

    if ( (dwCreationDisposition == CREATE_ALWAYS && IoStatusBlock.Information ==
          FILE_OVERWRITTEN) ||
         (dwCreationDisposition == OPEN_ALWAYS && IoStatusBlock.Information == FILE_OPENED) )
    {
        SetLastError(ERROR_ALREADY_EXISTS);
    }
    else
    {
        SetLastError(0);
    }

    //
    // Truncate the file if required
    //

    if ( dwCreationDisposition == TRUNCATE_EXISTING)
    {
        AllocationInfo.AllocationSize.QuadPart = 0;
        Status = NtSetInformationFile(Handle,
                                      &IoStatusBlock,
                                      &AllocationInfo,
                                      sizeof(AllocationInfo),
                                      FileAllocationInformation
                                      );
        if ( !NT_SUCCESS(Status) )
        {
            BaseSetLastNTError(Status);
            NtClose(Handle);
            Handle = INVALID_HANDLE_VALUE;
        }
    }

    return Handle;
}

HANDLE
WINAPI
NtNativeCreateFileA(
    LPCSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile,
    BOOL TranslatePath
    )
{
    NTSTATUS Status;
    ANSI_STRING AnsiFile;
    UNICODE_STRING WideFile;

    RtlInitAnsiString(&AnsiFile, lpFileName);
    Status = RtlAnsiStringToUnicodeString(&WideFile, &AnsiFile, TRUE);
    if (!NT_SUCCESS(Status))
    {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    HANDLE File;

    File = NtNativeCreateFileW(WideFile.Buffer, dwDesiredAccess, dwShareMode,
                               lpSecurityAttributes, dwCreationDisposition,
                               dwFlagsAndAttributes, hTemplateFile,
                               TranslatePath);

    RtlFreeUnicodeString(&WideFile);
    return File;
}

HANDLE
WINAPI
CreateFileA(
    LPCSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile
    )
{
    return NtNativeCreateFileA(lpFileName, dwDesiredAccess, dwShareMode,
                               lpSecurityAttributes, dwCreationDisposition,
                               dwFlagsAndAttributes, hTemplateFile,
                               TRUE);
}

BOOL
WINAPI
DeviceIoControl(
    HANDLE hDevice,
    DWORD dwIoControlCode,
    LPVOID lpInBuffer,
    DWORD nInBufferSize,
    LPVOID lpOutBuffer,
    DWORD nOutBufferSize,
    LPDWORD lpBytesReturned,
    LPOVERLAPPED lpOverlapped
    )
{
    if ((dwIoControlCode >> 16) == FILE_DEVICE_FILE_SYSTEM ||
        lpOverlapped != NULL)
    {
        return FALSE;
    }

    IO_STATUS_BLOCK Iosb;
    NTSTATUS Status;

    Status = NtDeviceIoControlFile(hDevice,
                                   NULL,
                                   NULL,             // APC routine
                                   NULL,             // APC Context
                                   &Iosb,
                                   dwIoControlCode,  // IoControlCode
                                   lpInBuffer,       // Buffer for data to the FS
                                   nInBufferSize,
                                   lpOutBuffer,      // OutputBuffer for data from the FS
                                   nOutBufferSize    // OutputBuffer Length
                                   );

    if ( Status == STATUS_PENDING)
    {
        // Operation must complete before return & Iosb destroyed
        Status = NtWaitForSingleObject( hDevice, FALSE, NULL );
        if ( NT_SUCCESS(Status))
        {
            Status = Iosb.Status;
        }
    }

    if ( NT_SUCCESS(Status) )
    {
        *lpBytesReturned = (DWORD)Iosb.Information;
        return TRUE;
    }
    else
    {
        // handle warning value STATUS_BUFFER_OVERFLOW somewhat correctly
        if ( !NT_ERROR(Status) )
        {
            *lpBytesReturned = (DWORD)Iosb.Information;
        }
        BaseSetLastNTError(Status);
        return FALSE;
    }
}

BOOL
WINAPI
ReadFile(
    HANDLE hFile,
    LPVOID lpBuffer,
    DWORD nNumberOfBytesToRead,
    LPDWORD lpNumberOfBytesRead,
    LPOVERLAPPED lpOverlapped
    )
{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;

    if ( ARGUMENT_PRESENT(lpNumberOfBytesRead) )
    {
        *lpNumberOfBytesRead = 0;
    }

    if ( ARGUMENT_PRESENT( lpOverlapped ) )
    {
        LARGE_INTEGER Li;

        lpOverlapped->Internal = (DWORD)STATUS_PENDING;
        Li.LowPart = lpOverlapped->Offset;
        Li.HighPart = lpOverlapped->OffsetHigh;
        Status = NtReadFile(
                hFile,
                lpOverlapped->hEvent,
                NULL,
                (ULONG_PTR)lpOverlapped->hEvent & 1 ? NULL : lpOverlapped,
                (PIO_STATUS_BLOCK)&lpOverlapped->Internal,
                lpBuffer,
                nNumberOfBytesToRead,
                &Li,
                NULL
                );

        if ( NT_SUCCESS(Status) && Status != STATUS_PENDING)
        {
            if ( ARGUMENT_PRESENT(lpNumberOfBytesRead) )
            {
                __try
                {
                    *lpNumberOfBytesRead = (DWORD)lpOverlapped->InternalHigh;
                }
                __except(EXCEPTION_EXECUTE_HANDLER)
                {
                    *lpNumberOfBytesRead = 0;
                }
            }
            return TRUE;
        }
        else if (Status == STATUS_END_OF_FILE)
        {
            if ( ARGUMENT_PRESENT(lpNumberOfBytesRead) )
            {
                *lpNumberOfBytesRead = 0;
            }
            BaseSetLastNTError(Status);
            return FALSE;
        }
        else
        {
            BaseSetLastNTError(Status);
            return FALSE;
        }
    }
    else
    {
        Status = NtReadFile(hFile,
                            NULL,
                            NULL,
                            NULL,
                            &IoStatusBlock,
                            lpBuffer,
                            nNumberOfBytesToRead,
                            NULL,
                            NULL
                        );

        if ( Status == STATUS_PENDING)
        {
            // Operation must complete before return & IoStatusBlock destroyed
            Status = NtWaitForSingleObject( hFile, FALSE, NULL );
            if ( NT_SUCCESS(Status))
            {
                Status = IoStatusBlock.Status;
            }
        }

        if ( NT_SUCCESS(Status) )
        {
            *lpNumberOfBytesRead = (DWORD)IoStatusBlock.Information;
            return TRUE;
        }
        else
        {
            if (Status == STATUS_END_OF_FILE)
            {
                *lpNumberOfBytesRead = 0;
                return TRUE;
            }
            else
            {
                if ( NT_WARNING(Status) )
                {
                    *lpNumberOfBytesRead = (DWORD)IoStatusBlock.Information;
                }
                BaseSetLastNTError(Status);
                return FALSE;
            }
        }
    }
}

BOOL
WINAPI
WriteFile(
    HANDLE hFile,
    LPCVOID lpBuffer,
    DWORD nNumberOfBytesToWrite,
    LPDWORD lpNumberOfBytesWritten,
    LPOVERLAPPED lpOverlapped
    )
{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;

    if ( ARGUMENT_PRESENT(lpNumberOfBytesWritten) )
    {
        *lpNumberOfBytesWritten = 0;
    }

    if ( ARGUMENT_PRESENT( lpOverlapped ) )
    {
        LARGE_INTEGER Li;

        lpOverlapped->Internal = (DWORD)STATUS_PENDING;
        Li.LowPart = lpOverlapped->Offset;
        Li.HighPart = lpOverlapped->OffsetHigh;
        Status = NtWriteFile(
                hFile,
                lpOverlapped->hEvent,
                NULL,
                (ULONG_PTR)lpOverlapped->hEvent & 1 ? NULL : lpOverlapped,
                (PIO_STATUS_BLOCK)&lpOverlapped->Internal,
                (PVOID)lpBuffer,
                nNumberOfBytesToWrite,
                &Li,
                NULL
                );

        if ( !NT_ERROR(Status) && Status != STATUS_PENDING)
        {
            if ( ARGUMENT_PRESENT(lpNumberOfBytesWritten) )
            {
                __try
                {
                    *lpNumberOfBytesWritten = (DWORD)lpOverlapped->InternalHigh;
                }
                __except(EXCEPTION_EXECUTE_HANDLER)
                {
                    *lpNumberOfBytesWritten = 0;
                }
            }
            return TRUE;
        }
        else
        {
            BaseSetLastNTError(Status);
            return FALSE;
        }
    }
    else
    {
        Status = NtWriteFile(hFile,
                             NULL,
                             NULL,
                             NULL,
                             &IoStatusBlock,
                             (PVOID)lpBuffer,
                             nNumberOfBytesToWrite,
                             NULL,
                             NULL
                             );

        if ( Status == STATUS_PENDING)
        {
            // Operation must complete before return & IoStatusBlock destroyed
            Status = NtWaitForSingleObject( hFile, FALSE, NULL );
            if ( NT_SUCCESS(Status))
            {
                Status = IoStatusBlock.Status;
            }
        }
        
        if ( NT_SUCCESS(Status))
        {
            *lpNumberOfBytesWritten = (DWORD)IoStatusBlock.Information;
            return TRUE;
        }
        else
        {
            if ( NT_WARNING(Status) )
            {
                *lpNumberOfBytesWritten = (DWORD)IoStatusBlock.Information;
            }
            BaseSetLastNTError(Status);
            return FALSE;
        }
    }
}

SIZE_T
WINAPI
VirtualQueryEx(
    HANDLE hProcess,
    LPCVOID lpAddress,
    PMEMORY_BASIC_INFORMATION lpBuffer,
    SIZE_T dwLength
    )
{
    NTSTATUS Status;
    SIZE_T ReturnLength;

    Status = NtQueryVirtualMemory( hProcess,
                                   (LPVOID)lpAddress,
                                   MemoryBasicInformation,
                                   (PMEMORY_BASIC_INFORMATION)lpBuffer,
                                   dwLength,
                                   &ReturnLength
                                 );
    if (NT_SUCCESS( Status ))
    {
        return( ReturnLength );
    }
    else
    {
        BaseSetLastNTError( Status );
        return( 0 );
    }
}

BOOL
WINAPI
VirtualProtectEx(
    HANDLE hProcess,
    PVOID lpAddress,
    SIZE_T dwSize,
    DWORD flNewProtect,
    PDWORD lpflOldProtect
    )
{
    NTSTATUS Status;

    Status = NtProtectVirtualMemory( hProcess,
                                     &lpAddress,
                                     &dwSize,
                                     flNewProtect,
                                     lpflOldProtect
                                   );

    if (NT_SUCCESS( Status )) {
        return( TRUE );
        }
    else {
        if (Status == STATUS_INVALID_PAGE_PROTECTION) {
            if (hProcess == NtCurrentProcess()) {

                //
                // Unlock any pages that were locked with MmSecureVirtualMemory.
                // This is useful for SANs.
                //

                if (RtlFlushSecureMemoryCache(lpAddress, dwSize)) {
                    Status = NtProtectVirtualMemory( hProcess,
                                                  &lpAddress,
                                                  &dwSize,
                                                  flNewProtect,
                                                  lpflOldProtect
                                                );

                    if (NT_SUCCESS( Status )) {
                        return( TRUE );
                        }
                    }
                }
            }
        BaseSetLastNTError( Status );
        return( FALSE );
        }
}

PVOID
WINAPI
VirtualAllocEx(
    HANDLE hProcess,
    PVOID lpAddress,
    SIZE_T dwSize,
    DWORD flAllocationType,
    DWORD flProtect
    )
{
    NTSTATUS Status;

    __try {
        Status = NtAllocateVirtualMemory( hProcess,
                                          &lpAddress,
                                          0,
                                          &dwSize,
                                          flAllocationType,
                                          flProtect
                                        );
        }
    __except( EXCEPTION_EXECUTE_HANDLER ) {
        Status = GetExceptionCode();
        }

    if (NT_SUCCESS( Status )) {
        return( lpAddress );
        }
    else {
        BaseSetLastNTError( Status );
        return( NULL );
        }
}

BOOL
WINAPI
VirtualFreeEx(
    HANDLE hProcess,
    LPVOID lpAddress,
    SIZE_T dwSize,
    DWORD dwFreeType
    )
{
    NTSTATUS Status;


    if ( (dwFreeType & MEM_RELEASE ) && dwSize != 0 ) {
        BaseSetLastNTError( STATUS_INVALID_PARAMETER );
        return FALSE;
        }

    Status = NtFreeVirtualMemory( hProcess,
                                  &lpAddress,
                                  &dwSize,
                                  dwFreeType
                                );

    if (NT_SUCCESS( Status )) {
        return( TRUE );
        }
    else {
        if (Status == STATUS_INVALID_PAGE_PROTECTION) {
            if (hProcess == NtCurrentProcess()) {

                //
                // Unlock any pages that were locked with MmSecureVirtualMemory.
                // This is useful for SANs.
                //

                if (RtlFlushSecureMemoryCache(lpAddress, dwSize)) {
                    Status = NtFreeVirtualMemory( hProcess,
                                                  &lpAddress,
                                                  &dwSize,
                                                  dwFreeType
                                                );

                    if (NT_SUCCESS( Status )) {
                        return( TRUE );
                        }
                    }
                }
            }

        BaseSetLastNTError( Status );
        return( FALSE );
        }
}

HANDLE
APIENTRY
CreateThread(
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    SIZE_T dwStackSize,
    LPTHREAD_START_ROUTINE lpStartAddress,
    LPVOID lpParameter,
    DWORD dwCreationFlags,
    LPDWORD lpThreadId
    )
{
    return CreateRemoteThread( NtCurrentProcess(),
                               lpThreadAttributes,
                               dwStackSize,
                               lpStartAddress,
                               lpParameter,
                               dwCreationFlags,
                               lpThreadId
                               );
}

HANDLE
APIENTRY
CreateRemoteThread(
    HANDLE hProcess,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    SIZE_T dwStackSize,
    LPTHREAD_START_ROUTINE lpStartAddress,
    LPVOID lpParameter,
    DWORD dwCreationFlags,
    LPDWORD lpThreadId
    )
{
    NTSTATUS Status;
    HANDLE Handle;
    CLIENT_ID ClientId;

    Handle = NULL;
    
    //
    // Allocate a stack for this thread in the address space of the target
    // process.
    //
    if ((dwCreationFlags & STACK_SIZE_PARAM_IS_A_RESERVATION) ||
        dwStackSize != 0 || lpThreadAttributes != NULL)
    {
        return NULL;
    }

    Status = RtlCreateUserThread (hProcess,
                                  NULL,
                                  (dwCreationFlags & CREATE_SUSPENDED) ?
                                  TRUE : FALSE,
                                  0,
                                  0,
                                  0,
                                  (PUSER_THREAD_START_ROUTINE)lpStartAddress,
                                  lpParameter,
                                  &Handle,
                                  &ClientId);

    if ( ARGUMENT_PRESENT(lpThreadId) )
    {
        *lpThreadId = HandleToUlong(ClientId.UniqueThread);
    }

    return Handle;
}

#define DOS_LOCAL_PIPE_PREFIX   L"\\\\.\\pipe\\"
#define DOS_LOCAL_PIPE          L"\\DosDevices\\pipe\\"
#define DOS_REMOTE_PIPE         L"\\DosDevices\\UNC\\"

#define INVALID_PIPE_MODE_BITS  ~(PIPE_READMODE_BYTE    \
                                | PIPE_READMODE_MESSAGE \
                                | PIPE_WAIT             \
                                | PIPE_NOWAIT)

HANDLE
APIENTRY
NtNativeCreateNamedPipeW(
    LPCWSTR lpName,
    DWORD dwOpenMode,
    DWORD dwPipeMode,
    DWORD nMaxInstances,
    DWORD nOutBufferSize,
    DWORD nInBufferSize,
    DWORD nDefaultTimeOut,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    BOOL TranslatePath
    )

/*++


Parameters:

    lpName --Supplies the pipe name Documented in "Pipe Names" section
        earlier.  This must be a local name.

    dwOpenMode --Supplies the set of flags that define the mode which the
        pipe is to be opened with.  The open mode consists of access
        flags (one of three values) logically ORed with a writethrough
        flag (one of two values) and an overlapped flag (one of two
        values), as described below.

        dwOpenMode Flags:

        PIPE_ACCESS_DUPLEX --Pipe is bidirectional.  (This is
            semantically equivalent to calling CreateFile with access
            flags of GENERIC_READ | GENERIC_WRITE.)

        PIPE_ACCESS_INBOUND --Data goes from client to server only.
            (This is semantically equivalent to calling CreateFile with
            access flags of GENERIC_READ.)

        PIPE_ACCESS_OUTBOUND --Data goes from server to client only.
            (This is semantically equivalent to calling CreateFile with
            access flags of GENERIC_WRITE.)

        PIPE_WRITETHROUGH --The redirector is not permitted to delay the
            transmission of data to the named pipe buffer on the remote
            server. This disables a performance enhancement for
            applications that need synchronization with every write
            operation.

        FILE_FLAG_OVERLAPPED --Indicates that the system should
            initialize the file so that ReadFile, WriteFile and other
            operations that may take a significant time to process will
            return ERROR_IO_PENDING. An event will be set to the
            signalled state when the operation completes.

        FILE_FLAG_WRITETHROUGH -- No intermediate buffering.

        WRITE_DAC --            Standard security desired access
        WRITE_OWNER --          ditto
        ACCESS_SYSTEM_SECURITY -- ditto

    dwPipeMode --Supplies the pipe-specific modes (as flags) of the pipe.
        This parameter is a combination of a read-mode flag, a type flag,
        and a wait flag.

        dwPipeMode Flags:

        PIPE_WAIT --Blocking mode is to be used for this handle.

        PIPE_NOWAIT --Nonblocking mode is to be used for this handle.

        PIPE_READMODE_BYTE --Read pipe as a byte stream.

        PIPE_READMODE_MESSAGE --Read pipe as a message stream.  Note that
            this is not allowed with PIPE_TYPE_BYTE.

        PIPE_TYPE_BYTE --Pipe is a byte-stream pipe.  Note that this is
            not allowed with PIPE_READMODE_MESSAGE.

        PIPE_TYPE_MESSAGE --Pipe is a message-stream pipe.

    nMaxInstances --Gives the maximum number of instances for this pipe.
        Acceptable values are 1 to PIPE_UNLIMITED_INSTANCES-1 and
        PIPE_UNLIMITED_INSTANCES.

        nMaxInstances Special Values:

        PIPE_UNLIMITED_INSTANCES --Unlimited instances of this pipe can
            be created.

    nOutBufferSize --Specifies an advisory on the number of bytes to
        reserve for the outgoing buffer.

    nInBufferSize --Specifies an advisory on the number of bytes to
        reserve for the incoming buffer.

    nDefaultTimeOut -- Specifies an optional pointer to a timeout value
        that is to be used if a timeout value is not specified when
        waiting for an instance of a named pipe. This parameter is only
        meaningful when the first instance of a named pipe is created. If
        neither CreateNamedPipe or WaitNamedPipe specify a timeout 50
        milliseconds will be used.

    lpSecurityAttributes --An optional parameter that, if present and
        supported on the target system, supplies a security descriptor
        for the named pipe.  This parameter includes an inheritance flag
        for the handle.  If this parameter is not present, the handle is
        not inherited by child processes.

Return Value:

    Returns one of the following:

    INVALID_HANDLE_VALUE --An error occurred.  Call GetLastError for more
    information.

    Anything else --Returns a handle for use in the server side of
    subsequent named pipe operations.

--*/
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    UNICODE_STRING FileName;
    IO_STATUS_BLOCK IoStatusBlock;
    BOOLEAN TranslationStatus;
    LARGE_INTEGER Timeout;
    RTL_RELATIVE_NAME RelativeName;
    PVOID FreeBuffer;
    ULONG CreateFlags;
    ULONG DesiredAccess;
    ULONG ShareAccess;
    ULONG MaxInstances;
    SECURITY_DESCRIPTOR SecurityDescriptor;
    PACL DefaultAcl = NULL;

    if ((nMaxInstances == 0) ||
        (nMaxInstances > PIPE_UNLIMITED_INSTANCES)) {
        BaseSetLastNTError(STATUS_INVALID_PARAMETER);
        return INVALID_HANDLE_VALUE;
        }

    // Convert Win32 maximum Instances to Nt maximum instances.
    MaxInstances = (nMaxInstances == PIPE_UNLIMITED_INSTANCES)?
        0xffffffff : nMaxInstances;

    if (TranslatePath)
    {
        TranslationStatus = RtlDosPathNameToNtPathName_U(
                                                         lpName,
                                                         &FileName,
                                                         NULL,
                                                         &RelativeName
                                                         );

        if ( !TranslationStatus ) {
            SetLastError(ERROR_PATH_NOT_FOUND);
            return INVALID_HANDLE_VALUE;
        }

        FreeBuffer = FileName.Buffer;

        if ( RelativeName.RelativeName.Length ) {
            FileName = *(PUNICODE_STRING)&RelativeName.RelativeName;
        }
        else {
            RelativeName.ContainingDirectory = NULL;
        }
    }
    else
    {
        RtlInitUnicodeString(&FileName, lpName);
        FreeBuffer = NULL;
        RelativeName.ContainingDirectory = NULL;
    }        

    InitializeObjectAttributes(
        &Obja,
        &FileName,
        OBJ_CASE_INSENSITIVE,
        RelativeName.ContainingDirectory,
        NULL
        );

    if ( ARGUMENT_PRESENT(lpSecurityAttributes) ) {
        Obja.SecurityDescriptor = lpSecurityAttributes->lpSecurityDescriptor;
        if ( lpSecurityAttributes->bInheritHandle ) {
            Obja.Attributes |= OBJ_INHERIT;
            }
        }

    if (Obja.SecurityDescriptor == NULL) {

        //
        // Apply default security if none specified (bug 131090)
        //

        Status = RtlDefaultNpAcl( &DefaultAcl );
        if (NT_SUCCESS( Status )) {
            RtlCreateSecurityDescriptor( &SecurityDescriptor, SECURITY_DESCRIPTOR_REVISION );
            RtlSetDaclSecurityDescriptor( &SecurityDescriptor, TRUE, DefaultAcl, FALSE );
            Obja.SecurityDescriptor = &SecurityDescriptor;
        } else {
            if (FreeBuffer != NULL)
            {
                RtlFreeHeap(RtlProcessHeap(),0,FreeBuffer);
            }
            BaseSetLastNTError(Status);
            return INVALID_HANDLE_VALUE;
        }
    }

    //  End of code common with fileopcr.c CreateFile()

    CreateFlags = (dwOpenMode & FILE_FLAG_WRITE_THROUGH ? FILE_WRITE_THROUGH : 0 );
    CreateFlags |= (dwOpenMode & FILE_FLAG_OVERLAPPED ? 0 : FILE_SYNCHRONOUS_IO_NONALERT);

    //
    //  Determine the timeout. Convert from milliseconds to an Nt delta time
    //

    if ( nDefaultTimeOut ) {
        Timeout.QuadPart = - (LONGLONG)UInt32x32To64( 10 * 1000, nDefaultTimeOut );
        }
    else {
        //  Default timeout is 50 Milliseconds
        Timeout.QuadPart =  -10 * 1000 * 50;
        }

    //  Check no reserved bits are set by mistake.

    if (( dwOpenMode & ~(PIPE_ACCESS_DUPLEX |
                         FILE_FLAG_OVERLAPPED | FILE_FLAG_WRITE_THROUGH |
                         FILE_FLAG_FIRST_PIPE_INSTANCE | WRITE_DAC |
                         WRITE_OWNER | ACCESS_SYSTEM_SECURITY ))||

        ( dwPipeMode & ~(PIPE_NOWAIT | PIPE_READMODE_MESSAGE |
                         PIPE_TYPE_MESSAGE ))) {

            if (FreeBuffer != NULL)
            {
                RtlFreeHeap(RtlProcessHeap(),0,FreeBuffer);
            }
            if (DefaultAcl != NULL) {
                RtlFreeHeap(RtlProcessHeap(),0,DefaultAcl);
            }
            BaseSetLastNTError(STATUS_INVALID_PARAMETER);
            return INVALID_HANDLE_VALUE;
        }

    //
    //  Translate the open mode into a sharemode to restrict the clients access
    //  and derive the appropriate local desired access.
    //

    switch ( dwOpenMode & PIPE_ACCESS_DUPLEX ) {
        case PIPE_ACCESS_INBOUND:
            ShareAccess = FILE_SHARE_WRITE;
            DesiredAccess = GENERIC_READ;
            break;

        case PIPE_ACCESS_OUTBOUND:
            ShareAccess = FILE_SHARE_READ;
            DesiredAccess = GENERIC_WRITE;
            break;

        case PIPE_ACCESS_DUPLEX:
            ShareAccess = FILE_SHARE_READ | FILE_SHARE_WRITE;
            DesiredAccess = GENERIC_READ | GENERIC_WRITE;
            break;

        default:
            if (FreeBuffer != NULL)
            {
                RtlFreeHeap(RtlProcessHeap(),0,FreeBuffer);
            }
            if (DefaultAcl != NULL) {
                RtlFreeHeap(RtlProcessHeap(),0,DefaultAcl);
            }
            BaseSetLastNTError(STATUS_INVALID_PARAMETER);
            return INVALID_HANDLE_VALUE;
        }

    DesiredAccess |= SYNCHRONIZE |
         ( dwOpenMode & (WRITE_DAC | WRITE_OWNER | ACCESS_SYSTEM_SECURITY ));

    Status = NtCreateNamedPipeFile (
        &Handle,
        DesiredAccess,
        &Obja,
        &IoStatusBlock,
        ShareAccess,
        (dwOpenMode & FILE_FLAG_FIRST_PIPE_INSTANCE) ?
            FILE_CREATE : FILE_OPEN_IF, // Create first instance or subsequent
        CreateFlags,                    // Create Options
        dwPipeMode & PIPE_TYPE_MESSAGE ?
            FILE_PIPE_MESSAGE_TYPE : FILE_PIPE_BYTE_STREAM_TYPE,
        dwPipeMode & PIPE_READMODE_MESSAGE ?
            FILE_PIPE_MESSAGE_MODE : FILE_PIPE_BYTE_STREAM_MODE,
        dwPipeMode & PIPE_NOWAIT ?
            FILE_PIPE_COMPLETE_OPERATION : FILE_PIPE_QUEUE_OPERATION,
        MaxInstances,                   // Max instances
        nInBufferSize,                  // Inbound quota
        nOutBufferSize,                 // Outbound quota
        (PLARGE_INTEGER)&Timeout
        );

    if ( Status == STATUS_NOT_SUPPORTED ||
         Status == STATUS_INVALID_DEVICE_REQUEST ) {

        //
        // The request must have been processed by some other device driver
        // (other than NPFS).  Map the error to something reasonable.
        //

        Status = STATUS_OBJECT_NAME_INVALID;
    }

    if (FreeBuffer != NULL)
    {
        RtlFreeHeap(RtlProcessHeap(),0,FreeBuffer);
    }
    if (DefaultAcl != NULL) {
        RtlFreeHeap(RtlProcessHeap(),0,DefaultAcl);
    }
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return INVALID_HANDLE_VALUE;
        }

    return Handle;
}

HANDLE
APIENTRY
NtNativeCreateNamedPipeA(
    LPCSTR lpName,
    DWORD dwOpenMode,
    DWORD dwPipeMode,
    DWORD nMaxInstances,
    DWORD nOutBufferSize,
    DWORD nInBufferSize,
    DWORD nDefaultTimeOut,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    BOOL TranslatePath
    )

/*++
    Ansi thunk to CreateNamedPipeW.

--*/
{
    NTSTATUS Status;
    PUNICODE_STRING Unicode;
    ANSI_STRING AnsiString;

    Unicode = &NtCurrentTeb()->StaticUnicodeString;
    RtlInitAnsiString(&AnsiString,lpName);
    Status = RtlAnsiStringToUnicodeString(Unicode,&AnsiString,FALSE);
    if ( !NT_SUCCESS(Status) ) {
        if ( Status == STATUS_BUFFER_OVERFLOW ) {
            SetLastError(ERROR_FILENAME_EXCED_RANGE);
            }
        else {
            BaseSetLastNTError(Status);
            }
        return INVALID_HANDLE_VALUE;
        }

    return NtNativeCreateNamedPipeW(
            (LPCWSTR)Unicode->Buffer,
            dwOpenMode,
            dwPipeMode,
            nMaxInstances,
            nOutBufferSize,
            nInBufferSize,
            nDefaultTimeOut,
            lpSecurityAttributes,
            TranslatePath);
}

BOOL
APIENTRY
ConnectNamedPipe(
    HANDLE hNamedPipe,
    LPOVERLAPPED lpOverlapped
    )

/*++

Routine Description:

    The ConnectNamedPipe function is used by the server side of a named pipe
    to wait for a client to connect to the named pipe with a CreateFile
    request. The handle provided with the call to ConnectNamedPipe must have
    been previously returned by a successful call to CreateNamedPipe. The pipe
    must be in the disconnected, listening or connected states for
    ConnectNamedPipe to succeed.

    The behavior of this call depends on the blocking/nonblocking mode selected
    with the PIPE_WAIT/PIPE_NOWAIT flags when the server end of the pipe was
    created with CreateNamedPipe.

    If blocking mode is specified, ConnectNamedPipe will change the state from
    disconnected to listening and block. When a client connects with a
    CreateFile, the state will be changed from listening to connected and the
    ConnectNamedPipe returns TRUE. When the file handle is created with
    FILE_FLAG_OVERLAPPED on a blocking mode pipe, the lpOverlapped parameter
    can be specified. This allows the caller to continue processing while the
    ConnectNamedPipe API awaits a connection. When the pipe enters the
    signalled state the event is set to the signalled state.

    When nonblocking is specified ConnectNamedPipe will not block. On the
    first call the state will change from disconnected to listening. When a
    client connects with an Open the state will be changed from listening to
    connected. The ConnectNamedPipe will return FALSE (with GetLastError
    returning ERROR_PIPE_LISTENING) until the state is changed to the listening
    state.

Arguments:

    hNamedPipe - Supplies a Handle to the server side of a named pipe.

    lpOverlapped - Supplies an overlap structure to be used with the request.
        If NULL then the API will not return until the operation completes. When
        FILE_FLAG_OVERLAPPED is specified when the handle was created,
        ConnectNamedPipe may return ERROR_IO_PENDING to allow the caller to
        continue processing while the operation completes. The event (or File
        handle if hEvent=NULL) will be set to the not signalled state before
        ERROR_IO_PENDING is returned. The event will be set to the signalled
        state upon completion of the request. GetOverlappedResult is used to
        determine the error status.

Return Value:

    TRUE -- The operation was successful, the pipe is in the
        connected state.

    FALSE -- The operation failed. Extended error status is available using
        GetLastError.

--*/
{
    NTSTATUS Status;
    IO_STATUS_BLOCK Iosb;

    if ( lpOverlapped ) {
        lpOverlapped->Internal = (DWORD)STATUS_PENDING;
        }
    Status = NtFsControlFile(
                hNamedPipe,
                (lpOverlapped==NULL)? NULL : lpOverlapped->hEvent,
                NULL,   // ApcRoutine
                lpOverlapped ? ((ULONG_PTR)lpOverlapped->hEvent & 1 ? NULL : lpOverlapped) : NULL,
                (lpOverlapped==NULL) ? &Iosb : (PIO_STATUS_BLOCK)&lpOverlapped->Internal,
                FSCTL_PIPE_LISTEN,
                NULL,   // InputBuffer
                0,      // InputBufferLength,
                NULL,   // OutputBuffer
                0       // OutputBufferLength
                );

    if ( lpOverlapped == NULL && Status == STATUS_PENDING) {
        // Operation must complete before return & Iosb destroyed
        Status = NtWaitForSingleObject( hNamedPipe, FALSE, NULL );
        if ( NT_SUCCESS(Status)) {
            Status = Iosb.Status;
            }
        }

    if (NT_SUCCESS( Status ) && Status != STATUS_PENDING ) {
        return TRUE;
        }
    else
        {
        BaseSetLastNTError(Status);
        return FALSE;
        }
}

BOOL
APIENTRY
WaitNamedPipeA(
    LPCSTR lpNamedPipeName,
    DWORD nTimeOut
    )
/*++

    Ansi thunk to WaitNamedPipeW

--*/
{
    ANSI_STRING Ansi;
    UNICODE_STRING UnicodeString;
    BOOL b;

    RtlInitAnsiString(&Ansi, lpNamedPipeName);
    if (!NT_SUCCESS(RtlAnsiStringToUnicodeString(&UnicodeString, &Ansi, TRUE))) {
        return FALSE;
    }

    b = WaitNamedPipeW( UnicodeString.Buffer, nTimeOut );

    RtlFreeUnicodeString(&UnicodeString);

    return b;

}

BOOL
APIENTRY
WaitNamedPipeW(
    LPCWSTR lpNamedPipeName,
    DWORD nTimeOut
    )
/*++

Routine Description:

    The WaitNamedPipe function waits for a named pipe to become available.

Arguments:

    lpNamedPipeName - Supplies the name of the named pipe.

    nTimeOut - Gives a value (in milliseconds) that is the amount of time
        this function should wait for the pipe to become available. (Note
        that the function may take longer than that to execute, due to
        various factors.)

    nTimeOut Special Values:

        NMPWAIT_WAIT_FOREVER
            No timeout.

        NMPWAIT_USE_DEFAULT_WAIT
            Use default timeout set in call to CreateNamedPipe.

Return Value:

    TRUE -- The operation was successful.

    FALSE -- The operation failed. Extended error status is available using
        GetLastError.

--*/
{

    IO_STATUS_BLOCK Iosb;
    OBJECT_ATTRIBUTES Obja;
    NTSTATUS Status;
    RTL_PATH_TYPE PathType;
    ULONG WaitPipeLength;
    PFILE_PIPE_WAIT_FOR_BUFFER WaitPipe;
    PWSTR FreeBuffer;
    UNICODE_STRING FileSystem;
    UNICODE_STRING PipeName;
    UNICODE_STRING OriginalPipeName;
    UNICODE_STRING ValidUnicodePrefix;
    HANDLE Handle;
    IO_STATUS_BLOCK IoStatusBlock;
    LPWSTR Pwc;
    ULONG Index;

    //
    //  Open a handle either to the redirector or the NPFS depending on
    //  the start of the pipe name. Split lpNamedPipeName into two
    //  halves as follows:
    //      \\.\pipe\pipename       \\.\pipe\ and pipename
    //      \\server\pipe\pipename  \\ and server\pipe\pipename
    //

    if (!RtlCreateUnicodeString( &OriginalPipeName, lpNamedPipeName)) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
        }

    //
    //  Change all the forward slashes into backward slashes.
    //

    for ( Index =0; Index < (OriginalPipeName.Length/sizeof(WCHAR)); Index++ ) {
        if (OriginalPipeName.Buffer[Index] == L'/') {
            OriginalPipeName.Buffer[Index] = L'\\';
            }
        }

    PipeName = OriginalPipeName;

    PathType = RtlDetermineDosPathNameType_U(lpNamedPipeName);

    FreeBuffer = NULL;

    switch ( PathType ) {
    case RtlPathTypeLocalDevice:

            //  Name should be of the form \\.\pipe\pipename (IgnoreCase)

            RtlInitUnicodeString( &ValidUnicodePrefix, DOS_LOCAL_PIPE_PREFIX);

            if (RtlPrefixString((PSTRING)&ValidUnicodePrefix,
                    (PSTRING)&PipeName,
                    TRUE) == FALSE) {
                RtlFreeUnicodeString(&OriginalPipeName);
                BaseSetLastNTError(STATUS_OBJECT_PATH_SYNTAX_BAD);
                return FALSE;
                }

            //  Skip first 9 characters "\\.\pipe\"
            PipeName.Buffer+=9;
            PipeName.Length-=9*sizeof(WCHAR);

            RtlInitUnicodeString( &FileSystem, DOS_LOCAL_PIPE);

            break;

        case RtlPathTypeUncAbsolute:
            //  Name is of the form \\server\pipe\pipename

            //  Find the pipe name.

            for ( Pwc = &PipeName.Buffer[2]; *Pwc != 0; Pwc++) {
                if ( *Pwc == L'\\') {
                    //  Found backslash after servername
                    break;
                    }
                }

            if ( (*Pwc != 0) &&
                 ( _wcsnicmp( Pwc + 1, L"pipe\\", 5 ) == 0 ) ) {

                // Temporarily, break this up into 2 strings
                //    string1 = \\server\pipe
                //    string2 = the-rest

                Pwc += (sizeof (L"pipe\\") / sizeof( WCHAR ) ) - 1;

            } else {

                // This is not a valid remote path name.

                RtlFreeUnicodeString(&OriginalPipeName);
                BaseSetLastNTError(STATUS_OBJECT_PATH_SYNTAX_BAD);
                return FALSE;
                }

            //  Pwc now points to the first path seperator after \\server\pipe.
            //  Attempt to open \DosDevices\Unc\Servername\Pipe.

            PipeName.Buffer = &PipeName.Buffer[2];
            PipeName.Length = (USHORT)((PCHAR)Pwc - (PCHAR)PipeName.Buffer);
            PipeName.MaximumLength = PipeName.Length;

            FileSystem.MaximumLength =
                (USHORT)sizeof( DOS_REMOTE_PIPE ) +
                PipeName.MaximumLength;

            FileSystem.Buffer = (PWSTR)RtlAllocateHeap(
                                    RtlProcessHeap(), 0,
                                    FileSystem.MaximumLength
                                    );

            if ( !FileSystem.Buffer ) {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                RtlFreeUnicodeString(&OriginalPipeName);
                return FALSE;
                }
            FreeBuffer = FileSystem.Buffer;

            RtlCopyMemory(
                FileSystem.Buffer,
                DOS_REMOTE_PIPE,
                sizeof( DOS_REMOTE_PIPE ) - sizeof(WCHAR)
                );

            FileSystem.Length = sizeof( DOS_REMOTE_PIPE ) - sizeof(WCHAR);

            RtlAppendUnicodeStringToString( &FileSystem, &PipeName );

            // Set up pipe name, skip leading backslashes.

            RtlInitUnicodeString( &PipeName, (PWCH)Pwc + 1 );

            break;

        default:
            BaseSetLastNTError(STATUS_OBJECT_PATH_SYNTAX_BAD);
            RtlFreeUnicodeString(&OriginalPipeName);
            return FALSE;
        }


    InitializeObjectAttributes(
        &Obja,
        &FileSystem,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = NtOpenFile(
                &Handle,
                (ACCESS_MASK)FILE_READ_ATTRIBUTES | SYNCHRONIZE,
                &Obja,
                &IoStatusBlock,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_SYNCHRONOUS_IO_NONALERT
                );

    if (FreeBuffer != NULL) {
        RtlFreeHeap(RtlProcessHeap(),0,FreeBuffer);
        }

    if ( !NT_SUCCESS(Status) ) {
        RtlFreeUnicodeString(&OriginalPipeName);
        BaseSetLastNTError(Status);
        return FALSE;
        }

    WaitPipeLength =
        FIELD_OFFSET(FILE_PIPE_WAIT_FOR_BUFFER, Name[0]) + PipeName.Length;
    WaitPipe = (PFILE_PIPE_WAIT_FOR_BUFFER)
        RtlAllocateHeap(RtlProcessHeap(), 0, WaitPipeLength);
    if ( !WaitPipe ) {
        RtlFreeUnicodeString(&OriginalPipeName);
        NtClose(Handle);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);

        return FALSE;
        }

    if ( nTimeOut == NMPWAIT_USE_DEFAULT_WAIT ) {
        WaitPipe->TimeoutSpecified = FALSE;
        }
    else {
        if ( nTimeOut == NMPWAIT_WAIT_FOREVER ) {
            WaitPipe->Timeout.LowPart = 0;
            WaitPipe->Timeout.HighPart =0x80000000;
            }
        else {
            //
            //  Convert from milliseconds to an Nt delta time.
            //

            WaitPipe->Timeout.QuadPart =
                                - (LONGLONG)UInt32x32To64( 10 * 1000, nTimeOut );
            }
        WaitPipe->TimeoutSpecified = TRUE;
        }

    WaitPipe->NameLength = PipeName.Length;

    RtlCopyMemory(
        WaitPipe->Name,
        PipeName.Buffer,
        PipeName.Length
        );

    RtlFreeUnicodeString(&OriginalPipeName);

    Status = NtFsControlFile(Handle,
                        NULL,
                        NULL,           // APC routine
                        NULL,           // APC Context
                        &Iosb,
                        FSCTL_PIPE_WAIT,// IoControlCode
                        WaitPipe,       // Buffer for data to the FS
                        WaitPipeLength,
                        NULL,           // OutputBuffer for data from the FS
                        0               // OutputBuffer Length
                        );

    RtlFreeHeap(RtlProcessHeap(),0,WaitPipe);

    NtClose(Handle);

    if (NT_SUCCESS( Status ) ) {
        return TRUE;
        }
    else
        {
        BaseSetLastNTError(Status);
        return FALSE;
        }
}

DWORD
WaitForSingleObject(
    HANDLE hHandle,
    DWORD dwMilliseconds
    )

/*++

Routine Description:

    A wait operation on a waitable object is accomplished with the
    WaitForSingleObject function.

    Waiting on an object checks the current state of the object.  If the
    current state of the object allows continued execution, any
    adjustments to the object state are made (for example, decrementing
    the semaphore count for a semaphore object) and the thread continues
    execution.  If the current state of the object does not allow
    continued execution, the thread is placed into the wait state
    pending the change of the object's state or time-out.

Arguments:

    hHandle - An open handle to a waitable object. The handle must have
        SYNCHRONIZE access to the object.

    dwMilliseconds - A time-out value that specifies the relative time,
        in milliseconds, over which the wait is to be completed.  A
        timeout value of 0 specified that the wait is to timeout
        immediately.  This allows an application to test an object to
        determine if it is in the signaled state.  A timeout value of -1
        specifies an infinite timeout period.

Return Value:

    WAIT_TIME_OUT - Indicates that the wait was terminated due to the
        TimeOut conditions.

    0 - indicates the specified object attained a Signaled
        state thus completing the wait.

    WAIT_ABANDONED - indicates the specified object attained a Signaled
        state but was abandoned.

--*/

{
    return WaitForSingleObjectEx(hHandle,dwMilliseconds,FALSE);
}

DWORD
APIENTRY
WaitForSingleObjectEx(
    HANDLE hHandle,
    DWORD dwMilliseconds,
    BOOL bAlertable
    )

/*++

Routine Description:

    A wait operation on a waitable object is accomplished with the
    WaitForSingleObjectEx function.

    Waiting on an object checks the current state of the object.  If the
    current state of the object allows continued execution, any
    adjustments to the object state are made (for example, decrementing
    the semaphore count for a semaphore object) and the thread continues
    execution.  If the current state of the object does not allow
    continued execution, the thread is placed into the wait state
    pending the change of the object's state or time-out.

    If the bAlertable parameter is FALSE, the only way the wait
    terminates is because the specified timeout period expires, or
    because the specified object entered the signaled state.  If the
    bAlertable parameter is TRUE, then the wait can return due to any
    one of the above wait termination conditions, or because an I/O
    completion callback terminated the wait early (return value of
    WAIT_IO_COMPLETION).

Arguments:

    hHandle - An open handle to a waitable object. The handle must have
        SYNCHRONIZE access to the object.

    dwMilliseconds - A time-out value that specifies the relative time,
        in milliseconds, over which the wait is to be completed.  A
        timeout value of 0 specified that the wait is to timeout
        immediately.  This allows an application to test an object to
        determine if it is in the signaled state.  A timeout value of
        0xffffffff specifies an infinite timeout period.

    bAlertable - Supplies a flag that controls whether or not the
        wait may terminate early due to an I/O completion callback.
        A value of TRUE allows this API to complete early due to an I/O
        completion callback.  A value of FALSE will not allow I/O
        completion callbacks to terminate this call early.

Return Value:

    WAIT_TIME_OUT - Indicates that the wait was terminated due to the
        TimeOut conditions.

    0 - indicates the specified object attained a Signaled
        state thus completing the wait.

    0xffffffff - The wait terminated due to an error. GetLastError may be
        used to get additional error information.

    WAIT_ABANDONED - indicates the specified object attained a Signaled
        state but was abandoned.

    WAIT_IO_COMPLETION - The wait terminated due to one or more I/O
        completion callbacks.

--*/
{
    NTSTATUS Status;
    LARGE_INTEGER TimeOut;
    PLARGE_INTEGER pTimeOut;
    PPEB Peb;
    RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME Frame = { sizeof(Frame), RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME_FORMAT_WHISTLER };

    RtlActivateActivationContextUnsafeFast(&Frame, NULL); // make the process default activation context active so that APCs are delivered under it
    __try {

        if (dwMilliseconds == INFINITE)
        {
            pTimeOut = NULL;
        }
        else
        {
            Win32ToNtTimeout(dwMilliseconds, &TimeOut);
            pTimeOut = &TimeOut;
        }
    rewait:
        Status = NtWaitForSingleObject(hHandle,(BOOLEAN)bAlertable,pTimeOut);
        if ( !NT_SUCCESS(Status) ) {
            BaseSetLastNTError(Status);
            Status = (NTSTATUS)0xffffffff;
            }
        else {
            if ( bAlertable && Status == STATUS_ALERTED ) {
                goto rewait;
                }
            }
    } __finally {
        RtlDeactivateActivationContextUnsafeFast(&Frame);
    }

    return (DWORD)Status;
}

DWORD
WaitForMultipleObjects(
    DWORD nCount,
    CONST HANDLE *lpHandles,
    BOOL bWaitAll,
    DWORD dwMilliseconds
    )

/*++

Routine Description:

A wait operation on multiple waitable objects (up to
MAXIMUM_WAIT_OBJECTS) is accomplished with the WaitForMultipleObjects
function.

Arguments:

    nCount - A count of the number of objects that are to be waited on.

    lpHandles - An array of object handles.  Each handle must have
        SYNCHRONIZE access to the associated object.

    bWaitAll - A flag that supplies the wait type.  A value of TRUE
        indicates a "wait all".  A value of false indicates a "wait
        any".

    dwMilliseconds - A time-out value that specifies the relative time,
        in milliseconds, over which the wait is to be completed.  A
        timeout value of 0 specified that the wait is to timeout
        immediately.  This allows an application to test an object to
        determine if it is in the signaled state.  A timeout value of -1
        specifies an infinite timeout period.

Return Value:

    WAIT_TIME_OUT - indicates that the wait was terminated due to the
        TimeOut conditions.

    0 to MAXIMUM_WAIT_OBJECTS-1, indicates, in the case of wait for any
        object, the object number which satisfied the wait.  In the case
        of wait for all objects, the value only indicates that the wait
        was completed successfully.

    WAIT_ABANDONED_0 to (WAIT_ABANDONED_0)+(MAXIMUM_WAIT_OBJECTS - 1),
        indicates, in the case of wait for any object, the object number
        which satisfied the event, and that the object which satisfied
        the event was abandoned.  In the case of wait for all objects,
        the value indicates that the wait was completed successfully and
        at least one of the objects was abandoned.

--*/

{
    return WaitForMultipleObjectsEx(nCount,lpHandles,bWaitAll,dwMilliseconds,FALSE);
}

DWORD
APIENTRY
WaitForMultipleObjectsEx(
    DWORD nCount,
    CONST HANDLE *lpHandles,
    BOOL bWaitAll,
    DWORD dwMilliseconds,
    BOOL bAlertable
    )

/*++

Routine Description:

    A wait operation on multiple waitable objects (up to
    MAXIMUM_WAIT_OBJECTS) is accomplished with the
    WaitForMultipleObjects function.

    This API can be used to wait on any of the specified objects to
    enter the signaled state, or all of the objects to enter the
    signaled state.

    If the bAlertable parameter is FALSE, the only way the wait
    terminates is because the specified timeout period expires, or
    because the specified objects entered the signaled state.  If the
    bAlertable parameter is TRUE, then the wait can return due to any one of
    the above wait termination conditions, or because an I/O completion
    callback terminated the wait early (return value of
    WAIT_IO_COMPLETION).

Arguments:

    nCount - A count of the number of objects that are to be waited on.

    lpHandles - An array of object handles.  Each handle must have
        SYNCHRONIZE access to the associated object.

    bWaitAll - A flag that supplies the wait type.  A value of TRUE
        indicates a "wait all".  A value of false indicates a "wait
        any".

    dwMilliseconds - A time-out value that specifies the relative time,
        in milliseconds, over which the wait is to be completed.  A
        timeout value of 0 specified that the wait is to timeout
        immediately.  This allows an application to test an object to
        determine if it is in the signaled state.  A timeout value of
        0xffffffff specifies an infinite timeout period.

    bAlertable - Supplies a flag that controls whether or not the
        wait may terminate early due to an I/O completion callback.
        A value of TRUE allows this API to complete early due to an I/O
        completion callback.  A value of FALSE will not allow I/O
        completion callbacks to terminate this call early.

Return Value:

    WAIT_TIME_OUT - indicates that the wait was terminated due to the
        TimeOut conditions.

    0 to MAXIMUM_WAIT_OBJECTS-1, indicates, in the case of wait for any
        object, the object number which satisfied the wait.  In the case
        of wait for all objects, the value only indicates that the wait
        was completed successfully.

    0xffffffff - The wait terminated due to an error. GetLastError may be
        used to get additional error information.

    WAIT_ABANDONED_0 to (WAIT_ABANDONED_0)+(MAXIMUM_WAIT_OBJECTS - 1),
        indicates, in the case of wait for any object, the object number
        which satisfied the event, and that the object which satisfied
        the event was abandoned.  In the case of wait for all objects,
        the value indicates that the wait was completed successfully and
        at least one of the objects was abandoned.

    WAIT_IO_COMPLETION - The wait terminated due to one or more I/O
        completion callbacks.

--*/
{
    NTSTATUS Status;
    LARGE_INTEGER TimeOut;
    PLARGE_INTEGER pTimeOut;
    DWORD i;
    LPHANDLE HandleArray;
    HANDLE Handles[ 8 ];
    PPEB Peb;

    RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME Frame = { sizeof(Frame), RTL_CALLER_ALLOCATED_ACTIVATION_CONTEXT_STACK_FRAME_FORMAT_WHISTLER };

    RtlActivateActivationContextUnsafeFast(&Frame, NULL); // make the process default activation context active so that APCs are delivered under it
    __try {
        if (nCount > 8) {
            BaseSetLastNTError(STATUS_NO_MEMORY);
            return 0xffffffff;
        } else {
            HandleArray = Handles;
        }
        RtlCopyMemory(HandleArray,(LPVOID)lpHandles,nCount*sizeof(HANDLE));

        Peb = NtCurrentPeb();

        if (dwMilliseconds == INFINITE)
        {
            pTimeOut = NULL;
        }
        else
        {
            Win32ToNtTimeout(dwMilliseconds, &TimeOut);
            pTimeOut = &TimeOut;
        }
    rewait:
        Status = NtWaitForMultipleObjects(
                     (CHAR)nCount,
                     HandleArray,
                     bWaitAll ? WaitAll : WaitAny,
                     (BOOLEAN)bAlertable,
                     pTimeOut
                     );
        if ( !NT_SUCCESS(Status) ) {
            BaseSetLastNTError(Status);
            Status = (NTSTATUS)0xffffffff;
            }
        else {
            if ( bAlertable && Status == STATUS_ALERTED ) {
                goto rewait;
                }
            }

        if (HandleArray != Handles) {
            RtlFreeHeap(RtlProcessHeap(), 0, HandleArray);
        }
    } __finally {
        RtlDeactivateActivationContextUnsafeFast(&Frame);
    }

    return (DWORD)Status;
}

HANDLE
APIENTRY
CreateEventA(
    LPSECURITY_ATTRIBUTES lpEventAttributes,
    BOOL bManualReset,
    BOOL bInitialState,
    LPCSTR lpName
    )

/*++

Routine Description:

    ANSI thunk to CreateEventW


--*/

{
    PUNICODE_STRING Unicode;
    ANSI_STRING AnsiString;
    NTSTATUS Status;
    LPCWSTR NameBuffer;

    NameBuffer = NULL;
    if ( ARGUMENT_PRESENT(lpName) ) {
        Unicode = &NtCurrentTeb()->StaticUnicodeString;
        RtlInitAnsiString(&AnsiString,lpName);
        Status = RtlAnsiStringToUnicodeString(Unicode,&AnsiString,FALSE);
        if ( !NT_SUCCESS(Status) ) {
            if ( Status == STATUS_BUFFER_OVERFLOW ) {
                SetLastError(ERROR_FILENAME_EXCED_RANGE);
                }
            else {
                BaseSetLastNTError(Status);
                }
            return NULL;
            }
        NameBuffer = (LPCWSTR)Unicode->Buffer;
        }

    return CreateEventW(
                lpEventAttributes,
                bManualReset,
                bInitialState,
                NameBuffer
                );
}


HANDLE
APIENTRY
CreateEventW(
    LPSECURITY_ATTRIBUTES lpEventAttributes,
    BOOL bManualReset,
    BOOL bInitialState,
    LPCWSTR lpName
    )

/*++

Routine Description:

    An event object is created and a handle opened for access to the
    object with the CreateEvent function.

    The CreateEvent function creates an event object with the specified
    initial state.  If an event is in the Signaled state (TRUE), a wait
    operation on the event does not block.  If the event is in the Not-
    Signaled state (FALSE), a wait operation on the event blocks until
    the specified event attains a state of Signaled, or the timeout
    value is exceeded.

    In addition to the STANDARD_RIGHTS_REQUIRED access flags, the following
    object type specific access flags are valid for event objects:

        - EVENT_MODIFY_STATE - Modify state access (set and reset) to
          the event is desired.

        - SYNCHRONIZE - Synchronization access (wait) to the event is
          desired.

        - EVENT_ALL_ACCESS - This set of access flags specifies all of
          the possible access flags for an event object.


Arguments:

    lpEventAttributes - An optional parameter that may be used to
        specify the attributes of the new event.  If the parameter is
        not specified, then the event is created without a security
        descriptor, and the resulting handle is not inherited on process
        creation.

    bManualReset - Supplies a flag which if TRUE specifies that the
        event must be manually reset.  If the value is FALSE, then after
        releasing a single waiter, the system automaticaly resets the
        event.

    bInitialState - The initial state of the event object, one of TRUE
        or FALSE.  If the InitialState is specified as TRUE, the event's
        current state value is set to one, otherwise it is set to zero.

    lpName - Optional unicode name of event

Return Value:

    NON-NULL - Returns a handle to the new event.  The handle has full
        access to the new event and may be used in any API that requires
        a handle to an event object.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    POBJECT_ATTRIBUTES pObja;
    HANDLE Handle;
    UNICODE_STRING ObjectName;
    PWCHAR pstrNewObjName = NULL;

    if (lpName != NULL || lpEventAttributes != NULL)
    {
        return FALSE;
    }

    pObja = NULL;

    Status = NtCreateEvent(
                &Handle,
                EVENT_ALL_ACCESS,
                pObja,
                bManualReset ? NotificationEvent : SynchronizationEvent,
                (BOOLEAN)bInitialState
                );

    if (pstrNewObjName) {
        RtlFreeHeap(RtlProcessHeap(), 0, pstrNewObjName);
    }

    if ( NT_SUCCESS(Status) ) {
        if ( Status == STATUS_OBJECT_NAME_EXISTS ) {
            SetLastError(ERROR_ALREADY_EXISTS);
            }
        else {
            SetLastError(0);
            }
        return Handle;
        }
    else {
        BaseSetLastNTError(Status);
        return NULL;
        }
}

BOOL
SetEvent(
    HANDLE hEvent
    )

/*++

Routine Description:

    An event can be set to the signaled state (TRUE) with the SetEvent
    function.

    Setting the event causes the event to attain a state of Signaled,
    which releases all currently waiting threads (for manual reset
    events), or a single waiting thread (for automatic reset events).

Arguments:

    hEvent - Supplies an open handle to an event object.  The
        handle must have EVENT_MODIFY_STATE access to the event.

Return Value:

    TRUE - The operation was successful

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;

    Status = NtSetEvent(hEvent,NULL);
    if ( NT_SUCCESS(Status) ) {
        return TRUE;
        }
    else {
        BaseSetLastNTError(Status);
        return FALSE;
        }
}

BOOL
ResetEvent(
    HANDLE hEvent
    )

/*++

Routine Description:

    The state of an event is set to the Not-Signaled state (FALSE) using
    the ClearEvent function.

    Once the event attains a state of Not-Signaled, any threads which
    wait on the event block, awaiting the event to become Signaled.  The
    reset event service sets the event count to zero for the state of
    the event.

Arguments:

    hEvent - Supplies an open handle to an event object.  The
        handle must have EVENT_MODIFY_STATE access to the event.

Return Value:

    TRUE - The operation was successful

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;

    Status = NtClearEvent(hEvent);
    if ( NT_SUCCESS(Status) ) {
        return TRUE;
        }
    else {
        BaseSetLastNTError(Status);
        return FALSE;
        }
}

BOOL
WINAPI
GetOverlappedResult(
    HANDLE hFile,
    LPOVERLAPPED lpOverlapped,
    LPDWORD lpNumberOfBytesTransferred,
    BOOL bWait
    )

/*++

Routine Description:

    The GetOverlappedResult function returns the result of the last
    operation that used lpOverlapped and returned ERROR_IO_PENDING.

Arguments:

    hFile - Supplies the open handle to the file that the overlapped
        structure lpOverlapped was supplied to ReadFile, WriteFile,
        ConnectNamedPipe, WaitNamedPipe or TransactNamedPipe.

    lpOverlapped - Points to an OVERLAPPED structure previously supplied to
        ReadFile, WriteFile, ConnectNamedPipe, WaitNamedPipe or
        TransactNamedPipe.

    lpNumberOfBytesTransferred - Returns the number of bytes transferred
        by the operation.

    bWait -  A boolean value that affects the behavior when the operation
        is still in progress. If TRUE and the operation is still in progress,
        GetOverlappedResult will wait for the operation to complete before
        returning. If FALSE and the operation is incomplete,
        GetOverlappedResult will return FALSE. In this case the extended
        error information available from the GetLastError function will be
        set to ERROR_IO_INCOMPLETE.

Return Value:

    TRUE -- The operation was successful, the pipe is in the
        connected state.

    FALSE -- The operation failed. Extended error status is available using
        GetLastError.

--*/
{
    DWORD WaitReturn;

    //
    // Did caller specify an event to the original operation or was the
    // default (file handle) used?
    //

    if (lpOverlapped->Internal == (DWORD)STATUS_PENDING ) {
        if ( bWait ) {
            WaitReturn = WaitForSingleObject(
                            ( lpOverlapped->hEvent != NULL ) ?
                                lpOverlapped->hEvent : hFile,
                            INFINITE
                            );
            }
        else {
            WaitReturn = WAIT_TIMEOUT;
            }

        if ( WaitReturn == WAIT_TIMEOUT ) {
            //  !bWait and event in not signalled state
            SetLastError( ERROR_IO_INCOMPLETE );
            return FALSE;
            }

        if ( WaitReturn != 0 ) {
             return FALSE;    // WaitForSingleObject calls BaseSetLastError
             }
        }

    *lpNumberOfBytesTransferred = (DWORD)lpOverlapped->InternalHigh;

    if ( NT_SUCCESS((NTSTATUS)lpOverlapped->Internal) ){
        return TRUE;
        }
    else {
        BaseSetLastNTError( (NTSTATUS)lpOverlapped->Internal );
        return FALSE;
        }
}

BOOL
ClearCommError(
    HANDLE hFile,
    LPDWORD lpErrors,
    LPCOMSTAT lpStat
    )

/*++

Routine Description:

    In case of a communications error, such as a buffer overrun or
    framing error, the communications software will abort all
    read and write operations on the communication port.  No further
    read or write operations will be accepted until this function
    is called.

Arguments:

    hFile - Specifies the communication device to be adjusted.

    lpErrors - Points to the DWORD that is to receive the mask of the
               error that occured.

    lpStat - Points to the COMMSTAT structure that is to receive
             the device status.  The structure contains information
             about the communications device.

Return Value:

    The return value is TRUE if the function is successful or FALSE
    if an error occurs.

--*/

{

    NTSTATUS Status;
    HANDLE SyncEvent;
    IO_STATUS_BLOCK Iosb;
    SERIAL_STATUS LocalStat;

    RtlZeroMemory(&LocalStat, sizeof(SERIAL_STATUS));

    if (!(SyncEvent = CreateEvent(
                          NULL,
                          TRUE,
                          FALSE,
                          NULL
                          ))) {

        return FALSE;

    }

    Status = NtDeviceIoControlFile(
                 hFile,
                 SyncEvent,
                 NULL,
                 NULL,
                 &Iosb,
                 IOCTL_SERIAL_GET_COMMSTATUS,
                 NULL,
                 0,
                 &LocalStat,
                 sizeof(LocalStat)
                 );

    if ( Status == STATUS_PENDING) {

        // Operation must complete before return & IoStatusBlock destroyed

        Status = NtWaitForSingleObject( SyncEvent, FALSE, NULL );
        if ( NT_SUCCESS(Status)) {

            Status = Iosb.Status;

        }
    }

    if (NT_ERROR(Status)) {

        CloseHandle(SyncEvent);
        BaseSetLastNTError(Status);
        return FALSE;

    }

    if (lpStat) {

        //
        // All is well up to this point.  Translate the NT values
        // into win32 values.
        //

        if (LocalStat.HoldReasons & SERIAL_TX_WAITING_FOR_CTS) {

            lpStat->fCtsHold = TRUE;

        } else {

            lpStat->fCtsHold = FALSE;

        }

        if (LocalStat.HoldReasons & SERIAL_TX_WAITING_FOR_DSR) {

            lpStat->fDsrHold = TRUE;

        } else {

            lpStat->fDsrHold = FALSE;

        }

        if (LocalStat.HoldReasons & SERIAL_TX_WAITING_FOR_DCD) {

            lpStat->fRlsdHold = TRUE;

        } else {

            lpStat->fRlsdHold = FALSE;

        }

        if (LocalStat.HoldReasons & SERIAL_TX_WAITING_FOR_XON) {

            lpStat->fXoffHold = TRUE;

        } else {

            lpStat->fXoffHold = FALSE;

        }

        if (LocalStat.HoldReasons & SERIAL_TX_WAITING_XOFF_SENT) {

            lpStat->fXoffSent = TRUE;

        } else {

            lpStat->fXoffSent = FALSE;

        }

        lpStat->fEof = LocalStat.EofReceived;
        lpStat->fTxim = LocalStat.WaitForImmediate;
        lpStat->cbInQue = LocalStat.AmountInInQueue;
        lpStat->cbOutQue = LocalStat.AmountInOutQueue;

    }

    if (lpErrors) {

        *lpErrors = 0;

        if (LocalStat.Errors & SERIAL_ERROR_BREAK) {

            *lpErrors = *lpErrors | CE_BREAK;

        }

        if (LocalStat.Errors & SERIAL_ERROR_FRAMING) {

            *lpErrors = *lpErrors | CE_FRAME;

        }

        if (LocalStat.Errors & SERIAL_ERROR_OVERRUN) {

            *lpErrors = *lpErrors | CE_OVERRUN;

        }

        if (LocalStat.Errors & SERIAL_ERROR_QUEUEOVERRUN) {

            *lpErrors = *lpErrors | CE_RXOVER;

        }

        if (LocalStat.Errors & SERIAL_ERROR_PARITY) {

            *lpErrors = *lpErrors | CE_RXPARITY;

        }

    }

    CloseHandle(SyncEvent);
    return TRUE;

}

BOOL
SetupComm(
    HANDLE hFile,
    DWORD dwInQueue,
    DWORD dwOutQueue
    )

/*++

Routine Description:

    The communication device is not initialized until SetupComm is
    called.  This function allocates space for receive and transmit
    queues.  These queues are used by the interrupt-driven transmit/
    receive software and are internal to the provider.

Arguments:

    hFile - Specifies the communication device to receive the settings.
            The CreateFile function returns this value.

    dwInQueue - Specifies the recommended size of the provider's
                internal receive queue in bytes.  This value must be
                even.  A value of -1 indicates that the default should
                be used.

    dwOutQueue - Specifies the recommended size of the provider's
                 internal transmit queue in bytes.  This value must be
                 even.  A value of -1 indicates that the default should
                 be used.

Return Value:

    The return value is TRUE if the function is successful or FALSE
    if an error occurs.

--*/

{

    NTSTATUS Status;

    HANDLE SyncEvent;
    IO_STATUS_BLOCK Iosb;
    SERIAL_QUEUE_SIZE NewSizes = {0};

    //
    // Make sure that the sizes are even.
    //

    if (dwOutQueue != ((DWORD)-1)) {

        if (((dwOutQueue/2)*2) != dwOutQueue) {

            SetLastError(ERROR_INVALID_DATA);
            return FALSE;

        }

    }

    if (dwInQueue != ((DWORD)-1)) {

        if (((dwInQueue/2)*2) != dwInQueue) {

            SetLastError(ERROR_INVALID_DATA);
            return FALSE;

        }

    }

    NewSizes.InSize = dwInQueue;
    NewSizes.OutSize = dwOutQueue;


    if (!(SyncEvent = CreateEvent(
                      NULL,
                      TRUE,
                      FALSE,
                      NULL
                      ))) {

        return FALSE;

    }

    Status = NtDeviceIoControlFile(
                 hFile,
                 SyncEvent,
                 NULL,
                 NULL,
                 &Iosb,
                 IOCTL_SERIAL_SET_QUEUE_SIZE,
                 &NewSizes,
                 sizeof(SERIAL_QUEUE_SIZE),
                 NULL,
                 0
                 );

    if ( Status == STATUS_PENDING) {

        // Operation must complete before return & IoStatusBlock destroyed

        Status = NtWaitForSingleObject( SyncEvent, FALSE, NULL );
        if ( NT_SUCCESS(Status)) {

            Status = Iosb.Status;

        }
    }

    if (NT_ERROR(Status)) {

        CloseHandle(SyncEvent);
        BaseSetLastNTError(Status);
        return FALSE;

    }

    CloseHandle(SyncEvent);
    return TRUE;

}

BOOL
GetCommState(
    HANDLE hFile,
    LPDCB lpDCB
    )

/*++

Routine Description:

    This function fills the buffer pointed to by the lpDCB parameter with
    the device control block of the communication device specified by hFile
    parameter.

Arguments:

    hFile - Specifies the communication device to be examined.
            The CreateFile function returns this value.

    lpDCB - Points to the DCB data structure that is to receive the current
            device control block.  The structure defines the control settings
            for the device.

Return Value:

    The return value is TRUE if the function is successful or FALSE
    if an error occurs.

--*/

{

    SERIAL_BAUD_RATE LocalBaud;
    SERIAL_LINE_CONTROL LineControl;
    SERIAL_CHARS Chars;
    SERIAL_HANDFLOW HandFlow;
    IO_STATUS_BLOCK Iosb;
    NTSTATUS Status;

    //
    // Given the possiblity that the app may be doing asynchronous
    // io we need an event to wait on.
    //
    // We need to make sure that any exit to this routine closes this
    // event handle.
    //
    HANDLE SyncEvent;

    //
    // Make sure the windows mapping is the same as the NT mapping.
    //

    ASSERT((ONESTOPBIT == STOP_BIT_1) &&
           (ONE5STOPBITS == STOP_BITS_1_5) &&
           (TWOSTOPBITS == STOP_BITS_2));

    ASSERT((NOPARITY == NO_PARITY) &&
           (ODDPARITY == ODD_PARITY) &&
           (EVENPARITY == EVEN_PARITY) &&
           (MARKPARITY == MARK_PARITY) &&
           (SPACEPARITY == SPACE_PARITY));

    //
    // Zero out the dcb.  This might create an access violation
    // if it isn't big enough.  Which is ok, since we would rather
    // get it before we create the sync event.
    //

    RtlZeroMemory(lpDCB, sizeof(DCB));

    lpDCB->DCBlength = sizeof(DCB);
    lpDCB->fBinary = TRUE;

    if (!(SyncEvent = CreateEvent(
                          NULL,
                          TRUE,
                          FALSE,
                          NULL
                          ))) {

        return FALSE;

    }

    Status = NtDeviceIoControlFile(
                 hFile,
                 SyncEvent,
                 NULL,
                 NULL,
                 &Iosb,
                 IOCTL_SERIAL_GET_BAUD_RATE,
                 NULL,
                 0,
                 &LocalBaud,
                 sizeof(LocalBaud)
                 );

    if ( Status == STATUS_PENDING) {

        // Operation must complete before return & IoStatusBlock destroyed

        Status = NtWaitForSingleObject( SyncEvent, FALSE, NULL );
        if ( NT_SUCCESS(Status)) {

            Status = Iosb.Status;

        }

    }

    if (NT_ERROR(Status)) {

        CloseHandle(SyncEvent);
        BaseSetLastNTError(Status);
        return FALSE;

    }

    lpDCB->BaudRate = LocalBaud.BaudRate;

    Status = NtDeviceIoControlFile(
                 hFile,
                 SyncEvent,
                 NULL,
                 NULL,
                 &Iosb,
                 IOCTL_SERIAL_GET_LINE_CONTROL,
                 NULL,
                 0,
                 &LineControl,
                 sizeof(LineControl)
                 );

    if ( Status == STATUS_PENDING) {

        // Operation must complete before return & IoStatusBlock destroyed

        Status = NtWaitForSingleObject( SyncEvent, FALSE, NULL );
        if ( NT_SUCCESS(Status)) {

            Status = Iosb.Status;

        }

    }

    if (NT_ERROR(Status)) {

        CloseHandle(SyncEvent);
        BaseSetLastNTError(Status);
        return FALSE;

    }

    lpDCB->Parity = LineControl.Parity;
    lpDCB->ByteSize = LineControl.WordLength;
    lpDCB->StopBits = LineControl.StopBits;

    Status = NtDeviceIoControlFile(
                 hFile,
                 SyncEvent,
                 NULL,
                 NULL,
                 &Iosb,
                 IOCTL_SERIAL_GET_CHARS,
                 NULL,
                 0,
                 &Chars,
                 sizeof(Chars)
                 );

    if ( Status == STATUS_PENDING) {

        // Operation must complete before return & IoStatusBlock destroyed

        Status = NtWaitForSingleObject( SyncEvent, FALSE, NULL );
        if ( NT_SUCCESS(Status)) {

            Status = Iosb.Status;

        }

    }

    if (NT_ERROR(Status)) {

        CloseHandle(SyncEvent);
        BaseSetLastNTError(Status);
        return FALSE;

    }

    lpDCB->XonChar = Chars.XonChar;
    lpDCB->XoffChar = Chars.XoffChar;
    lpDCB->ErrorChar = Chars.ErrorChar;
    lpDCB->EofChar = Chars.EofChar;
    lpDCB->EvtChar = Chars.EventChar;

    Status = NtDeviceIoControlFile(
                 hFile,
                 SyncEvent,
                 NULL,
                 NULL,
                 &Iosb,
                 IOCTL_SERIAL_GET_HANDFLOW,
                 NULL,
                 0,
                 &HandFlow,
                 sizeof(HandFlow)
                 );

    if ( Status == STATUS_PENDING) {

        // Operation must complete before return & IoStatusBlock destroyed

        Status = NtWaitForSingleObject( SyncEvent, FALSE, NULL );
        if ( NT_SUCCESS(Status)) {

            Status = Iosb.Status;

        }

    }

    if (NT_ERROR(Status)) {

        CloseHandle(SyncEvent);
        BaseSetLastNTError(Status);
        return FALSE;

    }

    if (HandFlow.ControlHandShake & SERIAL_CTS_HANDSHAKE) {

        lpDCB->fOutxCtsFlow = TRUE;

    }

    if (HandFlow.ControlHandShake & SERIAL_DSR_HANDSHAKE) {

        lpDCB->fOutxDsrFlow = TRUE;

    }

    if (HandFlow.FlowReplace & SERIAL_AUTO_TRANSMIT) {

        lpDCB->fOutX = TRUE;

    }

    if (HandFlow.FlowReplace & SERIAL_AUTO_RECEIVE) {

        lpDCB->fInX = TRUE;

    }

    if (HandFlow.FlowReplace & SERIAL_NULL_STRIPPING) {

        lpDCB->fNull = TRUE;

    }

    if (HandFlow.FlowReplace & SERIAL_ERROR_CHAR) {

        lpDCB->fErrorChar = TRUE;

    }

    if (HandFlow.FlowReplace & SERIAL_XOFF_CONTINUE) {

        lpDCB->fTXContinueOnXoff = TRUE;

    }

    if (HandFlow.ControlHandShake & SERIAL_ERROR_ABORT) {

        lpDCB->fAbortOnError = TRUE;

    }

    switch (HandFlow.FlowReplace & SERIAL_RTS_MASK) {
        case 0:
            lpDCB->fRtsControl = RTS_CONTROL_DISABLE;
            break;
        case SERIAL_RTS_CONTROL:
            lpDCB->fRtsControl = RTS_CONTROL_ENABLE;
            break;
        case SERIAL_RTS_HANDSHAKE:
            lpDCB->fRtsControl = RTS_CONTROL_HANDSHAKE;
            break;
        case SERIAL_TRANSMIT_TOGGLE:
            lpDCB->fRtsControl = RTS_CONTROL_TOGGLE;
            break;
    }

    switch (HandFlow.ControlHandShake & SERIAL_DTR_MASK) {
        case 0:
            lpDCB->fDtrControl = DTR_CONTROL_DISABLE;
            break;
        case SERIAL_DTR_CONTROL:
            lpDCB->fDtrControl = DTR_CONTROL_ENABLE;
            break;
        case SERIAL_DTR_HANDSHAKE:
            lpDCB->fDtrControl = DTR_CONTROL_HANDSHAKE;
            break;
    }

    lpDCB->fDsrSensitivity =
        (HandFlow.ControlHandShake & SERIAL_DSR_SENSITIVITY)?(TRUE):(FALSE);
    lpDCB->XonLim = (WORD)HandFlow.XonLimit;
    lpDCB->XoffLim = (WORD)HandFlow.XoffLimit;

    CloseHandle(SyncEvent);
    return TRUE;
}

BOOL
EscapeCommFunction(
    HANDLE hFile,
    DWORD dwFunc
    )

/*++

Routine Description:

    This function directs the communication-device specified by the
    hFile parameter to carry out the extended function specified by
    the dwFunc parameter.

Arguments:

    hFile - Specifies the communication device to receive the settings.
            The CreateFile function returns this value.

    dwFunc - Specifies the function code of the extended function.

Return Value:

    The return value is TRUE if the function is successful or FALSE
    if an error occurs.

--*/

{

    NTSTATUS Status;
    IO_STATUS_BLOCK Iosb;
    ULONG ControlCode;
    HANDLE Event;

    switch (dwFunc) {

        case SETXOFF: {
            ControlCode = IOCTL_SERIAL_SET_XOFF;
            break;
        }

        case SETXON: {
            ControlCode = IOCTL_SERIAL_SET_XON;
            break;
        }

        case SETRTS: {
            ControlCode = IOCTL_SERIAL_SET_RTS;
            break;
        }

        case CLRRTS: {
            ControlCode = IOCTL_SERIAL_CLR_RTS;
            break;
        }

        case SETDTR: {
            ControlCode = IOCTL_SERIAL_SET_DTR;
            break;
        }

        case CLRDTR: {
            ControlCode = IOCTL_SERIAL_CLR_DTR;
            break;
        }

        case RESETDEV: {
            ControlCode = IOCTL_SERIAL_RESET_DEVICE;
            break;
        }

        case SETBREAK: {
            ControlCode = IOCTL_SERIAL_SET_BREAK_ON;
            break;
        }

        case CLRBREAK: {
            ControlCode = IOCTL_SERIAL_SET_BREAK_OFF;
            break;
        }
        default: {

            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;


        }
    }


    if (!(Event = CreateEvent(
                      NULL,
                      TRUE,
                      FALSE,
                      NULL
                      ))) {

        return FALSE;

    }

    Status = NtDeviceIoControlFile(
                 hFile,
                 Event,
                 NULL,
                 NULL,
                 &Iosb,
                 ControlCode,
                 NULL,
                 0,
                 NULL,
                 0
                 );

    if ( Status == STATUS_PENDING) {

        // Operation must complete before return & IoStatusBlock destroyed

        Status = NtWaitForSingleObject( Event, FALSE, NULL );
        if ( NT_SUCCESS(Status)) {

            Status = Iosb.Status;

        }
    }

    if (NT_ERROR(Status)) {

        CloseHandle(Event);
        BaseSetLastNTError(Status);
        return FALSE;

    }

    CloseHandle(Event);
    return TRUE;

}

BOOL
SetCommState(
    HANDLE hFile,
    LPDCB lpDCB
    )

/*++

Routine Description:

    The SetCommState function sets a communication device to the state
    specified in the lpDCB parameter.  The device is identified by the
    hFile parameter.  This function reinitializes all hardwae and controls
    as specified byt the lpDCB, but does not empty the transmit or
    receive queues.

Arguments:

    hFile - Specifies the communication device to receive the settings.
            The CreateFile function returns this value.

    lpDCB - Points to a DCB structure that contains the desired
            communications setting for the device.

Return Value:

    The return value is TRUE if the function is successful or FALSE
    if an error occurs.

--*/

{

    SERIAL_BAUD_RATE LocalBaud;
    SERIAL_LINE_CONTROL LineControl;
    SERIAL_CHARS Chars;
    SERIAL_HANDFLOW HandFlow = {0};
    IO_STATUS_BLOCK Iosb;
    NTSTATUS Status;

    //
    // Keep a copy of what the DCB was like before we started
    // changing things.  If some error occurs we can use
    // it to restore the old setup.
    //
    DCB OldDcb;

    //
    // Given the possiblity that the app may be doing asynchronous
    // io we need an event to wait on.  While it would be very
    // strange to be setting the comm state while IO is active
    // we need to make sure we don't compound the problem by
    // returning before this API's IO is actually finished.  This
    // can happen because the file handle is set on the completion
    // of any IO.
    //
    // We need to make sure that any exit to this routine closes this
    // event handle.
    //
    HANDLE SyncEvent;

    if (GetCommState(
            hFile,
            &OldDcb
            )) {

        //
        // Try to set the baud rate.  If we fail here, we just return
        // because we never actually got to set anything.
        //

        if (!(SyncEvent = CreateEvent(
                              NULL,
                              TRUE,
                              FALSE,
                              NULL
                              ))) {

            return FALSE;

        }

        LocalBaud.BaudRate = lpDCB->BaudRate;
        Status = NtDeviceIoControlFile(
                     hFile,
                     SyncEvent,
                     NULL,
                     NULL,
                     &Iosb,
                     IOCTL_SERIAL_SET_BAUD_RATE,
                     &LocalBaud,
                     sizeof(LocalBaud),
                     NULL,
                     0
                     );

        if ( Status == STATUS_PENDING) {

            // Operation must complete before return & IoStatusBlock destroyed

            Status = NtWaitForSingleObject( SyncEvent, FALSE, NULL );
            if ( NT_SUCCESS(Status)) {

                Status = Iosb.Status;

            }

        }

        if (NT_ERROR(Status)) {

            CloseHandle(SyncEvent);
            BaseSetLastNTError(Status);
            return FALSE;

        }

        LineControl.StopBits = lpDCB->StopBits;
        LineControl.Parity = lpDCB->Parity;
        LineControl.WordLength = lpDCB->ByteSize;
        LocalBaud.BaudRate = lpDCB->BaudRate;
        Chars.XonChar   = lpDCB->XonChar;
        Chars.XoffChar  = lpDCB->XoffChar;
        Chars.ErrorChar = lpDCB->ErrorChar;
        Chars.BreakChar = lpDCB->ErrorChar;
        Chars.EofChar   = lpDCB->EofChar;
        Chars.EventChar = lpDCB->EvtChar;

        HandFlow.FlowReplace &= ~SERIAL_RTS_MASK;
        switch (lpDCB->fRtsControl) {
            case RTS_CONTROL_DISABLE:
                break;
            case RTS_CONTROL_ENABLE:
                HandFlow.FlowReplace |= SERIAL_RTS_CONTROL;
                break;
            case RTS_CONTROL_HANDSHAKE:
                HandFlow.FlowReplace |= SERIAL_RTS_HANDSHAKE;
                break;
            case RTS_CONTROL_TOGGLE:
                HandFlow.FlowReplace |= SERIAL_TRANSMIT_TOGGLE;
                break;
            default:
                SetCommState(
                    hFile,
                    &OldDcb
                    );
                CloseHandle(SyncEvent);
                BaseSetLastNTError(STATUS_INVALID_PARAMETER);
                return FALSE;
        }

        HandFlow.ControlHandShake &= ~SERIAL_DTR_MASK;
        switch (lpDCB->fDtrControl) {
            case DTR_CONTROL_DISABLE:
                break;
            case DTR_CONTROL_ENABLE:
                HandFlow.ControlHandShake |= SERIAL_DTR_CONTROL;
                break;
            case DTR_CONTROL_HANDSHAKE:
                HandFlow.ControlHandShake |= SERIAL_DTR_HANDSHAKE;
                break;
            default:
                SetCommState(
                    hFile,
                    &OldDcb
                    );
                CloseHandle(SyncEvent);
                BaseSetLastNTError(STATUS_INVALID_PARAMETER);
                return FALSE;
        }

        if (lpDCB->fDsrSensitivity) {

            HandFlow.ControlHandShake |= SERIAL_DSR_SENSITIVITY;

        }

        if (lpDCB->fOutxCtsFlow) {

            HandFlow.ControlHandShake |= SERIAL_CTS_HANDSHAKE;

        }

        if (lpDCB->fOutxDsrFlow) {

            HandFlow.ControlHandShake |= SERIAL_DSR_HANDSHAKE;

        }

        if (lpDCB->fOutX) {

            HandFlow.FlowReplace |= SERIAL_AUTO_TRANSMIT;

        }

        if (lpDCB->fInX) {

            HandFlow.FlowReplace |= SERIAL_AUTO_RECEIVE;

        }

        if (lpDCB->fNull) {

            HandFlow.FlowReplace |= SERIAL_NULL_STRIPPING;

        }

        if (lpDCB->fErrorChar) {

            HandFlow.FlowReplace |= SERIAL_ERROR_CHAR;
        }

        if (lpDCB->fTXContinueOnXoff) {

            HandFlow.FlowReplace |= SERIAL_XOFF_CONTINUE;

        }

        if (lpDCB->fAbortOnError) {

            HandFlow.ControlHandShake |= SERIAL_ERROR_ABORT;

        }

        //
        // For win95 compatiblity, if we are setting with
        // xxx_control_XXXXXXX then set the modem status line
        // to that state.
        //

        if (lpDCB->fRtsControl == RTS_CONTROL_ENABLE) {

            EscapeCommFunction(
                hFile,
                SETRTS
                );

        } else if (lpDCB->fRtsControl == RTS_CONTROL_DISABLE) {

            EscapeCommFunction(
                hFile,
                CLRRTS
                );

        }
        if (lpDCB->fDtrControl == DTR_CONTROL_ENABLE) {

            EscapeCommFunction(
                hFile,
                SETDTR
                );

        } else if (lpDCB->fDtrControl == DTR_CONTROL_DISABLE) {

            EscapeCommFunction(
                hFile,
                CLRDTR
                );

        }




        HandFlow.XonLimit = lpDCB->XonLim;
        HandFlow.XoffLimit = lpDCB->XoffLim;


        Status = NtDeviceIoControlFile(
                     hFile,
                     SyncEvent,
                     NULL,
                     NULL,
                     &Iosb,
                     IOCTL_SERIAL_SET_LINE_CONTROL,
                     &LineControl,
                     sizeof(LineControl),
                     NULL,
                     0
                     );

        if ( Status == STATUS_PENDING) {

            // Operation must complete before return & IoStatusBlock destroyed

            Status = NtWaitForSingleObject( SyncEvent, FALSE, NULL );
            if ( NT_SUCCESS(Status)) {

                Status = Iosb.Status;

            }

        }

        if (NT_ERROR(Status)) {

            CloseHandle(SyncEvent);
            SetCommState(
                hFile,
                &OldDcb
                );
            BaseSetLastNTError(Status);
            return FALSE;

        }

        Status = NtDeviceIoControlFile(
                     hFile,
                     SyncEvent,
                     NULL,
                     NULL,
                     &Iosb,
                     IOCTL_SERIAL_SET_CHARS,
                     &Chars,
                     sizeof(Chars),
                     NULL,
                     0
                     );

        if ( Status == STATUS_PENDING) {

            // Operation must complete before return & IoStatusBlock destroyed

            Status = NtWaitForSingleObject( SyncEvent, FALSE, NULL );
            if ( NT_SUCCESS(Status)) {

                Status = Iosb.Status;

            }

        }

        if (NT_ERROR(Status)) {

            CloseHandle(SyncEvent);
            SetCommState(
                hFile,
                &OldDcb
                );
            BaseSetLastNTError(Status);
            return FALSE;

        }

        Status = NtDeviceIoControlFile(
                     hFile,
                     SyncEvent,
                     NULL,
                     NULL,
                     &Iosb,
                     IOCTL_SERIAL_SET_HANDFLOW,
                     &HandFlow,
                     sizeof(HandFlow),
                     NULL,
                     0
                     );

        if ( Status == STATUS_PENDING) {

            // Operation must complete before return & IoStatusBlock destroyed

            Status = NtWaitForSingleObject( SyncEvent, FALSE, NULL );
            if ( NT_SUCCESS(Status)) {

                Status = Iosb.Status;

            }

        }

        if (NT_ERROR(Status)) {

            CloseHandle(SyncEvent);
            SetCommState(
                hFile,
                &OldDcb
                );
            BaseSetLastNTError(Status);
            return FALSE;

        }
        CloseHandle(SyncEvent);
        return TRUE;

    }

    return FALSE;

}

BOOL
SetCommTimeouts(
    HANDLE hFile,
    LPCOMMTIMEOUTS lpCommTimeouts
    )

/*++

Routine Description:

    This function establishes the timeout characteristics for all
    read and write operations on the handle specified by hFile.

Arguments:

    hFile - Specifies the communication device to receive the settings.
            The CreateFile function returns this value.

    lpCommTimeouts - Points to a structure containing timeout parameters.

Return Value:

    The return value is TRUE if the function is successful or FALSE
    if an error occurs.

--*/

{

    SERIAL_TIMEOUTS To;
    NTSTATUS Status;
    IO_STATUS_BLOCK Iosb;
    HANDLE Event;

    To.ReadIntervalTimeout = lpCommTimeouts->ReadIntervalTimeout;
    To.ReadTotalTimeoutMultiplier = lpCommTimeouts->ReadTotalTimeoutMultiplier;
    To.ReadTotalTimeoutConstant = lpCommTimeouts->ReadTotalTimeoutConstant;
    To.WriteTotalTimeoutMultiplier = lpCommTimeouts->WriteTotalTimeoutMultiplier;
    To.WriteTotalTimeoutConstant = lpCommTimeouts->WriteTotalTimeoutConstant;


    if (!(Event = CreateEvent(
                      NULL,
                      TRUE,
                      FALSE,
                      NULL
                      ))) {

        return FALSE;

    } else {

        Status = NtDeviceIoControlFile(
                     hFile,
                     Event,
                     NULL,
                     NULL,
                     &Iosb,
                     IOCTL_SERIAL_SET_TIMEOUTS,
                     &To,
                     sizeof(To),
                     NULL,
                     0
                     );

        if ( Status == STATUS_PENDING) {

            // Operation must complete before return & IoStatusBlock destroyed

            Status = NtWaitForSingleObject( Event, FALSE, NULL );
            if ( NT_SUCCESS(Status)) {

                Status = Iosb.Status;

            }

        }

        if (NT_ERROR(Status)) {

            CloseHandle(Event);
            BaseSetLastNTError(Status);
            return FALSE;

        }

        CloseHandle(Event);
        return TRUE;

    }

}

BOOL
APIENTRY
InitializeSecurityDescriptor (
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    DWORD dwRevision
    )
{
    NTSTATUS Status;

    Status = RtlCreateSecurityDescriptor (
                pSecurityDescriptor,
                dwRevision
                );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}

BOOL
APIENTRY
SetSecurityDescriptorDacl (
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    BOOL bDaclPresent,
    PACL pDacl OPTIONAL,
    BOOL bDaclDefaulted OPTIONAL
    )
{
    NTSTATUS Status;

    Status = RtlSetDaclSecurityDescriptor (
        pSecurityDescriptor,
        (BOOLEAN)bDaclPresent,
        pDacl,
        (BOOLEAN)bDaclDefaulted
        );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}

ULONG
APIENTRY
GetTickCount(void)
{
    return NtGetTickCount();
}

#endif // #ifdef NT_NATIVE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\dbg-common\dllimp.cpp ===
//----------------------------------------------------------------------------
//
// Certain calls are dynamically linked so that the user-mode
// DLL can be used on Win9x and NT4.
//
// Copyright (C) Microsoft Corporation, 2000-2001.
//
//----------------------------------------------------------------------------

#include "pch.hpp"

#include <ntcsrdll.h>

#include "dllimp.h"
#include "cmnutil.hpp"

// These entries must match the ordering in the NTDLL_CALLS structure.
DYNAMIC_CALL_NAME g_NtDllCallNames[] =
{
    "CsrGetProcessId", FALSE,
    "DbgBreakPoint", TRUE,
    "DbgPrint", TRUE,
    "DbgPrompt", TRUE,
    "DbgUiConvertStateChangeStructure", FALSE,
    "DbgUiGetThreadDebugObject", FALSE,
    "DbgUiIssueRemoteBreakin", FALSE,
    "DbgUiSetThreadDebugObject", FALSE,
    "NtAllocateVirtualMemory", TRUE,
    "NtClose", TRUE,
    "NtCreateDebugObject", FALSE,
    "NtDebugActiveProcess", FALSE,
    "NtDebugContinue", FALSE,
    "NtFreeVirtualMemory", TRUE,
    "NtOpenProcess", TRUE,
    "NtOpenThread", TRUE,
    "NtQueryInformationProcess", TRUE,
    "NtQueryInformationThread", TRUE,
    "NtQueryObject", TRUE,
    "NtQuerySystemInformation", TRUE,
    "NtRemoveProcessDebug", FALSE,
    "NtSetInformationDebugObject", FALSE,
    "NtSetInformationProcess", FALSE,
    "NtSystemDebugControl", TRUE,
    "NtWaitForDebugEvent", FALSE,
    "RtlFreeHeap", TRUE,
    "RtlGetFunctionTableListHead", FALSE,
    "RtlTryEnterCriticalSection", TRUE,
    "RtlUnicodeStringToAnsiString", TRUE,
};

#define NTDLL_CALL_NAMES DIMA(g_NtDllCallNames)
#define NTDLL_CALL_PROCS DIMAT(g_NtDllCalls, FARPROC)
NTDLL_CALLS g_NtDllCalls;
DYNAMIC_CALLS_DESC g_NtDllCallsDesc =
{
    "ntdll.dll", NTDLL_CALL_NAMES,
    g_NtDllCallNames, (FARPROC*)&g_NtDllCalls, NULL, FALSE,
};

// These entries must match the ordering in the KERNEL32_CALLS structure.
DYNAMIC_CALL_NAME g_Kernel32CallNames[] =
{
    "CreateToolhelp32Snapshot", FALSE,
    "DebugActiveProcessStop", FALSE,
    "DebugBreak", TRUE,
    "DebugBreakProcess", FALSE,
    "DebugSetProcessKillOnExit", FALSE,
    "Module32First", FALSE,
    "Module32Next", FALSE,
    "Process32First", FALSE,
    "Process32Next", FALSE,
    "Thread32First", FALSE,
    "Thread32Next", FALSE,
};

#define KERNEL32_CALL_NAMES DIMA(g_Kernel32CallNames)
#define KERNEL32_CALL_PROCS DIMAT(g_Kernel32Calls, FARPROC)
KERNEL32_CALLS g_Kernel32Calls;
DYNAMIC_CALLS_DESC g_Kernel32CallsDesc =
{
    "kernel32.dll", KERNEL32_CALL_NAMES,
    g_Kernel32CallNames, (FARPROC*)&g_Kernel32Calls, NULL, FALSE,
};

// These entries must match the ordering in the USER32_CALLS structure.
DYNAMIC_CALL_NAME g_User32CallNames[] =
{
    "PrivateKDBreakPoint", FALSE,
};

#define USER32_CALL_NAMES DIMA(g_User32CallNames)
#define USER32_CALL_PROCS DIMAT(g_User32Calls, FARPROC)
USER32_CALLS g_User32Calls;
DYNAMIC_CALLS_DESC g_User32CallsDesc =
{
    "user32.dll", USER32_CALL_NAMES,
    g_User32CallNames, (FARPROC*)&g_User32Calls, NULL, FALSE,
};

// These entries must match the ordering in the OLE32_CALLS structure.
DYNAMIC_CALL_NAME g_Ole32CallNames[] =
{
    "CLSIDFromString", TRUE,
    "CoCreateInstance", TRUE,
    "CoInitializeEx", TRUE,
    "CoUninitialize", TRUE,
};

#define OLE32_CALL_NAMES DIMA(g_Ole32CallNames)
#define OLE32_CALL_PROCS DIMAT(g_Ole32Calls, FARPROC)
OLE32_CALLS g_Ole32Calls;
DYNAMIC_CALLS_DESC g_Ole32CallsDesc =
{
    "ole32.dll", OLE32_CALL_NAMES,
    g_Ole32CallNames, (FARPROC*)&g_Ole32Calls, NULL, FALSE,
};

// These entries must match the ordering in the OLEAUT32_CALLS structure.
DYNAMIC_CALL_NAME g_OleAut32CallNames[] =
{
    "SysFreeString", TRUE,
};

#define OLEAUT32_CALL_NAMES DIMA(g_OleAut32CallNames)
#define OLEAUT32_CALL_PROCS DIMAT(g_OleAut32Calls, FARPROC)
OLEAUT32_CALLS g_OleAut32Calls;
DYNAMIC_CALLS_DESC g_OleAut32CallsDesc =
{
    "oleaut32.dll", OLEAUT32_CALL_NAMES,
    g_OleAut32CallNames, (FARPROC*)&g_OleAut32Calls, NULL, FALSE,
};

// These entries must match the ordering in the CRYPT32_CALLS structure.
DYNAMIC_CALL_NAME g_Crypt32CallNames[] =
{
    "CertFindCertificateInStore", FALSE,
    "CertFindChainInStore", FALSE,
    "CertFreeCertificateChain", FALSE,
    "CertFreeCertificateContext", FALSE,
    "CertGetCertificateChain", FALSE,
    "CertOpenStore", FALSE,
    "CertOpenSystemStoreA", FALSE,
    "CertVerifyCertificateChainPolicy", FALSE,
};

#define CRYPT32_CALL_NAMES DIMA(g_Crypt32CallNames)
#define CRYPT32_CALL_PROCS DIMAT(g_Crypt32Calls, FARPROC)
CRYPT32_CALLS g_Crypt32Calls;
DYNAMIC_CALLS_DESC g_Crypt32CallsDesc =
{
    "crypt32.dll", CRYPT32_CALL_NAMES,
    g_Crypt32CallNames, (FARPROC*)&g_Crypt32Calls, NULL, FALSE,
};

// These entries must match the ordering in the ADVAPI32_CALLS structure.
DYNAMIC_CALL_NAME g_Advapi32CallNames[] =
{
    "EnumServicesStatusExA", FALSE,
    "OpenSCManagerA", FALSE,
};

#define ADVAPI32_CALL_NAMES DIMA(g_Advapi32CallNames)
#define ADVAPI32_CALL_PROCS DIMAT(g_Advapi32Calls, FARPROC)
ADVAPI32_CALLS g_Advapi32Calls;
DYNAMIC_CALLS_DESC g_Advapi32CallsDesc =
{
    "advapi32.dll", ADVAPI32_CALL_NAMES,
    g_Advapi32CallNames, (FARPROC*)&g_Advapi32Calls, NULL, FALSE,
};

#ifndef NT_NATIVE

HRESULT
InitDynamicCalls(DYNAMIC_CALLS_DESC* Desc)
{
    if (Desc->Initialized)
    {
        return S_OK;
    }

    C_ASSERT(NTDLL_CALL_NAMES == NTDLL_CALL_PROCS);
    C_ASSERT(KERNEL32_CALL_NAMES == KERNEL32_CALL_PROCS);
    C_ASSERT(USER32_CALL_NAMES == USER32_CALL_PROCS);
    C_ASSERT(OLE32_CALL_NAMES == OLE32_CALL_PROCS);
    C_ASSERT(OLEAUT32_CALL_NAMES == OLEAUT32_CALL_PROCS);
    C_ASSERT(CRYPT32_CALL_NAMES == CRYPT32_CALL_PROCS);
    C_ASSERT(ADVAPI32_CALL_NAMES == ADVAPI32_CALL_PROCS);
    
    ZeroMemory(Desc->Procs, Desc->Count * sizeof(*Desc->Procs));

    Desc->Dll = LoadLibrary(Desc->DllName);
    if (Desc->Dll == NULL)
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    ULONG i;
    DYNAMIC_CALL_NAME* Name = Desc->Names;
    FARPROC* Proc = Desc->Procs;

    for (i = 0; i < Desc->Count; i++)
    {
        *Proc = GetProcAddress(Desc->Dll, Name->Name);
        if (*Proc == NULL && Name->Required)
        {
            return E_NOINTERFACE;
        }

        Proc++;
        Name++;
    }

    Desc->Initialized = TRUE;
    return S_OK;
}

#else // #ifndef NT_NATIVE

HRESULT
InitDynamicCalls(DYNAMIC_CALLS_DESC* Desc)
{
    if (Desc != &g_NtDllCallsDesc)
    {
        ZeroMemory(Desc->Procs, Desc->Count * sizeof(*Desc->Procs));
        return E_NOINTERFACE;
    }
    
    C_ASSERT(NTDLL_CALL_NAMES == NTDLL_CALL_PROCS);

    g_NtDllCalls.CsrGetProcessId = CsrGetProcessId;
    g_NtDllCalls.DbgBreakPoint = DbgBreakPoint;
    g_NtDllCalls.DbgPrint = DbgPrint;
    g_NtDllCalls.DbgPrompt = DbgPrompt;
    g_NtDllCalls.DbgUiConvertStateChangeStructure =
        DbgUiConvertStateChangeStructure;
    g_NtDllCalls.DbgUiGetThreadDebugObject = DbgUiGetThreadDebugObject;
    g_NtDllCalls.DbgUiIssueRemoteBreakin = DbgUiIssueRemoteBreakin;
    g_NtDllCalls.DbgUiSetThreadDebugObject = DbgUiSetThreadDebugObject;
    g_NtDllCalls.NtAllocateVirtualMemory = NtAllocateVirtualMemory;
    g_NtDllCalls.NtClose = NtClose;
    g_NtDllCalls.NtCreateDebugObject = NtCreateDebugObject;
    g_NtDllCalls.NtDebugActiveProcess = NtDebugActiveProcess;
    g_NtDllCalls.NtDebugContinue = NtDebugContinue;
    g_NtDllCalls.NtFreeVirtualMemory = NtFreeVirtualMemory;
    g_NtDllCalls.NtOpenProcess = NtOpenProcess;
    g_NtDllCalls.NtOpenThread = NtOpenThread;
    g_NtDllCalls.NtQueryInformationProcess = NtQueryInformationProcess;
    g_NtDllCalls.NtQueryInformationThread = NtQueryInformationThread;
    g_NtDllCalls.NtQueryObject = NtQueryObject;
    g_NtDllCalls.NtQuerySystemInformation = NtQuerySystemInformation;
    g_NtDllCalls.NtRemoveProcessDebug = NtRemoveProcessDebug;
    g_NtDllCalls.NtSetInformationDebugObject = NtSetInformationDebugObject;
    g_NtDllCalls.NtSetInformationProcess = NtSetInformationProcess;
    g_NtDllCalls.NtSystemDebugControl = NtSystemDebugControl;
    g_NtDllCalls.NtWaitForDebugEvent = NtWaitForDebugEvent;
    g_NtDllCalls.RtlFreeHeap = RtlFreeHeap;
#ifndef _X86_
    g_NtDllCalls.RtlGetFunctionTableListHead = RtlGetFunctionTableListHead;
#endif
    g_NtDllCalls.RtlTryEnterCriticalSection = RtlTryEnterCriticalSection;
    g_NtDllCalls.RtlUnicodeStringToAnsiString = RtlUnicodeStringToAnsiString;
    return S_OK;
}

#endif // #ifndef NT_NATIVE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\dbg-common\pch.hpp ===
//----------------------------------------------------------------------------
//
// Global header file.
//
// Copyright (C) Microsoft Corporation, 1999-2000.
//
//----------------------------------------------------------------------------

#include <stdlib.h>
#include <stdio.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#ifdef NT_NATIVE
#define _ADVAPI32_
#define _KERNEL32_
#endif

#include <windows.h>
#include <objbase.h>
#define NOEXTAPI
#include <wdbgexts.h>
#include <ntdbg.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\dbg-common\pparse.hpp ===
//----------------------------------------------------------------------------
//
// Simple parameter string parsing.
//
// Copyright (C) Microsoft Corporation, 2000.
//
//----------------------------------------------------------------------------

#ifndef __PPARSE_HPP__
#define __PPARSE_HPP__

//----------------------------------------------------------------------------
//
// ParameterStringParser.
//
//----------------------------------------------------------------------------

#define MAX_PARAM_NAME 32
#define MAX_PARAM_VALUE 256

#define PARSER_INVALID 0xffffffff

class ParameterStringParser
{
public:
    PCSTR m_Name;

    ParameterStringParser(void);
    
    virtual ULONG GetNumberParameters(void) = 0;
    virtual void GetParameter(ULONG Index, PSTR Name, PSTR Value) = 0;
    
    virtual void ResetParameters(void) = 0;
    virtual BOOL SetParameter(PCSTR Name, PCSTR Value) = 0;

    BOOL ParseParameters(PCSTR ParamString);
    BOOL GetParameters(PSTR Buffer, ULONG BufferSize);
    
    // Scan the names array for the <name> part of
    // a <name>:<parameters> string.
    static ULONG GetParser(PCSTR ParamString, ULONG NumNames, PCSTR* Names);
};    

#endif // #ifndef __PPARSE_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\dbg-common\wcecompat.h ===
//----------------------------------------------------------------------------
//
// Windows CE/Win32 compatibility definitions.
//
// Copyright (C) Microsoft Corporation, 2001.
//
//----------------------------------------------------------------------------

#ifndef __WCECOMPAT_H__
#define __WCECOMPAT_H__

#ifdef _WIN32_WCE

#ifndef DBG_COMMAND_EXCEPTION
#define DBG_COMMAND_EXCEPTION ((LONG)0x40010009L)
#endif

#ifndef STDMETHODV
#define STDMETHODV(Method) STDMETHOD(Method)
#endif

#ifndef INLINE
#define INLINE __inline
#endif

#ifndef FORCEINLINE
#define FORCEINLINE INLINE
#endif

#ifndef TH32CS_SNAPMODULE32
#define TH32CS_SNAPMODULE32 0
#endif

#ifndef INVALID_SET_FILE_POINTER
#define INVALID_SET_FILE_POINTER 0xffffffff
#endif

#define CREATE_UNICODE_ENVIRONMENT        0x00000400
#define STACK_SIZE_PARAM_IS_A_RESERVATION 0x00010000

typedef struct _EXCEPTION_RECORD32 {
    DWORD    ExceptionCode;
    DWORD ExceptionFlags;
    DWORD ExceptionRecord;
    DWORD ExceptionAddress;
    DWORD NumberParameters;
    DWORD ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];
} EXCEPTION_RECORD32, *PEXCEPTION_RECORD32;

typedef struct _EXCEPTION_RECORD64 {
    DWORD    ExceptionCode;
    DWORD ExceptionFlags;
    DWORD64 ExceptionRecord;
    DWORD64 ExceptionAddress;
    DWORD NumberParameters;
    DWORD __unusedAlignment;
    DWORD64 ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];
} EXCEPTION_RECORD64, *PEXCEPTION_RECORD64;

typedef LONG NTSTATUS;

#define NT_SUCCESS(Status) ((Status) >= 0)

typedef struct _STRING {
    USHORT Length;
    USHORT MaximumLength;
    PCHAR Buffer;
} STRING, ANSI_STRING, *PSTRING, *PANSI_STRING;

typedef struct _UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
    PWSTR  Buffer;
} UNICODE_STRING, *PUNICODE_STRING;

typedef const UNICODE_STRING* PCUNICODE_STRING;
typedef const ANSI_STRING* PCANSI_STRING;

typedef struct _OBJECT_ATTRIBUTES {
    ULONG Length;
    HANDLE RootDirectory;
    PUNICODE_STRING ObjectName;
    ULONG Attributes;
    PVOID SecurityDescriptor;        // Points to type SECURITY_DESCRIPTOR
    PVOID SecurityQualityOfService;  // Points to type SECURITY_QUALITY_OF_SERVICE
} OBJECT_ATTRIBUTES;
typedef OBJECT_ATTRIBUTES *POBJECT_ATTRIBUTES;

typedef struct _CLIENT_ID {
    HANDLE UniqueProcess;
    HANDLE UniqueThread;
} CLIENT_ID;
typedef CLIENT_ID *PCLIENT_ID;

#define WSA_FLAG_OVERLAPPED 0
#define WSA_IO_PENDING 0

typedef OVERLAPPED WSAOVERLAPPED;
typedef WSAOVERLAPPED *LPWSAOVERLAPPED;

#define OpenThread(dwDesiredAccess, bInheritHandle, dwThreadId) \
    ((HANDLE)(dwThreadId))
#define IsProcessorFeaturePresent(ProcessorFeature) FALSE
#define VirtualQueryEx(hProcess, lpAddress, lpBuffer, dwLength) \
    (SetLastError(ERROR_CALL_NOT_IMPLEMENTED), 0)
#define CancelIo(Handle) \
    (SetLastError(ERROR_CALL_NOT_IMPLEMENTED), FALSE)
#define GetOverlappedResult(hFile, lpOverlapped, lpNumberOfBytesTransferred, bWait) \
    (SetLastError(ERROR_CALL_NOT_IMPLEMENTED), FALSE)

#define WSASocket(af, type, protocol, lpProtocolInfo, g, dwFlags) \
    socket(af, type, protocol)
#define WSAGetOverlappedResult(hFile, lpOverlapped, lpNumberOfBytesTransferred, bWait, Flags) \
    (SetLastError(ERROR_CALL_NOT_IMPLEMENTED), FALSE)

INLINE
void *
ULongToHandle(
    const unsigned long h
    )
{
    return((void *) (UINT_PTR) h );
}

#define UlongToHandle(ul) ULongToHandle(ul)

#else

#ifndef VER_PLATFORM_WIN32_CE
#define VER_PLATFORM_WIN32_CE 3
#endif

#endif // #ifdef _WIN32_WCE

#endif // #ifndef __WCECOMPAT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\dbg-common\ntnative.h ===
//----------------------------------------------------------------------------
//
// NT native/Win32 mapping layer.
//
// Copyright (C) Microsoft Corporation, 2000.
//
//----------------------------------------------------------------------------

#ifndef __NTNATIVE_H__
#define __NTNATIVE_H__

#define InitializeCriticalSection(Crit) RtlInitializeCriticalSection(Crit)
#define DeleteCriticalSection(Crit)     RtlDeleteCriticalSection(Crit)
#define EnterCriticalSection(Crit)      RtlEnterCriticalSection(Crit)
#define LeaveCriticalSection(Crit)      RtlLeaveCriticalSection(Crit)

#define malloc(Bytes) RtlAllocateHeap(RtlProcessHeap(), 0, Bytes)
#define free(Ptr)     RtlFreeHeap(RtlProcessHeap(), 0, Ptr)

HANDLE
WINAPI
NtNativeCreateFileA(
    LPCSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile,
    BOOL TranslatePath
    );

HANDLE
APIENTRY
NtNativeCreateNamedPipeA(
    LPCSTR lpName,
    DWORD dwOpenMode,
    DWORD dwPipeMode,
    DWORD nMaxInstances,
    DWORD nOutBufferSize,
    DWORD nInBufferSize,
    DWORD nDefaultTimeOut,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    BOOL TranslatePath
    );

#endif // #ifndef __NTNATIVE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\dbgrpc\pch.hpp ===
//----------------------------------------------------------------------------
//
// Global header file.
//
// Copyright (C) Microsoft Corporation, 1999-2000.
//
//----------------------------------------------------------------------------

#include <stdlib.h>
#include <stdio.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#ifdef NT_NATIVE
#define _ADVAPI32_
#define _KERNEL32_
#endif

#include <windows.h>
#include <objbase.h>
#define NOEXTAPI
#include <wdbgexts.h>
#include <ntdbg.h>

#include <dllimp.h>
#include <cmnutil.hpp>

#include <dbgrpc.hpp>
#include <portio.h>

#ifdef NT_NATIVE
#include <ntnative.h>
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\dbg-common\pparse.cpp ===
//----------------------------------------------------------------------------
//
// Simple parameter string parsing.
//
// Copyright (C) Microsoft Corporation, 2000.
//
//----------------------------------------------------------------------------

#include "pch.hpp"

#include "pparse.hpp"

//----------------------------------------------------------------------------
//
// ParameterStringParser.
//
//----------------------------------------------------------------------------

ParameterStringParser::ParameterStringParser(void)
{
    m_Name = NULL;
}

BOOL
ParameterStringParser::ParseParameters(PCSTR ParamString)
{
    if (ParamString == NULL)
    {
        // Nothing to parse.
        return TRUE;
    }

    PCSTR Scan = ParamString;

    // Skip <name>: if present.
    while (*Scan && *Scan != ':')
    {
        Scan++;
    }
    if (*Scan == ':')
    {
        Scan++;
    }
    else
    {
        Scan = ParamString;
    }

    //
    // Scan options string for comma-delimited parameters
    // and pass them into the parameter handling method.
    //

    char Param[MAX_PARAM_NAME];
    char Value[MAX_PARAM_VALUE];
    PSTR ValStr;
    PSTR Str;

    for (;;)
    {
        while (*Scan && isspace(*Scan))
        {
            *Scan++;
        }
        if (!*Scan)
        {
            break;
        }

        Str = Param;
        while (*Scan && *Scan != ',' && *Scan != '=' &&
               (Str - Param) < MAX_PARAM_NAME)
        {
            *Str++ = *Scan++;
        }
        if (Str >= Param + MAX_PARAM_NAME)
        {
            return FALSE;
        }

        // Terminate option name and default value to nothing.
        *Str++ = 0;
        ValStr = NULL;

        if (*Scan == '=')
        {
            // Parameter has a value, scan it.
            Scan++;
            while (*Scan && isspace(*Scan))
            {
                *Scan++;
            }

            Str = Value;
            while (*Scan && *Scan != ',' &&
                   (Str - Value) < MAX_PARAM_VALUE)
            {
                *Str++ = *Scan++;
            }
            if (Str >= Value + MAX_PARAM_VALUE)
            {
                return FALSE;
            }

            *Str++ = 0;
            ValStr = Value;
        }

        if (*Scan)
        {
            // Skip comma for next iteration.
            Scan++;
        }

        // Set the value in the parser.
        if (!SetParameter(Param, ValStr))
        {
            return FALSE;
        }
    }

    return TRUE;
}

BOOL
ParameterStringParser::GetParameters(PSTR Buffer, ULONG BufferSize)
{
    ULONG Len;
    BOOL Ret = FALSE;

    // Reserve space for the terminator.
    if (BufferSize < 1)
    {
        return FALSE;
    }
    BufferSize--;

    if (m_Name != NULL)
    {
        Len = strlen(m_Name);
        if (BufferSize < Len + 1)
        {
            goto EH_Exit;
        }

        memcpy(Buffer, m_Name, Len);
        Buffer += Len;
        *Buffer++ = ':';
        BufferSize -= Len + 1;
    }

    ULONG Params;
    ULONG i;
    char Name[MAX_PARAM_NAME];
    char Value[MAX_PARAM_VALUE];
    BOOL NeedComma;

    Params = GetNumberParameters();
    NeedComma = FALSE;
    for (i = 0; i < Params; i++)
    {
        Name[0] = 0;
        Value[0] = 0;
        GetParameter(i, Name, Value);

        Len = strlen(Name);
        if (Len == 0)
        {
            continue;
        }

        if (BufferSize < Len)
        {
            goto EH_Exit;
        }

        if (NeedComma)
        {
            if (BufferSize < 1)
            {
                goto EH_Exit;
            }

            *Buffer++ = ',';
            BufferSize--;
        }

        memcpy(Buffer, Name, Len);
        Buffer += Len;
        BufferSize -= Len;
        NeedComma = TRUE;

        Len = strlen(Value);
        if (Len == 0)
        {
            continue;
        }

        if (BufferSize < Len + 1)
        {
            goto EH_Exit;
        }

        *Buffer++ = '=';
        memcpy(Buffer, Value, Len);
        Buffer += Len;
        BufferSize -= Len + 1;
    }

    Ret = TRUE;

 EH_Exit:
    *Buffer++ = 0;
    return Ret;
}

ULONG
ParameterStringParser::GetParser(PCSTR ParamString,
                                 ULONG NumNames, PCSTR* Names)
{
    if (ParamString == NULL)
    {
        return PARSER_INVALID;
    }

    //
    // Parse out <name>: and look up the name.
    //

    PCSTR Scan = ParamString;
    while (*Scan && *Scan != ':')
    {
        Scan++;
    }

    ULONG Len = (ULONG)(Scan - ParamString);
    if (*Scan != ':' || Len < 1)
    {
        return PARSER_INVALID;
    }

    ULONG i;
    for (i = 0; i < NumNames; i++)
    {
        if (strlen(Names[i]) == Len &&
            !_memicmp(Names[i], ParamString, Len))
        {
            return i;
        }
    }

    return PARSER_INVALID;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\dbgrpc\dbgrpc.hpp ===
//----------------------------------------------------------------------------
//
// Remoting support.
//
// Copyright (C) Microsoft Corporation, 1999-2000.
//
//----------------------------------------------------------------------------

#ifndef __DBGRPC_HPP__
#define __DBGRPC_HPP__

#include <wincrypt.h>
#include <security.h>
#include <winsock2.h>
#include <schannel.h>

#include <pparse.hpp>

#define DEBUG_SERVER_KEY "Software\\Microsoft\\Debug Engine\\Servers"

#define INT_ALIGN2(Val, Pow2) \
    (((Val) + (Pow2) - 1) & ~((Pow2) - 1))
#define PTR_ALIGN2(Type, Ptr, Pow2) \
    ((Type)INT_ALIGN2((ULONG64)(Ptr), Pow2))

#define DBGRPC_MAX_IDENTITY 128

typedef ULONG64 DbgRpcObjectId;

//
// Stub functions are indexed out of per-interface tables.
// The function indices are encoded as part interface index
// and part method index.
//

#define DBGRPC_STUB_INDEX_INTERFACE_SHIFT 8
#define DBGRPC_STUB_INDEX_INTERFACE_MAX \
    ((1 << (8 * sizeof(USHORT) - DBGRPC_STUB_INDEX_INTERFACE_SHIFT)) - 1)
#define DBGRPC_STUB_INDEX_METHOD_MAX \
    ((1 << DBGRPC_STUB_INDEX_INTERFACE_SHIFT) - 1)

#define DBGRPC_STUB_INDEX(Interface, Method) \
    ((USHORT)(((Interface) << DBGRPC_STUB_INDEX_INTERFACE_SHIFT) | (Method)))
#define DBGRPC_STUB_INDEX_INTERFACE(StubIndex) \
    ((StubIndex) >> DBGRPC_STUB_INDEX_INTERFACE_SHIFT)
#define DBGRPC_STUB_INDEX_METHOD(StubIndex) \
    ((StubIndex) & DBGRPC_STUB_INDEX_METHOD_MAX)

//
// Interface indices for stub indices are given here
// rather than generated as they must stay constant
// for compatibility.
//
// IMPORTANT: New interfaces must be added at the end of
// the section for that header.  New headers must be
// well separated from each other to allow expansion.
//

enum
{
    // The first dbgeng interface must always be zero.
    DBGRPC_SIF_IDebugAdvanced,
    DBGRPC_SIF_IDebugBreakpoint,
    DBGRPC_SIF_IDebugClient,
    DBGRPC_SIF_IDebugControl,
    DBGRPC_SIF_IDebugDataSpaces,
    DBGRPC_SIF_IDebugEventCallbacks,
    DBGRPC_SIF_IDebugInputCallbacks,
    DBGRPC_SIF_IDebugOutputCallbacks,
    DBGRPC_SIF_IDebugRegisters,
    DBGRPC_SIF_IDebugSymbolGroup,
    DBGRPC_SIF_IDebugSymbols,
    DBGRPC_SIF_IDebugSystemObjects,
    DBGRPC_SIF_IDebugClient2,
    DBGRPC_SIF_IDebugControl2,
    DBGRPC_SIF_IDebugDataSpaces2,
    DBGRPC_SIF_IDebugSymbols2,
    DBGRPC_SIF_IDebugSystemObjects2,
    // Add new dbgeng interfaces here.

    DBGRPC_SIF_IUserDebugServices = 192,
    // Add new dbgsvc interfaces here.
};

#define DBGRPC_SIF_DBGENG_FIRST 0
#define DBGRPC_SIF_DBGENG_LAST  DBGRPC_SIF_IDebugSystemObjects2

#define DBGRPC_SIF_DBGSVC_FIRST DBGRPC_SIF_IUserDebugServices
#define DBGRPC_SIF_DBGSVC_LAST  DBGRPC_SIF_IUserDebugServices

#define DBGRPC_RETURN           0x0001
#define DBGRPC_NO_RETURN        0x0002
#define DBGRPC_LOCKED           0x0004

struct DbgRpcCall
{
    DbgRpcObjectId ObjectId;
    USHORT StubIndex;
    USHORT Flags;
    ULONG InSize;
    ULONG OutSize;
    HRESULT Status;
    ULONG Sequence;
    ULONG Reserved1;
};

//
// These functions and tables are automatically generated.
//

typedef HRESULT (*DbgRpcStubFunction)
    (IUnknown* If, class DbgRpcConnection* Conn, DbgRpcCall* Call,
     PUCHAR InData, PUCHAR OutData);

struct DbgRpcStubFunctionTable
{
    DbgRpcStubFunction* Functions;
    ULONG Count;
};

// These functions are provided by a caller of dbgrpc with
// implementations specific to the caller.
void DbgRpcInitializeClient(void);
DbgRpcStubFunction DbgRpcGetStub(USHORT StubIndex);
#if DBG
PCSTR DbgRpcGetStubName(USHORT StubIndex);
#endif
HRESULT DbgRpcPreallocProxy(REFIID InterfaceId, PVOID* Interface,
                            class DbgRpcProxy** Proxy, PULONG IfUnique);
void DbgRpcDeleteProxy(class DbgRpcProxy* Proxy);
HRESULT DbgRpcServerThreadInitialize(void);
void DbgRpcServerThreadUninitialize(void);
void DbgRpcError(char* Format, ...);

//----------------------------------------------------------------------------
//
// DbgRpcTransport.
//
//----------------------------------------------------------------------------

#define MAX_SERVER_NAME MAX_PARAM_VALUE
#define MAX_PASSWORD_BUFFER 32

enum
{
    TRANS_TCP,
    TRANS_NPIPE,
    TRANS_SSL,
    TRANS_SPIPE,
    TRANS_1394,
    TRANS_COM,
    TRANS_COUNT
};

extern PCSTR g_DbgRpcTransportNames[TRANS_COUNT];

class DbgRpcTransport : public ParameterStringParser
{
public:
    DbgRpcTransport(void)
    {
        m_ServerName[0] = 0;
        m_PasswordGiven = FALSE;
    }
    virtual ~DbgRpcTransport(void);

    virtual ULONG GetNumberParameters(void);
    virtual void GetParameter(ULONG Index, PSTR Name, PSTR Value);

    virtual void ResetParameters(void);
    virtual BOOL SetParameter(PCSTR Name, PCSTR Value);

    virtual DbgRpcTransport* Clone(void) = 0;

    virtual HRESULT CreateServer(void) = 0;
    virtual HRESULT AcceptConnection(DbgRpcTransport** ClientTrans,
                                     PSTR Identity) = 0;

    virtual HRESULT ConnectServer(void) = 0;

    virtual ULONG Read(ULONG Seq, PVOID Buffer, ULONG Len) = 0;
    virtual ULONG Write(ULONG Seq, PVOID Buffer, ULONG Len) = 0;

    void CloneData(DbgRpcTransport* Trans);

    char m_ServerName[MAX_SERVER_NAME];
    BOOL m_PasswordGiven;
    UCHAR m_HashedPassword[MAX_PASSWORD_BUFFER];
};

class DbgRpcTcpTransport : public DbgRpcTransport
{
public:
    DbgRpcTcpTransport(void)
    {
        m_Name = g_DbgRpcTransportNames[TRANS_TCP];
        m_Sock = INVALID_SOCKET;
        ZeroMemory(&m_OlRead, sizeof(m_OlRead));
        ZeroMemory(&m_OlWrite, sizeof(m_OlWrite));
    }
    virtual ~DbgRpcTcpTransport(void);

    // DbgRpcTransport.
    virtual ULONG GetNumberParameters(void);
    virtual void GetParameter(ULONG Index, PSTR Name, PSTR Value);

    virtual void ResetParameters(void);
    virtual BOOL SetParameter(PCSTR Name, PCSTR Value);

    virtual DbgRpcTransport* Clone(void);

    virtual HRESULT CreateServer(void);
    virtual HRESULT AcceptConnection(DbgRpcTransport** ClientTrans,
                                     PSTR Identity);

    virtual HRESULT ConnectServer(void);

    virtual ULONG Read(ULONG Seq, PVOID Buffer, ULONG Len);
    virtual ULONG Write(ULONG Seq, PVOID Buffer, ULONG Len);

    HRESULT InitOl(void);
    
    struct sockaddr_in m_Addr;
    SOCKET m_Sock;
    WSAOVERLAPPED m_OlRead, m_OlWrite;
    ULONG m_TopPort;
};

class DbgRpcNamedPipeTransport : public DbgRpcTransport
{
public:
    DbgRpcNamedPipeTransport(void)
    {
        m_Name = g_DbgRpcTransportNames[TRANS_NPIPE];
        m_Handle = NULL;
        ZeroMemory(&m_ReadOlap, sizeof(m_ReadOlap));
        ZeroMemory(&m_WriteOlap, sizeof(m_WriteOlap));
    }
    virtual ~DbgRpcNamedPipeTransport(void);

    // DbgRpcTransport.
    virtual ULONG GetNumberParameters(void);
    virtual void GetParameter(ULONG Index, PSTR Name, PSTR Value);

    virtual void ResetParameters(void);
    virtual BOOL SetParameter(PCSTR Name, PCSTR Value);

    virtual DbgRpcTransport* Clone(void);

    virtual HRESULT CreateServer(void);
    virtual HRESULT AcceptConnection(DbgRpcTransport** ClientTrans,
                                     PSTR Identity);

    virtual HRESULT ConnectServer(void);

    virtual ULONG Read(ULONG Seq, PVOID Buffer, ULONG Len);
    virtual ULONG Write(ULONG Seq, PVOID Buffer, ULONG Len);

    char m_Pipe[MAX_PARAM_VALUE];
    HANDLE m_Handle;
    OVERLAPPED m_ReadOlap, m_WriteOlap;
};

// This class is a generic schannel-based wrapper for
// a normal transport.

#define DBGRPC_SCHAN_BUFFER 16384

class DbgRpcSecureChannelTransport : public DbgRpcTransport
{
public:
    DbgRpcSecureChannelTransport(ULONG ThisTransport,
                                 ULONG BaseTransport);
    virtual ~DbgRpcSecureChannelTransport(void);

    // DbgRpcTransport.
    virtual ULONG GetNumberParameters(void);
    virtual void GetParameter(ULONG Index, PSTR Name, PSTR Value);

    virtual void ResetParameters(void);
    virtual BOOL SetParameter(PCSTR Name, PCSTR Value);

    virtual DbgRpcTransport* Clone(void);

    virtual HRESULT CreateServer(void);
    virtual HRESULT AcceptConnection(DbgRpcTransport** ClientTrans,
                                     PSTR Identity);

    virtual HRESULT ConnectServer(void);

    virtual ULONG Read(ULONG Seq, PVOID Buffer, ULONG Len);
    virtual ULONG Write(ULONG Seq, PVOID Buffer, ULONG Len);

    // DbgRpcSecureChannelTransport.
    HRESULT GetSizes(void);
    HRESULT AuthenticateClientConnection(void);
    HRESULT InitiateServerConnection(LPSTR pszServerName);
    HRESULT AuthenticateServerConnection(void);
    void GetNewClientCredentials(void);
    void DisconnectFromClient(void);
    void DisconnectFromServer(void);

    ULONG StreamRead(ULONG Seq, PVOID Buffer, ULONG MaxSize)
    {
        ULONG Size;

        if (m_Stream->Read(Seq, &Size, sizeof(Size)) != sizeof(Size) ||
            Size > MaxSize)
        {
            return 0;
        }
        return m_Stream->Read(Seq, Buffer, Size);
    }
    ULONG StreamWrite(ULONG Seq, PVOID Buffer, ULONG Size)
    {
        if (m_Stream->Write(Seq, &Size, sizeof(Size)) != sizeof(Size))
        {
            return 0;
        }
        return m_Stream->Write(Seq, Buffer, Size);
    }

    ULONG m_ThisTransport;
    ULONG m_BaseTransport;
    DbgRpcTransport* m_Stream;
    SCHANNEL_CRED m_ScCreds;
    CredHandle m_Creds;
    BOOL m_OwnCreds;
    CtxtHandle m_Context;
    BOOL m_OwnContext;
    ULONG m_Protocol;
    char m_User[64];
    BOOL m_MachineStore;
    UCHAR m_Buffer[DBGRPC_SCHAN_BUFFER];
    ULONG m_BufferUsed;
    SecPkgContext_StreamSizes m_Sizes;
    ULONG m_MaxChunk;
    BOOL m_Server;
};

class DbgRpc1394Transport : public DbgRpcTransport
{
public:
    DbgRpc1394Transport(void)
    {
        m_Name = g_DbgRpcTransportNames[TRANS_1394];
        m_Handle = NULL;
    }
    virtual ~DbgRpc1394Transport(void);

    // DbgRpcTransport.
    virtual ULONG GetNumberParameters(void);
    virtual void GetParameter(ULONG Index, PSTR Name, PSTR Value);

    virtual void ResetParameters(void);
    virtual BOOL SetParameter(PCSTR Name, PCSTR Value);

    virtual DbgRpcTransport* Clone(void);

    virtual HRESULT CreateServer(void);
    virtual HRESULT AcceptConnection(DbgRpcTransport** ClientTrans,
                                     PSTR Identity);

    virtual HRESULT ConnectServer(void);

    virtual ULONG Read(ULONG Seq, PVOID Buffer, ULONG Len);
    virtual ULONG Write(ULONG Seq, PVOID Buffer, ULONG Len);

    ULONG m_AcceptChannel;
    ULONG m_StreamChannel;
    HANDLE m_Handle;
};

class DbgRpcComTransport : public DbgRpcTransport
{
public:
    DbgRpcComTransport(void)
    {
        m_Name = g_DbgRpcTransportNames[TRANS_COM];
        m_Handle = NULL;
        ZeroMemory(&m_ReadOlap, sizeof(m_ReadOlap));
        ZeroMemory(&m_WriteOlap, sizeof(m_WriteOlap));
    }
    virtual ~DbgRpcComTransport(void);

    // DbgRpcTransport.
    virtual ULONG GetNumberParameters(void);
    virtual void GetParameter(ULONG Index, PSTR Name, PSTR Value);

    virtual void ResetParameters(void);
    virtual BOOL SetParameter(PCSTR Name, PCSTR Value);

    virtual DbgRpcTransport* Clone(void);

    virtual HRESULT CreateServer(void);
    virtual HRESULT AcceptConnection(DbgRpcTransport** ClientTrans,
                                     PSTR Identity);

    virtual HRESULT ConnectServer(void);

    virtual ULONG Read(ULONG Seq, PVOID Buffer, ULONG Len);
    virtual ULONG Write(ULONG Seq, PVOID Buffer, ULONG Len);

    USHORT ScanQueue(UCHAR Chan, PVOID Buffer, USHORT Len);
    USHORT ScanPort(UCHAR Chan, PVOID Buffer, USHORT Len,
                    BOOL ScanForAck, UCHAR AckChan);
    USHORT ChanRead(UCHAR Chan, PVOID Buffer, USHORT Len);
    USHORT ChanWrite(UCHAR Chan, PVOID Buffer, USHORT Len);

    char m_PortName[MAX_PARAM_VALUE];
    ULONG m_BaudRate;
    UCHAR m_AcceptChannel;
    UCHAR m_StreamChannel;
    HANDLE m_Handle;
    OVERLAPPED m_ReadOlap, m_WriteOlap;

    static HRESULT InitializeChannels(void);
    
    static BOOL s_ChanInitialized;
    static CRITICAL_SECTION s_QueueLock;
    static HANDLE s_QueueChangedEvent;
    static LONG s_PortReadOwned;
    static CRITICAL_SECTION s_PortWriteLock;
    static CRITICAL_SECTION s_WriteAckLock;
    static HANDLE s_WriteAckEvent;
    static struct DbgRpcComQueue* s_QueueHead;
    static struct DbgRpcComQueue* s_QueueTail;
};

//----------------------------------------------------------------------------
//
// DbgRpcConnection.
//
//----------------------------------------------------------------------------

// Special value indicating no data was actually allocated.
// NULL is not used to make it easy to catch access.
#define DBGRPC_NO_DATA ((PUCHAR)(ULONG64)-1)

#define DBGRPC_CONN_BUFFER_SIZE 4096
#define DBGRPC_CONN_BUFFER_ALIGN 16
#define DBGRPC_CONN_BUFFER_DYNAMIC_LIMIT 1024

#define DBGRPC_IN_ASYNC_CALL       0x00000001
#define DBGRPC_FULL_REMOTE_UNKNOWN 0x00000002

class DbgRpcConnection
{
public:
    DbgRpcConnection(class DbgRpcTransport* Trans);
    ~DbgRpcConnection(void);
    
    PUCHAR StartCall(DbgRpcCall* Call, DbgRpcObjectId ObjectId,
                     ULONG StubIndex, ULONG InSize, ULONG OutSize);
    HRESULT SendReceive(DbgRpcCall* Call, PUCHAR* InOutData);
    void FreeData(PUCHAR Data)
    {
        if (Data != NULL && Data != DBGRPC_NO_DATA)
        {
            Free(Data);
        }
    }

    PVOID MallocAligned(ULONG Size);
    void FreeAligned(PVOID Ptr);
    PVOID Alloc(ULONG Size);
    void Free(PVOID Ptr);

    void Disconnect(void);
    
    class DbgRpcTransport* m_Trans;
    DbgRpcConnection* m_Next;
    ULONG m_ThreadId;
    UCHAR m_UnalignedBuffer[DBGRPC_CONN_BUFFER_SIZE +
                            DBGRPC_CONN_BUFFER_ALIGN];
    PUCHAR m_Buffer;
    ULONG m_BufferUsed;
    ULONG m_Flags;
    ULONG m_Objects;
};

//----------------------------------------------------------------------------
//
// DbgRpcProxy.
//
//----------------------------------------------------------------------------

class DbgRpcProxy
{
public:
    DbgRpcProxy(ULONG InterfaceIndex);
    ~DbgRpcProxy(void);

    IUnknown* InitializeProxy(DbgRpcObjectId ObjectId,
                              IUnknown* ExistingProxy);

    DbgRpcObjectId m_ObjectId;
    ULONG m_InterfaceIndex;
    ULONG m_OwningThread;
    ULONG m_LocalRefs, m_RemoteRefs;
};

//----------------------------------------------------------------------------
//
// DbgRpcClientObject.
//
//----------------------------------------------------------------------------

class DbgRpcClientObject
{
public:
    virtual HRESULT Initialize(PSTR Identity, PVOID* Interface) = 0;
    // Base implementation does nothing.
    virtual void    Finalize(void);
    virtual void    Uninitialize(void) = 0;
};

//----------------------------------------------------------------------------
//
// DbgRpcClientObjectFactory.
//
//----------------------------------------------------------------------------

class DbgRpcClientObjectFactory
{
public:
    virtual HRESULT CreateInstance(const GUID* DesiredObject,
                                   DbgRpcClientObject** Object) = 0;
    virtual void GetServerTypeName(PSTR Buffer) = 0;
};

#define DBGRPC_SIMPLE_FACTORY(Class, Guid, Name, CtorArgs)                    \
class Class##Factory : public DbgRpcClientObjectFactory                       \
{                                                                             \
public:                                                                       \
    virtual HRESULT CreateInstance(const GUID* DesiredObject,                 \
                                   DbgRpcClientObject** Object);              \
    virtual void GetServerTypeName(PSTR Buffer);                              \
};                                                                            \
HRESULT                                                                       \
Class##Factory::CreateInstance(const GUID* DesiredObject,                     \
                               DbgRpcClientObject** Object)                   \
{                                                                             \
    if (DbgIsEqualIID(Guid, *DesiredObject))                                  \
    {                                                                         \
        *Object = (DbgRpcClientObject*)new Class CtorArgs;                    \
        return *Object != NULL ? S_OK : E_OUTOFMEMORY;                        \
    }                                                                         \
    else                                                                      \
    {                                                                         \
        return E_NOINTERFACE;                                                 \
    }                                                                         \
}                                                                             \
void                                                                          \
Class##Factory::GetServerTypeName(PSTR Buffer)                                \
{                                                                             \
    strcpy(Buffer, Name);                                                     \
}

//----------------------------------------------------------------------------
//
// Functions.
//
//----------------------------------------------------------------------------

DbgRpcTransport*
DbgRpcNewTransport(ULONG Trans);
DbgRpcTransport*
DbgRpcInitializeTransport(PCSTR Options);

void
DbgRpcDeregisterServers(void);
HRESULT
DbgRpcCreateServerConnection(DbgRpcTransport* Trans,
                             const GUID* DesiredObject,
                             IUnknown** ClientObject);
HRESULT
DbgRpcCreateServer(PCSTR Options, DbgRpcClientObjectFactory* Factory);
HRESULT
DbgRpcConnectServer(PCSTR Options, const GUID* DesiredObject,
                    IUnknown** ClientObject);

DbgRpcConnection*
DbgRpcGetConnection(ULONG ThreadId);

#define DRPC_ERR(Args) g_NtDllCalls.DbgPrint Args

#if 0
#define DBG_RPC
#define DRPC(Args) g_NtDllCalls.DbgPrint Args
#else
#define DRPC(Args)
#endif

#if 0
#define DRPC_REF(Args) g_NtDllCalls.DbgPrint Args
#else
#define DRPC_REF(Args)
#endif

#endif // #ifndef __DBGRPC_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\dbgrpc\dbgrpc.cpp ===
//----------------------------------------------------------------------------
//
// Remoting support.
//
// Copyright (C) Microsoft Corporation, 1999-2001.
//
//----------------------------------------------------------------------------

#include "pch.hpp"

#include <lmcons.h>

#define DBGRPC_SIGNATURE 'CPRD'
#define DBGRPC_PROTOCOL_VERSION 2

enum
{
    SEQ_HANDSHAKE = 0xffff0000,
    SEQ_IDENTITY,
    SEQ_PASSWORD,
    SEQ_CALL_HEADER,
};

#define DBGRPC_SHAKE_FULL_REMOTE_UNKNOWN 0x00000001

struct DbgRpcHandshake
{
    ULONG Signature;
    ULONG ProtocolVersion;
    GUID DesiredObject;
    DbgRpcObjectId RemoteObject;
    ULONG IdentityLength;
    ULONG PasswordLength;
    ULONG Flags;
    ULONG Reserved1;
    ULONG64 Reserved2[10];
};

ULONG g_DbgRpcCallSequence;

CRITICAL_SECTION g_DbgRpcLock;

#define CreateUserThread(Start, Param, Tid) \
    CreateThread(NULL, 0, Start, Param, 0, Tid)
#ifdef NT_NATIVE
#define ExitUserThread(Code) RtlExitUserThread(Code)
#else
#define ExitUserThread(Code) return Code
#endif

//----------------------------------------------------------------------------
//
// DbgRpcReceiveCalls.
//
//----------------------------------------------------------------------------

HRESULT
DbgRpcReceiveCalls(DbgRpcConnection* Conn, DbgRpcCall* Call, PUCHAR* InOutData)
{
    HRESULT Status;
    ULONG RetSeq = Call->Sequence;

    DBG_ASSERT((Call->Flags & DBGRPC_RETURN) == 0 &&
               *InOutData == NULL);

    // If this thread isn't the owner of the connection we
    // cannot read the socket as that could create a
    // race condition with the owner thread reading
    // the socket.
    // If this is a locked call, where a higher-level lock
    // prevents socket contention, we can allow it.
    if ((Call->Flags & DBGRPC_LOCKED) == 0 &&
        Conn->m_ThreadId != GetCurrentThreadId())
    {
        return RPC_E_WRONG_THREAD;
    }

    for (;;)
    {
        DbgRpcCall ReadCall;

        if (Conn->m_Trans->Read(SEQ_CALL_HEADER, &ReadCall,
                                sizeof(ReadCall)) != sizeof(ReadCall))
        {
            DRPC_ERR(("%X: Unable to receive call header\n",
                      GetCurrentThreadId()));
            return RPC_E_CLIENT_DIED;
        }

        ULONG Size;
        PUCHAR Data;

        if (ReadCall.Flags & DBGRPC_RETURN)
        {
            Size = ReadCall.OutSize;
        }
        else
        {
            Size = ReadCall.InSize;
            ReadCall.Status = S_OK;
        }

        if (Size > 0)
        {
            Data = (PUCHAR)Conn->Alloc(Size);
            if (Data == NULL)
            {
                DRPC_ERR(("%X: Unable to allocate call body\n",
                          GetCurrentThreadId()));
                return E_OUTOFMEMORY;
            }

            if (Conn->m_Trans->Read(ReadCall.Sequence, Data, Size) != Size)
            {
                DRPC_ERR(("%X: Unable to receive call body\n",
                          GetCurrentThreadId()));
                Conn->Free(Data);
                return RPC_E_CLIENT_DIED;
            }
        }
        else
        {
            Data = NULL;
        }

#ifdef DBG_RPC
        if (ReadCall.Flags & DBGRPC_RETURN)
        {
            DRPC(("%X: %X: Return %s (%X), ret 0x%X, out %d\n",
                  GetCurrentThreadId(), ReadCall.Sequence,
                  DbgRpcGetStubName(ReadCall.StubIndex),
                  ReadCall.StubIndex, ReadCall.Status, ReadCall.OutSize));
        }
        else
        {
            DRPC(("%X: %X: Request %s (%X), fl %X, in %d\n",
                  GetCurrentThreadId(), ReadCall.Sequence,
                  DbgRpcGetStubName(ReadCall.StubIndex),
                  ReadCall.StubIndex, ReadCall.Flags, ReadCall.InSize));
        }
#endif

        if (ReadCall.Flags & DBGRPC_RETURN)
        {
            if (ReadCall.Sequence != RetSeq)
            {
#if DBG
                DRPC_ERR(("%X: %X: Non-seq ret 0x%X for %s (%X)\n",
                          GetCurrentThreadId(), ReadCall.Sequence,
                          ReadCall.Status,
                          DbgRpcGetStubName(ReadCall.StubIndex),
                          ReadCall.StubIndex));
#else
                DRPC_ERR(("%X: %X: Non-seq ret 0x%X for (%X)\n",
                          GetCurrentThreadId(), ReadCall.Sequence,
                          ReadCall.Status, ReadCall.StubIndex));
#endif
                // This return is for some call other than the current
                // call, which means that RPC is messed up.
                // Discard the return and hope for the best.
                Conn->FreeData(Data);
                continue;
            }

     