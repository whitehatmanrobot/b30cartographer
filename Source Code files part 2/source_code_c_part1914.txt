es_ = FALSE;
#ifdef  SNAP_SHOT
        POLLSTEREOHOTKEY(SaveStereoImage)
        {
            SaveStereoImageFile(pfd);
        }
#endif  //SNAP_SHOT
    }
#ifdef	SHOW_EYES
	CNvObject *pObj = GET_PNVOBJ(pfd->lpSurfTarg);
	if (!pObj) 
		return;
	pFrontSurf		= pObj->getSimpleSurface();
#endif	//SHOW_EYES
}

//**********************************************************************************************
/*
 * VertexRegister interfaces
 */

CVertexRegister::CVertexRegister(DWORD dwNumVertices)
{
    m_dwStage = FIRST_EYE;
    m_dwVertexCount = 0;
    m_dwInUseSize = (dwNumVertices + 7) >> 3;

    if (!(m_VertexStorage_Flip = (LPPERVERTEXSTORAGE_FLIP)AllocIPM(dwNumVertices*sizeof(PERVERTEXSTORAGE_FLIP)+m_dwInUseSize)))
    {
        return;
    }
    m_pInUse = (LPBYTE)(m_VertexStorage_Flip + dwNumVertices);
    return;
}

CVertexRegister::~CVertexRegister(void)
{
    FreeIPM(m_VertexStorage_Flip);
}

BOOL CVertexRegister::isInUse(DWORD dwVertex)
{
    DWORD Base = (DWORD)m_pInUse;
    BOOL  res;
    _asm {
        mov  edx, Base
        xor  eax, eax
        mov  ecx, dwVertex
        bt   [edx], ecx
        setc al
        mov  res, eax
    }
    return res;
}

BOOL CVertexRegister::isInUseTag(DWORD dwVertex)
{
    DWORD Base = (DWORD)m_pInUse;
    BOOL  res;
    _asm {
        mov  edx, Base
        xor  eax, eax
        mov  ecx, dwVertex
        bts  [edx], ecx
        setc al
        mov  res, eax
    }
    return res;
}

/************************************************************************************************************
 * Next function behaviour is based on the current stage. If stage is FIRST_EYE the function does nothing
 * and report that. The caller is responsible to fill out the m_VertexStorage_Flip and next time the DoAutomaticStage
 * will take care of everything automatically.
 ************************************************************************************************************/

DWORD CVertexRegister::DoAutomaticStage_Flip(void)
{
    DWORD                   RetVal = 0;
    DWORD                   i;
    LPPERVERTEXSTORAGE_FLIP pSrc;
    LPD3DVALUE              pDest;

    if (m_dwStage != FIRST_EYE)
    {
        //m_VertexStorage_Flip is valid. We can handle this case ourselves.
        RetVal = 1;
        pSrc = m_VertexStorage_Flip;
        if (m_dwStage == RESTORE)
        {
#ifdef  LASER_SIGHT
            if (pStereoData->StereoSettings.dwFlags & STEREO_LASERGETRHWSCALE)
            {
                if (m_dwVertexCount >= 2 && pSrc->pVertex[2] != (pSrc+1)->pVertex[2])
                {
                    LaserSZBase = pSrc->pVertex[2];
                    LaserRHWBase = pSrc->pVertex[3];
                    LaserRHWScale = (LaserRHWBase - (pSrc+1)->pVertex[3])/(LaserSZBase - (pSrc+1)->pVertex[2]);
                    pStereoData->StereoSettings.dwFlags &= ~STEREO_LASERGETRHWSCALE;
                }
            }
#endif  //LASER_SIGHT
            for (i = 0; i < m_dwVertexCount; i++, pSrc++)
            {
                pDest = pSrc->pVertex;
                pDest[0] = pSrc->OrigX;
            }
        } else
        {
            if (pStereoData->dwLastEye == EYE_LEFT)
            {
                //First eye was right
                for (i = 0; i < m_dwVertexCount; i++, pSrc++)
                {
                    pDest = pSrc->pVertex;
                    pDest[0] = pDest[0] - pSrc->XCorrection - pSrc->XCorrection;
                }
            } else
            {
                //First eye was left
                for (i = 0; i < m_dwVertexCount; i++, pSrc++)
                {
                    pDest = pSrc->pVertex;
                    pDest[0] = pDest[0] + pSrc->XCorrection + pSrc->XCorrection;
                }
            }
        }
    } else
        m_dwVertexCount = 0;
    UpdateStage();
    return RetVal;
}

#ifdef  PER_PRIMITIVE_SYNC
void StereoSync(void)
{
	if (!STEREO_ACTIVATED)
		return;

#ifdef	SHOW_EYES
	if (pFrontSurf)
	{
		ShowEyes();
	}
#endif	//SHOW_EYES

    WaitForIdle (TRUE,FALSE);

#ifdef	SHOW_EYES
	__asm int 3
#endif	//SHOW_EYES
}
#endif  //PER_PRIMITIVE_SYNC

#ifdef  PARTIALRENDERING
DWORD PrimitiveStat[5] = {0, 0, 0, 0x10000000, 0x10000000};
#endif  //PARTIALRENDERING

/*********************************************************************************
 * Below are the Stereo DP2 handlers and Stereo Eye Image calculation functions
 * for all possible cases. The all use the same template defined in the StereoFunc_i.cpp.
 * Particular implementation nuances are specified by the special defines.
 *********************************************************************************/

/*********************************************************************************
 * D3DDP2OP_POINTS
 *********************************************************************************/
#define POINT
#define STEREO_EYE_FUNCTION_FLIP    nvDP2Points_StereoEye_Flip
#define STEREO_DP2_FUNCTION_FLIP    nvDP2Points_Stereo_Flip

#include "StereoFunc_i.cpp"

/*********************************************************************************
 * D3DDP2OP_INDEXEDLINELIST
 *********************************************************************************/
#define STEREO_EYE_FUNCTION_FLIP    nvDP2IndexedLineList_StereoEye_Flip
#define STEREO_DP2_FUNCTION_FLIP    nvDP2IndexedLineList_Stereo_Flip
#define CHECK_RHW_CONDITION         nvDP2IndexedLineList_Check_RHW
#define INDEX
#define LINE

#include "StereoFunc_i.cpp"

/*********************************************************************************
 * D3DDP2OP_INDEXEDTRIANGLELIST
 *********************************************************************************/
#define STEREO_EYE_FUNCTION_FLIP    nvDP2IndexedTriangleList_StereoEye_Flip
#define STEREO_DP2_FUNCTION_FLIP    nvDP2IndexedTriangleList_Stereo_Flip
#define CHECK_RHW_CONDITION         nvDP2IndexedTriangleList_Check_RHW
#define INDEX

#include "StereoFunc_i.cpp"

/*********************************************************************************
 * D3DDP2OP_LINELIST
 *********************************************************************************/
#define STEREO_EYE_FUNCTION_FLIP    nvDP2LineList_StereoEye_Flip
#define STEREO_DP2_FUNCTION_FLIP    nvDP2LineList_Stereo_Flip
#define CHECK_RHW_CONDITION         nvDP2LineList_Check_RHW
#define LINE
#define START_VERTEX

#include "StereoFunc_i.cpp"

/*********************************************************************************
 * D3DDP2OP_LINESTRIP
 *********************************************************************************/
#define STEREO_EYE_FUNCTION_FLIP    nvDP2LineStrip_StereoEye_Flip
#define STEREO_DP2_FUNCTION_FLIP    nvDP2LineStrip_Stereo_Flip
#define CHECK_RHW_CONDITION         nvDP2LineStrip_Check_RHW
#define LINE
#define START_VERTEX
#define STRIP

#include "StereoFunc_i.cpp"

/*********************************************************************************
 * D3DDP2OP_INDEXEDLINESTRIP
 *********************************************************************************/
#define NOT_IMPLEMENTED
#define STEREO_EYE_FUNCTION_FLIP    nvDP2IndexedLineStrip_StereoEye_Flip
#define STEREO_DP2_FUNCTION_FLIP    nvDP2IndexedLineStrip_Stereo_Flip
#define CHECK_RHW_CONDITION         nvDP2IndexedLineStrip_Check_RHW
#define INDEX

#include "StereoFunc_i.cpp"

/*********************************************************************************
 * D3DDP2OP_TRIANGLELIST
 *********************************************************************************/
#define STEREO_EYE_FUNCTION_FLIP    nvDP2TriangleList_StereoEye_Flip
#define STEREO_DP2_FUNCTION_FLIP    nvDP2TriangleList_Stereo_Flip
#define CHECK_RHW_CONDITION         nvDP2TriangleList_Check_RHW

#include "StereoFunc_i.cpp"

/*********************************************************************************
 * D3DDP2OP_TRIANGLESTRIP
 *********************************************************************************/
#define STEREO_EYE_FUNCTION_FLIP    nvDP2TriangleStrip_StereoEye_Flip
#define STEREO_DP2_FUNCTION_FLIP    nvDP2TriangleStrip_Stereo_Flip
#define CHECK_RHW_CONDITION         nvDP2TriangleStrip_Check_RHW
#define STRIP
#define START_VERTEX

#include "StereoFunc_i.cpp"

/*********************************************************************************
 * D3DDP2OP_INDEXEDTRIANGLESTRIP
 *********************************************************************************/
#define STEREO_EYE_FUNCTION_FLIP    nvDP2IndexedTriangleStrip_StereoEye_Flip
#define STEREO_DP2_FUNCTION_FLIP    nvDP2IndexedTriangleStrip_Stereo_Flip
#define CHECK_RHW_CONDITION         nvDP2IndexedTriangleStrip_Check_RHW
#define INDEX
#define START_VERTEX
#define STRIP

#include "StereoFunc_i.cpp"

/*********************************************************************************
 * D3DDP2OP_TRIANGLEFAN
 *********************************************************************************/
#define STEREO_EYE_FUNCTION_FLIP    nvDP2TriangleFan_StereoEye_Flip
#define STEREO_DP2_FUNCTION_FLIP    nvDP2TriangleFan_Stereo_Flip
#define CHECK_RHW_CONDITION         nvDP2TriangleFan_Check_RHW
#define FAN
#define START_VERTEX

#include "StereoFunc_i.cpp"

/*********************************************************************************
 * D3DDP2OP_INDEXEDTRIANGLEFAN
 *********************************************************************************/
#define STEREO_EYE_FUNCTION_FLIP    nvDP2IndexedTriangleFan_StereoEye_Flip
#define STEREO_DP2_FUNCTION_FLIP    nvDP2IndexedTriangleFan_Stereo_Flip
#define CHECK_RHW_CONDITION         nvDP2IndexedTriangleFan_Check_RHW
#define INDEX
#define START_VERTEX
#define FAN

#include "StereoFunc_i.cpp"

/*********************************************************************************
 * D3DDP2OP_TRIANGLEFAN_IMM
 *********************************************************************************/
#define STEREO_EYE_FUNCTION_FLIP    nvDP2TriangleFanImm_StereoEye_Flip
#define STEREO_DP2_FUNCTION_FLIP    nvDP2TriangleFanImm_Stereo_Flip
#define CHECK_RHW_CONDITION         nvDP2TriangleFanImm_Check_RHW
#define FAN
#define ADVANCE                 D3DHAL_DP2TRIANGLEFAN_IMM
#define ALIGN

#include "StereoFunc_i.cpp"

/*********************************************************************************
 * D3DDP2OP_LINELIST_IMM
 *********************************************************************************/
#define NOT_IMPLEMENTED
#define STEREO_EYE_FUNCTION_FLIP    nvDP2LineListImm_StereoEye_Flip
#define STEREO_DP2_FUNCTION_FLIP    nvDP2LineListImm_Stereo_Flip
#define CHECK_RHW_CONDITION         nvDP2LineListImm_Check_RHW

#include "StereoFunc_i.cpp"

/*********************************************************************************
 * D3DDP2OP_INDEXEDTRIANGLELIST2
 *********************************************************************************/
#define STEREO_EYE_FUNCTION_FLIP    nvDP2IndexedTriangleList2_StereoEye_Flip
#define STEREO_DP2_FUNCTION_FLIP    nvDP2IndexedTriangleList2_Stereo_Flip
#define CHECK_RHW_CONDITION         nvDP2IndexedTriangleList2_Check_RHW
#define INDEX2
#define START_VERTEX

#include "StereoFunc_i.cpp"

/*********************************************************************************
 * D3DDP2OP_INDEXEDLINELIST2
 *********************************************************************************/
#define STEREO_EYE_FUNCTION_FLIP    nvDP2IndexedLineList2_StereoEye_Flip
#define STEREO_DP2_FUNCTION_FLIP    nvDP2IndexedLineList2_Stereo_Flip
#define CHECK_RHW_CONDITION         nvDP2IndexedLineList2_Check_RHW
#define INDEX
#define START_VERTEX
#define LINE

#include "StereoFunc_i.cpp"

/*********************************************************************************
 * D3DDP2OP_CLEAR
 *********************************************************************************/
HRESULT nvDP2Clear_Stereo_Flip (NV_DP2FUNCTION_ARGLIST)
{
    HRESULT RetVal;
    LPD3DHAL_DP2CLEAR   pDp2ClearData = (LPD3DHAL_DP2CLEAR)((*ppCommands)+1);
    LPD3DHAL_DP2COMMAND pSaveCommandsPtr = *ppCommands;

    StereoLockSubstituteFlush();

#ifdef  PARTIALRENDERING
    PrimitiveStat[0] = PrimitiveStat[1];
    PrimitiveStat[1] = 0;
    pDp2ClearData->dwFlags |= D3DCLEAR_TARGET;
    pDp2ClearData->dwFillColor = 0; //very very black
#endif  //PARTIALRENDERING

#ifdef  PER_PRIMITIVE_SYNC
    DWORD   dwFlags, dwFillColor;   //To save originals
    dwFlags = pDp2ClearData->dwFlags;
    pDp2ClearData->dwFlags |= D3DCLEAR_TARGET;
    dwFillColor = pDp2ClearData->dwFillColor;
    pDp2ClearData->dwFillColor = 0; //very very black
    SetupStereoContext(pContext);
    RetVal = (*(nvDP2SetFuncs_Orig[D3DDP2OP_CLEAR]))(pContext,
                                                     ppCommands,
                                                     pCommandBufferEnd,
                                                     pdwDP2RStates,
                                                     dwDP2Flags);
    StereoSync();
#ifndef ONE_EYE
    AlternateStereoContext(pContext);
#ifndef NULL_RIGHT_EYE_
    //Switch to the other eye and clear once again
    *ppCommands = pSaveCommandsPtr; //Restore it for the second pass.
    RetVal = (*(nvDP2SetFuncs_Orig[D3DDP2OP_CLEAR]))(pContext,
                                                     ppCommands,
                                                     pCommandBufferEnd,
                                                     pdwDP2RStates,
                                                     dwDP2Flags);
    StereoSync();
#endif  //NULL_RIGHT_EYE
#endif  //ONE_EYE
    pDp2ClearData->dwFlags = dwFlags;
    pDp2ClearData->dwFillColor = dwFillColor;
    return RetVal;
#else   //PER_PRIMITIVE_SYNC

    if (pStereoData->StereoSettings.PartialClearMode == DO_A_FULL_CLEAR)
    {
        LPRECT pRect = pDp2ClearData->Rects;
        LPDDHALMODEINFO lpModeInfo = &pDriverData->ModeList[pDXShare->dwModeNumber];
        pRect->top = 0;
        pRect->left = 0;
        pRect->right = lpModeInfo->dwWidth;
        pRect->bottom = lpModeInfo->dwHeight;
    }

#ifdef  DEBUG
#if 0
    nvAssert ((*ppCommands)->wPrimitiveCount == 1);
    LPRECT pRect = pDp2ClearData->Rects;
    LPDDHALMODEINFO lpModeInfo = &pDriverData->ModeList[pDXShare->dwModeNumber];
    if (pRect->top || pRect->left || (DWORD)pRect->bottom != lpModeInfo->dwHeight
       || (DWORD)pRect->right != lpModeInfo->dwWidth)
        nvAssert(0);
    {
        pRect->top = 0;
        pRect->left = 0;
        pRect->right = lpModeInfo->dwWidth;
        pRect->bottom = lpModeInfo->dwHeight;
    }
#endif
#endif  //DEBUG

    SetupStereoContext(pContext);
    RetVal = (*(nvDP2SetFuncs_Orig[D3DDP2OP_CLEAR]))(pContext,
                                                     ppCommands,
                                                     pCommandBufferEnd,
                                                     pdwDP2RStates,
                                                     dwDP2Flags);
    *ppCommands = pSaveCommandsPtr; //Restore it for the second pass.
    //Switch to the other eye and clear once again
    AlternateStereoContext(pContext);
    RetVal = (*(nvDP2SetFuncs_Orig[D3DDP2OP_CLEAR]))(pContext,
                                                     ppCommands,
                                                     pCommandBufferEnd,
                                                     pdwDP2RStates,
                                                     dwDP2Flags);
#if 0
    WaitForIdle (TRUE,FALSE);
#endif
    return RetVal;
#endif  //PER_PRIMITIVE_SYNC
}

typedef struct PrimTypeToStereoDP2_S 
{
	PSTEREOEYEFUNC      pStereoEyeFunc;
	PSTEREORHWFUNC      pStereoRHWFunc;
} PRIMTYPETOSTEREODP2, *LPPRIMTYPETOSTEREODP2;

typedef struct PrimTypeToStereoDP2Index_S 
{
	PSTEREOEYEFUNCINDEX pStereoEyeFuncIndex;
	PSTEREORHWFUNCINDEX pStereoRHWFuncIndex;
} PRIMTYPETOSTEREODP2INDEX, *LPPRIMTYPETOSTEREODP2INDEX;

PRIMTYPETOSTEREODP2 PrimTypeToStereoDP2[] = {
	{ NULL,											NULL },
	{ nvDP2Points_StereoEye_Flip,					NULL },
	{ nvDP2LineList_StereoEye_Flip,					nvDP2LineList_Check_RHW },
	{ nvDP2LineStrip_StereoEye_Flip,				nvDP2LineStrip_Check_RHW },
	{ nvDP2TriangleList_StereoEye_Flip,				nvDP2TriangleList_Check_RHW },
	{ nvDP2TriangleStrip_StereoEye_Flip,			nvDP2TriangleStrip_Check_RHW },
	{ nvDP2TriangleFan_StereoEye_Flip,				nvDP2TriangleFan_Check_RHW }
};

PRIMTYPETOSTEREODP2INDEX PrimTypeToStereoDP2Index[] = {
	{ NULL,											NULL },
	{ (PSTEREOEYEFUNCINDEX)nvDP2Points_StereoEye_Flip,					NULL },
	{ nvDP2IndexedLineList_StereoEye_Flip,			nvDP2IndexedLineList_Check_RHW },
	{ nvDP2IndexedLineStrip_StereoEye_Flip,			nvDP2IndexedLineStrip_Check_RHW },
	{ nvDP2IndexedTriangleList2_StereoEye_Flip,		nvDP2IndexedTriangleList2_Check_RHW },
	{ nvDP2IndexedTriangleStrip_StereoEye_Flip,		nvDP2IndexedTriangleStrip_Check_RHW },
	{ nvDP2IndexedTriangleFan_StereoEye_Flip,		nvDP2IndexedTriangleFan_Check_RHW }
};

/*********************************************************************************
 * D3DDP2OP_DRAWPRIMITIVE
 *********************************************************************************/
#define DRAWPRIMITIVE
#define STEREO_EYE_FUNCTION_FLIP    nvDP2DrawPrimitive_StereoEye_Flip
#define STEREO_DP2_FUNCTION_FLIP    nvDP2DrawPrimitive_Stereo_Flip
#define CHECK_RHW_CONDITION         nvDP2DrawPrimitive_Check_RHW
#define START_VERTEX

#include "StereoFunc_i.cpp"

/*********************************************************************************
 * D3DDP2OP_DRAWINDEXEDPRIMITIVE
 *********************************************************************************/
#define DRAWPRIMITIVE
#define STEREO_EYE_FUNCTION_FLIP    nvDP2DrawIndexedPrimitive_StereoEye_Flip
#define STEREO_DP2_FUNCTION_FLIP    nvDP2DrawIndexedPrimitive_Stereo_Flip
#define CHECK_RHW_CONDITION         nvDP2DrawIndexedPrimitive_Check_RHW
#define INDEX
#define START_VERTEX

#include "StereoFunc_i.cpp"

/*********************************************************************************
 * D3DNTDP2OP_CLIPPEDTRIANGLEFAN
 *********************************************************************************/
#define NOT_IMPLEMENTED
#define STEREO_EYE_FUNCTION_FLIP    nvDP2ClippedTriangleFan_StereoEye_Flip
#define STEREO_DP2_FUNCTION_FLIP    nvDP2ClippedTriangleFan_Stereo_Flip
#define CHECK_RHW_CONDITION         nvDP2ClippedTriangleFan_Check_RHW
#define START_VERTEX

#include "StereoFunc_i.cpp"

/*********************************************************************************
 * D3DDP2OP_DRAWPRIMITIVE2
 *********************************************************************************/
#define DRAWPRIMITIVE
#define STEREO_EYE_FUNCTION_FLIP    nvDP2DrawPrimitive2_StereoEye_Flip
#define STEREO_DP2_FUNCTION_FLIP    nvDP2DrawPrimitive2_Stereo_Flip
#define CHECK_RHW_CONDITION         nvDP2DrawPrimitive2_Check_RHW

#include "StereoFunc_i.cpp"

/*********************************************************************************
 * D3DDP2OP_DRAWINDEXEDPRIMITIVE2
 *********************************************************************************/
#define DRAWPRIMITIVE
#define STEREO_EYE_FUNCTION_FLIP    nvDP2DrawIndexedPrimitive2_StereoEye_Flip
#define STEREO_DP2_FUNCTION_FLIP    nvDP2DrawIndexedPrimitive2_Stereo_Flip
#define CHECK_RHW_CONDITION         nvDP2DrawIndexedPrimitive2_Check_RHW
#define INDEX

#include "StereoFunc_i.cpp"

/*********************************************************************************
 * D3DNTDP2OP_DRAWRECTSURFACE
 *********************************************************************************/
#define NOT_IMPLEMENTED
#define STEREO_EYE_FUNCTION_FLIP    nvDP2DrawRectSurface_StereoEye_Flip
#define STEREO_DP2_FUNCTION_FLIP    nvDP2DrawRectSurface_Stereo_Flip
#define CHECK_RHW_CONDITION         nvDP2DrawRectSurface_Check_RHW
#define START_VERTEX

#include "StereoFunc_i.cpp"

/*********************************************************************************
 * D3DNTDP2OP_DRAWTRISURFACE
 *********************************************************************************/
#define NOT_IMPLEMENTED
#define STEREO_EYE_FUNCTION_FLIP    nvDP2DrawTriSurface_StereoEye_Flip
#define STEREO_DP2_FUNCTION_FLIP    nvDP2DrawTriSurface_Stereo_Flip
#define CHECK_RHW_CONDITION         nvDP2DrawTriSurface_Check_RHW
#define START_VERTEX

#include "StereoFunc_i.cpp"

nvDP2FunctionTable nvDP2SetFuncs_Stereo_Flip =
{
    NULL,                                   //   0  invalid
    nvDP2Points_Stereo_Flip,                //   1  D3DDP2OP_POINTS
    nvDP2IndexedLineList_Stereo_Flip,       //   2  D3DDP2OP_INDEXEDLINELIST
    nvDP2IndexedTriangleList_Stereo_Flip,   //   3  D3DDP2OP_INDEXEDTRIANGLELIST
    NULL,                                   //   4  invalid
    NULL,                                   //   5  invalid
    NULL,                                   //   6  invalid
    NULL,                                   //   7  invalid
    NULL,                                   //   8  D3DDP2OP_RENDERSTATE
    NULL,                                   //   9  invalid
    NULL,                                   //  10  invalid
    NULL,                                   //  11  invalid
    NULL,                                   //  12  invalid
    NULL,                                   //  13  invalid
    NULL,                                   //  14  invalid
    nvDP2LineList_Stereo_Flip,              //  15  D3DDP2OP_LINELIST
    nvDP2LineStrip_Stereo_Flip,             //  16  D3DDP2OP_LINESTRIP
    nvDP2IndexedLineStrip_Stereo_Flip,      //  17  D3DDP2OP_INDEXEDLINESTRIP
    nvDP2TriangleList_Stereo_Flip,          //  18  D3DDP2OP_TRIANGLELIST
    nvDP2TriangleStrip_Stereo_Flip,         //  19  D3DDP2OP_TRIANGLESTRIP
    nvDP2IndexedTriangleStrip_Stereo_Flip,  //  20  D3DDP2OP_INDEXEDTRIANGLESTRIP
    nvDP2TriangleFan_Stereo_Flip,           //  21  D3DDP2OP_TRIANGLEFAN
    nvDP2IndexedTriangleFan_Stereo_Flip,    //  22  D3DDP2OP_INDEXEDTRIANGLEFAN
    nvDP2TriangleFanImm_Stereo_Flip,        //  23  D3DDP2OP_TRIANGLEFAN_IMM
    nvDP2LineListImm_Stereo_Flip,           //  24  D3DDP2OP_LINELIST_IMM
    NULL,                                   //  25  D3DDP2OP_TEXTURESTAGESTATE
    nvDP2IndexedTriangleList2_Stereo_Flip,  //  26  D3DDP2OP_INDEXEDTRIANGLELIST2
    nvDP2IndexedLineList2_Stereo_Flip,      //  27  D3DDP2OP_INDEXEDLINELIST2
    NULL,                                   //  28  D3DDP2OP_VIEWPORTINFO
    NULL,                                   //  29  D3DDP2OP_WINFO
    NULL,                                   //  30  D3DDP2OP_SETPALETTE
    NULL,                                   //  31  D3DDP2OP_UPDATEPALETTE
    NULL,                                   //  32  D3DDP2OP_ZRANGE
    NULL,                                   //  33  D3DDP2OP_SETMATERIAL
    NULL,                                   //  34  D3DDP2OP_SETLIGHT
    NULL,                                   //  35  D3DDP2OP_CREATELIGHT
    NULL,                                   //  36  D3DDP2OP_SETTRANSFORM
    NULL,                                   //  37  D3DDP2OP_EXT
    NULL,                                   //  38  D3DDP2OP_TEXBLT
    NULL,                                   //  39  D3DDP2OP_STATESET
    NULL,                                   //  40  D3DDP2OP_SETPRIORITY
    NULL,                                   //  41  D3DDP2OP_SETRENDERTARGET
    nvDP2Clear_Stereo_Flip,                 //  42  D3DDP2OP_CLEAR
    NULL,                                   //  43  D3DDP2OP_SETTEXLOD
    NULL,                                   //  44  D3DDP2OP_SETCLIPPLANE
    NULL,                                   //  45  D3DDP2OP_CREATEVERTEXSHADER
    NULL,                                   //  46  D3DDP2OP_DELETEVERTEXSHADER
    NULL,                                   //  47  D3DDP2OP_SETVERTEXSHADER
    NULL,                                   //  48  D3DDP2OP_SETVERTEXSHADERCONST
    NULL,                                   //  49  D3DDP2OP_SETSTREAMSOURCE
    NULL,                                   //  50  D3DNTDP2OP_SETSTREAMSOURCEUM
    NULL,                                   //  51  D3DDP2OP_SETINDICES
    nvDP2DrawPrimitive_Stereo_Flip,         //  52  D3DDP2OP_DRAWPRIMITIVE
    nvDP2DrawIndexedPrimitive_Stereo_Flip,  //  53  D3DDP2OP_DRAWINDEXEDPRIMITIVE
    NULL,                                   //  54  D3DDP2OP_CREATEPIXELSHADER
    NULL,                                   //  55  D3DDP2OP_DELETEPIXELSHADER
    NULL,                                   //  56  D3DDP2OP_SETPIXELSHADER
    NULL,                                   //  57  D3DNTDP2OP_SETPIXELSHADERCONST
    nvDP2ClippedTriangleFan_Stereo_Flip,    //  58  D3DNTDP2OP_CLIPPEDTRIANGLEFAN
    nvDP2DrawPrimitive2_Stereo_Flip,        //  59  D3DNTDP2OP_DRAWPRIMITIVE2
    nvDP2DrawIndexedPrimitive2_Stereo_Flip, //  60  D3DNTDP2OP_DRAWINDEXEDPRIMITIVE2
    nvDP2DrawRectSurface_Stereo_Flip,       //  61  D3DNTDP2OP_DRAWRECTSURFACE
    nvDP2DrawTriSurface_Stereo_Flip,        //  62  D3DNTDP2OP_DRAWTRISURFACE
    NULL,                                   //  63  D3DDP2OP_VOLUMEBLT
    NULL,                                   //  64  D3DDP2OP_BUFFERBLT
    NULL
};

nvDP2FunctionTable nvDP2SetFuncs_Orig = {NULL};

#endif  //STEREO_SUPPORT
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\src\nvSurface.cpp ===
//**************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
#include "nvprecomp.h"

//****************************************************************************
//****************************************************************************
//****************************************************************************
//**  CSimpleSurface *********************************************************
//****************************************************************************
//****************************************************************************
//****************************************************************************

// convert from heap location to context dma
DWORD g_adwSurfaceContextDMA[9] =
{
    /* undefined       */ 0,
    /* HEAP_VID = 0x01 */ NV_CONTEXT_DMA_VID,
    /* HEAP_AGP = 0x02 */ NV_CONTEXT_DMA_AGP_OR_PCI,
    /* undefined       */ 0,
    /* HEAP_PCI = 0x04 */ NV_CONTEXT_DMA_AGP_OR_PCI,
    /* undefined       */ 0,
    /* undefined       */ 0,
    /* undefined       */ 0,
    /* HEAP_SYS = 0x08 */ NV_CONTEXT_DMA_NONE
};

// helper function
inline DWORD nvGetOffsetFromLinear(DWORD dwLinearAddress)
{
    NV_CFGEX_GET_AGP_OFFSET_PARAMS addr;

    addr.linaddr = (void*)dwLinearAddress;
    NvRmConfigGetEx(pDriverData->dwRootHandle, NV_WIN_DEVICE, NV_CFGEX_GET_AGP_OFFSET, &addr, sizeof(addr));
    return addr.offset;
}

//****************************************************************************
// CSimpleSurface::isBusy
//

BOOL CSimpleSurface::isBusy (void) const
{
    dbgTracePush ("CSimpleSurface::isBusy");

    // check shadow
    if (getDC()->pRefCount->readShadow() >= m_dwRetireDate) {
        dbgTracePop();
        return FALSE;
    }

    // read HW and recheck
    if (getDC()->pRefCount->read() >= m_dwRetireDate) {
        dbgTracePop();
        return FALSE;
    }

    // return that the surface is busy
    dbgTracePop();
    return TRUE;
}

//****************************************************************************
// CSimpleSurface::reset
//
// surface is lost - tag as such

void CSimpleSurface::reset
(
    void
)
{
    dbgTracePush ("CSimpleSurface[%08x]::reset()",this);
    // disown memory
    disown();
    dbgTracePop();
}

//****************************************************************************
// CSimpleSurface::own
//
// let surface own a piece of memory that is allocated by someone else
//  unless explicitly tagged as a non-owner, the surface will be freed
//  at destroy time.

void CSimpleSurface::own
(
    DWORD dwAddress,
    DWORD dwPitch,
    DWORD dwHeight,
    DWORD dwHeapLocation,
    BOOL  bOwnMemory
)
{
    // tell world
    dbgTracePush ("CSimpleSurface[%08x]::own(dwAddress=%08x,dwPitch=%08x,dwH=%08x,dwHeapLoc=%x,bOwnMem=%d)",
                  this,dwAddress,dwPitch,dwHeight,dwHeapLocation,bOwnMemory);

    // assign
    m_dwAddress    = dwAddress;
    m_dwPitch      = dwPitch;
    m_dwHeight     = dwHeight;
    m_dwFlags     &= ~HEAP_LOCATION_MASK;
    m_dwFlags     |= dwHeapLocation;
    m_dwRetireDate = 0;
    if (bOwnMemory) m_dwFlags &= ~FLAG_DONOTOWNMEMORY;
               else m_dwFlags |= FLAG_DONOTOWNMEMORY;

    switch (getHeapLocation())
    {
        case HEAP_VID:
            m_dwOffset = m_dwAddress - VIDMEM_ADDR(pDriverData->BaseAddress);
            break;
        case HEAP_AGP:
#ifdef NV_AGP
            m_dwOffset = nvGetOffsetFromLinear(m_dwAddress);
            DPF_LEVEL(NVDBG_LEVEL_NV_AGP, "CSimpleSurface::Own: offset of AGP address %08x is %08x", m_dwAddress, m_dwOffset);
#else
            m_dwOffset = AGPMEM_OFFSET(m_dwAddress);
#endif
            break;
        case HEAP_PCI:
#ifdef WINNT // WINNT Temp Hack
        if (!getDC()->nvD3DTexHeapData.dwBase)
            m_dwOffset = m_dwAddress - getDC()->nvPusher.getBase();
        else
#endif // WINNT Temp Hack
            m_dwOffset = m_dwAddress - getDC()->nvD3DTexHeapData.dwBase;
            break;
        case HEAP_SYS:
            m_dwOffset = m_dwAddress;
            break;
        default:
            DPF ("unknown context");
            dbgD3DError();
            break;
    }

    dbgTracePop();
}

//****************************************************************************
// CSimpleSurface::disown
//
// remove surface ownership

void CSimpleSurface::disown
(
    void
)
{
    dbgTracePush ("CSimpleSurface[%08x]::disown()",this);
    // tag as invalid
    m_dwAddress = 0;
    m_dwFlags  &= ~HEAP_LOCATION_MASK;
    dbgTracePop();
}

//****************************************************************************
// CSimpleSurface::hwUnlock
//

void CSimpleSurface::hwUnlock
(
    void
)
{
    dbgTracePush ("CSimpleSurface::hwUnlock");
    // write reference count into push buffer and keep
    //  the value. HW has to reach this point before CPU can
    //  get lock access

    //added a check for surfaces that the HW could actually touch
    //should we actually check each surface instead of calling HWUnlock?
    //HMH

    if (hwCanRead() || hwCanWrite()) {
        m_dwRetireDate = getDC()->pRefCount->inc (CReferenceCount::INC_LAZY);
    }
    dbgTracePop();
}

//****************************************************************************
// CSimpleSurface::cpuLock
//

void CSimpleSurface::cpuLock
(
    DWORD //dwAccess
)
{
    DDSTARTTICK(SURF7_SPINLOCK);
    dbgTracePush ("CSimpleSurface::cpuLock");

    //The next check has been removed because looks like the only situation
    //we used it for was for a SystemMemorySurface artificially created in
    //CreateSurfaceEx. Ironically that is exactly the case where we need
    //synchronization now. Otherwise we pull a chair from under the blits
    //that are still in progress when the surface is being destroyed. Andrei O.
#if 1
    // if the surface is not touchable by HW, return immediately
    //
    //reenabled due to change in hwCanRead to reflect true value for Dynamic ContextDMAs
    //
    //note that hwCanWrite is currently redundant
    //
    //note also that this is simply an optimization.  surfaces that the HW can't touch
    //shouldn't be effected by HWLock/HWUnlock
    //
    // HMH
    if (!hwCanRead() && !hwCanWrite()) {
        DDENDTICK(SURF7_SPINLOCK);
        dbgTracePop();
        return;
    }
#endif

    if (getDC()->dwEnableStatus != CDriverContext::DC_ENABLESTATUS_ENABLED) {
        // if the channel's been destroyed, then everything is retired by definition
        DDENDTICK(SURF7_SPINLOCK);
        dbgTracePop();
        return;
    }

    // this is needed to prevent hangs when returning from a full-screen DOS box
    // waiting for a notifier with the FIFO in this state guarantees a hang
    if (pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_RECOVERYNEEDED_D3D) {
        DPF("CSimpleSurface::cpuLock: Early exit due to DosOccurred flag");
        dbgTracePop();
        DDENDTICK(SURF7_SPINLOCK);
        return;
    }

    // spin until surface is unlocked by HW
    getDC()->pRefCount->wait (CReferenceCount::WAIT_PREEMPTIVE, m_dwRetireDate);

    dbgTracePop();
    DDENDTICK(SURF7_SPINLOCK);

 }

//****************************************************************************
// CSimpleSurface::swap
//
// swap surface pointers

void CSimpleSurface::swap
(
    CSimpleSurface* pSurface
)
{
    dbgTracePush ("CSimpleSurface[%08x]::swap(pSurface=%08x)",this,pSurface);

    // sanity check
    assert (this);
    assert (isValid());
    assert (pSurface);
    assert (pSurface->isValid());

    NV_SWAP_1 (m_dwAddress,      pSurface->m_dwAddress);
    NV_SWAP_1 (m_dwOffset,       pSurface->m_dwOffset);
    NV_SWAP_1 (m_dwFormat,       pSurface->m_dwFormat);
    NV_SWAP_1 (m_dwBPP,          pSurface->m_dwBPP);
    NV_SWAP_1 (m_dwBPPRequested, pSurface->m_dwBPPRequested);
    NV_SWAP_1 (m_dwWidth,        pSurface->m_dwWidth);
    NV_SWAP_1 (m_dwHeight,       pSurface->m_dwHeight);
    NV_SWAP_1 (m_dwDepth,        pSurface->m_dwDepth);
    NV_SWAP_1 (m_dwPitch,        pSurface->m_dwPitch);
    NV_SWAP_1 (m_dwFourCC,       pSurface->m_dwFourCC);
    NV_SWAP_1 (m_dwFlags,        pSurface->m_dwFlags);
    NV_SWAP_1 (m_dwRetireDate,   pSurface->m_dwRetireDate);

    dbgTracePop();
}

//****************************************************************************
// CSimpleSurface::create
//
// creates a surface in one of the the allowed heaps based on preference.

BOOL CSimpleSurface::create
(
    DWORD dwPitch,
    DWORD dwHeight,
    DWORD dwDepth,
    DWORD dwBPPGranted,
    DWORD dwAllowedHeaps,
    DWORD dwPreferredHeap,
    DWORD dwAllocFlags
#ifdef CAPTURE
   ,DWORD dwUsageKind  // CAPTURE_SURFACE_KIND_xxx
#endif
)
{
#ifdef DEBUG
    // just so we can see what was asked for when debugging
    DWORD dwOriginalAllowedHeaps  = dwAllowedHeaps;
    DWORD dwOriginalPreferredHeap = dwPreferredHeap;
#endif

    // tell world
    dbgTracePush ("CSimpleSurface[%08x]::create(dwPitch=%08x,dwHt=%08x,dwDp=%08x,dwAllHeaps=%x,dwPrefHeap=%x,dwFlags=%x)",
                 this, dwPitch, dwHeight, dwDepth, dwAllowedHeaps, dwPreferredHeap, dwAllocFlags);

    DWORD dwSize = dwPitch * dwHeight * dwDepth;

    // Allow for a possible ZERO sized surface
    if (!dwSize) {
        // complain
        DPF ("CSimpleSurface::create: dwSize == 0");
        dbgD3DError();
        // tag surface as invalid
        m_dwAddress = 0;
        dbgTracePop();
        return (FALSE);
    }

    // retire surface (since it is about to exist)
    m_dwRetireDate = 0;

    // no specific preference would start with video memory
    if (dwPreferredHeap == HEAP_NOWHERE) {
        dwPreferredHeap = HEAP_VID;
    }

    // if we require tiled memory - override to only allow vid heap
    if (dwAllocFlags & ALLOCATE_TILED) {
        dwAllowedHeaps  = HEAP_VID;
        dwPreferredHeap = HEAP_VID;
    }

    // suppress video memory allocation all together if it is overidden
    //  by the registy
    if ((getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_VIDEOTEXTUREENABLE_MASK) == D3D_REG_VIDEOTEXTUREENABLE_DISABLE)
    {
        dwAllowedHeaps &= ~HEAP_VID;
        if (!dwAllowedHeaps) dwAllowedHeaps = HEAP_AGP | HEAP_PCI;
    }
#if 0 // moved
    else
    {
        // override the preference to the AGP heap if
        //  - it would be faster
        //  - it is allowed
        //  - and the preference indicated the slower option
        if ((global.dwPerformanceStrategy & PS_TEXTURE_PREFER_AGP)
         && ((dwAllowedHeaps & (HEAP_VID | HEAP_AGP)) == (HEAP_VID | HEAP_AGP))
         && (dwPreferredHeap == HEAP_VID))
        {
            // override to agp
            dwPreferredHeap = HEAP_AGP;
        }
    }
#endif

    m_dwAllocFlags = dwAllocFlags;

    // try to allocate in all allowed memory heaps
    while (dwAllowedHeaps)
    {
        // video
        if (dwAllowedHeaps & dwPreferredHeap & HEAP_VID)
        {
            DWORD dwStatus, dwType;

            if (dwAllocFlags & ALLOCATE_TILED)
            {
                dwType = (dwAllocFlags & ALLOCATE_AS_ZBUFFER_UNC) ?
                             TYPE_DEPTH :
                             ((dwAllocFlags & ALLOCATE_AS_ZBUFFER_CMP) ?
                                 ((dwBPPGranted == 2) ?
                                     TYPE_DEPTH_COMPR16 :
                                     TYPE_DEPTH_COMPR32) :
                                 TYPE_IMAGE);
#ifdef WINNT
                NVHEAP_ALLOC_TILED (dwStatus, m_dwOffset, dwPitch, dwHeight, dwType);
                m_dwAddress = VIDMEM_ADDR(m_dwOffset);
#else  // !WINNT
                NVHEAP_ALLOC_TILED (dwStatus, m_dwAddress, dwPitch, dwHeight, dwType);
#endif // !WINNT
#ifdef DEBUG_SURFACE_PLACEMENT
                m_dwRMAllocFlags = dwType;
#endif
                nvAssert (dwStatus == 0);
            }

            else
            {
                dwType = (dwAllocFlags & ALLOCATE_AS_ZBUFFER_UNC) ?
                             TYPE_DEPTH :
                             ((dwAllocFlags & ALLOCATE_AS_ZBUFFER_CMP) ?
                                 ((dwBPPGranted == 2) ?
                                     TYPE_DEPTH_COMPR16 :
                                     TYPE_DEPTH_COMPR32) :
                                 TYPE_TEXTURE);
#ifdef WINNT
                NVHEAP_ALLOC (dwStatus, m_dwOffset, dwSize, dwType);
                m_dwAddress = VIDMEM_ADDR(m_dwOffset);
#else
                NVHEAP_ALLOC (dwStatus, m_dwAddress, dwSize, dwType);
#endif // WINNT
#ifdef DEBUG_SURFACE_PLACEMENT
                m_dwRMAllocFlags = dwType;
#endif
            }

            if (dwStatus == 0) {
                // increment count of video memory surfaces allocated.
                pDriverData->DDrawVideoSurfaceCount++;
                m_dwPitch     = dwPitch;
                m_dwHeight    = dwHeight;
                m_dwDepth     = dwDepth;
#ifndef WINNT
                m_dwOffset    = m_dwAddress - pDriverData->BaseAddress;
#endif // WINNT
                m_dwFlags    &= ~HEAP_LOCATION_MASK;
                m_dwFlags    |= HEAP_VID;
                m_dwFlags    &= ~FLAG_TILED;
                m_dwFlags    |= (dwAllocFlags & ALLOCATE_TILED)      ? FLAG_TILED   : 0;
                m_dwFlags    |= (dwAllocFlags & ALLOCATE_AS_ZBUFFER) ? FLAG_ZBUFFER : 0;

#ifdef DEBUG
                DPF_LEVEL(NVDBG_LEVEL_SURFACEALLOC,"Vid Surface Alloc: Address:%08x Size:%08x\n",m_dwAddress,dwSize);
#endif

#ifdef CAPTURE
                if (getDC()->nvD3DRegistryData.regCaptureEnable & D3D_REG_CAPTUREENABLE_RECORD) {
                    CAPTURE_SURFACE_ALLOC surf;
                    surf.dwJmpCommand         = CAPTURE_JMP_COMMAND;
                    surf.dwExtensionSignature = CAPTURE_EXT_SIGNATURE;
                    surf.dwExtensionID        = CAPTURE_XID_SURFACE_ALLOC;
                    surf.dwCtxDMAHandle       = NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY;
                    surf.dwOffset             = m_dwOffset;
                    surf.dwSize               = getSize();
                    surf.dwAlignment          = 0;
                    surf.dwType               = (dwAllocFlags & ALLOCATE_AS_ZBUFFER) ? CAPTURE_SURFACE_TYPE_ZETA : CAPTURE_SURFACE_TYPE_NORMAL;
                    surf.dwKind               = dwUsageKind;
                    surf.dwSurfaceType        = getFormat();
                    surf.dwIntendedPitch      = dwPitch;
                    surf.dwIntendedHeight     = dwHeight;
                    captureLog (&surf,sizeof(surf));
                }
#endif
                dbgTracePop();
                return (TRUE);
            }

#ifdef DEBUG
                DPF_LEVEL(NVDBG_LEVEL_SURFACEALLOC,"Vid Surface Alloc Failed: Size:%08x\n",dwSize);
#endif
            // fail - don't try again
            DPF_LEVEL(NVDBG_LEVEL_INFO,"CSimpleSurface::create: Surface in VID failed");
            dwAllowedHeaps &= ~HEAP_VID;
        }

        // agp
        if (dwAllowedHeaps & dwPreferredHeap & HEAP_AGP)
        {
            if (pDriverData->GARTLinearBase)
            {
                // On AGP, allocate call DDRAW to allocate the AGP memory.
                m_dwAddress = (DWORD)nvAGPAlloc(dwSize);
                if (m_dwAddress != ERR_DXALLOC_FAILED)
                {
#ifdef NV_AGP
                    m_dwOffset   = nvGetOffsetFromLinear(m_dwAddress);
                    DPF_LEVEL(NVDBG_LEVEL_NV_AGP, "CSimpleSurface::Create: offset of AGP address %08x is %08x", m_dwAddress, m_dwOffset);
#else
                    // at this point m_dwAddress is actually an offset
                    m_dwAddress  = AGPMEM_ADDR(m_dwAddress);
                    m_dwOffset   = AGPMEM_OFFSET(m_dwAddress);
#endif
                    m_dwPitch    = dwPitch;
                    m_dwHeight   = dwHeight;
                    m_dwDepth    = dwDepth;
                    m_dwFlags   &= ~HEAP_LOCATION_MASK;
                    m_dwFlags   |= HEAP_AGP;
                    m_dwFlags   &= ~FLAG_TILED;
#ifdef DEBUG
                    DPF_LEVEL(NVDBG_LEVEL_SURFACEALLOC,"AGP Surface Alloc: Address:%08x Size:%08x\n",m_dwAddress,dwSize);
#endif

#ifdef CAPTURE
                    if (getDC()->nvD3DRegistryData.regCaptureEnable & D3D_REG_CAPTUREENABLE_RECORD) {
                        CAPTURE_SURFACE_ALLOC surf;
                        surf.dwJmpCommand         = CAPTURE_JMP_COMMAND;
                        surf.dwExtensionSignature = CAPTURE_EXT_SIGNATURE;
                        surf.dwExtensionID        = CAPTURE_XID_SURFACE_ALLOC;
                        surf.dwCtxDMAHandle       = D3D_CONTEXT_DMA_HOST_MEMORY;
                        surf.dwOffset             = m_dwOffset;
                        surf.dwSize               = getSize();
                        surf.dwAlignment          = 0;
                        surf.dwType               = CAPTURE_SURFACE_TYPE_NORMAL;
                        surf.dwKind               = dwUsageKind;
                        surf.dwSurfaceType        = getFormat();
                        surf.dwIntendedPitch      = dwPitch;
                        surf.dwIntendedHeight     = dwHeight;
                        captureLog (&surf,sizeof(surf));
                    }
#endif
                    dbgTracePop();
                    return (TRUE);
                }
            }
            // fail - don't try again
#ifdef DEBUG
                DPF_LEVEL(NVDBG_LEVEL_SURFACEALLOC,"AGP Surface Alloc Failed: Size:%08x\n",dwSize);
#endif
            DPF_LEVEL(NVDBG_LEVEL_INFO,"CSimpleSurface::create: Surface in AGP failed");
            dwAllowedHeaps &= ~HEAP_AGP;
        }

        // pci
        if (dwAllowedHeaps & dwPreferredHeap & HEAP_PCI)
        {
            DWORD dwOffset;

            // On PCI, allocate from our internal texture heap.
            dwOffset = nvPCIAlloc(dwSize);
            if (dwOffset)
            {
                m_dwPitch     = dwPitch;
                m_dwHeight    = dwHeight;
                m_dwDepth     = dwDepth;
                m_dwOffset    = dwOffset;
                m_dwAddress   = getDC()->nvD3DTexHeapData.dwBase + dwOffset;
                m_dwFlags    &= ~HEAP_LOCATION_MASK;
                m_dwFlags    |= HEAP_PCI;
                m_dwFlags    &= ~FLAG_TILED;

#ifdef DEBUG
                DPF_LEVEL(NVDBG_LEVEL_SURFACEALLOC,"PCI Surface Alloc: Address:%08x Size:%08x\n",m_dwAddress,dwSize);
#endif

#ifdef CAPTURE
                if (getDC()->nvD3DRegistryData.regCaptureEnable & D3D_REG_CAPTUREENABLE_RECORD) {
                    CAPTURE_SURFACE_ALLOC surf;
                    surf.dwJmpCommand         = CAPTURE_JMP_COMMAND;
                    surf.dwExtensionSignature = CAPTURE_EXT_SIGNATURE;
                    surf.dwExtensionID        = CAPTURE_XID_SURFACE_ALLOC;
                    surf.dwCtxDMAHandle       = D3D_CONTEXT_DMA_HOST_MEMORY;
                    surf.dwOffset             = m_dwOffset;
                    surf.dwSize               = getSize();
                    surf.dwAlignment          = 0;
                    surf.dwType               = CAPTURE_SURFACE_TYPE_NORMAL;
                    surf.dwKind               = dwUsageKind;
                    surf.dwSurfaceType        = getFormat();
                    surf.dwIntendedPitch      = dwPitch;
                    surf.dwIntendedHeight     = dwHeight;
                    captureLog (&surf,sizeof(surf));
                }
#endif
                dbgTracePop();
                return (TRUE);
            }

#ifdef DEBUG
            DPF_LEVEL(NVDBG_LEVEL_SURFACEALLOC,"PCI Surface Alloc Failed: Size:%08x\n",dwSize);
#endif

            // fail - don't try again
            DPF_LEVEL(NVDBG_LEVEL_INFO,"CSimpleSurface::create: Surface in PCI failed");
            dwAllowedHeaps &= ~HEAP_PCI;
        }

        // system memory
        if (dwAllowedHeaps & dwPreferredHeap & HEAP_SYS)
        {
            // For system memory, allocate from global heap.
            // m_dwOffset keeps the original ptr while
            // m_dwAddress keeps the aligned ptr
#ifdef WINNT
            PDD_SURFACE_LOCAL pDDSLcl = getWrapper() ? getWrapper()->getDDSLcl() : NULL;
            if (pDDSLcl)
            {
                m_dwOffset = (DWORD)EngAllocPrivateUserMem(pDDSLcl, dwSize + 31, 'x_VN');
//                getWrapper()->setDDSLcl(NULL);  We shouldn't keep Lcl around, but we have to for texture
                //management    HH
            }
            else
#endif // WINNT
            {
                m_dwOffset = (DWORD) AllocIPM (dwSize);
                nvAssert (((m_dwOffset + 31) & ~31) == m_dwOffset);
                //GlobalAlloc(GMEM_FIXED, dwSize + 31);
            }

            if (m_dwOffset)
            {
                m_dwPitch     = dwPitch;
                m_dwHeight    = dwHeight;
                m_dwDepth     = dwDepth;
                m_dwAddress   = (m_dwOffset + 31) & ~31;
                m_dwFlags    &= ~HEAP_LOCATION_MASK;
                m_dwFlags    |= HEAP_SYS;
                m_dwFlags    &= ~FLAG_TILED;

#ifdef DEBUG
                DPF_LEVEL(NVDBG_LEVEL_SURFACEALLOC,"SYS Surface Alloc: Address:%08x Size:%08x\n",m_dwAddress,dwSize);
#endif

                dbgTracePop();
                return (TRUE);
            }

            // fail - don't try again
#ifdef DEBUG
            DPF_LEVEL(NVDBG_LEVEL_SURFACEALLOC,"SYS Surface Alloc Failed: Size:%08x\n",dwSize);
#endif
            DPF_LEVEL(NVDBG_LEVEL_INFO,"CSimpleSurface::create: Surface in SYS failed");
            dwAllowedHeaps &= ~HEAP_SYS;
        }

        // next
        dwPreferredHeap = (dwPreferredHeap << 1) & HEAP_ANYWHERE;
        if (!dwPreferredHeap) dwPreferredHeap = HEAP_VID;
    }

    // not allocated
    //  tag as invalid and fail
    DPF_LEVEL(NVDBG_LEVEL_INFO,"CSimpleSurface::create: Surface Not allocated");
    m_dwAddress = 0;
    dbgTracePop();
    return (FALSE);
}

//****************************************************************************

BOOL CSimpleSurface::create
(
    const CSimpleSurface* pTemplateSurface
#ifdef CAPTURE
   ,DWORD dwUsageKind
#endif
)
{
    DWORD dwHeap, dwAllocFlags;
    BOOL  bRV;

    dbgTracePush ("CSimpleSurface[%08x]::create(pTemplateSurface=%08x)",this,pTemplateSurface);
    // create in same heap as original
    dwHeap = pTemplateSurface->getHeapLocation();
    dwAllocFlags  = CSimpleSurface::ALLOCATE_SIMPLE;
    dwAllocFlags |= pTemplateSurface->isZBuffer() ? CSimpleSurface::ALLOCATE_AS_ZBUFFER_CMP : 0;

    bRV = create (pTemplateSurface->getSize(),
                  1,
                  1,
                  pTemplateSurface->getBPP(),
                  dwHeap,
                  dwHeap,
                  dwAllocFlags
#ifdef CAPTURE
                 ,dwUsageKind
#endif
                  );
    dbgTracePop();
    return (bRV);
}

//****************************************************************************
// CSimpleSurface::create for formatted surfaces
//
// creates a surface with format information

BOOL CSimpleSurface::create (CNvObject *pWrapperObject,
                             DWORD      dwFormat,
                             DWORD      dwWidth,
                             DWORD      dwHeight,
                             DWORD      dwDepth,
                             DWORD      dwMultiSampleBits,
                             DWORD      dwBPPRequested,
                             DWORD      dwBPPGranted,
                             DWORD      dwPitch,
                             DWORD      dwAllowedHeaps,
                             DWORD      dwPreferredHeap,
                             DWORD      dwAllocFlags
#ifdef CAPTURE
                            ,DWORD      dwUsageKind
#endif
                             )
{
    dbgTracePush ("CSimpleSurface::create");

    setWrapper      (pWrapperObject);
    setFormat       (dwFormat);
    setWidth        (dwWidth);
    setHeight       (dwHeight);
    setDepth        (dwDepth);
    setMultiSampleBits(dwMultiSampleBits);
    setBPPRequested (dwBPPRequested);
    setBPP          (dwBPPGranted);

#ifdef  STEREO_SUPPORT
	if (dwAllocFlags & ALLOCATE_AS_STEREO && STEREODATA(dwStereoHWType) == STEREOCFG_INTERLACED) 
		dwPitch = GetModePitch(dwWidth, dwHeight, dwBPPGranted << 3) * 2;
#endif  //STEREO_SUPPORT

    BOOL bRV = create (dwPitch, dwHeight, dwDepth, dwBPPGranted, dwAllowedHeaps, dwPreferredHeap, dwAllocFlags
#ifdef CAPTURE
                                      ,dwUsageKind
#endif
                                       );
#ifdef  STEREO_SUPPORT
	if (bRV && dwAllocFlags & ALLOCATE_AS_STEREO) 
		bRV = createStereo ();
#endif  //STEREO_SUPPORT

    dbgTracePop();
    return (bRV);
}

//****************************************************************************
// CSimpleSurface::recreate for formatted surfaces
//
// recreate a surface with a different bit depth

BOOL CSimpleSurface::recreate (DWORD dwBPP)
{
    // cache off current info
    CNvObject *pNvObj   = getWrapper();
    DWORD      dwFormat = getFormat();
    DWORD      dwWidth  = getWidth();
    DWORD      dwHeight = getHeight();
    DWORD      dwMSBits = getMultiSampleBits();
    DWORD      dwBPPReq = getBPPRequested();
    DWORD      dwPitch  = dwBPP * dwWidth;
    DWORD      dwAFlags = getAllocFlags();
#ifdef  STEREO_SUPPORT
    BOOL       bStereo = isStereo();
    BOOL       bRetVal; 
    // destroy and reallocate
    destroy();
	if (bStereo && (m_dwFlags &  FLAG_NOTREAL) == 0 && STEREODATA(dwStereoHWType) == STEREOCFG_INTERLACED) 
		dwPitch = GetModePitch(dwWidth, dwHeight, dwBPP << 3) * 2;
    bRetVal = create (pNvObj, dwFormat, dwWidth, dwHeight, 1,
                    dwMSBits, dwBPPReq, dwBPP, dwPitch,
                    CSimpleSurface::HEAP_VID, CSimpleSurface::HEAP_VID, dwAFlags
            #ifdef CAPTURE
                   ,CAPTURE_SURFACE_KIND_ZETA
            #endif
                     );
    if (bStereo)
        createStereo();
    return bRetVal;
#else   //STEREO_SUPPORT
    // destroy and reallocate
    destroy();
    return (create (pNvObj, dwFormat, dwWidth, dwHeight, 1,
                    dwMSBits, dwBPPReq, dwBPP, dwPitch,
                    CSimpleSurface::HEAP_VID, CSimpleSurface::HEAP_VID, dwAFlags
            #ifdef CAPTURE
                   ,CAPTURE_SURFACE_KIND_ZETA
            #endif
                   )
           );
#endif  //STEREO_SUPPORT
}

//****************************************************************************
// CSimpleSurface::growTo
//
BOOL CSimpleSurface::growBy
(
    DWORD dwDelta,
    BOOL  bPreserveContents
)
{
    dbgTracePush ("CSimpleSurface::create");

    // currently we only grow sysmem surfaces (sorry)
    if (getHeapLocation() != HEAP_SYS)
    {
        nvAssert(0);
        dbgTracePop();
        return FALSE;
    }

    DWORD dwSize = getSize() + dwDelta + m_dwPitch - 1;
    dwSize /= m_dwPitch;
    dwSize *= m_dwPitch;

    // For system memory, allocate from global heap.
    // m_dwOffset keeps the original ptr while
    // m_dwAddress keeps the aligned ptr
#ifdef WINNT
    PDD_SURFACE_LOCAL pDDSLcl = getWrapper() ? getWrapper()->getDDSLcl() : NULL;
    if (pDDSLcl)
    {
        void *ptr = EngAllocPrivateUserMem(pDDSLcl, dwSize+31, 'x_VN');
        if (ptr)
        {
            if (bPreserveContents)
            {
                DWORD dw = (DWORD(ptr) + 31) & ~31;
                nvMemCopy (dw,m_dwAddress,getSize());
            }
            EngFreePrivateUserMem (pDDSLcl, (void*)m_dwOffset);
            m_dwOffset = (DWORD)ptr;
        }
        else
        {
            // fail safely
            dbgTracePop();
            return FALSE;
        }
    }
    else
#endif // WINNT
    {
        void *ptr = AllocIPM(dwSize);
        if (ptr)
        {
            if (bPreserveContents)
            {
                DWORD dw = (DWORD(ptr) + 31) & ~31;
                nvMemCopy (dw,m_dwAddress,getSize());
            }
            FreeIPM ((void*)m_dwOffset);
            m_dwOffset = (DWORD)ptr;
        }
        else
        {
            // fail safely
            dbgTracePop();
            return FALSE;
        }
    }

    // update state
    m_dwHeight  = dwSize / m_dwPitch;
    m_dwAddress = (m_dwOffset + 31) & ~31;

    DPF_LEVEL(NVDBG_LEVEL_SURFACEALLOC,"SYS Surface Realloc: Address:%08x Size:%08x\n",m_dwAddress,dwSize);

    dbgTracePop();
    return TRUE;
}

//****************************************************************************
// CSimpleSurface::destroy
//
// frees a surface

BOOL CSimpleSurface::destroy
(
    void
)
{
    dbgTracePush ("CSimpleSurface[%08x]::destroy()",this);

    // validate surface
    //  destroying a invalid surface is technically a bad thing, but unfortunately mode
    //  switches will disown memory that is still considered allocated. we just return.
    if (!isValid())
    {
        DPF ("CSimpleSurface::destroy: Attempting to free an invalid surface (may not be serious)");
        dbgTracePop();
        return TRUE;
    }

    // cannot free memory until it is actually not in use any more
    cpuLock (LOCK_NORMAL);

    // capture surface free
#ifdef CAPTURE
    if (getDC()->nvD3DRegistryData.regCaptureEnable & D3D_REG_CAPTUREENABLE_RECORD) {
        CAPTURE_SURFACE_FREE surf;
        surf.dwJmpCommand         = CAPTURE_JMP_COMMAND;
        surf.dwExtensionSignature = CAPTURE_EXT_SIGNATURE;
        surf.dwExtensionID        = CAPTURE_XID_SURFACE_FREE;
        surf.dwCtxDMAHandle       = (getHeapLocation() == CSimpleSurface::HEAP_VID)
                                    ? NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY
                                    : D3D_CONTEXT_DMA_HOST_MEMORY;
        surf.dwOffset             = m_dwOffset;
        captureLog (&surf,sizeof(surf));
    }
#endif

    // do we own the memory?
    if (m_dwFlags & FLAG_DONOTOWNMEMORY)
    {
        // disown this surface
        disown();
        dbgTracePop();
        return TRUE;
    }

    // free memory
    switch (getHeapLocation())
    {
        // video
        case HEAP_VID:
        {
            // Call DDRAW to de-allocate memory from the video memory heap.
#ifdef WINNT
            NVHEAP_FREE (m_dwOffset);
#else
            // we should only be trying to free this memory from 16 bit land when a mode switch is about
            // to happen. in this case the free isn't required since the RM will destroy the heap
            if (!global.b16BitCode)
            {
                NVHEAP_FREE (m_dwAddress);
            }
#endif

            // Decrement count of video memory surfaces allocated.
            pDriverData->DDrawVideoSurfaceCount--;

#ifdef DEBUG
            DPF_LEVEL(NVDBG_LEVEL_SURFACEALLOC,"VID Surface Free: Address:%08x\n",m_dwAddress);
#endif

            // done
            m_dwAddress = 0;
            m_dwFlags  &= ~HEAP_LOCATION_MASK;

#ifdef  STEREO_SUPPORT
            destroyStereo();
#endif  //STEREO_SUPPORT

            dbgTracePop();
            return TRUE;
        }
        // agp
        case HEAP_AGP:
        {
            // de-allocate memory from AGP heap
#ifdef NV_AGP
            nvAGPFree((void*)m_dwAddress);
#else
#ifdef WINNT
            nvAGPFree((void*)m_dwOffset);
#else
            nvAGPFree((void*)m_dwAddress);
#endif
#endif

#ifdef DEBUG
            DPF_LEVEL(NVDBG_LEVEL_SURFACEALLOC,"AGP Surface Free: Address:%08x\n",m_dwAddress);
#endif

            // done
            m_dwAddress = 0;
            m_dwFlags  &= ~HEAP_LOCATION_MASK;
            dbgTracePop();
            return TRUE;
        }
        // pci
        case HEAP_PCI:
        {
            // On PCI, de-allocate from our internal texture heap.
            nvPCIFree(m_dwAddress - getDC()->nvD3DTexHeapData.dwBase);

#ifdef DEBUG
            DPF_LEVEL(NVDBG_LEVEL_SURFACEALLOC,"PCI Surface Free: Address:%08x\n",m_dwAddress);
#endif
            // done
            m_dwAddress = 0;
            m_dwFlags  &= ~HEAP_LOCATION_MASK;
            dbgTracePop();
            return TRUE;
        }
        // sys
        case HEAP_SYS:
        {
            //  m_dwOffset has the original unaligned ptr
#ifdef WINNT
            PDD_SURFACE_LOCAL pDDSLcl = getWrapper() ? getWrapper()->getDDSLcl() : NULL;
            if (pDDSLcl)
            {
                EngFreePrivateUserMem(pDDSLcl, (void*)m_dwOffset);
                getWrapper()->setDDSLcl(NULL);
            }
            else
#endif // WINNT
            {
                FreeIPM ((void*) m_dwOffset);
                // GlobalFree ((HGLOBAL)m_dwOffset);
            }

#ifdef DEBUG
            DPF_LEVEL(NVDBG_LEVEL_SURFACEALLOC,"SYS Surface Free: Address:%08x\n",m_dwAddress);
#endif

            // done
            m_dwAddress = 0;
            m_dwFlags  &= ~HEAP_LOCATION_MASK;
            dbgTracePop();
            return TRUE;
        }
    }

    // failed (may be default push buffer - not allowed to be destroyed)
    DPF ("CSimpleSurface::destroy: Invalid heap specified. this surface is probably corrupt.");
    dbgD3DError();
    dbgTracePop();
    return FALSE;
}

#ifdef  STEREO_SUPPORT

BOOL CSimpleSurface::createStereo ()
    {
        BOOL    bRetVal = TRUE;
        DWORD   dwAllocFlags = 0;
        if (!STEREO_ENABLED)
            return TRUE;
        nvAssert (m_dwAddressRight == 0);
        if (isZBuffer())
            dwAllocFlags |= ALLOCATE_AS_ZBUFFER_UNC;
        if (m_dwFlags & FLAG_TILED)
            dwAllocFlags |= ALLOCATE_TILED;
        if (STEREODATA(dwStereoHWType) != STEREOCFG_INTERLACED || m_dwFlags & FLAG_NOTREAL)
        {
            //Save what will be overwritten.
            DWORD   dwSaveAddress = m_dwAddress;
            DWORD   dwSaveOffset  = m_dwOffset;
            if (bRetVal = create(m_dwPitch, m_dwHeight, 1, m_dwBPP,
                                 m_dwFlags & HEAP_LOCATION_MASK,
                                 m_dwFlags & HEAP_LOCATION_MASK, dwAllocFlags
#ifdef CAPTURE
                                 ,CAPTURE_SURFACE_KIND_UNKNOWN
#endif
                                 ))
            {
                m_dwAddressRight = m_dwAddress;
                m_dwOffsetRight  = m_dwOffset;
            } else
	            LOG("Can't create a stereo rendering surface");
            m_dwAddress = dwSaveAddress;
            m_dwOffset  = dwSaveOffset; 
        } else           
        {
			DWORD dwRightEyeOffset;
			dwRightEyeOffset = m_dwPitch >> 1;
			m_dwAddressRight = m_dwAddress + dwRightEyeOffset;
			m_dwOffsetRight  = m_dwOffset + dwRightEyeOffset;
        }
        tagAsStereo();
        if (m_dwFlags & FLAG_NOTREAL)
            return bRetVal;
        if (!isZBuffer())
        {
            nvAssert (STEREODATA(dwSurfaceCount) < 3);
            for (DWORD i = 0; i < 3; i++)
            {
                if (STEREODATA(RmStereoParams.FlipOffsets[i][0]) == 0xFFFFFFFF)
                {
                    //It is a free element
                    STEREODATA(RmStereoParams.FlipOffsets[i][0]) = m_dwOffset;
                    STEREODATA(RmStereoParams.FlipOffsets[i][1]) = m_dwOffsetRight;
                    STEREODATA(pRenderTargets[i]) = this;
                    STEREODATA(dwSurfaceCount)++;
                    return bRetVal;
                }
            }
            nvAssert (0);
        }
        return bRetVal;
    }

BOOL CSimpleSurface::destroyStereo (void)
    {
        if (isStereo())
        {
            m_dwFlags  &= ~FLAG_STEREO;
            if (STEREODATA(dwStereoHWType) != STEREOCFG_INTERLACED)
            {
#ifdef WINNT
                NVHEAP_FREE (m_dwOffsetRight);
#else
                NVHEAP_FREE (m_dwAddressRight);
#endif
                pDriverData->DDrawVideoSurfaceCount--;
            }
            m_dwAddressRight = 0;
            m_dwOffsetRight  = 0;
            if (m_dwFlags & FLAG_NOTREAL)
                return TRUE;
            if (!STEREO_ENABLED)
                return TRUE;
            if (!isZBuffer())
            {
                nvAssert (STEREODATA(dwSurfaceCount) > 0);
                STEREODATA(dwSurfaceCount)--;
                for (DWORD i = 0; i < 3; i++)
                {
                    if (STEREODATA(pRenderTargets[i]) == this)
                    {
                        //Found itself. Now clean it up.
                        STEREODATA(RmStereoParams.FlipOffsets[i][0]) = 0xFFFFFFFF;
                        STEREODATA(pRenderTargets[i]) = NULL;
                        return TRUE;
                    }
                }
            }
        }
        return TRUE;
    }
#endif  //STEREO_SUPPORT

//****************************************************************************
//****************************************************************************
//****************************************************************************
//**  CComplexSurface ********************************************************
//****************************************************************************
//****************************************************************************
//****************************************************************************

//****************************************************************************
// CComplexSurface::tagRenameEnable
//
// enable renaming and the renaming strategy to follow
template <int cMax>
void CComplexSurface<cMax>::tagRenameEnable
(
    DWORD           dwRenameType,
    DWORD           dwPreAllocCount,
    PCANRENAMEPROC  pfnCanRenameProc,
    PRENAMEPROC     pfnRenameProc,
    void           *pContext
)
{
    dbgTracePush ("CComplexSurface::tagRenameEnable");

    // update flags
    m_dwFlags &= ~FLAG_RENAME_CALL;
    m_dwFlags |=  FLAG_RENAME;

    // set new policy
    if (dwRenameType == RENAME_EXTERNAL)
    {
        m_pfnCanRenameProc     = pfnCanRenameProc;
        m_pfnRenameProc        = pfnRenameProc;
        m_pRenameContext       = pContext;
        m_dwFlags             |= FLAG_RENAME_CALL;
    }

    // allocate some of the surfaces already
    while (dwPreAllocCount > 1)
    {
        // alloc a surface
        dwPreAllocCount--;
        if (!m_aSurface[dwPreAllocCount].create(&m_aSurface[0]
#ifdef CAPTURE
            ,CAPTURE_SURFACE_KIND_TEXTURE
#endif
            )){
            DPF("tagRenameEnable: Failed to pre allocate surfaces\n");
            break;
        }
        m_dwTotalSurfaces++;
    }

    dbgTracePop();
}

//****************************************************************************
// CComplexSurface::forceRename
//
// rename surface on external demand
template <int cMax>
void CComplexSurface<cMax>::forceRename
(
    DWORD dwNewSurface,
    DWORD dwNewAddress
)
{
    // new surface retain most of its attributes
    DWORD dwPitch  = m_aSurface[m_dwActiveSurface].getPitch();
    DWORD dwHeight = m_aSurface[m_dwActiveSurface].getHeight();
    DWORD dwHeap   = m_aSurface[m_dwActiveSurface].getHeapLocation();
    m_aSurface[dwNewSurface].own (dwNewAddress,dwPitch,dwHeight,dwHeap,TRUE);

    // update flags
    m_dwPreviousSurface = m_dwActiveSurface;
    m_dwActiveSurface   = dwNewSurface;
    m_dwTotalSurfaces   = max(m_dwTotalSurfaces, (dwNewSurface+1));
}

//****************************************************************************
// CComplexSurface::cpuLock
//
// rename busy textures on demand when enabled

template <int cMax>
void CComplexSurface<cMax>::cpuLock
(
    DWORD dwAccess
)
{
    dbgTracePush ("CComplexSurface::cpuLock");

                #ifdef NV_PROFILE_CPULOCK
                NVP_START (NVP_T_FLOAT0);
                #endif

    // get proper index
    CSimpleSurface *pActive = getActiveSurface();

    // if we are allowed to rename and the surface is busy...
    if ((dwAccess & CSimpleSurface::LOCK_RENAME)                                    // renaming was requested (or is allowed)
     && canRename()                                                                 // surface has renaming enabled
     && pActive->isBusy()                                                           // surface is busy
     && (!(m_dwFlags & FLAG_RENAME_CALL)                                            // internal rename policy always OK
      || ((m_dwFlags & FLAG_RENAME_CALL) && m_pfnCanRenameProc(m_pRenameContext)))) // external rename policy active & OK
    {
        // search through all remaining surfaces
        BOOL  bAvailable      = FALSE;
        DWORD dwOldestDate    = ~0;
        DWORD dwOldestSurface = m_dwActiveSurface;
        DWORD dwNew;
        for(DWORD i = 1; i < m_dwTotalSurfaces; i++)
        {
            dwNew = m_dwActiveSurface + i;
            if (dwNew >= m_dwTotalSurfaces)
                dwNew -= m_dwTotalSurfaces;

            // check if we have a surface that isn't busy
            if (!m_aSurface[dwNew].isBusy()) {
                bAvailable = TRUE;
                break;
            }

            // update oldest pointer to point to the olders guy in this list
            if (m_aSurface[dwNew].getRetireDate() < dwOldestDate)
            {
                dwOldestDate    = m_aSurface[dwNew].getRetireDate();
                dwOldestSurface = dwNew;
            }
        }

        if (bAvailable)
        {
            // adopt the new surface
            m_dwPreviousSurface = m_dwActiveSurface;
            m_dwActiveSurface   = dwNew;
            pActive = getActiveSurface();
            // signal external rename policy of state, if needed
            if (m_dwFlags & FLAG_RENAME_CALL)
            {
                 //this call should really be made, but causes thrashing on some system in WinBench 1024x768x16 (test 10)
                (m_pfnRenameProc)(m_pRenameContext, m_dwPreviousSurface,m_dwActiveSurface);
            }
            else if (dwAccess & (CSimpleSurface::LOCK_RENAME_COPY & ~CSimpleSurface::LOCK_RENAME))
            {
                        #ifdef NV_PROFILE_COPIES
                        NVP_START(NVP_T_RENAME_AUTO_COPY);
                        #endif
                nvMemCopy (getSurface(m_dwActiveSurface)->getAddress(),
                           getSurface(m_dwPreviousSurface)->getAddress(),
                           getSurface(m_dwPreviousSurface)->getSize());
                        #ifdef NV_PROFILE_COPIES
                        NVP_STOP(NVP_T_RENAME_AUTO_COPY);
                        nvpLogTime (NVP_T_RENAME_AUTO_COPY,nvpTime[NVP_T_RENAME_AUTO_COPY]);
                        #endif
            }
        }
        else if (m_dwTotalSurfaces < cMax)
        {
            // create a new surface if we can
            dwNew = m_dwTotalSurfaces;
            if (m_aSurface[dwNew].create(&m_aSurface[m_dwActiveSurface]
#ifdef CAPTURE
               ,((m_dwFlags & FLAG_RENAME_CALL) && m_pfnCanRenameProc(m_pRenameContext)) ? CAPTURE_SURFACE_KIND_TEXTURE : CAPTURE_SURFACE_KIND_VERTEX
#endif
                ))
            {
                // signal external rename policy of state, if needed
                if (m_dwFlags & FLAG_RENAME_CALL)
                {
                    (m_pfnRenameProc)(m_pRenameContext, m_dwActiveSurface, dwNew);
                }
                else if (dwAccess & (CSimpleSurface::LOCK_RENAME_COPY & ~CSimpleSurface::LOCK_RENAME))
                {
                        #ifdef NV_PROFILE_COPIES
                        NVP_START(NVP_T_RENAME_AUTO_COPY);
                        #endif
                    nvMemCopy (getSurface(dwNew)->getAddress(),
                               getSurface(m_dwActiveSurface)->getAddress(),
                               getSurface(m_dwActiveSurface)->getSize());
                        #ifdef NV_PROFILE_COPIES
                        NVP_STOP(NVP_T_RENAME_AUTO_COPY);
                        nvpLogTime (NVP_T_RENAME_AUTO_COPY,nvpTime[NVP_T_RENAME_AUTO_COPY]);
                        #endif
                }

                // bump total
                m_dwTotalSurfaces++;

                // we'll take it
                m_dwPreviousSurface = m_dwActiveSurface;
                m_dwActiveSurface   = dwNew;
                pActive = getActiveSurface();
            }
            else
            {
                // we are all out of memory and all surfaces are busy - wait on the one that will retire first
                m_dwPreviousSurface = m_dwActiveSurface;
                m_dwActiveSurface   = dwOldestSurface;
                pActive = getActiveSurface();
            }
        }
        else
        {
            // we are all out of surfaces and all are busy - wait on the one that will retire first
            m_dwPreviousSurface = m_dwActiveSurface;
            m_dwActiveSurface   = dwOldestSurface;
            pActive = getActiveSurface();
        }
    }

    //  lock this surface (which may still be a busy surface)
// NVP_START(255);
            #ifdef NV_PROFILE_CPULOCK
            NVP_STOP (NVP_T_FLOAT0);
            nvpLogTime (NVP_T_FLOAT0,nvpTime[NVP_T_FLOAT0]);
            #endif

            #ifdef NV_PROFILE_CPULOCK
            NVP_START (NVP_T_FLOAT1);
            #endif
    pActive->cpuLock (dwAccess);
            #ifdef NV_PROFILE_CPULOCK
            NVP_STOP (NVP_T_FLOAT1);
            nvpLogTime (NVP_T_FLOAT1,nvpTime[NVP_T_FLOAT1]);
            #endif
// NVP_STOP(255);
// if (dwAccess & CSimpleSurface::LOCK_RENAME)
// {
    // __int64 time = nvpTime[255] / global.dwProcessorSpeed;
    // if (time >= 1000)
    // {
        // DPF ("%dus", (DWORD)time);
    // }
// }

    dbgTracePop();
}

//****************************************************************************
// CComplexSurface::create
//
// creates a surface in one of the the allowed heaps based on preference.
template <int cMax>
BOOL CComplexSurface<cMax>::create
(
    CNvObject *pWrapper,
    DWORD dwSize,
    DWORD dwAllowedHeaps,
    DWORD dwPreferredHeap
#ifdef CAPTURE
   ,DWORD dwUsageKind
#endif
)
{
    DWORD i;

    dbgTracePush ("CComplexSurface[%08x]::create(dwSize=%08x,dwAllowedHeaps=%x,dwPreferredHeap=%x)",
                 this,dwSize,dwAllowedHeaps,dwPreferredHeap);

    // set surface values
    m_dwTotalSurfaces = 1;
    m_dwActiveSurface = m_dwPreviousSurface = 0;
    //run down the simple surface list and make sure they all have the wrapper set BEFORE create.
    for (i=0;i<cMax;i++) m_aSurface[i].setWrapper(pWrapper);

    // create the first surface and return
    BOOL bRV = m_aSurface[0].create (dwSize, 1, 1, 0, dwAllowedHeaps, dwPreferredHeap,
                                     CSimpleSurface::ALLOCATE_SIMPLE
#ifdef CAPTURE
                                    ,dwUsageKind
#endif
                                     );

    dbgTracePop();
    return (bRV);
}

//****************************************************************************
// CComplexSurface::own
//
// claim an already allocated surface
template <int cMax>
BOOL CComplexSurface<cMax>::own
(
    DWORD dwAddress,
    DWORD dwPitch,
    DWORD dwLogHeight,
    DWORD dwHeapLocation,
    BOOL  bOwnMemory
)
{
    dbgTracePush ("CComplexSurface[%08x]::own(dwAddress=%08x,dwPitch=%08x,dwLogH=%08x,dwHeapLoc=%x,bOwnMem=%d)",
                  this,dwAddress,dwPitch,dwLogHeight,dwHeapLocation,bOwnMemory);

    // set surface values
    m_dwTotalSurfaces = 1;
    m_dwActiveSurface = m_dwPreviousSurface
                      = 0;

    // claim the first surface
    m_aSurface[0].own (dwAddress,dwPitch,dwLogHeight,dwHeapLocation,bOwnMemory);

    // done
    dbgTracePop();
    return TRUE;
}

//****************************************************************************
// CComplexSurface::disown
//
// claim an already allocated surface
template <int cMax>
BOOL CComplexSurface<cMax>::disown
(
    void
)
{
    dbgTracePush ("CComplexSurface::disown()");

    m_aSurface[0].disown();

    dbgTracePop();
    return TRUE;
}

//****************************************************************************
// CComplexSurface::swap
//
// interchange two complex surfaces

template <int cMax>
BOOL CComplexSurface<cMax>::swap
(
    CComplexSurface *pCSurf
)
{
    dbgTracePush ("CComplexSurface[%08x]::swap()", this);

    // get number of component surfaces
    DWORD dwCount = max (pCSurf->getTotalSurfaces(), getTotalSurfaces());

    // swap each component surface
    for (DWORD i=0; i<dwCount; i++) {
        m_aSurface[i].swap (&(pCSurf->m_aSurface[i]));
    }

    // done
    dbgTracePop();
    return (TRUE);
}

//****************************************************************************
// CComplexSurface::destroy
//
// frees a surface

template <int cMax>
BOOL CComplexSurface<cMax>::destroy
(
    void
)
{
    dbgTracePush ("CComplexSurface[%08x]::destroy()",this);

    // destroy and destruct all surfaces
    DWORD dwCount = getTotalSurfaces();
    for (DWORD i = 0; i < dwCount; i++)
    {
        // destroy
        if (m_aSurface[i].isValid())
        {
            m_aSurface[i].destroy();
        }

        // destruct
        m_aSurface[i].~CSimpleSurface();
    }

    // kill state
    m_dwTotalSurfaces = m_dwFlags
                      = 0;

    // done
    dbgTracePop();
    return TRUE;
}

#pragma warning (push, 1)
// NOTE: The following warning is issued incorrectly by the MS compiler. Ignore it.  <bdw>
template CComplexSurface<TOTAL_TEX_RENAME>;
template CComplexSurface<TOTAL_VB_RENAME>;
#pragma warning (pop)


//****************************************************************************
//****************************************************************************
//****************************************************************************
//**  CNvObject     **********************************************************
//****************************************************************************
//****************************************************************************
//****************************************************************************


//****************************************************************************
// CNvObject::dbgTestIntegrity
//
// tests integrity of an object

#ifdef DEBUG
void CNvObject::dbgTestIntegrity
(
    void
)
{
    dbgTracePush ("CNvObject::dbgTestIntegrity");

    // test self
    if (!isValid())
    {
        DPF ("CNvObject::dbgTestIntegrity: instance contains invalid THIS object");
        __asm int 3;
        dbgTracePop();
        return;
    }

    // test next
    if (m_pNext && !m_pNext->isValid())
    {
        DPF ("CNvObject::dbgTestIntegrity: instance contains invalid NEXT object");
        __asm int 3;
        dbgTracePop();
        return;
    }

    // test prev
    if (m_pPrev && !m_pPrev->isValid())
    {
        DPF ("CNvObject::dbgTestIntegrity: instance contains invalid PREV object");
        __asm int 3;
        dbgTracePop();
        return;
    }

    dbgTracePop();
}
#endif  // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\src\nvSurf.cpp ===
/*
 * Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 * (C) Copyright NVIDIA Corporation Inc., 1996,1998. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nvSurf.cpp                                                        *
*   Routines for management of surface lists added in DX7                   *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Craig Duttweiler (bertrem)   16Dec98    created                     *
*       Craig Duttweiler (bertrem)   05Aug99    major rework for G.U.D.     *
*                                                                           *
\***************************************************************************/
#include "nvprecomp.h"

#if (NVARCH >= 0x04)

//--------------------------------------------------------------------------

DWORD nvCreateSystemMemorySurface (LPDDRAWI_DDRAWSURFACE_LCL pDDSLcl)
{
    dbgTracePush ("nvCreateSystemMemorySurface");

    // create the basic objects
#ifndef WINNT
    CNvObject *pNvObj = new CNvObject (pDDSLcl->dwProcessId);
#else
    CNvObject *pNvObj = new CNvObject (0);
#endif // WINNT

    if (!pNvObj) {
        DPF ("nvCreateSystemMemorySurface: failed allocation of CNvObject");
        dbgD3DError();
        dbgTracePop();
        return DDERR_OUTOFMEMORY;
    }

    if (pDDSLcl->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER)
    {
        if (pDDSLcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_COMMANDBUFFER)
        {
            CCommandBuffer *pCommandBuffer = new CCommandBuffer (pNvObj, pDDSLcl);
            
            if (!pCommandBuffer) {
                pNvObj->release();
                DPF ("nvCreateSystemMemorySurface: failed to create CCommandBuffer");
                dbgD3DError();
                dbgTracePop();
                return DDERR_OUTOFMEMORY;
            }

            pNvObj->setObject (CNvObject::NVOBJ_COMMANDBUFFER, pCommandBuffer);
            pCommandBuffer->own(pDDSLcl->lpGbl->fpVidMem, pDDSLcl->lpGbl->dwLinearSize, CSimpleSurface::HEAP_SYS);
        }
        else
        {
            // assume everything else is a vertex buffer
            CVertexBuffer *pVertexBuffer = new CVertexBuffer (pNvObj);

            if (!pVertexBuffer) {
                pNvObj->release();
                DPF ("nvCreateSystemMemorySurface: failed to create CVertexBuffer");
                dbgD3DError();
                dbgTracePop();
                return DDERR_OUTOFMEMORY;
            }

            pNvObj->setObject (CNvObject::NVOBJ_VERTEXBUFFER, pVertexBuffer);
            pVertexBuffer->own(pDDSLcl->lpGbl->fpVidMem, pDDSLcl->lpGbl->dwLinearSize, CSimpleSurface::HEAP_SYS);
            pVertexBuffer->setVertexStride (0);
        }
    }

    else {

        CSimpleSurface *pSurf  = new CSimpleSurface;

        if (!pSurf) {
            pNvObj->release();
            DPF ("nvCreateSystemMemorySurface: failed allocation of CSimpleSurface");
            dbgD3DError();
            dbgTracePop();
            return DDERR_OUTOFMEMORY;
        }

        pNvObj->setObject (CNvObject::NVOBJ_SIMPLESURFACE, pSurf);

#ifdef WINNT
        // workaround for Win2K DX7 runtime bug - DXT surface size is set incorrectly
        if (pDDSLcl->lpGbl->ddpfSurface.dwFlags & DDPF_FOURCC) {
            switch(pDDSLcl->lpGbl->ddpfSurface.dwFourCC) {
            case FOURCC_DXT1:
                pDDSLcl->lpGbl->wHeight <<= 2;
                pDDSLcl->lpGbl->wWidth  >>= 1;
                break;
            case FOURCC_DXT2:
            case FOURCC_DXT3:
            case FOURCC_DXT4:
            case FOURCC_DXT5:
                pDDSLcl->lpGbl->wHeight <<= 2;
                pDDSLcl->lpGbl->wWidth  >>= 2;
                break;
            }
        }
#endif // WINNT

        // determine common surface parameters
        DWORD dwFormat, dwWidth, dwHeight, dwDepth, dwBPPRequested, dwBPPGranted, dwPitch, dwSlicePitch, dwMultiSampleBits;
        BOOL  bFourCC;
        DWORD dwRV = nvCalculateSurfaceParams (pDDSLcl, &dwFormat, &bFourCC, &dwWidth, &dwHeight, &dwDepth, &dwMultiSampleBits,
                                               &dwBPPRequested, &dwBPPGranted, &dwPitch, &dwSlicePitch, FALSE);

        if (dwRV == DDERR_INVALIDPIXELFORMAT) {
            // allow invalid (ie. unknown) pixel formats. just trust the surface
            dwFormat     = NV_SURFACE_FORMAT_UNKNOWN;
            dwPitch      = pDDSLcl->lpGbl->lPitch;
            dwSlicePitch = pDDSLcl->lpGbl->lSlicePitch;
            dwHeight     = pDDSLcl->lpGbl->wHeight;
            dwWidth      = pDDSLcl->lpGbl->wWidth;
            dwDepth      = pDDSLcl->lpSurfMore->ddsCapsEx.dwCaps4 & 0xffff;
            dwBPPGranted = dwBPPRequested = pDDSLcl->lpGbl->ddpfSurface.dwRGBBitCount/8;
        }
        else if (dwRV != DD_OK) {
            delete pSurf;
            pNvObj->release();
            dbgTracePop();
            return dwRV;
        }

#ifdef WINNT
        // MPR - MS runtime bug. pDDSLcl->lpGbl->lSlicePitch is not filled out for
        // system memory volume textures. Fortunately it is easily calculated
        if (pDDSLcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_VOLUME) {
            dwSlicePitch = dwPitch * dwHeight;
        }
#endif

        pSurf->own (pDDSLcl->lpGbl->fpVidMem, dwPitch, dwHeight, CSimpleSurface::HEAP_SYS, FALSE);
        pSurf->setWrapper (pNvObj);
        pSurf->setFormat (dwFormat);
        pSurf->setWidth (dwWidth);
        pSurf->setDepth(dwDepth);
        pSurf->setSlicePitch (dwSlicePitch);
        pSurf->setBPP (dwBPPGranted);
        pSurf->setBPPRequested (dwBPPRequested);
        if (bFourCC) {
            pSurf->setFourCC (pDDSLcl->lpGbl->ddpfSurface.dwFourCC);
        }

    }

    SET_PNVOBJ (pDDSLcl, pNvObj);

    dbgTracePop();
    return DD_OK;
}

//--------------------------------------------------------------------------

// return a pointer to the given surface's mipmap or flip chain. this is
// straightforward for regular textures and other chains but totally convoluted
// for cubemaps because MS is dumb

LPDDRAWI_DDRAWSURFACE_LCL nvFindSurfaceChain
(
    LPDDRAWI_DDRAWSURFACE_LCL pDDSLcl,
    LPATTACHLIST *ppAttachList
)
{
    DWORD dwRootFace, dwAttachedFace;

    dbgTracePush ("nvFindSurfaceChain");

    nvAssert (pDDSLcl);

    if (pDDSLcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_CUBEMAP) {
        // cubemap. seek out the proper mipmap chain
        dwRootFace = pDDSLcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_CUBEMAP_ALLFACES;
        *ppAttachList = pDDSLcl->lpAttachList;
        while (*ppAttachList) {
            dwAttachedFace = (*ppAttachList)->lpAttached->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_CUBEMAP_ALLFACES;
            if (dwAttachedFace == dwRootFace) {
                dbgTracePop();
                return (*ppAttachList)->lpAttached;
            }
            *ppAttachList = (*ppAttachList)->lpLink;
        }
    }

    else {
        // not a cubemap. just return the first thing attached
        *ppAttachList = pDDSLcl->lpAttachList;
        if (*ppAttachList) {
            dbgTracePop();
            return pDDSLcl->lpAttachList->lpAttached;
        }
    }

    dbgTracePop();
    return NULL;
}

//--------------------------------------------------------------------------

// return a pointer to the next face of the cubemap. this is convoluted
// because MS is annoying. we sort it all out here and store it internally
// in a more sane manner.

LPDDRAWI_DDRAWSURFACE_LCL nvFindNextCubemapFace
(
    LPDDRAWI_DDRAWSURFACE_LCL pDDSLclRoot,   // the root of the whole ratnest
    LPDDRAWI_DDRAWSURFACE_LCL pDDSLcl        // the surface whose next face we want to find
)
{
    LPATTACHLIST pAttachList;
    DWORD        dwThisFace, dwNextFace;

    dbgTracePush ("nvFindNextCubemapFace");

    nvAssert (pDDSLcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_CUBEMAP);
    nvAssert ((pDDSLclRoot->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_CUBEMAP_ALLFACES) == DDSCAPS2_CUBEMAP_POSITIVEX);

    // we rely on these definitions. if MS changes them, we'll have to fix
    nvAssert ((DDSCAPS2_CUBEMAP_POSITIVEX == 0x00000400L) &&
              (DDSCAPS2_CUBEMAP_NEGATIVEX == 0x00000800L) &&
              (DDSCAPS2_CUBEMAP_POSITIVEY == 0x00001000L) &&
              (DDSCAPS2_CUBEMAP_NEGATIVEY == 0x00002000L) &&
              (DDSCAPS2_CUBEMAP_POSITIVEZ == 0x00004000L) &&
              (DDSCAPS2_CUBEMAP_NEGATIVEZ == 0x00008000L));

    dwThisFace = pDDSLcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_CUBEMAP_ALLFACES;
    dwNextFace = dwThisFace << 1;

    if (dwThisFace == DDSCAPS2_CUBEMAP_NEGATIVEZ) {
        dbgTracePop();
        return NULL;
    }

    if (pDDSLclRoot->lpAttachList == NULL) {
        dbgTracePop();
        return NULL;
    }

    pAttachList = pDDSLclRoot->lpAttachList;

    while (pAttachList) {
        dwThisFace = pAttachList->lpAttached->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_CUBEMAP_ALLFACES;
        if (dwThisFace == dwNextFace) {
            dbgTracePop();
            return (pAttachList->lpAttached);
        }
        pAttachList = pAttachList->lpLink;
    }

    dbgTracePop();
    return NULL;
}

//--------------------------------------------------------------------------

DWORD nvCheckSystemMemorySurface
(
    LPDDRAWI_DDRAWSURFACE_LCL pDDSLcl
)
{
    dbgTracePush ("nvCheckSystemMemorySurface");

    nvAssert (pDDSLcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY);

    CNvObject *pNvObj = GET_PNVOBJ (pDDSLcl);

    if (!IS_VALID_PNVOBJ(pNvObj)) {
        // if this is a system memory surface, we may not have ever seen it before.
        // CreateSurfaceEx (and its subsidiaries) have to play the part of CreateSurface32.
        DWORD dwRV = nvCreateSystemMemorySurface (pDDSLcl);
        dbgTracePop();
        return dwRV;
    }

    else {
        // we've seen this surface before and have created an nvObject, but MS may have
        // moved it since we last saw it, so make sure that our pointer is up to date.
        //  (bdw) - actually, it seems that anything about it may have changed - check dimentions also
        //        - bugbug: we do not check format (although I have seen this change also)
        nvAssert (pNvObj->getClass() == CNvObject::NVOBJ_SIMPLESURFACE);
        CSimpleSurface *pSurf = pNvObj->getSimpleSurface();
        if ((pSurf->getAddress() != pDDSLcl->lpGbl->fpVidMem)
         || (pSurf->getWidth()   != pDDSLcl->lpGbl->wWidth)
         || (pSurf->getHeight()  != pDDSLcl->lpGbl->wHeight))
        {
            DWORD dwFormat, dwWidth, dwHeight, dwDepth, dwMultiSampleBits, dwBPPRequested, dwBPPGranted, dwPitch, dwSlicePitch, dwRV;
            BOOL  bFourCC;
            dwRV = nvCalculateSurfaceParams (pDDSLcl, &dwFormat, &bFourCC, &dwWidth, &dwHeight, &dwDepth, &dwMultiSampleBits,
                                             &dwBPPRequested, &dwBPPGranted, &dwPitch, &dwSlicePitch, FALSE);
            nvAssert (dwRV == DD_OK);  // really?  what about UNKNOWN formats?
            pSurf->disown();
            pSurf->own (pDDSLcl->lpGbl->fpVidMem, dwPitch, dwHeight, CSimpleSurface::HEAP_SYS, FALSE);
            pSurf->setFormat (dwFormat);
            pSurf->setWidth (dwWidth);
            pSurf->setBPP (dwBPPGranted);
            pSurf->setBPPRequested (dwBPPRequested);
        }
        dbgTracePop();
        return DD_OK;
    }

}

//--------------------------------------------------------------------------

DWORD nvAddSurfaceChainToList
(
    PNV_OBJECT_LIST           pNvObjectList,
    LPDDRAWI_DDRAWSURFACE_LCL pDDSLcl
)
{
    CNvObject                *pNvObj;
    DWORD                     dwHandle;
    LPDDRAWI_DDRAWSURFACE_LCL pChain;

    dbgTracePush ("nvAddSurfaceChainToList");

    if (pDDSLcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) {
        DWORD dwRV = nvCheckSystemMemorySurface (pDDSLcl);
        if (dwRV != DD_OK) {
            dbgTracePop();
            return dwRV;
        }
    }

    // at creation time, we will have cached the NvObject pointer in the
    // dwReserved field. retrieve it now and associate it with dwHandle

    pNvObj = GET_PNVOBJ (pDDSLcl);
    if (pNvObj) {
        dwHandle = pDDSLcl->lpSurfMore->dwSurfaceHandle;
        DWORD dwRV = nvAddObjectToList (pNvObjectList, pNvObj, dwHandle);
        if (dwRV != DD_OK) {
            dbgTracePop();
            return dwRV;
        }
    }
    else {
        nvAssert (pDDSLcl->lpGbl->fpVidMem == NULL);
        DPF ("runtime called CSEx on a surface that's already been destroyed (or was never created)");
        dbgD3DError();
    }

#ifdef DEBUG
    if (pNvObj && (pNvObj->getClass() == CNvObject::NVOBJ_SIMPLESURFACE)) {
        CSimpleSurface *pSurf = pNvObj->getSimpleSurface();
        nvAssert (pSurf->getfpVidMem() == pDDSLcl->lpGbl->fpVidMem);
        if ( pSurf->getFormat() != NV_SURFACE_FORMAT_UNKNOWN ) {
            DWORD dwPitch, dwSlicePitch, dwFormat, dwWidth, dwHeight, dwDepth, dwMultiSampleBits, dwBPPRequested, dwBPPGranted, dwRV;
            BOOL  bFourCC;
            dwRV = nvCalculateSurfaceParams (pDDSLcl, &dwFormat, &bFourCC, &dwWidth, &dwHeight, &dwDepth, &dwMultiSampleBits,
                                             &dwBPPRequested, &dwBPPGranted, &dwPitch, &dwSlicePitch, FALSE);
            nvAssert (dwRV     == DD_OK);
            nvAssert (dwFormat == pSurf->getFormat());
    #ifndef CAPTURE  // not when capturing b/c we may be spoofing allocation sizes
            if (!pSurf->isDXT()) {
                nvAssert (dwWidth  == pSurf->getWidth());
                nvAssert (dwHeight == pSurf->getHeight());
            }
    #endif
            nvAssert (dwBPPGranted == pSurf->getBPP());
        }
    }
#endif

    // get this surface's mipmap or flip chain, if any
    LPATTACHLIST lpAttachList;
    pChain = nvFindSurfaceChain (pDDSLcl, &lpAttachList);

    while (pChain) {

        // check if we are back at the beginning - this happens with flip chains
        if (pChain == pDDSLcl) break;

#ifndef WINNT
        BOOL bImplicit = lpAttachList->dwFlags & DDAL_IMPLICIT;
#else
        // simulate the implicit flag by checking for a NULL dwReserved1
        // this is only needed for flip chains with attached z-buffers, so it should
        // always be true for textures
        BOOL bImplicit = (GET_PNVOBJ(pChain) != NULL) | (pDDSLcl->ddsCaps.dwCaps & DDSCAPS_TEXTURE);
#endif // !WINNT

        // assign handle for implicitly attached surfaces only
        if (bImplicit) {
            // create an NvObject etc if necessary
            if (pDDSLcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) {
                DWORD dwRV = nvCheckSystemMemorySurface (pChain);
                if (dwRV != DD_OK) {
                    dbgTracePop();
                    return dwRV;
                }
            }

            if (pNvObj) {
                // attach the last one to this one
                pNvObj->setAttachedA (GET_PNVOBJ (pChain));
            }

            // add the new one to the list
            pNvObj = GET_PNVOBJ (pChain);
            if (pNvObj) {
                dwHandle = pChain->lpSurfMore->dwSurfaceHandle;
                DWORD dwRV = nvAddObjectToList (pNvObjectList, pNvObj, dwHandle);
                if (dwRV != DD_OK) {
                    dbgTracePop();
                    return dwRV;
                }
            }
            else {
                nvAssert (pChain->lpGbl->fpVidMem == NULL);
                DPF ("runtime called CSEx on a surface that's already been destroyed (or was never created)");
                dbgD3DError();
            }

#ifdef DEBUG
            if (pNvObj && (pNvObj->getClass() == CNvObject::NVOBJ_SIMPLESURFACE)) {
                CSimpleSurface *pSurf = pNvObj->getSimpleSurface();
                nvAssert (pSurf->getfpVidMem() == pChain->lpGbl->fpVidMem);
                if (pSurf->getFormat() != NV_SURFACE_FORMAT_UNKNOWN) {
                    DWORD dwPitch, dwSlicePitch, dwFormat, dwWidth, dwHeight, dwDepth, dwMultiSampleBits, dwBPPRequested, dwBPPGranted, dwRV;
                    BOOL  bFourCC;
                    dwRV = nvCalculateSurfaceParams (pChain, &dwFormat, &bFourCC, &dwWidth, &dwHeight, &dwDepth, &dwMultiSampleBits,
                                                     &dwBPPRequested, &dwBPPGranted, &dwPitch, &dwSlicePitch, FALSE);
                    nvAssert (dwRV     == DD_OK);
                    nvAssert (dwFormat == pSurf->getFormat());
                    if (!pSurf->isDXT()) {  // what if CAPTURE is on?
                        nvAssert (dwWidth  == pSurf->getWidth());
                        nvAssert (dwHeight == pSurf->getHeight());
                    }
                    nvAssert (dwBPPGranted == pSurf->getBPP());
                }
            }
#endif
            // get the next attach list
            lpAttachList = pChain->lpAttachList;
        }
        else { // !bImplicit
            lpAttachList = lpAttachList->lpLink;
        }

        // get the next surface
        pChain = lpAttachList ? lpAttachList->lpAttached : NULL;

    }  // while (pChain)

    dbgTracePop();
    return DD_OK;
}

//--------------------------------------------------------------------------

DWORD nvDeleteSystemMemorySurface (LPDDRAWI_DDRAWSURFACE_LCL pDDSLcl)
{
    dbgTracePush ("nvDeleteSystemMemorySurface");

    // retrieve the basic objects
    CNvObject *pNvObj = GET_PNVOBJ (pDDSLcl);

    if (IS_VALID_PNVOBJ(pNvObj)) {
        nvClearObjectListEntry (pNvObj, &global.pNvSurfaceLists);
        pNvObj->release();
        SET_PNVOBJ (pDDSLcl, NULL);
    }
    else if (pNvObj) {
        // this is likely a contextdma
        NvRmFree (pDriverData->dwRootHandle, pDriverData->dwRootHandle, (DWORD)pNvObj);
    }

    dbgTracePop();
    return DD_OK;
}

//--------------------------------------------------------------------------

// DX7 callback to let the driver know the value of the handle with
// which a newly created surface (an NvObject) will be associated

DWORD __stdcall nvCreateSurfaceEx
(
    LPDDHAL_CREATESURFACEEXDATA lpcsed
)
{
    LPDDRAWI_DDRAWSURFACE_LCL pDDSLcl;
    PNV_OBJECT_LIST           pNvObjectList;
    CNvObject                *pLastFace;
    DWORD                     dwDDLclID;

    dbgTracePush ("nvCreateSurfaceEx");

    nvSetDriverDataPtrFromDDGbl (lpcsed->lpDDLcl->lpGbl);

    // get ourselves a surface list
    dwDDLclID = (DWORD)(lpcsed->lpDDLcl);
    pNvObjectList = nvFindObjectList (dwDDLclID, &global.pNvSurfaceLists);
    if (pNvObjectList == NULL) {
        // find will create a list if it doesn't already exist
        // a return value of NULL indicates that a new list could not be created
        NvReleaseSemaphore(pDriverData);
        lpcsed->ddRVal = DDERR_OUTOFMEMORY;
        dbgTracePop();
        return DDHAL_DRIVER_HANDLED;
    }

    pDDSLcl = lpcsed->lpDDSLcl;

    if ((pDDSLcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) && (!pDDSLcl->lpGbl->fpVidMem)) {
        // Microsoft's way of letting us know that a system memory surface is being destroyed.
        DPF_LEVEL(NVDBG_LEVEL_SURFACE_ACTIVITY, "CSEx: destroy system surface, handle = %02x",
            pDDSLcl->lpSurfMore->dwSurfaceHandle);
        nvDeleteSystemMemorySurface (pDDSLcl);
        NvReleaseSemaphore(pDriverData);
        lpcsed->ddRVal = DD_OK;
        dbgTracePop();
        return DDHAL_DRIVER_HANDLED;
    }

    DPF_LEVEL(NVDBG_LEVEL_SURFACE_ACTIVITY, "CreateSurfaceEx: pDDSLcl = 0x%08x, fpVidMem = 0x%08x, handle = %02x",
        pDDSLcl, pDDSLcl->lpGbl->fpVidMem, pDDSLcl->lpSurfMore->dwSurfaceHandle);
    // handle the first chain of surfaces (flip chain, mipmap chain, etc)
    DWORD dwRV = nvAddSurfaceChainToList (pNvObjectList, pDDSLcl);
    if (dwRV != DD_OK)
    {
        NvReleaseSemaphore(pDriverData);
        lpcsed->ddRVal = dwRV;
        dbgTracePop();
        return DDHAL_DRIVER_HANDLED;
    }

    // iterate through linked attach lists to handle cube maps
    if (pDDSLcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_CUBEMAP) {

        // cache a pointer to the current face then get the next one
        pLastFace = GET_PNVOBJ (pDDSLcl);
        pDDSLcl = nvFindNextCubemapFace (lpcsed->lpDDSLcl, pDDSLcl);

        while (pDDSLcl) {
            // add this face's chain to out list
            dwRV = nvAddSurfaceChainToList (pNvObjectList, pDDSLcl);
            if (dwRV != DD_OK)
            {
                NvReleaseSemaphore(pDriverData);
                lpcsed->ddRVal = dwRV;
                dbgTracePop();
                return DDHAL_DRIVER_HANDLED;
            }

            // make the last face point to this one
            pLastFace->setAttachedB (GET_PNVOBJ (pDDSLcl));

            // advance
            pLastFace = GET_PNVOBJ (pDDSLcl);
            pDDSLcl = nvFindNextCubemapFace (lpcsed->lpDDSLcl, pDDSLcl);
        }

    }

    NvReleaseSemaphore(pDriverData);
    lpcsed->ddRVal = DD_OK;
    dbgTracePop();
    return DDHAL_DRIVER_HANDLED;
}

//-------------------------------------------------------------------------

// lock all textures referenced in the current combiner setup for use by the HW

void nvHWLockTextures
(
    PNVD3DCONTEXT pContext
)
{
    // late binding of texture handles set with D3DRENDERSTATE_TEXTUREHANDLE (accomodates retained mode junk)
    DWORD dwTextureHandle = pContext->tssState[0].dwHandle;
    if (dwTextureHandle) {
        pContext->tssState[0].dwValue[D3DTSS_TEXTUREMAP] = (DWORD) nvGetObjectFromHandle (pContext->dwDDLclID, dwTextureHandle, &global.pNvSurfaceLists);
        pContext->tssState[0].dwHandle = 0;
    }

    for (DWORD i = 0; i < 8; i++) {
        CNvObject *pNvObj = (CNvObject *)(pContext->tssState[i].dwValue[D3DTSS_TEXTUREMAP]);
        if (pNvObj) {
            CTexture *pTexture = pNvObj->getTexture();
            // we have to check that the 'textures' that are loaded really are
            // textures. some apps (like lego island) will pass in normal surfaces
            // as textures and cause us to fault
            if (pTexture && 
               (pTexture->getLinear() != pContext->pRenderTarget) &&
               (pTexture->getSwizzled() != pContext->pRenderTarget)) {
                // lock the texture
                pTexture->hwLock (pContext, CSimpleSurface::LOCK_NORMAL);
                // lock the palette
                CNvObject *pPaletteObj = pNvObj->getPalette();
                if (pPaletteObj) {
                    pPaletteObj->getPaletteSurface()->hwLock(CSimpleSurface::LOCK_NORMAL);
                }
            } else {
//              pContext->tssState[i].dwValue[D3DTSS_TEXTUREMAP] = NULL;
                //don't set this to NULL-- it should be failed in validate instead
                //set to a default texture at last second if they really insist
            }
        }
    }

    //lock the zbuffer and render targets as well for synchronizations with Locks of RT or ZB.
    // -/- could optimize this a bit if the 'ZBuffer' writes have been turned off -/-
#if (NVARCH >= 0x020)
    CSimpleSurface *pRenderTarget = pContext->kelvinAA.GetCurrentRT(pContext);
    CSimpleSurface *pZetaBuffer = pContext->kelvinAA.GetCurrentZB(pContext);
#else
    CSimpleSurface *pRenderTarget = pContext->pRenderTarget;
    CSimpleSurface *pZetaBuffer = pContext->pZetaBuffer;
#endif

    pRenderTarget->hwLock(CSimpleSurface::LOCK_NORMAL);
    if (pZetaBuffer) pZetaBuffer->hwLock(CSimpleSurface::LOCK_NORMAL);
}

//-------------------------------------------------------------------------

// unlock all textures referenced in the current combiner setup for use by the HW

void nvHWUnlockTextures
(
    PNVD3DCONTEXT pContext
)
{
    nvAssert(pContext);

    for (DWORD i = 0; i < 8; i++) {
        CNvObject *pNvObj = (CNvObject *)(pContext->tssState[i].dwValue[D3DTSS_TEXTUREMAP]);
        if (pNvObj) {
            CTexture  *pTexture = pNvObj->getTexture();
            
            if (pTexture &&
               (pTexture->getLinear() != pContext->pRenderTarget) &&
               (pTexture->getSwizzled() != pContext->pRenderTarget)) {
                // unlock the texture
                pNvObj->getTexture()->hwUnlock();
                // unlock the palette
                CNvObject *pPaletteObj = pNvObj->getPalette();
                if (pPaletteObj) {
                    pPaletteObj->getPaletteSurface()->hwUnlock();
                }
            }
        }
    }

    //unlock rendertarget and zbuffer
#if (NVARCH >= 0x020)
    CSimpleSurface *pRenderTarget = pContext->kelvinAA.GetCurrentRT(pContext);
    CSimpleSurface *pZetaBuffer = pContext->kelvinAA.GetCurrentZB(pContext);
#else
    CSimpleSurface *pRenderTarget = pContext->pRenderTarget;
    CSimpleSurface *pZetaBuffer = pContext->pZetaBuffer;
#endif

    nvAssert(pRenderTarget);
    pRenderTarget->hwUnlock();
    if (pZetaBuffer) pZetaBuffer->hwUnlock();
}

//-------------------------------------------------------------------------

// lock the first dwCount vertex streams for use by HW

void nvHWLockStreams
(
    PNVD3DCONTEXT pContext,
    DWORD         dwCount
)
{
    if(pContext->dwFlags & CONTEXT_NEEDS_VTX_CACHE_FLUSH)
    {
#if (NVARCH >= 0x020)
        if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
            nvglSetNv20KelvinInvalidateVertexCache (NV_DD_KELVIN);
        }
        else
#endif
#if (NVARCH >= 0x010)
        if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {
            nvglSetNv10CelsiusInvalidateVertexCache (NV_DD_CELSIUS);
        }
#endif
        pContext->dwFlags &= ~CONTEXT_NEEDS_VTX_CACHE_FLUSH;
    }

    for (DWORD i=0; i<dwCount; i++) {
        if (pContext->ppDX8Streams[i] != NULL) {
#ifdef MCFD
            pContext->ppDX8Streams[i]->LockForGPU (CSimpleSurface::LOCK_READ);
#else
            pContext->ppDX8Streams[i]->hwLock (CSimpleSurface::LOCK_NORMAL);
#endif
        }
    }
}

//-------------------------------------------------------------------------

// release the HW lock on the first dwCount vertex streams

void nvHWUnlockStreams
(
    PNVD3DCONTEXT pContext,
    DWORD         dwCount
)
{
    for (DWORD i=0; i<dwCount; i++) {
        if (pContext->ppDX8Streams[i] != NULL) {
#ifdef MCFD
            pContext->ppDX8Streams[i]->UnlockForGPU ();
#else
            pContext->ppDX8Streams[i]->hwUnlock ();
#endif
        }
    }
}

#endif // NVARCH >= 0x04
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\src\nvTexManage.cpp ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
//
//  Module: nvTexManage.cpp
//        texture management routines
//
//  History:
//        Craig Duttweiler      (bertrem)       3Dec99      created
//
// **************************************************************************
#include "nvprecomp.h"
#pragma hdrstop


#if (NVARCH >= 0x04)

#ifdef TEX_MANAGE

//---------------------------------------------------------------------------

BOOL nvTexManageInit
(
    PNVD3DCONTEXT pContext
)
{
    dbgTracePush ("nvTexManageInit");

    pContext->texManData.dwTextureListInUse = NV_TEXMAN_DEFAULT_CLASS;

    for (DWORD i=0; i<NV_TEXMAN_NUM_CLASSES; i++) {
        pContext->texManData.pTextureLRU[i] = NULL;
        pContext->texManData.pTextureMRU[i] = NULL;
    }

    pContext->texManData.pTextureToEvict = NULL;

    dbgTracePop();
    return (TRUE);
}

//---------------------------------------------------------------------------

// add a managed texture to pContext's list for class dwClass

BOOL nvTexManageAddTexture
(
    PNVD3DCONTEXT pContext,
    CTexture     *pTexture,
    DWORD         dwClass
)
{
    dbgTracePush ("nvTexManageAddTexture");

    if (!pContext)
    {
        pContext = nvGetPreapprovedContext();
    }
    nvAssert (pContext);
    nvAssert (pTexture && pTexture->isManaged() && pTexture->isBaseTexture());

    CTexture *pListTail = pContext->texManData.pTextureMRU[dwClass];

    pTexture->setPrev (pListTail);
    pTexture->setNext (NULL);

    if (pListTail) {
        pListTail->setNext (pTexture);
    }

    pContext->texManData.pTextureMRU[dwClass] = pTexture;

    if (pContext->texManData.pTextureLRU[dwClass] == NULL) {
        pContext->texManData.pTextureLRU[dwClass] = pTexture;
    }

    pTexture->setContext (pContext);

    dbgTracePop();
    return (TRUE);
}

//---------------------------------------------------------------------------

// remove a texture from the class lists

BOOL nvTexManageRemoveTexture
(
    CTexture *pTexture
)
{
    dbgTracePush ("nvTexManageRemoveTexture");

    nvAssert (pTexture && pTexture->isManaged() && pTexture->isBaseTexture());

    PNVD3DCONTEXT pContext = pTexture->getContext();
    CTexture     *pNext    = pTexture->getNext();
    CTexture     *pPrev    = pTexture->getPrev();

    nvAssert (pContext);

    // if the eviction pointer was pointing to this texture, advance it
    if (pContext->texManData.pTextureToEvict == pTexture) {
        nvTexManageAdvancePtr (pContext);
    }

    if (pNext) {
        nvAssert (pNext->getPrev() == pTexture);  // sanity
        pNext->setPrev (pPrev);
    }
    else {
        // this was the end of the list. find the relevant list-end pointer and clean it up
        for (DWORD i=0; i<NV_TEXMAN_NUM_CLASSES; i++) {
            if (pContext->texManData.pTextureMRU[i] == pTexture) break;
        }
        nvAssert (i<NV_TEXMAN_NUM_CLASSES);
        pContext->texManData.pTextureMRU[i] = pPrev;
    }

    if (pPrev) {
        nvAssert (pPrev->getNext() == pTexture);  // sanity
        pPrev->setNext (pNext);
    }
    else {
        // this was the start of the list. find the relevant list-head pointer and clean it up
        for (DWORD i=0; i<NV_TEXMAN_NUM_CLASSES; i++) {
            if (pContext->texManData.pTextureLRU[i] == pTexture) break;
        }
        nvAssert (i<NV_TEXMAN_NUM_CLASSES);
        pContext->texManData.pTextureLRU[i] = pNext;
    }

    pTexture->setNext    (NULL);
    pTexture->setPrev    (NULL);
    pTexture->setContext (NULL);

    dbgTracePop();
    return (TRUE);
}

//---------------------------------------------------------------------------

// advance to the next non-null list, after (and _inclusive_ of dwList)

BOOL nvTexManageAdvanceList
(
    PNVD3DCONTEXT pContext,
    DWORD         dwList
)
{
    dbgTracePush ("nvTexManageAdvanceList");

    // try to find a non-empty list
    while (dwList < NV_TEXMAN_NUM_CLASSES) {
        if (pContext->texManData.pTextureLRU[dwList] != NULL) {
            pContext->texManData.dwTextureListInUse = dwList;
            pContext->texManData.pTextureToEvict = pContext->texManData.pTextureLRU[dwList];
            dbgTracePop();
            return (TRUE);
        }
        dwList++;
    }

    pContext->texManData.dwTextureListInUse = 0;
    pContext->texManData.pTextureToEvict = NULL;

    dbgTracePop();
    return (FALSE);
}

//---------------------------------------------------------------------------

// reset the eviction pointer

BOOL nvTexManageResetPtr
(
    PNVD3DCONTEXT pContext
)
{
    dbgTracePush ("nvTexManageResetPtr");
    BOOL bRV = nvTexManageAdvanceList (pContext, 0);
    dbgTracePop();
    return (bRV);
}

//---------------------------------------------------------------------------

// advance the eviction pointer

BOOL nvTexManageAdvancePtr
(
    PNVD3DCONTEXT pContext
)
{
    BOOL bSuccess;

    dbgTracePush ("nvTexManageAdvancePtr");

    if (pContext->texManData.pTextureToEvict == NULL) {
        // reset everything
        bSuccess = nvTexManageResetPtr (pContext);
    }

    else {
        pContext->texManData.pTextureToEvict = (pContext->texManData.pTextureToEvict)->getNext();
        if (pContext->texManData.pTextureToEvict == NULL) {
            // we've fallen off the end of the list, advance to the next nonempty list
            bSuccess = nvTexManageAdvanceList (pContext, pContext->texManData.dwTextureListInUse+1);
        }
        else {
            bSuccess = TRUE;
        }
    }

    dbgTracePop();
    return (bSuccess);
}

//---------------------------------------------------------------------------

// nvTexManageEvict
//
// evicts a texture from pContext (or elsewhere, contingent on the protocol).
// see nvTexManage.h for possible values of dwProtocol.
//
// returns TRUE upon successful eviction, else FALSE

BOOL nvTexManageEvict
(
    PNVD3DCONTEXT pContext,
    DWORD         dwProtocol
)
{
    CTexture *pTexture;

    dbgTracePush ("nvTexManageEvict");

    switch (dwProtocol) {

        case NV_TEXMAN_EVICTION_PROTOCOL_ANY:
            // recurse on all protocols
            dwProtocol = NV_TEXMAN_EVICTION_PROTOCOL_PASSIVE;
            while (dwProtocol <= NV_TEXMAN_EVICTION_PROTOCOL_SEVERE) {
                if (nvTexManageEvict (pContext, dwProtocol)) {
                    dbgTracePop();
                    return (TRUE);
                }
                dwProtocol++;
            }
            break;

        case NV_TEXMAN_EVICTION_PROTOCOL_SEVERE:
            // recurse on all contexts, beginning with this one
            PNVD3DCONTEXT pCtxt;
            pCtxt = pContext;
            while (pCtxt) {
                if (nvTexManageEvict (pCtxt, NV_TEXMAN_EVICTION_PROTOCOL_AGGRESSIVE)) {
                    dbgTracePop();
                    return (TRUE);
                }
                pCtxt = pCtxt->pContextNext;
            }
            pCtxt = pContext->pContextPrev;
            while (pCtxt) {
                if (nvTexManageEvict (pCtxt, NV_TEXMAN_EVICTION_PROTOCOL_AGGRESSIVE)) {
                    dbgTracePop();
                    return (TRUE);
                }
                pCtxt = pCtxt->pContextPrev;
            }
            break;

        default:
            pTexture = pContext->texManData.pTextureToEvict;

            if (!pTexture) {
                nvTexManageResetPtr (pContext);
                pTexture = pContext->texManData.pTextureToEvict;
            }

            while (pTexture) {
                if (dwProtocol == NV_TEXMAN_EVICTION_PROTOCOL_AGGRESSIVE) {
                    // force the HW to give up this texture
					DDLOCKINDEX(NVSTAT_LOCK_TEXMAN_EVICT);
                    pTexture->cpuLockSwz (CSimpleSurface::LOCK_NORMAL);
                }
                if (pTexture->evict()) {
                    nvTexManageRemoveTexture (pTexture);
                    DPF_LEVEL (NVDBG_LEVEL_TEXMAN, "texman: evicted %08x at address %08x of size %08x, protocol=%d", pTexture, 
                                                pTexture->getSwizzled()->getAddress,pTexture->getSize(),dwProtocol);
                    dbgTracePop();
                    return (TRUE);
                }
                nvTexManageAdvancePtr (pContext);
                pTexture = pContext->texManData.pTextureToEvict;
            }
            break;

    }  // switch

    DPF_LEVEL (NVDBG_LEVEL_TEXMAN, "texman: eviction FAILED, protocol=%d", dwProtocol);

    dbgTracePop();
    return (FALSE);
}

//---------------------------------------------------------------------------

// nvTexManageEvictAll
//
// evict all managed textures associated with pContext.
// if pContext is NULL, evict all textures in all contexts

BOOL nvTexManageEvictAll
(
    PNVD3DCONTEXT pContext
)
{
    CTexture *pTexture;
    BOOL bSuccess = TRUE;

    dbgTracePush ("nvTexManageEvictAll: pContext=%08x", pContext);

    if (!pContext) {
        pContext = (PNVD3DCONTEXT) getDC()->dwContextListHead;
        while (pContext) {
            if (!nvTexManageEvictAll (pContext)) {
                bSuccess = FALSE;
            }
            pContext = pContext->pContextNext;
        }
        dbgTracePop();
        return (bSuccess);
    }

    nvTexManageResetPtr (pContext);
    pTexture = pContext->texManData.pTextureToEvict;

    while (pTexture) {
        // force the HW to give up this texture
		DDLOCKINDEX(NVSTAT_LOCK_TEXMAN_EVICT_ALL);
        pTexture->cpuLockSwz (CSimpleSurface::LOCK_NORMAL);
        if (pTexture->evict()) {
            nvTexManageRemoveTexture (pTexture);
            DPF_LEVEL (NVDBG_LEVEL_TEXMAN, "texman: evictAll evicted %08x at address %08x of size %08x from context %08x", 
                                            pTexture, pTexture->getSwizzled()->getAddress(),pTexture->getSize(),pContext);
        }
        else {
            bSuccess = FALSE;
            DPF ("texman: evictAll unable to evict %08x", pTexture);
            dbgD3DError();
            nvTexManageAdvancePtr (pContext);
        }
        pTexture->cpuUnlockSwz();
        pTexture = pContext->texManData.pTextureToEvict;
    }

    dbgTracePop();
    return (bSuccess);
}

//---------------------------------------------------------------------------

// nvTexManageFetch
//
// fetches a texture from system memory into video or AGP mempory.
// other textures are evicted from pContext as necessary.

BOOL nvTexManageFetch
(
    PNVD3DCONTEXT pContext,  // may be NULL!!
    CTexture     *pTexture
)
{
    BOOL bFetchSuccess, bEvictionSuccess;

    dbgTracePush ("nvTexManageFetch");

    DPF_LEVEL (NVDBG_LEVEL_TEXMAN, "texman: fetching %08x", pTexture);

    nvAssert (pTexture && pTexture->isManaged());

    if (!pContext) {
        // totally arbitrary. for lack of any context with which to
        // associate this texture, just stick it in the first
        pContext = (PNVD3DCONTEXT) getDC()->dwContextListHead;
    }

    bFetchSuccess = pTexture->fetch();

    if (!bFetchSuccess) {
        nvTexManageResetPtr (pContext);
        do {
            // evict something and try again
            bEvictionSuccess = nvTexManageEvict (pContext, NV_TEXMAN_EVICTION_PROTOCOL_ANY);
            if (bEvictionSuccess) {
                bFetchSuccess = pTexture->fetch();
            }
        } while (bEvictionSuccess && !bFetchSuccess);
    }

    if (bFetchSuccess) {
        nvAssert ((pTexture->getPrev() == NULL) &&
                  (pTexture->getNext() == NULL));
        nvTexManageAddTexture (pContext, pTexture, NV_TEXMAN_DEFAULT_CLASS);
    }

#ifdef DEBUG
    if (bFetchSuccess) {
        DWORD dwHeap = pTexture->getSwizzled()->getHeapLocation();
        DPF_LEVEL (NVDBG_LEVEL_TEXMAN, "texman: fetched %08x at address %08x of size %08x into %s memory",
                   pTexture,
                   pTexture->getSwizzled()->getAddress(),
                   pTexture->getSize(),
                   (dwHeap == CSimpleSurface::HEAP_VID) ? "video" :
                   (dwHeap == CSimpleSurface::HEAP_AGP) ? "agp"   :
                   (dwHeap == CSimpleSurface::HEAP_PCI) ? "pci"   : "unknown");
    }
    else {
        DPF_LEVEL (NVDBG_LEVEL_TEXMAN, "texman: fetch of %08x FAILED", pTexture);
    }
#endif

    dbgTracePop();
    return (bFetchSuccess);
}

//---------------------------------------------------------------------------

// nvTexManageTouch
//
// "touches" a texture. texture is moved from its current location in the
// eviction lists to the MRU slot.

BOOL nvTexManageTouch
(
    PNVD3DCONTEXT pContext,  // may be NULL!
    CTexture     *pTexture
)
{
    dbgTracePush ("nvTexManageTouch");

    nvAssert (pTexture && pTexture->isManaged() && pTexture->isBaseTexture());

    if (!nvTexManageRemoveTexture (pTexture)) {
        DPF ("failed to remove a managed texture from the LRU lists");
        dbgTracePop();
        return (FALSE);
    }

    if (!pContext) {
        // totally arbitray. for lack of any context with which to
        // associate this texture, just stick it in the first
        pContext = (PNVD3DCONTEXT) getDC()->dwContextListHead;
    }

    if (!nvTexManageAddTexture (pContext, pTexture, NV_TEXMAN_DEFAULT_CLASS)) {
        DPF ("failed to add a managed texture to the LRU lists");
        dbgTracePop();
        return (FALSE);
    }

    dbgTracePop();
    return (TRUE);
}

//---------------------------------------------------------------------------

// nvTexManageSceneEnd
//
// texture management done whenever scene end is called.
// under current scheme, we basically just shuffle some eviction lists around

BOOL nvTexManageSceneEnd
(
    PNVD3DCONTEXT pContext
)
{
    dbgTracePush ("nvTexManageSceneEnd");

    // list 2 (previous frame) goes onto the end of list 0 (old frames)
    CTexture *pList0Tail = pContext->texManData.pTextureMRU[0];
    CTexture *pList2Head = pContext->texManData.pTextureLRU[2];

    if (pList2Head) {
        if (pList0Tail) {
            // list0 exists. attach list2 at the end
            pList0Tail->setNext (pList2Head);
            pList2Head->setPrev (pList0Tail);
        }
        else {
            // there is no list0. list0 <= list2
            pContext->texManData.pTextureLRU[0] = pList2Head;
        }
        pContext->texManData.pTextureMRU[0] = pContext->texManData.pTextureMRU[2];
    }

    // list 1 (most recent frame) becomes list 2 (previous frame)
    pContext->texManData.pTextureLRU[2] = pContext->texManData.pTextureLRU[1];
    pContext->texManData.pTextureMRU[2] = pContext->texManData.pTextureMRU[1];

    // list 1 (most recent frame) is now empty
    pContext->texManData.pTextureLRU[1] = NULL;
    pContext->texManData.pTextureMRU[1] = NULL;

    dbgTracePop();
    return (TRUE);
}

#endif

#endif // NVARCH >= 0x04
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\src\nvTri.cpp ===
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nvTri.cpp                                                         *
*   NV4 Old Execute Buffer Style RenderPrimitive DDI routines.              *
*   NOTE: Uses indexed primitive rendering routines in NV4INDEX.C           *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Charles Inman (chasi)       01/31/98 - created                      *
*                                                                           *
\***************************************************************************/
#include "nvprecomp.h"

#if (NVARCH >= 0x04)

PFNRENDERPRIMITIVEOP pfnRenderPrimitiveOperation[] =
{
    nvRenderNoOp,           // Op codes are 1 based, so 0 is a no op.
    nvRenderPoint,
    nvRenderLine,
    nvRenderTriangle,
    nvRenderNoOp,           // 4  - not supported.
    nvRenderNoOp,           // 5  - not supported.
    nvRenderNoOp,           // 6  - not supported.
    nvRenderNoOp,           // 7  - not supported.
    nvRenderNoOp,           // 8  - not supported.
    nvRenderNoOp,           // 9  - not supported.
    nvRenderNoOp,           // 10 - not supported.
    nvRenderNoOp,           // 11 - not supported.
    nvRenderNoOp,           // 12 - not supported.
    nvRenderNoOp,           // 13 - not supported.
    nvRenderNoOp            // 14 - not supported.
};

//---------------------------------------------------------------------------

DWORD nvRenderNoOp
(
    NV_INNERLOOP_ARGLIST
)
{
    DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvRenderNoOp - Unhandled instruction opcode");
    return (DD_OK);
}

//---------------------------------------------------------------------------

DWORD nvRenderTriangle
(
    NV_INNERLOOP_ARGLIST
)
{
    /*
     * Call the appropriate wrapper function.
     */
    switch (pContext->dwRenderState[D3DRENDERSTATE_FILLMODE])
    {
        case D3DFILL_SOLID:
            nvTriangleDispatch (NV_INNERLOOP_ARGS);
            break;
        case D3DFILL_WIREFRAME:
            nvIndexedWireframeTriangle (NV_INNERLOOP_ARGS);
            break;
        case D3DFILL_POINT:
            nvIndexedPointTriangle (NV_INNERLOOP_ARGS);
            break;
    }
    return (DD_OK);
}

//---------------------------------------------------------------------------

#ifndef WINNT  // these calls are obsolete on NT (DX7)

// Old style execute buffer entry point.
// This callback is invoked when a primitive is to be rendered.
// All the data is known to be clipped.

DWORD __stdcall nvRenderPrimitive
(
    LPD3DHAL_RENDERPRIMITIVEDATA prd
)
{
    LPD3DINSTRUCTION    lpIns;
    LPBYTE              lpData;
    DWORD               dwPrimCount;
    LPWORD              lpPrim;
    LPBYTE              lpVertices;

#if (NVARCH >= 0x10)
    if (pDriverData->nvD3DPerfData.dwNVClasses & (NVCLASS_FAMILY_CELSIUS | NVCLASS_FAMILY_KELVIN)) {
        DPF ("ugh. need to implement nvRenderPrimitive for celsius / kelvin");
        dbgD3DError();
        prd->ddrval = DD_OK;
        return (DDHAL_DRIVER_HANDLED);
    }
#endif

#ifdef NV_NULL_DRIVER
    prd->ddrval = DD_OK;
    return (DDHAL_DRIVER_HANDLED);
#endif //NV_NULL_DRIVER

    // get the context
    PNVD3DCONTEXT pContext;
    NV_SET_CONTEXT (pContext, prd);

    // Get pointer to global driver. data structure.
    nvSetDriverDataPtrFromContext(pContext);

    if (getDC()->dwEnableStatus != CDriverContext::DC_ENABLESTATUS_ENABLED)
    {
        dbgD3DError();
        DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvRenderPrimitive - Bad Context");
        prd->ddrval = D3DHAL_CONTEXT_BAD;
        NvReleaseSemaphore(pDriverData);
        return (DDHAL_DRIVER_HANDLED);
    }

    // Check z-visibility test.
    if (pContext->dwRenderState[D3DRENDERSTATE_ZVISIBLE])
    {
        // If you don't implement Z visibility testing, just do this.
        prd->dwStatus &= ~D3DSTATUS_ZNOTVISIBLE;
        prd->ddrval    = DD_OK;
        NvReleaseSemaphore(pDriverData);
        return (DDHAL_DRIVER_HANDLED);
    }

    // Need to make sure that an unfriendly mode switch didn't sneak and not cause
    // us to get re-enabled properly.
    if (pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_RECOVERYNEEDED_D3D) {
        if (pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_COMPLETE) {
            nvD3DRecover();
        }
        else {
            prd->ddrval = DD_OK;
            NvReleaseSemaphore(pDriverData);
            return (DDHAL_DRIVER_HANDLED);
        }
    }

    if ((pContext->bStateChange || pDriverData->TwoDRenderingOccurred)
     || (pDriverData->dDrawSpareSubchannelObject != D3D_DX5_TEXTURED_TRIANGLE))
        NV_FORCE_TRI_SETUP(pContext);

    pContext->pCurrentVShader->create (pContext, D3DFVF_TLVERTEX, CVertexShader::getHandleFromFvf(D3DFVF_TLVERTEX));

#if (NVARCH >= 0x010)
    pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_TL_MODE |
                                      CELSIUS_DIRTY_FVF |
                                      CELSIUS_DIRTY_LIGHTS;
    pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_FVF |
                                      KELVIN_DIRTY_LIGHTS;
#endif  // nv10

    // If the context has changed since the last render call, switch it now.
    nvSetD3DSurfaceState(pContext);

    // Prepare to parse the instructions.
    prd->ddrval = DD_OK;
    lpData      = (LPBYTE)(VIDMEM_ADDR(((LPDDRAWI_DDRAWSURFACE_INT)prd->lpExeBuf)->lpLcl->lpGbl->fpVidMem));
    lpIns       = &prd->diInstruction;
    dwPrimCount = lpIns->wCount;
    lpPrim      = (LPWORD)(lpData + prd->dwOffset);
    lpVertices  = (LPBYTE)(VIDMEM_ADDR((LPDDRAWI_DDRAWSURFACE_INT)prd->lpTLBuf)->lpLcl->lpGbl->fpVidMem + prd->dwTLOffset);

    switch (lpIns->bOpcode) {
        case 1:
            pContext->dp2.dwDP2Prim = D3DDP2OP_POINTS;
            break;
        case 2:
            pContext->dp2.dwDP2Prim = D3DDP2OP_INDEXEDLINELIST;
            break;
        case 3:
            pContext->dp2.dwDP2Prim = D3DDP2OP_INDEXEDTRIANGLELIST;
            break;
        default:
            DPF ("unsupported primitive type in nvRenderPrimitive");
            dbgD3DError();
            break;
    }

    pContext->dp2.dwIndices = (DWORD)(lpPrim);

    pfnRenderPrimitiveOperation[lpIns->bOpcode] (pContext, (WORD)dwPrimCount);

    // Update the put offset.
    nvPusherStart (FALSE);

    // The DEBUG driver has a flag that can be set to force a flush after every triangle
    // rendering call.  This is helpful for debugging when dbgFrontRender is enabled.
    dbgFlushType (NVDBG_FLUSH_PRIMITIVE);

    // Tell DDRAW that thee global clip state has changed.
    // Probably don't need this, but I'd rather be safe.
    pDriverData->ddClipUpdate = TRUE;

    // Show that 3D rendering has occurred.
    pDriverData->TwoDRenderingOccurred   = 0;
    pDriverData->ThreeDRenderingOccurred = TRUE;

    // Return successfully.
    NvReleaseSemaphore(pDriverData);
    return (DDHAL_DRIVER_HANDLED);
}

#endif // !WINNT

#endif  // NVARCH >= 0x04
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\src\nvTranslate.cpp ===
/*
 * (C) Copyright NVIDIA Corporation Inc., 1996,1997,1998. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nvTranslate.cpp                                                   *
*   definitions of tables used to translate from generic (D3D or NV)        *
*   constants to HW-specific constants                                      *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*   Craig Duttweiler    bertrem     03May99     created                     *
*                                                                           *
\***************************************************************************/
#include "nvprecomp.h"

#if (NVARCH >= 0x04)

//--------------------------------------------------------------------------
// surface formats
//--------------------------------------------------------------------------

const DWORD nvSurfaceFormatToBPP[NV_SURFACE_FORMAT_COUNT] =
{
    1,                                                          // NV_SURFACE_FORMAT_Y8
    1,                                                          // NV_SURFACE_FORMAT_AY8
    2,                                                          // NV_SURFACE_FORMAT_A1R5G5B5
    2,                                                          // NV_SURFACE_FORMAT_X1R5G5B5
    2,                                                          // NV_SURFACE_FORMAT_A4R4G4B4
    2,                                                          // NV_SURFACE_FORMAT_R5G6B5
    4,                                                          // NV_SURFACE_FORMAT_A8R8G8B8
    4,                                                          // NV_SURFACE_FORMAT_X1A7R8G8B8
    4,                                                          // NV_SURFACE_FORMAT_X8R8G8B8
    1,                                                          // NV_SURFACE_FORMAT_I8_A1R5G5B5
    1,                                                          // NV_SURFACE_FORMAT_I8_R5G6B5
    1,                                                          // NV_SURFACE_FORMAT_I8_A4R4G4B4
    1,                                                          // NV_SURFACE_FORMAT_I8_A8R8G8B8
    8,                                                          // NV_SURFACE_FORMAT_DXT1_A1R5G5B5
    16,                                                         // NV_SURFACE_FORMAT_DXT23_A8R8G8B8
    16,                                                         // NV_SURFACE_FORMAT_DXT45_A8R8G8B8
    2,                                                          // NV_SURFACE_FORMAT_IMAGE_A1R5G5B5
    2,                                                          // NV_SURFACE_FORMAT_IMAGE_R5G6B5
    4,                                                          // NV_SURFACE_FORMAT_IMAGE_A8R8G8B8
    1,                                                          // NV_SURFACE_FORMAT_IMAGE_Y8
    1,                                                          // NV_SURFACE_FORMAT_IMAGE_SY8
    2,                                                          // NV_SURFACE_FORMAT_IMAGE_X7SY9
    2,                                                          // NV_SURFACE_FORMAT_IMAGE_R8B8
    2,                                                          // NV_SURFACE_FORMAT_IMAGE_G8B8
    2,                                                          // NV_SURFACE_FORMAT_IMAGE_SG8SB8
    2,                                                          // NV_SURFACE_FORMAT_Z16
    4,                                                          // NV_SURFACE_FORMAT_Z24S8
    4,                                                          // NV_SURFACE_FORMAT_Z24X8
    2,                                                          // NV_SURFACE_FORMAT_DV8DU8
    2,                                                          // NV_SURFACE_FORMAT_L6DV5DU5
    4,                                                          // NV_SURFACE_FORMAT_X8L8DV8DU8
    4,                                                          // NV_SURFACE_FORMAT_HILO_1_V16U16
    4,                                                          // NV_SURFACE_FORMAT_HILO_HEMI_V16U16
    4,                                                          // NV_SURFACE_FORMAT_A8B8G8R8
    0                                                           // NV_SURFACE_FORMAT_UNKNOWN
};

const DWORD nv052SurfaceFormat[NV_SURFACE_FORMAT_COUNT] = // for swizzling
{
    NV052_SET_FORMAT_COLOR_LE_Y8,                               // NV_SURFACE_FORMAT_Y8
    ~0,                                                         // NV_SURFACE_FORMAT_AY8
    ~0,                                                         // NV_SURFACE_FORMAT_A1R5G5B5
    NV052_SET_FORMAT_COLOR_LE_X1R5G5B5_O1R5G5B5,                // NV_SURFACE_FORMAT_X1R5G5B5
    ~0,                                                         // NV_SURFACE_FORMAT_A4R4G4B4
    NV052_SET_FORMAT_COLOR_LE_R5G6B5,                           // NV_SURFACE_FORMAT_R5G6B5
    NV052_SET_FORMAT_COLOR_LE_A8R8G8B8,                         // NV_SURFACE_FORMAT_A8R8G8B8
    NV052_SET_FORMAT_COLOR_LE_X1A7R8G8B8_Z1A7R8G8B8,            // NV_SURFACE_FORMAT_X1A7R8G8B8
    NV052_SET_FORMAT_COLOR_LE_X8R8G8B8_Z8R8G8B8,                // NV_SURFACE_FORMAT_X8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_I8_A1R5G5B5
    ~0,                                                         // NV_SURFACE_FORMAT_I8_R5G6B5
    ~0,                                                         // NV_SURFACE_FORMAT_I8_A4R4G4B4
    ~0,                                                         // NV_SURFACE_FORMAT_I8_A8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_DXT1_A1R5G5B5
    ~0,                                                         // NV_SURFACE_FORMAT_DXT23_A8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_DXT45_A8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_A1R5G5B5
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_R5G6B5
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_A8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_Y8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_SY8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_X7SY9
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_R8B8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_SG8SB8
    ~0,                                                         // NV_SURFACE_FORMAT_Z16
    ~0,                                                         // NV_SURFACE_FORMAT_Z24S8
    ~0,                                                         // NV_SURFACE_FORMAT_Z24X8
    ~0,                                                         // NV_SURFACE_FORMAT_DV8DU8
    ~0,                                                         // NV_SURFACE_FORMAT_L6DV5DU5
    ~0,                                                         // NV_SURFACE_FORMAT_X8L8DV8DU8
    ~0,                                                         // NV_SURFACE_FORMAT_HILO_1_V16U16
    ~0,                                                         // NV_SURFACE_FORMAT_HILO_HEMI_V16U16
    ~0,                                                         // NV_SURFACE_FORMAT_A8B8G8R8
    ~0                                                          // NV_SURFACE_FORMAT_UNKNOWN

};

const DWORD nv053SurfaceFormat[NV_SURFACE_FORMAT_COUNT] =
{
    ~0,                                                         // NV_SURFACE_FORMAT_Y8
    ~0,                                                         // NV_SURFACE_FORMAT_AY8
    ~0,                                                         // NV_SURFACE_FORMAT_A1R5G5B5
    NV053_SET_FORMAT_COLOR_LE_X1R5G5B5_Z1R5G5B5,                // NV_SURFACE_FORMAT_X1R5G5B5
    ~0,                                                         // NV_SURFACE_FORMAT_A4R4G4B4
    NV053_SET_FORMAT_COLOR_LE_R5G6B5,                           // NV_SURFACE_FORMAT_R5G6B5
    NV053_SET_FORMAT_COLOR_LE_A8R8G8B8,                         // NV_SURFACE_FORMAT_A8R8G8B8
    NV053_SET_FORMAT_COLOR_LE_X1A7R8G8B8_Z1A7R8G8B8,            // NV_SURFACE_FORMAT_X1A7R8G8B8
    NV053_SET_FORMAT_COLOR_LE_X8R8G8B8_Z8R8G8B8,                // NV_SURFACE_FORMAT_X8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_I8_A1R5G5B5
    ~0,                                                         // NV_SURFACE_FORMAT_I8_R5G6B5
    ~0,                                                         // NV_SURFACE_FORMAT_I8_A4R4G4B4
    ~0,                                                         // NV_SURFACE_FORMAT_I8_A8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_DXT1_A1R5G5B5
    ~0,                                                         // NV_SURFACE_FORMAT_DXT23_A8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_DXT45_A8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_A1R5G5B5
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_R5G6B5
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_A8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_Y8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_SY8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_X7SY9
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_R8B8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_SG8SB8
    ~0,                                                         // NV_SURFACE_FORMAT_Z16
    ~0,                                                         // NV_SURFACE_FORMAT_Z24S8
    ~0,                                                         // NV_SURFACE_FORMAT_Z24X8
    ~0,                                                         // NV_SURFACE_FORMAT_DV8DU8
    ~0,                                                         // NV_SURFACE_FORMAT_L6DV5DU5
    ~0,                                                         // NV_SURFACE_FORMAT_X8L8DV8DU8
    ~0,                                                         // NV_SURFACE_FORMAT_HILO_1_V16U16
    ~0,                                                         // NV_SURFACE_FORMAT_HILO_HEMI_V16U16
    ~0,                                                         // NV_SURFACE_FORMAT_A8B8G8R8
    ~0                                                          // NV_SURFACE_FORMAT_UNKNOWN
};

#if (NVARCH >= 0x010)
const DWORD nv056SurfaceFormat[NV_SURFACE_FORMAT_COUNT] =
{
    ~0,                                                         // NV_SURFACE_FORMAT_Y8
    ~0,                                                         // NV_SURFACE_FORMAT_AY8
    ~0,                                                         // NV_SURFACE_FORMAT_A1R5G5B5
    NV056_SET_SURFACE_FORMAT_COLOR_LE_X1R5G5B5_Z1R5G5B5,        // NV_SURFACE_FORMAT_X1R5G5B5
    ~0,                                                         // NV_SURFACE_FORMAT_A4R4G4B4
    NV056_SET_SURFACE_FORMAT_COLOR_LE_R5G6B5,                   // NV_SURFACE_FORMAT_R5G6B5
    NV056_SET_SURFACE_FORMAT_COLOR_LE_A8R8G8B8,                 // NV_SURFACE_FORMAT_A8R8G8B8
    NV056_SET_SURFACE_FORMAT_COLOR_LE_X1A7R8G8B8_Z1A7R8G8B8,    // NV_SURFACE_FORMAT_X1A7R8G8B8
    NV056_SET_SURFACE_FORMAT_COLOR_LE_X8R8G8B8_Z8R8G8B8,        // NV_SURFACE_FORMAT_X8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_I8_A1R5G5B5
    ~0,                                                         // NV_SURFACE_FORMAT_I8_R5G6B5
    ~0,                                                         // NV_SURFACE_FORMAT_I8_A4R4G4B4
    NV056_SET_TEXTURE_FORMAT_COLOR_LE_I8_A8R8G8B8,              // NV_SURFACE_FORMAT_I8_A8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_DXT1_A1R5G5B5
    ~0,                                                         // NV_SURFACE_FORMAT_DXT23_A8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_DXT45_A8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_A1R5G5B5
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_R5G6B5
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_A8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_Y8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_SY8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_X7SY9
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_R8B8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_SG8SB8
    ~0,                                                         // NV_SURFACE_FORMAT_Z16
    ~0,                                                         // NV_SURFACE_FORMAT_Z24S8
    ~0,                                                         // NV_SURFACE_FORMAT_Z24X8
    ~0,                                                         // NV_SURFACE_FORMAT_DV8DU8
    ~0,                                                         // NV_SURFACE_FORMAT_L6DV5DU5
    ~0,                                                         // NV_SURFACE_FORMAT_X8L8DV8DU8
    ~0,                                                         // NV_SURFACE_FORMAT_HILO_1_V16U16
    ~0,                                                         // NV_SURFACE_FORMAT_HILO_HEMI_V16U16
    ~0,                                                         // NV_SURFACE_FORMAT_A8B8G8R8
    ~0                                                          // NV_SURFACE_FORMAT_UNKNOWN
};

const DWORD nv062SurfaceFormat[NV_SURFACE_FORMAT_COUNT] =
{
    NV062_SET_COLOR_FORMAT_LE_Y8,                               // NV_SURFACE_FORMAT_Y8
    ~0,                                                         // NV_SURFACE_FORMAT_AY8
    ~0,                                                         // NV_SURFACE_FORMAT_A1R5G5B5
    NV062_SET_COLOR_FORMAT_LE_X1R5G5B5_Z1R5G5B5,                // NV_SURFACE_FORMAT_X1R5G5B5
    ~0,                                                         // NV_SURFACE_FORMAT_A4R4G4B4
    NV062_SET_COLOR_FORMAT_LE_R5G6B5,                           // NV_SURFACE_FORMAT_R5G6B5
    NV062_SET_COLOR_FORMAT_LE_A8R8G8B8,                         // NV_SURFACE_FORMAT_A8R8G8B8
    NV062_SET_COLOR_FORMAT_LE_X1A7R8G8B8_Z1A7R8G8B8,            // NV_SURFACE_FORMAT_X1A7R8G8B8
    NV062_SET_COLOR_FORMAT_LE_X8R8G8B8_Z8R8G8B8,                // NV_SURFACE_FORMAT_X8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_I8_A1R5G5B5
    ~0,                                                         // NV_SURFACE_FORMAT_I8_R5G6B5
    ~0,                                                         // NV_SURFACE_FORMAT_I8_A4R4G4B4
    ~0,                                                         // NV_SURFACE_FORMAT_I8_A8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_DXT1_A1R5G5B5
    ~0,                                                         // NV_SURFACE_FORMAT_DXT23_A8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_DXT45_A8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_A1R5G5B5
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_R5G6B5
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_A8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_Y8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_SY8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_X7SY9
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_R8B8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_SG8SB8
    ~0,                                                         // NV_SURFACE_FORMAT_Z16
    ~0,                                                         // NV_SURFACE_FORMAT_Z24S8
    ~0,                                                         // NV_SURFACE_FORMAT_Z24X8
    ~0,                                                         // NV_SURFACE_FORMAT_DV8DU8
    ~0,                                                         // NV_SURFACE_FORMAT_L6DV5DU5
    ~0,                                                         // NV_SURFACE_FORMAT_X8L8DV8DU8
    ~0,                                                         // NV_SURFACE_FORMAT_HILO_1_V16U16
    ~0,                                                         // NV_SURFACE_FORMAT_HILO_HEMI_V16U16
    ~0,                                                         // NV_SURFACE_FORMAT_A8B8G8R8
    ~0                                                          // NV_SURFACE_FORMAT_UNKNOWN
};
#endif

const DWORD nv077SurfaceFormat[NV_SURFACE_FORMAT_COUNT] = // for swizzling
{
    ~0,                                                         // NV_SURFACE_FORMAT_Y8
    ~0,                                                         // NV_SURFACE_FORMAT_AY8
    NV077_SET_COLOR_FORMAT_LE_R5G6B5,                           // NV_SURFACE_FORMAT_A1R5G5B5
    NV077_SET_COLOR_FORMAT_LE_R5G6B5,                           // NV_SURFACE_FORMAT_X1R5G5B5
    NV077_SET_COLOR_FORMAT_LE_R5G6B5,                           // NV_SURFACE_FORMAT_A4R4G4B4
    NV077_SET_COLOR_FORMAT_LE_R5G6B5,                           // NV_SURFACE_FORMAT_R5G6B5
    NV077_SET_COLOR_FORMAT_LE_A8R8G8B8,                         // NV_SURFACE_FORMAT_A8R8G8B8
    NV077_SET_COLOR_FORMAT_LE_A8R8G8B8,                         // NV_SURFACE_FORMAT_X1A7R8G8B8
    NV077_SET_COLOR_FORMAT_LE_A8R8G8B8,                         // NV_SURFACE_FORMAT_X8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_I8_A1R5G5B5
    ~0,                                                         // NV_SURFACE_FORMAT_I8_R5G6B5
    ~0,                                                         // NV_SURFACE_FORMAT_I8_A4R4G4B4
    ~0,                                                         // NV_SURFACE_FORMAT_I8_A8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_DXT1_A1R5G5B5
    ~0,                                                         // NV_SURFACE_FORMAT_DXT23_A8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_DXT45_A8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_A1R5G5B5
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_R5G6B5
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_A8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_Y8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_SY8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_X7SY9
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_R8B8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_SG8SB8
    NV077_SET_COLOR_FORMAT_LE_R5G6B5,                           // NV_SURFACE_FORMAT_Z16
    NV077_SET_COLOR_FORMAT_LE_A8R8G8B8,                         // NV_SURFACE_FORMAT_Z24S8
    NV077_SET_COLOR_FORMAT_LE_A8R8G8B8,                         // NV_SURFACE_FORMAT_Z24X8
    ~0,                                                         // NV_SURFACE_FORMAT_DV8DU8
    ~0,                                                         // NV_SURFACE_FORMAT_L6DV5DU5
    ~0,                                                         // NV_SURFACE_FORMAT_X8L8DV8DU8
    ~0,                                                         // NV_SURFACE_FORMAT_HILO_1_V16U16
    ~0,                                                         // NV_SURFACE_FORMAT_HILO_HEMI_V16U16
    ~0,                                                         // NV_SURFACE_FORMAT_A8B8G8R8
    ~0                                                          // NV_SURFACE_FORMAT_UNKNOWN
};

#if (NVARCH >= 0x010)
const DWORD nv089SurfaceFormat[NV_SURFACE_FORMAT_COUNT] =
{
    NV089_SET_COLOR_FORMAT_LE_Y8,                               // NV_SURFACE_FORMAT_Y8
    NV089_SET_COLOR_FORMAT_LE_AY8,                              // NV_SURFACE_FORMAT_AY8
    NV089_SET_COLOR_FORMAT_LE_A1R5G5B5,                         // NV_SURFACE_FORMAT_A1R5G5B5
    NV089_SET_COLOR_FORMAT_LE_X1R5G5B5,                         // NV_SURFACE_FORMAT_X1R5G5B5
    ~0,                                                         // NV_SURFACE_FORMAT_A4R4G4B4
    NV089_SET_COLOR_FORMAT_LE_R5G6B5,                           // NV_SURFACE_FORMAT_R5G6B5
    NV089_SET_COLOR_FORMAT_LE_A8R8G8B8,                         // NV_SURFACE_FORMAT_A8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_X1A7R8G8B8
    NV089_SET_COLOR_FORMAT_LE_X8R8G8B8,                         // NV_SURFACE_FORMAT_X8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_I8_A1R5G5B5
    ~0,                                                         // NV_SURFACE_FORMAT_I8_R5G6B5
    ~0,                                                         // NV_SURFACE_FORMAT_I8_A4R4G4B4
    ~0,                                                         // NV_SURFACE_FORMAT_I8_A8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_DXT1_A1R5G5B5
    ~0,                                                         // NV_SURFACE_FORMAT_DXT23_A8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_DXT45_A8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_A1R5G5B5
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_R5G6B5
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_A8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_Y8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_SY8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_X7SY9
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_R8B8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_SG8SB8
    ~0,                                                         // NV_SURFACE_FORMAT_Z16
    ~0,                                                         // NV_SURFACE_FORMAT_Z24S8
    ~0,                                                         // NV_SURFACE_FORMAT_Z24X8
    ~0,                                                         // NV_SURFACE_FORMAT_DV8DU8
    ~0,                                                         // NV_SURFACE_FORMAT_L6DV5DU5
    ~0,                                                         // NV_SURFACE_FORMAT_X8L8DV8DU8
    ~0,                                                         // NV_SURFACE_FORMAT_HILO_1_V16U16
    ~0,                                                         // NV_SURFACE_FORMAT_HILO_HEMI_V16U16
    ~0,                                                         // NV_SURFACE_FORMAT_A8B8G8R8
    ~0                                                          // NV_SURFACE_FORMAT_UNKNOWN
};
#endif

#if (NVARCH >= 0x020)
const DWORD nv097SurfaceFormat[NV_SURFACE_FORMAT_COUNT] =
{
    ~0,                                                         // NV_SURFACE_FORMAT_Y8
    ~0,                                                         // NV_SURFACE_FORMAT_AY8
    ~0,                                                         // NV_SURFACE_FORMAT_A1R5G5B5
    NV097_SET_SURFACE_FORMAT_COLOR_LE_X1R5G5B5_Z1R5G5B5,        // NV_SURFACE_FORMAT_X1R5G5B5
    ~0,                                                         // NV_SURFACE_FORMAT_A4R4G4B4
    NV097_SET_SURFACE_FORMAT_COLOR_LE_R5G6B5,                   // NV_SURFACE_FORMAT_R5G6B5
    NV097_SET_SURFACE_FORMAT_COLOR_LE_A8R8G8B8,                 // NV_SURFACE_FORMAT_A8R8G8B8
    NV097_SET_SURFACE_FORMAT_COLOR_LE_X1A7R8G8B8_Z1A7R8G8B8,    // NV_SURFACE_FORMAT_X1A7R8G8B8
    NV097_SET_SURFACE_FORMAT_COLOR_LE_X8R8G8B8_Z8R8G8B8,        // NV_SURFACE_FORMAT_X8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_I8_A1R5G5B5
    ~0,                                                         // NV_SURFACE_FORMAT_I8_R5G6B5
    ~0,                                                         // NV_SURFACE_FORMAT_I8_A4R4G4B4
    ~0,                                                         // NV_SURFACE_FORMAT_I8_A8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_DXT1_A1R5G5B5
    ~0,                                                         // NV_SURFACE_FORMAT_DXT23_A8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_DXT45_A8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_A1R5G5B5
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_R5G6B5
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_A8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_Y8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_SY8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_X7SY9
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_R8B8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_SG8SB8
    NV097_SET_SURFACE_FORMAT_ZETA_Z16,                          // NV_SURFACE_FORMAT_Z16
    NV097_SET_SURFACE_FORMAT_ZETA_Z24S8,                        // NV_SURFACE_FORMAT_Z24S8
    NV097_SET_SURFACE_FORMAT_ZETA_Z24S8,                        // NV_SURFACE_FORMAT_Z24X8
    ~0,                                                         // NV_SURFACE_FORMAT_DV8DU8
    ~0,                                                         // NV_SURFACE_FORMAT_L6DV5DU5
    ~0,                                                         // NV_SURFACE_FORMAT_X8L8DV8DU8
    ~0,                                                         // NV_SURFACE_FORMAT_HILO_1_V16U16
    ~0,                                                         // NV_SURFACE_FORMAT_HILO_HEMI_V16U16
    ~0,                                                         // NV_SURFACE_FORMAT_A8B8G8R8
    ~0                                                          // NV_SURFACE_FORMAT_UNKNOWN
};
#endif

//--------------------------------------------------------------------------
// texture formats
//--------------------------------------------------------------------------

const DWORD nv054TextureFormat[NV_SURFACE_FORMAT_COUNT] =
{
    NV054_FORMAT_COLOR_LE_Y8,                                   // NV_SURFACE_FORMAT_Y8
    ~0,                                                         // NV_SURFACE_FORMAT_AY8
    NV054_FORMAT_COLOR_LE_A1R5G5B5,                             // NV_SURFACE_FORMAT_A1R5G5B5
    NV054_FORMAT_COLOR_LE_X1R5G5B5,                             // NV_SURFACE_FORMAT_X1R5G5B5
    NV054_FORMAT_COLOR_LE_A4R4G4B4,                             // NV_SURFACE_FORMAT_A4R4G4B4
    NV054_FORMAT_COLOR_LE_R5G6B5,                               // NV_SURFACE_FORMAT_R5G6B5
    NV054_FORMAT_COLOR_LE_A8R8G8B8,                             // NV_SURFACE_FORMAT_A8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_X1A7R8G8B8
    NV054_FORMAT_COLOR_LE_X8R8G8B8,                             // NV_SURFACE_FORMAT_X8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_I8_A1R5G5B5
    ~0,                                                         // NV_SURFACE_FORMAT_I8_R5G6B5
    ~0,                                                         // NV_SURFACE_FORMAT_I8_A4R4G4B4
    ~0,                                                         // NV_SURFACE_FORMAT_I8_A8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_DXT1_A1R5G5B5
    ~0,                                                         // NV_SURFACE_FORMAT_DXT23_A8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_DXT45_A8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_A1R5G5B5
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_R5G6B5
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_A8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_Y8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_SY8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_X7SY9
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_R8B8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_SG8SB8
    ~0,                                                         // NV_SURFACE_FORMAT_Z16
    ~0,                                                         // NV_SURFACE_FORMAT_Z24S8
    ~0,                                                         // NV_SURFACE_FORMAT_Z24X8
    ~0,                                                         // NV_SURFACE_FORMAT_DV8DU8
    ~0,                                                         // NV_SURFACE_FORMAT_L6DV5DU5
    ~0,                                                         // NV_SURFACE_FORMAT_X8L8DV8DU8
    ~0,                                                         // NV_SURFACE_FORMAT_HILO_1_V16U16
    ~0,                                                         // NV_SURFACE_FORMAT_HILO_HEMI_V16U16
    ~0,                                                         // NV_SURFACE_FORMAT_A8B8G8R8
    ~0                                                          // NV_SURFACE_FORMAT_UNKNOWN
};

const DWORD nv055TextureFormat[NV_SURFACE_FORMAT_COUNT] =
{
    ~0,                                                         // NV_SURFACE_FORMAT_Y8
    NV055_FORMAT_COLOR_LE_AY8,                                  // NV_SURFACE_FORMAT_AY8
    NV055_FORMAT_COLOR_LE_A1R5G5B5,                             // NV_SURFACE_FORMAT_A1R5G5B5
    NV055_FORMAT_COLOR_LE_X1R5G5B5,                             // NV_SURFACE_FORMAT_X1R5G5B5
    NV055_FORMAT_COLOR_LE_A4R4G4B4,                             // NV_SURFACE_FORMAT_A4R4G4B4
    NV055_FORMAT_COLOR_LE_R5G6B5,                               // NV_SURFACE_FORMAT_R5G6B5
    NV055_FORMAT_COLOR_LE_A8R8G8B8,                             // NV_SURFACE_FORMAT_A8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_X1A7R8G8B8
    NV055_FORMAT_COLOR_LE_X8R8G8B8,                             // NV_SURFACE_FORMAT_X8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_I8_A1R5G5B5
    ~0,                                                         // NV_SURFACE_FORMAT_I8_R5G6B5
    ~0,                                                         // NV_SURFACE_FORMAT_I8_A4R4G4B4
    ~0,                                                         // NV_SURFACE_FORMAT_I8_A8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_DXT1_A1R5G5B5
    ~0,                                                         // NV_SURFACE_FORMAT_DXT23_A8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_DXT45_A8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_A1R5G5B5
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_R5G6B5
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_A8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_Y8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_SY8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_X7SY9
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_R8B8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_IMAGE_SG8SB8
    ~0,                                                         // NV_SURFACE_FORMAT_Z16
    ~0,                                                         // NV_SURFACE_FORMAT_Z24S8
    ~0,                                                         // NV_SURFACE_FORMAT_Z24X8
    ~0,                                                         // NV_SURFACE_FORMAT_DV8DU8
    ~0,                                                         // NV_SURFACE_FORMAT_L6DV5DU5
    ~0,                                                         // NV_SURFACE_FORMAT_X8L8DV8DU8
    ~0,                                                         // NV_SURFACE_FORMAT_HILO_1_V16U16
    ~0,                                                         // NV_SURFACE_FORMAT_HILO_HEMI_V16U16
    ~0,                                                         // NV_SURFACE_FORMAT_A8B8G8R8
    ~0                                                          // NV_SURFACE_FORMAT_UNKNOWN
};

#if (NVARCH >= 0x010)
const DWORD nv056TextureFormat[NV_SURFACE_FORMAT_COUNT] =
{
    NV056_SET_TEXTURE_FORMAT_COLOR_LE_Y8,                       // NV_SURFACE_FORMAT_Y8
    NV056_SET_TEXTURE_FORMAT_COLOR_LE_AY8,                      // NV_SURFACE_FORMAT_AY8
    NV056_SET_TEXTURE_FORMAT_COLOR_LE_A1R5G5B5,                 // NV_SURFACE_FORMAT_A1R5G5B5
    NV056_SET_TEXTURE_FORMAT_COLOR_LE_X1R5G5B5,                 // NV_SURFACE_FORMAT_X1R5G5B5
    NV056_SET_TEXTURE_FORMAT_COLOR_LE_A4R4G4B4,                 // NV_SURFACE_FORMAT_A4R4G4B4
    NV056_SET_TEXTURE_FORMAT_COLOR_LE_R5G6B5,                   // NV_SURFACE_FORMAT_R5G6B5
    NV056_SET_TEXTURE_FORMAT_COLOR_LE_A8R8G8B8,                 // NV_SURFACE_FORMAT_A8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_X1A7R8G8B8
    NV056_SET_TEXTURE_FORMAT_COLOR_LE_X8R8G8B8,                 // NV_SURFACE_FORMAT_X8R8G8B8
    NV056_SET_TEXTURE_FORMAT_COLOR_LE_I8_A1R5G5B5,              // NV_SURFACE_FORMAT_I8_A1R5G5B5
    NV056_SET_TEXTURE_FORMAT_COLOR_LE_I8_R5G6B5,                // NV_SURFACE_FORMAT_I8_R5G6B5
    NV056_SET_TEXTURE_FORMAT_COLOR_LE_I8_A4R4G4B4,              // NV_SURFACE_FORMAT_I8_A4R4G4B4
    NV056_SET_TEXTURE_FORMAT_COLOR_LE_I8_A8R8G8B8,              // NV_SURFACE_FORMAT_I8_A8R8G8B8
    NV056_SET_TEXTURE_FORMAT_COLOR_LE_DXT1_A1R5G5B5,            // NV_SURFACE_FORMAT_DXT1_A1R5G5B5
    NV056_SET_TEXTURE_FORMAT_COLOR_LE_DXT23_A8R8G8B8,           // NV_SURFACE_FORMAT_DXT23_A8R8G8B8
    NV056_SET_TEXTURE_FORMAT_COLOR_LE_DXT45_A8R8G8B8,           // NV_SURFACE_FORMAT_DXT45_A8R8G8B8
    NV056_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_A1R5G5B5,           // NV_SURFACE_FORMAT_IMAGE_A1R5G5B5
    NV056_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_R5G6B5,             // NV_SURFACE_FORMAT_IMAGE_R5G6B5
    NV056_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_A8R8G8B8,           // NV_SURFACE_FORMAT_IMAGE_A8R8G8B8
    NV056_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_Y8,                 // NV_SURFACE_FORMAT_IMAGE_Y8
    NV056_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_SY8,                // NV_SURFACE_FORMAT_IMAGE_SY8
    NV056_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_X7SY9,              // NV_SURFACE_FORMAT_IMAGE_X7SY9
    NV056_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_R8B8,               // NV_SURFACE_FORMAT_IMAGE_R8B8
    NV056_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_G8B8,               // NV_SURFACE_FORMAT_IMAGE_G8B8
    NV056_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_SG8SB8,             // NV_SURFACE_FORMAT_IMAGE_SG8SB8
    ~0,                                                         // NV_SURFACE_FORMAT_Z16
    ~0,                                                         // NV_SURFACE_FORMAT_Z24S8
    ~0,                                                         // NV_SURFACE_FORMAT_Z24X8
    ~0,                                                         // NV_SURFACE_FORMAT_DV8DU8
    ~0,                                                         // NV_SURFACE_FORMAT_L6DV5DU5
    ~0,                                                         // NV_SURFACE_FORMAT_X8L8DV8DU8
    ~0,                                                         // NV_SURFACE_FORMAT_HILO_1_V16U16
    ~0,                                                         // NV_SURFACE_FORMAT_HILO_HEMI_V16U16
    ~0,                                                         // NV_SURFACE_FORMAT_A8B8G8R8
    ~0                                                          // NV_SURFACE_FORMAT_UNKNOWN
};
#endif

#if (NVARCH >= 0x020)
const DWORD nv097TextureFormat[NV_SURFACE_FORMAT_COUNT] =
{
    NV097_SET_TEXTURE_FORMAT_COLOR_SZ_Y8,                       // NV_SURFACE_FORMAT_Y8
    NV097_SET_TEXTURE_FORMAT_COLOR_SZ_AY8,                      // NV_SURFACE_FORMAT_AY8
    NV097_SET_TEXTURE_FORMAT_COLOR_SZ_A1R5G5B5,                 // NV_SURFACE_FORMAT_A1R5G5B5
    NV097_SET_TEXTURE_FORMAT_COLOR_SZ_X1R5G5B5,                 // NV_SURFACE_FORMAT_X1R5G5B5
    NV097_SET_TEXTURE_FORMAT_COLOR_SZ_A4R4G4B4,                 // NV_SURFACE_FORMAT_A4R4G4B4
    NV097_SET_TEXTURE_FORMAT_COLOR_SZ_R5G6B5,                   // NV_SURFACE_FORMAT_R5G6B5
    NV097_SET_TEXTURE_FORMAT_COLOR_SZ_A8R8G8B8,                 // NV_SURFACE_FORMAT_A8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_X1A7R8G8B8
    NV097_SET_TEXTURE_FORMAT_COLOR_SZ_X8R8G8B8,                 // NV_SURFACE_FORMAT_X8R8G8B8
    ~0,                                                         // NV_SURFACE_FORMAT_I8_A1R5G5B5
    ~0,                                                         // NV_SURFACE_FORMAT_I8_R5G6B5
    ~0,                                                         // NV_SURFACE_FORMAT_I8_A4R4G4B4
    NV097_SET_TEXTURE_FORMAT_COLOR_SZ_I8_A8R8G8B8,              // NV_SURFACE_FORMAT_I8_A8R8G8B8
    NV097_SET_TEXTURE_FORMAT_COLOR_L_DXT1_A1R5G5B5,             // NV_SURFACE_FORMAT_DXT1_A1R5G5B5
    NV097_SET_TEXTURE_FORMAT_COLOR_L_DXT23_A8R8G8B8,            // NV_SURFACE_FORMAT_DXT23_A8R8G8B8
    NV097_SET_TEXTURE_FORMAT_COLOR_L_DXT45_A8R8G8B8,            // NV_SURFACE_FORMAT_DXT45_A8R8G8B8
    NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A1R5G5B5,           // NV_SURFACE_FORMAT_IMAGE_A1R5G5B5
    NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_R5G6B5,             // NV_SURFACE_FORMAT_IMAGE_R5G6B5
    NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A8R8G8B8,           // NV_SURFACE_FORMAT_IMAGE_A8R8G8B8
    NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_Y8,                 // NV_SURFACE_FORMAT_IMAGE_Y8
    NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_SY8,                // NV_SURFACE_FORMAT_IMAGE_SY8
    NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_X7SY9,              // NV_SURFACE_FORMAT_IMAGE_X7SY9
    NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_R8B8,               // NV_SURFACE_FORMAT_IMAGE_R8B8
    NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_G8B8,               // NV_SURFACE_FORMAT_IMAGE_G8B8
    NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_SG8SB8,             // NV_SURFACE_FORMAT_IMAGE_SG8SB8
    ~0,                                                         // NV_SURFACE_FORMAT_Z16
    ~0,                                                         // NV_SURFACE_FORMAT_Z24S8
    ~0,                                                         // NV_SURFACE_FORMAT_Z24X8
    NV097_SET_TEXTURE_FORMAT_COLOR_SZ_G8B8,                     // NV_SURFACE_FORMAT_DV8DU8
    NV097_SET_TEXTURE_FORMAT_COLOR_SZ_R6G5B5,                   // NV_SURFACE_FORMAT_L6DV5DU5
    NV097_SET_TEXTURE_FORMAT_COLOR_SZ_X8R8G8B8,                 // NV_SURFACE_FORMAT_X8L8DV8DU8
    NV097_SET_TEXTURE_FORMAT_COLOR_SZ_YB_16_YA_16,              // NV_SURFACE_FORMAT_HILO_1_V16U16
    NV097_SET_TEXTURE_FORMAT_COLOR_SZ_YB_16_YA_16,              // NV_SURFACE_FORMAT_HILO_HEMI_V16U16
    NV097_SET_TEXTURE_FORMAT_COLOR_SZ_A8B8G8R8,                 // NV_SURFACE_FORMAT_A8B8G8R8
    ~0                                                          // NV_SURFACE_FORMAT_UNKNOWN

};
#endif

//--------------------------------------------------------------------------
// context DMAs
//--------------------------------------------------------------------------

const DWORD nv054TextureContextDma[NV_CONTEXT_DMA_COUNT] =
{
    ~0,
    NV054_FORMAT_CONTEXT_DMA_A,
    NV054_FORMAT_CONTEXT_DMA_B
};

const DWORD nv055TextureContextDma[NV_CONTEXT_DMA_COUNT] =
{
    ~0,
    NV055_FORMAT_CONTEXT_DMA_A,
    NV055_FORMAT_CONTEXT_DMA_B
};

#if (NVARCH >= 0x010)
const DWORD nv056TextureContextDma[NV_CONTEXT_DMA_COUNT] =
{
    ~0,
    NV056_SET_TEXTURE_FORMAT_CONTEXT_DMA_A,
    NV056_SET_TEXTURE_FORMAT_CONTEXT_DMA_B
};
#endif

#if (NVARCH >= 0x020)
const DWORD nv097TextureContextDma[NV_CONTEXT_DMA_COUNT] =
{
    ~0,
    NV097_SET_TEXTURE_FORMAT_CONTEXT_DMA_A,
    NV097_SET_TEXTURE_FORMAT_CONTEXT_DMA_B
};
#endif

#if (NVARCH >= 0x010)
const DWORD nv056PaletteContextDma[NV_CONTEXT_DMA_COUNT] =
{
    ~0,
    NV056_SET_TEXTURE_PALETTE_CONTEXT_DMA_A,
    NV056_SET_TEXTURE_PALETTE_CONTEXT_DMA_B
};
#endif

#if (NVARCH >= 0x020)
const DWORD nv097PaletteContextDma[NV_CONTEXT_DMA_COUNT] =
{
    ~0,
    NV097_SET_TEXTURE_PALETTE_CONTEXT_DMA_A,
    NV097_SET_TEXTURE_PALETTE_CONTEXT_DMA_B
};

const DWORD nv097VertexContextDma[NV_CONTEXT_DMA_COUNT] =
{
    ~0,
    NV097_SET_VERTEX_DATA_ARRAY_OFFSET_CONTEXT_DMA_VERTEX_A,
    NV097_SET_VERTEX_DATA_ARRAY_OFFSET_CONTEXT_DMA_VERTEX_B,
};
#endif


//--------------------------------------------------------------------------
// D3D conversion stuff
//--------------------------------------------------------------------------

#if (NVARCH >= 0x010)
// note we define these in terms of STENCIL_OP_FAIL, but the values are
// actually the same for STENCIL_OP_ZFAIL and STENCIL_OP_ZPASS
const DWORD nv056StencilOp[D3D_STENCIL_OP_COUNT] =
{
    ~0,                                     // undefined
    NV056_SET_STENCIL_OP_FAIL_V_KEEP,       // D3DSTENCILOP_KEEP    = 1
    NV056_SET_STENCIL_OP_FAIL_V_ZERO,       // D3DSTENCILOP_ZERO    = 2
    NV056_SET_STENCIL_OP_FAIL_V_REPLACE,    // D3DSTENCILOP_REPLACE = 3
    NV056_SET_STENCIL_OP_FAIL_V_INCRSAT,    // D3DSTENCILOP_INCRSAT = 4
    NV056_SET_STENCIL_OP_FAIL_V_DECRSAT,    // D3DSTENCILOP_DECRSAT = 5
    NV056_SET_STENCIL_OP_FAIL_V_INVERT,     // D3DSTENCILOP_INVERT  = 6
    NV056_SET_STENCIL_OP_FAIL_V_INCR,       // D3DSTENCILOP_INCR    = 7
    NV056_SET_STENCIL_OP_FAIL_V_DECR        // D3DSTENCILOP_DECR    = 8
};

// note we define these in terms of STENCIL_OP_FAIL, but the values are
// actually the same for STENCIL_OP_ZFAIL and STENCIL_OP_ZPASS
const DWORD nv097StencilOp[D3D_STENCIL_OP_COUNT] =
{
    ~0,                                     // undefined
    NV097_SET_STENCIL_OP_FAIL_V_KEEP,       // D3DSTENCILOP_KEEP    = 1
    NV097_SET_STENCIL_OP_FAIL_V_ZERO,       // D3DSTENCILOP_ZERO    = 2
    NV097_SET_STENCIL_OP_FAIL_V_REPLACE,    // D3DSTENCILOP_REPLACE = 3
    NV097_SET_STENCIL_OP_FAIL_V_INCRSAT,    // D3DSTENCILOP_INCRSAT = 4
    NV097_SET_STENCIL_OP_FAIL_V_DECRSAT,    // D3DSTENCILOP_DECRSAT = 5
    NV097_SET_STENCIL_OP_FAIL_V_INVERT,     // D3DSTENCILOP_INVERT  = 6
    NV097_SET_STENCIL_OP_FAIL_V_INCR,       // D3DSTENCILOP_INCR    = 7
    NV097_SET_STENCIL_OP_FAIL_V_DECR        // D3DSTENCILOP_DECR    = 8
};

const DWORD nv056StencilFunc[D3D_CMP_FUNC_COUNT] =
{
    ~0,                                     // undefined
    NV056_SET_STENCIL_FUNC_V_NEVER,         // D3DCMP_NEVER        = 1
    NV056_SET_STENCIL_FUNC_V_LESS,          // D3DCMP_LESS         = 2
    NV056_SET_STENCIL_FUNC_V_EQUAL,         // D3DCMP_EQUAL        = 3
    NV056_SET_STENCIL_FUNC_V_LEQUAL,        // D3DCMP_LESSEQUAL    = 4
    NV056_SET_STENCIL_FUNC_V_GREATER,       // D3DCMP_GREATER      = 5
    NV056_SET_STENCIL_FUNC_V_NOTEQUAL,      // D3DCMP_NOTEQUAL     = 6
    NV056_SET_STENCIL_FUNC_V_GEQUAL,        // D3DCMP_GREATEREQUAL = 7
    NV056_SET_STENCIL_FUNC_V_ALWAYS         // D3DCMP_ALWAYS       = 8
};

const DWORD nv097StencilFunc[D3D_CMP_FUNC_COUNT] =
{
    ~0,                                     // undefined
    NV097_SET_STENCIL_FUNC_V_NEVER,         // D3DCMP_NEVER        = 1
    NV097_SET_STENCIL_FUNC_V_LESS,          // D3DCMP_LESS         = 2
    NV097_SET_STENCIL_FUNC_V_EQUAL,         // D3DCMP_EQUAL        = 3
    NV097_SET_STENCIL_FUNC_V_LEQUAL,        // D3DCMP_LESSEQUAL    = 4
    NV097_SET_STENCIL_FUNC_V_GREATER,       // D3DCMP_GREATER      = 5
    NV097_SET_STENCIL_FUNC_V_NOTEQUAL,      // D3DCMP_NOTEQUAL     = 6
    NV097_SET_STENCIL_FUNC_V_GEQUAL,        // D3DCMP_GREATEREQUAL = 7
    NV097_SET_STENCIL_FUNC_V_ALWAYS         // D3DCMP_ALWAYS       = 8
};

const DWORD nv056AlphaFunc[D3D_CMP_FUNC_COUNT] =
{
    ~0,                                     // undefined
    NV056_SET_ALPHA_FUNC_V_NEVER,           // D3DCMP_NEVER        = 1
    NV056_SET_ALPHA_FUNC_V_LESS,            // D3DCMP_LESS         = 2
    NV056_SET_ALPHA_FUNC_V_EQUAL,           // D3DCMP_EQUAL        = 3
    NV056_SET_ALPHA_FUNC_V_LEQUAL,          // D3DCMP_LESSEQUAL    = 4
    NV056_SET_ALPHA_FUNC_V_GREATER,         // D3DCMP_GREATER      = 5
    NV056_SET_ALPHA_FUNC_V_NOTEQUAL,        // D3DCMP_NOTEQUAL     = 6
    NV056_SET_ALPHA_FUNC_V_GEQUAL,          // D3DCMP_GREATEREQUAL = 7
    NV056_SET_ALPHA_FUNC_V_ALWAYS           // D3DCMP_ALWAYS       = 8
};

const DWORD nv097AlphaFunc[D3D_CMP_FUNC_COUNT] =
{
    ~0,                                     // undefined
    NV097_SET_ALPHA_FUNC_V_NEVER,           // D3DCMP_NEVER        = 1
    NV097_SET_ALPHA_FUNC_V_LESS,            // D3DCMP_LESS         = 2
    NV097_SET_ALPHA_FUNC_V_EQUAL,           // D3DCMP_EQUAL        = 3
    NV097_SET_ALPHA_FUNC_V_LEQUAL,          // D3DCMP_LESSEQUAL    = 4
    NV097_SET_ALPHA_FUNC_V_GREATER,         // D3DCMP_GREATER      = 5
    NV097_SET_ALPHA_FUNC_V_NOTEQUAL,        // D3DCMP_NOTEQUAL     = 6
    NV097_SET_ALPHA_FUNC_V_GEQUAL,          // D3DCMP_GREATEREQUAL = 7
    NV097_SET_ALPHA_FUNC_V_ALWAYS           // D3DCMP_ALWAYS       = 8
};

const DWORD nv056DepthFunc[D3D_CMP_FUNC_COUNT] =
{
    ~0,                                     // undefined
    NV056_SET_DEPTH_FUNC_V_NEVER,           // D3DCMP_NEVER        = 1
    NV056_SET_DEPTH_FUNC_V_LESS,            // D3DCMP_LESS         = 2
    NV056_SET_DEPTH_FUNC_V_EQUAL,           // D3DCMP_EQUAL        = 3
    NV056_SET_DEPTH_FUNC_V_LEQUAL,          // D3DCMP_LESSEQUAL    = 4
    NV056_SET_DEPTH_FUNC_V_GREATER,         // D3DCMP_GREATER      = 5
    NV056_SET_DEPTH_FUNC_V_NOTEQUAL,        // D3DCMP_NOTEQUAL     = 6
    NV056_SET_DEPTH_FUNC_V_GEQUAL,          // D3DCMP_GREATEREQUAL = 7
    NV056_SET_DEPTH_FUNC_V_ALWAYS           // D3DCMP_ALWAYS       = 8
};

const DWORD nv097DepthFunc[D3D_CMP_FUNC_COUNT] =
{
    ~0,                                     // undefined
    NV097_SET_DEPTH_FUNC_V_NEVER,           // D3DCMP_NEVER        = 1
    NV097_SET_DEPTH_FUNC_V_LESS,            // D3DCMP_LESS         = 2
    NV097_SET_DEPTH_FUNC_V_EQUAL,           // D3DCMP_EQUAL        = 3
    NV097_SET_DEPTH_FUNC_V_LEQUAL,          // D3DCMP_LESSEQUAL    = 4
    NV097_SET_DEPTH_FUNC_V_GREATER,         // D3DCMP_GREATER      = 5
    NV097_SET_DEPTH_FUNC_V_NOTEQUAL,        // D3DCMP_NOTEQUAL     = 6
    NV097_SET_DEPTH_FUNC_V_GEQUAL,          // D3DCMP_GREATEREQUAL = 7
    NV097_SET_DEPTH_FUNC_V_ALWAYS           // D3DCMP_ALWAYS       = 8
};

// we set these based on NV056 SFACTORs, but NV056 DFACTORs are the same
const DWORD nv056BlendFunc[D3D_BLEND_COUNT] =
{
    ~0,                                                  // undefined
    NV056_SET_BLEND_FUNC_SFACTOR_V_ZERO,                 // D3DBLEND_ZERO            = 1
    NV056_SET_BLEND_FUNC_SFACTOR_V_ONE,                  // D3DBLEND_ONE             = 2
    NV056_SET_BLEND_FUNC_SFACTOR_V_SRC_COLOR,            // D3DBLEND_SRCCOLOR        = 3
    NV056_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_SRC_COLOR,  // D3DBLEND_INVSRCCOLOR     = 4
    NV056_SET_BLEND_FUNC_SFACTOR_V_SRC_ALPHA,            // D3DBLEND_SRCALPHA        = 5
    NV056_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_SRC_ALPHA,  // D3DBLEND_INVSRCALPHA     = 6
    NV056_SET_BLEND_FUNC_SFACTOR_V_DST_ALPHA,            // D3DBLEND_DESTALPHA       = 7
    NV056_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_DST_ALPHA,  // D3DBLEND_INVDESTALPHA    = 8
    NV056_SET_BLEND_FUNC_SFACTOR_V_DST_COLOR,            // D3DBLEND_DESTCOLOR       = 9
    NV056_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_DST_COLOR,  // D3DBLEND_INVDESTCOLOR    = 10
    NV056_SET_BLEND_FUNC_SFACTOR_V_SRC_ALPHA_SATURATE,   // D3DBLEND_SRCALPHASAT     = 11
    NV056_SET_BLEND_FUNC_SFACTOR_V_SRC_ALPHA,            // D3DBLEND_BOTHSRCALPHA    = 12
    NV056_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_SRC_ALPHA   // D3DBLEND_BOTHINVSRCALPHA = 13
};

// we set these based on NV097 SFACTORs, but NV097 DFACTORs are the same
const DWORD nv097BlendFunc[D3D_BLEND_COUNT] =
{
    ~0,                                                  // undefined
    NV097_SET_BLEND_FUNC_SFACTOR_V_ZERO,                 // D3DBLEND_ZERO            = 1
    NV097_SET_BLEND_FUNC_SFACTOR_V_ONE,                  // D3DBLEND_ONE             = 2
    NV097_SET_BLEND_FUNC_SFACTOR_V_SRC_COLOR,            // D3DBLEND_SRCCOLOR        = 3
    NV097_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_SRC_COLOR,  // D3DBLEND_INVSRCCOLOR     = 4
    NV097_SET_BLEND_FUNC_SFACTOR_V_SRC_ALPHA,            // D3DBLEND_SRCALPHA        = 5
    NV097_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_SRC_ALPHA,  // D3DBLEND_INVSRCALPHA     = 6
    NV097_SET_BLEND_FUNC_SFACTOR_V_DST_ALPHA,            // D3DBLEND_DESTALPHA       = 7
    NV097_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_DST_ALPHA,  // D3DBLEND_INVDESTALPHA    = 8
    NV097_SET_BLEND_FUNC_SFACTOR_V_DST_COLOR,            // D3DBLEND_DESTCOLOR       = 9
    NV097_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_DST_COLOR,  // D3DBLEND_INVDESTCOLOR    = 10
    NV097_SET_BLEND_FUNC_SFACTOR_V_SRC_ALPHA_SATURATE,   // D3DBLEND_SRCALPHASAT     = 11
    NV097_SET_BLEND_FUNC_SFACTOR_V_SRC_ALPHA,            // D3DBLEND_BOTHSRCALPHA    = 12
    NV097_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_SRC_ALPHA   // D3DBLEND_BOTHINVSRCALPHA = 13
};

// New DX8 blend operations
const DWORD nv056BlendOp[D3D_BLEND_OP_COUNT] = {
    ~0,
    NV056_SET_BLEND_EQUATION_V_FUNC_ADD,                     // D3DBLENDOP_ADD
    NV056_SET_BLEND_EQUATION_V_FUNC_SUBTRACT,                // D3DBLENDOP_SUBTRACT
    NV056_SET_BLEND_EQUATION_V_FUNC_REVERSE_SUBTRACT,        // D3DBLENDOP_REVSUBTRACT
    NV056_SET_BLEND_EQUATION_V_MIN,                          // D3DBLENDOP_MIN
    NV056_SET_BLEND_EQUATION_V_MAX                           // D3DBLENDOP_MAX
};

const DWORD nv097BlendOp[D3D_BLEND_OP_COUNT] = {
    ~0,
    NV097_SET_BLEND_EQUATION_V_FUNC_ADD,                     // D3DBLENDOP_ADD
    NV097_SET_BLEND_EQUATION_V_FUNC_SUBTRACT,                // D3DBLENDOP_SUBTRACT
    NV097_SET_BLEND_EQUATION_V_FUNC_REVERSE_SUBTRACT,        // D3DBLENDOP_REVSUBTRACT
    NV097_SET_BLEND_EQUATION_V_MIN,                          // D3DBLENDOP_MIN
    NV097_SET_BLEND_EQUATION_V_MAX                           // D3DBLENDOP_MAX
};

// these are defined in terms of TEXTUREADDRESSU, but values for TEXTUREADDRESSV are the same
const DWORD nv056TextureAddress[D3D_TADDRESS_COUNT] =
{
    ~0,                                                  // undefined
    NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSU_WRAP,       // D3DTADDRESS_WRAP     = 1
    NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSU_MIRROR,     // D3DTADDRESS_MIRROR   = 2
    NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSU_CLAMP,      // D3DTADDRESS_CLAMP    = 3
    NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSU_WRAP        // D3DTADDRESS_BORDER   = 4
};

#if (NVARCH >= 0x020)
// these are defined in terms of TEXTUREADDRESSU, but values for TEXTUREADDRESSV are the same
const DWORD nv097TextureAddress[D3D_TADDRESS_COUNT] =
{
    ~0,                                                  // undefined
    NV097_SET_TEXTURE_ADDRESS_U_WRAP,                    // D3DTADDRESS_WRAP     = 1
    NV097_SET_TEXTURE_ADDRESS_U_MIRROR,                  // D3DTADDRESS_MIRROR   = 2
    NV097_SET_TEXTURE_ADDRESS_U_CLAMP_TO_EDGE,           // D3DTADDRESS_CLAMP    = 3
    NV097_SET_TEXTURE_ADDRESS_U_BORDER                   // D3DTADDRESS_BORDER   = 4
};
#endif

const DWORD nv056TextureMagFilter[D3D_MAGFILTER_COUNT] =
{
    ~0,                                                  // undefined
    NV056_SET_TEXTURE_FILTER_TEXTUREMAG_NEAREST,         // D3DTFG_POINT         = 1
    NV056_SET_TEXTURE_FILTER_TEXTUREMAG_LINEAR,          // D3DTFG_LINEAR        = 2
    NV056_SET_TEXTURE_FILTER_TEXTUREMAG_NEAREST,         // D3DTFG_FLATCUBIC     = 3
    NV056_SET_TEXTURE_FILTER_TEXTUREMAG_NEAREST,         // D3DTFG_GAUSSIANCUBIC = 4
    NV056_SET_TEXTURE_FILTER_TEXTUREMAG_LINEAR,          // D3DTFG_ANISOTROPIC   = 5  (Mag aniso is bilinear in HW, and this passes WHQL.)
};

#if (NVARCH >= 0x020)
const DWORD nv097TextureMagFilter[D3D_MAGFILTER_COUNT] =
{
    ~0,                                                  // undefined
    NV097_SET_TEXTURE_FILTER_MAG_BOX_LOD0,               // D3DTFG_POINT         = 1
    NV097_SET_TEXTURE_FILTER_MAG_TENT_LOD0,              // D3DTFG_LINEAR        = 2
    NV097_SET_TEXTURE_FILTER_MAG_BOX_LOD0,               // D3DTFG_FLATCUBIC     = 3
    NV097_SET_TEXTURE_FILTER_MAG_BOX_LOD0,               // D3DTFG_GAUSSIANCUBIC = 4
    ~0                                                   // D3DTFG_ANISOTROPIC   = 5  (invalid. we have to deal with this separately)
};
#endif

// notes on these values:
// in openGL, foo_mipmap_bar means:
// - use the 'foo' filter within mipmaps
// - use the 'bar' filter between mipmaps
// stupid DX5 (and hence the HW definitions) were/are reversed

const DWORD nv056TextureMinFilter[D3D_MINFILTER_COUNT][D3D_MIPFILTER_COUNT] =
{
    // minfilter = 0 (undefined)
    ~0,                                                   // undefined
    ~0,                                                   // D3DTFP_NONE    = 1
    ~0,                                                   // D3DTFP_POINT   = 2
    ~0,                                                   // D3DTFP_LINEAR  = 3

    // D3DTFN_POINT       = 1
    NV056_SET_TEXTURE_FILTER_TEXTUREMIN_LINEAR,           // undefined (use default? HMH)
    NV056_SET_TEXTURE_FILTER_TEXTUREMIN_NEAREST,          // D3DTFP_NONE    = 1
    NV056_SET_TEXTURE_FILTER_TEXTUREMIN_MIPNEAREST,       // D3DTFP_POINT   = 2
    NV056_SET_TEXTURE_FILTER_TEXTUREMIN_LINEARMIPNEAREST, // D3DTFP_LINEAR  = 3

    // D3DTFN_LINEAR      = 2
    NV056_SET_TEXTURE_FILTER_TEXTUREMIN_LINEAR,           // undefined (use default)
    NV056_SET_TEXTURE_FILTER_TEXTUREMIN_LINEAR,           // D3DTFP_NONE    = 1
    NV056_SET_TEXTURE_FILTER_TEXTUREMIN_MIPLINEAR,        // D3DTFP_POINT   = 2
    NV056_SET_TEXTURE_FILTER_TEXTUREMIN_LINEARMIPLINEAR,  // D3DTFP_LINEAR  = 3

    // D3DTFN_ANISOTROPIC = 3 (invalid. we have to deal with this separately)
    ~0,                                                   // undefined
    ~0,                                                   // D3DTFP_NONE    = 1
    ~0,                                                   // D3DTFP_POINT   = 2
    ~0,                                                   // D3DTFP_LINEAR  = 3
};

#if (NVARCH >= 0x020)
const DWORD nv097TextureMinFilter[D3D_MINFILTER_COUNT][D3D_MIPFILTER_COUNT] =
{
    // minfilter = 0 (undefined)
    ~0,                                                   // undefined
    ~0,                                                   // D3DTFP_NONE    = 1
    ~0,                                                   // D3DTFP_POINT   = 2
    ~0,                                                   // D3DTFP_LINEAR  = 3

    // D3DTFN_POINT       = 1
    ~0,                                                   // undefined
    NV097_SET_TEXTURE_FILTER_MIN_BOX_LOD0,                // D3DTFP_NONE    = 1
    NV097_SET_TEXTURE_FILTER_MIN_BOX_NEARESTLOD,          // D3DTFP_POINT   = 2
    NV097_SET_TEXTURE_FILTER_MIN_BOX_TENT_LOD,            // D3DTFP_LINEAR  = 3

    // D3DTFN_LINEAR      = 2
    NV097_SET_TEXTURE_FILTER_MIN_TENT_LOD0,               // undefined (use default)
    NV097_SET_TEXTURE_FILTER_MIN_TENT_LOD0,               // D3DTFP_NONE    = 1
    NV097_SET_TEXTURE_FILTER_MIN_TENT_NEARESTLOD,         // D3DTFP_POINT   = 2
    NV097_SET_TEXTURE_FILTER_MIN_TENT_TENT_LOD,           // D3DTFP_LINEAR  = 3

    // D3DTFN_ANISOTROPIC = 3 (invalid. we have to deal with this separately)
    ~0,                                                   // undefined
    ~0,                                                   // D3DTFP_NONE    = 1
    ~0,                                                   // D3DTFP_POINT   = 2
    ~0,                                                   // D3DTFP_LINEAR  = 3
};

#endif  // NVARCH >= 0x020

const DWORD dx8MinFilterMapping[] =
{
    ~0,                   // D3DTEXF_NONE
    D3DTFN_POINT,         // D3DTEXF_POINT
    D3DTFN_LINEAR,        // D3DTEXF_LINEAR
    D3DTFN_ANISOTROPIC,   // D3DTEXF_ANISOTROPIC
    ~0,                   // D3DTEXF_FLATCUBIC
    ~0                    // D3DTEXF_GAUSSIANCUBIC
};

const DWORD dx8MagFilterMapping[] =
{
    ~0,                   // D3DTEXF_NONE
    D3DTFG_POINT,         // D3DTEXF_POINT
    D3DTFG_LINEAR,        // D3DTEXF_LINEAR
    D3DTFG_ANISOTROPIC,   // D3DTEXF_ANISOTROPIC
    D3DTFG_FLATCUBIC,     // D3DTEXF_FLATCUBIC
    D3DTFG_GAUSSIANCUBIC  // D3DTEXF_GAUSSIANCUBIC
};

const DWORD dx8MipFilterMapping[] =
{
    D3DTFP_NONE,          // D3DTEXF_NONE
    D3DTFP_POINT,         // D3DTEXF_POINT
    D3DTFP_LINEAR,        // D3DTEXF_LINEAR
    ~0,                   // D3DTEXF_ANISOTROPIC
    ~0,                   // D3DTEXF_FLATCUBIC
    ~0                    // D3DTEXF_GAUSSIANCUBIC
};

//---------------------------------------------------------------------------

// mappings between vertex attributes, streams, and HW registers

// map positions of D3D vertex attributes to indices in the driver's
// vertex attribute array and the HW's fixed-pipe input registers

const DWORD defaultInputRegMap[D3D_INPUTREGMAP_COUNT] = {
       // Microsoft                             -> NV fixed pipe mapping
    0, // D3DVSDE_POSITION     0  Position         Param[0]   Position            X,Y,Z,W
    1, // D3DVSDE_BLENDWEIGHT  1  BlendWeight      Param[1]   Skin Weights        W,W,W,W
    5, // D3DVSDE_BLENDINDICES 2  BlendIndices     Param[5]   Fog(OGL)            F,*,*,*
    2, // D3DVSDE_NORMAL       3  Normal           Param[2]   Normal              X,Y,Z,*
    6, // D3DVSDE_PSIZE        4  PointSize        Param[6]   Point Size          P,*,*,*
    3, // D3DVSDE_DIFFUSE      5  Diffuse          Param[3]   Diffuse Color       R,G,B,A
    4, // D3DVSDE_SPECULAR     6  Specular         Param[4]   Specular Color      R,G,B,A
    9, // D3DVSDE_TEXCOORD0    7  Texcoord0        Param[9]   Texture0            S,T,R,Q
   10, // D3DVSDE_TEXCOORD1    8  Texcoord1        Param[10]  Texture1            S,T,R,Q
   11, // D3DVSDE_TEXCOORD2    9  Texcoord2        Param[11]  Texture2            S,T,R,Q
   12, // D3DVSDE_TEXCOORD3    10 Texcoord3        Param[12]  Texture3            S,T,R,Q
   13, // D3DVSDE_TEXCOORD4    11 Texcoord4        Param[13]  Texture4            S,T,R,Q
   14, // D3DVSDE_TEXCOORD5    12 Texcoord5        Param[14]  Texture5            S,T,R,Q
   15, // D3DVSDE_TEXCOORD6    13 Texcoord6        Param[15]  Texture6            S,T,R,Q
    7, // D3DVSDE_TEXCOORD7    14 Texcoord7        Param[7]   Texture7            S,T,R,Q
    8, // D3DVSDE_POSITION2    15 n/a              Param[8]   unused              *,*,*,*
    8, // D3DVSDE_NORMAL2      16 n/a              Param[8]   unused              *,*,*,*
};

// map output of MS shader program to HW's vertex shader output registers

const DWORD defaultOutputRegMap[D3D_OUTPUTREGMAP_COUNT] = {
    0, // 0  vertex
    3, // 1  diffuse
    4, // 2  specular
    7, // 3  backfacing diffuse - unused
    8, // 4  backfacing specular - unused
    5, // 5  fog
    6, // 6  point size
    9, // 7  texture 0
   10, // 8  texture 1
   11, // 9  texture 2
   12, // 10 texture 3
   13, // 11 texture 4 (undefined in NV20)
   14, // 12 texture 5 (undefined in NV20)
   15, // 13 texture 6 (undefined in NV20)
    1, // 14 undefined in NV20
    2, // 15 undefined in NV20
};

#endif  // NVARCH >= 0x010

#endif  // NVARCH >= 0x04
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\src\nvTex.cpp ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
//
//  Module: nvTex.cpp
//   HW Specific Texture routines.
//
//  History:
//        Charles Inman (chasi)       01/31/98 - re-wrote and cleaned up.
//        Ben de Waal                 10/12/98 - overhaul
//
// **************************************************************************
#include "nvprecomp.h"

#if (NVARCH >= 0x04)

//****************************************************************************
//****************************************************************************
//****************************************************************************
//**  CTexture  **************************************************************
//****************************************************************************
//****************************************************************************
//****************************************************************************

//****************************************************************************
// invalidateTextureCache
//
// invalidates the texture cache by forcing at least a write to offset

__inline void invalidateTextureCache
(
    PNVD3DCONTEXT pContext   // may be NULL!!
)
{
    dbgTracePush ("invalidateTextureCache");

    if (pContext) {
#if (NVARCH >= 0x20)
        if (pDriverData->nvD3DPerfData.dwNVClasses & (NVCLASS_FAMILY_KELVIN | NVCLASS_FAMILY_CELSIUS)) {
            pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_TEXTURE_STATE;
            pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_TEXTURE_STATE;
#ifdef STATE_CULL
            // there's no explicit method to clear nv10's texture cache,
            // but re-sending the offset will do it implicitly
            pContext->hwState.celsius.valid [NV056_SET_TEXTURE_OFFSET(0) >> 2] = 0;
            pContext->hwState.celsius.valid [NV056_SET_TEXTURE_OFFSET(1) >> 2] = 0;
#endif
        }
        else
#endif // NVARCH >= 0x10
        {
            NV_FORCE_TRI_SETUP (pContext);
        }
    }

    dbgTracePop();
}

//****************************************************************************
// updateMipMapChain
//
// what does it do?

__forceinline void updateMipMapChain
(
    PNVD3DCONTEXT pContext,  // may be NULL!!
    CNvObject    *pNvObj
)
{
    dbgTracePush ("updateMipMapChain");

    while (pNvObj) {
        // get texture
        CTexture *pTexture = pNvObj->getTexture();

        // if this level has been renamed, copy data forward
        if (pTexture->isRenamedNotCopied())
        {
            DWORD dwSize = pTexture->getBPP() << (pTexture->getLogWidth() + pTexture->getLogHeight());
            DWORD dwSrc  = pTexture->getPreviousSwizzled()->getAddress();
            DWORD dwDst  = pTexture->getSwizzled()->getAddress();
                    #ifdef NV_PROFILE_COPIES
                    NVP_START(NVP_T_RENAME_FWD);
                    #endif
            nvMemCopy (dwDst,dwSrc,dwSize);
                    #ifdef NV_PROFILE_COPIES
                    NVP_STOP(NVP_T_RENAME_FWD);
                    nvpLogTime (NVP_T_RENAME_FWD,nvpTime[NVP_T_RENAME_FWD]);
                    #endif
            pTexture->tagRenamedAndCopied();
        }

        // handle this texture
        if (!pTexture->getSwizzled()->isUpToDate())
        {
            pTexture->updateSwizzleSurface (pContext);
        }

        // get the next one in the chain
        pNvObj = pNvObj->getAttachedA();
    }

    dbgTracePop();
}

//****************************************************************************
// updateTextureSurfaces
//
// update all out-of-date swizzled surfaces in a complex texture.
// traverses all mipmap levels and all faces of a cubemap.

__forceinline void updateSwizzledSurfaces
(
    PNVD3DCONTEXT pContext,  // may be NULL!!
    CTexture     *pTexture
)
{
    // get this object
    CNvObject *pNvObj = pTexture->getLinear()->getWrapper();

    if (!pTexture->getSwizzled()->isUpToDate() || pTexture->isSubSurfacesDirty())
    {
        if (pTexture->isCubeMap())
        {
            // cube map
            while (pNvObj)
            {
                updateMipMapChain (pContext, pNvObj);
                pNvObj = pNvObj->getAttachedB();
            }
        }
        else
        {
            // simple texture
            updateMipMapChain (pContext, pNvObj);
        }
        pTexture->tagSubSurfacesClean();
    }
}

//****************************************************************************
// CTexture::hwLock
//
// aquire hw access to swizzled surface
//  if not swizzled yet, do it now.
// NOTE: if the surface to be locked is a mipmap, or a subsurface of a cube map,
//  this routine will automatically lock the whole chain (logically one memory region)

void CTexture::hwLock
(
    PNVD3DCONTEXT pContext,  // may be NULL!!
    DWORD         dwAccess
)
{
    dbgTracePush ("CTexture::hwLock");

    // if this texture is not the base, call lock with a base
    //  yes - we can honestly say we use recursion in our driver now!
    nvAssert (getBaseTexture());
    if (!isBaseTexture()) {
        getBaseTexture()->hwLock (pContext,dwAccess);
        dbgTracePop();
        return;
    }

#ifdef TEX_MANAGE
    if (isManaged()) {
        // if the texture is in system memory, we have to bring it into video or AGP
        if (getSwizzled()->getHeapLocation() == CSimpleSurface::HEAP_SYS) {
            BOOL bSuccess = nvTexManageFetch (pContext, this);
            nvAssert (bSuccess);
        }
        else {
            // just make a note of the fact that we've touched this texture
            nvTexManageTouch (pContext, this);
        }
    }
#endif

    // update only if dirty
#if defined(NV_NULL_DRIVER) || defined(NV_NULL_TEXTURE_DRIVER)
    // NOP
#else
    updateSwizzledSurfaces (pContext, this);

    // lock surface explicitly
    m_surfSwizzled.hwLock (dwAccess);
#endif // NULL

    dbgTracePop();
}

//****************************************************************************
// CTexture::internalCanRename
//
// tell surface renamer if it is OK to rename a this texture now

BOOL CTexture::internalCanRename
(
    void
)
{
    //
    // cannot rename cube maps or individual mipmap levels (for now)
    //
    dbgTracePush ("CTexture::internalCanRename");
    BOOL b = (!isCubeMap() && !isUserMipLevel());
    dbgTracePop();
    return b;
}

// helper wrapper

BOOL __stdcall _CTexture_canRename
(
    void *pContext
)
{
    dbgTracePush ("_CTexture_canRename");
    BOOL b = ((CTexture*)pContext)->internalCanRename();
    dbgTracePop();
    return b;
}

//****************************************************************************
// CTexture::enableRenaming
//
// enable texture renaming

void CTexture::internalRename
(
    DWORD dwOldIndex,
    DWORD dwNewIndex
)
{
    dbgTracePush ("CTexture::internalRename");

    // make sure that the 'old' surface does not have any pending
    //  copies. (i.e. we only rename one level ahead without copying).
/*todo*/ //hwLock (NULL,);

    // since we can only rename on a BLT to the top-level, we have to
    // tell all the mipmaps that they should take care of themselves
    // if they do not get updated properly (i.e. copy from old surface)
    DWORD dwAddr = m_surfSwizzled.getSurface(dwNewIndex)->getAddress();
    DWORD dwBPP  = getBPP();
    DWORD dwAdd  = dwBPP << (getLogWidth() + getLogHeight());

    CNvObject *pNvObj = getWrapper();


    if (pNvObj)
    {
        // skip the parent level
        dwAddr  += dwAdd;
        dwAdd  >>= 2;
        if (dwAdd < dwBPP) dwAdd = dwBPP;
        pNvObj = pNvObj->getAttachedA();
    }

    while (pNvObj)
    {
        // get texture
        CTexture *pTexture = pNvObj->getTexture();
        pTexture->tagRenamedNotCopied();
        pTexture->m_surfSwizzled.forceRename(dwNewIndex,dwAddr);

        // update (allow DXT to work down to 1x1 (which is stored as 4x4))
        dwAddr  += dwAdd;
        dwAdd  >>= 2;
        if (dwAdd < dwBPP) dwAdd = dwBPP;

        // get the next one in the chain
        pNvObj = pNvObj->getAttachedA();
    }

    tagSubSurfacesDirty();
    dbgTracePop();
}

// helper wrapper

void __stdcall _CTexture_rename
(
    void         *pTexture,
    DWORD         dwOldIndex,
    DWORD         dwNewIndex
)
{
    dbgTracePush ("_CTexture_rename");
    if(dbgShowState & NVDBG_SHOW_TEXTURE_RENAME)
        DPF("CTexture Renaming Handle: %08x TexAddr: %08x INDEX: %08x->%08x\n",
            (((CTexture*)pTexture)->getWrapper())->getHandle(), pTexture,
            dwOldIndex,dwNewIndex);

    ((CTexture*)pTexture)->internalRename(dwOldIndex,dwNewIndex);
    dbgTracePop();
}

//****************************************************************************
// CTexture::enableRenaming
//
// enable texture renaming

void CTexture::enableRenaming
(
    void
)
{
    dbgTracePush ("CTexture::enableRenaming");
    //
    // enable renaming with special callbacks
    //
    m_surfSwizzled.tagRenameEnable (CComplexSurface<TOTAL_TEX_RENAME>::RENAME_EXTERNAL,
                                    1, // todo: same here
                                    _CTexture_canRename,
                                    _CTexture_rename,
                                    this);
    dbgTracePop();
}

//****************************************************************************
// CTexture::calcMipMapSize
//
// calculates the amount of bytes needed with a given number of mipmaps

DWORD CTexture::calcMipMapSize
(
    DWORD dwLogU,
    DWORD dwLogV,
    DWORD dwLogP,
    DWORD dwMipMapLevels
)
{
    dbgTracePush ("CTexture::calcMipMapSize");

    DWORD dwSize = 0;
    while (dwMipMapLevels)
    {
        dwSize += 1U << (dwLogU + dwLogV + dwLogP);
        if (dwLogU) dwLogU --;
        if (dwLogV) dwLogV --;
        if (dwLogP) dwLogP --;
        dwMipMapLevels --;
    }

    dbgTracePop();
    return dwSize;

/*
    neat code that works for mipmaps that got to Nx1 or 1xN, not 1x1 (if non-square)

    DWORD dwBits  = ((dwLogU + dwLogV) & 1) ? 0xaaaaaaaa : 0x55555555;
    DWORD dwTotal =  ((1 << (dwLogU + dwLogV + 1)) - 1) & dwBits;
    DWORD dwMask  = ~((1 << (dwLogU + dwLogV + 2 - dwMipMapLevels * 2)) - 1);
    return dwTotal & dwMask;
*/
}

//****************************************************************************
// CTexture::getCubeMapFaceNum
//
// get the face number from the face flag

DWORD CTexture::getCubeMapFaceNum
(
    DWORD dwFace              // cubemap face flag
)
{
    DWORD dwFaceNum;

    dbgTracePush ("CTexture::getCubeMapFaceNum");

    switch (dwFace) {
        case DDSCAPS2_CUBEMAP_POSITIVEX:
            dwFaceNum = 0;
            break;
        case DDSCAPS2_CUBEMAP_NEGATIVEX:
            dwFaceNum = 1;
            break;
        case DDSCAPS2_CUBEMAP_POSITIVEY:
            dwFaceNum = 2;
            break;
        case DDSCAPS2_CUBEMAP_NEGATIVEY:
            dwFaceNum = 3;
            break;
        case DDSCAPS2_CUBEMAP_POSITIVEZ:
            dwFaceNum = 4;
            break;
        case DDSCAPS2_CUBEMAP_NEGATIVEZ:
            dwFaceNum = 5;
            break;
    }

    dbgTracePop();
    return dwFaceNum;
}

//****************************************************************************
// CTexture::prepareLinearAsRenderTarget
//
// checks that the linear copy of the texture is in video memory. if it does
//  not exist, or if it is in a different heap, relocate it

BOOL CTexture::prepareLinearAsRenderTarget
(
    void
)
{
    dbgTracePush ("CTexture[%08x]::prepareLinearAsRenderTarget()",this);

    // sanity checks
    assert (this);

    // we are going to use the linear surface, make sure it's up to date
    if (!updateLinearSurface())
    {
        dbgTracePop();
        return FALSE;
    }

    // is it in the right place? (vidmem)
    if (!(getLinear()->getHeapLocation() == CSimpleSurface::HEAP_VID))
    {
        // nope, allocate a version in video memory
        CSimpleSurface surfTemp;
        if (!surfTemp.create (getLinear()->getWrapper(), getLinear()->getFormat(),
                              getLinear()->getWidth(), getLinear()->getHeight(), getLinear()->getDepth(),
                              getLinear()->getMultiSampleBits(), getLinear()->getBPPRequested(), getLinear()->getBPP(),
                              getLinear()->getPitch(), CSimpleSurface::HEAP_VID,
                              CSimpleSurface::HEAP_VID, CSimpleSurface::ALLOCATE_TILED
#ifdef CAPTURE
                             ,CAPTURE_SURFACE_KIND_TEXTURE
#endif
                              ))
        {
            dbgTracePop();
            return FALSE;
        }

        // copy contents from original surface to the new one
        nvMemCopy (surfTemp.getAddress(),
                   getLinear()->getAddress(),
                   getLinear()->getSize());

        // swap surfaces
        //  neat trick to make the temp surface own the old non-vidmem surface
        getLinear()->swap (&surfTemp);

        // destroy old surface
        surfTemp.destroy();
    }

    // tag swizzled out-of-date, so that it gets reswizzled from the linear
    //  surface when it is used as a texture
    getSwizzled()->tagOutOfDate();

    // if this is part of a cube map/mipmap, tag the base as dirty
    //  this will trigger a proper update of all subsurfaces before HW touches them
    if (isUserMipLevel() || isCubeMap())
    {
        getBaseTexture()->tagSubSurfacesDirty();
    }

    // tag linear as up-to-date
    getLinear()->tagUpToDate();

    // done
    dbgTracePop();
    return TRUE;
}

//****************************************************************************
// CTexture::updateLinearSurface
//

BOOL CTexture::updateLinearSurface
(
    void
)
{
    dbgTracePush ("CTexture[%08x]::updateLinearSurface()",this);

    // texture valid
    assert (this);

    // cache active swizzled surface
    CSimpleSurface *pActive = getSwizzled();

    // create a linear surface if it does not exist already
    //  note that the linear surface for render targets get allocated in
    //   CTexture::prepareLinearAsRenderTarget(), and not here
    if (m_surfLinear.isValid())
    {
        // we have a linear surface, is it already up to date?
        if (m_surfLinear.isUpToDate())
        {
            // yes, we have no work!
            dbgTracePop();
            return TRUE;
        }
    }
    else
    {
        // allocate surface
        DWORD dwAllowedHeaps  = pDriverData->GARTLinearBase ? (CSimpleSurface::HEAP_VID | CSimpleSurface::HEAP_AGP | CSimpleSurface::HEAP_SYS)
                                                            : (CSimpleSurface::HEAP_VID | CSimpleSurface::HEAP_PCI | CSimpleSurface::HEAP_SYS);

        DWORD dwPreferredHeap = CSimpleSurface::HEAP_SYS;

        if (!((CSimpleSurface*)&m_surfLinear)->create (getPitch(), getHeight(), getDepth(), getBPP(),
                                                       dwAllowedHeaps, dwPreferredHeap,
                                                       CSimpleSurface::ALLOCATE_SIMPLE
#ifdef CAPTURE
                                                      ,CAPTURE_SURFACE_KIND_TARGET
#endif
                                                       ))
        {
            // no memory - ouch
            DPF ("CTexture::updateLinearSurface: cannot allocate linear surface");
            dbgD3DError();
            dbgTracePop();
            return FALSE;
        }
    }

    // Is the swizzle surface valid?
    //  if so then we deswizzle here. This is skipped usually when the app wants to
    //  lock the texture and hasn't touched a pixel yet
    if (pActive->isValid() && pActive->isUpToDate())
    {
        // deswizzle
                #ifdef NV_PROFILE_CPULOCK
                NVP_START (NVP_T_TEX_ULS);
                #endif
        DDLOCKINDEX(NVSTAT_LOCK_UPDATE_LINEAR);
        m_surfLinear.cpuLock (CSimpleSurface::LOCK_NORMAL);
        pActive->cpuLock (CSimpleSurface::LOCK_NORMAL);
                #ifdef NV_PROFILE_CPULOCK
                NVP_STOP (NVP_T_TEX_ULS);
                nvpLogTime (NVP_T_TEX_ULS,nvpTime[NVP_T_TEX_ULS]);
                #endif
        if (isDXT())
        {
            nvSwizBlt_cpu_lin2lin (pActive->getAddress(),getPitch(),0,0,
                                   m_surfLinear.getAddress(),getPitch(),0,0,
                                   getWidth(),getHeight(),getBPP());
        }
        else
        {
            nvSwizBlt_cpu_swz2lin (pActive->getAddress(),0,0,getLogWidth(),getLogHeight(),
                                   m_surfLinear.getAddress(),getPitch(),0,0,
                                   getWidth(),getHeight(),getBPP());
        }
        pActive->cpuUnlock();
        m_surfLinear.cpuUnlock();
    }

    // update flags & reset dirty rectangle
    m_surfLinear.tagUpToDate();

    // done
    dbgTracePop();
    return TRUE;
}

//****************************************************************************
// CTexture::updateSwizzleSurface
//

BOOL CTexture::updateSwizzleSurface
(
    PNVD3DCONTEXT pContext  // may be NULL!
)
{
    dbgTracePush ("CTexture[%08x]::updateSwizzleSurface()",this);

    // texture valid
    assert (this);

    // get active swizzled surface
    CSimpleSurface *pActive = getSwizzled();

    // create swizzled surface if it does not exist already
    // note that the linear surface for render targets get allocated in
    // CTexture::prepareLinearAsRenderTarget(), and not here

    if (!pActive->isValid()) {
        // allocate surface
        DWORD dwAllowedHeaps  = pDriverData->GARTLinearBase ? (CSimpleSurface::HEAP_VID | CSimpleSurface::HEAP_AGP)
                                                            : (CSimpleSurface::HEAP_VID | CSimpleSurface::HEAP_PCI);

        DWORD dwPreferredHeap = (pDriverData->nvD3DPerfData.dwPerformanceStrategy & PS_TEXTURE_PREFER_AGP) ? ( CSimpleSurface::HEAP_AGP | CSimpleSurface::HEAP_PCI)
                                                                                                           : CSimpleSurface::HEAP_VID;

        if (!pActive->create (getPitch(), getHeight(), getDepth(), getBPP(),
                              dwAllowedHeaps, dwPreferredHeap,
                              CSimpleSurface::ALLOCATE_SIMPLE
#ifdef CAPTURE
                             ,CAPTURE_SURFACE_KIND_TEXTURE
#endif
                              )) {
            // no memory - ouch
            DPF ("CTexture::updateSwizzleSurface: cannot allocate swizzled surface");
            dbgD3DError();
            dbgTracePop();
            return FALSE;
        }
    }
    else {
        // we have a swizzled surface, is it already up to date?
        if (pActive->isUpToDate()) {
            // yes, we have no work!
            dbgTracePop();
            return TRUE;
        }
    }

    // if the source is up to date, we can now swizzle it
    //  if not, texture corruption will occur because the app failed to init the texture

    if (m_surfLinear.isValid() && m_surfLinear.isUpToDate()) {
        // swizzle
        BOOL bUseHW = (pDriverData->nvD3DPerfData.dwPerformanceStrategy & PS_TEXTURE_USEHW)
                   && m_surfLinear.hwCanRead()
                   && pActive->hwCanWrite();

        if (bUseHW)
        {
            m_surfLinear.hwLock(CSimpleSurface::LOCK_NORMAL);
            pActive->hwLock(CSimpleSurface::LOCK_NORMAL);
            nvSwizBlt_gpu_lin2swz (m_surfLinear.getOffset(), m_surfLinear.getHeapLocation(),
                                   getPitch(), 0, 0,
                                   pActive->getOffset(), 0, 0,
                                   getLogWidth(), getLogHeight(),
                                   getWidth(), getHeight(),
                                   getBPP());
            pActive->hwUnlock();
            m_surfLinear.hwUnlock();
        }
        else
        {
                    #ifdef NV_PROFILE_CPULOCK
                    NVP_START (NVP_T_TEX_USS);
                    #endif
            DDLOCKINDEX(NVSTAT_LOCK_UPDATE_OPTIMIZED);
            m_surfLinear.cpuLock (CSimpleSurface::LOCK_NORMAL);
            pActive->cpuLock (CSimpleSurface::LOCK_RENAME); // allow renaming
                    #ifdef NV_PROFILE_CPULOCK
                    NVP_STOP (NVP_T_TEX_USS);
                    nvpLogTime (NVP_T_TEX_USS,nvpTime[NVP_T_TEX_USS]);
                    #endif
            if (isDXT())
            {
                nvSwizBlt_cpu_lin2lin (m_surfLinear.getAddress(),getPitch(),0,0,
                                       pActive->getAddress(),getPitch(),0,0,
                                       getWidth(),getHeight(),getBPP());
            }
            else
            {
                nvSwizBlt_cpu_lin2swz (m_surfLinear.getAddress(),getPitch(),0,0,
                                       pActive->getAddress(),0,0,getLogWidth(),getLogHeight(),
                                       getWidth(),getHeight(),getBPP());
            }

            // capture
#ifdef CAPTURE
            if (getDC()->nvD3DRegistryData.regCaptureEnable & D3D_REG_CAPTUREENABLE_RECORD) {
                CAPTURE_MEMORY_WRITE memwr;
                memwr.dwJmpCommand         = CAPTURE_JMP_COMMAND;
                memwr.dwExtensionSignature = CAPTURE_EXT_SIGNATURE;
                memwr.dwExtensionID        = CAPTURE_XID_MEMORY_WRITE;
                memwr.dwCtxDMAHandle       = (pActive->getHeapLocation() == CSimpleSurface::HEAP_VID)
                                           ? NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY
                                           : D3D_CONTEXT_DMA_HOST_MEMORY;
                memwr.dwOffset             = pActive->getOffset();
                memwr.dwSize               = getWidth() * getHeight() * getBPP();
                captureLog (&memwr,sizeof(memwr));
                captureLog ((void*)pActive->getAddress(),memwr.dwSize);
            }
#endif

            //
            // BUGBUG this should like below (test with powerslide)
            //
            // problem is that hwLock is called in inner loops after it read the dvb values. if
            //  the lock modifies them, it does not detect that case.
            //
            // can help perf if fixed.
            //
/*            nvSwizBlt_lin2swz (m_surfLinear.getAddress(),getPitch(),0,0,
                                    this,pActive->getAddress(),0,0,getLogWidth(),getLogHeight(),
                                    getWidth(),getHeight(),getBPP());*/
            pActive->cpuUnlock();
            m_surfLinear.cpuUnlock();
            invalidateTextureCache (pContext);
        }
    }

    // update state
    pActive->tagUpToDate();

    // done
    dbgTracePop();
    return TRUE;
}

//****************************************************************************

#if (NVARCH >= 0x010)

// pre-calculate HW-specific control words

void CTexture::calculateNV056ControlWords
(
    void
)
{
    m_dwNV056Control0  = DRF_DEF(056, _SET_TEXTURE_CONTROL0, _ENABLE, _TRUE);
    // these are backward from openGL. d3d can only set the maximum mipmap level, by which they mean
    // the openGL minimum level (d3d maximum = largest sized level to use, not largest level number).
    // the d3d minimum level (the openGL / celsius maximum) is always just the end of the chain
    m_dwNV056Control0 |= DRF_NUM(056, _SET_TEXTURE_CONTROL0, _MAX_LOD_CLAMP, ((m_dwMipMapCount-1) << 8));  // 4.8 fixed point
    // Let's assume these defaults are cool for D3D. Alpha kill works
    // when color key is set to kill (I think).
    m_dwNV056Control0 |= DRF_DEF(056, _SET_TEXTURE_CONTROL0, _ALPHA_KILL_ENABLE, _FALSE);

    m_dwNV056Format  = DRF_NUM(056, _SET_TEXTURE_FORMAT, _CONTEXT_DMA, nv056TextureContextDma[getSwizzled()->getContextDMA()]);
    m_dwNV056Format |= DRF_NUM(056, _SET_TEXTURE_FORMAT, _COLOR, nv056TextureFormat[m_surfLinear.getFormat()]);

    // texel alignment
    m_dwNV056Format |= ((getDC()->nvD3DRegistryData.regTexelAlignment & D3D_REG_TEXELALIGNMENT_ZOH_MASK) == D3D_REG_TEXELALIGNMENT_ZOH_CENTER)
                    ? DRF_DEF(056, _SET_TEXTURE_FORMAT, _ORIGIN_ZOH, _CENTER)
                    : DRF_DEF(056, _SET_TEXTURE_FORMAT, _ORIGIN_ZOH, _CORNER);
    m_dwNV056Format |= ((getDC()->nvD3DRegistryData.regTexelAlignment & D3D_REG_TEXELALIGNMENT_FOH_MASK) == D3D_REG_TEXELALIGNMENT_FOH_CENTER)
                    ? DRF_DEF(056, _SET_TEXTURE_FORMAT, _ORIGIN_FOH, _CENTER)
                    : DRF_DEF(056, _SET_TEXTURE_FORMAT, _ORIGIN_FOH, _CORNER);

    // levels should already be clamped to 1-15
    nvAssert ((m_dwMipMapCount > 0) && (m_dwMipMapCount < 16));
    m_dwNV056Format |= DRF_NUM(056, _SET_TEXTURE_FORMAT, _MIPMAP_LEVELS, m_dwMipMapCount);
    m_dwNV056Format |= DRF_NUM(056, _SET_TEXTURE_FORMAT, _BASE_SIZE_U, getLogicalLogWidth());
    m_dwNV056Format |= DRF_NUM(056, _SET_TEXTURE_FORMAT, _BASE_SIZE_V, getLogicalLogHeight());
}

#endif  // NVARCH >= 0x010

//****************************************************************************
// CTexture::create
//
// create a base level texture

BOOL CTexture::create
(
    CNvObject *pWrapperObject,   // NvObject wrapping this texture
    DWORD      dwWidth,          // width
    DWORD      dwHeight,         // height
    DWORD      dwDepth,          // depth
    DWORD      dwBPPRequested,   // bytes per pixel requested
    DWORD      dwBPPGranted,     // bytes per pixel granted
    DWORD      dwMipMapCount,    // # of mipmaps (including self)
    DWORD      dwFormat,         // texture format NV_TEXTURE_FORMAT_xxx
    DWORD      dwAllowedHeaps,   // allowed heaps to allocate in
    DWORD      dwPreferredHeap   // preferred heap
)
{
    dbgTracePush ("CTexture[%08x]::create(dwWidth=%d,dwHeight=%d,dwBPP=%d,dwMipMapCount=%d,dwFormat=%x,dwAllowedHeaps=%x,dwPreferredHeap=%x)",
                  this,dwWidth,dwHeight,dwBPPGranted,dwMipMapCount,dwFormat,dwAllowedHeaps,dwPreferredHeap);

    // valid?
    assert (this);

    DWORD dwLogWidth  = dwWidth;
    DWORD dwLogHeight = dwHeight;
    DWORD dwLogDepth  = dwDepth;
    ASM_LOG2 (dwLogWidth);
    ASM_LOG2 (dwLogHeight);
    ASM_LOG2 (dwLogDepth);

    // determine size of texture
    //  - include mipmaps
    DWORD dwSize = calcMipMapSize(dwLogWidth, dwLogHeight, dwLogDepth, dwMipMapCount) * dwBPPGranted;

    // cubemap
    if (isCubeMap())
    {
        if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
            m_dwCubeMapSizeFacePadded = (dwSize + NV_KELVIN_CUBEMAP_FACE_ALIGN) & ~NV_KELVIN_CUBEMAP_FACE_ALIGN;
        } else {
            m_dwCubeMapSizeFacePadded = (isDXT() || isPalettized()) ?
                                        (dwSize + NV_CELSIUS_CUBEMAP_FACE_ALIGN_COMPRESSED) & ~NV_CELSIUS_CUBEMAP_FACE_ALIGN_COMPRESSED :
                                        (dwSize + NV_CELSIUS_CUBEMAP_FACE_ALIGN) & ~NV_CELSIUS_CUBEMAP_FACE_ALIGN;
        }
        dwSize = 6 * m_dwCubeMapSizeFacePadded;
    }

    // if we prefer AGP memory over VID memory
    if (pDriverData->nvD3DPerfData.dwPerformanceStrategy & PS_TEXTURE_PREFER_AGP)
    {
        // if we are allowed agp and video memory to allocate in
        if ((dwPreferredHeap & (CSimpleSurface::HEAP_VID | CSimpleSurface::HEAP_AGP)) == (CSimpleSurface::HEAP_VID | CSimpleSurface::HEAP_AGP))
        {
            // if we want video
            if (dwPreferredHeap == CSimpleSurface::HEAP_VID)
            {
                // override to agp
                dwPreferredHeap = CSimpleSurface::HEAP_AGP;
            }
        }
    }

    // allocate surface
    if (!m_surfSwizzled.create (pWrapperObject, dwSize, dwAllowedHeaps, dwPreferredHeap
#ifdef CAPTURE
                               ,CAPTURE_SURFACE_KIND_TEXTURE
#endif
                                ))
    {
        DPF ("CTexture::create: failed to alloc surface");
        dbgTracePop();
        return FALSE;
    }

    m_surfLinear.setWrapper      (pWrapperObject);
    m_surfLinear.setWidth        (dwWidth);
    m_surfLinear.setHeight       (dwHeight);
    m_surfLinear.setDepth        (dwDepth);
    m_surfLinear.setBPP          (dwBPPGranted);
    m_surfLinear.setBPPRequested (dwBPPRequested);
    m_surfLinear.setFormat       (dwFormat);
    m_surfLinear.setPitch        (dwBPPGranted << dwLogWidth);
    m_surfLinear.setSlicePitch   (dwBPPGranted << (dwLogWidth+dwLogDepth));

    m_dwLogWidth    = dwLogWidth;
    m_dwLogHeight   = dwLogHeight;
    m_dwLogDepth    = dwLogDepth;
    m_dwMipMapCount = dwMipMapCount;

    // pre-calculate HW-specific control words
#if (NVARCH >= 0x010)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {
        calculateNV056ControlWords();
    }
#endif  // NVARCH >= 0x010

    dbgTracePop();
    return TRUE;
}

//****************************************************************************
// CTexture::create
//
// create a mipmap level texture

BOOL CTexture::create
(
    CNvObject *pWrapperObject,   // NvObject wrapping this texture
    DWORD      dwThisFace,
    CTexture  *pBaseTexture,   // create a mipmap from this base
    DWORD      dwMipMapLevel   // this is the nth mipmap (base = 0)
)
{
    dbgTracePush ("CTexture[%08x]::create(dwThisFace=%d,pBaseTexture=%08x,dwMipMapLevel=%d)",
                  this,dwThisFace,pBaseTexture,dwMipMapLevel);

    // valid?
    assert (this);

    // prepare information for this mipmap level
    DWORD dwBaseLogWidth  = pBaseTexture->getLogWidth();
    DWORD dwBaseLogHeight = pBaseTexture->getLogHeight();
    DWORD dwBaseLogDepth  = pBaseTexture->getLogDepth();
    DWORD dwLogWidth      = DWORD(max(0,int(dwBaseLogWidth  - dwMipMapLevel)));
    DWORD dwLogHeight     = DWORD(max(0,int(dwBaseLogHeight - dwMipMapLevel)));
    DWORD dwLogDepth      = DWORD(max(0,int(dwBaseLogDepth  - dwMipMapLevel)));
    DWORD dwWidth         = 1 << dwLogWidth;
    DWORD dwHeight        = 1 << dwLogHeight;
    DWORD dwDepth         = 1 << dwLogDepth;
    DWORD dwBPP           = pBaseTexture->getBPP();
    DWORD dwBPPRequested  = pBaseTexture->getBPPRequested();
    DWORD dwFormat        = pBaseTexture->getFormat();
    DWORD dwMipMapCount   = pBaseTexture->getMipMapCount() - dwMipMapLevel;
    DWORD dwPitch         = dwBPP << dwLogWidth;
    DWORD dwSize          = calcMipMapSize(dwLogWidth,dwLogHeight,dwLogDepth,dwMipMapCount) * dwBPP;
    DWORD dwAddress       = pBaseTexture->getSwizzled()->getAddress()
                          + pBaseTexture->getSwizzled()->getSize()
                          - dwSize;
    DWORD dwHeapLocation  = pBaseTexture->getSwizzled()->getHeapLocation();

    // cubemap
    if (isCubeMap())
    {
        // copy cube map info from base
        m_dwCubeMapSizeFacePadded = pBaseTexture->m_dwCubeMapSizeFacePadded;

        // get offset to this face
        dwAddress = pBaseTexture->getSwizzled()->getAddress()
                  + getCubeMapFaceNum(dwThisFace) * m_dwCubeMapSizeFacePadded
                  + calcMipMapSize(dwBaseLogWidth,dwBaseLogHeight,dwBaseLogDepth,dwMipMapLevel) * dwBPP;
    }

    // point texture to proper place off of base texture
    if (!m_surfSwizzled.own (dwAddress, dwPitch, dwLogHeight, dwHeapLocation, FALSE))
    {
        DPF ("CTexture::create: failed to claim surface");
        dbgTracePop();
        return FALSE;
    }

    // assign variables
    m_surfLinear.setWrapper      (pWrapperObject);
    m_surfLinear.setWidth        (dwWidth);
    m_surfLinear.setHeight       (dwHeight);
    m_surfLinear.setDepth        (dwDepth);
    m_surfLinear.setBPP          (dwBPP);
    m_surfLinear.setBPPRequested (dwBPPRequested);
    m_surfLinear.setFormat       (dwFormat);
    m_surfLinear.setPitch        (dwBPP << dwLogWidth);
    m_surfLinear.setSlicePitch   (dwBPP << (dwLogWidth+dwLogDepth));

    m_dwLogWidth    = dwLogWidth;
    m_dwLogHeight   = dwLogHeight;
    m_dwLogDepth    = dwLogDepth;
    m_dwMipMapCount = dwMipMapCount;
    m_pBaseTexture  = pBaseTexture;

    // update state
    tagUserMipLevel();

    // pre-calculate HW-specific control words
#if (NVARCH >= 0x010)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {
        calculateNV056ControlWords();
    }
#endif  // NVARCH >= 0x010

    dbgTracePop();
    return TRUE;
}

#ifdef TEX_MANAGE

//****************************************************************************

// CTexture::fetch
//
// bring a texture from system memory back into HW-readable memory (ie. video or AGP)
// returns TRUE on success, FALSE on failure

BOOL CTexture::fetch (void)
{
    CComplexSurface<TOTAL_TEX_RENAME> newSurfSwizzled;

    dbgTracePush ("CTexture::fetch");

    // this should be the base texture
    nvAssert (isBaseTexture());

    if (getSwizzled()->getHeapLocation() != CSimpleSurface::HEAP_SYS) {
        // texture is already in video or AGP memory. this shouldn't really have been called
        DPF ("attempt to fetch an unevicted texture");
        dbgD3DError();
        dbgTracePop();
        return (TRUE);
    }

    // determine the size of the texture
    DWORD dwSize;
    if (isCubeMap()) {
        dwSize = 6 * m_dwCubeMapSizeFacePadded;
    }
    else {
        dwSize = getBPP() * calcMipMapSize (m_dwLogWidth, m_dwLogHeight, m_dwLogDepth, m_dwMipMapCount);
    }

    // alternately, i think this should work...
    DWORD dwSize2 = m_surfSwizzled.getActiveSurface()->getPitch() * m_surfSwizzled.getActiveSurface()->getHeight();
    nvAssert (dwSize == dwSize2);

    // allocate a new surface in system memory
    DWORD dwPreferredHeap = CSimpleSurface::HEAP_VID;
    DWORD dwAllowedHeaps  = CSimpleSurface::HEAP_VID |
                            ((pDriverData->GARTLinearBase) ?
                                CSimpleSurface::HEAP_AGP :
                                CSimpleSurface::HEAP_PCI);

#ifdef TEX_MANAGE_TEST
    dwAllowedHeaps = dwPreferredHeap = CSimpleSurface::HEAP_VID;
#endif

    if (!newSurfSwizzled.create (m_surfLinear.getWrapper(), dwSize, dwAllowedHeaps, dwPreferredHeap
#ifdef CAPTURE
                                ,CAPTURE_SURFACE_KIND_TEXTURE
#endif
                                ))
    {
        dbgTracePop();
        return (FALSE);
    }

    // copy texture data to the new surface
    nvMemCopy (newSurfSwizzled.getActiveSurface()->getAddress(), m_surfSwizzled.getActiveSurface()->getAddress(), dwSize);

    // swap the new into the old, and destroy the new, which is now the old  :)
    m_surfSwizzled.swap (&newSurfSwizzled);
    newSurfSwizzled.destroy();

    // re-fresh HW control words (heap may have changed)
#if (NVARCH >= 0x010)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {
        calculateNV056ControlWords();
    }
#endif  // NVARCH >= 0x010

    // run down the attached textures and reset their pointers into the new surface
    CNvObject *pNvObjA, *pNvObjB;
    DWORD     dwFace, dwMMLevel;

    dwFace     = DDSCAPS2_CUBEMAP_POSITIVEX;
    dwMMLevel  = 0;

    // this surface's mipmaps
    pNvObjA = m_surfLinear.getWrapper()->getAttachedA();
    while (pNvObjA) {
        dwMMLevel++;
        pNvObjA->getTexture()->create (pNvObjA, dwFace, this, dwMMLevel);
        pNvObjA = pNvObjA->getAttachedA();
    }

    // run down the cubemap faces (if any)
    pNvObjB = m_surfLinear.getWrapper()->getAttachedB();
    while (pNvObjB) {
        dwFace <<= 1;
        dwMMLevel = 0;
        pNvObjB->getTexture()->create (pNvObjB, dwFace, this, dwMMLevel);
        pNvObjA = pNvObjB->getAttachedA();
        while (pNvObjA) {
            dwMMLevel++;
            pNvObjA->getTexture()->create (pNvObjA, dwFace, this, dwMMLevel);
            pNvObjA = pNvObjA->getAttachedA();
        }
        pNvObjB = pNvObjB->getAttachedB();
    }

    dbgTracePop();
    return (TRUE);
}

//****************************************************************************

// CTexture::evict
//
// evict a texture from video or AGP memory into system memory
// returns TRUE on success, FALSE on failure

BOOL CTexture::evict (void)
{
    CComplexSurface<TOTAL_TEX_RENAME> newSurfSwizzled;

    dbgTracePush ("CTexture::evict");

    // make sure this is a base texture
    nvAssert (isBaseTexture());

    if (isEvicted()) {
        // texture is already evicted. this shouldn't really have been called
        DPF ("ack. attempt to evict texture that's already been evicted");
        dbgD3DError();
        dbgTracePop();
        return (TRUE);
    }

    // if the texture is in use, it can't be evicted
    if (getSwizzled()->isBusy()) {
        dbgTracePop();
        return (FALSE);
    }

    // determine the size of the texture
    DWORD dwSize;
    if (isCubeMap()) {
        dwSize = 6 * m_dwCubeMapSizeFacePadded;
    }
    else {
        dwSize = getBPP() * calcMipMapSize (m_dwLogWidth, m_dwLogHeight, m_dwLogDepth, m_dwMipMapCount);
    }

    // alternately, i think this should work...
    DWORD dwSize2 = m_surfSwizzled.getActiveSurface()->getPitch() * m_surfSwizzled.getActiveSurface()->getHeight();
    nvAssert (dwSize == dwSize2);

    // allocate a new surface in system memory
    if (!newSurfSwizzled.create (m_surfLinear.getWrapper(), dwSize, CSimpleSurface::HEAP_SYS, CSimpleSurface::HEAP_SYS
#ifdef CAPTURE
                                ,CAPTURE_SURFACE_KIND_TEXTURE
#endif
                                 ))
    {
        DPF ("CTexture::evict: failed to alloc system memory surface");
        dbgD3DError();
        dbgTracePop();
        return (FALSE);
    }

    // copy texture data to the new surface
    nvMemCopy (newSurfSwizzled.getActiveSurface()->getAddress(), m_surfSwizzled.getActiveSurface()->getAddress(), dwSize);

    // swap the new into the old, and destroy the new, which is now the old  :)
    m_surfSwizzled.swap (&newSurfSwizzled);
    newSurfSwizzled.destroy();

    // re-fresh HW control words (heap may have changed)
#if (NVARCH >= 0x010)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {
        calculateNV056ControlWords();
    }
#endif  // NVARCH >= 0x010

    // run down the attached textures and reset their pointers into the new surface
    CNvObject *pNvObjA, *pNvObjB;
    DWORD     dwFace, dwMMLevel;

    dwFace     = DDSCAPS2_CUBEMAP_POSITIVEX;
    dwMMLevel  = 0;

    // this surface's mipmaps
    pNvObjA = m_surfLinear.getWrapper()->getAttachedA();
    while (pNvObjA) {
        dwMMLevel++;
        pNvObjA->getTexture()->create (pNvObjA, dwFace, this, dwMMLevel);
        pNvObjA = pNvObjA->getAttachedA();
    }

    // run down the cubemap faces (if any)
    pNvObjB = m_surfLinear.getWrapper()->getAttachedB();
    while (pNvObjB) {
        dwFace <<= 1;
        dwMMLevel = 0;
        pNvObjB->getTexture()->create (pNvObjB, dwFace, this, dwMMLevel);
        pNvObjA = pNvObjB->getAttachedA();
        while (pNvObjA) {
            dwMMLevel++;
            pNvObjA->getTexture()->create (pNvObjA, dwFace, this, dwMMLevel);
            pNvObjA = pNvObjA->getAttachedA();
        }
        pNvObjB = pNvObjB->getAttachedB();
    }

    dbgTracePop();
    return (TRUE);
}

#endif  // TEX_MANAGE

//****************************************************************************
// CTexture::destroy
//

BOOL CTexture::destroy
(
    void
)
{
    dbgTracePush ("CTexture[%08x]::destroy()",this);

    // valid?
    assert (this);

    // destroy surface(s)
    if (m_surfLinear.isValid())
    {
        m_surfLinear.destroy();
    }
    m_surfSwizzled.destroy();

    dbgTracePop();
    return TRUE;
}

//****************************************************************************
// CTexture::CTexture
//

CTexture::CTexture
(
    void
)
{
    dbgTracePush ("CTexture[%08x]::CTexture()",this);

    // alloc succeeded?
    assert (this);

    // init
    m_surfLinear.setWidth (0);
    m_surfLinear.setHeight (0);
    m_surfLinear.setDepth (1);
    m_surfLinear.setBPP (0);
    m_surfLinear.setBPPRequested (0);
    m_surfLinear.setFormat (0);

    m_dwFlags         = 0;
    m_pBaseTexture    = this;
    m_dwMipMapCount   = 0;
    m_dwPriority      = 0;

    m_dwNV056Control0 = 0;
    m_dwNV056Format   = 0;

#ifdef TEX_MANAGE
    m_pPrev           = NULL;
    m_pNext           = NULL;
    m_pContext        = NULL;
#endif

    dbgTracePop();
}

//****************************************************************************
// CTexture::~CTexture
//

CTexture::~CTexture
(
    void
)
{
    dbgTracePush ("CTexture[%08x]::~CTexture()",this);

    // valid?
    assert (this);

    // automatically destroy this texture
    destroy();

    // zero out (debug builds)
#ifdef DEBUG
    m_surfLinear.setWidth (0);
    m_surfLinear.setHeight (0);
    m_surfLinear.setDepth (0);
    m_surfLinear.setBPP (0);
    m_surfLinear.setBPPRequested (0);
    m_surfLinear.setFormat (0);
    m_surfLinear.setWrapper (NULL);

    m_dwFlags         = 0;
    m_pBaseTexture    = NULL;
    m_dwMipMapCount   = 0;
    m_dwPriority      = 0;

    m_dwNV056Control0 = 0;
    m_dwNV056Format   = 0;

#ifdef TEX_MANAGE
    m_pPrev           = (CTexture *) 0xCCCCCCCC;
    m_pNext           = (CTexture *) 0xCCCCCCCC;
    m_pContext        = (PNVD3DCONTEXT) 0xCCCCCCCC;
#endif

    m_dwCubeMapSizeFacePadded    = 0;
    // m_pCubeMap        = NULL;
#endif

    dbgTracePop();
}

//****************************************************************************
//****************************************************************************
//****************************************************************************
//**  exports  ***************************************************************
//****************************************************************************
//****************************************************************************
//****************************************************************************
//****************************************************************************

// nvTextureCreateSurface
//
// creates a texture surface with the passed in specicifations
//
// called from only one place in CreateSurface32()

DWORD nvTextureCreateSurface
(
    LPDDRAWI_DDRAWSURFACE_LCL pDDSLcl,
    LPDDRAWI_DIRECTDRAW_GBL   pDDGbl,
    LPDDSURFACEDESC           pDDSurfDesc
)
{
    dbgTracePush ("nvTextureCreateSurface");

    assert (pDDSLcl);
    assert (pDDGbl);

    LPDDRAWI_DDRAWSURFACE_GBL pGbl = pDDSLcl->lpGbl;
    assert (pGbl);

    // init
    if (pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_RECOVERYNEEDED_D3D) {
        if (pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_COMPLETE) {
            nvD3DRecover();
        }
        else {
            dbgTracePop();
            return (DD_OK);
        }
    }

    // calculate surface parameters
    DWORD dwFormat, dwWidth, dwHeight, dwDepth, dwBPPRequested, dwBPPGranted, dwPitch, dwSlicePitch, dwMultiSampleBits;
    BOOL  bFourCC;
    if (nvCalculateSurfaceParams (pDDSLcl, &dwFormat, &bFourCC, &dwWidth, &dwHeight, &dwDepth, &dwMultiSampleBits,
        &dwBPPRequested, &dwBPPGranted, /* pitch is ignored */&dwPitch, &dwSlicePitch, TRUE) != DD_OK) {
        DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvCreateTextureSurface - Invalid pixel format!");
        //dbgD3DError();  -- not an err: CanCreateSurface32() doesn't do checks, so we need them here
        dbgTracePop();
        return (DDERR_INVALIDPARAMS);
    }

    // dimensions: dwLogWidth, dwLogHeight
    if (!dwWidth                     // zero?
     || !dwHeight                    // zero?
     || !dwDepth
     || (dwWidth  & (dwWidth - 1))   // power of 2?
     || (dwHeight & (dwHeight - 1))
     || (dwDepth & (dwDepth - 1))) // power of 2?
    {
        DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvCreateTextureSurface - Invalid texture size!");
        dbgTracePop();
        return (DDERR_INVALIDPARAMS);
    }

    // get log2 of width & height
    DWORD dwLogWidth  = dwWidth;
    DWORD dwLogHeight = dwHeight;
    DWORD dwLogDepth = dwDepth;
    ASM_LOG2(dwLogWidth);
    ASM_LOG2(dwLogHeight);
    ASM_LOG2(dwLogDepth);

    DWORD dwLogLimit =
        (pDDSLcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_VOLUME) ?
        pDriverData->nvD3DPerfData.dwMaxVolumeTextureSize :
        pDriverData->nvD3DPerfData.dwMaxTextureSize;

    ASM_LOG2(dwLogLimit);

    if ((dwLogWidth  > dwLogLimit) ||
        (dwLogHeight > dwLogLimit) ||
        ((pDDSLcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_VOLUME) && (dwLogDepth > dwLogDepth)))
    {
        DPF_LEVEL(NVDBG_LEVEL_ERROR, "nvCreateTextureSurface - Invalid texture size!");
        dbgD3DError();
        dbgTracePop();
        return (DDERR_INVALIDPARAMS);
    }

    // dwMipMapCount
    CTexture *pBaseTexture       = NULL; // if defined, current texture is a user mip level
    CTexture *pCubeMapParentFace = NULL; // if defined, current cube map +x face
    DWORD     dwMipMapCount      = 1;
    DWORD     dwMipMapLevel      = 0;

    // handle cube maps
    if (pDDSLcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_CUBEMAP)
    {
        // the following check is necessary to get around Microsoft's cubemap topology bug
        // for the +X face mipmaps we will actually be counting the -Z face and its mipmaps
        // this check makes sure that we don't count the -Z parent face. Since all cubemap
        // faces must have the same number of miplevels, this will work in all cases
        LPDDRAWI_DDRAWSURFACE_LCL pMipLcl = pDDSLcl;
        if ( (pMipLcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_CUBEMAP_POSITIVEX)
         && !(pMipLcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_MIPMAPSUBLEVEL))
        {
            pMipLcl = pDDSLcl->lpAttachList->lpAttached;
        }
        // count the number of mip map levels
        for (; pMipLcl->lpAttachList; pMipLcl = pMipLcl->lpAttachList->lpAttached) {
            dwMipMapCount++;
        }
        // Check if this is the base level of the first face or some subordinate level.
        if (pDDSLcl->lpAttachListFrom)
        {
            // count the number of levels back to the parent of this face
            for (pMipLcl = pDDSLcl; pMipLcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_MIPMAPSUBLEVEL; pMipLcl = pMipLcl->lpAttachListFrom->lpAttached) {
                dwMipMapLevel++;
            }
            // continue back to the parent +X face
            for (; pMipLcl->lpAttachListFrom; pMipLcl = pMipLcl->lpAttachListFrom->lpAttached);
            // get the base texture
            pBaseTexture = GET_PNVOBJ(pMipLcl)->getTexture();
        }
    }
    else
    {
        // has mipmaps?
        if (pDDSLcl->ddsCaps.dwCaps & DDSCAPS_MIPMAP)
        {
            // registry allows?
            if ((getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_USERMIPMAPENABLE_MASK) == D3D_REG_USERMIPMAPENABLE_ENABLE)
            {
                // count the number of mip levels from this texture down
                LPDDRAWI_DDRAWSURFACE_LCL pMipLcl;
                for (pMipLcl = pDDSLcl; pMipLcl->lpAttachList; pMipLcl = pMipLcl->lpAttachList->lpAttached) {
                    dwMipMapCount ++;
                }

                // Check if this is the base level or one of the mip levels.
                if (pDDSLcl->lpAttachListFrom != 0)
                {
                    // figure out what mip level this is, and also at the
                    //  same time, find the base texture
                    for (pMipLcl = pDDSLcl; pMipLcl->lpAttachListFrom; pMipLcl = pMipLcl->lpAttachListFrom->lpAttached) {
                        dwMipMapLevel ++;
                    }

                    // assign base texture
                    pBaseTexture = GET_PNVOBJ(pMipLcl)->getTexture();
                    assert (IS_VALID_PNVOBJ(pBaseTexture));
                }
            }
        }
    }

    // create the texture
    CNvObject *pNvObj   = GET_PNVOBJ (pDDSLcl);
    CTexture  *pTexture = IS_VALID_PNVOBJ(pNvObj) ? pNvObj->getTexture() : NULL;

    if (!pTexture)
    {
        // texture structure not created yet, do it now
#ifndef WINNT
        pNvObj   = new CNvObject (pDDSLcl->dwProcessId);
#else   // WINNT don't have pid
        pNvObj   = new CNvObject (0);
#endif
        pTexture = new CTexture;

        if (!pNvObj || !pTexture) {
            if (pNvObj) pNvObj->release();
            pGbl->fpVidMem = 0;
            SET_PNVOBJ (pDDSLcl, NULL);
            dbgTracePop();
            return (DDERR_OUTOFMEMORY);
        }

        // tag as part of a cube map if needed
        if (pDDSLcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_CUBEMAP) {
            pTexture->tagCubeMap();
            //we need to augment the renaming logic to allow for
            //traversing renaming in the cube map direction as well
            //as the mipmap case.
        }
        else if (pDDSLcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_VOLUME) {
            pTexture->tagVolumeMap();
            //probably shouldn't enable renaming with volumemaps because
            //n^3 size would have serious impacts on memory usage
        }
        else{
            // apply renaming policy
            if (pDriverData->nvD3DPerfData.dwPerformanceStrategy & PS_TEXTURE_RENAME) {
                pTexture->enableRenaming();
            }
        }

        // store in surface
        pNvObj->setObject (CNvObject::NVOBJ_TEXTURE, pTexture);
        SET_PNVOBJ (pDDSLcl, pNvObj);
    }

#ifdef WINNT
        if (pNvObj)
        {
            // we need this pointer to release memory when the PID differs from the one used at creation time
            pNvObj->setDDSLcl(pDDSLcl);
        }
#endif

    // tag as fourCC (will also automatically select DXT)
    if (bFourCC) {
        pTexture->setFourCC (pGbl->ddpfSurface.dwFourCC);
    }
    else {
        pTexture->setFourCC (0);
    }

    // tag as color keyed
    DWORD dwCK;
    if (nvCalculateColorKey (&dwCK, pDDSLcl, dwFormat)) {
        pTexture->tagColorKey();
        pTexture->setColorKey(dwCK);
    }

    // tag as palletized
    // What should we REALLY be checking here... this is kind of a loose
    // match should the ddraw user HAVE to export both caps or just one???
    if ((pDDSLcl->ddsCaps.dwCaps & DDSCAPS_PALETTE) ||
        (pDDSLcl->lpGbl->ddpfSurface.dwFlags & DDPF_PALETTEINDEXED8))
    {
        DPF_LEVEL(NVDBG_LEVEL_PALETTE,"Surface marked palettized: pddslcl=%08x pnvobj=%08x ptexture=%08x\n",pDDSLcl, pNvObj, pTexture);
        DPF_LEVEL(NVDBG_LEVEL_PALETTE,"                           %d x %d x %d\n", dwWidth, dwHeight, dwBPPRequested<<2);
        pTexture->tagPalettized();
    }

    // tag as managed
    if ((pDDSLcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_TEXTUREMANAGE) ||
        (pBaseTexture && pBaseTexture->isManaged()))
    {
        pTexture->tagManaged();
        DPF_LEVEL(NVDBG_LEVEL_TEXMAN,"Texture %08x marked as managed\n",pTexture);
    }

#ifdef TEX_MANAGE_TEST
    pTexture->tagManaged();
#endif

    // determine DX app version
    DWORD dwDXAppVersion = 0x0700;
    PNVD3DCONTEXT pContext = (PNVD3DCONTEXT)getDC()->dwContextListHead;
    while (pContext)
    {
        if (pContext->pDriverData == pDriverData)
        {
            dwDXAppVersion = pContext->dwDXAppVersion;
            break;
        }
        pContext = pContext->pContextNext;
    }

    // figure out which heap to allocate from
    DWORD dwAllowedHeaps, dwPreferredHeap;

    if (pTexture->isPalettized()) {
        // palettized textures can only go in video memory due to memory bandwidth limitations
        dwAllowedHeaps  =
        dwPreferredHeap = CSimpleSurface::HEAP_VID;
    }

    else if ((dwDXAppVersion < 0x0700) ||
             (pDriverData->GARTLinearBase == NULL)) {
        // original scheme - used for pre-DX7 apps and PCI cards
        // treat their request as a preference, but allow all allocations to fall back into AGP or PCI
        dwAllowedHeaps = CSimpleSurface::HEAP_VID |
                         (pDriverData->GARTLinearBase ? CSimpleSurface::HEAP_AGP : CSimpleSurface::HEAP_PCI);
        if (pDDSLcl->ddsCaps.dwCaps & DDSCAPS_NONLOCALVIDMEM) {
            dwPreferredHeap = (pDriverData->GARTLinearBase) ? CSimpleSurface::HEAP_AGP : CSimpleSurface::HEAP_PCI;
        }
        else {
            dwPreferredHeap = CSimpleSurface::HEAP_VID;
        }
    }

    else {
        // new scheme - used for AGP cards on DX7 and beyond
        // rigorously honor app's requests for particular types of memory
        nvAssert (pDriverData->GARTLinearBase);
        if (pDDSLcl->ddsCaps.dwCaps & (DDSCAPS_LOCALVIDMEM | DDSCAPS_3DDEVICE)) {
            // they've explicitly requested video
            nvAssert ((pDDSLcl->ddsCaps.dwCaps & DDSCAPS_NONLOCALVIDMEM) == 0); // these are supposed to be mutually exclusive
            dwAllowedHeaps  =
            dwPreferredHeap = CSimpleSurface::HEAP_VID;
        }
        else if (pDDSLcl->ddsCaps.dwCaps & DDSCAPS_NONLOCALVIDMEM) {
            // they've explicitly requested AGP
            nvAssert ((pDDSLcl->ddsCaps.dwCaps & DDSCAPS_LOCALVIDMEM) == 0); // these are supposed to be mutually exclusive
            dwAllowedHeaps  =
            dwPreferredHeap = CSimpleSurface::HEAP_AGP;
        }
        else {
            // they explicitly requested neither video nor AGP, so either is OK, but video is preferred
            dwAllowedHeaps  = CSimpleSurface::HEAP_VID | CSimpleSurface::HEAP_AGP;
            dwPreferredHeap = CSimpleSurface::HEAP_VID;
        }
    }

    // initially create the texture in system memory if it's managed
    // and we're using the lazy texture management strategy -- ala microsoft.
    if ((pTexture->isManaged()) &&
        (getDC()->nvD3DRegistryData.regTextureManageStrategy == D3D_REG_TEXTUREMANAGESTRATEGY_LAZY)) {
        dwAllowedHeaps  |=  CSimpleSurface::HEAP_SYS;
        dwPreferredHeap |=  CSimpleSurface::HEAP_SYS;
        dwPreferredHeap &= ~CSimpleSurface::HEAP_VID;
    }

    // create the underlying swizzled surface
    if (pBaseTexture)
    {
        // this is a mipmap level.
        // user mip levels do not own their own memory. they point to memory
        //  off of the base texture. the base texture owns the memory
        DWORD dwThisFace = pDDSLcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_CUBEMAP_ALLFACES;

        if (!pTexture->create (pNvObj, dwThisFace, pBaseTexture, dwMipMapLevel))
        {
            pNvObj->release();
            pGbl->fpVidMem = 0;
            SET_PNVOBJ (pDDSLcl, NULL);
            dbgTracePop();
            return (DDERR_OUTOFVIDEOMEMORY);
        }

        // update state
        pTexture->tagUserMipLevel();

        /*
         * For DX6 runtime we need to attach this texture to the chain steming
         * from the base texture. For DX7 it gets done upon CreateTextureEx call
         */
        if (global.dwDXRuntimeVersion < 0x0700) {
            CNvObject *pNvObjFrom;
            LPDDRAWI_DDRAWSURFACE_LCL pFromLcl;
            // Go 1 level up.
            pFromLcl = pDDSLcl->lpAttachListFrom->lpAttached;
            pNvObjFrom = GET_PNVOBJ (pFromLcl);
            assert (IS_VALID_PNVOBJ(pNvObjFrom));
            if (pDDSLcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_CUBEMAP)
                pNvObjFrom->setAttachedB (pNvObj);
            else
                pNvObjFrom->setAttachedA (pNvObj);
        }
    }
    else
    {
        // this is a base texture. it owns its own memory and also those of all
        //  possible mipmaps

#ifdef TEX_MANAGE

#ifdef TEX_MANAGE_TEST

        dwAllowedHeaps = dwPreferredHeap = CSimpleSurface::HEAP_VID;
#endif

        BOOL bCreationSuccess, bEvictionSuccess;

        bCreationSuccess = pTexture->create (pNvObj, dwWidth, dwHeight, dwDepth,
                                             dwBPPRequested, dwBPPGranted, dwMipMapCount, dwFormat,
                                             dwAllowedHeaps, dwPreferredHeap);

        if (!bCreationSuccess && pTexture->isManaged()) {

            PNVD3DCONTEXT pContext = (PNVD3DCONTEXT) getDC()->dwContextListHead;

            while (pContext && !bCreationSuccess) {

                nvTexManageResetPtr (pContext);

                do {
                    // evict something and try again
                    bEvictionSuccess = nvTexManageEvict (pContext, NV_TEXMAN_EVICTION_PROTOCOL_ANY);
                    if (bEvictionSuccess) {
                        bCreationSuccess = pTexture->create (pNvObj, dwWidth, dwHeight, dwDepth,
                                                             dwBPPRequested, dwBPPGranted, dwMipMapCount, dwFormat,
                                                             dwAllowedHeaps, dwPreferredHeap);
                    }
                } while (bEvictionSuccess && !bCreationSuccess);

                pContext = pContext->pContextNext;

            }

        }  // !bSuccess

        // if we still haven't managed to create the thing, we have a serious problem
        if (!bCreationSuccess) {
            pNvObj->release();
            pGbl->fpVidMem = 0;
            SET_PNVOBJ (pDDSLcl, NULL);
            dbgTracePop();
            return (DDERR_OUTOFVIDEOMEMORY);
        }

        if (pTexture->isManaged() && !pTexture->isEvicted()) {
            nvTexManageAddTexture ((PNVD3DCONTEXT) getDC()->dwContextListHead,
                                   pTexture, NV_TEXMAN_DEFAULT_CLASS);
        }

#else  // !TEX_MANAGE

        if (!pTexture->create (pNvObj, dwWidth, dwHeight, dwDepth,
                               dwBPPRequested, dwBPPGranted, dwMipMapCount, dwFormat,
                               dwAllowedHeaps, dwPreferredHeap))
        {
            pNvObj->release();
            pGbl->fpVidMem = 0;
            SET_PNVOBJ (pDDSLcl, NULL);
            dbgTracePop();
            return (DDERR_OUTOFVIDEOMEMORY);
        }
#endif  // !TEX_MANAGE
    }

    // update DDraw
#ifdef WINNT
    if (pTexture->getSwizzled()->getHeapLocation() == CSimpleSurface::HEAP_AGP) {
#ifdef NV_AGP
        if (pBaseTexture) { // texture is a user mip level
            // BUGBUG tidy this up with "chunk per process AGP heap manager"
            DWORD dwBaseAddress = pBaseTexture->getSwizzled()->getAddress();
            DWORD dwMipAddress  = pTexture->getSwizzled()->getAddress();
            pGbl->fpVidMem = nvAGPGetUserAddr(dwBaseAddress) + (dwMipAddress - dwBaseAddress);
        } else {
            pGbl->fpVidMem = nvAGPGetUserAddr(pTexture->getSwizzled()->getAddress());
        }
#else
        pGbl->lpVidMemHeap = ppdev->AgpHeap;
        pGbl->fpHeapOffset = pTexture->getSwizzled()->getfpVidMem() + pDriverData->GARTLinearHeapOffset;
#endif
        // set the bits to let Microsoft know we put it in AGP
        pDDSLcl->ddsCaps.dwCaps |= (DDSCAPS_VIDEOMEMORY | DDSCAPS_NONLOCALVIDMEM);
    }
    else
#endif
    {
        pGbl->fpVidMem = pTexture->getSwizzled()->getfpVidMem();
    }

    // set size if linear, else set pitch
    // the correct conditional would be: (pDDSurfDesc->dwFlags & DDSD_LINEARSIZE)
    // but MS apparently hasn't set this flag yet, even though they will do so later. nice.
    if (pTexture->isDXT()) {  // for now these are the only "linear" texture surfaces
        pGbl->dwLinearSize = pTexture->getSize();
    }
    else {
        pGbl->lPitch = pTexture->getPitch();
        pGbl->lSlicePitch = pTexture->getSlicePitch();
    }

    // telling MS that we have an AGP surface causes BLTs not to come our way. Just say nothing...

    //pDDSLcl->ddsCaps.dwCaps = pTexture->getSwizzled()->modifyDDCaps(pDDSLcl->ddsCaps.dwCaps);

    // force DXT surfaces to pre-allocate sysmem copies since WB locks them
    //  all the time. This will evade costly GlobalAlloc calls during run
    if (pTexture->isDXT()) {
        pTexture->updateLinearSurface();
    }

    // done
    dbgTracePop();
    return (DD_OK);
}

//****************************************************************************
// nvTextureDestroySurface
//

BOOL nvTextureDestroySurface
(
    LPDDHAL_DESTROYSURFACEDATA pDestorySurfaceData,
    LPDDRAWI_DDRAWSURFACE_LCL  pDDSLcl
)
{
    dbgTracePush ("nvTextureDestroySurface");

    // sanity checks
    assert (pDestorySurfaceData);
    assert (pDDSLcl);

    LPDDRAWI_DDRAWSURFACE_GBL pGbl = pDDSLcl->lpGbl;
    assert (pGbl);

    // get driver context
    nvSetDriverDataPtrFromDDGbl (pDestorySurfaceData->lpDD);

    // get the texture
    CNvObject *pNvObj   = GET_PNVOBJ (pDDSLcl);
    CTexture  *pTexture = IS_VALID_PNVOBJ(pNvObj) ? pNvObj->getTexture() : NULL;

    if (pTexture)
    {
        BOOL bDestroyTexture = TRUE;
        // make sure that we do not have this texture referenced anywhere
        PNVD3DCONTEXT pContext = (PNVD3DCONTEXT)getDC()->dwContextListHead;
        while (pContext)
        {

            if (pContext->tssState[0].dwValue[D3DTSS_TEXTUREMAP] == (DWORD)pNvObj) {
                pContext->tssState[0].dwValue[D3DTSS_TEXTUREMAP] = 0;
#if (NVARCH >= 0x010)
                pContext->hwState.dwDirtyFlags |= celsiusDirtyBitsFromTextureStageState[D3DTSS_TEXTUREMAP];
                pContext->hwState.dwDirtyFlags |= kelvinDirtyBitsFromTextureStageState[D3DTSS_TEXTUREMAP];
#endif
                // for legacy apps that use the setContextState calls (e.g. tunnel)
                pContext->dwRenderState[D3DRENDERSTATE_TEXTUREHANDLE] = 0;
            }
            if (pContext->tssState[1].dwValue[D3DTSS_TEXTUREMAP] == (DWORD)pNvObj) {
                pContext->tssState[1].dwValue[D3DTSS_TEXTUREMAP] = 0;
#if (NVARCH >= 0x010)
                pContext->hwState.dwDirtyFlags |= celsiusDirtyBitsFromTextureStageState[D3DTSS_TEXTUREMAP];
                pContext->hwState.dwDirtyFlags |= kelvinDirtyBitsFromTextureStageState[D3DTSS_TEXTUREMAP];
#endif
            }
            pContext = pContext->pContextNext;
        }
        pGbl->fpVidMem = 0;

        if (global.dwDXRuntimeVersion >= 0x0700) {
            bDestroyTexture = (pDDSLcl->dwFlags & DDRAWISURF_INVALID) ? FALSE : TRUE;
        }
        else {
            bDestroyTexture = pTexture->hasHandle();
        }

        // destroy texture object if handle is freed already (or allocated at all)
        if (bDestroyTexture)
        {
            CNvObject *pNvObj = pTexture->getWrapper();

#ifdef WINNT
            // we need this pointer to release memory when the PID differs from the one used at creation time
            pNvObj->setDDSLcl(pDDSLcl);
#endif
#ifdef TEX_MANAGE
            if (pTexture->isManaged() && pTexture->isBaseTexture() && pTexture->isResident()) {
                nvTexManageRemoveTexture (pTexture);
            }
#endif

            // clean up ddraw
            SET_PNVOBJ (pDDSLcl, NULL);
            // BUGBUG what about the object list entry?

            // object release will delete the texture object and surface memory
            pNvObj->release();
        }
    }

    else
    {
        // not our surface - punt
        NvReleaseSemaphore(pDriverData);
        dbgTracePop();
        return FALSE;
    }

    // done
    NvReleaseSemaphore(pDriverData);
    pDestorySurfaceData->ddRVal = DD_OK;
    dbgTracePop();
    return TRUE;
}

//---------------------------------------------------------------------------

// nvTextureBlt
// performs blts to and/or from a texture

DWORD nvTextureBltDX7
(
    PNVD3DCONTEXT   pContext,  // may be NULL!!
    CNvObject      *pSrcObj,   // source nv object
    CNvObject      *pDstObj,   // dest nv object
    D3DBOX         *boxSrc,      // src rect
    DWORD           dwDstX,
    DWORD           dwDstY,
    DWORD           dwDstZ,
    DWORD           dwFlags    // blt flags
)
{
    BOOL bForceTextureInvalidate = FALSE;
    dbgTracePush ("nvTextureBltDX7");

#ifdef NO_TEX_BLTS

    // done
    dbgTracePop();
    return (DD_OK);
#endif


#if defined(NV_NULL_DRIVER) || defined(NV_NULL_TEXTURE_DRIVER)
    dbgTracePop();
    return (DD_OK);
#endif //NV_NULL_DRIVER

    if ((pSrcObj == NULL) || (pDstObj == NULL)) {
        // this routine doesn't handle things without sources (like blitFX)
        // and obviously we always need a destination
        dbgTracePop();
        return (DDERR_UNSUPPORTED);
    }

    DWORD dwSrcClass = pSrcObj->getClass();
    DWORD dwDstClass = pDstObj->getClass();

    if ((dwSrcClass != CNvObject::NVOBJ_TEXTURE) && (dwSrcClass != CNvObject::NVOBJ_SIMPLESURFACE)) {
        dbgTracePop();
        return (DDERR_UNSUPPORTED);
    }
    if ((dwDstClass != CNvObject::NVOBJ_TEXTURE) && (dwDstClass != CNvObject::NVOBJ_SIMPLESURFACE)) {
        dbgTracePop();
        return (DDERR_UNSUPPORTED);
    }

    // extract useful data about the source and destination surfaces

    // src
    DWORD dwSrcAddr;
    DWORD dwSrcPitch;
    DWORD dwSrcSlicePitch;
    DWORD dwSrcBPP;
    DWORD dwSrcHeap;
    DWORD dwSrcFourCC;
    BOOL  bSrcDXT;
    DWORD dwSrcSurfaceWidth;
    DWORD dwSrcSurfaceHeight;
    DWORD dwSrcSurfaceDepth;
    DWORD dwSrcSurfaceLogWidth;
    DWORD dwSrcSurfaceLogHeight;
    DWORD dwSrcSurfaceLogDepth;

    DWORD dwSrcX0 = boxSrc->Left;
    DWORD dwSrcY0 = boxSrc->Top;
    DWORD dwSrcZ0 = boxSrc->Front;
    DWORD dwSrcX1 = boxSrc->Right;
    DWORD dwSrcY1 = boxSrc->Bottom;
    DWORD dwSrcZ1 = boxSrc->Back;

    DWORD bSrcIsVolumeMap;

    CTexture       *pSrcTexture;
    CSimpleSurface *pSrcSurface;

    if (dwSrcClass == CNvObject::NVOBJ_TEXTURE)
    {
        pSrcTexture = pSrcObj->getTexture();
        pSrcSurface = pSrcTexture->getLinear();
        bSrcIsVolumeMap = pSrcTexture->isVolumeMap();

        if (pSrcSurface->isUpToDate()) {
            dwSrcAddr  = pSrcSurface->getAddress();
            dwSrcHeap  = pSrcSurface->getHeapLocation();
        }
        else {
            dwSrcAddr  = pSrcTexture->getSwizzled()->getAddress();
            dwSrcHeap  = pSrcTexture->getSwizzled()->getHeapLocation();
        }
    }
    else  // dwClassSrc == CNvObject::FORMATTEDSURFACE
    {
        pSrcTexture = NULL;
        pSrcSurface = pSrcObj->getSimpleSurface();
        dwSrcAddr   = pSrcSurface->getAddress();
        dwSrcHeap   = pSrcSurface->getHeapLocation();
        bSrcIsVolumeMap = ((dwSrcZ1 - dwSrcZ0) != 1);
    }

    // check if source was previously auto-paletized
    if (pSrcTexture) {
        // if this is the source for a blit, we must restore the original contents
        nvAutoPaletteCheckAndRevert(pSrcTexture, FALSE);
    }

    dwSrcPitch  = pSrcSurface->getPitch();
    dwSrcSlicePitch = pSrcSurface->getSlicePitch();
    dwSrcBPP    = pSrcSurface->getBPP();
    dwSrcFourCC = pSrcSurface->getFourCC();
    bSrcDXT     = pSrcSurface->isDXT();
    dwSrcSurfaceWidth     = pSrcSurface->getWidth();
    dwSrcSurfaceHeight    = pSrcSurface->getHeight();
    dwSrcSurfaceDepth     = pSrcSurface->getDepth();
    dwSrcSurfaceLogWidth  = dwSrcSurfaceWidth;
    dwSrcSurfaceLogHeight = dwSrcSurfaceHeight;
    dwSrcSurfaceLogDepth  = dwSrcSurfaceDepth;
    ASM_LOG2(dwSrcSurfaceLogWidth);
    ASM_LOG2(dwSrcSurfaceLogHeight);
    ASM_LOG2(dwSrcSurfaceLogDepth);

    // dest
    DWORD     dwDstAddr;
    DWORD     dwDstPitch;
    DWORD     dwDstSlicePitch;
    DWORD     dwDstBPP;
    DWORD     dwDstHeap;
    DWORD     dwDstFourCC;
    BOOL      bDstDXT;
    DWORD     dwDstSurfaceWidth;
    DWORD     dwDstSurfaceHeight;
    DWORD     dwDstSurfaceDepth;
    DWORD     dwDstSurfaceLogWidth;
    DWORD     dwDstSurfaceLogHeight;
    DWORD     dwDstSurfaceLogDepth;

    DWORD     dwDstX0 = dwDstX;
    DWORD     dwDstY0 = dwDstY;
    DWORD     dwDstZ0 = dwDstZ;
    DWORD     dwDstX1 = dwDstX0 + (dwSrcX1 - dwSrcX0);
    DWORD     dwDstY1 = dwDstY0 + (dwSrcY1 - dwSrcY0);
    DWORD     dwDstZ1 = dwDstZ0 + (dwSrcZ1 - dwSrcZ0);

    DWORD     bDstIsVolumeMap;

    CTexture       *pDstTexture;
    CSimpleSurface *pDstSurface;

    if (dwDstClass == CNvObject::NVOBJ_TEXTURE)
    {
        pDstTexture = pDstObj->getTexture();
        pDstSurface = pDstTexture->getLinear();
        dwDstAddr   = pDstTexture->getSwizzled()->getAddress();
        dwDstHeap   = pDstTexture->getSwizzled()->getHeapLocation();
        bDstIsVolumeMap = pDstTexture->isVolumeMap();
    }
    else  // dwClassDst == CNvObject::FORMATTEDSURFACE
    {
        pDstTexture = NULL;
        pDstSurface = pDstObj->getSimpleSurface();
        dwDstAddr   = pDstSurface->getAddress();
        dwDstHeap   = pDstSurface->getHeapLocation();
        bDstIsVolumeMap = ((dwDstZ1 - dwDstZ0) != 1);
    }

    dwDstPitch  = pDstSurface->getPitch();
    dwDstSlicePitch = pDstSurface->getSlicePitch();
    dwDstBPP    = pDstSurface->getBPP();
    dwDstFourCC = pDstSurface->getFourCC();
    bDstDXT     = pDstSurface->isDXT();
    dwDstSurfaceWidth     = pDstSurface->getWidth();
    dwDstSurfaceHeight    = pDstSurface->getHeight();
    dwDstSurfaceDepth     = pDstSurface->getDepth();
    dwDstSurfaceLogWidth  = dwDstSurfaceWidth;
    dwDstSurfaceLogHeight = dwDstSurfaceHeight;
    dwDstSurfaceLogDepth  = dwDstSurfaceDepth;
    ASM_LOG2 (dwDstSurfaceLogWidth);
    ASM_LOG2 (dwDstSurfaceLogHeight);
    ASM_LOG2 (dwDstSurfaceLogDepth);

    // derive commonly used values from extracted data
    DWORD dwBlitWidth  = dwSrcX1 - dwSrcX0;
    DWORD dwBlitHeight = dwSrcY1 - dwSrcY0;
    DWORD dwBlitDepth  = dwSrcZ1 - dwSrcZ0;

    BOOL  bFullDstSurface = FALSE;
    if (pDstSurface->isDXT())
    {
        if ((dwBlitWidth  == dwDstSurfaceWidth * 4) &&
            (dwBlitHeight == dwDstSurfaceHeight * 4) &&
            (dwBlitDepth == dwDstSurfaceDepth)) {   // Volume DXT's don't get multiplied, right?
            bFullDstSurface = TRUE;
        }
    }
    else
    {
        if ((dwBlitWidth  == dwDstSurfaceWidth) &&
            (dwBlitHeight == dwDstSurfaceHeight) &&
            (dwBlitDepth == dwDstSurfaceDepth)) {
            bFullDstSurface = TRUE;
        }
    }

    // validate parameters
    if ((dwSrcBPP != dwDstBPP)                    // bit depth must match
     || (!dwBlitHeight)                           // at least something to do
     || (!dwBlitWidth)                            // at least something to do
     || (!dwBlitDepth)                            // at least something to do
     || (!pSrcTexture && !pDstTexture)            // at least one texture involved
     || (bSrcDXT != bDstDXT)                      // we can only blit from one DXT to another
     || (bSrcDXT && (dwSrcFourCC != dwDstFourCC))) // we can only blit between similar DXTs
    {
        dbgTracePop();
        return (DDERR_UNSUPPORTED);
    }

    // this check doesn't seem to be required
/*    if ((dwSrcSurfaceWidth  != dwDstSurfaceWidth) ||
        (dwSrcSurfaceHeight != dwDstSurfaceHeight))
    {
        dbgTracePop();
        return (DDERR_NOSTRETCHHW);
    }*/

    // determine swizzledness. 4cc's are special cases handled first

    BOOL  bSrcSwizzled;
    BOOL  bDstSwizzled;
    DWORD dwSwizzledness;

    if (dwDstFourCC) {
        switch (dwDstFourCC) {
            case FOURCC_NVT0:
            case FOURCC_NVT1:
            case FOURCC_NVT2:
            case FOURCC_NVT3:
            case FOURCC_NVT4:
            case FOURCC_NVT5:
                bSrcSwizzled = TRUE;
                bDstSwizzled = TRUE;
                break;
            case FOURCC_NVS0:
            case FOURCC_NVS1:
            case FOURCC_NVS2:
            case FOURCC_NVS3:
            case FOURCC_NVS4:
            case FOURCC_NVS5:
#ifdef TEXFORMAT_CRD // --------------------------------
            case FOURCC_NVHU:
            case FOURCC_NVHS:
#else // !TEXFORMAT_CRD  --------------------------------
#if defined(HILO_SUPPORT_DX7) || defined(HILO_SUPPORT_DX8)
            case FOURCC_NVHU:
            case FOURCC_NVHS:
#endif
#endif // !TEXFORMAT_CRD  --------------------------------
                bSrcSwizzled = FALSE;
                bDstSwizzled = TRUE;
                break;
            case D3DFMT_Q8W8V8U8:
                bSrcSwizzled = pSrcTexture ? (pSrcTexture->getLinear()->isUpToDate() ? FALSE : TRUE) : FALSE;
                bDstSwizzled = pDstTexture != NULL;
                break;
            case FOURCC_DXT1:
            case FOURCC_DXT2:
            case FOURCC_DXT3:
            case FOURCC_DXT4:
            case FOURCC_DXT5:
                bSrcSwizzled = TRUE;        // well, it's compressed, but we want to use
                bDstSwizzled = TRUE;        // swz to swz blit copy because it supports renaming
                break;
            default:
                DPF ("unhandled 4cc in texture blit");
                dbgD3DError();
                dbgTracePop();
                return (DDERR_UNSUPPORTED);
                break;
        }  // switch
    }

    else {
        bSrcSwizzled = pSrcTexture ? (pSrcTexture->getLinear()->isUpToDate() ? FALSE : TRUE) : FALSE;
        bDstSwizzled = pDstTexture != NULL;
    }

    dwSwizzledness = (bSrcSwizzled ? 0x10 : 0x00) | (bDstSwizzled ? 0x01 : 0x00);

    // determine if we can allow HW to blt the texture
    //  - must be faster
    //  - must not be 1 wide (NV5 cannot do)
    //  - must not be 2046 wide or wdire (NV5 cannot do)
    //  - source must be in a suitable location
    //  - dest must be in a suitable location
    BOOL bAllowHW = (pDriverData->nvD3DPerfData.dwPerformanceStrategy & PS_TEXTURE_USEHW)
                 && ((dwSrcHeap == CSimpleSurface::HEAP_VID)
                  || (dwSrcHeap == CSimpleSurface::HEAP_AGP)
                  || (dwSrcHeap == CSimpleSurface::HEAP_PCI))
                 && (dwDstHeap == CSimpleSurface::HEAP_VID);
    // exception - vid to vid ALWAYS use HW
    if ((dwSrcHeap == CSimpleSurface::HEAP_VID)
     && (dwDstHeap == CSimpleSurface::HEAP_VID))
    {
        bAllowHW = TRUE;
    }

    // exception - certain dimensions cannot be swizzled (although this also kills lin2lin)
    if ((dwBlitWidth  <= 1)
     || (dwBlitWidth  >= 2046)
     || (dwBlitHeight >= 2046))
    {
        bAllowHW = FALSE;
    }

    // check if this was previously auto-paletized
    if (pDstTexture) {
        nvAutoPaletteCheckAndRevert(pDstTexture, bFullDstSurface);
    }

#if 0
    // Display the source texture on the screen. (DEBUG only)
    dbgDisplayLinearTexture (lpBltData->lpDDSrcSurface,
                             lpBltData->lpDDDestSurface,
                             pDstTexture ? pDstTexture->getFormat()
                                         : pSrcTexture->getFormat());
#endif

    // we've gathered / calculated all the information we need to actually do the blits.
    // there are just a couple of cases we support. Punt on others (ddraw will magically handle!)

#ifdef CNT_TEX
    if ((dwDstHeap == CSimpleSurface::HEAP_VID) && (dwSrcHeap != CSimpleSurface::HEAP_VID)) {
        g_dwVidTexDL[g_dwFrames]++;
    } else if ((dwSrcHeap != CSimpleSurface::HEAP_VID) && (dwSrcHeap != CSimpleSurface::HEAP_AGP) && (dwDstHeap == CSimpleSurface::HEAP_AGP)) {
        g_dwAgpTexDL[g_dwFrames]++;
    }
#endif // CNT_TEX

    if (0) { // TODO  (bAllowHW) {

        // get lock on textures
        if (pSrcTexture) {
            pSrcTexture->hwLock (pContext, CSimpleSurface::LOCK_NORMAL);
        }
        if (pDstTexture) {
            pDstTexture->hwLock (pContext, CSimpleSurface::LOCK_NORMAL);
        }

        // TODO: HW blits

        // release locks on textures
        if (pSrcTexture) {
            pSrcTexture->hwUnlock();
        }
        if (pDstTexture) {
            pDstTexture->hwUnlock();
        }

    }
    else {
        switch (dwSwizzledness)
        {

            case 0x00:  // L -> L
                        #ifdef NV_PROFILE_CPULOCK
                        NVP_START (NVP_T_TEX_BLT);
                        #endif
                DDLOCKINDEX(NVSTAT_LOCK_L2L_COPY);
                if (pSrcTexture) pSrcTexture->cpuLockLin (CSimpleSurface::LOCK_NORMAL);
                if (pDstTexture) pDstTexture->cpuLockLin (CSimpleSurface::LOCK_NORMAL);
                        #ifdef NV_PROFILE_CPULOCK
                        NVP_STOP (NVP_T_TEX_BLT);
                        nvpLogTime (NVP_T_TEX_BLT,nvpTime[NVP_T_TEX_BLT]);
                        #endif

                assert (!bDstDXT); // we dont want dxt blts here

                nvSwizBlt_cpu_lin2lin (dwSrcAddr, dwSrcPitch, dwSrcX0, dwSrcY0,
                                       dwDstAddr, dwDstPitch, dwDstX0, dwDstY0,
                                       dwBlitWidth, dwBlitHeight, dwSrcBPP);

                if (pSrcTexture) pSrcTexture->cpuUnlockLin();
                if (pDstTexture) pDstTexture->cpuUnlockLin();
                break;

            case 0x01:  // L -> S
                        #ifdef NV_PROFILE_CPULOCK
                        NVP_START (NVP_T_TEX_BLT);
                        #endif
                DDLOCKINDEX(NVSTAT_LOCK_L2O_COPY);

                if (pSrcTexture)
                {
                    pSrcTexture->cpuLockLin (CSimpleSurface::LOCK_NORMAL);
                }
                else
                {
                    pSrcSurface->cpuLock (CSimpleSurface::LOCK_NORMAL);
                }
                if (pDstTexture)
                {
                    if (bFullDstSurface)
                    {
                        pDstTexture->cpuLockSwz (CSimpleSurface::LOCK_RENAME);
                        pDstTexture->getSwizzled()->tagUpToDate();
                        dwDstAddr = pDstTexture->getSwizzled()->getAddress();
                    }
                    else
                    {
                        pDstTexture->cpuLockSwz (CSimpleSurface::LOCK_NORMAL);
                    }
                }
                else
                {
                    pDstSurface->cpuLock (CSimpleSurface::LOCK_NORMAL);
                }
                        #ifdef NV_PROFILE_CPULOCK
                        NVP_STOP (NVP_T_TEX_BLT);
                        nvpLogTime (NVP_T_TEX_BLT,nvpTime[NVP_T_TEX_BLT]);
                        #endif
                nvAssert (!bDstDXT); // we dont want dxt blts here

#ifndef CAPTURE
                if (pDstTexture)
                {
#ifndef NO_TEX_SWZ
                    nvSwizBlt_lin2swz (pContext, dwSrcAddr, dwSrcPitch, dwSrcSlicePitch, dwSrcX0, dwSrcY0, dwSrcZ0,
                                       pDstTexture, dwDstAddr, dwDstX0, dwDstY0, dwDstZ0,
                                       dwDstSurfaceLogWidth, dwDstSurfaceLogHeight, dwDstSurfaceLogDepth,
                                       dwBlitWidth, dwBlitHeight, dwBlitDepth, dwSrcBPP);
                }
                else
#else
                    nvSwizBlt_cpu_lin2lin (dwSrcAddr, dwSrcPitch, dwSrcX0, dwSrcY0,
                                           dwDstAddr, dwDstPitch, dwDstX0, dwDstY0,
                                           dwBlitWidth, dwBlitHeight, dwSrcBPP);
                }
                else
#endif // No_Tex_SWZ
#endif  // CAPTURE
                {
#ifndef NO_TEX_SWZ
                    nvSwizBlt_cpu_lin2swz (dwSrcAddr, dwSrcPitch, dwSrcX0, dwSrcY0,
                                           dwDstAddr, dwDstX0, dwDstY0, dwDstSurfaceLogWidth, dwDstSurfaceLogHeight,
                                           dwBlitWidth, dwBlitHeight, dwSrcBPP);
                }
#else
                    nvSwizBlt_cpu_lin2lin (dwSrcAddr, dwSrcPitch, dwSrcX0, dwSrcY0,
                                           dwDstAddr, dwDstPitch, dwDstX0, dwDstY0,
                                           dwBlitWidth, dwBlitHeight, dwSrcBPP);
                }
#endif // No_Tex_SWZ
                // capture
#ifdef CAPTURE
                if (getDC()->nvD3DRegistryData.regCaptureEnable & D3D_REG_CAPTUREENABLE_RECORD) {
                    CAPTURE_MEMORY_WRITE memwr;
                    memwr.dwJmpCommand         = CAPTURE_JMP_COMMAND;
                    memwr.dwExtensionSignature = CAPTURE_EXT_SIGNATURE;
                    memwr.dwExtensionID        = CAPTURE_XID_MEMORY_WRITE;
                    memwr.dwCtxDMAHandle       = (pDstTexture->getSwizzled()->getHeapLocation() == CSimpleSurface::HEAP_VID)
                                               ? NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY
                                               : D3D_CONTEXT_DMA_HOST_MEMORY;
                    memwr.dwOffset             = pDstTexture->getSwizzled()->getOffset();
                    memwr.dwSize               = pDstTexture->getWidth() * pDstTexture->getHeight() * pDstTexture->getBPP();
                    captureLog (&memwr,sizeof(memwr));
                    captureLog ((void*)pDstTexture->getSwizzled()->getAddress(),memwr.dwSize);
                }
#endif

                if (pSrcTexture) pSrcTexture->cpuUnlockLin();
                if (pDstTexture)
                {
                    pDstTexture->cpuUnlockSwz();
                    pDstTexture->tagRenamedAndCopied();
                    invalidateTextureCache(pContext);
                    if (pContext)
                        pContext->bStateChange = TRUE;
                    else
                        bForceTextureInvalidate = TRUE;
                }
                break;

            case 0x10:  // S -> L
                        #ifdef NV_PROFILE_CPULOCK
                        NVP_START (NVP_T_TEX_BLT);
                        #endif
                DDLOCKINDEX(NVSTAT_LOCK_O2L_COPY);
                if (pSrcTexture) pSrcTexture->cpuLockSwz (CSimpleSurface::LOCK_NORMAL);
                if (pDstTexture) pDstTexture->cpuLockLin (CSimpleSurface::LOCK_NORMAL);
                        #ifdef NV_PROFILE_CPULOCK
                        NVP_STOP (NVP_T_TEX_BLT);
                        nvpLogTime (NVP_T_TEX_BLT,nvpTime[NVP_T_TEX_BLT]);
                        #endif

                assert (!bDstDXT); // we dont want dxt blts here
#ifndef NO_TEX_SWZ
                nvSwizBlt_cpu_swz2lin (dwSrcAddr, dwSrcX0, dwSrcY0, dwSrcSurfaceLogWidth, dwSrcSurfaceLogHeight,
                                       dwDstAddr, dwDstPitch, dwDstX0, dwDstY0,
                                       dwBlitWidth, dwBlitHeight, dwSrcBPP);
#else
                nvSwizBlt_cpu_lin2lin (dwSrcAddr, dwSrcPitch, dwSrcX0, dwSrcY0,
                                       dwDstAddr, dwDstPitch, dwDstX0, dwDstY0,
                                       dwBlitWidth, dwBlitHeight, dwSrcBPP);
#endif
                if (pSrcTexture) pSrcTexture->cpuUnlockSwz();
                if (pDstTexture) pDstTexture->cpuUnlockLin();
                break;

            case 0x11:  // S -> S
                        #ifdef NV_PROFILE_CPULOCK
                        NVP_START (NVP_T_TEX_BLT);
                        #endif
                DDLOCKINDEX(NVSTAT_LOCK_O2O_COPY);
                if (pSrcTexture) pSrcTexture->cpuLockSwz (CSimpleSurface::LOCK_NORMAL);
                if (pDstTexture)
                {
                    if (bDstDXT && bFullDstSurface)
                    {
                        // allow renaming of DXT surfaces
                        pDstTexture->cpuLockSwz (CSimpleSurface::LOCK_RENAME);
                        dwDstAddr = pDstTexture->getSwizzled()->getAddress();
                    }
                    else
                    {
                        pDstTexture->cpuLockSwz (CSimpleSurface::LOCK_NORMAL);
                    }
                }
                        #ifdef NV_PROFILE_CPULOCK
                        NVP_STOP (NVP_T_TEX_BLT);
                        nvpLogTime (NVP_T_TEX_BLT,nvpTime[NVP_T_TEX_BLT]);
                        #endif
                if (bDstDXT)
                {
                    // we assume that all dxt blts are 4 texel aligned.
                    // if not, we blt a little extra
                    nvSwizBlt_cpu_lin2lin (dwSrcAddr, dwSrcPitch, dwSrcX0 >> 2, dwSrcY0 >> 2,
                                           dwDstAddr, dwDstPitch, dwDstX0 >> 2, dwDstY0 >> 2,
                                           (dwBlitWidth + 3) >> 2, (dwBlitHeight + 3) >> 2, dwSrcBPP);
                }
                else
                {
#ifndef NO_TEX_SWZ
                    nvSwizBlt_cpu_swz2swz (dwSrcAddr, dwSrcX0, dwSrcY0, dwSrcSurfaceLogWidth, dwSrcSurfaceLogHeight,
                                           dwDstAddr, dwDstX0, dwDstY0, dwDstSurfaceLogWidth, dwDstSurfaceLogHeight,
                                           dwBlitWidth, dwBlitHeight, dwSrcBPP);
#else
                    nvSwizBlt_cpu_lin2lin (dwSrcAddr, dwSrcPitch, dwSrcX0, dwSrcY0,
                                           dwDstAddr, dwDstPitch, dwDstX0, dwDstY0,
                                           dwBlitWidth, dwBlitHeight, dwSrcBPP);
#endif
                }
                // capture
#ifdef CAPTURE
                if (getDC()->nvD3DRegistryData.regCaptureEnable & D3D_REG_CAPTUREENABLE_RECORD) {
                    CAPTURE_MEMORY_WRITE memwr;
                    memwr.dwJmpCommand         = CAPTURE_JMP_COMMAND;
                    memwr.dwExtensionSignature = CAPTURE_EXT_SIGNATURE;
                    memwr.dwExtensionID        = CAPTURE_XID_MEMORY_WRITE;
                    memwr.dwCtxDMAHandle       = (pDstTexture->getSwizzled()->getHeapLocation() == CSimpleSurface::HEAP_VID)
                                               ? NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY
                                               : D3D_CONTEXT_DMA_HOST_MEMORY;
                    memwr.dwOffset             = pDstTexture->getSwizzled()->getOffset();
                    memwr.dwSize               = pDstTexture->getWidth() * pDstTexture->getHeight() * pDstTexture->getBPP();
                    captureLog (&memwr,sizeof(memwr));
                    captureLog ((void*)pDstTexture->getSwizzled()->getAddress(),memwr.dwSize);
                }
#endif

                if (pSrcTexture) pSrcTexture->cpuUnlockSwz();
                if (pDstTexture)
                {
                    pDstTexture->cpuUnlockSwz();
                    pDstTexture->tagRenamedAndCopied();
                    invalidateTextureCache (pContext);
                    if(!pContext) bForceTextureInvalidate=TRUE;
                }
                break;

            default:
                DPF ("uh oh. unknown swizzledness");
                dbgD3DError();
                break;

        }  // switch

    }

    // update flags
    if (pDstTexture)
    {
        if (dwSwizzledness & 0x01) // dest swizzled?
        {
            pDstTexture->getLinear()->tagOutOfDate();
            pDstTexture->getSwizzled()->tagUpToDate();
        }
        else
        {
            pDstTexture->getSwizzled()->tagOutOfDate();
            pDstTexture->getLinear()->tagUpToDate();
            // if this is part of a cube map/mipmap, tag the base as dirty
            //  this will trigger a proper update of all subsurfaces before HW touches them
            if (pDstTexture->isUserMipLevel() || pDstTexture->isCubeMap())
            {
                pDstTexture->getBaseTexture()->tagSubSurfacesDirty();
            }
        }
    }

    // todo: auto mipmaps

    // force a cache invalidation on all contexts because we might have forced
    // texture renaming and we haven't informed the hardware that we have moved
    // the texture.
    if ((pDriverData->nvD3DPerfData.dwPerformanceStrategy & PS_TEXTURE_RENAME) && bForceTextureInvalidate) {
        // run through the list of contexts and invalidate them all
        PNVD3DCONTEXT pCtxt = (PNVD3DCONTEXT) getDC()->dwContextListHead;
        while (pCtxt) {
            invalidateTextureCache (pCtxt);
            pCtxt->bStateChange = TRUE;
            pCtxt = pCtxt->pContextNext;
        }
    }

    // this was a 2D operation
    pDriverData->TwoDRenderingOccurred = TRUE;

    dbgFlushType (NVDBG_FLUSH_2D);

    // Display the swizzled texture on the screen. (DEBUG only)
    if (pDstTexture)
    {
        dbgTextureDisplay (pDstTexture);
    }

    // done
    dbgTracePop();
    return (DD_OK);
}

//---------------------------------------------------------------------------

// fill a sub-rect of a swizzled texture with a color

DWORD nvTextureColorFill
(
    CNvObject *pDstObj,
    DWORD dwX0,         // corner of fill region
    DWORD dwY0,
    DWORD dwFillWidth,  // size of fill region
    DWORD dwFillHeight,
    DWORD dwColor       // fill color
)
{
    DWORD dwX, dwXInterleaved;
    DWORD dwY, dwYInterleaved;
    DWORD dwIndex;

    dbgTracePush ("nvTextureColorFill");

    CTexture *pTex = pDstObj->getTexture();
    nvAssert (pTex);

    // lock the swizzled surface since we're going to mess with it
    DDLOCKINDEX(NVSTAT_LOCK_FILL_OPT);
    pTex->cpuLockSwz (CSimpleSurface::LOCK_NORMAL);

    DWORD dwAddr  = pTex->getSwizzled()->getAddress();
    DWORD dwPitch = pTex->getPitch();
    DWORD dwBPP   = pTex->getBPP();

    DWORD dwTexWidth  = pTex->getWidth();
    DWORD dwTexHeight = pTex->getHeight();

    switch (dwBPP) {

        case 2:
            for (dwY=dwY0; dwY < dwY0+dwFillHeight; dwY++) {
                V_INTERLEAVE (dwYInterleaved, dwY, dwTexWidth, dwTexHeight);
                for (dwX = dwX0; dwX < dwX0+dwFillWidth; dwX++) {
                    U_INTERLEAVE (dwXInterleaved, dwX, dwTexWidth, dwTexHeight);
                    dwIndex = dwXInterleaved | dwYInterleaved;
                    ((WORD*)dwAddr)[dwIndex] = (WORD)dwColor;
                }
            }
            break;

        case 4:
            for (dwY=dwY0; dwY < dwY0+dwFillHeight; dwY++) {
                V_INTERLEAVE (dwYInterleaved, dwY, dwTexWidth, dwTexHeight);
                for (dwX = dwX0; dwX < dwX0+dwFillWidth; dwX++) {
                    U_INTERLEAVE (dwXInterleaved, dwX, dwTexWidth, dwTexHeight);
                    dwIndex = dwXInterleaved | dwYInterleaved;
                    ((DWORD*)dwAddr)[dwIndex] = (DWORD)dwColor;
                }
            }
            break;

        case 1:
            for (dwY=dwY0; dwY < dwY0+dwFillHeight; dwY++) {
                V_INTERLEAVE (dwYInterleaved, dwY, dwTexWidth, dwTexHeight);
                for (dwX = dwX0; dwX < dwX0+dwFillWidth; dwX++) {
                    U_INTERLEAVE (dwXInterleaved, dwX, dwTexWidth, dwTexHeight);
                    dwIndex = dwXInterleaved | dwYInterleaved;
                    ((unsigned char *)dwAddr)[dwIndex] = (unsigned char)dwColor;
                }
            }
            break;
        default:
            DPF ("unknown bit depth in nvTextureColorFill");
            dbgD3DError();
            break;

    } // switch

    // update tags
    pTex->getSwizzled()->tagUpToDate();
    pTex->getLinear()->tagOutOfDate();

    // unlock the swizzled surface
    pTex->cpuUnlockSwz();

    dbgTextureDisplay (pTex);

    dbgTracePop();
    return (DD_OK);
}

//---------------------------------------------------------------------------

DWORD nvTextureStretchBlit
(
    LPSURFINFO pSrcInfo,
    LPSURFINFO pDstInfo
)
{
    dbgTracePush ("nvTextureStretchBlit");

    nvAssert (pDstInfo->pObj);
    CTexture *pTexDst = pDstInfo->pObj->getTexture();
    nvAssert (pTexDst);

    // lock the swizzled surface since we're going to mess with it
    DDLOCKINDEX(NVSTAT_LOCK_STR_BLT);
    pTexDst->cpuLockSwz (CSimpleSurface::LOCK_NORMAL);

    DWORD dwAddrSrc = pSrcInfo->fpVidMem;
    DWORD dwAddrDst = pDstInfo->fpVidMem;

    DWORD dwPitchSrc = pSrcInfo->dwPitch;
    DWORD dwBPP = pSrcInfo->dwBytesPerPixel;

    DWORD dwWidthDst  = pTexDst->getWidth();
    DWORD dwHeightDst = pTexDst->getHeight();

    DWORD dwXDst, dwXDstInterleaved;
    DWORD dwYDst, dwYDstInterleaved;
    DWORD dwOffsetSrc, dwIndexDst;

    float fXSrc, fYSrc;

    float fdxSrc_dxDst = float(pSrcInfo->dwSubRectWidth)  / float(pDstInfo->dwSubRectWidth);
    float fdySrc_dyDst = float(pSrcInfo->dwSubRectHeight) / float(pDstInfo->dwSubRectHeight);

    switch (dwBPP) {

        case 2:

            fYSrc = float (pSrcInfo->dwSubRectY);

            for (dwYDst=pDstInfo->dwSubRectY; dwYDst < pDstInfo->dwSubRectY + pDstInfo->dwSubRectHeight; dwYDst++) {

                V_INTERLEAVE (dwYDstInterleaved, dwYDst, dwWidthDst, dwHeightDst);

                fXSrc = float (pSrcInfo->dwSubRectX);

                for (dwXDst=pDstInfo->dwSubRectX; dwXDst < pDstInfo->dwSubRectX + pDstInfo->dwSubRectWidth; dwXDst++) {

                    U_INTERLEAVE (dwXDstInterleaved, dwXDst, dwWidthDst, dwHeightDst);

                    dwIndexDst  = dwXDstInterleaved | dwYDstInterleaved;
                    dwOffsetSrc = (DWORD(fYSrc) * dwPitchSrc) + (DWORD(fXSrc) * dwBPP);

                    ((WORD*)dwAddrDst)[dwIndexDst] = *(WORD*)(dwAddrSrc + dwOffsetSrc);

                    // increment src x coord
                    fXSrc += fdxSrc_dxDst;
                }

                // increment src y coord
                fYSrc += fdySrc_dyDst;
            }

            break;

        case 4:

            fYSrc = float (pSrcInfo->dwSubRectY);

            for (dwYDst=pDstInfo->dwSubRectY; dwYDst < pDstInfo->dwSubRectY + pDstInfo->dwSubRectHeight; dwYDst++) {

                V_INTERLEAVE (dwYDstInterleaved, dwYDst, dwWidthDst, dwHeightDst);

                fXSrc = float (pSrcInfo->dwSubRectX);

                for (dwXDst=pDstInfo->dwSubRectX; dwXDst < pDstInfo->dwSubRectX + pDstInfo->dwSubRectWidth; dwXDst++) {

                    U_INTERLEAVE (dwXDstInterleaved, dwXDst, dwWidthDst, dwHeightDst);

                    dwIndexDst  = dwXDstInterleaved | dwYDstInterleaved;
                    dwOffsetSrc = (DWORD(fYSrc) * dwPitchSrc) + (DWORD(fXSrc) * dwBPP);

                    ((DWORD*)dwAddrDst)[dwIndexDst] = *(DWORD*)(dwAddrSrc + dwOffsetSrc);

                    // increment src x coord
                    fXSrc += fdxSrc_dxDst;
                }

                // increment src y coord
                fYSrc += fdySrc_dyDst;
            }

            break;

        default:
            DPF ("unknown bit depth in nvTextureStretchBlit");
            dbgD3DError();
            break;

    } // switch

    // update tags
    pTexDst->getSwizzled()->tagUpToDate();
    pTexDst->getLinear()->tagOutOfDate();

    // unlock the swizzled surface
    pTexDst->cpuUnlockSwz();

    dbgTextureDisplay (pTexDst);

    dbgTracePop();
    return (DD_OK);

}

//---------------------------------------------------------------------------

// nvTextureLock
//
// locks a texture so the user can party on the texels

DWORD nvTextureLock
(
    CTexture         *pTexture,
    LPDDHAL_LOCKDATA  lpLockData
)
{
    DWORD retVal;
    retVal = DDHAL_DRIVER_NOTHANDLED;

    dbgTracePush ("nvTextureLock");

    assert (pTexture);

    // figure out what we need to do
    BOOL  bNoLinear   = FALSE;
    BOOL  bNoSysLock  = lpLockData->dwFlags & DDLOCK_NOSYSLOCK;
    DWORD dwOldLinear = pTexture->getLinear()->getAddress();

    if (pTexture->hasAutoPalette())
    {
        lpLockData->ddRVal = DD_OK;
        return DDHAL_DRIVER_NOTHANDLED;
    }

    // swizzled NVT format textures
    if ((pTexture->getFourCC() & FOURCC_NVT_MASK) == FOURCC_NVTx)
    {
        bNoLinear = TRUE;
    }
    else  // linear format
    {
        pTexture->updateLinearSurface();
        // tag swizzled surface as not up to date (since lock impicitly modifies the linear copy)
        // but NOT if the LOCK flags indicates they don't intend to change the contents
        if(!(lpLockData->dwFlags & DDLOCK_READONLY)){
            // only mark dirty if user intends to change linear contents.
            pTexture->getSwizzled()->tagOutOfDate();

            // if this is part of a cube map/mipmap, tag the base as dirty
            //  this will trigger a proper update of all subsurfaces before HW touches them
            if (pTexture->isUserMipLevel() || pTexture->isCubeMap())
            {
                pTexture->getBaseTexture()->tagSubSurfacesDirty();
            }
        }
    }

    // now that linear surface may exist, get its heap location
    DWORD dwHeapLocation = pTexture->getLinear()->getHeapLocation();

    // setup DDRAW with surface information. Under WINNT, DirectX uses
    // the offset in fpVidMem to calculate a per process surface address.

    if (bNoLinear) // compressed or swizzled format
    {
        dwHeapLocation = pTexture->getSwizzled()->getHeapLocation();

#ifdef NV_AGP
        if( dwHeapLocation & CSimpleSurface::HEAP_AGP )
        {
            DWORD dwBaseAddress = pTexture->getBaseTexture()->getSwizzled()->getAddress();
            DWORD dwMipAddress  = pTexture->getSwizzled()->getAddress();
            lpLockData->lpSurfData = (void *)(nvAGPGetUserAddr(dwBaseAddress) + (dwMipAddress - dwBaseAddress));
        }
        else
#endif // NV_AGP
        {
            lpLockData->lpSurfData                   = (void*) pTexture->getSwizzled()->getfpVidMem();
            // we already set this in nvTextureCreateSurface
            //lpLockData->lpDDSurface->lpGbl->lPitch   = pTexture->getPitch();
        }

        lpLockData->lpDDSurface->lpGbl->fpVidMem = bNoSysLock // renaming can happen at any time - force ddraw to comply
                                                 ? 0
                                                 : (DWORD)lpLockData->lpSurfData;
    }
    else
    {
        // DX6 DDRAW BUG:
        // for reasons totally unknown to humanity the lock will return an incorrect alias to
        // the locked surface when NOSYSLOCK flag is set and lpSurfData == fpVidMem.
        // it seems that ddraw thinks that the memory did not move so the internal alias is
        // still valid. Fact of the matter is that it is wrong.
        // attempt to spoof ddraw into doing the right thing here.
        if ((global.dwDXRuntimeVersion < 0x0700) && (bNoSysLock) && (!dwOldLinear)) // 1st time created - thus we moved the surface
        {
            lpLockData->lpSurfData                   = (void*)pTexture->getLinear()->getfpVidMem();
            lpLockData->lpDDSurface->lpGbl->fpVidMem = pTexture->getSwizzled()->getfpVidMem();
            // we already set this in nvTextureCreateSurface
            //lpLockData->lpDDSurface->lpGbl->lPitch   = pTexture->getPitch();
        }
        else
        {
            lpLockData->lpSurfData                   = (void*)pTexture->getLinear()->getfpVidMem();
            lpLockData->lpDDSurface->lpGbl->fpVidMem = (DWORD)lpLockData->lpSurfData;
            // we already set this in nvTextureCreateSurface
            //lpLockData->lpDDSurface->lpGbl->lPitch   = pTexture->getPitch();
        }
    }

    // tell texture that CPU wants access
            #ifdef NV_PROFILE_CPULOCK
            NVP_START (NVP_T_TEX_LOCK);
            #endif
    DDLOCKINDEX(NVSTAT_LOCK_TEX_NORMAL);
    if (bNoLinear) pTexture->getSwizzled()->cpuLock (CSimpleSurface::LOCK_NORMAL);
              else pTexture->getLinear()->cpuLock (CSimpleSurface::LOCK_NORMAL);
            #ifdef NV_PROFILE_CPULOCK
            NVP_STOP (NVP_T_TEX_LOCK);
            nvpLogTime (NVP_T_TEX_LOCK,nvpTime[NVP_T_TEX_LOCK]);
            #endif

    // done
    lpLockData->ddRVal = DD_OK;
    dbgTracePop();

#ifdef WINNT
    /* If the user's copy of the the texture is in system memory, must handle. */
    if ((dwHeapLocation & CSimpleSurface::HEAP_ANYWHERE) && (dwHeapLocation & CSimpleSurface::HEAP_SYS)) {
        retVal = DDHAL_DRIVER_HANDLED;
    }
#endif // WINNT
    // return NOTHANDLED because for Locks the return values are reversed from what
    // would make any sense whatsoever.
    return retVal;
}

//---------------------------------------------------------------------------

// nvTextureUnlock
//
// unlocks a texture after the user partied on the texels

DWORD nvTextureUnlock
(
    CTexture           *pTexture,
    LPDDHAL_UNLOCKDATA  lpUnlockData
)
{
    dbgTracePush ("nvTextureUnlock");

    assert (pTexture);

    // unlock texture
    if (pTexture->isFourCC()
     && !pTexture->isDXT())  // swizzled format
    {
        pTexture->cpuUnlockSwz();
        // force hw fetch
        PNVD3DCONTEXT pContext = (PNVD3DCONTEXT)getDC()->dwContextListHead;
        while (pContext)
        {
            invalidateTextureCache (pContext);
            pContext = pContext->pContextNext;
        }
    }
    else
    {
        pTexture->cpuUnlockLin();
    }


    // if this texture is in use, we must set the texture stage dirty bit
    // to force invalidation of the texture cache
    CNvObject *pNvObj = pTexture->getWrapper();
    PNVD3DCONTEXT pContext = (PNVD3DCONTEXT)getDC()->dwContextListHead;
    while (pContext)
    {
        if ((pContext->tssState[0].dwValue[D3DTSS_TEXTUREMAP] == (DWORD)pNvObj) ||
            (pContext->tssState[1].dwValue[D3DTSS_TEXTUREMAP] == (DWORD)pNvObj)) {
            invalidateTextureCache (pContext);
        }
        pContext = pContext->pContextNext;
    }

    // done
    lpUnlockData->ddRVal = DD_OK;

    dbgTracePop();
    return DDHAL_DRIVER_HANDLED;
}

//---------------------------------------------------------------------------

// D3DCreateTextureContexts
//
// allocate the system memory texture context DMA

DWORD D3DCreateTextureContexts
(
    DWORD   dwHeapBase,
    DWORD   dwNewLimit
)
{
    DWORD   dwStatus;

    dbgTracePush ("D3DCreateTextureContexts");

    dwStatus = NVOS03_STATUS_ERROR_BAD_LIMIT;

    if (dwHeapBase && dwNewLimit) {
        dwStatus = NvRmAllocContextDma(pDriverData->dwRootHandle,
                                       D3D_CONTEXT_DMA_HOST_MEMORY,
                                       NV01_CONTEXT_DMA,
                                       DRF_DEF(OS03, _FLAGS, _ACCESS, _READ_ONLY) |
                                       DRF_DEF(OS03, _FLAGS, _LOCKED, _ALWAYS) |
                                       DRF_DEF(OS03, _FLAGS, _COHERENCY, _CACHED),
                                       (PVOID) dwHeapBase,
                                       dwNewLimit);
    }

    // Force both triangle states to be resent.
    pDriverData->dDrawSpareSubchannelObject = 0;
    // let ddraw know we messed with the celsius object
    pDriverData->dwMostRecentHWUser = MODULE_ID_D3D;

    DPF_LEVEL(NVDBG_LEVEL_SURFACEALLOC,"Vid Heap: Address:%08x Size:%08x\n",pDriverData->BaseAddress,pDriverData->TotalVRAM);

    dbgTracePop();
    return (dwStatus);
}

//---------------------------------------------------------------------------

// Destroy all texture DMA contexts and free all allocated system memory for shutdown.

void D3DDestroyTextureContexts
(
    GLOBALDATA *pDriverData
)
{
    dbgTracePush ("D3DDestroyTextureContexts");
    NvRmFree(pDriverData->dwRootHandle, pDriverData->dwRootHandle, D3D_CONTEXT_DMA_HOST_MEMORY);
    dbgTracePop();
}

//---------------------------------------------------------------------------

BOOL nvTextureDefaultAlloc
(
    void
)
{
    dbgTracePush ("nvTextureDefaultAlloc");

    // create the white texture
    nvAssert (getDC()->pDefaultTexture == NULL);

    getDC()->pDefaultTexture = new CTexture;

    if (!getDC()->pDefaultTexture) {
        DPF ("nvTextureDefaultAlloc - out of memory");
        dbgTracePop();
        return (FALSE);
    }

    if (!getDC()->pDefaultTexture->create (NULL, 1, 1, 1, 2, 2, 1, NV_SURFACE_FORMAT_A1R5G5B5,
                                           CSimpleSurface::HEAP_VID, CSimpleSurface::HEAP_VID)) {
        DPF ("nvTextureDefaultAlloc - out of memory");
        dbgTracePop();
        return (FALSE);
    }

    // fill with a white pixel
    *(WORD*) (getDC()->pDefaultTexture->getSwizzled()->getAddress()) = 0xffff;

    // create the texture used for user clip planes
    nvAssert (getDC()->pClipPlaneTexture == NULL);

    getDC()->pClipPlaneTexture = new CTexture;

    if (!getDC()->pClipPlaneTexture) {
        DPF ("nvTextureDefaultAlloc - out of memory");
        dbgTracePop();
        return(FALSE);
    }

    if (!getDC()->pClipPlaneTexture->create (NULL, 2, 2, 1, 2, 2, 1, NV_SURFACE_FORMAT_A1R5G5B5,
                                             CSimpleSurface::HEAP_VID, CSimpleSurface::HEAP_VID)) {
        DPF ("nvTextureDefaultAlloc - out of memory");
        dbgTracePop();
        return (FALSE);
    }

    // fill with [0 0; 0 1]
    WORD *pData = (WORD*) (getDC()->pClipPlaneTexture->getSwizzled()->getAddress());
    pData[0] = 0x0000;   pData[1] = 0x0000;
    pData[2] = 0x0000;   pData[3] = 0xffff;

    // init spare texture memory
    DWORD dwStatus;
    for (DWORD ii=0; ii<2; ii++) {
        NVHEAP_ALLOC (dwStatus, getDC()->dwSpareTextureAddr[ii], 256 + NV_TEXTURE_PAD, TYPE_TEXTURE);
        if (dwStatus) {
            DPF ("nvTextureDefaultAlloc - failed to allocate spare texture space");
            dbgTracePop();
            return (FALSE);
        }
        getDC()->dwSpareTextureOffset[ii] = ((getDC()->dwSpareTextureAddr[ii] + NV_TEXTURE_OFFSET_ALIGN) & ~NV_TEXTURE_OFFSET_ALIGN) - pDriverData->BaseAddress;
        pDriverData->DDrawVideoSurfaceCount ++;
    }

    dbgTracePop();
    return (TRUE);
}

//-------------------------------------------------------------------------

void nvTextureDefaultFree
(
    void
)
{
    dbgTracePush ("nvTextureDefaultFree");

    // release the NVIDIA logo
    if ((getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_LOGOENABLE_MASK) == D3D_REG_LOGOENABLE_ENABLE) {
        nvFreeLogo();
    }

    // release the default (white) texture
    if (getDC()->pDefaultTexture) {
        getDC()->pDefaultTexture->destroy();
        delete getDC()->pDefaultTexture;
        getDC()->pDefaultTexture = NULL;
    }

    // release the texture used for user clip planes
    if (getDC()->pClipPlaneTexture) {
        getDC()->pClipPlaneTexture->destroy();
        delete getDC()->pClipPlaneTexture;
        getDC()->pClipPlaneTexture = NULL;
    }

    // free the spare texture memory
    for (DWORD ii=0; ii<2; ii++) {
        if (getDC()->dwSpareTextureAddr[ii] != 0xffffffff) {
            NVHEAP_FREE (getDC()->dwSpareTextureAddr[ii]);
            getDC()->dwSpareTextureAddr[ii] = 0;
            getDC()->dwSpareTextureOffset[ii] = 0;
            pDriverData->DDrawVideoSurfaceCount --;
        }
    }

    dbgTracePop();
}

#endif  // NVARCH >= 0x04
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\src\nvSwiz.cpp ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nvSwiz.cpp                                                        *
*   Texture swizzling routines (some HW dependence).                        *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Ben de Waal                 10/20/98 - wrote it                     *
*       Ben de Waal                 07/07/99 - rewrote it                   *
*                                                                           *
\***************************************************************************/
#include "nvprecomp.h"

#if (NVARCH >= 0x04)

#include "x86.h"

// swizzling flags
#define NV_SWIZFLAG_SRCLINEAR       0x00000000
#define NV_SWIZFLAG_SRCSWIZZLED     0x00000001
#define NV_SWIZFLAG_DESTLINEAR      0x00000000
#define NV_SWIZFLAG_DESTSWIZZLED    0x00000002
#define NV_SWIZFLAG_PALETTIZED      0x00000004
#define NV_SWIZFLAG_ALLOWHW         0x80000000

#define NV_SWIZVAL_MAX              16

BOOL nvSwizzleBlt (DWORD     dwSrcAddr,
                   DWORD     dwSrcAlloc,
                   DWORD     dwSrcLogW,
                   DWORD     dwSrcLogH,
                   DWORD     dwSrcX0,
                   DWORD     dwSrcY0,
                   DWORD     dwSrcX1,
                   DWORD     dwSrcY1,
                   DWORD     dwSrcPitch,
                   CTexture *pSrcTexture,  /* may be NULL if no texture is involved */
                   DWORD     dwDestAddr,
                   DWORD     dwDestAlloc,
                   DWORD     dwDestLogW,
                   DWORD     dwDestLogH,
                   DWORD     dwDestX,
                   DWORD     dwDestY,
                   DWORD     dwDestPitch,
                   CTexture *pDestTexture, /* may be NULL if no texture is involved */
                   DWORD     dwBPP,
                   DWORD     dwFlags);



/*
 * constants
 */
#define L2MB        5
#define MB          (1<<L2MB)   // swizzle macroblock size

#define MB_UMASK    ((MB*MB-1) & 0x55555555)
#define MB_VMASK    ((MB*MB-1) & 0xaaaaaaaa)

/*
 * macros
 */
#define ilcData         global.dwILCData
#define ilcCount        global.dwILCCount
#define ilcMax          global.dwILCMax

#define TEXELCOPY(d,s,bpp)                            \
{                                                     \
    if ((bpp) == 2) *(WORD*)(d)  = *(WORD*)(s);       \
    else if ((bpp) == 4) *(DWORD*)(d) = *(DWORD*)(s); \
    else *(BYTE*)(d)  = *(BYTE*)(s);                  \
}

#define PREF_POLICY 0
#define NUM_LINES 2
#define movaps_r_rm8(r,rm,ofs)      __asm _emit 0x0f __asm _emit 0x28 __asm _emit (mREG(r) | (rm)) __asm _emit (ofs)
#define movaps_rm8_r(rm,ofs,r)      __asm _emit 0x0f __asm _emit 0x29 __asm _emit (mREG(r) | (rm)) __asm _emit (ofs)
#define movups_r_rm8(r,rm,ofs)      __asm _emit 0x0f __asm _emit 0x10 __asm _emit (mREG(r) | (rm)) __asm _emit (ofs)
#define movups_rm8_r(rm,ofs,r)      __asm _emit 0x0f __asm _emit 0x11 __asm _emit (mREG(r) | (rm)) __asm _emit (ofs)
#define prefetch_rm8(h,rm,ofs)      __asm _emit 0x0f __asm _emit 0x18 __asm _emit (mREG(h) | (rm)) __asm _emit (ofs)
#define _femms                      __asm _emit 0x0f __asm _emit 0x0e

// Prefetch the first couple of lines of a macro block for the Texture Blt code
// This handles 16bpp textures

__forceinline void MB_prefetch16(DWORD dwSrcBase, DWORD dwSrcPitch)
{
#ifdef PREFETCH_TESTING
    if (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_PREFETCH)
    {
        __asm
        {
            mov eax,[dwSrcBase]
    #if (NUM_LINES > 0)
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 0)
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 32)
    #endif
    #if (NUM_LINES > 1)
            add eax,[dwSrcPitch]
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 0)
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 32)
    #endif
    #if (NUM_LINES > 2)
            add eax,[dwSrcPitch]
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 0)
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 32)
    #endif
    #if (NUM_LINES > 3)
            add eax,[dwSrcPitch]
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 0)
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 32)
    #endif
    #if (NUM_LINES > 4)
            add eax,[dwSrcPitch]
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 0)
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 32)
    #endif
    #if (NUM_LINES > 5)
            add eax,[dwSrcPitch]
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 0)
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 32)
    #endif
    #if (NUM_LINES > 6)
            add eax,[dwSrcPitch]
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 0)
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 32)
    #endif
    #if (NUM_LINES > 7)
            add eax,[dwSrcPitch]
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 0)
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 32)
    #endif
        }
    }
#else
    if (pDriverData->nvD3DPerfData.dwCPUFeatureSet & (FS_WILLAMETTE | FS_ATHLON))
    {
        __asm
        {
            mov eax,[dwSrcBase]
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 0)
            add eax,[dwSrcPitch]
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 0)
            add eax,[dwSrcPitch]
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 0)
        }
    }
    else if (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_KATMAI)
    {
        __asm
        {
            mov eax,[dwSrcBase]
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 0)
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 32)
            add eax,[dwSrcPitch]
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 0)
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 32)
        }

    }


#endif

}

// Prefetch the first couple of lines of a macro block for the Texture Blt code
// This handles 32bpp textures

__forceinline void MB_prefetch32(DWORD dwSrcBase, DWORD dwSrcPitch)
{
#ifdef PREFETCH_TESTING
    if (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_PREFETCH)
    {
        __asm
        {
            mov eax,[dwSrcBase]
    #if (NUM_LINES > 0)
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 0)
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 32)
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 64)
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 96)
    #endif
    #if (NUM_LINES > 1)
            add eax,[dwSrcPitch]
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 0)
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 32)
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 64)
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 96)
    #endif
    #if (NUM_LINES > 2)
            add eax,[dwSrcPitch]
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 0)
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 32)
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 64)
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 96)
    #endif
    #if (NUM_LINES > 3)
            add eax,[dwSrcPitch]
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 0)
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 32)
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 64)
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 96)
    #endif
    #if (NUM_LINES > 4)
            add eax,[dwSrcPitch]
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 0)
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 32)
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 64)
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 96)
    #endif
    #if (NUM_LINES > 5)
            add eax,[dwSrcPitch]
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 0)
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 32)
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 64)
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 96)
    #endif
    #if (NUM_LINES > 6)
            add eax,[dwSrcPitch]
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 0)
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 32)
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 64)
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 96)
    #endif
    #if (NUM_LINES > 7)
            add eax,[dwSrcPitch]
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 0)
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 32)
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 64)
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 96)
    #endif
    #if (NUM_LINES > 8)
            add eax,[dwSrcPitch]
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 0)
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 32)
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 64)
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 96)
    #endif
        }
    }
#else
    if (pDriverData->nvD3DPerfData.dwCPUFeatureSet & (FS_WILLAMETTE | FS_ATHLON))
    {
        __asm
        {
            mov eax,[dwSrcBase]
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 0)
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 64)
            add eax,[dwSrcPitch]
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 0)
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 64)
            add eax,[dwSrcPitch]
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 0)
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 64)
        }
    }
    else if (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_KATMAI)
    {
        __asm
        {
            mov eax,[dwSrcBase]
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 0)
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 32)
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 64)
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 96)
            add eax,[dwSrcPitch]
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 0)
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 32)
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 64)
            prefetch_rm8 (PREF_POLICY,rmIND8(rEAX), 96)
        }
    }
#endif
}


/*
 * swizzle table buffer layout
 */
BYTE nvTexelScratchBuffer[8192];  // must be as wide as the widest pitch (4 * 2048 = 8192)

/*****************************************************************************
 * swizzle address generation
 *****************************************************************************/
struct SWIZZLE_ADDR
{
    DWORD dwBase;
    DWORD dwOffset;
    DWORD dwLine;

    DWORD dwDUDXOr;
    DWORD dwDUDXAnd;
    DWORD dwDUDXAdd;

    DWORD dwDVDYOr;
    DWORD dwDVDYAnd;
    DWORD dwDVDYAdd;
};

__inline DWORD nvSwizzleAddrGet (SWIZZLE_ADDR *lpSA)
{
    return lpSA->dwBase + lpSA->dwOffset;
}

__inline void nvSwizzleAddrNext (SWIZZLE_ADDR *lpSA)
{
    DWORD u,v;

    u              = ((lpSA->dwOffset | lpSA->dwDUDXOr) + lpSA->dwDUDXAdd) & lpSA->dwDUDXAnd;
    v              =   lpSA->dwOffset & lpSA->dwDVDYAnd;
    lpSA->dwOffset = u | v;
}

__inline void nvSwizzleAddrNewLine (SWIZZLE_ADDR *lpSA)
{
    DWORD u,v;

    u            =   lpSA->dwLine & lpSA->dwDUDXAnd;
    v            = ((lpSA->dwLine | lpSA->dwDVDYOr) + lpSA->dwDVDYAdd) & lpSA->dwDVDYAnd;
    lpSA->dwLine = lpSA->dwOffset = u | v;
}

void nvSwizzleAddrCreate
(
    SWIZZLE_ADDR *lpSA,
    DWORD         dwBase,
    DWORD         dwX,
    DWORD         dwY,
    DWORD         dwLogW,
    DWORD         dwLogH,
    DWORD         dwBPP
)
{
    if (!dwLogW)
    {
        lpSA->dwBase    = dwBase;
        lpSA->dwOffset  = lpSA->dwLine
                        = dwY * dwBPP;
        lpSA->dwDUDXAnd = 0;
        lpSA->dwDUDXOr  = 0;
        lpSA->dwDUDXAdd = 0;
        lpSA->dwDVDYAnd = ~0;
        lpSA->dwDVDYOr  = 0;
        lpSA->dwDVDYAdd = dwBPP;
    }
    else if (!dwLogH)
    {
        lpSA->dwBase    = dwBase;
        lpSA->dwOffset  = lpSA->dwLine
                        = dwX * dwBPP;
        lpSA->dwDUDXAnd = ~0;
        lpSA->dwDUDXOr  = 0;
        lpSA->dwDUDXAdd = dwBPP;
        lpSA->dwDVDYAnd = 0;
        lpSA->dwDVDYOr  = 0;
        lpSA->dwDVDYAdd = 0;
    }
    else
    {
        DWORD dwLog       = min(dwLogW,dwLogH);
        DWORD dw2Log      = dwLog << 1;            // # of bits to interleave
        DWORD dwUpperMask = ~((1 << dw2Log) - 1);  // bits to preserve
        DWORD dwLowerMask = ~dwUpperMask;          // bits to interleave

        /*
         * calc offset
         */
        DWORD dwUpperU    = (dwX << dwLog) & dwUpperMask;
        DWORD dwUpperV    = (dwY << dwLog) & dwUpperMask;

        DWORD dwLower     = ((dwX & 0x001) <<  0) | ((dwY & 0x001) <<  1)
                          | ((dwX & 0x002) <<  1) | ((dwY & 0x002) <<  2)
                          | ((dwX & 0x004) <<  2) | ((dwY & 0x004) <<  3)
                          | ((dwX & 0x008) <<  3) | ((dwY & 0x008) <<  4)
                          | ((dwX & 0x010) <<  4) | ((dwY & 0x010) <<  5)
                          | ((dwX & 0x020) <<  5) | ((dwY & 0x020) <<  6)
                          | ((dwX & 0x040) <<  6) | ((dwY & 0x040) <<  7)
                          | ((dwX & 0x080) <<  7) | ((dwY & 0x080) <<  8)
                          | ((dwX & 0x100) <<  8) | ((dwY & 0x100) <<  9)
                          | ((dwX & 0x200) <<  9) | ((dwY & 0x200) << 10)
                          | ((dwX & 0x400) << 10) | ((dwY & 0x400) << 11)
                          | ((dwX & 0x800) << 11) | ((dwY & 0x800) << 12);

        lpSA->dwBase   = dwBase;
        lpSA->dwOffset = lpSA->dwLine
                       = ((dwLower & dwLowerMask) | dwUpperU | dwUpperV) * dwBPP;

        /*
         * calc masks
         */
        lpSA->dwDUDXOr  = (0xaaaaaaaa & dwLowerMask) * dwBPP;
        lpSA->dwDUDXAnd = ((dwLogW > dwLogH) ? (0x55555555 | dwUpperMask)
                                             : (0x55555555 & dwLowerMask)) * dwBPP;
        lpSA->dwDUDXAdd = dwBPP;
        lpSA->dwDVDYOr  = (0x55555555 & dwLowerMask) * dwBPP;
        lpSA->dwDVDYAnd = ((dwLogW < dwLogH) ? (0xaaaaaaaa | dwUpperMask)
                                             : (0xaaaaaaaa & dwLowerMask)) * dwBPP;
        lpSA->dwDVDYAdd = dwBPP << 1;
    }
}

/*
 * SOFTWARE SWIZZLE
 * ----------------
 */

/*
 * nvSwizzleSmallBlock
 *
 * swizzles any texture with a dimension less than 8 (i.e. 2048 x 4)
 */
void nvSwizzleSmallBlock
(
    DWORD dwSrcBase,
    DWORD dwSrcPitch,

    DWORD dwDestBase,

    DWORD dwLogW,
    DWORD dwLogH,
    DWORD dwBPP
)
{
    SWIZZLE_ADDR sa;
    DWORD        dwCount,dwSize,dwLine;
    DWORD        dwScratch0,dwScratch1;
    DWORD        x,y;
    void        *pMemory;

    /*
     * figure out memory requirements
     */
    dwCount = 1     << (dwLogW + dwLogH);
    dwSize  = dwBPP << (dwLogW + dwLogH);
    if (dwSize > 4096)
    {
        pMemory = AllocIPM(dwSize * 2);
        dwScratch0 = (DWORD)pMemory;
        dwScratch1 = ((DWORD)pMemory) + dwSize;
    }
    else
    {
        pMemory    = NULL;
        dwScratch0 = (DWORD)(nvTexelScratchBuffer + 0);
        dwScratch1 = (DWORD)(nvTexelScratchBuffer + 4096);
    }

    /*
     * read texels
     */
    dwLine = dwBPP << dwLogW;
    if (dwLine != dwSrcPitch)
    {
        DWORD u = dwSrcBase;
        DWORD v = dwScratch0;
        for (y = (1 << dwLogH); y; y--)
        {
            nvMemCopy (v,u,dwLine);
            v += dwLine;
            u += dwSrcPitch;
        }
    }
    else
    {
        nvMemCopy (dwScratch0,dwSrcBase,dwLine << dwLogH);
    }

    /*
     * prepare swizzle address generation
     */
    nvSwizzleAddrCreate (&sa,dwScratch1,0,0,dwLogW,dwLogH,dwBPP);

    /*
     * do swizzle
     */
    switch (dwBPP)
    {
        case 1:
        {
            for (y = (1 << dwLogH); y; y--)
            {
                for (x = (1 << dwLogW); x; x--)
                {
                    *(BYTE*)nvSwizzleAddrGet(&sa) = *(BYTE*)dwScratch0;

                    dwScratch0 += 1;
                    nvSwizzleAddrNext (&sa);
                }
                nvSwizzleAddrNewLine (&sa);
            }
            break;
        }
        case 2:
        {
            for (y = (1 << dwLogH); y; y--)
            {
                for (x = (1 << dwLogW); x; x--)
                {
                    *(WORD*)nvSwizzleAddrGet(&sa) = *(WORD*)dwScratch0;

                    dwScratch0 += 2;
                    nvSwizzleAddrNext (&sa);
                }
                nvSwizzleAddrNewLine (&sa);
            }
            break;
        }
        case 4:
        {
            for (y = (1 << dwLogH); y; y--)
            {
                for (x = (1 << dwLogW); x; x--)
                {
                    *(DWORD*)nvSwizzleAddrGet(&sa) = *(DWORD*)dwScratch0;

                    dwScratch0 += 4;
                    nvSwizzleAddrNext (&sa);
                }
                nvSwizzleAddrNewLine (&sa);
            }
            break;
        }
    }

    /*
     * write texels
     */
    nvMemCopy (dwDestBase,dwScratch1,dwSize);

    /*
     * free memory
     */
    if (pMemory) FreeIPM (pMemory);
}

/*
 * nvSwizzleMacroBlock_LS
 *
 * swizzles a full MBxMB block (lin -> swz)
 */
void nvSwizzleMacroBlock_LS
(
    DWORD dwSrcBase,
    DWORD dwSrcPitch,
    DWORD dwDestBase,
    DWORD dwBPP
)
{
    DWORD numLines = (pDriverData->nvD3DPerfData.dwCPUFeatureSet & (FS_WILLAMETTE | FS_ATHLON)) ? 3 : 2;

    if (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_PREFETCH)
    {
        switch (dwBPP)
        {
            case 1:
            {
                break;  //falling through to default supporrt
                        //TODO add KNI support for 8 bpp textures
            }
            case 2: // 16bpp Pentium3
            {

                {
                    DWORD src = dwSrcBase;
                    DWORD pref = src+numLines*dwSrcPitch;
                    DWORD dst = (DWORD)nvTexelScratchBuffer;
                    DWORD v = 0;
                    DWORD y;

                    for (y = MB; y; y--)
                    {
                        DWORD addr;

                        addr  = src;
                        src  += dwSrcPitch;

#define NXT1(u)  ((((u) | (MB_VMASK*2)) + 1*2) & (MB_UMASK*2))
#define NXT2(u)  NXT1(NXT1(u))
#define NXT4(u)  NXT2(NXT2(u))
#define NXT8(u)  NXT4(NXT4(u))
#define NXT16(u) NXT8(NXT8(u))
#define NXT32(u) NXT16(NXT16(u))

                        // MB assumed to be 32
                        __asm {
                            push esi
                            push edi
                            push ebx

                        // load 8 texels
                            mov eax,[addr]
                            mov ebx,[eax]
                            mov ecx,[eax + 4]
                            mov edx,[eax + 8]
                            mov edi,[eax + 12]

                            mov eax,[v]

                            mov esi,eax
                          //or esi,0
                            add esi,[dst]
                            mov [esi],ebx // 2 at a time

                            mov esi,eax
                            or  esi,NXT2(0)
                            add esi,[dst]
                            mov [esi],ecx

                            mov esi,eax
                            or  esi,NXT4(0)
                            add esi,[dst]
                            mov [esi],edx

                            mov esi,eax
                            or  esi,NXT4(NXT2(0))
                            add esi,[dst]
                            mov [esi],edi

                        // 8 more texels
                            mov eax,[addr]
                            mov ebx,[eax + 16]
                            mov ecx,[eax + 20]
                            mov edx,[eax + 24]
                            mov edi,[eax + 28]

                            mov eax,[v]

                            mov esi,eax
                            or  esi,NXT8(0)
                            add esi,[dst]
                            mov [esi],ebx // 2 at a time

                            mov esi,eax
                            or  esi,NXT8(NXT2(0))
                            add esi,[dst]
                            mov [esi],ecx

                            mov esi,eax
                            or  esi,NXT8(NXT4(0))
                            add esi,[dst]
                            mov [esi],edx

                            mov esi,eax
                            or  esi,NXT8(NXT4(NXT2(0)))
                            add esi,[dst]
                            mov [esi],edi

                        // 8 more texels
                            mov eax,[addr]
                            mov ebx,[eax + 32]
                            mov ecx,[eax + 36]
                            mov edx,[eax + 40]
                            mov edi,[eax + 44]

                            mov eax,[v]

                            mov esi,eax
                            or  esi,NXT16(0)
                            add esi,[dst]
                            mov [esi],ebx // 2 at a time

                            mov esi,eax
                            or  esi,NXT16(NXT2(0))
                            add esi,[dst]
                            mov [esi],ecx

                            mov esi,eax
                            or  esi,NXT16(NXT4(0))
                            add esi,[dst]
                            mov [esi],edx

                            mov esi,eax
                            or  esi,NXT16(NXT4(NXT2(0)))
                            add esi,[dst]
                            mov [esi],edi

                        // 8 more texels
                            mov eax,[addr]
                            mov ebx,[eax + 48]
                            mov ecx,[eax + 52]
                            mov edx,[eax + 56]
                            mov edi,[eax + 60]

                            mov eax,[v]

                            mov esi,eax
                            or  esi,NXT16(NXT8(0))
                            add esi,[dst]
                            mov [esi],ebx // 2 at a time

                            mov esi,eax
                            or  esi,NXT16(NXT8(NXT2(0)))
                            add esi,[dst]
                            mov [esi],ecx

                            mov esi,eax
                            or  esi,NXT16(NXT8(NXT4(0)))
                            add esi,[dst]
                            mov [esi],edx

                            mov esi,eax
                            or  esi,NXT16(NXT8(NXT4(NXT2(0))))
                            add esi,[dst]
                            mov [esi],edi
#if (NUM_LINES > 0)
                            mov ecx,[pref]
                            prefetch_rm8 (PREF_POLICY,rmIND8(rECX), 0)
                            prefetch_rm8 (PREF_POLICY,rmIND8(rECX),32)
                            add ecx, [dwSrcPitch]
                            mov [pref], ecx
#endif

                            pop ebx
                            pop edi
                            pop esi
                        }

                        v = ((v | (MB_UMASK*2)) + 2*2) & (MB_VMASK*2);
                    }

                    nvMemCopy (dwDestBase,(DWORD)nvTexelScratchBuffer,MB*MB*2);
                }

                return;
            }

            case 4:
            {
                DWORD src = dwSrcBase;
                DWORD pref = src+numLines*dwSrcPitch;
                DWORD dst = (DWORD)nvTexelScratchBuffer;
                DWORD v = 0;
                DWORD y;

                if (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_ATHLON)
                {
                    _femms
                }
                for (y = MB; y; y--)
                {
                    DWORD u;
                    DWORD addr;

                    addr  = src;
                    src  += dwSrcPitch;

                    u = 0;
#undef NXT1
#undef NXT2
#undef NXT4
#undef NXT8
#undef NXT16
#undef NXT32
#define NXT1(u)  ((((u) | (MB_VMASK*4)) + 1*4) & (MB_UMASK*4))
#define NXT2(u)  NXT1(NXT1(u))
#define NXT4(u)  NXT2(NXT2(u))
#define NXT8(u)  NXT4(NXT4(u))
#define NXT16(u) NXT8(NXT8(u))
#define NXT32(u) NXT16(NXT16(u))
                        __asm {
                            push esi
                            push edi
                            push ebx

#if (NUM_LINES == 0)
                            mov ecx,[pref]
                            prefetch_rm8 (PREF_POLICY,rmIND8(rECX), 0)
                            prefetch_rm8 (PREF_POLICY,rmIND8(rECX),32)
                            prefetch_rm8 (PREF_POLICY,rmIND8(rECX), 64)
                            prefetch_rm8 (PREF_POLICY,rmIND8(rECX), 96)
                            add ecx, [dwSrcPitch]
                            mov [pref], ecx
#endif
                        // load 8 texels
                            mov eax,[addr]
                            movq    mm0 ,[eax]
                            movq    mm1,[eax + 8]
                            movq    mm2,[eax + 16]
                            movq    mm3,[eax + 24]

                            mov eax,[v]

                            mov esi,eax
                          //or esi,0
                            add esi,[dst]
                            movq [esi],mm0 // 2 at a time

                            mov esi,eax
                            or  esi,NXT2(0)
                            add esi,[dst]
                            movq [esi],mm1

                            mov esi,eax
                            or  esi,NXT4(0)
                            add esi,[dst]
                            movq [esi],mm2

                            mov esi,eax
                            or  esi,NXT4(NXT2(0))
                            add esi,[dst]
                            movq [esi],mm3

                        // 8 more texels
                            mov eax,[addr]
                            movq mm0,[eax + 32]
                            movq mm1,[eax + 40]
                            movq mm2,[eax + 48]
                            movq mm3,[eax + 56]

                            mov eax,[v]

                            mov esi,eax
                            or  esi,NXT8(0)
                            add esi,[dst]
                            movq [esi],mm0 // 2 at a time

                            mov esi,eax
                            or  esi,NXT8(NXT2(0))
                            add esi,[dst]
                            movq [esi],mm1

                            mov esi,eax
                            or  esi,NXT8(NXT4(0))
                            add esi,[dst]
                            movq [esi],mm2

                            mov esi,eax
                            or  esi,NXT8(NXT4(NXT2(0)))
                            add esi,[dst]
                            movq [esi],mm3


                        // 8 more texels
                            mov eax,[addr]
                            movq mm0,[eax + 64]
                            movq mm1,[eax + 72]
                            movq mm2,[eax + 80]
                            movq mm3,[eax + 88]

                            mov eax,[v]

                            mov esi,eax
                            or  esi,NXT16(0)
                            add esi,[dst]
                            movq [esi],mm0 // 2 at a time

                            mov esi,eax
                            or  esi,NXT16(NXT2(0))
                            add esi,[dst]
                            movq [esi],mm1

                            mov esi,eax
                            or  esi,NXT16(NXT4(0))
                            add esi,[dst]
                            movq [esi],mm2

                            mov esi,eax
                            or  esi,NXT16(NXT4(NXT2(0)))
                            add esi,[dst]
                            movq [esi],mm3


                            // 8 more texels
                            mov eax,[addr]
                            movq mm0,[eax + 96]
                            movq mm1,[eax + 104]
                            movq mm2,[eax + 112]
                            movq mm3,[eax + 120]

                            mov eax,[v]

                            mov esi,eax
                            or  esi,NXT16(NXT8(0))
                            add esi,[dst]
                            movq [esi],mm0 // 2 at a time

                            mov esi,eax
                            or  esi,NXT16(NXT8(NXT2(0)))
                            add esi,[dst]
                            movq [esi],mm1

                            mov esi,eax
                            or  esi,NXT16(NXT8(NXT4(0)))
                            add esi,[dst]
                            movq [esi],mm2

                            mov esi,eax
                            or  esi,NXT16(NXT8(NXT4(NXT2(0))))
                            add esi,[dst]
                            movq [esi],mm3

#if (NUM_LINES > 0)
                            mov ecx,[pref]
                            prefetch_rm8 (PREF_POLICY,rmIND8(rECX), 0)
                            prefetch_rm8 (PREF_POLICY,rmIND8(rECX),32)
                            prefetch_rm8 (PREF_POLICY,rmIND8(rECX), 64)
                            prefetch_rm8 (PREF_POLICY,rmIND8(rECX), 96)
                            add ecx, [dwSrcPitch]
                            mov [pref], ecx
#endif

                            pop ebx
                            pop edi
                            pop esi
                        }
                    v = ((v | (MB_UMASK*4)) + 2*4) & (MB_VMASK*4);
                }

                nvMemCopy (dwDestBase,(DWORD)nvTexelScratchBuffer,MB*MB*4);
                if (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_ATHLON)
                {
                    _femms
                }
                else
                __asm { emms };
                return;
            }


        }
    }

    /*
     * default code
     */
    switch (dwBPP)
    {
        case 1:
        {
            DWORD src = dwSrcBase;
            DWORD dst = (DWORD)nvTexelScratchBuffer;
            DWORD v = 0;
            DWORD y;

            for (y = MB; y; y--)
            {
                DWORD u,x;
                DWORD addr;

                addr  = src;
                src  += dwSrcPitch;

                u = 0;
                for (x = MB; x; x--)
                {
                    DWORD store = dst + (u | v) * 1;
                    *(BYTE*)store = *(BYTE*)addr;

                    addr += 1;
                    u     = ((u | (MB_VMASK*1)) + 1*1) & (MB_UMASK*1);
                }
                v = ((v | (MB_UMASK*1)) + 2*1) & (MB_VMASK*1);
            }

            nvMemCopy (dwDestBase,(DWORD)nvTexelScratchBuffer,MB*MB*1);
            break;
        }

        case 2:
        {
            DWORD src = dwSrcBase;
            DWORD dst = (DWORD)nvTexelScratchBuffer;
            DWORD v = 0;
            DWORD y;

            for (y = MB; y; y--)
            {
                DWORD u,x;
                DWORD addr;

                addr  = src;
                src  += dwSrcPitch;

                u = 0;
                for (x = MB; x; x--)
                {
                    DWORD store = dst + (u | v);
                    *(WORD*)store = *(WORD*)addr;

                    addr += 2;
                    u     = ((u | (MB_VMASK*2)) + 1*2) & (MB_UMASK*2);
                }
                v = ((v | (MB_UMASK*2)) + 2*2) & (MB_VMASK*2);
            }

            nvMemCopy (dwDestBase,(DWORD)nvTexelScratchBuffer,MB*MB*2);
            break;
        }

        case 4:
        {
            DWORD src = dwSrcBase;
            DWORD dst = (DWORD)nvTexelScratchBuffer;
            DWORD v = 0;
            DWORD y;

            for (y = MB; y; y--)
            {
                DWORD u,x;
                DWORD addr;

                addr  = src;
                src  += dwSrcPitch;

                u = 0;
                for (x = MB; x; x--)
                {
                    DWORD store = dst + (u | v);
                    *(DWORD*)store = *(DWORD*)addr;

                    addr += 4;
                    u     = ((u | (MB_VMASK*4)) + 1*4) & (MB_UMASK*4);
                }
                v = ((v | (MB_UMASK*4)) + 2*4) & (MB_VMASK*4);
            }

            nvMemCopy (dwDestBase,(DWORD)nvTexelScratchBuffer,MB*MB*4);
            break;
        }
    }
}


/*
 * nvSwizzleBlt_Lin_Swz_FullTexture
 *
 * software swizzle algorithm for full textures
 *  full texture means:
 *    source width & height == dest width & height
 *    blt rectangle is (0,0) - (w,h)
 */
void nvSwizzleBlt_Lin_Swz_FullTexture
(
    DWORD dwSrcBase,
    DWORD dwSrcPitch,

    DWORD dwDestBase,

    DWORD dwLogW,
    DWORD dwLogH,
    DWORD dwBPP
)
{
    SWIZZLE_ADDR sa;
    DWORD        dwMBPP,dwMBPP2;
    DWORD        x,y;

    dbgTracePush ("nvSwizzleBlt_Lin_Swz_FullTexture");

    /*
     * handle small cases
     */
    if ((dwLogW < L2MB) || (dwLogH < L2MB))
    {
        nvSwizzleSmallBlock (dwSrcBase,dwSrcPitch,
                             dwDestBase,
                             dwLogW,dwLogH,dwBPP);
        dbgTracePop();
        return;
    }

    /*
     * adjust width & height for macroblocks
     */
    dwLogW -= L2MB;
    dwLogH -= L2MB;
    dwMBPP  = dwBPP << L2MB;
    dwMBPP2 = dwBPP << (L2MB + L2MB);


    // Prefetch the Scratch buffer

    if (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_PREFETCH)
    {
        __asm
        {

            mov eax,offset nvTexelScratchBuffer
            mov ecx,(MB * MB * 4) / 32
    xxx32:   prefetch_rm8 (1,rmIND8(rEAX), 0)
             add eax,32
             dec ecx
            jnz xxx32
        }
    }

    /*
     * optimize for thin vertical case (swizzle bit does not work for this)
     */
    if (!dwLogW)
    {
        // Prefetch first 2 lines of the texture. nVSwizzleMacroBlock_LS prefetches 2 ahead
        if (dwBPP == 4) MB_prefetch32(dwSrcBase, dwSrcPitch);
        if (dwBPP == 2) MB_prefetch16(dwSrcBase, dwSrcPitch);

        for (y = (1 << dwLogH); y; y--)
        {
            nvSwizzleMacroBlock_LS (dwSrcBase,dwSrcPitch,
                                    dwDestBase,
                                    dwBPP);
            dwSrcBase  += dwSrcPitch << L2MB;
            dwDestBase += dwMBPP2;
        }
        dbgTracePop();
        return;
    }

    // Prefetch first 2 lines of the texture. nVSwizzleMacroBlock_LS prefetches 2 ahead
    if (dwBPP == 4) MB_prefetch32(dwSrcBase, dwSrcPitch);
    if (dwBPP == 2) MB_prefetch16(dwSrcBase, dwSrcPitch);
    /*
     * prepare swizzle address generation
     */
    nvSwizzleAddrCreate (&sa,dwDestBase,0,0,dwLogW,dwLogH,dwMBPP2);

    /*
     * do macroblock swizzle
     */
    for (y = (1 << dwLogH); y; y--)
    {
        DWORD dwSrc = dwSrcBase;

        for (x = (1 << dwLogW); x; x--)
        {
            nvSwizzleMacroBlock_LS (dwSrc,dwSrcPitch,
                                    nvSwizzleAddrGet(&sa),
                                    dwBPP);

            nvSwizzleAddrNext (&sa);
            dwSrc += dwBPP << L2MB;
        }

        nvSwizzleAddrNewLine (&sa);
        dwSrcBase += dwSrcPitch << L2MB;
    }

    dbgTracePop();
}

/*
 * nvSwizzleBlt_Lin_Lin
 *
 * simple SW bit-blt
 */
void nvSwizzleBlt_Lin_Lin
(
    DWORD dwSrcAddr,
    DWORD dwSrcPitch,

    DWORD dwDestAddr,
    DWORD dwDestPitch,

    DWORD dwWidth,
    DWORD dwHeight,
    DWORD dwSubHeight,
    DWORD dwBPP
)
{
    DWORD dwBytes = dwWidth * dwBPP;
    DWORD y;

    dbgTracePush ("nvSwizzleBlt_Lin_Lin");

    for (y = dwHeight; y;)
    {
        DWORD a;
        DWORD h;
        DWORD f = min(dwSubHeight,y);

        /*
         * read linear
         */
        a = (DWORD)&nvTexelScratchBuffer;
        for (h = f; h; h--)
        {
            nvMemCopy (a,dwSrcAddr,dwBytes);
            dwSrcAddr += dwSrcPitch;
            a         += dwBytes;
        }

        /*
         * write linear
         */
        a = (DWORD)&nvTexelScratchBuffer;
        for (h = f; h; h--)
        {
            nvMemCopy (dwDestAddr,a,dwBytes);
            a          += dwBytes;
            dwDestAddr += dwDestPitch;
        }

        y -= f;
    }

    dbgTracePop();
}

/*
 * nvSwizzleBlt_Swz_Lin
 *
 * deswizzle anything
 */
void nvSwizzleBlt_Swz_Lin
(
    SWIZZLE_ADDR *lpSA,

    DWORD         dwDestAddr,
    DWORD         dwDestPitch,

    DWORD         dwWidth,
    DWORD         dwHeight,
    DWORD         dwSubHeight,
    DWORD         dwBPP
)
{
    DWORD dwBytes = dwWidth * dwBPP;
    DWORD y;

    dbgTracePush ("nvSwizzleBlt_Swz_Lin");

    for (y = dwHeight; y;)
    {
        DWORD a;
        DWORD h;
        DWORD f = min(dwSubHeight,y);

        /*
         * read swizzle
         */
        a = (DWORD)&nvTexelScratchBuffer;

        for (h = f; h; h--)
        {
            DWORD x;

            for (x = dwWidth; x; x--)
            {
                TEXELCOPY (a,nvSwizzleAddrGet(lpSA),dwBPP);
                a += dwBPP;
                nvSwizzleAddrNext (lpSA);
            }

            nvSwizzleAddrNewLine (lpSA);
        }

        /*
         * write linear
         */
        a = (DWORD)&nvTexelScratchBuffer;
        for (h = f; h; h--)
        {
            nvMemCopy (dwDestAddr,a,dwBytes);
            a          += dwBytes;
            dwDestAddr += dwDestPitch;
        }

        y -= f;
    }

    dbgTracePop();
}

/*
 * nvSwizzleBlt_Lin_Swz
 *
 * swizzles anything
 */
void nvSwizzleBlt_Lin_Swz
(
    DWORD         dwSrcAddr,
    DWORD         dwSrcPitch,

    SWIZZLE_ADDR *lpSA,

    DWORD         dwWidth,
    DWORD         dwHeight,
    DWORD         dwSubHeight,
    DWORD         dwBPP
)
{
    DWORD dwBytes   = dwWidth * dwBPP;
    DWORD y;

    dbgTracePush ("nvSwizzleBlt_Lin_Swz");

    for (y = dwHeight; y;)
    {
        DWORD a;
        DWORD h;
        DWORD f = min(dwSubHeight,y);

        /*
         * read linear
         */
        a = (DWORD)&nvTexelScratchBuffer;
        for (h = f; h; h--)
        {
            nvMemCopy (a,dwSrcAddr,dwBytes);
            a         += dwBytes;
            dwSrcAddr += dwSrcPitch;
        }

        /*
         * write swizzle
         */
        a = (DWORD)&nvTexelScratchBuffer;
        for (h = f; h; h--)
        {
            DWORD x;

            for (x = dwWidth; x; x--)
            {
                TEXELCOPY (nvSwizzleAddrGet(lpSA),a,dwBPP);
                a += dwBPP;
                nvSwizzleAddrNext (lpSA);
            }
            nvSwizzleAddrNewLine (lpSA);
        }

        y -= f;
    }

    dbgTracePop();
}

/*
 * nvSwizzleBlt_Swz_Swz
 *
 * swizzle - swizzle copy, handles anything
 */
void nvSwizzleBlt_Swz_Swz
(
    SWIZZLE_ADDR *lpSASrc,

    SWIZZLE_ADDR *lpSADest,

    DWORD         dwWidth,
    DWORD         dwHeight,
    DWORD         dwSubHeight,
    DWORD         dwBPP
)
{
    DWORD dwBytes   = dwWidth * dwBPP;
    DWORD y;

    dbgTracePush ("nvSwizzleBlt_Swz_Swz");

    for (y = dwHeight; y;)
    {
        DWORD a;
        DWORD h;
        DWORD f = min(dwSubHeight,y);

        /*
         * read swizzle
         */
        a = (DWORD)&nvTexelScratchBuffer;
        for (h = f; h; h--)
        {
            DWORD x;

            for (x = dwWidth; x; x--)
            {
                TEXELCOPY (a,nvSwizzleAddrGet(lpSASrc),dwBPP);
                a += dwBPP;
                nvSwizzleAddrNext (lpSASrc);
            }
            nvSwizzleAddrNewLine (lpSASrc);
        }

        /*
         * write swizzle
         */
        a = (DWORD)&nvTexelScratchBuffer;
        for (h = f; h; h--)
        {
            DWORD x;

            for (x = dwWidth; x; x--)
            {
                TEXELCOPY (nvSwizzleAddrGet(lpSADest),a,dwBPP);
                a += dwBPP;
                nvSwizzleAddrNext (lpSADest);
            }
            nvSwizzleAddrNewLine (lpSADest);
        }

        y -= f;
    }

    dbgTracePop();
}

/*****************************************************************************
 * HARDWARE SWIZZLE
 *****************************************************************************/

/*
 * nvHWSwizzleBlt
 *
 * perform a HW swizzle blt
 */
void nvHWSwizzleBlt
(
    DWORD dwSrcOffset,
    DWORD dwSrcPitch,
    DWORD dwImageColorFormat,
    DWORD dwSrcX0,
    DWORD dwSrcY0,
    DWORD dwSrcAlloc,

    DWORD dwDstSwizzleOffset,
    DWORD dwLogWidth,
    DWORD dwLogHeight,
    DWORD dwSurfaceColorFormat,

    DWORD dwDstX0,
    DWORD dwDstY0,

    DWORD dwBlitWidth,
    DWORD dwBlitHeight
)
{
    dbgTracePush ("nvHWSwizzleBlt");

    // target surface
    nvglSetObject          (NV_DD_SPARE, D3D_CONTEXT_SURFACE_SWIZZLED);
    nvglSetSwizzledSurface (NV_DD_SPARE,
                            (DRF_NUM(052,_SET_FORMAT,_COLOR ,dwSurfaceColorFormat)
                            |DRF_NUM(052,_SET_FORMAT,_WIDTH ,dwLogWidth)
                            |DRF_NUM(052,_SET_FORMAT,_HEIGHT,dwLogHeight)),
                             dwDstSwizzleOffset);

    // format
    nvglSetObject               (NV_DD_SPARE, D3D_SCALED_IMAGE_FROM_MEMORY);
    nvglSetScaledImageFormat    (NV_DD_SPARE, dwImageColorFormat);

    // source memory context
    switch (dwSrcAlloc & CSimpleSurface::HEAP_LOCATION_MASK) {
        case CSimpleSurface::HEAP_AGP:
            nvglSetScaledImageContextImage (NV_DD_SPARE, D3D_CONTEXT_DMA_HOST_MEMORY);
            break;
        case CSimpleSurface::HEAP_VID:
            nvglSetScaledImageContextImage (NV_DD_SPARE, NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);
            break;
        case CSimpleSurface::HEAP_PCI:
            nvglSetScaledImageContextImage (NV_DD_SPARE, D3D_CONTEXT_DMA_HOST_MEMORY);
            break;
        default:
            DPF ("unknown context");
            dbgD3DError();
            break;
    }

    // clip
    nvglScaledImageClip          (NV_DD_SPARE, ((DWORD)dwDstX0), ((DWORD)dwDstY0), dwBlitWidth, dwBlitHeight);
    nvglScaledImageOut           (NV_DD_SPARE, ((DWORD)dwDstX0), ((DWORD)dwDstY0), dwBlitWidth, dwBlitHeight);
    nvglScaledImageDeltaDuDxDvDy (NV_DD_SPARE, (1<<20), (1<<20));

    // Need to make sure the boundary is big enough to work around an anomoly in the scaled image from
    // memory object.
    if (dwBlitWidth < NV4_SCALED_IMAGE_CUTOFF) dwBlitWidth = NV4_SCALED_IMAGE_CUTOFF;

    // even align the input width to prevent an RM exception
    nvglScaledImageInSize   (NV_DD_SPARE, (dwSrcX0 + dwBlitWidth + 1) & ~1, dwSrcY0 + dwBlitHeight);
    nvglScaledImageInFormat (NV_DD_SPARE,
                             (DRF_NUM(077,_IMAGE_IN_FORMAT,_PITCH,        dwSrcPitch)
                             |DRF_DEF(077,_IMAGE_IN_FORMAT,_ORIGIN,       _CORNER)
                             |DRF_DEF(077,_IMAGE_IN_FORMAT,_INTERPOLATOR, _ZOH)));
    nvglScaledImageInOffset (NV_DD_SPARE, dwSrcOffset);
    nvglScaledImageInPoint  (NV_DD_SPARE, dwSrcX0 << 4, dwSrcY0 << 4);

    pDriverData->dDrawSpareSubchannelObject   = D3D_SCALED_IMAGE_FROM_MEMORY;
#if (NVARCH >= 0x010)
    getDC()->dwOutOfContextCelsiusDirtyFlags |= CELSIUS_DIRTY_SURFACE; // this logic kills celcius surface state somehow.
#endif  // NVARCH >= 0x010

    dbgTracePop();
}

/*
  BUGBUG
  new swizzle entry points sit on top of old logic.
  will rewrite / integrate later.
*/

/*****************************************************************************
 * nvSwizBlt_cpu_lin2lin
 *
 * CPU swizzle blt from linear to linear
 */

void nvSwizBlt_cpu_lin2lin
(
    DWORD dwSrcAddr,
    DWORD dwSrcPitch,
    DWORD dwSrcX,
    DWORD dwSrcY,
    DWORD dwDstAddr,
    DWORD dwDstPitch,
    DWORD dwDstX,
    DWORD dwDstY,
    DWORD dwWidth,
    DWORD dwHeight,
    DWORD dwBPP
)
{
    dbgTracePush ("nvSwizBlt_cpu_lin2lin");

    DWORD        dwSubHeight = 2048 / (dwWidth * dwBPP);
    if (!dwSubHeight) dwSubHeight = 1;
                 else dwSubHeight = min(dwSubHeight,dwHeight);

    nvSwizzleBlt_Lin_Lin (dwSrcAddr + dwSrcY * dwSrcPitch + dwSrcX * dwBPP,dwSrcPitch,
                          dwDstAddr + dwDstY * dwDstPitch + dwDstX * dwBPP,dwDstPitch,
                          dwWidth,dwHeight,dwSubHeight,dwBPP);

    dbgTracePop();
}


// Converts bits IHGFEDCBA to 00I00H00G00F00E00D00C00B00A
DWORD swizTable3D_512[] = {
    0x0000000, 0x0000001, 0x0000008, 0x0000009, 0x0000040, 0x0000041, 0x0000048, 0x0000049, 0x0000200, 0x0000201, 0x0000208, 0x0000209, 0x0000240, 0x0000241, 0x0000248, 0x0000249, 0x0001000, 0x0001001, 0x0001008, 0x0001009, 0x0001040, 0x0001041, 0x0001048, 0x0001049, 0x0001200, 0x0001201, 0x0001208, 0x0001209, 0x0001240, 0x0001241, 0x0001248, 0x0001249,
    0x0008000, 0x0008001, 0x0008008, 0x0008009, 0x0008040, 0x0008041, 0x0008048, 0x0008049, 0x0008200, 0x0008201, 0x0008208, 0x0008209, 0x0008240, 0x0008241, 0x0008248, 0x0008249, 0x0009000, 0x0009001, 0x0009008, 0x0009009, 0x0009040, 0x0009041, 0x0009048, 0x0009049, 0x0009200, 0x0009201, 0x0009208, 0x0009209, 0x0009240, 0x0009241, 0x0009248, 0x0009249,
    0x0040000, 0x0040001, 0x0040008, 0x0040009, 0x0040040, 0x0040041, 0x0040048, 0x0040049, 0x0040200, 0x0040201, 0x0040208, 0x0040209, 0x0040240, 0x0040241, 0x0040248, 0x0040249, 0x0041000, 0x0041001, 0x0041008, 0x0041009, 0x0041040, 0x0041041, 0x0041048, 0x0041049, 0x0041200, 0x0041201, 0x0041208, 0x0041209, 0x0041240, 0x0041241, 0x0041248, 0x0041249,
    0x0048000, 0x0048001, 0x0048008, 0x0048009, 0x0048040, 0x0048041, 0x0048048, 0x0048049, 0x0048200, 0x0048201, 0x0048208, 0x0048209, 0x0048240, 0x0048241, 0x0048248, 0x0048249, 0x0049000, 0x0049001, 0x0049008, 0x0049009, 0x0049040, 0x0049041, 0x0049048, 0x0049049, 0x0049200, 0x0049201, 0x0049208, 0x0049209, 0x0049240, 0x0049241, 0x0049248, 0x0049249,
    0x0200000, 0x0200001, 0x0200008, 0x0200009, 0x0200040, 0x0200041, 0x0200048, 0x0200049, 0x0200200, 0x0200201, 0x0200208, 0x0200209, 0x0200240, 0x0200241, 0x0200248, 0x0200249, 0x0201000, 0x0201001, 0x0201008, 0x0201009, 0x0201040, 0x0201041, 0x0201048, 0x0201049, 0x0201200, 0x0201201, 0x0201208, 0x0201209, 0x0201240, 0x0201241, 0x0201248, 0x0201249,
    0x0208000, 0x0208001, 0x0208008, 0x0208009, 0x0208040, 0x0208041, 0x0208048, 0x0208049, 0x0208200, 0x0208201, 0x0208208, 0x0208209, 0x0208240, 0x0208241, 0x0208248, 0x0208249, 0x0209000, 0x0209001, 0x0209008, 0x0209009, 0x0209040, 0x0209041, 0x0209048, 0x0209049, 0x0209200, 0x0209201, 0x0209208, 0x0209209, 0x0209240, 0x0209241, 0x0209248, 0x0209249,
    0x0240000, 0x0240001, 0x0240008, 0x0240009, 0x0240040, 0x0240041, 0x0240048, 0x0240049, 0x0240200, 0x0240201, 0x0240208, 0x0240209, 0x0240240, 0x0240241, 0x0240248, 0x0240249, 0x0241000, 0x0241001, 0x0241008, 0x0241009, 0x0241040, 0x0241041, 0x0241048, 0x0241049, 0x0241200, 0x0241201, 0x0241208, 0x0241209, 0x0241240, 0x0241241, 0x0241248, 0x0241249,
    0x0248000, 0x0248001, 0x0248008, 0x0248009, 0x0248040, 0x0248041, 0x0248048, 0x0248049, 0x0248200, 0x0248201, 0x0248208, 0x0248209, 0x0248240, 0x0248241, 0x0248248, 0x0248249, 0x0249000, 0x0249001, 0x0249008, 0x0249009, 0x0249040, 0x0249041, 0x0249048, 0x0249049, 0x0249200, 0x0249201, 0x0249208, 0x0249209, 0x0249240, 0x0249241, 0x0249248, 0x0249249,
    0x1000000, 0x1000001, 0x1000008, 0x1000009, 0x1000040, 0x1000041, 0x1000048, 0x1000049, 0x1000200, 0x1000201, 0x1000208, 0x1000209, 0x1000240, 0x1000241, 0x1000248, 0x1000249, 0x1001000, 0x1001001, 0x1001008, 0x1001009, 0x1001040, 0x1001041, 0x1001048, 0x1001049, 0x1001200, 0x1001201, 0x1001208, 0x1001209, 0x1001240, 0x1001241, 0x1001248, 0x1001249,
    0x1008000, 0x1008001, 0x1008008, 0x1008009, 0x1008040, 0x1008041, 0x1008048, 0x1008049, 0x1008200, 0x1008201, 0x1008208, 0x1008209, 0x1008240, 0x1008241, 0x1008248, 0x1008249, 0x1009000, 0x1009001, 0x1009008, 0x1009009, 0x1009040, 0x1009041, 0x1009048, 0x1009049, 0x1009200, 0x1009201, 0x1009208, 0x1009209, 0x1009240, 0x1009241, 0x1009248, 0x1009249,
    0x1040000, 0x1040001, 0x1040008, 0x1040009, 0x1040040, 0x1040041, 0x1040048, 0x1040049, 0x1040200, 0x1040201, 0x1040208, 0x1040209, 0x1040240, 0x1040241, 0x1040248, 0x1040249, 0x1041000, 0x1041001, 0x1041008, 0x1041009, 0x1041040, 0x1041041, 0x1041048, 0x1041049, 0x1041200, 0x1041201, 0x1041208, 0x1041209, 0x1041240, 0x1041241, 0x1041248, 0x1041249,
    0x1048000, 0x1048001, 0x1048008, 0x1048009, 0x1048040, 0x1048041, 0x1048048, 0x1048049, 0x1048200, 0x1048201, 0x1048208, 0x1048209, 0x1048240, 0x1048241, 0x1048248, 0x1048249, 0x1049000, 0x1049001, 0x1049008, 0x1049009, 0x1049040, 0x1049041, 0x1049048, 0x1049049, 0x1049200, 0x1049201, 0x1049208, 0x1049209, 0x1049240, 0x1049241, 0x1049248, 0x1049249,
    0x1200000, 0x1200001, 0x1200008, 0x1200009, 0x1200040, 0x1200041, 0x1200048, 0x1200049, 0x1200200, 0x1200201, 0x1200208, 0x1200209, 0x1200240, 0x1200241, 0x1200248, 0x1200249, 0x1201000, 0x1201001, 0x1201008, 0x1201009, 0x1201040, 0x1201041, 0x1201048, 0x1201049, 0x1201200, 0x1201201, 0x1201208, 0x1201209, 0x1201240, 0x1201241, 0x1201248, 0x1201249,
    0x1208000, 0x1208001, 0x1208008, 0x1208009, 0x1208040, 0x1208041, 0x1208048, 0x1208049, 0x1208200, 0x1208201, 0x1208208, 0x1208209, 0x1208240, 0x1208241, 0x1208248, 0x1208249, 0x1209000, 0x1209001, 0x1209008, 0x1209009, 0x1209040, 0x1209041, 0x1209048, 0x1209049, 0x1209200, 0x1209201, 0x1209208, 0x1209209, 0x1209240, 0x1209241, 0x1209248, 0x1209249,
    0x1240000, 0x1240001, 0x1240008, 0x1240009, 0x1240040, 0x1240041, 0x1240048, 0x1240049, 0x1240200, 0x1240201, 0x1240208, 0x1240209, 0x1240240, 0x1240241, 0x1240248, 0x1240249, 0x1241000, 0x1241001, 0x1241008, 0x1241009, 0x1241040, 0x1241041, 0x1241048, 0x1241049, 0x1241200, 0x1241201, 0x1241208, 0x1241209, 0x1241240, 0x1241241, 0x1241248, 0x1241249,
    0x1248000, 0x1248001, 0x1248008, 0x1248009, 0x1248040, 0x1248041, 0x1248048, 0x1248049, 0x1248200, 0x1248201, 0x1248208, 0x1248209, 0x1248240, 0x1248241, 0x1248248, 0x1248249, 0x1249000, 0x1249001, 0x1249008, 0x1249009, 0x1249040, 0x1249041, 0x1249048, 0x1249049, 0x1249200, 0x1249201, 0x1249208, 0x1249209, 0x1249240, 0x1249241, 0x1249248, 0x1249249
};

DWORD swiz3DMasks[] = { 0x0000000, 0x0000001, 0x0000009, 0x0000049, 0x0000249, 0x0001249, 0x0009249, 0x0049249, 0x0249249, 0x1249249 };



/*****************************************************************************
 * nvSwizBlt_cpu_lin2swz
 *
 * CPU swizzle blt from linear to swizzle
 */
void nvSwizBlt_cpu_lin2swz
(
    DWORD dwSrcAddr,
    DWORD dwSrcPitch,
    DWORD dwSrcX,
    DWORD dwSrcY,
    DWORD dwDstAddr,
    DWORD dwDstX,
    DWORD dwDstY,
    DWORD dwDstLogWidth,
    DWORD dwDstLogHeight,
    DWORD dwWidth,
    DWORD dwHeight,
    DWORD dwBPP
)
{
    dbgTracePush ("nvSwizBlt_cpu_lin2swz");

    /* DO NOT REMOVE
    DWORD dwSize      = dwWidth * dwBPP;
    DWORD dwDstPitch  = dwBPP << dwDstLogWidth;
    dwSrcAddr        += dwSrcY * dwSrcPitch + dwSrcX * dwBPP;
    dwDstAddr        += (dwDstY << dwDstLogWidth) + dwDstX * dwBPP;
    for (DWORD y = dwHeight; y; y--)
    {
        nvMemCopy (dwDstAddr,dwSrcAddr,dwSize);
        dwDstAddr += dwDstPitch;
        dwSrcAddr += dwSrcPitch;
    }

    return;
//*/

    BOOL bFullTexture = !dwSrcX && !dwSrcY
                     && !dwDstX && !dwDstY
                     && (dwWidth  == (1U << dwDstLogWidth))
                     && (dwHeight == (1U << dwDstLogHeight));

    if (bFullTexture)
    {
        nvSwizzleBlt_Lin_Swz_FullTexture (dwSrcAddr,dwSrcPitch,
                                          dwDstAddr,dwDstLogWidth,dwDstLogHeight,
                                          dwBPP);
/* DO NOT REMOVE
        DWORD dwSrc = dwSrcAddr;
        DWORD dwDst = VIDMEM_ADDR(pDriverData->CurrentVisibleSurfaceAddress);
        for (DWORD y = 0; y < dwHeight; y++)
        {
            nvMemCopy ((void*)dwDst,(void*)dwSrc,dwWidth * dwBPP);
            dwDst += ((DIBENGINEHDR1 *)pDXShare->pFlatDibeng)->deDeltaScan;
            dwSrc += dwSrcPitch;
        }
__asm int 3;
        dwSrc = dwDstAddr;
        dwDst = VIDMEM_ADDR(pDriverData->CurrentVisibleSurfaceAddress);
        for (y = 0; y < dwHeight; y++)
        {
            nvMemCopy ((void*)dwDst,(void*)dwSrc,dwBPP << dwDstLogWidth);
            dwDst += ((DIBENGINEHDR1 *)pDXShare->pFlatDibeng)->deDeltaScan;
            dwSrc += dwBPP << dwDstLogWidth;
        }
__asm int 3;
//*/
    }
    else
    {
        SWIZZLE_ADDR Dest;
        DWORD        dwSubHeight = 2048 / (dwWidth * dwBPP);
        if (!dwSubHeight) dwSubHeight = 1;
                     else dwSubHeight = min(dwSubHeight,dwHeight);

        nvSwizzleAddrCreate (&Dest,dwDstAddr,dwDstX,dwDstY,dwDstLogWidth,dwDstLogHeight,dwBPP);

        nvSwizzleBlt_Lin_Swz (dwSrcAddr + dwSrcY * dwSrcPitch + dwSrcX * dwBPP,dwSrcPitch,
                              &Dest,
                              dwWidth,dwHeight,dwSubHeight,dwBPP);
    }

    dbgTracePop();
}

//
// The slowest CPU volume swizzler ever...
//
void nvVolumeSwizBlt_cpu_lin2swz(
    DWORD dwSrcAddr,
    DWORD dwSrcPitch,
    DWORD dwSrcSlicePitch,
    DWORD dwSrcX,
    DWORD dwSrcY,
    DWORD dwSrcZ,
    DWORD dwDstAddr,
    DWORD dwDstX,
    DWORD dwDstY,
    DWORD dwDstZ,
    DWORD dwDstLogWidth,
    DWORD dwDstLogHeight,
    DWORD dwDstLogDepth,
    DWORD dwWidth,
    DWORD dwHeight,
    DWORD dwDepth,
    DWORD dwBPP
) {
    dbgTracePush ("nvVolumeSwizBlt_cpu_lin2swz");

    nvAssert(dwWidth <= 512);
    nvAssert(dwHeight <= 512);
    nvAssert(dwDepth <= 512);

    DWORD dwDstIndex, dwTempDstIndex, dwSrcIndex;
    DWORD i, j, k;

    DWORD dwMask = swiz3DMasks[dwDstLogWidth] | (swiz3DMasks[dwDstLogHeight] << 1) | (swiz3DMasks[dwDstLogDepth] << 2);
    DWORD dwTotalBits = dwDstLogWidth + dwDstLogHeight + dwDstLogDepth;
    DWORD dwTempMask, dwMaskIndex;

#define VOLUME_SWIZZLE_BLIT(type)                                                                               \
    for (k=0; k<dwDepth; k++) {                                                                                 \
        for (j=0; j<dwHeight; j++) {                                                                            \
            for (i=0; i<dwWidth; i++) {                                                                         \
                dwTempDstIndex  =  swizTable3D_512[i+dwDstX]       |                                            \
                                  (swizTable3D_512[j+dwDstY] << 1) |                                            \
                                  (swizTable3D_512[k+dwDstZ] << 2);                                             \
                dwTempMask = dwMask;                                                                            \
                dwDstIndex = 0;                                                                                 \
                dwMaskIndex = 0;                                                                                \
                while (dwTempMask) {                                                                            \
                    while (!(dwTempMask & 1)) {                                                                 \
                        dwTempDstIndex >>= 1;                                                                   \
                        dwTempMask >>= 1;                                                                       \
                    }                                                                                           \
                    dwDstIndex |= dwTempDstIndex & (1 << dwMaskIndex);                                          \
                    dwTempMask >>= 1;                                                                           \
                    dwMaskIndex++;                                                                              \
                }                                                                                               \
                dwSrcIndex = (dwSrcX+i)*dwBPP + dwSrcPitch*(j+dwSrcY) + dwSrcSlicePitch*(k+dwSrcZ);             \
                ((type *)dwDstAddr)[dwDstIndex] = *(type *)&((char *)dwSrcAddr)[dwSrcIndex];                    \
            }                                                                                                   \
        }                                                                                                       \
    }

    switch (dwBPP) {
        case 1:
            VOLUME_SWIZZLE_BLIT(BYTE);
            break;
        case 2:
            VOLUME_SWIZZLE_BLIT(WORD);
            break;
        case 4:
            VOLUME_SWIZZLE_BLIT(DWORD);
            break;
        default:
            // Bad bit depth
            nvAssert(0);
    }

    dbgTracePop();
}

/*****************************************************************************
 * nvSwizBlt_lin2swz
 *
 * CPU and GPU combined swizzle blt from linear to swizzle
 *
 * KKT 3/5/01:  Called only from nvTextureBltDX7.
 */

DWORD lutFormat[5] = { ~0, NV_SURFACE_FORMAT_Y8, NV_SURFACE_FORMAT_R5G6B5, ~0, NV_SURFACE_FORMAT_A8R8G8B8 };

void nvSwizBlt_lin2swz
(
    PNVD3DCONTEXT pContext,
    DWORD         dwSrcAddr,
    DWORD         dwSrcPitch,
    DWORD         dwSrcSlicePitch,
    DWORD         dwSrcX,
    DWORD         dwSrcY,
    DWORD         dwSrcZ,
    CTexture     *pDstTexture,
    DWORD         dwDstAddr,
    DWORD         dwDstX,
    DWORD         dwDstY,
    DWORD         dwDstZ,
    DWORD         dwDstLogWidth,
    DWORD         dwDstLogHeight,
    DWORD         dwDstLogDepth,
    DWORD         dwWidth,
    DWORD         dwHeight,
    DWORD         dwDepth,
    DWORD         dwBPP
)
{
    dbgTracePush ("nvSwizBlt_lin2swz");

    BOOL bFullTexture = !dwSrcX && !dwSrcY
                     && !dwDstX && !dwDstY
                     && (dwWidth  == (1U << dwDstLogWidth))
                     && (dwHeight == (1U << dwDstLogHeight));

    // get size of texture
    DWORD dwSize = dwSrcPitch * dwHeight;

    if (dwDstLogDepth) {
        // Blitting a volume texture
        nvVolumeSwizBlt_cpu_lin2swz(dwSrcAddr, dwSrcPitch, dwSrcSlicePitch,
                                    dwSrcX, dwSrcY, dwSrcZ,
                                    dwDstAddr, dwDstX, dwDstY, dwDstZ,
                                    dwDstLogWidth, dwDstLogHeight, dwDstLogDepth, dwWidth,
                                    dwHeight, dwDepth, dwBPP);
        dbgTracePop();
        return;
    }

    if ((pDriverData->nvD3DPerfData.dwPerformanceStrategy & PS_TEXTURE_USEHW)       // hw allowed blts enabled
     && ((CURRENT_FLIP - COMPLETED_FLIP) < 1)                                       // hw sufficiently idle
     && !(pDstTexture->getSwizzled()->getOffset() & 63)                             // hw can address dest
     && (pDstTexture->getSwizzled()->getHeapLocation() == CSimpleSurface::HEAP_VID) // hw can address dest
     && (dwWidth >= NV4_SCALED_IMAGE_CUTOFF) && (dwHeight >= 4)                     // anything smaller than this isn't worth bothering the hardware with
     && (dwWidth <= 2046) && (dwHeight <= 2047)                                     // dimensions small enough
     && (dwSize < getDC()->defaultVB.getSize() / 4)) {                              // enough staging space

        if (dwBPP == 1) goto cpuCopy;

        // get space
        DWORD dwVBOffset = getDC()->defaultVB.waitForSpace (dwSize + 64 * 12, TRUE);
        if (dwVBOffset == ~0) goto cpuCopy;

        // copy unswizzled texels to scratch surface
        dwVBOffset = (dwVBOffset + 64) & ~63;

                #ifdef NV_PROFILE_COPIES
                NVP_START(NVP_T_LIN2SWZ2);
                #endif
        nvMemCopy (getDC()->defaultVB.getAddress() + dwVBOffset, dwSrcAddr + dwSrcPitch * dwSrcY, dwSize);
                #ifdef NV_PROFILE_COPIES
                NVP_STOP(NVP_T_LIN2SWZ2);
                nvpLogTime (NVP_T_LIN2SWZ2,nvpTime[NVP_T_LIN2SWZ2]);
                #endif
        // capture BLT source
#ifdef CAPTURE
        if (getDC()->nvD3DRegistryData.regCaptureEnable & D3D_REG_CAPTUREENABLE_RECORD) {
            CAPTURE_MEMORY_WRITE memwr;
            memwr.dwJmpCommand         = CAPTURE_JMP_COMMAND;
            memwr.dwExtensionSignature = CAPTURE_EXT_SIGNATURE;
            memwr.dwExtensionID        = CAPTURE_XID_MEMORY_WRITE;
            memwr.dwCtxDMAHandle       = (getDC()->defaultVB.getHeap() == CSimpleSurface::HEAP_VID)
                                       ? NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY
                                       : D3D_CONTEXT_DMA_HOST_MEMORY;
            memwr.dwOffset             = getDC()->defaultVB.getOffset() + dwVBOffset;
            memwr.dwSize               = dwSize;
            captureLog (&memwr,sizeof(memwr));
            captureLog ((void*)getDC()->defaultVB.getAddress(),memwr.dwSize);
        }
#endif

        // lock the texture so that noone else can read from it until we're done writing to it
        pDstTexture->hwLock (pContext, CSimpleSurface::LOCK_NORMAL);

        // program HW to do swizzle
        nvSwizBlt_gpu_lin2swz (getDC()->defaultVB.getOffset() + dwVBOffset,
                               getDC()->defaultVB.getHeap(), dwSrcPitch /*dwBPP << dwDstLogWidth*/, dwSrcX, 0,
                               pDstTexture->getSwizzled()->getOffset(),dwDstX,dwDstY,dwDstLogWidth,dwDstLogHeight,
                               dwWidth,dwHeight,dwBPP);

        // unlock texture
        pDstTexture->hwUnlock();

        getDC()->defaultVB.updateOffset (dwVBOffset + dwSize);
        getDC()->defaultVB.updateMap();

        dbgTracePop();
        return;
    }

cpuCopy:

    if (bFullTexture)
    {
        nvSwizzleBlt_Lin_Swz_FullTexture (dwSrcAddr,dwSrcPitch,
                                          dwDstAddr,dwDstLogWidth,dwDstLogHeight,
                                          dwBPP);
    }
    else
    {
        SWIZZLE_ADDR Dest;
        DWORD        dwSubHeight = 2048 / (dwWidth * dwBPP);
        if (!dwSubHeight) dwSubHeight = 1;
                     else dwSubHeight = min(dwSubHeight,dwHeight);

        nvSwizzleAddrCreate (&Dest,dwDstAddr,dwDstX,dwDstY,dwDstLogWidth,dwDstLogHeight,dwBPP);

        nvSwizzleBlt_Lin_Swz (dwSrcAddr + dwSrcY * dwSrcPitch + dwSrcX * dwBPP,dwSrcPitch,
                              &Dest,
                              dwWidth,dwHeight,dwSubHeight,dwBPP);
    }

    dbgTracePop();
}

/*****************************************************************************
 * nvSwizBlt_cpu_lin2swz
 *
 * CPU swizzle blt from swizzle to linear
 */
void nvSwizBlt_cpu_swz2lin
(
    DWORD dwSrcAddr,
    DWORD dwSrcX,
    DWORD dwSrcY,
    DWORD dwSrcLogWidth,
    DWORD dwSrcLogHeight,
    DWORD dwDstAddr,
    DWORD dwDstPitch,
    DWORD dwDstX,
    DWORD dwDstY,
    DWORD dwWidth,
    DWORD dwHeight,
    DWORD dwBPP
)
{
    dbgTracePush ("nvSwizBlt_cpu_swz2lin");

    SWIZZLE_ADDR Source;
    DWORD        dwSubHeight = 2048 / (dwWidth * dwBPP);
    if (!dwSubHeight) dwSubHeight = 1;
                 else dwSubHeight = min(dwSubHeight,dwHeight);

    nvSwizzleAddrCreate (&Source,dwSrcAddr,dwSrcX,dwSrcY,dwSrcLogWidth,dwSrcLogHeight,dwBPP);

    nvSwizzleBlt_Swz_Lin (&Source,
                          dwDstAddr + dwDstY * dwDstPitch + dwDstX * dwBPP,dwDstPitch,
                          dwWidth,dwHeight,dwSubHeight,dwBPP);

    dbgTracePop();
}

/*****************************************************************************
 * nvSwizBlt_cpu_swz2swz
 *
 * CPU swizzle blt from swizzle to swizzle
 */
void nvSwizBlt_cpu_swz2swz
(
    DWORD dwSrcAddr,
    DWORD dwSrcX,
    DWORD dwSrcY,
    DWORD dwSrcLogWidth,
    DWORD dwSrcLogHeight,
    DWORD dwDstAddr,
    DWORD dwDstX,
    DWORD dwDstY,
    DWORD dwDstLogWidth,
    DWORD dwDstLogHeight,
    DWORD dwWidth,
    DWORD dwHeight,
    DWORD dwBPP
)
{
    dbgTracePush ("nvSwizBlt_cpu_swz2swz");

    SWIZZLE_ADDR Source;
    SWIZZLE_ADDR Dest;
    DWORD        dwSubHeight = 2048 / (dwWidth * dwBPP);
    if (!dwSubHeight) dwSubHeight = 1;
                 else dwSubHeight = min(dwSubHeight,dwHeight);

    nvSwizzleAddrCreate (&Source,dwSrcAddr,dwSrcX,dwSrcY,dwSrcLogWidth,dwSrcLogHeight,dwBPP);
    nvSwizzleAddrCreate (&Dest,  dwDstAddr,dwDstX,dwDstY,dwDstLogWidth,dwDstLogHeight,dwBPP);

    // todo - check for FT blts, use linear copy

    nvSwizzleBlt_Swz_Swz (&Source,
                          &Dest,
                          dwWidth,dwHeight,dwSubHeight,dwBPP);

    dbgTracePop();
}


/*****************************************************************************
 * nvSwizBlt_gpu_lin2swz
 *
 * GPU swizzle blt from linear to swizzle
 */
void nvSwizBlt_gpu_lin2swz
(
    DWORD dwSrcOffset,
    DWORD dwSrcHeap,
    DWORD dwSrcPitch,
    DWORD dwSrcX,
    DWORD dwSrcY,
    DWORD dwDstOffset,
    DWORD dwDstX,
    DWORD dwDstY,
    DWORD dwDstLogWidth,
    DWORD dwDstLogHeight,
    DWORD dwWidth,
    DWORD dwHeight,
    DWORD dwBPP
)
{
    dbgTracePush ("nvSwizBlt_gpu_lin2swz");
    DWORD dwImageColorFormat;
    DWORD dwFormat = lutFormat[dwBPP];
    nvAssert(dwFormat != ~0);

#if (NVARCH >= 0x010)
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_0089_SCALEDIMG) {
        dwImageColorFormat = nv089SurfaceFormat[dwFormat];
    }
    else
#endif  // NVARCH >= 0x010
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_0077_SCALEDIMG) {
        dwImageColorFormat = nv077SurfaceFormat[dwFormat];
    }

    DWORD dwSurfaceColorFormat = nv052SurfaceFormat[dwFormat];

    assert (dwImageColorFormat   != ~0);
    assert (dwSurfaceColorFormat != ~0);

    // NOTE: HW may not swizzle 8bpp correctly or at all!
    nvHWSwizzleBlt (dwSrcOffset,dwSrcPitch,dwImageColorFormat,dwSrcX,dwSrcY,dwSrcHeap,
                    dwDstOffset,dwDstLogWidth,dwDstLogHeight,dwSurfaceColorFormat,dwDstX,dwDstY,
                    dwWidth,dwHeight);

    dbgFlushType (NVDBG_FLUSH_2D);

    dbgTracePop();
}

////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////

extern "C++"
{

#define CPB_templ template<const DWORD cdwAMask,const DWORD cdwABitPos,const DWORD cdwABitCount,\
                           const DWORD cdwRMask,const DWORD cdwRBitPos,const DWORD cdwRBitCount,\
                           const DWORD cdwGMask,const DWORD cdwGBitPos,const DWORD cdwGBitCount,\
                           const DWORD cdwBMask,const DWORD cdwBBitPos,const DWORD cdwBBitCount,\
                           const DWORD cdwBPP,const DWORD cdwPalType,\
                           const DWORD cdwGetOrMask>

#define CPB_args cdwAMask,cdwABitPos,cdwABitCount,\
                 cdwRMask,cdwRBitPos,cdwRBitCount,\
                 cdwGMask,cdwGBitPos,cdwGBitCount,\
                 cdwBMask,cdwBBitPos,cdwBBitCount,\
                 cdwBPP,cdwPalType,\
                 cdwGetOrMask

CPB_templ class CPBAbstract
{
protected:
    struct PE
    {
        DWORD color;
        DWORD next;
        DWORD prev;
        DWORD index;
        DWORD count;
        DWORD numChildren;
        DWORD child[16];

        inline void init (void) { memset(this, 0xFF, sizeof(*this)); count = numChildren = 0; }
    };
    PE    *m_aSet;
    DWORD  m_adwRoot[9];
    DWORD  m_dwTop;
    DWORD  m_dwNextAlloc;
    DWORD  m_dwSize;
    DWORD  m_dwColors;

protected:
    inline DWORD mask (DWORD dwPel) const { return dwPel | cdwGetOrMask; }
    inline DWORD get  (BYTE *p)     const { return mask((cdwBPP == 4) ? (*(DWORD*)p) : ((DWORD)*(WORD*)p)); }
    inline DWORD getA (DWORD dwPel) const { return (dwPel & cdwAMask) >> cdwABitPos; }
    inline DWORD getR (DWORD dwPel) const { return (dwPel & cdwRMask) >> cdwRBitPos; }
    inline DWORD getG (DWORD dwPel) const { return (dwPel & cdwGMask) >> cdwGBitPos; }
    inline DWORD getB (DWORD dwPel) const { return (dwPel & cdwBMask) >> cdwBBitPos; }

    inline void put (BYTE *p,DWORD dw)
    {
        if (cdwBPP == 4) *(DWORD*)p = dw;
                    else *(WORD*)p = (WORD)dw;
    }

protected:
    BOOL grow (void);

    inline DWORD allocNode (void)
    {
        // march on
        m_dwNextAlloc++;
        if (m_dwNextAlloc >= m_dwSize)
        {
            // we are out of space - grow
            if (!grow()) return ~0;
        }

        // return free node
        m_aSet[m_dwNextAlloc].init();
        return m_dwNextAlloc;
    }
    inline DWORD lookup (DWORD dwPel)
    {
        DWORD a = getA(dwPel);
        DWORD r = getR(dwPel);
        DWORD g = getG(dwPel);
        DWORD b = getB(dwPel);

        DWORD curr = m_dwTop;
        for (DWORD i = 0; i < 9; i++)
        {
            // found it yet?
            if (!m_aSet[curr].numChildren)
            {
                return m_aSet[curr].index;
            }

            // get child
            DWORD child = ((a & 128) >> 4) | ((r & 128) >> 5) | ((g & 128) >> 6) | ((b & 128) >> 7);

            // next
            curr = m_aSet[curr].child[child];
            a <<= 1;
            r <<= 1;
            g <<= 1;
            b <<= 1;
        }

        return m_aSet[curr].index;
    }

protected:
    BOOL addToTable (DWORD dwPel);
    void swizzle    (DWORD dwSrcAddr,DWORD dwSrcPitch,SWIZZLE_ADDR *lpSA,DWORD dwWidth,DWORD dwHeight,DWORD dwSubHeight);

public:
    BOOL initTable  (void);
    BOOL buildTable (DWORD dwSource,DWORD dwWidth,DWORD dwHeight);
    BOOL palettize  (BYTE *pbPalette);
    BOOL apply      (DWORD dwSource,DWORD dwDest,DWORD dwWidth,DWORD dwLogWidth,DWORD dwHeight,DWORD dwLogHeight);
    BOOL freeTable  (void);

public:
    BOOL depalettizeInPlace      (DWORD dwSource,DWORD dwDest,DWORD dwWidth,DWORD dwHeight,DWORD *pPalette);
    BOOL depalettizeAndDeswizzle (DWORD dwSource,DWORD dwDest,DWORD dwWidth,DWORD dwLogWidth,DWORD dwHeight,DWORD dwLogHeight,DWORD dwDeviceMemPaletteAddr);
};

////////////////////////////////////////////////////////////////////////////////////////

CPB_templ
BOOL CPBAbstract<CPB_args>::grow
(
    void
)
{
    m_dwSize *= 2;
    if (!ReallocIPM(m_aSet,m_dwSize * sizeof(PE),(void**)&m_aSet)) return FALSE; // out of memory
    if (!m_aSet) return FALSE; // out of memory
    return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////////

CPB_templ
BOOL CPBAbstract<CPB_args>::addToTable
(
    DWORD dwPel
)
{
    DWORD a = getA(dwPel);
    DWORD r = getR(dwPel);
    DWORD g = getG(dwPel);
    DWORD b = getB(dwPel);

    DWORD curr   = m_dwTop;
    BOOL  unique = FALSE;
    for (DWORD i = 0; i < 8; i++)
    {
        // get child
        DWORD child = ((a & 128) >> 4) | ((r & 128) >> 5) | ((g & 128) >> 6) | ((b & 128) >> 7);

        // bump usage count
        m_aSet[curr].count ++;

        // traverse or add?
        if (m_aSet[curr].child[child] == ~0)
        {
            unique = TRUE;

            // add new node
            DWORD next = allocNode();
            if (next == ~0) return FALSE; // abort
            m_aSet[curr].child[child] = next;
            m_aSet[curr].numChildren  ++;

            // add to linked list
            m_aSet[next].prev = ~0;
            m_aSet[next].next = m_adwRoot[i+1];
            if (m_adwRoot[i+1] != ~0) m_aSet[m_adwRoot[i+1]].prev = next;
            m_adwRoot[i+1]    = next;

            // next pos
            curr = next;
        }
        else
        {
            // next pos
            curr = m_aSet[curr].child[child];
        }

        // next
        a <<= 1;
        r <<= 1;
        g <<= 1;
        b <<= 1;
    }

    // set color of leaf
    m_aSet[curr].count ++;
    m_aSet[curr].color = dwPel;
    if (unique) m_dwColors++; // unique color count

    // done
    return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////////

CPB_templ
void CPBAbstract<CPB_args>::swizzle
(
    DWORD         dwSrcAddr,
    DWORD         dwSrcPitch,

    SWIZZLE_ADDR *lpSA,

    DWORD         dwWidth,
    DWORD         dwHeight,
    DWORD         dwSubHeight
)
{
    DWORD dwBytes = dwWidth * cdwBPP;
    DWORD y;

    for (y = dwHeight; y;)
    {
        DWORD a;
        DWORD h;
        DWORD f = min(dwSubHeight,y);

        /*
         * read linear
         */
        a = (DWORD)&nvTexelScratchBuffer;
        for (h = f; h; h--)
        {
            nvMemCopy (a,dwSrcAddr,dwBytes);
            a         += dwBytes;
            dwSrcAddr += dwSrcPitch;
        }

        /*
         * write swizzle
         */
        a = (DWORD)&nvTexelScratchBuffer;
        for (h = f; h; h--)
        {
            DWORD x;

            for (x = dwWidth; x; x--)
            {
                DWORD dwPel = 0;
                if (cdwBPP == 4) dwPel = *(DWORD*)a;
                            else dwPel = *(WORD*)a;

                DWORD dwIndex = lookup(mask(dwPel));
                *(BYTE*)(nvSwizzleAddrGet(lpSA)) = (BYTE)dwIndex;

                a += cdwBPP;
                nvSwizzleAddrNext (lpSA);
            }
            nvSwizzleAddrNewLine (lpSA);
        }

        y -= f;
    }
}

////////////////////////////////////////////////////////////////////////////////////////

CPB_templ
BOOL CPBAbstract<CPB_args>::initTable
(
    void
)
{
    // init table
    memset(m_adwRoot, 0xFF, sizeof(m_adwRoot));
    m_dwSize      = 256;
    m_aSet        = (PE*)AllocIPM(m_dwSize * sizeof(PE));
    if (!m_aSet) return FALSE;
    m_aSet[0].init();
    m_adwRoot[0]  = 0;
    m_dwTop       = 0;
    m_dwNextAlloc = 0;

    // init stats
    m_dwColors = 0;

    // done
    return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////////

CPB_templ
BOOL CPBAbstract<CPB_args>::buildTable
(
    DWORD  dwSource,
    DWORD  dwWidth,
    DWORD  dwHeight
)
{
    // build table
    DWORD dwLine  = dwSource;
    DWORD dwPitch = dwWidth * cdwBPP;
    for (DWORD y = 0; y < dwHeight; y++,dwLine += dwPitch)
    {
        for (DWORD xx = 0,x = 0; x < dwWidth; x++, xx += cdwBPP)
        {
            DWORD pel = get((BYTE*)(dwLine+xx));
            if (!addToTable(pel)) return FALSE;
            if (m_dwColors >= 256) return FALSE;
        }
    }

    // done
    return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////////

CPB_templ
BOOL CPBAbstract<CPB_args>::palettize
(
    BYTE *pbPalette
)
{
    // do color reduction
    int lowest = 7;
    while (m_dwColors > 256)
    {
        // find the node with the lowest use count that is not a leaf
        DWORD max = ~0;
        DWORD pos = ~0;
        for (DWORD curr = m_adwRoot[lowest]; curr != ~0; curr = m_aSet[curr].next)
        {
            PE *p = m_aSet + curr;

            if (p->numChildren && (p->count < max))
            {
                max = p->count;
                pos = curr;

                if ((p->numChildren == 1) || (p->count <= 2)) break; // shortcut when useful stuff is found
            }
        }
        if (pos == ~0)
        {
            lowest--;
            continue;
        }

        // combine the child nodes
        DWORD  cmax = 0;
        PE     *p    = m_aSet + pos;
        for (int j = 0; j < 16; j++)
        {
            if (p->child[j] != ~0)
            {
                PE *c = m_aSet + p->child[j];

                assert (!c->numChildren);

                if (c->count > cmax)
                {
                    cmax     = c->count;
                    p->color = c->color;
                }

                DWORD a = c->prev;
                DWORD b = c->next;
                if (a != ~0) m_aSet[a].next = b; else m_adwRoot[lowest+1] = b;
                if (b != ~0) m_aSet[b].prev = a;

                m_dwColors--;
                p->child[j] = ~0;
            }
        }
        m_dwColors++;
        p->numChildren = 0;
    }

    // enumerate and build pallette
    DWORD index = 0;
    for (DWORD i = 0; i < 9; i++)
    {
        for (DWORD curr = m_adwRoot[i]; curr != ~0; curr = m_aSet[curr].next)
        {
            PE *p = m_aSet + curr;
            if (!p->numChildren)
            {
                assert (index < 256); // color reduction failed

                if (cdwBPP == 4) *(DWORD*)(pbPalette + index * 4) = p->color;
                            else *(WORD*)(pbPalette + index * 2) = (WORD)p->color;

                p->index          = index;
                index++;
            }
        }
    }

    return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////////

CPB_templ
BOOL CPBAbstract<CPB_args>::apply
(
    DWORD  dwSource,
    DWORD  dwDest,
    DWORD  dwWidth,
    DWORD  dwLogWidth,
    DWORD  dwHeight,
    DWORD  dwLogHeight
)
{
    // convert image and swizzle
    SWIZZLE_ADDR dest;
    DWORD        dwSubHeight = 2048 / (dwWidth * cdwBPP);
    DWORD        dwPitch     = dwWidth * cdwBPP;
    if (!dwSubHeight) dwSubHeight = 1;
                 else dwSubHeight = min(dwSubHeight,dwHeight);
    nvSwizzleAddrCreate (&dest,dwDest,0,0,dwLogWidth,dwLogHeight,1);
    swizzle(dwSource,dwPitch,&dest,dwWidth,dwHeight,dwSubHeight);

    // done
    return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////////

CPB_templ
BOOL CPBAbstract<CPB_args>::freeTable
(
    void
)
{
    if (m_aSet) FreeIPM (m_aSet);
    return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////////

CPB_templ
BOOL CPBAbstract<CPB_args>::depalettizeInPlace
(
    DWORD dwSource,
    DWORD dwDest,
    DWORD dwWidth,
    DWORD dwHeight,
    DWORD *pPalette
)
{
    // depalettize (bottom up since we do this in place)

    nvAssert(cdwBPP == 4);

    DWORD *dwPixels = (DWORD *)dwDest - 1;         //shift the array to optimize the loop
    BYTE * pIndices = (BYTE *)dwSource - 1;

    for (DWORD a = dwHeight*dwWidth; a; a--)
        dwPixels[a]=pPalette[pIndices[a]];

    return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////////

CPB_templ
BOOL CPBAbstract<CPB_args>::depalettizeAndDeswizzle
(
    DWORD dwSource,
    DWORD dwDest,
    DWORD dwWidth,
    DWORD dwLogWidth,
    DWORD dwHeight,
    DWORD dwLogHeight,
    DWORD dwDeviceMemPaletteAddr
)
{
    // copy palette away
    DWORD adwPalette[256];
    memcpy (adwPalette,(char*)dwDeviceMemPaletteAddr,256 * cdwBPP);

    // deswizzle and depalettize
    SWIZZLE_ADDR source;
    DWORD        dwSubHeight = 2048 / (dwWidth * cdwBPP);
    DWORD        dwPitch     = dwWidth * cdwBPP;
    if (!dwSubHeight) dwSubHeight = 1;
                 else dwSubHeight = min(dwSubHeight,dwHeight);
    nvSwizzleAddrCreate (&source,dwSource,0,0,dwLogWidth,dwLogHeight,1);

    DWORD        dwBytes = dwWidth * cdwBPP;
    DWORD        y;
    for (y = dwHeight; y;)
    {
        DWORD a;
        DWORD h;
        DWORD f = min(dwSubHeight,y);

        /*
         * read swizzle
         */
        a = (DWORD)&nvTexelScratchBuffer;

        for (h = f; h; h--)
        {
            DWORD x;

            for (x = dwWidth; x; x--)
            {
                DWORD dwPel;
                if (cdwBPP == 4) dwPel = adwPalette[*(BYTE*)nvSwizzleAddrGet(&source)];
                            else dwPel = *(WORD*)(DWORD(adwPalette) + 2 * (DWORD)*(BYTE*)nvSwizzleAddrGet(&source));
                put ((BYTE*)a,dwPel);

                a += cdwBPP;
                nvSwizzleAddrNext (&source);
            }

            nvSwizzleAddrNewLine (&source);
        }

        /*
         * write linear
         */
        a = (DWORD)&nvTexelScratchBuffer;
        for (h = f; h; h--)
        {
            nvMemCopy (dwDest,a,dwBytes);
            a          += dwBytes;
            dwDest     += dwPitch;
        }

        y -= f;
    }

    // done
    return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////////

// 32
CPBAbstract<0xff000000,24,8,
          0x00ff0000,16,8,
          0x0000ff00, 8,8,
          0x000000ff, 0,8,
          4,PT_8888,
          0x00000000>        g_PB8888;
CPBAbstract<0x00000000, 0,0,
          0x00ff0000,16,8,
          0x0000ff00, 8,8,
          0x000000ff, 0,8,
          4,PT_X888,
          0xff000000>        g_PBX888;
// 16
CPBAbstract<0x0000,12,4,
          0x0000, 8,4,
          0x0000, 4,4,
          0x0000, 0,4,
          2,PT_4444,
          0x00000000>        g_PB4444;
CPBAbstract<0x8000,15,1,
          0x7c00,10,5,
          0x03e0, 5,5,
          0x001f, 0,5,
          2,PT_1555,
          0x0000>            g_PB1555;
CPBAbstract<0x0000, 0,0,
          0x7c00,10,5,
          0x03e0, 5,5,
          0x001f, 0,5,
          2,PT_X555,
          0x8000>            g_PBX555;
CPBAbstract<0x0000, 0,0,
          0xfe00,11,5,
          0x07e0, 5,6,
          0x001f, 0,5,
          2,PT_565,
          0x0000>            g_PB565;

BOOL CPaletteBuilder::initTable  (DWORD dwPalType)
{
    switch (dwPalType)
    {
        case PT_8888: return g_PB8888.initTable();
        case PT_X888: return g_PBX888.initTable();
        case PT_4444: return g_PB4444.initTable();
        case PT_1555: return g_PB1555.initTable();
        case PT_X555: return g_PBX555.initTable();
        case PT_565 : return g_PB565 .initTable();
    }
    return FALSE;
}
BOOL CPaletteBuilder::buildTable (DWORD dwPalType,DWORD dwSource,DWORD dwWidth,DWORD dwHeight)
{
    switch (dwPalType)
    {
        case PT_8888: return g_PB8888.buildTable(dwSource,dwWidth,dwHeight);
        case PT_X888: return g_PBX888.buildTable(dwSource,dwWidth,dwHeight);
        case PT_4444: return g_PB4444.buildTable(dwSource,dwWidth,dwHeight);
        case PT_1555: return g_PB1555.buildTable(dwSource,dwWidth,dwHeight);
        case PT_X555: return g_PBX555.buildTable(dwSource,dwWidth,dwHeight);
        case PT_565 : return g_PB565 .buildTable(dwSource,dwWidth,dwHeight);
    }
    return FALSE;
}
BOOL CPaletteBuilder::palettize (DWORD dwPalType,BYTE *pbPalette)
{
    switch (dwPalType)
    {
        case PT_8888: return g_PB8888.palettize(pbPalette);
        case PT_X888: return g_PBX888.palettize(pbPalette);
        case PT_4444: return g_PB4444.palettize(pbPalette);
        case PT_1555: return g_PB1555.palettize(pbPalette);
        case PT_X555: return g_PBX555.palettize(pbPalette);
        case PT_565 : return g_PB565 .palettize(pbPalette);
    }
    return FALSE;
}
BOOL CPaletteBuilder::apply (DWORD dwPalType,DWORD dwSource,DWORD dwDest,DWORD dwWidth,DWORD dwLogWidth,DWORD dwHeight,DWORD dwLogHeight)
{
    switch (dwPalType)
    {
        case PT_8888: return g_PB8888.apply(dwSource,dwDest,dwWidth,dwLogWidth,dwHeight,dwLogHeight);
        case PT_X888: return g_PBX888.apply(dwSource,dwDest,dwWidth,dwLogWidth,dwHeight,dwLogHeight);
        case PT_4444: return g_PB4444.apply(dwSource,dwDest,dwWidth,dwLogWidth,dwHeight,dwLogHeight);
        case PT_1555: return g_PB1555.apply(dwSource,dwDest,dwWidth,dwLogWidth,dwHeight,dwLogHeight);
        case PT_X555: return g_PBX555.apply(dwSource,dwDest,dwWidth,dwLogWidth,dwHeight,dwLogHeight);
        case PT_565 : return g_PB565 .apply(dwSource,dwDest,dwWidth,dwLogWidth,dwHeight,dwLogHeight);
    }
    return FALSE;
}
BOOL CPaletteBuilder::freeTable (DWORD dwPalType)
{
    switch (dwPalType)
    {
        case PT_8888: return g_PB8888.freeTable();
        case PT_X888: return g_PBX888.freeTable();
        case PT_4444: return g_PB4444.freeTable();
        case PT_1555: return g_PB1555.freeTable();
        case PT_X555: return g_PBX555.freeTable();
        case PT_565 : return g_PB565 .freeTable();
    }
    return FALSE;
}
BOOL CPaletteBuilder::depalettizeInPlace (DWORD dwPalType,DWORD dwSource,DWORD dwDest,DWORD dwWidth,DWORD dwHeight,DWORD *pPalette)
{
    switch (dwPalType)
    {
        case PT_8888: return g_PB8888.depalettizeInPlace(dwSource,dwDest,dwWidth,dwHeight,pPalette);
        case PT_X888: return g_PBX888.depalettizeInPlace(dwSource,dwDest,dwWidth,dwHeight,pPalette);
        case PT_4444: return g_PB4444.depalettizeInPlace(dwSource,dwDest,dwWidth,dwHeight,pPalette);
        case PT_1555: return g_PB1555.depalettizeInPlace(dwSource,dwDest,dwWidth,dwHeight,pPalette);
        case PT_X555: return g_PBX555.depalettizeInPlace(dwSource,dwDest,dwWidth,dwHeight,pPalette);
        case PT_565 : return g_PB565 .depalettizeInPlace(dwSource,dwDest,dwWidth,dwHeight,pPalette);
    }
    return FALSE;
}
BOOL CPaletteBuilder::depalettizeAndDeswizzle (DWORD dwPalType,DWORD dwSource,DWORD dwDest,DWORD dwWidth,DWORD dwLogWidth,DWORD dwHeight,DWORD dwLogHeight,DWORD dwDeviceMemPaletteAddr)
{
    switch (dwPalType)
    {
        case PT_8888: return g_PB8888.depalettizeAndDeswizzle (dwSource,dwDest,dwWidth,dwLogWidth,dwHeight,dwLogHeight,dwDeviceMemPaletteAddr);
        case PT_X888: return g_PBX888.depalettizeAndDeswizzle (dwSource,dwDest,dwWidth,dwLogWidth,dwHeight,dwLogHeight,dwDeviceMemPaletteAddr);
        case PT_4444: return g_PB4444.depalettizeAndDeswizzle (dwSource,dwDest,dwWidth,dwLogWidth,dwHeight,dwLogHeight,dwDeviceMemPaletteAddr);
        case PT_1555: return g_PB1555.depalettizeAndDeswizzle (dwSource,dwDest,dwWidth,dwLogWidth,dwHeight,dwLogHeight,dwDeviceMemPaletteAddr);
        case PT_X555: return g_PBX555.depalettizeAndDeswizzle (dwSource,dwDest,dwWidth,dwLogWidth,dwHeight,dwLogHeight,dwDeviceMemPaletteAddr);
        case PT_565 : return g_PB565 .depalettizeAndDeswizzle (dwSource,dwDest,dwWidth,dwLogWidth,dwHeight,dwLogHeight,dwDeviceMemPaletteAddr);
    }
    return FALSE;
}

}

#endif  // NVARCH >= 0x04
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\src\nvUtil_link.cpp ===
// **************************************************************************
//
//       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
//
//  Module: nvUtil_link.cpp
//      a pointer to a shared file
//
// **************************************************************************
#include "nvprecomp.h"

#include "..\..\..\common\src\nvUtil.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\src\nvVB.cpp ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/
#include "nvprecomp.h"

/*****************************************************************************
 *****************************************************************************
 *****************************************************************************
 ***  CVertexBuffer  *********************************************************
 *****************************************************************************
 *****************************************************************************
 *****************************************************************************/

/*****************************************************************************
 * CVertexBuffer::prepareSuperTriLookAsideBuffer
 */
BOOL CVertexBuffer::prepareSuperTriLookAsideBuffer
(
    void
)
{
    //
    // fail if we cannot support supertri for this buffer
    //
    if (!getVertexStride()) return FALSE;

    //
    // [re]create buffer if needed
    //
    DWORD dwVertexCount = getSize() / getVertexStride();
    if (dwVertexCount != m_dwSuperTriLookAsideBufferSize)
    {
        destroySuperTriLookAsideBuffer();
        m_dwSuperTriLookAsideBufferSize = dwVertexCount;
    }

    if (!m_pSuperTriLookAsideBuffer)
    {
        // Align to 2 cachelines (1 cacheline for Willamette)
        // this is taken care of internally by AllocIPM (64 byte align)
        DWORD dwSize = dwVertexCount * sizeof(STVERTEX);
        m_pSuperTriLookAsideBuffer = AllocIPM(dwSize);
        if (!m_pSuperTriLookAsideBuffer) return FALSE;
        m_dwFlags |= FLAG_SUPERTRIOWNSMEM;
    }

    //
    // fill out (very slow operation)
    //
    DWORD dwSource = getAddress();
    DWORD dwDest   = (DWORD)m_pSuperTriLookAsideBuffer;
    DWORD *dwDestp = (DWORD *)m_pSuperTriLookAsideBuffer;
    for (DWORD i = 0; i < dwVertexCount; i++)
    {
        nvMemCopy (dwDest, dwSource, sizeof(STVERTEX));
        dwDestp[3] = 0;
        dwSource += getVertexStride();
        dwDestp  += sizeof(STVERTEX)/sizeof(float);
        dwDest   += sizeof(STVERTEX);
    }

    //
    // done
    //
    return TRUE;
}

/*****************************************************************************
 * CVertexBuffer::destroySuperTriLookAsideBuffer
 */
void CVertexBuffer::destroySuperTriLookAsideBuffer
(
    void
)
{
    if (m_dwFlags & FLAG_SUPERTRIOWNSMEM)
    {
        if (m_pSuperTriLookAsideBuffer)
        {
            FreeIPM (m_pSuperTriLookAsideBuffer);
            m_pSuperTriLookAsideBuffer = NULL;
        }
    }
}

/*****************************************************************************
 * CVertexBuffer::CVertexBuffer
 *
 * initialize a VB object
 */
CVertexBuffer::CVertexBuffer
(
    CNvObject *pWrapperObject
)
{
    // tell world
    DPF_LEVEL (NVDBG_LEVEL_SURFACE, "CVertexBuffer[%08x]::CVertexBuffer()", this);

    // assign variables
    m_pWrapperObject = pWrapperObject;

    // init the others
    m_dwFlags                       = 0;
    m_dwSuperTriLookAsideBufferSize = 0;
    m_pSuperTriLookAsideBuffer      = NULL;
    m_dwLockCount                   = 0;
}

/*****************************************************************************
 * CVertexBuffer::~CVertexBuffer
 *
 * destroy a VB object
 */
CVertexBuffer::~CVertexBuffer
(
    void
)
{
    /*
     * tell world
     */
    DPF_LEVEL (NVDBG_LEVEL_SURFACE, "CVertexBuffer[%08x]::~CVertexBuffer()", this);

    destroy();
}

/*****************************************************************************
 *****************************************************************************
 *****************************************************************************
 ***  CCommandBuffer  ********************************************************
 *****************************************************************************
 *****************************************************************************
 *****************************************************************************/

/*****************************************************************************
 * CCommandBuffer::CCommandBuffer
 */
CCommandBuffer::CCommandBuffer
(
    CNvObject                 *pWrapperObject,
    LPDDRAWI_DDRAWSURFACE_LCL  pDDSurfaceLcl
)
{
    /*
     * tell world
     */
    DPF_LEVEL (NVDBG_LEVEL_SURFACE, "CCommandBuffer[%08x]::CCommandBuffer()", this);

    m_pWrapperObject  = pWrapperObject;
    m_pDDSurfaceLcl   = pDDSurfaceLcl;
    m_Surface.setWrapper(pWrapperObject);
#ifdef WINNT
    m_Surface.getWrapper()->setDDSLcl(pDDSurfaceLcl);
#endif
}

/*****************************************************************************
 * CCommandBuffer::~CCommandBuffer
 */
CCommandBuffer::~CCommandBuffer
(
    void
)
{
    /*
     * tell world
     */
    DPF_LEVEL (NVDBG_LEVEL_SURFACE, "CCommandBuffer[%08x]::~CCommandBuffer()", this);
}

/*****************************************************************************
 *****************************************************************************
 *****************************************************************************
 ***  exports  ***************************************************************
 *****************************************************************************
 *****************************************************************************
 *****************************************************************************/

/*****************************************************************************
 * D3DCanCreateExecuteBuffer32
 *
 * D3D callback to check if we can create an execute, vertex or command buffer
 */
DWORD __stdcall D3DCanCreateExecuteBuffer32
(
    LPDDHAL_CANCREATESURFACEDATA pCanCreateSurfaceData
)
{
    dbgTracePush ("D3DCanCreateExecuteBuffer32");

    //
    // figure out if we can create a VB
    //
#ifdef DEBUG
    DWORD         dwLatest       = 0;
    PNVD3DCONTEXT pContext       = (PNVD3DCONTEXT)getDC()->dwContextListHead;
    PNVD3DCONTEXT pActualContext = NULL;
    while (pContext)
    {
        if (pContext->dwTickLastUsed > dwLatest)
        {
            pContext->dwTickLastUsed = dwLatest;
            pActualContext           = pContext;
        }
        pContext = pContext->pContextNext;
    }
    DWORD dwAppRuntimeLevel = pActualContext ? pActualContext->dwDXAppVersion
                                             : 0x0600;

    // show this call
    DPF_LEVEL (NVDBG_LEVEL_SURFACE, "D3DCanCreateExecuteBuffer32: appdx=%04x  rtdx=%04x",
               dwAppRuntimeLevel,global.dwDXRuntimeVersion);
#endif

    //
    // punt if we have DX6 runtime
    //
    if (global.dwDXRuntimeVersion <= 0x600)
    {
        pCanCreateSurfaceData->ddRVal = DDERR_INVALIDCAPS;
        dbgTracePop();
        return DDHAL_DRIVER_HANDLED;
    }

#ifdef DO_NOT_SUPPORT_VERTEX_BUFFERS // see nvprecomp.h
    pCanCreateSurfaceData->ddRVal = DDERR_INVALIDCAPS;
    dbgTracePop();
    return DDHAL_DRIVER_HANDLED;
#endif //!DO_NOT_SUPPORT_VERTEX_BUFFERS

    //
    // is this an optimize call?
    //
    if (pCanCreateSurfaceData->lpDDSurfaceDesc->dwFlags & DDSD_SRCVBHANDLE)
    {
        pCanCreateSurfaceData->ddRVal = DDERR_INVALIDCAPS;
        dbgTracePop();
        return DDHAL_DRIVER_HANDLED;
    }

    nvSetDriverDataPtrFromDDGbl (pCanCreateSurfaceData->lpDD);

    // fail if we don't have AGP memory -
    // on true PCI cards we never get this call, but on an AGP card running with AGP disabled (with the
    // DirectX diagnostic tool) the run-time will puke if we create a vertex buffer in PCI memory
    //
    if (!(pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_PCIBUS))
        if (pDriverData->GARTLinearBase == NULL)
        {
            NvReleaseSemaphore(pDriverData);
            pCanCreateSurfaceData->ddRVal = DDERR_INVALIDCAPS;
            dbgTracePop();
            return DDHAL_DRIVER_HANDLED;
        }

    //
    // we claim that we can create all types of buffers
    //
    NvReleaseSemaphore(pDriverData);
    pCanCreateSurfaceData->ddRVal = DD_OK;
    dbgTracePop();
    return DDHAL_DRIVER_HANDLED;
}

/*****************************************************************************
 * D3DCreateExecuteBuffer32
 *
 * D3D callback to create an execute, vertex or command buffer
 */
DWORD __stdcall D3DCreateExecuteBuffer32
(
    LPDDHAL_CREATESURFACEDATA pCreateSurfaceData
)
{
    dbgTracePush ("D3DCreateExecuteBuffer32");

    //
    // is this an optimize call?
    //
    DWORD dwFlags = pCreateSurfaceData->lpDDSurfaceDesc->dwFlags;
    if (dwFlags & DDSD_SRCVBHANDLE)
    {
        pCreateSurfaceData->ddRVal = DDERR_INVALIDCAPS;
        dbgTracePop();
        return DDHAL_DRIVER_HANDLED;
    }

    //
    // get driver context
    //
    nvSetDriverDataPtrFromDDGbl (pCreateSurfaceData->lpDD);

    // Reset NV and get the monitor frequency after a mode reset
    if (getDC()->dwEnableStatus != CDriverContext::DC_ENABLESTATUS_ENABLED) {
        getDisplayDuration();
        if (!nvEnable32 (pCreateSurfaceData->lpDD)) {
            NvReleaseSemaphore(pDriverData);
            pCreateSurfaceData->ddRVal = DDERR_OUTOFMEMORY;
            dbgTracePop();
            return DDHAL_DRIVER_HANDLED;
        }
    }

    //
    // get app version by looking for the presence of FVF flag
    // i begged for a better hint bit from MS - will see.
    //

    // bIsDX6 will be true for DX8 Index Buffers.  No way to code around it, so we will take a
    // dx6 performance hit when we are running on DX8
    BOOL bIsDX6       = FALSE;
    // wa rpeviously: BOOL bIsDX6 = ((dwFlags & DDSD_FVF) != DDSD_FVF); // not valid for command buffers
    BOOL bIsImplicit  = FALSE;
    BOOL bForceSysMem = FALSE;

    /*
     * for all surfaces in SList
     */
    LPDDRAWI_DDRAWSURFACE_LCL *lplpSList = pCreateSurfaceData->lplpSList;
    for(DWORD i = 0; i < pCreateSurfaceData->dwSCnt; i++)
    {
        /*
         * get the dd surface
         */
        LPDDRAWI_DDRAWSURFACE_LCL lpSurf = lplpSList[i];

        /*
         * figure out what to create
         */
        if (lpSurf->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER)
        {
            if (lpSurf->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_VERTEXBUFFER)
            {
            allocVertexBuffer:
                //
                // we have shown that DX6 vertex buffers are slower than MS managing them (3d mark 99)
                //
                BOOL bDoNotHandle = FALSE;
                if (bIsDX6 /*|| bIsImplicit  -- slower now - bdw */) {
                    bDoNotHandle = TRUE;
                }
#ifdef STEREO_SUPPORT
                //All vertices that potentially will be read back in order to be modified for stereo
                //should go to system memory.
                else
                {
                    if (STEREO_ENABLED)
                    {
                        if (bIsImplicit || ((dwFlags & DDSD_FVF) != DDSD_FVF))
                        {
                            //For stereo implicit and DX6 type VBs still go to system memory.
                            bDoNotHandle = TRUE;
                        } else
                        {
                            LPDDSURFACEDESC2 lpSurfDesc2 = (LPDDSURFACEDESC2)pCreateSurfaceData->lpDDSurfaceDesc;
                            if (FVF_TRANSFORMED(lpSurfDesc2->dwFVF))
                            {
                                //We don't want to allocate VBs for transformed vertices in offscreen memory. The
                                //problem is that we will have to physically modify vertices for the left and right
                                //eyes and it is going to be dog slow if the vertices end up in VRAM. So sacrificing
                                //VRAM VBs for this case is our trade off for being able to view stereo.
                                bDoNotHandle = TRUE;
                            }
                        }
                    }
                }
#endif  //STEREO_SUPPORT
                if (bDoNotHandle)
                {
                    NvReleaseSemaphore(pDriverData);
                    pCreateSurfaceData->ddRVal = DDERR_INVALIDCAPS;
                    dbgTracePop();
                    return DDHAL_DRIVER_HANDLED;
                }

                /*
                 * create a vertex buffer
                 */
#ifndef WINNT   // WINNT BUG - what about pid?
                CNvObject      *pNvObj = new CNvObject (lpSurf->dwProcessId);
#else   // WINNT
                CNvObject      *pNvObj = new CNvObject (0);
#endif  // WINNT
                CVertexBuffer  *pVertexBuffer;
                BOOL            bAllowRenaming;

                if (pNvObj)
                {
                    pVertexBuffer = new CVertexBuffer (pNvObj);
                    
                    if (!pVertexBuffer)
                    {
                        pNvObj->release();
                        NvReleaseSemaphore(pDriverData);
                        DPF ("D3DCreateExecuteBuffer32: failed to create CVertexBuffer object");
                        dbgD3DError();
                        pCreateSurfaceData->ddRVal = DDERR_OUTOFMEMORY;
                        dbgTracePop();
                        return DDHAL_DRIVER_HANDLED;
                    }

                    #ifdef DX7PROPER
                    if (bIsDX6)
                    {
                        PF ("1. Vertexbuffer is created from a DX6 interface.");
                        DPF_LEVEL(NVDBG_LEVEL_PERFORMANCE, "Vertex Buffer wasn't created by driver, copy forced");
                    }
                    #endif

                    //
                    // determine where to put the buffer
                    //  - we can force the VB in sysmem (dx6 implicit VB)
                    //  - if app will write only, go for agp or vid mem
                    //
                    DWORD dwAllowed;
                    DWORD dwPreferred;
                    LPDDSURFACEDESC2 lpSurfDesc2 = (LPDDSURFACEDESC2)pCreateSurfaceData->lpDDSurfaceDesc;


                    if ( (lpSurfDesc2->dwFVF & D3DFVF_PSIZE) ||
                         (lpSurf->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_RTPATCHES)
                        )
                    {
                        //force emulated point sprites into system memory
                        //force emulated vertex shaders into system memory
                        bForceSysMem = TRUE;
                    }

                    if (bForceSysMem
                     || !(lpSurf->ddsCaps.dwCaps & DDSCAPS_WRITEONLY)
                     /*|| (bIsImplicit)*/)  // Implicit buffers will be DMA'ed (WB2k)
                    {
                        #ifdef DX7PROPER // inaccurte for supertri case (i.e. actually a good thing)
                            DPF_LEVEL(NVDBG_LEVEL_PERFORMANCE, "Vertex Buffer forced into system memory");
                            PF ("2. Vertexbuffer is forced into system memory.");
                        #endif

                        //
                        // we force system memory with no renaming
                        //
                        dwAllowed      = CSimpleSurface::HEAP_SYS;
                        dwPreferred    = CSimpleSurface::HEAP_SYS;
                        bAllowRenaming = FALSE;

                        // temporary fix for sys mem VB's: allow MS to create them.
                        // we really should map/unmap them into the user space ourselves
                        pCreateSurfaceData->ddRVal = DDERR_GENERIC;
                        
                        // delete the pVertexBuffer we created, release the pNvObject
                        delete pVertexBuffer;
                        pNvObj->release();

                        NvReleaseSemaphore(pDriverData);
                        dbgTracePop();
                        return DDHAL_DRIVER_HANDLED;
                    }
                    else
                    {
                        //
                        // we allow both agp & vid
                        //
                        dwAllowed   = CSimpleSurface::HEAP_VID
                                    | (pDriverData->GARTLinearBase ? CSimpleSurface::HEAP_AGP
                                                                   : CSimpleSurface::HEAP_PCI);
                        //
                        // we prefer vid for machines with fast write cap, else agp (its closer)
                        //
                        // DX8  we'll need to look at memory usage etc...
                        if (lpSurf->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_HINTSTATIC) {
                            dwPreferred = CSimpleSurface::HEAP_VID;
                        }
                        else {
                            dwPreferred = (pDriverData->nvD3DPerfData.dwPerformanceStrategy & PS_VB_PREFER_AGP) ?
                                          (CSimpleSurface::HEAP_AGP | CSimpleSurface::HEAP_PCI) :
                                          (CSimpleSurface::HEAP_VID);
                        }
                        //
                        // some renaming is allowed
                        //
                        bAllowRenaming = TRUE;
                    }

                    //LPDDSURFACEDESC2 lpSurfDesc2 = (LPDDSURFACEDESC2)pCreateSurfaceData->lpDDSurfaceDesc;
                    // compute a DX8-style shader from the FVF format in order to generate the stride
                    //CVertexShader vShader;
                    //vShader.create ((PNVD3DCONTEXT)(pDriverData->dwContextListHead), lpSurfDesc2->dwFVF);
                    //pVertexBuffer->setVertexStride (vShader.getStride());

                    // set stride to 0. proper stride gets set in DP2
                    pVertexBuffer->setVertexStride (0);

                    // allocate the actual memory
                    DWORD dwSize = lpSurf->lpGbl->dwLinearSize;
#ifdef WINNT
                    pNvObj->setDDSLcl(lpSurf);
#endif
                    if (!pVertexBuffer->create(dwSize,
                                               dwAllowed,
                                               dwPreferred))
                    {
                        // temporary fix for sys mem VB's: allow MS to create them.
                        // we really should map/unmap them into the user space ourselves
                        pCreateSurfaceData->ddRVal = DDERR_GENERIC;

                        // delete the pVertexBuffer we created, release the pNvObject
                        delete pVertexBuffer;
                        pNvObj->release();

                        NvReleaseSemaphore(pDriverData);
                        dbgTracePop();
                        return DDHAL_DRIVER_HANDLED;
                    }

#ifdef MEMORY_ACTIVITY_CAPTURE
                    {
                        for (DWORD a = 0; a < dwSize; a += 4096)
                        {
                            *(DWORD*)(pVertexBuffer->getAddress() + a) = 0xaaaa1111;
                        }
                    }
#endif

                }
                else
                {
                    NvReleaseSemaphore(pDriverData);
                    DPF ("D3DCreateExecuteBuffer32: failed to create CNvObject object");
                    dbgD3DError();
                    pCreateSurfaceData->ddRVal = DDERR_OUTOFMEMORY;
                    dbgTracePop();
                    return DDHAL_DRIVER_HANDLED;
                }

                //
                // tag as dx6 vb
                //
                if (bIsDX6)
                {
                    pVertexBuffer->tagDX6();
                }

                /*
                 * all VBs are renameable
                 */
                if (bAllowRenaming)
                { 
                    pVertexBuffer->tagRenameEnable (CComplexSurface<TOTAL_VB_RENAME>::RENAME_DO_NOTHING);
                }

                //
                // tag flags
                //
                if (bIsImplicit) pVertexBuffer->tagD3DImplicit();

                /*
                 * tell the world
                 */
                DPF_LEVEL (NVDBG_LEVEL_SURFACE, "VB [%08x] created: [%s] incaps=0x%08x, addr=0x%08x ctxdma=%d size=%d pNvObj=%08x",
                           pVertexBuffer,
                           bIsImplicit ? "implicit" : "normal",
                           lpSurf->ddsCaps.dwCaps,
                           pVertexBuffer->getAddress(),
                           pVertexBuffer->getContextDMA(),
                           lpSurf->lpGbl->dwLinearSize,
                           pNvObj);

                /*
                 * populate DDraw
                 */
                pNvObj->setObject (CNvObject::NVOBJ_VERTEXBUFFER, pVertexBuffer);
                SET_PNVOBJ (lpSurf, pNvObj);
                if (global.dwDXRuntimeVersion >= 0x0700) {
                    DPF_LEVEL(NVDBG_LEVEL_SURFACE_ACTIVITY, "Create Vertex Buffer: pDDSLcl = %08x, handle = %02x",
                              lpSurf, lpSurf->lpSurfMore->dwSurfaceHandle);
                }

#ifdef WINNT
                if (pVertexBuffer->getHeapLocation() == CSimpleSurface::HEAP_SYS)
                {
                    lpSurf->lpGbl->fpVidMem = (FLATPTR)pVertexBuffer->getfpVidMem();
                }
                else if (pVertexBuffer->getHeapLocation() == CSimpleSurface::HEAP_AGP)
                {
#ifdef NV_AGP
                    lpSurf->lpGbl->fpVidMem = nvAGPGetUserAddr(pVertexBuffer->getAddress());
#else
                    lpSurf->lpGbl->lpVidMemHeap = ppdev->AgpHeap;
                    lpSurf->lpGbl->fpHeapOffset = pVertexBuffer->getfpVidMem() + pDriverData->GARTLinearHeapOffset;
#endif
                }
                else
#endif
                {
#ifdef WINNT
                    lpSurf->lpGbl->fpHeapOffset  = pVertexBuffer->getfpVidMem();
#endif
                    lpSurf->lpGbl->fpVidMem = pVertexBuffer->getfpVidMem();
                }
#ifdef MCFD
                lpSurf->ddsCaps.dwCaps  = pVertexBuffer->m_blockList.modifyDDCaps(lpSurf->ddsCaps.dwCaps);
#else
                lpSurf->ddsCaps.dwCaps  = pVertexBuffer->getSurface()->modifyDDCaps(lpSurf->ddsCaps.dwCaps);
#endif

#ifndef WINNT
                //
                // must tell dx if it ended up in sysmem (cannot use DDSCAPS_SYSTEMMEMORY)
                //
#ifdef MCFD
                if (!pVertexBuffer->hwCanRead())
                {
                    lpSurf->lpGbl->dwGlobalFlags |= DDRAWISURFGBL_SYSMEMEXECUTEBUFFER;
                }
#else
                if (!pVertexBuffer->getSurface()->hwCanRead())
                {
                    lpSurf->lpGbl->dwGlobalFlags |= DDRAWISURFGBL_SYSMEMEXECUTEBUFFER;
                }
#endif
#endif // WINNT
            }
            else if (lpSurf->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_COMMANDBUFFER)
            {
                /*
                 * create a command buffer
                 */
#ifndef WINNT   // WINNT BUG what about pid?
                CNvObject      *pNvObj = new CNvObject (lpSurf->dwProcessId);
#else   // WINNT
                CNvObject      *pNvObj = new CNvObject (0);
#endif  // WINNT
                CCommandBuffer *pCommandBuffer;

                if (pNvObj)
                {
                    pCommandBuffer = new CCommandBuffer(pNvObj,lpSurf);
                    if (!pCommandBuffer)
                    {
                        pNvObj->release();
                        NvReleaseSemaphore(pDriverData);
                        DPF ("D3DCreateExecuteBuffer32: failed to create CCommandBuffer object");
                        dbgD3DError();
                        pCreateSurfaceData->ddRVal = DDERR_OUTOFVIDEOMEMORY;
                        dbgTracePop();
                        return DDHAL_DRIVER_HANDLED;
                    }

                    /*
                     * allocate the actual memory
                     */
                    pNvObj->setObject (CNvObject::NVOBJ_COMMANDBUFFER, pCommandBuffer);
                    SET_PNVOBJ (lpSurf, pNvObj);

                    if (!pCommandBuffer->create(lpSurf->lpGbl->dwLinearSize))
                    {
                        pNvObj->release();
                        NvReleaseSemaphore(pDriverData);
                        DPF ("D3DCreateExecuteBuffer32: failed to create CCommandBuffer surface");
                        dbgD3DError();
                        pCreateSurfaceData->ddRVal = DDERR_OUTOFMEMORY;
                        dbgTracePop();
                        return DDHAL_DRIVER_HANDLED;
                    }
                }
                else
                {
                    NvReleaseSemaphore(pDriverData);
                    DPF ("D3DCreateExecuteBuffer32: failed to create CNvObject object");
                    dbgD3DError();
                    pCreateSurfaceData->ddRVal = DDERR_OUTOFMEMORY;
                    dbgTracePop();
                    return DDHAL_DRIVER_HANDLED;
                }
                /*
                 * populate DDraw
                 */
                // Command buffers are always system mem, have to change this code if that ever changes.

                lpSurf->lpGbl->fpVidMem = (FLATPTR)pCommandBuffer->getSurface()->getfpVidMem();
                lpSurf->ddsCaps.dwCaps        = pCommandBuffer->getSurface()->modifyDDCaps(lpSurf->ddsCaps.dwCaps);

#ifndef WINNT   // WINNT BUG what do we do here? ANSWER: nothing, DX6 not supported under NT
                lpSurf->lpGbl->dwGlobalFlags |= DDRAWISURFGBL_SYSMEMEXECUTEBUFFER; // must tell dx6 that it ended up in sysmem
#endif  // !WINNT
                /*
                 * tell the world
                 */
                DPF_LEVEL (NVDBG_LEVEL_SURFACE, "Command buffer [%08x] created at 0x%08x, size %d bytes (pNvObj=%08x)",
                           pCommandBuffer,lpSurf->lpGbl->fpVidMem,lpSurf->lpGbl->dwLinearSize,pNvObj);
            }

            else if (lpSurf->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_INDEXBUFFER)
            {
                //just use the default VB create for now.
                bForceSysMem = TRUE;
                goto allocVertexBuffer;
            }

            else
            {
                //
                // Implicit VBs on DX6 MUST be in system memory
                //
                bIsImplicit = TRUE;
                if (bIsDX6)
                {
                    bForceSysMem = TRUE;
                }

                //
                // alloc.
                // use archaic beginners all-purpose symbolic instruction code logic to achieve this.
                //
                goto allocVertexBuffer;
            }
        }

        else
        {
            /*
             * foreign request - we cannot honor
             */
            NvReleaseSemaphore(pDriverData);
            pCreateSurfaceData->ddRVal = DDERR_INVALIDCAPS;
            dbgTracePop();
            return DDHAL_DRIVER_HANDLED;
        }
    }

    NvReleaseSemaphore(pDriverData);
    pCreateSurfaceData->ddRVal = DD_OK;
    dbgTracePop();
    return DDHAL_DRIVER_HANDLED;
}

/*****************************************************************************
 * D3DDestroyExecuteBuffer32
 *
 * D3D callback to destroy an execute, vertex or command buffer
 */
DWORD __stdcall D3DDestroyExecuteBuffer32
(
    LPDDHAL_DESTROYSURFACEDATA pDestroySurfaceData
)
{
    dbgTracePush ("D3DDestroyExecuteBuffer32");

    /*
     * get driver context
     */
    nvSetDriverDataPtrFromDDGbl (pDestroySurfaceData->lpDD);

    //check for mode switch notification
    /*
    //This is commented out due to a MS kernel bug.  On A CTRL-ALT-DELETE, this
    //bit will be a random value.  This causes the app to get an invalid VB pointer
    //and fault. re-enable for Win2K SP2/Whistler

    if (global.dwDXRuntimeVersion >= 0x0700 && pDestroySurfaceData->lpDDSurface->dwFlags & DDRAWISURF_INVALID) {
        //not a true destroy, just notification of lost VB.
        //go ahead and exit?
        pDestroySurfaceData->lpDDSurface->lpGbl->fpVidMem = 0;
        NvReleaseSemaphore(pDriverData);
        pDestroySurfaceData->ddRVal = DD_OK;
        dbgTracePop();
        return (DDHAL_DRIVER_HANDLED);
    }
    */
    /*
     * extract surface to destroy
     */
    CNvObject *pNvObj = GET_PNVOBJ (pDestroySurfaceData->lpDDSurface);

    // pNvObj will be NULL if we voluntarily bailed out on the creation
    // (we sometimes do this for performance reasons)
    if (pNvObj) {

        switch (pNvObj->getClass())
        {
            /*
             * destroy vertex buffer
             */
            case CNvObject::NVOBJ_VERTEXBUFFER:
            case CNvObject::NVOBJ_COMMANDBUFFER:
            {
#ifdef DEBUG
                if (pNvObj->getClass() == CNvObject::NVOBJ_VERTEXBUFFER)
                {
                    CVertexBuffer *pVertexBuffer = pNvObj->getVertexBuffer();
                    DPF_LEVEL (NVDBG_LEVEL_SURFACE, "Vertex buffer about to be destroyed (pNvObj=%08x, pVB=%08x)",
                        pNvObj,pVertexBuffer);
                }
                else
                {
                    CCommandBuffer *pCommandBuffer = pNvObj->getCommandBuffer();
                    DPF_LEVEL (NVDBG_LEVEL_SURFACE, "Command buffer about to be destroyed (pNvObj=%08x, pCB=%08x)",
                        pNvObj,pCommandBuffer);
                }
                if (global.dwDXRuntimeVersion >= 0x0700) {
                    DPF_LEVEL(NVDBG_LEVEL_SURFACE_ACTIVITY, "Destroy Buffer: pDDSLcl = %08x, handle = %02x",
                              pDestroySurfaceData->lpDDSurface,
                              pDestroySurfaceData->lpDDSurface->lpSurfMore->dwSurfaceHandle);
                }
#endif
                pNvObj->release();

                //
                // update ddraw
                //
                pDestroySurfaceData->lpDDSurface->lpGbl->fpVidMem = 0;
                SET_PNVOBJ (pDestroySurfaceData->lpDDSurface, NULL);
                break;

            }
            /*
             * unknown
             */
            default:
            {
                /*
                 * report error
                 */
                NvReleaseSemaphore(pDriverData);
                DPF ("D3DDestroyExecuteBuffer32: unknown buffer passed in (pNvObj=%08x)",pNvObj);
                dbgD3DError();
                /*
                 * fail
                 */
                pDestroySurfaceData->ddRVal = DDERR_NOTFOUND;
                dbgTracePop();
                return (DDHAL_DRIVER_HANDLED);
            }

        }  // switch

    }  // if...

    /*
     * done
     */
    NvReleaseSemaphore(pDriverData);
    pDestroySurfaceData->ddRVal = DD_OK;
    dbgTracePop();
    return (DDHAL_DRIVER_HANDLED);
}

#ifdef NV_AGP
//
// MS proposed hack for the 6 second delay on mode switch with DX8 SDK apps
// BUGBUG We should not execute this code on Whistler
//
inline void MSAdjustAliasLock(DD_DIRECTDRAW_GLOBAL* lpDD, int iChange)
{
    if ((ppdev->OsVersionInfo.dwMajorVersion == 5ul) && (ppdev->OsVersionInfo.dwMinorVersion == 0ul)) {
        LPDWORD lpTemp = ((DWORD*)lpDD) + 386;
        *lpTemp += iChange;
    }
}
#endif

/*****************************************************************************
 * D3DLockExecuteBuffer32
 *
 * D3D callback to lock an execute, vertex or command buffer
 */
DWORD __stdcall D3DLockExecuteBuffer32
(
    LPDDHAL_LOCKDATA pLockData
)
{
    DWORD dwRetVal;

    dbgTracePush ("D3DLockExecuteBuffer32");

    /*
     * get driver context
     */
    nvSetDriverDataPtrFromDDGbl (pLockData->lpDD);

    /*
     * extract surface
     */
    CNvObject *pNvObj = GET_PNVOBJ (pLockData->lpDDSurface);
    nvAssert(pNvObj);

    switch (pNvObj->getClass())
    {
        /*
         * vertex buffer
         */
        case CNvObject::NVOBJ_VERTEXBUFFER:
        {
            CVertexBuffer *pVertexBuffer = pNvObj->getVertexBuffer();

            if (!pVertexBuffer)
            {
                NvReleaseSemaphore(pDriverData);
                DPF ("D3DLockExecuteBuffer32: cannot lock vertex buffer");
                dbgD3DError();
                pLockData->ddRVal = DDERR_NOTFOUND;
                dbgTracePop();
                return DDHAL_DRIVER_HANDLED;
            }

            // should we rename?
            BOOL bRename   = pLockData->dwFlags & DDLOCK_DISCARDCONTENTS;
            BOOL bDontWait = pLockData->dwFlags & DDLOCK_NOOVERWRITE;

                    #ifdef DX7PROPER
                    if (!bRename)
                    {
                        if (!bDontWait)
                        {
                            DPF_LEVEL(NVDBG_LEVEL_PERFORMANCE, "Vertex Buffer didn't use DDLOCK_DISCARDCONTENTS"
                                "or DDLOCK_NOOVERWRITE");
                            PF ("5. Lock called and VB without DDLOCK_DISCARDCONTENTS.");
                        }
                    }

                    if (bRename && bDontWait)
                    {
                        DPF_LEVEL(NVDBG_LEVEL_PERFORMANCE, "Vertex Buffer used both DDLOCK_DISCARDCONTENTS"
                                "and DDLOCK_NOOVERWRITE at the same time");
                    }
                    #endif

            // lock and rename
                    #ifdef NV_PROFILE_CPULOCK
                    NVP_START (NVP_T_VB_LOCK);
                    #endif

#ifdef DEBUG
            DWORD dwOldAddress, dwNewAddress;
            if (bRename) {
                dwOldAddress = pVertexBuffer->getAddress();
            }
#endif

            if (!bDontWait)
            {
                DDLOCKINDEX(NVSTAT_LOCK_VB);
#ifdef MCFD


/////// a different approach is 

// DDLOCK_DISCARDCONTENTS don't trigger a copy if a renaming occurs
// DDLOCK_NOOVERWRITE --> means READ_ONLY         

                //not finished (Paul, don't look at this code !! )

                if (pLockData->dwFlags & DDLOCK_NOOVERWRITE)
                    pVertexBuffer->LockForCPU(CSimpleSurface::LOCK_READ);
                else
                {
                    if (pLockData->dwFlags & DDLOCK_DISCARDCONTENTS)
                        pVertexBuffer->LockForCPU(CSimpleSurface::LOCK_WRITE);
                    else
                        pVertexBuffer->LockForCPU(CSimpleSurface::LOCK_WRITE, RENAME_POLICY_COPY);
                }

#else
                pVertexBuffer->cpuLock (bRename ? CSimpleSurface::LOCK_RENAME
                                                : CSimpleSurface::LOCK_NORMAL);
#endif
            }

#ifdef DEBUG
            if (bRename) {
                dwNewAddress = pVertexBuffer->getAddress();
                DPF_LEVEL (NVDBG_LEVEL_SURFACE, "VB renamed: %08x -> %08x", dwOldAddress, dwNewAddress);
            }
#endif

            // handles cases where we get dp2 calls before the unlock
            if (bRename){
                pVertexBuffer->tagModified();
            }
                    #ifdef NV_PROFILE_CPULOCK
                    NVP_STOP (NVP_T_VB_LOCK);
                    nvpLogTime (NVP_T_VB_LOCK,nvpTime[NVP_T_VB_LOCK]);
                    #endif

            /*
             * update ddraw
             */
            if (pVertexBuffer->getHeapLocation() == CSimpleSurface::HEAP_SYS)
            {
                pLockData->lpSurfData                   = (void*)pVertexBuffer->getAddress();
                pLockData->lpDDSurface->lpGbl->fpVidMem = (DWORD)pLockData->lpSurfData;
                dwRetVal = DDHAL_DRIVER_HANDLED;
            }
#ifdef WINNT
            else if (pVertexBuffer->getHeapLocation() == CSimpleSurface::HEAP_AGP)
            {
#ifdef NV_AGP
                MSAdjustAliasLock(pLockData->lpDD, 1);
                pVertexBuffer->tagAliasLocked();
                pLockData->lpSurfData = (void *)nvAGPGetUserAddr(pVertexBuffer->getAddress());
                DPF_LEVEL(NVDBG_LEVEL_NV_AGP, "Locking agp VB (%08x), fpVidMem = %08x", pVertexBuffer, pLockData->lpSurfData);
#else
                pLockData->lpDDSurface->lpGbl->fpVidMem    -= pLockData->lpDDSurface->lpGbl->fpHeapOffset; //hack
                pLockData->lpDDSurface->lpGbl->lpVidMemHeap = ppdev->AgpHeap;
                pLockData->lpDDSurface->lpGbl->fpHeapOffset = pVertexBuffer->getfpVidMem() + pDriverData->GARTLinearHeapOffset;
                pLockData->lpDDSurface->lpGbl->fpVidMem    += pLockData->lpDDSurface->lpGbl->fpHeapOffset; //hack
                pLockData->lpSurfData = (void *)pLockData->lpDDSurface->lpGbl->fpVidMem; //hack
#endif
                dwRetVal = DDHAL_DRIVER_HANDLED; //hack should be NOTHANDLED
            }
#endif
            else //video
            {
                pLockData->lpSurfData                   = (void*)pVertexBuffer->getfpVidMem();
                pLockData->lpDDSurface->lpGbl->fpVidMem = pVertexBuffer->getfpVidMem();
#if WINNT
                pLockData->lpDDSurface->lpGbl->fpHeapOffset = pVertexBuffer->getfpVidMem();
                pLockData->lpSurfData = (void *)((LPBYTE)pLockData->lpSurfData + pLockData->fpProcess); //hack
                pLockData->lpDDSurface->lpGbl->fpVidMem += pLockData->fpProcess; //hack
#endif
                dwRetVal = DDHAL_DRIVER_HANDLED; //hack should be NOTHANDLED
            }

            //
            // update our state
            //
            pVertexBuffer->tagD3DLocked();
            pVertexBuffer->bumpLockCount();
            break;
        }
        /*
         * command buffer
         */
        case CNvObject::NVOBJ_COMMANDBUFFER:
        {
            CCommandBuffer *pCommandBuffer = pNvObj->getCommandBuffer();

            if (!pCommandBuffer)
            {
                NvReleaseSemaphore(pDriverData);
                DPF ("D3DLockExecuteBuffer32: cannot lock command buffer");
                dbgD3DError();
                pLockData->ddRVal = DDERR_NOTFOUND;
                dbgTracePop();
                return DDHAL_DRIVER_HANDLED;
            }

            /*
             * lock
             */
            DDLOCKINDEX(NVSTAT_LOCK_EXECUTE_BUFFER);
            pCommandBuffer->cpuLock (CSimpleSurface::LOCK_NORMAL);

            /*
             * update ddraw
             */
            pLockData->lpSurfData                   = (void*)pCommandBuffer->getAddress();
            pLockData->lpDDSurface->lpGbl->fpVidMem = (DWORD)pLockData->lpSurfData;
            dwRetVal = DDHAL_DRIVER_HANDLED;
            break;
        }
        /*
         * unknown
         */
        default:
        {
            /*
             * report error
             */
            DPF ("D3DLockExecuteBuffer32: unknown buffer passed in (pNvObj=%08x)",pNvObj);
            dbgD3DError();
            /*
             * fail
             */
            NvReleaseSemaphore(pDriverData);
            pLockData->ddRVal = DDERR_NOTFOUND;
            dbgTracePop();
            return DDHAL_DRIVER_HANDLED;
        }
    }

    /*
     * done
     */
    NvReleaseSemaphore(pDriverData);
    pLockData->ddRVal = DD_OK;
    dbgTracePop();
    return dwRetVal;
}

/*****************************************************************************
 * D3DUnlockExecuteBuffer32
 *
 * D3D callback to unlock an execute, vertex or command buffer
 */
DWORD __stdcall D3DUnlockExecuteBuffer32
(
    LPDDHAL_UNLOCKDATA pUnlockData
)
{
    dbgTracePush ("D3DUnlockExecuteBuffer32");

    /*
     * get driver context
     */
    nvSetDriverDataPtrFromDDGbl (pUnlockData->lpDD);

    /*
     * extract surface
     */
    CNvObject *pNvObj = GET_PNVOBJ (pUnlockData->lpDDSurface);
    

    //bend attempts to unlock an invalid buffer after a few mode switches. FS
    switch (pNvObj ? pNvObj->getClass() : 0)
    {
        /*
         * vertex buffer
         */
        case CNvObject::NVOBJ_VERTEXBUFFER:
        {
            CVertexBuffer *pVertexBuffer = pNvObj->getVertexBuffer();

            if (!pVertexBuffer)
            {
                NvReleaseSemaphore(pDriverData);
                DPF ("D3DUnlockExecuteBuffer32: cannot unlock Vertex buffer");
                dbgD3DError();
                pUnlockData->ddRVal = DDERR_NOTFOUND;
                dbgTracePop();
                return DDHAL_DRIVER_HANDLED;
            }

            // unlock
#ifdef MCFD
            pVertexBuffer->UnlockForCPU();
#else
            pVertexBuffer->cpuUnlock();
#endif
            // update our state
            pVertexBuffer->tagD3DUnlocked();
            pVertexBuffer->tagModified();
            if (pVertexBuffer->getLockCount() > 1)
            {
                pVertexBuffer->destroySuperTriLookAsideBuffer();
                pVertexBuffer->tagDynamic();
            }

#ifdef NV_AGP
            if (pVertexBuffer->isAliasLocked()) {
                MSAdjustAliasLock(pUnlockData->lpDD, -1);
                pVertexBuffer->tagNotAliasLocked();
            }
            DPF_LEVEL(NVDBG_LEVEL_NV_AGP, "Unlocking agp VB (%08x), fpVidMem = %08x", pVertexBuffer, pVertexBuffer->getAddress());
#endif

            // capture
#ifdef CAPTURE
            if (getDC()->nvD3DRegistryData.regCaptureEnable & D3D_REG_CAPTUREENABLE_RECORD) {
                CAPTURE_MEMORY_WRITE memwr;
                memwr.dwJmpCommand         = CAPTURE_JMP_COMMAND;
                memwr.dwExtensionSignature = CAPTURE_EXT_SIGNATURE;
                memwr.dwExtensionID        = CAPTURE_XID_MEMORY_WRITE;
                memwr.dwCtxDMAHandle       = (pVertexBuffer->getHeapLocation() == CSimpleSurface::HEAP_VID)
                                           ? NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY
                                           : D3D_CONTEXT_DMA_HOST_MEMORY;
                memwr.dwOffset             = pVertexBuffer->getOffset();
                memwr.dwSize               = pVertexBuffer->getSize();
                captureLog (&memwr,sizeof(memwr));
                captureLog ((void*)pVertexBuffer->getAddress(),memwr.dwSize);
            }
#endif

#if (NVARCH >= 0x020)
            if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {
                nvglSetNv20KelvinInvalidateVertexCache (NV_DD_KELVIN);
            }
            else
#endif
#if (NVARCH >= 0x010)
            if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS) {
                nvglSetNv10CelsiusInvalidateVertexCache (NV_DD_CELSIUS);
            }
#endif

            break;
        }
        /*
         * command buffer
         */
        case CNvObject::NVOBJ_COMMANDBUFFER:
        {
            CCommandBuffer *pCommandBuffer = pNvObj->getCommandBuffer();

            if (!pCommandBuffer)
            {
                NvReleaseSemaphore(pDriverData);
                DPF ("D3DUnlockExecuteBuffer32: cannot unlock command buffer");
                dbgD3DError();
                pUnlockData->ddRVal = DDERR_NOTFOUND;
                dbgTracePop();
                return DDHAL_DRIVER_HANDLED;
            }

            /*
             * unlock
             */
            pCommandBuffer->cpuUnlock();
            break;
        }
        /*
         * unknown
         */
        default:
        {
            /*
             * report error
             */
            NvReleaseSemaphore(pDriverData);
            DPF ("D3DUnlockExecuteBuffer32: unknown buffer passed in (pNvObj=%08x)",pNvObj);
            dbgD3DError();
            /*
             * fail
             */
            pUnlockData->ddRVal = DDERR_NOTFOUND;
            dbgTracePop();
            return DDHAL_DRIVER_HANDLED;
        }
    }

    /*
     * done
     */
    NvReleaseSemaphore(pDriverData);
    pUnlockData->ddRVal = DD_OK;
    dbgTracePop();
    return DDHAL_DRIVER_HANDLED;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\src\nvVideoPort.cpp ===
/***************************************************************************\
* (C) Copyright NVIDIA Corporation Inc.,                                    *
*  1996,1997, 1998. All rights reserved.                                    *
*                                                                           *
* Module: nvVideoPort.cpp                                                   *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       schaefer           3/26/98                                          *
*                                                                           *
\***************************************************************************/

#include "nvprecomp.h"

#pragma hdrstop

volatile U032*  nvTimerPtr = NULL;
vpSurfaces*         pMySurfaces = NULL;
NvNotification* nvMyVPNotifiers = NULL;

#if (!defined(WINNT) && !defined(NVPE))   // WINNT BUG

const DWORD MY_CONNECTION_CAPS= //DDVPCONNECT_DOUBLECLOCK           |
                                            //DDVPCONNECT_VACT                  |
                                            /* we're capable of inverting the polarity */
                                            DDVPCONNECT_INVERTPOLARITY      |
                                            /* we discard at least until the V bit goes low, and potentially more depending
                                              on the setting of YCROP  as well as the current VBI situation  */
                                            //DDVPCONNECT_DISCARDSVREFDATA  |
                                            /* we WILL count the halfline */
                                            DDVPCONNECT_HALFLINE                |
                                            /*  these next are "client" only
                                            //DDVPCONNECT_INTERLACED            |
                                            //DDVPCONNECT_SHAREEVEN         |
                                            //DDVPCONNECT_SHAREODD              |
                                            */
                                            0;

DDPIXELFORMAT pf[] = {
    {sizeof(DDPIXELFORMAT),DDPF_FOURCC,  mmioFOURCC('U','Y','V','Y'),16,(DWORD)-1,(DWORD)-1,(DWORD)-1},
};
/*DDPIXELFORMAT pfvbi[] = {
    {sizeof(DDPIXELFORMAT),DDPF_FOURCC,  mmioFOURCC('R','A','W','8'),8,(DWORD)-1,(DWORD)-1,(DWORD)-1},
};
*/
DDPIXELFORMAT pfvbi[] = {
    {sizeof(DDPIXELFORMAT),DDPF_FOURCC,  mmioFOURCC('R','A','W','8'),8,(DWORD)-1,(DWORD)-1,(DWORD)-1},
};


//#define TESTCALLBACK
#ifdef TESTCALLBACK

void JoeCoolDudesCallbackRoutine(sCallBack* pCallbackStruct);

#endif

U032    getMilliTime(void);


void    getCurrentNanoTimer(U032 *  Most, U032 * Least) {
    volatile U032* myTimerLo = nvTimerPtr;
    volatile U032* myTimerHi = (U032*)(((U032)nvTimerPtr)+0x10);
    ASSERT(nvTimerPtr != NULL);
    ASSERT(Most         != NULL);
    ASSERT(Least        != NULL);
    if(nvTimerPtr!=NULL) {
        *Least = *myTimerLo;
        *Most   = *myTimerHi;
    } else {
        *Least = 0;
        *Most   = 0;
    }
}

U032    getMilliTime(void) {
    U032    bigTime;
    U032    smallTime;

    getCurrentNanoTimer(&bigTime, &smallTime);
    return (smallTime / 1000000) + bigTime * (0xFFFFFFFF/1000000);

}

/*

It appears that BPC has been programmd in such a way as to violate the API for VP.
So we need to compensate.  The problem is that the following scenario can happen.
CanCreateVP   VBI
CreateVP   VBI
UpdateVP   VBI
time passes
CanCreateVP   IMAGE
CreateVP  Image
UpdateVP   VBI+Image
timepasses
Destroy VP.

The key thing here is that the video ports will use the SAME port ID. so that should help us.


*/

DWORD __stdcall CanCreateVideoPort32 (LPDDHAL_CANCREATEVPORTDATA lpInput)
{
    /*
     * If the lpInput->lpDDVideoPortDesc can not be supported, set
     * lpInput->ddRVal to the correct error code and return
     * DDHAL_DRIVER_HANDLED
     */
    /*  this is only a query to see if VideoPort can handle a certain requirement,
        no structures are defined here, or even chip query */
    DPF("***CanCreateVideoPort32");

    ASSERT(lpInput!=NULL);
    ASSERT(lpInput->lpDDVideoPortDesc !=NULL);

    if( pDriverData == NULL ) {
        DPF("   ***VideoPort not creatable  -->  pDriverData = NULL!   YIKES!");
        lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
        return DDHAL_DRIVER_HANDLED;
    }
    // Ok, if we got to here that means we're talking to the VXD MiniVDD properly... onward ho!

    // Check structure size
    if(lpInput->lpDDVideoPortDesc->dwSize   < sizeof( DDVIDEOPORTDESC ) ) {
        DPF("   ***VideoPort not creatable  -->  stucture length is not large enough");
        lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
        return DDHAL_DRIVER_HANDLED;
    }

    // check input connection GUID
    if ( !IsEqualGUID_C((lpInput->lpDDVideoPortDesc->VideoPortType.guidTypeID), DDVPTYPE_CCIR656) )  {
        DPF("   ***VideoPort not creatable  -->  GUID should be DDVPTYPE_CCIR656");
        lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
        return DDHAL_DRIVER_HANDLED;
    }

    // check to see if there are ports available... by looking at local allocation
    if (pDriverData->dwVideoPortsAvailable <=0 ) {

            // check to see if there are ports available... by looking at IDs
       if (lpInput->lpDDVideoPortDesc->dwVideoPortID != 0 ) {
            DPF("   ***VideoPort not creatable  --> not enough video ports");
            lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
            return DDHAL_DRIVER_HANDLED;
        }

        DPF("CanCreate for Second VP with same ID Allowed.... silly API");
    }

    //
    // NV4/5 and NV10 have different hardware limitations
    //
    // Added height checking since "width*height check" has test escapes

    if (pDriverData->NvDeviceVersion < NV_DEVICE_VERSION_10) {

        if (lpInput->lpDDVideoPortDesc->dwFieldWidth > NV4_MAX_FIELDWIDTH) {
            DPF("   ***VideoPort not creatable  --> field Width is too great");
            lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
            return DDHAL_DRIVER_HANDLED;
        }

        if (lpInput->lpDDVideoPortDesc->dwVBIWidth > NV4_MAX_VBIWIDTH) {
            DPF("   ***VideoPort not creatable  --> VBI field Width is too great");
            lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
            return DDHAL_DRIVER_HANDLED;
        }
        
        if (lpInput->lpDDVideoPortDesc->dwFieldHeight > NV4_MAX_FIELDHEIGHT) {
            DPF("   ***VideoPort not creatable  --> field Height is too great");
            lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
            return DDHAL_DRIVER_HANDLED;
        }

        if (lpInput->lpDDVideoPortDesc->dwFieldHeight * lpInput->lpDDVideoPortDesc->dwFieldWidth > NV4_MAX_BUFFERLENGTH) {
            DPF("   ***VideoPort not creatable  --> Maximum buffer length exceed by field height too high");
            lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
            return DDHAL_DRIVER_HANDLED;
        }

        if (lpInput->lpDDVideoPortDesc->dwMaxPixelsPerSecond > NV4_MAX_PIXELRATE) {
            DPF("   ***VideoPort not creatable  --> Sorry incoming data rate is too high");
            lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
            return DDHAL_DRIVER_HANDLED;
        }

        if (lpInput->lpDDVideoPortDesc->VideoPortType.dwPortWidth != 8) {
            DPF("   ***VideoPort not creatable  --> incoming connection width is not 8 bits");
            lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
            return DDHAL_DRIVER_HANDLED;
        }

    }
    else {

        if (lpInput->lpDDVideoPortDesc->dwFieldWidth > NV10_MAX_FIELDWIDTH) {
            DPF("   ***VideoPort not creatable  --> field Width is too great");
            lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
            return DDHAL_DRIVER_HANDLED;
        }

        if (lpInput->lpDDVideoPortDesc->dwVBIWidth > NV10_MAX_VBIWIDTH) {
            DPF("   ***VideoPort not creatable  --> VBI field Width is too great");
            lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
            return DDHAL_DRIVER_HANDLED;
        }

        if (lpInput->lpDDVideoPortDesc->dwFieldHeight > NV10_MAX_FIELDHEIGHT) {
            DPF("   ***VideoPort not creatable  --> field Height is too great");
            lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
            return DDHAL_DRIVER_HANDLED;
        }

        if (lpInput->lpDDVideoPortDesc->dwFieldHeight * lpInput->lpDDVideoPortDesc->dwFieldWidth > NV10_MAX_BUFFERLENGTH) {
            DPF("   ***VideoPort not creatable  --> Maximum buffer length exceed by field height too high");
            lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
            return DDHAL_DRIVER_HANDLED;
        }

        if (lpInput->lpDDVideoPortDesc->dwMaxPixelsPerSecond > NV10_MAX_PIXELRATE) {
            DPF("   ***VideoPort not creatable  --> Sorry incoming data rate is too high");
            lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
            return DDHAL_DRIVER_HANDLED;
        }

        if ( !((lpInput->lpDDVideoPortDesc->VideoPortType.dwPortWidth  == 8 ) ||
               (lpInput->lpDDVideoPortDesc->VideoPortType.dwPortWidth  == 16 )) ) {
            DPF("   ***VideoPort not creatable  --> incoming connection width is not 8 or 16 bits");
            lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
            return DDHAL_DRIVER_HANDLED;
        }

    }

#ifdef NOCHECKHERE
            // the ones I'm not capable of   ANDed   with the ones Dx is asking for
    if( (~MY_CONNECTION_CAPS) & lpInput->lpDDVideoPortDesc->VideoPortType.dwFlags ) {
        // if we get here this should indicate that Dx is asking for a capability we're incapable of
        DPF("   ***VideoPort not creatable  --> Some of the capability flags bits are wrong");
        lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
        return DDHAL_DRIVER_HANDLED;

    }
#endif

    //  Ok, we've pretty much checked everything we can possibly check here... let's tell'em that
    // we can work!

    lpInput->ddRVal = DD_OK;
    DPF("   ***VideoPort creatable! ***");
    return DDHAL_DRIVER_HANDLED;
}


U032    HookUpVxdStorage(void) {


    HANDLE      aVXDHandle;
    U032 i;

    DPF("NOW ATTEMPTING VXD stuff");



    DPF("\n\n\n\nThe DeviceID is:%d\n\n\n\n",pDriverData->thisDeviceID);

    if( pDriverData->thisDeviceID == 0 ) {
        DPF("We are Primary controller! \n");
#ifdef NV3
        aVXDHandle = NvCreateFile(NV3_PRIMARY_MINIVDD, 0,FILE_SHARE_READ,0, CREATE_NEW, FILE_FLAG_DELETE_ON_CLOSE, 0);
#else
        aVXDHandle = NvCreateFile(NVX_PRIMARY_MINIVDD, 0,0,0, CREATE_NEW, FILE_FLAG_DELETE_ON_CLOSE, 0);
#endif
    } else {
        DPF("We are not primary controller :-( \n");
#ifdef NV3
        aVXDHandle = NvCreateFile(NV3_SECONDARY_MINIVDD, 0,FILE_SHARE_READ,0, CREATE_NEW, FILE_FLAG_DELETE_ON_CLOSE, 0);
#else
        aVXDHandle = NvCreateFile(NVX_SECONDARY_MINIVDD, 0,0,0, CREATE_NEW, FILE_FLAG_DELETE_ON_CLOSE, 0);
#endif
    }

    if((aVXDHandle == NULL) || (aVXDHandle ==INVALID_HANDLE_VALUE)) {
        U032    daError;
        DPF("Can't get Vxd handle   :-(");
        daError = GetLastError();
        DPF("The error was %d  or %x",daError,daError);
        if(daError == 50 ) {
            DPF("Which means most likely that you don't have a version of NVX.VXD or NVXmini2 which supports IOCTL");
        }
        return FALSE;

    }

    // nother block
    {
        U032                inBuffer;
        NVVDDPROCTABLE  aTable;
        U032                outputSize = 0;

        // pass in the pointer to the direct draw object.. this may be useful later
//      inBuffer = (U032) lpInput->lpDD;

        aTable.getStoragePointer = NULL;
        aTable.dwPDDDriver = 0;
        aTable.handleBufferInterrupts = NULL;

        if(DeviceIoControl(aVXDHandle,
                            VDD_IOCTL_NV_FILLTABLE,     // control code of operation to perform
                            &inBuffer,                          // pointer to buffer to supply input data
                            4,                              // size of input buffer
                            &aTable,                    // pointer to buffer to receive output data
                            sizeof(NVVDDPROCTABLE), // size of output buffer
                            &outputSize,                // pointer to variable to receive output byte count
                            NULL                            // pointer to overlapped structure for asynchronous operation
        ) ){
            // cool we made it.   Now copy our temporarly stuff into the real one!

            // first get the storage pointer
            if( aTable.getStoragePointer != NULL ) {
                pMySurfaces = (vpSurfaces*)(aTable.getStoragePointer)();
            } else {
                DPF("didn't get a valid pointer to a routine");

                NvCloseHandle(aVXDHandle);
                return FALSE;
            }

            if( pMySurfaces != NULL ) {
                // we cool!  everybody get funky one more time!  and copy that stuff in
                pMySurfaces->myVXDhandle = aVXDHandle;
                memcpy (&pMySurfaces->myTable, &aTable,  sizeof (NVVDDPROCTABLE));
                NvCloseHandle(aVXDHandle);

            } else {
                DPF("didn't get the storage pointer");

                NvCloseHandle(aVXDHandle);
                return FALSE;
            }

        }   else {
            //  failure
            //close the VXD
            DPF("couldn't call the VXD via IOCTL properly");
            NvCloseHandle(aVXDHandle);
            return FALSE;
        }

    }


    nvMyVPNotifiers = pMySurfaces->pTheNotifiers;
    pMySurfaces->numberOfSurfaces =0;

    for(i=0;i<MAXVPSURFACES;i++) {
        pMySurfaces->Surfaces[i] = NULL;
    }
    pMySurfaces->CurrentBufferSurface[4] = NOSURFACEPROGRAMED;              // to associate the HW buffer with an arrary index

    pMySurfaces->CurrentScanMode =SEPERATEBUF;      // seperate or interleaved buffersx
    if(pMySurfaces->bInvertedFields )   {
        pMySurfaces->lastField = ODD;   // this should be even so we'll always start on odd ( hopefully... :-)
        pMySurfaces->lastVBIField = ODD;
    } else {
        pMySurfaces->lastField = EVEN;
        pMySurfaces->lastVBIField = EVEN;
    }
    pMySurfaces->VBIstart = 0;;
    // general information
    pMySurfaces->bSkipNextField = FALSE;
    pMySurfaces->dwInHeight = 0;
    pMySurfaces->dwInWidth = 0;
    pMySurfaces->dwImageStartLine =10;              // ditch a minimum of 10 lines
    pMySurfaces->dwVBIStartLine = 0;
    pMySurfaces->dwVBIHeight = 0;
    pMySurfaces->dwPreHeight = 0;                   // height and width before prescaling
    pMySurfaces->dwPreWidth = 0;
    pMySurfaces->dwOriginX = 0;                     // orgins to move data within the surface
    pMySurfaces->dwOriginY = 0;
    pMySurfaces->bThreadDead = TRUE;
    pMySurfaces->bThreadRunning = FALSE;

    pMySurfaces->bStopVP = FALSE;                           // indicates to the thread that it should NOT reprogram

    pMySurfaces->Timings.LoopCount=0;

    pMySurfaces->pBuffer0Mem = (U032) NULL;
    pMySurfaces->pBuffer1Mem = (U032) NULL;
    pMySurfaces->curOverlay = 0;            // this way we should start into 0

    // initialize all the callback stuff
    pMySurfaces->ImageCallbackRoutine = NULL;
    pMySurfaces->VBICallbackRoutine = NULL;
    pMySurfaces->myIMGCallbackInfo.intCount = 0;
    pMySurfaces->myVBICallbackInfo.intCount = 0;
    pMySurfaces->myIMGCallbackInfo.dwFlags = 0;
    pMySurfaces->myVBICallbackInfo.dwFlags = 0;
    pMySurfaces->myIMGCallbackInfo.dwVersion = 0x100;
    pMySurfaces->myVBICallbackInfo.dwVersion = 0x100;
    pMySurfaces->myIMGCallbackInfo.curBufferAddr = (U032)NULL;
    pMySurfaces->myVBICallbackInfo.curBufferAddr = (U032)NULL;
    pMySurfaces->myIMGCallbackInfo.lastBufferAddr = (U032)NULL;
    pMySurfaces->myVBICallbackInfo.lastBufferAddr = (U032)NULL;
    pMySurfaces->myIMGCallbackInfo.dwSize = sizeof(sCallBack);
    pMySurfaces->myVBICallbackInfo.dwSize = sizeof(sCallBack);
    pMySurfaces->intermediateCycle = 0;
    if(pDriverData == NULL ) {
        // dude this is PROBLEM!!!
        return FALSE;
    }
    pMySurfaces->pDriverData = pDriverData;
    pDriverData->dwMySurfacesPtr = (unsigned long) pMySurfaces;

    pMySurfaces->DXIRQCallbackSources = 0;;
    pMySurfaces->pDXIRQCallback = (U032) NULL;
    pMySurfaces->dwIrqContext = 0;
    pMySurfaces->SetupComplete = FALSE;
    pMySurfaces->dwNextEmpty = 0;
    pMySurfaces->dwLastEmpty = (MAXTRANSFERS-1);
    pMySurfaces->lastSurface = NOSURFACEPROGRAMED;
    pMySurfaces->lastBuffer = NOSURFACEPROGRAMED;


   pMySurfaces->DropSystem.dwTargetSurface = 0;
   pMySurfaces->DropSystem.dwbIsBobFromInterleave = 0;
   pMySurfaces->DropSystem.dwFieldType = 0;
   pMySurfaces->DropSystem.dwFullBool = 0;
   pMySurfaces->DropSystem.dwDropFields = 0;

    pMySurfaces->DropSystem.dwFullBool =FALSE;   // used to indicate that we just dropped a field and the leap frogging should stop for one frame

    // get a pointer to the timer
    nvTimerPtr = (U032 *) NvDeviceBaseGet(NV_DEV_TIMER, pDriverData->dwDeviceIDNum );
    pMySurfaces->pNvTimer = nvTimerPtr;

    return TRUE;
}

/*
 * CreateVideoPort32
 *
 * This function is optional, define all objects if they have not already been defined.
 */
DWORD __stdcall CreateVideoPort32 (LPDDHAL_CREATEVPORTDATA lpInput)
{
    /*
     * This function allows the HAL to set internal flags and
     * become aware that a video port has been created. It should
     * always return DDHAL_DRIVER_NOTHANDLED.
     */

    /* According to DDHAL documentation, this procedure can return DDHAL_DRIVER_NOTHANDLED
       as well, signifying that the createvideoport fn could not be completed

       DirectDraw MS layer will prevent creating more videoports that is
       available.

       */

    DWORD       returnVal = DDHAL_DRIVER_HANDLED;
    DPF("   ***CreateVideoPort32***");
    // we should only have to get this once on creation

    if(pMySurfaces == NULL )
        if(!HookUpVxdStorage() )
        {
            lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
            return DDHAL_DRIVER_HANDLED;
        }
    if( pMySurfaces->pDriverData == NULL )
        if(!HookUpVxdStorage() )
        {
            lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
            return DDHAL_DRIVER_HANDLED;
        }


    if( pMySurfaces->SetupComplete ) {
            // we may be attempting a "second" CreateVideo port with the same ID..
            // let's check that.

            //CODE we should probably check here for non-duplicat VBI and Image, but we'll just let that slide for now.

            if (lpInput->lpDDVideoPortDesc->dwVideoPortID == 0 ) {
                // this is the second create
                DPF("***  HACKED second video port create has been called.");
                DPF("  now shunting to hyperspace modulator bypass code.  Turn reality distortion field driver code to 11");


                DPF("  Size of the DDVIDEOPORTDESC structure     %d",lpInput->lpDDVideoPortDesc->dwSize);
                DPF("  Width of the video port field.            %d",lpInput->lpDDVideoPortDesc->dwFieldWidth);
                DPF("  Width of the VBI data.                    %d",lpInput->lpDDVideoPortDesc->dwVBIWidth);
                DPF("  Height of the video port field.           %d",lpInput->lpDDVideoPortDesc->dwFieldHeight);
                DPF("  Microseconds per video field.             %d",lpInput->lpDDVideoPortDesc->dwMicrosecondsPerField);
                DPF("  Maximum pixel rate per second.            %d",lpInput->lpDDVideoPortDesc->dwMaxPixelsPerSecond);
                DPF("  Video port ID (0 - (dwMaxVideoPorts -1)). %d",lpInput->lpDDVideoPortDesc->dwVideoPortID);
                DPF("  Reserved for future use - set to zero.    %d",lpInput->lpDDVideoPortDesc->dwReserved1);

                DPF("  Size of the DDVIDEOPORTDESC.dwSize        %d",lpInput->lpDDVideoPortDesc->VideoPortType.dwSize);
                DPF("              DDVIDEOPORTDESC.dwPortWidth   %d",lpInput->lpDDVideoPortDesc->VideoPortType.dwPortWidth);
#ifndef __cplusplus
                DPF("              DDVIDEOPORTDESC.guidTypeID    %d",lpInput->lpDDVideoPortDesc->VideoPortType.guidTypeID);
#endif
                DPF("              DDVIDEOPORTDESC.dwFlags       %d",lpInput->lpDDVideoPortDesc->VideoPortType.dwFlags);

                lpInput->ddRVal = DD_OK;
                return returnVal;
            }
    }

    if(lpInput->lpDDVideoPortDesc->VideoPortType.dwFlags & DDVPCONNECT_INTERLACED ) {
        pMySurfaces->bInputInterLaced = TRUE;
    } else {
        pMySurfaces->bInputInterLaced = FALSE;
    }

    if(pMySurfaces->bInputInterLaced)
        pMySurfaces->CurrentCaptureMode =EVENODD;       // indicates which fields will be capture Even
    else
        pMySurfaces->CurrentCaptureMode =PROGRESSIVE;   // we're assuming progressive is ALWAYS even even even



    if(lpInput->lpDDVideoPortDesc->VideoPortType.dwFlags & DDVPCONNECT_INVERTPOLARITY ) {
        DPF("DDVPCONNECT_INVERTPOLARITY     on");
        pMySurfaces->bInvertedFields = TRUE;
        // Now check for the weird exception case when we want to skip half line as well...
        if(lpInput->lpDDVideoPortDesc->VideoPortType.dwFlags & DDVPCONNECT_HALFLINE ) {
            DPF("DDVPCONNECT_HALFLINE       on");
            pMySurfaces->bInvertedFields = FALSE;
        } else {
            DPF("DDVPCONNECT_HALFLINE       off");

        }

    } else {
        DPF("DDVPCONNECT_INVERTPOLARITY     off");
        pMySurfaces->bInvertedFields = FALSE;
    }


    if(lpInput->lpDDVideoPortDesc->VideoPortType.dwFlags & DDVPCONNECT_HALFLINE ) {
        DPF("DDVPCONNECT_HALFLINE             on");
    } else {
        DPF("DDVPCONNECT_HALFLINE             off");
    }


    DPF("***CreateVideoPort32");


    DPF("  Size of the DDVIDEOPORTDESC structure     %d",lpInput->lpDDVideoPortDesc->dwSize);
    DPF("  Width of the video port field.            %d",lpInput->lpDDVideoPortDesc->dwFieldWidth);
    DPF("  Width of the VBI data.                    %d",lpInput->lpDDVideoPortDesc->dwVBIWidth);
    DPF("  Height of the video port field.           %d",lpInput->lpDDVideoPortDesc->dwFieldHeight);
    DPF("  Microseconds per video field.             %d",lpInput->lpDDVideoPortDesc->dwMicrosecondsPerField);
    DPF("  Maximum pixel rate per second.            %d",lpInput->lpDDVideoPortDesc->dwMaxPixelsPerSecond);
    DPF("  Video port ID (0 - (dwMaxVideoPorts -1)). %d",lpInput->lpDDVideoPortDesc->dwVideoPortID);
    DPF("  Reserved for future use - set to zero.    %d",lpInput->lpDDVideoPortDesc->dwReserved1);

    DPF("  Size of the DDVIDEOPORTDESC.dwSize        %d",lpInput->lpDDVideoPortDesc->VideoPortType.dwSize);
    DPF("              DDVIDEOPORTDESC.dwPortWidth   %d",lpInput->lpDDVideoPortDesc->VideoPortType.dwPortWidth);
#ifndef __cplusplus
    DPF("              DDVIDEOPORTDESC.guidTypeID    %d",lpInput->lpDDVideoPortDesc->VideoPortType.guidTypeID);
#endif
    DPF("              DDVIDEOPORTDESC.dwFlags       %d",lpInput->lpDDVideoPortDesc->VideoPortType.dwFlags);

    DPF("   Reserved for future use - set to zero.     %d",lpInput->lpDDVideoPortDesc->dwReserved2);
    DPF("   Reserved for future use - set to zero.     %d",lpInput->lpDDVideoPortDesc->dwReserved3);


    // We'll assume for now that since CanCreate passed that our parameters are valid at this point
    // we need to setup the entire NV object system at this point

    // theorectically we should not have a channel open... let's check that?

    // get our OWN copy of the driver data

    returnVal = SetupVP ( lpInput);


    //pMySurfaces->pVPChanPtr = (NvChannel * ) pDriverData->NvDevFlatVPE;

    // cannot set this as unallocated here since it must be done once per OVERLAY
    // and not once per VP.
    //pDriverData->dwOverlayEventsAllocated = FALSE;


    // For the overlay flip, store away a channel pointer
    pMySurfaces->pOverlayChanPtr = (NvChannel*) pDriverData->NvDevVideoFlatPio;
    pMySurfaces->dwOverlaySubChan = NV_DD_SPARE;
    pMySurfaces->dwOverlayObjectID = NV_DD_YUV422_VIDEO_FROM_MEMORY;
    pMySurfaces->dwScalerObjectID = NV_DD_VIDEO_SCALER;
    //pMySurfaces->dwDVDObjectID = NV_DD_DVD_SUBPICTURE;
    pMySurfaces->dwDVDObjectID = NV_VIDEO_DVD_SUBPICTURE;
#ifdef TESTCALLBACK

    // let's register an IMAGE callback here and see what happens
    {
        HANDLE bVXDHandle;
        U032     inBuffer;
        //U032   returnCode;
        U032     outputSize;
        SETCALLBPROC    pSetCallback;

        inBuffer = 0;

        bVXDHandle = NvCreateFile(NVX_PRIMARY_MINIVDD, 0,0,0, CREATE_NEW, FILE_FLAG_DELETE_ON_CLOSE, 0);

        if(bVXDHandle != NULL ) {
            if(DeviceIoControl(bVXDHandle,
                                        VDD_IOCTL_NV_GETSETCALLBACK,        // control code of operation to perform
                                        &inBuffer,                          // pointer to buffer to supply input data
                                        4,                                      // size of input buffer
                                        &pSetCallback,                      // pointer to buffer to receive output data
                                        4,                                      // size of output buffer
                                        &outputSize,                        // pointer to variable to receive output byte count
                                        NULL                                    // pointer to overlapped structure for asynchronous operation
                                    )
                 ){

                        // things worked, the
                        inSCBStruct     inBuf;
                        outSCBStruct    outBuf;
                            // NOTE USE OF FLAGS FROM VPCALLBk.h
                        inBuf.flags = IMAGESURFACE;
                        inBuf.pTheCallback = JoeCoolDudesCallbackRoutine;

                        (pSetCallback)(&inBuf,&outBuf);

            } else {

                        // bummer, for some reason, we were unable to set your callback

            }

            NvCloseHandle(bVXDHandle);

        }


    }
#endif

    if(nvTimerPtr == NULL) {
        // get a pointer to the timer
        nvTimerPtr = (U032 *) NvDeviceBaseGet(NV_DEV_TIMER, pDriverData->dwDeviceIDNum );
        pMySurfaces->pNvTimer = nvTimerPtr;

    }
#ifdef ENABLE_VPP_DISPATCH_CODE
// This code is no longer used but may someday be useful.

#ifdef USEVPP
    // kick up the VPP process priority
    pDriverData->vppDispatch.dwThreadPriority = pDriverData->vppDispatch.dwOriginalThreadPriority;
    pDriverData->vppDispatch.dwProcessPriority = pDriverData->vppDispatch.dwOriginalProcessPriority;
    //pDriverData->vppDispatch.dwThreadPriority = THREAD_PRIORITY_TIME_CRITICAL;
    //pDriverData->vppDispatch.dwThreadPriority = THREAD_PRIORITY_HIGHEST;
    //pDriverData->vppDispatch.dwProcessPriority = REALTIME_PRIORITY_CLASS  ;
    pDriverData->vppDispatch.dwCommand = VPPDISPATCH_SETPRIORITY;
    SetEvent(pDriverData->vppDispatch.hSignalGo3);
#endif

#endif

    // don't forget to decrement the number of video ports avail number which is
    lpInput->ddRVal = DD_OK;

    return returnVal;
}


#ifdef TESTCALLBACK

void JoeCoolDudesCallbackRoutine(sCallBack* pCallbackStruct) {
    DPF("WoW we made it to JoeCoolDudesCallbackRoutine interrupt=%d",pCallbackStruct->intCount);


}


#endif
 /*
 * GetVideoPortBandwidth32
 *
 * This function is required
 */
DWORD __stdcall GetVideoPortBandwidth32 (LPDDHAL_GETVPORTBANDWIDTHDATA lpInput)
{

    DPF("***GetVideoPortBandwidth32");
    /*
     * Determine how much bandwidth is available for the specified
     * output format and fill in the information.
     */

     // we are lucky in that we basically only support ONE format  YEAH!

    if (lpInput->dwFlags & DDVPB_TYPE) {
        lpInput->lpBandwidth->dwCaps = DDVPBCAPS_DESTINATION;  // we are limited by the "shrink" of the overlay
    }

    if (lpInput->dwFlags & DDVPB_VIDEOPORT) {
        // The following four should indicate the MINIMUM stretch values represented as percentages times 10
        //  so if we could not stretch below 75% of the orginal size, the we should put in 750
        // for now I'll leave these "as is" because I need to collect the correct values -CJS
        lpInput->lpBandwidth->dwOverlay                 = 1000;
        lpInput->lpBandwidth->dwColorkey                = 1000;  // Overlay/video port/colorkey works at 1X
        lpInput->lpBandwidth->dwYInterpolate            = 1000;  // Overlay/video port works at 1X
        lpInput->lpBandwidth->dwYInterpAndColorkey      = 1000;  // Overlay/video port/interpolation works at 2X
    }


    if (lpInput->dwFlags & DDVPB_OVERLAY) {
        DPF("   We are NOT an overlay limited device but a destination ");
        DPF("      limited device we should not have been called");
    }

    lpInput->ddRVal = DD_OK;
    return DDHAL_DRIVER_HANDLED;
}

/*
 * GetVideoPortInputFormat32
 *
 * This function is required
 */
DWORD __stdcall GetVideoPortInputFormat32 (LPDDHAL_GETVPORTINPUTFORMATDATA lpInput)
{
   /* Only 1 input format supported UYVY 4:2:2 */
    /* Data stored in 32bit word as U[7:0] Y1[15:8] V[23:16] Y2[31:24] */
    DPF("   ***GetVideoPortInputFormat32");
    /*
    * The HAL is gaurenteed that the buffer in lpInput->lpddpfFormat
    * is large enough to hold the information
    */


    if (lpInput->dwFlags & DDVPFORMAT_VIDEO ) {
        lpInput->dwNumFormats = 1;
        if (lpInput->lpddpfFormat != NULL) {
            memcpy (lpInput->lpddpfFormat, &pf[0],  sizeof (DDPIXELFORMAT));
        }
    }

/*
    if (lpInput->dwFlags & DDVPFORMAT_VBI ) {
        lpInput->dwNumFormats = 1;
        if (lpInput->lpddpfFormat != NULL) {
            memcpy (lpInput->lpddpfFormat, &pf[0],  sizeof (DDPIXELFORMAT));
        }
    }
*/
    if (lpInput->dwFlags & DDVPFORMAT_VBI ) {
        lpInput->dwNumFormats = 1;
        if (lpInput->lpddpfFormat != NULL) {
            memcpy (lpInput->lpddpfFormat, &pfvbi[0],  sizeof (DDPIXELFORMAT));
        }
    }

    lpInput->ddRVal = DD_OK;
    return DDHAL_DRIVER_HANDLED;
}


/*
 * GetVideoPortOutputFormat32
 *
 * This function is required
 */
DWORD __stdcall GetVideoPortOutputFormat32 (LPDDHAL_GETVPORTOUTPUTFORMATDATA lpInput)
{
    /* OutputFormat does not convert UYUV to RGB, this would be done by Overlay control */
    /* Data stored in 32bit word as U[7:0] Y1[15:8] V[23:16] Y2[31:24] */

    DPF("***GetVideoPortOutputFormat32");

    /* OutputFormat does not convert UYUV to RGB, this would be done by Overlay control */
    /* Data stored in 32bit word as U[7:0] Y1[15:8] V[23:16] Y2[31:24] */

    // default
    lpInput->dwNumFormats = 1;
    if (lpInput->lpddpfOutputFormats != NULL) {
        memcpy (lpInput->lpddpfOutputFormats, lpInput->lpddpfInputFormat, sizeof (DDPIXELFORMAT));
    }

    // for the video data
    if (lpInput->dwFlags & DDVPFORMAT_VIDEO) {// video formats
        // is input format a FOURCC
        if (lpInput->lpddpfInputFormat->dwFlags & DDPF_FOURCC ) {
            // is it UYVY
            if (lpInput->lpddpfInputFormat->dwFourCC == mmioFOURCC('U','Y','V','Y')) {
                // translation of UYVY is UYVY (ie no translation)
            lpInput->dwNumFormats = 1;
           if (lpInput->lpddpfOutputFormats != NULL) {
                    memcpy (lpInput->lpddpfOutputFormats, pf, sizeof (DDPIXELFORMAT) );
                }
            }
        }
    }

    // for the VBI data
    if (lpInput->dwFlags & DDVPFORMAT_VBI) {// VBI formats
        // is input format a FOURCC
        if (lpInput->lpddpfInputFormat->dwFlags & DDPF_FOURCC ) {
            // is it UYVY
            if (lpInput->lpddpfInputFormat->dwFourCC == mmioFOURCC('R','A','W','8')) {
                // translation of UYVY is UYVY (ie no translation)
            lpInput->dwNumFormats = 1;
           if (lpInput->lpddpfOutputFormats != NULL) {
                    memcpy (lpInput->lpddpfOutputFormats, pfvbi, sizeof (DDPIXELFORMAT) );
                }
            }
        }
    }

    lpInput->ddRVal = DD_OK;
   return DDHAL_DRIVER_HANDLED;
}


/*
 * GetVideoPortField32
 *
 * This function is only required if readback of the current
 * field is supported.
 */
// needed defines for mediaport


DWORD __stdcall GetVideoPortField32 (LPDDHAL_GETVPORTFIELDDATA lpInput)
{
    /*
     * Make sure the video port is ON.  If not, set
     * lpInput->ddRVal to DDERR_VIDEONOTACTIVE and return.
     */

    /*
     * Readback whether the field is even or odd.  lpInput->bField is
     * set to TRUE if the current field is even.
     */
    DPF("***GetVideoPortField32");

    if (pMySurfaces->dwVideoPortStatus == VP_NOT_RUNNING) {
        //DPF("   Video is not active!!!");
        lpInput->bField = 0;
       lpInput->ddRVal = DDERR_VIDEONOTACTIVE;
    } else {
     /*
     * Readback the current line number and put it in
     * lpInput->dwLine
     */

        lpInput->bField = GetField();

        lpInput->ddRVal = DD_OK;

        lpInput->bField = 0;
    }

    return DDHAL_DRIVER_HANDLED;
}

/*
 * GetVideoPortLine32
 *
 * This function is only required if readback of the current
 * video line number (0 relative) is supported.
 */
    /*
     * Make sure the video port is ON.  If not, set
     * lpInput->ddRVal to DDERR_VIDEONOTACTIVE and return.
     */

DWORD __stdcall GetVideoPortLine32 (LPDDHAL_GETVPORTLINEDATA lpInput)
{

    DPF("***GetVideoPortLine32");

    // need channel poiner for this!
    if( GLOBDATAPTR->NvDevFlatVPE == (DWORD) NULL ) {
        lpInput->ddRVal = DDERR_SURFACELOST;
        return DDHAL_DRIVER_HANDLED;
    }

    if (pMySurfaces->dwVideoPortStatus == VP_NOT_RUNNING) {
        //DPF("   Video is not active!!!");
        lpInput->dwLine = 0;
       lpInput->ddRVal = DDERR_VIDEONOTACTIVE;
    } else {
     /*
     * Readback the current line number and put it in
     * lpInput->dwLine
     */

        lpInput->dwLine = getCurLine();
        lpInput->ddRVal = DD_OK;

    }

    return DDHAL_DRIVER_HANDLED;
}


/*
 * GetVideoPortConnectInfo
 *
 * This is the old:
 * Returns the GUIDs describing the connections that can be supported.
 * Think of a GUID simply as a 128 bit FOURCC that you don't have to
 * register.  This function is required.

 * And this is the new:
 * Fills in specified array of connections
 *
 */
DWORD __stdcall GetVideoPortConnectInfo (LPDDHAL_GETVPORTCONNECTDATA lpInput)
{
    /*
     * If lpInput->lpGUIDs is NULL, simply return the number of GUIDS
     * supported
     */

    // eventually we should check dwPortId if there are more than one port in operation.
    // however since all the port will likely have the same capabilities maybe it's not an
    // issue

    DPF("***GetVideoPortConnectInfo");

#if 0
    lpInput->dwNumEntries = 1;
    if(lpInput->lpConnect == NULL) {
        // this means that Dx is looking for the number of ways you can connect so that it can
        // allocate a structure for the next time around
        lpInput->ddRVal = DD_OK;
    } else {
        // fill in the one structure that we asked for..
        memcpy (&(lpInput->lpConnect->guidTypeID), &DDVPTYPE_CCIR656, sizeof (GUID));
        lpInput->lpConnect->dwPortWidth = 8;
        lpInput->lpConnect->dwFlags = MY_CONNECTION_CAPS;
    }
#else
    lpInput->dwNumEntries = 2;
    if(lpInput->lpConnect == NULL) {
        // this means that Dx is looking for the number of ways you can connect so that it can
        // allocate a structure for the next time around
        lpInput->ddRVal = DD_OK;
    } else {
        // fill in the one structure that we asked for..
        memcpy (&(lpInput->lpConnect[0].guidTypeID), &DDVPTYPE_CCIR656, sizeof (GUID));
        lpInput->lpConnect[0].dwPortWidth = 8;
        lpInput->lpConnect[0].dwFlags = MY_CONNECTION_CAPS;
        lpInput->lpConnect[0].dwSize = sizeof(DDVIDEOPORTCONNECT);
        memcpy (&(lpInput->lpConnect[1].guidTypeID), &DDVPTYPE_CCIR656, sizeof (GUID));
        lpInput->lpConnect[1].dwPortWidth = 16;
        lpInput->lpConnect[1].dwFlags = MY_CONNECTION_CAPS;
        lpInput->lpConnect[1].dwSize = sizeof(DDVIDEOPORTCONNECT);
    }

#endif
    return DDHAL_DRIVER_HANDLED;

}


/*
 * DestroyVideoPort32
 *
 * This optional function notifies the HAL when the video port
 * has been destroyed.
 */
DWORD __stdcall DestroyVideoPort32 (LPDDHAL_DESTROYVPORTDATA lpInput)
{

    DPF("***DestroyVideoPort32");

#ifdef USEVPP
#ifdef ENABLE_VPP_DISPATCH_CODE
// This code is no longer used but may someday be useful.
    // Restore the original priorities
    pDriverData->vppDispatch.dwCommand = VPPDISPATCH_RESTOREPRIORITY;
    SetEvent(pDriverData->vppDispatch.hSignalGo3);
#endif
#endif

    pMySurfaces->ImageCallbackRoutine = NULL;
    pMySurfaces->VBICallbackRoutine = NULL;

    tearDownVP();

    nvTimerPtr = NULL;

    lpInput->ddRVal = DD_OK;


    return DDHAL_DRIVER_HANDLED;
}


/*
 * GetVideoPortFlipStatus32
 *
 * This required function allows DDRAW to restrict access to a surface
 * until the physical flip has occurred, allowing doubled buffered capture.
 */

    /*
     * If the physical flip has not yet occurred, return
     * DDERR_WASSTILLDRAWING
     */

DWORD __stdcall GetVideoPortFlipStatus32 (LPDDHAL_GETVPORTFLIPSTATUSDATA lpInput)
{

    U032    dwIndex;

    DPF("***GetVideoPortFlipStatus32");

#if 0
    if( GLOBDATAPTR->NvDevFlatVPE == NULL ) {
        lpInput->ddRVal = DDERR_SURFACELOST;
        return DDHAL_DRIVER_HANDLED;
    }

#endif
    if( pMySurfaces->dwVideoPortStatus == VP_NOT_RUNNING ) {
    lpInput->ddRVal = DD_OK;
        return DDHAL_DRIVER_HANDLED;
    }

    // search through all of our known surfaces looking for the one it's curious about
    for (dwIndex = 0; dwIndex < pMySurfaces->numberOfSurfaces ; dwIndex++) {
        if (pMySurfaces->Surfaces[dwIndex]->pVidMem == lpInput->fpSurface) {
            // this means we've found the surface that DX is curious about
            if( pMySurfaces->Surfaces[dwIndex]->pNvNotify == NULL ) {
                ASSERT(1==0);
                DPF("   NOTIFY WAS NULL  !!!!!!!!!!!");
            lpInput->ddRVal = DD_OK;
                return DDHAL_DRIVER_HANDLED;
            }


            if( pMySurfaces->Surfaces[dwIndex]->bAutoFlip ) {
                // in the case of auto-flipping just always say we're done...
                lpInput->ddRVal = DD_OK;
            } else {
                if (pMySurfaces->bFlipRequested == TRUE ) {
                    lpInput->ddRVal = DDERR_WASSTILLDRAWING;
                } else {
                    lpInput->ddRVal = DD_OK;
                }
            }
            // return here... we found the surface
            return DDHAL_DRIVER_HANDLED;
        }
    }

    DPF("   ***FlipStatus having trouble  --> Surface does");
    DPF("          not exist in my list of surfaces");
    lpInput->ddRVal = DD_OK;

    return DDHAL_DRIVER_HANDLED;
}


/*
 * FlipVideoPort32
 *
 * This function is required
 *
 * Issues:
 *          Correct use of notifiers
 *          Updating surface logging info
 *          What if new surface has not got same or less capabilites as replaced surface

 *          Does not work because class 66 doesn't allow insertion of buffers
 *
 */

/*
important:
            Curr surface should be known to us
            Targ surface could be new

            both surfaces should have this flag: DDSCAPS_LIVEVIDEO set in ->ddsCaps structure
*/
DWORD __stdcall FlipVideoPort32 (LPDDHAL_FLIPVPORTDATA lpInput)
{

    /*
     * Program registers to do the actual flip
     */

    /*
     * Save information for BOTH lpSurfCurr so we can know in the future
     * when the physical flip has occurred.
     */


    // Check that both surfaces are in our list
    U032    newSurfaceIndex;
    U032    oldSurfaceIndex;
        //  U032    counter;
    DPF("***FlipVideoPort32");
    if( GLOBDATAPTR->NvDevFlatVPE == (DWORD) NULL ) {
        lpInput->ddRVal = DDERR_SURFACELOST;
        return DDHAL_DRIVER_HANDLED;
    }
    lpInput->ddRVal = DD_OK;

    oldSurfaceIndex = findSurface(lpInput->lpSurfCurr);
    if(oldSurfaceIndex  != SURFACENOTFOUND ) {
        newSurfaceIndex = findSurface(lpInput->lpSurfTarg);
        if(newSurfaceIndex == SURFACENOTFOUND ) {
            // in the case of non-interleaved surfaces this might be even more different
            // because we have essentially to replace TWO places where the old surface might be
            // residing...  not just one   non-auto flip SUCKS.
            if( oldSurfaceIndex < pMySurfaces->VBIstart ) {
                replaceSurfaceWithSurface(oldSurfaceIndex,lpInput->lpSurfTarg, FALSE);
            } else {
                replaceSurfaceWithSurface(oldSurfaceIndex,lpInput->lpSurfTarg, TRUE);
            }
            newSurfaceIndex = oldSurfaceIndex;
        }
        pMySurfaces->bFlipRequested = TRUE;

        if(newSurfaceIndex != SURFACENOTFOUND ) {
#if 0
            //  Now do some stuff... uh.. what?

            // Find out which of the buffers what programmed for the old surface
            U032    dwBufferIndex = NOSURFACEPROGRAMED;
            {
                U032 i;
                for(i=0;i<4;i++) {
                    if(oldSurfaceIndex == pMySurfaces->CurrentBufferSurface[i] ) {
                        dwBufferIndex = i;
                        break;
                    }
                }
                if (i == 4 ) {
                    DPF("   Not sure which buffer was attached to the Current Surface in FlipVideoPort");
                    return DDHAL_DRIVER_NOTHANDLED;
                }
            }


            //  We could wait here until we know the hardware is done...
            //  instead we'll just check it real quick and print a whiner if it's not done
            //  and then fail
            {
                NvNotification*     pNotify = pMySurfaces->Surfaces[oldSurfaceIndex]->pNvNotify;
                if(pNotify != NULL) {
                    if (pNotify->status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS ) {
                        DPF("   Attempting to flip out a surface which is still in progress");
                        // we should hang out here until it's done....
                        counter = 0;
                        while((pNotify->status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS ) && (counter < 3000000)) {
                            counter++;
                        }
                    }
                    // check to see if we've had an error
                    //    there are LOTS of these....
                    if ( (pNotify->status != NV04D_NOTIFICATION_STATUS_IN_PROGRESS ) |
                          (pNotify->status != NV04D_NOTIFICATION_STATUS_DONE_SUCCESS ) |
                          (pNotify->status != NV04D_NOTIFICATION_STATUS_NOT_LAUNCHED ) ){
                        DPF("   Attempting to flip out a surface which had an error during capture");
                        //return DDHAL_DRIVER_NOTHANDLED;
                    }
                } else {
                    DPF("   Attempting to flip out a surface where the notifier was NULL");
                    return DDHAL_DRIVER_NOTHANDLED;
                }
            }

#endif
            // Ok, program up the switch
            //ProgramBufferWithSurface(dwBufferIndex,newSurfaceIndex,FALSE);


        } else {
            DPF("   Unable to find Target Surface during FlipVideoPort32");
            DPF("   There was a note that we could be receiving new surfaces ");
            DPF("                      ( Tobin or MS ?)..... need to add code for this");

            return DDHAL_DRIVER_NOTHANDLED;
        }

    } else {
        DPF("   Unable to find Current Surface during FlipVideoPort32");
        return DDHAL_DRIVER_NOTHANDLED;
    }

    lpInput->ddRVal = DD_OK;

    return DDHAL_DRIVER_HANDLED;
}

#if 0
U032 startSurfaces(U032 bInterleave, VPSTATE*   pVideoPortStatus ) {
    U032    rValue = DD_OK;
    VPSTATE myState = *pVideoPortStatus;
    // figure out which buffers to program up and launch them...
    if(bInterleave) {
         DPF("   Now Launching surfaces.... INTERLEAVED");
    } else {
         DPF("   Now Launching surfaces.... NOT INTERLEAVED");
    }
    // zero out the last overlay scaler size so we're sure it gets reprogrammed
    pMySurfaces->lastsrcDeltaY = 0;
    pMySurfaces->bStopVP = FALSE;
    if( bInterleave ) {
        // both buffers will point to the same surface
        if( pMySurfaces->VBIstart >0 ) {
            if( ProgramBufferWithSurface(0,0,FALSE) )
                rValue = DDERR_INVALIDPARAMS;

            // since this is interleave always start the second buffer with the first surface
            if( ProgramBufferWithSurface(1,0,FALSE) )
                rValue = DDERR_INVALIDPARAMS;
            myState |= VP_IMAGE_CAPTURING;
        }
    } else {

        // buffers will point to consecutive surfaces
        if( pMySurfaces->VBIstart >0 ) {
            if( ProgramBufferWithSurface(0,0,FALSE) )
                rValue = DDERR_INVALIDPARAMS;
            myState |= VP_IMAGE_CAPTURING;
        }
        // check for another surface
        if( pMySurfaces->VBIstart > 1 ) {
            if( ProgramBufferWithSurface(1,1,FALSE) )
                rValue = DDERR_INVALIDPARAMS;
        } else {
            // fire up the second buffer at the first surface
            if( ProgramBufferWithSurface(1,0,FALSE) )
                rValue = DDERR_INVALIDPARAMS;
        }
    }

    // Now do VBI
    // start first vbi on first surface
    if( (pMySurfaces->numberOfSurfaces - pMySurfaces->VBIstart) > 0 ) {
        if( ProgramBufferWithSurface(2,pMySurfaces->VBIstart,FALSE))
                rValue = DDERR_INVALIDPARAMS;
        myState |= VP_VBI_CAPTURING;

        // now check to see if we have another surface
        if( (pMySurfaces->numberOfSurfaces - pMySurfaces->VBIstart) > 1 ) {
            if( ProgramBufferWithSurface(3,pMySurfaces->VBIstart+1,FALSE))
                    rValue = DDERR_INVALIDPARAMS;
        } else {
            // set second buffer to first surface
            if( ProgramBufferWithSurface(3,pMySurfaces->VBIstart+0,FALSE))
                    rValue = DDERR_INVALIDPARAMS;
        }
    }
    *pVideoPortStatus = myState;

    return rValue;
}

#endif

U032 startNV3DelayedStart(U032  bInterleave, VPSTATE*   pVideoPortStatus, U032 milliSecondsOfDelay ) {

    // ain't nothing happenin here yet.

    // First thing we're goin to do is paint that surface BLACK so as folks don't be noticin' we's gonna do the
    // delay factor for our masters up at microsoft.

    if(milliSecondsOfDelay > 5 )
    {
        U032    n = 2;
        U032    q;

        if(pMySurfaces->VBIstart <2 )
            n = 1;
        if(pMySurfaces->VBIstart <1 )
            return 0;
        for(q=0;q<n;q++) {
            // length in Long words
            U032    length = ( pMySurfaces->Surfaces[q]->dwPitch * pMySurfaces->Surfaces[q]->dwHeight ) / 4;
            U032    startOff = pMySurfaces->Surfaces[q]->pVidMem ;
            U032    i;
            U032*   pOverlay = (U032*) ((U032)startOff);
            for(i=0; i< length ; i++ ) {
                *pOverlay = 0x10801080;
                pOverlay++;
            }
        }
    }

// deficiencies in NV32.h

    nvMyVPNotifiers[NUM004OFFSET].status        = NV04D_NOTIFICATION_STATUS_NOT_LAUNCHED;

    pMySurfaces->pVPChanPtr->subchannel[0].SetObject  = MY_TIMER_OBJECT;

// get a 0.75 second delay in nanoseconds
#define NV3DELAYTIME ( milliSecondsOfDelay*1000*1000 )
    {
        U032    low;
        U032    low1;
        U032    high;

        getCurrentNanoTimer(&high, &low);
        low1 = low;


        low = low + NV3DELAYTIME;
        if( low < low1 ) {
            high = high + 1;
        }
        pMySurfaces->pVPChanPtr->subchannel[0].nv01Timer.SetAlarmTime.nanoseconds[0] = low;
        pMySurfaces->pVPChanPtr->subchannel[0].nv01Timer.SetAlarmTime.nanoseconds[1] = high;
        pMySurfaces->pVPChanPtr->subchannel[0].nv01Timer.SetAlarmNotify =
            NV004_SET_ALARM_NOTIFY_WRITE_THEN_AWAKEN;

        // ok, 3/4 second later we should get a notify!
    }

    //return startSurfaces(bInterleave, pVideoPortStatus );
    return DD_OK;

}


/*
 * UpdateVideoPort32
 *
 * This required function sets up the video port
 */

/* Questions:
 *          What if I want VBI latching while image is not latching ?
 */

DWORD __stdcall UpdateVideoPort32 (LPDDHAL_UPDATEVPORTDATA lpInput)
{

    VPERRORS myErrors;
    U032        bAutoflip;

    DPF("***UpdateVideoPort32");
    if( GLOBDATAPTR->NvDevFlatVPE == (DWORD) NULL ) {
#ifdef NV3
    // this is added to attempt to stop the writing of stop commands during mode switch
    // since it appears that they stop the video stream after receiving surface lost commands
    pMySurfaces->dwVideoPortStatus = VP_NOT_RUNNING;
#endif
        lpInput->ddRVal = DDERR_SURFACELOST;
        return DDHAL_DRIVER_HANDLED;
    }

// Since bruce changed the order of initialization, we should check if we need to reload this
    if(pMySurfaces->pOverlayChanPtr == NULL) {
        DPF("Late overlay channel update!");

        pMySurfaces->pOverlayChanPtr = (NvChannel*) pDriverData->NvDevVideoFlatPio;


    }


    lpInput->ddRVal = DD_OK;

    {
        /*
         * Turn off the video port
         */
//CODE
        DPF("   now Stopping the Video Port");
        // prevent future interrupts from doing anything
        pMySurfaces->bThreadRunning = FALSE;
        // tell the classes to stop
        StopVP();
        // zero out the notifiers

        {
            U032 i;
            for(i=0;i<NUM04DNOTIFIER;i++ ) {
                nvMyVPNotifiers[i+NUM04DOFFSET].status = NV04D_NOTIFICATION_STATUS_NOT_LAUNCHED;
                nvMyVPNotifiers[i+NUM04DOFFSET].info32 = 0;
                nvMyVPNotifiers[i+NUM04DOFFSET].info16 = 0;
                nvMyVPNotifiers[i+NUM04DOFFSET].timeStamp.nanoseconds[0] = 0;
                nvMyVPNotifiers[i+NUM04DOFFSET].timeStamp.nanoseconds[1] = 0;
            }
        }
        pMySurfaces->dwVideoPortStatus = VP_NOT_RUNNING;

    }

    if (lpInput->dwFlags != DDRAWI_VPORTSTOP) {
#ifdef NV3
        bDelayNV3 = FALSE;
#endif //NV4
        if (lpInput->dwFlags == DDRAWI_VPORTSTART) {
            DPF("   now Starting Video Port for the first time");

        // This is the first round....
#ifdef NV3
            bDelayNV3 = TRUE;
#endif  //NV4

        }

        DPF("   now updating the video port");

        {


            // print some stuff out about the flags we're lookin at:
            if( pMySurfaces->bInvertedFields ) {
                DPF("      field polarity               inverted");
            } else {
                DPF("      field polarity               normal");
            }

            if(lpInput->lpVideoInfo->dwVPFlags & DDVP_AUTOFLIP  ) {
                DPF("      FLAG DVP_AUTOFLIP            on");
            } else {
                DPF("      FLAG DVP_AUTOFLIP            off");
            }
            if(lpInput->lpVideoInfo->dwVPFlags & DDVP_CONVERT       ) {
                DPF("      FLAG DDVP_CONVERT            on");
            } else {
                DPF("      FLAG DDVP_CONVERT            off");
            }
            if(lpInput->lpVideoInfo->dwVPFlags & DDVP_CROP                  ) {
                DPF("      FLAG DDVP_CROP               on");
            } else {
                DPF("      FLAG DDVP_CROP               off");
            }
            if(lpInput->lpVideoInfo->dwVPFlags & DDVP_INTERLEAVE            ) {
                DPF("      FLAG DDVP_INTERLEAVE         on");
            } else {
                DPF("      FLAG DDVP_INTERLEAVE         off");
            }
            if(lpInput->lpVideoInfo->dwVPFlags & DDVP_MIRRORLEFTRIGHT       ) {
                DPF("      FLAG DDVP_MIRRORLEFTRIGHT    on");
            } else {
                DPF("      FLAG DDVP_MIRRORLEFTRIGHT    off");
            }
            if(lpInput->lpVideoInfo->dwVPFlags & DDVP_MIRRORUPDOWN          ) {
                DPF("      FLAG DDVP_MIRRORUPDOWN       on");
            } else {
                DPF("      FLAG DDVP_MIRRORUPDOWN       off");
            }
            if(lpInput->lpVideoInfo->dwVPFlags & DDVP_PRESCALE              ) {
                DPF("      FLAG DDVP_PRESCALE           on");
            } else {
                DPF("      FLAG DDVP_PRESCALE           off");
            }
            if(lpInput->lpVideoInfo->dwVPFlags & DDVP_SKIPEVENFIELDS        ) {
                DPF("      FLAG DDVP_SKIPEVENFIELDS     on");
            } else {
                DPF("      FLAG DDVP_SKIPEVENFIELDS     off");
            }
            if(lpInput->lpVideoInfo->dwVPFlags & DDVP_SKIPODDFIELDS         ) {
                DPF("      FLAG DDVP_SKIPODDFIELDS      on");
            } else {
                DPF("      FLAG DDVP_SKIPODDFIELDS      off");
            }
            if(lpInput->lpVideoInfo->dwVPFlags & DDVP_SYNCMASTER                ) {
                DPF("      FLAG DDVP_SYNCMASTER         on");
            } else {
                DPF("      FLAG DDVP_SYNCMASTER         off");
            }
            if(lpInput->lpVideoInfo->dwVPFlags & DDVP_VBICONVERT                ) {
                DPF("      FLAG DDVP_VBICONVERT         on");
            } else {
                DPF("      FLAG DDVP_VBICONVERT         off");
            }
            if(lpInput->lpVideoInfo->dwVPFlags & DDVP_VBINOSCALE                ) {
                DPF("      FLAG DDVP_VBINOSCALE         on");
            } else {
                DPF("      FLAG DDVP_VBINOSCALE         off");
            }
            if(lpInput->lpVideoInfo->dwVPFlags & DDVP_OVERRIDEBOBWEAVE      ) {
                //pMySurfaces->bInvertedFields = TRUE;
                DPF("      FLAG DDVP_OVERRIDEBOBWEAVE   on");
            } else {
                DPF("      FLAG DDVP_OVERRIDEBOBWEAVE   off");
            }

            if(lpInput->lpVideoInfo->dwVPFlags & DDVP_IGNOREVBIXCROP        ) {
                DPF("      FLAG DDVP_IGNOREVBIXCROP     on");
            } else {
                DPF("      FLAG DDVP_IGNOREVBIXCROP     off");
            }


        }

        // Decide which capture mode to be in given if we're trying to skip some types of fields


        if( lpInput->lpVideoInfo->dwVPFlags & DDVP_SKIPEVENFIELDS ) {
            pMySurfaces->CurrentCaptureMode = ODDODD;
        } else if ( lpInput->lpVideoInfo->dwVPFlags & DDVP_SKIPODDFIELDS ) {
            pMySurfaces->CurrentCaptureMode = EVENEVEN;
        } else {
            if(pMySurfaces->bInputInterLaced)
                pMySurfaces->CurrentCaptureMode = EVENODD;
            else
                pMySurfaces->CurrentCaptureMode = PROGRESSIVE;
        }

        if( lpInput->lpVideoInfo->dwVPFlags & DDVP_AUTOFLIP ) {
            bAutoflip = TRUE;
        } else {
            bAutoflip = FALSE;
        }

        if( lpInput->lpVideoInfo->dwVPFlags & DDVP_INTERLEAVE ) {
            pMySurfaces->CurrentScanMode = INTERLEAVBUF;
        } else {
            pMySurfaces->CurrentScanMode = SEPERATEBUF;
        }

        {
            // Here's where we're going to try to figure out where to put things in the vertical and horz
            // dimensions

            // At key thing here are the two different modes which people are using to capture VBI
            // one is that the VBI data is captured to the very beginning of the VIDEO surface in one big surface
            // the other mode is with a seperate surface

            // we can detect which mode by examining the number of VBI surface if > 0 we're in the second mode

            // When there ARE VBI surfaces, then we should jam the Video data right to the very beginning of the
            // video surface, since we know this is where it will be expected.

            // additionally we've reported DDVPCONNECT_DISCARDSVREFDATA is true which means
            // "/*
            //   * Indicates that any data written to the video port during the VREF
            //   * period will not be written into the frame buffer. This flag is read only.
            //   */"
           //  MS of course not really defining what the VREF period means in their land.


#define VBIVALIDDATALINE  (0x2)


            if( lpInput->lplpDDVBISurface == NULL ) {
                // this indicates that there are NO VBI surfaces associated with this video port update.
                // therefore we should send all the line to the Image surface

                // Ok, given the info the VIP2.0 spec about the "official NTSC" signal
                // the Vbit will go low around between line 9 and 10.
                // Since we're counting from line 1 when we do our Y-crop, we need to
                // add in the lines which microsoft has not counted in their system
#define MAGICMICROSOFTOFFSET    (4)
                // so that's the magic offset... let's see if it works!

                pMySurfaces->dwImageStartLine = MAGICMICROSOFTOFFSET;  // send all the data after line 0

                if ( lpInput->lpVideoInfo->dwVPFlags & DDVP_CROP ) {
                    if((lpInput->lpVideoInfo->rCrop.top + MAGICMICROSOFTOFFSET ) > (signed long) pMySurfaces->dwImageStartLine ) {
                        pMySurfaces->dwImageStartLine = lpInput->lpVideoInfo->rCrop.top;
                    }
                }

            } else {
                // there are some VBI surfaces associated with this video port,
                // so we should send the data to the VBI surfaces where applicable
                pMySurfaces->dwVBIStartLine = VBIVALIDDATALINE; // at least we're not starting with zero this first four are always
                                                                            // empty as best as I know

                pMySurfaces->dwVBIHeight = lpInput->lpVideoInfo->dwVBIHeight;

                // Image start line should be one line after the the sum of these two
                // H.AZAR: unless the flag DDVP_IGNOREVBIXCROP is set. In such case we are told to ignore the VBI cropping !!!
                if ((lpInput->lpVideoInfo->dwVPFlags & DDVP_IGNOREVBIXCROP) && (lpInput->lpVideoInfo->dwVPFlags & DDVP_PRESCALE))
                    pMySurfaces->dwImageStartLine = 1 + pMySurfaces->dwVBIStartLine - VBIVALIDDATALINE;
                else
                    pMySurfaces->dwImageStartLine = 1 + pMySurfaces->dwVBIHeight + pMySurfaces->dwVBIStartLine - VBIVALIDDATALINE;

                // if   dwImageStartLine < 1  then things don't work to well
                if(pMySurfaces->dwImageStartLine < 1) pMySurfaces->dwImageStartLine = 1;

                if ( lpInput->lpVideoInfo->dwVPFlags & DDVP_CROP ) {
                    if(lpInput->lpVideoInfo->rCrop.top > (signed long) pMySurfaces->dwImageStartLine ) {
                        pMySurfaces->dwImageStartLine = lpInput->lpVideoInfo->rCrop.top;
                    }
                }
            }



            // this is the only way I know how to do the check for vertical cropping
            if ( lpInput->lpVideoInfo->dwVPFlags & DDVP_CROP ) {
                pMySurfaces->dwInHeight = (DWORD)lpInput->lpVideoInfo->rCrop.bottom - lpInput->lpVideoInfo->rCrop.top;
                pMySurfaces->dwInWidth  = lpInput->lpVideoInfo->rCrop.right - lpInput->lpVideoInfo->rCrop.left;
                DPF("   UPDATE:         crop TOP %d",lpInput->lpVideoInfo->rCrop.top);
            } else {
                pMySurfaces->dwInHeight = lpInput->lpVideoPort->ddvpDesc.dwFieldHeight;
                pMySurfaces->dwInWidth  = lpInput->lpVideoPort->ddvpDesc.dwFieldWidth;
            }

            // this is something of a hack I suppose
            // pMySurfaces->dwInHeight = pMySurfaces->dwInHeight;

            // H.AZAR: in the case the DDVP_IGNOREVBIXCROP flag is set we must substract the VBIHeight from InHeight
            if ((lpInput->lpVideoInfo->dwVPFlags & DDVP_IGNOREVBIXCROP) && (lpInput->lpVideoInfo->dwVPFlags & DDVP_PRESCALE))
                pMySurfaces->dwInHeight -= pMySurfaces->dwVBIHeight;

            // if we're prescaling then do something
            if (DDVP_PRESCALE & lpInput->lpVideoInfo->dwVPFlags) {
                pMySurfaces->dwPreHeight = lpInput->lpVideoInfo->dwPrescaleHeight;
                pMySurfaces->dwPreWidth  = lpInput->lpVideoInfo->dwPrescaleWidth;
            } else {
                pMySurfaces->dwPreHeight = pMySurfaces->dwInHeight;
                pMySurfaces->dwPreWidth = pMySurfaces->dwInWidth;
            }


            pMySurfaces->dwOriginX = lpInput->lpVideoInfo->dwOriginX;
            pMySurfaces->dwOriginY = lpInput->lpVideoInfo->dwOriginY;
        }

        switch (pMySurfaces->CurrentCaptureMode) {
                case EVENODD:
                    DPF("   UPDATE:     capture mode EVENODD");
                    break;
                case EVENEVEN:
                    DPF("   UPDATE:     capture mode EVENEVEN");
                    break;
                case ODDODD:
                    DPF("   UPDATE:     capture mode ODDODD");
                    break;
        }
        switch (pMySurfaces->CurrentScanMode) {
                case SEPERATEBUF:
                    DPF("   UPDATE:        scan mode SEPERATEBUF");
                    break;
                case INTERLEAVBUF:
                    DPF("   UPDATE:        scan mode INTERLEAVBUF");
                    break;
        }

        DPF("   UPDATE: image start line %d",pMySurfaces->dwImageStartLine);
        DPF("   UPDATE: image in dimens %d,%d",pMySurfaces->dwInWidth,pMySurfaces->dwInHeight);
        DPF("   UPDATE: image pre dimens %d,%d",pMySurfaces->dwPreWidth,pMySurfaces->dwPreHeight);
        DPF("   UPDATE:   image position %d,%d",pMySurfaces->dwOriginX,pMySurfaces->dwOriginY);

        myErrors = replaceSurfaceList(lpInput->dwNumAutoflip,lpInput->dwNumVBIAutoflip,
                                        lpInput->lplpDDSurface, lpInput->lplpDDVBISurface,bAutoflip);

        pMySurfaces->dwVPFlags = lpInput->lpVideoInfo->dwVPFlags;
        if( myErrors == NOVPERROR ) {
          lpInput->ddRVal = startNV3DelayedStart(lpInput->lpVideoInfo->dwVPFlags & DDVP_INTERLEAVE, &(pMySurfaces->dwVideoPortStatus), 0);
        }   // NOVPERROR
        else {
          // seems like we can't replace the surface... bail out!
          lpInput->ddRVal = DDERR_INVALIDPARAMS;
          return DDHAL_DRIVER_HANDLED;
        }
    }  // DDRAWI_VPORTSTOP

    // this is sort of a big hack since things aren't actually running yet, but DirectShow seems to require it

#ifdef NV3
    //pMySurfaces->dwVideoPortStatus = VP_BOTH_CAPTURING;
#else
    pMySurfaces->dwVideoPortStatus = VP_BOTH_CAPTURING;
#endif
    return DDHAL_DRIVER_HANDLED;
}


/*
 * GetVideoSignalStatus32
 *
 * This function is required
 */

DWORD __stdcall GetVideoSignalStatus32 ( LPDDHAL_GETVPORTSIGNALDATA lpInput) {

    U032    dwIndex;
    ASSERT(lpInput != NULL);

    DPF("***GetVideoSignalStatus32");
    if( GLOBDATAPTR->NvDevFlatVPE == (DWORD) NULL ) {
        lpInput->ddRVal = DDERR_SURFACELOST;
        return DDHAL_DRIVER_HANDLED;
    }

    if( lpInput == NULL)
    {
        DPF("   Input NULL in GetVideoSignalStatus32");
        return DDHAL_DRIVER_NOTHANDLED;
    }
    // If the video port is not running, then we just don't know...
    if( pMySurfaces->dwVideoPortStatus == VP_NOT_RUNNING ) {
        DPF("   could not get the signal status, the video port is not running");
        // we'll return no signal in this case....
        lpInput->dwStatus = DDVPSQ_NOSIGNAL;
        lpInput->ddRVal = DDERR_VIDEONOTACTIVE;

        return DDHAL_DRIVER_HANDLED;
    }

    lpInput->ddRVal = DD_OK;
    // default for now is that the signal is good
    lpInput->dwStatus = DDVPSQ_SIGNALOK;
    // first check the notifiers to see if there has been ANY sync
    //     do this by seeing if the notify times are none zero

return DDHAL_DRIVER_HANDLED;

    {
        U032    probablyRunning = FALSE;
        for (dwIndex=0;dwIndex<pMySurfaces->numberOfSurfaces;dwIndex++) {
            if( pMySurfaces->Surfaces[dwIndex]->pNvNotify != NULL ) {
                if (pMySurfaces->Surfaces[dwIndex]->pNvNotify->timeStamp.nanoseconds[0]!=0) {
                    probablyRunning = TRUE;
                    break;
                }
            }
        }

        // if the timer are zero then wait at least 1/24 of a second and check again.
        if(!probablyRunning) {
            // find current time
            U032     tempTime;
            tempTime = getMilliTime();
            //now wait for 1/24 of a second
            while(tempTime + (1000/24) > getMilliTime());
            // and then check one more time for a possible completion
            for (dwIndex=0;dwIndex<pMySurfaces->numberOfSurfaces;dwIndex++) {
                if( pMySurfaces->Surfaces[dwIndex]->pNvNotify != NULL ) {
                    if (pMySurfaces->Surfaces[dwIndex]->pNvNotify->timeStamp.nanoseconds[0]!=0) {
                        probablyRunning = TRUE;
                        break;
                    }
                }
            }

            // if it's still non zero report no signal
            if(!probablyRunning) {
                lpInput->dwStatus = DDVPSQ_NOSIGNAL;
            }

        }
    }

    // have we already decided that the signal is bad...?
    if( lpInput->dwStatus != DDVPSQ_NOSIGNAL ) {

        // Now the default is that the signal is bad
        lpInput->dwStatus = DDVPSQ_NOSIGNAL;

        // check to see that at least one of of the notifiers is LESS than 1/24 of a second
        // hopefully there's been _some_ event in video land in the last 1/24 of a second
        for (dwIndex=0;dwIndex<pMySurfaces->numberOfSurfaces;dwIndex++) {
            if( pMySurfaces->Surfaces[dwIndex]->pNvNotify != NULL ) {
                if (pMySurfaces->Surfaces[dwIndex]->pNvNotify->timeStamp.nanoseconds[0]!=0) {
                    U032 diff;
                    // ok, we've got a non-zero surface, let's check to see how recent it is
                    U032    BigCurrentTime;
                    U032    SmallCurrentTime;

                    getCurrentNanoTimer(&BigCurrentTime,&SmallCurrentTime);
                    if(pMySurfaces->Surfaces[dwIndex]->pNvNotify->timeStamp.nanoseconds[1] < BigCurrentTime ) {
                        // we've got a wrap around situation.  this means that we need to work in weirder math
                        diff = (
                                    ((0x80000000)  - (pMySurfaces->Surfaces[dwIndex]->pNvNotify->timeStamp.nanoseconds[0] >> 1))
                                    +  (SmallCurrentTime >> 1)
                                 ) << 1;
                    } else {
                        // do a simple subtraction
                        diff = SmallCurrentTime - pMySurfaces->Surfaces[dwIndex]->pNvNotify->timeStamp.nanoseconds[0];
                    }
                    //diff now has the delta between the notify and "now"
                    // if the notifier is LESS than a frame period then we've got a signal
                    if(diff < MAXFRAMEPERIOD ) {
                        lpInput->dwStatus = DDVPSQ_SIGNALOK;
                    } else {
                        diff = 0;
                        // this is a place for chris's break point's while debugging
                    }

                }
            }
        }

    }

    return DDHAL_DRIVER_HANDLED;
}


/*
 * WaitForVideoPortSync32
 *
 * This function is required
 */


DWORD __stdcall WaitForVideoPortSync32 (LPDDHAL_WAITFORVPORTSYNCDATA lpInput)
{
    DPF("***WaitForVideoPortSync32");

    if( GLOBDATAPTR->NvDevFlatVPE == (DWORD) NULL ) {
        lpInput->ddRVal = DDERR_SURFACELOST;
        return DDHAL_DRIVER_HANDLED;
    }

    lpInput->ddRVal = DDVPSQ_NOSIGNAL;

    // if the port is running then
    if (pMySurfaces->dwVideoPortStatus != VP_NOT_RUNNING) {
        if( lpInput->dwFlags & DDVPWAIT_BEGIN ) {
            // wait for a vsync start.   timeout in lpInput->dwTimeOut
            U032    bigTime;
            U032    smallTime;
            U032    milliTime;
            U032    recentTime[MAXVPSURFACES];
            U032    dwIndex;
            U032    searchMAX;

        // find out what time it is now
            getCurrentNanoTimer(&bigTime, &smallTime);
            milliTime = getMilliTime();

            if( pMySurfaces->VBIstart == 0 ) {
                // we're only running VBI so check ALL the surfaces
                searchMAX = pMySurfaces->numberOfSurfaces;
            } else {
                // there is at least one image surface, so check for that
                searchMAX = pMySurfaces->VBIstart;
            }
            //find the current notifiers for the IMAGE surfaces
            for (dwIndex=0;dwIndex<searchMAX;dwIndex++) {
                if( pMySurfaces->Surfaces[dwIndex]->pNvNotify != NULL ) {
                    recentTime[dwIndex] = pMySurfaces->Surfaces[dwIndex]->pNvNotify->timeStamp.nanoseconds[0];
                } else {
                    recentTime[dwIndex] = 0;
                }
            }
            while( (getMilliTime() < ( milliTime + lpInput->dwTimeOut)) && ( lpInput->ddRVal == DDVPSQ_NOSIGNAL) ) {
                for (dwIndex=0;dwIndex<searchMAX;dwIndex++) {
                    if( pMySurfaces->Surfaces[dwIndex]->pNvNotify != NULL ) {
                        if( recentTime[dwIndex] < pMySurfaces->Surfaces[dwIndex]->pNvNotify->timeStamp.nanoseconds[0] ) {
                            // ok, ONE Of the notifiers moved foward
                            lpInput->ddRVal = DD_OK;    //  We found a sync
                        }
                    }
                }
            }
            // start a while
        } else if (lpInput->dwFlags & DDVPWAIT_END ) {
            //  timeout in lpInput->dwTimeOut
            // we could wait for ysync that then see which buffer we're on then wait for the line counter
            // to change  .. YUCK
            DPF("   Sorry, don't handle waiting for the end");

            return DDHAL_DRIVER_NOTHANDLED;
        } else if (lpInput->dwFlags & DDVPWAIT_LINE ) {
            //timeout in lpInput->dwTimeOut
                // lpInput ->dwLine
            DPF("   Sorry, can't wait for a particular line");
            return DDHAL_DRIVER_NOTHANDLED;
        };

    }// videoport status

    return DDHAL_DRIVER_HANDLED;
}

#endif //(!defined(WINNT) && !defined(NVPE))   // WINNT BUG
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\src\nvVPP_link.cpp ===
// **************************************************************************
//
//       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
//
//  Module: nvVPP_link.cpp
//      a pointer to a shared file
//
// **************************************************************************
//
//  History:
//      Matt Lavoie          09 Sep 2000
//
// **************************************************************************
#include "nvprecomp.h"

#include "..\..\..\common\src\nvVPP.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\src\StereoFunc_i.cpp ===
/***************************************************************************\
* Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.            *
* THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO       *
* NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY  *
* IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.                *
*                                                                           *
*  Portions: Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.*
*                                                                           *
* Module: StereoFunc_i.cpp                                                  *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Andrei Osnovich    02/23/00  Created                                *
*                                                                           *
\***************************************************************************/

#ifndef STEREOFUNC_GENERAL_MACROS
#define STEREOFUNC_GENERAL_MACROS
#define EQUAL       0
#define GREATER     1
#define LESS        2
#define X(pV)       (((LPD3DVALUE)pV)[0])
#define Y(pV)       (((LPD3DVALUE)pV)[1])
#define Z(pV)       (((LPD3DVALUE)pV)[2])
#define Z_I(pV)     (((DWORD *)pV)[2])
#define RHW(pV)     (((LPD3DVALUE)pV)[3])
#define RHW_I(pV)   (((DWORD *)pV)[3])
#define GET_REAL_NAME(token) #token
#endif  //STEREOFUNC_GENERAL_MACROS

#ifdef  FAN
    #define FAN_OR_STRIP
#else
#ifdef  STRIP
    #define FAN_OR_STRIP
#endif
#endif

#ifdef  INDEX2
#define INDEX
#endif  //INDEX2

#ifdef  INDEX
#ifdef  FAN_OR_STRIP
#define DEFINE_LOCALS   \
    WORD        wVertNum1; \
    LPBYTE      pVertex1;
#define FOR_ALL_VERTICES \
    for (i = 0; i < dwCount; i++, pIndices += sizeof(WORD))
#define GET_V1_POINTER \
    wVertNum1 = ((WORD *)pIndices)[0];          \
    nvAssert(wVertNum1 < pStereoData->dwVertexRegisterSize); \
    pVertex1 = &pVertices[wVertNum1*pContext->pCurrentVShader->getStride()];
#else   //FAN_OR_STRIP==0
#ifdef  LINE
#define DEFINE_LOCALS   \
    WORD        wVertNum1, wVertNum2; \
    LPBYTE      pVertex1, pVertex2;
#else   //LINE==0
#define DEFINE_LOCALS   \
    WORD        wVertNum1, wVertNum2, wVertNum3; \
    LPBYTE      pVertex1, pVertex2, pVertex3;
#endif  //LINE
#ifdef  INDEX2
#define FOR_ALL_VERTICES \
    for (i = 0; i < dwCount; i++, pIndices += sizeof(D3DHAL_DP2INDEXEDTRIANGLELIST2))
#define GET_V1_POINTER \
    wVertNum1 = ((LPD3DHAL_DP2INDEXEDTRIANGLELIST2)pIndices)->wV1;          \
    nvAssert(wVertNum1 < pStereoData->dwVertexRegisterSize); \
    pVertex1 = &pVertices[wVertNum1*pContext->pCurrentVShader->getStride()];
#define GET_V2_POINTER \
    wVertNum2 = ((LPD3DHAL_DP2INDEXEDTRIANGLELIST2)pIndices)->wV2;          \
    nvAssert(wVertNum2 < pStereoData->dwVertexRegisterSize); \
    pVertex2 = &pVertices[wVertNum2*pContext->pCurrentVShader->getStride()];
#define GET_V3_POINTER \
    wVertNum3 = ((LPD3DHAL_DP2INDEXEDTRIANGLELIST2)pIndices)->wV3;          \
    nvAssert(wVertNum3 < pStereoData->dwVertexRegisterSize); \
    pVertex3 = &pVertices[wVertNum3*pContext->pCurrentVShader->getStride()];
#else   //INDEX2==0
#ifdef  LINE
#define FOR_ALL_VERTICES \
    for (i = 0; i < dwCount; i++, pIndices += sizeof(D3DHAL_DP2INDEXEDLINELIST))
#define GET_V1_POINTER \
    wVertNum1 = ((LPD3DHAL_DP2INDEXEDLINELIST)pIndices)->wV1;           \
    nvAssert(wVertNum1 < pStereoData->dwVertexRegisterSize); \
    pVertex1 = &pVertices[wVertNum1*pContext->pCurrentVShader->getStride()];
#define GET_V2_POINTER \
    wVertNum2 = ((LPD3DHAL_DP2INDEXEDLINELIST)pIndices)->wV2;           \
    nvAssert(wVertNum2 < pStereoData->dwVertexRegisterSize); \
    pVertex2 = &pVertices[wVertNum2*pContext->pCurrentVShader->getStride()];
#else   //LINE==0
#define FOR_ALL_VERTICES \
    for (i = 0; i < dwCount; i++, pIndices += sizeof(D3DHAL_DP2INDEXEDTRIANGLELIST))
#define GET_V1_POINTER \
    wVertNum1 = ((LPD3DHAL_DP2INDEXEDTRIANGLELIST)pIndices)->wV1;           \
    nvAssert(wVertNum1 < pStereoData->dwVertexRegisterSize); \
    pVertex1 = &pVertices[wVertNum1*pContext->pCurrentVShader->getStride()];
#define GET_V2_POINTER \
    wVertNum2 = ((LPD3DHAL_DP2INDEXEDTRIANGLELIST)pIndices)->wV2;           \
    nvAssert(wVertNum2 < pStereoData->dwVertexRegisterSize); \
    pVertex2 = &pVertices[wVertNum2*pContext->pCurrentVShader->getStride()];
#define GET_V3_POINTER \
    wVertNum3 = ((LPD3DHAL_DP2INDEXEDTRIANGLELIST)pIndices)->wV3;           \
    nvAssert(wVertNum3 < pStereoData->dwVertexRegisterSize); \
    pVertex3 = &pVertices[wVertNum3*pContext->pCurrentVShader->getStride()];
#endif  //LINE
#endif  //INDEX2
#endif  //FAN_OR_STRIP
#else   //INDEX=0
#define DEFINE_LOCALS
#define FOR_ALL_VERTICES \
    for (i = 0; i < dwCount; i++, pVertices += pContext->pCurrentVShader->getStride())
#endif  //INDEX

BOOL
CHECK_RHW_CONDITION (
        PNVD3DCONTEXT pContext,
        LPBYTE pVertices,
    #ifdef INDEX
        LPBYTE pIndices,
    #endif //INDEX
        DWORD dwCount,
        DWORD dwCondition)
{
    DWORD       i;
    D3DVALUE    fRHW, fZ;
#ifdef  INDEX
    DEFINE_LOCALS;
#ifdef  FAN_OR_STRIP
    dwCount += 2;
#endif  //FAN_OR_STRIP
#else   //INDEX=0
#ifdef  FAN_OR_STRIP
#ifdef  LINE
    dwCount += 1;
#else   //LINE==0 (TRIANGLE)
    dwCount += 2;
#endif  //LINE
#else   //FAN_OR_STRIP=0
#ifndef POINT
#ifdef  LINE
    dwCount *= 2;
#else   //LINE==0 (TRIANGLE)
    dwCount *= 3;
#endif  //LINE
#endif  //POINT
#endif  //FAN_OR_STRIP
#endif  //INDEX
    switch (dwCondition)
    {
#ifdef  STEREO_CONFIG_ASSIST
    case EQUAL:
        if (pStereoData->StereoSettings.dwFlags & STEREO_FAVORSZOVERRHW)
        {
        //Check if the farthest 2D object is farther than the closest 3D object.
        //If so we need to reinitialize the farthest 2D object.
        if (ConfigAssistInfo.szMax2D > ConfigAssistInfo.szMin)
                ConfigAssistInfo.szMax2D = -9999.f;
        //Check if the closest 2D object is closer than the farthest 3D object.
        //If so we need to reinitialize the closest 2D object.
        if (ConfigAssistInfo.szMin2D < ConfigAssistInfo.szMax)
            ConfigAssistInfo.szMin2D = 9999.f;
            DWORD dwZ;
            BOOL  bForce2D;
            bForce2D = FALSE;
#ifdef  INDEX
            GET_V1_POINTER;
            dwZ = Z_I(pVertex1);
#else   //INDEX=0
            dwZ = Z_I(pVertices);
#endif  //INDEX
            if (pStereoData->StereoSettings.dwFlags & STEREO_RHWEQUALATSCREEN)
            {
#if 0
                if (*(LPD3DVALUE)&dwZ >= pStereoData->fRHW2DDetectionMin)
                    bForce2D = TRUE;
#endif
                if (*(LPD3DVALUE)&dwZ > ConfigAssistInfo.szMin
                    && *(LPD3DVALUE)&dwZ < ConfigAssistInfo.szMax) //This object is inside the 3D object range.
                    bForce2D = TRUE;
            } else
            {
#if 0
                if (*(LPD3DVALUE)&dwZ >= pStereoData->fRHW2DDetectionMin)
                    return FALSE;
#endif
                if (*(LPD3DVALUE)&dwZ > ConfigAssistInfo.szMin
                    && *(LPD3DVALUE)&dwZ < ConfigAssistInfo.szMax) //This object is inside the 3D object range.
                    return FALSE;
            }
            FOR_ALL_VERTICES {
#ifdef  INDEX
                GET_V1_POINTER;
                if (Z_I(pVertex1) != dwZ)
                    return FALSE;
#ifndef FAN_OR_STRIP
                GET_V2_POINTER;
                if (Z_I(pVertex2) != dwZ)
                    return FALSE;
#ifndef LINE
                GET_V3_POINTER;
                if (Z_I(pVertex3) != dwZ)
                    return FALSE;
#endif  //LINE
#endif  //FAN_OR_STRIP
#else   //INDEX=0
                if (Z_I(pVertices) != dwZ)
                    return FALSE;
#endif  //INDEX
            }
            if (!bForce2D)
            {
                if (ConfigAssistInfo.szMin > *(LPD3DVALUE)&dwZ)
                {
                    //Closer than all 3D
                    if (ConfigAssistInfo.szMax2D < *(LPD3DVALUE)&dwZ)
                        ConfigAssistInfo.szMax2D = *(LPD3DVALUE)&dwZ;
                } else
                {
                    //Farther than all 3D
                    if (ConfigAssistInfo.szMin2D > *(LPD3DVALUE)&dwZ)
                        ConfigAssistInfo.szMin2D = *(LPD3DVALUE)&dwZ;
                }
            }
#ifdef  FLAT_STAT
            RegisterFlatObject(*(LPD3DVALUE)&dwZ, dwCount);
#endif  //FLAT_STAT
            return TRUE;
        }
        //Check if the farthest 2D object is farther than the closest 3D object.
        //If so we need to reinitialize the farthest 2D object.
        if (ConfigAssistInfo.rhwMin2D < ConfigAssistInfo.rhwMax)
            ConfigAssistInfo.rhwMin2D = 9999.f;
        //Check if the closest 2D object is closer than the farthest 3D object.
        //If so we need to reinitialize the closest 2D object.
        if (ConfigAssistInfo.rhwMax2D > ConfigAssistInfo.rhwMin)
            ConfigAssistInfo.rhwMax2D = -9999.f;
        DWORD dwRHW;
        BOOL  bForce2D;
        bForce2D = FALSE;
#ifdef  INDEX
        GET_V1_POINTER;
        dwRHW = RHW_I(pVertex1);
#else   //INDEX=0
        dwRHW = RHW_I(pVertices);
#endif  //INDEX
        if (pStereoData->StereoSettings.dwFlags & STEREO_RHWEQUALATSCREEN)
        {
            if (*(LPD3DVALUE)&dwRHW <= pStereoData->fRHW2DDetectionMin)
                bForce2D = TRUE;
            if (*(LPD3DVALUE)&dwRHW < ConfigAssistInfo.rhwMax
                && *(LPD3DVALUE)&dwRHW > ConfigAssistInfo.rhwMin) //This object is inside the 3D object range.
                bForce2D = TRUE;
        } else
        {
            if (*(LPD3DVALUE)&dwRHW <= pStereoData->fRHW2DDetectionMin)
                return FALSE;
            if (*(LPD3DVALUE)&dwRHW < ConfigAssistInfo.rhwMax
                && *(LPD3DVALUE)&dwRHW > ConfigAssistInfo.rhwMin) //This object is inside the 3D object range.
                return FALSE;
        }
        FOR_ALL_VERTICES {
#ifdef  INDEX
            GET_V1_POINTER;
            if (RHW_I(pVertex1) != dwRHW)
                return FALSE;
#ifndef FAN_OR_STRIP
            GET_V2_POINTER;
            if (RHW_I(pVertex2) != dwRHW)
                return FALSE;
#ifndef LINE
            GET_V3_POINTER;
            if (RHW_I(pVertex3) != dwRHW)
                return FALSE;
#endif  //LINE
#endif  //FAN_OR_STRIP
#else   //INDEX=0
            if (RHW_I(pVertices) != dwRHW)
                return FALSE;
#endif  //INDEX
        }
        if (!bForce2D)
        {
            if (ConfigAssistInfo.rhwMax < *(LPD3DVALUE)&dwRHW)
            {
                //Closer than all 3D
                if (ConfigAssistInfo.rhwMin2D > *(LPD3DVALUE)&dwRHW)
                    ConfigAssistInfo.rhwMin2D = *(LPD3DVALUE)&dwRHW;
            } else
            {
                //Farther than all 3D
                if (ConfigAssistInfo.rhwMax2D < *(LPD3DVALUE)&dwRHW)
                    ConfigAssistInfo.rhwMax2D = *(LPD3DVALUE)&dwRHW;
            }
        }
#ifdef  FLAT_STAT
        RegisterFlatObject(*(LPD3DVALUE)&dwRHW, dwCount);
#endif  //FLAT_STAT
        return TRUE;
#endif  //STEREO_CONFIG_ASSIST

    case GREATER:
        if (pStereoData->StereoSettings.dwFlags & STEREO_FAVORSZOVERRHW)
        {
            fZ = pStereoData->StereoSettings.fRHWGreaterAtScreen;
            FOR_ALL_VERTICES {
#ifdef  INDEX
                GET_V1_POINTER;
                if (Z(pVertex1) > fZ)
                    return FALSE;
#ifndef FAN_OR_STRIP
                GET_V2_POINTER;
                if (Z(pVertex2) > fZ)
                    return FALSE;
#ifndef LINE
                GET_V3_POINTER;
                if (Z(pVertex3) > fZ)
                    return FALSE;
#endif  //LINE
#endif  //FAN_OR_STRIP
#else   //INDEX=0
                if (Z(pVertices) > fZ)
                    return FALSE;
#endif  //INDEX
            }
            return TRUE;
        }
        fRHW = pStereoData->StereoSettings.fRHWGreaterAtScreen;
        FOR_ALL_VERTICES {
#ifdef  INDEX
            GET_V1_POINTER;
            if (RHW(pVertex1) < fRHW)
                return FALSE;
#ifndef FAN_OR_STRIP
            GET_V2_POINTER;
            if (RHW(pVertex2) < fRHW)
                return FALSE;
#ifndef LINE
            GET_V3_POINTER;
            if (RHW(pVertex3) < fRHW)
                return FALSE;
#endif  //LINE
#endif  //FAN_OR_STRIP
#else   //INDEX=0
            if (RHW(pVertices) < fRHW)
                return FALSE;
#endif  //INDEX
        }
        return TRUE;

    case LESS:
        if (pStereoData->StereoSettings.dwFlags & STEREO_FAVORSZOVERRHW)
        {
            fZ = pStereoData->StereoSettings.fRHWLessAtScreen;
            FOR_ALL_VERTICES {
#ifdef  INDEX
                GET_V1_POINTER;
                if (Z(pVertex1) < fZ)
                    return FALSE;
#ifndef FAN_OR_STRIP
                GET_V2_POINTER;
                if (Z(pVertex2) < fZ)
                    return FALSE;
#ifndef LINE
                GET_V3_POINTER;
                if (Z(pVertex3) < fZ)
                    return FALSE;
#endif  //LINE
#endif  //FAN_OR_STRIP
#else   //INDEX=0
                if (Z(pVertices) < fZ)
                    return FALSE;
#endif  //INDEX
            }
            return TRUE;
        }
        //Some games like Triple Play 2001 put pop up 2D menus as
        //farthest objects in the scene. Stupid but we have to handle it.
        fRHW = pStereoData->StereoSettings.fRHWLessAtScreen;
        FOR_ALL_VERTICES {
#ifdef  INDEX
            GET_V1_POINTER;
            if (RHW(pVertex1) > fRHW)
                return FALSE;
#ifndef FAN_OR_STRIP
            GET_V2_POINTER;
            if (RHW(pVertex2) > fRHW)
                return FALSE;
#ifndef LINE
            GET_V3_POINTER;
            if (RHW(pVertex3) > fRHW)
                return FALSE;
#endif  //LINE
#endif  //FAN_OR_STRIP
#else   //INDEX=0
            if (RHW(pVertices) > fRHW)
                return FALSE;
#endif  //INDEX
        }
        return TRUE;

    default:
        LOG("%s: unsupported case", GET_REAL_NAME(CHECK_RHW_CONDITION) );
		nvAssert(0);
        break;
    }
    return FALSE;
}

DWORD
STEREO_EYE_FUNCTION_FLIP (
        PNVD3DCONTEXT pContext,
        LPBYTE pVertices,
    #ifdef INDEX
        LPBYTE pIndices,
    #endif //INDEX
        DWORD dwCount)
{
    DWORD       i;
    DWORD       res = 0;
    D3DVALUE    XCorrection;
    DEFINE_LOCALS;

    nvAssert(pStereoData->pVertexRegister);
    if (pStereoData->pVertexRegister->DoAutomaticStage_Flip())
    {
        //Everything has been done automatically.
        return 0;
    }
    //We're required to fill out the stage for the first eye.
#ifdef  INDEX
    pStereoData->pVertexRegister->cleanupInUse();
#ifdef  FAN_OR_STRIP
    dwCount += 2;
#endif  //FAN_OR_STRIP
#else   //INDEX=0
#ifdef  FAN_OR_STRIP
#ifdef  LINE
    dwCount += 1;
#else   //LINE==0 (TRIANGLE)
    dwCount += 2;
#endif  //LINE
#else   //FAN_OR_STRIP=0
#ifndef POINT
#ifdef  LINE
    dwCount *= 2;
#else   //LINE==0 (TRIANGLE)
    dwCount *= 3;
#endif  //LINE
#endif  //POINT
#endif  //FAN_OR_STRIP
#endif  //INDEX

    if (pStereoData->dwLastEye == EYE_LEFT)
    {
        //We're doing the left eye first
        FOR_ALL_VERTICES {
#ifdef  INDEX
            GET_V1_POINTER;
            if (!pStereoData->pVertexRegister->isInUseTag(wVertNum1))
            {
                //Unique vertex.
                pStereoData->pVertexRegister->SaveX((LPD3DVALUE)pVertex1);
                XCorrection = pStereoData->StereoSettings.fScreenStereoSeparation*(1.0f - RHW(pVertex1)*pStereoData->StereoSettings.fPostStereoConvergence);
                pStereoData->pVertexRegister->SaveXCorrection_Flip(XCorrection);
                X(pVertex1) = X(pVertex1) * pStereoData->StereoSettings.fPostStereoXStretch - pStereoData->StereoSettings.fPostStereoXShift - XCorrection;
#ifdef  STEREO_CONFIG_ASSIST
                if (!(ConfigAssistInfo.dwFlags & _2DSUSPECT))
                {
#endif  //STEREO_CONFIG_ASSIST
                    if (pStereoData->fFrameRHWMax < RHW(pVertex1))
                        pStereoData->fFrameRHWMax = RHW(pVertex1);
#ifdef  STEREO_CONFIG_ASSIST
                    if (ConfigAssistInfo.rhwMin > RHW(pVertex1))
                        ConfigAssistInfo.rhwMin = RHW(pVertex1);
                    if (ConfigAssistInfo.szMin > Z(pVertex1))
                        ConfigAssistInfo.szMin = Z(pVertex1);
                    if (ConfigAssistInfo.szMax < Z(pVertex1))
                        ConfigAssistInfo.szMax = Z(pVertex1);
                }
#endif  //STEREO_CONFIG_ASSIST
            }
#ifndef FAN_OR_STRIP
            GET_V2_POINTER;
            if (!pStereoData->pVertexRegister->isInUseTag(wVertNum2))
            {
                //Unique vertex.
                pStereoData->pVertexRegister->SaveX((LPD3DVALUE)pVertex2);
                XCorrection = pStereoData->StereoSettings.fScreenStereoSeparation*(1.0f - RHW(pVertex2)*pStereoData->StereoSettings.fPostStereoConvergence);
                pStereoData->pVertexRegister->SaveXCorrection_Flip(XCorrection);
                X(pVertex2) = X(pVertex2) * pStereoData->StereoSettings.fPostStereoXStretch - pStereoData->StereoSettings.fPostStereoXShift - XCorrection;
#ifdef  STEREO_CONFIG_ASSIST
                if (!(ConfigAssistInfo.dwFlags & _2DSUSPECT))
                {
#endif  //STEREO_CONFIG_ASSIST
                    if (pStereoData->fFrameRHWMax < RHW(pVertex2))
                        pStereoData->fFrameRHWMax = RHW(pVertex2);
#ifdef  STEREO_CONFIG_ASSIST
                    if (ConfigAssistInfo.rhwMin > RHW(pVertex2))
                        ConfigAssistInfo.rhwMin = RHW(pVertex2);
                    if (ConfigAssistInfo.szMin > Z(pVertex2))
                        ConfigAssistInfo.szMin = Z(pVertex2);
                    if (ConfigAssistInfo.szMax < Z(pVertex2))
                        ConfigAssistInfo.szMax = Z(pVertex2);
                }
#endif  //STEREO_CONFIG_ASSIST
            }
#ifndef LINE
            GET_V3_POINTER;
            if (!pStereoData->pVertexRegister->isInUseTag(wVertNum3))
            {
                //Unique vertex.
                pStereoData->pVertexRegister->SaveX((LPD3DVALUE)pVertex3);
                XCorrection = pStereoData->StereoSettings.fScreenStereoSeparation*(1.0f - RHW(pVertex3)*pStereoData->StereoSettings.fPostStereoConvergence);
                pStereoData->pVertexRegister->SaveXCorrection_Flip(XCorrection);
                X(pVertex3) = X(pVertex3) * pStereoData->StereoSettings.fPostStereoXStretch - pStereoData->StereoSettings.fPostStereoXShift - XCorrection;
#ifdef  STEREO_CONFIG_ASSIST
                if (!(ConfigAssistInfo.dwFlags & _2DSUSPECT))
                {
#endif  //STEREO_CONFIG_ASSIST
                    if (pStereoData->fFrameRHWMax < RHW(pVertex3))
                        pStereoData->fFrameRHWMax = RHW(pVertex3);
#ifdef  STEREO_CONFIG_ASSIST
                    if (ConfigAssistInfo.rhwMin > RHW(pVertex3))
                        ConfigAssistInfo.rhwMin = RHW(pVertex3);
                    if (ConfigAssistInfo.szMin > Z(pVertex3))
                        ConfigAssistInfo.szMin = Z(pVertex3);
                    if (ConfigAssistInfo.szMax < Z(pVertex3))
                        ConfigAssistInfo.szMax = Z(pVertex3);
                }
#endif  //STEREO_CONFIG_ASSIST
            }
#endif  //LINE
#endif  //FAN_OR_STRIP
#else   //INDEX=0
            pStereoData->pVertexRegister->SaveX((LPD3DVALUE)pVertices);
            XCorrection = pStereoData->StereoSettings.fScreenStereoSeparation*(1.0f - RHW(pVertices)*pStereoData->StereoSettings.fPostStereoConvergence);
            pStereoData->pVertexRegister->SaveXCorrection_Flip(XCorrection);
            X(pVertices) = X(pVertices) * pStereoData->StereoSettings.fPostStereoXStretch - pStereoData->StereoSettings.fPostStereoXShift - XCorrection;
#ifdef  STEREO_CONFIG_ASSIST
            if (!(ConfigAssistInfo.dwFlags & _2DSUSPECT))
            {
#endif  //STEREO_CONFIG_ASSIST
                if (pStereoData->fFrameRHWMax < RHW(pVertices))
                    pStereoData->fFrameRHWMax = RHW(pVertices);
#ifdef  STEREO_CONFIG_ASSIST
                if (ConfigAssistInfo.rhwMin > RHW(pVertices))
                    ConfigAssistInfo.rhwMin = RHW(pVertices);
                if (ConfigAssistInfo.szMin > Z(pVertices))
                    ConfigAssistInfo.szMin = Z(pVertices);
                if (ConfigAssistInfo.szMax < Z(pVertices))
                    ConfigAssistInfo.szMax = Z(pVertices);
            }
#endif  //STEREO_CONFIG_ASSIST
#endif  //INDEX
        }
    } else
    {
        //We're doing the right eye first
        FOR_ALL_VERTICES {
#ifdef  INDEX
            GET_V1_POINTER;
            if (!pStereoData->pVertexRegister->isInUseTag(wVertNum1))
            {
                //Unique vertex.
                pStereoData->pVertexRegister->SaveX((LPD3DVALUE)pVertex1);
                XCorrection = pStereoData->StereoSettings.fScreenStereoSeparation*(1.0f - RHW(pVertex1)*pStereoData->StereoSettings.fPostStereoConvergence);
                pStereoData->pVertexRegister->SaveXCorrection_Flip(XCorrection);
                X(pVertex1) = X(pVertex1) * pStereoData->StereoSettings.fPostStereoXStretch - pStereoData->StereoSettings.fPostStereoXShift + XCorrection;
#ifdef  STEREO_CONFIG_ASSIST
                if (!(ConfigAssistInfo.dwFlags & _2DSUSPECT))
                {
#endif  //STEREO_CONFIG_ASSIST
                    if (pStereoData->fFrameRHWMax < RHW(pVertex1))
                        pStereoData->fFrameRHWMax = RHW(pVertex1);
#ifdef  STEREO_CONFIG_ASSIST
                    if (ConfigAssistInfo.rhwMin > RHW(pVertex1))
                        ConfigAssistInfo.rhwMin = RHW(pVertex1);
                    if (ConfigAssistInfo.szMin > Z(pVertex1))
                        ConfigAssistInfo.szMin = Z(pVertex1);
                    if (ConfigAssistInfo.szMax < Z(pVertex1))
                        ConfigAssistInfo.szMax = Z(pVertex1);
                }
#endif  //STEREO_CONFIG_ASSIST
            }
#ifndef FAN_OR_STRIP
            GET_V2_POINTER;
            if (!pStereoData->pVertexRegister->isInUseTag(wVertNum2))
            {
                //Unique vertex.
                pStereoData->pVertexRegister->SaveX((LPD3DVALUE)pVertex2);
                XCorrection = pStereoData->StereoSettings.fScreenStereoSeparation*(1.0f - RHW(pVertex2)*pStereoData->StereoSettings.fPostStereoConvergence);
                pStereoData->pVertexRegister->SaveXCorrection_Flip(XCorrection);
                X(pVertex2) = X(pVertex2) * pStereoData->StereoSettings.fPostStereoXStretch - pStereoData->StereoSettings.fPostStereoXShift + XCorrection;
#ifdef  STEREO_CONFIG_ASSIST
                if (!(ConfigAssistInfo.dwFlags & _2DSUSPECT))
                {
#endif  //STEREO_CONFIG_ASSIST
                    if (pStereoData->fFrameRHWMax < RHW(pVertex2))
                        pStereoData->fFrameRHWMax = RHW(pVertex2);
#ifdef  STEREO_CONFIG_ASSIST
                    if (ConfigAssistInfo.rhwMin > RHW(pVertex2))
                        ConfigAssistInfo.rhwMin = RHW(pVertex2);
                    if (ConfigAssistInfo.szMin > Z(pVertex2))
                        ConfigAssistInfo.szMin = Z(pVertex2);
                    if (ConfigAssistInfo.szMax < Z(pVertex2))
                        ConfigAssistInfo.szMax = Z(pVertex2);
                }
#endif  //STEREO_CONFIG_ASSIST
            }
#ifndef LINE
            GET_V3_POINTER;
            if (!pStereoData->pVertexRegister->isInUseTag(wVertNum3))
            {
                //Unique vertex.
                pStereoData->pVertexRegister->SaveX((LPD3DVALUE)pVertex3);
                XCorrection = pStereoData->StereoSettings.fScreenStereoSeparation*(1.0f - RHW(pVertex3)*pStereoData->StereoSettings.fPostStereoConvergence);
                pStereoData->pVertexRegister->SaveXCorrection_Flip(XCorrection);
                X(pVertex3) = X(pVertex3) * pStereoData->StereoSettings.fPostStereoXStretch - pStereoData->StereoSettings.fPostStereoXShift + XCorrection;
#ifdef  STEREO_CONFIG_ASSIST
                if (!(ConfigAssistInfo.dwFlags & _2DSUSPECT))
                {
#endif  //STEREO_CONFIG_ASSIST
                    if (pStereoData->fFrameRHWMax < RHW(pVertex3))
                        pStereoData->fFrameRHWMax = RHW(pVertex3);
#ifdef  STEREO_CONFIG_ASSIST
                    if (ConfigAssistInfo.rhwMin > RHW(pVertex3))
                        ConfigAssistInfo.rhwMin = RHW(pVertex3);
                    if (ConfigAssistInfo.szMin > Z(pVertex3))
                        ConfigAssistInfo.szMin = Z(pVertex3);
                    if (ConfigAssistInfo.szMax < Z(pVertex3))
                        ConfigAssistInfo.szMax = Z(pVertex3);
                }
#endif  //STEREO_CONFIG_ASSIST
            }
#endif  //LINE
#endif  //FAN_OR_STRIP
#else   //INDEX=0
            pStereoData->pVertexRegister->SaveX((LPD3DVALUE)pVertices);
            XCorrection = pStereoData->StereoSettings.fScreenStereoSeparation*(1.0f - RHW(pVertices)*pStereoData->StereoSettings.fPostStereoConvergence);
            pStereoData->pVertexRegister->SaveXCorrection_Flip(XCorrection);
            X(pVertices) = X(pVertices) * pStereoData->StereoSettings.fPostStereoXStretch - pStereoData->StereoSettings.fPostStereoXShift + XCorrection;
#ifdef  STEREO_CONFIG_ASSIST
            if (!(ConfigAssistInfo.dwFlags & _2DSUSPECT))
            {
#endif  //STEREO_CONFIG_ASSIST
                if (pStereoData->fFrameRHWMax < RHW(pVertices))
                    pStereoData->fFrameRHWMax = RHW(pVertices);
#ifdef  STEREO_CONFIG_ASSIST
                if (ConfigAssistInfo.rhwMin > RHW(pVertices))
                    ConfigAssistInfo.rhwMin = RHW(pVertices);
                if (ConfigAssistInfo.szMin > Z(pVertices))
                    ConfigAssistInfo.szMin = Z(pVertices);
                if (ConfigAssistInfo.szMax < Z(pVertices))
                    ConfigAssistInfo.szMax = Z(pVertices);
            }
#endif  //STEREO_CONFIG_ASSIST
#endif  //INDEX
        }
    }
    return res;
}

#ifndef	DRAWPRIMITIVE
#ifndef POINT
HRESULT STEREO_DP2_FUNCTION_FLIP (NV_DP2FUNCTION_ARGLIST)
{
    HRESULT             RetVal;
    DWORD               dwDP2Op = (DWORD)((*ppCommands)->bCommand);
    LPD3DHAL_DP2COMMAND pSaveCommandsPtr = *ppCommands;

#ifdef	STEREO_DEBUG
	//Make sure it is not a rendering to a texture
	CNvObject *pNvObj = pContext->pRenderTarget->getWrapper();
	if (pNvObj->getClass() == CNvObject::NVOBJ_TEXTURE)
		__asm int 3
	//Make sure we render to a stereo surface
	if (pContext->pRenderTarget->isStereo() == 0)
		__asm int 3
	//Do we render to the Z buffer?
	if (pContext->pRenderTarget->isZBuffer())
		__asm int 3
#endif	//STEREO_DEBUG

    StereoLockSubstituteFlush();

    // First thing to determine is whether we take a HW T&L or SW T&L route. It breaks
    // down all our code into two vertually mutually exclusive cases. It is better to keep 
    // it this way for optimal performance
    if (!STEREO_R_US(pContext))
    {
        RetVal = (*(nvDP2SetFuncs_Orig[dwDP2Op]))(pContext,
                                                  ppCommands,
                                                  pCommandBufferEnd,
                                                  pdwDP2RStates,
                                                  dwDP2Flags);
        return RetVal;
    }
    if (pStereoData->dwHWTnL)
    {
        //This case is going to be the most frequently used in future. We want it fast.
        SetupStereoContext(pContext);
        RetVal = (*(nvDP2SetFuncs_Orig[dwDP2Op]))(pContext,
                                                  ppCommands,
                                                  pCommandBufferEnd,
                                                  pdwDP2RStates,
                                                  dwDP2Flags);
        *ppCommands = pSaveCommandsPtr; //Restore it for the second pass.
        AlternateStereoContext(pContext);
        RetVal = (*(nvDP2SetFuncs_Orig[dwDP2Op]))(pContext,
                                                  ppCommands,
                                                  pCommandBufferEnd,
                                                  pdwDP2RStates,
                                                  dwDP2Flags);
        return RetVal;
    }
    
    // And now is SW T&L or HW T&L with transformed vertices
    LPBYTE pVertexBufferBase = (LPBYTE)(pContext->ppDX8Streams[0]->getAddress());

#ifdef  PARTIALRENDERING
    if (PrimitiveStat[4] == PrimitiveStat[1])
       nvAssert(0);
#endif  //PARTIALRENDERING

#ifdef  NOT_IMPLEMENTED
    //LOG("%s: not implemented yet",GET_REAL_NAME( STEREO_DP2_FUNCTION_FLIP ));
    nvAssert (0);
    return ((*(nvDP2SetFuncs_Orig[dwDP2Op]))(pContext,
                                             ppCommands,
                                             pCommandBufferEnd,
                                             pdwDP2RStates,
                                             dwDP2Flags));
#else   //~NOT_IMPLEMENTED
    //nvAssert (0);
    WORD   wCommandCount = (*ppCommands)->wPrimitiveCount;
    LPBYTE lpPrim        = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);
#ifdef  INDEX
#ifdef  START_VERTEX
    DWORD dwVertexBufferOffset = pContext->dp2.dwVertexBufferOffset;
    DWORD  dwTotalOffset = dwVertexBufferOffset + ((DWORD)((LPD3DHAL_DP2STARTVERTEX)lpPrim)->wVStart * pContext->pCurrentVShader->getStride());
    pContext->dp2.dwVStart = (DWORD)((LPD3DHAL_DP2STARTVERTEX)lpPrim)->wVStart;
    pContext->dp2.dwTotalOffset = dwTotalOffset;
    LPBYTE pVertices     = (LPBYTE)(pVertexBufferBase+dwTotalOffset);
    LPBYTE pIndices      = lpPrim + sizeof(D3DHAL_DP2STARTVERTEX);
#else   //START_VERTEX==0
    DWORD dwVertexBufferOffset = pContext->dp2.dwVertexBufferOffset;
    pContext->dp2.dwVStart = 0;
    pContext->dp2.dwTotalOffset = dwVertexBufferOffset;
    LPBYTE pVertices     = (LPBYTE)(pVertexBufferBase+dwVertexBufferOffset);
    LPBYTE pIndices      = lpPrim;
#endif  //START_VERTEX
    PSTEREOEYEFUNCINDEX pStereoEyeFunc = NULL;
#else   //INDEX==0
#ifdef  FAN_OR_STRIP
#ifdef  START_VERTEX
    DWORD dwVertexBufferOffset = pContext->dp2.dwVertexBufferOffset;
    DWORD  dwTotalOffset = dwVertexBufferOffset + ((DWORD)((LPD3DHAL_DP2STARTVERTEX)lpPrim)->wVStart * pContext->pCurrentVShader->getStride());
    pContext->dp2.dwVStart = (DWORD)((LPD3DHAL_DP2STARTVERTEX)lpPrim)->wVStart;
    pContext->dp2.dwTotalOffset = dwTotalOffset;
    LPBYTE pVertices     = (LPBYTE)(pVertexBufferBase+dwTotalOffset);
#else   //START_VERTEX==0
    LPBYTE pVertices     = lpPrim;
    pContext->dp2.dwVStart = 0;
    pContext->dp2.dwTotalOffset = 0;
#endif  //START_VERTEX
#ifdef  ADVANCE
    pVertices += sizeof(ADVANCE);
#endif  //ADVANCE
#ifdef  ALIGN
    pVertices = (LPBYTE)(((DWORD)pVertices + 3) & ~3);
#endif  //ALIGN
#else   //FAN_OR_STRIP==0
    DWORD dwVertexBufferOffset = pContext->dp2.dwVertexBufferOffset;
    DWORD  dwTotalOffset = dwVertexBufferOffset + ((DWORD)((LPD3DHAL_DP2STARTVERTEX)lpPrim)->wVStart * pContext->pCurrentVShader->getStride());
    pContext->dp2.dwVStart = (DWORD)((LPD3DHAL_DP2STARTVERTEX)lpPrim)->wVStart;
    pContext->dp2.dwTotalOffset = dwTotalOffset;
    LPBYTE pVertices     = (LPBYTE)(pVertexBufferBase+dwTotalOffset);
#endif  //FAN_OR_STRIP==0
    PSTEREOEYEFUNC      pStereoEyeFunc = NULL;
#endif  //INDEX

#ifdef  STEREO_CONFIG_ASSIST
    ConfigAssistInfo.dwFlags &= ~_2DSUSPECT;
#endif  //STEREO_CONFIG_ASSIST

    SetupStereoContext(pContext);
    if (NV_VERTEX_TRANSFORMED(pContext->pCurrentVShader))
    {
        pStereoEyeFunc = STEREO_EYE_FUNCTION_FLIP;
#ifdef  INDEX
#ifdef  STEREO_CONFIG_ASSIST
#if 1
        if (CHECK_RHW_CONDITION (pContext, pVertices, pIndices, (DWORD)wCommandCount, EQUAL))
            ConfigAssistInfo.dwFlags |= _2DSUSPECT;
#else
        if (CHECK_RHW_CONDITION (pVertices, pIndices, (DWORD)wCommandCount, EQUAL))
            pStereoEyeFunc = NULL;
#endif
#endif  //STEREO_CONFIG_ASSIST
        if (pStereoData->StereoSettings.dwFlags & STEREO_RHWGREATERATSCREEN)
        {
            if (CHECK_RHW_CONDITION (pContext, pVertices, pIndices, (DWORD)wCommandCount, GREATER))
                pStereoEyeFunc = NULL;
        }
        if (pStereoData->StereoSettings.dwFlags & STEREO_RHWLESSATSCREEN)
        {
            if (CHECK_RHW_CONDITION (pContext, pVertices, pIndices, (DWORD)wCommandCount, LESS))
                pStereoEyeFunc = NULL;
        }
        if (pStereoEyeFunc)
		{
#ifdef	STEREO_DEBUG
			//Make sure vertices are in the system memory. Otherwise it is going to be sooo slow.
			CVertexBuffer      *pVertexBuffer = pContext->ppDX8Streams[0];
			if (pVertexBuffer && pVertexBuffer->getHeapLocation() != CSimpleSurface::HEAP_SYS)
				__asm int 3
#endif	//STEREO_DEBUG
            (*pStereoEyeFunc)(pContext, pVertices, pIndices, (DWORD)wCommandCount);
		}
#else   //INDEX==0
#ifdef  STEREO_CONFIG_ASSIST
#if 1
        if (CHECK_RHW_CONDITION (pContext, pVertices, (DWORD)wCommandCount, EQUAL))
            ConfigAssistInfo.dwFlags |= _2DSUSPECT;
#else
        if (CHECK_RHW_CONDITION (pContext, pVertices, (DWORD)wCommandCount, EQUAL))
            pStereoEyeFunc = NULL;
#endif
#endif  //STEREO_CONFIG_ASSIST
        if (pStereoData->StereoSettings.dwFlags & STEREO_RHWGREATERATSCREEN)
        {
            if (CHECK_RHW_CONDITION (pContext, pVertices, (DWORD)wCommandCount, GREATER))
                pStereoEyeFunc = NULL;
        }
        if (pStereoData->StereoSettings.dwFlags & STEREO_RHWLESSATSCREEN)
        {
            if (CHECK_RHW_CONDITION (pContext, pVertices, (DWORD)wCommandCount, LESS))
                pStereoEyeFunc = NULL;
        }
        if (pStereoEyeFunc)
            (*pStereoEyeFunc)(pContext, pVertices, (DWORD)wCommandCount);
#endif  //INDEX
    }
    RetVal = (*(nvDP2SetFuncs_Orig[dwDP2Op]))(pContext,
                                              ppCommands,
                                              pCommandBufferEnd,
                                              pdwDP2RStates,
                                              dwDP2Flags);
#ifdef  PER_PRIMITIVE_SYNC
    StereoSync();
#endif  //PER_PRIMITIVE_SYNC

#ifdef  PARTIALRENDERING
    PrimitiveStat[1]++;
    if (PrimitiveStat[2] > PrimitiveStat[1] || PrimitiveStat[3] < PrimitiveStat[1])
    {
        if (pStereoEyeFunc)
        {
#ifdef  INDEX
            (*pStereoEyeFunc)(pContext, pVertices, pIndices, (DWORD)wCommandCount);
            (*pStereoEyeFunc)(pContext, pVertices, pIndices, (DWORD)wCommandCount);
#else   //INDEX==0
            (*pStereoEyeFunc)(pContext, pVertices, (DWORD)wCommandCount);
            (*pStereoEyeFunc)(pContext, pVertices, (DWORD)wCommandCount);
#endif  //INDEX
        }
        return RetVal;
    }
#endif  //PARTIALRENDERING

#ifndef ONE_EYE
    AlternateStereoContext(pContext);
#endif  //ONE_EYE

    if (pStereoEyeFunc)
    {
#ifdef  INDEX
        (*pStereoEyeFunc)(pContext, pVertices, pIndices, (DWORD)wCommandCount);
#else   //INDEX==0
        (*pStereoEyeFunc)(pContext, pVertices, (DWORD)wCommandCount);
#endif  //INDEX
    }

#ifndef NULL_RIGHT_EYE
    *ppCommands = pSaveCommandsPtr; //Restore it for the second pass.
    RetVal = (*(nvDP2SetFuncs_Orig[dwDP2Op]))(pContext,
                                              ppCommands,
                                              pCommandBufferEnd,
                                              pdwDP2RStates,
                                              dwDP2Flags);
#ifdef  PER_PRIMITIVE_SYNC
    StereoSync();
#endif  //PER_PRIMITIVE_SYNC
#endif  //NULL_RIGHT_EYE

    if (pStereoEyeFunc)
    {
#ifdef  INDEX
        (*pStereoEyeFunc)(pContext, pVertices, pIndices, (DWORD)wCommandCount);
#else   //INDEX==0
        (*pStereoEyeFunc)(pContext, pVertices, (DWORD)wCommandCount);
#endif  //INDEX
    }
    return RetVal;
#endif  //~NOT_IMPLEMENTED
}

#else   //POINT=1
HRESULT STEREO_DP2_FUNCTION_FLIP (NV_DP2FUNCTION_ARGLIST)
{
    HRESULT             RetVal;
    DWORD               dwDP2Op = (DWORD)((*ppCommands)->bCommand);
    LPD3DHAL_DP2COMMAND pSaveCommandsPtr = *ppCommands;

    StereoLockSubstituteFlush();

    // First thing to determine is whether we take a HW T&L or SW T&L route. It breaks
    // down all our code into two vertually mutually exclusive cases. It is better to keep 
    // it this way for optimal performance
    if (!STEREO_R_US(pContext))
    {
        RetVal = (*(nvDP2SetFuncs_Orig[dwDP2Op]))(pContext,
                                                  ppCommands,
                                                  pCommandBufferEnd,
                                                  pdwDP2RStates,
                                                  dwDP2Flags);
        return RetVal;
    }
    if (pStereoData->dwHWTnL)
    {
        //This case is going to be the most frequently used in future. We want it fast.
        SetupStereoContext(pContext);
        RetVal = (*(nvDP2SetFuncs_Orig[dwDP2Op]))(pContext,
                                                  ppCommands,
                                                  pCommandBufferEnd,
                                                  pdwDP2RStates,
                                                  dwDP2Flags);
        *ppCommands = pSaveCommandsPtr; //Restore it for the second pass.
        AlternateStereoContext(pContext);
        RetVal = (*(nvDP2SetFuncs_Orig[dwDP2Op]))(pContext,
                                                  ppCommands,
                                                  pCommandBufferEnd,
                                                  pdwDP2RStates,
                                                  dwDP2Flags);
        return RetVal;
    }
    
#ifdef  NOT_IMPLEMENTED
    //LOG("%s: not implemented yet",GET_REAL_NAME( STEREO_DP2_FUNCTION_FLIP ));
	nvAssert (0);
    return ((*(nvDP2SetFuncs_Orig[dwDP2Op]))(pContext,
                                             ppCommands,
                                             pCommandBufferEnd,
                                             pdwDP2RStates,
                                             dwDP2Flags));
#else   //~NOT_IMPLEMENTED
    // And now is SW T&L or HW T&L with transformed vertices
    LPBYTE pVertexBufferBase = (LPBYTE)(pContext->ppDX8Streams[0]->getAddress());
    WORD   wCommandCount = (*ppCommands)->wPrimitiveCount;
    LPBYTE lpPrim        = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);
    DWORD dwVertexBufferOffset = pContext->dp2.dwVertexBufferOffset;
    DWORD  dwTotalOffset = dwVertexBufferOffset + ((DWORD)((LPD3DHAL_DP2POINTS)lpPrim)->wVStart * pContext->pCurrentVShader->getStride());
    pContext->dp2.dwVStart = (DWORD)((LPD3DHAL_DP2POINTS)lpPrim)->wVStart;
    pContext->dp2.dwTotalOffset = dwTotalOffset;
    LPBYTE pVertices     = (LPBYTE)(pVertexBufferBase+dwTotalOffset);
    PSTEREOEYEFUNC      pStereoEyeFunc = NULL;
    nvAssert (wCommandCount == 1); //Haven't implemented more than 1 yet. What a shame!
    wCommandCount = ((LPD3DHAL_DP2POINTS)lpPrim)->wCount;
#ifdef  STEREO_CONFIG_ASSIST
    ConfigAssistInfo.dwFlags &= ~_2DSUSPECT;
#endif  //STEREO_CONFIG_ASSIST

    SetupStereoContext(pContext);
    if (NV_VERTEX_TRANSFORMED(pContext->pCurrentVShader))
    {
        pStereoEyeFunc = STEREO_EYE_FUNCTION_FLIP;
#ifdef  STEREO_CONFIG_ASSIST
#if 1
        if (CHECK_RHW_CONDITION (pContext, pVertices, (DWORD)wCommandCount, EQUAL))
            ConfigAssistInfo.dwFlags |= _2DSUSPECT;
#else
        if (CHECK_RHW_CONDITION (pContext, pVertices, (DWORD)wCommandCount, EQUAL))
            pStereoEyeFunc = NULL;
#endif
#endif  //STEREO_CONFIG_ASSIST
        if (pStereoData->StereoSettings.dwFlags & STEREO_RHWGREATERATSCREEN)
        {
            if (CHECK_RHW_CONDITION (pContext, pVertices, (DWORD)wCommandCount, GREATER))
                pStereoEyeFunc = NULL;
        }
        if (pStereoData->StereoSettings.dwFlags & STEREO_RHWLESSATSCREEN)
        {
            if (CHECK_RHW_CONDITION (pContext, pVertices, (DWORD)wCommandCount, LESS))
                pStereoEyeFunc = NULL;
        }
        if (pStereoEyeFunc)
            (*pStereoEyeFunc)(pContext, pVertices, (DWORD)wCommandCount);
    }
    RetVal = (*(nvDP2SetFuncs_Orig[dwDP2Op]))(pContext,
                                              ppCommands,
                                              pCommandBufferEnd,
                                              pdwDP2RStates,
                                              dwDP2Flags);
#ifdef  PER_PRIMITIVE_SYNC
    StereoSync();
#endif  //PER_PRIMITIVE_SYNC

#ifndef ONE_EYE
    AlternateStereoContext(pContext);
#endif  //ONE_EYE

    if (pStereoEyeFunc)
    {
        (*pStereoEyeFunc)(pContext, pVertices, (DWORD)wCommandCount);
    }

#ifndef NULL_RIGHT_EYE
    *ppCommands = pSaveCommandsPtr; //Restore it for the second pass.
    RetVal = (*(nvDP2SetFuncs_Orig[dwDP2Op]))(pContext,
                                              ppCommands,
                                              pCommandBufferEnd,
                                              pdwDP2RStates,
                                              dwDP2Flags);
#ifdef  PER_PRIMITIVE_SYNC
    StereoSync();
#endif  //PER_PRIMITIVE_SYNC
#endif  //NULL_RIGHT_EYE

    if (pStereoEyeFunc)
    {
        (*pStereoEyeFunc)(pContext, pVertices, (DWORD)wCommandCount);
    }
    return RetVal;
#endif  //~NOT_IMPLEMENTED
}

#endif  //POINT

#else	//DRAWPRIMITIVE
HRESULT STEREO_DP2_FUNCTION_FLIP (NV_DP2FUNCTION_ARGLIST)
{
    HRESULT             RetVal;
    DWORD               dwDP2Op = (DWORD)((*ppCommands)->bCommand);
    LPD3DHAL_DP2COMMAND pSaveCommandsPtr = *ppCommands;

#ifdef	STEREO_DEBUG
	//Make sure it is not a rendering to a texture
	CNvObject *pNvObj = pContext->pRenderTarget->getWrapper();
	if (pNvObj->getClass() == CNvObject::NVOBJ_TEXTURE)
		__asm int 3
	//Make sure we render to a stereo surface
	if (pContext->pRenderTarget->isStereo() == 0)
		__asm int 3
	//Do we render to the Z buffer?
	if (pContext->pRenderTarget->isZBuffer())
		__asm int 3
#endif	//STEREO_DEBUG

    StereoLockSubstituteFlush();

    // First thing to determine is whether we take a HW T&L or SW T&L route. It breaks
    // down all our code into two vertually mutually exclusive cases. It is better to keep 
    // it this way for optimal performance
    if (!STEREO_R_US(pContext))
    {
        RetVal = (*(nvDP2SetFuncs_Orig[dwDP2Op]))(pContext,
                                                  ppCommands,
                                                  pCommandBufferEnd,
                                                  pdwDP2RStates,
                                                  dwDP2Flags);
        return RetVal;
    }
	BOOL UseHWTnLPath = FALSE;
	if (STEREODATA(StereoSettings.dwFlags) & STEREO_MIXEDTNLS)
	{
		if (!NV_VERTEX_TRANSFORMED(pContext->pCurrentVShader))
			UseHWTnLPath = TRUE;
	} else
	{
		if (pStereoData->dwHWTnL)
			UseHWTnLPath = TRUE;
	}

    if (UseHWTnLPath)
    {
        //This case is going to be the most frequently used in future. We want it fast.
        SetupStereoContext(pContext);
        RetVal = (*(nvDP2SetFuncs_Orig[dwDP2Op]))(pContext,
                                                  ppCommands,
                                                  pCommandBufferEnd,
                                                  pdwDP2RStates,
                                                  dwDP2Flags);
        *ppCommands = pSaveCommandsPtr; //Restore it for the second pass.
        AlternateStereoContext(pContext);
        RetVal = (*(nvDP2SetFuncs_Orig[dwDP2Op]))(pContext,
                                                  ppCommands,
                                                  pCommandBufferEnd,
                                                  pdwDP2RStates,
                                                  dwDP2Flags);
        return RetVal;
    }
    
#ifdef	STEREO_DEBUG
	// Once we got here make sure vertices are in the system memory. 
	// Otherwise it is going to be sooo slow.
	CVertexBuffer      *pVertexBuffer = pContext->ppDX8Streams[0];
	if (pVertexBuffer && pVertexBuffer->getHeapLocation() != CSimpleSurface::HEAP_SYS)
		__asm int 3
#endif	//STEREO_DEBUG

#if 0
	__asm int 3
#endif

    // And now is SW T&L or HW T&L with transformed vertices
    LPBYTE pVertexBufferBase = (LPBYTE)(pContext->ppDX8Streams[0]->getAddress());

#ifdef  NOT_IMPLEMENTED
    //LOG("%s: not implemented yet",GET_REAL_NAME( STEREO_DP2_FUNCTION_FLIP ));
    nvAssert (0);
    return ((*(nvDP2SetFuncs_Orig[dwDP2Op]))(pContext,
                                             ppCommands,
                                             pCommandBufferEnd,
                                             pdwDP2RStates,
                                             dwDP2Flags));
#else   //~NOT_IMPLEMENTED
    //nvAssert (0);
    WORD   wCommandCount = (*ppCommands)->wPrimitiveCount;
    LPBYTE lpPrim        = (LPBYTE)(*ppCommands) + sizeof(D3DHAL_DP2COMMAND);

#ifdef	STEREO_DEBUG
    if (wCommandCount != 1)
    {
		__asm int 3
	} 
#endif	//STEREO_DEBUG
#ifdef  INDEX
    LPD3DHAL_DP2DRAWINDEXEDPRIMITIVE lpDPCommand = (LPD3DHAL_DP2DRAWINDEXEDPRIMITIVE)(lpPrim);
    PSTEREOEYEFUNCINDEX      pStereoEyeFunc = NULL;
    PSTEREORHWFUNCINDEX      pStereoRHWFunc = NULL;
#ifdef  START_VERTEX
    DWORD dwVertexBufferOffset = pContext->dp2.dwVertexBufferOffset;
	pContext->dp2.dwVStart      = lpDPCommand->BaseVertexIndex;
    DWORD  dwTotalOffset = dwVertexBufferOffset + ((DWORD)pContext->dp2.dwVStart * pContext->pCurrentVShader->getStride());
    pContext->dp2.dwTotalOffset = dwTotalOffset;
    LPBYTE pIndices      = (LPBYTE)(pContext->pIndexBuffer->getAddress() + pContext->pIndexBuffer->getVertexStride()*lpDPCommand->StartIndex);
    pContext->dp2.dwIndexStride = pContext->pIndexBuffer->getVertexStride();
    LPBYTE pVertices     = (LPBYTE)(pVertexBufferBase+dwTotalOffset);
#else   //START_VERTEX==0
    DWORD  dwTotalOffset = ((LPD3DHAL_DP2DRAWINDEXEDPRIMITIVE2)lpDPCommand)->BaseVertexOffset;
    pContext->dp2.dwTotalOffset = dwTotalOffset;
    LPBYTE pIndices      = (LPBYTE)(pContext->pIndexBuffer->getAddress() + ((LPD3DHAL_DP2DRAWINDEXEDPRIMITIVE2)lpDPCommand)->StartIndexOffset);
    pContext->dp2.dwIndexStride = pContext->pIndexBuffer->getVertexStride();
    LPBYTE pVertices     = (LPBYTE)(pVertexBufferBase+dwTotalOffset);
#endif  //START_VERTEX
#else   //INDEX==0
    LPD3DHAL_DP2DRAWPRIMITIVE lpDPCommand = (LPD3DHAL_DP2DRAWPRIMITIVE)(lpPrim);
    PSTEREOEYEFUNC      pStereoEyeFunc = NULL;
    PSTEREORHWFUNC      pStereoRHWFunc = NULL;
#ifdef  START_VERTEX
    DWORD dwVertexBufferOffset = pContext->dp2.dwVertexBufferOffset;
	pContext->dp2.dwVStart      = lpDPCommand->VStart;
    DWORD  dwTotalOffset = dwVertexBufferOffset + ((DWORD)pContext->dp2.dwVStart * pContext->pCurrentVShader->getStride());
    pContext->dp2.dwTotalOffset = dwTotalOffset;
    LPBYTE pVertices     = (LPBYTE)(pVertexBufferBase+dwTotalOffset);
#else   //START_VERTEX==0
    DWORD  dwTotalOffset = ((LPD3DHAL_DP2DRAWPRIMITIVE2)lpDPCommand)->FirstVertexOffset;
    pContext->dp2.dwTotalOffset = dwTotalOffset;
    LPBYTE pVertices     = (LPBYTE)(pVertexBufferBase+dwTotalOffset);
#endif  //START_VERTEX
#endif  //INDEX
#ifdef	STEREO_DEBUG
    if (!lpDPCommand->primType || lpDPCommand->primType == 1)
    {
		__asm int 3
	} 
#endif	//STEREO_DEBUG
#ifdef  INDEX
	pStereoEyeFunc = PrimTypeToStereoDP2Index[lpDPCommand->primType].pStereoEyeFuncIndex;
	pStereoRHWFunc = PrimTypeToStereoDP2Index[lpDPCommand->primType].pStereoRHWFuncIndex;

    SetupStereoContext(pContext);

#ifdef  STEREO_CONFIG_ASSIST
    if (pStereoRHWFunc (pContext, pVertices, pIndices, (DWORD)lpDPCommand->PrimitiveCount, EQUAL))
        ConfigAssistInfo.dwFlags |= _2DSUSPECT;
#endif  //STEREO_CONFIG_ASSIST
    if (pStereoData->StereoSettings.dwFlags & STEREO_RHWGREATERATSCREEN)
    {
        if (pStereoRHWFunc (pContext, pVertices, pIndices, (DWORD)lpDPCommand->PrimitiveCount, GREATER))
            pStereoEyeFunc = NULL;
    }
    if (pStereoData->StereoSettings.dwFlags & STEREO_RHWLESSATSCREEN)
    {
        if (pStereoRHWFunc (pContext, pVertices, pIndices, (DWORD)lpDPCommand->PrimitiveCount, LESS))
            pStereoEyeFunc = NULL;
    }

    if (pStereoEyeFunc)
	{
        (*pStereoEyeFunc)(pContext, pVertices, pIndices, (DWORD)lpDPCommand->PrimitiveCount);
	}
    RetVal = (*(nvDP2SetFuncs_Orig[dwDP2Op]))(pContext,
                                              ppCommands,
                                              pCommandBufferEnd,
                                              pdwDP2RStates,
                                              dwDP2Flags);
    AlternateStereoContext(pContext);
    if (pStereoEyeFunc)
    {
        (*pStereoEyeFunc)(pContext, pVertices, pIndices, (DWORD)lpDPCommand->PrimitiveCount);
    }

    *ppCommands = pSaveCommandsPtr; //Restore it for the second pass.
    RetVal = (*(nvDP2SetFuncs_Orig[dwDP2Op]))(pContext,
                                              ppCommands,
                                              pCommandBufferEnd,
                                              pdwDP2RStates,
                                              dwDP2Flags);
    if (pStereoEyeFunc)
    {
        (*pStereoEyeFunc)(pContext, pVertices, pIndices, (DWORD)lpDPCommand->PrimitiveCount);
    }
    return RetVal;
#else   //INDEX==0
	pStereoEyeFunc = PrimTypeToStereoDP2[lpDPCommand->primType].pStereoEyeFunc;
	pStereoRHWFunc = PrimTypeToStereoDP2[lpDPCommand->primType].pStereoRHWFunc;

    SetupStereoContext(pContext);

#ifdef  STEREO_CONFIG_ASSIST
    if (pStereoRHWFunc (pContext, pVertices, (DWORD)lpDPCommand->PrimitiveCount, EQUAL))
        ConfigAssistInfo.dwFlags |= _2DSUSPECT;
#endif  //STEREO_CONFIG_ASSIST
    if (pStereoData->StereoSettings.dwFlags & STEREO_RHWGREATERATSCREEN)
    {
        if (pStereoRHWFunc (pContext, pVertices, (DWORD)lpDPCommand->PrimitiveCount, GREATER))
            pStereoEyeFunc = NULL;
    }
    if (pStereoData->StereoSettings.dwFlags & STEREO_RHWLESSATSCREEN)
    {
        if (pStereoRHWFunc (pContext, pVertices, (DWORD)lpDPCommand->PrimitiveCount, LESS))
            pStereoEyeFunc = NULL;
    }

    if (pStereoEyeFunc)
	{
        (*pStereoEyeFunc)(pContext, pVertices, (DWORD)lpDPCommand->PrimitiveCount);
	}
    RetVal = (*(nvDP2SetFuncs_Orig[dwDP2Op]))(pContext,
                                              ppCommands,
                                              pCommandBufferEnd,
                                              pdwDP2RStates,
                                              dwDP2Flags);
    AlternateStereoContext(pContext);
    if (pStereoEyeFunc)
    {
        (*pStereoEyeFunc)(pContext, pVertices, (DWORD)lpDPCommand->PrimitiveCount);
    }

    *ppCommands = pSaveCommandsPtr; //Restore it for the second pass.
    RetVal = (*(nvDP2SetFuncs_Orig[dwDP2Op]))(pContext,
                                              ppCommands,
                                              pCommandBufferEnd,
                                              pdwDP2RStates,
                                              dwDP2Flags);
    if (pStereoEyeFunc)
    {
        (*pStereoEyeFunc)(pContext, pVertices, (DWORD)lpDPCommand->PrimitiveCount);
    }
    return RetVal;
#endif  //INDEX
#endif  //~NOT_IMPLEMENTED
}

#endif	//DRAWPRIMITIVE

#undef  STEREO_DP2_FUNCTION_OAU
#undef  STEREO_EYE_FUNCTION_OAU
#undef  STEREO_2D_FUNCTION_OAU
#undef  STEREO_DP2_FUNCTION_FLIP
#undef  STEREO_EYE_FUNCTION_FLIP
#undef  CHECK_RHW_CONDITION
#undef  INDEX
#undef  INDEX2
#undef  FAN
#undef  STRIP
#undef  FAN_OR_STRIP
#undef  FOR_ALL_VERTICES
#undef  GET_V1_POINTER
#undef  GET_V2_POINTER
#undef  GET_V3_POINTER
#undef  ADVANCE
#undef  ALIGN
#undef  START_VERTEX
#undef  LINE
#undef  POINT
#undef  DEFINE_LOCALS
#undef  NOT_IMPLEMENTED
#undef	DRAWPRIMITIVE
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\src\Surfaces.cpp ===
/***************************************************************************\
* (C) Copyright NVIDIA Corporation Inc.,                                    *
*  1996,1997, 1998. All rights reserved.                                    *
*                                                                           *
* Module: Surfaces.cpp                                                      *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       schaefer           3/26/98                                          *
*                                                                           *
\***************************************************************************/
#include "nvprecomp.h"

#if (!defined(WINNT) && !defined(NVPE))

// we're going to use this definition so that we can
// do this under NT or Win9x "MULTI-MON" which is a cheeser way of saying
// that we're using the NValloc architecture
#define USE_NV_ALLOC_ARCH

// unit specific includes
#include "VidTex.h"

// Hey Folks some storage right here
extern vpSurfaces*          pMySurfaces;
//vpSurfaces            MySurfaces;

NvChannel*          pMyNvChan = NULL;
extern NvNotification*  nvMyVPNotifiers;

#define STARTINGBUF (99)
#define UNKNOWNBUF  (123)


// This is a hack to fix up stuff which a contradiction between the two known systems
// CODE this should be cleaned up as the NV4 style RM moves into NV3 land


BOOLEAN checkScalingOk(U032 in, U032 out ) {
    U032 xIn,yIn,xOut,yOut;
    U032    xRatio;
    /*  Scaling works like this... the output MUST be smaller than the input, and the X ratio must be an integer value
         there is no limit on the Y ratio since it's just a line dropping system
    */

    xIn  = in & 0xFFFF;
    yIn  = in >> 16;
    xOut = out & 0xFFFF;
    yOut = out >> 16;

    if( xIn < xOut ) {
        DPF ("   In dimension X is SMALLER than out X dimension %d, %d",xIn,xOut);
        return FALSE;
    }
    if( yIn < yOut ) {
        DPF ("   In dimension Y is SMALLER than out Y dimension %d, %d",yIn,yOut);
        return FALSE;
    }
    if( xIn % xOut != 0 ) {
        DPF ("   X dimension In does not evenly divide by X out %d, %d",xIn,xOut);
        return FALSE;
    }
    xRatio = xIn / xOut;

    switch (xRatio) {
            case 1:
            case 2:
            case 3:
            case 4:
            case 6:
            case 8:
            case 12:
            case 16:
            case 24:
                break;
            default:
                {
                    DPF ("   Not one of the good scale factors %d, %d, %d",xIn,xOut,xRatio);
                    return FALSE;
                }
                break;
    }

    return TRUE;
}


BOOL GetField(void) {
    BOOL    retvalue = TRUE;
    U032    whiletime = 0;
    FIELDTYPE aField = UNKNOWN;

    // we're not hitting the channel
    //INIT_FREE_COUNT(0);


    // clear the notifiers
    nvMyVPNotifiers[NV04D_NOTIFIERS_GET_IMAGE_OFFSET_NOTIFY(0)+NUM04DOFFSET].status = NV04D_NOTIFICATION_STATUS_IN_PROGRESS;
    nvMyVPNotifiers[NV04D_NOTIFIERS_GET_IMAGE_OFFSET_NOTIFY(1)+NUM04DOFFSET].status = NV04D_NOTIFICATION_STATUS_IN_PROGRESS;

    // put the object into the channel
#ifdef NV3
    pMyNvChan->subchannel[0].control.object = MY_EXTERNAL_DECODER_OBJECT;
#else
    pMyNvChan->subchannel[0].SetObject = MY_EXTERNAL_DECODER_OBJECT;
#endif // NV4

    // fire off the command
    pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.GetImageOffsetNotify[0] =  NV04D_GET_IMAGE_OFFSET_NOTIFY_WRITE_ONLY;
    pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.GetImageOffsetNotify[1] =  NV04D_GET_IMAGE_OFFSET_NOTIFY_WRITE_ONLY;

    // wait for completion
    while ( ((nvMyVPNotifiers[NV04D_NOTIFIERS_GET_IMAGE_OFFSET_NOTIFY(0)+NUM04DOFFSET].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS) ||
                 (nvMyVPNotifiers[NV04D_NOTIFIERS_GET_IMAGE_OFFSET_NOTIFY(1)+NUM04DOFFSET].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS))    &&
                (whiletime++ < WHILETIMEOUT) );

    // only one of these should be running right now....
    if( nvMyVPNotifiers[NV04D_NOTIFIERS_GET_IMAGE_OFFSET_NOTIFY(0)+NUM04DOFFSET].info16 == 0x1 /*NV04D_NOTIFICATION_INFO16_FIELD_VALID_OFFSET*/ ) {
        aField = pMySurfaces->Surfaces[pMySurfaces->CurrentBufferSurface[0]]->field;
    }
    if( nvMyVPNotifiers[NV04D_NOTIFIERS_GET_IMAGE_OFFSET_NOTIFY(1)+NUM04DOFFSET].info16 == 0x1 /*NV04D_NOTIFICATION_INFO16_FIELD_VALID_OFFSET*/ ) {
        aField = pMySurfaces->Surfaces[pMySurfaces->CurrentBufferSurface[1]]->field;
    }

    if(aField == EVEN ) {
        retvalue = TRUE;
    } else {
        retvalue = FALSE;
    }

    return retvalue;
}

U032 checkNvAllocArchError(U032 error) {
    // returns true if there IS an error
    // otherwise false
    switch (error) {
            case NVOS04_STATUS_SUCCESS:
                return 0;
//              DPF("NVOS04_STATUS_SUCCESS");
                break;
            case NVOS04_STATUS_ERROR_OPERATING_SYSTEM:
                DPF("NVOS04_STATUS_ERROR_OPERATING_SYSTEM");
                return error;
                break;
            case NVOS04_STATUS_ERROR_BAD_OBJECT_PARENT:
                DPF("NVOS04_STATUS_ERROR_BAD_OBJECT_PARENT");
                return error;
                break;
            case NVOS04_STATUS_ERROR_BAD_OBJECT_NEW:
                DPF("NVOS04_STATUS_ERROR_BAD_OBJECT_NEW");
                return error;
                break;
            case NVOS04_STATUS_ERROR_BAD_CLASS:
                DPF("NVOS04_STATUS_ERROR_BAD_CLASS");
                return error;
                break;
            case NVOS04_STATUS_ERROR_BAD_OBJECT_ERROR:
                DPF("NVOS04_STATUS_ERROR_BAD_OBJECT_ERROR");
                return error;
                break;
            case NVOS04_STATUS_ERROR_BAD_FLAGS:
                DPF("NVOS04_STATUS_ERROR_BAD_FLAGS");
                return error;
                break;
            case NVOS04_STATUS_ERROR_INSUFFICIENT_RESOURCES:
                DPF("NVOS04_STATUS_ERROR_INSUFFICIENT_RESOURCES");
                return error;
                break;
            default:
                    DPF("UNKNOWN ERROR");
                    return 1;
    }

    return 0;
}

DWORD SetupVP (LPDDHAL_CREATEVPORTDATA lpInput) {
    U032 error;
    U032 i;
    INIT_FREE_COUNT(0);

    pMyNvChan = pMySurfaces->pVPChanPtr;
    if(pMyNvChan == NULL ) {
        //CODE
        error = NvRmAllocChannelPio ((GLOBDATAPTR)->ROOTHANDLE,
                    NV_WIN_DEVICE,
                    MY_VPE_CHANNEL,
                    NV03_CHANNEL_PIO,
                    0,
                    (PVOID*)&(pMySurfaces->pVPChanPtr),
                    NVOS04_FLAGS_FIFO_RUNOUT_IGNORE);
        if(checkNvAllocArchError(error )) {
            DPF("   Warning: Unable to sucessfully complete NvRmAllocChannelPio");
            return DDHAL_DRIVER_NOTHANDLED;
        }


        pMyNvChan = pMySurfaces->pVPChanPtr;

        // Now store a copy in global land so that the brucerator's code can kill the channel on mode switches
        GLOBDATAPTR->NvDevFlatVPE = (U032) pMySurfaces->pVPChanPtr;

    }

    if(pMyNvChan == NULL ) {
        DPF("   Warning: the NV Channel for VPE is not initialized... sorry");
        return DDHAL_DRIVER_NOTHANDLED;
    } else {

            error = NvRmAllocObject(  (GLOBDATAPTR)->ROOTHANDLE,
                                MY_VPE_CHANNEL,
                                MY_EXTERNAL_DECODER_OBJECT,
                                        NV03_EXTERNAL_VIDEO_DECODER
                                );

            if(checkNvAllocArchError(error )) {
                DPF("NVDD: Cannot allocate External Decoder Object %d",MY_EXTERNAL_DECODER_OBJECT);
                return FALSE;
            }
#ifdef NV3
            error = NvRmAllocObject(  (GLOBDATAPTR)->ROOTHANDLE,
                                MY_VPE_CHANNEL,
                                MY_TIMER_OBJECT,
                                        NV_TIMER
                                      );
#else // !NV3
            error = NvRmAllocObject(  (GLOBDATAPTR)->ROOTHANDLE,
                                MY_VPE_CHANNEL,
                                MY_TIMER_OBJECT,
                                NV01_TIMER
                                );
#endif // !NV3
            if(checkNvAllocArchError(error )) {
                DPF("NVDD: Cannot allocate Timer Object %d",MY_TIMER_OBJECT);
                return FALSE;
            }

            // setup Notify Context

            if (NvRmAllocContextDma(  (GLOBDATAPTR)->ROOTHANDLE,
                                MY_EXTERNAL_DECODER_NOTIFIER,
                                NV01_CONTEXT_DMA,
                                DRF_DEF(OS03, _FLAGS, _ACCESS, _READ_WRITE) |
                                DRF_DEF(OS03, _FLAGS, _COHERENCY, _UNCACHED),
                                (PVOID)(((U032)nvMyVPNotifiers) + NUM04DOFFSET*sizeof(NvNotification)),
                                (sizeof( NvNotification)*NUM04DNOTIFIER  - 1)
                         ) != NVOS03_STATUS_SUCCESS )
             {
                DPF((1, "NVDD: Cannot allocate notifier context"));
                return FALSE;
             }


            if (NvRmAllocContextDma(  (GLOBDATAPTR)->ROOTHANDLE,
                                MY_TIMER_NOTIFIER,
                                NV01_CONTEXT_DMA,
                                DRF_DEF(OS03, _FLAGS, _ACCESS, _READ_WRITE) |
                                DRF_DEF(OS03, _FLAGS, _COHERENCY, _UNCACHED),
                                (PVOID)(((U032)nvMyVPNotifiers) + NUM004OFFSET*sizeof(NvNotification)),
                                (sizeof( NvNotification)*NUM004NOTIFIER  - 1)
                         ) != NVOS03_STATUS_SUCCESS )
             {
                DPF((1, "NVDD: Cannot allocate notifier context"));
                return FALSE;
             }


            // Plug the notifiers into the main object
            // make sure the object is on the channel
#ifdef NV3
            pMyNvChan->subchannel[0].control.object = MY_EXTERNAL_DECODER_OBJECT;
#else
            pMyNvChan->subchannel[0].SetObject  = MY_EXTERNAL_DECODER_OBJECT;
#endif // NV4

            pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetContextDmaNotifies = MY_EXTERNAL_DECODER_NOTIFIER;

            // do something now to put the port into the proper mode...
            if (pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10) {
              if( lpInput->lpDDVideoPortDesc->VideoPortType.dwPortWidth == 16 ) {
                  // this is the something
                  DPF((1, "NVDD: Now switching video port to 16 wide mode"));
                  pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetImageConfig = 16 ;/* data width, task bit, null data  02f8-02fb*/
              } else if( lpInput->lpDDVideoPortDesc->VideoPortType.dwPortWidth == 8 ) {
                  DPF((1, "NVDD: Now switching video port to 8 wide mode"));
                  pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetImageConfig = 8 ;/* data width, task bit, null data  02f8-02fb*/
              } else {
                  DPF((1, "NVDD: invalid port width"));
              }
            }
#ifdef NV3
            pMyNvChan->subchannel[0].control.object = MY_TIMER_OBJECT;
            pMyNvChan->subchannel[0].timer.SetAlarmNotifyCtxDma = MY_TIMER_NOTIFIER;
#else
            pMyNvChan->subchannel[0].SetObject  = MY_TIMER_OBJECT;
            pMyNvChan->subchannel[0].nv01Timer.SetContextDmaNotifies = MY_TIMER_NOTIFIER;
#endif // NV4


 //**************************************************************************
 // Allocate a DMA context which points to all of video memory. The limit
 // must be page aligned: i.e. limit = (size in bytes of video mem rounded to the
 // closest page boundary) - 1.
 //**************************************************************************

        {
            void*  pFrameBuffer = (void*)(GLOBDATAPTR)->PBASEADDRESS;
            U032     dwFBLen= DWFBUFFERLEN;

            if (NvRmAllocContextDma(    (GLOBDATAPTR)->ROOTHANDLE,
                                            MY_IMAGE0_BUFFER_CONTEXT,
                                            NV01_CONTEXT_DMA,
                                            DRF_DEF(OS03, _FLAGS, _ACCESS, _READ_WRITE) |
                                            DRF_DEF(OS03, _FLAGS, _COHERENCY, _UNCACHED),
                                            pFrameBuffer,
                                    dwFBLen
                                        ) != NVOS03_STATUS_SUCCESS )
            {
              DPF((1, "NVDD: Cannot allocate dma in memory context for MY_IMAGE0_BUFFER_CONTEXT"));
              return FALSE;
            }

             if (NvRmAllocContextDma(  (GLOBDATAPTR)->ROOTHANDLE,
                                            MY_IMAGE1_BUFFER_CONTEXT,
                                            NV01_CONTEXT_DMA,
                                            DRF_DEF(OS03, _FLAGS, _ACCESS, _READ_WRITE) |
                                            DRF_DEF(OS03, _FLAGS, _COHERENCY, _UNCACHED),
                                    pFrameBuffer,
                                    dwFBLen
                                  ) != NVOS03_STATUS_SUCCESS )
              {
              DPF((1, "NVDD: Cannot allocate dma in memory context for MY_IMAGE1_BUFFER_CONTEXT"));
              return FALSE;
              }

            if (NvRmAllocContextDma(  (GLOBDATAPTR)->ROOTHANDLE,
                                  MY_VBI0_BUFFER_CONTEXT,
                                  NV01_CONTEXT_DMA,
                                  DRF_DEF(OS03, _FLAGS, _ACCESS, _READ_WRITE) |
                                  DRF_DEF(OS03, _FLAGS, _COHERENCY, _UNCACHED),
                                  pFrameBuffer,
                                  dwFBLen
                                  ) != NVOS03_STATUS_SUCCESS )
            {
              DPF((1, "NVDD: Cannot allocate dma in memory context for MY_VBI0_BUFFER_CONTEXT"));
              return FALSE;
            }

            if (NvRmAllocContextDma(  (GLOBDATAPTR)->ROOTHANDLE,
                                  MY_VBI1_BUFFER_CONTEXT,
                                  NV01_CONTEXT_DMA,
                                  DRF_DEF(OS03, _FLAGS, _ACCESS, _READ_WRITE) |
                                  DRF_DEF(OS03, _FLAGS, _COHERENCY, _UNCACHED),
                                  pFrameBuffer,
                                  dwFBLen
                                  ) != NVOS03_STATUS_SUCCESS )
            {
              DPF((1, "NVDD: Cannot allocate dma in memory context for MY_VBI1_BUFFER_CONTEXT"));
              return FALSE;
            }

        }


            CHECK_FREE_COUNT(pMyNvChan,10*5);

            // make sure decoder object is in the channel....
#ifdef NV3
            pMyNvChan->subchannel[0].control.object = MY_EXTERNAL_DECODER_OBJECT;
#else
            pMyNvChan->subchannel[0].SetObject = MY_EXTERNAL_DECODER_OBJECT;
#endif // NV4
            // plug in our buffer contexts
            pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetContextDmaImage[0]     = MY_IMAGE0_BUFFER_CONTEXT;
            pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetContextDmaImage[1]     = MY_IMAGE1_BUFFER_CONTEXT;
            pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetContextDmaVbi[0]       = MY_VBI0_BUFFER_CONTEXT;
            pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetContextDmaVbi[1]       = MY_VBI1_BUFFER_CONTEXT;

        // Ok, done setting up the various contexts
        // now we should setup the class with some boring default values

            CHECK_FREE_COUNT(pMyNvChan,10*10);

            for( i = 0; i < 2; i++ ) {
                pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetImage[i].sizeIn     = ((240 << 16 ) | 720 );   // *The next four method may fail if the scaling values do not work out properly.
                pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetImage[i].sizeOut = ((240 << 16 ) | 720 );      // changing either In or Out values will modify the scaling values
                pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetImage[i].offset        =0;         //  *indicates DMA "address" as on offset from frame buffer base

                //  we don't actually want to launch any captures at this point

                pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetVbi[i].offset      = 0;
                pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetVbi[i].size        = 0;
                //  we don't actually want to launch any captures at this point
            }


        // Ok, reset all the notifiers:

            for (i = 0; i < NUMVPNOTIFIERS ; i++ ) {
                nvMyVPNotifiers[i].status       = NV04D_NOTIFICATION_STATUS_NOT_LAUNCHED;
                nvMyVPNotifiers[i].info32   = 0;
                nvMyVPNotifiers[i].info32   = 0;
                nvMyVPNotifiers[i].timeStamp.nanoseconds[0] = 0;
                nvMyVPNotifiers[i].timeStamp.nanoseconds[1] = 0;
            }


            // this means we're going to try for kevin's new cool callback dealy

            /*
             * NvAllocEvent() specifies a Windows event or callback for NV to send to the
             * application after requesting notifications with the
             * NV_OS_WRITE_THEN_AWAKEN style.
             *    first parameter is the NvChannel
             *    second is the object name
             *    third is the notify index
             *    fourth is the notify event type (NV_OS_EVENT_*)
             *    fifth is the lower 32bits of the 64bit event data
             *    sixth is the upper 32bits of the 64bit event data
             */

            // first object we're going to associate will be the MY_EXTERNAL_DECODER_OBJECT
            // we want to different notifiers associated here.

            pMySurfaces->bThreadDead = FALSE;
            pMySurfaces->bThreadRunning = TRUE;

            // I want VBI/Image/ 0 / 1  all to go to the same place


#ifdef NV3
// until someone gets this define in the right header file
#define  NV01_EVENT_KERNEL_CALLBACK                                (0x00000078)
#endif

            {
                U032 status = 0;

                status = NvRmAllocEvent (   (GLOBDATAPTR)->ROOTHANDLE,
                                        MY_EXTERNAL_DECODER_OBJECT,
                                MY_VBI0_BUFFER_EVENT,
                                NV01_EVENT_KERNEL_CALLBACK,
                                        NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(0),
                                        (void*)pMySurfaces->pNotifyCallbackProcV0);

                if( status !=  0x0 /* meaning sucess */ ) {
                    DPF("Bad status returned from nvRmAllocEvent. status = %d",status);
                }

                status = NvRmAllocEvent (   (GLOBDATAPTR)->ROOTHANDLE,
                                        MY_EXTERNAL_DECODER_OBJECT,
                                MY_VBI1_BUFFER_EVENT,
                                NV01_EVENT_KERNEL_CALLBACK,
                                        NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(1),
                                        (void*)pMySurfaces->pNotifyCallbackProcV1);
               if( status !=  0x0 /* meaning sucess */ ) {
                    DPF("Bad status returned from nvRmAllocEvent. status = %d",status);
                }
                status = NvRmAllocEvent (   (GLOBDATAPTR)->ROOTHANDLE,
                                        MY_EXTERNAL_DECODER_OBJECT,
                                MY_IMAGE0_BUFFER_EVENT,
                                NV01_EVENT_KERNEL_CALLBACK,
                                        NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(0),
                                        (void*)pMySurfaces->pNotifyCallbackProcI0);
               if( status !=  0x0 /* meaning sucess */ ) {
                    DPF("Bad status returned from nvRmAllocEvent. status = %d",status);
                }
                status = NvRmAllocEvent (   (GLOBDATAPTR)->ROOTHANDLE,
                                        MY_EXTERNAL_DECODER_OBJECT,
                                MY_IMAGE1_BUFFER_EVENT,
                                NV01_EVENT_KERNEL_CALLBACK,
                                        NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(1),
                                        (void*)pMySurfaces->pNotifyCallbackProcI1);
               if( status !=  0x0 /* meaning sucess */ ) {
                    DPF("Bad status returned from nvRmAllocEvent. status = %d",status);
                }

                 // And finally one for the timer
#ifdef NV3
#define NV004_NOTIFIERS_SET_ALARM_NOTIFY                           (1)
#endif
                 status = NvRmAllocEvent    (   (GLOBDATAPTR)->ROOTHANDLE,
                                        MY_TIMER_OBJECT,
                                MY_TIMER_EVENT,
                                NV01_EVENT_KERNEL_CALLBACK,
                                        NV004_NOTIFIERS_SET_ALARM_NOTIFY,
                                        (void*)pMySurfaces->pTimerNotifyProc);
               if( status !=  0x0 /* meaning sucess */ ) {
                    DPF("Bad status returned from nvRmAllocEvent. status = %d",status);
                }

            }   // event alloc block




        // Decrement the number of ports available count
            (pMySurfaces->pDriverData)->dwVideoPortsAvailable--;


    }

    // this sets up the structures for ring0 data transfers
    SetupMTM();

    pMySurfaces->pVidTexSurf = NULL;
#ifndef NV3
    //initTextureSurf();
#endif

    pMySurfaces->SetupComplete = TRUE;
    return DDHAL_DRIVER_HANDLED;
}


void    tearDownVP(void) {
    U032    error;
    U032    i;
    U032    whiletime;
    INIT_FREE_COUNT(0);

    // stop things from running  ( check to make sure the channel is not null by which we'll assume
    //   that things are not running
    // tell the thread to exit
    pMySurfaces->bThreadRunning = FALSE;

    if(pMyNvChan != NULL)
        StopVP();

#ifndef NV3
    //DestroyTextureSurf();
#endif

    TearDownMTM();
#if 0
    {
             error = NvRmFree((GLOBDATAPTR)->ROOTHANDLE, NV_DD_DEV_VIDEO, MY_DVD_SUBPICTURE_OBJECT);


            if(checkNvAllocArchError(error )) {
                DPF("NVDD: Cannot deallocate DVD-subpicture Object %d",MY_DVD_SUBPICTURE_OBJECT);
            }
    }
#endif

    // this should wake up the thread
//  NvSetEvent( pMySurfaces->hVPInterruptEvent );

    // wait for it to die
    whiletime = 0;
    while( (!pMySurfaces->bThreadDead) &
            (whiletime++ < WHILETIMEOUT) );
    // make sure that the thread has really exited
    //TerminateThread((HANDLE)pMySurfaces->VpInterruptId,0);




    if(pMyNvChan != NULL ) {
        CHECK_FREE_COUNT(pMyNvChan,12*4);

        // stop the transfers
#ifdef NV3
        pMyNvChan->subchannel[0].control.object = MY_EXTERNAL_DECODER_OBJECT;
#else
        pMyNvChan->subchannel[0].SetObject  = MY_EXTERNAL_DECODER_OBJECT;
#endif // NV4

        if(pMySurfaces->dwVideoPortStatus != VP_NOT_RUNNING ) {
            pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.StopTransferImage   = 0;
            pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.StopTransferVbi = 0;
        }

    }


#define NOEVENTFREEFUNCTIONYETFOLKS
#ifdef NOEVENTFREEFUNCTIONYETFOLKS
    DPF("Now ditching the EVENTs ");

    error = NvRmFree((GLOBDATAPTR)->ROOTHANDLE, MY_EXTERNAL_DECODER_OBJECT, MY_IMAGE0_BUFFER_EVENT);
   checkNvAllocArchError(error);
    error = NvRmFree((GLOBDATAPTR)->ROOTHANDLE, MY_EXTERNAL_DECODER_OBJECT, MY_IMAGE1_BUFFER_EVENT);
   checkNvAllocArchError(error);
    error = NvRmFree((GLOBDATAPTR)->ROOTHANDLE, MY_EXTERNAL_DECODER_OBJECT, MY_VBI0_BUFFER_EVENT);
   checkNvAllocArchError(error);
    error = NvRmFree((GLOBDATAPTR)->ROOTHANDLE, MY_EXTERNAL_DECODER_OBJECT, MY_VBI1_BUFFER_EVENT);
   checkNvAllocArchError(error);
    error = NvRmFree((GLOBDATAPTR)->ROOTHANDLE, MY_TIMER_OBJECT, MY_TIMER_EVENT);
    checkNvAllocArchError(error);
    error = NvRmFree((GLOBDATAPTR)->ROOTHANDLE, pMySurfaces->dwOverlayObjectID, MY_OVERLAY0_BUFFER_EVENT);
    checkNvAllocArchError(error);
    error = NvRmFree((GLOBDATAPTR)->ROOTHANDLE, pMySurfaces->dwOverlayObjectID, MY_OVERLAY1_BUFFER_EVENT);
    checkNvAllocArchError(error);


#endif

    DPF("Now setting notifiers to NULL");
    if(pMyNvChan != NULL ) {

// set notifiers to NULL context DMAs
#ifdef NV3
        pMyNvChan->subchannel[0].control.object = MY_EXTERNAL_DECODER_OBJECT;
#else
        pMyNvChan->subchannel[0].SetObject  = MY_EXTERNAL_DECODER_OBJECT;
#endif // NV4

        pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetContextDmaNotifies = 0;


#ifdef NV3
        pMyNvChan->subchannel[0].control.object = MY_TIMER_OBJECT;
        pMyNvChan->subchannel[0].timer.SetAlarmNotifyCtxDma = 0;
#else
        pMyNvChan->subchannel[0].SetObject  = MY_TIMER_OBJECT;
        pMyNvChan->subchannel[0].nv01Timer.SetContextDmaNotifies = 0;
#endif // NV4

// set DMA for transfers to NULL

#ifdef NV3
        pMyNvChan->subchannel[0].control.object = MY_EXTERNAL_DECODER_OBJECT;
#else
        pMyNvChan->subchannel[0].SetObject = MY_EXTERNAL_DECODER_OBJECT;
#endif // NV4

        pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetContextDmaImage[0]     = 0;
        pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetContextDmaImage[1]     = 0;
        pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetContextDmaVbi[0]       = 0;
        pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetContextDmaVbi[1]       = 0;




    // spin waiting for empty fifo
#ifdef NV3
        while(NvGetFreeCount(pMyNvChan, 0) < NV_GUARANTEED_FIFO_SIZE );
#else
        while(NvGetFreeCount(pMyNvChan, 0) < NV06A_FIFO_GUARANTEED_SIZE );
#endif

    }
//  I'm a bit concerned about syncing the FIFO with these NVRM API calls. but we'll let this slide for now

    DPF("Now ditching the Notifiers");
    error = NvRmFree((GLOBDATAPTR)->ROOTHANDLE, (GLOBDATAPTR)->ROOTHANDLE, MY_EXTERNAL_DECODER_NOTIFIER);
    checkNvAllocArchError(error);
    error = NvRmFree((GLOBDATAPTR)->ROOTHANDLE, (GLOBDATAPTR)->ROOTHANDLE, MY_TIMER_NOTIFIER);
    checkNvAllocArchError(error);



    DPF("Now ditching the Buffer contexts");
    error = NvRmFree((GLOBDATAPTR)->ROOTHANDLE, (GLOBDATAPTR)->ROOTHANDLE, MY_IMAGE0_BUFFER_CONTEXT);
    if(checkNvAllocArchError(error)) {
        DPF("that was trouble freeing MY_IMAGE0_BUFFER_CONTEXT");
    }
    error = NvRmFree((GLOBDATAPTR)->ROOTHANDLE, (GLOBDATAPTR)->ROOTHANDLE, MY_IMAGE1_BUFFER_CONTEXT);
    if(checkNvAllocArchError(error)) {
        DPF("that was trouble freeing MY_IMAGE1_BUFFER_CONTEXT");
    }
    error = NvRmFree((GLOBDATAPTR)->ROOTHANDLE, (GLOBDATAPTR)->ROOTHANDLE, MY_VBI0_BUFFER_CONTEXT);
    if(checkNvAllocArchError(error)) {
        DPF("that was trouble freeing MY_VBI0_BUFFER_CONTEXT");
    }
    error = NvRmFree((GLOBDATAPTR)->ROOTHANDLE, (GLOBDATAPTR)->ROOTHANDLE, MY_VBI1_BUFFER_CONTEXT);
    if(checkNvAllocArchError(error)) {
        DPF("that was trouble freeing MY_VBI1_BUFFER_CONTEXT");
    }




    error = NvRmFree((GLOBDATAPTR)->ROOTHANDLE, MY_VPE_CHANNEL, MY_TIMER_OBJECT);
    if(checkNvAllocArchError(error)) {
        DPF("that was trouble freeing MY_TIMER_OBJECT");
    }
    error = NvRmFree((GLOBDATAPTR)->ROOTHANDLE, MY_VPE_CHANNEL, MY_EXTERNAL_DECODER_OBJECT);

    if(checkNvAllocArchError(error)) {
        DPF("that was trouble freeing MY_EXTERNAL_DECODER_OBJECT");
    }



// increment the number of ports available
    (pMySurfaces->pDriverData)->dwVideoPortsAvailable++;
// shut down Media Port channel

    pMyNvChan = pMySurfaces->pVPChanPtr;
    {
        ULONG status;

        status = NvRmFree((GLOBDATAPTR)->ROOTHANDLE,
                                 NV_WIN_DEVICE,
                                 MY_VPE_CHANNEL);

        if( status == 0x0) {
            pMyNvChan = NULL;
            pMySurfaces->pVPChanPtr = NULL;
        } else {
            DPF("Uh Dude,  I couldn't deallocate the channel pointer... ");

        }
    }


    (pMySurfaces->pDriverData)->NvDevFlatVPE = (DWORD) NULL;
    pMyNvChan = NULL;

    // Ok, reset all the notifiers:

//  CLOSE_HANDLE(pMySurfaces->hThreadHandle);
    for (i = 0; i < NUMVPNOTIFIERS ; i++ ) {
        nvMyVPNotifiers[i].status       = NV04D_NOTIFICATION_STATUS_NOT_LAUNCHED;
        nvMyVPNotifiers[i].info32   = 0;
        nvMyVPNotifiers[i].info32   = 0;
        nvMyVPNotifiers[i].timeStamp.nanoseconds[0] = 0;
        nvMyVPNotifiers[i].timeStamp.nanoseconds[1] = 0;
    }
    pMySurfaces->SetupComplete = FALSE;

}


void StopVP(void) {
    U032    whiletime;

    INIT_FREE_COUNT(0);

#ifdef NV3
    NV_DD_DMA_PUSHER_SYNC();
#endif

    CHECK_FREE_COUNT(pMyNvChan,8);


#ifdef NV3
    pMyNvChan->subchannel[0].control.object = MY_EXTERNAL_DECODER_OBJECT;
#else
    pMyNvChan->subchannel[0].SetObject  = MY_EXTERNAL_DECODER_OBJECT;
#endif
    DPF ("   Firing Off Stop commands");

    if(pMySurfaces->dwVideoPortStatus != VP_NOT_RUNNING ) {
        pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.StopTransferImage   = 0;
        pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.StopTransferVbi = 0;
    }
// wait for the last few notifies to show up ?

    pMySurfaces->bStopVP = TRUE;

    whiletime = 0;
    while ( ((nvMyVPNotifiers[NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(0)].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS) ||
                 (nvMyVPNotifiers[NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(1)].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS)) &&
                (whiletime++ < WHILETIMEOUT) );

// CODE wait for VBI notifies.. too
//  while (nvMyVPNotifiers[NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(0)].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS);
//  while (nvMyVPNotifiers[NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(1)].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS);
    DPF ("   Done waiting for stops");

    // one more time to make sure those register get cleared
    if(pMySurfaces->dwVideoPortStatus != VP_NOT_RUNNING ) {
        pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.StopTransferImage   = 0;
        pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.StopTransferVbi = 0;
   }

}

DWORD getCurLine(void) {
    U032    whiletime;
    U032    possibleOffset = 0;
    U032    line;
    U032    returnLine;
    INIT_FREE_COUNT(0);

    nvMyVPNotifiers[NV04D_NOTIFIERS_GET_IMAGE_OFFSET_NOTIFY(0)].status = NV04D_NOTIFICATION_STATUS_IN_PROGRESS;
    nvMyVPNotifiers[NV04D_NOTIFIERS_GET_IMAGE_OFFSET_NOTIFY(1)].status = NV04D_NOTIFICATION_STATUS_IN_PROGRESS;

    returnLine = 0;

    // Put decoder object into the channel
    CHECK_FREE_COUNT(pMyNvChan,1*4);
#ifdef NV3
    pMyNvChan->subchannel[0].control.object = MY_EXTERNAL_DECODER_OBJECT;
#else
    pMyNvChan->subchannel[0].SetObject = MY_EXTERNAL_DECODER_OBJECT;
#endif

    CHECK_FREE_COUNT(pMyNvChan,8);

    pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.GetImageOffsetNotify[0]       = 0;            // *allows programming of either ODD or EVEN fields
    pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.GetImageOffsetNotify[1]       = 0;            // *allows programming of either ODD or EVEN fields

//CODE   there may still be in issue with divide by ZERO here.. I can't imagine pitch = 0.. but you never know...

    whiletime = 0;

    while ( ((nvMyVPNotifiers[NV04D_NOTIFIERS_GET_IMAGE_OFFSET_NOTIFY(0)].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS) ||
                 (nvMyVPNotifiers[NV04D_NOTIFIERS_GET_IMAGE_OFFSET_NOTIFY(1)].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS)) &&
                (whiletime++ < WHILETIMEOUT) );


    if(nvMyVPNotifiers[NV04D_NOTIFIERS_GET_IMAGE_OFFSET_NOTIFY(0)].info32 == 0x1 /*NV04D_NOTIFICATION_INFO16_FIELD_VALID_OFFSET*/ ) {
        possibleOffset = nvMyVPNotifiers[NV04D_NOTIFIERS_GET_IMAGE_OFFSET_NOTIFY(0)].info32;
        line = possibleOffset - pMySurfaces->Surfaces[pMySurfaces->CurrentBufferSurface[0]]->dwOffset;
        returnLine = line / pMySurfaces->Surfaces[pMySurfaces->CurrentBufferSurface[0]]->dwPitch;
    }
    if(nvMyVPNotifiers[NV04D_NOTIFIERS_GET_IMAGE_OFFSET_NOTIFY(1)].info32 == 0x1 /*NV04D_NOTIFICATION_INFO16_FIELD_VALID_OFFSET*/ ) {
        possibleOffset = nvMyVPNotifiers[NV04D_NOTIFIERS_GET_IMAGE_OFFSET_NOTIFY(1)].info32;
        line = possibleOffset - pMySurfaces->Surfaces[pMySurfaces->CurrentBufferSurface[1]]->dwOffset;
        returnLine = line / pMySurfaces->Surfaces[pMySurfaces->CurrentBufferSurface[1]]->dwPitch;
    }

    return returnLine;
}

U032    notifyIndexFromBuffer(U032 dwBuffer) {
    switch (dwBuffer) {
            case 0:
                return NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(0);
                break;
            case 1:
                return NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(1);
                break;
            case 2:
                return NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(0);
                break;
            case 3:
                return NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(1);
                break;
            default:
                {
                    DPF ("   Problem... trying get an index for an unknown buffer notify");
                    return UNKNOWNBUF;
                }
    }
}


VPERRORS replaceSurfaceList(DWORD dwNumAutoflip,DWORD dwNumVBIAutoflip,
                                        LPDDRAWI_DDRAWSURFACE_INT   *lplpDDSurface,
                                        LPDDRAWI_DDRAWSURFACE_INT   *lplpDDVBISurface,
                                        U032 bAutoflip ) {
    VPERRORS    localError = NOVPERROR;
    U032    imageSurfCount = 0;
    U032    VBISurfCount = 0;
    U032    i;
    U032    next;

    pMySurfaces->surfMemAllocCount = 0;

    ASSERT(!((lplpDDSurface         != NULL) ^ (dwNumAutoflip > 0)));
    ASSERT(!((lplpDDVBISurface  != NULL) ^ (dwNumVBIAutoflip > 0)));
    if ((dwNumAutoflip == 0 ) && (dwNumVBIAutoflip ==0 )
         && (bAutoflip)) // H.AZAR (09/02/99): we must check NumAutoflip != 0 only if autoflip flag is set !!!
    {
      return CANTCREATESURFACE;
    }

    DPF ("   We have #Image=%d  #VB=%d autoflip surfaces",dwNumAutoflip,dwNumVBIAutoflip);

    localError = clearAllSurfaces();
    if( localError != NOVPERROR ) {
        return localError;
    }

    imageSurfCount = 0;

    if(lplpDDSurface != NULL) {
        // first count the surfaces
        imageSurfCount = 0;
        if(bAutoflip) {
            while( (imageSurfCount < dwNumAutoflip) &&(lplpDDSurface[imageSurfCount] != NULL )) {
                imageSurfCount++;
            }
        } else {
            while(lplpDDSurface[imageSurfCount] != NULL ) {
                imageSurfCount++;
            }
        }
        if(bAutoflip) {
            if(imageSurfCount > dwNumAutoflip ) {
                DPF("More in list than are autoflip!");
                imageSurfCount = dwNumAutoflip;
            }
        }
        // next add the surfaces to the list
        i = 0;
        while((lplpDDSurface[i] != NULL ) && (i <imageSurfCount) ) {
            next = i + 1;
            if( next == imageSurfCount )
                next = 0;
            localError = addSurface(createSurface(lplpDDSurface[i], bAutoflip, FALSE, NULL,next));
            i=i+1;
        }

        DPF("Added %d Image surfaces",imageSurfCount);
    }
    pMySurfaces->VBIstart = imageSurfCount;


    if(lplpDDVBISurface!=NULL ) {
        // now count VBI surfaces
        VBISurfCount = 0;
        // if we're auto flip then don't check beyond what numVBIAutoflip passes into us since
        // some lamers don't zero terminate their list in this case
        if(bAutoflip) {
            while((VBISurfCount < dwNumVBIAutoflip) && (lplpDDVBISurface[VBISurfCount] != NULL ) ) {
                VBISurfCount++;
            }
        } else {
            while(lplpDDVBISurface[VBISurfCount] != NULL ) {
                VBISurfCount++;
            }
        }
        if(bAutoflip) {
            if(VBISurfCount > dwNumVBIAutoflip ) {
                DPF("More in VBI list than are autoflip!");
                VBISurfCount = dwNumVBIAutoflip;
            }
        }
        // next add the surfaces to the list
        i = 0;
        // All the VBI surfaces are offset by a certain amount
        while((lplpDDVBISurface[i] != NULL ) && (i <VBISurfCount) ) {
            next = i + 1;
            if( next == VBISurfCount )
                next = 0;
            localError = addSurface(createSurface(lplpDDVBISurface[i], bAutoflip, TRUE, NULL,next+pMySurfaces->VBIstart));
            i=i+1;
        }
        DPF("Added %d VBI surfaces",VBISurfCount);
    }


    pMySurfaces->CurrentBufferSurface[0] = NOSURFACEPROGRAMED;
    pMySurfaces->CurrentBufferSurface[1] = NOSURFACEPROGRAMED;
    pMySurfaces->CurrentBufferSurface[2] = NOSURFACEPROGRAMED;
    pMySurfaces->CurrentBufferSurface[3] = NOSURFACEPROGRAMED;

    if( localError == NOVPERROR ) {
        DPF ("   Replaced surfaces - OK");
    } else {
        switch (localError) {
                case    TOOMANYSURFACESERROR:
                    DPF ("   Replaced surfaces - TOOMANYSURFACESERROR");
                    break;
                case CANTCREATESURFACE:
                    DPF ("   Replaced surfaces - CANTCREATESURFACE");
                    break;
                case SURFACENOTFOUND:
                    DPF ("   Replaced surfaces - SURFACENOTFOUND");
                    break;
                case NOSURFACEPROGRAMED:
                    DPF ("   Replaced surfaces - NOSURFACEPROGRAMED");
                    break;
        }

        DPF ("   Replaced surfaces there was a problem = %d",localError);
    }

#if 0
#ifdef DEBUG
    DPF("Now checking the surface thingie");
    {
        U032    i;
        for(i=0;i<pMySurfaces->numberOfSurfaces;i++) {
            DPF("#Surfaces = %d surface = %d, nextSurface = %d, prevSurcace = %d",pMySurfaces->numberOfSurfaces,i,getNextSurface(i),getPrevSurface(i));
        }
    }

    DPF("done checking");

#endif

#endif
    return localError;
}


VPERRORS    addSurface(vpSurfaceInfo*   pNewSurface) {
    ASSERT(pNewSurface  != NULL);

    if(pMySurfaces->numberOfSurfaces >= MAXVPSURFACES ) {
        return  TOOMANYSURFACESERROR;
    }
    if( pNewSurface == NULL) {
        return CANTCREATESURFACE;
    }

    pMySurfaces->Surfaces[pMySurfaces->numberOfSurfaces] = pNewSurface;
    pMySurfaces->numberOfSurfaces++;

    return NOVPERROR;
}

vpSurfaceInfo* createSurface(LPDDRAWI_DDRAWSURFACE_INT pNewSurface, U032 bAutoflip,
                                        U032 bVBI, NvNotification* pToNotify,U032 nextSurface) {


    vpSurfaceInfo*      pSurface;
    U032 Delta;

    ASSERT( pNewSurface != NULL);
    // unlikely to ever be not NULL
    //ASSERT( pToNotify != NULL);
    ASSERT( nextSurface < MAXVPSURFACES);

    pSurface = &pMySurfaces->surfMemory[pMySurfaces->surfMemAllocCount];
    pMySurfaces->surfMemAllocCount++;

    pSurface->surfHandle = pNewSurface;
    pSurface->bAutoFlip = bAutoflip;
    pSurface->pVidMem = VIDMEM_ADDR(pNewSurface->lpLcl->lpGbl->fpVidMem);
    pSurface->ddsCaps = pNewSurface->lpLcl->ddsCaps.dwCaps;
    pSurface->nextSurfaceNum = nextSurface;
    // store the offset of the intermediate hidden surface
    pSurface->dwRes1 = pNewSurface->lpLcl->lpGbl->dwReserved1;
//

    pSurface->dwPitch = pNewSurface->lpLcl->lpGbl->lPitch;



    // move things around in the surface
    if (pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10) {
      Delta = 0;   // in NV10 the overlay can do these calculations..
    } else {
      Delta = pMySurfaces->dwOriginX*2 + pMySurfaces->dwOriginY*pSurface->dwPitch;
    }

    pSurface->dwOffset = (unsigned long) pSurface->pVidMem
                    - (unsigned long)(pMySurfaces->pDriverData)->BaseAddress
                    + Delta;


    if(bVBI) {
        pSurface->dwStartLine = pMySurfaces->dwVBIStartLine;
    } else {
        if( pMySurfaces->CurrentScanMode == INTERLEAVBUF) {
                // both field have bigger pitch
                pSurface->dwPitch = pNewSurface->lpLcl->lpGbl->lPitch * 2;
            }



        //if( pMySurfaces->dwImageStartLine < 6 )
        //  pSurface->dwStartLine = 6;
        //else
            if(pMySurfaces->dwImageStartLine == 1) {
                pSurface->dwStartLine = 16; //tried 17 no much- 15 can see stuff on top of intercast disk - 16?
            } else {
                pSurface->dwStartLine = pMySurfaces->dwImageStartLine;
            }
    }

#define VIDEOEXTRALEN (0)
    // make sure we're not trying to cram something into a surface that's too small
    if(bVBI ) {
        pSurface->dwHeight = pMySurfaces->dwVBIHeight;
    } else {
        if ( pMySurfaces->dwInHeight > pNewSurface->lpLcl->lpGbl->wHeight ) {
            pSurface->dwHeight = pNewSurface->lpLcl->lpGbl->wHeight + VIDEOEXTRALEN;
        } else {
            pSurface->dwHeight = pMySurfaces->dwInHeight + VIDEOEXTRALEN;
        }
    }
    if ( pMySurfaces->dwInWidth > pNewSurface->lpLcl->lpGbl->wWidth ) {
        pSurface->dwWidth = pNewSurface->lpLcl->lpGbl->wWidth;
    } else {
        pSurface->dwWidth = pMySurfaces->dwInWidth;
    }

    pSurface->dwPreScaleSize =  (pMySurfaces->dwPreWidth) | ((pMySurfaces->dwPreHeight+VIDEOEXTRALEN) << 16);
            // we know that there are TWO bytes per pixel in UYVY format
    //pSurface->dwLength = pNewSurface->lpLcl->lpGbl->lPitch * ((U032)pNewSurface->lpLcl->lpGbl->wHeight) * 2;
    pSurface->dwLength = pSurface->dwPitch * (((U032)pSurface->dwHeight) ) * 2;

    return pSurface;
}


VPERRORS replaceSurfaceWithSurface(U032 surfaceToReplace, LPDDRAWI_DDRAWSURFACE_LCL pNewSurface, U032  bVBI) {

    vpSurfaceInfo*      pSurface;
    U032                    Delta;

    ASSERT( pNewSurface != NULL);

    pSurface = pMySurfaces->Surfaces[surfaceToReplace];
// not sure if this is necessary or not....
//  pSurface->pNvNotify = &(nvMyVPNotifiers[notifyIndexFromBuffer(0)]);

    pSurface->surfHandle = pNewSurface;
    // pSurface->bAutoFlip = bAutoflip; // leave this the same!
    pSurface->pVidMem = VIDMEM_ADDR(pNewSurface->lpGbl->fpVidMem);
    pSurface->ddsCaps = pNewSurface->ddsCaps.dwCaps;
    // pSurface->nextSurfaceNum = nextSurface;      // leave this the same!

    pSurface->dwPitch = pNewSurface->lpGbl->lPitch;

    // move things around in the surface
    if (pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10) {
      Delta = 0;   // in NV10 the overlay can do these calculations..
    } else {
      Delta = pMySurfaces->dwOriginX*2 + pMySurfaces->dwOriginY*pSurface->dwPitch;
    }
    pSurface->dwOffset = (unsigned long) pSurface->pVidMem
                    - (unsigned long)(pMySurfaces->pDriverData)->BaseAddress
                    + Delta;

    if( pMySurfaces->CurrentScanMode == INTERLEAVBUF) {
        // both field have bigger pitch
        pSurface->dwPitch = pNewSurface->lpGbl->lPitch * 2;
    }

    if(bVBI) {
        pSurface->dwStartLine = pMySurfaces->dwVBIStartLine;
    } else {
        //if( pMySurfaces->dwImageStartLine < 6 )
        //  pSurface->dwStartLine = 6;
        //else
            if(pMySurfaces->dwImageStartLine == 1) {
                pSurface->dwStartLine = 16; //tried 17 no much- 15 can see stuff on top of intercast disk - 16?
            } else {
                pSurface->dwStartLine = pMySurfaces->dwImageStartLine;
            }
    }

#define VIDEOEXTRALEN (0)
    // make sure we're not trying to cram something into a surface that's too small
    if(bVBI ) {
        pSurface->dwHeight = pMySurfaces->dwVBIHeight;
    } else {
        if ( pMySurfaces->dwInHeight > pNewSurface->lpGbl->wHeight ) {
            pSurface->dwHeight = pNewSurface->lpGbl->wHeight + VIDEOEXTRALEN;
        } else {
            pSurface->dwHeight = pMySurfaces->dwInHeight + VIDEOEXTRALEN;
        }
    }
    if ( pMySurfaces->dwInWidth > pNewSurface->lpGbl->wWidth ) {
        pSurface->dwWidth = pNewSurface->lpGbl->wWidth;
    } else {
        pSurface->dwWidth = pMySurfaces->dwInWidth;
    }

    pSurface->dwPreScaleSize =  (pMySurfaces->dwPreWidth) | ((pMySurfaces->dwPreHeight+VIDEOEXTRALEN) << 16);
            // we know that there are TWO bytes per pixel in UYVY format
    //pSurface->dwLength = pNewSurface->lpGbl->lPitch * ((U032)pNewSurface->lpGbl->wHeight) * 2;
    pSurface->dwLength = pSurface->dwPitch * (((U032)pSurface->dwHeight) ) * 2;

    return NOVPERROR;

}

VPERRORS clearAllSurfaces() {
    U032    i;

    for (i=0;i<pMySurfaces->numberOfSurfaces; i++ ) {
        pMySurfaces->Surfaces[i] = NULL;
    }

    pMySurfaces->surfMemAllocCount = 0;
    pMySurfaces->numberOfSurfaces = 0;

    return NOVPERROR;
}

U032    findSurface(LPDDRAWI_DDRAWSURFACE_LCL pNewSurface ) {
    U032    i;

    for(i = 0 ; i < pMySurfaces->numberOfSurfaces; i ++ ) {
        if( pNewSurface->lpGbl->fpVidMem == pMySurfaces->Surfaces[i]->pVidMem ) {
            // Ok, we found the surface!
            return i;
        }

    }

    return SURFACENOTFOUND;
}

#if 0

FIELDTYPE   getNextFieldType(FIELDTYPE lastFieldType) {

    switch (pMySurfaces->CurrentCaptureMode) {
            case EVENODD:
                if(lastFieldType ==EVEN ) {
                    return ODD;
                } else if( lastFieldType ==ODD ) {
                    return EVEN;
                } else {
                    return EVEN;
                }
                break;
            case EVENEVEN:
                if(lastFieldType ==EVEN ) {
                    return EVEN;
                } else {
                    return EVEN;
                }
                break;
            case ODDODD:
                if(lastFieldType ==ODD ) {
                    return ODD;
                } else {
                    return ODD;
                }
                break;
            default:
                ASSERT(pMySurfaces->CurrentCaptureMode == ODDODD );
    }
}



U032    ProgramBufferWithSurface(U032   dwBufferIndex,U032  newSurfaceIndex, U032 bZeroLength) {
    // This function is responsible for programming up and then launching buffer/surface combination
    // This will finish Asyncronously, and either be relaunched in the case of auto-flip, or be able
    // to report back usefully with the VPE functions
    U032    nextField;
    U032    dwInterleaveAddition;
    INIT_FREE_COUNT(0);

    ASSERT(dwBufferIndex < 4 );
    ASSERT(newSurfaceIndex < MAXVPSURFACES );
    //Update the surface structures
        // notify


    pMySurfaces->Surfaces[newSurfaceIndex]->pNvNotify = &(nvMyVPNotifiers[notifyIndexFromBuffer(dwBufferIndex)]);
    pMySurfaces->CurrentBufferSurface[dwBufferIndex] = newSurfaceIndex;


    // Figure out the whole field thing
    nextField = getNextFieldType(pMySurfaces->lastField);
    pMySurfaces->Surfaces[newSurfaceIndex]->field = nextField;
    pMySurfaces->lastField = nextField;
    pMySurfaces->curSurf = newSurfaceIndex;

#define PRINTPROGRAM
#ifdef PRINTPROGRAM
    DPF("   ProgramBufferWithSurface");
    DPF("           dwBufferIndex = %d",dwBufferIndex);
    DPF("         newSurfaceIndex = %d",newSurfaceIndex);
    DPF("             bZeroLength = %d",bZeroLength);
    switch (nextField) {
            case ODD:
                 DPF("                   field = ODD");
                break;
            case EVEN:
                 DPF("                   field = EVEN");
                break;
            case UNKNOWN:
                 DPF("                   field = UNKNOWN");
                break;
    }
#endif //PRINTPROGRAM

    // if we're interleaving AND we're on the EVEN field then move everything down a bit
    //   OOD field is on top
    if(( pMySurfaces->CurrentScanMode == INTERLEAVBUF) && (nextField == EVEN ) ) {
        dwInterleaveAddition = pMySurfaces->Surfaces[newSurfaceIndex]->dwPitch/2;
    } else {
        dwInterleaveAddition = 0;
    }
    // choose which type of surface this is
    if( dwBufferIndex <2 ) {
        // Image surface
        // setup the field polarity, offset and fire it off


        // Put decoder object into the channel
        CHECK_FREE_COUNT(pMyNvChan,1*4);
#ifdef NV3
        pMyNvChan->subchannel[0].control.object = MY_EXTERNAL_DECODER_OBJECT;
#else
        pMyNvChan->subchannel[0].SetObject = MY_EXTERNAL_DECODER_OBJECT;
#endif

        // for now use the same "in" as "out"

        CHECK_FREE_COUNT(pMyNvChan,5*4);

        pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetImageStartLine =
            pMySurfaces->Surfaces[newSurfaceIndex]->dwStartLine;

// check for invalid scaling combo's

        // if prescale is not on 2:1 integer boundaries from output, then fail...
        {
            BOOL bScale = checkScalingOk((pMySurfaces->Surfaces[newSurfaceIndex]->dwWidth) |
                                                    (pMySurfaces->Surfaces[newSurfaceIndex]->dwHeight << 16)
                            ,pMySurfaces->Surfaces[newSurfaceIndex]->dwPreScaleSize);

            if(! bScale ) {
                DPF("   Invalid Scaling parameters in use...");

                return (-7);
            }
        }

        pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetImage[dwBufferIndex].sizeIn =
            (pMySurfaces->dwInWidth) | (pMySurfaces->dwInHeight << 16);

        if( bZeroLength ) {
            pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetImage[dwBufferIndex].sizeOut = 0;
        } else {
            pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetImage[dwBufferIndex].sizeOut =
                pMySurfaces->Surfaces[newSurfaceIndex]->dwPreScaleSize;
        }

#ifdef PRINTPROGRAM
        DPF("                  offset = %x",pMySurfaces->Surfaces[newSurfaceIndex]->dwOffset + dwInterleaveAddition);
        DPF("                  pitch  = %x",pMySurfaces->Surfaces[newSurfaceIndex]->dwPitch);
#endif //PRINTPROGRAM
        pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetImage[dwBufferIndex].offset    =
                pMySurfaces->Surfaces[newSurfaceIndex]->dwOffset + dwInterleaveAddition;

        // There is some sly behavior in the field statement...
        // since progressive fields are expected to be delivered in the EVEN fields we only check for OOD
        // and then everything else is considered to be even
        nvMyVPNotifiers[notifyIndexFromBuffer(dwBufferIndex)].status = NV04D_NOTIFICATION_STATUS_IN_PROGRESS;
        pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetImage[dwBufferIndex].format =
                ( pMySurfaces->Surfaces[newSurfaceIndex]->dwPitch & 0xFFFF )  |
                ((( ( nextField == ODD ) ? NV04D_SET_IMAGE_FORMAT_FIELD_ODD_FIELD : NV04D_SET_IMAGE_FORMAT_FIELD_EVEN_FIELD) << 16 ) & 0xFF0000 )  |
                ((NV_OS_WRITE_THEN_AWAKEN << 24 ) & 0xFF000000 ) ;


    } else {
        CHECK_FREE_COUNT(pMyNvChan,3*4);

        // VBI surface
        pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetVbi[dwBufferIndex-2].size  =
            (pMySurfaces->Surfaces[newSurfaceIndex]->dwHeight << 16) | (pMySurfaces->Surfaces[newSurfaceIndex]->dwStartLine) ;

        pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetVbi[dwBufferIndex-2].offset    =
            pMySurfaces->Surfaces[newSurfaceIndex]->dwOffset;

        nvMyVPNotifiers[notifyIndexFromBuffer(dwBufferIndex)].status = NV04D_NOTIFICATION_STATUS_IN_PROGRESS;
        pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetVbi[dwBufferIndex-2].format =
            ( pMySurfaces->Surfaces[newSurfaceIndex]->dwPitch & 0xFFFF )  |
            ((( ( nextField == ODD ) ? NV04D_SET_IMAGE_FORMAT_FIELD_ODD_FIELD : NV04D_SET_IMAGE_FORMAT_FIELD_EVEN_FIELD) << 16 ) & 0xFF0000 )  |
            ((NV_OS_WRITE_THEN_AWAKEN << 24 ) & 0xFF000000 ) ;

    }
    //Update the Capture Class

    return 0;
}


DWORD WINAPI VPInterruptThread(PVOID daParameter) {

    DWORD       waitReturnValue;
    HANDLE  myEvent = (HANDLE) daParameter;

    ASSERT(myEvent != NULL);

    DPF ("   |||||||| Thread Started");

    while(pMySurfaces->bThreadRunning) {
        // sit and wait...
        // we'll wake up on the event which can be triggered EITHER by the RM
        // OR by our parent telling us to wake up and then exit
        waitReturnValue = NvWaitEvent(myEvent,INFINITE);
        if( pMySurfaces->bThreadRunning ) {
            if(!IS_EVENT_ERROR(waitReturnValue)) {
                //DPF ("   interrupt");
                //HandleBufferInterrupt();
                if( pMySurfaces->myTable.handleBufferInterrupts != NULL ) {
                        U032 retval = (pMySurfaces->myTable.handleBufferInterrupts)();
                        if(retval != 0)
                            DPF("FUCKUP!!!!!!!!!   this is ab ad thing    what sometimes this is bad = %8x",retval);
                    } else {
                        ASSERT(1==0);
                        // massive failure... hang out here for a while
                    }
            }
        }
    }

    DPF ("   |||||||| Thread Ending");

    pMySurfaces->bThreadDead = TRUE;

    return 0;
}



#endif
#endif //(!defined(WINNT) && !defined(NVPE))
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\src\nvVShad.cpp ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// ********************************* Direct 3D ******************************
//
//  Module: nvVShad.cpp
//
// **************************************************************************
//
//  History:
//      Hadden Hoppert?           May00           DX8 development
//
// **************************************************************************

#include "nvprecomp.h"

/*****************************************************************************
 *****************************************************************************
 *****************************************************************************
 ***  CVertexShader  *********************************************************
 *****************************************************************************
 *****************************************************************************
 ****************************************************************************/

CVertexShader::CVertexShader()
{
    this->reset();
}

CVertexShader::reset( void )
{
    m_dwHandle    = 0;
    m_dwFVF       = 0;
    m_dwCodeSize  = 0;
    m_pCodeData   = NULL;
    m_dwStride    = 0;
    m_bHasConsts  = FALSE;
    m_one         = 1.0f;
    m_zero        = 0.0f;
    m_ProgramOutput.residentProgram = NULL;
    m_ProgramOutput.residentNumInstructions = 0;
    m_ProgramOutput.residentSize = 0;

    for (int i = 0; i < NV_CAPS_MAX_STREAMS; i++) {
        // sources of the data loaded into the 16 vertex attribute registers
        m_vaSourceData[i].dwStream = VA_STREAM_NONE;
        m_vaSourceData[i].dwOffset = 0;
        m_vaSourceData[i].dwType = 0;
        m_vaSourceData[i].dwSrc  = 0;
        m_vaSourceData[i].flag = AUTONONE;
    }

#if (NVARCH >= 0x020)
    m_pKelvinProgram = NULL;
#endif

    return TRUE;
}

/*****************************************************************************
 * CVertexShader::create
 *
 * create a vertex shader from code
 */
static char *typeDecode[8] = { "D3DVSDT_FLOAT1  ", "D3DVSDT_FLOAT2  ", "D3DVSDT_FLOAT3  ",
                               "D3DVSDT_FLOAT4  ", "D3DVSDT_D3DCOLOR", "D3DVSDT_UBYTE4  ",
                               "D3DVSDT_SHORT2  ", "D3DVSDT_SHORT4  "};

#define SwapSources(a,b)    {   VASOURCEINFO temp;                                      \
                            DWORD dwTemp;                                           \
                    memcpy(&temp, &m_vaSourceData[a], sizeof(VASOURCEINFO));                    \
                            memcpy(&m_vaSourceData[a], &m_vaSourceData[b],sizeof(VASOURCEINFO));                    \
                            memcpy(&m_vaSourceData[b], &temp, sizeof(VASOURCEINFO));                            \
                            for(i=0; i < 16; i++){  if((unsigned int)m_CallerKelvin.inputRegMap[i] == a) break; }           \
                            for(j=0; j < 16; j++){  if((unsigned int)m_CallerKelvin.inputRegMap[j] == b)        break; }    \
                            dwTemp = m_CallerKelvin.inputRegMap[i];                             \
                            m_CallerKelvin.inputRegMap[i] = m_CallerKelvin.inputRegMap[j];                  \
                            m_CallerKelvin.inputRegMap[j] = dwTemp;                             \
                }

CVertexShader::create
(
    PNVD3DCONTEXT pContext,
    DWORD         dwHandle,
    DWORD         dwDeclSize,
    DWORD         dwCodeSize,
    DWORD        *lpDecl,
    DWORD        *lpCode
)
{
    DWORD dwCurrentStream, dwCurrentOffset;
    DWORD dwToken, dwLoadType, dwType, dwReg, dwSwappedReg, dwCount, i, j, dwSrc, dwSwappedSrc;

    // cache the handle
    m_dwHandle = dwHandle;
    nvAssert(m_dwFVF == 0);
    nvAssert( m_dwHandle & 0x1 );

    DPF_LEVEL(NVDBG_LEVEL_VSHADER_INS, "Create vertex shader 0x%02x", dwHandle);

    m_dwCodeSize = dwCodeSize;
    if (dwCodeSize) {
        m_pCodeData = (DWORD *)AllocIPM(dwCodeSize);
        memcpy (m_pCodeData, lpCode, dwCodeSize);  //lpDecl ?
    }

    // parse the declaration
    m_dwStride = 0;

    for (i = 0; i < dwDeclSize; i++, lpDecl++) {

        dwToken = *lpDecl;

        switch ((dwToken & D3DVSD_TOKENTYPEMASK) >> D3DVSD_TOKENTYPESHIFT) {

        case D3DVSD_TOKEN_NOP:
            // NOP or extension
            //nvAssert (dwToken == 0);
            break;

        case D3DVSD_TOKEN_STREAM:
            // stream selector
            dwCurrentStream = (dwToken & D3DVSD_STREAMNUMBERMASK) >> D3DVSD_STREAMNUMBERSHIFT;
            dwCurrentOffset = 0;
            break;

        case D3DVSD_TOKEN_STREAMDATA:
            // stream data definition (map to vertex input memory)
            dwLoadType = (dwToken & D3DVSD_DATALOADTYPEMASK) >> D3DVSD_DATALOADTYPESHIFT;
            if (dwLoadType == 0) {
                // vertex input register load
                dwType = (dwToken & D3DVSD_DATATYPEMASK) >> D3DVSD_DATATYPESHIFT;
                dwReg  = (dwToken & D3DVSD_VERTEXREGMASK) >> D3DVSD_VERTEXREGSHIFT;
                dwSwappedReg  = defaultInputRegMap[dwReg];        //remap inputs to conform to internal formats
                m_vaSourceData[dwSwappedReg].dwStream = dwCurrentStream;
                m_vaSourceData[dwSwappedReg].dwOffset = dwCurrentOffset;
                m_vaSourceData[dwSwappedReg].dwType   = dwType;
                m_vaSourceData[dwSwappedReg].flag     = CVertexShader::AUTONONE;
                DPF_LEVEL (NVDBG_LEVEL_VSHADER_INS, "reg: %02d->%02d , stream: %02d, type: %s, offset %02x, src: %x, flag: %d",
                           dwReg, dwSwappedReg, m_vaSourceData[dwSwappedReg].dwStream, typeDecode[m_vaSourceData[dwSwappedReg].dwType], m_vaSourceData[dwSwappedReg].dwOffset,
                           m_vaSourceData[dwSwappedReg].dwSrc, m_vaSourceData[dwSwappedReg].flag);
                DWORD dwVASize = getVASize(dwSwappedReg);
                dwCurrentOffset += dwVASize;
                m_dwStride      += dwVASize;
            } else {
                // data skip (no register load)
                dwCount = (dwToken & D3DVSD_SKIPCOUNTMASK) >> D3DVSD_SKIPCOUNTSHIFT;
                dwCurrentOffset += dwCount*sizeof(DWORD);
            }
            break;

        case D3DVSD_TOKEN_TESSELLATOR:
            dwReg = (dwToken & D3DVSD_VERTEXREGMASK) >> D3DVSD_VERTEXREGSHIFT;
            dwSwappedReg = defaultInputRegMap[dwReg];        //remap inputs to conform to internal formats
            m_vaSourceData[dwSwappedReg].dwStream = dwCurrentStream;
            m_vaSourceData[dwSwappedReg].dwOffset = NULL;
            dwSrc = (dwToken & D3DVSD_VERTEXREGINMASK) >> D3DVSD_VERTEXREGINSHIFT;
            dwSwappedSrc = defaultInputRegMap[dwSrc];
            m_vaSourceData[dwSwappedReg].dwSrc = dwSwappedSrc;
            m_vaSourceData[dwSwappedReg].dwType   = (dwToken & D3DVSD_DATATYPEMASK)    >> D3DVSD_DATATYPESHIFT;
            if (dwToken & 0x10000000) { // is this a vertex normal def or a UV def
                m_vaSourceData[dwSwappedReg].flag = CVertexShader::AUTOTEXCOORD;
                m_dwStride += 2 * sizeof(DWORD);
            }
            else {
                m_vaSourceData[dwSwappedReg].flag = CVertexShader::AUTONORMAL;
                m_dwStride += 3 * sizeof(DWORD);
            }
            DPF_LEVEL (NVDBG_LEVEL_VSHADER_INS, "reg: %02d->%02d, stream: %02d, type: %s, offset %02x, src: %x->%x, flag: %s",
                       dwReg, dwSwappedReg, m_vaSourceData[dwSwappedReg].dwStream, typeDecode[m_vaSourceData[dwSwappedReg].dwType],
                       m_vaSourceData[dwSwappedReg].dwOffset, dwSrc, dwSwappedSrc,
                       (m_vaSourceData[dwSwappedReg].flag == CVertexShader::AUTOTEXCOORD ? "AUTOTEX" : "AUTONORM" ));
            break;

        case D3DVSD_TOKEN_CONSTMEM:
            // constant memory from shader
            if (!m_bHasConsts) {
                memset(m_numConsts, 0, sizeof(m_numConsts));
                m_bHasConsts = TRUE;
            }
            dwCount = (dwToken & D3DVSD_CONSTCOUNTMASK)   >> D3DVSD_CONSTCOUNTSHIFT;
            dwReg   = (dwToken & D3DVSD_CONSTADDRESSMASK) >> D3DVSD_CONSTADDRESSSHIFT;
            nvAssert(dwReg < D3DVS_CONSTREG_MAX_V1_1);
            nvAssert((dwReg + dwCount) <= D3DVS_CONSTREG_MAX_V1_1);
            memcpy((DWORD *)&m_vertexShaderConstants[dwReg], lpDecl + 1, dwCount * sizeof(VSHADERREGISTER));
            m_numConsts[dwReg] = dwCount;
            lpDecl += 4 * dwCount;
            break;

        case D3DVSD_TOKEN_EXT:
            // extension
            dwCount = (dwToken & D3DVSD_EXTCOUNTMASK) >> D3DVSD_EXTCOUNTSHIFT;
            lpDecl += dwCount;
            break;

        case D3DVSD_TOKEN_END:
            // end-of-array (requires all DWORD bits to be 1)
            i = dwDeclSize; // force exit of for loop
            break;
        }
    }

    //create a kelvin program and upload it
#if (NVARCH >= 0x020)
    if (dwCodeSize)
    {
        m_pKelvinProgram = (PKELVIN_PROGRAM)AllocIPM(sizeof(KELVIN_PROGRAM));

        //parse the D3D code into kelvin meta-code
        nvKelvinParseVertexShaderCode (m_pKelvinProgram, &m_ParsedProgram, lpCode, dwCodeSize);

        m_ParsedProgram.firstInstruction = m_pKelvinProgram->code;
        m_ParsedProgram.liveOnEntry      = FALSE;
        m_ParsedProgram.IsStateProgram   = FALSE; // compiler will add viewport transform code
        vp_Optimize(&m_ParsedProgram, m_pKelvinProgram->dwNumInstructions, 0);

        //compile to kelvin microcode
        if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN)
        {
            // set up kelvin compiler
            m_CallerKelvin.caller_id = 0xD3D;
            m_CallerKelvin.malloc    = glLikeAllocIPM;
            m_CallerKelvin.free      = glLikeFreeIPM;
            m_CallerKelvin.mallocArg = NULL;

            memcpy (m_CallerKelvin.inputRegMap,  defaultInputRegMap,  sizeof(defaultInputRegMap));
            memcpy (m_CallerKelvin.outputRegMap, defaultOutputRegMap, sizeof(defaultOutputRegMap));

            DWORD dwStream = getAutoNormalStream();
            //if the autonormal stream is NOT equal to stream 2 (where we can guard curve) swap 2 and wherever it was?
            if(dwStream != VA_STREAM_NONE && dwStream != 2){

                //swap normal stream into position 2
                SwapSources(dwStream,2);

                //if we have created an autonormal make sure that its src is from stream 0 and swap as necessary.
                if(m_vaSourceData[2].dwSrc != 0x0){     //if src for an autonormal is NOT position 0 --> move it there.
                    dwStream = m_vaSourceData[2].dwSrc;
                    SwapSources(dwStream,0);
                }
                m_vaSourceData[2].dwSrc = 0x0;  //input will be swapped below to come from channel 0

            }

            if (!vp_CompileKelvin(&m_CallerKelvin, &m_ParsedProgram, m_pKelvinProgram->dwNumInstructions, &m_ProgramOutput)) {
                DPF ("Failed to compile kelvin vertex shader code");
                dbgD3DError();
            }
        }
        else
        {
            // set up x86 assembly compiler
            m_Caller.caller_id         = 0xD3D;
            m_Caller.malloc            = glLikeAllocIPM;
            m_Caller.free              = glLikeFreeIPM;
            m_Caller.mallocArg         = NULL;
            m_Caller.exec_malloc       = glLikeAllocIPM;
            m_Caller.expf              = expf;
            m_Caller.logf              = logf;
            // we use addresses instead of offsets and then just pass in 0 for the base address later
            m_Caller.attrib_offset     = int(m_Attrib);
            m_Caller.temp_offset       = int(pContext->pVShaderConsts->vertexShaderTemp);
            m_Caller.result_offset     = int(m_Result);
            m_Caller.param_offset      = int(pContext->pVShaderConsts->vertexShaderConstants);
            m_Caller.float_one_offset  = int(&m_one);
            m_Caller.float_zero_offset = int(&m_zero);

            if (!vp_CompileX86(&m_Caller, &m_ParsedProgram, m_pKelvinProgram->dwNumInstructions, &m_ProgramOutput)) {
                DPF ("Failed to compile X86 vertex shader code");
                dbgD3DError();
            }
        }
    }
#endif
    return TRUE;
}

/*****************************************************************************
 * CVertexShader::create
 *
 * create a vertex shader from FVF format
 */
CVertexShader::create
(
    PNVD3DCONTEXT pContext,
    DWORD         dwFVF,
    DWORD         dwHandle
)
{
    static BYTE bTextureSize[4]  = {2*4, 3*4, 4*4, 1*4};
    static BYTE bTextureCount[4] = { 2,   3,   4,   1 };
    static BYTE bTextureType[4]  = { D3DVSDT_FLOAT2,
                                     D3DVSDT_FLOAT3,
                                     D3DVSDT_FLOAT4,
                                     D3DVSDT_FLOAT1 };
    static BYTE bWeightType[6]   = { 0,
                                     D3DVSDT_FLOAT1,
                                     D3DVSDT_FLOAT2,
                                     D3DVSDT_FLOAT3,
                                     D3DVSDT_FLOAT4,
                                     D3DVSDT_FLOAT4 };

    DWORD dwTextureFormats,dwNumTexSets;
    DWORD dwOffset, dwBCount, i;

    nvAssert( dwFVF );

    // if the FVF handle hasn't changed, just return
    if (m_dwFVF == dwFVF) {
        return (TRUE);
    }

    m_dwHandle   = dwHandle;
    m_dwFVF      = dwFVF;
    m_dwCodeSize = 0;

    dwOffset = 0;

    // x,y,z
    m_vaSourceData[defaultInputRegMap[D3DVSDE_POSITION]].dwStream = 0;
    m_vaSourceData[defaultInputRegMap[D3DVSDE_POSITION]].dwType   = D3DVSDT_FLOAT3;
    m_vaSourceData[defaultInputRegMap[D3DVSDE_POSITION]].dwOffset = dwOffset;
    dwOffset += 3*sizeof(DWORD);

    // default to having no geometry other than x,y,z
    m_vaSourceData[defaultInputRegMap[D3DVSDE_BLENDWEIGHT]].dwStream = VA_STREAM_NONE;
    dwBCount = 0;

    // check for geometry beyond just x,y,z
    switch (dwFVF & D3DFVF_POSITION_MASK) {
        case D3DFVF_XYZ:
            break;
        case D3DFVF_XYZRHW:
            m_vaSourceData[defaultInputRegMap[D3DVSDE_POSITION]].dwType = D3DVSDT_FLOAT4;
            dwOffset += 1*sizeof(DWORD);
            break;
        case D3DFVF_XYZB5:   // we have x,y,z,b1,b2,b3,b4,b5
            dwBCount++;
        case D3DFVF_XYZB4:   // we have x,y,z,b1,b2,b3,b4
            dwBCount++;
        case D3DFVF_XYZB3:   // we have x,y,z,b1,b2,b3
            dwBCount++;
        case D3DFVF_XYZB2:   // we have x,y,z,b1,b2
            dwBCount++;
        case D3DFVF_XYZB1:   // we have x,y,z,b1
            dwBCount++;
            m_vaSourceData[defaultInputRegMap[D3DVSDE_BLENDWEIGHT]].dwStream = 0;
            m_vaSourceData[defaultInputRegMap[D3DVSDE_BLENDWEIGHT]].dwType   = bWeightType[dwBCount];
            m_vaSourceData[defaultInputRegMap[D3DVSDE_BLENDWEIGHT]].dwOffset = dwOffset;
            dwOffset += dwBCount * sizeof(D3DVALUE);
            break;
        default:
            DPF ("unknown position mask in FVF");
            dbgD3DError();
            break;
    }  // switch

    // normal
    if (dwFVF & D3DFVF_NORMAL) {
        m_vaSourceData[defaultInputRegMap[D3DVSDE_NORMAL]].dwStream = 0;
        m_vaSourceData[defaultInputRegMap[D3DVSDE_NORMAL]].dwType   = D3DVSDT_FLOAT3;
        m_vaSourceData[defaultInputRegMap[D3DVSDE_NORMAL]].dwOffset = dwOffset;
        dwOffset += 3*sizeof(DWORD);
    }
    else {
        m_vaSourceData[defaultInputRegMap[D3DVSDE_NORMAL]].dwStream = VA_STREAM_NONE;
    }

    // point size
    if (dwFVF & D3DFVF_PSIZE) {
        // must check runtime version since annoying DX7 apps (Isle of Morg)
        // will set the RESERVED1 flag which is the same as the PSIZE flag
        if (pContext->dwDXAppVersion >= 0x800) {
            m_vaSourceData[defaultInputRegMap[D3DVSDE_PSIZE]].dwStream = 0;
            m_vaSourceData[defaultInputRegMap[D3DVSDE_PSIZE]].dwType   = D3DVSDT_FLOAT1;
            m_vaSourceData[defaultInputRegMap[D3DVSDE_PSIZE]].dwOffset = dwOffset;
        }
        dwOffset += 1*sizeof(D3DVALUE);
    }
    else {
        m_vaSourceData[defaultInputRegMap[D3DVSDE_PSIZE]].dwStream = VA_STREAM_NONE;
    }

    // diffuse
    if (dwFVF & D3DFVF_DIFFUSE) {
        m_vaSourceData[defaultInputRegMap[D3DVSDE_DIFFUSE]].dwStream = 0;
        m_vaSourceData[defaultInputRegMap[D3DVSDE_DIFFUSE]].dwType   = D3DVSDT_D3DCOLOR;
        m_vaSourceData[defaultInputRegMap[D3DVSDE_DIFFUSE]].dwOffset = dwOffset;
        dwOffset += 1*sizeof(DWORD);
    }
    else {
        m_vaSourceData[defaultInputRegMap[D3DVSDE_DIFFUSE]].dwStream = VA_STREAM_NONE;
    }

    // specular
    if (dwFVF & D3DFVF_SPECULAR) {
        m_vaSourceData[defaultInputRegMap[D3DVSDE_SPECULAR]].dwStream = 0;
        m_vaSourceData[defaultInputRegMap[D3DVSDE_SPECULAR]].dwType   = D3DVSDT_D3DCOLOR;
        m_vaSourceData[defaultInputRegMap[D3DVSDE_SPECULAR]].dwOffset = dwOffset;
        dwOffset += 1*sizeof(DWORD);
    }
    else {
        m_vaSourceData[defaultInputRegMap[D3DVSDE_SPECULAR]].dwStream = VA_STREAM_NONE;
    }

    // texture coordinates
    dwNumTexSets     = FVF_TEXCOORD_NUMBER(dwFVF);
    dwTextureFormats = dwFVF >> 16;
    for (i=0; i<dwNumTexSets; i++) {
        m_vaSourceData[defaultInputRegMap[D3DVSDE_TEXCOORD0+i]].dwStream = 0;
        m_vaSourceData[defaultInputRegMap[D3DVSDE_TEXCOORD0+i]].dwType   = bTextureType[dwTextureFormats & 0x3];
        m_vaSourceData[defaultInputRegMap[D3DVSDE_TEXCOORD0+i]].dwOffset = dwOffset;
        dwOffset += bTextureSize[dwTextureFormats & 0x3];
        dwTextureFormats >>= 2;
    }
    for (i=dwNumTexSets; i<NV_CAPS_MAX_UV_SETS; i++) {
        m_vaSourceData[defaultInputRegMap[D3DVSDE_TEXCOORD0+i]].dwStream = VA_STREAM_NONE;
    }

    m_dwStride = dwOffset;

    // set dirty state as required
#if (NVARCH >= 0x010)
    pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_TL_MODE |
                                      CELSIUS_DIRTY_FVF     |
                                      CELSIUS_DIRTY_LIGHTS  |
                                      CELSIUS_DIRTY_TEXTURE_STATE;
    pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_FVF     |
                                      KELVIN_DIRTY_LIGHTS  |
                                      KELVIN_DIRTY_TEXTURE_STATE;
#endif

    return TRUE;
}

/*****************************************************************************
 * CVertexShader::~CVertexShader
 *
 * set the constants of a shader
 */
CVertexShader::~CVertexShader(void)
{
    if (m_pCodeData) {
        FreeIPM (m_pCodeData);
    }

    if (m_ProgramOutput.residentProgram) {
        FreeIPM(m_ProgramOutput.residentProgram);
        m_ProgramOutput.residentProgram = NULL;
        m_ProgramOutput.residentNumInstructions = 0;
        m_ProgramOutput.residentSize = 0;
    }

#if (NVARCH >= 0x020)
    if (m_pKelvinProgram) {
        FreeIPM (m_pKelvinProgram);
    }
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\src\TransInit.cpp ===
/***************************************************************************\
* (C) Copyright NVIDIA Corporation Inc.,                                    *
*  1996,1997, 1998. All rights reserved.                                    *
* THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO       *
* NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY  *
* IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.                *
*                                                                           *
* Module: TransInit.cpp                                                     *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       schaefer           8/17/98                                          *
*                                                                           *
\***************************************************************************/
// these are intented to be called from surfaces.c setupvp and teardownvp

#include "nvprecomp.h"
#pragma hdrstop

extern vpSurfaces*          pMySurfaces;
extern NvNotification*      nvMyVPNotifiers;
NvChannel*          nvPtr = NULL;


U032 SetupMTM() {
    U032    i;
    U032    error;
    nvPtr = pMySurfaces->pVPChanPtr;

    // allocate the MTM object
#ifdef NV3
    error = NvRmAllocObject(  (GLOBDATAPTR)->ROOTHANDLE,
                                MY_VPE_CHANNEL,
                                MY_MTM_OBJECT,
                                NV_MEMORY_TO_MEMORY_FORMAT
                              );
#else
    error = NvRmAllocObject(  (GLOBDATAPTR)->ROOTHANDLE,
                                MY_VPE_CHANNEL,
                                MY_MTM_OBJECT,
                                NV03_MEMORY_TO_MEMORY_FORMAT
                                );
#endif // !NV3
    if(checkNvAllocArchError(error )) {
        DPF("NVDD: Cannot allocate MTM object %d",MY_EXTERNAL_DECODER_OBJECT);
        return FALSE;
    }


    // allocate the notify context
    error = NvRmAllocContextDma(  (GLOBDATAPTR)->ROOTHANDLE,
                                MY_MTM_NOTIFIER,
                                NV01_CONTEXT_DMA,
                                DRF_DEF(OS03, _FLAGS, _ACCESS, _READ_WRITE) |
                                DRF_DEF(OS03, _FLAGS, _COHERENCY, _UNCACHED),
                                (PVOID)(((U032)nvMyVPNotifiers) + NUM039OFFSET*sizeof(NvNotification)),
                                (sizeof( NvNotification)*NUM039NOTIFIER  - 1)
                         );
    if(checkNvAllocArchError(error )) {
        DPF("NVDD: Cannot allocate MTM Notifier object %d",MY_EXTERNAL_DECODER_OBJECT);
        return FALSE;
    }

    // allocate the FROM context
    error = NvRmAllocContextDma(  (GLOBDATAPTR)->ROOTHANDLE,
                                MY_MTM_FROM_CONTEXT,
                                NV01_CONTEXT_DMA,       //NV_CONTEXT_DMA_FROM_MEMORY ?
                                DRF_DEF(OS03, _FLAGS, _ACCESS, _READ_WRITE) |
                                DRF_DEF(OS03, _FLAGS, _COHERENCY, _UNCACHED),
                                (PVOID)(void*)((GLOBALDATA*)(pMySurfaces->pDriverData))->BaseAddress,
                                ((((GLOBALDATA*)(pMySurfaces->pDriverData))->VideoHeapEnd - ((GLOBALDATA*)(pMySurfaces->pDriverData))->BaseAddress)) -1
                         );

    if(checkNvAllocArchError(error )) {
        DPF("NVDD: Cannot allocate MTM FROM context object %d",MY_EXTERNAL_DECODER_OBJECT);
        return FALSE;
    }

    // allocate the MTM event
    error = NvRmAllocEvent  (   (GLOBDATAPTR)->ROOTHANDLE,
                                        MY_MTM_OBJECT,
                                MY_MTM_EVENT,
                                NV01_EVENT_KERNEL_CALLBACK,
                                        NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(0),
                                        (void*)pMySurfaces->pMTMNotifyCallback);

    if(checkNvAllocArchError(error )) {
        DPF("NVDD: Cannot allocate MTM event object %d",MY_EXTERNAL_DECODER_OBJECT);
        return FALSE;
    }
#if 0
// second one until RM is working

    error = NvRmAllocEvent  (   (GLOBDATAPTR)->ROOTHANDLE,
                                        MY_MTM_OBJECT,
                                MY_MTM_EVENT2,
                                NV01_EVENT_KERNEL_CALLBACK,
                                        NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(0),
                                        (void*)pMySurfaces->pMTMNotifyCallback);

    if(checkNvAllocArchError(error )) {
        DPF("NVDD: Cannot allocate MTM event object %d",MY_EXTERNAL_DECODER_OBJECT);
        return FALSE;
    }
// done with second one
#endif

#ifdef NV3
    nvPtr->subchannel[5].control.object = MY_MTM_OBJECT;
#else
    nvPtr->subchannel[5].SetObject  = MY_MTM_OBJECT;
#endif


#ifdef NV3
    nvPtr->subchannel[5].memoryToMemoryFormat.SetBufferNotifyCtxDma = MY_MTM_NOTIFIER;
    nvPtr->subchannel[5].memoryToMemoryFormat.SetBufferInCtxDma = MY_MTM_FROM_CONTEXT;
#else
    nvPtr->subchannel[5].nv03MemoryToMemoryFormat.SetContextDmaNotifies = MY_MTM_NOTIFIER;
    nvPtr->subchannel[5].nv03MemoryToMemoryFormat.SetContextDmaBufferIn = MY_MTM_FROM_CONTEXT;
#endif

    // Null out the transfers
    for(i=0;i<MAXTRANSFERS;i++) {
        pMySurfaces->MyTransfers[i].TransferID = TRANSFERNOTINUSE;
    }
//  pMySurfaces->pLastTransfer =
    pMySurfaces->pCurrentTransfer = NULL;
    pMySurfaces->bContextCreated    = FALSE;
    return TRUE;
}



void TearDownMTM() {
    U032    i;
    U032    error;
    nvPtr = pMySurfaces->pVPChanPtr;


    // set the transfers to something useless
    for(i=0;i<MAXTRANSFERS;i++) {
        pMySurfaces->MyTransfers[i].TransferID = 0;
    }

    if(nvPtr != NULL ) {
#ifdef NV3
        nvPtr->subchannel[5].control.object = MY_MTM_OBJECT;
#else
        nvPtr->subchannel[5].SetObject  = MY_MTM_OBJECT;
#endif

                                                                            // plug in some null objects
#ifdef NV3
        nvPtr->subchannel[5].memoryToMemoryFormat.SetBufferNotifyCtxDma = 0;
        nvPtr->subchannel[5].memoryToMemoryFormat.SetBufferInCtxDma = 0;
        nvPtr->subchannel[5].memoryToMemoryFormat.SetBufferOutCtxDma = 0;
#else
        nvPtr->subchannel[5].nv03MemoryToMemoryFormat.SetContextDmaNotifies = 0;
        nvPtr->subchannel[5].nv03MemoryToMemoryFormat.SetContextDmaBufferIn = 0;
        nvPtr->subchannel[5].nv03MemoryToMemoryFormat.SetContextDmaBufferOut = 0;
#endif

    // DO a SYNC here.
        // spin waiting for empty fifo
        {
            long countDown = 0x200000;

#ifdef NV3
            while( (NvGetFreeCount(nvPtr, 5) < NV_GUARANTEED_FIFO_SIZE ) && (countDown > 0) )
                NV_SLEEP;
#else
            while( (NvGetFreeCount(nvPtr, 5) < NV06A_FIFO_GUARANTEED_SIZE ) && (countDown > 0) )
                NV_SLEEP;
#endif
        }

    }

    if(pMySurfaces->bContextCreated) {
        error = NvRmFree((GLOBDATAPTR)->ROOTHANDLE, (GLOBDATAPTR)->ROOTHANDLE, MY_MTM_TO_CONTEXT);

        checkNvAllocArchError(error);
        pMySurfaces->bContextCreated = FALSE;

    }

#ifdef NOEVENTFREEFUNCTIONYETFOLKS
    error = NvRmFree((GLOBDATAPTR)->ROOTHANDLE, MY_MTM_OBJECT, MY_MTM_EVENT);
   checkNvAllocArchError(error);
#if 0
    error = NvRmFree((GLOBDATAPTR)->ROOTHANDLE, MY_MTM_OBJECT, MY_MTM_EVENT2);
   checkNvAllocArchError(error);
#endif

#endif

    error = NvRmFree((GLOBDATAPTR)->ROOTHANDLE, (GLOBDATAPTR)->ROOTHANDLE, MY_MTM_NOTIFIER);
    checkNvAllocArchError(error);
    error = NvRmFree((GLOBDATAPTR)->ROOTHANDLE, (GLOBDATAPTR)->ROOTHANDLE, MY_MTM_FROM_CONTEXT);
    checkNvAllocArchError(error);
    error = NvRmFree((GLOBDATAPTR)->ROOTHANDLE, MY_VPE_CHANNEL, MY_MTM_OBJECT);
    checkNvAllocArchError(error);

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common\src\TexInit.cpp ===
/***************************************************************************\
* Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.            *
* THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO       *
* NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY  *
* IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.                *
*                                                                           *
* Module: TexInit.cpp                                                       *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       schaefer           11/16/98                                         *
*                                                                           *
\***************************************************************************/
#include "nvprecomp.h"

#if (NVARCH >= 0x04)

extern vpSurfaces*          pMySurfaces;
extern NvNotification*      nvMyVPNotifiers;


void initTextureSurf(void) {
    U032    error;

    // We're going to stuff things into our channel which are NV4 only
    // since the channel is an NV3 channel we have to type cast it to NV4
    // KevinK says this works fine...
    Nv04ChannelPio* nvPtr = (Nv04ChannelPio*)pMySurfaces->pVPChanPtr;

    // allocate the objects and the notifiers
    //   the contexts we have to do on the fly in ring0


    // allocate the notifier for the swiz class
    error = NvRmAllocContextDma(  (GLOBDATAPTR)->ROOTHANDLE,
        MY_SWIZ_NOTIFIER,
        NV01_CONTEXT_DMA,
        DRF_DEF(OS03, _FLAGS, _ACCESS, _READ_WRITE) |
        DRF_DEF(OS03, _FLAGS, _COHERENCY, _UNCACHED),
        (PVOID)(((U032)nvMyVPNotifiers) + NUM077OFFSET*sizeof(NvNotification)),
        (sizeof( NvNotification)*NUM077NOTIFIER  - 1)
   );
    checkNvAllocArchError(error);

    // allocate the notifer for the 2dswized surface class
    error = NvRmAllocContextDma(  (GLOBDATAPTR)->ROOTHANDLE,
        MY_2DSWIZD_NOTIFIER,
        NV01_CONTEXT_DMA,
        DRF_DEF(OS03, _FLAGS, _ACCESS, _READ_WRITE) |
        DRF_DEF(OS03, _FLAGS, _COHERENCY, _UNCACHED),
        (PVOID)(((U032)nvMyVPNotifiers) + NUM052OFFSET*sizeof(NvNotification)),
        (sizeof( NvNotification)*NUM052NOTIFIER  - 1)
   );
    checkNvAllocArchError(error);

   // allocate the swizzler object
    error = NvRmAllocObject(  (GLOBDATAPTR)->ROOTHANDLE,
                                MY_VPE_CHANNEL,
                                MY_SWIZ_OBJECT,
                                        NV04_CONTEXT_SURFACE_SWIZZLED
                                );

    checkNvAllocArchError(error);
    // allocate the swizzled surface
    error = NvRmAllocObject(  (GLOBDATAPTR)->ROOTHANDLE,
                                MY_VPE_CHANNEL,
                                MY_2DSWIZD_OBJECT,
                                        NV4_STRETCHED_IMAGE_FROM_CPU
                                );
    checkNvAllocArchError(error);

    //setup subchannels
    // subchannel 3-swiz 4-conv
    nvPtr->subchannel[3].SetObject  = MY_SWIZ_OBJECT;
    nvPtr->subchannel[4].SetObject = MY_2DSWIZD_OBJECT;

    // plug the notifiers in
    nvPtr->subchannel[3].nv04ScaledImageFromMemory.SetContextDmaNotifies = MY_SWIZ_NOTIFIER;
    nvPtr->subchannel[4].nv04ContextSurfaceSwizzled.SetContextDmaNotifies = MY_2DSWIZD_NOTIFIER;
    //
    // entire frame buffer context stolen from VPE stuff
    nvPtr->subchannel[3].nv04ScaledImageFromMemory.SetContextDmaImage = MY_IMAGE0_BUFFER_CONTEXT;
    // I think this is the correct color format...
    nvPtr->subchannel[3].nv04ScaledImageFromMemory.SetContextSurface = MY_2DSWIZD_OBJECT;
    // entire frame buffer context stolen from VPE stuff

}


void DestroyTextureSurf(void) {
    U032    error;

    error = NvRmFree((GLOBDATAPTR)->ROOTHANDLE, (GLOBDATAPTR)->ROOTHANDLE, MY_SWIZ_NOTIFIER);
    checkNvAllocArchError(error);
    error = NvRmFree((GLOBDATAPTR)->ROOTHANDLE, (GLOBDATAPTR)->ROOTHANDLE, MY_2DSWIZD_NOTIFIER);
    checkNvAllocArchError(error);
    error = NvRmFree((GLOBDATAPTR)->ROOTHANDLE, MY_VPE_CHANNEL, MY_SWIZ_OBJECT);
    checkNvAllocArchError(error);
    error = NvRmFree((GLOBDATAPTR)->ROOTHANDLE, MY_VPE_CHANNEL, MY_2DSWIZD_OBJECT);
    checkNvAllocArchError(error);

}

#endif  // NVARCH >= 0x04
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common_disp\src\nvD3DKelvinBackend.cpp ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein./
//
// ********************************* Direct 3D ******************************
//
//  Module: nvD3DKelvinBackend.cpp
//      basically just a pointer to a shared file
//
// **************************************************************************
//
//  History:
//      Daniel Rohrer          14Aug2000         DX8 development
//
// **************************************************************************
#include "nvprecomp.h"

#include "..\..\..\common\src\nvD3DKelvinBackend.c"
//The include file goes to the shared code (native kelvin)

// this is the software fallback case which draws emulated triangles... VERY slow and not efficient.
static void nvKelvinBeginPrimImm(void *info, NV_PATCH_PRIMITIVE_TYPE primType)
{
    getDC()->nvPusher.makeSpace(2);
    switch (primType) {
    case NV_PATCH_PRIMITIVE_TSTRIP:
        getDC()->nvPusher.push (0, 0x00040000 | (NV_DD_KELVIN << 13) | NV097_SET_BEGIN_END);
        getDC()->nvPusher.push (1, NV056_SET_BEGIN_END_OP_TRIANGLE_STRIP);
        DPF_LEVEL(NVDBG_LEVEL_HOS_VERTEX_INFO ,"HOS: Begin TriStrip");
        break;
    case NV_PATCH_PRIMITIVE_TFAN:
        getDC()->nvPusher.push (0, 0x00040000 | (NV_DD_KELVIN << 13) | NV097_SET_BEGIN_END);
        getDC()->nvPusher.push (1, NV056_SET_BEGIN_END_OP_TRIANGLE_FAN);
        DPF_LEVEL(NVDBG_LEVEL_HOS_VERTEX_INFO ,"HOS: Begin TriFan");
        break;
    }
    getDC()->nvPusher.adjust(2);
}

static void nvKelvinEndPrimImm(void *info)
{
    getDC()->nvPusher.push (0, 0x00040000 | (NV_DD_KELVIN << 13) | NV097_SET_BEGIN_END);
    getDC()->nvPusher.push (1, NV097_SET_BEGIN_END_OP_END);
    getDC()->nvPusher.adjust(2);
    DPF_LEVEL(NVDBG_LEVEL_HOS_VERTEX_INFO ,"HOS: End Prim");
}

#define VIEW_AS_DWORD(f) (*(DWORD *)(&(f)))

//map our enables bits to kelvin rendering
static int inline_renderorder[] = {
    D3DVSDE_POSITION,
    D3DVSDE_BLENDWEIGHT,
    D3DVSDE_NORMAL,
    D3DVSDE_DIFFUSE,
    D3DVSDE_SPECULAR,
    D3DVSDE_PSIZE,           
    D3DVSDE_TEXCOORD0,
    D3DVSDE_TEXCOORD1,
    D3DVSDE_TEXCOORD2,
    D3DVSDE_TEXCOORD3
};

NV_INLINE int dumpAttribute(float *pFinalAttribs, CVertexShader *pShader, DWORD dwReg, int i){
    DWORD packedByte;
    DWORD index = dwReg*4;
    switch(pShader->getVAType(dwReg)){
    case NV_PATCH_VERTEX_FORMAT_FLOAT_1:
        DPF_LEVEL(NVDBG_LEVEL_HOS_VERTEX_INFO ,"HOS:\t%d\t%f",dwReg,pFinalAttribs[4*dwReg+0]);
        getDC()->nvPusher.push (i, VIEW_AS_DWORD(pFinalAttribs[index+0]));
        i++; break;
    case NV_PATCH_VERTEX_FORMAT_FLOAT_2:
        DPF_LEVEL(NVDBG_LEVEL_HOS_VERTEX_INFO ,"HOS:\t%d\t%f\t%f",dwReg,pFinalAttribs  [4*dwReg+0],pFinalAttribs[4*dwReg+1]);
        getDC()->nvPusher.push (i,   VIEW_AS_DWORD(pFinalAttribs[index+0]));
        getDC()->nvPusher.push (i+1, VIEW_AS_DWORD(pFinalAttribs[index+1]));
        i+=2; break;
    case NV_PATCH_VERTEX_FORMAT_FLOAT_3:
        DPF_LEVEL(NVDBG_LEVEL_HOS_VERTEX_INFO ,"HOS:\t%d\t%f\t%f\t%f",dwReg,pFinalAttribs[4*dwReg+0],pFinalAttribs[4*dwReg+1],pFinalAttribs[4*dwReg+2]);
        getDC()->nvPusher.push (i,   VIEW_AS_DWORD(pFinalAttribs[index+0]));
        getDC()->nvPusher.push (i+1, VIEW_AS_DWORD(pFinalAttribs[index+1]));
        getDC()->nvPusher.push (i+2, VIEW_AS_DWORD(pFinalAttribs[index+2]));
        i+=3; break;
    case NV_PATCH_VERTEX_FORMAT_FLOAT_4:
        DPF_LEVEL(NVDBG_LEVEL_HOS_VERTEX_INFO ,"HOS:\t%d\t%f\t%f\t%f\t%f",dwReg,pFinalAttribs[4*dwReg+0],pFinalAttribs[4*dwReg+1],
                                                                 pFinalAttribs[4*dwReg+2],pFinalAttribs[4*dwReg+3]);
        getDC()->nvPusher.push (i,   VIEW_AS_DWORD(pFinalAttribs[index+0]));
        getDC()->nvPusher.push (i+1, VIEW_AS_DWORD(pFinalAttribs[index+1]));
        getDC()->nvPusher.push (i+2, VIEW_AS_DWORD(pFinalAttribs[index+2]));
        getDC()->nvPusher.push (i+3, VIEW_AS_DWORD(pFinalAttribs[index+3]));
        i+=4; break;
    case NV_PATCH_VERTEX_FORMAT_UBYTE:
    case NV_PATCH_VERTEX_FORMAT_D3DCOLOR: 
        //packed byte will be expanded by tess to 4 vec float
        //pack it back down so the backend FVF definition isn't different                                    
        packedByte  = (max(0,min((int)(pFinalAttribs[index + 0]*255.0),255))<<16);
        packedByte |= (max(0,min((int)(pFinalAttribs[index + 1]*255.0),255))<<8);
        packedByte |= (max(0,min((int)(pFinalAttribs[index + 2]*255.0),255))<<0);
        packedByte |= (max(0,min((int)(pFinalAttribs[index + 3]*255.0),255))<<24);
        DPF_LEVEL(NVDBG_LEVEL_HOS_VERTEX_INFO ,"HOS:\t%d\t%x",dwReg,packedByte);
        getDC()->nvPusher.push (i, packedByte);
        i++; break; 
    case D3DVSDT_SHORT2:   // 6
    case D3DVSDT_SHORT4:   // 7
    default:
        DPF_LEVEL(NVDBG_LEVEL_HOS_VERTEX_INFO ,"HOS:\tDefault: vertex shouldn't be here!!");
        nvAssert(0);
    }
    return i;
}

static void nvKelvinSendPrimImm(void *context, NV_PATCH_EVAL_OUTPUT *pData, int index)
{
    float *pFinalAttribs = &pData->vertexAttribs[index][0][0];
    NV_PATCH_INFO     *info = (NV_PATCH_INFO*)context;
    PNVD3DCONTEXT  pContext = (PNVD3DCONTEXT)info->context;    
    CVertexShader  *pShader = pContext->hwState.pVertexShader;                  
    int i,j,bUsesTexture;    
    DWORD dwReg;

    if (pShader->hasProgram()) {        
        getDC()->nvPusher.push (0, (info->vertexSize << 18) | (NV_DD_KELVIN << 13) | NVPUSHER_NOINC(NV097_INLINE_ARRAY));
        i = 1;
        for(j=0; j < 16; j++){                        
            if(info->evalEnables & 1<<j){
                i = dumpAttribute(pFinalAttribs, pShader, j, i);
            }
        }
        getDC()->nvPusher.adjust(info->vertexSize + 1);
    } else{
        getDC()->nvPusher.push (0, (info->vertexSize << 18) | (NV_DD_KELVIN << 13) | NVPUSHER_NOINC(NV097_INLINE_ARRAY));
        i=1;
        bUsesTexture = 1;
        for(j=0; j < 10; j++){            
            //THIS SHOULD ONLY EVER BE CALLED VIA KELVIN            
            //this will force the inline vertex stride to match kelvin setup in sequencer mode
            dwReg = inline_renderorder[j];                        
            if(!pShader->hasProgram() && dwReg >= D3DVSDE_TEXCOORD0 && dwReg <= D3DVSDE_TEXCOORD3){
                dwReg = defaultInputRegMap[dwReg];            
                bUsesTexture = 0;
                DWORD dwTCIndex, dwVAIndex, dwHWStage;
                for (dwHWStage=0; dwHWStage < KELVIN_NUM_TEXTURES; dwHWStage++) {
                    if ((pContext->hwState.dwStateFlags & KELVIN_FLAG_USERTEXCOORDSNEEDED(dwHWStage))) {
                        dwTCIndex = (pContext->hwState.dwTexCoordIndices >> (8*dwHWStage)) & 0xff;
                        dwVAIndex = defaultInputRegMap[D3DVSDE_TEXCOORD0+dwTCIndex];
                        if(dwVAIndex == dwReg){ bUsesTexture = 1; break;}
                    }
                }
            }
            else{
                dwReg = defaultInputRegMap[dwReg];            
            }
            if((info->evalEnables & 1<<dwReg) && bUsesTexture){
                i = dumpAttribute(pFinalAttribs, pShader, dwReg,i);
            }
        }
        getDC()->nvPusher.adjust(info->vertexSize + 1);
    }
}

static void nvKelvinStreamInit(void  *context)
{
    //getDC()->nvPusher.flush(TRUE,CPushBuffer::FLUSH_HEAVY_POLLING);
    //NV_PATCH_INFO *info = (NV_PATCH_INFO*)context;
    return;
}

static void nvKelvinStreamDestroy(void *context)
{
    //getDC()->nvPusher.flush(TRUE,CPushBuffer::FLUSH_HEAVY_POLLING);
    //NV_PATCH_INFO *info = (NV_PATCH_INFO*)context;
    return;
}

static void nvKelvinSendFrontFace(void *context, int reversed){
    PNVD3DCONTEXT pContext;
    NV_PATCH_INFO *info = (NV_PATCH_INFO*)context;
    pContext = (PNVD3DCONTEXT)info->context;

    switch(pContext->dwRenderState[D3DRENDERSTATE_CULLMODE]){
    case D3DCULL_NONE:
            break;
    case D3DCULL_CW:
            reversed=1-reversed;
    case D3DCULL_CCW:
        getDC()->nvPusher.push(0, (0x1 << 18) | (NV_DD_KELVIN << 13) | NV097_SET_FRONT_FACE);
        if(reversed){
            DPF_LEVEL(NVDBG_LEVEL_HOS_VERTEX_INFO ,"HOS: Cull CW");
            getDC()->nvPusher.push(1, NV097_SET_FRONT_FACE_V_CW);
        } else {
            DPF_LEVEL(NVDBG_LEVEL_HOS_VERTEX_INFO ,"HOS: Cull CCW");
            getDC()->nvPusher.push(1, NV097_SET_FRONT_FACE_V_CCW);
        }
        getDC()->nvPusher.adjust(2);
        break;
    default:
        nvAssert(0);    //should never be here
    }
}

static void nvKelvinBeginPatch(void *context){      
#ifdef DCR_SEMAPHORE
    NV_PATCH_INFO *info = (NV_PATCH_INFO*)context;   
    //COUNTER IS STORED AT OFFSET 0x0 in the page of semaphores
    //SEMAPHORE IS STORED AT 0x4
#if defined(IS_OPENGL)
#if defined(linux)
    //NEED AN INTERLOCK EXCHANGE HERE!!!!
    //COULD WE JUST USE THE CLIP_SPIN LOCK INSTEAD??? TO 
    //MUTEX ANY CHANGES TO THE COUNTER VALUE
#endif
#if defined(OSX)
    //JAYANT SAYS MAC DOESN'T PREEMPTIVE SWITCH YET
    //SO UNTIL OSX IS READY NOTHING NEEDED HERE
#endif
#else
    info->counter = InterlockedIncrement(&(g_FDGlobalData.FDSynchCounter[0]));
#endif       
    //set the semaphore context DMA to the FD semaphore set
    getDC()->nvPusher.push (0, (0x00040000 | (NV_DD_KELVIN << 13) | NV206E_SET_CONTEXT_DMA_SEMAPHORE));
    getDC()->nvPusher.push (1, FD_SEMAPHORE_206E_CONTEXT_DMA);    // must be read-only
    getDC()->nvPusher.push (2, (0x00040000 | (NV_DD_KELVIN << 13) | NV097_SET_CONTEXT_DMA_SEMAPHORE));
    getDC()->nvPusher.push (3, FD_SEMAPHORE_097_CONTEXT_DMA);   
   
    getDC()->nvPusher.push (4, (0x00040000 | NV206E_SEMAPHORE_OFFSET));
    getDC()->nvPusher.push (5, 0x4);       
    getDC()->nvPusher.push (6, (0x00040000 | NV206E_SEMAPHORE_ACQUIRE));
    getDC()->nvPusher.push (7, info->counter-1);

    //reset the semaphore context DMA to the standard kelvin flipper
    getDC()->nvPusher.push (8, (0x00040000 | (NV_DD_KELVIN << 13) | NV206E_SET_CONTEXT_DMA_SEMAPHORE));
    getDC()->nvPusher.push (9, CSemaphoreManager::SEMAPHORE_CONTEXT_DMA_FROM_MEMORY);    //must be read-only
    getDC()->nvPusher.push (10, (0x00040000 | (NV_DD_KELVIN << 13) | NV097_SET_CONTEXT_DMA_SEMAPHORE));
    getDC()->nvPusher.push (11,  CSemaphoreManager::SEMAPHORE_CONTEXT_DMA_IN_MEMORY);    //must be read-write

    getDC()->nvPusher.adjust (12);
    getDC()->nvPusher.start(TRUE);
#endif
    return;
}

static void nvKelvinEndPatch(void *context){
#ifdef DCR_SEMAPHORE
    NV_PATCH_INFO *info = (NV_PATCH_INFO*)context;   

    //set the semaphore context DMA to the FD semaphore set
    getDC()->nvPusher.push (0, (0x00040000 | (NV_DD_KELVIN << 13) | NV206E_SET_CONTEXT_DMA_SEMAPHORE));
    getDC()->nvPusher.push (1, FD_SEMAPHORE_206E_CONTEXT_DMA);    
    getDC()->nvPusher.push (2, (0x00040000 | (NV_DD_KELVIN << 13) | NV097_SET_CONTEXT_DMA_SEMAPHORE));
    getDC()->nvPusher.push (3, FD_SEMAPHORE_097_CONTEXT_DMA);   

    getDC()->nvPusher.push (4, (0x00040000 | NV206E_SEMAPHORE_OFFSET));        
    getDC()->nvPusher.push (5, 0x4);
    getDC()->nvPusher.push (6, (0x00040000 | NV206E_SEMAPHORE_RELEASE));
    getDC()->nvPusher.push (7, info->counter);

    //reset the semaphore context DMA to the standard kelvin flipper
    getDC()->nvPusher.push (8, (0x00040000 | (NV_DD_KELVIN << 13) | NV206E_SET_CONTEXT_DMA_SEMAPHORE));
    getDC()->nvPusher.push (9, CSemaphoreManager::SEMAPHORE_CONTEXT_DMA_FROM_MEMORY);   //must be read-only
    getDC()->nvPusher.push (10, (0x00040000 | (NV_DD_KELVIN << 13) | NV097_SET_CONTEXT_DMA_SEMAPHORE));
    getDC()->nvPusher.push (11, CSemaphoreManager::SEMAPHORE_CONTEXT_DMA_IN_MEMORY);    //must be read-write
    
    getDC()->nvPusher.adjust (12);
    getDC()->nvPusher.start(TRUE);
#endif
    return;
}

NV_PATCH_BACKEND nvKelvinImm_Backend = {
    nvKelvinStreamInit,
    nvKelvinStreamDestroy,
    nvKelvinBeginPrimImm,
    nvKelvinEndPrimImm,
    nvKelvinSendPrimImm,
    nvKelvinSendFrontFace,
    nvKelvinBeginPatch,
    nvKelvinEndPatch
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common_disp\src\nvD3DCelsiusBackend.cpp ===
//**************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
//
//  Module: nvGLBackend.c
//        gl immediate mode entry points for the patch shared library
//
//  History:
//        Daniel Rohrer    (drohrer)      23Jun00      created
//
// **************************************************************************

#include "nvprecomp.h"
#ifdef HOSURF_ENABLE

static void nvCelsiusBeginPrimImm(void *info, NV_PATCH_PRIMITIVE_TYPE primType)
{
    getDC()->nvPusher.makeSpace(2);
    switch (primType) {
    case NV_PATCH_PRIMITIVE_TSTRIP:
        getDC()->nvPusher.push (0, 0x00040000 | (NV_DD_CELSIUS << 13) | NV056_SET_BEGIN_END4);
        getDC()->nvPusher.push (1, NV056_SET_BEGIN_END_OP_TRIANGLE_STRIP);
        DPF_LEVEL(NVDBG_LEVEL_HOS_VERTEX_INFO ,"HOS: Begin TriStrip");
        break;
    case NV_PATCH_PRIMITIVE_TFAN:
        getDC()->nvPusher.push (0, 0x00040000 | (NV_DD_CELSIUS << 13) | NV056_SET_BEGIN_END4);
        getDC()->nvPusher.push (1, NV056_SET_BEGIN_END_OP_TRIANGLE_FAN);
        DPF_LEVEL(NVDBG_LEVEL_HOS_VERTEX_INFO ,"HOS: Begin TriFan");
        break;
    }
    getDC()->nvPusher.adjust(2);
}

static void nvCelsiusEndPrimImm(void *info)
{
    getDC()->nvPusher.push (0, 0x00040000 | (NV_DD_CELSIUS << 13) | NV056_SET_BEGIN_END4);
    getDC()->nvPusher.push (1, NV056_SET_BEGIN_END_OP_END);
    getDC()->nvPusher.adjust(2);
    DPF_LEVEL(NVDBG_LEVEL_HOS_VERTEX_INFO ,"HOS: End Prim");
}

#define VIEW_AS_DWORD(f) (*(DWORD *)(&(f)))

// map our enables bits to celsius rendering
static int inline_renderorder[] = {
    D3DVSDE_BLENDWEIGHT,
    D3DVSDE_NORMAL,
    D3DVSDE_TEXCOORD1,
    D3DVSDE_TEXCOORD0,
    D3DVSDE_SPECULAR,
    D3DVSDE_DIFFUSE,
    D3DVSDE_POSITION
};

// This won't work quite right until we have state aliasing for vertex programs.
extern DWORD method_dispatch [9][16][2];
static void nvCelsiusSendPrimImm(void *context, NV_PATCH_EVAL_OUTPUT *pData, int index)
{
    float *pAttribs = &pData->vertexAttribs[index][0][0];
    float *pFinalAttribs;
    NV_PATCH_INFO *info = (NV_PATCH_INFO*)context;
    int evalEnables = info->evalEnables;
    int vertexSize = info->vertexSize;
    int i,j;
    DWORD mapping;
    DWORD packedByte, dwT0, dwT1, dwType;
    PNVD3DCONTEXT pContext;

    BOOL bUseTSSState = FALSE;

    pContext = (PNVD3DCONTEXT)info->context;
    // if we don't have a program we need to double check the TSS State and see what we
    // need to actually output.
    if(pContext && !pContext->pCurrentVShader->hasProgram()){
        // if textures are on enable the texture 'arrays'
        // even though they may not have data... dwT0/dwT1 will fetch from the right place
        if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_USERTEXCOORDSNEEDED(0)) {
            DWORD dwTCIndex = (pContext->hwState.dwTexCoordIndices >>  0) & 0xffff;
            dwT0 = defaultInputRegMap[D3DVSDE_TEXCOORD0+dwTCIndex];
            evalEnables |= (1 << defaultInputRegMap[D3DVSDE_TEXCOORD0]);
        }
        else{
            dwT0 = defaultInputRegMap[D3DVSDE_TEXCOORD0];
            evalEnables &= ~(1 << defaultInputRegMap[D3DVSDE_TEXCOORD0]);
        }
        if (pContext->hwState.dwStateFlags & CELSIUS_FLAG_USERTEXCOORDSNEEDED(1)) {
            DWORD dwTCIndex = (pContext->hwState.dwTexCoordIndices >> 16) & 0xffff;
            dwT1 = defaultInputRegMap[D3DVSDE_TEXCOORD0+dwTCIndex];
            evalEnables |= (1 << defaultInputRegMap[D3DVSDE_TEXCOORD1]);
        }
        else{
            dwT1 = defaultInputRegMap[D3DVSDE_TEXCOORD1];
            evalEnables &= ~(1 << defaultInputRegMap[D3DVSDE_TEXCOORD1]);
        }
        bUseTSSState = TRUE;
        pFinalAttribs = pAttribs;
    }

    getDC()->nvPusher.push (0, (vertexSize << 18) | (NV_DD_CELSIUS << 13) | NVPUSHER_NOINC(NV056_INLINE_ARRAY(0)));
    i=1;

    // do inline vertex data in reverse order
    for (j=0; j<7; j++) {

        mapping = defaultInputRegMap[inline_renderorder[j]];

        if (bUseTSSState) {
            if      (mapping == defaultInputRegMap[D3DVSDE_TEXCOORD0]) mapping = dwT0;
            else if (mapping == defaultInputRegMap[D3DVSDE_TEXCOORD1]) mapping = dwT1;
        }

        nvAssert (mapping >= 0);

        if (evalEnables & (1<<mapping)) {

            nvAssert(pFinalAttribs);
            dwType = info->maps[mapping].Originaltype;

            //hack for weights when someone asks for a weight size greater than we can handle
            if (mapping == defaultInputRegMap[D3DVSDE_BLENDWEIGHT] && dwType > NV_PATCH_VERTEX_FORMAT_FLOAT_1) dwType = NV_PATCH_VERTEX_FORMAT_FLOAT_1;

            switch (dwType) {
                case NV_PATCH_VERTEX_FORMAT_FLOAT_1:
                    DPF_LEVEL(NVDBG_LEVEL_HOS_VERTEX_INFO ,"HOS:\t%d\t%f",mapping,pFinalAttribs[4*mapping+0]);
                    getDC()->nvPusher.push (i, VIEW_AS_DWORD(pFinalAttribs[4*mapping+0]));
                    i++; break;
                case NV_PATCH_VERTEX_FORMAT_FLOAT_2:
                    DPF_LEVEL(NVDBG_LEVEL_HOS_VERTEX_INFO ,"HOS:\t%d\t%f\t%f",mapping,pFinalAttribs  [4*mapping+0],pFinalAttribs[4*mapping+1]);
                    getDC()->nvPusher.push (i,   VIEW_AS_DWORD(pFinalAttribs[4*mapping+0]));
                    getDC()->nvPusher.push (i+1, VIEW_AS_DWORD(pFinalAttribs[4*mapping+1]));
                    i+=2; break;
                case NV_PATCH_VERTEX_FORMAT_FLOAT_3:
                    DPF_LEVEL(NVDBG_LEVEL_HOS_VERTEX_INFO ,"HOS:\t%d\t%f\t%f\t%f",mapping,pFinalAttribs[4*mapping+0],pFinalAttribs[4*mapping+1],pFinalAttribs[4*mapping+2]);
                    if(info->flags & NV_PATCH_FLAG_TYPE_TRIANGULAR && mapping == defaultInputRegMap[D3DVSDE_NORMAL]){
                        getDC()->nvPusher.push (i,   (0x80000000^VIEW_AS_DWORD(pFinalAttribs[4*mapping+0])));
                        getDC()->nvPusher.push (i+1, (0x80000000^VIEW_AS_DWORD(pFinalAttribs[4*mapping+1])));
                        getDC()->nvPusher.push (i+2, (0x80000000^VIEW_AS_DWORD(pFinalAttribs[4*mapping+2])));
                    }else{
                        getDC()->nvPusher.push (i,   VIEW_AS_DWORD(pFinalAttribs[4*mapping+0]));
                        getDC()->nvPusher.push (i+1, VIEW_AS_DWORD(pFinalAttribs[4*mapping+1]));
                        getDC()->nvPusher.push (i+2, VIEW_AS_DWORD(pFinalAttribs[4*mapping+2]));
                    }
                    i+=3; break;
                case NV_PATCH_VERTEX_FORMAT_FLOAT_4:
                    DPF_LEVEL(NVDBG_LEVEL_HOS_VERTEX_INFO ,"HOS:\t%d\t%f\t%f\t%f\t%f",mapping,pFinalAttribs[4*mapping+0],pFinalAttribs[4*mapping+1],
                                                                             pFinalAttribs[4*mapping+2],pFinalAttribs[4*mapping+3]);
                    getDC()->nvPusher.push (i,   VIEW_AS_DWORD(pFinalAttribs[4*mapping+0]));
                    getDC()->nvPusher.push (i+1, VIEW_AS_DWORD(pFinalAttribs[4*mapping+1]));
                    getDC()->nvPusher.push (i+2, VIEW_AS_DWORD(pFinalAttribs[4*mapping+2]));
                    getDC()->nvPusher.push (i+3, VIEW_AS_DWORD(pFinalAttribs[4*mapping+3]));
                    i+=4; break;
                case NV_PATCH_VERTEX_FORMAT_UBYTE:
                    //packed byte will be expanded by tess to 4 vec float
                    //pack it back down so the backend FVF definition isn't different
                    packedByte  =  max(0,min((int)(pFinalAttribs[4*mapping + 0]*256.0),256));
                    packedByte |= (max(0,min((int)(pFinalAttribs[4*mapping + 1]*256.0),256))<<8);
                    packedByte |= (max(0,min((int)(pFinalAttribs[4*mapping + 2]*256.0),256))<<8);
                    packedByte |= (max(0,min((int)(pFinalAttribs[4*mapping + 3]*256.0),256))<<8);
                    DPF_LEVEL(NVDBG_LEVEL_HOS_VERTEX_INFO ,"HOS:\t%d\t%ld",mapping,packedByte);
                    getDC()->nvPusher.push (i, packedByte);
                    i++; break;
                default:
                    DPF_LEVEL(NVDBG_LEVEL_HOS_VERTEX_INFO ,"HOS:\tDefault: vertex shouldn't be here!!");
            }
        }
    }
    getDC()->nvPusher.adjust (i);
}

static void nvCelsiusStreamInit(void  *context)
{
    //getDC()->nvPusher.flush(TRUE,CPushBuffer::FLUSH_HEAVY_POLLING);
    //NV_PATCH_INFO *info = (NV_PATCH_INFO*)context;
    return;
}

static void nvCelsiusStreamDestroy(void *context)
{
    //getDC()->nvPusher.flush(TRUE,CPushBuffer::FLUSH_HEAVY_POLLING);
    //NV_PATCH_INFO *info = (NV_PATCH_INFO*)context;
    return;
}

static void nvCelsiusSendFrontFace(void *context, int reversed){
    PNVD3DCONTEXT pContext;
    NV_PATCH_INFO *info = (NV_PATCH_INFO*)context;
    pContext = (PNVD3DCONTEXT)info->context;


    //DCR UGLY HACK -- OGL and D3D have different ordering on vertices so I 'remap' mine on the front end
    //but it forces a reversal in windings for the triangular tesellation case... FIND a better solution
    if(info->flags & NV_PATCH_FLAG_TYPE_TRIANGULAR) reversed=1-reversed;
    switch(pContext->dwRenderState[D3DRENDERSTATE_CULLMODE]){
    case D3DCULL_NONE:
            break;
    case D3DCULL_CW:
            reversed=1-reversed;
    case D3DCULL_CCW:
        getDC()->nvPusher.push(0, (0x1 << 18) | (NV_DD_CELSIUS << 13) | NV056_SET_FRONT_FACE);
        if(reversed){
            DPF_LEVEL(NVDBG_LEVEL_HOS_VERTEX_INFO ,"HOS: Cull CW");
            getDC()->nvPusher.push(1, NV056_SET_FRONT_FACE_V_CW);
        } else {
            DPF_LEVEL(NVDBG_LEVEL_HOS_VERTEX_INFO ,"HOS: Cull CCW");
            getDC()->nvPusher.push(1, NV056_SET_FRONT_FACE_V_CCW);
        }
        getDC()->nvPusher.adjust(2);
        break;
    default:
        nvAssert(0);    //should never be here
    }
}

static void nvCelsiusBeginPatch(void *info){
    return;
}
static void nvCelsiusEndPatch(void *info){
    return;
}

NV_PATCH_BACKEND nvCelsiusImm_Backend = {
    nvCelsiusStreamInit,
    nvCelsiusStreamDestroy,
    nvCelsiusBeginPrimImm,
    nvCelsiusEndPrimImm,
    nvCelsiusSendPrimImm,
    nvCelsiusSendFrontFace,
    nvCelsiusBeginPatch,
    nvCelsiusEndPatch
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common_disp\src\nvPatchConsts.cpp ===
//**************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
//
//  Module: nvPatchConsts.cpp
//        file used to indirectly load patch matrix constants
//
//  History:
//        Daniel Rohrer    (drohrer)      23Jun00      created
//
// **************************************************************************
#include "nvprecomp.h"

#pragma warning(disable : 4305)

#include "..\..\..\common\src\nvPatchConsts.c"

#pragma warning(default : 4305)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common_disp\src\nvPatchUtilInit.cpp ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein./
//
// ********************************* Direct 3D ******************************
//
//  Module: nvPatchUtilInit.cpp
//      basically just a pointer to a shared file
//
// **************************************************************************
//
//  History:
//      Daniel Rohrer          14Aug2000         DX8 development
//
// **************************************************************************
#include "nvprecomp.h"
#include "..\..\..\common\src\nvPatchUtilInit.c"
//The include file goes to the shared code
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\common_disp\src\nvPatchUtils.cpp ===
//**************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION7
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
//
//  Module: nvPatchUtil.cpp
//        file used to indirectly load patch software emulation
//
//  History:
//        Daniel Rohrer    (drohrer)      23Jun00      created
//
// ***************************************************************************

#include "nvprecomp.h"

#ifdef HOSURF_ENABLE
#include "..\..\..\common\src\nvPatchUtil.c"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\kelvin\inc\nvKelvinCaps.h ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// ********************************* Direct 3D ******************************
//
// Module: nvKelvinCaps.h
//      Define the capabilities of the kelvin D3D driver.
//
// **************************************************************************
//
// History:
//      Craig Duttweiler    bertrem     26Apr2000     created
//
// **************************************************************************

#ifndef _NVKELVINCAPS_H_
#define _NVKELVINCAPS_H_

#if (NVARCH >= 0x020)

// --------------------------------------------------------------------------
//  Direct 3D HAL Capabilities
// --------------------------------------------------------------------------

// Define which fields of the D3DDEVICECAPS structure are valid.
#define KELVIN_DEVDESC_FLAGS            D3DDD_COLORMODEL                    |   \
                                        D3DDD_DEVCAPS                       |   \
                                        D3DDD_LINECAPS                      |   \
                                        D3DDD_TRICAPS                       |   \
                                        D3DDD_DEVICERENDERBITDEPTH          |   \
                                        D3DDD_DEVICEZBUFFERBITDEPTH

// Define the color model for the D3D driver.
#define KELVIN_COLORMODEL               D3DCOLOR_RGB

// Define the device capabilities.
#define KELVIN_DEVCAPS_FLAGS            D3DDEVCAPS_FLOATTLVERTEX            |   \
                                        D3DDEVCAPS_EXECUTESYSTEMMEMORY      |   \
                                        D3DDEVCAPS_EXECUTEVIDEOMEMORY       |   \
                                        D3DDEVCAPS_TLVERTEXSYSTEMMEMORY     |   \
                                        D3DDEVCAPS_TLVERTEXVIDEOMEMORY      |   \
                                        D3DDEVCAPS_TEXTUREVIDEOMEMORY       |   \
                                        D3DDEVCAPS_DRAWPRIMTLVERTEX         |   \
                                        D3DDEVCAPS_CANRENDERAFTERFLIP       |   \
                                        D3DDEVCAPS_TEXTURENONLOCALVIDMEM    |   \
                                        D3DDEVCAPS_DRAWPRIMITIVES2          |   \
                                        D3DDEVCAPS_DRAWPRIMITIVES2EX        |   \
                                        D3DDEVCAPS_HWTRANSFORMANDLIGHT      |   \
                                        D3DDEVCAPS_CANBLTSYSTONONLOCAL      |   \
                                        D3DDEVCAPS_PUREDEVICE               |   \
                                        D3DDEVCAPS_QUINTICRTPATCHES         |   \
                                        D3DDEVCAPS_RTPATCHES                |   \
                                        D3DDEVCAPS_HWVERTEXBUFFER           |   \
                                        D3DDEVCAPS_HWINDEXBUFFER            |   \
                                        D3DDEVCAPS_HWRASTERIZATION

// Define the transformation capabilities.
#define KELVIN_TRANSFORMCAPS_FLAGS      D3DTRANSFORMCAPS_CLIP

// Define 3D clipping capabilities.
#define KELVIN_3DCLIPPINGCAPS           TRUE

// Define the lighting capabilities.
#define KELVIN_LIGHTINGCAPS_FLAGS       D3DLIGHTINGMODEL_RGB                |   \
                                        D3DLIGHTCAPS_POINT                  |   \
                                        D3DLIGHTCAPS_SPOT                   |   \
                                        D3DLIGHTCAPS_DIRECTIONAL
#define KELVIN_MAX_LIGHTS               8

// Define NULL primary capabilities.
#define KELVIN_PRIMCAPS_NULL            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

// Define the line capabilities.
//
// Miscellaneous capabilities (dwMiscCaps)
#define KELVIN_LINECAPS_MISC            D3DPMISCCAPS_MASKZ                  |   \
                                        D3DPMISCCAPS_CULLNONE               |   \
                                        D3DPMISCCAPS_CULLCW                 |   \
                                        D3DPMISCCAPS_CULLCCW                |   \
                                        D3DPMISCCAPS_BLENDOP                |   \
                                        D3DPMISCCAPS_COLORWRITEENABLE       |   \
                                        D3DPMISCCAPS_TSSARGTEMP

// Raster capabilities (dwRasterCaps)
#define KELVIN_LINECAPS_RASTER          D3DPRASTERCAPS_DITHER                   |   \
                                        D3DPRASTERCAPS_SUBPIXEL                 |   \
                                        D3DPRASTERCAPS_FOGVERTEX                |   \
                                        D3DPRASTERCAPS_FOGTABLE                 |   \
                                        D3DPRASTERCAPS_MIPMAPLODBIAS            |   \
                                        D3DPRASTERCAPS_ZBIAS                    |   \
                                        D3DPRASTERCAPS_FOGRANGE                 |   \
                                        D3DPRASTERCAPS_WBUFFER                  |   \
                                        D3DPRASTERCAPS_WFOG                     |   \
                                        D3DPRASTERCAPS_ANTIALIASSORTINDEPENDENT |   \
                                        D3DPRASTERCAPS_STRETCHBLTMULTISAMPLE    |   \
                                        D3DPRASTERCAPS_ANISOTROPY               |   \
                                        D3DPRASTERCAPS_ZFOG

// Z Compare capabilities (dwZCmpCaps)
#define KELVIN_LINECAPS_ZCMP            D3DPCMPCAPS_NEVER                   |   \
                                        D3DPCMPCAPS_LESS                    |   \
                                        D3DPCMPCAPS_EQUAL                   |   \
                                        D3DPCMPCAPS_LESSEQUAL               |   \
                                        D3DPCMPCAPS_GREATER                 |   \
                                        D3DPCMPCAPS_NOTEQUAL                |   \
                                        D3DPCMPCAPS_GREATEREQUAL            |   \
                                        D3DPCMPCAPS_ALWAYS

// Source blend capabilities (dwSrcBlendCaps)
#define KELVIN_LINECAPS_SRCBLEND        D3DPBLENDCAPS_ZERO                  |   \
                                        D3DPBLENDCAPS_ONE                   |   \
                                        D3DPBLENDCAPS_SRCCOLOR              |   \
                                        D3DPBLENDCAPS_INVSRCCOLOR           |   \
                                        D3DPBLENDCAPS_SRCALPHA              |   \
                                        D3DPBLENDCAPS_INVSRCALPHA           |   \
                                        D3DPBLENDCAPS_DESTALPHA             |   \
                                        D3DPBLENDCAPS_INVDESTALPHA          |   \
                                        D3DPBLENDCAPS_DESTCOLOR             |   \
                                        D3DPBLENDCAPS_INVDESTCOLOR          |   \
                                        D3DPBLENDCAPS_SRCALPHASAT           |   \
                                        D3DPBLENDCAPS_BOTHSRCALPHA          |   \
                                        D3DPBLENDCAPS_BOTHINVSRCALPHA

// Destination blend capabilities (dwDestBlendCaps)
#define KELVIN_LINECAPS_DESTBLEND       D3DPBLENDCAPS_ZERO                  |   \
                                        D3DPBLENDCAPS_ONE                   |   \
                                        D3DPBLENDCAPS_SRCCOLOR              |   \
                                        D3DPBLENDCAPS_INVSRCCOLOR           |   \
                                        D3DPBLENDCAPS_SRCALPHA              |   \
                                        D3DPBLENDCAPS_INVSRCALPHA           |   \
                                        D3DPBLENDCAPS_DESTALPHA             |   \
                                        D3DPBLENDCAPS_INVDESTALPHA          |   \
                                        D3DPBLENDCAPS_DESTCOLOR             |   \
                                        D3DPBLENDCAPS_INVDESTCOLOR          |   \
                                        D3DPBLENDCAPS_SRCALPHASAT           |   \
                                        D3DPBLENDCAPS_BOTHSRCALPHA          |   \
                                        D3DPBLENDCAPS_BOTHINVSRCALPHA

// Alpha compare capabilities (dwAlphaCmpCaps)
#define KELVIN_LINECAPS_ALPHACMP        D3DPCMPCAPS_NEVER                   |   \
                                        D3DPCMPCAPS_LESS                    |   \
                                        D3DPCMPCAPS_EQUAL                   |   \
                                        D3DPCMPCAPS_LESSEQUAL               |   \
                                        D3DPCMPCAPS_GREATER                 |   \
                                        D3DPCMPCAPS_NOTEQUAL                |   \
                                        D3DPCMPCAPS_GREATEREQUAL            |   \
                                        D3DPCMPCAPS_ALWAYS

// Shading capabilities (dwShadeCaps)
#define KELVIN_LINECAPS_SHADE           D3DPSHADECAPS_COLORFLATMONO         |   \
                                        D3DPSHADECAPS_COLORFLATRGB          |   \
                                        D3DPSHADECAPS_COLORGOURAUDMONO      |   \
                                        D3DPSHADECAPS_COLORGOURAUDRGB       |   \
                                        D3DPSHADECAPS_SPECULARFLATRGB       |   \
                                        D3DPSHADECAPS_SPECULARGOURAUDRGB    |   \
                                        D3DPSHADECAPS_ALPHAFLATBLEND        |   \
                                        D3DPSHADECAPS_ALPHAGOURAUDBLEND     |   \
                                        D3DPSHADECAPS_FOGFLAT               |   \
                                        D3DPSHADECAPS_FOGGOURAUD

// Texture capabilities (dwTextureCaps)
#define KELVIN_LINECAPS_TEXTURE         D3DPTEXTURECAPS_PERSPECTIVE         |   \
                                        D3DPTEXTURECAPS_POW2                |   \
                                        D3DPTEXTURECAPS_ALPHA               |   \
                                        D3DPTEXTURECAPS_TRANSPARENCY        |   \
                                        D3DPTEXTURECAPS_CUBEMAP             |   \
                                        D3DPTEXTURECAPS_CUBEMAP_POW2        |   \
                                        D3DPTEXTURECAPS_MIPMAP              |   \
                                        D3DPTEXTURECAPS_MIPCUBEMAP          |   \
                                        D3DPTEXTURECAPS_PROJECTED           |   \
                                        D3DPTEXTURECAPS_ALPHAPALETTE        |   \
                                        D3DPTEXTURECAPS_VOLUMEMAP           |   \
                                        D3DPTEXTURECAPS_VOLUMEMAP_POW2      |   \
                                        D3DPTEXTURECAPS_MIPVOLUMEMAP

// Texture filtering capabilities (dwTextureFilterCaps)
#define KELVIN_LINECAPS_TEXTUREFILTER   D3DPTFILTERCAPS_NEAREST             |   \
                                        D3DPTFILTERCAPS_LINEAR              |   \
                                        D3DPTFILTERCAPS_MIPNEAREST          |   \
                                        D3DPTFILTERCAPS_MIPLINEAR           |   \
                                        D3DPTFILTERCAPS_LINEARMIPNEAREST    |   \
                                        D3DPTFILTERCAPS_LINEARMIPLINEAR     |   \
                                        D3DPTFILTERCAPS_MINFPOINT           |   \
                                        D3DPTFILTERCAPS_MINFLINEAR          |   \
                                        D3DPTFILTERCAPS_MIPFPOINT           |   \
                                        D3DPTFILTERCAPS_MIPFLINEAR          |   \
                                        D3DPTFILTERCAPS_MAGFPOINT           |   \
                                        D3DPTFILTERCAPS_MAGFLINEAR

// Texture blending capabilities (dwTextureBlendCaps)
#define KELVIN_LINECAPS_TEXTUREBLEND    D3DPTBLENDCAPS_DECAL                |   \
                                        D3DPTBLENDCAPS_MODULATE             |   \
                                        D3DPTBLENDCAPS_DECALALPHA           |   \
                                        D3DPTBLENDCAPS_MODULATEALPHA        |   \
                                        D3DPTBLENDCAPS_DECALMASK            |   \
                                        D3DPTBLENDCAPS_MODULATEMASK         |   \
                                        D3DPTBLENDCAPS_COPY                 |   \
                                        D3DPTBLENDCAPS_ADD

// Texture addressing capabilities (dwTextureAddressCaps)
#define KELVIN_LINECAPS_TEXTUREADDRESS  D3DPTADDRESSCAPS_WRAP               |   \
                                        D3DPTADDRESSCAPS_MIRROR             |   \
                                        D3DPTADDRESSCAPS_CLAMP              |   \
                                        D3DPTADDRESSCAPS_BORDER             |   \
                                        D3DPTADDRESSCAPS_INDEPENDENTUV

// Maximum stipple dimensions.
#define KELVIN_LINECAPS_STIPPLEWIDTH    0
#define KELVIN_LINECAPS_STIPPLEHEIGHT   0

// Define the triangle capabilities.
//
// Miscellaneous capabilities (dwMiscCaps)
#define KELVIN_TRICAPS_MISC             D3DPMISCCAPS_MASKZ                  |   \
                                        D3DPMISCCAPS_CULLNONE               |   \
                                        D3DPMISCCAPS_CULLCW                 |   \
                                        D3DPMISCCAPS_CULLCCW                |   \
                                        D3DPMISCCAPS_BLENDOP                |   \
                                        D3DPMISCCAPS_COLORWRITEENABLE       |   \
                                        D3DPMISCCAPS_TSSARGTEMP

// Raster capabilities (dwRasterCaps)
#define KELVIN_TRICAPS_RASTER           D3DPRASTERCAPS_DITHER                   |   \
                                        D3DPRASTERCAPS_SUBPIXEL                 |   \
                                        D3DPRASTERCAPS_FOGVERTEX                |   \
                                        D3DPRASTERCAPS_FOGTABLE                 |   \
                                        D3DPRASTERCAPS_MIPMAPLODBIAS            |   \
                                        D3DPRASTERCAPS_ZBIAS                    |   \
                                        D3DPRASTERCAPS_FOGRANGE                 |   \
                                        D3DPRASTERCAPS_WBUFFER                  |   \
                                        D3DPRASTERCAPS_WFOG                     |   \
                                        D3DPRASTERCAPS_ANTIALIASSORTINDEPENDENT |   \
                                        D3DPRASTERCAPS_STRETCHBLTMULTISAMPLE    |   \
                                        D3DPRASTERCAPS_ANISOTROPY               |   \
                                        D3DPRASTERCAPS_ZFOG

// Z Compare capabilities (dwZCmpCaps)
#define KELVIN_TRICAPS_ZCMP             D3DPCMPCAPS_NEVER                   |   \
                                        D3DPCMPCAPS_LESS                    |   \
                                        D3DPCMPCAPS_EQUAL                   |   \
                                        D3DPCMPCAPS_LESSEQUAL               |   \
                                        D3DPCMPCAPS_GREATER                 |   \
                                        D3DPCMPCAPS_NOTEQUAL                |   \
                                        D3DPCMPCAPS_GREATEREQUAL            |   \
                                        D3DPCMPCAPS_ALWAYS

// Source blend capabilities (dwSrcBlendCaps)
#define KELVIN_TRICAPS_SRCBLEND         D3DPBLENDCAPS_ZERO                  |   \
                                        D3DPBLENDCAPS_ONE                   |   \
                                        D3DPBLENDCAPS_SRCCOLOR              |   \
                                        D3DPBLENDCAPS_INVSRCCOLOR           |   \
                                        D3DPBLENDCAPS_SRCALPHA              |   \
                                        D3DPBLENDCAPS_INVSRCALPHA           |   \
                                        D3DPBLENDCAPS_DESTALPHA             |   \
                                        D3DPBLENDCAPS_INVDESTALPHA          |   \
                                        D3DPBLENDCAPS_DESTCOLOR             |   \
                                        D3DPBLENDCAPS_INVDESTCOLOR          |   \
                                        D3DPBLENDCAPS_SRCALPHASAT           |   \
                                        D3DPBLENDCAPS_BOTHSRCALPHA          |   \
                                        D3DPBLENDCAPS_BOTHINVSRCALPHA

// Destination blend capabilities (dwDestBlendCaps)
#define KELVIN_TRICAPS_DESTBLEND        D3DPBLENDCAPS_ZERO                  |   \
                                        D3DPBLENDCAPS_ONE                   |   \
                                        D3DPBLENDCAPS_SRCCOLOR              |   \
                                        D3DPBLENDCAPS_INVSRCCOLOR           |   \
                                        D3DPBLENDCAPS_SRCALPHA              |   \
                                        D3DPBLENDCAPS_INVSRCALPHA           |   \
                                        D3DPBLENDCAPS_DESTALPHA             |   \
                                        D3DPBLENDCAPS_INVDESTALPHA          |   \
                                        D3DPBLENDCAPS_DESTCOLOR             |   \
                                        D3DPBLENDCAPS_INVDESTCOLOR          |   \
                                        D3DPBLENDCAPS_SRCALPHASAT           |   \
                                        D3DPBLENDCAPS_BOTHSRCALPHA          |   \
                                        D3DPBLENDCAPS_BOTHINVSRCALPHA

// Alpha compare capabilities (dwAlphaCmpCaps)
#define KELVIN_TRICAPS_ALPHACMP         D3DPCMPCAPS_NEVER                   |   \
                                        D3DPCMPCAPS_LESS                    |   \
                                        D3DPCMPCAPS_EQUAL                   |   \
                                        D3DPCMPCAPS_LESSEQUAL               |   \
                                        D3DPCMPCAPS_GREATER                 |   \
                                        D3DPCMPCAPS_NOTEQUAL                |   \
                                        D3DPCMPCAPS_GREATEREQUAL            |   \
                                        D3DPCMPCAPS_ALWAYS

// Shading capabilities (dwShadeCaps)
#define KELVIN_TRICAPS_SHADE            D3DPSHADECAPS_COLORFLATMONO         |   \
                                        D3DPSHADECAPS_COLORFLATRGB          |   \
                                        D3DPSHADECAPS_COLORGOURAUDMONO      |   \
                                        D3DPSHADECAPS_COLORGOURAUDRGB       |   \
                                        D3DPSHADECAPS_SPECULARFLATRGB       |   \
                                        D3DPSHADECAPS_SPECULARGOURAUDRGB    |   \
                                        D3DPSHADECAPS_ALPHAFLATBLEND        |   \
                                        D3DPSHADECAPS_ALPHAGOURAUDBLEND     |   \
                                        D3DPSHADECAPS_FOGFLAT               |   \
                                        D3DPSHADECAPS_FOGGOURAUD

// Texture capabilities (dwTextureCaps)
#define KELVIN_TRICAPS_TEXTURE          D3DPTEXTURECAPS_PERSPECTIVE         |   \
                                        D3DPTEXTURECAPS_POW2                |   \
                                        D3DPTEXTURECAPS_ALPHA               |   \
                                        D3DPTEXTURECAPS_TRANSPARENCY        |   \
                                        D3DPTEXTURECAPS_CUBEMAP             |   \
                                        D3DPTEXTURECAPS_CUBEMAP_POW2        |   \
                                        D3DPTEXTURECAPS_MIPMAP              |   \
                                        D3DPTEXTURECAPS_MIPCUBEMAP          |   \
                                        D3DPTEXTURECAPS_PROJECTED           |   \
                                        D3DPTEXTURECAPS_ALPHAPALETTE        |   \
                                        D3DPTEXTURECAPS_VOLUMEMAP           |   \
                                        D3DPTEXTURECAPS_VOLUMEMAP_POW2      |   \
                                        D3DPTEXTURECAPS_MIPVOLUMEMAP


// Texture filtering capabilities (dwTextureFilterCaps)
#define KELVIN_TRICAPS_TEXTUREFILTER    D3DPTFILTERCAPS_NEAREST             |   \
                                        D3DPTFILTERCAPS_LINEAR              |   \
                                        D3DPTFILTERCAPS_MIPNEAREST          |   \
                                        D3DPTFILTERCAPS_MIPLINEAR           |   \
                                        D3DPTFILTERCAPS_LINEARMIPNEAREST    |   \
                                        D3DPTFILTERCAPS_LINEARMIPLINEAR     |   \
                                        D3DPTFILTERCAPS_MINFPOINT           |   \
                                        D3DPTFILTERCAPS_MINFLINEAR          |   \
                                        D3DPTFILTERCAPS_MINFANISOTROPIC     |   \
                                        D3DPTFILTERCAPS_MIPFPOINT           |   \
                                        D3DPTFILTERCAPS_MIPFLINEAR          |   \
                                        D3DPTFILTERCAPS_MAGFPOINT           |   \
                                        D3DPTFILTERCAPS_MAGFLINEAR          |   \
                                        D3DPTFILTERCAPS_MAGFANISOTROPIC

// Volume texture filtering capabilities
#define KELVIN_TRICAPS_VOLUMETEXFILTER  D3DPTFILTERCAPS_NEAREST             |   \
                                        D3DPTFILTERCAPS_LINEAR              |   \
                                        D3DPTFILTERCAPS_MIPNEAREST          |   \
                                        D3DPTFILTERCAPS_MIPLINEAR           |   \
                                        D3DPTFILTERCAPS_LINEARMIPNEAREST    |   \
                                        D3DPTFILTERCAPS_LINEARMIPLINEAR     |   \
                                        D3DPTFILTERCAPS_MINFPOINT           |   \
                                        D3DPTFILTERCAPS_MINFLINEAR          |   \
                                        D3DPTFILTERCAPS_MINFANISOTROPIC     |   \
                                        D3DPTFILTERCAPS_MIPFPOINT           |   \
                                        D3DPTFILTERCAPS_MIPFLINEAR          |   \
                                        D3DPTFILTERCAPS_MAGFPOINT


// Texture blending capabilities (dwTextureBlendCaps)
#define KELVIN_TRICAPS_TEXTUREBLEND     D3DPTBLENDCAPS_DECAL                |   \
                                        D3DPTBLENDCAPS_MODULATE             |   \
                                        D3DPTBLENDCAPS_DECALALPHA           |   \
                                        D3DPTBLENDCAPS_MODULATEALPHA        |   \
                                        D3DPTBLENDCAPS_DECALMASK            |   \
                                        D3DPTBLENDCAPS_MODULATEMASK         |   \
                                        D3DPTBLENDCAPS_COPY                 |   \
                                        D3DPTBLENDCAPS_ADD

// Texture addressing capabilities (dwTextureAddressCaps)
#define KELVIN_TRICAPS_TEXTUREADDRESS   D3DPTADDRESSCAPS_WRAP               |   \
                                        D3DPTADDRESSCAPS_MIRROR             |   \
                                        D3DPTADDRESSCAPS_CLAMP              |   \
                                        D3DPTADDRESSCAPS_BORDER             |   \
                                        D3DPTADDRESSCAPS_INDEPENDENTUV

// Maximum stipple dimensions.
#define KELVIN_TRICAPS_STIPPLEWIDTH     0
#define KELVIN_TRICAPS_STIPPLEHEIGHT    0

// Texture Ops
#define KELVIN_CAPS_TEXTUREOPS   D3DTEXOPCAPS_DISABLE                       |   \
                                 D3DTEXOPCAPS_SELECTARG1                    |   \
                                 D3DTEXOPCAPS_SELECTARG2                    |   \
                                 D3DTEXOPCAPS_MODULATE                      |   \
                                 D3DTEXOPCAPS_MODULATE2X                    |   \
                                 D3DTEXOPCAPS_MODULATE4X                    |   \
                                 D3DTEXOPCAPS_ADD                           |   \
                                 D3DTEXOPCAPS_ADDSIGNED                     |   \
                                 D3DTEXOPCAPS_ADDSIGNED2X                   |   \
                                 D3DTEXOPCAPS_SUBTRACT                      |   \
                                 D3DTEXOPCAPS_ADDSMOOTH                     |   \
                                 D3DTEXOPCAPS_BLENDDIFFUSEALPHA             |   \
                                 D3DTEXOPCAPS_BLENDTEXTUREALPHA             |   \
                                 D3DTEXOPCAPS_BLENDFACTORALPHA              |   \
                                 D3DTEXOPCAPS_BLENDTEXTUREALPHAPM           |   \
                                 D3DTEXOPCAPS_BLENDCURRENTALPHA             |   \
                                 D3DTEXOPCAPS_PREMODULATE                   |   \
                                 D3DTEXOPCAPS_MODULATEALPHA_ADDCOLOR        |   \
                                 D3DTEXOPCAPS_MODULATECOLOR_ADDALPHA        |   \
                                 D3DTEXOPCAPS_MODULATEINVALPHA_ADDCOLOR     |   \
                                 D3DTEXOPCAPS_MODULATEINVCOLOR_ADDALPHA     |   \
                                 D3DTEXOPCAPS_BUMPENVMAP                    |   \
                                 D3DTEXOPCAPS_BUMPENVMAPLUMINANCE           |   \
                                 D3DTEXOPCAPS_DOTPRODUCT3                   |   \
                                 D3DTEXOPCAPS_MULTIPLYADD                   |   \
                                 D3DTEXOPCAPS_LERP

// Stencil Ops
#define KELVIN_CAPS_STENCILOPS   D3DSTENCILCAPS_KEEP                        |   \
                                 D3DSTENCILCAPS_ZERO                        |   \
                                 D3DSTENCILCAPS_REPLACE                     |   \
                                 D3DSTENCILCAPS_INCRSAT                     |   \
                                 D3DSTENCILCAPS_DECRSAT                     |   \
                                 D3DSTENCILCAPS_INVERT                      |   \
                                 D3DSTENCILCAPS_INCR                        |   \
                                 D3DSTENCILCAPS_DECR

// Vertex Processing Caps
#define KELVIN_CAPS_VTXPCAPS   D3DVTXPCAPS_TEXGEN                           |   \
                               D3DVTXPCAPS_MATERIALSOURCE7                  |   \
                               D3DVTXPCAPS_VERTEXFOG                        |   \
                               D3DVTXPCAPS_DIRECTIONALLIGHTS                |   \
                               D3DVTXPCAPS_POSITIONALLIGHTS                 |   \
                               D3DVTXPCAPS_LOCALVIEWER                      |   \
                               D3DVTXPCAPS_NO_VSDT_UBYTE4 // NV20 does not support this, NV25 does

// Define the render bit depth capabilites.
#define KELVIN_RENDERBITDEPTHCAPS      (DDBD_16 | DDBD_32)

// Define the Z buffer bit depth capabilities.
#define KELVIN_ZBUFFERBITDEPTHCAPS     (DDBD_16 | DDBD_24)

#endif  // NVARCH > 0x020
#endif  // _NVKELVINCAPS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\kelvin\inc\nvKelvinAA.h ===
#ifndef _NVKELVINAA_H
#define _NVKELVINAA_H

/*
 * Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.
 *
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nvKelvinAA.h                                                      *
*     prototypes for aa routines                                            *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Scott Cutler                     11Oct2000   created                *
*                                                                           *
\***************************************************************************/

#if (NVARCH >= 0x020)
typedef union _DWORD_float {
    DWORD d;
    float f;
} DF;

typedef unsigned __int64 uint64;
uint64 nvHash64(unsigned char *, unsigned int);

#define KELVIN_AA_NUM_FLIP_CHAIN_SLOTS 16

class CKelvinAAState {
public:
    // Public enums
    typedef enum BufferType { 
        BUFFER_SRT       = 0,          // Super render target
        BUFFER_RT        = 1,          // Normal render target
        BUFFER_SZB       = 2,          // Super Z buffer
        BUFFER_ZB        = 3,          // Normal Z buffer
        BUFFER_SCRATCH   = 4,          // Stratch Z buffer
        BUFFER_MAX       = 5,
        BUFFER_INVALID   = 0xffffffff  // invalid
    };
    
    typedef enum AccessType { 
        ACCESS_READ          = 0, // Read access (write semantics are undefined)
        ACCESS_WRITE         = 1, // Full read/write access
        ACCESS_WRITE_DISCARD = 2, // Write access, except that a) no read access, and b) you must overwrite the entire buffer
        ACCESS_MAX           = 3
    };

    typedef enum AppCompatibilityFlags {
        // Usually, we assume that apps will completely overwrite the contents of the color buffer.
        // This allows the optimization that we don't have to upsample the normal buffer after a
        // flip.  Some apps, particularly ones where there are cursor drawing routines that use
        // read/modify/write blits, break when using this optimization, and as such we can turn it 
        // off.
        APPFLAGS_MAGNIFY_AFTER_FLIP        = 0x00000001,

        // Apps that perform large numbers of upsample/downsample operations often show dithering 
        // artifacts, because of a hardware property where the dither is applied even for colors
        // truncated to 16 bits.  Force dithering off for these apps (we want it on by default
        // because of banding issues).
        APPFLAGS_DISABLE_DITHER            = 0x00000002,

        // Multisampling has the peculiar property where a texture sample can be taken outside 
        // of the border of a triangle.  In most cases this is ok, as triangles that are joined
        // together usually have their textures join in a similar way.  Unfortunately, sometimes
        // apps will store several uncorrelated textures in a single map, and we sometimes sample
        // from these adjacent textures, leading to color artifacts on the edges of some triangles.
        APPFLAGS_FORCE_SUPERSAMPLE         = 0x00000004,

        // Some apps are just fundamentally broken with AA.  Usually this includes apps that perform
        // nasty hacks with the Z buffer.
        APPFLAGS_DISABLE_AA                = 0x00000008,

        // Win2k will often stomp all over our buffer when we're not in a BeginScene/EndScene.
        // For apps where this is a problem, we give the application write access to the normal
        // buffer when it sends us an EndScene.
        APPFLAGS_WRITE_ACCESS_ON_ENDSCENE  = 0x00000010,

        // Normally, we will blit to either the super or normal buffer, depending on
        // which one is valid.  Some apps don't like it when we blit to the superbuffer.
        // In these cases, always downscale the buffer before blitting.
        APPFLAGS_DOWNSAMPLE_ON_BLIT        = 0x00000020,

        // Z compression doesn't always work right when we're upscaling/downscaling
        // the Z buffer.  Force compression off if it's causing problems.
        APPFLAGS_FORCE_UNCOMPRESSED_Z      = 0x00000040
    };
    
    typedef enum NotificationType {
        NOTIFY_FULL_SCREEN_COLOR_CLEAR,
    };

    static const char * BufferTypeNames[];
    static const char * AccessTypeNames[];
    
    typedef enum BufferFlags {
        FLAGS_VALID  = 0x00000001,  // Contains valid data
    };

    // Public members
    CKelvinAAState();

    void SetSampleMask();

    void TestCreation(PNVD3DCONTEXT);
    void Create(PNVD3DCONTEXT);
    void Destroy();
    void Suspend();
    void Resume();
    void Refresh();
    void Flip();
    void Notify(NotificationType);
    void ReCreateZBuffer();
    void TagBadSemantics() { _badSemantics = true; }
    void EndScene();
    bool IsValid(BufferType buffer) { return (_bufferInfo[buffer].flags & FLAGS_VALID); }

    void Save();
    void Restore();
    void SetChanged() { _bAAMethodChanged = true; }

    void UpdateZBuffer();
    void UpdateRenderTarget();

    float GetXOffset() { return _appCompatibility.fXOffset; }
    float GetYOffset() { return _appCompatibility.fYOffset; }

    void TagSeen3D() { _seen3D = 1; }

    CSimpleSurface * GetSRT() { return _bufferInfo[BUFFER_SRT].pSurface; }
    CSimpleSurface * GetSZB() { return _bufferInfo[BUFFER_SZB].pSurface; }

    CSimpleSurface * GetCurrentRT(PNVD3DCONTEXT);
    CSimpleSurface * GetCurrentZB(PNVD3DCONTEXT);

    DWORD GetAAFormat();
    DWORD GetWidthScale() { return BufferBltInfo[MethodInfo[_method].type].dwSuperBufferScaleX; }
    DWORD GetHeightScale() { return BufferBltInfo[MethodInfo[_method].type].dwSuperBufferScaleY; }
    
    int IsEnabled();
    int IsCreated();
    int IsMultisampling();
    int IsSupersampling();

    bool CompatibilityMode(AppCompatibilityFlags flags) { return ((_appCompatibility.dwFlags & flags) ? true : false); }
    bool IsMixedModeAA() { return _MixedModeAA; }
    static bool CheckBufferMemoryConfig(PNVD3DCONTEXT);

    void GrantAccess(BufferType, AccessType, bool = false, bool = false);

    static PNVD3DCONTEXT GetContext(CSimpleSurface *);

private:
    // Private enums
    typedef enum MethodType {
        METHOD_NONE                         = 0,
        METHOD_SUPERSAMPLE_2X_H             = 1,
        METHOD_SUPERSAMPLE_2X_V             = 2,
        METHOD_MULTISAMPLE_2X               = 3,
        METHOD_MULTISAMPLE_2X_QUINCUNX      = 4,
        METHOD_SUPERSAMPLE_4X_BIAS          = 5,
        METHOD_SUPERSAMPLE_4X               = 6,
        METHOD_SUPERSAMPLE_4X_GAUSSIAN      = 7,
        METHOD_MULTISAMPLE_4X               = 8,
        METHOD_MULTISAMPLE_4X_GAUSSIAN      = 9,
        METHOD_MULTISAMPLE_4X_ROTATED_4TAP  = 10,   
        METHOD_MULTISAMPLE_4X_ROTATED_8TAP  = 11,
        METHOD_SUPERSAMPLE_9X_BIAS          = 12,   // Not used yet
        METHOD_SUPERSAMPLE_9X               = 13,   // Not used yet
        METHOD_SUPERSAMPLE_16X_BIAS         = 14,   // Not used yet
        METHOD_SUPERSAMPLE_16X              = 15,   // Not used yet
        METHOD_MAX                          = 16
    };

    typedef enum SimpleMethodType {
        SIMPLEMETHOD_1X1 = 0,
        SIMPLEMETHOD_1X2 = 1,
        SIMPLEMETHOD_2X1 = 2,
        SIMPLEMETHOD_2X2 = 3,
        SIMPLEMETHOD_3X3 = 4,
        SIMPLEMETHOD_4X4 = 5,
        SIMPLEMETHOD_MAX = 6,
    };

    // Private structs
    struct BufferInfo {
        DWORD flags;
        BufferType other;
        CSimpleSurface *pSurface;
    } _bufferInfo[BUFFER_MAX];

    struct MethodInfoStruct {
        bool  bMultisample;
        float fBias;
        float fLinePointSize;
        SimpleMethodType type;
        DWORD AASurfaceType;
        DWORD dwKernel;
        DWORD dwBoxFilteredAlternative;
        DWORD dwSuperSampledAlternative;
    };

    struct BufferBltInfoStruct {
        DWORD   dwSuperBufferScaleX;
        DWORD   dwSuperBufferScaleY;

        DWORD   dwScratchBufferScaleX;
        DWORD   dwScratchBufferScaleY;

        double  fDownscaleOffsetX1;
        double  fDownscaleOffsetY1;
        double  fDownscaleOffsetX2;
        double  fDownscaleOffsetY2;

        double  fUpscaleOffsetX;
        double  fUpscaleOffsetY;
    };


    // break filter into strips
    struct  stripinfo {
        DF x0, y0;
        DF _x0;
        DWORD remainder;
        DWORD num_strips;
        DWORD stripsize;
        DF srcyinc;
        DF srcyrem;
        DF dstyinc;
        DF dstyrem;
        DF srcWidth;
        DF srcWidth_x0;
        DF dstWidth;
        DWORD swath;
    } _strip;

    // Private methods
    void ScaledBlt(BufferType, BufferType, bool, bool);
    void ScaledBlt(CSimpleSurface *, DWORD, DWORD, DWORD, DWORD, CSimpleSurface *, double, double, DWORD, DWORD);

    void ImageModeTexBlt(CSimpleSurface *, CSimpleSurface *, DWORD, bool, bool, bool);

    bool InGrantAccess() { return _bInGrantAccess; }
    void EnterGrantAccess() { _bInGrantAccess = true; }
    void ExitGrantAccess() { _bInGrantAccess = false; }

    void InitAppCompatibility();

    // Private members
    PNVD3DCONTEXT _pContext;
    bool _enabled;
    bool _seen3D;
    bool _MixedModeAA;
    bool _invalidRT;
    bool _badSemantics;
    bool _didUpsample;
    bool _lastDownsampleUsedConvolution;
    bool _bSubdivideAA;
    bool _bSubdivideAASave;
    bool _bAAMethodChanged;
    bool _bInitializedState;
    bool _bInGrantAccess;
    DWORD _sampleMask;
    DWORD _method;
    DWORD _methodSave;
    DWORD _numUpsamplings;
    DWORD _UpsampleFlip;
    DWORD _numZLocks;
    KELVIN_MICRO_PROGRAM _program;

    struct AppCompatibilityStruct {
        uint64 qwHashVal;
        DWORD dwFlags;
        float fXOffset, fYOffset;
    } _appCompatibility;

    CSimpleSurface *_flipChain[KELVIN_AA_NUM_FLIP_CHAIN_SLOTS]; // potentially they could have a huge flip chain; in reality it'll be 2 or 3


    static const MethodInfoStruct MethodInfo[METHOD_MAX];
    static const BufferBltInfoStruct BufferBltInfo[SIMPLEMETHOD_MAX];
    static const MethodType RegQualityToAATypeMapping[10];

    void SetMethod(MethodType);
};

#endif // NVARCH >= 0x020

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\kelvin\inc\nvKelvinProgram.h ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// ********************************* Direct 3D ******************************
//
//  Module: nvKelvinProgram.h
//      Kelvin program header file
//
// **************************************************************************
//
//  History:
//      Craig Duttweiler        23May2000         NV20 development
//
// **************************************************************************

#ifndef _NVKELVINPROGRAM_H
#define _NVKELVINPROGRAM_H

#if (NVARCH >= 0x020)

#include "vtxpgmconsts.h"
#include "vtxpgmcomp.h"


// #define MAX_PROGRAM_COUNT             128
// #define GL_EXECUTE_PROGRAM           0x88888888
// #define GL_DRIVER_EXECUTE_PROGRAM    0x88888889

#define SET_ILU(pucode,x) (pucode->ilu = (x)&7)     /* cycle 0.. */
#define SET_MAC(pucode,x) (pucode->mac = (x)&15)    /* cycle 01. */
#define SET_CA(pucode,x)  (pucode->ca  = (x)&255)   /* cycle 0.2 */
#define SET_VA(pucode,x)  (pucode->va  = (x)&15)    /* cycle 0.. */

#define SET_AMX(pucode,x) (pucode->amx = (x)&3)     /* cycle 0.. */
#define SET_ARR(pucode,x) (pucode->arr = (x)&15)    /* cycle 0.. */
#define SET_ANE(pucode,x) (pucode->ane = (x)&1)     /* cycle 0.. */
#define SET_AXS(pucode,x) (pucode->axs = (x)&3)     /* cycle 0.. */
#define SET_AYS(pucode,x) (pucode->ays = (x)&3)     /* cycle 0.. */
#define SET_AZS(pucode,x) (pucode->azs = (x)&3)     /* cycle 0.. */
#define SET_AWS(pucode,x) (pucode->aws = (x)&3)     /* cycle 0.. */

#define SET_BMX(pucode,x) (pucode->bmx = (x)&3)     /* cycle 0.. */
#define SET_BRR(pucode,x) (pucode->brr = (x)&15)    /* cycle 0.. */
#define SET_BNE(pucode,x) (pucode->bne = (x)&1)     /* cycle 0.. */
#define SET_BXS(pucode,x) (pucode->bxs = (x)&3)     /* cycle 0.. */
#define SET_BYS(pucode,x) (pucode->bys = (x)&3)     /* cycle 0.. */
#define SET_BZS(pucode,x) (pucode->bzs = (x)&3)     /* cycle 0.. */
#define SET_BWS(pucode,x) (pucode->bws = (x)&3)     /* cycle 0.. */

#define SET_CMX(pucode,x) (pucode->cmx = (x)&3)     /* cycle 0.. */
#define SET_CRR(pucode,x) (pucode->crr = (x)&15)    /* cycle 0.. */
#define SET_CNE(pucode,x) (pucode->cne = (x)&1)     /* cycle 0.. */
#define SET_CXS(pucode,x) (pucode->cxs = (x)&3)     /* cycle 0.. */
#define SET_CYS(pucode,x) (pucode->cys = (x)&3)     /* cycle 0.. */
#define SET_CZS(pucode,x) (pucode->czs = (x)&3)     /* cycle 0.. */
#define SET_CWS(pucode,x) (pucode->cws = (x)&3)     /* cycle 0.. */

#define SET_RWM(pucode,x) (pucode->rwm = (x)&15)    /* cycle ..2 */
#define SET_RW(pucode,x)  (pucode->rw  = (x)&15)    /* cycle ..2 */
#define SET_SWM(pucode,x) (pucode->swm = (x)&15)    /* cycle ..2 */
#define SET_OWM(pucode,x) (pucode->owm = (x)&15)    /* cycle ..2 */
#define SET_OC(pucode,x)  (pucode->oc  = (x)&511)   /* cycle ..2 */
#define SET_OM(pucode,x)  (pucode->om  = (x)&1)     /* cycle ..2 */
#define SET_CIN(pucode,x) (pucode->cin = (x)&1)     /* cycle 0.. */
#define SET_EOS(pucode,x) (pucode->eos = (x)&1)     /* cycle 0.. */

#define PGM_UWORDW(pucode) ((pucode->eos << 0) |\
                            (pucode->cin << 1) |\
                            (pucode->om  << 2) |\
                            (pucode->oc  << 3) |\
                            (pucode->owm <<12) |\
                            (pucode->swm <<16) |\
                            (pucode->rw  <<20) |\
                            (pucode->rwm <<24) |\
                            (pucode->cmx <<28) |\
                            (pucode->crr <<30))

#define PGM_UWORDZ(pucode) ((pucode->crr >> 2) |\
                            (pucode->cws << 2) |\
                            (pucode->czs << 4) |\
                            (pucode->cys << 6) |\
                            (pucode->cxs << 8) |\
                            (pucode->cne <<10) |\
                            (pucode->bmx <<11) |\
                            (pucode->brr <<13) |\
                            (pucode->bws <<17) |\
                            (pucode->bzs <<19) |\
                            (pucode->bys <<21) |\
                            (pucode->bxs <<23) |\
                            (pucode->bne <<25) |\
                            (pucode->amx <<26) |\
                            (pucode->arr <<28))

#define PGM_UWORDY(pucode) ((pucode->aws << 0) |\
                            (pucode->azs << 2) |\
                            (pucode->ays << 4) |\
                            (pucode->axs << 6) |\
                            (pucode->ane << 8) |\
                            (pucode->va  << 9) |\
                            (pucode->ca  <<13) |\
                            (pucode->mac <<21) |\
                            (pucode->ilu <<25))

#define PGM_UWORDX(pucode) 0

#define ADD_MASK  (0x0000ff)
#define MUX_MASK  (0x000300)
#define SWZ_MASK  (0x0ff000)
#define SGN_MASK  (0x100000)
#define IDX_MASK  (0x200000)
#define DST_MASK  (0x400000)

#define NV_IGRAPH_XF_V_NOP        0x00
#define NV_IGRAPH_XF_V_MOV        0x01
#define NV_IGRAPH_XF_V_MUL        0x02
#define NV_IGRAPH_XF_V_ADD        0x03
#define NV_IGRAPH_XF_V_MAD        0x04
#define NV_IGRAPH_XF_V_DP3        0x05
#define NV_IGRAPH_XF_V_DPH        0x06
#define NV_IGRAPH_XF_V_DP4        0x07
#define NV_IGRAPH_XF_V_DST        0x08
#define NV_IGRAPH_XF_V_MIN        0x09
#define NV_IGRAPH_XF_V_MAX        0x0a
#define NV_IGRAPH_XF_V_SLT        0x0b
#define NV_IGRAPH_XF_V_SGE        0x0c
#define NV_IGRAPH_XF_V_ARL        0x0d

#define NV_IGRAPH_XF_S_NOP        0x00
#define NV_IGRAPH_XF_S_MOV        0x01
#define NV_IGRAPH_XF_S_RCP        0x02
#define NV_IGRAPH_XF_S_RCC        0x03
#define NV_IGRAPH_XF_S_RSQ        0x04
#define NV_IGRAPH_XF_S_EXP        0x05
#define NV_IGRAPH_XF_S_LOG        0x06
#define NV_IGRAPH_XF_S_LIT        0x07

#define CSW_X                     0x00  // take swizzled source from x
#define CSW_Y                     0x01  // ...from y
#define CSW_Z                     0x02  // ...from z
#define CSW_W                     0x03  // ...from w

#define MX_M                      0     // mux select
#define MX_R                      1     // mux select scratch (a.k.a. temporary) register
#define MX_V                      2     // mux select input (a.k.a. vertex attribute) register
#define MX_C                      3     // mux select context (a.k.a. parameter/constant) register
#define MX_O                      MX_M

#define OM_MAC                    0x00  // output mux selects value produced by MLU/ALU
#define OM_ILU                    0x01  // output mux selects value produced by ILU

typedef struct _t_CheopsUcode {
    unsigned long eos:1;        /* 0:00 last instruction */
    unsigned long cin:1;        /* 0:01 ctx indexed address */
    unsigned long  om:1;        /* 0:02 output mux */
    unsigned long  oc:9;        /* 0:03 output write control */
    unsigned long owm:4;        /* 0:12 output write mask */
    unsigned long swm:4;        /* 0:16 secondary register write mask */
    unsigned long  rw:4;        /* 0:20 register write */
    unsigned long rwm:4;        /* 0:24 primary register write mask */
    unsigned long cmx:2;        /* 0:28 c mux (NA,r1,v,c) */
    unsigned long crr:4;        /* 0:30 c register read */
    unsigned long cws:2;        /* 1:02 c w swizzle */
    unsigned long czs:2;        /* 1:04 c z swizzle */
    unsigned long cys:2;        /* 1:06 c y swizzle */
    unsigned long cxs:2;        /* 1:08 c x swizzle */
    unsigned long cne:1;        /* 1:10 c negate */
    unsigned long bmx:2;        /* 1:11 b mux (NA,r1,v,c) */
    unsigned long brr:4;        /* 1:13 b register read */
    unsigned long bws:2;        /* 1:17 b w swizzle */
    unsigned long bzs:2;        /* 1:19 b z swizzle */
    unsigned long bys:2;        /* 1:21 b y swizzle */
    unsigned long bxs:2;        /* 1:23 b x swizzle */
    unsigned long bne:1;        /* 1:25 b negate */
    unsigned long amx:2;        /* 1:26 a mux (NA,r0,v,c) */
    unsigned long arr:4;        /* 1:28 a register read */
    unsigned long aws:2;        /* 2:00 a w swizzle */
    unsigned long azs:2;        /* 2:02 a z swizzle */
    unsigned long ays:2;        /* 2:04 a y swizzle */
    unsigned long axs:2;        /* 2:06 a x swizzle */
    unsigned long ane:1;        /* 2:08 a negate */
    unsigned long  va:4;        /* 2:09 ibuffer address */
    unsigned long  ca:8;        /* 2:13 ctx address */
    unsigned long mac:4;        /* 2:21 MLU/ALU op */
    unsigned long ilu:3;        /* 2:25 ILU op */
} t_CheopsUcode;

// a program that's been fully compiled and assembled into kelvin microcode
typedef struct _KELVIN_MICRO_PROGRAM {
    //GLuint nid;
    //long pType;
    long ctxwri;
    long outwri;
    long length;
    //long stadd;
    //long bound;
    //long loaded;
    //float x,y,z,w;
    t_CheopsUcode ucode[136];
} KELVIN_MICRO_PROGRAM, *PKELVIN_MICRO_PROGRAM;

// a compiled program in the intermediate format between a D3D token stream and microcode
typedef struct _KELVIN_PROGRAM {
    Instruction code[136];
    DWORD dwNumInstructions;
} KELVIN_PROGRAM, *PKELVIN_PROGRAM;


// prototypes
void nvKelvinInitProgram           (PKELVIN_MICRO_PROGRAM pProgram);
void nvKelvinParseProgram          (PKELVIN_MICRO_PROGRAM pProgram, char *s);
void nvKelvinDownloadProgram       (PNVD3DCONTEXT pContext, PKELVIN_MICRO_PROGRAM pProgram,DWORD dwStartAddress);
void nvKelvinDownloadProgram       (PNVD3DCONTEXT pContext, VertexProgramOutput *pProgramOutput, DWORD dwStartAddress);
void nvKelvinDownloadConstants     (PNVD3DCONTEXT pContext);
void nvKelvinParseVertexShaderCode (PKELVIN_PROGRAM pProgram, ParsedProgram* parsed, DWORD *pCode, DWORD dwCodeSize);


#ifdef KPFS
class CVertexShader;

class CKelvinProgramMan {
    
    class CInstr {
    public:
        CInstr *next;
        DWORD len;    
        DWORD handle; 
        DWORD index;  
    };
    
    PNVD3DCONTEXT m_pContext, m_pPrevContext;
    DWORD m_dwInstructions;
    DWORD m_dwOffset;
    DWORD m_dwLastHandle;
    DWORD m_dwDirty;
    CInstr* ins; 
    
    void add (DWORD handle, DWORD num_instr);
    bool find(DWORD handle, DWORD num_instr);
    
    public:
        
        CKelvinProgramMan()  {};
        ~CKelvinProgramMan() {};
        
        void create(DWORD);
        void destroy();
        void flush();
        void download(PNVD3DCONTEXT pContext, CVertexShader* pVertexShader);
        void download_special(PNVD3DCONTEXT pContext, PKELVIN_MICRO_PROGRAM pProgram, DWORD handle);
        void display();
        inline void dirty() {m_dwDirty=1;}
};
#endif 

#endif  // NVARCH >= 0x020

#endif  // _NVKELVINPROGRAM_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\kelvin\inc\nvKelvinState.h ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// ********************************* Direct 3D ******************************
//
//  Module: nvKelvinState.h
//      Kelvin state header file
//
// **************************************************************************
//
//  History:
//      Craig Duttweiler        27Mar2000         NV20 development
//
// **************************************************************************

#ifndef _NVKELVINSTATE_H
#define _NVKELVINSTATE_H

#if (NVARCH >= 0x020)

// general HW capabilities used internally by driver ------------------------

#define KELVIN_NUM_COMBINERS            8           // virtual combiner stages
#define KELVIN_NUM_MATRICES             4           // blendable matrices
#define KELVIN_NUM_TEXTURES             4           // texture units
#define KELVIN_NUM_WINDOWS              8           // clip windows

#define KELVIN_ALIGNMENT_MIN            64

#define KELVIN_VIEWPORT_BOUND           0           // kelvin viewport runs from 0..4096
#define KELVIN_D3D2OGL                  0.5f        // add 0.5 so that D3D pixels line up with OGL pixels
#define KELVIN_HALFSUBPIXELBIAS         0.03125f    // round to nearest 1/16 pixel grid

#define KELVIN_BORDER                   (-KELVIN_VIEWPORT_BOUND + KELVIN_D3D2OGL + KELVIN_HALFSUBPIXELBIAS)

// z depths
#define KELVIN_Z_SCALE16                65535.0f     // 2^16 - 1
#define KELVIN_Z_SCALE24                16777215.0f  // 2^24 - 1
#define KELVIN_Z_SCALE16_INV            (1.0f / KELVIN_Z_SCALE16)
#define KELVIN_Z_SCALE24_INV            (1.0f / KELVIN_Z_SCALE24)

#define KELVIN_TETRIS_THRESHOLD         1024         // minimum width of a clear that will get striped
#define KELVIN_TETRIS_WIDTH             256          // width of clear stripe in pixels (optimal = 1024 bytes)
                                                     // This needs to be adjusted by the color depth, as it's only accurate for 32bpp.
                                                     // It turns out that for NV20, it's much faster to clear 1024 byte swaths of
                                                     // the Z buffer.


#define KELVIN_MAX_INLINE_STRIDE        16    // largest number of DWORDs allowed in a single vertex
#define KELVIN_MAX_INLINE_VERTICES      120   // maximum vertices = maximum method data size / maximum vertex size
                                              //                  = 2^11 DWORDs / KELVIN_MAX_INLINE_STRIDE
                                              //                  = 128
#define KELVIN_MAX_NONINC_DATA          1000  // maximum amount of data (DWORDs) that can be sent to a non-incrementing
                                              // method like NV097_ARRAY_ELEMENT16 (actually 2^10-1 = 1023)

// general HW capabilities exported to D3D ----------------------------------

#define KELVIN_MAXVERTEXCOUNT                       32768
#define KELVIN_MAXBUFFERSIZE                        0

#define KELVIN_CAPS_GUARD_BAND_LEFT                -1.0e8f   // nv10/20 can use a guardband as large as 1e25, but 1e8 appears
#define KELVIN_CAPS_GUARD_BAND_TOP                 -1.0e8f   // to be the largest value that the game re-volt will handle.
#define KELVIN_CAPS_GUARD_BAND_RIGHT                1.0e8f   // anything larger aggravates an app bug that causes it to
#define KELVIN_CAPS_GUARD_BAND_BOTTOM               1.0e8f   // send us completely broken geometry.

#define KELVIN_CAPS_MAX_TEXTURE_REPEAT              8192 // the constraint on nv10 is actually du/dx < 8192
#define KELVIN_CAPS_MAX_TEXTURE_ASPECT_RATIO        0
#define KELVIN_CAPS_MAX_ANISOTROPY                  8    // Means we support anisotropic filtering.
#define KELVIN_CAPS_EXTENTS_ADJUST                  0

#define KELVIN_CAPS_MAX_UV_PAIRS                    8    // Number of texture uv's supported.

#define KELVIN_CAPS_FVF_CAPS                        (KELVIN_CAPS_MAX_UV_PAIRS | D3DFVFCAPS_DONOTSTRIPELEMENTS)
#define KELVIN_CAPS_MAX_TEXTURE_BLEND_STATES        KELVIN_NUM_COMBINERS
#define KELVIN_CAPS_MAX_SIMULTANEOUS_TEXTURES       KELVIN_NUM_TEXTURES

// DX7 stuff
#define KELVIN_CAPS_MAX_ACTIVE_LIGHTS               8
#define KELVIN_CAPS_MAX_USER_CLIP_PLANES_EXPORTED   0    // we can do 16, but it's not orthogonal to texturing, so WHQL won't let us export any
#define KELVIN_CAPS_MAX_USER_CLIP_PLANES_ALLOWED    8    // we can do 16, but nv30 will only do 8, so only process that many and ignore others
#define KELVIN_CAPS_MAX_VERTEX_BLEND_MATRICES       KELVIN_NUM_MATRICES

// DX8 stuff
#define KELVIN_CAPS_MAX_STREAMS                     16
#define KELVIN_CAPS_MAX_PSHADER_CONSTS              16
#define KELVIN_CAPS_MAX_VSHADER_CONSTS              96
#define KELVIN_CAPS_MAX_VSHADER_TEMPS               16

// maximum fog scale = 2^13. (the HW has 14 bits. we leave one for roundoff)
#define KELVIN_MAX_FOG_SCALE                        8192.0f

//---------------------------------------------------------------------------

// combiner inputs
typedef enum _kelvinCombinerInput {
    kelvinCombinerInputA = 0,
    kelvinCombinerInputB = 1,
    kelvinCombinerInputC = 2,
    kelvinCombinerInputD = 3,
} kelvinCombinerInput;

// the positions of the inputs in the input control words
static DWORD kelvinCombinerInputShift[4] = {24, 16, 8, 0};

//---------------------------------------------------------------------------
// dirty bits

// celsius uses 0x0000FFFF
// kelvin  uses 0xFFFF0000
#define KELVIN_DIRTY_COMBINERS_COLOR   0x00010000
#define KELVIN_DIRTY_COMBINERS_SPECFOG 0x00020000
#define KELVIN_DIRTY_CONTROL0          0x00040000
#define KELVIN_DIRTY_DEFAULTS          0x00080000
#define KELVIN_DIRTY_FVF               0x00100000
#define KELVIN_DIRTY_LIGHTS            0x00200000
#define KELVIN_DIRTY_MISC_STATE        0x00400000
#define KELVIN_DIRTY_SURFACE           0x00800000
#define KELVIN_DIRTY_TEXTURE_STATE     0x01000000
#define KELVIN_DIRTY_TEXTURE_TRANSFORM 0x02000000
#define KELVIN_DIRTY_TRANSFORM         0x04000000
#define KELVIN_DIRTY_VERTEX_SHADER     0x08000000
#define KELVIN_DIRTY_PIXEL_SHADER      0x10000000

#define KELVIN_DIRTY_REALLY_FILTHY     (KELVIN_DIRTY_COMBINERS_COLOR   | \
                                        KELVIN_DIRTY_COMBINERS_SPECFOG | \
                                        KELVIN_DIRTY_CONTROL0          | \
                                        KELVIN_DIRTY_DEFAULTS          | \
                                        KELVIN_DIRTY_FVF               | \
                                        KELVIN_DIRTY_LIGHTS            | \
                                        KELVIN_DIRTY_MISC_STATE        | \
                                        KELVIN_DIRTY_SURFACE           | \
                                        KELVIN_DIRTY_TEXTURE_STATE     | \
                                        KELVIN_DIRTY_TEXTURE_TRANSFORM | \
                                        KELVIN_DIRTY_TRANSFORM         | \
                                        KELVIN_DIRTY_VERTEX_SHADER     | \
                                        KELVIN_DIRTY_PIXEL_SHADER)

//---------------------------------------------------------------------------

// values for the texture stage <=> texture unit mappings
#define KELVIN_UNUSED                          0xdeadbeef
#define KELVIN_COMBINER_REG_TEX0               0x00000008      // the combiner's first texture register (data from texture unit 0)

// values for texture unit status
#define KELVIN_TEXUNITSTATUS_IDLE              0x00000000      // texture unit is unused
#define KELVIN_TEXUNITSTATUS_USER              0x00000001      // texture unit has a typical user-supplied texture
#define KELVIN_TEXUNITSTATUS_BUMPMAPA          0x00000002      // texture unit has a user-supplied bumpmap in it (see below)
#define KELVIN_TEXUNITSTATUS_BUMPMAPB          0x00000004      //                          "
#define KELVIN_TEXUNITSTATUS_BUMPMAPC          0x00000008      //                          "
#define KELVIN_TEXUNITSTATUS_BUMPMAPD          0x00000010      //                          "
#define KELVIN_TEXUNITSTATUS_CLIP              0x00000020      // texture unit is being used to handle user clip plnes

// bumpmap flavors:
//   A: blend mode does not request luminance from texture, and texure does not have it
//   B: blend mode does not request luminance from texture, but texure does have it
//   C: blend mode requests luminance from texture, but texure does not have it
//   D: blend mode requests luminance from texture, and texure has it

// general kelvin state flags
#define KELVIN_FLAG_PASSTHROUGHMODE            0x00000001      // are we in passthrough mode?
#define KELVIN_FLAG_TEXSTATENEEDSINVMV         0x00000004      // inverse modelview matrix is needed b/c of texture state
#define KELVIN_FLAG_LIGHTINGNEEDSINVMV         0x00000008      // inverse modelview matrix is needed b/c of light state
#define KELVIN_FLAG_COMBINERSNEEDSPECULAR      0x00000010      // specular is referenced as a combiner (TSS) input
#define KELVIN_FLAG_SETUPFAILURE               0x00008000      // did we fail to give the app what it really wanted for one reason or another?

// kelvin texture unit and combiner state flags
#define KELVIN_FLAG_USERTEXCOORDSNEEDED(i)     (0x00010000 << (4*(i)))  // are user texture coordinates needed by HW texture unit i?
#define KELVIN_FLAG_USERTEXCOORDSNEEDED_MASK   (0x11110000)

#ifdef STOMP_TEX_COORDS
#define KELVIN_FLAG_STOMP_4TH_COORD(i)         (0x00020000 << (4*(i)))  // stupid app fix: stomp 4th texcoord to 1.0 when they moronically send down extraneous coordinates
#define KELVIN_FLAG_STOMP_4TH_COORD_MASK       (0x22220000)
#endif  // STOMP_TEX_COORDS

#define KELVIN_SET_NUM_TEX_COORDS(stage,num)   ((num) << (4*(stage)))
#define KELVIN_GET_NUM_TEX_COORDS(value,stage) (((value) >> (4*(stage))) & 0xf)

#ifdef STOMP_TEX_COORDS
#define KELVIN_MASK_INNERLOOPUNIQUENESS        (KELVIN_FLAG_USERTEXCOORDSNEEDED_MASK  |  \
                                                KELVIN_FLAG_STOMP_4TH_COORD_MASK)
#else  // !STOMP_TEX_COORDS
#define KELVIN_MASK_INNERLOOPUNIQUENESS        (KELVIN_FLAG_USERTEXCOORDSNEEDED_MASK)
#endif  // !STOMP_TEX_COORDS

// inner loop constants
#define KELVIN_ILMASK_PRIMTYPE        0x0000ffff
#define KELVIN_ILFLAG_LEGACY          0x00010000  // use legacy strides
//#define KELVIN_ILFLAG_CMHACK          0x00020000  // use tex matrix hack vertex copy routine
#define KELVIN_ILFLAG_NOCULL          0x00040000  // no culling

#define KELVIN_ILMASK_LOOPTYPE        0xf0000000  // type of inner loop
#define KELVIN_ILFLAG_IX_VB_PRIM      0x00000000
#define KELVIN_ILFLAG_IX_STR_PRIM     0x10000000
#define KELVIN_ILFLAG_IX_INL_PRIM     0x20000000
#define KELVIN_ILFLAG_IX_INL_TRI_LIST 0x40000000
#define KELVIN_ILFLAG_IX_DVB_TRI      0x60000000
#define KELVIN_ILFLAG_OR_VB_PRIM      0x80000000
#define KELVIN_ILFLAG_OR_STR_PRIM     0x90000000
#define KELVIN_ILFLAG_OR_INL_PRIM     0xa0000000
#define KELVIN_ILFLAG_OR_INL_TRI_LIST 0xc0000000
#define KELVIN_ILFLAG_SUPER_TRI_LIST  0xe0000000

#define KELVIN_SHORT_INDEXED_PRIM_COUNT_CUTOFF     25    // prim length before we introduce culling
#define KELVIN_SHORT_ORDERED_PRIM_COUNT_CUTOFF     25

// xPipe / Super-tri constants
#define KELVIN_CULLFLAG_MODELOK         0x00000001

// xPipe / Super-tri inner loop flags. These ought to be in the inner loop flags above, but we don't have enough
// flag bits.
#define KELVIN_STILFLAG_STDEFVB         0x00000001  // default VB is used (affects supertri logic)
#define KELVIN_STILFLAG_MODEL           0x00000002  // Model Culling
#define KELVIN_STILFLAG_XFORM           0x00000004  // Xform / clipcheck / cull
#define KELVIN_STILFLAG_HIBW            0x00000008  // High bandwidth mode -- check all triangles

typedef void (__stdcall *KELVINDISPATCHPRIMITIVE)(void);

//---------------------------------------------------------------------------

// forward declarations
class CVertexShader;

//---------------------------------------------------------------------------

class CKelvinState
{
    // intermediate state
public:

    // methods
public:

#if STATE_OPTIMIZE
    // push integer data from an array
    inline void seta (DWORD dwOffset, DWORD count, DWORD *dwArray)
    {
        if (!count) return;

        getDC()->nvPusher.push (0, (count << 18) | (NV_DD_KELVIN << 13) | dwOffset);
        for (DWORD i = 1; i <= count; i++)
        {
            getDC()->nvPusher.push(i, *dwArray++);
        }
        getDC()->nvPusher.adjust(count+1);
    }
#endif

    // integer data
    inline void set1 (DWORD dwOffset, DWORD dw0)
    {
        getDC()->nvPusher.push (0, 0x00040000 | (NV_DD_KELVIN << 13) | dwOffset);
        getDC()->nvPusher.push (1, dw0);
        getDC()->nvPusher.adjust (2);
    }
    inline void set2 (DWORD dwOffset, DWORD dw0, DWORD dw1)
    {
        getDC()->nvPusher.push (0, 0x00080000 | (NV_DD_KELVIN << 13) | dwOffset);
        getDC()->nvPusher.push (1, dw0);
        getDC()->nvPusher.push (2, dw1);
        getDC()->nvPusher.adjust (3);
    }
    inline void set3 (DWORD dwOffset, DWORD dw0, DWORD dw1, DWORD dw2)
    {
        getDC()->nvPusher.push (0, 0x000c0000 | (NV_DD_KELVIN << 13) | dwOffset);
        getDC()->nvPusher.push (1, dw0);
        getDC()->nvPusher.push (2, dw1);
        getDC()->nvPusher.push (3, dw2);
        getDC()->nvPusher.adjust (4);
    }
    inline void set4 (DWORD dwOffset, DWORD dw0, DWORD dw1, DWORD dw2, DWORD dw3)
    {
        getDC()->nvPusher.push (0, 0x00100000 | (NV_DD_KELVIN << 13) | dwOffset);
        getDC()->nvPusher.push (1, dw0);
        getDC()->nvPusher.push (2, dw1);
        getDC()->nvPusher.push (3, dw2);
        getDC()->nvPusher.push (4, dw3);
        getDC()->nvPusher.adjust (5);
    }
    inline void set5 (DWORD dwOffset, DWORD dw0, DWORD dw1, DWORD dw2, DWORD dw3, DWORD dw4)
    {
        getDC()->nvPusher.push (0, 0x00140000 | (NV_DD_KELVIN << 13) | dwOffset);
        getDC()->nvPusher.push (1, dw0);
        getDC()->nvPusher.push (2, dw1);
        getDC()->nvPusher.push (3, dw2);
        getDC()->nvPusher.push (4, dw3);
        getDC()->nvPusher.push (5, dw4);
        getDC()->nvPusher.adjust (6);
    }
    inline void set6 (DWORD dwOffset, DWORD dw0, DWORD dw1, DWORD dw2, DWORD dw3, DWORD dw4, DWORD dw5)
    {
        getDC()->nvPusher.push (0, 0x00180000 | (NV_DD_KELVIN << 13) | dwOffset);
        getDC()->nvPusher.push (1, dw0);
        getDC()->nvPusher.push (2, dw1);
        getDC()->nvPusher.push (3, dw2);
        getDC()->nvPusher.push (4, dw3);
        getDC()->nvPusher.push (5, dw4);
        getDC()->nvPusher.push (6, dw5);
        getDC()->nvPusher.adjust (7);
    }
    inline void set7 (DWORD dwOffset, DWORD dw0, DWORD dw1, DWORD dw2, DWORD dw3, DWORD dw4, DWORD dw5, DWORD dw6)
    {
        getDC()->nvPusher.push (0, 0x001c0000 | (NV_DD_KELVIN << 13) | dwOffset);
        getDC()->nvPusher.push (1, dw0);
        getDC()->nvPusher.push (2, dw1);
        getDC()->nvPusher.push (3, dw2);
        getDC()->nvPusher.push (4, dw3);
        getDC()->nvPusher.push (5, dw4);
        getDC()->nvPusher.push (6, dw5);
        getDC()->nvPusher.push (7, dw6);
        getDC()->nvPusher.adjust (8);
    }
    inline void set8 (DWORD dwOffset, DWORD dw0, DWORD dw1, DWORD dw2, DWORD dw3, DWORD dw4, DWORD dw5, DWORD dw6, DWORD dw7)
    {
        getDC()->nvPusher.push (0, 0x00200000 | (NV_DD_KELVIN << 13) | dwOffset);
        getDC()->nvPusher.push (1, dw0);
        getDC()->nvPusher.push (2, dw1);
        getDC()->nvPusher.push (3, dw2);
        getDC()->nvPusher.push (4, dw3);
        getDC()->nvPusher.push (5, dw4);
        getDC()->nvPusher.push (6, dw5);
        getDC()->nvPusher.push (7, dw6);
        getDC()->nvPusher.push (8, dw7);
        getDC()->nvPusher.adjust (9);
    }

    // floating-point data
    inline void set1f (DWORD dwOffset, float fData0)
    {
        getDC()->nvPusher.push (0, 0x00040000 | (NV_DD_KELVIN << 13) | dwOffset);
        getDC()->nvPusher.push (1, *(DWORD*)&fData0);
        getDC()->nvPusher.adjust (2);
    }
    inline void set2f (DWORD dwOffset, float fData0, float fData1)
    {
        getDC()->nvPusher.push (0, 0x00080000 | (NV_DD_KELVIN << 13) | dwOffset);
        getDC()->nvPusher.push (1, *(DWORD*)&fData0);
        getDC()->nvPusher.push (2, *(DWORD*)&fData1);
        getDC()->nvPusher.adjust (3);
    }
    inline void set3f (DWORD dwOffset, float fData0, float fData1, float fData2)
    {
        getDC()->nvPusher.push (0, 0x000c0000 | (NV_DD_KELVIN << 13) | dwOffset);
        getDC()->nvPusher.push (1, *(DWORD*)&fData0);
        getDC()->nvPusher.push (2, *(DWORD*)&fData1);
        getDC()->nvPusher.push (3, *(DWORD*)&fData2);
        getDC()->nvPusher.adjust (4);
    }
    inline void set4f (DWORD dwOffset,
                       float fData0, float fData1,
                       float fData2, float fData3)
    {
        getDC()->nvPusher.push (0, 0x00100000 | (NV_DD_KELVIN << 13) | dwOffset);
        getDC()->nvPusher.push (1, *(DWORD*)&fData0);
        getDC()->nvPusher.push (2, *(DWORD*)&fData1);
        getDC()->nvPusher.push (3, *(DWORD*)&fData2);
        getDC()->nvPusher.push (4, *(DWORD*)&fData3);
        getDC()->nvPusher.adjust (5);
    }
    inline void set8f (DWORD dwOffset,
                       float fData0, float fData1, float fData2, float fData3,
                       float fData4, float fData5, float fData6, float fData7)
    {
        getDC()->nvPusher.push (0, 0x00200000 | (NV_DD_KELVIN << 13) | dwOffset);
        getDC()->nvPusher.push (1, *(DWORD*)&fData0);
        getDC()->nvPusher.push (2, *(DWORD*)&fData1);
        getDC()->nvPusher.push (3, *(DWORD*)&fData2);
        getDC()->nvPusher.push (4, *(DWORD*)&fData3);
        getDC()->nvPusher.push (5, *(DWORD*)&fData4);
        getDC()->nvPusher.push (6, *(DWORD*)&fData5);
        getDC()->nvPusher.push (7, *(DWORD*)&fData6);
        getDC()->nvPusher.push (8, *(DWORD*)&fData7);
        getDC()->nvPusher.adjust (9);
    }

    // various routines to set texture transform matrices. see comments in nvSetKelvinTextureTransform()
    // (s,t,1.0) in, (s,t,1.0) out
    void setTextureTransformMatrixType220 (DWORD dwName, D3DMATRIX *pMatrix)
    {
        set4f (dwName +  0, pMatrix->_11, pMatrix->_21, 0.0f,         pMatrix->_31);
        set4f (dwName + 16, pMatrix->_12, pMatrix->_22, 0.0f,         pMatrix->_32);
        set4f (dwName + 32, 0.0f,         0.0f,         0.0f,         0.0f        );
        set4f (dwName + 48, 0.0f,         0.0f,         0.0f,         1.0f        );
    }
    // (s,t,1.0) in, (s,t,r,1.0) out
    void setTextureTransformMatrixType230 (DWORD dwName, D3DMATRIX *pMatrix)
    {
        set4f (dwName +  0, pMatrix->_11, pMatrix->_21, 0.0f,         pMatrix->_31);
        set4f (dwName + 16, pMatrix->_12, pMatrix->_22, 0.0f,         pMatrix->_32);
        set4f (dwName + 32, pMatrix->_13, pMatrix->_23, 0.0f,         pMatrix->_33);
        set4f (dwName + 48, 0.0f,         0.0f,         0.0f,         1.0f        );
    }
    // (s,t,1.0) in, (s,t,q) out
    void setTextureTransformMatrixType231 (DWORD dwName, D3DMATRIX *pMatrix)
    {
        set4f (dwName +  0, pMatrix->_11, pMatrix->_21, 0.0f,         pMatrix->_31);
        set4f (dwName + 16, pMatrix->_12, pMatrix->_22, 0.0f,         pMatrix->_32);
        set4f (dwName + 32, 0.0f,         0.0f,         0.0f,         0.0f        );
        set4f (dwName + 48, pMatrix->_13, pMatrix->_23, 0.0f,         pMatrix->_33);
    }
    // (s,t,1.0) in, (s,t,r,q) out
    void setTextureTransformMatrixType241 (DWORD dwName, D3DMATRIX *pMatrix)
    {
        set4f (dwName +  0, pMatrix->_11, pMatrix->_21, 0.0f,         pMatrix->_31);
        set4f (dwName + 16, pMatrix->_12, pMatrix->_22, 0.0f,         pMatrix->_32);
        set4f (dwName + 32, pMatrix->_13, pMatrix->_23, 0.0f,         pMatrix->_33);
        set4f (dwName + 48, pMatrix->_14, pMatrix->_24, 0.0f,         pMatrix->_34);
    }
    // (s,t,r,1.0) in, (s,t,1.0) out
    void setTextureTransformMatrixType320 (DWORD dwName, D3DMATRIX *pMatrix)
    {
        set4f (dwName +  0, pMatrix->_11, pMatrix->_21, pMatrix->_31, pMatrix->_41);
        set4f (dwName + 16, pMatrix->_12, pMatrix->_22, pMatrix->_32, pMatrix->_42);
        set4f (dwName + 32, 0.0f,         0.0f,         0.0f,         0.0f        );
        set4f (dwName + 48, 0.0f,         0.0f,         0.0f,         1.0f        );
    }
    // (s,t,r,1.0) in, (s,t,r,1.0) out
    void setTextureTransformMatrixType330 (DWORD dwName, D3DMATRIX *pMatrix)
    {
        set4f (dwName +  0, pMatrix->_11, pMatrix->_21, pMatrix->_31, pMatrix->_41);
        set4f (dwName + 16, pMatrix->_12, pMatrix->_22, pMatrix->_32, pMatrix->_42);
        set4f (dwName + 32, pMatrix->_13, pMatrix->_23, pMatrix->_33, pMatrix->_43);
        set4f (dwName + 48, 0.0f,         0.0f,         0.0f,         1.0f        );
    }
    // (s,t,r,1.0) in, (s,t,q) out
    void setTextureTransformMatrixType331 (DWORD dwName, D3DMATRIX *pMatrix)
    {
        set4f (dwName +  0, pMatrix->_11, pMatrix->_21, pMatrix->_31, pMatrix->_41);
        set4f (dwName + 16, pMatrix->_12, pMatrix->_22, pMatrix->_32, pMatrix->_42);
        set4f (dwName + 32, 0.0f,         0.0f,         0.0f,         0.0f        );
        set4f (dwName + 48, pMatrix->_13, pMatrix->_23, pMatrix->_33, pMatrix->_43);
    }
    // (s,t,r,1.0) in, (s,t,r,q) out
    void setTextureTransformMatrixType341 (DWORD dwName, D3DMATRIX *pMatrix)
    {
        set4f (dwName +  0, pMatrix->_11, pMatrix->_21, pMatrix->_31, pMatrix->_41);
        set4f (dwName + 16, pMatrix->_12, pMatrix->_22, pMatrix->_32, pMatrix->_42);
        set4f (dwName + 32, pMatrix->_13, pMatrix->_23, pMatrix->_33, pMatrix->_43);
        set4f (dwName + 48, pMatrix->_14, pMatrix->_24, pMatrix->_34, pMatrix->_44);
    }

    // set only the first three rows, since the rest is unnecessary
    void setInverseModelViewMatrix (DWORD dwName, D3DMATRIX *pMatrix)
    {
        set4f (dwName +  0, pMatrix->_11, pMatrix->_12, pMatrix->_13, pMatrix->_14);
        set4f (dwName + 16, pMatrix->_21, pMatrix->_22, pMatrix->_23, pMatrix->_24);
        set4f (dwName + 32, pMatrix->_31, pMatrix->_32, pMatrix->_33, pMatrix->_34);
    }

    // transpose the matrix since d3d does {v}[M] instead of [M]{v}'
    void setMatrixTransposed (DWORD dwName,D3DMATRIX *pMatrix)
    {
        set4f (dwName +  0, pMatrix->_11, pMatrix->_21, pMatrix->_31, pMatrix->_41);
        set4f (dwName + 16, pMatrix->_12, pMatrix->_22, pMatrix->_32, pMatrix->_42);
        set4f (dwName + 32, pMatrix->_13, pMatrix->_23, pMatrix->_33, pMatrix->_43);
        set4f (dwName + 48, pMatrix->_14, pMatrix->_24, pMatrix->_34, pMatrix->_44);
    }
};

// prototypes ---------------------------------------------------------------

HRESULT __stdcall       nvSetKelvinState           (PNVD3DCONTEXT pContext);
HRESULT __stdcall       nvSetKelvinClearState      (PNVD3DCONTEXT pContext);
KELVINDISPATCHPRIMITIVE nvKelvinGetDispatchRoutine (PNVD3DCONTEXT pConext,DWORD dwFlags);

#endif  // NVARCH >= 0x020

#endif  // _NVKELVINSTATE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\kelvin\inc\nvKelvinStateHelp.h ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// ********************************* Direct 3D ******************************
//
//  Module: nvKelvinStateHelp.h
//      Constants, macros, and prototypes for nvKelvinStateHelp.cpp
//
// **************************************************************************
//
//  History:
//       Craig Duttweiler        26Apr2000         NV20 development
//
// **************************************************************************

#ifndef _NVKELVINSTATEHELP_H
#define _NVKELVINSTATEHELP_H

#if (NVARCH >= 0x020)

DWORD nvKelvinValidateTextureStageState (LPD3DHAL_VALIDATETEXTURESTAGESTATEDATA);
DWORD nvKelvinInlineVertexStride        (PNVD3DCONTEXT pContext);

#endif  // NVARCH >= 0x020

#endif  // _NVKELVINSTATEHELP_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\kelvin\src\nvKelvinComp.cpp ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// ********************************* Direct 3D ******************************
//
//  Module: nvKelvinComp.cpp
//      Kelvin inner loop compiler
//
// **************************************************************************
//
//  History:
//      Craig Duttweiler        29Jun2000         ported from celsius
//
// **************************************************************************
#include "nvprecomp.h"

#if (NVARCH >= 0x20)

#include "x86.h"
#include "nvILHash.h"

#ifdef KELVIN_ILC

//////////////////////////////////////////////////////////////////////////////
// notes:
//
// inner loop uniqueness is a function of:
//  - fvfData.dwVertexStride
//  - fvfData.dwVertexType
//  - fvfData.dwUVCount[8]
//  - fvfData.dwUVOffset[8]
//  - pContext->hwState.dwStateFlags & KELVIN_MASK_INNERLOOPUNIQUENESS
//  - pContext->hwState.kelvin.dwTexUnitToTexStageMapping[2]
//
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// switches
//
//#define PRINT_NAME          // prints ilcFlags for every primitive batch

//////////////////////////////////////////////////////////////////////////////
// aliases
//
#define ilcData         global.dwILCData
#define ilcCount        global.dwILCCount
#define ilcMax          global.dwILCMax

#define KNIMEM(x)           ((((DWORD)&((*(KATMAI_STATE*)global.kni).x[0])) + 15) & ~15)

//////////////////////////////////////////////////////////////////////////////
// external declarations (mostly nvcomp.cpp)
//
void ILCCompile_GetSpace (void);
void ILCCompile_mul      (DWORD reg,DWORD num);

// forward declarations
//
DWORD nvKelvinILCompile_inline_prim      (PNVD3DCONTEXT pContext,DWORD dwFlags);    // nvKelvinInlPrim.cpp
DWORD nvKelvinILCompile_inline_tri_list  (PNVD3DCONTEXT pContext,DWORD dwFlags);    // nvKelvinInlTri.cpp
DWORD nvKelvinILCompile_vb_prim          (PNVD3DCONTEXT pContext,DWORD dwFlags);    // nvKelvinVbPrim.cpp
// DWORD nvKelvinILCompile_str_prim         (PNVD3DCONTEXT pContext,DWORD dwFlags);    // nvKelvinInlStrPrim.cpp
DWORD nvKelvinILCompile_super_tri_list   (PNVD3DCONTEXT pContext,DWORD dwFlags);    // nvKelvinSuperTri.cpp

//---------------------------------------------------------------------------

// nvKelvinGetDispatchRoutine

KELVINDISPATCHPRIMITIVE nvKelvinGetDispatchRoutine
(
    PNVD3DCONTEXT pContext,
    DWORD         dwFlags
)
{
    // check quick cache
    if (global.kelvin.dwLoopCache)
    {
        CILHashEntry *pEntry = (CILHashEntry*)global.kelvin.dwLoopCache;
        if (pEntry->match (pContext,NVCLASS_FAMILY_KELVIN,dwFlags))
        {
            return (KELVINDISPATCHPRIMITIVE)(ilcData + pEntry->getOffset());
        }
    }

    // check hash table
    DWORD dwHashIndex = (DRAW_PRIM_TABLE_ENTRIES - 1) & ((dwFlags + (dwFlags >> 12) + (dwFlags >> 24))
                                                      + pContext->hwState.pVertexShader->getStride()
                                                      + pContext->hwState.pVertexShader->getFVF());

    CILHashEntry *pEntry = (CILHashEntry*)dwDrawPrimitiveTable[dwHashIndex];

    while (pEntry)
    {
        // found it?
        if (pEntry->match (pContext,NVCLASS_FAMILY_KELVIN,dwFlags))
        {
            global.kelvin.dwLoopCache = (DWORD)pEntry;
            return (KELVINDISPATCHPRIMITIVE)(ilcData + pEntry->getOffset());
        }
        // next
        pEntry = pEntry->getNext();
    }

    // build new innerloop
    //  loops require pContext->hwState.dwStateFlags to be set up correctly (CM hack, inline expansion)
    DWORD dwOffset;
    switch (dwFlags & KELVIN_ILMASK_LOOPTYPE)
    {
        case KELVIN_ILFLAG_IX_VB_PRIM:
        case KELVIN_ILFLAG_OR_VB_PRIM:       dwOffset = nvKelvinILCompile_vb_prim(pContext,dwFlags);
                                             break;
        case KELVIN_ILFLAG_IX_STR_PRIM:
        case KELVIN_ILFLAG_OR_STR_PRIM:      //dwOffset = nvKelvinILCompile_str_prim(pContext,dwFlags);
                                             dwOffset = 0;
                                             break;
        case KELVIN_ILFLAG_IX_INL_PRIM:
        case KELVIN_ILFLAG_OR_INL_PRIM:      dwOffset = nvKelvinILCompile_inline_prim(pContext,dwFlags);
                                             break;
        case KELVIN_ILFLAG_IX_INL_TRI_LIST:
        case KELVIN_ILFLAG_OR_INL_TRI_LIST:  dwOffset = nvKelvinILCompile_inline_tri_list(pContext,dwFlags);
                                             break;
        case KELVIN_ILFLAG_SUPER_TRI_LIST:   dwOffset = nvKelvinILCompile_super_tri_list(pContext,dwFlags);
                                             break;
        case KELVIN_ILFLAG_IX_DVB_TRI:       dwOffset = 0;//todo - nvKelvinILCompile_indexed_dvb_tri(pContext,dwFlags);
                                             break;
    }

    // add to hash list
    pEntry = new CILHashEntry (pContext,NVCLASS_FAMILY_KELVIN,dwFlags,dwOffset,(CILHashEntry*)dwDrawPrimitiveTable[dwHashIndex]);
    if (!pEntry) return NULL;
    dwDrawPrimitiveTable[dwHashIndex] = (DWORD)pEntry;

#ifdef PRINT_NAME
    PF ("new kelvin loop (%08x): type %x, dp2 %s (%2x), state = %08x, %s %s", pEntry,
        (dwFlags & 0xF0000000) >> 28,
        kelvinPrimitiveName[dwFlags & 0xFFFF], dwFlags & 0xFFFF,
        pContext->hwState.dwStateFlags & KELVIN_MASK_INNERLOOPUNIQUENESS,
        dwFlags & KELVIN_ILFLAG_LEGACY ? "LEGACY" : "",
        dwFlags & KELVIN_ILFLAG_NOCULL ? "NOCULL" : "");
#endif

    // done
    global.kelvin.dwLoopCache = (DWORD)pEntry;
    return (KELVINDISPATCHPRIMITIVE)(ilcData + pEntry->getOffset());
}


//---------------------------------------------------------------------------

// helpers

void __stdcall nvKelvinDispatchGetPusherSpace (void)
{
    // wrap around -or- make space
    nvPusherAdjust (0);
}

//---------------------------------------------------------------------------

#ifdef DEBUG
void __stdcall nvKelvinDispatchFlush (void)
{
    nvPusherAdjust (0);
    getDC()->nvPusher.flush (TRUE, CPushBuffer::FLUSH_WITH_DELAY);
}

void __stdcall nvKelvinDispatchPrintVertex (PNVD3DCONTEXT pContext,DWORD dwPutAddress)
{
    static DWORD  dwVertexCount = 0;
           DWORD *pdwData       = ((DWORD*)dwPutAddress) + 1;

    if (dbgShowState & NVDBG_SHOW_VERTICES)
    {
        dwVertexCount ++;

        DPF ("Vertex %d",dwVertexCount);

        if (pContext->hwState.pVertexShader->bVAExists(defaultInputRegMap[D3DVSDE_BLENDWEIGHT])) {
            DPF ("         B = %08x",pdwData[0]);
            pdwData += 1;
        }

        if (pContext->hwState.pVertexShader->bVAExists(defaultInputRegMap[D3DVSDE_NORMAL])) {
            DPF ("    Normal = %f, %f, %f", FLOAT_FROM_DWORD(pdwData[0]),FLOAT_FROM_DWORD(pdwData[1]),FLOAT_FROM_DWORD(pdwData[2]));
            DPF ("           = [%08x, %08x, %08x]", pdwData[0],pdwData[1],pdwData[2]);
            pdwData += 3;
        }

        if (pContext->hwState.dwStateFlags & KELVIN_FLAG_USERTEXCOORDSNEEDED(1)) {
            DWORD dwD3DStage = pContext->hwState.dwTexUnitToTexStageMapping[1];
            DWORD dwTCIndex  = (pContext->hwState.dwTexCoordIndices >> 8) & 0xff;
            DWORD dwVAIndex  = defaultInputRegMap[D3DVSDE_TEXCOORD0+dwTCIndex];
            DWORD dwCount    = (pContext->hwState.pVertexShader->getVASize(dwVAIndex) >> 2);
            for (DWORD i = 0; i < dwCount; i++)
            {
                DPF ("   UV1[%d] = %f [%08x]", i,FLOAT_FROM_DWORD(pdwData[0]),pdwData[0]);
                pdwData += 1;
            }
        }

        if (pContext->hwState.dwStateFlags & KELVIN_FLAG_USERTEXCOORDSNEEDED(0)) {
            DWORD dwD3DStage = pContext->hwState.dwTexUnitToTexStageMapping[0];
            DWORD dwTCIndex  = (pContext->hwState.dwTexCoordIndices >> 0) & 0xff;
            DWORD dwVAIndex  = defaultInputRegMap[D3DVSDE_TEXCOORD0+dwTCIndex];
            DWORD dwCount    = (pContext->hwState.pVertexShader->getVASize(dwVAIndex) >> 2);
            for (DWORD i = 0; i < dwCount; i++)
            {
                DPF ("   UV0[%d] = %f [%08x]", i,FLOAT_FROM_DWORD(pdwData[0]),pdwData[0]);
                pdwData += 1;
            }
        }

        if (pContext->hwState.pVertexShader->bVAExists(defaultInputRegMap[D3DVSDE_SPECULAR])){
            DPF ("  Specular = %08x",pdwData[0]);
            pdwData += 1;
        }

        if (pContext->hwState.pVertexShader->bVAExists(defaultInputRegMap[D3DVSDE_DIFFUSE])) {
            DPF ("   Diffuse = %08x",pdwData[0]);
            pdwData += 1;
        }

        nvAssert (pContext->hwState.pVertexShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]));
        DPF ("       XYZ = %f, %f, %f", FLOAT_FROM_DWORD(pdwData[0]),FLOAT_FROM_DWORD(pdwData[1]),FLOAT_FROM_DWORD(pdwData[2]));
        DPF ("           = [%08x, %08x, %08x]", pdwData[0],pdwData[1],pdwData[2]);
        pdwData += 3;

        if (pContext->hwState.pVertexShader->getVASize(defaultInputRegMap[D3DVSDE_POSITION]) == 4*sizeof(DWORD)) {
            DPF ("       RHW = %f [%08x]", FLOAT_FROM_DWORD(pdwData[0]),pdwData[0]);
            pdwData += 1;
        }
        DPF ("");
    }
}
#endif

// copies dwCount bytes from [esi] to [edi] with increment. if dwCount is zero then we copy ecx bytes
// we use esi,edi,eax and ecx. for kni we also use xmm0 to xmm3
void nvKelvinILCompile_memcpy
(
    DWORD dwCount, bool recurse
)
{

//    if (dwCount)
//    {
//        xMOV_rm_imm (rmREG(rECX),dwCount)
//    }
//
//    xMOV_r_rm   (rEAX,rmREG(rECX))
//    xSHR_rm_imm (rmREG(rECX),2)
//    xAND_rm_imm (rmREG(rEAX),3)
//    xREP xMOVSD
//    xMOV_r_rm   (rECX,rmREG(rEAX))
//    xREP xMOVSB
//
    if (dwCount)
    {
        // do copy
        if (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_KATMAI)
        {
            //
            // KNI copy
            //
            while (dwCount >= 64)
            {
                xMOVLPS_r_rm    (rXMM0,rmIND(rESI))
                xMOVHPS_r_rm    (rXMM0,rmIND8(rESI)) xOFS8(8)
                xMOVLPS_r_rm    (rXMM1,rmIND8(rESI)) xOFS8(16)
                xMOVHPS_r_rm    (rXMM1,rmIND8(rESI)) xOFS8(24)
                xMOVLPS_r_rm    (rXMM2,rmIND8(rESI)) xOFS8(32)
                xMOVHPS_r_rm    (rXMM2,rmIND8(rESI)) xOFS8(40)
                xMOVLPS_r_rm    (rXMM3,rmIND8(rESI)) xOFS8(48)
                xMOVHPS_r_rm    (rXMM3,rmIND8(rESI)) xOFS8(56)
                xADD_rm_imm     (rmREG(rESI),64)
                xMOVLPS_rm_r    (rmIND(rEDI),rXMM0)
                xMOVHPS_rm_r    (rmIND8(rEDI),rXMM0) xOFS8(8)
                xMOVLPS_rm_r    (rmIND8(rEDI),rXMM1) xOFS8(16)
                xMOVHPS_rm_r    (rmIND8(rEDI),rXMM1) xOFS8(24)
                xMOVLPS_rm_r    (rmIND8(rEDI),rXMM2) xOFS8(32)
                xMOVHPS_rm_r    (rmIND8(rEDI),rXMM2) xOFS8(40)
                xMOVLPS_rm_r    (rmIND8(rEDI),rXMM3) xOFS8(48)
                xMOVHPS_rm_r    (rmIND8(rEDI),rXMM3) xOFS8(56)
                xADD_rm_imm     (rmREG(rEDI),64)
                dwCount -= 64;
            }

            while (dwCount >= 16)
            {
                xMOVLPS_r_rm    (rXMM0,rmIND(rESI))
                xMOVHPS_r_rm    (rXMM0,rmIND8(rESI)) xOFS8(8)
                xADD_rm_imm     (rmREG(rESI),16)
                xMOVLPS_rm_r    (rmIND(rEDI),rXMM0)
                xMOVHPS_rm_r    (rmIND8(rEDI),rXMM0) xOFS8(8)
                xADD_rm_imm     (rmREG(rEDI),16)
                dwCount -= 16;
            }

            while (dwCount >= 8)
            {
                xMOV_r_rm    (rEAX,rmIND(rESI))
                xMOV_r_rm    (rECX,rmIND8(rESI)) xOFS8(4)
                xADD_rm_imm  (rmREG(rESI),8)
                xMOV_rm_r    (rmIND(rEDI),rEAX)
                xADD_rm_imm  (rmREG(rEDI),8)
                xMOV_rm_r    (rmIND8(rEDI),rECX) xOFS8(4 - 8)
                dwCount -= 8;
            }

            while (dwCount >= 4)
            {
                xMOV_r_rm    (rEAX,rmIND(rESI))
                xADD_rm_imm  (rmREG(rESI),4)
                xMOV_rm_r    (rmIND(rEDI),rEAX)
                xADD_rm_imm  (rmREG(rEDI),4)
                dwCount -= 4;
            }

            if (dwCount)
            {
                xMOV_rm_imm (rmREG(rECX),dwCount)
                xREP xMOVSB
            }
        }
        else if (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_ATHLON)
        {
            //
            // AMD copy
            //
            bool needFemms = false;
            if (dwCount >= 16 && !recurse)
            {
                xFEMMS
                needFemms = true;
            }

            while (dwCount >= 64)
            {
                xMOVQ_r_rm      (rMM0,rmIND(rESI))
                xMOVQ_r_rm      (rMM1,rmIND8(rESI)) xOFS8(8)
                xMOVQ_r_rm      (rMM2,rmIND8(rESI)) xOFS8(16)
                xMOVQ_r_rm      (rMM3,rmIND8(rESI)) xOFS8(24)
                xMOVQ_r_rm      (rMM4,rmIND8(rESI)) xOFS8(32)
                xMOVQ_r_rm      (rMM5,rmIND8(rESI)) xOFS8(40)
                xMOVQ_r_rm      (rMM6,rmIND8(rESI)) xOFS8(48)
                xMOVQ_r_rm      (rMM7,rmIND8(rESI)) xOFS8(56)
                xADD_rm_imm     (rmREG(rESI),64)
                xMOVNTQ_rm_r    (rmIND(rEDI),rMM0)
                xMOVNTQ_rm_r    (rmIND8(rEDI),rMM1) xOFS8(8)
                xMOVNTQ_rm_r    (rmIND8(rEDI),rMM2) xOFS8(16)
                xMOVNTQ_rm_r    (rmIND8(rEDI),rMM3) xOFS8(24)
                xMOVNTQ_rm_r    (rmIND8(rEDI),rMM4) xOFS8(32)
                xMOVNTQ_rm_r    (rmIND8(rEDI),rMM5) xOFS8(40)
                xMOVNTQ_rm_r    (rmIND8(rEDI),rMM6) xOFS8(48)
                xMOVNTQ_rm_r    (rmIND8(rEDI),rMM7) xOFS8(56)
                xADD_rm_imm     (rmREG(rEDI),64)
                dwCount -= 64;
            }

            while (dwCount >= 16)
            {
                xMOVQ_r_rm      (rMM0,rmIND(rESI))
                xMOVQ_r_rm      (rMM1,rmIND8(rESI)) xOFS8(8)
                xADD_rm_imm     (rmREG(rESI),16)
                xMOVNTQ_rm_r    (rmIND(rEDI),rMM0)
                xMOVNTQ_rm_r    (rmIND8(rEDI),rMM1) xOFS8(8)
                xADD_rm_imm     (rmREG(rEDI),16)
                dwCount -= 16;
            }

            while (dwCount >= 8)
            {
                xMOV_r_rm    (rEAX,rmIND(rESI))
                xMOV_r_rm    (rECX,rmIND8(rESI)) xOFS8(4)
                xADD_rm_imm  (rmREG(rESI),8)
                xMOV_rm_r    (rmIND(rEDI),rEAX)
                xADD_rm_imm  (rmREG(rEDI),8)
                xMOV_rm_r    (rmIND8(rEDI),rECX) xOFS8(4 - 8)
                dwCount -= 8;
            }

            while (dwCount >= 4)
            {
                xMOV_r_rm    (rEAX,rmIND(rESI))
                xADD_rm_imm  (rmREG(rESI),4)
                xMOV_rm_r    (rmIND(rEDI),rEAX)
                xADD_rm_imm  (rmREG(rEDI),4)
                dwCount -= 4;
            }

            if (dwCount)
            {
                xMOV_rm_imm (rmREG(rECX),dwCount)
                xREP xMOVSB
            }

            if (needFemms)
            {
                xFEMMS
            }

        }
        else
        {
            //
            // normal 8086 copy
            //
            DWORD dwWordCount = dwCount / 4;
            if (dwWordCount)
            {
                xMOV_rm_imm (rmREG(rECX),dwWordCount)
                xREP xMOVSD
            }
            dwCount &= 3;
            if (dwCount)
            {
                xMOV_rm_imm (rmREG(rECX),dwCount)
                xREP xMOVSB
            }
        }
    }
    else
    {
        // variable length copy
        if ((pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_KATMAI) || (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_ATHLON))
        {
            bool needFemms = false;
            if (dwCount >= 16 && !recurse)
            {
                xFEMMS
                needFemms = true;
            }

            //
            // kni copy
            //
            DWORD label1;
            DWORD label2;
            // 64 byte xfers
            xLABEL      (label2)
            xCMP_rm_imm (rmREG(rECX),64)
            xLABEL      (label1)
            xJL32       (0)
            xPUSH_r     (rECX)
            nvKelvinILCompile_memcpy (64, true);
            xPOP_r      (rECX)
            xLEA_r_rm   (rECX,rmIND8(rECX)) xOFS8(-64)
            xJMP        (label2)
            xTARGET_b32 (label1)
            // 16 byte xfers
            xLABEL      (label2)
            xCMP_rm_imm (rmREG(rECX),16)
            xLABEL      (label1)
            xJL32       (0)
            xPUSH_r     (rECX)
            nvKelvinILCompile_memcpy (16, true);
            xPOP_r      (rECX)
            xLEA_r_rm   (rECX,rmIND8(rECX)) xOFS8(-16)
            xJMP        (label2)
            xTARGET_b32 (label1)
            // the rest
            xMOV_r_rm   (rEAX,rmREG(rECX))
            xSHR_rm_imm8(rmREG(rECX),2)
            xAND_rm_imm (rmREG(rEAX),3)
            xREP xMOVSD
            xMOV_r_rm   (rECX,rmREG(rEAX))
            xREP xMOVSB

            if (needFemms)
            {
                xFEMMS
            }
        }
        else
        {
            //
            // normal 8086 copy
            //
            xMOV_r_rm   (rEAX,rmREG(rECX))
            xSHR_rm_imm8(rmREG(rECX),2)
            xAND_rm_imm (rmREG(rEAX),3)
            xREP xMOVSD
            xMOV_r_rm   (rECX,rmREG(rEAX))
            xREP xMOVSB
        }
    }
}

// adds a base vertex index (16bit) to all 16bit chunks
// copies dwCount bytes from [esi] to [edi] with increment. if dwCount is zero then we copy ecx bytes
// we use esi,edi,eax and ecx. for kni we also use xmm0 to xmm3
void nvKelvinILCompile_indexcpy
(
    DWORD dwCount
)
{
    if (dwCount)
    {
        // do copy
        if (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_WILLAMETTE)
        {
            //
            // WNI copy
            //
            xMOV_r_i32      (rECX,mMEM32(global.kelvin.dwBaseVertex))
            xSHL_rm_imm8    (rmREG(rECX),16)
            xOR_r_i32       (rECX,mMEM32(global.kelvin.dwBaseVertex))
            xMOVDX_r_rm      (rXMM4, rmREG(rECX))
            xPSHUFLW_r_rm_imm (rXMM4, rmREG(rXMM4), 0)
            xPUNPCKLWDX_r_rm (rXMM4, rmREG(rXMM4))

            while (dwCount >= 64)
            {
                xMOVLPS_r_rm    (rXMM0,rmIND(rESI))
                xMOVHPS_r_rm    (rXMM0,rmIND8(rESI)) xOFS8(8)
                xPADDWX_r_rm    (rXMM0, rmREG(rXMM4))
                xMOVLPS_r_rm    (rXMM1,rmIND8(rESI)) xOFS8(16)
                xMOVHPS_r_rm    (rXMM1,rmIND8(rESI)) xOFS8(24)
                xPADDWX_r_rm    (rXMM1, rmREG(rXMM4))
                xMOVLPS_r_rm    (rXMM2,rmIND8(rESI)) xOFS8(32)
                xMOVHPS_r_rm    (rXMM2,rmIND8(rESI)) xOFS8(40)
                xPADDWX_r_rm    (rXMM2, rmREG(rXMM4))
                xMOVLPS_r_rm    (rXMM3,rmIND8(rESI)) xOFS8(48)
                xMOVHPS_r_rm    (rXMM3,rmIND8(rESI)) xOFS8(56)
                xPADDWX_r_rm    (rXMM3, rmREG(rXMM4))
                xADD_rm_imm     (rmREG(rESI),64)
                xMOVLPS_rm_r    (rmIND(rEDI),rXMM0)
                xMOVHPS_rm_r    (rmIND8(rEDI),rXMM0) xOFS8(8)
                xMOVLPS_rm_r    (rmIND8(rEDI),rXMM1) xOFS8(16)
                xMOVHPS_rm_r    (rmIND8(rEDI),rXMM1) xOFS8(24)
                xMOVLPS_rm_r    (rmIND8(rEDI),rXMM2) xOFS8(32)
                xMOVHPS_rm_r    (rmIND8(rEDI),rXMM2) xOFS8(40)
                xMOVLPS_rm_r    (rmIND8(rEDI),rXMM3) xOFS8(48)
                xMOVHPS_rm_r    (rmIND8(rEDI),rXMM3) xOFS8(56)
                xADD_rm_imm     (rmREG(rEDI),64)
                dwCount -= 64;
            }

            while (dwCount >= 16)
            {
                xMOVLPS_r_rm    (rXMM0,rmIND(rESI))
                xMOVHPS_r_rm    (rXMM0,rmIND8(rESI)) xOFS8(8)
                xPADDWX_r_rm    (rXMM0, rmREG(rXMM4))
                xADD_rm_imm     (rmREG(rESI),16)
                xMOVLPS_rm_r    (rmIND(rEDI),rXMM0)
                xMOVHPS_rm_r    (rmIND8(rEDI),rXMM0) xOFS8(8)
                xADD_rm_imm     (rmREG(rEDI),16)
                dwCount -= 16;
            }
        }
        else if (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_KATMAI)
        {
            //
            // KNI copy - we use MMX because there's no integer add for KNI regs.
            //
            xEMMS
            xMOV_r_i32      (rECX,mMEM32(global.kelvin.dwBaseVertex))
            xSHL_rm_imm8    (rmREG(rECX),16)
            xOR_r_i32       (rECX,mMEM32(global.kelvin.dwBaseVertex))
            xMOVD_r_rm      (rMM4, rmREG(rECX))
            xPSHUFW_r_rm_imm (rMM4, rmREG(rMM4), 0)
            while (dwCount >= 64)
            {

                xMOVQ_r_rm      (rMM0,rmIND(rESI))
                xPADDW_r_rm     (rMM0, rmREG(rMM4))
                xMOVQ_r_rm      (rMM1,rmIND8(rESI)) xOFS8(8)
                xPADDW_r_rm     (rMM1, rmREG(rMM4))
                xMOVQ_r_rm      (rMM2,rmIND8(rESI)) xOFS8(16)
                xPADDW_r_rm     (rMM2, rmREG(rMM4))
                xMOVQ_r_rm      (rMM3,rmIND8(rESI)) xOFS8(24)
                xPADDW_r_rm     (rMM3, rmREG(rMM4))

                xMOVNTQ_rm_r    (rmIND(rEDI),rMM0)
                xMOVNTQ_rm_r    (rmIND8(rEDI),rMM1) xOFS8(8)
                xMOVNTQ_rm_r    (rmIND8(rEDI),rMM2) xOFS8(16)
                xMOVNTQ_rm_r    (rmIND8(rEDI),rMM3) xOFS8(24)

                xMOVQ_r_rm      (rMM0,rmIND8(rESI)) xOFS8(32)
                xPADDW_r_rm     (rMM0, rmREG(rMM4))
                xMOVQ_r_rm      (rMM1,rmIND8(rESI)) xOFS8(40)
                xPADDW_r_rm     (rMM1, rmREG(rMM4))
                xMOVQ_r_rm      (rMM2,rmIND8(rESI)) xOFS8(48)
                xPADDW_r_rm     (rMM2, rmREG(rMM4))
                xMOVQ_r_rm      (rMM3,rmIND8(rESI)) xOFS8(56)
                xPADDW_r_rm     (rMM3, rmREG(rMM4))

                xADD_rm_imm     (rmREG(rESI),64)


                xMOVNTQ_rm_r    (rmIND8(rEDI),rMM0) xOFS8(32)
                xMOVNTQ_rm_r    (rmIND8(rEDI),rMM1) xOFS8(40)
                xMOVNTQ_rm_r    (rmIND8(rEDI),rMM2) xOFS8(48)
                xMOVNTQ_rm_r    (rmIND8(rEDI),rMM3) xOFS8(56)
                xADD_rm_imm     (rmREG(rEDI),64)


                dwCount -= 64;
            }

            while (dwCount >= 16)
            {
                xMOVQ_r_rm      (rMM0,rmIND(rESI))
                xPADDW_r_rm     (rMM0, rmREG(rMM4))
                xMOVQ_r_rm      (rMM1,rmIND8(rESI)) xOFS8(8)
                xPADDW_r_rm     (rMM1, rmREG(rMM4))
                xADD_rm_imm     (rmREG(rESI),16)
                xMOVNTQ_rm_r    (rmIND(rEDI),rMM0)
                xMOVNTQ_rm_r    (rmIND8(rEDI),rMM1) xOFS8(8)
                xADD_rm_imm     (rmREG(rEDI),16)
                dwCount -= 16;
            }
            xEMMS

        }
        else if (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_ATHLON)
        {
            //
            // AMD copy
            //
            xFEMMS
            xMOV_r_i32      (rECX,mMEM32(global.kelvin.dwBaseVertex))
            xSHL_rm_imm8    (rmREG(rECX),16)
            xOR_r_i32       (rECX,mMEM32(global.kelvin.dwBaseVertex))
            xMOVD_r_rm      (rMM4, rmREG(rECX))
            xPUNPCKLDQ_r_rm (rMM4, rmREG(rMM4))
            while (dwCount >= 64)
            {
                xMOVQ_r_rm      (rMM0,rmIND(rESI))
                xPADDW_r_rm     (rMM0, rmREG(rMM4))
                xMOVQ_r_rm      (rMM1,rmIND8(rESI)) xOFS8(8)
                xPADDW_r_rm     (rMM1, rmREG(rMM4))
                xMOVQ_r_rm      (rMM2,rmIND8(rESI)) xOFS8(16)
                xPADDW_r_rm     (rMM2, rmREG(rMM4))
                xMOVQ_r_rm      (rMM3,rmIND8(rESI)) xOFS8(24)
                xPADDW_r_rm     (rMM3, rmREG(rMM4))

                xMOVNTQ_rm_r    (rmIND(rEDI),rMM0)
                xMOVNTQ_rm_r    (rmIND8(rEDI),rMM1) xOFS8(8)
                xMOVNTQ_rm_r    (rmIND8(rEDI),rMM2) xOFS8(16)
                xMOVNTQ_rm_r    (rmIND8(rEDI),rMM3) xOFS8(24)

                xMOVQ_r_rm      (rMM0,rmIND8(rESI)) xOFS8(32)
                xPADDW_r_rm     (rMM0, rmREG(rMM4))
                xMOVQ_r_rm      (rMM1,rmIND8(rESI)) xOFS8(40)
                xPADDW_r_rm     (rMM1, rmREG(rMM4))
                xMOVQ_r_rm      (rMM2,rmIND8(rESI)) xOFS8(48)
                xPADDW_r_rm     (rMM2, rmREG(rMM4))
                xMOVQ_r_rm      (rMM3,rmIND8(rESI)) xOFS8(56)
                xPADDW_r_rm     (rMM3, rmREG(rMM4))

                xADD_rm_imm     (rmREG(rESI),64)


                xMOVNTQ_rm_r    (rmIND8(rEDI),rMM0) xOFS8(32)
                xMOVNTQ_rm_r    (rmIND8(rEDI),rMM1) xOFS8(40)
                xMOVNTQ_rm_r    (rmIND8(rEDI),rMM2) xOFS8(48)
                xMOVNTQ_rm_r    (rmIND8(rEDI),rMM3) xOFS8(56)
                xADD_rm_imm     (rmREG(rEDI),64)


                dwCount -= 64;
            }

            while (dwCount >= 16)
            {
                xMOVQ_r_rm      (rMM0,rmIND(rESI))
                xPADDW_r_rm     (rMM0, rmREG(rMM4))
                xMOVQ_r_rm      (rMM1,rmIND8(rESI)) xOFS8(8)
                xPADDW_r_rm     (rMM1, rmREG(rMM4))
                xADD_rm_imm     (rmREG(rESI),16)
                xMOVNTQ_rm_r    (rmIND(rEDI),rMM0)
                xMOVNTQ_rm_r    (rmIND8(rEDI),rMM1) xOFS8(8)
                xADD_rm_imm     (rmREG(rEDI),16)
                dwCount -= 16;
            }
            xFEMMS
        }
        if (dwCount)
        {
            //
            // normal 8086 copy
            //
            DWORD label;
            xLABEL (label)


            xMOV_r_i32  (rECX,mMEM32(global.kelvin.dwBaseVertex))
            xSHL_rm_imm8 (rmREG(rECX),16)
            xOR_r_i32   (rECX,mMEM32(global.kelvin.dwBaseVertex))
            //hmmm fully unrolled loop might not be the best... HMH
            //never mind, 64 indices is max (aka 32 moves)
            while (dwCount >= 4)
            {
                xMOV_r_rm    (rEAX,rmIND(rESI))
                xADD_rm_imm  (rmREG(rESI),4)
                xADD_r_rm    (rEAX, rmREG(rECX)) //add base index
                xMOV_rm_r    (rmIND(rEDI),rEAX)
                xADD_rm_imm  (rmREG(rEDI),4)
                dwCount -= 4;

            }
            if (dwCount) //it had better be 2
            {
                x16r xMOV_r_rm (rAX,rmIND(rESI))
                xADD_rm_imm  (rmREG(rESI),2)
                xADD_r_rm    (rEAX, rmREG(rECX)) //add base index
                xMOV_rm_r    (rmIND(rEDI),rAX)
                xADD_rm_imm  (rmREG(rEDI),2)
                dwCount -= 2;
            }
        }
    }
}


// vertex at ESI, pusher at EDI
//  thrashes eax,ebx,ecx,edx and ebp
void nvKelvinILCompile_copyVertex
(
    PNVD3DCONTEXT pContext,
    DWORD         dwFlags
)
{
    CVertexShader *pVShader;

    const DWORD    adwRegister[]        = { rEAX,rEBX,rECX,rEDX,rEBP };
    DWORD          dwDstIndex           = 0;
    DWORD          dwInlineVertexStride = pContext->hwState.dwInlineVertexStride;

    // cache the vertex shader
    pVShader = pContext->hwState.pVertexShader;
    nvAssert (pVShader);

    // rd: method
    xMOV_rm_imm (rmREG(rEAX),(((dwInlineVertexStride) << 16) | ((NV_DD_KELVIN) << 13) | (NVPUSHER_NOINC(NV097_INLINE_ARRAY))))

    // wr: method
    xMOV_rm_r   (rmIND(rEDI),rEAX)
    dwDstIndex += 4;

    nvAssert (pVShader->bVAExists(defaultInputRegMap[D3DVSDE_POSITION]));

    // rd: xyz
    xMOV_r_rm   (rECX,rmIND8(rESI)) xOFS8(global.kelvin.dwOffsetXYZ)
    xMOV_r_rm   (rEDX,rmIND8(rESI)) xOFS8(global.kelvin.dwOffsetXYZ + 4)
    xMOV_r_rm   (rEBP,rmIND8(rESI)) xOFS8(global.kelvin.dwOffsetXYZ + 8)

    // wr: xyz
    xMOV_rm_r   (rmIND8(rEDI),rECX) xOFS8(dwDstIndex)
    xMOV_rm_r   (rmIND8(rEDI),rEDX) xOFS8(dwDstIndex + 4)
    xMOV_rm_r   (rmIND8(rEDI),rEBP) xOFS8(dwDstIndex + 8)
    dwDstIndex += 12;

    // rd & wr: rhw
    if (pVShader->getVASize(defaultInputRegMap[D3DVSDE_POSITION]) == 4*sizeof(DWORD))
    {
        xMOV_r_rm   (rEAX,rmIND8(rESI)) xOFS8(global.kelvin.dwOffsetRHW)
        xMOV_rm_r   (rmIND8(rEDI),rEAX) xOFS8(dwDstIndex)
        dwDstIndex += 4;
    }

    // rd & wr: blend weights
    if (pVShader->bVAExists(defaultInputRegMap[D3DVSDE_BLENDWEIGHT]))
    {
        DWORD dwNumWeights = pVShader->getVASize(defaultInputRegMap[D3DVSDE_BLENDWEIGHT]) >> 2;
        for (DWORD i=0; i<dwNumWeights; i++) {
            xMOV_r_rm   (rEBX,rmIND8(rESI)) xOFS8(global.kelvin.dwOffsetWeight + 4*i)
            xMOV_rm_r   (rmIND8(rEDI),rEBX) xOFS8(dwDstIndex)
            dwDstIndex += 4;
        }
    }

    // rd & wr: normal
    if (pVShader->bVAExists(defaultInputRegMap[D3DVSDE_NORMAL]))
    {
        xMOV_r_rm   (rECX,rmIND8(rESI)) xOFS8(global.kelvin.dwOffsetNormal)
        xMOV_r_rm   (rEDX,rmIND8(rESI)) xOFS8(global.kelvin.dwOffsetNormal + 4)
        xMOV_r_rm   (rEBP,rmIND8(rESI)) xOFS8(global.kelvin.dwOffsetNormal + 8)
        xMOV_rm_r   (rmIND8(rEDI),rECX) xOFS8(dwDstIndex)
        xMOV_rm_r   (rmIND8(rEDI),rEDX) xOFS8(dwDstIndex + 4)
        xMOV_rm_r   (rmIND8(rEDI),rEBP) xOFS8(dwDstIndex + 8)
        dwDstIndex += 12;
    }

    // rd: diffuse
    if (pVShader->bVAExists(defaultInputRegMap[D3DVSDE_DIFFUSE]))
    {
        xMOV_r_rm   (rEAX,rmIND8(rESI)) xOFS8(global.kelvin.dwOffsetDiffuse)
    }

    // rd: specular
    if (pVShader->bVAExists(defaultInputRegMap[D3DVSDE_SPECULAR]))
    {
        xMOV_r_rm   (rEBX,rmIND8(rESI)) xOFS8(global.kelvin.dwOffsetSpecular)
    }

    // rd: point size
    if (pVShader->bVAExists(defaultInputRegMap[D3DVSDE_PSIZE]))
    {
        xMOV_r_rm   (rECX,rmIND8(rESI)) xOFS8(global.kelvin.dwOffsetPointSize)
    }

    // wr: diffuse
    if (pVShader->bVAExists(defaultInputRegMap[D3DVSDE_DIFFUSE]))
    {
        xMOV_rm_r   (rmIND8(rEDI),rEAX) xOFS8(dwDstIndex)
        dwDstIndex += 4;
    }

    // wr: specular
    if (pVShader->bVAExists(defaultInputRegMap[D3DVSDE_SPECULAR]))
    {
        xMOV_rm_r   (rmIND8(rEDI),rEBX) xOFS8(dwDstIndex)
        dwDstIndex += 4;
    }

    // wr: point size
    if (pVShader->bVAExists(defaultInputRegMap[D3DVSDE_PSIZE]))
    {
        xMOV_rm_r   (rmIND8(rEDI),rECX) xOFS8(dwDstIndex)
        dwDstIndex += 4;
    }

    for (DWORD dwHWStage = 0; dwHWStage < KELVIN_NUM_TEXTURES; dwHWStage++)
    {
        if (pContext->hwState.dwStateFlags & KELVIN_FLAG_USERTEXCOORDSNEEDED(dwHWStage))
        {
            DWORD dwD3DStage = pContext->hwState.dwTexUnitToTexStageMapping[dwHWStage];
            DWORD dwTCIndex  = (pContext->hwState.dwTexCoordIndices >> (8*dwHWStage)) & 0xff;  // BUGBUG?? are these indices even relevant in DX8?
            DWORD dwVAIndex  = defaultInputRegMap[D3DVSDE_TEXCOORD0+dwTCIndex];
            DWORD dwCount    = ((pVShader->getVASize (dwVAIndex)) >> 2);
            assert (dwCount < 5);
            {
                for (DWORD i = 0; i < dwCount; i++)
                {
                    xMOV_r_rm   (adwRegister[i],rmIND8(rESI)) xOFS8(i * 4 + global.kelvin.dwOffsetUV[dwTCIndex])
                }

#ifdef STOMP_TEX_COORDS
                if (pContext->hwState.dwStateFlags & KELVIN_FLAG_STOMP_4TH_COORD(dwHWStage))
                {
                    xMOV_r_imm  (adwRegister[3],0x3f800000)
                }
#endif  // STOMP_TEX_COORDS

                for (DWORD k = 0; k < dwCount; k++)
                {
                    xMOV_rm_r   (rmIND8(rEDI),adwRegister[k]) xOFS8(dwDstIndex)
                    dwDstIndex += 4;
                }
            }
        }
    }

    // sanity check
    assert ((dwDstIndex - 4) == dwInlineVertexStride);

    // we can optionally print the vertex here
#if defined(DEBUG) || defined(NVSTATDRIVER)
    xMOV_rm_imm (rmREG(rEAX),(DWORD)nvKelvinDispatchPrintVertex)
    xMOV_r_i32  (rEBX,mMEM32(global.kelvin.pContext))
    xPUSH_r     (rEDI)
    xPUSH_r     (rEBX)
    xCALL_rm    (rmREG(rEAX))
#endif

    // adjust put
    xLEA_r_rm   (rEDI,rmIND8(rEDI)) xOFS8(dwDstIndex)
}

//
// range limit <only on NT> (dummy must be eax, ebx, ecx or edx)
//
void nvKelvinILCompile_limit
(
    DWORD regLimit,
    DWORD regDummy
)
{
    assert ((regDummy == rEAX)
         || (regDummy == rEBX)
         || (regDummy == rECX)
         || (regDummy == rEDX));

#ifdef WINNT
    xXOR_r_rm   (regDummy,rmREG(regDummy))
    xCMP_r_i32  (regLimit,mMEM32(global.dwMaxVertexOffset))
    xSETAE_rm8  (rmREG(regDummy))
    xDEC_rm     (rmREG(regDummy))
    xAND_r_rm   (regLimit,rmREG(regDummy))
#endif
}



// prefetch data
//  will trash ESI, ECX, EDX, EAX
void nvKelvinILCompile_prefetch
(
    BOOL bIsIndexed,
    BOOL bLegacyStrides
)
{
    if (bIsIndexed)
    {
        // prefetch & range check indices
        DWORD labelPrefetch1;
        DWORD labelPrefetch2;
        DWORD labelPrefetch3;
        DWORD labelPrefetch4;
        xLABEL      (labelPrefetch1)
        xMOV_r_i32  (rESI,mMEM32(global.kelvin.dwPrefetchBase))
        xCMP_r_i32  (rESI,mMEM32(global.kelvin.pIndices))
        xLABEL      (labelPrefetch2)
        xJA32       (0)

        xMOV_rm_imm (rmREG(rECX),2048 / global.kelvin.dwVertexStride)
        xLABEL      (labelPrefetch4)
        {
            xPUSH_r     (rECX)
            // read index
            xXOR_r_rm   (rEDX,rmREG(rEDX))
       x16r xMOV_r_rm   (rDX,rmIND(rESI))
            xLEA_r_rm   (rESI,rmIND8(rESI)) xOFS8(2)
            if (bLegacyStrides)
            {
                xMOV_r_rm   (rEAX,rmREG(rESI))
                xSUB_r_i32  (rEAX,mMEM32(global.kelvin.pIndexBase))
                xAND_rm_imm (rmREG(rEAX),6)
                xXOR_r_rm   (rECX,rmREG(rECX))
                xCMP_rm_imm (rmREG(rEAX),6)
                xSETNZ_rm8  (rmREG(rCL))
                xDEC_rm     (rmREG(rECX))
                xAND_rm_imm (rmREG(rECX),2)
                xADD_r_rm   (rESI,rmREG(rECX))
            }
            ILCCompile_mul (rEDX,global.kelvin.dwVertexStride);
            // range limit
            nvKelvinILCompile_limit (rEDX,rECX);
            // compute vertex address
            xADD_r_i32  (rEDX,mMEM32(global.kelvin.pVertices))
            // prefetch
            xMOV_r_rm   (rEAX,rmIND(rEDX))
            if (global.kelvin.dwVertexStride > 32)
            {
                xMOV_r_rm   (rEAX,rmIND8(rEDX)) xOFS8(32)
            }
            xMOV_rm_imm (rmREG(rEAX),0)
            // end of valid run?
            xPOP_r      (rECX)
            xCMP_r_i32  (rESI,mMEM32(global.kelvin.dwPrefetchMax))
            xLABEL      (labelPrefetch3)
            xJAE32      (0)
            // next
            xDEC_rm     (rmREG(rECX))
        }
        xJNZ32      (labelPrefetch4)
        xTARGET_b32 (labelPrefetch3)
        xMOV_i32_r  (mMEM32(global.kelvin.dwPrefetchBase),rESI)
        xTARGET_b32 (labelPrefetch2)
    }
    else
    {
        // prefetch & range check indices
        DWORD labelPrefetch1;
        DWORD labelPrefetch2;
        DWORD labelPrefetch3;
        DWORD labelPrefetch4;
        xLABEL      (labelPrefetch1)
        xMOV_r_i32  (rESI,mMEM32(global.kelvin.dwPrefetchBase))
        xCMP_r_i32  (rESI,mMEM32(global.kelvin.pVertices))
        xLABEL      (labelPrefetch2)
        xJA32       (0)

        xMOV_rm_imm (rmREG(rECX),2048 / global.kelvin.dwVertexStride)
        xLABEL      (labelPrefetch4)
        {
            // prefetch
            xMOV_r_rm   (rEAX,rmIND(rESI))
            xMOV_rm_imm (rmREG(rEAX),0)
            xADD_rm_imm (rmREG(rESI),32)
            // end of valid run?
            xCMP_r_i32  (rESI,mMEM32(global.kelvin.dwPrefetchMax))
            xLABEL      (labelPrefetch3)
            xJAE32      (0)
            // next
            xDEC_rm     (rmREG(rECX))
        }
        xJNZ32      (labelPrefetch4)
        xTARGET_b32 (labelPrefetch3)
        xMOV_i32_r  (mMEM32(global.kelvin.dwPrefetchBase),rESI)
        xTARGET_b32 (labelPrefetch2)
    }
}

#endif KELVIN_ILC


#endif  // NVARCH == 0x20
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\kelvin\src\nvKelvinAlphaCombiners.cpp ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// ********************************* Direct 3D ******************************
//
//  Module: nvKelvinAlphaCombiners.cpp
//      routines for setting up the Kelvin alpha combiners from
//      DX6-style texture stages
//
// **************************************************************************
//
//  History:
//      Craig Duttweiler        29Mar00         NV20 development
//
// **************************************************************************
#include "nvprecomp.h"

#if (NVARCH >= 0x20)

//---------------------------------------------------------------------------

// Set an alpha input to to 1 or -1

void nvKelvinACSetAlphaInputOne (PNVD3DCONTEXT pContext, kelvinCombinerInput eInput,
                                 DWORD dwCombinerStage, BOOL bNegate)
{
    DWORD dwICW = 0;

    dwICW |= bNegate ? DRF_DEF (097, _SET_COMBINER_ALPHA, _ICW_D_MAP, _EXPAND_NORMAL) :
                       DRF_DEF (097, _SET_COMBINER_ALPHA, _ICW_D_MAP, _UNSIGNED_INVERT);

    dwICW |= DRF_DEF (097, _SET_COMBINER_ALPHA, _ICW_D_ALPHA, _FALSE);
    dwICW |= DRF_DEF (097, _SET_COMBINER_ALPHA, _ICW_D_SOURCE, _REG_0);

    pContext->hwState.dwAlphaICW[dwCombinerStage] |= (dwICW << kelvinCombinerInputShift[eInput]);
}

//---------------------------------------------------------------------------

// Select the source for combiner input eInput in combiner stage
// dwCombinerStage from argument dwD3DTSSArg in D3D stage dwD3DStage.
// return TSS_USES_NULL_TEXTURE if we reference a texture we don't have

HRESULT nvKelvinACSelectAlphaInput (PNVD3DCONTEXT pContext, kelvinCombinerInput eInput,
                                    DWORD dwCombinerStage, DWORD dwD3DStage, DWORD dwD3DTSSArg,
                                    BOOL bComplement, BOOL bExpandNormal)
{
    DWORD dwICW = 0;
    DWORD dwCurrentUsed =FALSE;
    int i;

    switch (pContext->tssState[dwD3DStage].dwValue[dwD3DTSSArg] & D3DTA_SELECTMASK) {
        case D3DTA_CURRENT:
            if (dwD3DStage != 0)
            {
                for (i=dwD3DStage - 1;i>=0;i--)
                {
                    if (pContext->tssState[i].dwValue[D3DTSS_RESULTARG] != D3DTA_TEMP)
                    {
                        dwCurrentUsed=TRUE;
                        break;
                    }
                }
            
            }
            if (dwCurrentUsed == TRUE) {
                // Output from previous stage
                dwICW |= DRF_DEF (097, _SET_COMBINER_ALPHA, _ICW_D_SOURCE, _REG_C);
                break;
            }
            // else, default to diffuse below
        case D3DTA_DIFFUSE:
            dwICW |= DRF_DEF (097, _SET_COMBINER_ALPHA, _ICW_D_SOURCE, _REG_4);
            break;
        case D3DTA_TEXTURE:
            if (!(pContext->tssState[dwD3DStage].dwValue[D3DTSS_TEXTUREMAP])) {
                // if we don't actually have a texture, default to the 'current' alpha.
                // yes, this is actually the d3d default: select texture with no texture.
                // my mama done told me, my name was duh microsoft.
                return (TSS_USES_NULL_TEXTURE);
            }
            else {
                if (pContext->hwState.dwNextAvailableTextureUnit < KELVIN_NUM_TEXTURES) {
                    pContext->hwState.dwTexUnitToTexStageMapping[pContext->hwState.dwNextAvailableTextureUnit] = dwD3DStage;
                    dwICW |= DRF_NUM (097, _SET_COMBINER_ALPHA, _ICW_D_SOURCE, KELVIN_COMBINER_REG_TEX0 + pContext->hwState.dwNextAvailableTextureUnit);
                }
                else {
                    pContext->hwState.dwStateFlags |= KELVIN_FLAG_SETUPFAILURE;
                    dwICW |= DRF_DEF (097, _SET_COMBINER_ALPHA, _ICW_D_SOURCE, _REG_0);
                }
            }
            break;
        case D3DTA_TFACTOR:
            dwICW |= DRF_DEF (097, _SET_COMBINER_ALPHA, _ICW_D_SOURCE, _REG_1);
            break;
        case D3DTA_TEMP:
            dwICW |= DRF_DEF(097, _SET_COMBINER_ALPHA, _ICW_D_SOURCE, _REG_D);
            break;
        case D3DTA_SPECULAR:
            dwICW |= DRF_DEF (097, _SET_COMBINER_COLOR, _ICW_D_SOURCE, _REG_5);
            pContext->hwState.dwStateFlags |= KELVIN_FLAG_COMBINERSNEEDSPECULAR;
            DPF ("Specular Alpha doesn't exist in Kelvin, rendering corruption will result.",
                 pContext->tssState[dwD3DStage].dwValue[dwD3DTSSArg] & D3DTA_SELECTMASK);
            dbgD3DError();
            pContext->hwState.dwStateFlags |= KELVIN_FLAG_SETUPFAILURE;
            break;
        default:
            DPF ("unknown / illegal alpha argument '%d' in nvKelvinACSelectAlphaInput",
                 pContext->tssState[dwD3DStage].dwValue[dwD3DTSSArg] & D3DTA_SELECTMASK);
            dbgD3DError();
            pContext->hwState.dwStateFlags |= KELVIN_FLAG_SETUPFAILURE;
            break;
    }

    // handle the alpha replicate and complement flags

    dwICW |= DRF_DEF (097, _SET_COMBINER_ALPHA, _ICW_D_ALPHA, _TRUE);

    bComplement = ((pContext->tssState[dwD3DStage].dwValue[dwD3DTSSArg] & D3DTA_COMPLEMENT) ^
                   ((bComplement) ? D3DTA_COMPLEMENT : 0))
                  ?
                  TRUE : FALSE;

    if (bExpandNormal) {
        dwICW |= bComplement ? DRF_DEF (097, _SET_COMBINER_ALPHA, _ICW_D_MAP, _EXPAND_NEGATE) :
                               DRF_DEF (097, _SET_COMBINER_ALPHA, _ICW_D_MAP, _EXPAND_NORMAL);
    }
    else {
        dwICW |= bComplement ? DRF_DEF (097, _SET_COMBINER_ALPHA, _ICW_D_MAP, _UNSIGNED_INVERT) :
                               DRF_DEF (097, _SET_COMBINER_ALPHA, _ICW_D_MAP, _UNSIGNED_IDENTITY);
    }

    pContext->hwState.dwAlphaICW[dwCombinerStage] |= (dwICW << kelvinCombinerInputShift[eInput]);
    return (0);
}

//---------------------------------------------------------------------------

// Select the input into A
static HRESULT nvKelvinACSelect1 (PNVD3DCONTEXT pContext, DWORD dwHWStage, DWORD dwD3DStage)
{
    HRESULT hr;
    // Make A input
    hr = nvKelvinACSelectAlphaInput (pContext, kelvinCombinerInputA, dwHWStage, dwD3DStage, D3DTSS_ALPHAARG1, FALSE, FALSE);
    // Make B 1
    nvKelvinACSetAlphaInputOne (pContext, kelvinCombinerInputB, dwHWStage, FALSE);
    // C & D default to zero
    return (hr);
}

//---------------------------------------------------------------------------

// Select the input into D
static HRESULT nvKelvinACSelect2 (PNVD3DCONTEXT pContext, DWORD dwHWStage, DWORD dwD3DStage)
{
    HRESULT hr;
    // Multiply D * 1
    nvKelvinACSetAlphaInputOne (pContext, kelvinCombinerInputC, dwHWStage, FALSE);
    hr = nvKelvinACSelectAlphaInput (pContext, kelvinCombinerInputD, dwHWStage, dwD3DStage, D3DTSS_ALPHAARG2, FALSE, FALSE);
    // A & B default to zero
    return (hr);
}

//---------------------------------------------------------------------------

static HRESULT nvKelvinACModulate (PNVD3DCONTEXT pContext, DWORD dwHWStage, DWORD dwD3DStage)
{
    HRESULT hr;
    // Multiply A * B
    hr  = nvKelvinACSelectAlphaInput (pContext, kelvinCombinerInputA, dwHWStage, dwD3DStage, D3DTSS_ALPHAARG1, FALSE, FALSE);
    hr |= nvKelvinACSelectAlphaInput (pContext, kelvinCombinerInputB, dwHWStage, dwD3DStage, D3DTSS_ALPHAARG2, FALSE, FALSE);
    // C & D default to zero
    return (hr);
}

//---------------------------------------------------------------------------

static HRESULT nvKelvinACAdd (PNVD3DCONTEXT pContext, DWORD dwHWStage, DWORD dwD3DStage)
{
    HRESULT hr;
    // Multiply A * 1
    hr = nvKelvinACSelectAlphaInput (pContext, kelvinCombinerInputA, dwHWStage, dwD3DStage, D3DTSS_ALPHAARG1, FALSE, FALSE);
    // Make B 1
    nvKelvinACSetAlphaInputOne (pContext, kelvinCombinerInputB, dwHWStage, FALSE);
    // Multiply D * 1
    nvKelvinACSetAlphaInputOne (pContext, kelvinCombinerInputC, dwHWStage, FALSE);
    hr |= nvKelvinACSelectAlphaInput (pContext, kelvinCombinerInputD, dwHWStage, dwD3DStage, D3DTSS_ALPHAARG2, FALSE, FALSE);
    // Implicit A + D
    return (hr);
}

//---------------------------------------------------------------------------

static HRESULT nvKelvinACSub (PNVD3DCONTEXT pContext, DWORD dwHWStage, DWORD dwD3DStage)
{
    HRESULT hr;
    // Multiply A * 1
    hr = nvKelvinACSelectAlphaInput (pContext, kelvinCombinerInputA, dwHWStage, dwD3DStage, D3DTSS_ALPHAARG1, FALSE, FALSE);
    nvKelvinACSetAlphaInputOne (pContext, kelvinCombinerInputB, dwHWStage, FALSE);
    // Multiply D * -1
    nvKelvinACSetAlphaInputOne (pContext, kelvinCombinerInputC, dwHWStage, TRUE);
    hr |= nvKelvinACSelectAlphaInput (pContext, kelvinCombinerInputD, dwHWStage, dwD3DStage, D3DTSS_ALPHAARG2, FALSE, FALSE);
    // Implicit A + -D
    return (hr);
}

//---------------------------------------------------------------------------

static HRESULT nvKelvinACAddSmooth (PNVD3DCONTEXT pContext,DWORD dwHWStage, DWORD dwD3DStage)
{
    HRESULT hr;
    // Multiply A * 1
    hr = nvKelvinACSelectAlphaInput (pContext, kelvinCombinerInputA, dwHWStage, dwD3DStage, D3DTSS_ALPHAARG1, FALSE, FALSE);
    nvKelvinACSetAlphaInputOne (pContext, kelvinCombinerInputB, dwHWStage, FALSE);
    // Make C: (1-arg1), make D: arg2
    hr |= nvKelvinACSelectAlphaInput (pContext, kelvinCombinerInputC, dwHWStage, dwD3DStage, D3DTSS_ALPHAARG1, TRUE, FALSE);
    hr |= nvKelvinACSelectAlphaInput (pContext, kelvinCombinerInputD, dwHWStage, dwD3DStage, D3DTSS_ALPHAARG2, FALSE, FALSE);
    return (hr);
}

//---------------------------------------------------------------------------

static HRESULT nvKelvinACBlendAlpha (PNVD3DCONTEXT pContext, DWORD dwHWStage, DWORD dwD3DStage, DWORD dwType)
{
    HRESULT hr;
    DWORD dwTemp;

    // Multiply A * B(alpha)
    hr = nvKelvinACSelectAlphaInput (pContext, kelvinCombinerInputA, dwHWStage, dwD3DStage, D3DTSS_ALPHAARG1, FALSE, FALSE);

    if (dwType == TEXTUREPM) { // this type defined by us
        // Make B 1 since texture is already pre-multiplied
        nvKelvinACSetAlphaInputOne (pContext, kelvinCombinerInputB, dwHWStage, FALSE);
        // set type again for making C (1-alpha) below
        dwType = D3DTA_TEXTURE;
    }
    else {
        // Make B alpha, appropriate type
        dwTemp = pContext->tssState[dwD3DStage].dwValue[D3DTSS_ALPHAARG2];
        pContext->tssState[dwD3DStage].dwValue[D3DTSS_ALPHAARG2] = dwType;
        hr |= nvKelvinACSelectAlphaInput (pContext, kelvinCombinerInputB, dwHWStage, dwD3DStage, D3DTSS_ALPHAARG2, FALSE, FALSE);
        // copy arg2 back
        pContext->tssState[dwD3DStage].dwValue[D3DTSS_ALPHAARG2] = dwTemp;
    }

    // Make C: 1-alpha, make D: arg2
    dwTemp = pContext->tssState[dwD3DStage].dwValue[D3DTSS_ALPHAARG1];
    pContext->tssState[dwD3DStage].dwValue[D3DTSS_ALPHAARG1] = dwType;
    hr |= nvKelvinACSelectAlphaInput (pContext, kelvinCombinerInputC, dwHWStage, dwD3DStage, D3DTSS_ALPHAARG1, TRUE, FALSE);
    // copy back to alphaarg1
    pContext->tssState[dwD3DStage].dwValue[D3DTSS_ALPHAARG1] = dwTemp;
    hr |= nvKelvinACSelectAlphaInput (pContext, kelvinCombinerInputD, dwHWStage, dwD3DStage, D3DTSS_ALPHAARG2, FALSE, FALSE);

    return (hr);
}

//---------------------------------------------------------------------------

// The way D3D does this, it essentially allows using texture from stage 1
// in stage1 twice.  D3D does not normally allow you to use a texture in
// stage 0 and stage1.  This way, D3D allows you to modulate in (effectively)
// stage 0 and then do whatever it is you are going to do in stage1.  The
// key is that we use the texture from stage1 (since there is really no texture
// in stage 0)
static HRESULT nvKelvinACPremodulate (PNVD3DCONTEXT pContext,DWORD dwHWStage, DWORD dwD3DStage)
{
    HRESULT hr;
    DWORD   dwTemp;

    DPF ("pre-modulation is totally broken right now");
    dbgD3DError();

    if (dwD3DStage == 0) {
        if(pContext->tssState[dwD3DStage+1].dwValue[D3DTSS_ALPHAOP] != D3DTOP_DISABLE){
            // make A: alphaArg1(0), make B: texture(1)
             hr = nvKelvinACSelectAlphaInput (pContext, kelvinCombinerInputA, dwHWStage, dwD3DStage, D3DTSS_ALPHAARG1, FALSE, FALSE);
             dwTemp = pContext->tssState[dwD3DStage].dwValue[D3DTSS_ALPHAARG2];
             pContext->tssState[dwD3DStage].dwValue[D3DTSS_ALPHAARG2] = D3DTA_TEXTURE;
             hr |= nvKelvinACSelectAlphaInput (pContext, kelvinCombinerInputB, dwHWStage, dwD3DStage, D3DTSS_ALPHAARG2, FALSE, FALSE);
             // copy back arg2
             pContext->tssState[dwD3DStage].dwValue[D3DTSS_ALPHAARG2] = dwTemp;
        }
        else{
            //asked to do premodulate on a single texture stage -- just pass down
            //the colorarg1
            hr = nvKelvinACSelectAlphaInput (pContext, kelvinCombinerInputA, dwHWStage, dwD3DStage, D3DTSS_ALPHAARG1, FALSE, FALSE);
            nvKelvinACSetAlphaInputOne (pContext, kelvinCombinerInputB, dwHWStage, FALSE);
        }

    }
    else { // well, right now we only handle two stages (we could compress these)
        // if pre-modulate is called in stage1, we could modulate with
        // texture from next stage. But, we'd have to handle settexture a bit
        // differently. For now, we'll just use selectarg1
        hr = nvKelvinACSelectAlphaInput (pContext, kelvinCombinerInputA, dwHWStage, dwD3DStage, D3DTSS_ALPHAARG1, FALSE, FALSE);
        nvKelvinACSetAlphaInputOne (pContext, kelvinCombinerInputB, dwHWStage, FALSE);
    }

    return (hr);
}

//---------------------------------------------------------------------------

static HRESULT nvKelvinACMultiplyAdd (PNVD3DCONTEXT pContext, int hdStage, int dxStage)
{
    HRESULT hr;

    // set A to arg1
    hr  = nvKelvinACSelectAlphaInput (pContext, kelvinCombinerInputA, hdStage, dxStage, D3DTSS_ALPHAARG0, FALSE, FALSE);
    //set B to 1
    nvKelvinACSetAlphaInputOne (pContext, kelvinCombinerInputB, hdStage, FALSE);
    // set C to arg2
    hr |= nvKelvinACSelectAlphaInput (pContext, kelvinCombinerInputC, hdStage, dxStage, D3DTSS_ALPHAARG1, FALSE, FALSE);
    //set D to arg3
    hr |= nvKelvinACSelectAlphaInput (pContext, kelvinCombinerInputD, hdStage, dxStage, D3DTSS_ALPHAARG2, FALSE, FALSE);

    return (hr);
}

//---------------------------------------------------------------------------

static HRESULT nvKelvinACLerp (PNVD3DCONTEXT pContext, int hdStage, int dxStage)
{
    HRESULT hr;

    // Multiply A * B
    hr  = nvKelvinACSelectAlphaInput (pContext, kelvinCombinerInputA, hdStage, dxStage, D3DTSS_ALPHAARG0, FALSE, FALSE);
    hr |= nvKelvinACSelectAlphaInput (pContext, kelvinCombinerInputB, hdStage, dxStage, D3DTSS_ALPHAARG1, FALSE, FALSE);
    //set C to 1 - arg1
    hr |= nvKelvinACSelectAlphaInput (pContext, kelvinCombinerInputC, hdStage, dxStage, D3DTSS_ALPHAARG0, TRUE, FALSE);
    //set D to arg3
    hr |= nvKelvinACSelectAlphaInput (pContext, kelvinCombinerInputD, hdStage, dxStage, D3DTSS_ALPHAARG2, FALSE, FALSE);

    return (hr);
}

//---------------------------------------------------------------------------

void nvConstructKelvinOutputAlphaCombiners (PNVD3DCONTEXT pContext, BOOL bEnable,
                                            DWORD dwHWStage, DWORD dwD3DStage,
                                            BOOL bBias, DWORD dwShift, BOOL bOutTemp)
{
    bOutTemp &= (dwD3DStage != 8);

    if ((!bEnable) ||
        (pContext->tssState[dwD3DStage].dwValue[D3DTSS_COLOROP] == D3DTOP_DOTPRODUCT3))
    {
        pContext->hwState.dwAlphaOCW[dwHWStage] |= (DRF_DEF (097, _SET_COMBINER_ALPHA, _OCW_SUM_DST, _REG_0)  |
                                                    DRF_DEF (097, _SET_COMBINER_ALPHA, _OCW_AB_DST, _REG_0)   |
                                                    DRF_DEF (097, _SET_COMBINER_ALPHA, _OCW_CD_DST, _REG_0));
        return;
    }

    // select bias operation
    switch (dwShift) {
        case 0:
            pContext->hwState.dwAlphaOCW[dwHWStage] |= bBias ?
                                                       DRF_DEF (097, _SET_COMBINER_ALPHA, _OCW_OPERATION, _NOSHIFT_BIAS) :
                                                       DRF_DEF (097, _SET_COMBINER_ALPHA, _OCW_OPERATION, _NOSHIFT);
            break;
        case 1:
            pContext->hwState.dwAlphaOCW[dwHWStage] |= bBias ?
                                                       DRF_DEF (097, _SET_COMBINER_ALPHA, _OCW_OPERATION, _SHIFTLEFTBY1_BIAS) :
                                                       DRF_DEF (097, _SET_COMBINER_ALPHA, _OCW_OPERATION, _SHIFTLEFTBY1);
            break;
        case 2:
            pContext->hwState.dwAlphaOCW[dwHWStage] |= bBias ?
                                                       // we can't shift by 2 and bias. do the best we can...
                                                       DRF_DEF (097, _SET_COMBINER_ALPHA, _OCW_OPERATION, _SHIFTLEFTBY1_BIAS) :
                                                       DRF_DEF (097, _SET_COMBINER_ALPHA, _OCW_OPERATION, _SHIFTLEFTBY2);
            break;
        default:
            DPF ("illegal shift in nvConstructKelvinOutputAlphaCombiners");
            dbgD3DError();
            break;
    }  // switch

    pContext->hwState.dwAlphaOCW[dwHWStage] |= (DRF_DEF (097, _SET_COMBINER_ALPHA, _OCW_MUX_ENABLE, _FALSE) |
                                                DRF_DEF (097, _SET_COMBINER_ALPHA, _OCW_AB_DST, _REG_0)     |
                                                DRF_DEF (097, _SET_COMBINER_ALPHA, _OCW_CD_DST, _REG_0));
    pContext->hwState.dwAlphaOCW[dwHWStage] |= bOutTemp ?
                                               DRF_DEF (097, _SET_COMBINER_ALPHA, _OCW_SUM_DST, _REG_D) :
                                               DRF_DEF (097, _SET_COMBINER_ALPHA, _OCW_SUM_DST, _REG_C);
}

//---------------------------------------------------------------------------

void nvConstructKelvinAlphaCombiners (PNVD3DCONTEXT pContext, DWORD dwHWStage, DWORD dwD3DStage, BOOL bStageActive)
{
    DWORD   dwShift;
    BOOL    bBias, bEnable;
    HRESULT hr = 0;

    dwShift = 0;
    bBias   = FALSE;
    bEnable = TRUE;

    pContext->hwState.dwAlphaICW[dwHWStage] = 0;
    pContext->hwState.dwAlphaOCW[dwHWStage] = 0;

    if (!bStageActive) {
        // colorop was set to disable
        if (dwHWStage == 0) { // only construct default for stage 0
            // Default is diffuse alpha, make A=diffuse alpha, B=1, C=D=0
            pContext->hwState.dwAlphaICW[dwHWStage] |= DRF_DEF (097, _SET_COMBINER_ALPHA, _ICW_A_SOURCE, _REG_4);
            pContext->hwState.dwAlphaICW[dwHWStage] |= DRF_DEF (097, _SET_COMBINER_ALPHA, _ICW_A_ALPHA, _TRUE);
            nvKelvinACSetAlphaInputOne (pContext, kelvinCombinerInputB, dwHWStage, FALSE);
        }
        else {
            bEnable = FALSE;
        }
    }

    else {

        switch (pContext->tssState[dwD3DStage].dwValue[D3DTSS_ALPHAOP]) {
            default:
            case D3DTOP_DOTPRODUCT3:
                // We treat dot3 like disable because it doesn't really matter.
                // if the colorop is also dot3, then alpha will be overwritten momentarily anyhow.
                // BUGBUG if the colorop is NOT dot3, what the heck does this even mean???
            case D3DTOP_DISABLE:
                if (dwHWStage == 0) { // only construct default for stage 0
                    // Default is diffuse alpha, make A=diffuse alpha, B=1, C=D=0
                    pContext->hwState.dwAlphaICW[dwHWStage] |= DRF_DEF (097, _SET_COMBINER_ALPHA, _ICW_A_SOURCE, _REG_4);
                    pContext->hwState.dwAlphaICW[dwHWStage] |= DRF_DEF (097, _SET_COMBINER_ALPHA, _ICW_A_ALPHA, _TRUE);
                    nvKelvinACSetAlphaInputOne (pContext, kelvinCombinerInputB, dwHWStage, FALSE);
                }
                else {
                    bEnable = FALSE;
                }
                break;
            case D3DTOP_SELECTARG1:
                hr = nvKelvinACSelect1 (pContext, dwHWStage, dwD3DStage);
                break;
            case D3DTOP_SELECTARG2:
                hr = nvKelvinACSelect2 (pContext, dwHWStage, dwD3DStage);
                break;
            case D3DTOP_MODULATE4X:
                dwShift++;
            case D3DTOP_MODULATE2X:
                dwShift++;
            case D3DTOP_MODULATE:
                hr = nvKelvinACModulate (pContext, dwHWStage, dwD3DStage);
                break;
            case D3DTOP_ADDSIGNED2X: // same as addsigned with following change
                dwShift = 1;
            case D3DTOP_ADDSIGNED:   // same as add with following change
                bBias = TRUE;
            case D3DTOP_ADD:
                hr = nvKelvinACAdd (pContext, dwHWStage, dwD3DStage);
                break;
            case D3DTOP_SUBTRACT:
                hr = nvKelvinACSub (pContext, dwHWStage, dwD3DStage);
                break;
            case D3DTOP_ADDSMOOTH:
                hr = nvKelvinACAddSmooth (pContext, dwHWStage, dwD3DStage);
                break;
            case D3DTOP_BLENDDIFFUSEALPHA:
                hr = nvKelvinACBlendAlpha (pContext, dwHWStage, dwD3DStage, D3DTA_DIFFUSE);
                break;
            case D3DTOP_BLENDTEXTUREALPHA:
                hr = nvKelvinACBlendAlpha (pContext, dwHWStage, dwD3DStage, D3DTA_TEXTURE);
                break;
            case D3DTOP_BLENDFACTORALPHA:
                hr = nvKelvinACBlendAlpha (pContext, dwHWStage, dwD3DStage, D3DTA_TFACTOR);
                break;
            case D3DTOP_BLENDTEXTUREALPHAPM:
                hr = nvKelvinACBlendAlpha (pContext,dwHWStage, dwD3DStage, TEXTUREPM);
                break;
            case D3DTOP_BLENDCURRENTALPHA:
                hr = nvKelvinACBlendAlpha (pContext, dwHWStage, dwD3DStage, D3DTA_CURRENT);
                break;
            case D3DTOP_PREMODULATE:
                hr = nvKelvinACPremodulate (pContext, dwHWStage, dwD3DStage);
                break;
// BUGBUG
#if 0
            case D3DTOP_ALPHAMODULATE:
                // This is the case where the old D3DRENDERSTATE_TEXTUREMAPBLEND was used with
                // the D3DTBLEND_MODULATE op because the dump translates this into TSS we define
                // a new op that properly handles D3DTBLEND_MODULATE
                // Alpha is obtained by the texture, if it has alpha otherwise it is obtained from
                // the vertex. The dump always sets arg1 to be texture and arg2 to be current
                if (statev.ptexture[0] && statev.ptexture[0]->sd.ddpfPixelFormat.dwRGBAlphaBitMask) {
                    nvKelvinACSelect1(dwHWStage);
                }
                else {
                    nvKelvinACSelect2(dwHWStage);
                }
                break;
#endif
            case D3DTOP_MULTIPLYADD:
                hr = nvKelvinACMultiplyAdd (pContext, dwHWStage, dwD3DStage);
                break;
            case D3DTOP_LERP:
                hr = nvKelvinACLerp (pContext, dwHWStage, dwD3DStage);
                break;
        }  // switch

    }

    if (hr == TSS_USES_NULL_TEXTURE) {
        // this stage references a non-existent texture. just set it back to "select current"
        if (dwHWStage == 0) {
            // current = diffuse in stage 0
            pContext->hwState.dwAlphaICW[dwHWStage] = DRF_DEF (097, _SET_COMBINER_ALPHA, _ICW_A_SOURCE, _REG_4) |
                                                          DRF_DEF (097, _SET_COMBINER_ALPHA, _ICW_A_ALPHA, _TRUE);
        }
        else {
            pContext->hwState.dwAlphaICW[dwHWStage] = DRF_DEF (097, _SET_COMBINER_ALPHA, _ICW_A_SOURCE, _REG_C) |
                                                          DRF_DEF (097, _SET_COMBINER_ALPHA, _ICW_A_ALPHA, _TRUE);
        }
        nvKelvinACSetAlphaInputOne (pContext, kelvinCombinerInputB, dwHWStage, FALSE);
    }

    nvConstructKelvinOutputAlphaCombiners (pContext, bEnable, dwHWStage, dwD3DStage, bBias, dwShift,
                                           pContext->tssState[dwD3DStage].dwValue[D3DTSS_RESULTARG] == D3DTA_TEMP);

}

#endif  // NVARCH == 0x20
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\kelvin\inc\nvKelvinTables.h ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// ********************************* Direct 3D ******************************
//
//  Module: nvKelvinTables.h
//      tables of values and constants related to the kelvin object
//
// **************************************************************************
//
//  History:
//       Craig Duttweiler        28Apr2000         NV20 development
//
// **************************************************************************

#ifndef _NVKELVINTABLES_H
#define _NVKELVINTABLES_H

#if (NVARCH >= 0x020)

// table for looking up pre-computed combiner settings for legacy texture blends
extern DWORD kelvinTextureBlendSettings[D3D_TBLEND_MAX+1][4];
extern DWORD kelvinTextureBlendDefault[4];

// table of dependencies between d3d renderstates and kelvin state
extern DWORD kelvinDirtyBitsFromRenderState[D3D_RENDERSTATE_MAX+1];

// table of dependencies between d3d texture stage states and kelvin state
extern DWORD kelvinDirtyBitsFromTextureStageState[D3D_TEXSTAGESTATE_MAX+1];

// table mapping dp2ops to the kelvin method values associated with them.
extern DWORD kelvinBeginEndOp[D3D_DP2OP_MAX+1];

// table mapping d3d vertex types to kelvin vertex sizes
extern DWORD kelvinVertexSize[8];

// table mapping d3d vertex types to kelvin vertex types
extern DWORD kelvinVertexType[8];

// table mapping dp2ops to the scale and bias required to calculate
// the number of vertices from the number of primitives.
extern DWORD kelvinPrimitiveToPrimitiveMagic[D3D_DP2OP_MAX+1];

// table for primitive names
#ifdef DEBUG
extern char* kelvinPrimitiveName[D3D_DP2OP_MAX+1];
#endif

#endif  // NVARCH >= 0x020

#endif  // _NVKELVINTABLES_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\kelvin\src\nvKelvinAA.cpp ===
/*
 * Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.
 *
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nvKelvinAA.cpp                                                    *
*     prototypes for aa routines                                            *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Scott Cutler                     11Oct2000   created                *
*                                                                           *
\***************************************************************************/
#include "nvprecomp.h"

#if (NVARCH >= 0x020)

#ifdef DEBUG_SURFACE_PLACEMENT
extern CSurfaceDebug csd;
#endif

//#define SCALED_IMAGE
//#define SUPERSAMPLE
#define AAFORCE_16_32
#define SUBDIVIDE_AA
//#define _16_BIT_FIX
//#define TEST_SUB

#define UPSAMPLE_SEMANTICS_FRAME_COUNT 5

#ifdef SUBDIVIDE_AA
#ifdef TEST_SUB
DWORD __stripsize = 768;
DWORD __swath = NV097_SET_SWATH_WIDTH_V_32;
#endif
#endif


extern HRESULT nvSetKelvinD3DDefaults(PNVD3DCONTEXT pContext);
__forceinline DWORD F2D(float f) { return *(DWORD *)&f; }

const char * CKelvinAAState::BufferTypeNames[] = {
    "BUFFER_SRT",
    "BUFFER_RT",
    "BUFFER_SZB",
    "BUFFER_ZB",
    "BUFFER_SCRATCH"
};

const char * CKelvinAAState::AccessTypeNames[] = {
    "ACCESS_READ",
    "ACCESS_WRITE",
    "ACCESS_WRITE_DISCARD"
};

const CKelvinAAState::MethodInfoStruct CKelvinAAState::MethodInfo[METHOD_MAX] = {
    { // METHOD_NONE
        false, 
        1.0,  0.0, 
        SIMPLEMETHOD_1X1, 
        DRF_DEF(097, _SET_SURFACE_FORMAT, _ANTI_ALIASING, _CENTER_1),        
        0,
        METHOD_NONE,
        METHOD_NONE
    }, { // METHOD_SUPERSAMPLE_2X_H                                                     
        false, 
        1.41, 0.0, 
        SIMPLEMETHOD_2X1, 
        DRF_DEF(097, _SET_SURFACE_FORMAT, _ANTI_ALIASING, _CENTER_1),        
        0,
        METHOD_SUPERSAMPLE_2X_H,
        METHOD_SUPERSAMPLE_2X_H
    }, { // METHOD_SUPERSAMPLE_2X_V                                                     
        false, 
        1.41, 0.0, 
        SIMPLEMETHOD_1X2, 
        DRF_DEF(097, _SET_SURFACE_FORMAT, _ANTI_ALIASING, _CENTER_1),        
        0,
        METHOD_SUPERSAMPLE_2X_V,
        METHOD_SUPERSAMPLE_2X_V
    }, { // METHOD_MULTISAMPLE_2X                                                     
        true,  
        0.0,  0.0, 
        SIMPLEMETHOD_2X1, 
        DRF_DEF(097, _SET_SURFACE_FORMAT, _ANTI_ALIASING, _CENTER_CORNER_2), 
        0,
        METHOD_MULTISAMPLE_2X,
        METHOD_SUPERSAMPLE_2X_V
    }, { // METHOD_MULTISAMPLE_2X_QUINCUNX                                                     
        true,  
        0.0,  0.0, 
        SIMPLEMETHOD_2X1, 
        DRF_DEF(097, _SET_SURFACE_FORMAT, _ANTI_ALIASING, _CENTER_CORNER_2), 
        NV097_SET_TEXTURE_FILTER_CONVOLUTION_KERNEL_QUINCUNX,
        METHOD_MULTISAMPLE_2X,
        METHOD_SUPERSAMPLE_2X_V
    }, { // METHOD_SUPERSAMPLE_4X_BIAS                                                     
        false, 
        2.0,  1.0, 
        SIMPLEMETHOD_2X2, 
        DRF_DEF(097, _SET_SURFACE_FORMAT, _ANTI_ALIASING, _CENTER_1),        
        0,
        METHOD_SUPERSAMPLE_4X_BIAS,
        METHOD_SUPERSAMPLE_4X_BIAS
    }, { // METHOD_SUPERSAMPLE_4X                                                     
        false, 
        2.0,  0.0, 
        SIMPLEMETHOD_2X2, 
        DRF_DEF(097, _SET_SURFACE_FORMAT, _ANTI_ALIASING, _CENTER_1),        
        0,
        METHOD_SUPERSAMPLE_4X,
        METHOD_SUPERSAMPLE_4X
    }, { // METHOD_SUPERSAMPLE_4X_GAUSSIAN                                                    
        false, 
        2.0,  0.0, 
        SIMPLEMETHOD_2X2, 
        DRF_DEF(097, _SET_SURFACE_FORMAT, _ANTI_ALIASING, _CENTER_1),        
        NV097_SET_TEXTURE_FILTER_CONVOLUTION_KERNEL_GAUSSIAN_3,
        METHOD_SUPERSAMPLE_4X,
        METHOD_SUPERSAMPLE_4X
    }, { // METHOD_MULTISAMPLE_4X                                                     
        true,
        0.0,  0.0,
        SIMPLEMETHOD_2X2,
        DRF_DEF(097, _SET_SURFACE_FORMAT, _ANTI_ALIASING, _SQUARE_OFFSET_4),
        0,
        METHOD_MULTISAMPLE_4X,
        METHOD_SUPERSAMPLE_4X
    }, { // METHOD_MULTISAMPLE_4X_GAUSSIAN                                                     
        true,  
        0.0,  0.0, 
        SIMPLEMETHOD_2X2, 
        DRF_DEF(097, _SET_SURFACE_FORMAT, _ANTI_ALIASING, _SQUARE_OFFSET_4), 
        NV097_SET_TEXTURE_FILTER_CONVOLUTION_KERNEL_GAUSSIAN_3,
        METHOD_MULTISAMPLE_4X,
        METHOD_SUPERSAMPLE_4X
    }, { // METHOD_MULTISAMPLE_4X_ROTATED_4TAP                                                     
        true,  
        0.0,  0.0, 
        SIMPLEMETHOD_2X2, 
        DRF_DEF(097, _SET_SURFACE_FORMAT, _ANTI_ALIASING,_CENTER_CORNER_2),
        0,
        METHOD_MULTISAMPLE_4X,
        METHOD_SUPERSAMPLE_4X
    }, { // METHOD_MULTISAMPLE_4X_ROTATED_8TAP                                                     
        true,  
        0.0,  0.0, 
        SIMPLEMETHOD_2X2, 
        DRF_DEF(097, _SET_SURFACE_FORMAT, _ANTI_ALIASING,_CENTER_CORNER_2),
        0,
        METHOD_MULTISAMPLE_4X,
        METHOD_SUPERSAMPLE_4X
    }, { // METHOD_SUPERSAMPLE_9X_BIAS                                                     
        false, 
        3.0,  1.5, 
        SIMPLEMETHOD_3X3, 
        DRF_DEF(097, _SET_SURFACE_FORMAT, _ANTI_ALIASING, _CENTER_1),
        0,
        METHOD_SUPERSAMPLE_9X_BIAS,
        METHOD_SUPERSAMPLE_9X_BIAS
    }, { // METHOD_SUPERSAMPLE_9X                                                     
        false, 
        3.0,  0.0, 
        SIMPLEMETHOD_3X3, 
        DRF_DEF(097, _SET_SURFACE_FORMAT, _ANTI_ALIASING, _CENTER_1),
        0,
        METHOD_SUPERSAMPLE_9X,
        METHOD_SUPERSAMPLE_9X
    }, { // METHOD_SUPERSAMPLE_16X_BIAS                                                     
        false, 
        4.0,  2.0, 
        SIMPLEMETHOD_4X4, 
        DRF_DEF(097, _SET_SURFACE_FORMAT, _ANTI_ALIASING, _CENTER_1),
        0,
        METHOD_SUPERSAMPLE_16X_BIAS,
        METHOD_SUPERSAMPLE_16X_BIAS
    }, { // METHOD_SUPERSAMPLE_16X                                                     
        false, 
        4.0,  0.0, 
        SIMPLEMETHOD_4X4, 
        DRF_DEF(097, _SET_SURFACE_FORMAT, _ANTI_ALIASING, _CENTER_1),
        0,
        METHOD_SUPERSAMPLE_16X,
        METHOD_SUPERSAMPLE_16X
    }
};

const CKelvinAAState::BufferBltInfoStruct CKelvinAAState::BufferBltInfo[SIMPLEMETHOD_MAX] = {
    {1, 1, 0, 0, 0.00, 0.00, 0.00, 0.00,   0.5000, 0.5000},    // SIMPLEMETHOD_1X1
    {1, 2, 0, 0, 0.00, 0.50, 0.00, 0.00,   0.5000, 0.2500},    // SIMPLEMETHOD_1X2
    {2, 1, 0, 0, 0.50, 0.00, 0.00, 0.00,   0.2500, 0.5000},    // SIMPLEMETHOD_2X1
    {2, 2, 0, 0, 0.50, 0.50, 0.00, 0.00,   0.2500, 0.2500},    // SIMPLEMETHOD_2X2
    {3, 3, 2, 2, 0.25, 0.25, 0.50, 0.50,   0.1666, 0.1666},    // SIMPLEMETHOD_3X3
    {4, 4, 2, 2, 0.50, 0.50, 0.50, 0.50,   0.1250, 0.1250}     // SIMPLEMETHOD_4X4
};


const CKelvinAAState::MethodType CKelvinAAState::RegQualityToAATypeMapping[10] = {
    METHOD_NONE,
    METHOD_MULTISAMPLE_2X,
    METHOD_MULTISAMPLE_2X_QUINCUNX,
    METHOD_MULTISAMPLE_4X,
    METHOD_MULTISAMPLE_4X_GAUSSIAN,
// Following methods are not implemented yet.  Punt to working modes.
//    METHOD_SUPERSAMPLE_9X_BIAS,
//    METHOD_SUPERSAMPLE_9X,
//    METHOD_SUPERSAMPLE_16X_BIAS,
//    METHOD_SUPERSAMPLE_16X
    METHOD_MULTISAMPLE_4X_GAUSSIAN,
    METHOD_MULTISAMPLE_4X_GAUSSIAN,
    METHOD_MULTISAMPLE_4X_GAUSSIAN,
    METHOD_MULTISAMPLE_4X_GAUSSIAN,
    METHOD_MULTISAMPLE_4X_GAUSSIAN
};


CKelvinAAState::CKelvinAAState() { 
    _pContext = 0;
    _enabled = 0;
    _numZLocks = 0;
    _didUpsample = true;
    _lastDownsampleUsedConvolution = false;
    _badSemantics = false;
    _seen3D = 0;

    memset(_bufferInfo, 0, sizeof(_bufferInfo));
}





void CKelvinAAState::Create(PNVD3DCONTEXT pContext) {
    if (_pContext) {
        // Make sure we don't try to create things twice
        // We want one Destroy for every Create
        nvAssert(0);
        return;
    }
        
    nvKelvinInitProgram(&_program);
    nvKelvinParseProgram(&_program, "%!VP1.0\nMOV o[HPOS], v[0];\nMOV o[TEX0], v[9];\nMOV o[TEX1], v[10];\nMOV o[TEX2], v[11];\nMOV o[TEX3], v[12];");

    InitAppCompatibility();
    if (_appCompatibility.dwFlags & APPFLAGS_DISABLE_AA) return;

    //on endscene we give read access to the RT, and if it's invalid, we minify the SRT.
    //after a refresh call, the SRT is invalidated and usually a subsequent write access
    //(like a clear) to the SRT tags the RT as invalid (and the SRT as valid). however, if
    //the app doesn't write to the SRT before the read access to the RT, the RT is never
    //invalidated which means the minification never happens -> eek!
    //this remebers if the SRT was valid at refresh time and does not set the RT as valid
    //in that case. FS
    
    if (_invalidRT)
      _invalidRT = 0;
    else 
      _bufferInfo[BUFFER_RT].flags |= FLAGS_VALID;
      


    // Well, this isn't quite correct, since we haven't copied
    // the contents of the Z buffer.  Fortunately, it shouldn't cause many
    // problems, and it needed because we destroy the normal Z buffer before
    // we create the new one.
    _bufferInfo[BUFFER_SZB].flags |= FLAGS_VALID;

    _bufferInfo[BUFFER_RT].other = BUFFER_SRT;
    _bufferInfo[BUFFER_SRT].other = BUFFER_RT;
    _bufferInfo[BUFFER_ZB].other = BUFFER_SZB;
    _bufferInfo[BUFFER_SZB].other = BUFFER_ZB;

    nvAssert(getDC()->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN);


    if ((!pContext->pRenderTarget) ||
        (pContext->pRenderTarget->isSwizzled())) {
        DPF_LEVEL (NVDBG_LEVEL_ERROR,"CKelvinAAState::Create: AA failed because render target either does not exist or it is swizzled.");
        memset(_bufferInfo, 0, sizeof(_bufferInfo));
        return;
    }

    _pContext = pContext;


    DWORD dwMSBits = _pContext->pRenderTarget->getMultiSampleBits();

    if (dwMSBits >= 2) {
        // App-controlled multisampling.  We support 2 and 4 sample modes.
        nvAssert(!_pContext->pZetaBuffer || (dwMSBits == _pContext->pZetaBuffer->getMultiSampleBits()));

        switch (dwMSBits) {
        case 2:  SetMethod(METHOD_MULTISAMPLE_2X);           break;
        case 3:  SetMethod(METHOD_MULTISAMPLE_2X_QUINCUNX);  break;
        case 4:  SetMethod(METHOD_MULTISAMPLE_4X);           break;
        case 5:  SetMethod(METHOD_MULTISAMPLE_4X_GAUSSIAN);  break;
        default:
            // Invalid number of bits
            DPF_LEVEL(NVDBG_LEVEL_ERROR,"CKelvinAAState::Create: App set invalid number of multisampling bits (%d).", dwMSBits);
            _pContext = 0;
            return;
        }
    } else if ((getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_ANTIALIASFORCEENABLE_MASK) ||
               (pContext->dwRenderState[D3DRENDERSTATE_ANTIALIAS] != D3DANTIALIAS_NONE)) {
        // FSAA forced on through registry or render state.
        nvAssert(getDC()->nvD3DRegistryData.regAntiAliasQuality < 9);
        SetMethod(RegQualityToAATypeMapping[getDC()->nvD3DRegistryData.regAntiAliasQuality]);
    } else {
        // We shouldn't be in here
        nvAssert(0);
    }

#ifdef AAFORCE_16_32
    _MixedModeAA = (getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_ANTIALIASCONVOLUTIONFASTMODE_MASK) == D3D_REG_ANTIALIASCONVOLUTIONFASTMODE_ENABLE ;
#endif

    const MethodInfoStruct *info = &MethodInfo[_method];
    const BufferBltInfoStruct *bltInfo;

    DWORD dwSimpleMethod = info->type;

    // Just for the convenience factor
    CSimpleSurface *&pRT = _bufferInfo[BUFFER_RT].pSurface;
    CSimpleSurface *&pZB = _bufferInfo[BUFFER_ZB].pSurface;
    CSimpleSurface *&pSRT = _bufferInfo[BUFFER_SRT].pSurface;
    CSimpleSurface *&pSZB = _bufferInfo[BUFFER_SZB].pSurface;

    pRT = _pContext->pRenderTarget;
    pZB = _pContext->pZetaBuffer;
    pSRT = 0;
    pSZB = 0;

    // Kill the normal Z buffer.  There's no need for it unless the application
    // later locks the Z buffer (in which case we'll recreate it).  Otherwise it 
    // just takes up memory and Z tag bit space.
    if (pZB) {
#ifdef DEBUG_SURFACE_PLACEMENT
        csd.DeleteSurface(pZB);
#endif
        pZB->destroy();
    }

    // A "simple method" is a unique buffer scale + filter type combination.
    // We start at the top, iterating down, until we find one that works.
    while (dwSimpleMethod > SIMPLEMETHOD_1X1) {
        DWORD dwMem = 0;
        DWORD dwPitch = 0;

        bltInfo = &BufferBltInfo[dwSimpleMethod];
        
        // 4k is the max.
        if ((pRT->getWidth() * bltInfo->dwSuperBufferScaleX) > 4096) goto creationFail;
        if ((pRT->getHeight() * bltInfo->dwSuperBufferScaleY) > 4096) goto creationFail;

        // Calculate the framebuffer space requirements
        if (pRT) dwMem += pRT->getBPP() * pRT->getWidth() * pRT->getHeight();
        if (pZB) dwMem += pZB->getBPP() * pZB->getWidth() * pZB->getHeight();

        dwMem *= DWORD((bltInfo->dwSuperBufferScaleX * bltInfo->dwSuperBufferScaleY) +
                        (bltInfo->dwScratchBufferScaleX * bltInfo->dwScratchBufferScaleY));

        // Ensure that we still have 1/4 of frame buffer memory left after all is said and done
        if ((int(getDC()->VideoHeapFree) - int(dwMem)) < int(getDC()->VideoHeapTotal / 4)) goto creationFail;

        
        // Create the super render target if the app has one (it better!)
        if (pRT) {
            if (!(pSRT = new CSimpleSurface())) goto creationFail;

#ifndef AAFORCE_16_32
            dwPitch = pRT->getWidth() * bltInfo->dwSuperBufferScaleX * pRT->getBPP();
#else
            if (IsMixedModeAA() && pRT->getFormat() == NV_SURFACE_FORMAT_X8R8G8B8 && (_method == METHOD_MULTISAMPLE_2X_QUINCUNX || _method ==  METHOD_MULTISAMPLE_4X_GAUSSIAN)) 
                dwPitch = pRT->getWidth() * bltInfo->dwSuperBufferScaleX * 2;
            else 
                dwPitch = pRT->getWidth() * bltInfo->dwSuperBufferScaleX * pRT->getBPP();
#endif
            dwPitch = (dwPitch + getDC()->dwSurfaceAlignPad) & ~getDC()->dwSurfaceAlignPad;


#ifndef AAFORCE_16_32
            if (!pSRT->create(NULL,
                              pRT->getFormat(),
                              pRT->getWidth()  * bltInfo->dwSuperBufferScaleX,
                              pRT->getHeight() * bltInfo->dwSuperBufferScaleY,
                              pRT->getDepth(),
                              1,
                              pRT->getBPPRequested(),
                              pRT->getBPP(),
                              dwPitch,
                              CSimpleSurface::HEAP_VID,
                              CSimpleSurface::HEAP_VID,
                              CSimpleSurface::ALLOCATE_TILED
#ifdef CAPTURE
                             ,CAPTURE_SURFACE_KIND_TARGET
#endif
                        )) goto creationFail;
#else   //AAFORCE_16_32

            if (IsMixedModeAA() && pRT->getFormat() == NV_SURFACE_FORMAT_X8R8G8B8 && (_method == METHOD_MULTISAMPLE_2X_QUINCUNX || _method ==  METHOD_MULTISAMPLE_4X_GAUSSIAN)) 
            {
                if (!pSRT->create(NULL,
                                  NV_SURFACE_FORMAT_R5G6B5,
                                  pRT->getWidth()  * bltInfo->dwSuperBufferScaleX,
                                  pRT->getHeight() * bltInfo->dwSuperBufferScaleY,
                                  pRT->getDepth(),
                                  1,
                                  2,
                                  2,
                                  dwPitch,
                                  CSimpleSurface::HEAP_VID,
                                  CSimpleSurface::HEAP_VID,
                                  CSimpleSurface::ALLOCATE_TILED
#ifdef CAPTURE
                                 ,CAPTURE_SURFACE_KIND_TARGET
#endif
                            )) goto creationFail;
                
            }
            else 
            {
                
                if (!pSRT->create(NULL,
                                  pRT->getFormat(),
                                  pRT->getWidth()  * bltInfo->dwSuperBufferScaleX,
                                  pRT->getHeight() * bltInfo->dwSuperBufferScaleY,
                                  pRT->getDepth(),
                                  1,
                                  pRT->getBPPRequested(),
                                  pRT->getBPP(),
                                  dwPitch,
                                  CSimpleSurface::HEAP_VID,
                                  CSimpleSurface::HEAP_VID,
                                  CSimpleSurface::ALLOCATE_TILED
#ifdef CAPTURE
                                 ,CAPTURE_SURFACE_KIND_TARGET
#endif
                            )) goto creationFail;

            }
#endif //AAFORCE_16_32
        } else {
            DPF("Error in CKelvinAAState::Create: No render target");
            nvAssert(0);
            goto creationFail;
        }


#ifdef DEBUG_SURFACE_PLACEMENT
        csd.SetAARenderBuffer(pSRT);
#endif 


        if (pZB) {
            if (!(pSZB = new CSimpleSurface())) goto creationFail;

            dwPitch = pZB->getWidth() * bltInfo->dwSuperBufferScaleX * pZB->getBPP();
            dwPitch = (dwPitch + getDC()->dwSurfaceAlignPad) & ~getDC()->dwSurfaceAlignPad;

            DWORD dwZCmpFlags = (_appCompatibility.dwFlags & APPFLAGS_FORCE_UNCOMPRESSED_Z) ? 
                CSimpleSurface::ALLOCATE_AS_ZBUFFER_UNC : 
                CSimpleSurface::ALLOCATE_AS_ZBUFFER_CMP;

            if (!pSZB->create(NULL,
                              pZB->getFormat(),
                              pZB->getWidth()  * bltInfo->dwSuperBufferScaleX,
                              pZB->getHeight() * bltInfo->dwSuperBufferScaleY,
                              pZB->getDepth(),
                              1,
                              pZB->getBPPRequested(),
                              pZB->getBPP(),
                              dwPitch,
                              CSimpleSurface::HEAP_VID,
                              CSimpleSurface::HEAP_VID,
                              CSimpleSurface::ALLOCATE_TILED | dwZCmpFlags
#ifdef CAPTURE
                             ,CAPTURE_SURFACE_KIND_ZETA
#endif
                        )) goto creationFail;
        }

#ifdef DEBUG_SURFACE_PLACEMENT
        csd.SetAAZBuffer(pSZB);
#endif 

#ifdef  STEREO_SUPPORT
        if (STEREO_ENABLED)
        {
            if (pSRT) {
                pSRT->tagNotReal();
                pSRT->createStereo();
            }
            if (pSZB) {
                pSZB->tagNotReal();
                pSZB->createStereo();
            }
        }
#endif  //STEREO_SUPPORT

        // TODO: scratch buffer stuff


        // The buffers were created properly.
        break;

creationFail:
        if (pSRT) {
            pSRT->destroy();
            delete pSRT;
            pSRT = 0;
        }

        if (pSZB) {
            pSZB->destroy();
            delete pSZB;
            pSZB = 0;
        }

        dwSimpleMethod--;
    }


    CNvObject *pWrapper;
    
    if (pSRT) {
        pWrapper = new CNvObject(0);
        pWrapper->setObject(CNvObject::NVOBJ_SIMPLESURFACE, (void *)pSRT);
        pSRT->setWrapper(pWrapper);
    }
    
    if (pSZB) {
        pWrapper = new CNvObject(0);
        pWrapper->setObject(CNvObject::NVOBJ_SIMPLESURFACE, (void *)pSZB);
        pSZB->setWrapper(pWrapper);
    }
    

    if ((DWORD)info->type != dwSimpleMethod) {
        // We changed the method from what the user requested for one reason or
        // another.  Find an ordinary method that corresponds with this.

        _method = METHOD_SUPERSAMPLE_16X;
        while (
            (_method > METHOD_NONE) && 
            (((DWORD)MethodInfo[_method].type != dwSimpleMethod) ||
            MethodInfo[_method].dwKernel)
            ) _method--;

        info = &MethodInfo[_method];
        bltInfo = &BufferBltInfo[dwSimpleMethod];
    }

    if (_method == METHOD_NONE) {
        ReCreateZBuffer();
    
        pSRT = pRT;
        pSZB = pZB;
        bltInfo = &BufferBltInfo[METHOD_NONE];
    }

    
    if (MethodInfo[_method].bMultisample) {
        // Multisampling does the viewport scaling automatically.
        if (_method == METHOD_MULTISAMPLE_4X_ROTATED_4TAP || _method == METHOD_MULTISAMPLE_4X_ROTATED_8TAP ) 
        {
            _pContext->aa.fWidthAmplifier = 1;
            _pContext->aa.fHeightAmplifier = 2;
        }
        else {
            _pContext->aa.fWidthAmplifier  = 1;
            _pContext->aa.fHeightAmplifier = 1;
        }
        
    } else {
        _pContext->aa.fWidthAmplifier = bltInfo->dwSuperBufferScaleX;
        _pContext->aa.fHeightAmplifier = bltInfo->dwSuperBufferScaleY;
    }
    _pContext->aa.dwDepthAmplifier = 1;
    _pContext->aa.fLODBias = info->fBias;
    _pContext->aa.dwLinePointSize = (DWORD)(info->fLinePointSize * 0x8);

/////////////////////////////////////////////////////
    
    // Should we stripdivide?
    // output 0, dsty, strip._x0, srcy-strip.y0
    //        strip.dstWidth, dsty, strip.srcWidth_x0, srcy-strip.y0
    //        strip.dstWidth, dsty+strip.dstyinc, strip.srcWidth_x0, srcy+strip.srcyinc-strip.y0
    //        0, dsty+strip.dstyinc, strip._x0, srcy+strip.srcyinc-strip.y0

    // This logic actually works whether we're upscaling or downscaling
    if (MethodInfo[_method].dwKernel) {
        _strip.x0.f = 0.25 * BufferBltInfo[dwSimpleMethod].dwSuperBufferScaleX;
        _strip.y0.f = 0.25 * BufferBltInfo[dwSimpleMethod].dwSuperBufferScaleY;
    } else {
        _strip.x0.f = 0;
        _strip.y0.f = 0;
    }
    _strip._x0.f = -_strip.x0.f;

    _bSubdivideAA = true;
    _UpsampleFlip = CURRENT_FLIP;
    if (IsMixedModeAA()) 
    {
        if (_method == METHOD_MULTISAMPLE_2X_QUINCUNX)
            _strip.stripsize = 32;        
        else if (_method == METHOD_MULTISAMPLE_4X_GAUSSIAN)
            _strip.stripsize = 16;
        else  
        {
            _strip.stripsize = pRT->getHeight();
            _bSubdivideAA = false;            
        }
    }
    else 
    {
        if (_method == METHOD_MULTISAMPLE_2X_QUINCUNX)
            _strip.stripsize = 16;
        else 
        {
            _strip.stripsize = pRT->getHeight();
            _bSubdivideAA = false;            
        }
        
    }
    
#ifdef TEST_SUB
    _strip.stripsize = __stripsize;
#endif

    _strip.num_strips =  pRT->getHeight() / _strip.stripsize;
    _strip.remainder = pRT->getHeight() % _strip.stripsize;

    if (_method <= METHOD_MULTISAMPLE_2X_QUINCUNX)
        _strip.swath = NV097_SET_SWATH_WIDTH_V_32;
    else if (_method < METHOD_MULTISAMPLE_4X_GAUSSIAN)
        _strip.swath = NV097_SET_SWATH_WIDTH_V_128;
    else 
        _strip.swath = NV097_SET_SWATH_WIDTH_V_OFF;

    if (_strip.num_strips > 1) 
    {
        if (_method == METHOD_MULTISAMPLE_2X_QUINCUNX)
            _strip.swath = IsMixedModeAA() ? NV097_SET_SWATH_WIDTH_V_16 : NV097_SET_SWATH_WIDTH_V_8;
        else if (IsMixedModeAA()  && (_method == METHOD_MULTISAMPLE_4X_GAUSSIAN))
            _strip.swath = NV097_SET_SWATH_WIDTH_V_16;
    }

#ifdef TEST_SUB
    _strip.swath = __swath;
#endif

    _strip.srcyinc.f = static_cast<float>(_strip.stripsize * BufferBltInfo[dwSimpleMethod].dwSuperBufferScaleY);
    _strip.dstyinc.f = static_cast<float>(_strip.stripsize);
    if (_strip.remainder) 
    {
        _strip.srcyrem.f = static_cast<float>(_strip.remainder * BufferBltInfo[dwSimpleMethod].dwSuperBufferScaleY);         
        _strip.dstyrem.f = static_cast<float>(_strip.remainder);
    }
    float tmp = static_cast<float>(pSRT->getWidth());
    _strip.srcWidth.f = tmp;
    _strip.srcWidth_x0.f = tmp - _strip.x0.f;
    _strip.dstWidth.f = static_cast<float>(pRT->getWidth());

///////////////////////////////////////////////

    // Finally, turn on AA
    SetSampleMask();

    Save();
    
    // start off suspended
    _enabled = 1;

    // for good luck
    if (_pContext) _pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_MISC_STATE | KELVIN_DIRTY_SURFACE | KELVIN_DIRTY_TRANSFORM;

    getDC()->dwAAContextCount++;
}

void CKelvinAAState::Refresh() {
    if (!_enabled || !_pContext) return;

    PNVD3DCONTEXT pContext = _pContext;
    //don't optimize this! FS
    if (IsValid(CKelvinAAState::BUFFER_SRT)) {
        Destroy();
        _invalidRT = true;
    } else {
        Destroy();
    }
    Create(pContext);
}

void CKelvinAAState::Destroy() {
    if (!_pContext) return;
    
    if (getDC()->nvPusher.isValid()) {
        getDC()->nvPusher.flush (TRUE, CPushBuffer::FLUSH_WITH_DELAY);
    }

    //dirty the surface state at least -- do we need to dirty anything else?
    _pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_SURFACE;

    if (_method != SIMPLEMETHOD_1X1) {
        // Eh, we better not destroy these if we don't own them
        if (_bufferInfo[BUFFER_RT].pSurface != _bufferInfo[BUFFER_SRT].pSurface) _bufferInfo[BUFFER_SRT].pSurface->getWrapper()->release();
        if (_bufferInfo[BUFFER_ZB].pSurface != _bufferInfo[BUFFER_SZB].pSurface) _bufferInfo[BUFFER_SZB].pSurface->getWrapper()->release();
    }

    ReCreateZBuffer();

    getDC()->dwAAContextCount--;

    bool badSemantics = _badSemantics; // save this bit of info across destroy calls
    memset(this, 0, sizeof(CKelvinAAState));
    _badSemantics = badSemantics;
}

CSimpleSurface * CKelvinAAState::GetCurrentRT(PNVD3DCONTEXT pContext) {
    _seen3D = true;
    return IsEnabled() ? GetSRT() : pContext->pRenderTarget; 
}

CSimpleSurface * CKelvinAAState::GetCurrentZB(PNVD3DCONTEXT pContext) { 
    _seen3D = true;
    return IsEnabled() ? GetSZB() : pContext->pZetaBuffer; 
}


bool CKelvinAAState::CheckBufferMemoryConfig(PNVD3DCONTEXT pContext) {
    // quick check to see if we have enough memory
    DWORD dwMem = 0;

    if (pContext->pRenderTarget) {
        // 3 bits is really 2 with a filter
        DWORD dwMultiSampleBits = (pContext->pRenderTarget->getMultiSampleBits() == 3) ? 2 : pContext->pRenderTarget->getMultiSampleBits();

        if (dwMultiSampleBits < 2) return true; // no AA

        dwMem += 
            pContext->pRenderTarget->getBPP() * 
            pContext->pRenderTarget->getWidth() * 
            pContext->pRenderTarget->getHeight() *
            dwMultiSampleBits;
    }

    if (pContext->pZetaBuffer) {
        DWORD dwMultiSampleBits = (pContext->pZetaBuffer->getMultiSampleBits() == 3) ? 2 : pContext->pZetaBuffer->getMultiSampleBits();

        if (dwMultiSampleBits < 2) return true; // no AA

        dwMem += 
            pContext->pZetaBuffer->getBPP() * 
            pContext->pZetaBuffer->getWidth() * 
            pContext->pZetaBuffer->getHeight() *
            dwMultiSampleBits;
    }

    // Ensure that we still have 1/4 of frame buffer memory left after all is said and done
    if ((int(getDC()->VideoHeapFree) - int(dwMem)) < int(getDC()->VideoHeapTotal / 4)) return false;

    // multisample settings must match
    if (pContext->pRenderTarget && pContext->pZetaBuffer && 
       (pContext->pRenderTarget->getMultiSampleBits() != pContext->pZetaBuffer->getMultiSampleBits())) return false;

    return true;
}

void CKelvinAAState::TestCreation(PNVD3DCONTEXT pContext) {
    if (!(getDC()->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN)) return;
    
    nvAssert(pContext && getDC());

    if (_pContext) {
        // Already created; destroy if needed
        if (_enabled &&
           ((!(getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_ANTIALIASFORCEENABLE_MASK) &&
             !(pContext->dwRenderState[D3DRENDERSTATE_ANTIALIAS] == D3DANTIALIAS_SORTDEPENDENT) &&
             !(pContext->dwRenderState[D3DRENDERSTATE_ANTIALIAS] == D3DANTIALIAS_SORTINDEPENDENT) &&
             !(_bufferInfo[BUFFER_RT].pSurface->getMultiSampleBits() > 1)  &&
             !(_bufferInfo[BUFFER_ZB].pSurface && (_bufferInfo[BUFFER_ZB].pSurface->getMultiSampleBits() > 1))) ||
             _badSemantics ||
             (_appCompatibility.dwFlags & APPFLAGS_DISABLE_AA))) {
            Destroy();
        }
    } else {
        // Not created; check if we need to
        if (_enabled &&
            !(_appCompatibility.dwFlags & APPFLAGS_DISABLE_AA) &&
            !_badSemantics &&
           ((getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_ANTIALIASFORCEENABLE_MASK &&
             getDC()->nvD3DRegistryData.regAntiAliasQuality > 0) ||
            (pContext->dwRenderState[D3DRENDERSTATE_ANTIALIAS] == D3DANTIALIAS_SORTDEPENDENT) ||
            (pContext->dwRenderState[D3DRENDERSTATE_ANTIALIAS] == D3DANTIALIAS_SORTINDEPENDENT) ||
            (pContext->pRenderTarget && pContext->pRenderTarget->getMultiSampleBits() > 1))) {
                Create(pContext);
        }
    }

    if (IsEnabled()) {
        CSimpleSurface *pCRT = pContext->pRenderTarget;
        CSimpleSurface *pRT  = _bufferInfo[BUFFER_RT].pSurface;
        CSimpleSurface *pCZB = pContext->pZetaBuffer;
        CSimpleSurface *pZB  = _bufferInfo[BUFFER_ZB].pSurface;
        
        if ((!pCRT != !pRT) || (!pCZB != !pZB) ||
            (pCRT && pRT && (pCRT->getWidth() != pRT->getWidth()) && (pCRT->getHeight() != pRT->getHeight())) ||
            (pCZB && pZB && (pCZB->getWidth() != pZB->getWidth()) && (pCZB->getHeight() != pZB->getHeight()))) {
            Refresh();
        }
    }
}

void CKelvinAAState::Save() 
{
    _bSubdivideAASave = _bSubdivideAA;
    _methodSave = _method;
    _bAAMethodChanged = false;
}

void CKelvinAAState::Restore()
{
    if (_bAAMethodChanged) 
    {
        if ((CURRENT_FLIP - _UpsampleFlip) > 5)
        {
            _bSubdivideAA = _bSubdivideAASave;
            _method = _methodSave;
        }
    
    }
}    


void CKelvinAAState::SetMethod(MethodType method) {
    if (!_pContext) return;

#ifndef SUPERSAMPLE
    if (!(_appCompatibility.dwFlags & APPFLAGS_FORCE_SUPERSAMPLE)) {
        _method = method;
    } else 
#endif
    {
        _method = MethodInfo[method].dwSuperSampledAlternative;
    }

}

DWORD CKelvinAAState::GetAAFormat() {
    return IsEnabled() ? MethodInfo[_method].AASurfaceType : 0; 
}

void CKelvinAAState::Suspend() {
    _enabled = 0;
    if (_pContext) _pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_MISC_STATE | KELVIN_DIRTY_SURFACE | KELVIN_DIRTY_TRANSFORM;
}

void CKelvinAAState::Resume() {
    _enabled = 1;
    if (_pContext) _pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_MISC_STATE | KELVIN_DIRTY_SURFACE | KELVIN_DIRTY_TRANSFORM;
}

void CKelvinAAState::Notify(NotificationType type) {
    if (!_pContext) return;
    // not used yet
    nvAssert(0);
}

void CKelvinAAState::Flip() {
    if (!_pContext) return;

    Resume();

    if (_appCompatibility.dwFlags & APPFLAGS_MAGNIFY_AFTER_FLIP) {
        GrantAccess(BUFFER_RT, ACCESS_WRITE, true);
    } else {
        GrantAccess(BUFFER_RT, ACCESS_READ, true);
    }
}

int CKelvinAAState::IsEnabled() {
    return (_enabled && _pContext && (_method != METHOD_NONE));
}

int CKelvinAAState::IsCreated() {
    return (int)_pContext; 
}

int CKelvinAAState::IsMultisampling() { 
    return (IsEnabled() && MethodInfo[_method].bMultisample);
}

int CKelvinAAState::IsSupersampling() { 
    return (IsEnabled() && MethodInfo[_method].bMultisample);
}

void CKelvinAAState::SetSampleMask() {
    if (!_pContext) return;

    if (_pContext->pRenderTarget->getMultiSampleBits() <= 1) {
        _sampleMask = 0xffff;
    } else {
        _sampleMask = _pContext->dwRenderState[D3DRS_MULTISAMPLEMASK] & 0xf;
        _sampleMask = (_sampleMask << 12) | (_sampleMask << 8) | (_sampleMask << 4) | _sampleMask; // Replicate across four pixels
    }

    DWORD aaControl = _enabled ?
        DRF_DEF(097, _SET_ANTI_ALIASING_CONTROL, _ENABLE, _TRUE) |
        DRF_DEF(097, _SET_ANTI_ALIASING_CONTROL, _ALPHA_TO_COVERAGE, _DISABLE) |
        DRF_DEF(097, _SET_ANTI_ALIASING_CONTROL, _ALPHA_TO_ONE, _DISABLE) |
        DRF_NUM(097, _SET_ANTI_ALIASING_CONTROL, _SAMPLE_MASK, _sampleMask)
        :
        DRF_DEF(097, _SET_ANTI_ALIASING_CONTROL, _ENABLE, _FALSE) |
        DRF_DEF(097, _SET_ANTI_ALIASING_CONTROL, _ALPHA_TO_COVERAGE, _DISABLE) |
        DRF_DEF(097, _SET_ANTI_ALIASING_CONTROL, _ALPHA_TO_ONE, _DISABLE) |
        DRF_NUM(097, _SET_ANTI_ALIASING_CONTROL, _SAMPLE_MASK, 0xffff);

    _pContext->hwState.kelvin.set1(NV097_SET_ANTI_ALIASING_CONTROL, aaControl);
}

void CKelvinAAState::ReCreateZBuffer() {
    
    CSimpleSurface *pZB = _bufferInfo[BUFFER_ZB].pSurface;
    
    if (pZB && !pZB->isValid()) {
//        pZB->recreate(pZB->getBPP());
        pZB->create(pZB->getWrapper(),
            pZB->getFormat(),
            pZB->getWidth(),
            pZB->getHeight(),
            1,
            pZB->getMultiSampleBits(),
            pZB->getBPPRequested(),
            pZB->getBPP(),
            pZB->getBPP() * pZB->getWidth(),
            CSimpleSurface::HEAP_VID,
            CSimpleSurface::HEAP_VID,
            pZB->getAllocFlags()
#ifdef CAPTURE
            ,CAPTURE_SURFACE_KIND_ZETA
#endif          
            );
#ifdef DEBUG_SURFACE_PLACEMENT
        csd.ReCreateZBuffer(pZB);
#endif
#ifdef  STEREO_SUPPORT
            pZB->createStereo();
#endif  //STEREO_SUPPORT
    }
}

PNVD3DCONTEXT CKelvinAAState::GetContext(CSimpleSurface *pSurf) {
    int i;

    PNVD3DCONTEXT pContext = (PNVD3DCONTEXT)getDC()->dwContextListHead;

    while (pContext) {
        if (pSurf == pContext->pZetaBuffer) return pContext;

        for (i=0; i<KELVIN_AA_NUM_FLIP_CHAIN_SLOTS; i++) {
            if (pSurf == pContext->kelvinAA._flipChain[i]) return pContext;
        }

        pContext = pContext->pContextNext;
    }

    return 0;
}


void CKelvinAAState::EndScene() {
#ifdef WINNT
    if (_appCompatibility.dwFlags & APPFLAGS_WRITE_ACCESS_ON_ENDSCENE) {
        GrantAccess(CKelvinAAState::BUFFER_RT, CKelvinAAState::ACCESS_WRITE, TRUE);
    } else
#endif
    {
        GrantAccess(CKelvinAAState::BUFFER_RT, CKelvinAAState::ACCESS_READ, TRUE);
    }
}

void CKelvinAAState::UpdateZBuffer() {
    if (!IsEnabled()) return;

    _bufferInfo[BUFFER_ZB].pSurface = _pContext->pZetaBuffer;
}

void CKelvinAAState::UpdateRenderTarget() {
    if (!IsEnabled()) return;

    CSimpleSurface *pRT = _bufferInfo[BUFFER_RT].pSurface;
    CSimpleSurface *pCRT = _pContext->pRenderTarget;

    if (pCRT && pRT && (pCRT->getWidth() != pRT->getWidth()) && (pCRT->getHeight() != pRT->getHeight())) {
        Refresh();
    }

    _bufferInfo[BUFFER_RT].pSurface = _pContext->pRenderTarget;

    int i;

    for (i=0; i<KELVIN_AA_NUM_FLIP_CHAIN_SLOTS; i++) {
        if (_flipChain[i] == _pContext->pRenderTarget) break;
    }

    if (i == KELVIN_AA_NUM_FLIP_CHAIN_SLOTS) {
        for (i=0; i<KELVIN_AA_NUM_FLIP_CHAIN_SLOTS; i++) if (!_flipChain[i]) break;
        nvAssert(i < KELVIN_AA_NUM_FLIP_CHAIN_SLOTS);
        _flipChain[i] = _pContext->pRenderTarget;
    }
}

void CKelvinAAState::GrantAccess(BufferType buffer, AccessType access, bool bConvolve, bool bFlush) {
#ifdef DEBUG
    nvAssert(buffer < BUFFER_MAX);
    nvAssert(access < ACCESS_MAX);
    DPF_LEVEL(NVDBG_LEVEL_AA_INFO, 
        "CKelvinAAState::GrantAccess(%s, %s), address: %x   %d%d %d%d", 
        BufferTypeNames[buffer], 
        AccessTypeNames[access],
	_bufferInfo[buffer].pSurface,
        !!(_bufferInfo[BUFFER_RT].flags & FLAGS_VALID),
        !!(_bufferInfo[BUFFER_SRT].flags & FLAGS_VALID),
        !!(_bufferInfo[BUFFER_ZB].flags & FLAGS_VALID),
        !!(_bufferInfo[BUFFER_SZB].flags & FLAGS_VALID));
#endif

    // Return if AA is not on
    if (!IsEnabled()) return;
    
    //exit GrantAccess if we have recursed here.
    if (InGrantAccess()) return;
    EnterGrantAccess();

    nvAssert(buffer < BUFFER_MAX);
    nvAssert(access < ACCESS_MAX);

    UpdateRenderTarget();

    BufferType other = _bufferInfo[buffer].other;

    if ((access == ACCESS_WRITE) &&
        _lastDownsampleUsedConvolution &&
        (buffer == BUFFER_RT)) {
        // superbuffer better be valid
        nvAssert(_bufferInfo[other].flags & FLAGS_VALID);
        _bufferInfo[buffer].flags &= ~FLAGS_VALID;
        _appCompatibility.dwFlags |= APPFLAGS_DISABLE_DITHER;
    }

    // We deallocated the normal Z buffer for performance reasons
    // If we desire access, then we have to reallocate it.
    CSimpleSurface *pZB = _bufferInfo[BUFFER_ZB].pSurface;
    if (buffer == BUFFER_ZB) ReCreateZBuffer();

    //at aa creation time, the z buffer was disabled. later, the app
    //enabled it and now we have to write to the super z, so create one.
    if (_bufferInfo[BUFFER_ZB].pSurface && !_bufferInfo[BUFFER_SZB].pSurface && buffer == BUFFER_SZB)
    {
        const BufferBltInfoStruct *bltInfo = &BufferBltInfo[MethodInfo[_method].type];

        if (!(_bufferInfo[BUFFER_SZB].pSurface = new CSimpleSurface())) {
            Destroy();
            ExitGrantAccess();
            return;
        }

        DWORD dwPitch = pZB->getWidth() * bltInfo->dwSuperBufferScaleX * pZB->getBPP();
        dwPitch = (dwPitch + getDC()->dwSurfaceAlignPad) & ~getDC()->dwSurfaceAlignPad;
        
        if (!_bufferInfo[BUFFER_SZB].pSurface->create(NULL,
            pZB->getFormat(),
            pZB->getWidth()  * bltInfo->dwSuperBufferScaleX,
            pZB->getHeight() * bltInfo->dwSuperBufferScaleY,
            pZB->getDepth(),
            1,
            pZB->getBPPRequested(),
            pZB->getBPP(),
            dwPitch,
            CSimpleSurface::HEAP_VID,
            CSimpleSurface::HEAP_VID,
            CSimpleSurface::ALLOCATE_TILED | CSimpleSurface::ALLOCATE_AS_ZBUFFER_CMP
#ifdef CAPTURE
            ,CAPTURE_SURFACE_KIND_ZETA
#endif
            ))
        {
            Destroy();
            ExitGrantAccess();
            return;
        }
#ifdef  STEREO_SUPPORT
        _bufferInfo[BUFFER_SZB].pSurface->createStereo();
#endif  //STEREO_SUPPORT
        CNvObject *pWrapper = new CNvObject(0);
        pWrapper->setObject(CNvObject::NVOBJ_SIMPLESURFACE, (void *)_bufferInfo[BUFFER_SZB].pSurface);
        _bufferInfo[BUFFER_SZB].pSurface->setWrapper(pWrapper);
    }
    
    switch (access) {
    case ACCESS_READ:
        if (!(_bufferInfo[buffer].flags & FLAGS_VALID)) {
            ScaledBlt(buffer, other, bConvolve, bFlush);
            _bufferInfo[buffer].flags |= FLAGS_VALID;
        }

        break;
    case ACCESS_WRITE:
        if (!(_bufferInfo[buffer].flags & FLAGS_VALID)) {
            // we never want to give write access to a blur filtered buffer
            ScaledBlt(buffer, other, bConvolve, bFlush);
            _bufferInfo[buffer].flags |= FLAGS_VALID;
        }
        _bufferInfo[other].flags &= ~FLAGS_VALID;

        break;
    case ACCESS_WRITE_DISCARD:
        // Don't have to perform any blts; we don't care about the results
        _bufferInfo[buffer].flags |= FLAGS_VALID;
        _bufferInfo[other].flags &= ~FLAGS_VALID;

        break;
    default:
        DPF("Invalid access type in CKelvinAAState::GrantAccess()");
        nvAssert(0);

        break;
    };

    ExitGrantAccess();
    return;
}

void CKelvinAAState::ScaledBlt(BufferType dst, BufferType src, bool bConvolve, bool bFlush) {
    DPF_LEVEL(NVDBG_LEVEL_AA_INFO, "CKelvinAAState::ScaledBlt(%s, %s)", BufferTypeNames[dst], BufferTypeNames[src]);
    nvAssert(_enabled && _pContext);

    BufferInfo *dstInfo = &_bufferInfo[dst];
    BufferInfo *srcInfo = &_bufferInfo[src];
    const BufferBltInfoStruct *bltInfo = &BufferBltInfo[MethodInfo[src].type];

    BufferInfo *tempInfo = (bltInfo->dwScratchBufferScaleX) ? &_bufferInfo[BUFFER_SCRATCH] : 0;

    bConvolve = bConvolve && MethodInfo[_method].dwKernel; // and out the filter if we're not using convolution

    if (!srcInfo->pSurface || !dstInfo->pSurface) return;
    if (_method == SIMPLEMETHOD_1X1) return;

    nvAssert(dstInfo->pSurface);
    nvAssert(srcInfo->pSurface);

    DWORD dwMethod = _method;
    bool bSubdivideAA = (bool)_bSubdivideAA;
    bool bDither = !(_appCompatibility.dwFlags & APPFLAGS_DISABLE_DITHER);
    bool bZBuffer = (src == BUFFER_ZB) || (src == BUFFER_SZB);

    if ((dstInfo->pSurface->getWidth() < srcInfo->pSurface->getWidth()) ||
        (dstInfo->pSurface->getHeight() < srcInfo->pSurface->getHeight())) {
        if (!bZBuffer) {
            if (_didUpsample) {
                bDither = false;
                _didUpsample = false;
            }
    
            if (bConvolve) {
                _lastDownsampleUsedConvolution = true;
            } else {
                _lastDownsampleUsedConvolution = false;
                dwMethod = MethodInfo[_method].dwBoxFilteredAlternative;
            }
        }
    } else {
        // upsampling
        bSubdivideAA = false;
        bDither = false;
        _didUpsample = true;
        dwMethod = MethodInfo[_method].dwBoxFilteredAlternative;
    }

    if (!tempInfo) {
#ifndef SCALED_IMAGE
#ifdef  STEREO_SUPPORT
        if (STEREO_ACTIVATED)
        {
			//We can't mess up the pStereoData->dwLastEye or use SetupStereoContext
			//for that matter. Those are higher level primitives.
			DWORD dwLastEye = pStereoData->dwLastEye;
			pStereoData->dwLastEye = EYE_LEFT;
            ImageModeTexBlt(dstInfo->pSurface, srcInfo->pSurface, dwMethod, bSubdivideAA, bDither, bFlush);
            pStereoData->dwLastEye = EYE_RIGHT;
            ImageModeTexBlt(dstInfo->pSurface, srcInfo->pSurface, dwMethod, bSubdivideAA, bDither, bFlush);
			pStereoData->dwLastEye = dwLastEye;
        } else
            ImageModeTexBlt(dstInfo->pSurface, srcInfo->pSurface, dwMethod, bSubdivideAA, bDither, bFlush);
#else   //STEREO_SUPPORT==0
        ImageModeTexBlt(dstInfo->pSurface, srcInfo->pSurface, dwMethod, bSubdivideAA, bDither, bFlush);
#endif  //STEREO_SUPPORT
#else
        DWORD dstWidth  = dstInfo->pSurface->getWidth();
        DWORD dstHeight = dstInfo->pSurface->getHeight();
        DWORD srcWidth  = srcInfo->pSurface->getWidth();
        DWORD srcHeight = srcInfo->pSurface->getHeight();
        
        if (dstWidth >= 1024) {
            nvAssert(!(dstWidth & 0x1));
            
            ScaledBlt(
                dstInfo->pSurface, 0, 0, dstWidth/2, dstInfo->pSurface->getHeight(), 
                srcInfo->pSurface, bltInfo->fDownscaleOffsetX1, bltInfo->fDownscaleOffsetY1, srcWidth/2, srcInfo->pSurface->getHeight() 
                );
            ScaledBlt(
                dstInfo->pSurface, dstWidth/2, 0, dstWidth/2, dstInfo->pSurface->getHeight(), 
                srcInfo->pSurface, bltInfo->fDownscaleOffsetX1+(srcWidth/2), bltInfo->fDownscaleOffsetY1, srcWidth/2, srcInfo->pSurface->getHeight() 
                );
        } else {
            ScaledBlt(
                dstInfo->pSurface, 0, 0, dstInfo->pSurface->getWidth(), dstInfo->pSurface->getHeight(), 
                srcInfo->pSurface, bltInfo->fDownscaleOffsetX1, bltInfo->fDownscaleOffsetY1, srcInfo->pSurface->getWidth(), srcInfo->pSurface->getHeight() 
                );
        }
#endif
    } else {
        nvAssert(0);
        // We don't handle this case yet
    }
}

void CKelvinAAState::ImageModeTexBlt(
    CSimpleSurface *pDst, 
    CSimpleSurface *pSrc,
    DWORD dwMethod,
    bool bSubdivideAA,
    bool bDither,
    bool bFlush
) {
    DWORD i;
    DWORD dwSimpleMethod = MethodInfo[dwMethod].type;
    DWORD dwSrcFormat = pSrc->getFormat();
    DWORD dwDstFormat = pDst->getFormat();
    bool bZBuffer = false;

    if (!_bInitializedState) {
        _pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_REALLY_FILTHY;
        nvSetKelvinState(_pContext);
	    // THIS IS KIND OF UGLY NOW because we moved the GrantAccess call into nvSetKelvinState
	    // thus ImageModeTexBlt could call itself recursively.  Make sure you set _bInitializedState=true
	    // BEFORE calling nvSetKelvinState here or you will fall into an infinite loop
        _bInitializedState = true;	//<------------------- DO NOT DELETE
    }

    bool bUpscaling = (pDst->getWidth() > pSrc->getWidth()) || (pDst->getHeight() > pSrc->getHeight());


    // Spoof the src format
    switch (dwSrcFormat) {
    case NV_SURFACE_FORMAT_Z16:
        bZBuffer = true;
        bDither = false;
    case NV_SURFACE_FORMAT_R5G6B5:
    case NV_SURFACE_FORMAT_IMAGE_R5G6B5:
        dwSrcFormat = NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_R5G6B5;
        break;
    case NV_SURFACE_FORMAT_Z24S8:
    case NV_SURFACE_FORMAT_Z24X8:
        bZBuffer = true;
        bDither = false;
    case NV_SURFACE_FORMAT_X8R8G8B8:
    case NV_SURFACE_FORMAT_A8R8G8B8:
    case NV_SURFACE_FORMAT_IMAGE_A8R8G8B8:
        dwSrcFormat = NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A8R8G8B8;
        break;
    default:
        // Invalid surface format
        nvAssert(0);
        return;
    }

    // Spoof the dst format
    switch (dwDstFormat) {
    case NV_SURFACE_FORMAT_X1R5G5B5:
        dwDstFormat = NV097_SET_SURFACE_FORMAT_COLOR_LE_X1R5G5B5_Z1R5G5B5;
        break;
    case NV_SURFACE_FORMAT_Z16:
    case NV_SURFACE_FORMAT_R5G6B5:
    case NV_SURFACE_FORMAT_IMAGE_R5G6B5:
        dwDstFormat = NV097_SET_SURFACE_FORMAT_COLOR_LE_R5G6B5;
        break;
    case NV_SURFACE_FORMAT_Z24S8:
    case NV_SURFACE_FORMAT_Z24X8:
    case NV_SURFACE_FORMAT_X8R8G8B8:
    case NV_SURFACE_FORMAT_A8R8G8B8:
    case NV_SURFACE_FORMAT_IMAGE_A8R8G8B8:
        dwDstFormat = NV097_SET_SURFACE_FORMAT_COLOR_LE_A8R8G8B8;
        break;
    case NV_SURFACE_FORMAT_X1A7R8G8B8:
        dwDstFormat = NV097_SET_SURFACE_FORMAT_COLOR_LE_X1A7R8G8B8_Z1A7R8G8B8;
        break;
    default:
        // don't worry, we're not catching all the cases
        break;
    }


    struct filterTypeStruct {
        bool bEmulateFilter;
        DWORD dwNumTextures;

        struct {
            float fXOffset;
            float fYOffset;
        } texStageInfo[4];

        DWORD dwNumCombinerStages;

        struct {
            DWORD dwICW;
            DWORD dwOCW;
            DWORD dwFactor0;
            DWORD dwFactor1;
        } combinerInfo[4];
    };

    float fCenterContrib = 0.25; // Contribution of center texel in Gaussian filter.
    float fSqrtCenterContrib = float(sqrt(fCenterContrib));

    DWORD dwCombinerCountInc = 0;

#ifdef _16_BIT_FIX
    if ((pSrc->getBPP() == 2) && !bUpscaling && bDither) dwCombinerCountInc = 1;
#endif

    static const filterTypeStruct filterType[] = {
        {   // ordinary filter - box, standard gaussian, standard quincunx
            false,
            1, 
            {{0.0, 0.0},
             {0.0, 0.0},
             {0.0, 0.0},
             {0.0, 0.0}},
            1+dwCombinerCountInc, 
            {{0x08200000, 0x00000c00, 0x00000000, 0x00000000},
             {0x0c010000, 0x00000c00, 0x00f7fbf7, 0x00000000},
             {0x00000000, 0x00000000, 0x00000000, 0x00000000},
             {0x00000000, 0x00000000, 0x00000000, 0x00000000}}
        }, { // emulated gaussian
            true,
            4, 
            {{-1+fSqrtCenterContrib, -1+fSqrtCenterContrib},
             { 1-fSqrtCenterContrib, -1+fSqrtCenterContrib},
             {-1+fSqrtCenterContrib,  1-fSqrtCenterContrib},
             { 1-fSqrtCenterContrib,  1-fSqrtCenterContrib}},
            3+dwCombinerCountInc, 
            {{0x08010902, 0x00000C00, 0x7f7f7f7f, 0x7f7f7f7f},
             {0x0c010a02, 0x00000C00, 0x7f7f7f7f, 0x3f3f3f3f},
             {0x0c010b02, 0x00000C00, 0xffffffff, 0x3f3f3f3f},
             {0x0c010000, 0x00000c00, 0x00f7fbf7, 0x00000000}}
        
        },  { //9 tap emulated gaussian 
            true,
            4, 
            {{0.66+0.5, 0.5+0.5},  //.75 8
             {1.33+0.5, 0.5+0.5},  //.75 9
             {0+0.5   , 1.5+0.5},  //.25 a
             {2+0.5   , 1.5+0.5}}, //.25 b
            4, 
            {{0x48014a02, 0x00000c00, 0xBFBFBFBF, 0x3f3f3f3f},
             {0x49014b02, 0x00000d00, 0xBFBFBFBF, 0x3f3f3f3f},
             {0xcc01cd02, 0x00000C00, 0x7f7f7f7f, 0x7f7f7f7f},
             {0xcc01c102, 0x00000C00, 0x7f7f7f7f, 0xFFFFFFFF}}
        },  { //
            true,
            2, 
            {{0.5,      0.0},
             {-0.5,      0.5},
             {0.0,      0.0},
             {0.0,      0.0}},
            1+dwCombinerCountInc, 
            {{0x08010902, 0x00000c00, 0x80808080, 0x7f7f7f7f},
             {0x0c010000, 0x00000c00, 0x00f7fbf7, 0x00000000},
             {0x00000000, 0x00000000, 0x00000000, 0x00000000},
             {0x00000000, 0x00000000, 0x00000000, 0x00000000}}
        }
    };
    
    DWORD dwFilterType;

    switch (dwMethod) {
//    case METHOD_MULTISAMPLE_2X_QUINCUNX:       dwFilterType = 3;   break;
    case METHOD_MULTISAMPLE_4X_ROTATED_8TAP:   dwFilterType = 2;   break;
    default:                                   dwFilterType = 0;   break; 
    }

    DWORD dwShaderStageProgram = 0;
    for (i=0; i<filterType[dwFilterType].dwNumTextures; i++) {
        dwShaderStageProgram |= DRF_DEF(097, _SET_SHADER_STAGE_PROGRAM, _STAGE0, _2D_PROJECTIVE) << (5*i);
    }

    _pContext->hwState.kelvin.set1(NV097_SET_SHADER_STAGE_PROGRAM, dwShaderStageProgram);

    _pContext->hwState.kelvin.set1(NV097_SET_DOT_RGBMAPPING,
        DRF_DEF(097, _SET_DOT_RGBMAPPING, _STAGE1, _ZERO_TO_1) |
        DRF_DEF(097, _SET_DOT_RGBMAPPING, _STAGE2, _ZERO_TO_1) |
        DRF_DEF(097, _SET_DOT_RGBMAPPING, _STAGE3, _ZERO_TO_1));

#ifdef SUBDIVIDE_AA
    _pContext->hwState.kelvin.set1(NV097_SET_SWATH_WIDTH, _strip.swath);
#else
    if (dwMethod <= METHOD_MULTISAMPLE_2X_QUINCUNX)
        _pContext->hwState.kelvin.set1(NV097_SET_SWATH_WIDTH, NV097_SET_SWATH_WIDTH_V_32);
    else if (dwMethod < METHOD_MULTISAMPLE_4X_GAUSSIAN)
        _pContext->hwState.kelvin.set1(NV097_SET_SWATH_WIDTH, NV097_SET_SWATH_WIDTH_V_128);
    else 
        _pContext->hwState.kelvin.set1(NV097_SET_SWATH_WIDTH, NV097_SET_SWATH_WIDTH_V_OFF);
#endif

    // dithering
    _pContext->hwState.kelvin.set1(NV097_SET_DITHER_ENABLE, bDither ? NV097_SET_DITHER_ENABLE_V_TRUE : NV097_SET_DITHER_ENABLE_V_FALSE);

    _pContext->hwState.kelvin.set1(NV097_SET_SHADER_CLIP_PLANE_MODE, 0);
    _pContext->hwState.kelvin.set1(NV097_SET_SHADER_OTHER_STAGE_INPUT, 0);
    _pContext->hwState.kelvin.set1(NV097_SET_FLAT_SHADE_OP, NV097_SET_FLAT_SHADE_OP_V_LAST_VTX);
    _pContext->hwState.kelvin.set1(NV097_SET_LOGIC_OP_ENABLE, NV097_SET_LOGIC_OP_ENABLE_V_FALSE);
    _pContext->hwState.kelvin.set1(NV097_SET_ZMIN_MAX_CONTROL,
        DRF_DEF(097, _SET_ZMIN_MAX_CONTROL, _CULL_IGNORE_W, _TRUE)   |
        DRF_DEF(097, _SET_ZMIN_MAX_CONTROL, _ZCLAMP_EN, _CLAMP)      |
        DRF_DEF(097, _SET_ZMIN_MAX_CONTROL, _CULL_NEAR_FAR_EN, _FALSE));

    _pContext->hwState.kelvin.set1(NV097_SET_ANTI_ALIASING_CONTROL, (0xFFFF0000) | NV097_SET_ANTI_ALIASING_CONTROL_ENABLE_FALSE);
    _pContext->hwState.kelvin.set1(NV097_SET_COMPRESS_ZBUFFER_EN, NV097_SET_COMPRESS_ZBUFFER_EN_V_DISABLE);
    _pContext->hwState.kelvin.set1(NV097_SET_OCCLUDE_ZSTENCIL_EN, NV097_SET_OCCLUDE_ZSTENCIL_EN_OCCLUDE_ZEN_DISABLE);
    _pContext->hwState.kelvin.set1(NV097_SET_TWO_SIDE_LIGHT_EN, NV097_SET_TWO_SIDE_LIGHT_EN_V_FALSE);
    _pContext->hwState.kelvin.set1(NV097_SET_ZPASS_PIXEL_COUNT_ENABLE, NV097_SET_ZPASS_PIXEL_COUNT_ENABLE_V_FALSE);

    // deactivate all but the first clip rectangle
    for (DWORD dwWindow=1; dwWindow < KELVIN_NUM_WINDOWS; dwWindow++) {
        _pContext->hwState.kelvin.set1 (NV097_SET_WINDOW_CLIP_HORIZONTAL(dwWindow), 0);
        _pContext->hwState.kelvin.set1 (NV097_SET_WINDOW_CLIP_VERTICAL(dwWindow), 0);
    }


    _pContext->hwState.kelvin.set1 (NV097_SET_WINDOW_CLIP_HORIZONTAL(0), 
        DRF_NUM(097, _SET_WINDOW_CLIP_HORIZONTAL, _XMIN, 0) |
        DRF_NUM(097, _SET_WINDOW_CLIP_HORIZONTAL, _XMAX, pDst->getWidth()-1));

    _pContext->hwState.kelvin.set1 (NV097_SET_WINDOW_CLIP_VERTICAL(0), 
        DRF_NUM(097, _SET_WINDOW_CLIP_VERTICAL, _YMIN, 0) |
        DRF_NUM(097, _SET_WINDOW_CLIP_VERTICAL, _YMAX, pDst->getHeight()-1));

    ////////////////////////////////////////

    _pContext->hwState.kelvin.set8(NV097_SET_VERTEX_DATA_ARRAY_OFFSET(0), 0, 0, 0, 0, 0, 0, 0, 0);
    _pContext->hwState.kelvin.set8(NV097_SET_VERTEX_DATA_ARRAY_OFFSET(8), 0, 8, 16, 24, 32, 0, 0, 0);

    _pContext->hwState.kelvin.set8(NV097_SET_VERTEX_DATA_ARRAY_FORMAT(0),
        DRF_DEF(097, _SET_VERTEX_DATA_ARRAY_FORMAT, _SIZE, _2)        | DRF_DEF(097, _SET_VERTEX_DATA_ARRAY_FORMAT, _TYPE, _F),
        DRF_DEF(097, _SET_VERTEX_DATA_ARRAY_FORMAT, _SIZE, _DISABLED) | DRF_DEF(097, _SET_VERTEX_DATA_ARRAY_FORMAT, _TYPE, _F),
        DRF_DEF(097, _SET_VERTEX_DATA_ARRAY_FORMAT, _SIZE, _DISABLED) | DRF_DEF(097, _SET_VERTEX_DATA_ARRAY_FORMAT, _TYPE, _F),
        DRF_DEF(097, _SET_VERTEX_DATA_ARRAY_FORMAT, _SIZE, _DISABLED) | DRF_DEF(097, _SET_VERTEX_DATA_ARRAY_FORMAT, _TYPE, _F),
        DRF_DEF(097, _SET_VERTEX_DATA_ARRAY_FORMAT, _SIZE, _DISABLED) | DRF_DEF(097, _SET_VERTEX_DATA_ARRAY_FORMAT, _TYPE, _F),
        DRF_DEF(097, _SET_VERTEX_DATA_ARRAY_FORMAT, _SIZE, _DISABLED) | DRF_DEF(097, _SET_VERTEX_DATA_ARRAY_FORMAT, _TYPE, _F),
        DRF_DEF(097, _SET_VERTEX_DATA_ARRAY_FORMAT, _SIZE, _DISABLED) | DRF_DEF(097, _SET_VERTEX_DATA_ARRAY_FORMAT, _TYPE, _F),
        DRF_DEF(097, _SET_VERTEX_DATA_ARRAY_FORMAT, _SIZE, _DISABLED) | DRF_DEF(097, _SET_VERTEX_DATA_ARRAY_FORMAT, _TYPE, _F));

    _pContext->hwState.kelvin.set8(NV097_SET_VERTEX_DATA_ARRAY_FORMAT(8),
        DRF_DEF(097, _SET_VERTEX_DATA_ARRAY_FORMAT, _SIZE, _DISABLED) | DRF_DEF(097, _SET_VERTEX_DATA_ARRAY_FORMAT, _TYPE, _F),
        DRF_DEF(097, _SET_VERTEX_DATA_ARRAY_FORMAT, _SIZE, _2)        | DRF_DEF(097, _SET_VERTEX_DATA_ARRAY_FORMAT, _TYPE, _F),
        DRF_DEF(097, _SET_VERTEX_DATA_ARRAY_FORMAT, _SIZE, _2)        | DRF_DEF(097, _SET_VERTEX_DATA_ARRAY_FORMAT, _TYPE, _F),
        DRF_DEF(097, _SET_VERTEX_DATA_ARRAY_FORMAT, _SIZE, _2)        | DRF_DEF(097, _SET_VERTEX_DATA_ARRAY_FORMAT, _TYPE, _F),
        DRF_DEF(097, _SET_VERTEX_DATA_ARRAY_FORMAT, _SIZE, _2)        | DRF_DEF(097, _SET_VERTEX_DATA_ARRAY_FORMAT, _TYPE, _F),
        DRF_DEF(097, _SET_VERTEX_DATA_ARRAY_FORMAT, _SIZE, _DISABLED) | DRF_DEF(097, _SET_VERTEX_DATA_ARRAY_FORMAT, _TYPE, _F),
        DRF_DEF(097, _SET_VERTEX_DATA_ARRAY_FORMAT, _SIZE, _DISABLED) | DRF_DEF(097, _SET_VERTEX_DATA_ARRAY_FORMAT, _TYPE, _F),
        DRF_DEF(097, _SET_VERTEX_DATA_ARRAY_FORMAT, _SIZE, _DISABLED) | DRF_DEF(097, _SET_VERTEX_DATA_ARRAY_FORMAT, _TYPE, _F));

    _pContext->hwState.kelvin.set1(NV097_SET_CULL_FACE_ENABLE, NV097_SET_CULL_FACE_ENABLE_V_FALSE);

    /////////////////////////////////////////////////////

    DWORD dwFormat = DRF_NUM(097, _SET_SURFACE_FORMAT, _COLOR, dwDstFormat);

    if (pDst->isSwizzled()) {
        CTexture* pTexture = pDst->getWrapper()->getTexture();
        nvAssert(pTexture);
        dwFormat |= DRF_DEF(097, _SET_SURFACE_FORMAT, _TYPE, _SWIZZLE);
        dwFormat |= DRF_NUM(097, _SET_SURFACE_FORMAT, _WIDTH,  pTexture->getLogWidth());
        dwFormat |= DRF_NUM(097, _SET_SURFACE_FORMAT, _HEIGHT, pTexture->getLogHeight());
    } else {
        dwFormat |= DRF_DEF(097, _SET_SURFACE_FORMAT, _TYPE, _PITCH);
    }

    dwFormat |= DRF_NUM(097, _SET_SURFACE_FORMAT, _ZETA, 
        (pDst->getBPP() == 2) ? NV097_SET_SURFACE_FORMAT_ZETA_Z16 : NV097_SET_SURFACE_FORMAT_ZETA_Z24S8);

    _pContext->hwState.kelvin.set3(NV097_SET_SURFACE_PITCH,
                                 (DRF_NUM (097, _SET_SURFACE_PITCH, _COLOR, pDst->getPitch()) |
                                  DRF_NUM (097, _SET_SURFACE_PITCH, _ZETA, KELVIN_ALIGNMENT_MIN)),
#ifdef  STEREO_SUPPORT
                                  GetStereoOffset(pDst),
#else   //STEREO_SUPPORT==0
                                  pDst->getOffset(),
#endif  //STEREO_SUPPORT
                                  0);

    _pContext->hwState.kelvin.set1 (NV097_SET_SURFACE_FORMAT, dwFormat);

    _pContext->hwState.kelvin.set2 (NV097_SET_SURFACE_CLIP_HORIZONTAL,
        DRF_NUM(097, _SET_SURFACE_CLIP_HORIZONTAL, _X, 0) |
        DRF_NUM(097, _SET_SURFACE_CLIP_HORIZONTAL, _WIDTH, pDst->getWidth()),
        DRF_NUM(097, _SET_SURFACE_CLIP_VERTICAL, _Y, 0) |
        DRF_NUM(097, _SET_SURFACE_CLIP_VERTICAL, _HEIGHT, pDst->getHeight()));

    ///////////////////////////////////////////////////////

    for (i=0; i<filterType[dwFilterType].dwNumTextures; i++) {
        _pContext->hwState.kelvin.set1(NV097_SET_TEXTURE_FORMAT(i),
            DRF_NUM(097, _SET_TEXTURE_FORMAT, _MIPMAP_LEVELS, 1)                               |
            DRF_NUM(097, _SET_TEXTURE_FORMAT, _COLOR, dwSrcFormat)                             |
            DRF_DEF(097, _SET_TEXTURE_FORMAT, _DIMENSIONALITY, _TWO)                           |
            DRF_DEF(097, _SET_TEXTURE_FORMAT, _BORDER_SOURCE, _COLOR)                          |
            DRF_DEF(097, _SET_TEXTURE_FORMAT, _CUBEMAP_ENABLE, _FALSE)                         |
            DRF_NUM(097, _SET_TEXTURE_FORMAT, _CONTEXT_DMA, nv097TextureContextDma[pSrc->getContextDMA()]));

        _pContext->hwState.kelvin.set1(NV097_SET_TEXTURE_CONTROL0(i),
            DRF_DEF(097, _SET_TEXTURE_CONTROL0, _ENABLE, _TRUE)              |
            DRF_NUM(097, _SET_TEXTURE_CONTROL0, _MIN_LOD_CLAMP, 0)           |
            DRF_NUM(097, _SET_TEXTURE_CONTROL0, _MAX_LOD_CLAMP, 0)           |
            DRF_DEF(097, _SET_TEXTURE_CONTROL0, _LOG_MAX_ANISO, _0)          |
            DRF_DEF(097, _SET_TEXTURE_CONTROL0, _IMAGE_FIELD_ENABLE, _FALSE) |
            DRF_DEF(097, _SET_TEXTURE_CONTROL0, _ALPHA_KILL_ENABLE, _FALSE)  |
            DRF_DEF(097, _SET_TEXTURE_CONTROL0, _COLOR_KEY_OPERATION, _FALSE));

        _pContext->hwState.kelvin.set1(NV097_SET_TEXTURE_CONTROL1(i),
            DRF_NUM(097, _SET_TEXTURE_CONTROL1, _IMAGE_PITCH, pSrc->getPitch()));

        _pContext->hwState.kelvin.set1(NV097_SET_TEXTURE_ADDRESS(i),
            DRF_DEF(097, _SET_TEXTURE_ADDRESS, _CYLWRAP_Q, _FALSE) |
            DRF_DEF(097, _SET_TEXTURE_ADDRESS, _CYLWRAP_P, _FALSE) |
            DRF_DEF(097, _SET_TEXTURE_ADDRESS, _CYLWRAP_V, _FALSE) |
            DRF_DEF(097, _SET_TEXTURE_ADDRESS, _CYLWRAP_U, _FALSE) |
            DRF_DEF(097, _SET_TEXTURE_ADDRESS, _U, _CLAMP_TO_EDGE) |
            DRF_DEF(097, _SET_TEXTURE_ADDRESS, _V, _CLAMP_TO_EDGE) |
            DRF_DEF(097, _SET_TEXTURE_ADDRESS, _P, _CLAMP_TO_EDGE));
        
        if (bUpscaling || bZBuffer) {
            // We're upscaling
            _pContext->hwState.kelvin.set1(NV097_SET_TEXTURE_FILTER(i),
                DRF_DEF(097, _SET_TEXTURE_FILTER, _BSIGNED, _BIT_DISABLED) |
                DRF_DEF(097, _SET_TEXTURE_FILTER, _GSIGNED, _BIT_DISABLED) |
                DRF_DEF(097, _SET_TEXTURE_FILTER, _RSIGNED, _BIT_DISABLED) |
                DRF_DEF(097, _SET_TEXTURE_FILTER, _ASIGNED, _BIT_DISABLED) |
                DRF_DEF(097, _SET_TEXTURE_FILTER, _MAG, _BOX_LOD0)         |
                DRF_DEF(097, _SET_TEXTURE_FILTER, _MIN, _BOX_LOD0)         |
                DRF_DEF(097, _SET_TEXTURE_FILTER, _CONVOLUTION_KERNEL, _GAUSSIAN_3));
        } else if (MethodInfo[dwMethod].dwKernel && !filterType[dwFilterType].bEmulateFilter) {
            _pContext->hwState.kelvin.set1(NV097_SET_TEXTURE_FILTER(i),
                DRF_DEF(097, _SET_TEXTURE_FILTER, _BSIGNED, _BIT_DISABLED)    |
                DRF_DEF(097, _SET_TEXTURE_FILTER, _GSIGNED, _BIT_DISABLED)    |
                DRF_DEF(097, _SET_TEXTURE_FILTER, _RSIGNED, _BIT_DISABLED)    |
                DRF_DEF(097, _SET_TEXTURE_FILTER, _ASIGNED, _BIT_DISABLED)    |
                DRF_DEF(097, _SET_TEXTURE_FILTER, _MAG, _CONVOLUTION_2D_LOD0) |
                DRF_DEF(097, _SET_TEXTURE_FILTER, _MIN, _CONVOLUTION_2D_LOD0) |
                DRF_NUM(097, _SET_TEXTURE_FILTER, _CONVOLUTION_KERNEL, MethodInfo[dwMethod].dwKernel));
        } else {
            // We're downscaling
            _pContext->hwState.kelvin.set1(NV097_SET_TEXTURE_FILTER(i),
                DRF_DEF(097, _SET_TEXTURE_FILTER, _BSIGNED, _BIT_DISABLED) |
                DRF_DEF(097, _SET_TEXTURE_FILTER, _GSIGNED, _BIT_DISABLED) |
                DRF_DEF(097, _SET_TEXTURE_FILTER, _RSIGNED, _BIT_DISABLED) |
                DRF_DEF(097, _SET_TEXTURE_FILTER, _ASIGNED, _BIT_DISABLED) |
                DRF_DEF(097, _SET_TEXTURE_FILTER, _MAG, _TENT_LOD0)        |
                DRF_DEF(097, _SET_TEXTURE_FILTER, _MIN, _TENT_LOD0)        |
                DRF_DEF(097, _SET_TEXTURE_FILTER, _CONVOLUTION_KERNEL, _GAUSSIAN_3));
        }
    
#ifdef  STEREO_SUPPORT
        _pContext->hwState.kelvin.set1(NV097_SET_TEXTURE_OFFSET(i), GetStereoOffset(pSrc));
#else   //STEREO_SUPPORT==0
        _pContext->hwState.kelvin.set1(NV097_SET_TEXTURE_OFFSET(i), pSrc->getOffset());
#endif  //STEREO_SUPPORT

        // we subtract the X and Y scaling factors here, then c
//        _pContext->hwState.kelvin.set1(NV097_SET_TEXTURE_IMAGE_RECT(i), 
//            DRF_NUM(097, _SET_TEXTURE_IMAGE_RECT, _WIDTH, pSrc->getWidth()-BufferBltInfo[dwSimpleMethod].dwSuperBufferScaleX) |
//            DRF_NUM(097, _SET_TEXTURE_IMAGE_RECT, _HEIGHT, pSrc->getHeight()-BufferBltInfo[dwSimpleMethod].dwSuperBufferScaleY));
        _pContext->hwState.kelvin.set1(NV097_SET_TEXTURE_IMAGE_RECT(i), 
            DRF_NUM(097, _SET_TEXTURE_IMAGE_RECT, _WIDTH, pSrc->getWidth()) |
            DRF_NUM(097, _SET_TEXTURE_IMAGE_RECT, _HEIGHT, pSrc->getHeight()));

        _pContext->hwState.kelvin.set4(NV097_SET_TEXGEN_S(i),
            NV097_SET_TEXGEN_S_V_DISABLE,
            NV097_SET_TEXGEN_T_V_DISABLE,
            NV097_SET_TEXGEN_R_V_DISABLE,
            NV097_SET_TEXGEN_Q_V_DISABLE);

        _pContext->hwState.kelvin.set1(NV097_SET_TEXTURE_MATRIX_ENABLE(i), 
            DRF_DEF(097, _SET_TEXTURE_MATRIX_ENABLE, _V, _FALSE));
    }


    ///////////////////////////////////////////////////////

    _pContext->hwState.kelvin.set1(NV097_SET_LIGHTING_ENABLE, NV097_SET_LIGHTING_ENABLE_V_FALSE);
    _pContext->hwState.kelvin.set1(NV097_SET_DEPTH_TEST_ENABLE, NV097_SET_DEPTH_TEST_ENABLE_V_FALSE);
    _pContext->hwState.kelvin.set2(NV097_SET_FRONT_POLYGON_MODE, NV097_SET_FRONT_POLYGON_MODE_V_FILL, NV097_SET_BACK_POLYGON_MODE_V_FILL);
    _pContext->hwState.kelvin.set1(NV097_SET_BLEND_ENABLE, NV097_SET_BLEND_ENABLE_V_FALSE);
    _pContext->hwState.kelvin.set1(NV097_SET_ALPHA_TEST_ENABLE, NV097_SET_ALPHA_TEST_ENABLE_V_FALSE);
    _pContext->hwState.kelvin.set1(NV097_SET_STENCIL_TEST_ENABLE, NV097_SET_STENCIL_TEST_ENABLE_V_FALSE);
    _pContext->hwState.kelvin.set1(NV097_SET_FOG_ENABLE, NV097_SET_FOG_ENABLE_V_FALSE);
#ifdef KPFS
    getDC()->nvKelvinPM.download_special(_pContext,&_program,0xFFFFFFFE);
#else
    _pContext->hwState.kelvin.set1(NV097_SET_TRANSFORM_EXECUTION_MODE,
         DRF_DEF(097, _SET_TRANSFORM_EXECUTION_MODE, _MODE, _PROGRAM) |
         DRF_DEF(097, _SET_TRANSFORM_EXECUTION_MODE, _RANGE_MODE, _PRIV));

    _pContext->hwState.kelvin.set1(NV097_SET_TRANSFORM_PROGRAM_CXT_WRITE_EN,
         DRF_DEF(097, _SET_TRANSFORM_PROGRAM_CXT_WRITE_EN, _V, _READ_ONLY));

    nvKelvinDownloadProgram(_pContext, &_program,0);

    _pContext->hwState.kelvin.set1 (NV097_SET_TRANSFORM_PROGRAM_START, 0);
#endif
    _pContext->hwState.kelvin.set1(NV097_INVALIDATE_VERTEX_CACHE_FILE, 0);

    /////////////////////////////////////////////////////////

    _pContext->hwState.kelvin.set1 (NV097_SET_COMBINER_CONTROL, 
        DRF_NUM(097, _SET_COMBINER_CONTROL, _ITERATION_COUNT, filterType[dwFilterType].dwNumCombinerStages)         |
        DRF_DEF(097, _SET_COMBINER_CONTROL, _MUX_SELECT, _LSB)           |
        DRF_DEF(097, _SET_COMBINER_CONTROL, _FACTOR0, _EACH_STAGE)       |
        DRF_DEF(097, _SET_COMBINER_CONTROL, _FACTOR1, _EACH_STAGE));

    for (i=0; i<filterType[dwFilterType].dwNumCombinerStages; i++) {
        _pContext->hwState.kelvin.set1 (NV097_SET_COMBINER_COLOR_ICW(i), filterType[dwFilterType].combinerInfo[i].dwICW);
        _pContext->hwState.kelvin.set1 (NV097_SET_COMBINER_COLOR_OCW(i), filterType[dwFilterType].combinerInfo[i].dwOCW);
        _pContext->hwState.kelvin.set1 (NV097_SET_COMBINER_ALPHA_ICW(i), filterType[dwFilterType].combinerInfo[i].dwICW |
            DRF_DEF(097, _SET_COMBINER_ALPHA, _ICW_A_ALPHA, _TRUE) |
            DRF_DEF(097, _SET_COMBINER_ALPHA, _ICW_B_ALPHA, _TRUE) |
            DRF_DEF(097, _SET_COMBINER_ALPHA, _ICW_C_ALPHA, _TRUE) |
            DRF_DEF(097, _SET_COMBINER_ALPHA, _ICW_D_ALPHA, _TRUE));
        _pContext->hwState.kelvin.set1 (NV097_SET_COMBINER_ALPHA_OCW(i), filterType[dwFilterType].combinerInfo[i].dwOCW);
        _pContext->hwState.kelvin.set1 (NV097_SET_COMBINER_FACTOR0(i), filterType[dwFilterType].combinerInfo[i].dwFactor0);
        _pContext->hwState.kelvin.set1 (NV097_SET_COMBINER_FACTOR1(i), filterType[dwFilterType].combinerInfo[i].dwFactor1);
    }

    /////////////////////////////////////////////////////

    float x0, y0;
    
    // This logic actually works whether we're upscaling or downscaling
    if (MethodInfo[dwMethod].dwKernel && !filterType[dwFilterType].bEmulateFilter) {
        x0 = 0.25 * BufferBltInfo[dwSimpleMethod].dwSuperBufferScaleX;
        y0 = 0.25 * BufferBltInfo[dwSimpleMethod].dwSuperBufferScaleY;
    } else {
        x0 = 0;
        y0 = 0;
    }

    if (IsMultisampling()) {
        if (bUpscaling) {
            x0 -= _appCompatibility.fXOffset;
            y0 -= _appCompatibility.fYOffset;
        } else {
            // match the offset we already added in nvSetKelvinTransform
            x0 += _appCompatibility.fXOffset * BufferBltInfo[dwSimpleMethod].dwSuperBufferScaleX;
            y0 += _appCompatibility.fYOffset * BufferBltInfo[dwSimpleMethod].dwSuperBufferScaleY;
        }
    } 

    float dx0 = filterType[dwFilterType].texStageInfo[0].fXOffset;
    float dy0 = filterType[dwFilterType].texStageInfo[0].fYOffset;
    float dx1 = filterType[dwFilterType].texStageInfo[1].fXOffset;
    float dy1 = filterType[dwFilterType].texStageInfo[1].fYOffset;
    float dx2 = filterType[dwFilterType].texStageInfo[2].fXOffset;
    float dy2 = filterType[dwFilterType].texStageInfo[2].fYOffset;
    float dx3 = filterType[dwFilterType].texStageInfo[3].fXOffset;
    float dy3 = filterType[dwFilterType].texStageInfo[3].fYOffset;
    
    if (bSubdivideAA) {
        float srcy0, srcy1, dsty0, dsty1;
        srcy0 = 0;
        dsty0 = 0;
        srcy1 = _strip.srcyinc.f;
        dsty1 = _strip.dstyinc.f;

        for (DWORD j=0; j<=_strip.num_strips; j++) {
            _pContext->hwState.kelvin.set1(NV097_SET_BEGIN_END, NV097_SET_BEGIN_END_OP_QUADS);
            getDC()->nvPusher.makeSpace (sizeSetStartMethod + 40);
            nvglSetStartMethod (0, NV_DD_KELVIN, NVPUSHER_NOINC(NV097_INLINE_ARRAY), 40);
            getDC()->nvPusher.inc (sizeSetStartMethod);

            if (j == _strip.num_strips) {
                srcy1 = srcy0 + _strip.srcyrem.f;
                dsty1 = dsty0 + _strip.dstyrem.f;
            }
            
            const float verts[4][10] = {
                {
                    0,                       dsty0,                 
                    x0+dx0,                  srcy0+y0+dy0, 
                    x0+dx1,                  srcy0+y0+dy1, 
                    x0+dx2,                  srcy0+y0+dy2, 
                    x0+dx3,                  srcy0+y0+dy3 
                }, {
                    pDst->getWidth(),        dsty0,                 
                    pSrc->getWidth()+x0+dx0, srcy0+y0+dy0, 
                    pSrc->getWidth()+x0+dx1, srcy0+y0+dy1, 
                    pSrc->getWidth()+x0+dx2, srcy0+y0+dy2, 
                    pSrc->getWidth()+x0+dx3, srcy0+y0+dy3 
                }, {
                    pDst->getWidth(),        dsty1, 
                    pSrc->getWidth()+x0+dx0, srcy1+y0+dy0, 
                    pSrc->getWidth()+x0+dx1, srcy1+y0+dy1, 
                    pSrc->getWidth()+x0+dx2, srcy1+y0+dy2, 
                    pSrc->getWidth()+x0+dx3, srcy1+y0+dy3
                }, {
                    0,                       dsty1, 
                    x0+dx0,                  srcy1+y0+dy0,
                    x0+dx1,                  srcy1+y0+dy1,
                    x0+dx2,                  srcy1+y0+dy2,
                    x0+dx3,                  srcy1+y0+dy3,
                }
            };
            
            
            for (i=0; i<40; i++) nvglSetData(i, *(DWORD *)&(((float *)verts)[i]));
            getDC()->nvPusher.inc(40);

            _pContext->hwState.kelvin.set1(NV097_SET_BEGIN_END, NV097_SET_BEGIN_END_OP_END);
    
            srcy0 = srcy1;
            dsty0 = dsty1;
            srcy1 += _strip.srcyinc.f;
            dsty1 += _strip.dstyinc.f;
        }
    } else {
        _pContext->hwState.kelvin.set1(NV097_SET_BEGIN_END, NV097_SET_BEGIN_END_OP_QUADS);
        
        getDC()->nvPusher.makeSpace (sizeSetStartMethod + 40);
        nvglSetStartMethod (0, NV_DD_KELVIN, NVPUSHER_NOINC(NV097_INLINE_ARRAY), 40);
        getDC()->nvPusher.inc (sizeSetStartMethod);
        
        const float verts[4][10] = {
            {
                0,                       0,
                x0+dx0,                  y0+dy0,
                x0+dx1,                  y0+dy1,
                x0+dx2,                  y0+dy2,
                x0+dx3,                  y0+dy3
            }, {
                pDst->getWidth(),        0,                 
                pSrc->getWidth()+x0+dx0, y0+dy0, 
                pSrc->getWidth()+x0+dx1, y0+dy1, 
                pSrc->getWidth()+x0+dx2, y0+dy2, 
                pSrc->getWidth()+x0+dx3, y0+dy3 
            }, {
                pDst->getWidth(),        pDst->getHeight(), 
                pSrc->getWidth()+x0+dx0, pSrc->getHeight()+y0+dy0, 
                pSrc->getWidth()+x0+dx1, pSrc->getHeight()+y0+dy1, 
                pSrc->getWidth()+x0+dx2, pSrc->getHeight()+y0+dy2, 
                pSrc->getWidth()+x0+dx3, pSrc->getHeight()+y0+dy3
            }, {
                0,                       pDst->getHeight(), 
                x0+dx0,                  pSrc->getHeight()+y0+dy0,
                x0+dx1,                  pSrc->getHeight()+y0+dy1,
                x0+dx2,                  pSrc->getHeight()+y0+dy2,
                x0+dx3,                  pSrc->getHeight()+y0+dy3,
            }
        };
        
        
        for (i=0; i<40; i++) nvglSetData(i, *(DWORD *)&(((float *)verts)[i]));
        getDC()->nvPusher.inc(40);
        
        _pContext->hwState.kelvin.set1(NV097_SET_BEGIN_END, NV097_SET_BEGIN_END_OP_END);
    }

    //////////////////////////////////////////////////
    // Gotta reset the whole shebang
    _pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_REALLY_FILTHY;
    if (bFlush) getDC()->nvPusher.flush (TRUE, CPushBuffer::FLUSH_WITH_DELAY);

    // Turn AA back on
    SetSampleMask();
    nvPusherStart(FALSE);
}


void CKelvinAAState::ScaledBlt(
    CSimpleSurface *pDst, 
    DWORD dwDstX,
    DWORD dwDstY,
    DWORD dwDstWidth, 
    DWORD dwDstHeight, 
    CSimpleSurface *pSrc, 
    double fSrcX,
    double fSrcY,
    DWORD dwSrcWidth,
    DWORD dwSrcHeight
    ) {

    nvAssert(_pContext);

    DWORD dwDstFormat = pDst->getFormat();
    DWORD dwSrcFormat = pSrc->getFormat();

    // Spoof the dst format
    switch (dwDstFormat) {
    case NV_SURFACE_FORMAT_Z16:
        dwDstFormat = NV_SURFACE_FORMAT_R5G6B5;
        break;
    case NV_SURFACE_FORMAT_Z24S8:
    case NV_SURFACE_FORMAT_Z24X8:
        dwDstFormat = NV_SURFACE_FORMAT_A8R8G8B8;
        break;
    }

    // Spoof the src format
    switch (dwSrcFormat) {
    case NV_SURFACE_FORMAT_Z16:
        dwSrcFormat = NV_SURFACE_FORMAT_R5G6B5;
        break;
    case NV_SURFACE_FORMAT_Z24S8:
    case NV_SURFACE_FORMAT_Z24X8:
        dwSrcFormat = NV_SURFACE_FORMAT_A8R8G8B8;
        break;
    }

    DWORD bDither = 1;

/////////////////////////////////////////////////////

    DWORD dwDstBPP = nvSurfaceFormatToBPP[dwDstFormat];
    DWORD dwSrcBPP = nvSurfaceFormatToBPP[dwSrcFormat];

/////////////////////////////////////////////////////

    nvPushData(0, dDrawSubchannelOffset(NV_DD_ROP) | SET_ROP_OFFSET | 0x40000);
    nvPushData(1, (SRCCOPY >> 16));
    nvPusherAdjust(2);
    getDC()->bltData.dwLastRop = (SRCCOPY >> 16);

/////////////////////////////////////////////////////

    DWORD dwSrcOffset, dwDstOffset;
    DWORD dwSrcPitch, dwDstPitch;
    DWORD dwSrcPoint, dwDstPoint;
    DWORD dwDsDx, dwDtDy;
    DWORD dwSrcSize, dwDstSize;
    DWORD dwSrcX, dwSrcY;
    DWORD bFOH, bCenter;


    dwSrcPitch = pSrc->getPitch();
    dwDstPitch = pDst->getPitch();

    dwDstOffset  = pDst->getOffset() + (dwDstBPP * dwDstX + dwDstPitch * dwDstY);
    dwDstX       = 0;
    dwDstY       = 0;
    if (dwDstOffset & NV_BYTE_ALIGNMENT_PAD) {
        dwDstX      += (dwDstOffset & NV_BYTE_ALIGNMENT_PAD) / dwDstBPP;
        dwDstOffset &= ~NV_BYTE_ALIGNMENT_PAD;
    }

    dwSrcX = (DWORD)(fSrcX * 16);
    dwSrcY = (DWORD)(fSrcY * 16);
    dwSrcOffset = pSrc->getOffset() + (dwSrcBPP * (dwSrcX >> 4) + dwSrcPitch * (dwSrcY >> 4));
    dwSrcX     &= 0xf;
    dwSrcY     &= 0xf;
    if (dwSrcOffset & NV_BYTE_ALIGNMENT_PAD) {
        dwSrcX      += ((dwSrcOffset & NV_BYTE_ALIGNMENT_PAD) / dwSrcBPP) << 4;
        dwSrcOffset &= ~NV_BYTE_ALIGNMENT_PAD;
    }

    dwDstSize = (dwDstHeight << 16) | dwDstWidth;
    dwSrcSize = (dwSrcHeight << 16) | dwSrcWidth;

    dwDstPoint = (dwDstY << 16) | dwDstX;
    dwSrcPoint = (dwSrcY << 20) | (dwSrcX << 4);

    dwDsDx = DWORD((__int64(dwSrcWidth) << 20) / __int64(dwDstWidth));
    dwDtDy = DWORD((__int64(dwSrcHeight) << 20) / __int64(dwDstHeight));

    bFOH = 1;
    bCenter = 0;

///////////////////////////////////////////////

//    nvAssert(!(dwSrcSize & 0xfffefffe));
//    nvAssert(!(dwDstSize & 0xfffefffe));

///////////////////////////////////////////////

    nvPushData ( 0, dDrawSubchannelOffset(NV_DD_SURFACES) | SURFACES_2D_SET_COLOR_FORMAT_OFFSET | 0x100000);
    nvPushData ( 1, nv062SurfaceFormat[dwSrcFormat]);    // SetColorFormat
    nvPushData ( 2, (dwDstPitch << 16) | dwSrcPitch); // SetPitch
    nvPushData ( 3, dwSrcOffset);                     // SetOffset
    nvPushData ( 4, dwDstOffset);                     // SetOffset
    nvPusherAdjust (5);
    getDC()->bltData.dwLastColourFormat = nv062SurfaceFormat[dwSrcFormat];
    getDC()->bltData.dwLastCombinedPitch = (dwDstPitch << 16) | dwSrcPitch;
    getDC()->bltData.dwLastSrcOffset = dwSrcOffset;
    getDC()->bltData.dwLastDstOffset = dwDstOffset;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000);
    nvPushData(1, NV_DD_CONTEXT_COLOR_KEY);
    nvPushData(2, dDrawSubchannelOffset(NV_DD_SPARE) | SET_TRANSCOLOR_OFFSET | 0x40000);
    nvPushData(3, 0);
    nvPusherAdjust(4);
    getDC()->bltData.dwLastColourKey = 0xFFFFFFFF;
    getDC()->dDrawSpareSubchannelObject = NV_DD_CONTEXT_COLOR_KEY;


    nvPushData ( 0, dDrawSubchannelOffset(NV_DD_STRETCH) | 0x40000);
    nvPushData ( 1, NV_DD_SCALED_IMAGE_IID);
    nvPushData ( 2, dDrawSubchannelOffset(NV_DD_STRETCH) | SCALED_IMAGE_CONTEXT_DMA_IMAGE_OFFSET | 0x40000);
    nvPushData ( 3, NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY); // SetContextDmaImage
    nvPushData ( 4, dDrawSubchannelOffset(NV_DD_STRETCH) | SCALED_IMAGE_SET_COLOR_FORMAT | 0x40000);
    nvPushData ( 5, nv089SurfaceFormat[dwDstFormat]); // SetColorFormat
    nvPushData ( 6, dDrawSubchannelOffset(NV_DD_STRETCH) | SCALED_IMAGE_CLIPPOINT_OFFSET | 0x180000);
    nvPushData ( 7, dwDstPoint);             // ClipPoint
    nvPushData ( 8, dwDstSize);              // ClipSize
    nvPushData ( 9, dwDstPoint);             // ImageOutPoint
    nvPushData (10, dwDstSize);              // ImageOutSize
    nvPushData (11, dwDsDx);                 // DsDx
    nvPushData (12, dwDtDy);                 // DtDy
    nvPushData (13, dDrawSubchannelOffset(NV_DD_STRETCH) | SCALED_IMAGE_IMAGE_IN_SIZE_OFFSET | 0x100000);
    nvPushData (14, dwSrcSize);              // ImageInSize
    nvPushData (15, (bFOH ? (NV077_IMAGE_IN_FORMAT_INTERPOLATOR_FOH << 24)
                          : (NV077_IMAGE_IN_FORMAT_INTERPOLATOR_ZOH << 24)) |     // ImageInFormat
                    (bCenter ? (NV077_IMAGE_IN_FORMAT_ORIGIN_CENTER << 16)
                             : (NV077_IMAGE_IN_FORMAT_ORIGIN_CORNER << 16)) |
                    dwSrcPitch);
    nvPushData (16, dwSrcOffset);            // ImageInOffset
    nvPushData (17, dwSrcPoint);             // ImageInPoint

    if (bDither) {
        nvPushData (18, dDrawSubchannelOffset(NV_DD_STRETCH) | NV089_SET_COLOR_CONVERSION | 0x40000);
        nvPushData (19, NV089_SET_COLOR_CONVERSION_DITHER); // SetColorFormat
        nvPusherAdjust (20);
    } else {
        nvPusherAdjust (18);
    }

    nvPusherStart (TRUE);

    getDC()->TwoDRenderingOccurred   = TRUE;
    getDC()->ThreeDRenderingOccurred = 0;

    _pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_REALLY_FILTHY;
    
} 

extern "C" void __CxxFrameHandler() {
    // WARNING: This frame handler does absolutely nothing.  It's only
    // defined because it's required by __try/__except blocks, and apparently
    // we can't link in the library that has the real function.  If you hit this
    // int 3, make absolutely sure that the behavior is what you want.
#ifdef DEBUG
    __asm int 3;
#endif
}

char * nvGetCommandLine() {
#ifdef WINNT
    if (getDC()->nvD3DRegistryData.regAACompatibilityBits) {
        // the address is defined in the registry; load it
        char **pCmdLinePtrPtr = (char **)(~getDC()->nvD3DRegistryData.regAACompatibilityBits);

        if (*pCmdLinePtrPtr) {
            return *pCmdLinePtrPtr;
        } else {
            // somebody input the wrong registry value, and we were lucky to trap the null pointer
            dbgD3DError();
            return "";
        }
    } else {
        // nothing in the registry; iterate through our list of known possible 
        // locations, trying to determine which one will work, and using exception
        // handlers to gracefully recover.

#define MAX_GCL_PTRS 3
        // To add a new OS:
        // - Write a small program to return the address of the GetCommandLine function (say, 0x77e871cc)
        // - While still in the program (so that the DLL doesn't get unmapped), break into SoftICE and
        //   disassemble starting at that address ("u 77e871cc").
        // - There should be a line looking something like "mov eax, [77ee0694]".  The number in the 
        //   brackets is the one you want
        // - Add it to the list below, making sure to comment the OS, service pack, and build number
        // - I suggest adding the item to the bottom of the list and testing, to ensure that when it
        //   runs through the existing pointers, the excpetion handling works correctly.

        static const char **ppGCL[MAX_GCL_PTRS] = {
            (const char **)0x77edf694,    // Win2k SP1
            (const char **)0x77ee0694,    // Win2k, no SP
            (const char **)0x77e48fdc,    // Whistler build 2416
        };

        static char pCmdLine[256];
        int i, j, len;
    
        for (i=0; i<MAX_GCL_PTRS; i++) {
            __try {
                // This memcpy will throw an exception if the pointer is bad, though try/except
                // only works for user-space pointers.  Check that the pointer we look at is <2 GB,
                // and attempt the copy.

                nvAssert(ppGCL[i] < (const char **)0x80000000);      // no kernel-space pointers should be put in ppGCL!
                if (*ppGCL[i] >= (const char *)0x80000000) continue; // check that the dereferenced pointer is also <2 GB

                memcpy(pCmdLine, *ppGCL[i], 256);
    
                for (j=0; j<256; j++) if (!pCmdLine[j]) break;
                
                if (j == 256) continue; // no null character in string; we must be looking at the wrong memory
    
                len = j;
                if (len < 5) continue; // the filename better have at least one character, a dot, and an extension

                for (j=0; j<len; j++) if ((pCmdLine[j] > 0) && (pCmdLine[j] < 32)) continue; // hmmm, hit some control characters; abort.

                break; // looks like we found one that works
            } __except (EXCEPTION_EXECUTE_HANDLER) {
                continue;
            }
        }

        if (i == MAX_GCL_PTRS) {
            // we tried all the pointers in ppGCL, and they all failed
            return "";
        } else {
            return (char *)pCmdLine;
        }
    }

#else
    // under Win9x, we don't have to go through this mess
    return GetCommandLine();
#endif
}


void CKelvinAAState::InitAppCompatibility() {
    char *pCmdLine = nvGetCommandLine();

    static const AppCompatibilityStruct AppCompatibilitySettings[] = {
        {0x7ce92a196eb3e4a8, APPFLAGS_FORCE_SUPERSAMPLE, 0.04, 0.04},     // "monkey4.exe"          Escape From Monkey Island
        {0x97b0a9f590eb304f, APPFLAGS_FORCE_SUPERSAMPLE, 0, 0},           // "gpolice.exe"          G-Police
        {0x61053382419baf37, 0, 0.04, 0.04},                              // "hh2002_demo.exe"      High Heat Baseball 2002
        {0xd528be9ef82890fa, APPFLAGS_FORCE_SUPERSAMPLE, 0, 0},           // "monsterx.exe"         Monster Truck Madness 1/2
        {0x7814373c4b0b7201, APPFLAGS_WRITE_ACCESS_ON_ENDSCENE, 0, 0},    // "mrball.exe"           Mr Ball
        {0x8e039f4e0d3c4a75, APPFLAGS_FORCE_SUPERSAMPLE, 0, 0},           // "newhaas.exe"          Newman Hass Racing
        {0x925ac5084c34c71f, 0, -0.25, -0.25},                            // "lithtech.exe"         No One Lives Forever demo
        {0xbe568edf15a298b0, APPFLAGS_DOWNSAMPLE_ON_BLIT, 0, 0},          // "pop3ddemo.exe"        Prince of Persia demo
        {0x1ed8331bc713a59c, APPFLAGS_DISABLE_AA, 0, 0},                  // "revenant.exe"         Revenant
        {0xc9360a7086bac23c, APPFLAGS_FORCE_UNCOMPRESSED_Z, 0, 0},        // "kamdemo.exe"          Star Trek: Klingon Academy
        {0x8c02d8d6d094cf9a, 0, -1.0, -1.0},                              // "unrealtournament.exe" Unreal Tournament
        {0x849ce96f91d533d9, APPFLAGS_DOWNSAMPLE_ON_BLIT | APPFLAGS_FORCE_SUPERSAMPLE, 0, 0},        // "armada.exe" Star Trek Armada
        {0x0fb32fa59c3762d6, APPFLAGS_MAGNIFY_AFTER_FLIP | APPFLAGS_DOWNSAMPLE_ON_BLIT, 0, 0},     // "lemmings revolution.exe" Lemmings Revolution
        {0xb7c39ae78e70f3d3, 0,0.25,0.25},                                //"aquanox.exe"           Aquanox
        {0xfffe65aaac391e60, APPFLAGS_DISABLE_DITHER,0.25,0.0},           //"linksmmi.exe"          Msft Links2001
        {0x34b3962ff618545d, 0,0,0.25},                                   //"fs2.exe"               Descent Freepace 2, partial fix
        {0xd9e267694cee1255, APPFLAGS_FORCE_SUPERSAMPLE, 0.2501,0.25},    //"game.exe"              Driver, also matches Diablo II (.25->.2501 for Quincunx AA on Diablo)
        {0x0000000000000000, 0, 0, 0}   
    };

    
    char pLCCmdLine[256];
    strncpy(pLCCmdLine, pCmdLine, 256);
    pLCCmdLine[255] = 0;
    _strlwr(pLCCmdLine);

    char *pPos = strstr(pLCCmdLine, ".exe");
    char *pEnd = pPos + 4;
    char pExeName[256];

    
    if (pPos) {
        while ((pPos >= pLCCmdLine) && (*pPos != '\\') && (*pPos != '"')) pPos--;
        pPos++;

        int len = pEnd - pPos;

        strncpy(pExeName, pPos, len);
        pExeName[len] = 0;
    } else {
        pExeName[0] = 0;
    }
    


    _appCompatibility.qwHashVal = nvHash64((unsigned char *)pExeName, strlen(pExeName));
    DPF("Program name/hash value: \"%s\" = 0x%08x%08x", pExeName, (DWORD)(_appCompatibility.qwHashVal>>32), (DWORD)(_appCompatibility.qwHashVal&0xffffffff));  

    for (int i=0; AppCompatibilitySettings[i].qwHashVal; i++) {
        if (_appCompatibility.qwHashVal == AppCompatibilitySettings[i].qwHashVal) {
            _appCompatibility = AppCompatibilitySettings[i];
            //DPF (">>>>>>>>>>>>> matched");
            break;
        }
    }
}

/////////////////////////////////////////////////////////////////////////////


/*
--------------------------------------------------------------------
hash() -- hash a variable-length key into a 64-bit value
  k     : the key (the unaligned variable-length array of bytes)
  len   : the length of the key, counting by bytes
  level : can be any 8-byte value
Returns a 64-bit value.  Every bit of the key affects every bit of
the return value.  No funnels.  Every 1-bit and 2-bit delta achieves
avalanche.  About 41+5len instructions.

The best hash table sizes are powers of 2.  There is no need to do
mod a prime (mod is sooo slow!).  If you need less than 64 bits,
use a bitmask.  For example, if you need only 10 bits, do
  h = (h & hashmask(10));
In which case, the hash table should have hashsize(10) elements.

If you are hashing n strings (ub1 **)k, do it like this:
  for (i=0, h=0; i<n; ++i) h = hash( k[i], len[i], h);

By Bob Jenkins, Jan 4 1997.  bob_jenkins@burtleburtle.net.  You may
use this code any way you wish, private, educational, or commercial,
as long as this whole comment accompanies it.

See http://burtleburtle.net/bob/hash/evahash.html
Use for hash table lookup, or anything where one collision in 2^^64
is acceptable.  Do NOT use for cryptographic purposes.
--------------------------------------------------------------------
*/

#define mix64(a,b,c) do { \
    a -= b; a -= c; a ^= (c>>43); \
    b -= c; b -= a; b ^= (a<<9); \
    c -= a; c -= b; c ^= (b>>8); \
    a -= b; a -= c; a ^= (c>>38); \
    b -= c; b -= a; b ^= (a<<23); \
    c -= a; c -= b; c ^= (b>>5); \
    a -= b; a -= c; a ^= (c>>35); \
    b -= c; b -= a; b ^= (a<<49); \
    c -= a; c -= b; c ^= (b>>11); \
    a -= b; a -= c; a ^= (c>>12); \
    b -= c; b -= a; b ^= (a<<18); \
    c -= a; c -= b; c ^= (b>>22); \
} while (0)

uint64 nvHash64(unsigned char *k, unsigned int length) {
    uint64 a,b,c;
    unsigned int len;
    
    // Set up the internal state
    len = length;
    a = b = 0;
    c = 0x9e3779b97f4a7c13; // the golden ratio; an arbitrary value
    
    // handle most of the key
    while (len >= 24) {
        a += ((uint64)k[0]       + ((uint64)k[ 1]<< 8) + ((uint64)k[ 2]<<16) + ((uint64)k[ 3]<<24)
          +  ((uint64)k[4 ]<<32) + ((uint64)k[ 5]<<40) + ((uint64)k[ 6]<<48) + ((uint64)k[ 7]<<56));
        b += ((uint64)k[8]       + ((uint64)k[ 9]<< 8) + ((uint64)k[10]<<16) + ((uint64)k[11]<<24)
          +  ((uint64)k[12]<<32) + ((uint64)k[13]<<40) + ((uint64)k[14]<<48) + ((uint64)k[15]<<56));
        c += ((uint64)k[16]      + ((uint64)k[17]<< 8) + ((uint64)k[18]<<16) + ((uint64)k[19]<<24)
          +  ((uint64)k[20]<<32) + ((uint64)k[21]<<40) + ((uint64)k[22]<<48) + ((uint64)k[23]<<56));
        
        mix64(a,b,c);
        k += 24; len -= 24;
    }
    
    // handle the last 23 bytes
    c += length;
    switch (len) {
    case 23: c+=((uint64)k[22]<<56);
    case 22: c+=((uint64)k[21]<<48);
    case 21: c+=((uint64)k[20]<<40);
    case 20: c+=((uint64)k[19]<<32);
    case 19: c+=((uint64)k[18]<<24);
    case 18: c+=((uint64)k[17]<<16);
    case 17: c+=((uint64)k[16]<<8);
    // the first byte of c is reserved for the length
    case 16: b+=((uint64)k[15]<<56);
    case 15: b+=((uint64)k[14]<<48);
    case 14: b+=((uint64)k[13]<<40);
    case 13: b+=((uint64)k[12]<<32);
    case 12: b+=((uint64)k[11]<<24);
    case 11: b+=((uint64)k[10]<<16);
    case 10: b+=((uint64)k[ 9]<<8);
    case  9: b+=((uint64)k[ 8]);
    case  8: a+=((uint64)k[ 7]<<56);
    case  7: a+=((uint64)k[ 6]<<48);
    case  6: a+=((uint64)k[ 5]<<40);
    case  5: a+=((uint64)k[ 4]<<32);
    case  4: a+=((uint64)k[ 3]<<24);
    case  3: a+=((uint64)k[ 2]<<16);
    case  2: a+=((uint64)k[ 1]<<8);
    case  1: a+=((uint64)k[ 0]);
    // case 0: nothing left to add
    }
    
    mix64(a,b,c);
    
    return c;
}

#endif // NVARCH >= 0x020
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\kelvin\src\nvKelvinColorCombiners.cpp ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// ********************************* Direct 3D ******************************
//
//  Module: nvKelvinColorCombiners.cpp
//      routines for setting up the Kelvin color combiners from
//      DX6-style texture stages
//
// **************************************************************************
//
//  History:
//      Craig Duttweiler        29Mar00         NV20 development
//
// **************************************************************************
#include "nvprecomp.h"

#if (NVARCH >= 0x20)

//---------------------------------------------------------------------------

// Set a color input to to 1 or -1

void nvKelvinCCSetColorInputOne (PNVD3DCONTEXT pContext, kelvinCombinerInput eInput,
                                 DWORD dwCombinerStage, BOOL bNegate)
{
    DWORD dwICW = 0;

    dwICW |= bNegate ? DRF_DEF (097, _SET_COMBINER_COLOR, _ICW_D_MAP, _EXPAND_NORMAL) :
                       DRF_DEF (097, _SET_COMBINER_COLOR, _ICW_D_MAP, _UNSIGNED_INVERT);

    dwICW |= DRF_DEF (097, _SET_COMBINER_COLOR, _ICW_D_ALPHA, _FALSE);
    dwICW |= DRF_DEF (097, _SET_COMBINER_COLOR, _ICW_D_SOURCE, _REG_0);

    pContext->hwState.dwColorICW[dwCombinerStage] |= (dwICW << kelvinCombinerInputShift[eInput]);
}

//---------------------------------------------------------------------------

// Select the source for combiner input eInput in combiner stage
// dwCombinerStage from argument dwD3DTSSArg in D3D stage dwD3DStage.
// return TSS_USES_NULL_TEXTURE if we reference a texture we don't have

HRESULT nvKelvinCCSelectColorInput (PNVD3DCONTEXT pContext, kelvinCombinerInput eInput,
                                    DWORD dwCombinerStage, DWORD dwD3DStage, DWORD dwD3DTSSArg,
                                    BOOL bComplement, BOOL bExpandNormal, BOOL bAlphaReplicate)
{
    DWORD dwICW = 0;
    DWORD dwCurrentUsed = FALSE; //slight hack to fix D3DTA_CURRENT issues.  This should be cleaner.
    int i;

    switch (pContext->tssState[dwD3DStage].dwValue[dwD3DTSSArg] & D3DTA_SELECTMASK) {
        case D3DTA_CURRENT:
            if (dwD3DStage != 0)
            {
                for (i=dwD3DStage - 1;i>=0;i--)
                {
                    if (pContext->tssState[i].dwValue[D3DTSS_RESULTARG] != D3DTA_TEMP)
                    {
                        dwCurrentUsed=TRUE;
                        break;
                    }
                }

            }
            if (dwCurrentUsed == TRUE) 
            {
                // Output from previous stage
                dwICW |= DRF_DEF (097, _SET_COMBINER_COLOR, _ICW_D_SOURCE, _REG_C);
                break;
            }
            // else, default to diffuse below
        case D3DTA_DIFFUSE:
            dwICW |= DRF_DEF (097, _SET_COMBINER_COLOR, _ICW_D_SOURCE, _REG_4);
            break;
        case D3DTA_TEXTURE:
            if (!(pContext->tssState[dwD3DStage].dwValue[D3DTSS_TEXTUREMAP])) {
                // if we don't actually have a texture, default to the 'current'.
                // yes, this is actually the d3d default: select texture with no texture.
                // my mama done told me, my name was duh microsoft.
                return (TSS_USES_NULL_TEXTURE);
            }
            else {
                if (pContext->hwState.dwNextAvailableTextureUnit < KELVIN_NUM_TEXTURES) {
                    pContext->hwState.dwTexUnitToTexStageMapping[pContext->hwState.dwNextAvailableTextureUnit] = dwD3DStage;
                    dwICW |= DRF_NUM (097, _SET_COMBINER_COLOR, _ICW_D_SOURCE, KELVIN_COMBINER_REG_TEX0 + pContext->hwState.dwNextAvailableTextureUnit);
                }
                else {
                    pContext->hwState.dwStateFlags |= KELVIN_FLAG_SETUPFAILURE;
                    dwICW |= DRF_DEF (097, _SET_COMBINER_COLOR, _ICW_D_SOURCE, _REG_0);
                }
            }
            break;
        case D3DTA_TFACTOR:
            dwICW |= DRF_DEF (097, _SET_COMBINER_COLOR, _ICW_D_SOURCE, _REG_1);
            break;
        case D3DTA_SPECULAR:
            dwICW |= DRF_DEF (097, _SET_COMBINER_COLOR, _ICW_D_SOURCE, _REG_5);
            pContext->hwState.dwStateFlags |= KELVIN_FLAG_COMBINERSNEEDSPECULAR;
            break;
        case D3DTA_TEMP:
            dwICW |= DRF_DEF(056, _SET_COMBINER_COLOR, _ICW_D_SOURCE, _REG_D);
            break;
        default:
            DPF ("unknown / illegal color argument '%d' in nvKelvinCCSelectColorInput",
                 pContext->tssState[dwD3DStage].dwValue[dwD3DTSSArg] & D3DTA_SELECTMASK);
            dbgD3DError();
            pContext->hwState.dwStateFlags |= KELVIN_FLAG_SETUPFAILURE;
            break;
    }

    // Now handle the alpha replicate and complement flags

    bAlphaReplicate |= (pContext->tssState[dwD3DStage].dwValue[dwD3DTSSArg] & D3DTA_ALPHAREPLICATE);

    dwICW |= bAlphaReplicate ? DRF_DEF (097, _SET_COMBINER_COLOR, _ICW_D_ALPHA, _TRUE) :
                               DRF_DEF (097, _SET_COMBINER_COLOR, _ICW_D_ALPHA, _FALSE);

    bComplement = ((pContext->tssState[dwD3DStage].dwValue[dwD3DTSSArg] & D3DTA_COMPLEMENT) ^
                   ((bComplement) ? D3DTA_COMPLEMENT : 0))
                  ?
                  TRUE : FALSE;

    if (bExpandNormal) {
        dwICW |= bComplement ? DRF_DEF (097, _SET_COMBINER_COLOR, _ICW_D_MAP, _EXPAND_NEGATE) :
                               DRF_DEF (097, _SET_COMBINER_COLOR, _ICW_D_MAP, _EXPAND_NORMAL);
    }
    else {
        dwICW |= bComplement ? DRF_DEF (097, _SET_COMBINER_COLOR, _ICW_D_MAP, _UNSIGNED_INVERT) :
                               DRF_DEF (097, _SET_COMBINER_COLOR, _ICW_D_MAP, _UNSIGNED_IDENTITY);
    }

    pContext->hwState.dwColorICW[dwCombinerStage] |= (dwICW << kelvinCombinerInputShift[eInput]);
    return (D3D_OK);
}

//---------------------------------------------------------------------------

// Select the input into A
static HRESULT nvKelvinCCSelect1 (PNVD3DCONTEXT pContext, DWORD dwHWStage, DWORD dwD3DStage)
{
    HRESULT hr;
    // A * 1
    hr = nvKelvinCCSelectColorInput (pContext, kelvinCombinerInputA, dwHWStage, dwD3DStage, D3DTSS_COLORARG1, FALSE, FALSE, FALSE);
    nvKelvinCCSetColorInputOne (pContext, kelvinCombinerInputB, dwHWStage, FALSE);
    // C & D default to zero
    return (hr);
}

//---------------------------------------------------------------------------

// Select the input into D
static HRESULT nvKelvinCCSelect2 (PNVD3DCONTEXT pContext, DWORD dwHWStage, DWORD dwD3DStage)
{
    HRESULT hr;
    // Multiply D * 1
    nvKelvinCCSetColorInputOne (pContext, kelvinCombinerInputC, dwHWStage, FALSE);
    hr = nvKelvinCCSelectColorInput (pContext, kelvinCombinerInputD, dwHWStage, dwD3DStage, D3DTSS_COLORARG2, FALSE, FALSE, FALSE);
    // A & B default to zero
    return (hr);
}

//---------------------------------------------------------------------------

static HRESULT nvKelvinCCModulate (PNVD3DCONTEXT pContext, DWORD dwHWStage, DWORD dwD3DStage)
{
    HRESULT hr;
    // Multiply A * B
    hr  = nvKelvinCCSelectColorInput (pContext, kelvinCombinerInputA, dwHWStage, dwD3DStage, D3DTSS_COLORARG1, FALSE, FALSE, FALSE);
    hr |= nvKelvinCCSelectColorInput (pContext, kelvinCombinerInputB, dwHWStage, dwD3DStage, D3DTSS_COLORARG2, FALSE, FALSE, FALSE);
    // C & D default to zero
    return (hr);
}

//---------------------------------------------------------------------------

static HRESULT nvKelvinCCAdd (PNVD3DCONTEXT pContext, DWORD dwHWStage, DWORD dwD3DStage)
{
    HRESULT hr;
    // Multiply A * 1(B)
    hr = nvKelvinCCSelectColorInput (pContext, kelvinCombinerInputA, dwHWStage, dwD3DStage, D3DTSS_COLORARG1, FALSE, FALSE, FALSE);
    // Make B 1
    nvKelvinCCSetColorInputOne (pContext, kelvinCombinerInputB, dwHWStage, FALSE);
    // Multiply 1(C) * D
    nvKelvinCCSetColorInputOne (pContext, kelvinCombinerInputC, dwHWStage, FALSE);
    hr |= nvKelvinCCSelectColorInput (pContext, kelvinCombinerInputD, dwHWStage, dwD3DStage, D3DTSS_COLORARG2, FALSE, FALSE, FALSE);
    // Implicit A + D
    return (hr);
}

//---------------------------------------------------------------------------

static HRESULT nvKelvinCCSub (PNVD3DCONTEXT pContext, DWORD dwHWStage, DWORD dwD3DStage)
{
    HRESULT hr;
    // Multiply A * 1
    hr = nvKelvinCCSelectColorInput (pContext, kelvinCombinerInputA, dwHWStage, dwD3DStage, D3DTSS_COLORARG1, FALSE, FALSE, FALSE);
    nvKelvinCCSetColorInputOne (pContext, kelvinCombinerInputB, dwHWStage, FALSE);
    // Multiply D * -1
    nvKelvinCCSetColorInputOne (pContext, kelvinCombinerInputC, dwHWStage, TRUE);
    hr |= nvKelvinCCSelectColorInput (pContext, kelvinCombinerInputD, dwHWStage, dwD3DStage, D3DTSS_COLORARG2, FALSE, FALSE, FALSE);
    // Implicit A + -D
    return (hr);
}

//---------------------------------------------------------------------------

static HRESULT nvKelvinCCAddSmooth (PNVD3DCONTEXT pContext, DWORD dwHWStage, DWORD dwD3DStage)
{
    HRESULT hr;
    // Multiply A * 1
    hr = nvKelvinCCSelectColorInput (pContext, kelvinCombinerInputA, dwHWStage, dwD3DStage, D3DTSS_COLORARG1, FALSE, FALSE, FALSE);
    nvKelvinCCSetColorInputOne (pContext, kelvinCombinerInputB, dwHWStage, FALSE);
    // Make C: (1-arg1), make D: arg2
    hr |= nvKelvinCCSelectColorInput (pContext, kelvinCombinerInputC, dwHWStage, dwD3DStage, D3DTSS_COLORARG1, TRUE, FALSE, FALSE);
    hr |= nvKelvinCCSelectColorInput (pContext, kelvinCombinerInputD, dwHWStage, dwD3DStage, D3DTSS_COLORARG2, FALSE, FALSE, FALSE);
    return (hr);
}

//---------------------------------------------------------------------------

static HRESULT nvKelvinCCBlendAlpha (PNVD3DCONTEXT pContext, DWORD dwHWStage, DWORD dwD3DStage, DWORD dwType)
{
    HRESULT hr;
    DWORD   dwTemp;

    // Multiply A * B(alpha)
    hr = nvKelvinCCSelectColorInput (pContext, kelvinCombinerInputA, dwHWStage, dwD3DStage, D3DTSS_COLORARG1, FALSE, FALSE, FALSE);

    if (dwType == TEXTUREPM) // this type defined by us
    {
        // Make B 1 since texture is already pre-multiplied
        nvKelvinCCSetColorInputOne (pContext, kelvinCombinerInputB, dwHWStage, FALSE);
        // set type again for making C (1-alpha) below
        dwType = D3DTA_TEXTURE;
    }
    else
    {
        // Make B alpha, appropriate type
        dwTemp = pContext->tssState[dwD3DStage].dwValue[D3DTSS_COLORARG2];
        pContext->tssState[dwD3DStage].dwValue[D3DTSS_COLORARG2] = dwType;
        hr |= nvKelvinCCSelectColorInput (pContext, kelvinCombinerInputB, dwHWStage, dwD3DStage, D3DTSS_COLORARG2, FALSE, FALSE, TRUE);
        // copy arg2 back
        pContext->tssState[dwD3DStage].dwValue[D3DTSS_COLORARG2] = dwTemp;
    }

    // Make C: 1-alpha, make D: arg2
    dwTemp = pContext->tssState[dwD3DStage].dwValue[D3DTSS_COLORARG1];
    pContext->tssState[dwD3DStage].dwValue[D3DTSS_COLORARG1] = dwType;
    hr |= nvKelvinCCSelectColorInput (pContext, kelvinCombinerInputC, dwHWStage, dwD3DStage, D3DTSS_COLORARG1, TRUE, FALSE, TRUE);
    // copy back to colorarg1
    pContext->tssState[dwD3DStage].dwValue[D3DTSS_COLORARG1] = dwTemp;
    hr |= nvKelvinCCSelectColorInput (pContext, kelvinCombinerInputD, dwHWStage, dwD3DStage, D3DTSS_COLORARG2, FALSE, FALSE, FALSE);

    return (hr);
}

//---------------------------------------------------------------------------

// The way D3D does this, it essentially allows using texture from stage 1
// in stage1 twice.  D3D does not normally allow you to use a texture in
// stage 0 and stage1.  This way, D3D allows you to modulate in (effectively)
// stage 0 and then do whatever it is you are going to do in stage1.  The
// key is that we use the texture from stage1 (since there is really no texture
// in stage 0)

// Premodulate in stage (i-1) is effectively selectarg1
// Then, in stage i, modulate current color (the above) with texture in stage i
// Then, do the operation chosen for stage i

static HRESULT nvKelvinCCPremodulate (PNVD3DCONTEXT pContext, DWORD dwHWStage, DWORD dwD3DStage)
{
    HRESULT hr;
    DWORD   dwTemp;

    DPF ("pre-modulationis totally broken");
    dbgD3DError();

    if (dwD3DStage == 0) {
        if (pContext->tssState[1].dwValue[D3DTSS_COLOROP] != D3DTOP_DISABLE) {
            // This modulates selectarg1(stage0) with texture(stage1) now!
            // The right solution is really to wait and see if there is a stage 1
            // make A: colorArg1(0), make B: texture(nextstage)
            hr = nvKelvinCCSelectColorInput (pContext, kelvinCombinerInputA, dwHWStage, dwD3DStage, D3DTSS_COLORARG1, FALSE, FALSE, FALSE);
            // This is a bit of a hack here since we use colorarg from stage 0
            // but we get the texture from stage 1 (told to in SelectB)
            dwTemp = pContext->tssState[dwD3DStage].dwValue[D3DTSS_COLORARG2];
            pContext->tssState[dwD3DStage].dwValue[D3DTSS_COLORARG2] = D3DTA_TEXTURE;
            hr |= nvKelvinCCSelectColorInput (pContext, kelvinCombinerInputB, dwHWStage, dwD3DStage, D3DTSS_COLORARG2, FALSE, FALSE, FALSE);
            // reset back arg2
            pContext->tssState[dwD3DStage].dwValue[D3DTSS_COLORARG2] = dwTemp;
        }
        else {
            // asked to do premodulate on a single texture stage -- just pass down
            // the colorarg1
            hr = nvKelvinCCSelectColorInput (pContext, kelvinCombinerInputA, dwHWStage, dwD3DStage, D3DTSS_COLORARG1, FALSE, FALSE, FALSE);
            nvKelvinCCSetColorInputOne (pContext, kelvinCombinerInputB, dwHWStage, FALSE);
        }
    }
    else // well, right now we only handle two stages (we could compress these)
    {
        // if pre-modulate is called in stage1, we could modulate with
        // texture from next stage. But, we'd have to handle settexture a bit
        // differently. For now, we'll just use selectarg1
        hr = nvKelvinCCSelectColorInput (pContext, kelvinCombinerInputA, dwHWStage, dwD3DStage, D3DTSS_COLORARG1, FALSE, FALSE, FALSE);
        nvKelvinCCSetColorInputOne (pContext, kelvinCombinerInputB, dwHWStage, FALSE);

        //DCR check for premodulate on stage 0?
    }

    return (hr);
}

//---------------------------------------------------------------------------

static HRESULT nvKelvinCCModulateAlpha (PNVD3DCONTEXT pContext, DWORD dwHWStage, DWORD dwD3DStage, BOOL bComplement)
{
    HRESULT hr;
    // A * 1
    hr = nvKelvinCCSelectColorInput (pContext, kelvinCombinerInputA, dwHWStage, dwD3DStage, D3DTSS_COLORARG1, FALSE, FALSE, FALSE);
    nvKelvinCCSetColorInputOne (pContext, kelvinCombinerInputB, dwHWStage, FALSE);
    // Set C alpha(arg1), Set D: arg2
    hr |= nvKelvinCCSelectColorInput (pContext, kelvinCombinerInputC, dwHWStage, dwD3DStage, D3DTSS_COLORARG1, bComplement, FALSE, TRUE);
    hr |= nvKelvinCCSelectColorInput (pContext, kelvinCombinerInputD, dwHWStage, dwD3DStage, D3DTSS_COLORARG2, FALSE, FALSE, FALSE);
    return (hr);
}

//---------------------------------------------------------------------------

static HRESULT nvKelvinCCModulateColor (PNVD3DCONTEXT pContext, DWORD dwHWStage, DWORD dwD3DStage, BOOL bComplement)
{
    HRESULT hr;
    // A * B
    hr  = nvKelvinCCSelectColorInput (pContext, kelvinCombinerInputA, dwHWStage, dwD3DStage, D3DTSS_COLORARG1, bComplement, FALSE, FALSE);
    hr |= nvKelvinCCSelectColorInput (pContext, kelvinCombinerInputB, dwHWStage, dwD3DStage, D3DTSS_COLORARG2, FALSE, FALSE, FALSE);

    // Set C alpha(arg1), Set D: 1
    hr |= nvKelvinCCSelectColorInput (pContext, kelvinCombinerInputC, dwHWStage, dwD3DStage, D3DTSS_COLORARG1, FALSE, FALSE, TRUE);
    nvKelvinCCSetColorInputOne (pContext, kelvinCombinerInputD, dwHWStage, FALSE);
    return (hr);
}

//---------------------------------------------------------------------------

static HRESULT nvKelvinBumpMap (PNVD3DCONTEXT pContext, DWORD dwHWStage, DWORD dwD3DStage)
{
    HRESULT hr;
    DWORD   dwArg1Cache;

    // this is terribly inefficient. we actually burn up a combiner stage doing nothing at all.
    // to make this better, we need a combiner analog to "nextAvailableTextureUnit" and to allow
    // for the possibility that this doesn't get incremented when we parse a D3D combiner stage.
    if (pContext->tssState[dwD3DStage].dwValue[D3DTSS_TEXTUREMAP] == NULL) {
        pContext->hwState.dwStateFlags |= KELVIN_FLAG_SETUPFAILURE;
        hr = TSS_USES_NULL_TEXTURE;
    }
    else if (pContext->hwState.dwNextAvailableTextureUnit >= KELVIN_NUM_TEXTURES) {
        pContext->hwState.dwStateFlags |= KELVIN_FLAG_SETUPFAILURE;
        // not really OK, but there's nothing we can do about it.
        hr = D3D_OK;
    }
    else {
        // just pass the result of the last stage on to the next
        dwArg1Cache = pContext->tssState[dwD3DStage].dwValue[D3DTSS_COLORARG1];
        pContext->tssState[dwD3DStage].dwValue[D3DTSS_COLORARG1] = D3DTA_CURRENT;
        hr = nvKelvinCCSelectColorInput (pContext, kelvinCombinerInputA, dwHWStage, dwD3DStage, D3DTSS_COLORARG1, FALSE, FALSE, FALSE);
        pContext->tssState[dwD3DStage].dwValue[D3DTSS_COLORARG1] = dwArg1Cache;
        nvKelvinCCSetColorInputOne (pContext, kelvinCombinerInputB, dwHWStage, FALSE);
        pContext->hwState.dwTexUnitToTexStageMapping[pContext->hwState.dwNextAvailableTextureUnit] = dwD3DStage;
    }

    return (hr);
}

//---------------------------------------------------------------------------

static HRESULT nvKelvinCCDotProduct (PNVD3DCONTEXT pContext, DWORD dwHWStage, DWORD dwD3DStage)
{
    HRESULT hr;
    // Multiply expanded A * expanded B
    hr  = nvKelvinCCSelectColorInput (pContext, kelvinCombinerInputA, dwHWStage, dwD3DStage, D3DTSS_COLORARG1, FALSE, TRUE, FALSE);
    hr |= nvKelvinCCSelectColorInput (pContext, kelvinCombinerInputB, dwHWStage, dwD3DStage, D3DTSS_COLORARG2, FALSE, TRUE, FALSE);
    // C & D default to zero
    return (hr);
}

//---------------------------------------------------------------------------

static HRESULT nvKelvinCCMultiplyAdd (PNVD3DCONTEXT pContext, int hdStage, int dxStage)
{
    HRESULT hr;

    // set A to arg1
    hr  = nvKelvinCCSelectColorInput (pContext, kelvinCombinerInputA, hdStage, dxStage, D3DTSS_COLORARG0, FALSE, FALSE, FALSE);
    // set B to 1
    nvKelvinCCSetColorInputOne (pContext, kelvinCombinerInputB, hdStage, FALSE);
    // set C to arg2
    hr |= nvKelvinCCSelectColorInput (pContext, kelvinCombinerInputC, hdStage, dxStage, D3DTSS_COLORARG1, FALSE, FALSE, FALSE);
    // set D to arg3
    hr |= nvKelvinCCSelectColorInput (pContext, kelvinCombinerInputD, hdStage, dxStage, D3DTSS_COLORARG2, FALSE, FALSE, FALSE);

    return (hr);
}

//---------------------------------------------------------------------------

static HRESULT nvKelvinCCLerp (PNVD3DCONTEXT pContext, int hdStage, int dxStage)
{
    HRESULT hr;

    // Multiply A * B
    hr  = nvKelvinCCSelectColorInput (pContext, kelvinCombinerInputA, hdStage, dxStage, D3DTSS_COLORARG0, FALSE, FALSE, FALSE);
    hr |= nvKelvinCCSelectColorInput (pContext, kelvinCombinerInputB, hdStage, dxStage, D3DTSS_COLORARG1, FALSE, FALSE, FALSE);
    // set C to 1 - arg1
    hr |= nvKelvinCCSelectColorInput (pContext, kelvinCombinerInputC, hdStage, dxStage, D3DTSS_COLORARG0, TRUE, FALSE, FALSE);
    // set D to arg3
    hr |= nvKelvinCCSelectColorInput (pContext, kelvinCombinerInputD, hdStage, dxStage, D3DTSS_COLORARG2, FALSE, FALSE, FALSE);

    return (hr);
}

//---------------------------------------------------------------------------

// Set up output combiners

void nvConstructKelvinOutputColorCombiners (PNVD3DCONTEXT pContext, BOOL bEnable, DWORD dwStage,
                                            BOOL bBias, DWORD dwShift, BOOL bDotAB, BOOL bDotCD, BOOL bOutTemp)
{
    bOutTemp &= (dwStage != 8); // last stage must go to normal output

    if (!bEnable) {
        nvAssert (dwStage > 0);  // stage 0 should always be enabled
        pContext->hwState.dwColorOCW[dwStage] |= DRF_DEF (097, _SET_COMBINER_COLOR, _OCW_SUM_DST, _REG_0);
        return;
    }

    // select bias operation
    switch (dwShift) {
        case 0:
            pContext->hwState.dwColorOCW[dwStage] |= bBias ?
                                                     DRF_DEF (097, _SET_COMBINER_COLOR, _OCW_OP, _NOSHIFT_BIAS) :
                                                     DRF_DEF (097, _SET_COMBINER_COLOR, _OCW_OP, _NOSHIFT);
            break;
        case 1:
            pContext->hwState.dwColorOCW[dwStage] |= bBias ?
                                                     DRF_DEF (097, _SET_COMBINER_COLOR, _OCW_OP, _SHIFTLEFTBY1_BIAS) :
                                                     DRF_DEF (097, _SET_COMBINER_COLOR, _OCW_OP, _SHIFTLEFTBY1);
            break;
        case 2:
            pContext->hwState.dwColorOCW[dwStage] |= bBias ?
                                                     // we can't shift by 2 and bias. do the best we can...
                                                     DRF_DEF (097, _SET_COMBINER_COLOR, _OCW_OP, _SHIFTLEFTBY1_BIAS) :
                                                     DRF_DEF (097, _SET_COMBINER_COLOR, _OCW_OP, _SHIFTLEFTBY2);
            break;
        default:
            DPF ("illagal shift in nvConstructKelvinOutputColorCombiners");
            dbgD3DError();
            break;
    }  // switch

    // select mux enable
    pContext->hwState.dwColorOCW[dwStage] |= DRF_DEF (097, _SET_COMBINER_COLOR, _OCW_MUX_ENABLE, _FALSE);

    // select dot enables
    if (bDotAB && bDotCD) {
        pContext->hwState.dwColorOCW[dwStage] |= (DRF_DEF (097, _SET_COMBINER_COLOR, _OCW_AB_DOT_ENABLE, _TRUE)           |
                                                  DRF_DEF (097, _SET_COMBINER_COLOR, _OCW_CD_DOT_ENABLE, _TRUE)           |
                                                  DRF_DEF (097, _SET_COMBINER_COLOR, _OCW_BLUETOALPHA_AB, _AB_DST_ENABLE) |
                                                  DRF_DEF (097, _SET_COMBINER_COLOR, _OCW_BLUETOALPHA_CD, _CD_DST_ENABLE));
        pContext->hwState.dwColorOCW[dwStage] |= bOutTemp ?
                                                 DRF_DEF (097, _SET_COMBINER_COLOR, _OCW_SUM_DST, _REG_D) :
                                                 DRF_DEF (097, _SET_COMBINER_COLOR, _OCW_SUM_DST, _REG_C);
    }
    else if (bDotAB) {
        pContext->hwState.dwColorOCW[dwStage] |= (DRF_DEF (097, _SET_COMBINER_COLOR, _OCW_AB_DOT_ENABLE, _TRUE)           |
                                                  DRF_DEF (097, _SET_COMBINER_COLOR, _OCW_CD_DOT_ENABLE, _FALSE)          |
                                                  DRF_DEF (097, _SET_COMBINER_COLOR, _OCW_BLUETOALPHA_AB, _AB_DST_ENABLE) |
                                                  DRF_DEF (097, _SET_COMBINER_COLOR, _OCW_BLUETOALPHA_CD, _DISABLE));
        pContext->hwState.dwColorOCW[dwStage] |= bOutTemp ?
                                                 DRF_DEF (097, _SET_COMBINER_COLOR, _OCW_AB_DST, _REG_D) :
                                                 DRF_DEF (097, _SET_COMBINER_COLOR, _OCW_AB_DST, _REG_C);
    }
    else {
        // select the sum as final result
        pContext->hwState.dwColorOCW[dwStage] |= (DRF_DEF (097, _SET_COMBINER_COLOR, _OCW_AB_DOT_ENABLE, _FALSE)    |
                                                  DRF_DEF (097, _SET_COMBINER_COLOR, _OCW_CD_DOT_ENABLE, _FALSE)    |
                                                  DRF_DEF (097, _SET_COMBINER_COLOR, _OCW_BLUETOALPHA_AB, _DISABLE) |
                                                  DRF_DEF (097, _SET_COMBINER_COLOR, _OCW_BLUETOALPHA_CD, _DISABLE));
        pContext->hwState.dwColorOCW[dwStage] |= bOutTemp ?
                                                 DRF_DEF (097, _SET_COMBINER_COLOR, _OCW_SUM_DST, _REG_D) :
                                                 DRF_DEF (097, _SET_COMBINER_COLOR, _OCW_SUM_DST, _REG_C);
    }

}

//---------------------------------------------------------------------------

BOOL nvConstructKelvinColorCombiners (PNVD3DCONTEXT pContext, DWORD dwHWStage, DWORD dwD3DStage)
{
    DWORD   dwShift;
    BOOL    bDotProduct, bBias, bEnable, bStageActive;
    HRESULT hr = 0;

    bEnable      = TRUE;
    bStageActive = TRUE;
    bDotProduct  = FALSE;
    bBias        = FALSE;
    dwShift      = 0;

    pContext->hwState.dwColorICW[dwHWStage] = 0;
    pContext->hwState.dwColorOCW[dwHWStage] = 0;

    switch (pContext->tssState[dwD3DStage].dwValue[D3DTSS_COLOROP]) {
        default:
        case D3DTOP_DISABLE:
            if (dwD3DStage == 0) { // only construct for stage 0
                // Default is diffuse color, make A=diffuse, B=1, C=D=0
                pContext->hwState.dwColorICW[dwHWStage] |= DRF_DEF (097, _SET_COMBINER_COLOR, _ICW_A_SOURCE, _REG_4);
                nvKelvinCCSetColorInputOne (pContext, kelvinCombinerInputB, dwHWStage, FALSE);
            }
            else {
                bEnable = FALSE; // don't enable output combiner
            }
            bStageActive = FALSE;
            break;
        case D3DTOP_SELECTARG1:
            hr = nvKelvinCCSelect1 (pContext, dwHWStage, dwD3DStage);
            break;
        case D3DTOP_SELECTARG2: // same as 2 from above
            hr = nvKelvinCCSelect2 (pContext, dwHWStage, dwD3DStage);
            break;
        case D3DTOP_MODULATE4X:
            dwShift++;
        case D3DTOP_MODULATE2X:
            dwShift++;
        case D3DTOP_MODULATE:
            hr = nvKelvinCCModulate (pContext, dwHWStage, dwD3DStage);
            break;
        case D3DTOP_ADDSIGNED2X: // same as addsigned with following change
            dwShift = 1;
        case D3DTOP_ADDSIGNED:   // same as add with following change
            bBias = TRUE;
        case D3DTOP_ADD:
            hr = nvKelvinCCAdd (pContext, dwHWStage, dwD3DStage);
            break;
        case D3DTOP_SUBTRACT:
            hr = nvKelvinCCSub (pContext, dwHWStage, dwD3DStage);
            break;
        case D3DTOP_ADDSMOOTH:
            hr = nvKelvinCCAddSmooth (pContext, dwHWStage, dwD3DStage);
            break;
        case D3DTOP_BLENDDIFFUSEALPHA:
            hr = nvKelvinCCBlendAlpha (pContext, dwHWStage, dwD3DStage, D3DTA_DIFFUSE);
            break;
        case D3DTOP_BLENDTEXTUREALPHA:
            hr = nvKelvinCCBlendAlpha (pContext, dwHWStage , dwD3DStage, D3DTA_TEXTURE);
            break;
        case D3DTOP_BLENDFACTORALPHA:
            hr = nvKelvinCCBlendAlpha (pContext, dwHWStage, dwD3DStage, D3DTA_TFACTOR);
            break;
        case D3DTOP_BLENDTEXTUREALPHAPM:
            hr = nvKelvinCCBlendAlpha (pContext, dwHWStage, dwD3DStage, TEXTUREPM);
            break;
        case D3DTOP_BLENDCURRENTALPHA:
            hr = nvKelvinCCBlendAlpha (pContext, dwHWStage, dwD3DStage, D3DTA_CURRENT);
            break;
        case D3DTOP_PREMODULATE:
            hr = nvKelvinCCPremodulate (pContext, dwHWStage, dwD3DStage);
            break;
        case D3DTOP_MODULATEALPHA_ADDCOLOR:
            hr = nvKelvinCCModulateAlpha (pContext, dwHWStage, dwD3DStage, FALSE);
            break;
        case D3DTOP_MODULATECOLOR_ADDALPHA:
            hr = nvKelvinCCModulateColor (pContext, dwHWStage, dwD3DStage, FALSE);
            break;
        case D3DTOP_MODULATEINVALPHA_ADDCOLOR:
            hr = nvKelvinCCModulateAlpha (pContext, dwHWStage, dwD3DStage, TRUE); // complement
            break;
        case D3DTOP_MODULATEINVCOLOR_ADDALPHA:
            hr = nvKelvinCCModulateColor (pContext, dwHWStage, dwD3DStage, TRUE); // complement
            break;
        case D3DTOP_BUMPENVMAP:
        case D3DTOP_BUMPENVMAPLUMINANCE:
            hr = nvKelvinBumpMap (pContext, dwHWStage, dwD3DStage);
            break;
        case D3DTOP_DOTPRODUCT3:
            hr = nvKelvinCCDotProduct (pContext, dwHWStage, dwD3DStage);
            bDotProduct = TRUE;
            break;
        case D3DTOP_MULTIPLYADD:
            hr = nvKelvinCCMultiplyAdd (pContext, dwHWStage, dwD3DStage);
            break;
        case D3DTOP_LERP:
            hr = nvKelvinCCLerp (pContext, dwHWStage, dwD3DStage);
            break;
    }

    if (hr == TSS_USES_NULL_TEXTURE) {
        // this stage references a non-existent texture. just set it back to "select current"
        if (dwHWStage == 0) {
            // current = diffuse in stage 0
            pContext->hwState.dwColorICW[dwHWStage] = DRF_DEF (097, _SET_COMBINER_COLOR, _ICW_A_SOURCE, _REG_4);
        }
        else {
            pContext->hwState.dwColorICW[dwHWStage] = DRF_DEF (097, _SET_COMBINER_COLOR, _ICW_A_SOURCE, _REG_C);
        }
        nvKelvinCCSetColorInputOne (pContext, kelvinCombinerInputB, dwHWStage, FALSE);
    }

    nvConstructKelvinOutputColorCombiners (pContext, bEnable, dwHWStage, bBias, dwShift, bDotProduct, FALSE,
                                           pContext->tssState[dwD3DStage].dwValue[D3DTSS_RESULTARG] == D3DTA_TEMP);

    return (bStageActive);
}

#endif  // NVARCH == 0x20
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\kelvin\src\nvKelvinCompileVS_link.cpp ===
// **************************************************************************
//
//       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
//
//  Module: nvKelvinCompileVS_link.cpp
//      a pointer to a shared file
//
// **************************************************************************

#include "nvprecomp.h"
#include "..\..\..\common\nv20\src\vpcompilekelvin.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\kelvin\src\nvKelvinStateHelp.cpp ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// ********************************* Direct 3D ******************************
//
//  Module: nvhwState.kelvin.cpp
//      Kelvin state management routines.
//
// **************************************************************************
//
//  History:
//      Craig Duttweiler        26Apr2000         NV20 development
//
// **************************************************************************
#include "nvprecomp.h"

#if (NVARCH >= 0x20)

//---------------------------------------------------------------------------

#define KELVIN_VALIDATE_FAIL(reason)    \
{                                       \
    pvtssd->dwNumPasses = 0xffffffff;   \
    pvtssd->ddrval = reason;            \
    dbgTracePop();                      \
    return (DDHAL_DRIVER_HANDLED);      \
}

//---------------------------------------------------------------------------

DWORD nvKelvinValidateTextureStageState
(
    LPD3DHAL_VALIDATETEXTURESTAGESTATEDATA pvtssd
)
{
    dbgTracePush ("nvKelvinValidateTextureStageState");

    // get the context
    PNVD3DCONTEXT pContext;
    NV_SET_CONTEXT (pContext, pvtssd);

    // update everything
    pContext->hwState.dwDirtyFlags = KELVIN_DIRTY_REALLY_FILTHY;
    nvSetKelvinState (pContext);

    // make sure the setup went smoothly
    if (pContext->hwState.dwStateFlags & KELVIN_FLAG_SETUPFAILURE) {
        KELVIN_VALIDATE_FAIL (D3DERR_CONFLICTINGRENDERSTATE);
    }

    // everything is kosher. set return values and return OK
    pvtssd->dwNumPasses = 1;
    pvtssd->ddrval      = D3D_OK;

    dbgTracePop();
    return (DDHAL_DRIVER_HANDLED);
}

//---------------------------------------------------------------------------

// returns the size (in bytes) of an inlined vertex

DWORD nvKelvinInlineVertexStride
(
    PNVD3DCONTEXT pContext
)
{
    DWORD dwStride, dwHWStage, dwD3DStage, dwTCIndex, dwVAIndex;

    CVertexShader *pShader = pContext->pCurrentVShader;

    dwStride  = 0;
    dwStride += pShader->getVASize(defaultInputRegMap[D3DVSDE_POSITION]);
    dwStride += pShader->getVASize(defaultInputRegMap[D3DVSDE_BLENDWEIGHT]);
    dwStride += pShader->getVASize(defaultInputRegMap[D3DVSDE_NORMAL]);
    dwStride += pShader->getVASize(defaultInputRegMap[D3DVSDE_DIFFUSE]);
    dwStride += pShader->getVASize(defaultInputRegMap[D3DVSDE_SPECULAR]);
    // fog distance
    dwStride += pShader->getVASize(defaultInputRegMap[D3DVSDE_PSIZE]);
    // back diffuse
    // back specular
    for (dwHWStage=0; dwHWStage < KELVIN_NUM_TEXTURES; dwHWStage++) {
        if (pContext->hwState.dwStateFlags & KELVIN_FLAG_USERTEXCOORDSNEEDED(dwHWStage)) {
            // the app needs texture N and provided us with one
            dwD3DStage = pContext->hwState.dwTexUnitToTexStageMapping[dwHWStage];
            nvAssert (dwD3DStage != KELVIN_UNUSED);
            dwTCIndex = (pContext->hwState.dwTexCoordIndices >> (8*dwHWStage)) & 0xff;
            dwVAIndex = defaultInputRegMap[D3DVSDE_TEXCOORD0+dwTCIndex];
            nvAssert (pShader->getVASize(dwVAIndex));  // they better have given us coordinates
            dwStride += pShader->getVASize(dwVAIndex);
        }
    }

    return (dwStride);
}

#endif // (NVARCH >= 0x020)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\kelvin\src\nvKelvinOptimiseVS_link.cpp ===
// **************************************************************************
//
//       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// **************************************************************************
//
//  Module: nvKelvinCompileVS_link.cpp
//      a pointer to a shared file
//
// **************************************************************************

#include "nvprecomp.h"
#include "..\..\..\common\src\vpoptimize.c"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\kelvin\src\nvKelvinState.cpp ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// ********************************* Direct 3D ******************************
//
//  Module: nvKelvinState.cpp
//      Kelvin state management routines.
//
// **************************************************************************
//
//  History:
//      Craig Duttweiler        12Mar00         NV20 development
//
// **************************************************************************

#include "nvprecomp.h"

#if (NVARCH >= 0x20)

// all elements of this matrix remain zero except the last row and the diagonal
// which get set appropriately in nvSetKelvinTransform
static D3DMATRIX mViewportMatrix = matrixZero;

#define PRECOMPILED_PASSTHROUGH
#ifdef PRECOMPILED_PASSTHROUGH

static BYTE kmpPassthruProgramSpecFog[] = {
    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 0xF8, 0x0F, 0x10, 0x1F,
    0xB0, 0x21, 0xD8, 0x20, 0xB0, 0x01, 0x00, 0x02, 0x18, 0xF8, 0x71, 0x90, 0xF1, 0x2F, 0xD8, 0x20,
    0xB0, 0x61, 0x00, 0x42, 0x20, 0xF8, 0x70, 0x10, 0xB0, 0x21, 0xD8, 0x20, 0xB0, 0x81, 0x00, 0x02,
    0x28, 0xF8, 0x70, 0x10, 0xB0, 0x21, 0xD8, 0x20, 0xF0, 0x8F, 0x00, 0x02, 0xF8, 0x0F, 0x10, 0x1F,
    0xB0, 0x61, 0xD8, 0x10, 0xB1, 0x01, 0x74, 0x04, 0x30, 0xF8, 0x70, 0x90, 0xB0, 0x21, 0xD8, 0x20,
    0x00, 0x20, 0x00, 0x02, 0x00, 0xF8, 0x70, 0x30, 0xB0, 0x21, 0xD8, 0x90, 0xB1, 0x01, 0x76, 0x06,
    0x48, 0xF8, 0x70, 0x90, 0xB0, 0x21, 0xD8, 0xA0, 0xB0, 0x21, 0x01, 0x02, 0x50, 0xF8, 0x70, 0x90,
    0xB0, 0x21, 0xD8, 0x20, 0xB0, 0x41, 0x01, 0x02, 0x58, 0xF8, 0x70, 0x10, 0xB0, 0x21, 0xD8, 0xA0,
    0xB0, 0x61, 0x01, 0x02, 0x61, 0xF8, 0x70, 0x90, 0xB0, 0x21, 0xD8, 0xA0, 0xB0, 0x81, 0x01, 0x02,
};

static BYTE kmpPassthruProgramZFog[] = {
    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 0xF8, 0x0F, 0x10, 0x1F,
    0xB0, 0x21, 0xD8, 0x20, 0xB0, 0x01, 0x00, 0x02, 0x18, 0xF8, 0x71, 0x90, 0xF1, 0x2F, 0xD8, 0x20,
    0xB0, 0x61, 0x00, 0x42, 0x20, 0xF8, 0x70, 0x10, 0xB0, 0x21, 0xD8, 0x20, 0xB0, 0x81, 0x00, 0x02,
    0x28, 0xF8, 0x70, 0x10, 0xB0, 0x21, 0xD8, 0x10, 0xA1, 0x0A, 0x00, 0x02, 0xF8, 0x0F, 0x10, 0x1F,
    0xB0, 0x61, 0xD8, 0x10, 0xB1, 0x01, 0x74, 0x04, 0x30, 0xF8, 0x70, 0x90, 0xB0, 0x21, 0xD8, 0x20,
    0x00, 0x20, 0x00, 0x02, 0x00, 0xF8, 0x70, 0x30, 0xB0, 0x21, 0xD8, 0x90, 0xB1, 0x01, 0x76, 0x06,
    0x48, 0xF8, 0x70, 0x90, 0xB0, 0x21, 0xD8, 0xA0, 0xB0, 0x21, 0x01, 0x02, 0x50, 0xF8, 0x70, 0x90,
    0xB0, 0x21, 0xD8, 0x20, 0xB0, 0x41, 0x01, 0x02, 0x58, 0xF8, 0x70, 0x10, 0xB0, 0x21, 0xD8, 0xA0,
    0xB0, 0x61, 0x01, 0x02, 0x61, 0xF8, 0x70, 0x90, 0xB0, 0x21, 0xD8, 0xA0, 0xB0, 0x81, 0x01, 0x02,
};

static BYTE kmpPassthruProgramWFog[] = {
    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 0xF8, 0x0F, 0x10, 0x1F,
    0xB0, 0x21, 0xD8, 0x20, 0xB0, 0x01, 0x00, 0x02, 0x18, 0xF8, 0x71, 0x90, 0xF1, 0x2F, 0xD8, 0x20,
    0xB0, 0x61, 0x00, 0x42, 0x20, 0xF8, 0x70, 0x10, 0xB0, 0x21, 0xD8, 0x20, 0xB0, 0x81, 0x00, 0x02,
    0x28, 0xF8, 0x70, 0x10, 0xB0, 0x21, 0xD8, 0x10, 0xF1, 0x0F, 0x00, 0x02, 0xF8, 0x0F, 0x10, 0x1F,
    0xB0, 0x61, 0xD8, 0x10, 0xB1, 0x01, 0x74, 0x04, 0x30, 0xF8, 0x70, 0x90, 0xB0, 0x21, 0xD8, 0x20,
    0x00, 0x20, 0x00, 0x02, 0x00, 0xF8, 0x70, 0x30, 0xB0, 0x21, 0xD8, 0x90, 0xB1, 0x01, 0x76, 0x06,
    0x48, 0xF8, 0x70, 0x90, 0xB0, 0x21, 0xD8, 0xA0, 0xB0, 0x21, 0x01, 0x02, 0x50, 0xF8, 0x70, 0x90,
    0xB0, 0x21, 0xD8, 0x20, 0xB0, 0x41, 0x01, 0x02, 0x58, 0xF8, 0x70, 0x10, 0xB0, 0x21, 0xD8, 0xA0,
    0xB0, 0x61, 0x01, 0x02, 0x61, 0xF8, 0x70, 0x90, 0xB0, 0x21, 0xD8, 0xA0, 0xB0, 0x81, 0x01, 0x02,
};

#else  // !PRECOMPILED_PASSTHROUGH

static char szPassthruProgramSpecFog[] = \
   "%!VP1.0                              \
    MOV R1,v[0];                         \
    MOV o[COL0],v[3] : RCP R1.w,R1.w;    \
    MOV o[COL1],v[4];                    \
    MOV o[FOGC],v[4].w;                  \
    MUL R1,R1,c[58];                     \
    MOV o[PSIZ],v[1].x;                  \
    ADD o[HPOS],R1,c[59];                \
    MOV o[TEX0],v[9];                    \
    MOV o[TEX1],v[10];                   \
    MOV o[TEX2],v[11];                   \
    MOV o[TEX3],v[12];";

static char szPassthruProgramZFog[] =    \
   "%!VP1.0                              \
    MOV R1,v[0];                         \
    MOV o[COL0],v[3] : RCP R1.w,R1.w;    \
    MOV o[COL1],v[4];                    \
    MOV o[FOGC],R1.z;                    \
    MUL R1,R1,c[58];                     \
    MOV o[PSIZ],v[1].x;                  \
    ADD o[HPOS],R1,c[59];                \
    MOV o[TEX0],v[9];                    \
    MOV o[TEX1],v[10];                   \
    MOV o[TEX2],v[11];                   \
    MOV o[TEX3],v[12];";

static char szPassthruProgramWFog[] =    \
   "%!VP1.0                              \
    MOV R1,v[0];                         \
    MOV o[COL0],v[3] : RCP R1.w,R1.w;    \
    MOV o[COL1],v[4];                    \
    MOV o[FOGC],R1.w;                    \
    MUL R1,R1,c[58];                     \
    MOV o[PSIZ],v[1].x;                  \
    ADD o[HPOS],R1,c[59];                \
    MOV o[TEX0],v[9];                    \
    MOV o[TEX1],v[10];                   \
    MOV o[TEX2],v[11];                   \
    MOV o[TEX3],v[12];";

#endif  // !PRECOMPILED_PASSTHROUGH

//---------------------------------------------------------------------------

// set things that are never changed in D3D. this routine is run once to initialize
// and then only whenever someone else (DDRAW) stomps on our kelvin object

HRESULT nvSetKelvinD3DDefaults (PNVD3DCONTEXT pContext)
{
    // clear the dirty bit
    pContext->hwState.dwDirtyFlags &= ~KELVIN_DIRTY_DEFAULTS;

    // context dmas
    pContext->hwState.kelvin.set3 (NV097_SET_CONTEXT_DMA_NOTIFIES,
                                   NV_DD_DMA_PUSHER_SYNC_NOTIFIER_CONTEXT_DMA_TO_MEMORY,   // notifier context
                                   D3D_CONTEXT_DMA_HOST_MEMORY,                            // texture context a - system/agp memory
                                   NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY);                 // texture context b - video memory

#ifdef KELVIN_SEMAPHORES
    pContext->hwState.kelvin.set7 (NV097_SET_CONTEXT_DMA_STATE,
                                   NV_DD_DMA_CONTEXT_DMA_TO_VIDEO_MEMORY,                  // state context
                                   NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY,                  // frame buffer context
                                   NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY,                  // zeta buffer context
                                   D3D_CONTEXT_DMA_HOST_MEMORY,                            // vertex buffer context a
                                   NV_DD_DMA_CONTEXT_DMA_FROM_VIDEO_MEMORY,                // vertex buffer context b
                                   CSemaphoreManager::SEMAPHORE_CONTEXT_DMA_IN_MEMORY,     // semaphore context
                                   NV01_NULL_OBJECT);                                      // report context
#else
    pContext->hwState.kelvin.set7 (NV097_SET_CONTEXT_DMA_STATE,
                                   NV_DD_DMA_CONTEXT_DMA_TO_VIDEO_MEMORY,                  // state context
                                   NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY,                  // frame buffer context
                                   NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY,                  // zeta buffer context
                                   D3D_CONTEXT_DMA_HOST_MEMORY,                            // vertex buffer context a
                                   NV_DD_DMA_CONTEXT_DMA_FROM_VIDEO_MEMORY,                // vertex buffer context b
                                   NV01_NULL_OBJECT,                                       // semaphore context
                                   NV01_NULL_OBJECT);                                      // report context
#endif

    // use the first vertex to determine the color used for flat-shading
    pContext->hwState.kelvin.set1 (NV097_SET_FLAT_SHADE_OP, NV097_SET_FLAT_SHADE_OP_V_FIRST_VTX);

    // clipping is inclusive of boundaries
    pContext->hwState.kelvin.set1 (NV097_SET_WINDOW_CLIP_TYPE, NV097_SET_WINDOW_CLIP_TYPE_V_INCLUSIVE);

    // deactivate all but the first clip rectangle
    for (DWORD dwWindow=1; dwWindow < KELVIN_NUM_WINDOWS; dwWindow++) {
        pContext->hwState.kelvin.set1 (NV097_SET_WINDOW_CLIP_HORIZONTAL(dwWindow), 0);
        pContext->hwState.kelvin.set1 (NV097_SET_WINDOW_CLIP_VERTICAL(dwWindow), 0);
    }

    // no point params until DX8
    if (global.dwDXRuntimeVersion < 0x0800) {
        pContext->hwState.kelvin.set1 (NV097_SET_POINT_PARAMS_ENABLE, NV097_SET_POINT_PARAMS_ENABLE_V_FALSE);
    }

    // D3D has no smoothing (note smoothing != anti-aliasing!)
    pContext->hwState.kelvin.set3 (NV097_SET_POINT_SMOOTH_ENABLE,
                                   NV097_SET_POINT_SMOOTH_ENABLE_V_FALSE,
                                   NV097_SET_LINE_SMOOTH_ENABLE_V_FALSE,
                                   NV097_SET_POLY_SMOOTH_ENABLE_V_FALSE);

    // blend color not available in d3d
    pContext->hwState.kelvin.set1 (NV097_SET_BLEND_COLOR, 0);

    // line and point sizes are just one pixel (in DX7. this changes in DX8)
    pContext->hwState.kelvin.set1 (NV097_SET_LINE_WIDTH, 0x00000008);  // 6.3 format
    pContext->hwState.kelvin.set1 (NV097_SET_POINT_SIZE, 0x00000008);  // 6.3 format

    pContext->hwState.kelvin.set1 (NV097_SET_EDGE_FLAG, NV097_SET_EDGE_FLAG_V_TRUE);

    // initialize immediate mode data
    pContext->hwState.kelvin.set3f (NV097_SET_NORMAL3F(0), 0.0f, 0.0f, 1.0f);

    pContext->hwState.kelvin.set4f (NV097_SET_TEXCOORD0_4F(0), 0.0f, 0.0f, 0.0f, 1.0f);
    pContext->hwState.kelvin.set4f (NV097_SET_TEXCOORD1_4F(0), 0.0f, 0.0f, 0.0f, 1.0f);
    pContext->hwState.kelvin.set4f (NV097_SET_TEXCOORD2_4F(0), 0.0f, 0.0f, 0.0f, 1.0f);
    pContext->hwState.kelvin.set4f (NV097_SET_TEXCOORD3_4F(0), 0.0f, 0.0f, 0.0f, 1.0f);

    pContext->hwState.kelvin.set1f (NV097_SET_FOG1F, 0.0f);

    // set image (unswizzled) texture pitch to an allowable, innocuous value
    for (DWORD dwTex=0; dwTex < KELVIN_NUM_TEXTURES; dwTex++) {
        pContext->hwState.kelvin.set1 (NV097_SET_TEXTURE_CONTROL1(dwTex),
                                       DRF_NUM (097, _SET_TEXTURE_CONTROL1, _IMAGE_PITCH, 0x0008));
    }

    // swath width for the boustrophedonic rasterization
    // todo - use montrym's algorithm
    pContext->hwState.kelvin.set1 (NV097_SET_SWATH_WIDTH, NV097_SET_SWATH_WIDTH_V_128);

    pContext->hwState.kelvin.set4f (NV097_SET_EYE_POSITION(0),  0.0f, 0.0f, 0.0f, 1.0f);
    pContext->hwState.kelvin.set3f (NV097_SET_EYE_DIRECTION(0), 0.0f, 0.0f,-1.0f);

    // we'll always cull what we call backfacing geometry.
    // this goes along with D3D's definition of culling.
    pContext->hwState.kelvin.set1 (NV097_SET_CULL_FACE, NV097_SET_CULL_FACE_V_BACK);

    // always clip <0
    pContext->hwState.kelvin.set1 (NV097_SET_SHADER_CLIP_PLANE_MODE, 0);

    // fog plane
    pContext->hwState.kelvin.set4f (NV097_SET_FOG_PLANE(0), 0.0f, 0.0f, 1.0f, 0.0f);

#ifndef DISABLE_Z_COMPR
    // compressed z
    if ((getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_ZCOMPRESSENABLE_MASK) == D3D_REG_ZCOMPRESSENABLE_ENABLE) {
        pContext->hwState.kelvin.set1 (NV097_SET_COMPRESS_ZBUFFER_EN, NV097_SET_COMPRESS_ZBUFFER_EN_V_ENABLE);
    }
#endif

    // no two-sided lighting in d3d (maybe in dx8?)
    pContext->hwState.kelvin.set1 (NV097_SET_TWO_SIDE_LIGHT_EN, NV097_SET_TWO_SIDE_LIGHT_EN_V_FALSE);

    // set up clipping in z and w. for now default to strict nv10-like behavior
    pContext->hwState.kelvin.set1 (NV097_SET_ZMIN_MAX_CONTROL,
                                   (DRF_DEF (097, _SET_ZMIN_MAX_CONTROL, _CULL_NEAR_FAR_EN, _TRUE) |
                                    DRF_DEF (097, _SET_ZMIN_MAX_CONTROL, _ZCLAMP_EN, _CULL)        |
                                    DRF_DEF (097, _SET_ZMIN_MAX_CONTROL, _CULL_IGNORE_W, _FALSE)));

    // for DX7, dependent texture lookups always run between stages i and i+1
    pContext->hwState.kelvin.set1 (NV097_SET_SHADER_OTHER_STAGE_INPUT,
                                   (DRF_DEF (097, _SET_SHADER_OTHER_STAGE_INPUT, _STAGE1, _INSTAGE_0) |
                                    DRF_DEF (097, _SET_SHADER_OTHER_STAGE_INPUT, _STAGE2, _INSTAGE_1) |
                                    DRF_DEF (097, _SET_SHADER_OTHER_STAGE_INPUT, _STAGE3, _INSTAGE_2)));

    dbgFlushType (NVDBG_FLUSH_STATE);

    return (D3D_OK);
}

//---------------------------------------------------------------------------

// set surface info: offset, pitch, clip

HRESULT nvSetKelvinSurfaceInfo (PNVD3DCONTEXT pContext)
{
    DWORD dwFormat;
    DWORD dwOffset, dwPitch;
    DWORD dwZOffset, dwZPitch;
    DWORD dwClipH, dwClipV;  // horizontal and vertical clip locations
    DWORD dwOcclude;

    pContext->hwState.dwDirtyFlags &= ~KELVIN_DIRTY_SURFACE;

    // get  render targets
#if (NVARCH >= 0x020)
    CSimpleSurface *pRenderTarget = pContext->kelvinAA.GetCurrentRT(pContext);
    CSimpleSurface *pZetaBuffer = pContext->kelvinAA.GetCurrentZB(pContext);
#else
    CSimpleSurface *pRenderTarget = pContext->pRenderTarget;
    CSimpleSurface *pZetaBuffer = pContext->pZetaBuffer;
#endif

    nvAssert (pRenderTarget);

    // surface formats
    dwFormat = DRF_NUM (097, _SET_SURFACE_FORMAT, _COLOR, nv097SurfaceFormat[pRenderTarget->getFormat()]);

    if (pRenderTarget->isSwizzled()) {
        CTexture* pTexture = pRenderTarget->getWrapper()->getTexture();
        nvAssert(pTexture);
        dwFormat |= DRF_DEF (097, _SET_SURFACE_FORMAT, _TYPE, _SWIZZLE);
        dwFormat |= DRF_NUM (097, _SET_SURFACE_FORMAT, _WIDTH,  pTexture->getLogWidth());
        dwFormat |= DRF_NUM (097, _SET_SURFACE_FORMAT, _HEIGHT, pTexture->getLogHeight());
    }
    else {
        dwFormat |= DRF_DEF (097, _SET_SURFACE_FORMAT, _TYPE, _PITCH);
    }

    dwFormat |= pZetaBuffer ?
                DRF_NUM (097, _SET_SURFACE_FORMAT, _ZETA, nv097SurfaceFormat[pZetaBuffer->getFormat()]) :
                // no zbuffer - set the format according to the render target bit depth to prevent an RM exception
                DRF_NUM (097, _SET_SURFACE_FORMAT, _ZETA, (pRenderTarget->getBPP() == 2) ?
                         NV097_SET_SURFACE_FORMAT_ZETA_Z16 : NV097_SET_SURFACE_FORMAT_ZETA_Z24S8);

    dwFormat |= pContext->kelvinAA.GetAAFormat();

    // render target pitch and offset
#ifdef STEREO_SUPPORT
    dwOffset = GetStereoOffset(pRenderTarget);
#else  //STEREO_SUPPORT==0
    dwOffset = pRenderTarget->getOffset();
#endif //STEREO_SUPPORT
    dwPitch  = pRenderTarget->getPitch();

    // zeta buffer pitch and offset
    if (pZetaBuffer) {
#ifdef  STEREO_SUPPORT
        dwZOffset = GetStereoOffset(pZetaBuffer);
#else //STEREO_SUPPORT==0
        dwZOffset = pZetaBuffer->getOffset();
#endif//STEREO_SUPPORT
        dwZPitch  = pZetaBuffer->getPitch();
    }
    else {
        dwZOffset = 0;
        dwZPitch  = KELVIN_ALIGNMENT_MIN;
    }

    // send everything to the HW
    pContext->hwState.kelvin.set3 (NV097_SET_SURFACE_PITCH,
                                   (DRF_NUM (097, _SET_SURFACE_PITCH, _COLOR, dwPitch) |
                                    DRF_NUM (097, _SET_SURFACE_PITCH, _ZETA,  dwZPitch)),
                                   dwOffset,
                                   dwZOffset);
    pContext->hwState.kelvin.set1 (NV097_SET_SURFACE_FORMAT, dwFormat);

    // since we're using the window clip to clip to the viewport,
    // the surface clip can just clip to the whole window.
    dwClipH = DRF_NUM (097, _SET_SURFACE_CLIP_HORIZONTAL, _X, 0) |
              DRF_NUM (097, _SET_SURFACE_CLIP_HORIZONTAL, _WIDTH, ((DWORD)pRenderTarget->getWidth()));
    dwClipV = DRF_NUM (097, _SET_SURFACE_CLIP_VERTICAL, _Y, 0) |
              DRF_NUM (097, _SET_SURFACE_CLIP_VERTICAL, _HEIGHT, ((DWORD)pRenderTarget->getHeight()));

    pContext->hwState.kelvin.set2 (NV097_SET_SURFACE_CLIP_HORIZONTAL, dwClipH, dwClipV);

    // set up occlusion culling. this doesn't logically belong here, but ends up here
    // because of an unfortunate HW bug that yields a dependancy on z-buffer format

    // BUGBUG: BSK 1/5/00 -- Disable Z CULL in AA modes -- it's broken and yet slow. Remove this for NV25.
    if (pZetaBuffer && !pContext->kelvinAA.IsEnabled() && ((getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_ZCULLENABLE_MASK) == D3D_REG_ZCULLENABLE_ENABLE)) {
        dwOcclude  = DRF_DEF (097, _SET_OCCLUDE_ZSTENCIL_EN, _OCCLUDE_STENCIL_EN, _ENABLE);
        dwOcclude |= (pZetaBuffer->getBPP() == 2) ?
                     DRF_DEF (097, _SET_OCCLUDE_ZSTENCIL_EN, _OCCLUDE_ZEN, _DISABLE) :
                     DRF_DEF (097, _SET_OCCLUDE_ZSTENCIL_EN, _OCCLUDE_ZEN, _ENABLE);
    }
    else {
        dwOcclude  = DRF_DEF (097, _SET_OCCLUDE_ZSTENCIL_EN, _OCCLUDE_STENCIL_EN, _DISABLE) |
                     DRF_DEF (097, _SET_OCCLUDE_ZSTENCIL_EN, _OCCLUDE_ZEN, _DISABLE);
    }
    pContext->hwState.kelvin.set1 (NV097_SET_OCCLUDE_ZSTENCIL_EN, dwOcclude);

    // cache the z scales
    if (pZetaBuffer) {
        if (pZetaBuffer->getBPP() == 2) {
            pContext->hwState.dvZScale    = KELVIN_Z_SCALE16;
            pContext->hwState.dvInvZScale = KELVIN_Z_SCALE16_INV;
        }
        else {
            pContext->hwState.dvZScale    = KELVIN_Z_SCALE24;
            pContext->hwState.dvInvZScale = KELVIN_Z_SCALE24_INV;
        }
    }

    dbgFlushType (NVDBG_FLUSH_STATE);
    return (D3D_OK);
}

//---------------------------------------------------------------------------

// set up the combiners to produce one of the legacy D3D texture blends

HRESULT nvKelvinSetTextureBlend (PNVD3DCONTEXT pContext)
{
    DWORD dwTBlend;

    if (pContext->tssState[0].dwValue[D3DTSS_TEXTUREMAP]) {

        // we have a texture. go ahead and do the blend

        dwTBlend = pContext->dwRenderState[D3DRENDERSTATE_TEXTUREMAPBLEND];

        nvAssert (dwTBlend <= D3D_TBLEND_MAX);  // make sure we're not off the end of the table

        pContext->hwState.dwAlphaICW[0] = kelvinTextureBlendSettings[dwTBlend][0];
        pContext->hwState.dwColorICW[0] = kelvinTextureBlendSettings[dwTBlend][1];
        pContext->hwState.dwAlphaOCW[0] = kelvinTextureBlendSettings[dwTBlend][2];
        pContext->hwState.dwColorOCW[0] = kelvinTextureBlendSettings[dwTBlend][3];

        // handle the stupid special case in which we have TBLEND_MODULATE and a
        // texture without alpha; use D3DTBLEND_MODULATEALPHA instead
        if (dwTBlend == D3DTBLEND_MODULATE) {
            CTexture *pTexture = ((CNvObject *)(pContext->tssState[0].dwValue[D3DTSS_TEXTUREMAP]))->getTexture();
            if (!pTexture->hasAlpha()) {
                pContext->hwState.dwAlphaICW[0] = kelvinTextureBlendSettings[D3DTBLEND_MODULATEALPHA][0];
            }
        }

        pContext->hwState.dwTexUnitToTexStageMapping[0] = 0;

    }

    else {

        // they've enabled a texture blend without a texture. just use diffuse
        pContext->hwState.dwAlphaICW[0] = kelvinTextureBlendDefault[0];
        pContext->hwState.dwColorICW[0] = kelvinTextureBlendDefault[1];
        pContext->hwState.dwAlphaOCW[0] = kelvinTextureBlendDefault[2];
        pContext->hwState.dwColorOCW[0] = kelvinTextureBlendDefault[3];

    }

    return (D3D_OK);
}

//---------------------------------------------------------------------------

// set up the kelvin combiners for either the current texture stage state
// or a legacy texture blend

HRESULT nvSetKelvinColorCombiners     (PNVD3DCONTEXT pContext)
{
    DWORD dwStage;
    BOOL  bStageActive;
    DWORD dwMapping[KELVIN_NUM_TEXTURES];
    DWORD dwControl;

    pContext->hwState.dwDirtyFlags &= ~KELVIN_DIRTY_COMBINERS_COLOR;

    // save off the last prim type for which combiners were set up (affects point sprites)
    pContext->hwState.dwCombinerDP2Prim = pContext->dp2.dwDP2Prim;

    // cache current values
    for (dwStage = 0; dwStage < KELVIN_NUM_TEXTURES; dwStage++) {
        dwMapping[dwStage] = pContext->hwState.dwTexUnitToTexStageMapping[dwStage];
    }

    // clear state that will be re-determined here
    pContext->hwState.dwNumActiveCombinerStages = 0;
    for (dwStage=0; dwStage < KELVIN_NUM_TEXTURES; dwStage++) {
        pContext->hwState.dwTexUnitToTexStageMapping[dwStage] = KELVIN_UNUSED;
    }

    pContext->hwState.dwNextAvailableTextureUnit = ((pContext->dwRenderState[D3DRS_POINTSPRITEENABLE]) &&
                                                    (pContext->dp2.dwDP2Prim == D3DDP2OP_POINTS)) ? 3 : 0;

    if (pContext->bUseTBlendSettings) {

        nvKelvinSetTextureBlend (pContext);
        pContext->hwState.dwNumActiveCombinerStages = 1;

    }

    else {

        // process all active texture stages
        do {

            bStageActive = nvConstructKelvinColorCombiners (pContext,
                                                            pContext->hwState.dwNumActiveCombinerStages,
                                                            pContext->hwState.dwNumActiveCombinerStages);
            nvConstructKelvinAlphaCombiners (pContext,
                                             pContext->hwState.dwNumActiveCombinerStages,
                                             pContext->hwState.dwNumActiveCombinerStages,
                                             bStageActive);

            // if the current unit got assigned to this stage, move on to the next
            if ((pContext->hwState.dwNextAvailableTextureUnit < KELVIN_NUM_TEXTURES) &&
                (pContext->hwState.dwTexUnitToTexStageMapping[pContext->hwState.dwNextAvailableTextureUnit] != KELVIN_UNUSED)) {
                pContext->hwState.dwNextAvailableTextureUnit++;
            }

            if ((bStageActive) || (pContext->hwState.dwNumActiveCombinerStages == 0)) {
                pContext->hwState.dwNumActiveCombinerStages++;
            }

        } while (bStageActive && pContext->hwState.dwNumActiveCombinerStages < KELVIN_NUM_COMBINERS);

    }

    // clear all the unused stages
    for (dwStage=pContext->hwState.dwNumActiveCombinerStages; dwStage<KELVIN_NUM_COMBINERS; dwStage++) {
        pContext->hwState.dwColorICW[dwStage] = 0;
        pContext->hwState.dwColorOCW[dwStage] = 0;
        pContext->hwState.dwAlphaICW[dwStage] = 0;
        pContext->hwState.dwAlphaOCW[dwStage] = 0;
    }

    // set control bits
    dwControl = DRF_NUM (097, _SET_COMBINER_CONTROL, _ITERATION_COUNT,
                         pContext->hwState.dwNumActiveCombinerStages);
    dwControl |= (DRF_DEF (097, _SET_COMBINER_CONTROL, _MUX_SELECT, _LSB)           |
                  DRF_DEF (097, _SET_COMBINER_CONTROL, _FACTOR0, _SAME_FACTOR_ALL)  |
                  DRF_DEF (097, _SET_COMBINER_CONTROL, _FACTOR1, _SAME_FACTOR_ALL));

#if STATE_OPTIMIZE
    // send the active stages to the hardware
    pContext->hwState.kelvin.set1 (NV097_SET_COMBINER_CONTROL, dwControl);
    pContext->hwState.kelvin.seta (NV097_SET_COMBINER_COLOR_ICW(0), pContext->hwState.dwNumActiveCombinerStages, pContext->hwState.dwColorICW);
    pContext->hwState.kelvin.seta (NV097_SET_COMBINER_COLOR_OCW(0), pContext->hwState.dwNumActiveCombinerStages, pContext->hwState.dwColorOCW);
    pContext->hwState.kelvin.seta (NV097_SET_COMBINER_ALPHA_ICW(0), pContext->hwState.dwNumActiveCombinerStages, pContext->hwState.dwAlphaICW);
    pContext->hwState.kelvin.seta (NV097_SET_COMBINER_ALPHA_OCW(0), pContext->hwState.dwNumActiveCombinerStages, pContext->hwState.dwAlphaOCW);

#else
    // send everything to the hardware
    pContext->hwState.kelvin.set1 (NV097_SET_COMBINER_CONTROL, dwControl);
    pContext->hwState.kelvin.set8 (NV097_SET_COMBINER_COLOR_ICW(0),
                                   pContext->hwState.dwColorICW[0],
                                   pContext->hwState.dwColorICW[1],
                                   pContext->hwState.dwColorICW[2],
                                   pContext->hwState.dwColorICW[3],
                                   pContext->hwState.dwColorICW[4],
                                   pContext->hwState.dwColorICW[5],
                                   pContext->hwState.dwColorICW[6],
                                   pContext->hwState.dwColorICW[7]);
    pContext->hwState.kelvin.set8 (NV097_SET_COMBINER_COLOR_OCW(0),
                                   pContext->hwState.dwColorOCW[0],
                                   pContext->hwState.dwColorOCW[1],
                                   pContext->hwState.dwColorOCW[2],
                                   pContext->hwState.dwColorOCW[3],
                                   pContext->hwState.dwColorOCW[4],
                                   pContext->hwState.dwColorOCW[5],
                                   pContext->hwState.dwColorOCW[6],
                                   pContext->hwState.dwColorOCW[7]);
    pContext->hwState.kelvin.set8 (NV097_SET_COMBINER_ALPHA_ICW(0),
                                   pContext->hwState.dwAlphaICW[0],
                                   pContext->hwState.dwAlphaICW[1],
                                   pContext->hwState.dwAlphaICW[2],
                                   pContext->hwState.dwAlphaICW[3],
                                   pContext->hwState.dwAlphaICW[4],
                                   pContext->hwState.dwAlphaICW[5],
                                   pContext->hwState.dwAlphaICW[6],
                                   pContext->hwState.dwAlphaICW[7]);
    pContext->hwState.kelvin.set8 (NV097_SET_COMBINER_ALPHA_OCW(0),
                                   pContext->hwState.dwAlphaOCW[0],
                                   pContext->hwState.dwAlphaOCW[1],
                                   pContext->hwState.dwAlphaOCW[2],
                                   pContext->hwState.dwAlphaOCW[3],
                                   pContext->hwState.dwAlphaOCW[4],
                                   pContext->hwState.dwAlphaOCW[5],
                                   pContext->hwState.dwAlphaOCW[6],
                                   pContext->hwState.dwAlphaOCW[7]);
#endif

    // if we've changed the flags or mappings, invalidate a bunch of state

    //if ((pContext->hwState.dwStateFlags & KELVIN_MASK_COMBINERPROGRAMUNIQUENESS) != dwStateFlags) {
    //    pContext->hwState.dwDirtyFlags |= (KELVIN_DIRTY_SPECFOG_COMBINER |
    //                                            KELVIN_DIRTY_LIGHTS);
    //}

#ifdef TESTCALLANDRETURN

    // this should render a pink banana in bend
    getDC()->nvPusher.flush (TRUE, CPushBuffer::FLUSH_WITH_DELAY);

    DWORD dwPBBase = getDC()->nvPusher.getBase();
    DWORD dwPBEnd = dwPBBase + getDC()->nvPusher.getSize();
    DWORD dwFuncBase = dwPBEnd - (14<<2);

    getDC()->nvPusher.push (0, NVPUSHER_CALL(dwFuncBase-dwPBBase));
    getDC()->nvPusher.adjust(1);

    dwControl = DRF_NUM (097, _SET_COMBINER_CONTROL, _ITERATION_COUNT, 1);
    dwControl |= (DRF_DEF (097, _SET_COMBINER_CONTROL, _MUX_SELECT, _LSB)           |
                  DRF_DEF (097, _SET_COMBINER_CONTROL, _FACTOR0, _SAME_FACTOR_ALL)  |
                  DRF_DEF (097, _SET_COMBINER_CONTROL, _FACTOR1, _SAME_FACTOR_ALL));

    DWORD dwCICW = 0x20010000;
    DWORD dwCOCW = 0x00000c00;
    DWORD dwAICW = 0x30300000;
    DWORD dwAOCW = 0x00000c00;

    ((DWORD*)dwFuncBase)[0]  = (0x00040000 | (NV_DD_KELVIN << 13) | NV097_SET_COMBINER_FACTOR0(0));
    ((DWORD*)dwFuncBase)[1]  = 0x00ff00ff;
    ((DWORD*)dwFuncBase)[2]  = (0x00040000 | (NV_DD_KELVIN << 13) | NV097_SET_COMBINER_CONTROL);
    ((DWORD*)dwFuncBase)[3]  = dwControl;
    ((DWORD*)dwFuncBase)[4]  = (0x00040000 | (NV_DD_KELVIN << 13) | NV097_SET_COMBINER_COLOR_ICW(0));
    ((DWORD*)dwFuncBase)[5]  = dwCICW;
    ((DWORD*)dwFuncBase)[6]  = (0x00040000 | (NV_DD_KELVIN << 13) | NV097_SET_COMBINER_COLOR_OCW(0));
    ((DWORD*)dwFuncBase)[7]  = dwCOCW;
    ((DWORD*)dwFuncBase)[8]  = (0x00040000 | (NV_DD_KELVIN << 13) | NV097_SET_COMBINER_ALPHA_ICW(0));
    ((DWORD*)dwFuncBase)[9]  = dwAICW;
    ((DWORD*)dwFuncBase)[10] = (0x00040000 | (NV_DD_KELVIN << 13) | NV097_SET_COMBINER_ALPHA_OCW(0));
    ((DWORD*)dwFuncBase)[11] = dwAOCW;
    ((DWORD*)dwFuncBase)[12] = NVPUSHER_RETURN();

    getDC()->nvPusher.flush (TRUE, CPushBuffer::FLUSH_WITH_DELAY);

#endif

    for (dwStage=0; dwStage<KELVIN_NUM_TEXTURES; dwStage++) {
        if (pContext->hwState.dwTexUnitToTexStageMapping[dwStage] != dwMapping[dwStage]) {
            pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_TEXTURE_STATE
                                           |  KELVIN_DIRTY_TEXTURE_TRANSFORM
                                           |  KELVIN_DIRTY_FVF
                                           |  KELVIN_DIRTY_TRANSFORM;
            break;
        }
    }

#ifdef ALPHA_CULL
    if(pContext->dwEarlyCopyStrategy && pContext->hwState.alphacull_mode >= 2)
        pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_MISC_STATE;
#endif

    dbgFlushType (NVDBG_FLUSH_STATE);
    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT nvSetKelvinPixelShader (PNVD3DCONTEXT pContext)
{
    pContext->hwState.dwDirtyFlags &= ~KELVIN_DIRTY_PIXEL_SHADER;

    if (pContext->pCurrentPShader) {
        pContext->pCurrentPShader->setKelvinState(pContext);
        pContext->hwState.dwDirtyFlags |= (KELVIN_DIRTY_TEXTURE_STATE     |
                                           KELVIN_DIRTY_FVF               |
                                           KELVIN_DIRTY_TEXTURE_TRANSFORM |
                                           KELVIN_DIRTY_TRANSFORM);
    }

    dbgFlushType (NVDBG_FLUSH_STATE);
    return (D3D_OK);
}

//---------------------------------------------------------------------------

// find next clip plane, if any, given clip plane enable bits and the
// current clip plane index. The former is expected to already have been
// shifted right by the latter.

__inline D3DVALUE *nvKelvinGetClipPlane
(
    PNVD3DCONTEXT pContext,
    DWORD *dwClipPlaneEnable,
    DWORD *dwCurrentClipPlaneIndex
)
{
    D3DVALUE *pClipPlane;

    if (*dwClipPlaneEnable) {
        // skip over disabled planes
        while (!((*dwClipPlaneEnable) & 0x1)) {
            (*dwClipPlaneEnable) >>= 1;
            (*dwCurrentClipPlaneIndex) ++;
        }
        // pick off the enabled plane
        pClipPlane = pContext->ppClipPlane[*dwCurrentClipPlaneIndex];
        (*dwClipPlaneEnable) >>= 1;
        (*dwCurrentClipPlaneIndex) ++;
    }
    else {
        pClipPlane = NULL;
    }

    return (pClipPlane);
}

//---------------------------------------------------------------------------

// set kelvin texture state, including:
//      - formats
//      - filters
//      - offsets
// note: the combiners must be set up before calling this routine!

HRESULT nvSetKelvinTextureState (PNVD3DCONTEXT pContext)
{
    DWORD               dwHWStage, dwD3DStage;
    PNVD3DTEXSTAGESTATE pTSSState;
    CTexture           *pTexture;
    CNvObject          *pTexObj;
    CNvObject          *pPalObj;
    CSimpleSurface     *pPalette;
    DWORD               dwOffset, dwFormat, dwAddress;
    DWORD               dwControl0, dwControl1;
    DWORD               dwFilter, dwRect, dwPalette, dwKey;
    DWORD               dwTexUnitStatus, dwLastTexUnitStatus;
    DWORD               dwTexGen, dwTCIndex, dwTexgenMode;
    DWORD               dwUserCoordsNeeded = 0;
    DWORD               dwTexCoordIndices = 0;
    DWORD               dwNumTexCoordsNeeded = 0;
    DWORD               dwInvMVNeeded = 0;
    BOOL                bCubeMap, bBumpMap, bSignedHILO, bUnsignedHILO, bLuminanceMode, bTextureHasLuminance;
    BOOL                bWrapU, bWrapV, bWrapP, bWrapQ;
    DWORD               dwClipPlaneEnable, dwCurrentClipPlaneIndex, dwClipStagesAllowed;
    DWORD               dwPlane, dwMethodOffset;
    D3DVALUE            dvScale, dvOffset;
    D3DVALUE            pClipPlaneEye[4];
    D3DVALUE           *pClipPlane[KELVIN_NUM_TEXTURES];
    D3DMATRIX           mTmp, mTmp2;
    DWORD               dwShaderMode[KELVIN_NUM_TEXTURES];
    DWORD               dwRGBMapping[KELVIN_NUM_TEXTURES];

    pContext->hwState.dwDirtyFlags &= ~KELVIN_DIRTY_TEXTURE_STATE;

    dwClipStagesAllowed     = KELVIN_CAPS_MAX_USER_CLIP_PLANES_ALLOWED >> 2;
    dwClipPlaneEnable       = pContext->dwRenderState[D3DRENDERSTATE_CLIPPLANEENABLE];
    dwCurrentClipPlaneIndex = 0;

    dwLastTexUnitStatus = KELVIN_TEXUNITSTATUS_IDLE;

    // iterate over the HW's texture units

    for (dwHWStage=0; dwHWStage < KELVIN_NUM_TEXTURES; dwHWStage++) {

        // which D3D stage is handled by this HW stage
        dwD3DStage = pContext->hwState.dwTexUnitToTexStageMapping[dwHWStage];

        if (dwD3DStage != KELVIN_UNUSED) {

#ifdef NV_PROFILE_DP2OPS
            pDriverData->pBenchmark->incActiveTextures();
#endif

            // the combiners assigned this texture unit.
            // we must have a legitimate texture to use

            pTSSState = &(pContext->tssState[dwD3DStage]);
            pTexObj = (CNvObject *)(pTSSState->dwValue[D3DTSS_TEXTUREMAP]);
            pTexture = pTexObj ? pTexObj->getTexture() : 0;

            if(!pTexture){
                //we should ALWAYS have a texture by this point -- substitute the default texture
                //this should be considered a setup error and will propogate out to 
                //nvValidateTextureStageState
                pTexture = getDC()->pDefaultTexture;
                pContext->hwState.dwStateFlags |= KELVIN_FLAG_SETUPFAILURE;
            }

            if (pTexture) {

                dbgTextureDisplay (pTexture);

                bCubeMap = pTexture->isCubeMap();
                if (bCubeMap) {
                    // cubemaps may only be referenced from their bases
                    pTexture = pTexture->getBaseTexture();
                }

                bBumpMap = (pContext->pCurrentPShader) ?
                        pContext->pCurrentPShader->isBEM(dwHWStage) :
                        (pTSSState->dwValue[D3DTSS_COLOROP] == D3DTOP_BUMPENVMAP) || (pTSSState->dwValue[D3DTSS_COLOROP] == D3DTOP_BUMPENVMAPLUMINANCE);

                if ((bBumpMap ^ pTexture->isBumpMap()) && !pContext->pCurrentPShader) {
                    DPF ("stupid app (WHQL) using bumpmapping w/o a bumpmap texture or vice-versa");
                    dbgD3DError();
                    pContext->hwState.dwStateFlags |= KELVIN_FLAG_SETUPFAILURE;
                }

                if (bBumpMap) {
                    // some kind of bumpmapping is desired. the exact flavor and how we treat it
                    // depends on the DX version, the blend mode, and the texture format. ugh.
                    bLuminanceMode = (pContext->pCurrentPShader) ?
                                    pContext->pCurrentPShader->isBEML(dwHWStage) :
                                    (pTSSState->dwValue[D3DTSS_COLOROP] == D3DTOP_BUMPENVMAPLUMINANCE);
                    bTextureHasLuminance = ((pTexture->getFormat() == NV_SURFACE_FORMAT_L6DV5DU5) ||
                                            (pTexture->getFormat() == NV_SURFACE_FORMAT_X8L8DV8DU8)) ? TRUE : FALSE;
                    dwTexUnitStatus = (!bLuminanceMode && !bTextureHasLuminance) ?
                                        KELVIN_TEXUNITSTATUS_BUMPMAPA :
                                        (!bLuminanceMode && bTextureHasLuminance) ?
                                            KELVIN_TEXUNITSTATUS_BUMPMAPB :
                                            (bLuminanceMode && !bTextureHasLuminance) ?
                                                KELVIN_TEXUNITSTATUS_BUMPMAPC :
                                                KELVIN_TEXUNITSTATUS_BUMPMAPD;
                }
                else {
                    dwTexUnitStatus = KELVIN_TEXUNITSTATUS_USER;
                }

                pContext->hwState.pTextureInUse[dwHWStage] = pTexture;

            }  // pTexture

            // we need this data later, for stomping out the projective coordinate when apps are stupid
            // and send down 4 coordinates, even though they don't need them
            if (pContext->pCurrentPShader) {
                dwNumTexCoordsNeeded |= KELVIN_SET_NUM_TEX_COORDS(dwHWStage, pContext->pCurrentPShader->getNumTexCoords(pContext, dwHWStage));
            } else if (pTexture) {
                dwNumTexCoordsNeeded |= KELVIN_SET_NUM_TEX_COORDS(dwHWStage, pTexture->getNumTexCoords());
            }

            // texgen -------------------------------------------------------
            if (pContext->pCurrentVShader->hasProgram()) {
                dwTexgenMode = NV097_SET_TEXGEN_S_V_DISABLE;  // vertex shader subsumes texgen
                dwTCIndex    = dwD3DStage;                    // mapping between vertex shader outputs and texture stages is identity
            }
            else {
                dwTexGen  = (pContext->hwState.dwStateFlags & KELVIN_FLAG_PASSTHROUGHMODE) ?
                            D3DTSS_TCI_PASSTHRU :
                            pTSSState->dwValue[D3DTSS_TEXCOORDINDEX] & 0xffff0000;
                dwTCIndex = pTSSState->dwValue[D3DTSS_TEXCOORDINDEX] & 0x0000ffff;
                switch (dwTexGen) {
                    case D3DTSS_TCI_PASSTHRU:
                        if (pContext->pCurrentVShader->bVAExists (defaultInputRegMap[D3DVSDE_TEXCOORD0+dwTCIndex])) {
                            dwUserCoordsNeeded |= KELVIN_FLAG_USERTEXCOORDSNEEDED(dwHWStage);
                            dwTexCoordIndices  |= dwTCIndex << (8*dwHWStage);
                        }
                        else if (!pContext->dwRenderState[D3DRS_POINTSPRITEENABLE]) {
                            // the architects are on crack. the NV097_SET_TEXCOORDx_4F methods are not evenly spaced.
                            DWORD dwBase = (dwHWStage == 3) ?
                                           NV097_SET_TEXCOORD3_4F(0) :
                                           NV097_SET_TEXCOORD0_4F(0) + 0x28*dwHWStage;
                            // u,v = 0,0  (says MS)W=1.0 THIS IS IMPORTANT (DOH!)
                            pContext->hwState.kelvin.set4f (dwBase, 0.0f, 0.0f, 0.0f, 1.0f);
                        }
                        dwTexgenMode = NV097_SET_TEXGEN_S_V_DISABLE;
                        break;
                    case D3DTSS_TCI_CAMERASPACENORMAL:
                        dwInvMVNeeded = KELVIN_FLAG_TEXSTATENEEDSINVMV;
                        dwTexgenMode = NV097_SET_TEXGEN_S_V_NORMAL_MAP;
                        break;
                    case D3DTSS_TCI_CAMERASPACEPOSITION:
                        pContext->hwState.kelvin.set4f (NV097_SET_TEXGEN_PLANE_S(dwHWStage,0), 1.0f, 0.0f, 0.0f, 0.0f);
                        pContext->hwState.kelvin.set4f (NV097_SET_TEXGEN_PLANE_T(dwHWStage,0), 0.0f, 1.0f, 0.0f, 0.0f);
                        pContext->hwState.kelvin.set4f (NV097_SET_TEXGEN_PLANE_R(dwHWStage,0), 0.0f, 0.0f, 1.0f, 0.0f);
                        dwTexgenMode = NV097_SET_TEXGEN_S_V_EYE_LINEAR;
                        break;
                    case D3DTSS_TCI_CAMERASPACEREFLECTIONVECTOR:
                        dwInvMVNeeded = KELVIN_FLAG_TEXSTATENEEDSINVMV;
                        dwTexgenMode = NV097_SET_TEXGEN_S_V_REFLECTION_MAP;
                        break;
                    default:
                        DPF ("unknown texgen mode in nvSetKelvinTextureState");
                        dbgD3DError();
                        pContext->hwState.dwStateFlags |= KELVIN_FLAG_SETUPFAILURE;
                        break;
                }
            }

            // we always generate three coordinates (i think)
            pContext->hwState.kelvin.set4 (NV097_SET_TEXGEN_S(dwHWStage),
                                           dwTexgenMode, dwTexgenMode,
                                           dwTexgenMode, NV097_SET_TEXGEN_Q_V_DISABLE);
            pContext->hwState.kelvin.set1 (NV097_SET_TEXGEN_VIEW_MODEL,
                                           pContext->dwRenderState[D3DRENDERSTATE_LOCALVIEWER] ?
                                           NV097_SET_TEXGEN_VIEW_MODEL_V_LOCAL_VIEWER :
                                           NV097_SET_TEXGEN_VIEW_MODEL_V_INFINITE_VIEWER);

            if (pTexture) {

                // offset -------------------------------------------------------
                dwOffset = pTexture->getSwizzled()->getOffset();

                // format -------------------------------------------------------
                dwFormat  = DRF_NUM (097, _SET_TEXTURE_FORMAT, _CONTEXT_DMA, nv097TextureContextDma[pTexture->getSwizzled()->getContextDMA()]);
                dwFormat |= DRF_NUM (097, _SET_TEXTURE_FORMAT, _CUBEMAP_ENABLE, bCubeMap);

                dwFormat |= (pTexture->isVolumeMap()) ?
                            DRF_DEF (097, _SET_TEXTURE_FORMAT, _DIMENSIONALITY, _THREE) :
                            DRF_DEF (097, _SET_TEXTURE_FORMAT, _DIMENSIONALITY, _TWO);

                if ((pTSSState->dwValue[D3DTSS_ADDRESSU] == D3DTADDRESS_BORDER) ||
                    (pTSSState->dwValue[D3DTSS_ADDRESSV] == D3DTADDRESS_BORDER) ||
                    (pTSSState->dwValue[D3DTSS_ADDRESSW] == D3DTADDRESS_BORDER)) {
                    pContext->hwState.kelvin.set1 (NV097_SET_TEXTURE_BORDER_COLOR(dwHWStage), pTSSState->dwValue[D3DTSS_BORDERCOLOR]);
                }

                dwFormat |= DRF_DEF (097, _SET_TEXTURE_FORMAT, _BORDER_SOURCE, _COLOR);
                dwFormat |= DRF_NUM (097, _SET_TEXTURE_FORMAT, _COLOR, nv097TextureFormat[pTexture->getFormat()]);

                dwFormat |= DRF_NUM (097, _SET_TEXTURE_FORMAT, _MIPMAP_LEVELS, pTexture->getMipMapCount());
                dwFormat |= DRF_NUM (097, _SET_TEXTURE_FORMAT, _BASE_SIZE_U,   pTexture->getLogicalLogWidth());
                dwFormat |= DRF_NUM (097, _SET_TEXTURE_FORMAT, _BASE_SIZE_V,   pTexture->getLogicalLogHeight());
                dwFormat |= DRF_NUM (097, _SET_TEXTURE_FORMAT, _BASE_SIZE_P,   pTexture->getLogicalLogDepth());

                // addressing ---------------------------------------------------

                // force clamp to edge if we're cubemapping
                dwAddress  = DRF_NUM (097, _SET_TEXTURE_ADDRESS, _U, pTexture->isCubeMap() ? nv097TextureAddress[3] : nv097TextureAddress[pTSSState->dwValue[D3DTSS_ADDRESSU]]);
                dwAddress |= DRF_NUM (097, _SET_TEXTURE_ADDRESS, _V, pTexture->isCubeMap() ? nv097TextureAddress[3] : nv097TextureAddress[pTSSState->dwValue[D3DTSS_ADDRESSV]]);
                dwAddress |= pTexture->isVolumeMap() ?    // D3DTSS_ADDRESSW doesn't seem to be valid if we don't have a volume map
                             DRF_NUM (097, _SET_TEXTURE_ADDRESS, _P, nv097TextureAddress[pTSSState->dwValue[D3DTSS_ADDRESSW]]) :
                             DRF_NUM (097, _SET_TEXTURE_ADDRESS, _P, nv097TextureAddress[1]);


                // check cylindrical wrapping (disallow it if we're cubemapping)
                NV_EVAL_CYLINDRICAL_WRAP (pContext, dwTCIndex, bWrapU, bWrapV, bWrapP, bWrapQ);
                dwAddress |= DRF_NUM (097, _SET_TEXTURE_ADDRESS, _CYLWRAP_U, bWrapU);
                dwAddress |= DRF_NUM (097, _SET_TEXTURE_ADDRESS, _CYLWRAP_V, bWrapV);
                dwAddress |= DRF_NUM (097, _SET_TEXTURE_ADDRESS, _CYLWRAP_P, bWrapP);
                dwAddress |= DRF_NUM (097, _SET_TEXTURE_ADDRESS, _CYLWRAP_Q, bWrapQ);

                // control0 -----------------------------------------------------
                dwControl0  = DRF_DEF (097, _SET_TEXTURE_CONTROL0, _ENABLE, _TRUE);

                // these are backward from openGL. d3d can only set the maximum mipmap level, by which they mean
                // the openGL minimum level (d3d maximum = largest sized level to use, not largest level number).
                // the d3d minimum level (the openGL / kelvin maximum) is always just the end of the chain
                dwControl0 |= DRF_NUM (097, _SET_TEXTURE_CONTROL0, _MIN_LOD_CLAMP, ((pTSSState->dwValue[D3DTSS_MAXMIPLEVEL]) << 8));  // 4.8 fixed point
                // If we are not mip mapped, we need to set the MAX_LOD_CLAMP to 1 in order to
                // get min filtering (if set to 0 we only get mag filtering on non-mipmapped textures).
                if( pTexture->getMipMapCount() == 1 ) {
                    dwControl0 |= DRF_NUM (097, _SET_TEXTURE_CONTROL0, _MAX_LOD_CLAMP, (1 << 8));  // 4.8 fixed point
                }
                else {
                    dwControl0 |= DRF_NUM (097, _SET_TEXTURE_CONTROL0, _MAX_LOD_CLAMP, ((pTexture->getMipMapCount()-1) << 8));  // 4.8 fixed point
                }

                dwControl0 |= DRF_DEF (097, _SET_TEXTURE_CONTROL0, _ALPHA_KILL_ENABLE, _FALSE);
                dwControl0 |= DRF_DEF (097, _SET_TEXTURE_CONTROL0, _IMAGE_FIELD_ENABLE, _FALSE);  // BUGBUG what's this???

                // colorkey
                if ((pContext->dwRenderState[D3DRENDERSTATE_COLORKEYENABLE]) && (pTexture->hasColorKey())) {
                    dwControl0 |= DRF_DEF (097, _SET_TEXTURE_CONTROL0, _COLOR_KEY_OPERATION, _KILL);  // use this choice since the texture may not have alpha
                    dwKey = pTexture->getColorKey();
                    if (pTexture->isPalettized()) {
                        if ((pTexture->getWrapper()) &&
                            (pTexture->getWrapper()->getPalette()) &&
                            (pTexture->getWrapper()->getPalette()->getPaletteSurface()) &&
                            (dwKey < 256)) {
                            dwKey = ((DWORD *)(pTexture->getWrapper()->getPalette()->getPaletteSurface()->getAddress()))[dwKey];
                        }
                        else {
                            DPF ("unable to extract color key from palettized texture");
                            dbgD3DError();
                        }
                    }
                    pContext->hwState.kelvin.set1 (NV097_SET_COLOR_KEY_COLOR(dwHWStage), dwKey);
                }
                else {
                    dwControl0 |= DRF_DEF (097, _SET_TEXTURE_CONTROL0, _COLOR_KEY_OPERATION, _FALSE);
                }

                // control1 -----------------------------------------------------
                dwControl1 = DRF_NUM (097, _SET_TEXTURE_CONTROL1, _IMAGE_PITCH, 0x0008);

                // filter -------------------------------------------------------
                dwFilter  = DRF_DEF (097, _SET_TEXTURE_FILTER, _CONVOLUTION_KERNEL, _GAUSSIAN_3);

                bSignedHILO   = (pTexture->getFormat() == NV_SURFACE_FORMAT_HILO_HEMI_V16U16);
                bUnsignedHILO = (pTexture->getFormat() == NV_SURFACE_FORMAT_HILO_1_V16U16);

                if (pContext->pCurrentPShader && !pContext->pCurrentPShader->stageUsesTexture(dwHWStage)) {
                    dwFilter |= DRF_DEF (097, _SET_TEXTURE_FILTER, _ASIGNED, _BIT_DISABLED) |
                                DRF_DEF (097, _SET_TEXTURE_FILTER, _RSIGNED, _BIT_DISABLED) |
                                DRF_DEF (097, _SET_TEXTURE_FILTER, _GSIGNED, _BIT_DISABLED) |
                                DRF_DEF (097, _SET_TEXTURE_FILTER, _BSIGNED, _BIT_DISABLED);
                } else if (bBumpMap) {
                    dwFilter |= DRF_DEF (097, _SET_TEXTURE_FILTER, _ASIGNED, _BIT_DISABLED) |
                                DRF_DEF (097, _SET_TEXTURE_FILTER, _RSIGNED, _BIT_DISABLED) |
                                DRF_DEF (097, _SET_TEXTURE_FILTER, _GSIGNED, _BIT_ENABLED)  |
                                DRF_DEF (097, _SET_TEXTURE_FILTER, _BSIGNED, _BIT_ENABLED);
                } else if (bSignedHILO) {
                    dwFilter |= DRF_DEF (097, _SET_TEXTURE_FILTER, _ASIGNED, _BIT_ENABLED)  |
                                DRF_DEF (097, _SET_TEXTURE_FILTER, _RSIGNED, _BIT_DISABLED) |
                                DRF_DEF (097, _SET_TEXTURE_FILTER, _GSIGNED, _BIT_ENABLED)  |
                                DRF_DEF (097, _SET_TEXTURE_FILTER, _BSIGNED, _BIT_DISABLED);
                } else if (pTexture->getFourCC() == D3DFMT_Q8W8V8U8) {
                    dwFilter |= DRF_DEF (097, _SET_TEXTURE_FILTER, _ASIGNED, _BIT_ENABLED) |
                                DRF_DEF (097, _SET_TEXTURE_FILTER, _RSIGNED, _BIT_ENABLED) |
                                DRF_DEF (097, _SET_TEXTURE_FILTER, _GSIGNED, _BIT_ENABLED) |
                                DRF_DEF (097, _SET_TEXTURE_FILTER, _BSIGNED, _BIT_ENABLED);
                } else {
                    dwFilter |= DRF_DEF (097, _SET_TEXTURE_FILTER, _ASIGNED, _BIT_DISABLED) |
                                DRF_DEF (097, _SET_TEXTURE_FILTER, _RSIGNED, _BIT_DISABLED) |
                                DRF_DEF (097, _SET_TEXTURE_FILTER, _GSIGNED, _BIT_DISABLED) |
                                DRF_DEF (097, _SET_TEXTURE_FILTER, _BSIGNED, _BIT_DISABLED);
                }

                DWORD dwMinFilter = pTSSState->dwValue[D3DTSS_MINFILTER];
                DWORD dwMagFilter = pTSSState->dwValue[D3DTSS_MAGFILTER];
                DWORD dwMipFilter = pTSSState->dwValue[D3DTSS_MIPFILTER];

                if (pContext->dwDXAppVersion >= 0x800) {
                    // DX8 changed the filter enumerants. Remap them so we don't have to change our code.
                    dwMinFilter = dx8MinFilterMapping[dwMinFilter];
                    dwMagFilter = dx8MagFilterMapping[dwMagFilter];
                    dwMipFilter = dx8MipFilterMapping[dwMipFilter];
                }

                // Mag filter aniso is bilinear in HW, and this passes WHQL.
                // As a result trigger anisotropic off of Min filter only
                if ((dwMinFilter == D3DTFN_ANISOTROPIC) ||
                    (getDC()->nvD3DRegistryData.regAnisotropicLevel != D3D_REG_ANISOTROPICLEVEL_PASSIVE))
                {
                    DWORD dwMaxAnisotropy = (getDC()->nvD3DRegistryData.regAnisotropicLevel == D3D_REG_ANISOTROPICLEVEL_PASSIVE) ?
                                            pTSSState->dwValue[D3DTSS_MAXANISOTROPY] :
                                            getDC()->nvD3DRegistryData.regAnisotropicLevel;
                    // We can only handle anisotropy in powers-of-2.  Non powers-of-2 are
                    // promoted to higher levels of anisotropy.
                    switch (dwMaxAnisotropy) {
                        case 0:
                            // default back to point
                            dwControl0 |= DRF_DEF (097, _SET_TEXTURE_CONTROL0, _LOG_MAX_ANISO, _0);
                            dwFilter   |= DRF_NUM (097, _SET_TEXTURE_FILTER, _MIN, nv097TextureMinFilter[D3DTFN_POINT][dwMipFilter]);
                            dwFilter   |= DRF_NUM (097, _SET_TEXTURE_FILTER, _MAG, nv097TextureMagFilter[dwMagFilter]);
                            break;
                        case 1:
                            // default back to linear with no aniso
                            dwControl0 |= DRF_DEF (097, _SET_TEXTURE_CONTROL0, _LOG_MAX_ANISO, _0);
                            dwFilter   |= DRF_NUM (097, _SET_TEXTURE_FILTER, _MIN, nv097TextureMinFilter[D3DTFN_LINEAR][dwMipFilter]);
                            dwFilter   |= DRF_NUM (097, _SET_TEXTURE_FILTER, _MAG, nv097TextureMagFilter[dwMagFilter]);
                            break;
                        case 2:
                            // use real aniso
                            dwControl0 |= DRF_DEF (097, _SET_TEXTURE_CONTROL0, _LOG_MAX_ANISO, _1);
                            dwFilter   |= DRF_NUM (097, _SET_TEXTURE_FILTER, _MIN, nv097TextureMinFilter[D3DTFN_LINEAR][dwMipFilter]);
                            dwFilter   |= DRF_NUM (097, _SET_TEXTURE_FILTER, _MAG, nv097TextureMagFilter[D3DTFG_LINEAR]);
                            if(dwMagFilter == D3DTFG_POINT) {
                                // When aniso filtering is on, mag filter will be linear, point filtering
                                // won't happen, so we must fail validate texture stage for DCT450.
                                pContext->hwState.dwStateFlags |= KELVIN_FLAG_SETUPFAILURE;
                            }
                            break;
                        case 3:
                        case 4:
                            // use real aniso
                            dwControl0 |= DRF_DEF (097, _SET_TEXTURE_CONTROL0, _LOG_MAX_ANISO, _2);
                            dwFilter   |= DRF_NUM (097, _SET_TEXTURE_FILTER, _MIN, nv097TextureMinFilter[D3DTFN_LINEAR][dwMipFilter]);
                            dwFilter   |= DRF_NUM (097, _SET_TEXTURE_FILTER, _MAG, nv097TextureMagFilter[D3DTFG_LINEAR]);
                            if(dwMagFilter == D3DTFG_POINT) {
                                // When aniso filtering is on, mag filter will be linear, point filtering
                                // won't happen, so we must fail validate texture stage for DCT450.
                                pContext->hwState.dwStateFlags |= KELVIN_FLAG_SETUPFAILURE;
                            }
                            break;
                        default:
                            // aniso > 8. we can't really do it, but we'll approximate it as best we can
                            pContext->hwState.dwStateFlags |= KELVIN_FLAG_SETUPFAILURE;
                            // fall through
                        case 5:
                        case 6:
                        case 7:
                        case 8:
                            // use real aniso
                            dwControl0 |= DRF_DEF (097, _SET_TEXTURE_CONTROL0, _LOG_MAX_ANISO, _3);
                            dwFilter   |= DRF_NUM (097, _SET_TEXTURE_FILTER, _MIN, nv097TextureMinFilter[D3DTFN_LINEAR][dwMipFilter]);
                            dwFilter   |= DRF_NUM (097, _SET_TEXTURE_FILTER, _MAG, nv097TextureMagFilter[D3DTFG_LINEAR]);
                            if(dwMagFilter == D3DTFG_POINT) {
                                // When aniso filtering is on, mag filter will be linear, point filtering
                                // won't happen, so we must fail validate texture stage for DCT450.
                                pContext->hwState.dwStateFlags |= KELVIN_FLAG_SETUPFAILURE;
                            }
                            break;
                    }  // switch
                }

                else {  // anisotropic filtering should not be enabled
                    // Mag aniso is bilinear in HW, and this passes WHQL.
                    if (dwMagFilter == D3DTFG_ANISOTROPIC) {
                        dwMagFilter = D3DTFG_LINEAR;
                    }

                    dwControl0 |= DRF_DEF (097, _SET_TEXTURE_CONTROL0, _LOG_MAX_ANISO, _0);
                    dwFilter   |= DRF_NUM (097, _SET_TEXTURE_FILTER, _MIN, nv097TextureMinFilter[dwMinFilter][dwMipFilter]);
                    dwFilter   |= DRF_NUM (097, _SET_TEXTURE_FILTER, _MAG, nv097TextureMagFilter[dwMagFilter]);
                }

                // LOD bias
                dwFilter |= DRF_NUM (097, _SET_TEXTURE_FILTER, _MIPMAP_LOD_BIAS, pTSSState->dwLODBias);

                // image rect ---------------------------------------------------
                dwRect  = DRF_NUM (097, _SET_TEXTURE_IMAGE_RECT, _WIDTH, 8);  // this is ignored, just set something valid
                dwRect |= DRF_NUM (097, _SET_TEXTURE_IMAGE_RECT, _HEIGHT, 8);

                // palette ------------------------------------------------------
                dwPalette = 0;
                if (pTexture->isPalettized()) {
                    pPalObj = ((CNvObject *)(pTSSState->dwValue[D3DTSS_TEXTUREMAP]))->getPalette();
                    if (pPalObj) {
                        pPalette = pPalObj->getPaletteSurface();
                        nvAssert (pPalette);   // should already have bound a palette before using this texture
                        dwPalette |= DRF_NUM (097, _SET_TEXTURE_PALETTE, _CONTEXT_DMA, nv097PaletteContextDma[pPalette->getContextDMA()]);
                        dwPalette |= DRF_DEF (097, _SET_TEXTURE_PALETTE, _LENGTH, _256);
                        dwPalette |= DRF_NUM (097, _SET_TEXTURE_PALETTE, _OFFSET, (pPalette->getOffset() >> 6));  // offset measured is 64-byte units
                    } else {
                        DPF ("stupid app/runtime gave us a palettized texture without a palette");
                        DPF ("the app likely has no idea about alt-tabbing");
                        dbgD3DError();
                    }
                }
                else if (pTexture->hasAutoPalette()) {
                    nvAssert ((pTexture->getAutoPaletteOffset() & 63) == 0);
                    dwPalette |= DRF_NUM (097, _SET_TEXTURE_PALETTE, _CONTEXT_DMA, nv097PaletteContextDma[pTexture->getSwizzled()->getContextDMA()]);
                    dwPalette |= DRF_DEF (097, _SET_TEXTURE_PALETTE, _LENGTH, _256);
                    dwPalette |= DRF_NUM (097, _SET_TEXTURE_PALETTE, _OFFSET, (pTexture->getAutoPaletteOffset() >> 6));  // offset measured is 64-byte units
                }

                // send everything ----------------------------------------------
                pContext->hwState.kelvin.set6 (NV097_SET_TEXTURE_OFFSET(dwHWStage),
                                               dwOffset, dwFormat, dwAddress, dwControl0, dwControl1, dwFilter);
                pContext->hwState.kelvin.set2 (NV097_SET_TEXTURE_IMAGE_RECT(dwHWStage),
                                               dwRect, dwPalette);

                // bumpmapping and shader mode ----------------------------------
                // the latter is saved off to be sent to the HW when we're done with all textures
                if (dwLastTexUnitStatus & (KELVIN_TEXUNITSTATUS_BUMPMAPA |
                                           KELVIN_TEXUNITSTATUS_BUMPMAPB |
                                           KELVIN_TEXUNITSTATUS_BUMPMAPC |
                                           KELVIN_TEXUNITSTATUS_BUMPMAPD)) {

                    if (pContext->tssState[dwD3DStage].dwValue[D3DTSS_TEXTURETRANSFORMFLAGS] & D3DTTFF_PROJECTED) {
                        DPF ("kelvin097 cannot do projective texturing with bumpmapping");
                        pContext->hwState.dwStateFlags |= KELVIN_FLAG_SETUPFAILURE;
                    }

                    DWORD dwBumpMapStage = (pContext->pCurrentPShader) ? dwD3DStage : (dwD3DStage-1);

                    pContext->hwState.kelvin.set4 (NV097_SET_TEXTURE_SET_BUMP_ENV_MAT00(dwHWStage),
                                                   pContext->tssState[dwBumpMapStage].dwValue[D3DTSS_BUMPENVMAT00],
                                                   pContext->tssState[dwBumpMapStage].dwValue[D3DTSS_BUMPENVMAT01],
                                                   pContext->tssState[dwBumpMapStage].dwValue[D3DTSS_BUMPENVMAT11],
                                                   pContext->tssState[dwBumpMapStage].dwValue[D3DTSS_BUMPENVMAT10]);

                    if (pContext->dwDXAppVersion < 0x0700) {
                        // DX6 or below
                        switch (dwLastTexUnitStatus) {
                            case KELVIN_TEXUNITSTATUS_BUMPMAPA:
                            case KELVIN_TEXUNITSTATUS_BUMPMAPB:
                            case KELVIN_TEXUNITSTATUS_BUMPMAPC:
                                dvScale  = 0.f;
                                dvOffset = FLOAT_FROM_DWORD(pContext->tssState[dwBumpMapStage].dwValue[D3DTSS_BUMPENVLSCALE]) +
                                           FLOAT_FROM_DWORD(pContext->tssState[dwD3DStage-1].dwValue[D3DTSS_BUMPENVLOFFSET]);
                                dwShaderMode[dwHWStage] = NV097_SET_SHADER_STAGE_PROGRAM_STAGE1_BUMPENVMAP_LUMINANCE;
                                break;
                            case KELVIN_TEXUNITSTATUS_BUMPMAPD:
                                dvScale  = FLOAT_FROM_DWORD(pContext->tssState[dwBumpMapStage].dwValue[D3DTSS_BUMPENVLSCALE]);
                                dvOffset = FLOAT_FROM_DWORD(pContext->tssState[dwBumpMapStage].dwValue[D3DTSS_BUMPENVLOFFSET]);
                                dwShaderMode[dwHWStage] = NV097_SET_SHADER_STAGE_PROGRAM_STAGE1_BUMPENVMAP_LUMINANCE;
                                break;
                        }
                    }
                    else {
                        // DX7 or higher
                        switch (dwLastTexUnitStatus) {
                            case KELVIN_TEXUNITSTATUS_BUMPMAPA:
                            case KELVIN_TEXUNITSTATUS_BUMPMAPB:
                                dvScale  = 0.f;  // actually n/a
                                dvOffset = 0.f;  // actually n/a
                                dwShaderMode[dwHWStage] = NV097_SET_SHADER_STAGE_PROGRAM_STAGE1_BUMPENVMAP;
                                break;
                            case KELVIN_TEXUNITSTATUS_BUMPMAPC:
                                dvScale  = 0.f;
                                dvOffset = FLOAT_FROM_DWORD(pContext->tssState[dwBumpMapStage].dwValue[D3DTSS_BUMPENVLSCALE]) +
                                           FLOAT_FROM_DWORD(pContext->tssState[dwBumpMapStage].dwValue[D3DTSS_BUMPENVLOFFSET]);
                                dwShaderMode[dwHWStage] = NV097_SET_SHADER_STAGE_PROGRAM_STAGE1_BUMPENVMAP_LUMINANCE;
                                break;
                            case KELVIN_TEXUNITSTATUS_BUMPMAPD:
                                dvScale  = FLOAT_FROM_DWORD(pContext->tssState[dwBumpMapStage].dwValue[D3DTSS_BUMPENVLSCALE]);
                                dvOffset = FLOAT_FROM_DWORD(pContext->tssState[dwBumpMapStage].dwValue[D3DTSS_BUMPENVLOFFSET]);
                                dwShaderMode[dwHWStage] = NV097_SET_SHADER_STAGE_PROGRAM_STAGE1_BUMPENVMAP_LUMINANCE;
                                break;
                        }
                    }
                    pContext->hwState.kelvin.set2f (NV097_SET_TEXTURE_SET_BUMP_ENV_SCALE(dwHWStage), dvScale, dvOffset);

                }

                else {
                    dwShaderMode[dwHWStage] = bCubeMap ?
                                                  NV097_SET_SHADER_STAGE_PROGRAM_STAGE0_CUBE_MAP :
                                                  pTexture->isVolumeMap() ?
                                                      NV097_SET_SHADER_STAGE_PROGRAM_STAGE0_3D_PROJECTIVE :
                                                      NV097_SET_SHADER_STAGE_PROGRAM_STAGE0_2D_PROJECTIVE;
                }

                // really only relevant for stages >= 1, but innocuous for stage 0
                dwRGBMapping[dwHWStage] = bSignedHILO ?
                                              NV097_SET_DOT_RGBMAPPING_STAGE1_HILO_HEMISPHERE_MS :
                                              (bUnsignedHILO ?
                                                  NV097_SET_DOT_RGBMAPPING_STAGE1_HILO_1 :
                                                  NV097_SET_DOT_RGBMAPPING_STAGE1_ZERO_TO_1);

            }

            else {

                dwTexUnitStatus = KELVIN_TEXUNITSTATUS_USER;

                // control 0
                dwControl0  = DRF_DEF (097, _SET_TEXTURE_CONTROL0, _ENABLE, _FALSE);
                dwControl0 |= DRF_NUM (097, _SET_TEXTURE_CONTROL0, _MIN_LOD_CLAMP, 0);
                dwControl0 |= DRF_NUM (097, _SET_TEXTURE_CONTROL0, _MAX_LOD_CLAMP, 0);
                dwControl0 |= DRF_DEF (097, _SET_TEXTURE_CONTROL0, _ALPHA_KILL_ENABLE, _FALSE);
                dwControl0 |= DRF_DEF (097, _SET_TEXTURE_CONTROL0, _IMAGE_FIELD_ENABLE, _FALSE);
                dwControl0 |= DRF_DEF (097, _SET_TEXTURE_CONTROL0, _COLOR_KEY_OPERATION, _FALSE);
                dwControl0 |= DRF_DEF (097, _SET_TEXTURE_CONTROL0, _LOG_MAX_ANISO, _0);

                pContext->hwState.kelvin.set1 (NV097_SET_TEXTURE_CONTROL0(dwHWStage), dwControl0);

            }

        }

        else if (dwClipPlaneEnable && dwClipStagesAllowed) {

            // if user clip planes are enabled, knock off as many as we can.
            // (each texture stage can handle four)

            dwTexUnitStatus = KELVIN_TEXUNITSTATUS_CLIP;
            pContext->hwState.pTextureInUse[dwHWStage] = NULL;

            dwClipStagesAllowed --;

            // fetch up to four planes
            for (dwPlane = 0; dwPlane < 4; dwPlane++) {
                pClipPlane[dwPlane] = nvKelvinGetClipPlane (pContext, &dwClipPlaneEnable, &dwCurrentClipPlaneIndex);
            }

            // we better have found at least one
            nvAssert(pClipPlane[0]);

            // D3D gives us the normals in world space, so they need to be converted to eye space
            // calculate the required matrix
            Inverse4x4 (&mTmp, &(pContext->xfmView), TRUE);
            MatrixTranspose4x4 (&mTmp2, &mTmp);

            dwMethodOffset = NV097_SET_TEXGEN_PLANE_S (dwHWStage,0);

            // transform and send as many planes as we have
            for (dwPlane = 0; dwPlane < 4; dwPlane++) {
                if (pClipPlane[dwPlane]) {
                    XformVector4 (pClipPlaneEye, pClipPlane[dwPlane], &mTmp2);
                }
                // send the last plane repeatedly to fill the remaining slots
                pContext->hwState.kelvin.set4f (dwMethodOffset,
                                                pClipPlaneEye[0], pClipPlaneEye[1],
                                                pClipPlaneEye[2], pClipPlaneEye[3]);
                dwMethodOffset += 0x10;
            }

            // generate texture coords from eye space coordinates
            pContext->hwState.kelvin.set4 (NV097_SET_TEXGEN_S(dwHWStage),
                                           NV097_SET_TEXGEN_S_V_EYE_LINEAR,
                                           NV097_SET_TEXGEN_T_V_EYE_LINEAR,
                                           NV097_SET_TEXGEN_R_V_EYE_LINEAR,
                                           NV097_SET_TEXGEN_Q_V_EYE_LINEAR);

            // according to Harold, the only thing we care about in this case is control0
            dwControl0  = DRF_DEF (097, _SET_TEXTURE_CONTROL0, _ENABLE, _TRUE);
            dwControl0 |= DRF_NUM (097, _SET_TEXTURE_CONTROL0, _MIN_LOD_CLAMP, 0);
            dwControl0 |= DRF_NUM (097, _SET_TEXTURE_CONTROL0, _MAX_LOD_CLAMP, 0);
            dwControl0 |= DRF_DEF (097, _SET_TEXTURE_CONTROL0, _ALPHA_KILL_ENABLE, _FALSE);
            dwControl0 |= DRF_DEF (097, _SET_TEXTURE_CONTROL0, _IMAGE_FIELD_ENABLE, _FALSE);
            dwControl0 |= DRF_DEF (097, _SET_TEXTURE_CONTROL0, _COLOR_KEY_OPERATION, _FALSE);
            dwControl0 |= DRF_DEF (097, _SET_TEXTURE_CONTROL0, _LOG_MAX_ANISO, _0);

            pContext->hwState.kelvin.set1 (NV097_SET_TEXTURE_CONTROL0(dwHWStage), dwControl0);

            // set the shader program to clip mode (pixel kill contingent on sign of eye
            // coords dotted with clip plane normal)
            dwShaderMode[dwHWStage] = NV097_SET_SHADER_STAGE_PROGRAM_STAGE0_CLIP_PLANE;
            dwRGBMapping[dwHWStage] = NV097_SET_DOT_RGBMAPPING_STAGE1_ZERO_TO_1;

        }

        else if (!pContext->pCurrentPShader) {

            // no user texture, no clip planes. go ahead and totally disable the stage

            dwTexUnitStatus = KELVIN_TEXUNITSTATUS_IDLE;
            pContext->hwState.pTextureInUse[dwHWStage] = NULL;

            pContext->hwState.kelvin.set4 (NV097_SET_TEXGEN_S(dwHWStage),
                                           NV097_SET_TEXGEN_S_V_DISABLE,
                                           NV097_SET_TEXGEN_T_V_DISABLE,
                                           NV097_SET_TEXGEN_R_V_DISABLE,
                                           NV097_SET_TEXGEN_Q_V_DISABLE);

            // control 0
            dwControl0  = DRF_DEF (097, _SET_TEXTURE_CONTROL0, _ENABLE, _FALSE);
            dwControl0 |= DRF_NUM (097, _SET_TEXTURE_CONTROL0, _MIN_LOD_CLAMP, 0);
            dwControl0 |= DRF_NUM (097, _SET_TEXTURE_CONTROL0, _MAX_LOD_CLAMP, 0);
            dwControl0 |= DRF_DEF (097, _SET_TEXTURE_CONTROL0, _ALPHA_KILL_ENABLE, _FALSE);
            dwControl0 |= DRF_DEF (097, _SET_TEXTURE_CONTROL0, _IMAGE_FIELD_ENABLE, _FALSE);
            dwControl0 |= DRF_DEF (097, _SET_TEXTURE_CONTROL0, _COLOR_KEY_OPERATION, _FALSE);
            dwControl0 |= DRF_DEF (097, _SET_TEXTURE_CONTROL0, _LOG_MAX_ANISO, _0);

            pContext->hwState.kelvin.set1 (NV097_SET_TEXTURE_CONTROL0(dwHWStage), dwControl0);

            dwShaderMode[dwHWStage] = NV097_SET_SHADER_STAGE_PROGRAM_STAGE0_PROGRAM_NONE;
            dwRGBMapping[dwHWStage] = NV097_SET_DOT_RGBMAPPING_STAGE1_ZERO_TO_1;

        }

        dwLastTexUnitStatus = dwTexUnitStatus;

        if (pContext->hwState.dwTextureUnitStatus[dwHWStage] != dwTexUnitStatus) {
            pContext->hwState.dwTextureUnitStatus[dwHWStage] = dwTexUnitStatus;
            pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_TEXTURE_TRANSFORM | KELVIN_DIRTY_FVF;
        }

    }  // for dwHWStage=0...

    if (!pContext->pCurrentPShader) {
        // send the shader RGB mapping state to the hardware
        pContext->hwState.kelvin.set1 (NV097_SET_DOT_RGBMAPPING, // No stage 0 remapping
                                       (DRF_NUM (097, _SET_DOT_RGBMAPPING, _STAGE1, dwRGBMapping[1]) |
                                        DRF_NUM (097, _SET_DOT_RGBMAPPING, _STAGE2, dwRGBMapping[2]) |
                                        DRF_NUM (097, _SET_DOT_RGBMAPPING, _STAGE3, dwRGBMapping[3])));

        // send the collective shader programs to the HW
        pContext->hwState.kelvin.set1 (NV097_SET_SHADER_STAGE_PROGRAM,
                                       (DRF_NUM (097, _SET_SHADER_STAGE_PROGRAM, _STAGE0, dwShaderMode[0]) |
                                        DRF_NUM (097, _SET_SHADER_STAGE_PROGRAM, _STAGE1, dwShaderMode[1]) |
                                        DRF_NUM (097, _SET_SHADER_STAGE_PROGRAM, _STAGE2, dwShaderMode[2]) |
                                        DRF_NUM (097, _SET_SHADER_STAGE_PROGRAM, _STAGE3, dwShaderMode[3])));

        // for DX7, dependent texture lookups always run between stages i and i+1
        pContext->hwState.kelvin.set1 (NV097_SET_SHADER_OTHER_STAGE_INPUT,
                                      (DRF_DEF (097, _SET_SHADER_OTHER_STAGE_INPUT, _STAGE1, _INSTAGE_0) |
                                       DRF_DEF (097, _SET_SHADER_OTHER_STAGE_INPUT, _STAGE2, _INSTAGE_1) |
                                       DRF_DEF (097, _SET_SHADER_OTHER_STAGE_INPUT, _STAGE3, _INSTAGE_2)));
    }

    // set dependent dirty state

    if ((pContext->hwState.dwStateFlags & KELVIN_FLAG_USERTEXCOORDSNEEDED_MASK) != dwUserCoordsNeeded) {
        pContext->hwState.dwStateFlags &= ~KELVIN_FLAG_USERTEXCOORDSNEEDED_MASK;
        pContext->hwState.dwStateFlags |= dwUserCoordsNeeded;
        pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_FVF;
    }

    if (dwNumTexCoordsNeeded != pContext->hwState.dwNumTexCoordsNeeded) {
        pContext->hwState.dwNumTexCoordsNeeded = dwNumTexCoordsNeeded;
        pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_FVF;
    }

    if ((pContext->hwState.dwStateFlags & KELVIN_FLAG_TEXSTATENEEDSINVMV) != dwInvMVNeeded) {
        pContext->hwState.dwStateFlags &= ~KELVIN_FLAG_TEXSTATENEEDSINVMV;
        pContext->hwState.dwStateFlags |= dwInvMVNeeded;
        pContext->hwState.dwDirtyFlags |= dwInvMVNeeded ? KELVIN_DIRTY_TRANSFORM : 0;
    }

    if (pContext->hwState.dwTexCoordIndices != dwTexCoordIndices) {
        pContext->hwState.dwTexCoordIndices = dwTexCoordIndices;
        pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_FVF;
    }

    if ((getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_SQUASHW_MASK) == D3D_REG_SQUASHW_ENABLE) {
        pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_TRANSFORM;
    }

    if (dwClipPlaneEnable) {
        DPF ("nvSetKelvinTextureState: exiting with unhandled clip planes");
        nvAssert (0);
        pContext->hwState.dwStateFlags |= KELVIN_FLAG_SETUPFAILURE;
    }

    dbgFlushType (NVDBG_FLUSH_STATE);
    return (D3D_OK);
}

//---------------------------------------------------------------------------

HRESULT nvKelvinSetFogMode (PNVD3DCONTEXT pContext)
{
    float fBias, fScale;

    nvAssert (pContext->dwRenderState[D3DRENDERSTATE_FOGENABLE]);

    cacheFogValues (pContext);

    switch (pContext->fogData.dwFogTableMode) {
        case D3DFOG_NONE:   // user-supplied fog (neither table nor vertex)
            fBias = 1.0f;
            fScale = 1.0f;
            pContext->hwState.kelvin.set1 (NV097_SET_FOG_MODE, NV097_SET_FOG_MODE_V_LINEAR);
            break;
        case D3DFOG_LINEAR:
            fBias = 1.0f + pContext->fogData.fFogTableEnd * pContext->fogData.fFogTableLinearScale;
            fScale = -pContext->fogData.fFogTableLinearScale;
            pContext->hwState.kelvin.set1 (NV097_SET_FOG_MODE, NV097_SET_FOG_MODE_V_LINEAR);
            break;
        case D3DFOG_EXP:
            fBias = 1.5f;
            fScale = -pContext->fogData.fFogTableDensity * (1.0f / (2.0f * 5.5452f));
            pContext->hwState.kelvin.set1 (NV097_SET_FOG_MODE, NV097_SET_FOG_MODE_V_EXP);
            break;
        case D3DFOG_EXP2:
            fBias = 1.5f;
            fScale = -pContext->fogData.fFogTableDensity * (1.0f / (2.0f * (float)sqrt(5.5452f)));
            pContext->hwState.kelvin.set1 (NV097_SET_FOG_MODE, NV097_SET_FOG_MODE_V_EXP2);
            break;
        default:
            DPF ("uh oh. unknown fog mode");
    }

    // set fog_gen mode. note this is actually only relevant in T&L fixed mode, but we'll just set it regardless
    if (pContext->fogData.dwFogTableMode == D3DFOG_NONE) {
        // both table fog and vertex fog are disabled. we default back to regular user fog from specular alpha
        pContext->hwState.kelvin.set1 (NV097_SET_FOG_GEN_MODE, NV097_SET_FOG_GEN_MODE_V_SPEC_ALPHA);
    }
    else {
        pContext->hwState.kelvin.set1 (NV097_SET_FOG_GEN_MODE,
                                       pContext->dwRenderState[D3DRENDERSTATE_RANGEFOGENABLE] ?
                                           NV097_SET_FOG_GEN_MODE_V_RADIAL :
                                           NV097_SET_FOG_GEN_MODE_V_PLANAR);
    }

    pContext->hwState.kelvin.set3f (NV097_SET_FOG_PARAMS(0), fBias, fScale, 0.0f);

    dbgFlushType (NVDBG_FLUSH_STATE);
    return (D3D_OK);
}

//---------------------------------------------------------------------------

// set the specular/fog combiner

HRESULT nvSetKelvinSpecularFogCombiner (PNVD3DCONTEXT pContext)
{
    DWORD dwControl0, dwControl1;  // HW control words

    pContext->hwState.dwDirtyFlags &= ~KELVIN_DIRTY_COMBINERS_SPECFOG;

    dwControl0 = 0;

    if (pContext->dwRenderState[D3DRENDERSTATE_FOGENABLE]) {

        pContext->hwState.kelvin.set2 (NV097_SET_FOG_ENABLE,
                                       NV097_SET_FOG_ENABLE_V_TRUE,
                                       swapRGB(pContext->dwRenderState[D3DRENDERSTATE_FOGCOLOR]));

        nvKelvinSetFogMode (pContext);

        // A is fog factor, obtained from fog alpha
        dwControl0 |= (DRF_DEF (097, _SET_COMBINER_SPECULAR_FOG_CW0, _A_SOURCE, _REG_3) |
                       DRF_DEF (097, _SET_COMBINER_SPECULAR_FOG_CW0, _A_ALPHA, _TRUE));

        // B source is (textured diffuse) or (textured diffuse + specular)
        if (pContext->dwRenderState[D3DRENDERSTATE_SPECULARENABLE]) {
            dwControl0 |= DRF_DEF (097, _SET_COMBINER_SPECULAR_FOG_CW0, _B_SOURCE, _REG_SPECLIT);
        }
        else {  // don't add specular to diffuse(textured) color
            dwControl0 |= DRF_DEF (097, _SET_COMBINER_SPECULAR_FOG_CW0, _B_SOURCE, _REG_C);
        }

        // C is fog color
        dwControl0 |= DRF_DEF (097, _SET_COMBINER_SPECULAR_FOG_CW0, _C_SOURCE, _REG_3);

        // D isn't used

        pContext->hwState.kelvin.set1 (NV097_SET_COMBINER_SPECULAR_FOG_CW0, dwControl0);
    }

    else { // no fog, just output diffuse (+ specular)

        pContext->hwState.kelvin.set1 (NV097_SET_FOG_ENABLE, NV097_SET_FOG_ENABLE_V_FALSE);

        if (pContext->dwRenderState[D3DRENDERSTATE_SPECULARENABLE]) {
            dwControl0 |= DRF_DEF (097, _SET_COMBINER_SPECULAR_FOG_CW0, _D_SOURCE, _REG_SPECLIT);
        }
        else {  // don't add specular to diffuse(textured) color
            dwControl0 |= DRF_DEF (097, _SET_COMBINER_SPECULAR_FOG_CW0, _D_SOURCE, _REG_C);
        }

        pContext->hwState.kelvin.set1 (NV097_SET_COMBINER_SPECULAR_FOG_CW0, dwControl0);
    }

    dwControl1 = 0;

    // the final value for alpha is just taken from G
    dwControl1 |= (DRF_DEF (097, _SET_COMBINER_SPECULAR_FOG_CW1, _G_SOURCE, _REG_C) |
                   DRF_DEF (097, _SET_COMBINER_SPECULAR_FOG_CW1, _G_ALPHA, _TRUE));

    dwControl1 |= DRF_DEF (097, _SET_COMBINER_SPECULAR_FOG_CW1, _SPECULAR_CLAMP, _TRUE);

    pContext->hwState.kelvin.set1 (NV097_SET_COMBINER_SPECULAR_FOG_CW1, dwControl1);

#ifdef ALPHA_CULL
    //cachec off spec/fog control words
    pContext->hwState.specfog_cw[0] = dwControl0;
    pContext->hwState.specfog_cw[1] = dwControl1;

    if(pContext->dwEarlyCopyStrategy && pContext->hwState.alphacull_mode >= 2)
        pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_MISC_STATE;
#endif

    dbgFlushType (NVDBG_FLUSH_STATE);
    return (D3D_OK);
}

//---------------------------------------------------------------------------

// set kelvin vertex shaders

HRESULT nvSetKelvinVertexShader (PNVD3DCONTEXT pContext)
{
#ifdef PRECOMPILED_PASSTHROUGH
    KELVIN_MICRO_PROGRAM *pProgram;
#else
    KELVIN_MICRO_PROGRAM program;
    char *pProgram;
#endif

    pContext->hwState.dwDirtyFlags &= ~KELVIN_DIRTY_VERTEX_SHADER;

    nvAssert(pContext->pCurrentVShader);

    if ((pContext->dwDXAppVersion >= 0x800) && (pContext->pCurrentVShader->hasProgram())) {

        // load user's program
        CVertexShader* pVertexShader = pContext->pCurrentVShader;

        if (pVertexShader->m_ProgramOutput.residentNumInstructions) {

#ifdef KPFS
            pDriverData->nvKelvinPM.download(pContext,pVertexShader);
#else

            pContext->hwState.kelvin.set1 (NV097_SET_TRANSFORM_EXECUTION_MODE,
                                           (DRF_DEF (097, _SET_TRANSFORM_EXECUTION_MODE, _MODE, _PROGRAM) |
                                            DRF_DEF (097, _SET_TRANSFORM_EXECUTION_MODE, _RANGE_MODE, _USER)));
            pContext->hwState.kelvin.set1 (NV097_SET_TRANSFORM_PROGRAM_CXT_WRITE_EN,
                                           DRF_DEF (097, _SET_TRANSFORM_PROGRAM_CXT_WRITE_EN, _V, _READ_ONLY));

            pContext->hwState.kelvin.set1 (NV097_SET_TRANSFORM_PROGRAM_START, 0);
            nvKelvinDownloadProgram (pContext, &pVertexShader->m_ProgramOutput, 0);
            nvKelvinDownloadConstants (pContext);
#endif

        }

    }

    else if (pContext->hwState.dwStateFlags & KELVIN_FLAG_PASSTHROUGHMODE) {
        // choose the appropriate passthru program
        if (pContext->fogData.dwFogTableMode == D3DFOG_NONE) {
            // fog is disabled or both table fog and vertex fog are disabled.
            // we default back to regular user fog from specular alpha
#ifdef PRECOMPILED_PASSTHROUGH
            pProgram = (KELVIN_MICRO_PROGRAM*)(kmpPassthruProgramSpecFog);
#else
            pProgram = szPassthruProgramSpecFog;
#endif
        }
        else {
            // we're doing vertex or table fog
            nvAssert(pContext->hwState.dwFogSource); // assert that fog source has been set
            if (pContext->hwState.dwFogSource == CHardwareState::FOG_SOURCE_Z) {
                // use z for fog depth
#ifdef PRECOMPILED_PASSTHROUGH
                pProgram = (KELVIN_MICRO_PROGRAM*)(kmpPassthruProgramZFog);
#else
                pProgram = szPassthruProgramZFog;
#endif
            }
            else {
                // use w for fog depth
#ifdef PRECOMPILED_PASSTHROUGH
                pProgram = (KELVIN_MICRO_PROGRAM*)(kmpPassthruProgramWFog);
#else
                pProgram = szPassthruProgramWFog;
#endif
            }
        }
        DWORD temp = sizeof(KELVIN_MICRO_PROGRAM);
        // passthrough program
        pContext->hwState.kelvin.set1 (NV097_SET_TRANSFORM_EXECUTION_MODE,
                                       (DRF_DEF (097, _SET_TRANSFORM_EXECUTION_MODE, _MODE, _PROGRAM) |
                                        DRF_DEF (097, _SET_TRANSFORM_EXECUTION_MODE, _RANGE_MODE, _PRIV)));
        pContext->hwState.kelvin.set1 (NV097_SET_TRANSFORM_PROGRAM_CXT_WRITE_EN,
                                       DRF_DEF (097, _SET_TRANSFORM_PROGRAM_CXT_WRITE_EN, _V, _READ_ONLY));
#ifdef PRECOMPILED_PASSTHROUGH

    #ifdef KPFS
        pDriverData->nvKelvinPM.download_special(pContext,pProgram,0xFFFFFFFF);
    #else
        nvKelvinDownloadProgram (pContext, pProgram,0);
    #endif

#else
        nvKelvinInitProgram (&program);
        nvKelvinParseProgram (&program, pProgram);

    #ifdef KPFS
        pDriverData->nvKelvinPM.download_special(pContext,pProgram,0xFFFFFFFF);
    #else
        nvKelvinDownloadProgram (pContext, &program,0);
    #endif

#endif

#ifndef KPFS
        // the starting address is just 0
        pContext->hwState.kelvin.set1 (NV097_SET_TRANSFORM_PROGRAM_START, 0);
#endif
    }

    else {
        // just use fixed mode
        pContext->hwState.kelvin.set1 (NV097_SET_TRANSFORM_EXECUTION_MODE,
                                       (DRF_DEF (097, _SET_TRANSFORM_EXECUTION_MODE, _MODE, _FIXED) |
                                        DRF_DEF (097, _SET_TRANSFORM_EXECUTION_MODE, _RANGE_MODE, _PRIV)));
#ifdef KPFS
        pDriverData->nvKelvinPM.dirty();
#endif

    }

    dbgFlushType (NVDBG_FLUSH_STATE);
    return (D3D_OK);
}

//---------------------------------------------------------------------------

// set texture transformation matrices

HRESULT nvSetKelvinTextureTransform (PNVD3DCONTEXT pContext)
{
    BOOL       bEnable;
    DWORD      dwHWStage, dwD3DStage;
    DWORD      dwInCount, dwOutCount;
    DWORD      dwFlags, dwTexUnitStatus;
    DWORD      dwMatrixName, dwMatrixType;
    D3DMATRIX *pMatrix;

    pContext->hwState.dwDirtyFlags &= ~KELVIN_DIRTY_TEXTURE_TRANSFORM;

    for (dwHWStage=0; dwHWStage < KELVIN_NUM_TEXTURES; dwHWStage++) {

        dwD3DStage = pContext->hwState.dwTexUnitToTexStageMapping[dwHWStage];
        dwTexUnitStatus = pContext->hwState.dwTextureUnitStatus[dwHWStage];

        if ((dwD3DStage == KELVIN_UNUSED) || (dwTexUnitStatus == KELVIN_TEXUNITSTATUS_CLIP)) {

            bEnable = FALSE;

        }

        else {

            nvAssert (dwTexUnitStatus & (KELVIN_TEXUNITSTATUS_USER     |
                                         KELVIN_TEXUNITSTATUS_BUMPMAPA |
                                         KELVIN_TEXUNITSTATUS_BUMPMAPB |
                                         KELVIN_TEXUNITSTATUS_BUMPMAPC |
                                         KELVIN_TEXUNITSTATUS_BUMPMAPD));
            nvAssert (pContext->pCurrentPShader || (pContext->tssState[dwD3DStage].dwValue[D3DTSS_COLOROP] != D3DTOP_DISABLE));

            dwFlags = pContext->tssState[dwD3DStage].dwValue[D3DTSS_TEXTURETRANSFORMFLAGS];

            // the number of coordinates to come out of the transformation, including the projective coordinate
            // (== the number of d3d-style matrix columns with non-zero elements)
            dwOutCount = dwFlags & 0xff; // BUGBUG there should be a #define for this. pester MS
            bEnable = (dwOutCount != D3DTTFF_DISABLE);

        }

        if (!bEnable) {

            pContext->hwState.kelvin.set1 (NV097_SET_TEXTURE_MATRIX_ENABLE(dwHWStage),
                                           DRF_DEF (097, _SET_TEXTURE_MATRIX_ENABLE, _V, _FALSE));

        }

        else {

            pContext->hwState.kelvin.set1 (NV097_SET_TEXTURE_MATRIX_ENABLE(dwHWStage),
                                           DRF_DEF (097, _SET_TEXTURE_MATRIX_ENABLE, _V, _TRUE));

            pMatrix = &(pContext->tssState[dwD3DStage].mTexTransformMatrix);

            // the number of coordinates incoming from the vertex streams or texgen (not counting q).
            // this is typically the number of d3d-style matrix rows with non-zero elements, though
            // there may be dwInCount+1 rows, the last of which references the q=1.0 that d3d assumes
            // to be automatically postpended to the incoming coordinates.
            DWORD dwTexGen  = pContext->tssState[dwD3DStage].dwValue[D3DTSS_TEXCOORDINDEX] & 0xffff0000;
            DWORD dwTCIndex = pContext->tssState[dwD3DStage].dwValue[D3DTSS_TEXCOORDINDEX] & 0x0000ffff;
            DWORD dwVAIndex = defaultInputRegMap[D3DVSDE_TEXCOORD0+dwTCIndex];
            if (dwTexGen) {
                dwInCount = 3;
            }
            else {
                // if index invalid, just use 0,0
                dwInCount = (pContext->pCurrentVShader->bVAExists(dwVAIndex)) ?
                            (pContext->pCurrentVShader->getVASize(dwVAIndex)) :
                            2*sizeof(DWORD);
                dwInCount >>= 2;
            }

            // nv097 texture matrix macros are less than ideal
            dwMatrixName = NV097_SET_TEXTURE_MATRIX0(0) + 0x40*dwHWStage;

            // calculate an arbitrary identifier
            dwMatrixType = (dwInCount << 8) | (dwOutCount << 4) | ((dwFlags & D3DTTFF_PROJECTED) ? 1 : 0);

            // the way we emit the matrix varies widely because d3d is dumb.
            // A. when there are two incoming coordinates, we must move the 3rd matrix row to the fourth, because
            //    MS expects the appended q to sit in the third slot, whereas in the HW, it sits in the 4th.
            // B. when the matrix is projective and there are only 3 outgoing coordinates (including q)
            //    we must shift the value in the third outgoing slot (where MS puts q) to the 4th slot (where
            //    the HW wants it) by moving the 3rd column to the 4th
            // C. when the matrix is non-projective, it becomes our job to override the relevant row of the
            //    matrix, forcing the outgoing q to 1.0
            // finally, when all is said and done, the matrix must be transposed to change it from backward
            // d3d style to real opengl style.
            switch (dwMatrixType) {

                case 0x220:
                    // (s,t,1.0) in, (s,t,1.0) out
                    pContext->hwState.kelvin.setTextureTransformMatrixType220 (dwMatrixName, pMatrix);
                    break;
                case 0x230:
                    // (s,t,1.0) in, (s,t,r,1.0) out
                    pContext->hwState.kelvin.setTextureTransformMatrixType230 (dwMatrixName, pMatrix);
                    break;
                case 0x231:
                    // (s,t,1.0) in, (s,t,q) out
                    pContext->hwState.kelvin.setTextureTransformMatrixType231 (dwMatrixName, pMatrix);
                    break;
                case 0x241:
                    // (s,t,1.0) in, (s,t,r,q) out
                    pContext->hwState.kelvin.setTextureTransformMatrixType241 (dwMatrixName, pMatrix);
                    break;
                case 0x320:
                    // (s,t,r,1.0) in, (s,t,1.0) out
                    pContext->hwState.kelvin.setTextureTransformMatrixType320 (dwMatrixName, pMatrix);
                    break;
                case 0x330:
                    // (s,t,r,1.0) in, (s,t,r,1.0) out
                    pContext->hwState.kelvin.setTextureTransformMatrixType330 (dwMatrixName, pMatrix);
                    break;
                case 0x331:
                    // (s,t,r,1.0) in, (s,t,q) out
                    pContext->hwState.kelvin.setTextureTransformMatrixType331 (dwMatrixName, pMatrix);
                    break;
                case 0x341:
                    // (s,t,r,1.0) in, (s,t,r,q) out
                    pContext->hwState.kelvin.setTextureTransformMatrixType341 (dwMatrixName, pMatrix);
                    break;
                default:
                    DPF ("unhandled texture transform = 0x%04x", dwMatrixType);
                    dbgD3DError();
                    break;

            }  // switch

        }  // else enable

    }  // for dwHWStage=0...

    dbgFlushType (NVDBG_FLUSH_STATE);
    return (D3D_OK);
}

//---------------------------------------------------------------------------

// set kelvin class specular parameters

HRESULT nvKelvinSetSpecularParams (PNVD3DCONTEXT pContext)
{
    float L, M, N, L1, M1, N1, power;

    nvAssert ((pContext->dwRenderState[D3DRENDERSTATE_SPECULARENABLE]) ||
              (pContext->hwState.dwStateFlags & KELVIN_FLAG_COMBINERSNEEDSPECULAR));

    power = pContext->Material.dvPower;
    explut (power, &L, &M);
    N = 1.f+L-M;
    explut (0.5f*power, &L1, &M1);
    N1 = 1.f+L1-M1;
    pContext->hwState.kelvin.set3f (NV097_SET_SPECULAR_PARAMS(0),L, M, N);
    pContext->hwState.kelvin.set3f (NV097_SET_SPECULAR_PARAMS(3),L1,M1,N1);
    //pContext->hwState.kelvin.set3f (NV097_SET_BACK_SPECULAR_PARAMS(0),L, M, N);
    //pContext->hwState.kelvin.set3f (NV097_SET_BACK_SPECULAR_PARAMS(3),L1,M1,N1);

    return (D3D_OK);
}

//---------------------------------------------------------------------------

// set diffuse, specular, and ambient colors for a particular light
// input:
//      - dwLightID = light index [0...7]
//      - pLight7 = pointer to light data
//      - dwCmArg   = color material flags

HRESULT nvKelvinDumpLightColors (PNVD3DCONTEXT pContext, DWORD dwLightID, LPD3DLIGHT7 pLight7, DWORD dwCmArg)
{
    D3DVALUE dvAmbientR, dvAmbientG, dvAmbientB;
    D3DVALUE dvDiffuseR, dvDiffuseG, dvDiffuseB;
    D3DVALUE dvSpecularR, dvSpecularG, dvSpecularB;

    nvAssert ((dwLightID >=0) && (dwLightID <= 7));

    dvAmbientR = pLight7->dcvAmbient.dvR;
    dvAmbientG = pLight7->dcvAmbient.dvG;
    dvAmbientB = pLight7->dcvAmbient.dvB;
    if (DRF_VAL (097, _SET_COLOR_MATERIAL, _AMBIENT_MATERIAL, dwCmArg) == NV097_SET_COLOR_MATERIAL_AMBIENT_MATERIAL_DISABLE) {
        // use material ambient color
        dvAmbientR *= pContext->Material.dcvAmbient.dvR;
        dvAmbientG *= pContext->Material.dcvAmbient.dvG;
        dvAmbientB *= pContext->Material.dcvAmbient.dvB;
    }

    dvDiffuseR = pLight7->dcvDiffuse.dvR;
    dvDiffuseG = pLight7->dcvDiffuse.dvG;
    dvDiffuseB = pLight7->dcvDiffuse.dvB;
    if (DRF_VAL (097, _SET_COLOR_MATERIAL, _DIFF_MATERIAL, dwCmArg) == NV097_SET_COLOR_MATERIAL_DIFF_MATERIAL_DISABLE) {
        // use material diffuse color
        dvDiffuseR *= pContext->Material.dcvDiffuse.dvR;
        dvDiffuseG *= pContext->Material.dcvDiffuse.dvG;
        dvDiffuseB *= pContext->Material.dcvDiffuse.dvB;
    }

    dvSpecularR = pLight7->dcvSpecular.dvR;
    dvSpecularG = pLight7->dcvSpecular.dvG;
    dvSpecularB = pLight7->dcvSpecular.dvB;
    if (DRF_VAL (097, _SET_COLOR_MATERIAL, _SPECULAR_MATERIAL, dwCmArg) == NV097_SET_COLOR_MATERIAL_SPECULAR_MATERIAL_DISABLE) {
        // follow material specular color
        dvSpecularR *= pContext->Material.dcvSpecular.dvR;
        dvSpecularG *= pContext->Material.dcvSpecular.dvG;
        dvSpecularB *= pContext->Material.dcvSpecular.dvB;
    }

    pContext->hwState.kelvin.set3f (NV097_SET_LIGHT_AMBIENT_COLOR(dwLightID,0), dvAmbientR, dvAmbientG, dvAmbientB);  // ambient
    pContext->hwState.kelvin.set3f (NV097_SET_LIGHT_DIFFUSE_COLOR(dwLightID,0), dvDiffuseR, dvDiffuseG, dvDiffuseB);  // diffuse
    pContext->hwState.kelvin.set3f (NV097_SET_LIGHT_SPECULAR_COLOR(dwLightID,0),dvSpecularR,dvSpecularG,dvSpecularB); // specular

    return (D3D_OK);
}

//---------------------------------------------------------------------------

// set position and attenuation of a particular light
// input:
//      - dwLightID = light index [0...7]
//      - pLight7 = pointer to light data

HRESULT nvKelvinDumpLocalLightData (PNVD3DCONTEXT pContext, int dwLightID, LPD3DLIGHT7 pLight7)
{
    D3DVECTOR pos1;

    nvAssert ((dwLightID >=0) && (dwLightID <= 7));

    // We don't normalize the position
    XformBy4x3 (&pos1, &(pLight7->dvPosition), 1.f, &(pContext->xfmView));

    pContext->hwState.kelvin.set3f (NV097_SET_LIGHT_LOCAL_POSITION(dwLightID,0), pos1.dvX, pos1.dvY, pos1.dvZ);

    nvAssert ((DWORD_FROM_FLOAT(pLight7->dvAttenuation0) != 0) ||
              (DWORD_FROM_FLOAT(pLight7->dvAttenuation1) != 0) ||
              (DWORD_FROM_FLOAT(pLight7->dvAttenuation2) != 0));

    pContext->hwState.kelvin.set3f (NV097_SET_LIGHT_LOCAL_ATTENUATION(dwLightID,0),
                                    pLight7->dvAttenuation0,
                                    pLight7->dvAttenuation1,
                                    pLight7->dvAttenuation2);

    return (D3D_OK);
}

//---------------------------------------------------------------------------

DWORD getKelvinColorMaterialFlags (PNVD3DCONTEXT pContext)
{
    DWORD dwArgs;

    // start out with everything disabled
    dwArgs = 0;

    // if COLORVERTEX isn't set just return now
    if (!pContext->dwRenderState[D3DRENDERSTATE_COLORVERTEX]) {
        return (dwArgs);
    }

    switch (pContext->dwRenderState[D3DRENDERSTATE_AMBIENTMATERIALSOURCE]) {
        case D3DMCS_MATERIAL:
            break;
        case D3DMCS_COLOR1:  // diffuse
            if (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_DIFFUSE])) {
                dwArgs |= DRF_DEF (097, _SET_COLOR_MATERIAL, _AMBIENT_MATERIAL, _DIFFUSE_VTX_COLOR);
                //dwArgs |= DRF_DEF (097, _SET_COLOR_MATERIAL, _BACK_AMBIENT_MATERIAL, _DIFF_VTX_COLOR);
            }
            break;
        case D3DMCS_COLOR2:  // specular
            if (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_SPECULAR])) {
                dwArgs |= DRF_DEF (097, _SET_COLOR_MATERIAL, _AMBIENT_MATERIAL, _SPECULAR_VTX_COLOR);
                //dwArgs |= DRF_DEF (097, _SET_COLOR_MATERIAL, _BACK_AMBIENT_MATERIAL, _SPEC_VTX_COLOR);
            }
            break;
        default:
            DPF ("unknown AMBIENTMATERIALSOURCE");
            break;
    }

    switch (pContext->dwRenderState[D3DRENDERSTATE_DIFFUSEMATERIALSOURCE]) {
        case D3DMCS_MATERIAL:
            break;
        case D3DMCS_COLOR1:  // diffuse
            if (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_DIFFUSE])) {
                dwArgs |= DRF_DEF (097, _SET_COLOR_MATERIAL, _DIFF_MATERIAL, _DIFFUSE_VTX_COLOR);
                //dwArgs |= DRF_DEF (097, _SET_COLOR_MATERIAL, _BACK_DIFF_MATERIAL, _DIFF_VTX_COLOR);
            }
            break;
        case D3DMCS_COLOR2:  // specular
            if (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_SPECULAR])) {
                dwArgs |= DRF_DEF (097, _SET_COLOR_MATERIAL, _DIFF_MATERIAL, _SPECULAR_VTX_COLOR);
                //dwArgs |= DRF_DEF (097, _SET_COLOR_MATERIAL, _BACK_DIFF_MATERIAL, _SPEC_VTX_COLOR);
            }
            break;
        default:
            DPF ("unknown DIFFUSEMATERIALSOURCE");
            break;
    }

    switch (pContext->dwRenderState[D3DRENDERSTATE_SPECULARMATERIALSOURCE]) {
        case D3DMCS_MATERIAL:
            break;
        case D3DMCS_COLOR1:  // diffuse
            if (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_DIFFUSE])) {
                dwArgs |= DRF_DEF (097, _SET_COLOR_MATERIAL, _SPECULAR_MATERIAL, _DIFFUSE_VTX_COLOR);
                //dwArgs |= DRF_DEF (097, _SET_COLOR_MATERIAL, _BACK_SPECULAR_MATERIAL, _DIFF_VTX_COLOR);
            }
            break;
        case D3DMCS_COLOR2:  // specular
            // inherit material specular from vertex specular
            if (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_SPECULAR])) {
                dwArgs |= DRF_DEF (097, _SET_COLOR_MATERIAL, _SPECULAR_MATERIAL, _SPECULAR_VTX_COLOR);
                //dwArgs |= DRF_DEF (097, _SET_COLOR_MATERIAL, _BACK_SPECULAR_MATERIAL, _SPEC_VTX_COLOR);
            }
            break;
        default:
            DPF ("unknown SPECULARMATERIALSOURCE");
            break;
    }

    switch (pContext->dwRenderState[D3DRENDERSTATE_EMISSIVEMATERIALSOURCE]) {
        case D3DMCS_MATERIAL:
            break;
        case D3DMCS_COLOR1:  // diffuse
            if (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_DIFFUSE])) {
                dwArgs |= DRF_DEF (097, _SET_COLOR_MATERIAL, _EMISSIVE_MATERIAL, _DIFFUSE_VTX_COLOR);
                //dwArgs |= DRF_DEF (097, _SET_COLOR_MATERIAL, _BACK_EMISSIVE_MATERIAL, _DIFF_VTX_COLOR);
            }
            break;
        case D3DMCS_COLOR2:  // specular
            if (pContext->pCurrentVShader->bVAExists(defaultInputRegMap[D3DVSDE_SPECULAR])) {
                dwArgs |= DRF_DEF (097, _SET_COLOR_MATERIAL, _EMISSIVE_MATERIAL, _SPECULAR_VTX_COLOR);
                //dwArgs |= DRF_DEF (097, _SET_COLOR_MATERIAL, _BACK_EMISSIVE_MATERIAL, _SPEC_VTX_COLOR);
            }
            break;
        default:
            DPF ("unknown EMISSIVEMATERIALSOURCE");
            break;
    }

    return (dwArgs);
}

//---------------------------------------------------------------------------

// set lighting state

HRESULT nvSetKelvinLights (PNVD3DCONTEXT pContext)
{
    DWORD         dwColorMaterialArgs;
    DWORD         dwControl = 0;
    DWORD         dwLightNum;
    DWORD         dwMask = 0;
    D3DCOLORVALUE dcvAmbient, dcvEmissive;
    D3DVECTOR     eyeDirection;
    D3DVECTOR     dir, hv;          // light directions
    pnvLight      pLight;
    LPD3DLIGHT7   pLight7;
    BOOL          bSpecularNeeded;
    DWORD         dwInvMVNeeded;

    pContext->hwState.dwDirtyFlags &= ~KELVIN_DIRTY_LIGHTS;

    // specular enable
    bSpecularNeeded = ((pContext->dwRenderState[D3DRENDERSTATE_SPECULARENABLE]) ||
                       (pContext->hwState.dwStateFlags & KELVIN_FLAG_COMBINERSNEEDSPECULAR)) ? TRUE : FALSE;

    // disable hardware lighting if app has disabled it or if we're in passthrough mode
    // (yes, stupid apps will try to enable lighting without giving us normals, etc...)
    if (!GET_LIGHTING_STATE(pContext) || (pContext->hwState.dwStateFlags & KELVIN_FLAG_PASSTHROUGHMODE)) {

        // disable lighting
        pContext->hwState.kelvin.set1 (NV097_SET_LIGHTING_ENABLE, NV097_SET_LIGHTING_ENABLE_V_FALSE);

        dwInvMVNeeded = 0;

        pContext->hwState.kelvin.set1 (NV097_SET_SPECULAR_ENABLE, DRF_NUM (097, _SET_SPECULAR_ENABLE, _V, bSpecularNeeded));

        dwControl |= (DRF_DEF (097, _SET_LIGHT_CONTROL, _LOCALEYE, _FALSE) |
                      DRF_DEF (097, _SET_LIGHT_CONTROL, _SOUT, _ZERO_OUT)  |            // set alpha component to 1.0 (method is horribly misnamed)
                      DRF_DEF (097, _SET_LIGHT_CONTROL, _SEPARATE_SPECULAR_EN, _TRUE)); // this is a don't-care

        pContext->hwState.kelvin.set1 (NV097_SET_LIGHT_CONTROL, dwControl);

        // set default diffuse and specular
        pContext->hwState.kelvin.set1 (NV097_SET_DIFFUSE_COLOR4UB,  0xFFFFFFFF);  // white
        pContext->hwState.kelvin.set1 (NV097_SET_SPECULAR_COLOR4UB, 0);           // black

    }

    else {

        // we shouldn't be in passthru mode if we're really going to do lighting
        // (moreover we can't be, b/c we won't have calculated xfmInvModelView which
        // is needed for spot lights)
        nvAssert (!(pContext->hwState.dwStateFlags & KELVIN_FLAG_PASSTHROUGHMODE));

        // enable lighting
        pContext->hwState.kelvin.set1 (NV097_SET_LIGHTING_ENABLE, NV097_SET_LIGHTING_ENABLE_V_TRUE);

        dwInvMVNeeded = KELVIN_FLAG_LIGHTINGNEEDSINVMV;

        // this should always be TRUE in T&L mode. see table of kelvin's perverse specular behavior
        pContext->hwState.kelvin.set1 (NV097_SET_SPECULAR_ENABLE, DRF_DEF (097, _SET_SPECULAR_ENABLE, _V, _TRUE));

        // set specular parameters if needed
        if (bSpecularNeeded) {
            nvKelvinSetSpecularParams (pContext);
        }

        // use local viewer only if we really need to, since it's slow
        if ((pContext->dwRenderState[D3DRENDERSTATE_LOCALVIEWER]) &&
            (pContext->lighting.pActiveLights != NULL) &&
            (bSpecularNeeded)) {
            dwControl |= DRF_DEF (097, _SET_LIGHT_CONTROL, _LOCALEYE, _TRUE);
        }
        else {
            dwControl |= DRF_DEF (097, _SET_LIGHT_CONTROL, _LOCALEYE, _FALSE);
        }

        dwControl |= (DRF_DEF (097, _SET_LIGHT_CONTROL, _SOUT, _ZERO_OUT) |             // set alpha component to 1.0 (method is horribly misnamed)
                      DRF_DEF (097, _SET_LIGHT_CONTROL, _SEPARATE_SPECULAR_EN, _TRUE)); // d3d never lumps specular in with diffuse

        pContext->hwState.kelvin.set1 (NV097_SET_LIGHT_CONTROL, dwControl);

        // material properties
        dwColorMaterialArgs = getKelvinColorMaterialFlags (pContext);
        pContext->hwState.kelvin.set1 (NV097_SET_COLOR_MATERIAL, dwColorMaterialArgs);

        // in kelvin, the color is initialized to SCENE_AMBIENT, C0, or C1. this is followed by an
        // optional accumulation of C0 or C1 times MATERIAL_EMISSION. both the initialization and
        // accumulation are controlled by the color material bits, so these determine the (sometimes
        // counter-intuitive) values to which we initialize SCENE_AMBIENT and MATERIAL_EMISSION.

        if (dwColorMaterialArgs & (DRF_DEF (097, _SET_COLOR_MATERIAL, _AMBIENT_MATERIAL, _DIFFUSE_VTX_COLOR) |
                                   DRF_DEF (097, _SET_COLOR_MATERIAL, _AMBIENT_MATERIAL, _SPECULAR_VTX_COLOR))) {
            // ambient is being pulled from the vertex
            dcvAmbient.dvR  = pContext->Material.dcvEmissive.dvR;
            dcvAmbient.dvG  = pContext->Material.dcvEmissive.dvG;
            dcvAmbient.dvB  = pContext->Material.dcvEmissive.dvB;
            dcvEmissive.dvR = pContext->lighting.dcvAmbient.dvR;
            dcvEmissive.dvG = pContext->lighting.dcvAmbient.dvG;
            dcvEmissive.dvB = pContext->lighting.dcvAmbient.dvB;
        }
        else if (dwColorMaterialArgs & (DRF_DEF (097, _SET_COLOR_MATERIAL, _EMISSIVE_MATERIAL, _DIFFUSE_VTX_COLOR) |
                                        DRF_DEF (097, _SET_COLOR_MATERIAL, _EMISSIVE_MATERIAL, _SPECULAR_VTX_COLOR))) {
            // emissive is being pulled from the vertex, and ambient is not
            dcvAmbient.dvR  = pContext->lighting.dcvAmbient.dvR * pContext->Material.dcvAmbient.dvR;
            dcvAmbient.dvG  = pContext->lighting.dcvAmbient.dvG * pContext->Material.dcvAmbient.dvG;
            dcvAmbient.dvB  = pContext->lighting.dcvAmbient.dvB * pContext->Material.dcvAmbient.dvB;
            dcvEmissive.dvR = 1.0;
            dcvEmissive.dvG = 1.0;
            dcvEmissive.dvB = 1.0;
        }
        else {
            // neither ambient nor emissive is being pulled from the vertex
            dcvAmbient.dvR  = (pContext->lighting.dcvAmbient.dvR * pContext->Material.dcvAmbient.dvR) + pContext->Material.dcvEmissive.dvR;
            dcvAmbient.dvG  = (pContext->lighting.dcvAmbient.dvG * pContext->Material.dcvAmbient.dvG) + pContext->Material.dcvEmissive.dvG;
            dcvAmbient.dvB  = (pContext->lighting.dcvAmbient.dvB * pContext->Material.dcvAmbient.dvB) + pContext->Material.dcvEmissive.dvB;
            dcvEmissive.dvR = 0.0;
            dcvEmissive.dvG = 0.0;
            dcvEmissive.dvB = 0.0;
        }

        pContext->hwState.kelvin.set3f (NV097_SET_SCENE_AMBIENT_COLOR(0), dcvAmbient.dvR,  dcvAmbient.dvG,  dcvAmbient.dvB);
        pContext->hwState.kelvin.set3f (NV097_SET_MATERIAL_EMISSION(0),   dcvEmissive.dvR, dcvEmissive.dvG, dcvEmissive.dvB);

        // pull material alpha from the diffuse component
        pContext->hwState.kelvin.set1f (NV097_SET_MATERIAL_ALPHA, pContext->Material.dcvDiffuse.dvA);
        //pContext->hwState.kelvin.set1f (NV097_SET_BACK_MATERIAL_ALPHA, pContext->Material.dcvDiffuse.dvA);

        // Set the eye position and direction
        eyeDirection = vectorZero;
        eyeDirection.dvZ = -1.0f;

        // Download transform and lighting methods. Pack lights and send them

        dwMask = 0;
        dwLightNum = 0;

        for (pLight=pContext->lighting.pActiveLights; pLight!=NULL; pLight=pLight->pNext) {

            if (dwLightNum == 8) break; // too many

            pLight7 = &(pLight->Light7);
            dbgDisplayLight (pLight7);

            switch (pLight7->dltType) {

                case D3DLIGHT_POINT:

                    dwMask |= NV097_SET_LIGHT_ENABLE_MASK_LIGHT0_LOCAL << (dwLightNum << 1);

                    nvKelvinDumpLightColors (pContext, dwLightNum, pLight7, dwColorMaterialArgs);
                    pContext->hwState.kelvin.set1f (NV097_SET_LIGHT_LOCAL_RANGE(dwLightNum), pLight7->dvRange);
                    nvKelvinDumpLocalLightData (pContext, dwLightNum, pLight7);

                    break;

                case D3DLIGHT_SPOT:

                    dwMask |= NV097_SET_LIGHT_ENABLE_MASK_LIGHT0_SPOT << (dwLightNum << 1);

                    nvKelvinDumpLightColors (pContext, dwLightNum, pLight7, dwColorMaterialArgs);
                    pContext->hwState.kelvin.set1f (NV097_SET_LIGHT_LOCAL_RANGE(dwLightNum), pLight7->dvRange);
                    nvKelvinDumpLocalLightData (pContext, dwLightNum, pLight7);

                    // Transform the spotlight direction vector back
                    XformBy4x3 (&dir, &(pLight->direction), 0.f, &(pContext->xfmView));
                    // unless the view matrix has non-uniform scales in it, this is not necessary
                    // For now, we take the easy way out though.
                    NormalizeVector3 (&dir);

                    ScaleVector3 (&dir, &dir, pLight->dvScale);
                    pContext->hwState.kelvin.set3f (NV097_SET_LIGHT_SPOT_FALLOFF(dwLightNum,0),
                                                    pLight->falloffParams.L,
                                                    pLight->falloffParams.M,
                                                    pLight->falloffParams.N);
                    pContext->hwState.kelvin.set4f (NV097_SET_LIGHT_SPOT_DIRECTION(dwLightNum,0),
                                                    dir.dvX, dir.dvY, dir.dvZ, pLight->dvW);

                    break;

                case D3DLIGHT_DIRECTIONAL:

                    dwMask |= NV097_SET_LIGHT_ENABLE_MASK_LIGHT0_INFINITE << (dwLightNum << 1);

                    nvKelvinDumpLightColors (pContext, dwLightNum, pLight7, dwColorMaterialArgs);
                    pContext->hwState.kelvin.set1f (NV097_SET_LIGHT_LOCAL_RANGE(dwLightNum), 1e30f);

                    // Transform the spotlight direction vector back
                    XformBy4x3 (&dir, &(pLight->direction), 0.f, &(pContext->xfmView));
                    // unless the view matrix has non-uniform scales in it, this is not necessary
                    // For now, we take the easy way out though.
                    NormalizeVector3 (&dir);

                    AddVectors3 (&hv, &dir, &eyeDirection);
                    NormalizeVector3 (&hv);
                    pContext->hwState.kelvin.set3f (NV097_SET_LIGHT_INFINITE_HALF_VECTOR(dwLightNum,0),
                                                    hv.dvX, hv.dvY, hv.dvZ);
                    pContext->hwState.kelvin.set3f (NV097_SET_LIGHT_INFINITE_DIRECTION(dwLightNum,0),
                                                    dir.dvX, dir.dvY, dir.dvZ);

                    break;

                default:

                    DPF ("unknown light type in nvSetKelvinLights");
                    dbgD3DError();
                    break;

            } // switch

            dwLightNum++;

        } // for all lights

        // Tell HW which lights are active
        pContext->hwState.kelvin.set1 (NV097_SET_LIGHT_ENABLE_MASK, dwMask);

    }

    if ((pContext->hwState.dwStateFlags & KELVIN_FLAG_LIGHTINGNEEDSINVMV) != dwInvMVNeeded) {
        pContext->hwState.dwStateFlags &= ~KELVIN_FLAG_LIGHTINGNEEDSINVMV;
        pContext->hwState.dwStateFlags |= dwInvMVNeeded;
        pContext->hwState.dwDirtyFlags |= dwInvMVNeeded ? KELVIN_DIRTY_TRANSFORM : 0;
    }

#ifdef KELVIN_ILC
    pContext->hwState.SuperTri.setNumLights(dwLightNum);
#endif

    // disable lights after setting them up (i.e minimum impact)
#ifdef NV_NULL_LIGHTS_DRIVER
    pContext->hwState.kelvin.set (NV097_SET_SPECULAR_ENABLE, DRF_NUM (097, _SET_SPECULAR_ENABLE, _V, FALSE));
    pContext->hwState.kelvin.set (NV097_SET_LIGHTING_ENABLE, NV097_SET_LIGHTING_ENABLE_V_FALSE);
#endif

    dbgFlushType (NVDBG_FLUSH_STATE);
    return (D3D_OK);
}

//---------------------------------------------------------------------------

// set geometric transformation matrices

HRESULT nvSetKelvinTransform (PNVD3DCONTEXT pContext)
{
    D3DMATRIX        mMV0, mMVBlend, mCTM, mInvMV, mTemp;
    DWORD            dwClipH, dwClipV;
    float            fm11, fm22, fm33, fm41, fm42, fm43, fm44;
    float            fxTrans, fyTrans;
    SurfaceViewport  viewport;

    pContext->hwState.dwDirtyFlags &= ~KELVIN_DIRTY_TRANSFORM;

    viewport = pContext->surfaceViewport;

    if (pContext->kelvinAA.IsEnabled()) {
        viewport.clipHorizontal.wX      = (DWORD)(0.5f + viewport.clipHorizontal.wX     * pContext->aa.fWidthAmplifier);
        viewport.clipHorizontal.wWidth  = (DWORD)(0.5f + viewport.clipHorizontal.wWidth * pContext->aa.fWidthAmplifier);
        viewport.clipVertical.wY        = (DWORD)(0.5f + viewport.clipVertical.wY       * pContext->aa.fHeightAmplifier);
        viewport.clipVertical.wHeight   = (DWORD)(0.5f + viewport.clipVertical.wHeight  * pContext->aa.fHeightAmplifier);
    }

    if (pContext->pCurrentVShader->hasProgram()) {

        fxTrans = (float)(viewport.clipHorizontal.wX) + KELVIN_BORDER;
        fyTrans = (float)(viewport.clipVertical.wY) + KELVIN_BORDER;

        fm11 = 0.5f * (float)(viewport.clipHorizontal.wWidth);
        fm41 = fm11;

        fm22 = -0.5f * (float)(viewport.clipVertical.wHeight);
        fm42 = -fm22;

        fm33 = pContext->hwState.dvZScale * (pContext->surfaceViewport.dvMaxZ - pContext->surfaceViewport.dvMinZ);
        fm43 = pContext->hwState.dvZScale * pContext->surfaceViewport.dvMinZ;

        // these end up in privileged registers c[58] and c[59], from which they are read by the
        // viewport transformation code automatically tacked onto the end of every user program
        pContext->hwState.kelvin.set4f (NV097_SET_VIEWPORT_SCALE(0), fm11, fm22, fm33, 0.0f);
        pContext->hwState.kelvin.set4f (NV097_SET_VIEWPORT_OFFSET(0), fm41 + fxTrans, fm42 + fyTrans, fm43, 0.0f);

        // set depth clipping
        pContext->hwState.kelvin.set2f (NV097_SET_CLIP_MIN, 0.0f, pContext->hwState.dvZScale);

    }

    else if (pContext->hwState.dwStateFlags & KELVIN_FLAG_PASSTHROUGHMODE) {

        // calculate scales and biases for passthru mode

        D3DVECTOR4 vScale = {1.0f, 1.0f, 1.0f, 1.0f};
        D3DVECTOR4 vBias  = {KELVIN_BORDER, KELVIN_BORDER, 0.0f, 0.0f};

        if (getDC()->nvD3DRegistryData.regfZBias) {
            vScale.dvZ = pContext->hwState.dvZScale / (1.f + getDC()->nvD3DRegistryData.regfZBias);
            vBias.dvZ  = getDC()->nvD3DRegistryData.regfZBias * vScale.dvZ;
        }
        else {
            vScale.dvZ = pContext->hwState.dvZScale;
        }

        // Because NV20 uses a weird sampling pattern, we offset by approximately a pixel here, then clamp on
        // the right edge of the superbuffer.  This fixes apps that clip their non-T&L geometry
        // to the border of the *aliased* samples on screen (not the antialiased subsamples).
        if (pContext->kelvinAA.IsMultisampling()) {
            vBias.dvX += pContext->kelvinAA.GetXOffset();
            vBias.dvY += pContext->kelvinAA.GetYOffset();
        }

        if ( ((getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_SQUASHW_MASK) == D3D_REG_SQUASHW_ENABLE)
             &&
             ( ((pContext->hwState.dwTextureUnitStatus[0] == KELVIN_TEXUNITSTATUS_IDLE) &&
                (pContext->hwState.dwTextureUnitStatus[1] == KELVIN_TEXUNITSTATUS_IDLE))
               ||
               (pContext->dwRenderState[D3DRENDERSTATE_TEXTUREPERSPECTIVE] == FALSE)
             )
           )
        {
            vScale.dvW = 0.0f;
        }
        else  {
            vScale.dvW = (pContext->dwRenderState[D3DRENDERSTATE_ZENABLE] == D3DZB_USEW) ?
                         pContext->surfaceViewport.dvInvWFar * pContext->hwState.dvZScale :
                         1.0f;
        }

        vScale.dvX *= pContext->aa.fWidthAmplifier;
        vScale.dvY *= pContext->aa.fHeightAmplifier;

        // these end up in privileged registers c[58] and c[59], from which they are read by the passthru-mode programs
        pContext->hwState.kelvin.set4f (NV097_SET_VIEWPORT_SCALE(0), vScale.dvX, vScale.dvY, vScale.dvZ, vScale.dvW);
        pContext->hwState.kelvin.set4f (NV097_SET_VIEWPORT_OFFSET(0), vBias.dvX, vBias.dvY, vBias.dvZ, vBias.dvW);

        // set depth clipping
        // if we're w-buffering in passthru mode, do the best we can to disable the HW's inevitable
        // z clipping because dumb apps may give us bad z's thinking they're unneeded.
        // otherwise, just clip z to the real range of the z-buffer
        // BUGBUG we can explicitly ignore z on nv20. no need for this hack
        pContext->hwState.kelvin.set2f (NV097_SET_CLIP_MIN, 0.0f, (pContext->dwRenderState[D3DRENDERSTATE_ZENABLE] == D3DZB_USEW) ?
                                                                  KELVIN_Z_SCALE24 :
                                                                  pContext->hwState.dvZScale);

    }

    else {

        float fMinZ = pContext->surfaceViewport.dvMinZ;
        float fMaxZ = pContext->surfaceViewport.dvMaxZ;

        if (fMinZ == fMaxZ) {
            // the whole universe has been packed down to a single plane.
            // this is an LSB nightmare, so back it off a bit.
            fMinZ = max (0.0f, fMinZ-EPSILON);
            fMaxZ = min (1.0f, fMaxZ+EPSILON);
        }

        // disable CT
        if (pContext->pZetaBuffer) {
            pContext->pZetaBuffer->getWrapper()->tagCTZE();
            pContext->pZetaBuffer->getWrapper()->disableCT();
        }

        // process viewport dependencies
        fxTrans = (float)(viewport.clipHorizontal.wX) + KELVIN_BORDER;
        fyTrans = (float)(viewport.clipVertical.wY) + KELVIN_BORDER;

        pContext->hwState.kelvin.set4f (NV097_SET_VIEWPORT_OFFSET(0), fxTrans, fyTrans, 0.0f, 0.0f);

        // this is based on clipX = -1.0, clipY = 1.0
        fm11 = 0.5f * (float)(viewport.clipHorizontal.wWidth);
        fm41 = fm11;

        fm22 = -0.5f * (float)(viewport.clipVertical.wHeight);
        fm42 = -fm22;

        fm33 = pContext->hwState.dvZScale * (fMaxZ - fMinZ);
        fm43 = pContext->hwState.dvZScale * fMinZ;

        if (pContext->dwRenderState[D3DRENDERSTATE_ZENABLE] == D3DZB_USEW) {
            // we are doing w-buffering  - scale w to optimize use of buffer
            fm44 = pContext->hwState.dvZScale * pContext->surfaceViewport.dvInvWFar;
            // scale x, y, and z similarly to negate the effect of dividing through by a scaled w
            fm11 *= fm44;  fm22 *= fm44;  fm33 *= fm44;
            fm41 *= fm44;  fm42 *= fm44;  fm43 *= fm44;
        }
        else {
            fm44 = 1.0f;
        }

#ifdef NV_NULL_FILL_DRIVER
        fm11 = 0.0f;
        fm22 = 0.0f;
#endif

        mViewportMatrix._11 = fm11;
        mViewportMatrix._22 = fm22;
        mViewportMatrix._33 = fm33;
        mViewportMatrix._41 = fm41;
        mViewportMatrix._42 = fm42;
        mViewportMatrix._43 = fm43;
        mViewportMatrix._44 = fm44;

        // set the 3 Cheops matrices

        // Cheops modelview = D3D world * D3D view
        MatrixProduct4x4 (&mMV0, &(pContext->xfmWorld[0]), &(pContext->xfmView));

        pContext->hwState.kelvin.setMatrixTransposed (NV097_SET_MODEL_VIEW_MATRIX0(0), &mMV0);

#ifdef KELVIN_ILC
        pContext->hwState.SuperTri.setEye(&mMV0);
#endif
        // Normals are transformed by the transpose of the inverse of the model view matrix.
        // (see Graphics Gems I, p. 541).
        // We only invert the upper 3x3 in order to eliminate the effects of translations.
        // the transposition happens because unlike all other matrices, we DON'T un-transpose
        // this one when we send it to the HW. (this is the one matrix for which D3D's
        // backwardness is convenient)

        if (pContext->hwState.dwStateFlags & (KELVIN_FLAG_TEXSTATENEEDSINVMV | KELVIN_FLAG_LIGHTINGNEEDSINVMV)) {
            // there's no reason to waste time normalizing the inverse MV matrix if we're going to have to normalize
            // normals anyway. otherwise, they give us normalized stuff and we need to preserve the normalization
            Inverse4x4 (&mInvMV, &mMV0, (pContext->dwRenderState[D3DRENDERSTATE_NORMALIZENORMALS] == FALSE));
            pContext->hwState.kelvin.setInverseModelViewMatrix (NV097_SET_INVERSE_MODEL_VIEW_MATRIX0(0), &mInvMV);
        }

        if (GET_VERTEXBLEND_STATE(pContext) == FALSE) {
            // we're not skinning.
            // compute the composite matrix normally and skip the second set of modelview matrices.
            // cheops composite = D3D World*View*projection plus accomodations for the viewport
            MatrixProduct4x4 (&mTemp, &(pContext->xfmProj), &mViewportMatrix);
            MatrixProduct4x4 (&mCTM, &mMV0, &mTemp);
            pContext->hwState.kelvin.setMatrixTransposed (NV097_SET_COMPOSITE_MATRIX(0), &mCTM);

            // for supertri we need world*view*proj
            if (pDriverData->nvD3DPerfData.dwPerformanceStrategy & PS_SUPERTRI) {
                MatrixProduct4x4 (&pContext->hwState.mTransform, &mMV0, &(pContext->xfmProj));
            }
        }

        else {
            // when skinning, the composite matrix does NOT include the modelview matrix.
            // cheops composite = projection plus accomodations for the viewport
            MatrixProduct4x4 (&mCTM, &(pContext->xfmProj), &mViewportMatrix);
            pContext->hwState.kelvin.setMatrixTransposed (NV097_SET_COMPOSITE_MATRIX(0), &mCTM);

            // we also need to compute and send down the second set of modelview matrices
            for (DWORD i=1; i<KELVIN_NUM_MATRICES; i++) {
                MatrixProduct4x4 (&mMVBlend, &(pContext->xfmWorld[i]), &(pContext->xfmView));
                pContext->hwState.kelvin.setMatrixTransposed (NV097_SET_MODEL_VIEW_MATRIX0(0) + 0x40*i, &mMVBlend);
                if (pContext->hwState.dwStateFlags & (KELVIN_FLAG_TEXSTATENEEDSINVMV | KELVIN_FLAG_LIGHTINGNEEDSINVMV)) {
                    Inverse4x4 (&mInvMV, &mMVBlend, (pContext->dwRenderState[D3DRENDERSTATE_NORMALIZENORMALS] == FALSE));
                    pContext->hwState.kelvin.setInverseModelViewMatrix (NV097_SET_INVERSE_MODEL_VIEW_MATRIX0(0) + 0x40*i, &mInvMV);
                }
            }
        }

        pContext->hwState.kelvin.set1 (NV097_SET_NORMALIZATION_ENABLE,
                                       DRF_NUM(097, _SET_NORMALIZATION_ENABLE, _V, pContext->dwRenderState[D3DRENDERSTATE_NORMALIZENORMALS]));

        // set depth clipping
        float fClipNear, fClipFar;
        if (pContext->dwRenderState[D3DRENDERSTATE_ZENABLE] == D3DZB_USEW) {
            fClipNear = pContext->hwState.dvZScale * pContext->surfaceViewport.dvWNear * pContext->surfaceViewport.dvInvWFar;
            fClipFar  = pContext->hwState.dvZScale;
        }
        else {
            fClipNear = pContext->hwState.dvZScale * fMinZ;
            fClipFar  = pContext->hwState.dvZScale * fMaxZ;
        }
        pContext->hwState.kelvin.set2f (NV097_SET_CLIP_MIN, fClipNear, fClipFar);

    }  // !FVF_TRANSFORMED

    // set window clipping
    // we subtract one from xmax (ymax) because the HW clips to xmin <= x <= xmax
    // ie. it's inclusive of both limits. note this makes it impossible to clip to nothing
    DWORD x,y,w,h;
    x = viewport.clipHorizontal.wX;
    w = viewport.clipHorizontal.wWidth;
    y = viewport.clipVertical.wY;
    h = viewport.clipVertical.wHeight;

    dwClipH = DRF_NUM (097, _SET_WINDOW_CLIP_HORIZONTAL, _XMIN, ((x - KELVIN_VIEWPORT_BOUND) & 0xfff))  |
              DRF_NUM (097, _SET_WINDOW_CLIP_HORIZONTAL, _XMAX, ((x + w - 1 - KELVIN_VIEWPORT_BOUND) & 0xfff));
    dwClipV = DRF_NUM (097, _SET_WINDOW_CLIP_VERTICAL, _YMIN, ((y - KELVIN_VIEWPORT_BOUND) & 0xfff))  |
              DRF_NUM (097, _SET_WINDOW_CLIP_VERTICAL, _YMAX, ((y + h - 1 - KELVIN_VIEWPORT_BOUND) & 0xfff));

    pContext->hwState.kelvin.set1 (NV097_SET_WINDOW_CLIP_HORIZONTAL(0), dwClipH);
    pContext->hwState.kelvin.set1 (NV097_SET_WINDOW_CLIP_VERTICAL(0),   dwClipV);

    dbgFlushType (NVDBG_FLUSH_STATE);
    return (D3D_OK);
}

//---------------------------------------------------------------------------

// This handles the SetControl0 method:
//      premultiplied alpha
//      texture perspective
//      z perspective
//      z format
//      stencil write enable

HRESULT nvSetKelvinControl0 (PNVD3DCONTEXT pContext)
{
    DWORD dwControl0;

    pContext->hwState.dwDirtyFlags &= ~KELVIN_DIRTY_CONTROL0;

    dwControl0 = DRF_DEF (097, _SET_CONTROL0, _COLOR_SPACE_CONVERT, _PASS);

    // SRWNOTE: D3D has the possibility of having pre-multiplied alpha in 1
    // texture stage and not in another stage. How do we handle this?
    // hmm... actually this seems to be specified on a per surface basis
    // hedge on this for now
// BUGBUG
#if 0
    if (statev.premultipliedalpha)
        dwControl0 |= DRF_DEF (097, _SET_CONTROL0, _PREMULTIPLIEDALPHA, _TRUE);
    else
        dwControl0 |= DRF_DEF (097, _SET_CONTROL0, _PREMULTIPLIEDALPHA, _FALSE);
#endif

    // disabling texture perspective kills color perspective as well. since
    // the latter is assumed by D3D, we must always enable the former.
    dwControl0 |= DRF_DEF (097, _SET_CONTROL0, _TEXTUREPERSPECTIVE, _TRUE);

    // w or z buffering
    dwControl0 |= DRF_NUM (097, _SET_CONTROL0, _Z_PERSPECTIVE_ENABLE,
                           (pContext->dwRenderState[D3DRENDERSTATE_ZENABLE] == D3DZB_USEW) ? 1:0);

    // D3D has no provision for specification of zbuffer format
    // somewhat arbitrarily choose FIXED. alternately we could select it
    // to their advantage according to whether w-buffering is enabled (?)
    dwControl0 |= DRF_DEF (097, _SET_CONTROL0, _Z_FORMAT, _FIXED);


    dwControl0 |= DRF_NUM (097, _SET_CONTROL0, _STENCIL_WRITE_ENABLE,
                           pContext->dwRenderState[D3DRENDERSTATE_STENCILENABLE]);

    pContext->hwState.kelvin.set1 (NV097_SET_CONTROL0, dwControl0);

    dbgFlushType (NVDBG_FLUSH_STATE);
    return (D3D_OK);
}

//---------------------------------------------------------------------------

// set everything else not covered by other kelvin state routines. this includes:
//      - depth testing
//      - stencil testing
//      - alpha testing
//      - alpha blending

HRESULT nvSetKelvinMiscState (PNVD3DCONTEXT pContext)
{
    DWORD dwHWStage, dwMask;
    DWORD dwSrcFactor, dwDstFactor;
    DWORD dwPointSize;
    DWORD dwZEnable;
    float fDepthBias, fDepthScale;
    float fAtten, fPP0, fPP1, fPP2, fPP3, fPP4, fPP5;  // point size variables
    float fSizeMin, fSizeMax, fSize, fHeight, fScale;

    pContext->hwState.dwDirtyFlags &= ~KELVIN_DIRTY_MISC_STATE;

    // z-buffering
    dwZEnable = pContext->pZetaBuffer ? pContext->dwRenderState[D3DRENDERSTATE_ZENABLE] : D3DZB_FALSE;
    if (dwZEnable) {
        pContext->hwState.kelvin.set1 (NV097_SET_DEPTH_TEST_ENABLE, NV097_SET_DEPTH_TEST_ENABLE_V_TRUE);
        pContext->hwState.kelvin.set1 (NV097_SET_DEPTH_MASK,        DRF_NUM (097, _SET_DEPTH_MASK, _V, pContext->dwRenderState[D3DRENDERSTATE_ZWRITEENABLE]));
        pContext->hwState.kelvin.set1 (NV097_SET_DEPTH_FUNC,        nv097DepthFunc[CTFunc(pContext,pContext->dwRenderState[D3DRENDERSTATE_ZFUNC])]);
    }
    else {
        pContext->hwState.kelvin.set1 (NV097_SET_DEPTH_TEST_ENABLE, NV097_SET_DEPTH_TEST_ENABLE_V_FALSE);
    }

    //if no zbuffer (that's true that enable is set to false...) and in passthrough mode, disable min/max z culling
    if ((dwZEnable == D3DZB_FALSE) && (pContext->hwState.dwStateFlags & KELVIN_FLAG_PASSTHROUGHMODE)) {
        pContext->hwState.kelvin.set1 (NV097_SET_ZMIN_MAX_CONTROL, (DRF_DEF (097, _SET_ZMIN_MAX_CONTROL, _CULL_NEAR_FAR_EN, _FALSE)
                                                                  | DRF_DEF (097, _SET_ZMIN_MAX_CONTROL, _ZCLAMP_EN, _CLAMP)
                                                                  | DRF_DEF (097, _SET_ZMIN_MAX_CONTROL, _CULL_IGNORE_W, _TRUE)));
    }
    else if (dwZEnable == D3DZB_USEW) {
        pContext->hwState.kelvin.set1 (NV097_SET_ZMIN_MAX_CONTROL, (DRF_DEF (097, _SET_ZMIN_MAX_CONTROL, _CULL_NEAR_FAR_EN, _FALSE)
                                                                  | DRF_DEF (097, _SET_ZMIN_MAX_CONTROL, _ZCLAMP_EN, _CULL)
                                                                  | DRF_DEF (097, _SET_ZMIN_MAX_CONTROL, _CULL_IGNORE_W, _FALSE)));
    }
    else {
        // if z-buffering and/or not passthrough
        pContext->hwState.kelvin.set1 (NV097_SET_ZMIN_MAX_CONTROL, (DRF_DEF (097, _SET_ZMIN_MAX_CONTROL, _CULL_NEAR_FAR_EN, _TRUE)
                                                                  | DRF_DEF (097, _SET_ZMIN_MAX_CONTROL, _ZCLAMP_EN, _CULL)
                                                                  | DRF_DEF (097, _SET_ZMIN_MAX_CONTROL, _CULL_IGNORE_W, _FALSE)));
    }

    // fill mode
    switch (pContext->dwRenderState[D3DRENDERSTATE_FILLMODE]) {
        case D3DFILL_POINT:
            pContext->hwState.kelvin.set2 (NV097_SET_FRONT_POLYGON_MODE,
                                           NV097_SET_FRONT_POLYGON_MODE_V_POINT,
                                           NV097_SET_BACK_POLYGON_MODE_V_POINT);
            break;
        case D3DFILL_WIREFRAME:
            pContext->hwState.kelvin.set2 (NV097_SET_FRONT_POLYGON_MODE,
                                           NV097_SET_FRONT_POLYGON_MODE_V_LINE,
                                           NV097_SET_BACK_POLYGON_MODE_V_LINE);
            break;
        case D3DFILL_SOLID:
            pContext->hwState.kelvin.set2 (NV097_SET_FRONT_POLYGON_MODE,
                                           NV097_SET_FRONT_POLYGON_MODE_V_FILL,
                                           NV097_SET_BACK_POLYGON_MODE_V_FILL);
            break;
        default:
            DPF ("unknown FILLMODE");
            dbgD3DError();
            break;
    }

    // shading
    pContext->hwState.kelvin.set1 (NV097_SET_SHADE_MODE, (pContext->dwRenderState[D3DRENDERSTATE_SHADEMODE] == D3DSHADE_FLAT)
                                                         ? NV097_SET_SHADE_MODE_V_FLAT
                                                         : NV097_SET_SHADE_MODE_V_SMOOTH);

    // color write enable
    DWORD dwPlaneMask = pContext->dwRenderState[D3DRS_COLORWRITEENABLE];
    if (dwPlaneMask == (D3DCOLORWRITEENABLE_ALPHA |
                        D3DCOLORWRITEENABLE_RED   |
                        D3DCOLORWRITEENABLE_GREEN |
                        D3DCOLORWRITEENABLE_BLUE)) {
        // the common case
        dwMask = 0x01010101;
    }
    else {
        dwMask = 0;
        if (dwPlaneMask & D3DCOLORWRITEENABLE_ALPHA) dwMask |= (0x1 << 24);
        if (dwPlaneMask & D3DCOLORWRITEENABLE_RED)   dwMask |= (0x1 << 16);
        if (dwPlaneMask & D3DCOLORWRITEENABLE_GREEN) dwMask |= (0x1 << 8);
        if (dwPlaneMask & D3DCOLORWRITEENABLE_BLUE)  dwMask |= (0x1 << 0);
    }

    pContext->hwState.kelvin.set1 (NV097_SET_COLOR_MASK, dwMask);

    // alpha blending
    if (pContext->dwRenderState[D3DRENDERSTATE_ALPHABLENDENABLE]) {
        pContext->hwState.kelvin.set1 (NV097_SET_BLEND_ENABLE, NV097_SET_BLEND_ENABLE_V_TRUE);
        dwSrcFactor = nv097BlendFunc[pContext->dwRenderState[D3DRENDERSTATE_SRCBLEND]];
        dwDstFactor = nv097BlendFunc[pContext->dwRenderState[D3DRENDERSTATE_DESTBLEND]];
        // for these two cases, we need to go back and override dwDstFactor
        switch (pContext->dwRenderState[D3DRENDERSTATE_SRCBLEND]) {
            case D3DBLEND_BOTHSRCALPHA:    // obsolete, but we'll do it for Dx5 and prior
                dwDstFactor = NV097_SET_BLEND_FUNC_DFACTOR_V_ONE_MINUS_SRC_ALPHA;
                break;
            case D3DBLEND_BOTHINVSRCALPHA: // likewise
                dwDstFactor = NV097_SET_BLEND_FUNC_DFACTOR_V_SRC_ALPHA;
                break;
            default:
                // nada
                break;
        }
        pContext->hwState.kelvin.set2 (NV097_SET_BLEND_FUNC_SFACTOR, dwSrcFactor, dwDstFactor);
        pContext->hwState.kelvin.set1 (NV097_SET_BLEND_EQUATION,
                                       (pContext->dwDXAppVersion >= 0x0800) ?
                                       nv097BlendOp[pContext->dwRenderState[D3DRS_BLENDOP]] :
                                       DRF_DEF (097, _SET_BLEND_EQUATION, _V, _FUNC_ADD));
    }
    else {
        pContext->hwState.kelvin.set1 (NV097_SET_BLEND_ENABLE, NV097_SET_BLEND_ENABLE_V_FALSE);
    }

    //anti aliased edges
    if (getDC()->nvD3DPerfData.dwHaveAALines){
        if (pContext->dwRenderState[D3DRENDERSTATE_EDGEANTIALIAS]){
            pContext->hwState.kelvin.set1(NV097_SET_LINE_SMOOTH_ENABLE, NV097_SET_LINE_SMOOTH_ENABLE_V_TRUE);
        }
        else {
            pContext->hwState.kelvin.set1(NV097_SET_LINE_SMOOTH_ENABLE, NV097_SET_LINE_SMOOTH_ENABLE_V_FALSE);
        }
    }

    // culling
    switch (pContext->dwRenderState[D3DRENDERSTATE_CULLMODE]) {
        case D3DCULL_CW:
            pContext->hwState.kelvin.set1 (NV097_SET_CULL_FACE_ENABLE, NV097_SET_CULL_FACE_ENABLE_V_TRUE);
            pContext->hwState.kelvin.set1 (NV097_SET_FRONT_FACE,       NV097_SET_FRONT_FACE_V_CCW);
            break;
        case D3DCULL_CCW:
            pContext->hwState.kelvin.set1 (NV097_SET_CULL_FACE_ENABLE, NV097_SET_CULL_FACE_ENABLE_V_TRUE);
            pContext->hwState.kelvin.set1 (NV097_SET_FRONT_FACE,       NV097_SET_FRONT_FACE_V_CW);
            break;
        default:
            DPF ("unknown cull mode");
        case D3DCULL_NONE:
            pContext->hwState.kelvin.set1 (NV097_SET_CULL_FACE_ENABLE, NV097_SET_CULL_FACE_ENABLE_V_FALSE);
            break;
    }

    // alpha test
    if (pContext->dwRenderState[D3DRENDERSTATE_ALPHATESTENABLE]) {
        pContext->hwState.kelvin.set1 (NV097_SET_ALPHA_TEST_ENABLE, NV097_SET_ALPHA_TEST_ENABLE_V_TRUE);
        pContext->hwState.kelvin.set1 (NV097_SET_ALPHA_REF,         pContext->dwRenderState[D3DRENDERSTATE_ALPHAREF]);
        pContext->hwState.kelvin.set1 (NV097_SET_ALPHA_FUNC,        nv097AlphaFunc[pContext->dwRenderState[D3DRENDERSTATE_ALPHAFUNC]]);
    }
    else {
        pContext->hwState.kelvin.set1 (NV097_SET_ALPHA_TEST_ENABLE, NV097_SET_ALPHA_TEST_ENABLE_V_FALSE);
    }
#ifdef ALPHA_CULL
    // alpha test
#if ALPHA_CULL ==0
    pContext->alphacull_mode = 0;
    if (!pContext->dwRenderState[D3DRENDERSTATE_ALPHATESTENABLE] && pContext->dwRenderState[D3DRENDERSTATE_ALPHABLENDENABLE] &&
        !pContext->dwRenderState[D3DRENDERSTATE_ZWRITEENABLE] && !pContext->dwRenderState[D3DRENDERSTATE_STENCILENABLE] &&
    pContext->dwEarlyCopyStrategy
       )
    {
#else
    pContext->hwState.alphacull_mode = 0;
    if (!pContext->dwRenderState[D3DRENDERSTATE_ALPHATESTENABLE] && pContext->dwRenderState[D3DRENDERSTATE_ALPHABLENDENABLE] &&
        /*!pContext->dwRenderState[D3DRENDERSTATE_ZWRITEENABLE] &&*/ !pContext->dwRenderState[D3DRENDERSTATE_STENCILENABLE]  &&
    pContext->dwEarlyCopyStrategy
       )
#endif
    {
        pContext->hwState.alphacull_mode = 1;
        if(pContext->dwRenderState[D3DRENDERSTATE_SRCBLEND] == D3DBLEND_SRCALPHA &&
           pContext->dwRenderState[D3DRENDERSTATE_DESTBLEND] == D3DBLEND_INVSRCALPHA){
                pContext->hwState.kelvin.set1 (NV097_SET_ALPHA_TEST_ENABLE, NV097_SET_ALPHA_TEST_ENABLE_V_TRUE);
                pContext->hwState.kelvin.set1 (NV097_SET_ALPHA_REF, 0x8);
                pContext->hwState.kelvin.set1 (NV097_SET_ALPHA_FUNC, NV097_SET_ALPHA_FUNC_V_GREATER);
        }
#if ALPHA_CULL >= 2
        /*else if(pContext->dwRenderState[D3DRENDERSTATE_SRCBLEND] == D3DBLEND_ZERO &&
           pContext->dwRenderState[D3DRENDERSTATE_DESTBLEND] == D3DBLEND_SRCCOLOR &&
           pContext->hwState.dwAlphaICW[0] == 0x18200000 && pContext->hwState.dwAlphaOCW[0] == 0xc00 &&
           pContext->hwState.dwColorICW[0] == 0x08040000 && pContext->hwState.dwColorOCW[0] == 0xc00)
        {
            pContext->hwState.celsius.alphacull_mode = 2;
            pContext->hwState.celsius.set (NV056_SET_COMBINER_COLOR_ICW(0), 0x08042820);
            pContext->hwState.celsius.set (NV056_SET_COMBINER0_COLOR_OCW,   0x000010CD);
            pContext->hwState.celsius.set (NV056_SET_COMBINER_ALPHA_ICW(0), 0x18200000);
            pContext->hwState.celsius.set (NV056_SET_COMBINER_ALPHA_OCW(0), 0x00000C00);
            pContext->hwState.celsius.set (NV056_SET_COMBINER_SPECULAR_FOG_CW0, pContext->hwState.specfog_cw[0]);
            pContext->hwState.celsius.set (NV056_SET_COMBINER_SPECULAR_FOG_CW1, 0x0D00 | (pContext->hwState.specfog_cw[1] & ~0x1f00));
            pContext->hwState.celsius.set (NV056_SET_ALPHA_TEST_ENABLE, NV056_SET_ALPHA_TEST_ENABLE_V_TRUE);
            pContext->hwState.celsius.set (NV056_SET_ALPHA_REF, 0x8);
            pContext->hwState.celsius.set (NV056_SET_ALPHA_FUNC, NV056_SET_ALPHA_FUNC_V_GREATER);
        }*/
#endif
#if ALPHA_CULL >= 3
        else if(pContext->dwRenderState[D3DRENDERSTATE_SRCBLEND] == D3DBLEND_ONE &&
           pContext->dwRenderState[D3DRENDERSTATE_DESTBLEND] == D3DBLEND_ONE &&
           pContext->hwState.dwColorICW[0] == 0x08040000 && pContext->hwState.dwColorOCW[0] == 0xc00 &&
           pContext->hwState.dwAlphaICW[0] == 0x18200000 && pContext->hwState.dwAlphaOCW[0] == 0xc00 &&
           pContext->dwEarlyCopyStrategy == 3)
        {
            pContext->hwState.alphacull_mode = 3;
            pContext->hwState.kelvin.set1 (NV097_SET_COMBINER_COLOR_ICW(0), 0x08040820);
            pContext->hwState.kelvin.set1 (NV097_SET_COMBINER_COLOR_OCW(0),   0x000010CD);
            pContext->hwState.kelvin.set1 (NV097_SET_COMBINER_ALPHA_ICW(0), 0x18200000);
            pContext->hwState.kelvin.set1 (NV097_SET_COMBINER_ALPHA_OCW(0), 0x00000C00);
            pContext->hwState.kelvin.set1 (NV097_SET_COMBINER_SPECULAR_FOG_CW0, pContext->hwState.specfog_cw[0]);
            pContext->hwState.kelvin.set1 (NV097_SET_COMBINER_SPECULAR_FOG_CW1, 0x0D00 | (pContext->hwState.specfog_cw[1] & ~0x1f00));
            pContext->hwState.kelvin.set1 (NV097_SET_ALPHA_TEST_ENABLE, NV097_SET_ALPHA_TEST_ENABLE_V_TRUE);
            pContext->hwState.kelvin.set1 (NV097_SET_ALPHA_REF, 0x8);
            pContext->hwState.kelvin.set1 (NV097_SET_ALPHA_FUNC, NV097_SET_ALPHA_FUNC_V_GREATER);
        }
#endif
        else if(pContext->dwRenderState[D3DRENDERSTATE_SRCBLEND] == D3DBLEND_INVSRCALPHA &&
                pContext->dwRenderState[D3DRENDERSTATE_DESTBLEND] == D3DBLEND_SRCALPHA){
                pContext->hwState.kelvin.set1 (NV097_SET_ALPHA_TEST_ENABLE, NV097_SET_ALPHA_TEST_ENABLE_V_TRUE);
                pContext->hwState.kelvin.set1 (NV097_SET_ALPHA_REF, 0xf4);
                pContext->hwState.kelvin.set1 (NV097_SET_ALPHA_FUNC, NV097_SET_ALPHA_FUNC_V_LESS);
        }
        else if(pContext->dwRenderState[D3DRENDERSTATE_SRCBLEND] == D3DBLEND_ZERO){
            if(pContext->dwRenderState[D3DRENDERSTATE_DESTBLEND] == D3DBLEND_SRCALPHA){
                pContext->hwState.kelvin.set1 (NV097_SET_ALPHA_TEST_ENABLE, NV097_SET_ALPHA_TEST_ENABLE_V_TRUE);
                pContext->hwState.kelvin.set1 (NV097_SET_ALPHA_REF, 0xf4);
                pContext->hwState.kelvin.set1 (NV097_SET_ALPHA_FUNC, NV097_SET_ALPHA_FUNC_V_LESS);
            }
            else if(pContext->dwRenderState[D3DRENDERSTATE_DESTBLEND] == D3DBLEND_INVSRCALPHA){
                pContext->hwState.kelvin.set1 (NV097_SET_ALPHA_TEST_ENABLE, NV097_SET_ALPHA_TEST_ENABLE_V_TRUE);
                pContext->hwState.kelvin.set1 (NV097_SET_ALPHA_REF, 0x8);
                pContext->hwState.kelvin.set1 (NV097_SET_ALPHA_FUNC, NV097_SET_ALPHA_FUNC_V_GREATER);
            }
        }
    }
#endif

    // dithering
    pContext->hwState.kelvin.set1 (NV097_SET_DITHER_ENABLE,
                                DRF_NUM (097, _SET_DITHER_ENABLE, _V, pContext->dwRenderState[D3DRENDERSTATE_DITHERENABLE]));

    // Multisample mask
    pContext->kelvinAA.SetSampleMask();

    // depth bias
    if ((dwZEnable) &&
        (pContext->dwRenderState[D3DRENDERSTATE_ZBIAS])) {
        // the bias is applied to depth values in device coordinates
        // (i.e in the range [0..2^16-1] or [0..2^24-1])
        pContext->hwState.kelvin.set3 (NV097_SET_POLY_OFFSET_POINT_ENABLE,
                                    NV097_SET_POLY_OFFSET_POINT_ENABLE_V_TRUE,
                                    NV097_SET_POLY_OFFSET_LINE_ENABLE_V_TRUE,
                                    NV097_SET_POLY_OFFSET_FILL_ENABLE_V_TRUE);
        fDepthBias  = -(float)(pContext->dwRenderState[D3DRENDERSTATE_ZBIAS]);
        fDepthScale = 0.25f * fDepthBias;
        pContext->hwState.kelvin.set2f (NV097_SET_POLYGON_OFFSET_SCALE_FACTOR, fDepthScale, fDepthBias);
    }
    else {
        // renderstate_zbias==0 and/or zenable==D3DZB_FALSE
        pContext->hwState.kelvin.set3 (NV097_SET_POLY_OFFSET_POINT_ENABLE,
                                       NV097_SET_POLY_OFFSET_POINT_ENABLE_V_FALSE,
                                       NV097_SET_POLY_OFFSET_LINE_ENABLE_V_FALSE,
                                       NV097_SET_POLY_OFFSET_FILL_ENABLE_V_FALSE);
    }

    // stencil
    if (pContext->dwRenderState[D3DRENDERSTATE_STENCILENABLE]) {
        pContext->bStencilEnabled = TRUE;
        pContext->hwState.kelvin.set1 (NV097_SET_STENCIL_TEST_ENABLE, NV097_SET_STENCIL_TEST_ENABLE_V_TRUE);
        pContext->hwState.kelvin.set7 (NV097_SET_STENCIL_MASK,
                                       pContext->dwRenderState[D3DRENDERSTATE_STENCILWRITEMASK] & 0xff,
                                       nv097StencilFunc[pContext->dwRenderState[D3DRENDERSTATE_STENCILFUNC]],
                                       pContext->dwRenderState[D3DRENDERSTATE_STENCILREF]       & 0xff,
                                       pContext->dwRenderState[D3DRENDERSTATE_STENCILMASK]      & 0xff,
                                       nv097StencilOp[pContext->dwRenderState[D3DRENDERSTATE_STENCILFAIL]],
                                       nv097StencilOp[pContext->dwRenderState[D3DRENDERSTATE_STENCILZFAIL]],
                                       nv097StencilOp[pContext->dwRenderState[D3DRENDERSTATE_STENCILPASS]]);
    }
    else {
        pContext->hwState.kelvin.set1 (NV097_SET_STENCIL_TEST_ENABLE, NV097_SET_STENCIL_TEST_ENABLE_V_FALSE);
    }

    // combiner factor
    if (!pContext->pCurrentPShader) {
        for (dwHWStage=0; dwHWStage<KELVIN_NUM_COMBINERS; dwHWStage++) {
            pContext->hwState.kelvin.set1 (NV097_SET_COMBINER_FACTOR0(dwHWStage), pContext->dwRenderState[D3DRENDERSTATE_TEXTUREFACTOR]);
            pContext->hwState.kelvin.set1 (NV097_SET_COMBINER_FACTOR1(dwHWStage), pContext->dwRenderState[D3DRENDERSTATE_TEXTUREFACTOR]);
        }
    }

    // skinning
    switch (GET_VERTEXBLEND_STATE(pContext)) {
        case D3DVBF_DISABLE:
            pContext->hwState.kelvin.set1 (NV097_SET_SKIN_MODE, NV097_SET_SKIN_MODE_V_OFF);
            break;
        case D3DVBF_1WEIGHTS:
            pContext->hwState.kelvin.set1 (NV097_SET_SKIN_MODE, NV097_SET_SKIN_MODE_V_2G);
            break;
        case D3DVBF_2WEIGHTS:
            pContext->hwState.kelvin.set1 (NV097_SET_SKIN_MODE, NV097_SET_SKIN_MODE_V_3G);
            break;
        case D3DVBF_3WEIGHTS:
            pContext->hwState.kelvin.set1 (NV097_SET_SKIN_MODE, NV097_SET_SKIN_MODE_V_4G);
            break;
        default:
            DPF ("illegal vertex blend mode");
            dbgD3DError();
            break;
    }  // switch

    // point params
    if (pContext->dwDXAppVersion >= 0x800) {

        // setting POINT_PARAMS_ENABLE to true tells the HW that a screen-space point size is being
        // calculated or needs to be calculated per vertex. in fixed-pipe mode, the HW will perform
        // the calculation itself, as a function of POINT_SIZE and POINT_PARAMS. in program mode, the
        // calculation is handled by some other entity (vertex shader / SW T&L) but POINT_PARAMS_ENABLE
        // is still set true so that the HW knows to fetch the pre-calculated point size from oPts.x.
        // when POINT_PARAMS_ENABLE is false, the HW simple takes the static value from POINT_SIZE
        // and performs no additional calculations.

        DWORD dwMode = pContext->pCurrentVShader->hasProgram() ?
                           1 :
                           ((pContext->hwState.dwStateFlags & KELVIN_FLAG_PASSTHROUGHMODE) ?
                               2 :
                               3);

        BOOL bHavePSize = pContext->pCurrentVShader->bVAExists (defaultInputRegMap[D3DVSDE_PSIZE]);
        BOOL bPScaleEn  = pContext->dwRenderState[D3DRS_POINTSCALEENABLE];

        // check for incompatibility with broken HW
        if ((dwMode == 3) && (bHavePSize)) {
            DPF ("uh oh. app wants to provide a point size per vertex in fixed-pipe mode.");
            dbgD3DError();
            pContext->hwState.dwStateFlags |= KELVIN_FLAG_SETUPFAILURE;
        }

        // enable point params if...
        BOOL bPPEnable = (dwMode == 1)                  ||  // ...we have a vertex shader
                         ((dwMode == 2) && bHavePSize)  ||  // ...we're in passthrough mode and have a per-vertex point size
                         ((dwMode == 3) && bPScaleEn);      // ...we're in fixed-pipe mode and D3DRS_POINTSCALEENABLE is true

        pContext->hwState.kelvin.set2 (NV097_SET_POINT_PARAMS_ENABLE,
                                       bPPEnable ?
                                       NV097_SET_POINT_PARAMS_ENABLE_V_TRUE :
                                       NV097_SET_POINT_PARAMS_ENABLE_V_FALSE,
                                       pContext->dwRenderState[D3DRS_POINTSPRITEENABLE] ?
                                       NV097_SET_POINT_SMOOTH_ENABLE_V_TRUE :
                                       NV097_SET_POINT_SMOOTH_ENABLE_V_FALSE);

        // we need to set POINT_SIZE if...
        if (((dwMode == 2) && (!bHavePSize)) ||  // ...we're in passthrough mode without a per-vertex point size
            (dwMode == 3))                       // ...we're in fixed-pipe mode
        {
            fSizeMin = FLOAT_FROM_DWORD (pContext->dwRenderState[D3DRS_POINTSIZE_MIN]);
            fSizeMax = FLOAT_FROM_DWORD (pContext->dwRenderState[D3DRS_POINTSIZE_MAX]);
            fSize    = FLOAT_FROM_DWORD (pContext->dwRenderState[D3DRS_POINTSIZE]);

            // workaround for NV20 bug where point sprites < 0.125 get bumped to 1.0
            if ((pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) == NVCLASS_0097_KELVIN) {
                // clamp POINTSIZE_MIN to >= 0.125
                fSizeMin = max (fSizeMin, 0.125f);
            }

            fScale   = max (fSize, 0.0001f);

            fSize    = max (fSize, fSizeMin);
            fSize    = min (fSize, fSizeMax);

            if ((pContext->surfaceViewport.clipVertical.wHeight) && (pContext->dwRenderState[D3DRS_POINTSCALEENABLE])) {
                fHeight = (float)(pContext->surfaceViewport.clipVertical.wHeight);
                // have to do this loop if we want to move height into the attenuation
                // factors because valid point sprite sizes < 0.125 will be expressed
                // as zeros if we don't do something  HMH
                while ((fSize < 32.0f) && (fHeight > 2.0f)) {
                    fSize   *= 2.0f;
                    fScale  *= 2.0f;
                    fHeight *= 0.5f;
                }
            }

            dwPointSize = ((DWORD)(fSize * 8.0f)) & 0x1ff;  // convert to 6.3

            pContext->hwState.kelvin.set1 (NV097_SET_POINT_SIZE, dwPointSize);

            // finally, we must also set POINT_PARAMS if we're in fixed pipe mode with POINTSCALEENABLE set true
            if ((dwMode == 3) && bPScaleEn) {

                fPP3 = fSizeMax - fSizeMin;
                fPP4 = fPP3 ? (-fSizeMin / fPP3) : 0.0f;
                fPP5 = fSizeMin;

                fAtten  = fPP3 / (fScale * fHeight);
                fAtten *= fAtten;

                fPP0 = fAtten * FLOAT_FROM_DWORD (pContext->dwRenderState[D3DRS_POINTSCALE_A]);
                fPP1 = fAtten * FLOAT_FROM_DWORD (pContext->dwRenderState[D3DRS_POINTSCALE_B]);
                fPP2 = fAtten * FLOAT_FROM_DWORD (pContext->dwRenderState[D3DRS_POINTSCALE_C]);

                pContext->hwState.kelvin.set8f (NV097_SET_POINT_PARAMS(0), fPP0,fPP1,fPP2,fPP3,fPP3,fPP3,fPP4,fPP5);

            }
        }
    }

    dbgFlushType (NVDBG_FLUSH_STATE);
    return (D3D_OK);
}

//---------------------------------------------------------------------------

__inline DWORD nvKelvinVertexFormat
(
    CVertexShader  *pShader,
    CVertexBuffer **ppStreams,
    DWORD           dwReg,
    BOOL            bInlineVertices,
    DWORD           dwInlineStride
)
{
    DWORD dwFormat, dwStreamSelector, dwType;

    dwStreamSelector = pShader->getVAStream (dwReg);

    if ((dwStreamSelector == CVertexShader::VA_STREAM_NONE) || (ppStreams[dwStreamSelector] == NULL)) {
        dwFormat = DRF_DEF (097, _SET_VERTEX_DATA_ARRAY_FORMAT, _SIZE, _DISABLED) |
                   DRF_DEF (097, _SET_VERTEX_DATA_ARRAY_FORMAT, _TYPE, _F);
    }
    else {
        dwType   = pShader->getVAType (dwReg);
        dwFormat = (DRF_NUM (097, _SET_VERTEX_DATA_ARRAY_FORMAT, _SIZE, kelvinVertexSize[dwType]) |
                    DRF_NUM (097, _SET_VERTEX_DATA_ARRAY_FORMAT, _TYPE, kelvinVertexType[dwType]) |
                    DRF_NUM (097, _SET_VERTEX_DATA_ARRAY_FORMAT, _STRIDE, bInlineVertices ?
                                                                          dwInlineStride  :
                                                                          ppStreams[dwStreamSelector]->getVertexStride()));
        if (dwType == D3DVSDT_UBYTE4) {
            DPF ("app is using unsupported D3DVSDT_UBYTE4 despite D3DVTXPCAPS_NO_VSDT_UBYTE4");
            nvAssert(0);
        }
    }

    return (dwFormat);
}

//---------------------------------------------------------------------------

__inline DWORD nvKelvinVertexOffset
(
    CVertexShader  *pShader,
    CVertexBuffer **ppStreams,
    DWORD           dwReg,
    DWORD           dwBaseVertexOffset
)
{
    DWORD dwOffset;
    DWORD dwStreamSelector;
    DWORD dwOffsetAdjustment;
    DWORD dwDMAMask, dwVBOffset;

    dwStreamSelector = pShader->getVAStream (dwReg);

    if ((dwStreamSelector == CVertexShader::VA_STREAM_NONE) || (ppStreams[dwStreamSelector] == NULL)) {

        dwOffset = DRF_DEF (097, _SET_VERTEX_DATA_ARRAY_OFFSET, _CONTEXT_DMA, _VERTEX_A) |
                   DRF_NUM (097, _SET_VERTEX_DATA_ARRAY_OFFSET, _OFFSET, 0);

    }

    else {

        // program the context dma and calculate a kelvin-specific offset adjustment:
        // kelvin wants an offset relative to a page aligned context dma, something
        // we do not know we have using the built in getOffset() methods.
        switch (ppStreams[dwStreamSelector]->getContextDMA()) {
            case NV_CONTEXT_DMA_AGP_OR_PCI:
                dwDMAMask = DRF_DEF (097, _SET_VERTEX_DATA_ARRAY_OFFSET, _CONTEXT_DMA, _VERTEX_A);
                // compensate for ctx dma that is possibly not 4k aligned
                dwOffsetAdjustment = (ppStreams[dwStreamSelector]->getHeapLocation() == CSimpleSurface::HEAP_AGP) ?
                                     (pDriverData->GARTLinearBase & 0xfff) :      // AGP
                                     (getDC()->nvD3DTexHeapData.dwBase & 0xfff);  // PCI
                break;
            case NV_CONTEXT_DMA_VID:
                dwDMAMask = DRF_DEF (097, _SET_VERTEX_DATA_ARRAY_OFFSET, _CONTEXT_DMA, _VERTEX_B);
                // NOTE - this is highly unlikely to not be 4k aligned...
                nvAssert ((pDriverData->BaseAddress & 0xfff) == 0);
                dwOffsetAdjustment = 0;
                break;
            default:
                DPF ("unknown context DMA");
                dbgD3DError();
                break;
        }  // switch

        dwVBOffset = ppStreams[dwStreamSelector]->getOffset() +
                     dwBaseVertexOffset +
                     pShader->getVAOffset (dwReg) +
                     dwOffsetAdjustment;

        dwOffset = dwDMAMask | DRF_NUM (097, _SET_VERTEX_DATA_ARRAY_OFFSET, _OFFSET, dwVBOffset);

    }

    return (dwOffset);
}

//---------------------------------------------------------------------------

// tell the hardware where to find vertex coordinates, normals, etc...
// the order of these is important!

HRESULT nvSetKelvinVertexFormat (PNVD3DCONTEXT pContext)
{
    DWORD  dwFormat[16], dwOffset[16];
    DWORD  dwHWStage, dwD3DStage, dwTCIndex, dwVAIndex;
    DWORD  dwInlineStride;
    BOOL   bInlineVertices;

    pContext->hwState.dwDirtyFlags &= ~KELVIN_DIRTY_FVF;

    CVertexShader  *pShader   = pContext->pCurrentVShader;
    CVertexBuffer **ppStreams = pContext->ppDX8Streams;

    // shadow the values so we know what we last sent to the HW
    pContext->hwState.dwVertexOffset = pContext->dp2.dwVertexBufferOffset;
    pContext->hwState.pVertexShader  = pContext->pCurrentVShader;
    nvMemCopy (pContext->hwState.ppStreams, pContext->ppDX8Streams, KELVIN_CAPS_MAX_STREAMS*sizeof(CVertexBuffer *));

#ifdef STOMP_TEX_COORDS
    pContext->hwState.dwStateFlags &= ~KELVIN_FLAG_STOMP_4TH_COORD_MASK;

    if (!pShader->hasProgram()) {
        for (dwHWStage=0; dwHWStage < KELVIN_NUM_TEXTURES; dwHWStage++) {
            if (pContext->hwState.dwStateFlags & KELVIN_FLAG_USERTEXCOORDSNEEDED(dwHWStage)) {
                dwTCIndex  = (pContext->hwState.dwTexCoordIndices >> (8*dwHWStage)) & 0xff;
                if ((pShader->getVASize(defaultInputRegMap[D3DVSDE_TEXCOORD0+dwTCIndex]) == 16) &&
                    (KELVIN_GET_NUM_TEX_COORDS(pContext->hwState.dwNumTexCoordsNeeded, dwHWStage) < 4)) {
                    pContext->hwState.dwStateFlags |= KELVIN_FLAG_STOMP_4TH_COORD(dwHWStage);
                }
            }
        }
    }

    // This should only happen in WHQL.  If it's happening elsewhere, either the app
    // is really stupid, or we're doing something wrong.
    nvAssert(!(pContext->hwState.dwStateFlags & KELVIN_FLAG_STOMP_4TH_COORD_MASK));
#endif  // STOMP_TEX_COORDS

    // figure out if we can dma this vertex data
#ifdef FORCE_INLINE_VERTICES
    bInlineVertices = TRUE;
#else
#ifdef STOMP_TEX_COORDS
    bInlineVertices = ((NV_NUM_UNIQUE_STREAMS(pContext->dwStreamDMACount) > 2) ||
                       (NV_NUM_SYSTEM_STREAMS(pContext->dwStreamDMACount) > 0) ||
                       (pContext->hwState.dwStateFlags & KELVIN_FLAG_STOMP_4TH_COORD_MASK));
#else  // !STOMP_TEX_COORDS
    bInlineVertices = ((NV_NUM_UNIQUE_STREAMS(pContext->dwStreamDMACount) > 2) ||
                       (NV_NUM_SYSTEM_STREAMS(pContext->dwStreamDMACount) > 0));
#endif  // !STOMP_TEX_COORDS
#endif

    if (bInlineVertices) {
        dwInlineStride = pShader->hasProgram() ?
                         pContext->pCurrentVShader->getStride() :
                         nvKelvinInlineVertexStride (pContext);
        nvAssert ( !(dwInlineStride == 4 && !pShader->hasProgram()) );
    }
    else {
        dwInlineStride = 0;
    }
    // set context inline stride
    pContext->hwState.dwInlineVertexStride = dwInlineStride; //don't want to lose the actual stride
    //workaround for kelvin bug
    if (dwInlineStride == 4) dwInlineStride = 8; //fake out vertex setup for HW failure case

    // formats --------------------------------------------------------------

    if (pShader->hasProgram()) {

        for (DWORD dwReg = 0; dwReg < 16; dwReg++) {
            dwFormat[dwReg] = nvKelvinVertexFormat (pShader, ppStreams, dwReg, bInlineVertices, dwInlineStride);
        }
    }

    else {

        // x, y, z, [w]
        dwFormat[0] = nvKelvinVertexFormat (pShader, ppStreams, defaultInputRegMap[D3DVSDE_POSITION], bInlineVertices, dwInlineStride);

        // weights (for skinning)
        dwFormat[1] = nvKelvinVertexFormat (pShader, ppStreams, defaultInputRegMap[D3DVSDE_BLENDWEIGHT], bInlineVertices, dwInlineStride);

        // normal
        dwFormat[2] = nvKelvinVertexFormat (pShader, ppStreams, defaultInputRegMap[D3DVSDE_NORMAL], bInlineVertices, dwInlineStride);

        // diffuse
        dwFormat[3] = nvKelvinVertexFormat (pShader, ppStreams, defaultInputRegMap[D3DVSDE_DIFFUSE], bInlineVertices, dwInlineStride);
        if (dwFormat[3] == (DRF_DEF (097, _SET_VERTEX_DATA_ARRAY_FORMAT, _SIZE, _DISABLED) |
                            DRF_DEF (097, _SET_VERTEX_DATA_ARRAY_FORMAT, _TYPE, _F))) {
            // no vertex diffuse. default to white
            pContext->hwState.kelvin.set1 (NV097_SET_DIFFUSE_COLOR4UB, 0xFFFFFFFF);
        }

        // specular
        dwFormat[4] = nvKelvinVertexFormat (pShader, ppStreams, defaultInputRegMap[D3DVSDE_SPECULAR], bInlineVertices, dwInlineStride);
        if (dwFormat[4] == (DRF_DEF (097, _SET_VERTEX_DATA_ARRAY_FORMAT, _SIZE, _DISABLED) |
                            DRF_DEF (097, _SET_VERTEX_DATA_ARRAY_FORMAT, _TYPE, _F))) {
            // no vertex specular. default to black
            pContext->hwState.kelvin.set1 (NV097_SET_SPECULAR_COLOR4UB, 0);
        }

        // fog distance (never exists in d3d)
        dwFormat[5] = DRF_DEF (097, _SET_VERTEX_DATA_ARRAY_FORMAT, _SIZE, _DISABLED) |
                      DRF_DEF (097, _SET_VERTEX_DATA_ARRAY_FORMAT, _TYPE, _F);

        // point size
        dwFormat[6] = nvKelvinVertexFormat (pShader, ppStreams, defaultInputRegMap[D3DVSDE_PSIZE], bInlineVertices, dwInlineStride);

        // back diffuse (DX8 was going to have this, but axed it)
        dwFormat[7] = DRF_DEF (097, _SET_VERTEX_DATA_ARRAY_FORMAT, _SIZE, _DISABLED) |
                      DRF_DEF (097, _SET_VERTEX_DATA_ARRAY_FORMAT, _TYPE, _F);

        // back specular (DX8 was going to have this, but axed it)
        dwFormat[8] = DRF_DEF (097, _SET_VERTEX_DATA_ARRAY_FORMAT, _SIZE, _DISABLED) |
                      DRF_DEF (097, _SET_VERTEX_DATA_ARRAY_FORMAT, _TYPE, _F);

        // texture 0-3
        for (dwHWStage=0; dwHWStage < KELVIN_NUM_TEXTURES; dwHWStage++) {
            if (pContext->hwState.dwStateFlags & KELVIN_FLAG_USERTEXCOORDSNEEDED(dwHWStage)) {
                // the app needs texture N and provided us with one
                dwD3DStage = pContext->hwState.dwTexUnitToTexStageMapping[dwHWStage];
                nvAssert (dwD3DStage != KELVIN_UNUSED);
                dwTCIndex  = (pContext->hwState.dwTexCoordIndices >> (8*dwHWStage)) & 0xff;
                dwVAIndex  = defaultInputRegMap[D3DVSDE_TEXCOORD0+dwTCIndex];
                nvAssert (pShader->bVAExists(dwVAIndex));  // they better have given us coordinates
                dwFormat[9+dwHWStage] = nvKelvinVertexFormat (pShader, ppStreams, dwVAIndex, bInlineVertices, dwInlineStride);
            }
            else {
                dwFormat[9+dwHWStage] = DRF_DEF (097, _SET_VERTEX_DATA_ARRAY_FORMAT, _SIZE, _DISABLED) |
                                        DRF_DEF (097, _SET_VERTEX_DATA_ARRAY_FORMAT, _TYPE, _F);
            }
        }  // for dwHWStage

        // remainder are unused
        dwFormat[13] = DRF_DEF (097, _SET_VERTEX_DATA_ARRAY_FORMAT, _SIZE, _DISABLED) |
                       DRF_DEF (097, _SET_VERTEX_DATA_ARRAY_FORMAT, _TYPE, _F);
        dwFormat[14] = DRF_DEF (097, _SET_VERTEX_DATA_ARRAY_FORMAT, _SIZE, _DISABLED) |
                       DRF_DEF (097, _SET_VERTEX_DATA_ARRAY_FORMAT, _TYPE, _F);
        dwFormat[15] = DRF_DEF (097, _SET_VERTEX_DATA_ARRAY_FORMAT, _SIZE, _DISABLED) |
                       DRF_DEF (097, _SET_VERTEX_DATA_ARRAY_FORMAT, _TYPE, _F);

    }

    //"fix" the format if it's only one DWORD and headed towards inline.
    //workaround for kelvin bug
    if (bInlineVertices && pContext->hwState.dwInlineVertexStride == 4)
    {
        if (dwFormat[0] == 2 ) //the one actual DWORD is somewhere else (not likely)
        {
            dwFormat[0]=0x825; //hardcode to 2 DWORD stride/ 2 Short value.
        }
        else //use register 1 for bogus info
        {
            dwFormat[1]=0x825; //hardcode to 2 DWORD stride/ 2 Short value.
        }
    }
    // send the formats to the HW
    pContext->hwState.kelvin.set8 (NV097_SET_VERTEX_DATA_ARRAY_FORMAT(0),
                                   dwFormat[0],  dwFormat[1],  dwFormat[2],  dwFormat[3],
                                   dwFormat[4],  dwFormat[5],  dwFormat[6],  dwFormat[7]);
    pContext->hwState.kelvin.set8 (NV097_SET_VERTEX_DATA_ARRAY_FORMAT(8),
                                   dwFormat[8],  dwFormat[9],  dwFormat[10], dwFormat[11],
                                   dwFormat[12], dwFormat[13], dwFormat[14], dwFormat[15]);

    // offsets --------------------------------------------------------------

    // we only need to send offsets if we're dma'ing vertex data
    if (!bInlineVertices) {

        // invalidate the vertex cache since we're messing with offsets
        pContext->hwState.kelvin.set1 (NV097_INVALIDATE_VERTEX_CACHE_FILE, 0);

        if (pShader->hasProgram()) {

            for (DWORD dwReg = 0; dwReg < 16; dwReg++) {
                dwOffset[dwReg] = nvKelvinVertexOffset (pShader, ppStreams, dwReg, pContext->hwState.dwVertexOffset);
            }

        }

        else {

            // x,y,z,[w]
            dwOffset[0] = nvKelvinVertexOffset (pShader, ppStreams, defaultInputRegMap[D3DVSDE_POSITION], pContext->hwState.dwVertexOffset);

            // weights
            dwOffset[1] = nvKelvinVertexOffset (pShader, ppStreams, defaultInputRegMap[D3DVSDE_BLENDWEIGHT], pContext->hwState.dwVertexOffset);

            // normal
            dwOffset[2] = nvKelvinVertexOffset (pShader, ppStreams, defaultInputRegMap[D3DVSDE_NORMAL], pContext->hwState.dwVertexOffset);

            // diffuse
            dwOffset[3] = nvKelvinVertexOffset (pShader, ppStreams, defaultInputRegMap[D3DVSDE_DIFFUSE], pContext->hwState.dwVertexOffset);

            // specular
            dwOffset[4] = nvKelvinVertexOffset (pShader, ppStreams, defaultInputRegMap[D3DVSDE_SPECULAR], pContext->hwState.dwVertexOffset);

            // fog distance
            dwOffset[5] = DRF_DEF (097, _SET_VERTEX_DATA_ARRAY_OFFSET, _CONTEXT_DMA, _VERTEX_A) |
                          DRF_NUM (097, _SET_VERTEX_DATA_ARRAY_OFFSET, _OFFSET, 0);

            // point size
            dwOffset[6] = nvKelvinVertexOffset (pShader, ppStreams, defaultInputRegMap[D3DVSDE_PSIZE], pContext->hwState.dwVertexOffset);

            // back diffuse
            dwOffset[7] = DRF_DEF (097, _SET_VERTEX_DATA_ARRAY_OFFSET, _CONTEXT_DMA, _VERTEX_A) |
                          DRF_NUM (097, _SET_VERTEX_DATA_ARRAY_OFFSET, _OFFSET, 0);

            // back specular
            dwOffset[8] = DRF_DEF (097, _SET_VERTEX_DATA_ARRAY_OFFSET, _CONTEXT_DMA, _VERTEX_A) |
                          DRF_NUM (097, _SET_VERTEX_DATA_ARRAY_OFFSET, _OFFSET, 0);

            // texture 0-3
            for (dwHWStage=0; dwHWStage < KELVIN_NUM_TEXTURES; dwHWStage++) {
                if (pContext->hwState.dwStateFlags & KELVIN_FLAG_USERTEXCOORDSNEEDED(dwHWStage)) {
                    // the app needs texture N and provided us with one
                    dwD3DStage = pContext->hwState.dwTexUnitToTexStageMapping[dwHWStage];
                    nvAssert (dwD3DStage != KELVIN_UNUSED);
                    dwTCIndex  = (pContext->hwState.dwTexCoordIndices >> (8*dwHWStage)) & 0xff;
                    dwVAIndex  = defaultInputRegMap[D3DVSDE_TEXCOORD0+dwTCIndex];
                    nvAssert (pShader->bVAExists(dwVAIndex));
                    dwOffset[9+dwHWStage] = nvKelvinVertexOffset (pShader, ppStreams, dwVAIndex,
                                                                  pContext->hwState.dwVertexOffset);
                }
                else {
                    dwOffset[9+dwHWStage] = DRF_DEF (097, _SET_VERTEX_DATA_ARRAY_OFFSET, _CONTEXT_DMA, _VERTEX_A) |
                                            DRF_NUM (097, _SET_VERTEX_DATA_ARRAY_OFFSET, _OFFSET, 0);
                }
            }  // for dwHWStage

            // remainder are unused
            dwOffset[13] = DRF_DEF (097, _SET_VERTEX_DATA_ARRAY_OFFSET, _CONTEXT_DMA, _VERTEX_A) |
                           DRF_NUM (097, _SET_VERTEX_DATA_ARRAY_OFFSET, _OFFSET, 0);
            dwOffset[14] = DRF_DEF (097, _SET_VERTEX_DATA_ARRAY_OFFSET, _CONTEXT_DMA, _VERTEX_A) |
                           DRF_NUM (097, _SET_VERTEX_DATA_ARRAY_OFFSET, _OFFSET, 0);
            dwOffset[15] = DRF_DEF (097, _SET_VERTEX_DATA_ARRAY_OFFSET, _CONTEXT_DMA, _VERTEX_A) |
                           DRF_NUM (097, _SET_VERTEX_DATA_ARRAY_OFFSET, _OFFSET, 0);

        }

        // send the offsets to the HW
        pContext->hwState.kelvin.set8 (NV097_SET_VERTEX_DATA_ARRAY_OFFSET(0),
                                       dwOffset[0],  dwOffset[1],  dwOffset[2],  dwOffset[3],
                                       dwOffset[4],  dwOffset[5],  dwOffset[6],  dwOffset[7]);
        pContext->hwState.kelvin.set8 (NV097_SET_VERTEX_DATA_ARRAY_OFFSET(8),
                                       dwOffset[8],  dwOffset[9],  dwOffset[10], dwOffset[11],
                                       dwOffset[12], dwOffset[13], dwOffset[14], dwOffset[15]);

    }  // !bInlineVertices

    dbgFlushType (NVDBG_FLUSH_STATE);
    return (D3D_OK);
}


#ifdef PROFILE_STATE_CHANGES
// Profile number of times a given state is changed. This is quick and dirty and will be improved.
static DWORD state_count[14] =
{
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};
#endif

//---------------------------------------------------------------------------

// set all state of the kelvin object

HRESULT __stdcall nvSetKelvinState (PNVD3DCONTEXT pContext)
{


#ifdef PROFILE_STATE_CHANGES
    state_count[13]++;
#endif

#ifdef NV_PROFILE_DP2OPS
    pDriverData->pBenchmark->beginHWStateChange(pContext->hwState.dwDirtyFlags, pDriverData->nvPusher.m_dwPut);
#endif

//    These calls have been moved/deferred from nvDrawPrimitives2 to nvSetKelvinState in order to avoid spurious upsampling in AA modes
//    where we have a simple Flip-SRT-Lock-UnLock-Flip loop.  The SRT as a consequence of the Flip was causing us
//    to do an unneeded upsample when no 3D rendering actually occurred.  Defer to SetKelvinState because it is only
//    called JUST before 3D rendering happens.
    pContext->kelvinAA.GrantAccess(CKelvinAAState::BUFFER_SRT, CKelvinAAState::ACCESS_WRITE);
    pContext->kelvinAA.GrantAccess(CKelvinAAState::BUFFER_SZB, CKelvinAAState::ACCESS_WRITE);

#ifdef NV_NULL_BLEND

    if (((pContext->hwState.dwDirtyFlags & KELVIN_DIRTY_MISC_STATE)) || (pContext->hwState.dwDirtyFlags & KELVIN_DIRTY_COMBINERS_COLOR) || (pContext->hwState.dwDirtyFlags & KELVIN_DIRTY_TEXTURE_STATE)) {

    pContext->dwRenderState[D3DRENDERSTATE_SRCBLEND]           = D3DBLEND_ONE;
    pContext->dwRenderState[D3DRENDERSTATE_DESTBLEND]          = D3DBLEND_ZERO;
    DWORD dwLODBias0 = nvTranslateLODBias (0);
    pContext->dwRenderState[D3DRENDERSTATE_ALPHAFUNC]          = D3DCMP_ALWAYS;
    pContext->dwRenderState[D3DRENDERSTATE_ALPHABLENDENABLE]   = FALSE;
    for (int i = 0; i < 8; i++) {
#ifdef NV_NULL_TEXTURES
        pContext->tssState[i].dwValue[D3DTSS_TEXTUREMAP]      = 0;
        pContext->tssState[i].dwValue[D3DTSS_ADDRESSU]        = D3DTADDRESS_WRAP;
        pContext->tssState[i].dwValue[D3DTSS_ADDRESSV]        = D3DTADDRESS_WRAP;
        pContext->tssState[i].dwValue[D3DTSS_MAGFILTER]       = D3DTFG_POINT;
        pContext->tssState[i].dwValue[D3DTSS_MINFILTER]       = D3DTFN_POINT;
        pContext->tssState[i].dwValue[D3DTSS_MIPFILTER]       = D3DTFP_POINT;
        pContext->tssState[i].dwValue[D3DTSS_COLOROP]         = D3DTOP_DISABLE;
        pContext->tssState[i].dwValue[D3DTSS_COLORARG1]       = D3DTA_TEXTURE;
        pContext->tssState[i].dwValue[D3DTSS_COLORARG2]       = D3DTA_CURRENT;
#endif
        pContext->tssState[i].dwValue[D3DTSS_ALPHAOP]         = D3DTOP_DISABLE;
        pContext->tssState[i].dwValue[D3DTSS_ALPHAARG1]       = D3DTA_TEXTURE;
        pContext->tssState[i].dwValue[D3DTSS_ALPHAARG2]       = D3DTA_CURRENT;
#ifdef NV_NULL_TEXTURES
        pContext->tssState[i].dwValue[D3DTSS_BUMPENVMAT00]    = 0;
        pContext->tssState[i].dwValue[D3DTSS_BUMPENVMAT01]    = 0;
        pContext->tssState[i].dwValue[D3DTSS_BUMPENVMAT10]    = 0;
        pContext->tssState[i].dwValue[D3DTSS_BUMPENVMAT11]    = 0;
        pContext->tssState[i].dwValue[D3DTSS_TEXCOORDINDEX]   = 0;
        pContext->tssState[i].dwValue[D3DTSS_BORDERCOLOR]     = 0x00000000;
        pContext->tssState[i].dwValue[D3DTSS_MIPMAPLODBIAS]   = 0;
        pContext->tssState[i].dwValue[D3DTSS_MAXMIPLEVEL]     = 0;
        pContext->tssState[i].dwValue[D3DTSS_MAXANISOTROPY]   = 1;
        pContext->tssState[i].dwValue[D3DTSS_BUMPENVLSCALE]   = 0;
        pContext->tssState[i].dwValue[D3DTSS_BUMPENVLOFFSET]  = 0;
        pContext->tssState[i].dwHandle                        = 0;
        pContext->tssState[i].dwLODBias                       = dwLODBias0;
#endif
    }
#ifdef NV_NULL_TEXTURES
    pContext->tssState[0].dwValue[D3DTSS_COLOROP] = D3DTOP_MODULATE;
    pContext->tssState[0].dwValue[D3DTSS_ALPHAOP] = D3DTOP_SELECTARG1;
    pContext->dwStageCount       = 1;
#endif
    }

#endif

    // clear the failure flag
    pContext->hwState.dwStateFlags &= ~KELVIN_FLAG_SETUPFAILURE;

    // if ddraw has sullied the kelvin object or if we last programmed
    // the kelvin object for a different context, start from scratch
    if ((pDriverData->dwMostRecentHWUser != MODULE_ID_D3D) ||
        (getDC()->dwLastHWContext        != (DWORD)pContext))
    {
        pDriverData->dwMostRecentHWUser = MODULE_ID_D3D;
        getDC()->dwLastHWContext        = (DWORD)pContext;
        pContext->hwState.dwDirtyFlags  = KELVIN_DIRTY_REALLY_FILTHY;
    }

    // apply out-of-context dirty flags
    // this was here because of aliasing to the celsius object.
    // lord willing we won't have the same problem with kelvin, but...
    //pContext->hwState.dwDirtyFlags |= pDriverData->dwOutOfContextKelvinDirtyFlags;
    //pDriverData->dwOutOfContextKelvinDirtyFlags = 0;

    pContext->hwState.dwDirtyFlags |= dbgForceHWRefresh;

    // mask out any non-kelvin bits
    pContext->hwState.dwDirtyFlags &= KELVIN_DIRTY_REALLY_FILTHY;

    // if nothing is dirty, just return
    if (!(pContext->hwState.dwDirtyFlags)) {
        return D3D_OK;
    }

#ifdef NV_PROFILE_CALLSTACK
    NVP_START (NVP_T_SETKELVINSTATE);
#endif

    // fundamental D3D stuff that doesn't normally change
    if (pContext->hwState.dwDirtyFlags & KELVIN_DIRTY_DEFAULTS) {
#ifdef PROFILE_STATE_CHANGES
        state_count[0]++;
#endif
        nvSetKelvinD3DDefaults (pContext);
    }

    if (pContext->hwState.dwDirtyFlags & KELVIN_DIRTY_SURFACE) {
#ifdef PROFILE_STATE_CHANGES
        state_count[1]++;
#endif
        nvSetKelvinSurfaceInfo (pContext);
    }

    // program the color combiners early since they determine the mapping
    // between hardware texture units and D3D texture stages, upon
    // which tons of other stuff depends.
    if (pContext->hwState.dwDirtyFlags & KELVIN_DIRTY_COMBINERS_COLOR) {
#ifdef PROFILE_STATE_CHANGES
        state_count[2]++;
#endif
        nvSetKelvinColorCombiners (pContext);
    }

    // If a pixel shader is enabled, use it to update the state
    if (pContext->hwState.dwDirtyFlags & KELVIN_DIRTY_PIXEL_SHADER) {
#ifdef PROFILE_STATE_CHANGES
        state_count[3]++;
#endif
        nvSetKelvinPixelShader (pContext);
    }

    // texture state
    if (pContext->hwState.dwDirtyFlags & KELVIN_DIRTY_TEXTURE_STATE) {
#ifdef PROFILE_STATE_CHANGES
        state_count[4]++;
#endif
        nvSetKelvinTextureState (pContext);
    }

    // fog / specular combiner
    if (pContext->hwState.dwDirtyFlags & KELVIN_DIRTY_COMBINERS_SPECFOG) {
#ifdef PROFILE_STATE_CHANGES
        state_count[5]++;
#endif
        nvSetKelvinSpecularFogCombiner (pContext);
    }

    // vertex shader
    if (pContext->hwState.dwDirtyFlags & KELVIN_DIRTY_VERTEX_SHADER) {
#ifdef PROFILE_STATE_CHANGES
        state_count[6]++;
#endif
        nvSetKelvinVertexShader (pContext);
    }

    // texture transform
    if (pContext->hwState.dwDirtyFlags & KELVIN_DIRTY_TEXTURE_TRANSFORM) {
#ifdef PROFILE_STATE_CHANGES
        state_count[7]++;
#endif
        nvSetKelvinTextureTransform (pContext);
    }

    // lighting
    if (pContext->hwState.dwDirtyFlags & KELVIN_DIRTY_LIGHTS) {
#ifdef PROFILE_STATE_CHANGES
        state_count[8]++;
#endif
        nvSetKelvinLights (pContext);
    }

    // transform
    if (pContext->hwState.dwDirtyFlags & KELVIN_DIRTY_TRANSFORM) {
#ifdef PROFILE_STATE_CHANGES
        state_count[9]++;
#endif
        nvSetKelvinTransform (pContext);
    }

    // control0
    if (pContext->hwState.dwDirtyFlags & KELVIN_DIRTY_CONTROL0) {
#ifdef PROFILE_STATE_CHANGES
        state_count[10]++;
#endif
        nvSetKelvinControl0 (pContext);
    }

    // remaining random stuff
    if (pContext->hwState.dwDirtyFlags & KELVIN_DIRTY_MISC_STATE) {
#ifdef PROFILE_STATE_CHANGES
        state_count[11]++;
#endif
        nvSetKelvinMiscState (pContext);
    }

    if (pContext->hwState.dwDirtyFlags & KELVIN_DIRTY_FVF) {
#ifdef PROFILE_STATE_CHANGES
        state_count[12]++;
#endif
        nvSetKelvinVertexFormat (pContext);
    }

#ifdef NV_PROFILE_CALLSTACK
    NVP_STOP(NVP_T_SETKELVINSTATE);
    nvpLogTime(NVP_T_SETKELVINSTATE,nvpTime[NVP_T_SETKELVINSTATE]);
#endif

    // make sure we're not dirty anymore. (this might happen if
    // there are interdepencies among the kelvin state routines
    // and the routines get called in the 'wrong' order)
    nvAssert (!(pContext->hwState.dwDirtyFlags));

#ifdef NV_PROFILE_DP2OPS
    pDriverData->pBenchmark->endHWStateChange(pDriverData->nvPusher.m_dwPut);
#endif

    return (D3D_OK);
}

//---------------------------------------------------------------------------

// set only the kelvin state required to clear

HRESULT __stdcall nvSetKelvinClearState (PNVD3DCONTEXT pContext)
{
    // if ddraw has sullied the kelvin object or if we last programmed
    // the kelvin object for a different context, start from scratch
    if ((pDriverData->dwMostRecentHWUser != MODULE_ID_D3D) ||
        (getDC()->dwLastHWContext        != (DWORD)pContext))
    {
        pDriverData->dwMostRecentHWUser = MODULE_ID_D3D;
        getDC()->dwLastHWContext        = (DWORD)pContext;
        pContext->hwState.dwDirtyFlags  = KELVIN_DIRTY_REALLY_FILTHY;
    }

    pContext->hwState.dwDirtyFlags |= dbgForceHWRefresh;

    // mask out any non-kelvin bits
    pContext->hwState.dwDirtyFlags &= KELVIN_DIRTY_REALLY_FILTHY;

#ifdef NV_PROFILE_CALLSTACK
    NVP_START (NVP_T_SETKELVINSTATE);
#endif

    // fundamental D3D stuff that doesn't normally change
    if (pContext->hwState.dwDirtyFlags & KELVIN_DIRTY_DEFAULTS) {
        nvSetKelvinD3DDefaults (pContext);
    }

    if (pContext->hwState.dwDirtyFlags & KELVIN_DIRTY_SURFACE) {
        nvSetKelvinSurfaceInfo (pContext);
    }

#ifdef NV_PROFILE_CALLSTACK
    NVP_STOP(NVP_T_SETKELVINSTATE);
    nvpLogTime(NVP_T_SETKELVINSTATE,nvpTime[NVP_T_SETKELVINSTATE]);
#endif

    return (D3D_OK);
}

#endif // (NVARCH >= 0x20)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\kelvin\src\nvKelvinInlPrim.cpp ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// ********************************* Direct 3D ******************************
//
//  Module: nvKelvinInlPrim.cpp
//      compiled inner loops for Kelvin inline primitives
//
// **************************************************************************
//
//  History:
//      Craig Duttweiler        10Aug2000         port from celsius
//
// **************************************************************************
#include "nvprecomp.h"

#if (NVARCH >= 0x20)

#include "x86.h"

#ifdef KELVIN_ILC
//////////////////////////////////////////////////////////////////////////////
// notes:
//
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// switches
//

//////////////////////////////////////////////////////////////////////////////
// aliases
//
#define ilcData         global.dwILCData
#define ilcCount        global.dwILCCount
#define ilcMax          global.dwILCMax

//////////////////////////////////////////////////////////////////////////////
// externals
//
void ILCCompile_mul                            (DWORD reg,DWORD num);
void nvKelvinILCompile_copyVertex              (PNVD3DCONTEXT pContext,DWORD dwFlags);
void nvKelvinILCompile_prefetch                (BOOL bIsIndexed,BOOL bLegacyStrides);
void nvKelvinILCompile_limit                   (DWORD regLimit,DWORD regDummy);

void __stdcall nvKelvinDispatchGetPusherSpace (void);

//---------------------------------------------------------------------------
DWORD nvKelvinILCompile_inline_prim
(
    PNVD3DCONTEXT pContext,
    DWORD         dwFlags
)
{
     //
    // get loop constants
    //
    DWORD  dwMagic                = kelvinPrimitiveToPrimitiveMagic[dwFlags & KELVIN_ILMASK_PRIMTYPE];
    DWORD  dwVerticesPerPrim      = (dwMagic >> 8) & 0xff;
    DWORD  dwStartVerticesPerPrim = (dwMagic >> 0) & 0xff;
    BOOL   bLegacyStrides         = dwFlags & KELVIN_ILFLAG_LEGACY;
    BOOL   bIsIndexed             = (dwFlags & KELVIN_ILMASK_LOOPTYPE) == KELVIN_ILFLAG_IX_INL_PRIM;

    //
    // align entry point
    //
    while (ilcCount & 31) { xINT3 }
    DWORD lEntry;
    xLABEL (lEntry);

    //
    // setup stack frame
    //
    xPUSH_r     (rEBP)
    xPUSH_r     (rEBX)
    xPUSH_r     (rESI)
    xPUSH_r     (rEDI)

    //
    // verify that we are using the correct inner loop - debug only
    //
#ifdef DEBUG
    DWORD ld1,ld2;
    xLABEL      (ld1)
    xJMP        (0)
    xLABEL      (ld2)
    xINT3

#define CHECK(a,x)                  \
{                                   \
    xMOV_rm_imm (rmREG(rEBX),a)     \
    xMOV_rm_imm (rmREG(rEAX),x)     \
    xCMP_r_i32  (rEAX,mMEM32(x))    \
    xJNZ32      (ld2)               \
}
#define CHECK2(a,x,y,t)             \
{                                   \
    xMOV_r_i32  (rEDX,mMEM32(global.kelvin.x))    \
    xMOV_rm_imm (rmREG(rEBX),a)     \
    xMOV_rm_imm (rmREG(rEAX),x->y)   \
    xCMP_r_rm   (rEAX,rmIND32(rEDX)) xOFS32(OFFSETOF(t,y)) \
    xJNZ32      (ld2)               \
}

    xTARGET_jmp (ld1)

/*
    CHECK (0x00000000,fvfData.dwVertexStride)

    CHECK (0x00010000,fvfData.dwVertexType)

    CHECK (0x00020000,fvfData.dwUVCount[0])
    CHECK (0x00020001,fvfData.dwUVCount[1])
    CHECK (0x00020002,fvfData.dwUVCount[2])
    CHECK (0x00020003,fvfData.dwUVCount[3])
    CHECK (0x00020004,fvfData.dwUVCount[4])
    CHECK (0x00020005,fvfData.dwUVCount[5])
    CHECK (0x00020006,fvfData.dwUVCount[6])
    CHECK (0x00020007,fvfData.dwUVCount[7])

    CHECK (0x00030000,fvfData.dwUVOffset[0])
    CHECK (0x00030001,fvfData.dwUVOffset[1])
    CHECK (0x00030002,fvfData.dwUVOffset[2])
    CHECK (0x00030003,fvfData.dwUVOffset[3])
    CHECK (0x00030004,fvfData.dwUVOffset[4])
    CHECK (0x00030005,fvfData.dwUVOffset[5])
    CHECK (0x00030006,fvfData.dwUVOffset[6])
    CHECK (0x00030007,fvfData.dwUVOffset[7])
*/

    //  - pContext->hwState.dwStateFlags & KELVIN_MASK_INNERLOOPUNIQUENESS
    xMOV_r_i32  (rEDX,mMEM32(global.kelvin.pContext))
    xMOV_rm_imm (rmREG(rEBX),0x00040000)
    xMOV_r_rm   (rEAX,rmIND32(rEDX)) xOFS32(OFFSETOF(NVD3DCONTEXT, hwState.dwStateFlags))
    xAND_rm_imm (rmREG(rEAX),KELVIN_MASK_INNERLOOPUNIQUENESS)
    xCMP_rm_imm (rmREG(rEAX),pContext->hwState.dwStateFlags & KELVIN_MASK_INNERLOOPUNIQUENESS)
    xJNZ32      (ld2)

    if (pContext->hwState.dwStateFlags & KELVIN_FLAG_USERTEXCOORDSNEEDED(0))
    {
        CHECK2 (0x00050000,pContext,hwState.dwTexUnitToTexStageMapping[0],NVD3DCONTEXT)
    }
    if (pContext->hwState.dwStateFlags & KELVIN_FLAG_USERTEXCOORDSNEEDED(1))
    {
        CHECK2 (0x00050001,pContext,hwState.dwTexUnitToTexStageMapping[1],NVD3DCONTEXT)
    }
#endif

#ifdef KELVIN_INLINE_REUSE
    if (bIsIndexed)
    {
        // clear the reuse history buffer
        xMOV_rm_imm     (rmREG(rECX), KELVIN_MAX_REUSE)
        xMOV_rm_imm     (rmREG(rEDI), mMEM32(global.kelvin.dwVertexReuse))
        DWORD lClearReuse;
        xLABEL          (lClearReuse);
        xMOV_rm_imm     (rmIND(rEDI), 0xffffffff);
        xADD_rm_imm8    (rmREG(rEDI), 0x4);
        xDEC_r          (rECX)
        xJNZ            (lClearReuse)

        xXOR_r_rm       (rEAX, rmREG(rEAX))
        xMOV_i32_r      (mMEM32(global.kelvin.dwCurrentHistoryIndex), rEAX)


    }

#endif KELVIN_INLINE_REUSE

//     if (pContext->hwState.pVertexShader->bVAExists(CVertexShader::PSIZE_ARRAY)) // do the point size
//     {
// #if 0 //USE_C_LOGIC
//         xMOV_rm_imm (rmREG(rEAX),dwFlags)
//             xPUSH_r (rEAX)
//             xMOV_rm_imm (rmREG(rEAX),nvCelsiusDumpTLPoints)
//             xCALL_rm (rmREG(rEAX))
//             xADD_rm_imm (rmREG(rESP),4);
// #else //USE_C_LOGIC
//         nvAssert(0);
// #endif
//     }
//     else
    {
    //
    // setup push buffer
    //
    xMOV_r_i32  (rEDX,mMEM32(pDriverData))
    xMOV_r_rm   (rEDI,rmIND32(rEDX)) xOFS32(OFFSETOF(CDriverContext,nvPusher.m_dwPut))

    //
    // calc how many verts to copy into EBX
    //
    xMOV_r_i32  (rEBX,mMEM32(global.kelvin.dwPrimCount))
    ILCCompile_mul (rEBX, dwVerticesPerPrim);
    if (dwStartVerticesPerPrim)
    {
        xADD_rm_imm (rmREG(rEBX),dwStartVerticesPerPrim)
    }

    //
    // setup prefetcher (EBX has # of vertices to copy in total)
    //
    if (bIsIndexed)
    {
        xMOV_r_i32  (rEAX,mMEM32(global.kelvin.pIndices))
         xLEA_r_rm   (rECX,rmSIB) xSIB(rEAX,rEBX,x2)
        xMOV_i32_r  (mMEM32(global.kelvin.dwPrefetchBase),rEAX)
         xMOV_i32_r  (mMEM32(global.kelvin.dwPrefetchMax),rECX)
        if (bLegacyStrides)
        {
            xMOV_r_i32  (rEAX,mMEM32(global.kelvin.pIndices))
            xMOV_i32_r  (mMEM32(global.kelvin.pIndexBase),rEAX)
        }
    }
    else
    {
        xMOV_r_i32  (rEAX,mMEM32(global.kelvin.pVertices))
         xMOV_r_rm   (rECX,rmREG(rEBX))
         ILCCompile_mul (rECX,global.kelvin.dwVertexStride);
         xADD_r_rm   (rECX,rmREG(rEAX))
        xMOV_i32_r  (mMEM32(global.kelvin.dwPrefetchBase),rEAX)
         xMOV_i32_r  (mMEM32(global.kelvin.dwPrefetchMax),rECX)
    }

    //
    // start primitive
    //
    xMOV_rm_imm (rmREG(rEAX),((sizeSetNv20KelvinBeginEndMthdCnt << 2) << 16) | ((NV_DD_KELVIN) << 13) | NV097_SET_BEGIN_END);
    xMOV_rm_imm (rmREG(rECX),kelvinBeginEndOp[dwFlags & KELVIN_ILMASK_PRIMTYPE])
    xMOV_rm_r   (rmIND(rEDI),rEAX)
    xMOV_rm_r   (rmIND8(rEDI),rECX) xOFS8(4)
    xLEA_r_rm   (rEDI,rmIND8(rEDI)) xOFS8(8)

#ifdef KELVIN_INLINE_REUSE
    DWORD           nextVertex;
#endif

    //
    // start copying
    //   for this loop EDI points to PUT and EBX has the amount of prims to go
    //
    DWORD labelLoop;
    xLABEL  (labelLoop)
    {
        xPUSH_r     (rEBX)

        //
        // prefetch
        //
        nvKelvinILCompile_prefetch (bIsIndexed, bLegacyStrides);

        //
        // copy vertex
        //
        if (bIsIndexed)
        {
            // get index
            xMOV_r_i32  (rEDX,mMEM32(global.kelvin.pIndices))
            xXOR_r_rm   (rESI,rmREG(rESI))
       x16r xMOV_r_rm   (rSI,rmIND(rEDX))
            xLEA_r_rm   (rEDX,rmIND8(rEDX)) xOFS8(2)
            if (bLegacyStrides)
            {
                xMOV_r_rm   (rEAX,rmREG(rEDX))
                xSUB_r_i32  (rEAX,mMEM32(global.kelvin.pIndexBase))
                xAND_rm_imm (rmREG(rEAX),6)
                xXOR_r_rm   (rECX,rmREG(rECX))
                xCMP_rm_imm (rmREG(rEAX),6)
                xSETNZ_rm8  (rmREG(rCL))
                xDEC_rm     (rmREG(rECX))
                xAND_rm_imm (rmREG(rECX),2)
                xADD_r_rm   (rEDX,rmREG(rECX))
            }
            xMOV_i32_r  (mMEM32(global.kelvin.pIndices),rEDX)

#ifdef KELVIN_INLINE_REUSE
            // ESI contains the vertex

            xMOV_r_i32      (rEAX, mMEM32(global.kelvin.dwCurrentHistoryIndex))
            xMOV_rm_imm     (rmREG(rECX), KELVIN_MAX_REUSE)
            xXOR_r_rm       (rEDX, rmREG(rEDX))

            DWORD ReuseLoop;
            xLABEL          (ReuseLoop)


            xCMP_r_rm       (rESI, rmSIB) xSIBID(rEAX,x4) xOFS32(mMEM32(global.kelvin.dwVertexReuse[0]))
            DWORD notFound;
            xLABEL          (notFound)
            xJNZ            (0)

            // output reused index
            xMOV_rm_imm     (rmREG(rEBX),( ( ((1) << 2) << 16) | ((NV_DD_KELVIN) << 13) | (NV097_INLINE_VERTEX_REUSE)))
            xMOV_rm_r       (rmIND(rEDI),rEBX)
            xMOV_rm_r       (rmIND8(rEDI),rEDX) xOFS8(4)
            xLEA_r_rm       (rEDI, rmIND8(rEDI)) xOFS8(8)

            xLABEL          (nextVertex)
            xJMP            (0)

            xTARGET_b8      (notFound)
            xINC_r          (rEDX)

            xDEC_r          (rEAX)
            xAND_rm_imm8    (rmREG(rEAX), KELVIN_REUSE_MASK)

            xDEC_r          (rECX)
            xJNZ            (ReuseLoop)

            // New index -- output it and update cached indices

            xMOV_r_i32      (rEAX, mMEM32(global.kelvin.dwCurrentHistoryIndex))
            xINC_r          (rEAX)
            xAND_rm_imm8    (rmREG(rEAX), KELVIN_REUSE_MASK)
            xMOV_i32_r      (mMEM32(global.kelvin.dwCurrentHistoryIndex), rEAX)
            xMOV_rm_r       (rmSIB, rESI) xSIBID(rEAX,x4) xOFS32(mMEM32(global.kelvin.dwVertexReuse[0]))


#endif // KELVIN_INLINE_REUSE

            // compute vertex offset
            ILCCompile_mul (rESI,global.kelvin.dwVertexStride);
            // range limit for NT
            nvKelvinILCompile_limit (rESI,rECX);

            // compute vertex address
            xADD_r_i32  (rESI,mMEM32(global.kelvin.pVertices))
        }
        else
        {
            // get vertex & increment
            xMOV_r_i32  (rESI,mMEM32(global.kelvin.pVertices))
            xLEA_r_rm   (rEAX,rmIND32(rESI)) xOFS32(global.kelvin.dwVertexStride)
            xMOV_i32_r  (mMEM32(global.kelvin.pVertices),rEAX)
        }

        // copy vertex (from ESI to EDI)
        nvKelvinILCompile_copyVertex (pContext,dwFlags);

        // update instumentation stats
#ifdef INSTRUMENT_INNER_LOOPS
        {
            xMOV_rm_imm (rmREG(rEAX),fvfData.dwVertexStride)
            xADD_i32_r  (mMEM32(global.dwBytesCopied),rEAX)
        }
#endif

#ifdef KELVIN_INLINE_REUSE
        if (bIsIndexed)
        {
            xTARGET_jmp     (nextVertex)
        }
#endif//KELVIN_INLINE_REUSE

        // check for pusher space
        DWORD labelSpace;
        xMOV_r_i32  (rESI,mMEM32(pDriverData))
        xCMP_r_rm   (rEDI,rmIND32(rESI)) xOFS32(OFFSETOF(CDriverContext,nvPusher.m_dwThreshold))
        xLABEL      (labelSpace)
        xJL         (0)
        {
            xMOV_rm_r   (rmIND32(rESI),rEDI) xOFS32(OFFSETOF(CDriverContext,nvPusher.m_dwPut))
            xMOV_rm_imm (rmREG(rEAX),(DWORD)nvKelvinDispatchGetPusherSpace)
            xCALL_rm    (rmREG(rEAX))
            xMOV_r_rm   (rEDI,rmIND32(rESI)) xOFS32(OFFSETOF(CDriverContext,nvPusher.m_dwPut))
        }
        xTARGET_b8  (labelSpace)

        // next
        xPOP_r  (rEBX)
        xDEC_rm (rmREG(rEBX))
    }
    xJNZ32  (labelLoop)

    //
    // end primitive
    //
    xMOV_rm_imm (rmREG(rEAX),((sizeSetNv20KelvinBeginEndMthdCnt << 2) << 16) | ((NV_DD_KELVIN) << 13) | NV097_SET_BEGIN_END);
    xMOV_rm_imm (rmREG(rECX),NV097_SET_BEGIN_END_OP_END)
    xMOV_rm_r   (rmIND(rEDI),rEAX)
    xMOV_rm_r   (rmIND8(rEDI),rECX) xOFS8(4)
    xLEA_r_rm   (rEDI,rmIND8(rEDI)) xOFS8(8)

    //
    // save off push buffer
    //
    xMOV_r_i32  (rEDX,mMEM32(pDriverData))
#ifndef NV_NULL_HW_DRIVER
    xMOV_rm_r   (rmIND32(rEDX),rEDI) xOFS32(OFFSETOF(CDriverContext,nvPusher.m_dwPut))
#endif
    }
    //
    // done
    //
    xPOP_r      (rEDI)
    xPOP_r      (rESI)
    xPOP_r      (rEBX)
    xPOP_r      (rEBP)
    xRET

    return lEntry;
}

#endif // KELVIN_ILC

#endif  // NVARCH == 0x20
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\kelvin\src\nvkelvinsupertri.cpp ===
// **************************************************************************
//
//       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// ********************************* Direct 3D ******************************
//
//  Module: nvKelvinSuperTri.cpp
//      Kelvin primitive rendering routines
//
// **************************************************************************
//
//  History:
//      Scott Kephart       06 Nov 00               Ported from Celsius
//
// **************************************************************************
#include "nvprecomp.h"

#if (NVARCH >= 0x20)

#include "x86.h"

#ifdef KELVIN_ILC
//////////////////////////////////////////////////////////////////////////////
// notes:
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// switches
//
//#define USE_C_LOGIC     // force c logic (easier to debug)

//////////////////////////////////////////////////////////////////////////////
// aliases
//
#define ilcData         global.dwILCData
#define ilcCount        global.dwILCCount
#define ilcMax          global.dwILCMax

#define KNIMEM(x)       ((((DWORD)&((*(KATMAI_STATE*)global.kni).x[0])) + 15) & ~15)

//////////////////////////////////////////////////////////////////////////////
// externals
//
void ILCCompile_mul                            (DWORD reg,DWORD num);
void nvKelvinILCompile_limit                 (DWORD regLimit,DWORD regDummy);

void __stdcall nvKelvinDispatchGetFreeSpace   (PNVD3DCONTEXT pContext);
void __stdcall nvKelvinDispatchGetPusherSpace (void);
#ifdef DEBUG
void __stdcall nvKelvinDispatchFlush          (void);
void __stdcall nvKelvinDispatchPrintVertex    (PNVD3DCONTEXT pContext,DWORD dwPutAddress);
#endif

/*****************************************************************************
 *****************************************************************************
 *** helpers *****************************************************************
 *****************************************************************************
 *****************************************************************************/


/*****************************************************************************
 *****************************************************************************
 *** super triangle lists *********ASSUMES KNI OR 3DNOW !*************
 *****************************************************************************
 *****************************************************************************/

DWORD nvKelvinILCompile_super_tri_list
(
    PNVD3DCONTEXT pContext,
    DWORD         dwFlags
)
{

#if 1

    if (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_3DNOW)
    {
//*****************************************************************************************************
//*****************************************************************************************************
//
//      AMD Athlon
//
//*****************************************************************************************************
//*****************************************************************************************************

        //
        // align entry point
        //
        while (ilcCount & 31)
        {
            xINT3
        }
        DWORD lEntry;
        xLABEL (lEntry);

        //
        // setup stack frame
        //
        xPUSH_r     (rEBP)
        xPUSH_r     (rEBX)
        xPUSH_r     (rESI)
        xPUSH_r     (rEDI)

    #ifdef USE_C_LOGIC
        xMOV_rm_imm (rmREG(rEAX),dwFlags)
        xPUSH_r (rEAX)
        xMOV_rm_imm (rmREG(rEAX),proto)
        xCALL_rm (rmREG(rEAX))
    #else //USE_C_LOGIC

        //
        // setup push buffer
        //
        xMOV_r_i32  (rEDX,mMEM32(pDriverData))
        xMOV_r_rm   (rEDI,rmIND32(rEDX)) xOFS32(OFFSETOF(CDriverContext, nvPusher.m_dwPut))

        //
        // align push buffer
        //
        {
            DWORD skip,again;
            xMOV_rm_imm  (rmREG(rEAX),(((0 << 2) << 16) | ((NV_DD_KELVIN) << 13) | NV097_NO_OPERATION))
            xLABEL       (again)
            xMOV_r_rm    (rEBX,rmREG(rEDI))
            xAND_rm_imm  (rmREG(rEBX),0xf)
            xCMP_rm_imm  (rmREG(rEBX),8)
            xLABEL       (skip)
            xJZ          (0)
            xMOV_rm_r    (rmIND(rEDI),rEAX)
            xLEA_r_rm    (rEDI,rmIND8(rEDI)) xOFS8(4)
            xJMP         (again)
            xTARGET_b8   (skip)
        }

//         if (!(dwFlags & KELVIN_ILFLAG_NOCLIP))
//         {
//         }
//         else
        {

           xFEMMS
            //
            // start primitive
            //
            xMOVQ_r_i64  (rMM0,mMEM64(global.kelvin.qwBegin))
            xMOVQ_rm_r (rmIND(rEDI),rMM0)
            xLEA_r_rm   (rEDI,rmIND8(rEDI)) xOFS8(8)

            //
            // setup
            //
            xMOV_r_i32  (rEAX,mMEM32(global.dwVertexSN))
            xADD_rm_imm (rmREG(rEAX),0x10000)
            xMOV_i32_r  (mMEM32(global.dwVertexSN),rEAX)

            xMOV_r_i32  (rESI,mMEM32(global.kelvin.pIndices))
            xMOV_r_i32  (rECX,mMEM32(global.kelvin.dwPrimCount))
            xLEA_r_rm   (rEAX,rmSIB) xSIB(rECX,rECX,x2)
            xMOV_i32_r  (mMEM32(global.kelvin.dwPrefetchBase),rESI)
            xLEA_r_rm   (rEAX,rmSIB) xSIB(rEAX,rEAX,x1)
            xMOV_i32_r  (mMEM32(global.kelvin.dwPrefetchMax),rEAX)

            //
            // process all triangles
            //
            DWORD again;
            xLABEL  (again)
            xPUSH_r (rECX)

            //
            DWORD cullCheck = 0;
            if (!(dwFlags & KELVIN_ILFLAG_NOCULL))
            {
                // eye point in model space

                xMOV_r_i32 (rEAX,mMEM32(global.kelvin.dwEyeAddr))
                xMOVQ_r_rm (rMM6,rmIND(rEAX)) 
                xMOVQ_r_rm (rMM7,rmIND8(rEAX)) xOFS8(8)
                // get index
                //clear EDX

                // Vertex 0
        #define STMC_PREF_DIST_AMD (0x40)
                xXOR_r_rm   (rEDX,rmREG(rEDX))

                xMOV_r_i32  (rESI,mMEM32(global.kelvin.pIndices))
                x16r xMOV_r_rm   (rDX,rmIND8(rESI)) xOFS8(0*2)
                xADD_r_i32       (rEDX, mMEM32(global.kelvin.dwBaseVertex))      //******** BV
                xMOV_i32_r  (KNIMEM(dwKelvinTriDispatch) + 4 + 0*4,rEDX)

                // compute vertex address into edx
                ILCCompile_mul (rEDX,pContext->hwState.SuperTri.getSTLBStride());
                xADD_r_i32     (rEDX,mMEM32(global.kelvin.pVertices))

                xMOV_r_rm   (rEAX, rmREG(rEDX))

                xMOVQ_r_rm  (rMM0, rmIND(rEDX))             //MM0 = V0.Y V0.X
                xMOVQ_r_rm  (rMM1, rmIND8(rEDX)) xOFS8(8)   //MM1 = xxxx V0.Z

                // Vertex 1
                xXOR_r_rm   (rEDX,rmREG(rEDX))

                x16r xMOV_r_rm   (rDX,rmIND8(rESI)) xOFS8(1*2)
                xADD_r_i32       (rEDX, mMEM32(global.kelvin.dwBaseVertex))      //******** BV
                xMOV_i32_r  (KNIMEM(dwKelvinTriDispatch) + 4 + 1*4,rEDX)

                // compute vertex address into edx
                ILCCompile_mul (rEDX,pContext->hwState.SuperTri.getSTLBStride());
                xADD_r_i32     (rEDX,mMEM32(global.kelvin.pVertices))

                xMOV_r_rm   (rEBX, rmREG(rEDX))
                xMOVQ_r_rm  (rMM2, rmIND(rEDX))             //MM2 = V1.Y V1.X
                xMOVQ_r_rm  (rMM3, rmIND8(rEDX)) xOFS8(8)   //MM3 = xxxx V1.Z

                xPFSUB_r_rm     (rMM6, rmREG(rMM0))     //mm6 & mm7 = eyevec
                xPFSUB_r_rm     (rMM7, rmREG(rMM1))

                // Vertex 2
                xXOR_r_rm   (rEDX,rmREG(rEDX))

                x16r xMOV_r_rm   (rDX,rmIND8(rESI)) xOFS8(2*2)
                xADD_r_i32       (rEDX, mMEM32(global.kelvin.dwBaseVertex))      //******** BV
                xMOV_i32_r  (KNIMEM(dwKelvinTriDispatch) + 4 + 2*4,rEDX)

                // compute vertex address into edx
                ILCCompile_mul (rEDX,pContext->hwState.SuperTri.getSTLBStride());
                xADD_r_i32      (rEDX,mMEM32(global.kelvin.pVertices))

                xPFSUB_r_rm     (rMM2, rmREG(rMM0))     //mm2 & mm3 = v1 - v0 = v10
                xPFSUB_r_rm     (rMM3, rmREG(rMM1))


                xMOV_r_rm   (rECX, rmREG(rEDX))
                xMOVQ_r_rm  (rMM4, rmIND(rEDX))             //MM4 = V2.Y V2.X
                xMOVQ_r_rm  (rMM5, rmIND8(rEDX)) xOFS8(8)   //MM5 = xxxx V2.Z

                // Compute eye vector
//                xCMP_r_rm   (rEBX, rmREG(rEAX))


                // Compute Normal

//                xCMOVA_r_rm (rEAX, rmREG(rEBX))
                xAND_rm_imm (rmREG(rEAX), ~0x3f)
                if (pContext->hwState.SuperTri.isFixedLBStride())
                {
                    xPREFETCH_rm8(0, rmIND8(rEAX), STMC_PREF_DIST_AMD)
                }
                else
                {
                    if ((4 * pContext->hwState.SuperTri.getSTLBStride()) < 128) {
                        xPREFETCH_rm8(0, rmIND8(rEAX), 4 * pContext->hwState.SuperTri.getSTLBStride())
                    }
                    else {
                        xADD_rm_imm(rmREG(rEAX), 4 * pContext->hwState.SuperTri.getSTLBStride())
                        xPREFETCH_rm8(0, rmIND8(rEAX), 0)
                    }
                }

                xPFSUB_r_rm     (rMM4, rmREG(rMM0))     //mm4 & mm5 = v2 - v0 = v20
                xPFSUB_r_rm     (rMM5, rmREG(rMM1))

                //      0.0 V10.X   V10.Z   V10.Y
                //    * 0.0 V20.y   V20.X   V20.Z
                //    -
                //      0.0 V10.Y   V10.X   V10.Z
                //    * 0.0 V20.X   V20.Z   V20.Y



                // MM2 = V10.Y V10.X
                // MM3 = xxxxx V10.Z
                // MM4 = V20.Y V20.X
                // MM5 = xxxxx V20.Z

                xPUNPCKLDQ_r_rm (rMM3, rmREG(rMM3))     //mm3 = V10.Z V10.Z
                xPUNPCKLDQ_r_rm (rMM5, rmREG(rMM5))     //mm5 = v20.z v20.z

//                xCMP_r_rm   (rECX, rmREG(rEAX))

                // MM2 = V10.Y V10.X
                // MM3 = v10.z V10.Z
                // MM4 = V20.Y V20.X
                // MM5 = v20.z V20.Z


                xMOVQ_r_rm      (rMM0, rmREG(rMM2))
                xMOVQ_r_rm      (rMM1, rmREG(rMM4))

//                xCMOVA_r_rm (rEAX, rmREG(rECX))
                xAND_rm_imm (rmREG(rEBX), ~0x3f)
                if (pContext->hwState.SuperTri.isFixedLBStride())
                {
                    xPREFETCH_rm8(0, rmIND8(rEBX), STMC_PREF_DIST_AMD)
                }
                else
                {
                    if ((4 * pContext->hwState.SuperTri.getSTLBStride()) < 128) {
                        xPREFETCH_rm8(0, rmIND8(rEBX), 4 * pContext->hwState.SuperTri.getSTLBStride())
                    }
                    else {
                        xADD_rm_imm(rmREG(rEBX), 4 * pContext->hwState.SuperTri.getSTLBStride())
                        xPREFETCH_rm8(0, rmIND8(rEBX), 0)
                    }
                }

                xPUNPCKHDQ_r_rm (rMM0, rmREG(rMM0))
                xPUNPCKHDQ_r_rm (rMM1, rmREG(rMM1))

//                xAND_rm_imm (rmREG(rEAX), ~0x3f)
                xAND_rm_imm (rmREG(rECX), ~0x3f)

                //MM0 = V10.Y V10.Y
                //MM1 = V20.Y V20.Y

                xPFMUL_r_rm     (rMM0, rmREG(rMM4)) //mm0 = xxxx V10.Y*V20.X
                xPFMUL_r_rm     (rMM1, rmREG(rMM2)) //mm1 = xxxx v20.Y*V10.X
                xPFSUB_r_rm     (rMM1, rmREG(rMM0)) //mm1 = xxxx Z'

                xPUNPCKLDQ_r_rm (rMM3, rmREG(rMM2)) //mm3 = v10.x v10.z
                xPUNPCKLDQ_r_rm (rMM5, rmREG(rMM4)) //mm5 = v20.x v20.z

                xPUNPCKHDQ_r_rm (rMM2, rmREG(rMM2)) //mm2 = v10.Y v10.Y
                xPUNPCKHDQ_r_rm (rMM4, rmREG(rMM4)) //mm4 = V20.Y V20.Y

                xPUNPCKLDQ_r_rm (rMM2, rmREG(rMM3)) //mm2 = V10.Z V10.Y
                xPUNPCKLDQ_r_rm (rMM4, rmREG(rMM5)) //mm4 = v20.z v20.y

                xPFMUL_r_rm     (rMM2, rmREG(rMM5))
                xPFMUL_r_rm     (rMM4, rmREG(rMM3))

                if (pContext->hwState.SuperTri.isFixedLBStride())
                {
                    xPREFETCH_rm8   (0, rmIND8(rECX), STMC_PREF_DIST_AMD)
                }
                else
                {
                    if ((4 * pContext->hwState.SuperTri.getSTLBStride()) < 128) {
                        xPREFETCH_rm8(0, rmIND8(rECX), 4 * pContext->hwState.SuperTri.getSTLBStride())
                    }
                    else {
                        xADD_rm_imm(rmREG(rECX), 4 * pContext->hwState.SuperTri.getSTLBStride())
                        xPREFETCH_rm8(0, rmIND8(rECX), 0)
                    }
                }

                xPFSUB_r_rm     (rMM2, rmREG(rMM4)) //mm2 = Y' X'

                // Dot normal and eye vector

                xPFMUL_r_rm     (rMM2, rmREG(rMM6))     //mm2 = Y' * eyevec.Y   X'*eyevec.X
                xPFMUL_r_rm     (rMM1, rmREG(rMM7))     //mm1 = xxxx            Z' * eyevec.Z
                xMOVQ_r_rm      (rMM0, rmREG(rMM2))     //mm0 = Y' * eyevec.Y   X'*eyevec.X
                xPUNPCKHDQ_r_rm (rMM0, rmREG(rMM0))     //mm0 = Y' * eyevec.Y   Y'*eyevec.Y
                xPFADD_r_rm     (rMM2, rmREG(rMM1))
                xPFADD_r_rm     (rMM2, rmREG(rMM0))

                xMOV_r_i32      (rEAX,mMEM32(global.kelvin.dwCullAddr))
                xMOV_r_rm       (rEBX,rmIND(rEAX)) 

                xMOVD_rm_r      (rmREG(rEAX), rMM2)
                xSHR_rm_imm8    (rmREG(rEAX), 31)

                xXOR_r_rm       (rEAX, rmREG(rEBX))
                xXOR_rm_imm     (rmREG(rEAX), 0x00000001)
                xTEST_rm_imm    (rmREG(rEAX), 0x00000001)


                //reads EBX,ECX,EDX

                xLABEL           (cullCheck)
                xJNZ32            (0)
            }
            else
            {
                xXOR_r_rm   (rEDX,rmREG(rEDX))

                xMOV_r_i32  (rESI,mMEM32(global.kelvin.pIndices))
                x16r xMOV_r_rm   (rDX,rmIND8(rESI)) xOFS8(0*2)
                xADD_r_i32       (rEDX, mMEM32(global.kelvin.dwBaseVertex))      //******** BV
                xMOV_i32_r  (KNIMEM(dwKelvinTriDispatch) + 4 + 0*4,rEDX)

                x16r xMOV_r_rm   (rDX,rmIND8(rESI)) xOFS8(1*2)
                xADD_r_i32       (rEDX, mMEM32(global.kelvin.dwBaseVertex))      //******** BV
                xMOV_i32_r  (KNIMEM(dwKelvinTriDispatch) + 4 + 1*4,rEDX)

                x16r xMOV_r_rm   (rDX,rmIND8(rESI)) xOFS8(2*2)
                xADD_r_i32       (rEDX, mMEM32(global.kelvin.dwBaseVertex))      //******** BV
                xMOV_i32_r  (KNIMEM(dwKelvinTriDispatch) + 4 + 2*4,rEDX)
            }

            //
            // dispatch
            //

            xMOVQ_r_i64(rMM1,KNIMEM(dwKelvinTriDispatch))
            xMOVQ_r_i64(rMM2,KNIMEM(dwKelvinTriDispatch)+8)
            xMOVNTQ_rm_r (rmIND(rEDI),rMM1)
            xMOVNTQ_rm_r (rmIND8(rEDI),rMM2) xOFS8(8)
            xLEA_r_rm      (rEDI,rmIND8(rEDI)) xOFS8(16)

            //
            // send more triangles after this one, utilizing connectivity statistics
            //
    #if 1
            if (!pContext->hwState.SuperTri.isCheckAll() || (dwFlags & KELVIN_ILFLAG_NOCULL))
            {
                const int count = 4; // do not exceed 128 words (about 14 of these)
                DWORD sendMore;
                xPOP_r      (rECX)
                xCMP_rm_imm (rmREG(rECX),count)
                xLABEL      (sendMore)
                xJLE32      (0)

                xMOV_r_i32  (rESI,mMEM32(global.kelvin.pIndices))
                for (int i = 0; i < count; i++)
                {
                    // prep tri
                    xLEA_r_rm   (rESI,rmIND8(rESI)) xOFS8(6)
                    xXOR_r_rm   (rEBX,rmREG(rEBX))
                    xMOV_r_rm   (rEAX,rmIND(rESI))
                    x16r xMOV_r_rm   (rBX,rmIND8(rESI)) xOFS8(4)
                    xADD_r_i32       (rEBX, mMEM32(global.kelvin.dwBaseVertex))      //******** BV
                    xMOV_r_rm   (rEDX,rmREG(rEAX))
                    xAND_rm_imm (rmREG(rEAX),0xffff)
                    xADD_r_i32       (rEAX, mMEM32(global.kelvin.dwBaseVertex))      //******** BV
                    xMOV_i32_r  (KNIMEM(dwKelvinTriDispatch) + 12,rEBX)
                    xSHR_rm_imm8(rmREG(rEDX),16)
                    xADD_r_i32       (rEDX, mMEM32(global.kelvin.dwBaseVertex))      //******** BV
                    xMOV_i32_r  (KNIMEM(dwKelvinTriDispatch) + 4,rEAX)
                    xMOV_i32_r  (KNIMEM(dwKelvinTriDispatch) + 8,rEDX)

                    // dispatch
                    xMOVQ_r_i64 (rMM0,KNIMEM(dwKelvinTriDispatch))
                    xMOVQ_r_i64 (rMM1,KNIMEM(dwKelvinTriDispatch)+8)
                    xMOVNTQ_rm_r   (rmIND(rEDI),rXMM0)
                    xMOVNTQ_rm_r   (rmIND8(rEDI),rXMM1) xOFS8(8)
                    xLEA_r_rm      (rEDI,rmIND8(rEDI)) xOFS8(16)

                }
                xSUB_rm_imm (rmREG(rECX),count)
                xMOV_i32_r  (mMEM32(global.kelvin.pIndices),rESI)
                xTARGET_b32 (sendMore)
                xPUSH_r     (rECX)
            }
    #endif
            // check for pusher space
            DWORD labelSpace;
            xMOV_r_i32  (rESI,mMEM32(pDriverData))
            xCMP_r_rm   (rEDI,rmIND32(rESI)) xOFS32(OFFSETOF(CDriverContext, nvPusher.m_dwThreshold))
            xLABEL      (labelSpace)
            xJL         (0)
            {
                xMOV_rm_imm (rmREG(rEBX),(DWORD)nvKelvinDispatchGetPusherSpace)
                xMOV_rm_r   (rmIND32(rESI),rEDI) xOFS32(OFFSETOF(CDriverContext, nvPusher.m_dwPut))
                xCALL_rm    (rmREG(rEBX))
                xMOV_r_rm   (rEDI,rmIND32(rESI)) xOFS32(OFFSETOF(CDriverContext, nvPusher.m_dwPut))
            }
            xTARGET_b8  (labelSpace)

            //
            // next triangle
            //
            if (cullCheck)
            { xTARGET_b32 (cullCheck)
            }
            xMOV_r_i32  (rESI,mMEM32(global.kelvin.pIndices))
            xPOP_r      (rECX)
            xLEA_r_rm   (rESI,rmIND8(rESI)) xOFS8(6)
            xDEC_rm     (rmREG(rECX))
            xMOV_i32_r  (mMEM32(global.kelvin.pIndices),rESI)
            xJNZ32      (again)

            //
            // end primitive
            //
            xMOVQ_r_i64  (rMM0,mMEM64(global.kelvin.qwEnd))
            xMOVNTQ_rm_r (rmIND(rEDI),rMM0)
            xLEA_r_rm   (rEDI,rmIND8(rEDI)) xOFS8(8)
            xFEMMS


        }//#endif // ~INVERSE_XFORM_CULL

        //
        // save off push buffer
        //
        xMOV_r_i32  (rEDX,mMEM32(pDriverData))
    #ifndef NV_NULL_HW_DRIVER
        xMOV_rm_r   (rmIND32(rEDX),rEDI) xOFS32(OFFSETOF(CDriverContext, nvPusher.m_dwPut))
    #endif

    #endif // USE_C_LOGIC
        //
        // clean up caching strategy
        //
        //     xMOV_r_i32  (rEAX,mMEM32(pDriverData))
        //     xMOV_rm_imm (rmREG(rEBX),rzSetAGPMTRR)
        //     xPUSH_imm   (1)
        //     xPUSH_rm    (rmIND32(rEAX)) xOFS32(OFFSETOF(GLOBALDATA, GARTPhysicalBase))
        //     xCALL_rm    (rmREG(rEBX))

        //
        // done
        //
        xPOP_r      (rEDI)
        xPOP_r      (rESI)
        xPOP_r      (rEBX)
        xPOP_r      (rEBP)
        xRET
        return lEntry;

    }

    else
    {

//*****************************************************************************************************
//*****************************************************************************************************
//
//      Intel SSE & SSE2
//
//*****************************************************************************************************
//*****************************************************************************************************


        //
        // align entry point
        //
        while (ilcCount & 31)
        {
            xINT3
        }
        DWORD lEntry;
        xLABEL (lEntry);

        //
        // setup stack frame
        //
        xPUSH_r     (rEBP)
        xPUSH_r     (rEBX)
        xPUSH_r     (rESI)
        xPUSH_r     (rEDI)

    #ifdef USE_C_LOGIC
        xMOV_rm_imm (rmREG(rEAX),dwFlags)
        xPUSH_r (rEAX)
        xMOV_rm_imm (rmREG(rEAX),proto)
        xCALL_rm (rmREG(rEAX))
    #else //USE_C_LOGIC

        //
        // setup push buffer
        //
        xMOV_r_i32  (rEDX,mMEM32(pDriverData))
        xMOV_r_rm   (rEDI,rmIND32(rEDX)) xOFS32(OFFSETOF(CDriverContext, nvPusher.m_dwPut))

        //
        // align push buffer
        //
        {
            DWORD skip,again;
            xMOV_rm_imm  (rmREG(rEAX),(((0 << 2) << 16) | ((NV_DD_KELVIN) << 13) | NV097_NO_OPERATION))
            xLABEL       (again)
            xMOV_r_rm    (rEBX,rmREG(rEDI))
#ifndef SW_WC
            xAND_rm_imm  (rmREG(rEBX),0xf)
            xCMP_rm_imm  (rmREG(rEBX),8)
#else
            xAND_rm_imm  (rmREG(rEBX),0x3f)
            xCMP_rm_imm  (rmREG(rEBX),0x38)
#endif
            xLABEL       (skip)
            xJZ          (0)
            xMOV_rm_r    (rmIND(rEDI),rEAX)
            xLEA_r_rm    (rEDI,rmIND8(rEDI)) xOFS8(4)
            xJMP         (again)
            xTARGET_b8   (skip)
        }

        //
        // setup caching strategy
        //
        //     xMOV_r_i32  (rEAX,mMEM32(pDriverData))
        //     xMOV_rm_imm (rmREG(rEBX),rzSetAGPMTRR)
        //     xPUSH_imm   (4)
        //     xPUSH_rm    (rmIND32(rEAX)) xOFS32(OFFSETOF(GLOBALDATA, GARTPhysicalBase))
        //     xCALL_rm    (rmREG(rEBX))
        if (pContext->hwState.SuperTri.isXFormCull())
        {


            //
            // load KNI matrix
            //
            if ((pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_KATMAI))
            {
                xMOV_r_i32   (rEAX,mMEM32(global.kelvin.pContext_kelvinState))
                xMOVLPS_r_rm (rXMM4,rmIND32(rEAX)) xOFS32(OFFSETOF(CHardwareState, mTransform._11))
                xMOVHPS_r_rm (rXMM4,rmIND32(rEAX)) xOFS32(OFFSETOF(CHardwareState, mTransform._13))
                xMOVLPS_r_rm (rXMM5,rmIND32(rEAX)) xOFS32(OFFSETOF(CHardwareState, mTransform._21))
                xMOVHPS_r_rm (rXMM5,rmIND32(rEAX)) xOFS32(OFFSETOF(CHardwareState, mTransform._23))
                xMOVLPS_r_rm (rXMM6,rmIND32(rEAX)) xOFS32(OFFSETOF(CHardwareState, mTransform._31))
                xMOVHPS_r_rm (rXMM6,rmIND32(rEAX)) xOFS32(OFFSETOF(CHardwareState, mTransform._33))
                xMOVLPS_r_rm (rXMM7,rmIND32(rEAX)) xOFS32(OFFSETOF(CHardwareState, mTransform._41))
                xMOVHPS_r_rm (rXMM7,rmIND32(rEAX)) xOFS32(OFFSETOF(CHardwareState, mTransform._43))
            }



            //
            // start primitive
            //
            xMOVQ_r_i64  (rMM0,mMEM64(global.kelvin.qwBegin))
            xMOVNTQ_rm_r (rmIND(rEDI),rMM0)
            xLEA_r_rm   (rEDI,rmIND8(rEDI)) xOFS8(8)
            xEMMS


            //
            // setup
            //
            xMOV_r_i32  (rEAX,mMEM32(global.dwVertexSN))
            xADD_rm_imm (rmREG(rEAX),0x10000)
            xMOV_i32_r  (mMEM32(global.dwVertexSN),rEAX)

            xMOV_r_i32  (rESI,mMEM32(global.kelvin.pIndices))
            xMOV_r_i32  (rECX,mMEM32(global.kelvin.dwPrimCount))
            xLEA_r_rm   (rEAX,rmSIB) xSIB(rECX,rECX,x2)
            xMOV_i32_r  (mMEM32(global.kelvin.dwPrefetchBase),rESI)
            xLEA_r_rm   (rEAX,rmSIB) xSIB(rEAX,rEAX,x1)
            xMOV_i32_r  (mMEM32(global.kelvin.dwPrefetchMax),rEAX)
            xXOR_r_rm   (rEAX, rmREG(rEAX))
            xMOV_i32_r  (mMEM32(global.kelvin.dwPrefMaxIdx), rEAX)

            //
            // process all triangles
            //
            {
                DWORD again;
                xLABEL  (again)
                xPUSH_r (rECX)

                //
                // prefetch HERE

                xMOV_r_i32  (rESI,mMEM32(global.kelvin.pIndices))

                const DWORD dist = 3;
                DWORD noPrefetch;
                xCMP_rm_imm     (rmREG(rECX), dist)
                xLABEL      (noPrefetch)
                xJBE32      (0)


                xMOV_r_i32  (rEAX,mMEM32(global.kelvin.dwPrefMaxIdx))
                xXOR_r_rm   (rEDX,rmREG(rEDX))
                for (int i = 0; i < 3; i++)
                {
                    x16r xMOV_r_rm   (rDX,rmIND8(rESI)) xOFS8(((dist*3)+i)*2)
                    xADD_r_i32       (rEDX, mMEM32(global.kelvin.dwBaseVertex))     //******** BV
                    if (!pContext->hwState.SuperTri.isFixedLBStride())
                        xAND_rm_imm (rmREG(rEDX), ~1)
                        DWORD noPre1=0;
                    xCMP_r_rm   (rEDX, rmREG(rEAX))
                    xLABEL      (noPre1)
                    xJBE        (0)

                    xMOV_r_rm   (rEAX, rmREG(rEDX))
                    xMOV_r_rm   (rEBX, rmREG(rEDX))
                    ILCCompile_mul (rEDX, pContext->hwState.SuperTri.getSTLBStride());
                    xADD_r_i32     (rEBX,mMEM32(global.kelvin.pVertices))
                    xPREFETCH_rm8(1, rmIND8(rEBX), 0)
                    xTARGET_b8 (noPre1)
                }

                xMOV_i32_r  (mMEM32(global.kelvin.dwPrefMaxIdx), rEAX)
                xTARGET_b32 (noPrefetch)

                //
                // do transform, outcode and w-divide calculations. use cached verts if possible
                //
                for (i = 0; i < 3; i++)
                {
                    // get index
                    //clear EDX
                    xXOR_r_rm   (rEDX,rmREG(rEDX))
                    xMOV_r_i32  (rESI,mMEM32(global.kelvin.pIndices))
                    x16r xMOV_r_rm   (rDX,rmIND8(rESI)) xOFS8(i*2)
                    xADD_r_i32       (rEDX, mMEM32(global.kelvin.dwBaseVertex))      //******** BV
                    // compute cache index (save edx)
                    xMOV_r_rm   (rEAX,rmREG(rEDX))
                    xMOV_i32_r  (KNIMEM(dwKelvinTriDispatch) + 4 + i*4,rEDX)
                    xAND_rm_imm (rmREG(rEAX),VB_CACHE_SIZE - 1)
                    // arbitration (save eax,edx)
                    DWORD arb;
                    xLABEL      (arb)
                    switch (i)
                    {
                    case 1:
                        {
                            DWORD skip;

                            xCMP_r_i32  (rEAX,mMEM32(global.dwIndex0))
                            xLABEL      (skip)
                            xJNZ        (0)
                            xADD_rm_imm (rmREG(rEAX),3)
                            xAND_rm_imm (rmREG(rEAX),VB_CACHE_SIZE - 1)
                            xJMP        (arb)

                            xTARGET_b8  (skip)
                            break;
                        }
                    case 2:
                        {
                            DWORD skip1,skip2;

                            xCMP_r_i32  (rEAX,mMEM32(global.dwIndex0))
                            xLABEL      (skip1)
                            xJNZ        (0)
                            xADD_rm_imm (rmREG(rEAX),3)
                            xAND_rm_imm (rmREG(rEAX),VB_CACHE_SIZE - 1)
                            xJMP        (arb)

                            xTARGET_b8  (skip1)
                            xCMP_r_i32  (rEAX,mMEM32(global.dwIndex1))
                            xLABEL      (skip2)
                            xJNZ        (0)
                            xADD_rm_imm (rmREG(rEAX),3)
                            xAND_rm_imm (rmREG(rEAX),VB_CACHE_SIZE - 1)
                            xJMP        (arb)

                            xTARGET_b8  (skip2)
                            break;
                        }
                    }
                    xMOV_i32_r  (mMEM32(global.dwIndex0) + i*4,rEAX)
                    // compute TL vertex address (save eax,edx)
                    xMOV_r_rm   (rEBX,rmREG(rEAX))
                    xMOV_r_rm   (rECX,rmREG(rEDX))
                    ILCCompile_mul (rEBX,sizeof(KATMAI_STATE::TLVERTEX));
                    xADD_rm_imm (rmREG(rEBX),KNIMEM(adwTLVertexCache))
                    xOR_r_i32   (rECX,mMEM32(global.dwVertexSN))
                    xMOV_i32_r  (mMEM32(global.dwVertex0) + i*4,rEBX)
                    // test cache (save eax,ecx,edx)
                    DWORD cacheHit;
                    xCMP_r_rm   (rECX,rmSIB) xSIBID(rEAX,x4) xOFS32(mMEM32(global.dwVertexCacheIndex))
                    xLABEL      (cacheHit)
                    xJZ32       (0)

                    //
                    // cache miss
                    //

                    // occupy cache entry (save edx)
                    xMOV_rm_r (rmSIB,rECX) xSIBID(rEAX,x4) xOFS32(mMEM32(global.dwVertexCacheIndex))

                    // compute vertex address into edx
                    ILCCompile_mul (rEDX,pContext->hwState.SuperTri.getSTLBStride());
                    xADD_r_i32     (rEDX,mMEM32(global.kelvin.pVertices))


                    //
                    // transform vertex and apply min/max info
                    //

                    xMOV_r_i32       (rECX,mMEM32(global.dwVertex0) + i*4)

                    ///katmai
                    if ((pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_KATMAI))
                    {



                        //0: 0 0 0 X
                        xMOVSS_r_rm      (rXMM0,rmIND(rEDX))
                        //1: 0 0 0 Y
                        xMOVSS_r_rm      (rXMM1,rmIND8(rEDX)) xOFS8(4)
                        //0: X X X X
                        xSHUFPS_r_rm_imm (rXMM0,rmREG(rXMM0),0)
                        //1: Y Y Y Y
                        xSHUFPS_r_rm_imm (rXMM1,rmREG(rXMM1),0)
                        //2: 0 0 0 Z
                        xMOVSS_r_rm      (rXMM2,rmIND8(rEDX)) xOFS8(8)
                        //0: 3X 2X 1X 0X
                        xMULPS_r_rm      (rXMM0,rmREG(rXMM4))
                        //2: Z Z Z Z
                        xSHUFPS_r_rm_imm (rXMM2,rmREG(rXMM2),0)
                        //1: 7y 6y 5y 4y
                        xMULPS_r_rm      (rXMM1,rmREG(rXMM5))
                        //2:11Z 10Z 9Z 8Z
                        xMULPS_r_rm      (rXMM2,rmREG(rXMM6))
                        //0: 0+1
                        xADDPS_r_rm      (rXMM0,rmREG(rXMM1))
                        //0: 0+2
                        xADDPS_r_rm      (rXMM0,rmREG(rXMM2))
                        //0: 0+7 (15 14 13 12)
                        xADDPS_r_rm (rXMM0,rmREG(rXMM7))
                        //store xformed WZYX -> XYZW
                        xMOVAPS_rm_r     (rmIND(rECX),rXMM0)

                        //!!!!stores to ECX

                        //deadbeef
                        // start w-divide (save ecx)
                        ///load wxyz into xmm1
                        xMOVAPS_r_rm     (rXMM1,rmREG(rXMM0))
                        /// spread W over xmm0
                        xSHUFPS_r_rm_imm (rXMM0,rmREG(rXMM0),0xff)
                        /// xmm1 -> w/w z/w y/w x/w
                        //                   xDIVPS_r_rm      (rXMM1,rmREG(rXMM0))
                        //                 Replace the DIVPS with approximation 1/w rcpps with 1 Newton-Raphson iteration
                        //                 This is faster on all cpu's, and is accurate to within 2 bits of precision of divps
                        // Compute 1/w
                        xRCPPS_r_rm      (rXMM2, rmREG(rXMM0))
                        xMULPS_r_rm      (rXMM0, rmREG(rXMM2))
                        xMULPS_r_rm      (rXMM0, rmREG(rXMM2))
                        xADDPS_r_rm      (rXMM2, rmREG(rXMM2))
                        xSUBPS_r_rm      (rXMM2, rmREG(rXMM0))
                        // Multiply w z y x by 1/w 1/w 1/w 1/w
                        xMULPS_r_rm      (rXMM1, rmREG(rXMM2))

                    }
                    /*
                    else
                    {
                    ///3dnow

                    //xFEMMS
                    xEMMS

                    //load EBX with matrix start
                    xMOV_r_i32   (rEBX,mMEM32(global.kelvin.pContext_celsiusState))

                    xMOV_r_i32   (rEAX,mMEM32(global.celsius.dwTouchedMin))
                    //MOVQ MM0, [EDX]
                    xMOVQ_r_rm  (rMM0,rmIND(rEDX));
                    //MOVQ MM1, [EDX+8]
                    xMOVQ_r_rm  (rMM1,rmIND8(rEDX)); xOFS8(8)

                    //MOVQ MM2, MM0
                    xMOVQ_r_rm(rMM2,rmREG(rMM0))
                    //MOVQ MM3, [EBX+M00] //1
                    xMOVQ_r_rm   (rMM3,rmIND32(rEBX)) xOFS32(OFFSETOF(CCelsiusState,mTransform) + 0)

                    xCMP_r_rm    (rEDX,rmREG(rEAX))

                    //PUNPCKLDQ MM0, MM0
                    xPUNPCKLDQ_r_rm(rMM0, rmREG(rMM0));
                    //MOVQ MM4, [EBX+M10] //2
                    xMOVQ_r_rm   (rMM4,rmIND32(rEBX)) xOFS32(OFFSETOF(CCelsiusState,mTransform) + 16)

                    xCMOVB_r_rm  (rEAX,rmREG(rEDX))

                    //PFMUL MM3, MM0
                    xPFMUL_r_rm(rMM3,rmREG(rMM0))
                    //PUNPCKHDQ MM2,MM2
                    xPUNPCKHDQ_r_rm(rMM2,rmREG(rMM2))

                    xMOV_i32_r   (mMEM32(global.celsius.dwTouchedMin),rEAX)

                    //PFMUL MM4, MM2
                    xPFMUL_r_rm(rMM4,rmREG(rMM2))
                    //MOVQ MM5, [EBX+M02] //3
                    xMOVQ_r_rm   (rMM5,rmIND32(rEBX)) xOFS32(OFFSETOF(CCelsiusState,mTransform) + 8)


                    //MOVQ MM7, [EBX+M12] //4
                    xMOVQ_r_rm   (rMM7,rmIND32(rEBX)) xOFS32(OFFSETOF(CCelsiusState,mTransform) + 24)
                    //MOVQ MM6, MM1
                    xMOVQ_r_rm(rMM6,rmREG(rMM1))


                    //==========don't move anything that's pipelined accross this line======
                    //switch to EAX for matrix base
                    xMOV_r_rm (rEAX, rmREG(rEBX))

                    //PFMUL MM5,MM0
                    xPFMUL_r_rm(rMM5,rmREG(rMM0))
                    //MOVQ MM0,[EAX+M20]  //5
                    xMOVQ_r_rm   (rMM0,rmIND32(rEAX)) xOFS32(OFFSETOF(CCelsiusState,mTransform) + 32)

                    //EBX -- merge in second part
                    xMOV_r_i32   (rEBX,mMEM32(global.celsius.dwTouchedMax))


                    //PUNPCKLDQ MM1, MM1
                    xPUNPCKLDQ_r_rm(rMM1,rmREG(rMM1))
                    //PFMUL MM7, MM2
                    xPFMUL_r_rm(rMM7,rmREG(rMM2))

                    //MOVQ MM2,[EAX+M22] //6
                    xMOVQ_r_rm   (rMM2,rmIND32(rEAX)) xOFS32(OFFSETOF(CCelsiusState,mTransform) + 40)
                    //PFMUL MM0,MM1
                    xPFMUL_r_rm(rMM0,rmREG(rMM1))

                    xCMP_r_rm    (rEDX,rmREG(rEBX))

                    //PFADD MM3, MM4
                    xPFADD_r_rm(rMM3,rmREG(rMM4))
                    //MOVQ MM4, [EAX+M30] //7
                    xMOVQ_r_rm   (rMM4,rmIND32(rEAX)) xOFS32(OFFSETOF(CCelsiusState,mTransform) + 48)

                    xCMOVA_r_rm  (rEBX,rmREG(rEDX))
                    xMOV_i32_r   (mMEM32(global.celsius.dwTouchedMax),rEBX)

                    //PFMUL MM2, MM1
                    xPFMUL_r_rm(rMM2,rmREG(rMM1))
                    //PFADD MM5, MM7
                    xPFADD_r_rm(rMM5,rmREG(rMM7))

                    //MOVQ MM1,[EAX+M32] //8
                    xMOVQ_r_rm   (rMM1,rmIND32(rEAX)) xOFS32(OFFSETOF(CCelsiusState,mTransform) + 56)
                    //PFADD MM3, MM0
                    xPFADD_r_rm(rMM3,rmREG(rMM0))

                    //PFADD MM5, MM2
                    xPFADD_r_rm(rMM5,rmREG(rMM2))
                    //PFADD MM3, MM4
                    xPFADD_r_rm(rMM3,rmREG(rMM4))

                    //MOVQ [EDX], MM3  Y X -> xy
                    xMOVQ_rm_r(rmIND(rECX),rMM3)

                    //PFADD  MM5, MM1
                    xPFADD_r_rm(rMM5,rmREG(rMM1))

                    //MOVQ [EDX+8], MM5 WZ -> zw
                    xMOVQ_rm_r(rmIND8(rECX),rMM5) xOFS8(8)


                    //xFEMMS
                    xEMMS




                    } ///xform and min/max loop
                    */

                    //             xMOV_r_i32  (rEBX,mMEM32(global.celsius.pContext))
                    //             xMOV_r_rm   (rEBX,rmIND32(rEBX)) xOFS32(OFFSETOF(NVD3DCONTEXT,dwRenderState[D3DRENDERSTATE_CLIPPING]))
                    //             xTEST_r_rm  (rEBX, rmREG(rEBX))
                    //             DWORD noClip = 0;
                    //             xLABEL      (noClip)
                    //             xJZ32       (0)


                    //
                    // generate out codes (under divide) (save ecx)
                    //

                    ///clear esi
                    xXOR_r_rm    (rESI,rmREG(rESI))
                    /// mov ebx, 1
                    xMOV_rm_imm  (rmREG(rEBX),1)
                    /// mov [ecx+16], dwtouchedmin
                    xMOV_rm_r    (rmIND8(rECX),rEAX) xOFS8(16)
                    xFLD_rm32    (rmIND8(rECX)) xOFS8(12)           // w
                    xFLD_st      (rST0)                             // w w
                    xFCHS                                           // -w w

                    // x < -w
                    xFLD_rm32    (rmIND(rECX))                      // x -w w
                    xXOR_r_rm    (rEAX,rmREG(rEAX))
                    xFCOMI_st    (rST1)                             // x -w w
                    xMOV_rm_imm  (rmREG(rEBX),1)
                    xCMOVB_r_rm  (rEAX,rmREG(rEBX))
                    xOR_r_rm     (rESI,rmREG(rEAX))

                    // x > w
                    xXOR_r_rm    (rEAX,rmREG(rEAX))
                    xFCOMIP_st   (rST2)                             // -w w
                    xMOV_rm_imm  (rmREG(rEBX),2)
                    xCMOVA_r_rm  (rEAX,rmREG(rEBX))
                    xOR_r_rm     (rESI,rmREG(rEAX))

                    // y < -w
                    xFLD_rm32    (rmIND8(rECX)) xOFS8(4)            // y -w w
                    xXOR_r_rm    (rEAX,rmREG(rEAX))
                    xFCOMI_st    (rST1)                             // y -w w
                    xMOV_rm_imm  (rmREG(rEBX),4)
                    xCMOVB_r_rm  (rEAX,rmREG(rEBX))
                    xOR_r_rm     (rESI,rmREG(rEAX))

                    // y > w
                    xXOR_r_rm    (rEAX,rmREG(rEAX))
                    xFCOMIP_st   (rST2)                             // -w w
                    xMOV_rm_imm  (rmREG(rEBX),8)
                    xCMOVA_r_rm  (rEAX,rmREG(rEBX))
                    xOR_r_rm     (rESI,rmREG(rEAX))

                    // z < 0
                    xFLDZ                                           // 0 -w w
                    xFLD_rm32    (rmIND8(rECX)) xOFS8(8)            // z 0 -w w
                    xXOR_r_rm    (rEAX,rmREG(rEAX))
                    xFCOMI_st    (rST1)                             // z 0 -w w
                    xMOV_rm_imm  (rmREG(rEBX),16)
                    xCMOVB_r_rm  (rEAX,rmREG(rEBX))
                    xOR_r_rm     (rESI,rmREG(rEAX))

                    // z > w
                    xXOR_r_rm    (rEAX,rmREG(rEAX))
                    xFCOMIP_st   (rST3)                             // 0 -w w
                    xMOV_rm_imm  (rmREG(rEBX),32)
                    xCMOVA_r_rm  (rEAX,rmREG(rEBX))
                    xOR_r_rm     (rESI,rmREG(rEAX))

                    xFFREE_st    (rST0)
                    xFINCSTP
                    xFFREE_st    (rST0)
                    xFINCSTP
                    xFFREE_st    (rST0)
                    xFINCSTP

                    xMOV_r_rm    (rEAX,rmIND8(rECX)) xOFS8(12)
                    xMOV_rm_r    (rmIND8(rECX),rESI) xOFS8(16)

                    //             xTARGET_b32  (noClip)

                    //
                    // store result of divide
                    //
                    ///katmai
                    if ((pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_KATMAI))
                    {
                        ///store x/w y/w z/w w/w

                        // wzyx -> xyzw
                        xMOVAPS_rm_r (rmIND(rECX),rXMM1)
                        //!!! stores EAX tp ECX
                        xMOV_rm_r    (rmIND8(rECX),rEAX) xOFS8(20)


                    }
                    /*
                    else
                    {
                    ///3dnow, temporary, PIPELINE THE DIVIDE, REWRITE CLIP CODES TO 3DNOW AND MERGE

                    //xFEMMS
                    xEMMS

                    //reload vertex
                    //MOVQ MM0, [EDX]
                    ///0 =  Y X
                    xMOVQ_r_rm  (rMM0,rmIND(rECX));

                    //MOVQ MM1, [EDX+8]
                    ///1=  W Z
                    xMOVQ_r_rm  (rMM1,rmIND8(rECX)); xOFS8(8)

                    //2=W Z
                    xMOVQ_r_rm(rMM2,rmREG(rMM1))

                    //temp code
                    //4 = 0 W
                    xMOVD_r_rm(rMM4, rmIND8(rECX)) xOFS8(12)
                    xPFRCP_r_rm (rMM2,rmREG(rMM4))
                    xPFRCPIT1_r_rm (rMM4,rmREG(rMM2))
                    xPFRCPIT2_r_rm (rMM4,rmREG(rMM2))


                    //expand w
                    //2 = W W
                    //xPUNPCKHDQ_r_rm(rMM2,rmREG(rMM2))
                    // 1/w | 1/w
                    //xPFRCP_r_rm (rMM2,rmREG(rMM2))
                    //xPFRCPIT1_r_rm (rMM2,rmREG(rMM2))
                    //xPFRCPIT2_r_rm (rMM2,rmREG(rMM2))

                    //y/w, x/w
                    xPFMUL_r_rm(rMM0,rmREG(rMM2))  //was2
                    //w/w z/w
                    xPFMUL_r_rm(rMM1,rmREG(rMM2))  //was2

                    //store y,x
                    xMOVQ_rm_r(rmIND(rECX),rMM0);


                    //store w,z
                    xMOVQ_rm_r(rmIND8(rECX),rMM1) xOFS8(8)
                    //xPSWAPD_r_rm(rMM4,rmREG(rMM1))
                    //xMOVQ_rm_r(rmIND8(rECX),rMM4) xOFS8(8)

                    //stores EAX to ECX (kni does it)
                    xMOV_rm_r    (rmIND8(rECX),rEAX) xOFS8(20)

                    ///xFEMMS


                    xMOVD_r_rm(rMM0, rmIND8(rECX)) xOFS8(12)
                    xPFRCP_r_rm (rMM1,rmREG(rMM0))
                    xPUNPCKHDQ_r_rm(rMM0,rmREG(rMM0))
                    xPFRCPIT1_r_rm (rMM0,rmREG(rMM1))

                    xMOVQ_r_rm  (rMM2,rmIND(rECX));
                    xMOVQ_r_rm  (rMM3,rmIND8(rECX)); xOFS8(8)

                    xPFRCPIT2_r_rm (rMM0,rmREG(rMM1))

                    xPFMUL_r_rm(rMM2,rmREG(rMM0))
                    xPFMUL_r_rm(rMM3,rmREG(rMM0))

                    xMOVQ_rm_r(rmIND(rECX),rMM2);
                    xMOVQ_rm_r(rmIND8(rECX),rMM3) xOFS8(8)


                    //stores EAX to ECX (kni does it)
                    xMOV_rm_r    (rmIND8(rECX),rEAX) xOFS8(20)

                    xEMMS

                    }
                    */

                    xTARGET_b32 (cacheHit)

                    // instrumentation
    #ifdef INSTRUMENT_INNER_LOOPS
                    xMOV_rm_imm (rmREG(rEAX),global.kelvin.dwVertexStride) // not sizeof(CVertexBuffer::STVERTEX) since we compute effective efficiency
                    xADD_i32_r  (mMEM32(global.dwBytesCopied),rEAX)
    #endif
                }

                //
                // prepare for reject & cull
                //
                xMOV_r_i32  (rEBX,mMEM32(global.dwVertex0))
                xMOV_r_i32  (rECX,mMEM32(global.dwVertex1))
                xMOV_r_i32  (rEDX,mMEM32(global.dwVertex2))

                //
                // do trivial reject (save ebx,ecx,edx)
                //
                DWORD trivialReject = 0;

                xMOV_r_rm   (rEAX,rmIND8(rEBX)) xOFS8(16)
                xAND_r_rm   (rEAX,rmIND8(rECX)) xOFS8(16)
                xAND_r_rm   (rEAX,rmIND8(rEDX)) xOFS8(16)
                xLABEL      (trivialReject)
                xJNZ32      (0)

                //
                // do a cull check
                //

                DWORD cullCheck = 0;
                ///turn culling off temporarly, REMOVE
                //dwFlags |= KELVIN_ILFLAG_NOCULL;

                //katmai
                if ((pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_KATMAI))
                {

                    if (!(dwFlags & KELVIN_ILFLAG_NOCULL))
                    {
                        //reads EBX,ECX,EDX

                        //0: W0 Z0 X0 Y0
                        xMOVAPS_r_rm     (rXMM0,rmIND(rEBX))
                        //1: W1 Z1 X1 Y1
                        xMOVAPS_r_rm     (rXMM1,rmIND(rECX))
                        //2: W2 Z2 X2 Y2
                        xMOVAPS_r_rm     (rXMM2,rmIND(rEDX))
                        //1: W10 Z10 Y10 X10
                        xSUBPS_r_rm      (rXMM1,rmREG(rXMM0))
                        //2: W20 Z20 Y20 X20
                        xSUBPS_r_rm      (rXMM2,rmREG(rXMM0))

                        //0: W10 Z10 Y10 X10
                        xMOVAPS_r_rm     (rXMM0,rmREG(rXMM1))
                        //3: W20 Z20 Y20 X20
                        xMOVAPS_r_rm     (rXMM3,rmREG(rXMM2))

                        //1: Y10 Y10 Y10 Y10
                        xSHUFPS_r_rm_imm (rXMM1,rmREG(rXMM1),1)
                        //2: Y20 Y20 Y20 Y20
                        xSHUFPS_r_rm_imm (rXMM3,rmREG(rXMM3),1)

                        //0: W10 Z10 Y10 X10*Y20
                        xMULSS_r_rm      (rXMM0,rmREG(rXMM3))

                        xMOV_r_rm        (rEAX,rmIND8(rEBX)) xOFS8(20)
                        xXOR_r_rm        (rEAX,rmIND8(rECX)) xOFS8(20)

                        //1: Y10 Y10 Y10 Y10*X20
                        xMULSS_r_rm      (rXMM1,rmREG(rXMM2))
                        xXOR_r_rm        (rEAX,rmIND8(rEDX)) xOFS8(20)

                        //1: Y10*Y20 - X10*X20
                        xSUBSS_r_rm      (rXMM1,rmREG(rXMM0))
                        xMOVSS_i32_r     (mMEM32(global.dwTemp),rXMM1)

                        xMOV_r_i32       (rEBX,mMEM32(global.dwTemp))
                        xXOR_r_rm        (rEBX,rmREG(rEAX))
                        xAND_rm_imm      (rmREG(rEBX),0x80000000)
                        xCMP_r_i32       (rEBX,mMEM32(global.kelvin.dwCullValue))
                        xLABEL           (cullCheck)
                        xJZ32            (0)
                    }

                }
                /*
                else
                {
                //3dnow
                if (!(dwFlags & KELVIN_ILFLAG_NOCULL))
                {

                ///xFEMMS
                xEMMS
                // Y0 | X0
                xMOVQ_r_rm     (rMM0,rmIND(rEBX))
                // Y1 | X1
                xMOVQ_r_rm     (rMM1,rmIND(rECX))
                // Y2 | X2
                xMOVQ_r_rm     (rMM2,rmIND(rEDX))
                // Y10 | X10
                xPFSUB_r_rm    (rMM1, rmREG(rMM0))
                // Y20 | X20
                xPFSUB_r_rm   (rMM2, rmREG(rMM0))
                // X10 | Y10
                xPSWAPD_r_rm (rMM1, rmREG(rMM1))
                //Y20*X10 | X20*Y10
                xPFMUL_r_rm (rMM1,rmREG(rMM2))
                // whatever | X20*Y10 - Y20*X10
                xPFNACC_r_rm (rMM1, rmREG(rMM1))

                //embed in above
                xMOV_r_rm        (rEAX,rmIND8(rEBX)) xOFS8(20)
                xXOR_r_rm        (rEAX,rmIND8(rECX)) xOFS8(20)
                xXOR_r_rm        (rEAX,rmIND8(rEDX)) xOFS8(20)


                //store that stuff
                //xMOVD_r_rm     (mMEM32(global.dwTemp),rMM1)
                xMOVD_r_rm (rEBX,rmREG(rMM1))

                //try to remove
                //xFEMMS
                xEMMS

                //this has to be after the store
                //xMOV_r_i32       (rEBX,mMEM32(global.dwTemp))
                xXOR_r_rm        (rEBX,rmREG(rEAX))
                xAND_rm_imm      (rmREG(rEBX),0x80000000)
                xCMP_r_i32       (rEBX,mMEM32(global.kelvin.dwCullValue))
                xLABEL           (cullCheck)
                xJZ32            (0)
                }
                }
                */

                //
                // dispatch
                //
                //katmai, okay
                if ((pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_KATMAI))
                {

                    xMOVAPS_r_i128 (rXMM0,KNIMEM(dwKelvinTriDispatch))
                    if (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_WILLAMETTE)
                    {
                        xMOVAPS_rm_r   (rmIND(rEDI),rXMM0)
                    }
                    else
                    {
                        xMOVNTPS_rm_r  (rmIND(rEDI),rXMM0)
                    }
                    xLEA_r_rm      (rEDI,rmIND8(rEDI)) xOFS8(16)

                }
                else
                {

                    //generic, if you keep emms, replace with femms.
                    xEMMS
                    xMOVQ_r_i64(rMM1,KNIMEM(dwKelvinTriDispatch))
                    xMOVQ_r_i64(rMM2,KNIMEM(dwKelvinTriDispatch)+8)
                    xMOVNTQ_rm_r (rmIND(rEDI),rMM1)
                    xMOVNTQ_rm_r (rmIND8(rEDI),rMM2) xOFS8(8)
                    xLEA_r_rm      (rEDI,rmIND8(rEDI)) xOFS8(16)
                    xEMMS
                }
                //
                // send more triangles after this one, utilizing connectivity statistics
                //
    #if 1
                // SK -- even though the super-tri code is faster now, this is still a winning bet!
                const int count = 4; // do not exceed 128 words (about 14 of these)
                DWORD sendMore;
                xPOP_r      (rECX)
                xCMP_rm_imm (rmREG(rECX),count)
                xLABEL      (sendMore)
                xJLE32      (0)

                xMOV_r_i32  (rESI,mMEM32(global.kelvin.pIndices))
                for (i = 0; i < count; i++)
                {
                    // prep tri
                    xLEA_r_rm   (rESI,rmIND8(rESI)) xOFS8(6)
                    xXOR_r_rm   (rEBX,rmREG(rEBX))
                    xMOV_r_rm   (rEAX,rmIND(rESI))
                    x16r xMOV_r_rm   (rBX,rmIND8(rESI)) xOFS8(4)
                    xMOV_r_rm   (rEDX,rmREG(rEAX))
                    xAND_rm_imm (rmREG(rEAX),0xffff)
                    xADD_r_i32  (rEBX, mMEM32(global.kelvin.dwBaseVertex))      //******** BV
                    xMOV_i32_r  (KNIMEM(dwKelvinTriDispatch) + 12,rEBX)
                    xSHR_rm_imm8(rmREG(rEDX),16)
                    xADD_r_i32  (rEAX, mMEM32(global.kelvin.dwBaseVertex))      //******** BV
                    xMOV_i32_r  (KNIMEM(dwKelvinTriDispatch) + 4,rEAX)
                    xADD_r_i32  (rEDX, mMEM32(global.kelvin.dwBaseVertex))      //******** BV
                    xMOV_i32_r  (KNIMEM(dwKelvinTriDispatch) + 8,rEDX)

                    // dispatch
                    //katmai, eek
                    if ((pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_KATMAI))
                    {
                        xMOVAPS_r_i128 (rXMM0,KNIMEM(dwKelvinTriDispatch))
                        if (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_WILLAMETTE)
                        {
                            xMOVAPS_rm_r   (rmIND(rEDI),rXMM0)
                        }
                        else
                        {
                            xMOVNTPS_rm_r  (rmIND(rEDI),rXMM0)
                        }
                        xLEA_r_rm      (rEDI,rmIND8(rEDI)) xOFS8(16)
                    }
                    else
                    {

                        ////generic
                        xEMMS
                        xMOVQ_r_i64(rMM1,KNIMEM(dwKelvinTriDispatch))
                        xMOVQ_r_i64(rMM2,KNIMEM(dwKelvinTriDispatch)+8)
                        xMOVNTQ_rm_r (rmIND(rEDI),rMM1)
                        xMOVNTQ_rm_r (rmIND8(rEDI),rMM2) xOFS8(8)
                        xLEA_r_rm      (rEDI,rmIND8(rEDI)) xOFS8(16)
                        xEMMS
                    }


                }
                xSUB_rm_imm (rmREG(rECX),count)
                xMOV_i32_r  (mMEM32(global.kelvin.pIndices),rESI)
                xTARGET_b32 (sendMore)
                xPUSH_r     (rECX)
    #endif
                // check for pusher space
                DWORD labelSpace;
                xMOV_r_i32  (rESI,mMEM32(pDriverData))
                xCMP_r_rm   (rEDI,rmIND32(rESI)) xOFS32(OFFSETOF(CDriverContext, nvPusher.m_dwThreshold))
                xLABEL      (labelSpace)
                xJL         (0)
                {
                    xMOV_rm_imm (rmREG(rEBX),(DWORD)nvKelvinDispatchGetPusherSpace)
                    xMOV_rm_r   (rmIND32(rESI),rEDI) xOFS32(OFFSETOF(CDriverContext, nvPusher.m_dwPut))
                    xCALL_rm    (rmREG(rEBX))
                    xMOV_r_rm   (rEDI,rmIND32(rESI)) xOFS32(OFFSETOF(CDriverContext, nvPusher.m_dwPut))
                }
                xTARGET_b8  (labelSpace)

                //
                // next triangle
                //
                if (trivialReject)
                { xTARGET_b32 (trivialReject)
                }
                if (cullCheck)
                { xTARGET_b32 (cullCheck)
                }
                xMOV_r_i32  (rESI,mMEM32(global.kelvin.pIndices))
                xPOP_r      (rECX)
                xLEA_r_rm   (rESI,rmIND8(rESI)) xOFS8(6)
                xDEC_rm     (rmREG(rECX))
                xMOV_i32_r  (mMEM32(global.kelvin.pIndices),rESI)
                xJNZ32      (again)
            }

            //
            // end primitive
            //
            xMOVQ_r_i64  (rMM0,mMEM64(global.kelvin.qwEnd))
            xMOVNTQ_rm_r (rmIND(rEDI),rMM0)
            xLEA_r_rm   (rEDI,rmIND8(rEDI)) xOFS8(8)
            xEMMS


            //***********************************************************************************************
            //                          Model Space Culling
            //***********************************************************************************************
        }
        else if (pContext->hwState.SuperTri.isModelCull())
        {


#ifdef SW_WC
#define NVPUSHER_NV097_ARRAY_ELELMENT32 ((((3) << 2) << 16) | ((NV_DD_KELVIN) << 13) | (NVPUSHER_NOINC(NV097_ARRAY_ELEMENT32)))
#endif
//#define NO_RAW1
//#define NO_RAW2
            //
            // start primitive
            //
            xMOVQ_r_i64  (rMM0,mMEM64(global.kelvin.qwBegin))
            xMOVNTQ_rm_r (rmIND(rEDI),rMM0)
            xLEA_r_rm   (rEDI,rmIND8(rEDI)) xOFS8(8)
            xEMMS


            //
            // setup
            //
            xMOV_r_i32  (rEAX,mMEM32(global.dwVertexSN))
            xADD_rm_imm (rmREG(rEAX),0x10000)
            xMOV_i32_r  (mMEM32(global.dwVertexSN),rEAX)

            xMOV_r_i32  (rESI,mMEM32(global.kelvin.pIndices))
            xMOV_r_i32  (rECX,mMEM32(global.kelvin.dwPrimCount))
            xLEA_r_rm   (rEAX,rmSIB) xSIB(rECX,rECX,x2)
            xMOV_i32_r  (mMEM32(global.kelvin.dwPrefetchBase),rESI)
            xLEA_r_rm   (rEAX,rmSIB) xSIB(rEAX,rEAX,x1)
            xMOV_i32_r  (mMEM32(global.kelvin.dwPrefetchMax),rEAX)

            // eye point in model space

            xMOV_r_i32 (rEAX,mMEM32(global.kelvin.dwEyeAddr))

            xMOVLPS_r_rm (rXMM7,rmIND(rEAX)) 
            xMOVHPS_r_rm (rXMM7,rmIND8(rEAX)) xOFS8(8)

#ifdef SW_WC
            // Setup SW WC pointers
            xXOR_r_rm   (rEBP, rmREG(rEBP))

#endif

            //
            // process all triangles
            //
            DWORD again;
            xLABEL  (again)
            xPUSH_r (rECX)

            //
            DWORD cullCheck = 0;
#ifdef SW_WC
            DWORD cullCheck2 = 0;
#endif
            if (!(dwFlags & KELVIN_ILFLAG_NOCULL))
            {
                // get index
                //clear EDX

#ifdef SW_WC
                xMOV_rm_imm(rmREG(rEDX), NVPUSHER_NV097_ARRAY_ELELMENT32)
                xMOV_rm_r(rmIND32(rEBP), rEDX) xOFS32(KNIMEM(dwKelvinTriDispatch))
#endif
                // Vertex 0
//#ifdef SW_WC
//        #define STMC_PREF_DIST 0x60
//#else
        #define STMC_PREF_DIST 0x40
//#endif
                xXOR_r_rm   (rEDX,rmREG(rEDX))

                xMOV_r_i32  (rESI,mMEM32(global.kelvin.pIndices))
                x16r xMOV_r_rm   (rDX,rmIND8(rESI)) xOFS8(0*2)
                xADD_r_i32       (rEDX, mMEM32(global.kelvin.dwBaseVertex))      //******** BV
#ifdef SW_WC
                xMOV_rm_r(rmIND32(rEBP), rEDX) xOFS32(KNIMEM(dwKelvinTriDispatch)+1*4)
#else
#ifndef NO_RAW1
                xMOV_i32_r  (KNIMEM(dwKelvinTriDispatch) + 4 + 0*4,rEDX)
#endif
#endif

                // compute vertex address into edx
                ILCCompile_mul (rEDX,pContext->hwState.SuperTri.getSTLBStride());
                xADD_r_i32     (rEDX,mMEM32(global.kelvin.pVertices))

                xMOV_r_rm   (rEAX, rmREG(rEDX))
                if ((pContext->hwState.SuperTri.getSTLBStride() & 0xf) != 0)
                {
                    xMOVLPS_r_rm (rXMM0, rmIND(rEDX))
                    xMOVHPS_r_rm (rXMM0, rmIND8(rEDX)) xOFS8(8)
                }
                else
                {
                    xMOVAPS_r_rm (rXMM0, rmIND(rEDX))
                }

                // Vertex 1
                xXOR_r_rm   (rEDX,rmREG(rEDX))

                x16r xMOV_r_rm   (rDX,rmIND8(rESI)) xOFS8(1*2)
                xADD_r_i32       (rEDX, mMEM32(global.kelvin.dwBaseVertex))      //******** BV
#ifdef SW_WC
                xMOV_rm_r(rmIND32(rEBP), rEDX) xOFS32(KNIMEM(dwKelvinTriDispatch)+2*4)
#else
#ifndef NO_RAW1
                xMOV_i32_r  (KNIMEM(dwKelvinTriDispatch) + 4 + 1*4,rEDX)
#endif
#endif
                // compute vertex address into edx
                ILCCompile_mul (rEDX,pContext->hwState.SuperTri.getSTLBStride());
                xADD_r_i32     (rEDX,mMEM32(global.kelvin.pVertices))

                xMOV_r_rm   (rEBX, rmREG(rEDX))
                if ((pContext->hwState.SuperTri.getSTLBStride() & 0xf) != 0)
                {
                    xMOVLPS_r_rm (rXMM1, rmIND(rEDX))
                    xMOVHPS_r_rm (rXMM1, rmIND8(rEDX)) xOFS8(8)
                }
                else
                {
                    xMOVAPS_r_rm (rXMM1, rmIND(rEDX))
                }

                // Vertex 2
                xXOR_r_rm   (rEDX,rmREG(rEDX))

                x16r xMOV_r_rm   (rDX,rmIND8(rESI)) xOFS8(2*2)
                xADD_r_i32       (rEDX, mMEM32(global.kelvin.dwBaseVertex))      //******** BV
#ifdef SW_WC
                xMOV_rm_r(rmIND32(rEBP), rEDX) xOFS32(KNIMEM(dwKelvinTriDispatch)+3*4)
#else
#ifndef NO_RAW1
                xMOV_i32_r  (KNIMEM(dwKelvinTriDispatch) + 4 + 2*4,rEDX)
#endif
#endif

                // compute vertex address into edx
                ILCCompile_mul (rEDX,pContext->hwState.SuperTri.getSTLBStride());
                xADD_r_i32      (rEDX,mMEM32(global.kelvin.pVertices))

                xMOV_r_rm   (rECX, rmREG(rEDX))
                if ((pContext->hwState.SuperTri.getSTLBStride() & 0xf) != 0)
                {
                    xMOVLPS_r_rm    (rXMM2, rmIND(rEDX))
                    xMOVHPS_r_rm    (rXMM2, rmIND8(rEDX)) xOFS8(8)
                }
                else
                {
                    xMOVAPS_r_rm (rXMM2, rmIND(rEDX))
                }

                // Compute eye vector

                xCMP_r_rm   (rEBX, rmREG(rEAX))

                xMOVAPS_r_rm    (rXMM6, rmREG(rXMM7))       //xmm6 = eye point
                xSUBPS_r_rm     (rXMM6, rmREG(rXMM0))       //xmm6 = eye vec

                // Compute Normal
                xCMOVA_r_rm (rEAX, rmREG(rEBX))

                xSUBPS_r_rm     (rXMM1, rmREG(rXMM0))       //v1 - v0 = v10
                xMOVAPS_r_rm    (rXMM3, rmREG(rXMM1))       //v1 - v0 = v10


                xSHUFPS_r_rm_imm (rXMM1,rmREG(rXMM1),0xC9)  //xmm1 = 1.0 v10.x v10.z v10.y

                xCMP_r_rm   (rECX, rmREG(rEAX))

                xSHUFPS_r_rm_imm (rXMM3,rmREG(rXMM3),0xD2)  //xmm3 = 1.0 v10.y v10.x v10.z


                xSUBPS_r_rm     (rXMM2, rmREG(rXMM0))       //v2 - v0 = v20
                xMOVAPS_r_rm    (rXMM4, rmREG(rXMM2))       //v2 - v0 = v20


                xSHUFPS_r_rm_imm (rXMM2, rmREG(rXMM2),0xC9) //xmm2 = 1.0 v20.x v20.z v20. y
                xCMOVA_r_rm (rEAX, rmREG(rECX))
                xSHUFPS_r_rm_imm (rXMM4, rmREG(rXMM4),0xD2) //xmm4 = 1.0 v20.y v20.x v20.z

                xMULPS_r_rm     (rXMM1, rmREG(rXMM4))
                xAND_rm_imm (rmREG(rEAX), ~0x1f)
                xMULPS_r_rm     (rXMM2, rmREG(rXMM3))

                if (pContext->hwState.SuperTri.isFixedLBStride())
                {
                    xPREFETCH_rm8(1, rmIND8(rEAX), STMC_PREF_DIST)
                }
                else
                {
                    if ((4 * pContext->hwState.SuperTri.getSTLBStride()) < 128) {
                        xPREFETCH_rm8(1, rmIND8(rEAX), 4 * pContext->hwState.SuperTri.getSTLBStride())
                    }
                    else {
                        xADD_rm_imm(rmREG(rEAX), 4 * pContext->hwState.SuperTri.getSTLBStride())
                        xPREFETCH_rm8(1, rmIND8(rEAX), 0)
                    }
                }

                xSUBPS_r_rm     (rXMM1, rmREG(rXMM2))       //xmm1 = 0.0 Z' Y' X'

                // Dot eye vector with normal

                xMULPS_r_rm     (rXMM1, rmREG(rXMM6))       // xxx n.z*v.z n.y*v.y n.x*v.x
                xMOVAPS_r_rm    (rXMM0, rmREG(rXMM1))
                xMOVAPS_r_rm    (rXMM2, rmREG(rXMM1))
                xSHUFPS_r_rm_imm (rXMM0, rmREG(rXMM0), 0x01)
                xMOV_r_i32      (rEAX,mMEM32(global.kelvin.dwCullAddr))
                xMOV_r_rm       (rEBX,rmIND(rEAX)) 
                xSHUFPS_r_rm_imm (rXMM2, rmREG(rXMM2), 0x02)
                xADDSS_r_rm     (rXMM0, rmREG(rXMM1))
                xADDSS_r_rm     (rXMM0, rmREG(rXMM2))

                // Extract sign bit from dot product

                xMOVMSKPS_r_r   (rEAX, rmREG(rXMM0))
                xXOR_r_rm       (rEAX, rmREG(rEBX))

//                 xXOR_rm_imm     (rmREG(rEAX), 0x00000001)
                xTEST_rm_imm    (rmREG(rEAX), 0x00000001)


                //reads EBX,ECX,EDX

                xLABEL           (cullCheck)
//                 xJNZ32            (0)
                xJZ32            (0)


#ifdef SW_WC
                xLEA_r_rm      (rEBP,rmIND8(rEBP)) xOFS8(16)
//                 xADD_r_rm       (rEBP, rmREG(rEBX))
#endif


            }
            else
            {
#ifdef SW_WC
                xMOV_rm_imm     (rmREG(rEDX), NVPUSHER_NV097_ARRAY_ELELMENT32)
                xMOV_rm_r       (rmIND32(rEBP), rEDX) xOFS32(KNIMEM(dwKelvinTriDispatch))

                xXOR_r_rm       (rEDX,rmREG(rEDX))

                xMOV_r_i32      (rESI,mMEM32(global.kelvin.pIndices))
                x16r xMOV_r_rm  (rDX,rmIND8(rESI)) xOFS8(0*2)
                xADD_r_i32       (rEDX, mMEM32(global.kelvin.dwBaseVertex))      //******** BV
                xMOV_rm_r       (rmIND32(rEBP), rEDX) xOFS32(KNIMEM(dwKelvinTriDispatch)+1*4)

                x16r xMOV_r_rm  (rDX,rmIND8(rESI)) xOFS8(1*2)
                xADD_r_i32       (rEDX, mMEM32(global.kelvin.dwBaseVertex))      //******** BV
                xMOV_rm_r       (rmIND32(rEBP), rEDX) xOFS32(KNIMEM(dwKelvinTriDispatch)+2*4)

                x16r xMOV_r_rm  (rDX,rmIND8(rESI)) xOFS8(2*2)
                xADD_r_i32       (rEDX, mMEM32(global.kelvin.dwBaseVertex))      //******** BV
                xMOV_rm_r       (rmIND32(rEBP), rEDX) xOFS32(KNIMEM(dwKelvinTriDispatch)+3*4)
                xLEA_r_rm       (rEBP,rmIND8(rEBP)) xOFS8(16)
#else
#ifndef NO_RAW1
                xXOR_r_rm   (rEDX,rmREG(rEDX))

                xMOV_r_i32  (rESI,mMEM32(global.kelvin.pIndices))
                x16r xMOV_r_rm   (rDX,rmIND8(rESI)) xOFS8(0*2)
                xADD_r_i32       (rEDX, mMEM32(global.kelvin.dwBaseVertex))      //******** BV
                xMOV_i32_r  (KNIMEM(dwKelvinTriDispatch) + 4 + 0*4,rEDX)

                x16r xMOV_r_rm   (rDX,rmIND8(rESI)) xOFS8(1*2)
                xADD_r_i32       (rEDX, mMEM32(global.kelvin.dwBaseVertex))      //******** BV
                xMOV_i32_r  (KNIMEM(dwKelvinTriDispatch) + 4 + 1*4,rEDX)

                x16r xMOV_r_rm   (rDX,rmIND8(rESI)) xOFS8(2*2)
                xADD_r_i32       (rEDX, mMEM32(global.kelvin.dwBaseVertex))      //******** BV
                xMOV_i32_r  (KNIMEM(dwKelvinTriDispatch) + 4 + 2*4,rEDX)
#endif
#endif
            }

            //
            // dispatch
            //
            //katmai, okay
#ifdef SW_WC
            xCMP_rm_imm     (rmREG(rEBP), SW_WC_BYTES)
            xLABEL          (cullCheck2)
            xJNZ32          (0)


            DWORD labelFlush0;
            xMOV_rm_imm (rmREG(rESI), KNIMEM(dwKelvinTriDispatch))
            xLABEL      (labelFlush0)
            xMOV_r_rm   (rEAX, rmIND(rESI))
            xMOV_rm_r   (rmIND(rEDI), rEAX)
            xMOV_r_rm   (rEAX, rmIND8(rESI)) xOFS8(4)
            xMOV_rm_r   (rmIND8(rEDI), rEAX) xOFS8(4)
            xMOV_r_rm   (rEAX, rmIND8(rESI)) xOFS8(8)
            xMOV_rm_r   (rmIND8(rEDI), rEAX) xOFS8(8)
            xMOV_r_rm   (rEAX, rmIND8(rESI)) xOFS8(12)
            xMOV_rm_r   (rmIND8(rEDI), rEAX) xOFS8(12)
            xLEA_r_rm   (rESI, rmIND8(rESI)) xOFS8(16)
            xLEA_r_rm   (rEDI, rmIND8(rEDI)) xOFS8(16)
            xSUB_rm_imm (rmREG(rEBP), 16)
            xJNZ        (labelFlush0)

//
//             for (int i = 0;i < SW_WC_LINES2FILL ;i++)
//             {
//                 xMOVAPS_r_i128  (rXMM0,KNIMEM(dwKelvinTriDispatch)+(i*64)+0*16)
//                 xMOVAPS_r_i128  (rXMM1,KNIMEM(dwKelvinTriDispatch)+(i*64)+1*16)
//                 xMOVAPS_r_i128  (rXMM2,KNIMEM(dwKelvinTriDispatch)+(i*64)+2*16)
//                 xMOVAPS_r_i128  (rXMM3,KNIMEM(dwKelvinTriDispatch)+(i*64)+3*16)
//                 xMOVAPS_rm_r   (rmIND32(rEDI),rXMM0) xOFS32(i*64+0*16)
//                 xMOVAPS_rm_r   (rmIND32(rEDI),rXMM1) xOFS32(i*64+1*16)
//                 xMOVAPS_rm_r   (rmIND32(rEDI),rXMM2) xOFS32(i*64+2*16)
//                 xMOVAPS_rm_r   (rmIND32(rEDI),rXMM3) xOFS32(i*64+3*16)
//
//             }
//             xLEA_r_rm      (rEDI,rmIND32(rEDI)) xOFS32(SW_WC_BYTES)
            xXOR_r_rm   (rEBP, rmREG(rEBP))


#else
#ifdef NO_RAW1

                xMOV_r_i32  (rESI,mMEM32(global.kelvin.pIndices))
                xMOV_r_i32  (rEDX, KNIMEM(dwKelvinTriDispatch))
                xMOV_rm_r   (rmIND(rEDI), rEDX)

                xXOR_r_rm   (rEDX,rmREG(rEDX))

                x16r xMOV_r_rm   (rDX,rmIND(rESI))
                xADD_r_i32       (rEDX, mMEM32(global.kelvin.dwBaseVertex))      //******** BV
                xMOV_rm_r  (rmIND8(rEDI),rEDX) xOFS8(1*4)

                x16r xMOV_r_rm   (rDX,rmIND8(rESI)) xOFS8(1*2)
                xADD_r_i32       (rEDX, mMEM32(global.kelvin.dwBaseVertex))      //******** BV
                xMOV_rm_r  (rmIND8(rEDI),rEDX) xOFS8(2*4)

                x16r xMOV_r_rm   (rDX,rmIND8(rESI)) xOFS8(2*2)
                xADD_r_i32       (rEDX, mMEM32(global.kelvin.dwBaseVertex))      //******** BV
                xMOV_rm_r  (rmIND8(rEDI),rEDX) xOFS8(3*4)
                xLEA_r_rm      (rEDI,rmIND8(rEDI)) xOFS8(16)
#else // old code
            if ((pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_KATMAI))
            {

                xMOVAPS_r_i128 (rXMM0,KNIMEM(dwKelvinTriDispatch))
                if (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_WILLAMETTE)
                {
                    xMOVAPS_rm_r   (rmIND(rEDI),rXMM0)
                }
                else
                {
                    xMOVNTPS_rm_r  (rmIND(rEDI),rXMM0)
                }
                xLEA_r_rm      (rEDI,rmIND8(rEDI)) xOFS8(16)

            }
            else
            {

                //generic, if you keep emms, replace with femms.
                xEMMS
                xMOVQ_r_i64(rMM1,KNIMEM(dwKelvinTriDispatch))
                xMOVQ_r_i64(rMM2,KNIMEM(dwKelvinTriDispatch)+8)
                xMOVNTQ_rm_r (rmIND(rEDI),rMM1)
                xMOVNTQ_rm_r (rmIND8(rEDI),rMM2) xOFS8(8)
                xLEA_r_rm      (rEDI,rmIND8(rEDI)) xOFS8(16)
                xEMMS
            }
#endif
#endif

#ifndef SW_WC
            //
            // send more triangles after this one, utilizing connectivity statistics
            //
    #ifdef NO_RAW2
            if (!pContext->hwState.SuperTri.isCheckAll() || (dwFlags & KELVIN_ILFLAG_NOCULL))
            {
                const int count = 4; // do not exceed 128 words (about 14 of these)
                DWORD sendMore;
                xPOP_r      (rECX)
                xCMP_rm_imm (rmREG(rECX),count)
                xLABEL      (sendMore)
                xJLE32      (0)

                xMOV_r_i32  (rESI,mMEM32(global.kelvin.pIndices))
                xMOV_r_i32  (rEDX, KNIMEM(dwKelvinTriDispatch))
                for (int i = 0; i < count; i++)
                {
                    // prep tri
                    xLEA_r_rm   (rESI,rmIND8(rESI)) xOFS8(6)
                    xMOV_rm_r   (rmIND(rEDI), rEDX)

                    xXOR_r_rm   (rEBX,rmREG(rEBX))

                    x16r xMOV_r_rm   (rBX,rmIND(rESI))
                    xADD_r_i32       (rEBX, mMEM32(global.kelvin.dwBaseVertex))      //******** BV
                    xMOV_rm_r  (rmIND8(rEDI),rEBX) xOFS8(1*4)

                    x16r xMOV_r_rm   (rBX,rmIND8(rESI)) xOFS8(1*2)
                    xADD_r_i32       (rEBX, mMEM32(global.kelvin.dwBaseVertex))      //******** BV
                    xMOV_rm_r  (rmIND8(rEDI),rEBX) xOFS8(2*4)

                    x16r xMOV_r_rm   (rBX,rmIND8(rESI)) xOFS8(2*2)
                    xADD_r_i32       (rEBX, mMEM32(global.kelvin.dwBaseVertex))      //******** BV
                    xMOV_rm_r  (rmIND8(rEDI),rEBX) xOFS8(3*4)
                    xLEA_r_rm      (rEDI,rmIND8(rEDI)) xOFS8(16)

                }
                xSUB_rm_imm (rmREG(rECX),count)
                xMOV_i32_r  (mMEM32(global.kelvin.pIndices),rESI)
                xTARGET_b32 (sendMore)
                xPUSH_r     (rECX)
            }
    #else
            if (!pContext->hwState.SuperTri.isCheckAll() || (dwFlags & KELVIN_ILFLAG_NOCULL))
            {
                const int count = 4; // do not exceed 128 words (about 14 of these)
                DWORD sendMore;
                xPOP_r      (rECX)
                xCMP_rm_imm (rmREG(rECX),count)
                xLABEL      (sendMore)
                xJLE32      (0)

                xMOV_r_i32  (rESI,mMEM32(global.kelvin.pIndices))
                for (int i = 0; i < count; i++)
                {
                    // prep tri
                    xLEA_r_rm   (rESI,rmIND8(rESI)) xOFS8(6)
                    xXOR_r_rm   (rEBX,rmREG(rEBX))
                    xMOV_r_rm   (rEAX,rmIND(rESI))
                    x16r xMOV_r_rm   (rBX,rmIND8(rESI)) xOFS8(4)
                    xADD_r_i32       (rEBX, mMEM32(global.kelvin.dwBaseVertex))      //******** BV
                    xMOV_r_rm   (rEDX,rmREG(rEAX))
                    xAND_rm_imm (rmREG(rEAX),0xffff)
                    xADD_r_i32       (rEAX, mMEM32(global.kelvin.dwBaseVertex))      //******** BV
                    xMOV_i32_r  (KNIMEM(dwKelvinTriDispatch) + 12,rEBX)
                    xSHR_rm_imm8(rmREG(rEDX),16)
                    xADD_r_i32       (rEDX, mMEM32(global.kelvin.dwBaseVertex))      //******** BV
                    xMOV_i32_r  (KNIMEM(dwKelvinTriDispatch) + 4,rEAX)
                    xMOV_i32_r  (KNIMEM(dwKelvinTriDispatch) + 8,rEDX)

                    // dispatch
                    //katmai, eek
                    if ((pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_KATMAI))
                    {
                        xMOVAPS_r_i128 (rXMM0,KNIMEM(dwKelvinTriDispatch))
                        if (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_WILLAMETTE)
                        {
                            xMOVAPS_rm_r   (rmIND(rEDI),rXMM0)
                        }
                        else
                        {
                            xMOVNTPS_rm_r  (rmIND(rEDI),rXMM0)
                        }
                        xLEA_r_rm      (rEDI,rmIND8(rEDI)) xOFS8(16)
                    }
                    else
                    {

                        ////generic
                        xEMMS
                        xMOVQ_r_i64(rMM1,KNIMEM(dwKelvinTriDispatch))
                        xMOVQ_r_i64(rMM2,KNIMEM(dwKelvinTriDispatch)+8)
                        xMOVNTQ_rm_r (rmIND(rEDI),rMM1)
                        xMOVNTQ_rm_r (rmIND8(rEDI),rMM2) xOFS8(8)
                        xLEA_r_rm      (rEDI,rmIND8(rEDI)) xOFS8(16)
                        xEMMS
                    }


                }
                xSUB_rm_imm (rmREG(rECX),count)
                xMOV_i32_r  (mMEM32(global.kelvin.pIndices),rESI)
                xTARGET_b32 (sendMore)
                xPUSH_r     (rECX)
            }
    #endif
#endif //SW_WC
            // check for pusher space
            DWORD labelSpace;
            xMOV_r_i32  (rESI,mMEM32(pDriverData))
            xCMP_r_rm   (rEDI,rmIND32(rESI)) xOFS32(OFFSETOF(CDriverContext, nvPusher.m_dwThreshold))
            xLABEL      (labelSpace)
            xJL         (0)
            {
                xMOV_rm_imm (rmREG(rEBX),(DWORD)nvKelvinDispatchGetPusherSpace)
                xMOV_rm_r   (rmIND32(rESI),rEDI) xOFS32(OFFSETOF(CDriverContext, nvPusher.m_dwPut))
                xCALL_rm    (rmREG(rEBX))
                xMOV_r_rm   (rEDI,rmIND32(rESI)) xOFS32(OFFSETOF(CDriverContext, nvPusher.m_dwPut))
            }
            xTARGET_b8  (labelSpace)

            //
            // next triangle
            //
            if (cullCheck)
            { xTARGET_b32 (cullCheck)
            }
#ifdef SW_WC
            if (cullCheck2)
            { xTARGET_b32 (cullCheck2)
            }
#endif
            xMOV_r_i32  (rESI,mMEM32(global.kelvin.pIndices))
            xPOP_r      (rECX)
            xLEA_r_rm   (rESI,rmIND8(rESI)) xOFS8(6)
            xDEC_rm     (rmREG(rECX))
            xMOV_i32_r  (mMEM32(global.kelvin.pIndices),rESI)
            xJNZ32      (again)


#ifdef  SW_WC
            // flush out remaining triangles
            DWORD labelDone;
            DWORD labelFlush;
            xTEST_r_rm  (rEBP, rmREG(rEBP))
            xLABEL      (labelDone)
            xJZ         (0)

            xMOV_rm_imm (rmREG(rESI), KNIMEM(dwKelvinTriDispatch))
            xLABEL      (labelFlush)
            xMOV_r_rm   (rEAX, rmIND(rESI))
            xMOV_rm_r   (rmIND(rEDI), rEAX)
            xMOV_r_rm   (rEAX, rmIND8(rESI)) xOFS8(4)
            xMOV_rm_r   (rmIND8(rEDI), rEAX) xOFS8(4)
            xMOV_r_rm   (rEAX, rmIND8(rESI)) xOFS8(8)
            xMOV_rm_r   (rmIND8(rEDI), rEAX) xOFS8(8)
            xMOV_r_rm   (rEAX, rmIND8(rESI)) xOFS8(12)
            xMOV_rm_r   (rmIND8(rEDI), rEAX) xOFS8(12)
            xLEA_r_rm   (rESI, rmIND8(rESI)) xOFS8(16)
            xLEA_r_rm   (rEDI, rmIND8(rEDI)) xOFS8(16)
            xSUB_rm_imm (rmREG(rEBP), 16)
            xJNZ        (labelFlush)


            xTARGET_b8  (labelDone)
#endif


            //
            // end primitive
            //
            xMOVQ_r_i64  (rMM0,mMEM64(global.kelvin.qwEnd))
            xMOVNTQ_rm_r (rmIND(rEDI),rMM0)
            xLEA_r_rm   (rEDI,rmIND8(rEDI)) xOFS8(8)
            xEMMS


        }//#endif // ~INVERSE_XFORM_CULL

        //
        // save off push buffer
        //
        xMOV_r_i32  (rEDX,mMEM32(pDriverData))
    #ifndef NV_NULL_HW_DRIVER
        xMOV_rm_r   (rmIND32(rEDX),rEDI) xOFS32(OFFSETOF(CDriverContext,nvPusher.m_dwPut))
    #endif

    #endif // USE_C_LOGIC
        //
        // clean up caching strategy
        //
        //     xMOV_r_i32  (rEAX,mMEM32(pDriverData))
        //     xMOV_rm_imm (rmREG(rEBX),rzSetAGPMTRR)
        //     xPUSH_imm   (1)
        //     xPUSH_rm    (rmIND32(rEAX)) xOFS32(OFFSETOF(GLOBALDATA,GARTPhysicalBase))
        //     xCALL_rm    (rmREG(rEBX))

        //
        // done
        //
        xPOP_r      (rEDI)
        xPOP_r      (rESI)
        xPOP_r      (rEBX)
        xPOP_r      (rEBP)
        xRET
        return lEntry;

    }

#else //#if 0

    return 0;
#endif //#if 0

}


#endif KELVIN_ILC

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\kelvin\src\nvKelvinProgram.cpp ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// ********************************* Direct 3D ******************************
//
//  Module: nvKelvinProgram.cpp
//      Routines for management of Kelvin programs
//
// **************************************************************************
//
//  History:
//      Craig Duttweiler        23May00         NV20 development
//
// **************************************************************************
#include "nvprecomp.h"

#if (NVARCH >= 0x20)

extern DWORD dwCelsiusMethodDispatch[11][16][2];

//---------------------------------------------------------------------------

long getout (char *s)
{
    long i=0,add;

    if (strstr(s,"HPOS")) add =  0;
    else if (strstr(s,"COL0")) add =  3;
    else if (strstr(s,"COL1")) add =  4;
    else if (strstr(s,"BFC0")) add =  7;
    else if (strstr(s,"BFC1")) add =  8;
    else if (strstr(s,"FOGC")) add =  5;
    else if (strstr(s,"PSIZ")) add =  6;
    else if (strstr(s,"TEX0")) add =  9;
    else if (strstr(s,"TEX1")) add = 10;
    else if (strstr(s,"TEX2")) add = 11;
    else if (strstr(s,"TEX3")) add = 12;
    else if (strstr(s,"TEX4")) add = 13;
    else if (strstr(s,"TEX5")) add = 14;
    else if (strstr(s,"TEX6")) add = 15;
    else if (strstr(s,"TEX7")) add = 15; /* dev null it */
    else {
        while (s[i] < '0' || s[i] > '9')
            i++;

        add = 0;
        while (s[i] >= '0' && s[i] <= '9') {
            add *= 10;
            add += s[i] - '0';
            i++;
        }
    }

    return(add);
}

//---------------------------------------------------------------------------

long readit
(
    char *s,
    long dest
)
{
    long msk,add,i,neg,mux,indexed,output;
    long xmsk,ymsk,zmsk,wmsk,hold0,hold1,j;

    indexed = 0;
    output = 0;

    if (dest) {
        if (strstr(s,"c[")) {
            mux = MX_C;
            if (strstr(s,"A0"))
                assert(0);
        }
        else if (strstr(s,"o[")) {
            mux = MX_O;
            output = 1;
            add = getout(s);
            if (strstr(s,"A0"))
                assert(0);
        }
        else if (strstr(s,"R")) {
            mux = MX_R;
        }
        else if (strstr(s,"v[")) {
            assert(0);
        }
        else {
            return(0);
        }
    }
    else {
        if (strstr(s,"c[")) {
            mux = MX_C;
            if (strstr(s,"A0"))
                indexed = IDX_MASK;
        }
        else if (strstr(s,"v[")) {
            mux = MX_V;
            if (strstr(s,"A0"))
                assert(0);
        }
        else if (strstr(s,"R")) {
            mux = MX_R;
        }
        else if (strstr(s,"o[")) {
            assert(0);
        }
        else {
            return(0);
        }
    }

    neg = 0;
    if (s[0] == '-')
        neg = SGN_MASK;

    i = 0;
    if (output) {
        while (s[i] != ']')
            i++;
    }
    else {
        while (s[i] < '0' || s[i] > '9')
            i++;

        if (indexed && s[i-1] == 'A' && s[i] == '0') {
            i++;
            while (s[i] < '0' || s[i] > '9')
                i++;
        }

        /* else address */
        add = 0;
        while (s[i] >= '0' && s[i] <= '9') {
            add *= 10;
            add += s[i] - '0';
            i++;
        }
    }
    if (add < 0 || add > 511)
        assert(0);
    add &= 0xff;

    hold0 = hold1 = 0;
    for (j=i; s[j] != '\0'; j++) {
        if (s[j] == '.') hold0 = j;
        if (s[j] == ']') hold1 = j+1;
    }
    i = (hold1 > hold0) ?  hold1 : hold0;

    /* write mask */
    if (dest) {
        msk = 15;
        if (s[i++] == '.') {
            msk = 0;
            while (s[i]=='x' || s[i]=='y' || s[i]=='z' || s[i]=='w') {
                if (s[i]=='x') {
                    if (msk & 0xf)
                        assert(0);
                    msk |= 8;
                }
                if (s[i]=='y') {
                    if (msk & 0x7)
                        assert(0);
                    msk |= 4;
                }
                if (s[i]=='z') {
                    if (msk & 0x3)
                        assert(0);
                    msk |= 2;
                }
                if (s[i]=='w') {
                    if (msk & 0x1)
                        assert(0);
                    msk |= 1;
                }
                i++;
            }
        }
    }

    /* swizzle mask */
    else {
        xmsk = 0;
        ymsk = 1;
        zmsk = 2;
        wmsk = 3;
        if (s[i++] == '.') {
            if (s[i] == 'x' && (s[i+1] < 'w' || s[i+1] > 'z'))
                xmsk = ymsk = zmsk = wmsk = CSW_X;
            else if (s[i] == 'y' && (s[i+1] < 'w' || s[i+1] > 'z'))
                xmsk = ymsk = zmsk = wmsk = CSW_Y;
            else if (s[i] == 'z' && (s[i+1] < 'w' || s[i+1] > 'z'))
                xmsk = ymsk = zmsk = wmsk = CSW_Z;
            else if (s[i] == 'w' && (s[i+1] < 'w' || s[i+1] > 'z'))
                xmsk = ymsk = zmsk = wmsk = CSW_W;
            else {
                switch (s[i++]) {
                    case 'x': xmsk = CSW_X; break;
                    case 'y': xmsk = CSW_Y; break;
                    case 'z': xmsk = CSW_Z; break;
                    case 'w': xmsk = CSW_W; break;
                    default: assert(0);
                }
                switch (s[i++]) {
                    case 'x': ymsk = CSW_X; break;
                    case 'y': ymsk = CSW_Y; break;
                    case 'z': ymsk = CSW_Z; break;
                    case 'w': ymsk = CSW_W; break;
                    default: assert(0);
                }
                switch (s[i++]) {
                    case 'x': zmsk = CSW_X; break;
                    case 'y': zmsk = CSW_Y; break;
                    case 'z': zmsk = CSW_Z; break;
                    case 'w': zmsk = CSW_W; break;
                    default: assert(0);
                }
                switch (s[i++]) {
                    case 'x': wmsk = CSW_X; break;
                    case 'y': wmsk = CSW_Y; break;
                    case 'z': wmsk = CSW_Z; break;
                    case 'w': wmsk = CSW_W; break;
                    default: assert(0);
                }
            }
        }

        msk = (wmsk<<6) | (zmsk<<4) | (ymsk<<2) | (xmsk<<0);
    }

    return(indexed | neg | (msk<<12) | (mux<<8) | add);
}

//---------------------------------------------------------------------------

void opcode
(
    PKELVIN_MICRO_PROGRAM pProgram,
    char *s1,
    char *s2
)
{
    long i,j,iflag,mflag,flog,loop,d1,d2,pp[10],pm,mux;
    long neg,msk,add,dubl,faddr;
    long count,start;
    char a[256];
    t_CheopsUcode *ucode;

    ucode = &(pProgram->ucode[pProgram->length]);

    // default fields
    ucode->mac = NV_IGRAPH_XF_V_NOP;
    ucode->ilu = NV_IGRAPH_XF_S_NOP;
    ucode->ca  = 0;
    ucode->va  = 0;
    ucode->ane = 0;
    ucode->axs = CSW_X;
    ucode->ays = CSW_Y;
    ucode->azs = CSW_Z;
    ucode->aws = CSW_W;
    ucode->amx = MX_R;
    ucode->arr = 0;
    ucode->bne = 0;
    ucode->bxs = CSW_X;
    ucode->bys = CSW_Y;
    ucode->bzs = CSW_Z;
    ucode->bws = CSW_W;
    ucode->bmx = MX_R;
    ucode->brr = 0;
    ucode->cne = 0;
    ucode->cxs = CSW_X;
    ucode->cys = CSW_Y;
    ucode->czs = CSW_Z;
    ucode->cws = CSW_W;
    ucode->cmx = MX_R;
    ucode->crr = 0;
    ucode->rw  = 7;
    ucode->rwm = 0;
    ucode->oc  = 0x1ff;
    ucode->om  = OM_MAC;
    ucode->eos = 0;
    ucode->cin = 0;
    ucode->swm = 0;

    for (i=0; i<10; i++)
        pp[i] = 0;

    /********************************/
    /* one or two instructions      */
    /********************************/
    dubl = 0;
    if (s1[0] != '\0' && s2[0] != '\0')
        dubl = 1;

    /********************************/
    /* s1 processing                */
    /********************************/
    if (s1[0] != '\0')
        for (pm=0,i=3,loop=0; loop<5; loop++) {
            flog = j = 0;
            while (s1[i] != ',' && s1[i] != '\0') {
                if (s1[i] == '{')
                    pm = DST_MASK;
                if (s1[i] == '}') {
                    flog = DST_MASK;
                    pm = 0;
                }
                if (s1[i] == '{' || s1[i] == '}')
                    i++;
                else
                    a[j++] = s1[i++];

                if (j >= 200)
                    assert(0);
            }
            a[j] = '\0';

            d1 = readit(a,(pm?1:0)|(loop==0)|(flog?1:0));

            if (d1 != 0) {
                d1 |= pm | flog;
                if (loop == 0)
                    d1 |= DST_MASK;
            }

            pp[loop] = d1;
            if (s1[i] != '\0')
                i++;
        }

    /********************************/
    /* s2 processing                */
    /********************************/
    if (s2[0] != '\0')
        for (pm=0,i=3,loop=6; loop<10; loop++) {
            flog = j = 0;
            while (s2[i] != ',' && s2[i] != '\0') {
                if (s2[i] == '{')
                    pm = DST_MASK;
                if (s2[i] == '}') {
                    flog = DST_MASK;
                    pm = 0;
                }
                if (s2[i] == '{' || s2[i] == '}')
                    i++;
                else
                    a[j++] = s2[i++];

                if (j >= 200)
                    assert(0);
            }
            a[j] = '\0';

            d2 = readit(a,(pm?1:0)|(loop==6)|(flog?1:0));

            if (d2 != 0) {
                d2 |= pm | flog;
                if (loop == 6)
                    d2 |= DST_MASK;
            }

            pp[loop] = d2;
            if (s2[i] != '\0')
                i++;
        }

    /*** sign check ***/
    for (i=0; i<10; i++)
        if ((pp[i]&DST_MASK) && (pp[i]&SGN_MASK))
            assert(0);

        /********************************/
        /* mac/ilu processing           */
        /********************************/
    mflag = 0;
    iflag = 0;
    if (strstr(s1,"NOP")) {
        SET_MAC(ucode,NV_IGRAPH_XF_V_NOP);
    }
    else if (strstr(s1,"MOV")) {
        SET_MAC(ucode,NV_IGRAPH_XF_V_MOV); mflag = 1;
    }
    else if (strstr(s1,"RCP")) {
        SET_ILU(ucode,NV_IGRAPH_XF_S_RCP); iflag = 1;
    }
    else if (strstr(s1,"RCC")) {
        SET_ILU(ucode,NV_IGRAPH_XF_S_RCC); iflag = 1;
    }
    else if (strstr(s1,"RSQ")) {
        SET_ILU(ucode,NV_IGRAPH_XF_S_RSQ); iflag = 1;
    }
    else if (strstr(s1,"MUL")) {
        SET_MAC(ucode,NV_IGRAPH_XF_V_MUL); mflag = 1;
    }
    else if (strstr(s1,"ADD")) {
        SET_MAC(ucode,NV_IGRAPH_XF_V_ADD); mflag = 1;
    }
    else if (strstr(s1,"MAD")) {
        SET_MAC(ucode,NV_IGRAPH_XF_V_MAD); mflag = 1;
    }
    else if (strstr(s1,"DP3")) {
        SET_MAC(ucode,NV_IGRAPH_XF_V_DP3); mflag = 1;
    }
    else if (strstr(s1,"DPH")) {
        SET_MAC(ucode,NV_IGRAPH_XF_V_DPH); mflag = 1;
    }
    else if (strstr(s1,"DP4")) {
        SET_MAC(ucode,NV_IGRAPH_XF_V_DP4); mflag = 1;
    }
    else if (strstr(s1,"DST")) {
        SET_MAC(ucode,NV_IGRAPH_XF_V_DST); mflag = 1;
    }
    else if (strstr(s1,"MIN")) {
        SET_MAC(ucode,NV_IGRAPH_XF_V_MIN); mflag = 1;
    }
    else if (strstr(s1,"MAX")) {
        SET_MAC(ucode,NV_IGRAPH_XF_V_MAX); mflag = 1;
    }
    else if (strstr(s1,"SLT")) {
        SET_MAC(ucode,NV_IGRAPH_XF_V_SLT); mflag = 1;
    }
    else if (strstr(s1,"SGE")) {
        SET_MAC(ucode,NV_IGRAPH_XF_V_SGE); mflag = 1;
    }
    else if (strstr(s1,"ARL")) {
        SET_MAC(ucode,NV_IGRAPH_XF_V_ARL); mflag = 1;
    }
    else if (strstr(s1,"EXP")) {
        SET_ILU(ucode,NV_IGRAPH_XF_S_EXP); iflag = 1;
    }
    else if (strstr(s1,"LOG")) {
        SET_ILU(ucode,NV_IGRAPH_XF_S_LOG); iflag = 1;
    }
    else if (strstr(s1,"LIT")) {
        SET_ILU(ucode,NV_IGRAPH_XF_S_LIT); iflag = 1;
    }
    else if (strstr(s1,"IMV")) {
        SET_ILU(ucode,NV_IGRAPH_XF_S_MOV); iflag = 1;
    }
    else assert(0);

    if (iflag && dubl)
        assert(0);

    if (s2[0] != '\0') {
        if (strstr(s2,"NOP")) {
            SET_ILU(ucode,NV_IGRAPH_XF_S_NOP); iflag =1;
        }
        else if (strstr(s2,"RCP")) {
            SET_ILU(ucode,NV_IGRAPH_XF_S_RCP); iflag =1;
        }
        else if (strstr(s2,"RCC")) {
            SET_ILU(ucode,NV_IGRAPH_XF_S_RCC); iflag =1;
        }
        else if (strstr(s2,"RSQ")) {
            SET_ILU(ucode,NV_IGRAPH_XF_S_RSQ); iflag =1;
        }
        else if (strstr(s2,"EXP")) {
            SET_ILU(ucode,NV_IGRAPH_XF_S_EXP); iflag =1;
        }
        else if (strstr(s2,"LOG")) {
            SET_ILU(ucode,NV_IGRAPH_XF_S_LOG); iflag =1;
        }
        else if (strstr(s2,"LIT")) {
            SET_ILU(ucode,NV_IGRAPH_XF_S_LIT); iflag =1;
        }
        else if (strstr(s2,"IMV")) {
            SET_ILU(ucode,NV_IGRAPH_XF_S_MOV); iflag =1;
        }
        else assert(0);
    }

    // VA
    for (flog=i=0; i<10; i++) {
        add = (pp[i]>> 0) & 0xff;

        if (((pp[i] & MUX_MASK)>>8) == MX_V) {
            if (pp[i] & DST_MASK)
                assert(0);
            if (flog && add != faddr)
                assert(0);

            SET_VA(ucode,add);
            flog = 1;
            faddr = add;
        }
    }

    /*** CA,CIN ***/
    for (flog=i=0; i<10; i++) {
        add = pp[i] & ADD_MASK;

        if (((pp[i] & MUX_MASK)>>8) == MX_C && !(pp[i] & DST_MASK)) {
            if (flog && add != faddr)
                assert(0);

            SET_CA(ucode,add);
            if (pp[i]&IDX_MASK)
                SET_CIN(ucode,1);
            flog = 1;
            faddr = add;
        }
    }

    /*** AMUX ***/
    if (mflag) {
        for (count=i=0; i<6; i++) {
            add =  pp[i] & ADD_MASK;
            mux = (pp[i] & MUX_MASK)>>8;
            msk = (pp[i] & SWZ_MASK)>>12;
            neg = (pp[i] & SGN_MASK) ? 1 : 0;

            if (pp[i] && !(pp[i]&DST_MASK)) {
                count++;

                if (count == 1) {
                    SET_AMX(ucode,mux);
                    SET_AXS(ucode,(msk>>0)&3);
                    SET_AYS(ucode,(msk>>2)&3);
                    SET_AZS(ucode,(msk>>4)&3);
                    SET_AWS(ucode,(msk>>6)&3);
                    SET_ANE(ucode,neg);
                    if (mux == MX_R)
                        SET_ARR(ucode,add);
                }
            }
        }
    }

    /*** BMX, CMX ***/
    if (mflag) {
        for (count=0,i=0; i<6; i++) {
            add =  pp[i] & ADD_MASK;
            mux = (pp[i] & MUX_MASK)>>8;
            msk = (pp[i] & SWZ_MASK)>>12;
            neg = (pp[i] & SGN_MASK) ? 1 : 0;

            if (pp[i] && !(pp[i]&DST_MASK)) {
                count++;

                if (count == 2) {
                    if (strstr(s1,"MUL") || strstr(s1,"MAD") || strstr(s1,"DP3") || strstr(s1,"DPH") || strstr(s1,"DP4") ||
                        strstr(s1,"DST") || strstr(s1,"MIN") || strstr(s1,"MAX") || strstr(s1,"SLT") || strstr(s1,"SGE")) {
                        SET_BMX(ucode,mux);
                        SET_BXS(ucode,(msk>>0)&3);
                        SET_BYS(ucode,(msk>>2)&3);
                        SET_BZS(ucode,(msk>>4)&3);
                        SET_BWS(ucode,(msk>>6)&3);
                        SET_BNE(ucode,neg);
                        if (mux == MX_R)
                            SET_BRR(ucode,add);
                    }
                }

                if ((count == 2 && strstr(s1,"ADD")) || (count == 3 && (strstr(s1,"MAD")))) {
                    SET_CMX(ucode,mux);
                    SET_CXS(ucode,(msk>>0)&3);
                    SET_CYS(ucode,(msk>>2)&3);
                    SET_CZS(ucode,(msk>>4)&3);
                    SET_CWS(ucode,(msk>>6)&3);
                    SET_CNE(ucode,neg);
                    if (mux == MX_R)
                        SET_CRR(ucode,add);
                }
            }
        }
    }

    /*** CMX ***/
    if (iflag) {
        start = (dubl ? 6 : 0);

        for (i=start; i<10; i++) {
            add =  pp[i] & ADD_MASK;
            mux = (pp[i] & MUX_MASK)>>8;
            msk = (pp[i] & SWZ_MASK)>>12;
            neg = (pp[i] & SGN_MASK) ? 1 : 0;

            if (pp[i] && !(pp[i]&DST_MASK)) {
                SET_CMX(ucode,mux);
                SET_CXS(ucode,(msk>>0)&3);
                SET_CYS(ucode,(msk>>2)&3);
                SET_CZS(ucode,(msk>>4)&3);
                SET_CWS(ucode,(msk>>6)&3);
                SET_CNE(ucode,neg);
                if (mux == MX_R)
                    SET_CRR(ucode,add);

                break;
            }
        }
    }

    /*** RW, RWM, SWM ***/
    for (count=i=0; i<10; i++) {
        add =  pp[i] & ADD_MASK;
        mux = (pp[i] & MUX_MASK)>>8;
        msk = (pp[i] & SWZ_MASK)>>12;

        if (pp[i] && (pp[i]&DST_MASK) && (mux == MX_R)) {
            if (i<6) {
                if (count > 1)
                    assert(0);
                count++;

                SET_RW(ucode,add);

                if (mflag)
                    SET_RWM(ucode,msk);
                else if (iflag)
                    SET_SWM(ucode,msk);
                else
                    assert(0);
            }
            else {
                if (!dubl)
                    assert(0);
                if (add != 1)
                    assert(0);

                SET_SWM(ucode,msk);
            }
        }
    }

    /*** OC, OM, OWM ***/
    for (count=i=0; i<10; i++) {
        mux = (pp[i] & MUX_MASK)>>8;

        if ((pp[i]&DST_MASK) && (mux != MX_R)) {
            add =  pp[i] & ADD_MASK;
            msk = (pp[i] & SWZ_MASK)>>12;

            if (count)
                assert(0);

            SET_OWM(ucode,msk);
            if (i < 6 && mflag)
                SET_OM(ucode,OM_MAC);
            else
                SET_OM(ucode,OM_ILU);

            if (mux == MX_O) {
                count = 1;
                pProgram->outwri = 1;
                SET_OC(ucode,(0x100|add));
            }
            else if (mux == MX_C) {
                count = 1;
                pProgram->ctxwri = 1;
                SET_OC(ucode,add);
            }
            else
                assert(0);
        }
    }

    (pProgram->length)++;
}

//---------------------------------------------------------------------------

void nvKelvinInitProgram
(
    PKELVIN_MICRO_PROGRAM pProgram
)
{
    pProgram->ctxwri = 0;
    pProgram->outwri = 0;
    pProgram->length = 0;
}

//---------------------------------------------------------------------------

void nvKelvinParseProgram
(
    PKELVIN_MICRO_PROGRAM pProgram,
    // GLenum pType,
    // GLuint nid,
    char *s
)
{
    char  t[256], u[256];
    DWORD i, j;

    // check for header %!VP1.0
    if ((s[0] != '%') ||
        (s[1] != '!') ||
        (s[2] != 'V') ||
        (s[3] != 'P') ||
        (s[4] != '1') ||
        (s[5] != '.') ||
        (s[6] != '0')) {
        nvAssert(0);
    }

    // parse program
    for (i=7; s[i]!='\0'; i++) {

        for (j=0; s[i]!=':'&&s[i]!=';'&&s[i]!='\0'; i++)
            if (s[i]!=' ' && s[i]!='\t')
                t[j++] = s[i];

        t[j++] = ';';
        t[j++] = '\0';

        u[0] = '\0';
        if (s[i] == ':') {
            i++;
            for (j=0; s[i]!=';'&&s[i]!='\0'; i++)
                if (s[i]!=' ' && s[i]!='\t')
                    u[j++] = s[i];

            u[j++] = ';';
            u[j++] = '\0';
        }

        for (; (s[i]<'A' || s[i]>'Z') && s[i]!='\0'; i++)
            ;
        i--;

        opcode (pProgram, t, u);
    }

    // set end bit
    pProgram->ucode[pProgram->length-1].eos = 1;

    if (pProgram->length > 128) {
        nvAssert(0);
    }
}

//---------------------------------------------------------------------------

void nvKelvinDownloadProgram
(
    PNVD3DCONTEXT         pContext,
    PKELVIN_MICRO_PROGRAM pProgram,
    DWORD                 dwStartAddress
)
{
    long i;
    t_CheopsUcode *ucode;

    // program load address
    pContext->hwState.kelvin.set1 (NV097_SET_TRANSFORM_PROGRAM_LOAD, dwStartAddress);

    // load program
    for (i=0; i < pProgram->length; i++) {
        ucode = &(pProgram->ucode[i]);
        pContext->hwState.kelvin.set4 (NV097_SET_TRANSFORM_PROGRAM(0),
                                       PGM_UWORDX(ucode), PGM_UWORDY(ucode),
                                       PGM_UWORDZ(ucode), PGM_UWORDW(ucode));
    }
}

//---------------------------------------------------------------------------

void nvKelvinDownloadProgram
(
    PNVD3DCONTEXT        pContext,
    VertexProgramOutput *pProgramOutput,
    DWORD                dwStartAddress
)
{
    nvAssert(pContext);
    nvAssert(pProgramOutput);

    vtxpgmInstPacked *pInst = (vtxpgmInstPacked *) pProgramOutput->residentProgram;

    // program load address
    pContext->hwState.kelvin.set1 (NV097_SET_TRANSFORM_PROGRAM_LOAD, dwStartAddress);

    // load program
    for (int i = 0; i < pProgramOutput->residentNumInstructions; i++) {
        pContext->hwState.kelvin.set4 (NV097_SET_TRANSFORM_PROGRAM(0),
                                    pInst[i].x, pInst[i].y,
                                    pInst[i].z, pInst[i].w);
    }
}

//---------------------------------------------------------------------------

// load constants for use by the user vertex program

void nvKelvinDownloadConstants
(
    PNVD3DCONTEXT pContext
)
{
    pContext->hwState.kelvin.set1 (NV097_SET_TRANSFORM_CONSTANT_LOAD, __GL_KELVIN_FIRST_USER_CONSTANT_REGISTER);
    for (DWORD i=0; i < D3DVS_CONSTREG_MAX_V1_1; i++) {
        nvAssert(pContext->pVShaderConsts);
        VSHADERREGISTER *pConst = &pContext->pVShaderConsts->vertexShaderConstants[i];
        pContext->hwState.kelvin.set4f (NV097_SET_TRANSFORM_CONSTANT(0),
                                        pConst->x, pConst->y, pConst->z, pConst->w);
    }
}

//---------------------------------------------------------------------------

// parse D3D-style vertex shader code into kelvin microcode

DWORD KELVIN_BASE_REG(DWORD type)
{
    switch (type & D3DSP_REGTYPE_MASK)
    {
        case D3DSPR_INPUT:
            return VA_0;
            break;
        case D3DSPR_RASTOUT:
            if ((type & D3DSP_REGNUM_MASK )==0) {
                return VR_0;
            } else {
                return VR_4;
            }
            break;
        case D3DSPR_ATTROUT:
            return VR_1;
            break;
        case D3DSPR_TEXCRDOUT:
            return VR_7;
            break;
        case D3DSPR_ADDR:
            return ARL;
            break;
        case D3DSPR_CONST:
            return PR_0;
            break;
        case D3DSPR_TEMP:
            return TR_0;
            break;
        default:
            return 0xDEADBEEF;
            break;
    }
}

Register_t KELVIN_ENUMERATED_REG (DWORD token)
{
    DWORD final;
    if ((token & D3DSP_REGTYPE_MASK) == D3DSPR_RASTOUT) {
        // psz, fog, pts
        if ((token & D3DSP_REGNUM_MASK) == 0) {
            final = VR_0;
        } else {
            final = VR_4;
        }
        final += (DWORD)(token & D3DSP_REGNUM_MASK);
    } else {
        // everything else
        final = KELVIN_BASE_REG(token);
        final += (DWORD)(token & D3DSP_REGNUM_MASK);
        if (final > ARL) {
            DPF("Vertex Shader register index out of range");
            nvAssert(0);
            final = 0;
        }
    }
#ifdef DEBUG
    // debug stuff
    if (final <= VA_15) {
        DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, "VA_%02d", final - VA_0);
    } else if (final <= VR_14) {
        DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, "VR_%02d", final - VR_0);
    } else if (final <= PR_95) {
        DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, "PR_%02d", final - PR_0);
    } else if (final <= TR_15) {
        DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, "TR_%02d", final - TR_0);
    } else if (final == ARL) {
        DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, "ARL");
    } else {
        DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, "Unknown reg %d", final);
    }
#endif
    return (Register_t)final;
}

static char dbgMaskChar[4] = { 'x', 'y', 'z', 'w' };

char getDbgScalarMask(DWORD mask)
{
    return dbgMaskChar[mask & 0x03];
}

DWORD* getDbgVectorMask(DWORD mask)
{
    static DWORD dwResult;
    dwResult = (dbgMaskChar[(mask >> 0) & 0x03] << 0)
             | (dbgMaskChar[(mask >> 2) & 0x03] << 8)
             | (dbgMaskChar[(mask >> 4) & 0x03] << 16)
             | (dbgMaskChar[(mask >> 6) & 0x03] << 24);
    return &dwResult;
}

DWORD* getDbgWriteMask(DWORD mask)
{
    static DWORD dwResult;
    dwResult = (((mask & 1) ? dbgMaskChar[0] : ' ') << 0)
             | (((mask & 2) ? dbgMaskChar[1] : ' ') << 8)
             | (((mask & 4) ? dbgMaskChar[2] : ' ') << 16)
             | (((mask & 8) ? dbgMaskChar[3] : ' ') << 24);
    return &dwResult;
}

#define KELVIN_SET_SWIZZLED_SRC_REG(swizreg, token)                                                        \
{                                                                                                          \
    DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, ", ");                                                        \
    swizreg.Signed      = BYTE((token & D3DSP_SRCMOD_MASK) >> D3DSP_SRCMOD_SHIFT);                         \
    DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, "%c", (swizreg.Signed ? '-' : '+'));                          \
    swizreg.reg.reg     = KELVIN_ENUMERATED_REG(token);                                                    \
    swizreg.reg.AddrReg = BYTE((token & D3DVS_ADDRESSMODE_MASK) >> D3DVS_ADDRESSMODE_SHIFT);               \
    if (swizreg.reg.AddrReg) { swizreg.reg.addrRegOffset = swizreg.reg.reg - PR_0;                         \
                               DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, "[+a0]"); }                        \
    swizreg.com4        = BYTE((token & D3DVS_SWIZZLE_MASK) >> D3DVS_SWIZZLE_SHIFT);                       \
    DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, ".%4.4s", getDbgVectorMask(swizreg.com4));                    \
}

#define KELVIN_SET_SCALAR_SRC_REG_X(scalarreg, token)                                                      \
{                                                                                                          \
    DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, ", ");                                                        \
    scalarreg.Signed      = BYTE((token & D3DSP_SRCMOD_MASK) >> D3DSP_SRCMOD_SHIFT);                       \
    DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, "%c", (scalarreg.Signed ? '-' : '+'));                        \
    scalarreg.reg.reg     = KELVIN_ENUMERATED_REG(token);                                                  \
    scalarreg.reg.AddrReg = BYTE((token & D3DVS_ADDRESSMODE_MASK) >> D3DVS_ADDRESSMODE_SHIFT);             \
    if (scalarreg.reg.AddrReg) { scalarreg.reg.addrRegOffset = scalarreg.reg.reg - PR_0;                   \
                                 DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, "[+a0]"); }                      \
    scalarreg.com         = Component_t((((token & D3DVS_SWIZZLE_MASK) >> D3DVS_SWIZZLE_SHIFT) >> 0) & 3); \
    DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, ".%-4c", getDbgScalarMask(scalarreg.com));                    \
}

#define KELVIN_SET_SCALAR_SRC_REG_Y(scalarreg, token)                                                      \
{                                                                                                          \
    DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, ", ");                                                        \
    scalarreg.Signed      = BYTE((token & D3DSP_SRCMOD_MASK) >> D3DSP_SRCMOD_SHIFT);                       \
    DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, "%c", (scalarreg.Signed ? '-' : '+'));                        \
    scalarreg.reg.reg     = KELVIN_ENUMERATED_REG(token);                                                  \
    scalarreg.reg.AddrReg = BYTE((token & D3DVS_ADDRESSMODE_MASK) >> D3DVS_ADDRESSMODE_SHIFT);             \
    if (scalarreg.reg.AddrReg) { scalarreg.reg.addrRegOffset = scalarreg.reg.reg - PR_0;                   \
                                 DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, "[+a0]"); }                      \
    scalarreg.com         = Component_t((((token & D3DVS_SWIZZLE_MASK) >> D3DVS_SWIZZLE_SHIFT) >> 2) & 3); \
    DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, ".%-4c", getDbgScalarMask(scalarreg.com));                    \
}

#define KELVIN_SET_SCALAR_SRC_REG_Z(scalarreg, token)                                                      \
{                                                                                                          \
    DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, ", ");                                                        \
    scalarreg.Signed      = BYTE((token & D3DSP_SRCMOD_MASK) >> D3DSP_SRCMOD_SHIFT);                       \
    DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, "%c", (scalarreg.Signed ? '-' : '+'));                        \
    scalarreg.reg.reg     = KELVIN_ENUMERATED_REG(token);                                                  \
    scalarreg.reg.AddrReg = BYTE((token & D3DVS_ADDRESSMODE_MASK) >> D3DVS_ADDRESSMODE_SHIFT);             \
    if (scalarreg.reg.AddrReg) { scalarreg.reg.addrRegOffset = scalarreg.reg.reg - PR_0;                   \
                                 DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, "[+a0]"); }                      \
    scalarreg.com         = Component_t((((token & D3DVS_SWIZZLE_MASK) >> D3DVS_SWIZZLE_SHIFT) >> 4) & 3); \
    DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, ".%-4c", getDbgScalarMask(scalarreg.com));                    \
}

#define KELVIN_SET_SCALAR_SRC_REG_W(scalarreg, token)                                                      \
{                                                                                                          \
    DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, ", ");                                                        \
    scalarreg.Signed      = BYTE((token & D3DSP_SRCMOD_MASK) >> D3DSP_SRCMOD_SHIFT);                       \
    DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, "%c", (scalarreg.Signed ? '-' : '+'));                        \
    scalarreg.reg.reg     = KELVIN_ENUMERATED_REG(token);                                                  \
    scalarreg.reg.AddrReg = BYTE((token & D3DVS_ADDRESSMODE_MASK) >> D3DVS_ADDRESSMODE_SHIFT);             \
    if (scalarreg.reg.AddrReg) { scalarreg.reg.addrRegOffset = scalarreg.reg.reg - PR_0;                   \
                                 DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, "[+a0]"); }                      \
    scalarreg.com         = Component_t((((token & D3DVS_SWIZZLE_MASK) >> D3DVS_SWIZZLE_SHIFT) >> 6) & 3); \
    DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, ".%-4c", getDbgScalarMask(scalarreg.com));                    \
}

#define KELVIN_SET_MASKED_DST_REG(dstreg, token)                                                    \
{                                                                                                   \
    DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, " ");                                                  \
    dstreg.reg  = KELVIN_ENUMERATED_REG(token);                                                     \
    dstreg.mask = (BYTE) ((token & D3DSP_WRITEMASK_ALL) >> 16);                                     \
    DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, ".%4.4s", getDbgWriteMask(dstreg.mask));               \
}
// should really be:
//    dstreg.mask = (token & D3DSP_WRITEMASK_MASK) >> D3DSP_WRITEMASK_SHIFT;

#define KELVIN_SET_ARL_OP(op,pinstruc,pcode)                                                        \
{                                                                                                   \
    pinstruc->arl_op.opclass = CLASS_ARL;                                                           \
    pinstruc->arl_op.opcode  = op;                                                                  \
    KELVIN_SET_SCALAR_SRC_REG_X (pinstruc->arl_op.src, pcode[1]);                                   \
    pcode += 2;                                                                                     \
}

#define KELVIN_SET_VECTOR_OP(op,pinstruc,pcode)                                                     \
{                                                                                                   \
    pinstruc->vector_op.opclass = CLASS_VECTOR;                                                     \
    pinstruc->vector_op.opcode  = op;                                                               \
    KELVIN_SET_MASKED_DST_REG   (pinstruc->vector_op.dst, pcode[0]);                                \
    KELVIN_SET_SWIZZLED_SRC_REG (pinstruc->vector_op.src, pcode[1]);                                \
    pcode += 2;                                                                                     \
}

#define KELVIN_SET_SCALAR_OP(op,pinstruc,pcode)                                                     \
{                                                                                                   \
    pinstruc->scalar_op.opclass = CLASS_SCALAR;                                                     \
    pinstruc->scalar_op.opcode  = op;                                                               \
    KELVIN_SET_MASKED_DST_REG (pinstruc->scalar_op.dst, pcode[0]);                                  \
    KELVIN_SET_SCALAR_SRC_REG_W (pinstruc->scalar_op.src, pcode[1]);                                \
    pcode += 2;                                                                                     \
}

#define KELVIN_SET_BINARY_OP(op,pinstruc,pcode)                                                     \
{                                                                                                   \
    pinstruc->bin_op.opclass = CLASS_BIN;                                                           \
    pinstruc->bin_op.opcode  = op;                                                                  \
    KELVIN_SET_MASKED_DST_REG   (pinstruc->bin_op.dst,  pcode[0]);                                  \
    KELVIN_SET_SWIZZLED_SRC_REG (pinstruc->bin_op.srcA, pcode[1]);                                  \
    KELVIN_SET_SWIZZLED_SRC_REG (pinstruc->bin_op.srcB, pcode[2]);                                  \
    pcode += 3;                                                                                     \
}

#define KELVIN_SET_TERNARY_OP(op,pinstruc,pcode)                                                    \
{                                                                                                   \
    pinstruc->tri_op.opclass = CLASS_TRI;                                                           \
    pinstruc->tri_op.opcode  = op;                                                                  \
    KELVIN_SET_MASKED_DST_REG   (pinstruc->tri_op.dst,  pcode[0]);                                  \
    KELVIN_SET_SWIZZLED_SRC_REG (pinstruc->tri_op.srcA, pcode[1]);                                  \
    KELVIN_SET_SWIZZLED_SRC_REG (pinstruc->tri_op.srcB, pcode[2]);                                  \
    KELVIN_SET_SWIZZLED_SRC_REG (pinstruc->tri_op.srcC, pcode[3]);                                  \
    pcode += 4;                                                                                     \
}

#define KELVIN_SET_MACRO_4_OP(op,pinstruc,pcode)                                                    \
{                                                                                                   \
    pinstruc[0].bin_op.opclass = CLASS_BIN;                                                         \
    pinstruc[1].bin_op.opclass = CLASS_BIN;                                                         \
    pinstruc[2].bin_op.opclass = CLASS_BIN;                                                         \
    pinstruc[3].bin_op.opclass = CLASS_BIN;                                                         \
    pinstruc[0].bin_op.opcode  = op;                                                                \
    pinstruc[1].bin_op.opcode  = op;                                                                \
    pinstruc[2].bin_op.opcode  = op;                                                                \
    pinstruc[3].bin_op.opcode  = op;                                                                \
    KELVIN_SET_MASKED_DST_REG   (pinstruc[0].bin_op.dst,  pcode[0] & ~D3DSP_WRITEMASK_ALL | D3DSP_WRITEMASK_0); \
    KELVIN_SET_MASKED_DST_REG   (pinstruc[1].bin_op.dst,  pcode[0] & ~D3DSP_WRITEMASK_ALL | D3DSP_WRITEMASK_1); \
    KELVIN_SET_MASKED_DST_REG   (pinstruc[2].bin_op.dst,  pcode[0] & ~D3DSP_WRITEMASK_ALL | D3DSP_WRITEMASK_2); \
    KELVIN_SET_MASKED_DST_REG   (pinstruc[3].bin_op.dst,  pcode[0] & ~D3DSP_WRITEMASK_ALL | D3DSP_WRITEMASK_3); \
    KELVIN_SET_SWIZZLED_SRC_REG (pinstruc[0].bin_op.srcA, pcode[1]);                                \
    KELVIN_SET_SWIZZLED_SRC_REG (pinstruc[1].bin_op.srcA, pcode[1]);                                \
    KELVIN_SET_SWIZZLED_SRC_REG (pinstruc[2].bin_op.srcA, pcode[1]);                                \
    KELVIN_SET_SWIZZLED_SRC_REG (pinstruc[3].bin_op.srcA, pcode[1]);                                \
    KELVIN_SET_SWIZZLED_SRC_REG (pinstruc[0].bin_op.srcB, pcode[2] + 0);                            \
    KELVIN_SET_SWIZZLED_SRC_REG (pinstruc[1].bin_op.srcB, pcode[2] + 1);                            \
    KELVIN_SET_SWIZZLED_SRC_REG (pinstruc[2].bin_op.srcB, pcode[2] + 2);                            \
    KELVIN_SET_SWIZZLED_SRC_REG (pinstruc[3].bin_op.srcB, pcode[2] + 3);                            \
    pcode += 3;                                                                                     \
}

#define KELVIN_SET_MACRO_3_OP(op,pinstruc,pcode)                                                    \
{                                                                                                   \
    pinstruc[0].bin_op.opclass = CLASS_BIN;                                                         \
    pinstruc[1].bin_op.opclass = CLASS_BIN;                                                         \
    pinstruc[2].bin_op.opclass = CLASS_BIN;                                                         \
    pinstruc[0].bin_op.opcode  = op;                                                                \
    pinstruc[1].bin_op.opcode  = op;                                                                \
    pinstruc[2].bin_op.opcode  = op;                                                                \
    KELVIN_SET_MASKED_DST_REG   (pinstruc[0].bin_op.dst,  pcode[0] & ~D3DSP_WRITEMASK_ALL | D3DSP_WRITEMASK_0); \
    KELVIN_SET_MASKED_DST_REG   (pinstruc[1].bin_op.dst,  pcode[0] & ~D3DSP_WRITEMASK_ALL | D3DSP_WRITEMASK_1); \
    KELVIN_SET_MASKED_DST_REG   (pinstruc[2].bin_op.dst,  pcode[0] & ~D3DSP_WRITEMASK_ALL | D3DSP_WRITEMASK_2); \
    KELVIN_SET_SWIZZLED_SRC_REG (pinstruc[0].bin_op.srcA, pcode[1]);                                \
    KELVIN_SET_SWIZZLED_SRC_REG (pinstruc[1].bin_op.srcA, pcode[1]);                                \
    KELVIN_SET_SWIZZLED_SRC_REG (pinstruc[2].bin_op.srcA, pcode[1]);                                \
    KELVIN_SET_SWIZZLED_SRC_REG (pinstruc[0].bin_op.srcB, pcode[2] + 0);                            \
    KELVIN_SET_SWIZZLED_SRC_REG (pinstruc[1].bin_op.srcB, pcode[2] + 1);                            \
    KELVIN_SET_SWIZZLED_SRC_REG (pinstruc[2].bin_op.srcB, pcode[2] + 2);                            \
    pcode += 3;                                                                                     \
}

#define KELVIN_SET_MACRO_2_OP(op,pinstruc,pcode)                                                    \
{                                                                                                   \
    pinstruc[0].bin_op.opclass = CLASS_BIN;                                                         \
    pinstruc[1].bin_op.opclass = CLASS_BIN;                                                         \
    pinstruc[0].bin_op.opcode  = op;                                                                \
    pinstruc[1].bin_op.opcode  = op;                                                                \
    KELVIN_SET_MASKED_DST_REG   (pinstruc[0].bin_op.dst,  pcode[0] & ~D3DSP_WRITEMASK_ALL | D3DSP_WRITEMASK_0); \
    KELVIN_SET_MASKED_DST_REG   (pinstruc[1].bin_op.dst,  pcode[0] & ~D3DSP_WRITEMASK_ALL | D3DSP_WRITEMASK_1); \
    KELVIN_SET_SWIZZLED_SRC_REG (pinstruc[0].bin_op.srcA, pcode[1]);                                \
    KELVIN_SET_SWIZZLED_SRC_REG (pinstruc[1].bin_op.srcA, pcode[1]);                                \
    KELVIN_SET_SWIZZLED_SRC_REG (pinstruc[0].bin_op.srcB, pcode[2] + 0);                            \
    KELVIN_SET_SWIZZLED_SRC_REG (pinstruc[1].bin_op.srcB, pcode[2] + 1);                            \
    pcode += 3;                                                                                     \
}

void MarkResultReg (unsigned char* pos, MaskedDstReg_Rec dst)
{
    if (dst.reg >= VR_0 && dst.reg <= VR_14)
    {
        pos[dst.reg-VR_0] |= dst.mask;
    }
}

void ExpMacro (PKELVIN_PROGRAM pProgram, DWORD dwInstruction, DWORD *pcode)
{
    pProgram->code[dwInstruction + 0].scalar_op.opclass         = CLASS_SCALAR;
    pProgram->code[dwInstruction + 0].scalar_op.opcode          = OP_EXP;
    KELVIN_SET_MASKED_DST_REG   (pProgram->code[dwInstruction + 1].vector_op.dst, pcode[0]);
    KELVIN_SET_SCALAR_SRC_REG_W (pProgram->code[dwInstruction + 0].scalar_op.src, pcode[1]);
    pProgram->code[dwInstruction + 0].scalar_op.dst.reg         = TR_8;
    pProgram->code[dwInstruction + 0].scalar_op.dst.mask        = 4; // write z only

    pProgram->code[dwInstruction + 1].scalar_op.opclass         = CLASS_VECTOR;
    pProgram->code[dwInstruction + 1].scalar_op.opcode          = OP_MOV;
    pProgram->code[dwInstruction + 1].vector_op.src.reg.reg     = TR_8;
    pProgram->code[dwInstruction + 1].vector_op.src.reg.AddrReg = 0x0;
    pProgram->code[dwInstruction + 1].vector_op.src.com4        = 0xAA; // get from z
    pProgram->code[dwInstruction + 1].vector_op.src.Signed      = 0x0;
}

void LogMacro (PKELVIN_PROGRAM pProgram, DWORD dwInstruction, DWORD *pcode)
{
    pProgram->code[dwInstruction + 0].scalar_op.opclass         = CLASS_SCALAR;
    pProgram->code[dwInstruction + 0].scalar_op.opcode          = OP_LOG;
    KELVIN_SET_MASKED_DST_REG   (pProgram->code[dwInstruction + 1].vector_op.dst, pcode[0]);
    KELVIN_SET_SCALAR_SRC_REG_W (pProgram->code[dwInstruction + 0].scalar_op.src, pcode[1]);
    pProgram->code[dwInstruction + 0].scalar_op.dst.reg         = TR_8;
    pProgram->code[dwInstruction + 0].scalar_op.dst.mask        = 4; // write z only

    pProgram->code[dwInstruction + 1].scalar_op.opclass         = CLASS_VECTOR;
    pProgram->code[dwInstruction + 1].scalar_op.opcode          = OP_MOV;
    pProgram->code[dwInstruction + 1].vector_op.src.reg.reg     = TR_8;
    pProgram->code[dwInstruction + 1].vector_op.src.reg.AddrReg = 0x0;
    pProgram->code[dwInstruction + 1].vector_op.src.com4        = 0xAA; // get from z
    pProgram->code[dwInstruction + 1].vector_op.src.Signed      = 0x0;
}

DWORD FrcMacro (PKELVIN_PROGRAM pProgram, DWORD dwInstruction, DWORD *pCode)
{
    if (pCode[0] & D3DSP_WRITEMASK_0) { // if x is written
        pProgram->code[dwInstruction].scalar_op.opclass         = CLASS_SCALAR;
        pProgram->code[dwInstruction].scalar_op.opcode          = OP_EXP;
        KELVIN_SET_SCALAR_SRC_REG_X (pProgram->code[dwInstruction].scalar_op.src, pCode[1]);
        pProgram->code[dwInstruction].scalar_op.dst.reg         = TR_8;
        pProgram->code[dwInstruction].scalar_op.dst.mask        = 2; // write y only
        dwInstruction++;
        pProgram->code[dwInstruction].scalar_op.opclass         = CLASS_VECTOR;
        pProgram->code[dwInstruction].scalar_op.opcode          = OP_MOV;
        pProgram->code[dwInstruction].vector_op.src.reg.reg     = TR_8;
        pProgram->code[dwInstruction].vector_op.src.reg.AddrReg = 0x0;
        pProgram->code[dwInstruction].vector_op.src.com4        = 0x55; // get from y
        pProgram->code[dwInstruction].vector_op.src.Signed      = 0x0;
        KELVIN_SET_MASKED_DST_REG   (pProgram->code[dwInstruction].vector_op.dst, pCode[0]);
        pProgram->code[dwInstruction].vector_op.dst.mask        = 0x1; // write x only
        dwInstruction++;
    }

    if (pCode[0] & D3DSP_WRITEMASK_1) { // if y is written
        pProgram->code[dwInstruction].scalar_op.opclass         = CLASS_SCALAR;
        pProgram->code[dwInstruction].scalar_op.opcode          = OP_EXP;
        KELVIN_SET_SCALAR_SRC_REG_Y (pProgram->code[dwInstruction].scalar_op.src, pCode[1]);
        KELVIN_SET_MASKED_DST_REG   (pProgram->code[dwInstruction].vector_op.dst, pCode[0]);
        pProgram->code[dwInstruction].scalar_op.dst.mask        = 2; // write y only
        dwInstruction++;
    }

/* MS doesn't want these anymore (for now)
    if (pCode[0] & D3DSP_WRITEMASK_2) { // if z is written
        pProgram->code[dwInstruction].scalar_op.opclass         = CLASS_SCALAR;
        pProgram->code[dwInstruction].scalar_op.opcode          = OP_EXP;
        KELVIN_SET_SCALAR_SRC_REG_Z (pProgram->code[dwInstruction].scalar_op.src, pCode[1]);
        pProgram->code[dwInstruction].scalar_op.dst.reg         = TR_8;
        pProgram->code[dwInstruction].scalar_op.dst.mask        = 2; // write y only
        dwInstruction++;
        pProgram->code[dwInstruction].scalar_op.opclass         = CLASS_VECTOR;
        pProgram->code[dwInstruction].scalar_op.opcode          = OP_MOV;
        pProgram->code[dwInstruction].vector_op.src.reg.reg     = TR_8;
        pProgram->code[dwInstruction].vector_op.src.reg.AddrReg = 0x0;
        pProgram->code[dwInstruction].vector_op.src.com4        = 0x55; // get from y
        pProgram->code[dwInstruction].vector_op.src.Signed      = 0x0;
        KELVIN_SET_MASKED_DST_REG   (pProgram->code[dwInstruction].vector_op.dst, pCode[0]);
        pProgram->code[dwInstruction].vector_op.dst.mask       &= 0x4; // write z only
        dwInstruction++;
    }

    if (pCode[0] & D3DSP_WRITEMASK_3) { // if w is written
        pProgram->code[dwInstruction].scalar_op.opclass         = CLASS_SCALAR;
        pProgram->code[dwInstruction].scalar_op.opcode          = OP_EXP;
        KELVIN_SET_SCALAR_SRC_REG_W (pProgram->code[dwInstruction].scalar_op.src, pCode[1]);
        pProgram->code[dwInstruction].scalar_op.dst.reg         = TR_8;
        pProgram->code[dwInstruction].scalar_op.dst.mask        = 2; // write y only
        dwInstruction++;
        pProgram->code[dwInstruction].scalar_op.opclass         = CLASS_VECTOR;
        pProgram->code[dwInstruction].scalar_op.opcode          = OP_MOV;
        pProgram->code[dwInstruction].vector_op.src.reg.reg     = TR_8;
        pProgram->code[dwInstruction].vector_op.src.reg.AddrReg = 0x0;
        pProgram->code[dwInstruction].vector_op.src.com4        = 0x55; // get from y
        pProgram->code[dwInstruction].vector_op.src.Signed      = 0x0;
        KELVIN_SET_MASKED_DST_REG   (pProgram->code[dwInstruction].vector_op.dst, pCode[0]);
        pProgram->code[dwInstruction].vector_op.dst.mask       &= 0x8; // write w only
        dwInstruction++;
    }
*/
    return dwInstruction - 1;
}

// parse D3D-style vertex shader code into intermediate compiled code

void nvKelvinParseVertexShaderCode
(
    PKELVIN_PROGRAM pProgram,
    ParsedProgram *parsed,
    DWORD *pCode,
    DWORD dwCodeSize
)
{
    DWORD dwHeader, dwToken, dwInstruction;
    Instruction *pInstruction;
    BOOL bDone;

    // read the header
    dwHeader = *pCode;
    pCode++;

    // clear written regs
    for (int i = 0; i < __GL_NUMBER_OF_RESULT_REGISTERS; i++) {
        parsed->resultRegsWritten[i] = DST_NONE_BITS;
    }

    bDone = FALSE;
    dwInstruction = 0;

    while (!bDone) {

        dwToken = *pCode;
        pCode++;
        pInstruction = &(pProgram->code[dwInstruction]);

        switch (dwToken & D3DSI_OPCODE_MASK) {

            case D3DSIO_NOP:
                DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, "%2d NOP ", dwInstruction);
                pInstruction->end_op.opclass = CLASS_END;
                pInstruction->end_op.opcode  = OP_NOP;
                break;
            case D3DSIO_MOV:
                if (KELVIN_BASE_REG(pCode[0]) == ARL) {
                    DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, "%2d ARL ", dwInstruction);
                    KELVIN_SET_ARL_OP (OP_ARL, pInstruction, pCode);
                } else {
                    DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, "%2d MOV ", dwInstruction);
                    KELVIN_SET_VECTOR_OP (OP_MOV, pInstruction, pCode);
                    MarkResultReg (parsed->resultRegsWritten, pInstruction->vector_op.dst);
                }
                break;
            case D3DSIO_ADD:
                DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, "%2d ADD ", dwInstruction);
                KELVIN_SET_BINARY_OP (OP_ADD, pInstruction, pCode);
                MarkResultReg (parsed->resultRegsWritten, pInstruction->bin_op.dst);
                break;
            case D3DSIO_MAD:
                DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, "%2d MAD ", dwInstruction);
                KELVIN_SET_TERNARY_OP (OP_MAD, pInstruction, pCode);
                MarkResultReg (parsed->resultRegsWritten, pInstruction->tri_op.dst);
                break;
            case D3DSIO_MUL:
                DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, "%2d MUL ", dwInstruction);
                KELVIN_SET_BINARY_OP (OP_MUL, pInstruction, pCode);
                MarkResultReg (parsed->resultRegsWritten, pInstruction->bin_op.dst);
                break;
            case D3DSIO_RCP:
                DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, "%2d RCP ", dwInstruction);
                KELVIN_SET_SCALAR_OP (OP_RCP, pInstruction, pCode);
                MarkResultReg (parsed->resultRegsWritten, pInstruction->scalar_op.dst);
                break;
            case D3DSIO_RSQ:
                DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, "%2d RSQ ", dwInstruction);
                KELVIN_SET_SCALAR_OP (OP_RSQ, pInstruction, pCode);
                MarkResultReg (parsed->resultRegsWritten, pInstruction->scalar_op.dst);
                break;
            case D3DSIO_DP3:
                DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, "%2d DP3 ", dwInstruction);
                KELVIN_SET_BINARY_OP (OP_DP3, pInstruction, pCode);
                MarkResultReg (parsed->resultRegsWritten, pInstruction->bin_op.dst);
                break;
            case D3DSIO_DP4:
                DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, "%2d DP4 ", dwInstruction);
                KELVIN_SET_BINARY_OP (OP_DP4, pInstruction, pCode);
                MarkResultReg (parsed->resultRegsWritten, pInstruction->bin_op.dst);
                break;
            case D3DSIO_MIN:
                DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, "%2d MIN ", dwInstruction);
                KELVIN_SET_BINARY_OP (OP_MIN, pInstruction, pCode);
                MarkResultReg (parsed->resultRegsWritten, pInstruction->bin_op.dst);
                break;
            case D3DSIO_MAX:
                DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, "%2d MAX ", dwInstruction);
                KELVIN_SET_BINARY_OP (OP_MAX, pInstruction, pCode);
                MarkResultReg (parsed->resultRegsWritten, pInstruction->bin_op.dst);
                break;
            case D3DSIO_SLT:
                DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, "%2d SLT ", dwInstruction);
                KELVIN_SET_BINARY_OP (OP_SLT, pInstruction, pCode);
                MarkResultReg (parsed->resultRegsWritten, pInstruction->bin_op.dst);
                break;
            case D3DSIO_SGE:
                DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, "%2d SGE ", dwInstruction);
                KELVIN_SET_BINARY_OP (OP_SGE, pInstruction, pCode);
                MarkResultReg (parsed->resultRegsWritten, pInstruction->bin_op.dst);
                break;
            case D3DSIO_EXP:
                DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, "%2d EXP ", dwInstruction);
                ExpMacro(pProgram, dwInstruction, pCode);
                pCode += 2;
                dwInstruction ++;
                break;
            case D3DSIO_LOG:
                DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, "%2d LOG ", dwInstruction);
                LogMacro(pProgram, dwInstruction, pCode);
                pCode += 2;
                dwInstruction ++;
                break;
            case D3DSIO_LIT:
                DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, "%2d LIT ", dwInstruction);
                KELVIN_SET_VECTOR_OP (OP_LIT, pInstruction, pCode);
                MarkResultReg (parsed->resultRegsWritten, pInstruction->vector_op.dst);
                break;
            case D3DSIO_DST:
                DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, "%2d DST ", dwInstruction);
                KELVIN_SET_BINARY_OP (OP_DST, pInstruction, pCode);
                MarkResultReg (parsed->resultRegsWritten, pInstruction->bin_op.dst);
                break;
            case D3DSIO_M4x4:
                DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, "%2d M4x4", dwInstruction);
                KELVIN_SET_MACRO_4_OP (OP_DP4, pInstruction, pCode);
                MarkResultReg (parsed->resultRegsWritten, pInstruction[0].bin_op.dst);
                MarkResultReg (parsed->resultRegsWritten, pInstruction[1].bin_op.dst);
                MarkResultReg (parsed->resultRegsWritten, pInstruction[2].bin_op.dst);
                MarkResultReg (parsed->resultRegsWritten, pInstruction[3].bin_op.dst);
                dwInstruction += 3;
                break;
            case D3DSIO_M3x4:
                DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, "%2d M3x4", dwInstruction);
                KELVIN_SET_MACRO_4_OP (OP_DP3, pInstruction, pCode);
                MarkResultReg (parsed->resultRegsWritten, pInstruction[0].bin_op.dst);
                MarkResultReg (parsed->resultRegsWritten, pInstruction[1].bin_op.dst);
                MarkResultReg (parsed->resultRegsWritten, pInstruction[2].bin_op.dst);
                MarkResultReg (parsed->resultRegsWritten, pInstruction[3].bin_op.dst);
                dwInstruction += 3;
                break;
            case D3DSIO_M4x3:
                DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, "%2d M4x3", dwInstruction);
                KELVIN_SET_MACRO_3_OP (OP_DP4, pInstruction, pCode);
                MarkResultReg (parsed->resultRegsWritten, pInstruction[0].bin_op.dst);
                MarkResultReg (parsed->resultRegsWritten, pInstruction[1].bin_op.dst);
                MarkResultReg (parsed->resultRegsWritten, pInstruction[2].bin_op.dst);
                dwInstruction += 2;
                break;
            case D3DSIO_M3x3:
                DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, "%2d M3x3", dwInstruction);
                KELVIN_SET_MACRO_3_OP (OP_DP3, pInstruction, pCode);
                MarkResultReg (parsed->resultRegsWritten, pInstruction[0].bin_op.dst);
                MarkResultReg (parsed->resultRegsWritten, pInstruction[1].bin_op.dst);
                MarkResultReg (parsed->resultRegsWritten, pInstruction[2].bin_op.dst);
                dwInstruction += 2;
                break;
            case D3DSIO_M3x2:
                DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, "%2d M3x2", dwInstruction);
                KELVIN_SET_MACRO_2_OP (OP_DP3, pInstruction, pCode);
                MarkResultReg (parsed->resultRegsWritten, pInstruction[0].bin_op.dst);
                MarkResultReg (parsed->resultRegsWritten, pInstruction[1].bin_op.dst);
                dwInstruction ++;
                break;
            case D3DSIO_FRC:
                DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, "%2d FRC ", dwInstruction);
                dwInstruction = FrcMacro(pProgram, dwInstruction, pCode);
                pCode += 2;
                break;
            case D3DSIO_EXPP:
                DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, "%2d EXPP", dwInstruction);
                KELVIN_SET_SCALAR_OP (OP_EXP, pInstruction, pCode);
                MarkResultReg (parsed->resultRegsWritten, pInstruction->scalar_op.dst);
                break;
            case D3DSIO_LOGP:
                DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, "%2d LOGP", dwInstruction);
                KELVIN_SET_SCALAR_OP (OP_LOG, pInstruction, pCode);
                MarkResultReg (parsed->resultRegsWritten, pInstruction->scalar_op.dst);
                break;
            case D3DSIO_COMMENT:
                DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, "%2d COMMENT (TODO)", dwInstruction);
                nvAssert(0);
                break;
            case D3DSIO_END:
                DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, "%2d END\r\n", dwInstruction);
                pInstruction->end_op.opclass = CLASS_END;
                pInstruction->end_op.opcode  = OP_END;
                bDone = TRUE;
                break;
            default:
                // unhandled instruction
                DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, "Unknown opcode (%d)", dwToken & D3DSI_OPCODE_MASK);
                nvAssert(0);

        }  // switch

        DPF_LEVEL_PLAIN(NVDBG_LEVEL_VSHADER_INS, "\r\n");
        dwInstruction++;
    }

    // check special case output registers
    if (parsed->resultRegsWritten[VA_FOGC]) {
        // fog may only use .x
        nvAssert(parsed->resultRegsWritten[VA_FOGC] == 1);

        // force it to .x
        parsed->resultRegsWritten[VA_FOGC] = 1;
    }

/*
    // sanity check program output
    for (i = 0; i < 11; i++)
    {
        DWORD dwRegWriteMask = parsed->resultRegsWritten[i];

        // data in this stream?
        if (dwRegWriteMask)
        {
            // valid combination of output registers written?
            if (dwCelsiusMethodDispatch[i][dwRegWriteMask][0] == 0xDEADBEEF) {
                DPF("Vertex Shader - invalid write mask for register %d reset", i);
                nvAssert(0);
                // set the regs written mask to 0 (disable output for this register)
                parsed->resultRegsWritten[i] = 0; // do this for emulation only
            }
        }
    }
*/
    pProgram->dwNumInstructions = dwInstruction;
}
 
#ifdef KPFS

void CKelvinProgramMan::create(DWORD dwInstructions)
{ 
    memset(this,0,sizeof(CKelvinProgramMan));
    m_dwInstructions = dwInstructions;
    if (!ins)
        ins=new CInstr[dwInstructions]();
    nvAssert(ins);
    memset(ins,0,sizeof(CInstr)*dwInstructions);
    for (DWORD i=0;i<dwInstructions;i++) {
        ins[i].index=i;
        ins[i].len=dwInstructions-i;
    }
    DPF_LEVEL(NVDBG_LEVEL_VSHADER_MAN,"shaderman: created\n");
}

void CKelvinProgramMan::destroy()
{ 
    nvAssert(ins);
    if (ins) 
        delete[] ins;
    DPF_LEVEL(NVDBG_LEVEL_VSHADER_MAN,"shaderman: deleted\n");
}

void CKelvinProgramMan::flush()
{
    DWORD   n= m_dwInstructions;
    CInstr* t= ins ? ins : new CInstr[m_dwInstructions]();
    memset(this,0,sizeof(CKelvinProgramMan));
    ins = t; m_dwInstructions = n;
    for (DWORD i=0;i<m_dwInstructions;i++) {
        ins[i].index=i;
        ins[i].len=m_dwInstructions-i;
        ins[i].next = 0;
    }
    DPF_LEVEL(NVDBG_LEVEL_VSHADER_MAN,"shaderman: flushed\n");
}

bool CKelvinProgramMan::find(DWORD handle, DWORD num_instr)
{
    CInstr *f = &ins[0];
    while (f){
        if (f->handle==handle){   
            //check
            if (f->next) {
                nvAssert((f->next->index) == (f->index+f->len));
                nvAssert(f->len ==num_instr);
            }
            m_dwOffset=f->index;
            return true;
        }
        f=f->next;
    }
    return false;
}

void CKelvinProgramMan::add(DWORD handle, DWORD num_instr) 
{
    DWORD    i,  x, sx, px = ~0;
    CInstr  *t, *n, *a, *f = &ins[0];
    //find a place to insert
    while (f) {
        //found a free block   
        if (!f->handle && f->len >= num_instr){
            sx=f->len;
            n=f->next;
            m_dwOffset = f->index;
            goto free_block;
        }
        
        //slide window and compute cost
        t=f; x=0;
        while(num_instr > x && t) {
            x+=t->len;
            t=t->next;
        }
        
        if (x<px && num_instr <= x) {
            sx=px=x;
            n=t;
            m_dwOffset=f->index;
        }
        
        f=f->next;
    }
    
    //insert
    f = &ins[m_dwOffset]; 
    free_block:
    f->handle = handle;
    f->len = num_instr;
    i = f->index+f->len;
    
    if (i<m_dwInstructions) {
        a = &ins[i];
        f->next = a;
        
        if (f->next!=n) {
            a->next = n;
            a->len=sx-f->len;
            a->handle=0;
        }
    }
    else f->next=NULL;
}   

void CKelvinProgramMan::display() 
{
    CInstr* t=&ins[0];
    while(t) {
        for(DWORD i=0;i<t->len;i++) {
            DPF_PLAIN("%3x",t->handle);        
        }       
        t=t->next;
    }
    DPF_PLAIN("\n"); 
}


#define SET_PROGRAM_TYPE(type)                                              \
{                                                                           \
    pContext->hwState.kelvin.set1(NV097_SET_TRANSFORM_EXECUTION_MODE,       \
    DRF_DEF(097, _SET_TRANSFORM_EXECUTION_MODE, _MODE, _PROGRAM) |          \
    DRF_DEF(097, _SET_TRANSFORM_EXECUTION_MODE, _RANGE_MODE, type));        \
    pContext->hwState.kelvin.set1(NV097_SET_TRANSFORM_PROGRAM_CXT_WRITE_EN, \
    DRF_DEF(097, _SET_TRANSFORM_PROGRAM_CXT_WRITE_EN, _V, _READ_ONLY));     \
}


void CKelvinProgramMan::download_special(PNVD3DCONTEXT pContext, PKELVIN_MICRO_PROGRAM pProgram, DWORD handle) {

    DWORD num_instr = pProgram->length;
    nvAssert(num_instr<=m_dwInstructions);
    
    if (!m_pContext)
        m_pContext=pContext;
    else {
        if (m_pContext!=pContext) {
            m_pContext=pContext;
            m_dwOffset=0;
            flush();
            goto fromzero;
        }
        else {
            //early out
            if ((m_dwLastHandle==handle) && (m_pPrevContext == pContext)) { 
                if (m_dwDirty) {
                    SET_PROGRAM_TYPE(_PRIV);
                    m_dwDirty=0;
                }
                return;
            }
                
            m_dwLastHandle=handle;
            m_pPrevContext = pContext; 
        }
    }

    SET_PROGRAM_TYPE(_PRIV);

    //shader already loaded
    if (find(handle,num_instr)) {
        pContext->hwState.kelvin.set1 (NV097_SET_TRANSFORM_PROGRAM_START, m_dwOffset);
        DPF_LEVEL(NVDBG_LEVEL_VSHADER_MAN,"shaderman: Is %d, %d",m_dwOffset,num_instr);
    }
    else {
        add(handle,num_instr);
        fromzero:
        pContext->hwState.kelvin.set1 (NV097_SET_TRANSFORM_PROGRAM_START, m_dwOffset);
        nvKelvinDownloadProgram(pContext, pProgram,m_dwOffset);
        DPF_LEVEL(NVDBG_LEVEL_VSHADER_MAN,"shaderman: Es %d, %d",m_dwOffset,num_instr);
    }
}

void CKelvinProgramMan::download(PNVD3DCONTEXT pContext,  CVertexShader* pVS) {
    
    DWORD num_instr = pVS->m_ProgramOutput.residentNumInstructions;
    DWORD handle = pVS->getHandle();
    
    nvAssert(num_instr<=m_dwInstructions);
    nvAssert(handle!=0xFFFFFFFF && handle!=0xFFFFFFFE); //reserved for passthrough and aa shaders, bug florin if this ever triggers

    if (!m_pContext)
        m_pContext=pContext;
    else {
        if (m_pContext!=pContext) {
            m_pContext=pContext;
            m_dwOffset=0;
            flush();
            goto fromzero;
        }
        else
        {
            //early out
            if ((m_dwLastHandle==handle) && (m_pPrevContext == pContext)) {
                if (m_dwDirty) {
                    SET_PROGRAM_TYPE(_USER);
                    m_dwDirty=0;
                }
                nvKelvinDownloadConstants (pContext);
                return;
            }
            m_dwLastHandle=handle;
            m_pPrevContext = pContext; 
        }
    }

    SET_PROGRAM_TYPE(_USER);
    
    //shader already loaded
    if (find(handle,num_instr)) {
        pContext->hwState.kelvin.set1 (NV097_SET_TRANSFORM_PROGRAM_START, m_dwOffset);
        DPF_LEVEL(NVDBG_LEVEL_VSHADER_MAN,"I %d, %d",m_dwOffset,num_instr);
    }
    else {
        add(handle,num_instr);
        fromzero:
        pContext->hwState.kelvin.set1 (NV097_SET_TRANSFORM_PROGRAM_START, m_dwOffset);
        nvKelvinDownloadProgram (pContext, &pVS->m_ProgramOutput, m_dwOffset);
        DPF_LEVEL(NVDBG_LEVEL_VSHADER_MAN,"E %d, %d",m_dwOffset,num_instr);
    }
    
    nvKelvinDownloadConstants (pContext);
}
#endif

#endif  // NVARCH >= 0x020
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\kelvin\src\nvKelvinPrim.cpp ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// ********************************* Direct 3D ******************************
//
//  Module: nvKelvinPrim.cpp
//      Kelvin primitive rendering routines
//
// **************************************************************************
//
//  History:
//      Craig Duttweiler        26Apr2000         NV20 development
//
// **************************************************************************
#include "nvprecomp.h"

#if (NVARCH >= 0x20)

#ifdef KELVIN_ILC
DWORD UseKelvinILC = 1;     //Temp - set to zero to disable Kelvin compiled inner loops.
#endif

#ifdef PROFILE_INDEX
void nvLogIndexData(DWORD, DWORD, WORD *);
#endif

// switches
#define VERTEX_REUSE

//---------------------------------------------------------------------------
// forward declarations

void nvKelvinDispatchIndexedPrimitiveInline    (PNVD3DCONTEXT       pContext,
                                                DWORD               dwCount,
                                                BOOL                bLegacyStrides);
void nvKelvinDispatchNonIndexedPrimitiveInline (PNVD3DCONTEXT       pContext,
                                                DWORD               dwCount);

//---------------------------------------------------------------------------

void nvKelvinDispatchIndexedPrimitive
(
    NV_INNERLOOP_ARGLIST
)
{
    BOOL bLegacyStrides;

#ifdef FORCE_NULL
    return;
#endif

#ifdef PROFILE_INDEX
    nvLogIndexData(dwDP2Operation, (DWORD)wCount, pIndices);
#endif //PROFILE_INDEX

    // any work?
    if (dwCount == 0) return;

    DDSTATLOGWORDS(D3D_PRIM_COUNT_PARMS, 1, dwCount);
    bLegacyStrides = (pContext->dp2.dwDP2Prim == D3DDP2OP_INDEXEDTRIANGLELIST) ? TRUE : FALSE;

    // book keeping
    if (pContext->pZetaBuffer) {
        pContext->pZetaBuffer->getWrapper()->setCTDrawPrim();
    }

    // lock surfaces for use by the HW
    nvHWLockTextures (pContext);
    nvHWLockStreams (pContext, KELVIN_CAPS_MAX_STREAMS);

#if SYSVB2AGP
    DWORD bAltVBPerfStrategy = ( (pContext->dwEarlyCopyStrategy) || (pContext->dwEarlyCopyStrategy > 0x20));

    if (bAltVBPerfStrategy) {

        if (pContext->dp2.dwDP2Prim == D3DDP2OP_INDEXEDTRIANGLELIST2 && pContext->dp2.dwVertexBufferOffset == 0)
        {
            if (!pContext->sysvb.pSysMemVB)
            {
                DWORD stream = pContext->hwState.pVertexShader->getVAStream(defaultInputRegMap[D3DVSDE_POSITION]);
                CVertexBuffer *pVertexBuffer = pContext->ppDX8Streams[stream];
                if (!pVertexBuffer->cachedhwCanRead())
                {

                    DWORD dwTotalSize = pContext->hwState.pVertexShader->getStride() * pContext->dp2.dwVertexLength;
                    if (dwTotalSize < pDriverData->nvD3DPerfData.dwRecommendedStageBufferSize)   // never fill more than 1/4 at once
                    {
                        pContext->sysvb.dwStreamDMACount = pContext->dwStreamDMACount;
                        pContext->dwStreamDMACount &= 0xffff;
                        // get default VB
                        CVertexBuffer *pDefVertexBuffer = getDC()->defaultVB.getVB();
                        DWORD stride = pContext->hwState.pVertexShader->getStride();

                        pDefVertexBuffer->setVertexStride(stride);

                        // check for space
                        DWORD dwVBOffset = (getDC()->defaultVB.waitForSpace(dwTotalSize + 64 * 12, TRUE) + 32) & ~31;
                        // copy verts
                        nvMemCopy (pDefVertexBuffer->getAddress() + dwVBOffset ,
                                   (DWORD)pVertexBuffer->getAddress(),
                                   dwTotalSize);
                        // set up supertri
                        pDefVertexBuffer->setSuperTriLookAsideBuffer ((void*)((DWORD)pVertexBuffer->getAddress()));
                        pContext->dp2.dwVertexBufferOffsetSave = pContext->dp2.dwVertexBufferOffset;
                        pContext->sysvb.dwDefVBOffset = pContext->dp2.dwVertexBufferOffset = dwVBOffset;

                        pContext->sysvb.pSysMemVB = pVertexBuffer;
                        pContext->sysvb.dwSysMemVBStream = stream;
                        pContext->ppDX8Streams[stream] = pDefVertexBuffer;

                        // unlock vb
                        getDC()->defaultVB.m_dwTotalVerticesSincePut += pContext->dp2.dwVertexLength;
                        if (getDC()->defaultVB.m_dwTotalVerticesSincePut >= 128)
                        {
                            pContext->sysvb.bWriteOffset = TRUE;
                            getDC()->defaultVB.m_dwTotalVerticesSincePut = 0;
                        }
                        getDC()->defaultVB.m_dwCurrentOffset = dwVBOffset + dwTotalSize;

                    }
                }
            }
            else
            {
                pContext->sysvb.dwStreamDMACount = pContext->dwStreamDMACount;
                pContext->dwStreamDMACount &= 0xffff;
                pContext->dp2.dwVertexBufferOffsetSave = pContext->dp2.dwVertexBufferOffset;
                pContext->dp2.dwVertexBufferOffset = pContext->sysvb.dwDefVBOffset;
                pContext->sysvb.pSysMemVB = pContext->ppDX8Streams[pContext->sysvb.dwSysMemVBStream];
                pContext->ppDX8Streams[pContext->sysvb.dwSysMemVBStream] = getDC()->defaultVB.getVB();
            }
        }
    }
#endif //SYSVB2AGP

    // set the vertex sources and if anything has changed, dirty the fvf flag
    if (pContext->hwState.dwVertexOffset != pContext->dp2.dwVertexBufferOffset)
    {
        pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_FVF;
    }

    // ugh.  Special case to set up the combiners for pointsprites..
    if ((pContext->dwRenderState[D3DRS_POINTSPRITEENABLE]) &&
        (pContext->hwState.dwCombinerDP2Prim != pContext->dp2.dwDP2Prim))
    {
        pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_COMBINERS_COLOR;
    }

#ifdef KELVIN_ILC
// ToDo: Insert code to copy SYSMEM VB's to AGP here. Make it work for things other than test 6 & 7.

//     if (!pContext->ppDX8Streams[pContext->pCurrentVShader->getVAStream(defaultInputRegMap[D3DVSDE_POSITION])]->cachedhwCanRead())
//     {
//         __asm int 3
//     }
#endif //KELVIN_ILC

    // set kelvin state (required to get the correct inner loop)
    nvSetKelvinState (pContext);

#ifdef FORCE_INLINE_VERTICES

    nvKelvinDispatchIndexedPrimitiveInline (pContext, dwCount, pIndices, bLegacyStrides);

#else // !FORCE_INLINE_VERTICES

#ifdef KELVIN_ILC
    // get inner loop entry point flags
    DWORD dwFlags = (pContext->dp2.dwDP2Prim & KELVIN_ILMASK_PRIMTYPE)
                  | (bLegacyStrides ? KELVIN_ILFLAG_LEGACY : 0);
#endif KELVIN_ILC


#ifdef KELVIN_ILC

    if (UseKelvinILC)
    {
        if (pContext->dp2.dwIndexStride == 4) {
            goto C_Code;
        }

        if (pContext->hwState.dwInlineVertexStride)
        {
            if ((pContext->hwState.pVertexShader->hasProgram())
             || (NV_NUM_UNIQUE_STREAMS(pContext->dwStreamDMACount) > 1) // asm code doesn't handle multiple streams
             || (NV_NUM_SYSTEM_STREAMS(pContext->dwStreamDMACount) > 1)) {
                goto C_Code;
            }

            if ((dwCount >= KELVIN_SHORT_INDEXED_PRIM_COUNT_CUTOFF) &&
                ((kelvinPrimitiveToPrimitiveMagic[pContext->dp2.dwDP2Prim] & 0x00ffffff) == 0x00030300))
            {
                if (NV_VERTEX_TRANSFORMED(pContext->hwState.pVertexShader)) {
                    dwFlags |= KELVIN_ILFLAG_IX_INL_TRI_LIST;
                }
                else {
                    dwFlags |= KELVIN_ILFLAG_IX_INL_PRIM;
                }
                dwFlags                    |= ((pContext->dwRenderState[D3DRENDERSTATE_CULLMODE] == D3DCULL_NONE) ? KELVIN_ILFLAG_NOCULL : 0);
                global.kelvin.dwCullValue  =  (pContext->dwRenderState[D3DRENDERSTATE_CULLMODE] == D3DCULL_CCW)  ? 0x80000000 : 0x00000000;
            }
            else {
                dwFlags |= KELVIN_ILFLAG_IX_INL_PRIM;
            }
        }

        else
        {
            if (pContext->hwState.SuperTri.Strategy (pContext->dp2.dwDP2Prim, dwCount, pContext->hwState.pVertexShader))
            {
                dwFlags |= KELVIN_ILFLAG_SUPER_TRI_LIST;
            }
            else
            {
                dwFlags |= KELVIN_ILFLAG_IX_VB_PRIM;
            }
        }

        // setup variables passed to innerloop
        global.kelvin.pContext              = (DWORD)pContext;
        global.kelvin.pContext_kelvinState  = (DWORD)&pContext->hwState;
        global.kelvin.dwPrimCount           = dwCount;

        global.kelvin.dwVertexStride        = pContext->hwState.pVertexShader->getStride();  // vertex stride of source data
        global.kelvin.pIndices              = pContext->dp2.dwIndices;
        global.kelvin.dwIndexStride         = pContext->dp2.dwIndexStride;

        // BUGBUG this won't work with vertex shaders
        // pVertices is used in the inline functions and needs the base vertex (dwVStart) built in.
        // pVertices is not used in the VB routines - they use dwBaseVertex
        global.kelvin.pVertices             = pContext->hwState.ppStreams[pContext->hwState.pVertexShader->getVAStream(defaultInputRegMap[D3DVSDE_POSITION])]->getAddress() +
                                              pContext->hwState.dwVertexOffset +
                                              pContext->dp2.dwVStart * pContext->hwState.ppStreams[pContext->hwState.pVertexShader->getVAStream(defaultInputRegMap[D3DVSDE_POSITION])]->getVertexStride() +
                                              pContext->hwState.pVertexShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]);
        //set base vertex for use in VB Prim and super tri routines
        global.kelvin.dwBaseVertex          = pContext->dp2.dwVStart;

        // set component offsets
        global.kelvin.dwOffsetXYZ           = pContext->hwState.pVertexShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]);
        global.kelvin.dwOffsetRHW           = pContext->hwState.pVertexShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]) + 3*sizeof(DWORD);
        global.kelvin.dwOffsetWeight        = pContext->hwState.pVertexShader->getVAOffset(defaultInputRegMap[D3DVSDE_BLENDWEIGHT]);
        global.kelvin.dwOffsetNormal        = pContext->hwState.pVertexShader->getVAOffset(defaultInputRegMap[D3DVSDE_NORMAL]);
        global.kelvin.dwOffsetDiffuse       = pContext->hwState.pVertexShader->getVAOffset(defaultInputRegMap[D3DVSDE_DIFFUSE]);
        global.kelvin.dwOffsetSpecular      = pContext->hwState.pVertexShader->getVAOffset(defaultInputRegMap[D3DVSDE_SPECULAR]);
        global.kelvin.dwOffsetPointSize     = pContext->hwState.pVertexShader->getVAOffset(defaultInputRegMap[D3DVSDE_PSIZE]);
        for (DWORD i=0; i<KELVIN_CAPS_MAX_UV_PAIRS; i++) {
            global.kelvin.dwOffsetUV[i]     = pContext->hwState.pVertexShader->getVAOffset(defaultInputRegMap[D3DVSDE_TEXCOORD0+i]);
        }
        global.kelvin.dwEyeAddr             = pContext->hwState.SuperTri.getEyeAddr();
        global.kelvin.dwCullAddr            = pContext->hwState.SuperTri.getCullsignAddr();

        if ((dwFlags & KELVIN_ILMASK_LOOPTYPE) == KELVIN_ILFLAG_SUPER_TRI_LIST)
        {
            // do preprocessing
            dwFlags                   |= ((pContext->dwRenderState[D3DRENDERSTATE_CULLMODE] == D3DCULL_NONE) ? KELVIN_ILFLAG_NOCULL : 0);
            global.kelvin.dwCullValue  = (pContext->dwRenderState[D3DRENDERSTATE_CULLMODE] == D3DCULL_CCW)  ? 0x80000000 : 0x00000000;
            CVertexBuffer *pVertexBufferInUse = pContext->ppDX8Streams[pContext->hwState.pVertexShader->getVAStream(defaultInputRegMap[D3DVSDE_POSITION])];
            global.kelvin.pVertices           = (DWORD) pVertexBufferInUse->getSuperTriLookAsideBuffer() +
                                                pContext->hwState.pVertexShader->getVAOffset(defaultInputRegMap[D3DVSDE_POSITION]);
        }

        KELVINDISPATCHPRIMITIVE pfn = nvKelvinGetDispatchRoutine(pContext,dwFlags);
        if (pfn) pfn();
    }
    else
    {

#endif //KELVIN_ILC
C_Code:
    if (pContext->hwState.dwInlineVertexStride)
    {

        // vertices are not in video memory or not accessible by HW. shove them through the push buffer
        nvKelvinDispatchIndexedPrimitiveInline (pContext, dwCount, bLegacyStrides);
    }
    else
    {
        // vertices are in video memory. allow NV20 to fetch them from there

        nvAssert (kelvinBeginEndOp[pContext->dp2.dwDP2Prim] != ~0);
        nvglSetNv20KelvinBeginEnd (NV_DD_KELVIN, kelvinBeginEndOp[pContext->dp2.dwDP2Prim]);

        // determine the number of indices
        DWORD dwScaleAndBias = kelvinPrimitiveToPrimitiveMagic[pContext->dp2.dwDP2Prim];
        nvAssert (dwScaleAndBias != ~0);
        DWORD dwIndexCount = (((dwScaleAndBias >> 8) & 0xff) * dwCount) + (dwScaleAndBias & 0xff);

        // cache index info
        PBYTE pIndices  = (PBYTE)(pContext->dp2.dwIndices);
        DWORD dwIStride = pContext->dp2.dwIndexStride;

        // dump 32-bit blocks of indices
        DWORD dw32BitCount, dw32BitStart, dwMethod;
        if (dwIStride == 2) {
            dw32BitCount = dwIndexCount >> 1;
            dw32BitStart = (pContext->dp2.dwVStart << 16) | (pContext->dp2.dwVStart << 0);
            dwMethod     = NV097_ARRAY_ELEMENT16;
        }
        else {
            nvAssert (dwIStride == 4);
            dw32BitCount = dwIndexCount;
            dw32BitStart = pContext->dp2.dwVStart;
            dwMethod     = NV097_ARRAY_ELEMENT32;
        }

        while (dw32BitCount) {
            DWORD dwCount = min (dw32BitCount, KELVIN_MAX_NONINC_DATA);
            getDC()->nvPusher.makeSpace (sizeSetStartMethod + dwCount);
            nvglSetStartMethod (0, NV_DD_KELVIN, NONINC_METHOD(dwMethod), dwCount);
            getDC()->nvPusher.inc (sizeSetStartMethod);
            for (DWORD i=0; i<dwCount; i++) {
                nvglSetData (i, *((DWORD*)pIndices) + dw32BitStart);
                pIndices += 4;
            }
            getDC()->nvPusher.inc (dwCount);
            dw32BitCount -= dwCount;
        }

        // handle the odd 16-bit index if there is one
        if ((dwIStride == 2) && (dwIndexCount & 0x1)) {
            getDC()->nvPusher.makeSpace (sizeSetStartMethod + 1);
            nvglSetStartMethod (0, NV_DD_KELVIN, NONINC_METHOD(NV097_ARRAY_ELEMENT32), 1);
            getDC()->nvPusher.inc (sizeSetStartMethod);
            nvglSetData (0, (DWORD)(*((WORD*)pIndices)) + pContext->dp2.dwVStart);
            getDC()->nvPusher.inc (1);
        }

        nvglSetNv20KelvinBeginEnd (NV_DD_KELVIN, NV097_SET_BEGIN_END_OP_END);

    }


#ifdef KELVIN_ILC
    }
#endif



#endif // !FORCE_INLINE_VERTICES

#if SYSVB2AGP
    if (pContext->sysvb.pSysMemVB)
    {
        DWORD stream = pContext->sysvb.dwSysMemVBStream;
        pContext->ppDX8Streams[pContext->sysvb.dwSysMemVBStream] = pContext->sysvb.pSysMemVB;
        pContext->sysvb.pSysMemVB = getDC()->defaultVB.getVB();
        pContext->dwStreamDMACount = pContext->sysvb.dwStreamDMACount;
        pContext->dp2.dwVertexBufferOffset = pContext->dp2.dwVertexBufferOffsetSave;
    }
#endif
    //set that we need to unlock all surfaces.  defer till we need to to lower number of CPU
    //clocks per primitive.
    pContext->dwHWUnlockAllPending = TRUE;
}

//---------------------------------------------------------------------------

void nvKelvinDispatchNonIndexedPrimitive
(
    NV_INNERLOOP_ARGLIST
)
{
#ifdef FORCE_NULL
    return;
#endif

    // any work?
    if (dwCount == 0) return;

    DDSTATLOGWORDS(D3D_PRIM_COUNT_PARMS, 1, (DWORD)dwCount);
    // book keeping
    if (pContext->pZetaBuffer) {
        pContext->pZetaBuffer->getWrapper()->setCTDrawPrim();
    }

    // lock surfaces for use by the HW
    nvHWLockTextures (pContext);
    nvHWLockStreams (pContext, KELVIN_CAPS_MAX_STREAMS);

    // set the vertex sources and if anything has changed, dirty the fvf flag
    if (pContext->hwState.dwVertexOffset != pContext->dp2.dwVertexBufferOffset)
    {
        pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_FVF;

    }
    // ugh.  Special case to set up the combiners for pointsprites..
    if ((pContext->dwRenderState[D3DRS_POINTSPRITEENABLE]) &&
        (pContext->hwState.dwCombinerDP2Prim != pContext->dp2.dwDP2Prim))
    {
        pContext->hwState.dwDirtyFlags |= KELVIN_DIRTY_COMBINERS_COLOR;
    }

    // set kelvin state (required to get the correct inner loop)
    nvSetKelvinState (pContext);

#ifdef FORCE_INLINE_VERTICES

    nvKelvinDispatchNonIndexedPrimitiveInline (pContext, dwCount);

#else // !FORCE_INLINE_VERTICES

    if (pContext->hwState.dwInlineVertexStride) {

        nvKelvinDispatchNonIndexedPrimitiveInline (pContext, dwCount);

    }

    else {

        // vertices are in video memory. allow NV20 to fetch them from there

        nvAssert (kelvinBeginEndOp[pContext->dp2.dwDP2Prim] != ~0);
        nvglSetNv20KelvinBeginEnd (NV_DD_KELVIN, kelvinBeginEndOp[pContext->dp2.dwDP2Prim]);

        DWORD dwScaleAndBias = kelvinPrimitiveToPrimitiveMagic[pContext->dp2.dwDP2Prim];
        nvAssert (dwScaleAndBias != ~0);
        DWORD dwNumVertices = (((dwScaleAndBias >> 8) & 0xff) * dwCount) + (dwScaleAndBias & 0xff);

        DWORD dwIndex = 0;
        while (dwNumVertices > KELVIN_MAX_INLINE_VERTICES) {
            nvglSetNv20KelvinDrawArrays (NV_DD_KELVIN,
                                         DRF_NUM(097, _DRAW_ARRAYS, _COUNT, KELVIN_MAX_INLINE_VERTICES-1) |
                                         DRF_NUM(097, _DRAW_ARRAYS, _START_INDEX, dwIndex + pContext->dp2.dwVStart));
            dwNumVertices -= KELVIN_MAX_INLINE_VERTICES;
            dwIndex += KELVIN_MAX_INLINE_VERTICES;
        }
        if (dwNumVertices) {
            nvglSetNv20KelvinDrawArrays (NV_DD_KELVIN,
                                         DRF_NUM(097, _DRAW_ARRAYS, _COUNT, dwNumVertices-1) |
                                         DRF_NUM(097, _DRAW_ARRAYS, _START_INDEX, dwIndex + pContext->dp2.dwVStart));
        }

        nvglSetNv20KelvinBeginEnd (NV_DD_KELVIN, NV097_SET_BEGIN_END_OP_END);

    }

#endif // !FORCE_INLINE_VERTICES

    //set that we need to unlock all surfaces.  defer till we need to to lower number of CPU
    //clocks per primitive.
    pContext->dwHWUnlockAllPending = TRUE;
}

//---------------------------------------------------------------------------

void nvKelvinDispatchLegacyWireframePrimitive
(
    NV_INNERLOOP_ARGLIST
)
{
    nvAssert (pContext->dwRenderState[D3DRENDERSTATE_FILLMODE] == D3DFILL_WIREFRAME);

    DWORD dwCachedDP2Op     = pContext->dp2.dwDP2Prim;
    pContext->dp2.dwDP2Prim = D3DDP2OP_INDEXEDLINELIST;

    if (dwCachedDP2Op == D3DDP2OP_INDEXEDTRIANGLELIST) {

        LPD3DHAL_DP2INDEXEDTRIANGLELIST pTriListData;
        DWORD dwEdge;
        WORD  wIndicesIn[3];
        WORD  wIndicesOut[2];

        pTriListData = (LPD3DHAL_DP2INDEXEDTRIANGLELIST)(pContext->dp2.dwIndices);
        pContext->dp2.dwIndices     = (DWORD)(&(wIndicesOut[0]));
        pContext->dp2.dwIndexStride = 2;

        while (dwCount) {

            wIndicesIn[0] = pTriListData->wV1;
            wIndicesIn[1] = pTriListData->wV2;
            wIndicesIn[2] = pTriListData->wV3;

            for (dwEdge=0; dwEdge<3; dwEdge++) {
                if (pTriListData->wFlags & (D3DTRIFLAG_EDGEENABLE1 << dwEdge)) {
                    wIndicesOut[0] = wIndicesIn [(dwEdge+0) % 3];
                    wIndicesOut[1] = wIndicesIn [(dwEdge+1) % 3];
                    nvKelvinDispatchIndexedPrimitive (pContext, 1);
                }
            }

            pTriListData ++;
            dwCount --;

        }

    }

    else if ((dwCachedDP2Op == D3DDP2OP_TRIANGLEFAN_IMM) || (dwCachedDP2Op == D3DDP2OP_TRIANGLEFAN)) {

        DWORD dwEdgeFlags, dwEdgeMask;
        WORD  wTriNum;
        WORD  wIndicesOut[2];

        nvAssert (dwCount < 32);

        dwEdgeFlags = pContext->dp2.dwEdgeFlags;
        dwEdgeMask  = 0x1;

        pContext->dp2.dwIndices     = (DWORD)(&(wIndicesOut[0]));
        pContext->dp2.dwIndexStride = 2;

        // we never draw edge v0-v1 for anything but the first triangle
        wIndicesOut[0] = 1;
        wIndicesOut[1] = 0;
        if (dwEdgeFlags & dwEdgeMask) {
            nvKelvinDispatchIndexedPrimitive (pContext, 1);
            dbgFlushType (NVDBG_FLUSH_PRIMITIVE);
        }
        dwEdgeMask <<= 1;

        // we may draw edge v1-v2 for any or all triangles
        for (wTriNum=0; wTriNum<dwCount; wTriNum++) {
            wIndicesOut[0] = wTriNum+1;
            wIndicesOut[1] = wTriNum+2;
            if (dwEdgeFlags & dwEdgeMask) {
                nvKelvinDispatchIndexedPrimitive (pContext, 1);
                dbgFlushType (NVDBG_FLUSH_PRIMITIVE);
            }
            dwEdgeMask <<= 1;
        }

        // we never draw edge v2-v0 for anything but the last triangle
        wIndicesOut[0] = dwCount+1;
        wIndicesOut[1] = 0;
        if (dwEdgeFlags & dwEdgeMask) {
            nvKelvinDispatchIndexedPrimitive (pContext, 1);
            dbgFlushType (NVDBG_FLUSH_PRIMITIVE);
        }
        dwEdgeMask <<= 1;

    }

    else {

        // we don't handle any other legacy primitives
        nvAssert (0);

    }

    pContext->dp2.dwDP2Prim = dwCachedDP2Op;
}

/*****************************************************************************
 *****************************************************************************
 *** Inline Vertex Code ******************************************************
 *****************************************************************************
 *****************************************************************************/

// this code is typically unused. it's used only for debugging
// purposes if FORCE_INLINE_VERTICES is defined

// table mapping dp2ops to the scale and bias required to calculate the number
// of vertices from the number of primitives. the scale is in the upper half
// of the word and the bias is in the lower.
// numVertices = scale * numPrimitives + bias

DWORD kelvinPrimitiveToVertexCountScaleAndBias[D3D_DP2OP_MAX+1] =
{
    ~0,                                          //   0  invalid
    0x00010000,                                  //   1  D3DDP2OP_POINTS
    0x00020000,                                  //   2  D3DDP2OP_INDEXEDLINELIST
    0x00030000,                                  //   3  D3DDP2OP_INDEXEDTRIANGLELIST
    ~0,                                          //   4  invalid
    ~0,                                          //   5  invalid
    ~0,                                          //   6  invalid
    ~0,                                          //   7  invalid
    ~0,                                          //   8  D3DDP2OP_RENDERSTATE
    ~0,                                          //   9  invalid
    ~0,                                          //  10  invalid
    ~0,                                          //  11  invalid
    ~0,                                          //  12  invalid
    ~0,                                          //  13  invalid
    ~0,                                          //  14  invalid
    0x00020000,                                  //  15  D3DDP2OP_LINELIST
    0x00010001,                                  //  16  D3DDP2OP_LINESTRIP
    0x00010001,                                  //  17  D3DDP2OP_INDEXEDLINESTRIP
    0x00030000,                                  //  18  D3DDP2OP_TRIANGLELIST
    0x00010002,                                  //  19  D3DDP2OP_TRIANGLESTRIP
    0x00010002,                                  //  20  D3DDP2OP_INDEXEDTRIANGLESTRIP
    0x00010002,                                  //  21  D3DDP2OP_TRIANGLEFAN
    0x00010002,                                  //  22  D3DDP2OP_INDEXEDTRIANGLEFAN
    0x00010002,                                  //  23  D3DDP2OP_TRIANGLEFAN_IMM
    0x00020000,                                  //  24  D3DDP2OP_LINELIST_IMM
    ~0,                                          //  25  D3DDP2OP_TEXTURESTAGESTATE
    0x00030000,                                  //  26  D3DDP2OP_INDEXEDTRIANGLELIST2
    0x00020000,                                  //  27  D3DDP2OP_INDEXEDLINELIST2
    ~0,                                          //  28  D3DDP2OP_VIEWPORTINFO
    ~0,                                          //  29  D3DDP2OP_WINFO
    ~0,                                          //  30  D3DDP2OP_SETPALETTE
    ~0,                                          //  31  D3DDP2OP_UPDATEPALETTE
    ~0,                                          //  32  D3DDP2OP_ZRANGE
    ~0,                                          //  33  D3DDP2OP_SETMATERIAL
    ~0,                                          //  34  D3DDP2OP_SETLIGHT
    ~0,                                          //  35  D3DDP2OP_CREATELIGHT
    ~0,                                          //  36  D3DDP2OP_SETTRANSFORM
    ~0,                                          //  37  D3DDP2OP_EXT
    ~0,                                          //  38  D3DDP2OP_TEXBLT
    ~0,                                          //  39  D3DDP2OP_STATESET
    ~0,                                          //  40  D3DDP2OP_SETPRIORITY
    ~0,                                          //  41  D3DDP2OP_SETRENDERTARGET
    ~0,                                          //  42  D3DDP2OP_CLEAR
    ~0,                                          //  43  D3DDP2OP_SETTEXLOD
    ~0                                           //  44  D3DDP2OP_SETCLIPPLANE
};

//---------------------------------------------------------------------------

// dump one vertex attribute into the push buffer (conditional on its existence)

__inline void nvKelvinDumpInlineVA
(
    DWORD           dwReg,
    CVertexShader  *pShader,
    CVertexBuffer **ppStreams,
    DWORD           dwVertexBufferOffset,
    DWORD           dwIndex,
    DWORD          *dwPutIndex
#ifdef STOMP_TEX_COORDS
    BOOL           ,bStompLast
#endif  // STOMP_TEX_COORDS
)
{
    DWORD dwStreamSelector, pComponent, dwCount, i;

    dwStreamSelector = pShader->getVAStream(dwReg);
    if (dwStreamSelector != CVertexShader::VA_STREAM_NONE) {
        nvAssert (ppStreams[dwStreamSelector]);
        pComponent = ppStreams[dwStreamSelector]->getAddress()                // address of buffer
                   + dwVertexBufferOffset                                     // global offset within buffer
                   + pShader->getVAOffset (dwReg)                             // offset of this component
                   + dwIndex*ppStreams[dwStreamSelector]->getVertexStride();  // offset of this particular vertex
        dwCount = pShader->getVASize (dwReg) / sizeof(DWORD);
        for (i=0; i<dwCount; i++) {
            nvglSetData (*dwPutIndex, ((DWORD*)pComponent)[i]);
            (*dwPutIndex) ++;
        }
#ifdef STOMP_TEX_COORDS
        if (bStompLast) {
            nvglSetData ((*dwPutIndex)-1, FP_ONE_BITS);
        }
#endif  // STOMP_TEX_COORDS
    }
}

//---------------------------------------------------------------------------

void nvKelvinDumpDebugVertex
(
    PNVD3DCONTEXT pContext,
    DWORD         dwIndex
)
{
    CVertexShader  *pShader;
    CVertexBuffer **ppStreams;
    DWORD           dwVertexBufferOffset;
    DWORD           dwPBIndex, dwReg;
    DWORD           dwHWStage, dwD3DStage, dwTCIndex, dwVAIndex;

    pShader              = pContext->hwState.pVertexShader;
    ppStreams            = pContext->hwState.ppStreams;
    dwVertexBufferOffset = pContext->hwState.dwVertexOffset;
    dwIndex             += pContext->dp2.dwVStart; //add in the base vertex
    dwPBIndex=0;

    DWORD  *pComponent;
    DWORD   dwSs;
    DWORD   flag = NVDBG_SHOW_VERTICES;

    dbgDPFAndDump(flag, "\nkelvin vertex, index = %d", dwIndex);

    // x,y,z,w
    dwReg=defaultInputRegMap[D3DVSDE_POSITION];
    dwSs=pShader->getVAStream(dwReg);
    if (dwSs!=CVertexShader::VA_STREAM_NONE)
    {
        pComponent = (DWORD*)(ppStreams[dwSs]->getAddress()
            + dwVertexBufferOffset
            + pShader->getVAOffset (dwReg)
            + dwIndex*ppStreams[dwSs]->getVertexStride());

        dbgDPFAndDump(flag, "             X = %f",    FLOAT_FROM_DWORD(pComponent[0]));
        dbgDPFAndDump(flag, "             Y = %f",    FLOAT_FROM_DWORD(pComponent[1]));
        dbgDPFAndDump(flag, "             Z = %f",    FLOAT_FROM_DWORD(pComponent[2]));
        dbgDPFAndDump(flag, "             W = %f",    FLOAT_FROM_DWORD(pComponent[3]));
    }

    // blendweight
    dwReg=defaultInputRegMap[D3DVSDE_BLENDWEIGHT];
    dwSs=pShader->getVAStream(dwReg);
    if (dwSs!=CVertexShader::VA_STREAM_NONE)
    {
        pComponent = (DWORD*)(ppStreams[dwSs]->getAddress()
            + dwVertexBufferOffset
            + pShader->getVAOffset (dwReg)
            + dwIndex*ppStreams[dwSs]->getVertexStride());

        dbgDPFAndDump(flag, " blendWeight = %f",    FLOAT_FROM_DWORD(pComponent[0]));
    }

    // normal
    dwReg=defaultInputRegMap[D3DVSDE_NORMAL];
    dwSs=pShader->getVAStream(dwReg);
    if (dwSs!=CVertexShader::VA_STREAM_NONE)
    {
        pComponent = (DWORD*)(ppStreams[dwSs]->getAddress()
            + dwVertexBufferOffset
            + pShader->getVAOffset (dwReg)
            + dwIndex*ppStreams[dwSs]->getVertexStride());

        dbgDPFAndDump(flag, "    nX       = %f",    FLOAT_FROM_DWORD(pComponent[0]));
        dbgDPFAndDump(flag, "    nY       = %f",    FLOAT_FROM_DWORD(pComponent[1]));
        dbgDPFAndDump(flag, "    nZ       = %f",    FLOAT_FROM_DWORD(pComponent[2]));
    }

    // diffuse
    dwReg=defaultInputRegMap[D3DVSDE_DIFFUSE];
    dwSs=pShader->getVAStream(dwReg);
    if (dwSs!=CVertexShader::VA_STREAM_NONE)
    {
        pComponent = (DWORD*)(ppStreams[dwSs]->getAddress()
            + dwVertexBufferOffset
            + pShader->getVAOffset (dwReg)
            + dwIndex*ppStreams[dwSs]->getVertexStride());

        dbgDPFAndDump(flag, "     diffuse = %x",    pComponent[0]);
    }

    // specular
    dwReg=defaultInputRegMap[D3DVSDE_SPECULAR];
    dwSs=pShader->getVAStream(dwReg);
    if (dwSs!=CVertexShader::VA_STREAM_NONE)
    {
        pComponent = (DWORD*)(ppStreams[dwSs]->getAddress()
            + dwVertexBufferOffset
            + pShader->getVAOffset (dwReg)
            + dwIndex*ppStreams[dwSs]->getVertexStride());

        dbgDPFAndDump(flag, "    specular = %x",    pComponent[0]);
    }

    for (dwHWStage=0; dwHWStage < KELVIN_NUM_TEXTURES; dwHWStage++)
    {
        if (pContext->hwState.dwStateFlags & KELVIN_FLAG_USERTEXCOORDSNEEDED(dwHWStage))
        {
            dwD3DStage = pContext->hwState.dwTexUnitToTexStageMapping[dwHWStage];
            nvAssert (dwD3DStage != KELVIN_UNUSED);
            dwTCIndex  = (pContext->hwState.dwTexCoordIndices >> (8*dwHWStage)) & 0xff;  // BUGBUG?? are these indices even relevant in DX8?
            dwVAIndex  = defaultInputRegMap[D3DVSDE_TEXCOORD0+dwTCIndex];
            nvAssert (pShader->bVAExists(dwVAIndex));  // they better have given us coordinates


            dwReg=dwVAIndex;
            dwSs=pShader->getVAStream(dwReg);
            if (dwSs!=CVertexShader::VA_STREAM_NONE)
            {
                pComponent = (DWORD*)(ppStreams[dwSs]->getAddress()
                    + dwVertexBufferOffset
                    + pShader->getVAOffset (dwReg)
                    + dwIndex*ppStreams[dwSs]->getVertexStride());

                switch (pShader->getVASize(dwReg)>>2) {
                case 1: dbgDPFAndDump(flag, "    Texture %d = <%f>", dwHWStage, FLOAT_FROM_DWORD(pComponent[0])); break;
                case 2: dbgDPFAndDump(flag, "    Texture %d = <%f, %f>", dwHWStage, FLOAT_FROM_DWORD(pComponent[0]), FLOAT_FROM_DWORD(pComponent[1])); break;
                case 3: dbgDPFAndDump(flag, "    Texture %d = <%f, %f, %f>", dwHWStage, FLOAT_FROM_DWORD(pComponent[0]), FLOAT_FROM_DWORD(pComponent[1]), FLOAT_FROM_DWORD(pComponent[2])); break;
                case 4: dbgDPFAndDump(flag, "    Texture %d = <%f, %f, %f, %f>", dwHWStage, FLOAT_FROM_DWORD(pComponent[0]), FLOAT_FROM_DWORD(pComponent[1]), FLOAT_FROM_DWORD(pComponent[2]), FLOAT_FROM_DWORD(pComponent[3])); break;
                default: dbgDPFAndDump(flag, "    Invalid number of texture coordinates"); dbgD3DError();
                }
            }
        }
    }
}

//---------------------------------------------------------------------------

// dumps one vertex into the push buffer with the components in the order
// kelvin requires. note that adequate push buffer space is assumed to have
// been verified already!

void nvKelvinDumpInlineVertex
(
    PNVD3DCONTEXT pContext,
    DWORD         dwIndex
)
{
    CVertexShader  *pShader;
    CVertexBuffer **ppStreams;
    DWORD           dwVertexBufferOffset;
    DWORD           dwPBIndex, dwReg;
    DWORD           dwHWStage, dwD3DStage, dwTCIndex, dwVAIndex;

    pShader              = pContext->hwState.pVertexShader;
    ppStreams            = pContext->hwState.ppStreams;
    dwVertexBufferOffset = pContext->hwState.dwVertexOffset;
    dwIndex             += pContext->dp2.dwVStart; //add in the base vertex
    dwPBIndex=0;

    if (pShader->hasProgram()) {

        // dump all enabled vertex attributes
        for (dwReg=0; dwReg < NV_CAPS_MAX_STREAMS; dwReg++) {
#ifdef STOMP_TEX_COORDS
            nvKelvinDumpInlineVA (dwReg, pShader, ppStreams, dwVertexBufferOffset, dwIndex, &dwPBIndex, FALSE);
#else  // !STOMP_TEX_COORDS
            nvKelvinDumpInlineVA (dwReg, pShader, ppStreams, dwVertexBufferOffset, dwIndex, &dwPBIndex);
#endif  // !STOMP_TEX_COORDS
        }
        if (pContext->hwState.dwInlineVertexStride == 4) //workaround for kelvin bug
        {
            //add some extra
            nvglSetData (dwPBIndex, 0);
            dwPBIndex++;
        }
    }
    else {

        if ((dbgShowState & NVDBG_SHOW_VERTICES) || (dbgDumpState & NVDBG_SHOW_VERTICES)) {
            nvKelvinDumpDebugVertex (pContext, dwIndex);
        }

#ifdef STOMP_TEX_COORDS
        // dump pre-ordained components
        nvKelvinDumpInlineVA (defaultInputRegMap[D3DVSDE_POSITION],    pShader, ppStreams, dwVertexBufferOffset, dwIndex, &dwPBIndex, FALSE);
        nvKelvinDumpInlineVA (defaultInputRegMap[D3DVSDE_BLENDWEIGHT], pShader, ppStreams, dwVertexBufferOffset, dwIndex, &dwPBIndex, FALSE);
        nvKelvinDumpInlineVA (defaultInputRegMap[D3DVSDE_NORMAL],      pShader, ppStreams, dwVertexBufferOffset, dwIndex, &dwPBIndex, FALSE);
        nvKelvinDumpInlineVA (defaultInputRegMap[D3DVSDE_DIFFUSE],     pShader, ppStreams, dwVertexBufferOffset, dwIndex, &dwPBIndex, FALSE);
        nvKelvinDumpInlineVA (defaultInputRegMap[D3DVSDE_SPECULAR],    pShader, ppStreams, dwVertexBufferOffset, dwIndex, &dwPBIndex, FALSE);
        nvKelvinDumpInlineVA (defaultInputRegMap[D3DVSDE_PSIZE],       pShader, ppStreams, dwVertexBufferOffset, dwIndex, &dwPBIndex, FALSE);
        for (dwHWStage=0; dwHWStage < KELVIN_NUM_TEXTURES; dwHWStage++) {
            if (pContext->hwState.dwStateFlags & KELVIN_FLAG_USERTEXCOORDSNEEDED(dwHWStage)) {
                dwD3DStage = pContext->hwState.dwTexUnitToTexStageMapping[dwHWStage];
                nvAssert (dwD3DStage != KELVIN_UNUSED);
                dwTCIndex  = (pContext->hwState.dwTexCoordIndices >> (8*dwHWStage)) & 0xff;  // BUGBUG?? are these indices even relevant in DX8?
                dwVAIndex  = defaultInputRegMap[D3DVSDE_TEXCOORD0+dwTCIndex];
                nvAssert (pShader->bVAExists(dwVAIndex));  // they better have given us coordinates
                BOOL bStompLast = (pContext->hwState.dwStateFlags & KELVIN_FLAG_STOMP_4TH_COORD(dwHWStage));
                nvKelvinDumpInlineVA (dwVAIndex, pShader, ppStreams, dwVertexBufferOffset, dwIndex, &dwPBIndex, bStompLast);
            }
        }
#else  // !STOMP_TEX_COORDS
        // dump pre-ordained components
        nvKelvinDumpInlineVA (defaultInputRegMap[D3DVSDE_POSITION],    pShader, ppStreams, dwVertexBufferOffset, dwIndex, &dwPBIndex);
        nvKelvinDumpInlineVA (defaultInputRegMap[D3DVSDE_BLENDWEIGHT], pShader, ppStreams, dwVertexBufferOffset, dwIndex, &dwPBIndex);
        nvKelvinDumpInlineVA (defaultInputRegMap[D3DVSDE_NORMAL],      pShader, ppStreams, dwVertexBufferOffset, dwIndex, &dwPBIndex);
        nvKelvinDumpInlineVA (defaultInputRegMap[D3DVSDE_DIFFUSE],     pShader, ppStreams, dwVertexBufferOffset, dwIndex, &dwPBIndex);
        nvKelvinDumpInlineVA (defaultInputRegMap[D3DVSDE_SPECULAR],    pShader, ppStreams, dwVertexBufferOffset, dwIndex, &dwPBIndex);
        nvKelvinDumpInlineVA (defaultInputRegMap[D3DVSDE_PSIZE],       pShader, ppStreams, dwVertexBufferOffset, dwIndex, &dwPBIndex);
        for (dwHWStage=0; dwHWStage < KELVIN_NUM_TEXTURES; dwHWStage++) {
            if (pContext->hwState.dwStateFlags & KELVIN_FLAG_USERTEXCOORDSNEEDED(dwHWStage)) {
                dwD3DStage = pContext->hwState.dwTexUnitToTexStageMapping[dwHWStage];
                nvAssert (dwD3DStage != KELVIN_UNUSED);
                dwTCIndex  = (pContext->hwState.dwTexCoordIndices >> (8*dwHWStage)) & 0xff;  // BUGBUG?? are these indices even relevant in DX8?
                dwVAIndex  = defaultInputRegMap[D3DVSDE_TEXCOORD0+dwTCIndex];
                nvAssert (pShader->bVAExists(dwVAIndex));  // they better have given us coordinates
                nvKelvinDumpInlineVA (dwVAIndex, pShader, ppStreams, dwVertexBufferOffset, dwIndex, &dwPBIndex);
            }
        }
#endif  // !STOMP_TEX_COORDS

    }

    nvAssert ((dwPBIndex == (pContext->hwState.dwInlineVertexStride >> 2)) || pContext->hwState.dwInlineVertexStride == 4 );
}

//---------------------------------------------------------------------------

// dumps a block of 'dwCount' non-indexed vertices starting with index 'i0'

void nvKelvinDumpNonIndexedInlineVertexBlock
(
    PNVD3DCONTEXT pContext,
    DWORD         i0,
    DWORD         dwCount,
    DWORD         dwInlineVertexStride
)
{
    DWORD dwMethodCount;

    dwMethodCount = dwCount * dwInlineVertexStride;  // number of 4-byte words
    nvAssert (dwMethodCount < (1<<11));

    getDC()->nvPusher.makeSpace (sizeSetStartMethod + dwMethodCount);
    nvglSetStartMethod (0, NV_DD_KELVIN, NVPUSHER_NOINC(NV097_INLINE_ARRAY), dwMethodCount);
    getDC()->nvPusher.inc (sizeSetStartMethod);

    for (DWORD i=i0; i<i0+dwCount; i++) {
        nvKelvinDumpInlineVertex (pContext, i);
        getDC()->nvPusher.inc (dwInlineVertexStride);
    }
}

#ifndef VERTEX_REUSE

//---------------------------------------------------------------------------

// dumps a block of 'dwCount' indexed vertices beginning with index 'i0'

void nvKelvinDumpIndexedInlineVertexBlock
(
    PNVD3DCONTEXT pContext,
    DWORD         i0,
    DWORD         dwCount,
    BOOL          bLegacyStrides,
    DWORD         dwInlineVertexStride
)
{
    DWORD dwMethodCount;
    DWORD i, i1;
    PWORD lpIndices  = (PWORD)(pContext->dp2.dwIndices);

    dwMethodCount = dwCount * dwInlineVertexStride;  // number of 4-byte words
    nvAssert (dwMethodCount < 2048);

    getDC()->nvPusher.makeSpace (sizeSetStartMethod + dwMethodCount);
    nvglSetStartMethod (0, NV_DD_KELVIN, NVPUSHER_NOINC(NV097_INLINE_ARRAY), dwMethodCount);
    getDC()->nvPusher.inc (sizeSetStartMethod);

    if (bLegacyStrides) {

        // stupid old style indexing - {index16:index16 index16:junk16} repeat
        for (i=i0; i < (i0+dwCount); i++) {
            i1 = 4 * i / 3;  // offset of the i'th index
            nvKelvinDumpInlineVertex (pContext, lpIndices[i1]);
            getDC()->nvPusher.inc (dwInlineVertexStride);
        }

    }

    else {

        // new indexing - fully packed
        for (i=i0; i < (i0+dwCount); i++) {
            nvKelvinDumpInlineVertex (pContext, lpIndices[i]);
            getDC()->nvPusher.inc (dwInlineVertexStride);
        }

    }
}

#else  // VERTEX_REUSE


#if 0 // old way

//---------------------------------------------------------------------------

// dumps a block of 'dwCount' indexed vertices beginning with index 'i0'

void nvKelvinDumpIndexedInlineVertexBlock
(
    PNVD3DCONTEXT pContext,
    LPWORD        lpIndices,
    DWORD         i0,
    DWORD         dwCount,
    BOOL          bLegacyStrides,
    DWORD         dwInlineVertexStride
)
{
    DWORD dwMethodCount;
    DWORD i, i1;
    DWORD adwBitField[16];
    DWORD dwIndexMask;
    DWORD dwBitIndex, dwBit;
#ifdef DEBUG
    DWORD dwNewCount = 0;
    DWORD dwReuseCount = 0;
#endif

    if (bLegacyStrides) {

        // stupid old style indexing - {index16:index16 index16:junk16} repeat

        dwMethodCount = dwCount * dwInlineVertexStride;  // number of 4-byte words
        nvAssert (dwMethodCount <= 2048);

        getDC()->nvPusher.makeSpace (sizeSetStartMethod + dwMethodCount);
        nvglSetStartMethod (0, NV_DD_KELVIN, NVPUSHER_NOINC(NV097_INLINE_ARRAY), dwMethodCount);
        getDC()->nvPusher.inc (sizeSetStartMethod);

        for (i=i0; i < (i0+dwCount); i++) {
            i1 = 4 * i / 3;  // offset of the i'th index
            nvKelvinDumpInlineVertex (pContext, lpIndices[i1]);
            getDC()->nvPusher.inc (dwInlineVertexStride);
        }

    }

    else {

        // new indexing - fully packed

        // conservatively make space as if we're not going to reuse any
        getDC()->nvPusher.makeSpace (dwCount * (sizeSetStartMethod + dwInlineVertexStride));

        // clear the cached values
        memset ((void*)adwBitField, 0, 16*sizeof(DWORD));

        for (i=i0; i < (i0+dwCount); i++) {

            i1 = lpIndices[i];

            // see if we've used this index before
            dwIndexMask = ~0;
            for (dwBitIndex=0; dwBitIndex<16; dwBitIndex++) {
                dwBit = (i1 >> dwBitIndex) & 0x1;
                dwIndexMask &= ((adwBitField[dwBitIndex] >> (dwBit<<4)) & 0xffff);
            }

            if (dwIndexMask) {

                // we've seen this index before. re-use the vertex
#ifdef DEBUG
                dwReuseCount++;

                // only one bit should be set
                DWORD aa = dwIndexMask;
                DWORD bb = dwIndexMask;
                ASM_LOG2(aa);
                ASM_LOG2_R(bb);
                nvAssert (aa==bb);
#endif
                ASM_LOG2(dwIndexMask);
                nvglSetStartMethod (0, NV_DD_KELVIN, NV097_INLINE_VERTEX_REUSE, 1);
                nvglSetData (1, dwIndexMask);
                getDC()->nvPusher.inc (2);

            }

            else {

                // this is a new index. emit the vertex and update cached indices
#ifdef DEBUG
                dwNewCount++;
#endif
                nvglSetStartMethod (0, NV_DD_KELVIN, NVPUSHER_NOINC(NV097_INLINE_ARRAY), dwInlineVertexStride);
                getDC()->nvPusher.inc (sizeSetStartMethod);
                nvKelvinDumpInlineVertex (pContext, i1);
                getDC()->nvPusher.inc (dwInlineVertexStride);
                for (dwBitIndex=0; dwBitIndex<16; dwBitIndex++) {
                    dwBit = (i1 >> dwBitIndex) & 0x1;
                    adwBitField[dwBitIndex] <<= 1;
                    adwBitField[dwBitIndex]  &= 0xfffefffe;
                    adwBitField[dwBitIndex]  |= ((dwBit << 16) | (dwBit ^ 0x1));
                }

            }

        }

    }

#ifdef DEBUG
    DPF_LEVEL (NVDBG_LEVEL_VERTEX_REUSE, "Vertex Reuse Statistics:");
    DPF_LEVEL (NVDBG_LEVEL_VERTEX_REUSE, "      new : %d (%.2f)", dwNewCount, (float)dwNewCount/(dwNewCount+dwReuseCount));
    DPF_LEVEL (NVDBG_LEVEL_VERTEX_REUSE, "   reused : %d (%.2f)", dwReuseCount, (float)dwReuseCount/(dwNewCount+dwReuseCount));
    DPF_LEVEL (NVDBG_LEVEL_VERTEX_REUSE, "    total : %d (%.2f)", dwNewCount+dwReuseCount, 100.f);
#endif

}


#else // new way

//---------------------------------------------------------------------------

// dumps a block of 'dwCount' indexed vertices beginning with index 'i0'

#define INDEX_HISTORY_SIZE 16
#define INDEX_HISTORY_MASK (INDEX_HISTORY_SIZE-1)
void nvKelvinDumpIndexedInlineVertexBlock
(
    PNVD3DCONTEXT pContext,
    DWORD         i0,
    DWORD         dwCount,
    BOOL          bLegacyStrides,
    DWORD         dwInlineVertexStride
)
{
    DWORD dwMethodCount;
    DWORD i, i1;
    DWORD dwReuseIndex, dwVertexIndex;
    DWORD adwIndexHistory[INDEX_HISTORY_SIZE];
    DWORD dwCurrentHistoryIndex, dwHistoryIndex;

    PBYTE pIndices  = (PBYTE)(pContext->dp2.dwIndices);
    DWORD dwIStride = pContext->dp2.dwIndexStride;

    if (bLegacyStrides) {

        // stupid old style indexing - {index16:index16 index16:junk16} repeat

        dwMethodCount = dwCount * dwInlineVertexStride;  // number of 4-byte words
        nvAssert (dwMethodCount <= 2048);
        nvAssert (dwIStride == 2);  // legacy shouldn't be using 32-bit indices

        getDC()->nvPusher.makeSpace (sizeSetStartMethod + dwMethodCount);
        nvglSetStartMethod (0, NV_DD_KELVIN, NVPUSHER_NOINC(NV097_INLINE_ARRAY), dwMethodCount);
        getDC()->nvPusher.inc (sizeSetStartMethod);

        for (i=i0; i < (i0+dwCount); i++) {
            i1 = 4 * i / 3;  // offset of the i'th index
            nvKelvinDumpInlineVertex (pContext, ((WORD*)pIndices)[i1]);
            getDC()->nvPusher.inc (dwInlineVertexStride);
        }

    }

    else {

        // new indexing - fully packed

        // conservatively make space as if we're not going to reuse any
        getDC()->nvPusher.makeSpace (dwCount * (sizeSetStartMethod + dwInlineVertexStride));

        // clear the history
        dwCurrentHistoryIndex = 0;
        memset ((void*)adwIndexHistory, 0xff, INDEX_HISTORY_SIZE*sizeof(DWORD));

        for (i=i0; i < (i0+dwCount); i++) {

            dwVertexIndex = (dwIStride == 2) ? ((WORD*)pIndices)[i] : ((DWORD*)pIndices)[i];

            // see if we've used this index before
            dwHistoryIndex = dwCurrentHistoryIndex;
            for (dwReuseIndex=0; dwReuseIndex<INDEX_HISTORY_SIZE; dwReuseIndex++) {
                if (adwIndexHistory[dwHistoryIndex] == dwVertexIndex) {
                    // re-use index dwReuseIndex
                    nvglSetStartMethod (0, NV_DD_KELVIN, NV097_INLINE_VERTEX_REUSE, 1);
                    nvglSetData (1, dwReuseIndex);
                    getDC()->nvPusher.inc (2);
                    goto next_i;
                }
                dwHistoryIndex--;
                dwHistoryIndex &= INDEX_HISTORY_MASK;
            }

            // this is a new index. emit the vertex and update cached indices
            nvglSetStartMethod (0, NV_DD_KELVIN, NVPUSHER_NOINC(NV097_INLINE_ARRAY), dwInlineVertexStride);
            getDC()->nvPusher.inc (sizeSetStartMethod);
            nvKelvinDumpInlineVertex (pContext, dwVertexIndex);
            getDC()->nvPusher.inc (dwInlineVertexStride);

            dwCurrentHistoryIndex++;
            dwCurrentHistoryIndex &= INDEX_HISTORY_MASK;
            adwIndexHistory[dwCurrentHistoryIndex] = dwVertexIndex;

            next_i:
            ;  // null statement to make label happy

        }

    }
}

#endif  // new way

#endif  // VERTEX_REUSE

//---------------------------------------------------------------------------

void nvKelvinDispatchNonIndexedPrimitiveInline
(
    PNVD3DCONTEXT       pContext,
    DWORD               dwCount
)
{
    DWORD numVertices, emittedVertices, dwScaleAndBias, dwInlineVertexStride, dwKelvinMaxInlineVertices;

    dwInlineVertexStride      = pContext->hwState.dwInlineVertexStride >> 2;
    if (dwInlineVertexStride == 1) dwInlineVertexStride = 2; //workaround for kelvin bug
    dwKelvinMaxInlineVertices = NVPUSHER_MAX_METHOD_COUNT / dwInlineVertexStride;

    nvAssert (kelvinBeginEndOp[pContext->dp2.dwDP2Prim] != ~0);

    nvglSetStartMethod (0, NV_DD_KELVIN, NV097_SET_BEGIN_END, 1);
    nvglSetData (1, kelvinBeginEndOp[pContext->dp2.dwDP2Prim]);
    nvglAdjust (2);

    dwScaleAndBias = kelvinPrimitiveToVertexCountScaleAndBias[pContext->dp2.dwDP2Prim];
    nvAssert (dwScaleAndBias != ~0);
    numVertices = (dwScaleAndBias >> 16) * dwCount + (dwScaleAndBias & 0xffff);

    emittedVertices = 0;

    while (numVertices > dwKelvinMaxInlineVertices) {
        // attempt to kick off some work already
        nvPusherStart (FALSE);
        // send more vertices
        nvKelvinDumpNonIndexedInlineVertexBlock (pContext, emittedVertices, dwKelvinMaxInlineVertices, dwInlineVertexStride);
        emittedVertices += dwKelvinMaxInlineVertices;
        numVertices -= dwKelvinMaxInlineVertices;
    }

    nvKelvinDumpNonIndexedInlineVertexBlock (pContext, emittedVertices, numVertices, dwInlineVertexStride);

    nvglSetStartMethod (0, NV_DD_KELVIN, NV097_SET_BEGIN_END, 1);
    nvglSetData (1, NV097_SET_BEGIN_END_OP_END);
    nvglAdjust (2);

    nvPusherStart (FALSE);
}

//---------------------------------------------------------------------------

void nvKelvinDispatchIndexedPrimitiveInline
(
    PNVD3DCONTEXT       pContext,
    DWORD               dwCount,
    BOOL                bLegacyStrides
)
{
    DWORD numVertices, emittedVertices, dwScaleAndBias, dwInlineVertexStride, dwKelvinMaxInlineVertices;

    dwInlineVertexStride      = pContext->hwState.dwInlineVertexStride >> 2;
    if (dwInlineVertexStride == 1) dwInlineVertexStride = 2; // workaround for kelvin bug
    dwKelvinMaxInlineVertices = NVPUSHER_MAX_METHOD_COUNT / dwInlineVertexStride;

    // tell the hardware what kind of thing we're going to draw
    nvAssert (kelvinBeginEndOp[pContext->dp2.dwDP2Prim] != ~0);

    nvglSetStartMethod (0, NV_DD_KELVIN, NV097_SET_BEGIN_END, 1);
    nvglSetData (1, kelvinBeginEndOp[pContext->dp2.dwDP2Prim]);
    nvglAdjust (2);

    // determine the number of vertices
    dwScaleAndBias = kelvinPrimitiveToVertexCountScaleAndBias[pContext->dp2.dwDP2Prim];
    nvAssert (dwScaleAndBias != ~0);
    numVertices = (dwScaleAndBias >> 16) * dwCount + (dwScaleAndBias & 0xffff);

    emittedVertices = 0;

    while (numVertices > dwKelvinMaxInlineVertices) {
        // attempt to kick off some work already
        nvPusherStart (FALSE);
        // send more vertices
        nvKelvinDumpIndexedInlineVertexBlock (pContext, emittedVertices, dwKelvinMaxInlineVertices,
                                              bLegacyStrides, dwInlineVertexStride);
        emittedVertices += dwKelvinMaxInlineVertices;
        numVertices     -= dwKelvinMaxInlineVertices;
    }

    // dump the remainder
    nvKelvinDumpIndexedInlineVertexBlock (pContext, emittedVertices, numVertices,
                                          bLegacyStrides, dwInlineVertexStride);

    nvglSetStartMethod (0, NV_DD_KELVIN, NV097_SET_BEGIN_END, 1);
    nvglSetData (1, NV097_SET_BEGIN_END_OP_END);
    nvglAdjust (2);

    // attempt to kick off some work already
    nvPusherStart (FALSE);
}

#endif  // NVARCH > 0x020
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\kelvin\src\nvkelvininltri.cpp ===
/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nvKelvinInlTri.cpp                                               *
*       indexed and ordered inline triangle lists                           *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Scott Kephart           18Nov00         Ported from NV10            *
*                                                                           *
\***************************************************************************/
#include "nvprecomp.h"

#if (NVARCH >= 0x10)

#include "x86.h"

#ifdef KELVIN_ILC

//////////////////////////////////////////////////////////////////////////////
// notes:
//  - when offset changes, only program it, dont call setcelsiusstate
//
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// switches
//

//////////////////////////////////////////////////////////////////////////////
// aliases
//
#define ilcData         global.dwILCData
#define ilcCount        global.dwILCCount
#define ilcMax          global.dwILCMax

//////////////////////////////////////////////////////////////////////////////
// externals
//
void ILCCompile_mul                             (DWORD reg,DWORD num);
void nvKelvinILCompile_beginEnd                 (DWORD dwPrimType);
void nvKelvinILCompile_computeIndexAndOffset    (DWORD dwVBStride,DWORD dwVBLogStride);
void nvKelvinILCompile_memcpy                   (DWORD dwCount, bool recurse);
void nvKelvinILCompile_copyVertex               (PNVD3DCONTEXT pContext,DWORD dwFlags);
void nvKelvinILCompile_prefetch                 (BOOL bIsIndexed,BOOL bLegacyStrides);
void nvKelvinILCompile_limit                    (DWORD regLimit,DWORD regDummy);

void __stdcall nvKelvinDispatchGetFreeSpace   (PNVD3DCONTEXT pContext);
void __stdcall nvKelvinDispatchGetPusherSpace (void);
#ifdef DEBUG
void __stdcall nvKelvinDispatchFlush          (void);
void __stdcall nvKelvinDispatchPrintVertex    (PNVD3DCONTEXT pContext,DWORD dwPutAddress);
#endif

/*****************************************************************************
 *****************************************************************************
 *** helpers *****************************************************************
 *****************************************************************************
 *****************************************************************************/

void nvKelvinILCompile_cullcheck
(
    BOOL bIsIndexed
)
{
    //
    // get vertices into eax, ebx and ecx
    //
    if (bIsIndexed)
    {
        // already set up correctly
    }
    else
    {
        xMOV_r_i32       (rEAX,mMEM32(global.kelvin.pVertices))
        xMOV_r_rm        (rEBX,rmREG(rEAX))
        xMOV_r_rm        (rECX,rmREG(rEAX))
        xADD_rm_imm      (rmREG(rEBX),global.kelvin.dwVertexStride)
        xADD_rm_imm      (rmREG(rECX),global.kelvin.dwVertexStride * 2)
    }

    //
    // compute cross product
    //
    if (pDriverData->nvD3DPerfData.dwCPUFeatureSet & FS_KATMAI)
    {
        /*
         * katmai
         */
        xMOVLPS_r_rm     (rXMM0,rmIND(rEAX))
        xMOVLPS_r_rm     (rXMM1,rmIND(rEBX))
        xSHUFPS_r_rm_imm (rXMM0,rmREG(rXMM0),0x44)          // xmm0: y0     x0      y0      x0
        xMOVHPS_r_rm     (rXMM1,rmIND(rECX))                // xmm1: y2     x2      y1      x1

        xSUBPS_r_rm      (rXMM1,rmREG(rXMM0))               // xmm1: y2-y0  x2-x0   y1-y0   x1-x0
        xSHUFPS_r_rm_imm (rXMM1,rmREG(rXMM1),0xe1)          // xmm1: y2-y0  x2-x0   x1-x0   y1-y0

        xMOVHLPS_r_r     (rXMM0,rXMM1)                      // xmm0: ?      ?       y2-y0   x2-x0
        xMULPS_r_rm      (rXMM0,rmREG(rXMM1))               // xmm0: ?      ?       (x1-x0)*(y2-y0) (y1-y0)*(x2-x0)

        xMOVAPS_r_rm     (rXMM1,rmREG(rXMM0))
        xSHUFPS_r_rm_imm (rXMM1,rmREG(rXMM1),0xe1)          // xmm1: ?      ?       ?       (x1-x0)*(y2-y0)

        xSUBSS_r_rm      (rXMM1,rmREG(rXMM0))               // xmm1: ?      ?       ?       (x1-x0)*(y2-y0)-(y1-y0)*(x2-x0)
        xMOVSS_i32_r     (mMEM32(global.dwTemp),rXMM1)
        xMOV_r_i32       (rEDX,mMEM32(global.dwTemp))
        xAND_rm_imm      (rmREG(rEDX),0x80000000)
        xCMP_r_i32       (rEDX,mMEM32(global.kelvin.dwCullValue))
    }
    else
    {
        /*
         * generic
         */
        xFLD_rm32  (rmIND(rEAX))                    // X0
        xFLD_rm32  (rmIND(rEBX))                    // X1 | X0
        xFXCH_st   (rST1)                           // X0 | X1
        xFSUBP_st  (rST1)                           // X1-X0
        xFLD_rm32  (rmIND8(rECX)) xOFS8(4)          // Y2 | X1-X0
        xFXCH_st   (rST1)                           // X1-X0 | Y2
        xFLD_rm32  (rmIND8(rEAX)) xOFS8(4)          // Y0 | X1-X0 | Y2
        xFXCH_st   (rST1)                           // X1-X0 | Y0 | Y2
        xFLD_rm32  (rmIND(rECX))                    // X2 | X1-X0 | Y0 | Y2
        xFXCH_st   (rST3)                           // Y2 | X1-X0 | Y0 | X2
        xFLD_rm32  (rmIND(rEAX))                    // X0 | Y2 | X1-X0 | Y0 | X2
        xFXCH_st   (rST3)                           // Y0 | Y2 | X1-X0 | X0 | X2
        xFSUBP_st  (rST1)                           // Y2-Y0 | X1-X0 | X0 | X2
        xFXCH_st   (rST3)                           // X2 | X1-X0 | X0 | Y2-Y0
        xFLD_rm32  (rmIND8(rEBX)) xOFS8(4)          // Y1 | X2 | X1-X0 | X0 | Y2-Y0
        xFXCH_st   (rST3)                           // X0 | X2 | X1-X0 | Y1 | Y2-Y0
        xFSUBP_st  (rST1)                           // X2-X0 | X1-X0 | Y1 | Y2-Y0
        xFXCH_st   (rST3)                           // Y2-Y0 | X1-X0 | Y1 | X2-X0
        xFLD_rm32  (rmIND8(rEAX)) xOFS8(4)          // Y0 | Y2-Y0 | X1-X0 | Y1 | X2-X0
        xFXCH_st   (rST2)                           // X1-X0 | Y2-Y0 | Y0 | Y1 | X2-X0
        xFMULP_st  (rST1)                           // (X1-X0)(Y2-Y0) | Y0 | Y1 | X2-X0
        xFXCH_st   (rST1)                           // Y0 | (X1-X0)(Y2-Y0) | Y1 | X2-X0
        xFSUBP_st  (rST2)                           // (X1-X0)(Y2-Y0) | Y1-Y0 | X2-X0
        xFXCH_st   (rST2)                           // X2-X0 | Y1-Y0 | (X1-X0)(Y2-Y0)
        xFMULP_st  (rST1)                           // (X2-X0)(Y1-Y0) | (X1-X0)(Y2-Y0)
        xFSUBP_st  (rST1)                           // (X1-X0)(Y2-Y0)-(X2-X0)(Y1-Y0)
        xFSTP_i32  (mMEM32(global.dwTemp))
        xMOV_r_i32       (rEDX,mMEM32(global.dwTemp))
        xAND_rm_imm      (rmREG(rEDX),0x80000000)
        xCMP_r_i32       (rEDX,mMEM32(global.kelvin.dwCullValue))
    }
}

/*****************************************************************************
 *****************************************************************************
 *** inline triangle lists ***************************************************
 *****************************************************************************
 *****************************************************************************/
DWORD nvKelvinILCompile_inline_tri_list
(
    PNVD3DCONTEXT pContext,
    DWORD         dwFlags
)
{
    //
    // get loop constants
    //
    BOOL   bLegacyStrides = dwFlags & KELVIN_ILFLAG_LEGACY;
    BOOL   bIsIndexed     = (dwFlags & KELVIN_ILMASK_LOOPTYPE) == KELVIN_ILFLAG_IX_INL_TRI_LIST;

    //
    // align entry point
    //
    while (ilcCount & 31) { xINT3 }
    DWORD lEntry;
    xLABEL (lEntry);

    //
    // setup stack frame
    //
    xPUSH_r     (rEBP)
    xPUSH_r     (rEBX)
    xPUSH_r     (rESI)
    xPUSH_r     (rEDI)

    //
    // verify that we are using the correct inner loop - debug only
    //
#ifdef DEBUG
    DWORD ld1,ld2;
    xLABEL      (ld1)
    xJMP        (0)
    xLABEL      (ld2)
    xINT3

#define CHECK(a,x)                  \
{                                   \
    xMOV_rm_imm (rmREG(rEBX),a)     \
    xMOV_rm_imm (rmREG(rEAX),x)     \
    xCMP_r_i32  (rEAX,mMEM32(x))    \
    xJNZ32      (ld2)               \
}
#define CHECK2(a,x,y,t)             \
{                                   \
    xMOV_r_i32  (rEDX,mMEM32(global.kelvin.x))    \
    xMOV_rm_imm (rmREG(rEBX),a)     \
    xMOV_rm_imm (rmREG(rEAX),x->y)   \
    xCMP_r_rm   (rEAX,rmIND32(rEDX)) xOFS32(OFFSETOF(t,y)) \
    xJNZ32      (ld2)               \
}

    xTARGET_jmp (ld1)

/*
    CHECK (0x00000000,fvfData.dwVertexStride)

    CHECK (0x00010000,fvfData.dwVertexType)

    CHECK (0x00020000,fvfData.dwUVCount[0])
    CHECK (0x00020001,fvfData.dwUVCount[1])
    CHECK (0x00020002,fvfData.dwUVCount[2])
    CHECK (0x00020003,fvfData.dwUVCount[3])
    CHECK (0x00020004,fvfData.dwUVCount[4])
    CHECK (0x00020005,fvfData.dwUVCount[5])
    CHECK (0x00020006,fvfData.dwUVCount[6])
    CHECK (0x00020007,fvfData.dwUVCount[7])

    CHECK (0x00030000,fvfData.dwUVOffset[0])
    CHECK (0x00030001,fvfData.dwUVOffset[1])
    CHECK (0x00030002,fvfData.dwUVOffset[2])
    CHECK (0x00030003,fvfData.dwUVOffset[3])
    CHECK (0x00030004,fvfData.dwUVOffset[4])
    CHECK (0x00030005,fvfData.dwUVOffset[5])
    CHECK (0x00030006,fvfData.dwUVOffset[6])
    CHECK (0x00030007,fvfData.dwUVOffset[7])
*/

    //  - pContext->hwState.dwStateFlags & KELVIN_MASK_INNERLOOPUNIQUENESS
    xMOV_r_i32  (rEDX,mMEM32(global.kelvin.pContext))
    xMOV_rm_imm (rmREG(rEBX),0x00040000)
    xMOV_r_rm   (rEAX,rmIND32(rEDX)) xOFS32(OFFSETOF(NVD3DCONTEXT, hwState.dwStateFlags))
    xAND_rm_imm (rmREG(rEAX),KELVIN_MASK_INNERLOOPUNIQUENESS)
    xCMP_rm_imm (rmREG(rEAX),pContext->hwState.dwStateFlags & KELVIN_MASK_INNERLOOPUNIQUENESS)
    xJNZ32      (ld2)

    if (pContext->hwState.dwStateFlags & KELVIN_FLAG_USERTEXCOORDSNEEDED(0))
    {
        CHECK2 (0x00050000,pContext,hwState.dwTexUnitToTexStageMapping[0],NVD3DCONTEXT)
    }
    if (pContext->hwState.dwStateFlags & KELVIN_FLAG_USERTEXCOORDSNEEDED(1))
    {
        CHECK2 (0x00050001,pContext,hwState.dwTexUnitToTexStageMapping[1],NVD3DCONTEXT)
    }
#endif

    //
    // setup push buffer
    //
    xMOV_r_i32  (rEDX,mMEM32(pDriverData))
    xMOV_r_rm   (rEDI,rmIND32(rEDX)) xOFS32(OFFSETOF(CDriverContext,nvPusher.m_dwPut))

    //
    // calc how many verts to copy into EBX
    //
    xMOV_r_i32  (rEBX,mMEM32(global.kelvin.dwPrimCount))
    ILCCompile_mul (rEBX,bLegacyStrides ? 4 : 3);

    //
    // setup prefetcher (EBX has # of vertices to copy in total)
    //
    if (bIsIndexed)
    {
        xMOV_r_i32  (rEAX,mMEM32(global.kelvin.pIndices))
         xLEA_r_rm   (rECX,rmSIB) xSIB(rEAX,rEBX,x2)
        xMOV_i32_r  (mMEM32(global.kelvin.dwPrefetchBase),rEAX)
         xMOV_i32_r  (mMEM32(global.kelvin.dwPrefetchMax),rECX)
    }
    else
    {
        xMOV_r_i32  (rEAX,mMEM32(global.kelvin.pVertices))
         xMOV_r_rm   (rECX,rmREG(rEBX))
         ILCCompile_mul (rECX,global.kelvin.dwVertexStride);
         xADD_r_rm   (rECX,rmREG(rEAX))
        xMOV_i32_r  (mMEM32(global.kelvin.dwPrefetchBase),rEAX)
         xMOV_i32_r  (mMEM32(global.kelvin.dwPrefetchMax),rECX)
    }

    //
    // start primitive
    //
    xMOV_rm_imm (rmREG(rEAX),((sizeSetNv20KelvinBeginEndMthdCnt << 2) << 16) | ((NV_DD_KELVIN) << 13) | NV097_SET_BEGIN_END);
    xMOV_rm_imm (rmREG(rECX),NV097_SET_BEGIN_END_OP_TRIANGLES)
    xMOV_rm_r   (rmIND(rEDI),rEAX)
    xMOV_rm_r   (rmIND8(rEDI),rECX) xOFS8(4)
    xLEA_r_rm   (rEDI,rmIND8(rEDI)) xOFS8(8)

    //
    // load prim count into EBX
    //
    xMOV_r_i32  (rEBX,mMEM32(global.kelvin.dwPrimCount))

    //
    // start copying
    //   for this loop EDI points to PUT and EBX has the amount of prims to go
    //
    DWORD labelEarlyExit;
    DWORD labelLoop;
    xLABEL  (labelLoop)
    {
        xPUSH_r     (rEBX)

        //
        // prefetch
        //
        nvKelvinILCompile_prefetch (bIsIndexed,bLegacyStrides);

        //
        // do two triangles at a time
        //
        for (DWORD dwTriNum = 0; dwTriNum < 2; dwTriNum++)
        {
            if (bIsIndexed)
            {
                //
                // compute vertices
                //
                xMOV_r_i32  (rEDX,mMEM32(global.kelvin.pIndices))
                xXOR_r_rm   (rECX,rmREG(rECX))
                xLEA_r_rm   (rEAX,rmIND8(rEDX)) xOFS8 (bLegacyStrides ? 8 : 6)
                xMOV_r_rm   (rEBX,rmIND(rEDX))
           x16r xMOV_r_rm   (rCX,rmIND8(rEDX)) xOFS8(4)
                xMOV_i32_r  (mMEM32(global.kelvin.pIndices),rEAX)
                xMOV_r_rm   (rEAX,rmREG(rEBX))
                xSHR_rm_imm8(rmREG(rEBX),16)
                xAND_rm_imm (rmREG(rEAX),0xffff)
                // convert indices to vertex address with limit checking (on NT)
                ILCCompile_mul (rECX,global.kelvin.dwVertexStride);
                ILCCompile_mul (rEBX,global.kelvin.dwVertexStride);
                ILCCompile_mul (rEAX,global.kelvin.dwVertexStride);
                nvKelvinILCompile_limit (rECX,rEDX);
                nvKelvinILCompile_limit (rEBX,rEDX);
                nvKelvinILCompile_limit (rEAX,rEDX);
                xADD_r_i32  (rEBX,mMEM32(global.kelvin.pVertices))
                xADD_r_i32  (rEAX,mMEM32(global.kelvin.pVertices))
                xADD_r_i32  (rECX,mMEM32(global.kelvin.pVertices))
            }

            //
            // do cull check
            //      indexed - eax,ebx and ecx has vertex addresses
            //      ordered - pVertices has vertex0, rest follow in dwVertexStride increments
            DWORD labelCull;
            if (!(dwFlags & KELVIN_ILFLAG_NOCULL))
            {
                nvKelvinILCompile_cullcheck (bIsIndexed);
                xLABEL      (labelCull)
                xJZ32       (0)
            }

            //
            // copy vertices
            //
            if (bIsIndexed)
            {
                xPUSH_r     (rECX)
                xPUSH_r     (rEBX)
                xMOV_r_rm   (rESI,rmREG(rEAX))
                nvKelvinILCompile_copyVertex (pContext,dwFlags);
                xPOP_r      (rESI)
                nvKelvinILCompile_copyVertex (pContext,dwFlags);
                xPOP_r      (rESI)
                nvKelvinILCompile_copyVertex (pContext,dwFlags);
            }
            else
            {
                xMOV_r_i32  (rESI,mMEM32(global.kelvin.pVertices))
                nvKelvinILCompile_copyVertex (pContext,dwFlags);
                xADD_rm_imm (rmREG(rESI),global.kelvin.dwVertexStride)
                nvKelvinILCompile_copyVertex (pContext,dwFlags);
                xADD_rm_imm (rmREG(rESI),global.kelvin.dwVertexStride)
                nvKelvinILCompile_copyVertex (pContext,dwFlags);
            }

            if (!(dwFlags & KELVIN_ILFLAG_NOCULL))
            {
                xTARGET_b32 (labelCull)
            }

            // update instrumentation count (include culled tris so we have a normalized result)
#ifdef INSTRUMENT_INNER_LOOPS
            {
                xMOV_rm_imm (rmREG(rEAX),fvfData.dwVertexStride * 3)
                xADD_i32_r  (mMEM32(global.dwBytesCopied),rEAX)
            }
#endif

            //
            // next triangle
            //
            if (bIsIndexed)
            {
                // nothing to do here
            }
            else
            {
                xMOV_r_i32  (rEAX,mMEM32(global.kelvin.pVertices))
                xADD_rm_imm (rmREG(rEAX),global.kelvin.dwVertexStride * 3)
                xMOV_i32_r  (mMEM32(global.kelvin.pVertices),rEAX)
            }

            //
            // done already? (odd # of triangles)
            //
            if (dwTriNum == 0)
            {
                xPOP_r  (rEBX)
                xDEC_rm (rmREG(rEBX))
                xLABEL  (labelEarlyExit)
                xJZ32   (0)
                xPUSH_r (rEBX)
            }
        }

/*
        //
        // copy vertex
        //
        if (bIsIndexed)
        {
            // get index
            xMOV_r_i32  (rEDX,mMEM32(global.celsius.pIndices))
            xXOR_r_rm   (rESI,rmREG(rESI))
       x16r xMOV_r_rm   (rSI,rmIND(rEDX))
            xLEA_r_rm   (rEDX,rmIND8(rEDX)) xOFS8(2)
            if (bLegacyStrides)
            {

// do in setup ....
          if (bLegacyStrides)
        {
            xMOV_r_i32  (rEAX,mMEM32(global.celsius.pIndices))
            xMOV_i32_r  (mMEM32(global.celsius.pIndexBase),rEAX)
        }


                xMOV_r_rm   (rEAX,rmREG(rEDX))
                xSUB_r_i32  (rEAX,mMEM32(global.celsius.pIndexBase))
                xAND_rm_imm (rmREG(rEAX),6)
                xXOR_r_rm   (rECX,rmREG(rECX))
                xCMP_rm_imm (rmREG(rEAX),6)
                xSETNZ_rm8  (rmREG(rCL))
                xDEC_rm     (rmREG(rECX))
                xAND_rm_imm (rmREG(rECX),2)
                xADD_r_rm   (rEDX,rmREG(rECX))
            }
            xMOV_i32_r  (mMEM32(global.celsius.pIndices),rEDX)
            // compute vertex offset
            ILCCompile_mul (rESI,fvfData.dwVertexStride);
            // range limit
            xXOR_r_rm   (rECX,rmREG(rECX))
            xCMP_r_i32  (rESI,mMEM32(global.dwMaxVertexOffset))
            xSETAE_rm8  (rmREG(rCL))
            xDEC_rm     (rmREG(rECX))
            xAND_r_rm   (rESI,rmREG(rECX))
            // compute vertex address
            xADD_r_i32  (rESI,mMEM32(global.celsius.pVertices))
        }
        else
        {
            // get vertex & increment
            xMOV_r_i32  (rESI,mMEM32(global.celsius.pVertices))
            xLEA_r_rm   (rEAX,rmIND32(rESI)) xOFS32(fvfData.dwVertexStride)
            xMOV_i32_r  (mMEM32(global.celsius.pVertices),rEAX)
        }

        // copy vertex (from ESI to EDI)
        nvCelsiusILCompile_copyVertex (pContext);
*/

        // check for pusher space
        DWORD labelSpace;
        xMOV_r_i32  (rESI,mMEM32(pDriverData))
        xCMP_r_rm   (rEDI,rmIND32(rESI)) xOFS32(OFFSETOF(CDriverContext,nvPusher.m_dwThreshold))
        xLABEL      (labelSpace)
        xJL         (0)
        {
            xMOV_rm_r   (rmIND32(rESI),rEDI) xOFS32(OFFSETOF(CDriverContext,nvPusher.m_dwPut))
            xMOV_rm_imm (rmREG(rEAX),(DWORD)nvKelvinDispatchGetPusherSpace)
            xCALL_rm    (rmREG(rEAX))
            xMOV_r_rm   (rEDI,rmIND32(rESI)) xOFS32(OFFSETOF(CDriverContext,nvPusher.m_dwPut))
        }
        xTARGET_b8  (labelSpace)

        // next
        xPOP_r  (rEBX)
        xDEC_rm (rmREG(rEBX))
    }
    xJNZ32      (labelLoop)
    xTARGET_b32 (labelEarlyExit)

    //
    // end primitive
    //
    xMOV_rm_imm (rmREG(rEAX),((sizeSetNv20KelvinBeginEndMthdCnt << 2) << 16) | ((NV_DD_KELVIN) << 13) | NV097_SET_BEGIN_END);
    xMOV_rm_imm (rmREG(rECX),NV097_SET_BEGIN_END_OP_END)
    xMOV_rm_r   (rmIND(rEDI),rEAX)
    xMOV_rm_r   (rmIND8(rEDI),rECX) xOFS8(4)
    xLEA_r_rm   (rEDI,rmIND8(rEDI)) xOFS8(8)

    //
    // save off push buffer
    //
    xMOV_r_i32  (rEDX,mMEM32(pDriverData))
#ifndef NV_NULL_HW_DRIVER
    xMOV_rm_r   (rmIND32(rEDX),rEDI) xOFS32(OFFSETOF(CDriverContext,nvPusher.m_dwPut))
#endif

    //
    // done
    //
    xPOP_r      (rEDI)
    xPOP_r      (rESI)
    xPOP_r      (rEBX)
    xPOP_r      (rEBP)
    xRET
    return lEntry;
}

#endif  //KELVIN_ILC
#endif  // NVARCH == 0x10
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\kelvin\src\nvKelvinTables.cpp ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// ********************************* Direct 3D ******************************
//
//  Module: nvKelvinTables.cpp
//      tables of values and constants related to the kelvin object
//
// **************************************************************************
//
//  History:
//       Craig Duttweiler        28Apr2000         NV20 development
//
// **************************************************************************
#include "nvprecomp.h"

#if (NVARCH >= 0x20)

//---------------------------------------------------------------------------

// table of precomputed combiner settings for stupid legacy texture blends.

// the table is indexed as [i][j]
// where i = D3DTBLEND_BLAH
//       j=0 => alpha_icw[0]
//       j=1 => color_icw[0]
//       j=2 => alpha_ocw[0]
//       j=3 => color_ocw[0]

DWORD kelvinTextureBlendSettings[D3D_TBLEND_MAX+1][4] =
{
    // i=0
    // invalid

    ~0,
    ~0,
    ~0,
    ~0,

    // i=1
    // D3DTBLEND_DECAL
    // aPix = aTex
    // cPix = cTex

    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _A_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _A_ALPHA,  _TRUE)              |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _A_SOURCE, _REG_8)             |  // aTex0
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _B_MAP,    _UNSIGNED_INVERT)   |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _B_ALPHA,  _TRUE)              |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _B_SOURCE, _REG_0)             |  // 1
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _C_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _C_ALPHA,  _TRUE)              |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _C_SOURCE, _REG_0)             |  // 0
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _D_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _D_ALPHA,  _TRUE)              |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _D_SOURCE, _REG_0),               // 0

    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _A_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _A_ALPHA,  _FALSE)             |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _A_SOURCE, _REG_8)             |  // cTex0
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _B_MAP,    _UNSIGNED_INVERT)   |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _B_ALPHA,  _FALSE)             |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _B_SOURCE, _REG_0)             |  // 1
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _C_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _C_ALPHA,  _FALSE)             |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _C_SOURCE, _REG_0)             |  // 0
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _D_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _D_ALPHA,  _FALSE)             |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _D_SOURCE, _REG_0),               // 0

    DRF_DEF(097, _SET_COMBINER_ALPHA_OCW, _OPERATION,  _NOSHIFT) |
    DRF_DEF(097, _SET_COMBINER_ALPHA_OCW, _MUX_ENABLE, _FALSE)   |
    DRF_DEF(097, _SET_COMBINER_ALPHA_OCW, _SUM_DST,    _REG_C)   |  // a*b + c*d => r12
    DRF_DEF(097, _SET_COMBINER_ALPHA_OCW, _AB_DST,     _REG_0)   |  // dev/null
    DRF_DEF(097, _SET_COMBINER_ALPHA_OCW, _CD_DST,     _REG_0),     // dev/null

    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _BLUETOALPHA_AB, _DISABLE) |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _BLUETOALPHA_CD, _DISABLE) |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _OP,             _NOSHIFT) |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _MUX_ENABLE,     _FALSE)   |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _AB_DOT_ENABLE,  _FALSE)   |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _CD_DOT_ENABLE,  _FALSE)   |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _SUM_DST,        _REG_C)   |  // a*b + c*d => r12
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _AB_DST,         _REG_0)   |  // dev/null
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _CD_DST,         _REG_0),     // dev/null

    // i=2
    // D3DTBLEND_MODULATE
    // aPix = aTex
    // cPix = cTex * cDiffuse

    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _A_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _A_ALPHA,  _TRUE)              |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _A_SOURCE, _REG_8)             |  // aTex0
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _B_MAP,    _UNSIGNED_INVERT)   |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _B_ALPHA,  _TRUE)              |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _B_SOURCE, _REG_0)             |  // 1
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _C_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _C_ALPHA,  _TRUE)              |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _C_SOURCE, _REG_0)             |  // 0
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _D_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _D_ALPHA,  _TRUE)              |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _D_SOURCE, _REG_0),               // 0

    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _A_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _A_ALPHA,  _FALSE)             |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _A_SOURCE, _REG_8)             |  // cTex0
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _B_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _B_ALPHA,  _FALSE)             |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _B_SOURCE, _REG_4)             |  // cDiffuse
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _C_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _C_ALPHA,  _FALSE)             |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _C_SOURCE, _REG_0)             |  // 0
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _D_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _D_ALPHA,  _FALSE)             |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _D_SOURCE, _REG_0),               // 0

    DRF_DEF(097, _SET_COMBINER_ALPHA_OCW, _OPERATION,  _NOSHIFT) |
    DRF_DEF(097, _SET_COMBINER_ALPHA_OCW, _MUX_ENABLE, _FALSE)   |
    DRF_DEF(097, _SET_COMBINER_ALPHA_OCW, _SUM_DST,    _REG_C)   |  // a*b + c*d => r12
    DRF_DEF(097, _SET_COMBINER_ALPHA_OCW, _AB_DST,     _REG_0)   |  // dev/null
    DRF_DEF(097, _SET_COMBINER_ALPHA_OCW, _CD_DST,     _REG_0),     // dev/null

    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _BLUETOALPHA_AB, _DISABLE) |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _BLUETOALPHA_CD, _DISABLE) |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _OP,             _NOSHIFT) |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _MUX_ENABLE,     _FALSE)   |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _AB_DOT_ENABLE,  _FALSE)   |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _CD_DOT_ENABLE,  _FALSE)   |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _SUM_DST,        _REG_C)   |  // a*b + c*d => r12
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _AB_DST,         _REG_0)   |  // dev/null
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _CD_DST,         _REG_0),     // dev/null

    // i=3
    // D3DTBLEND_DECALALPHA
    // aPix = aDiffuse
    // cPix = ((1 - aTex) * cDiffuse) + (aTex * cTex)

    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _A_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _A_ALPHA,  _TRUE)              |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _A_SOURCE, _REG_4)             |  // aDiffuse
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _B_MAP,    _UNSIGNED_INVERT)   |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _B_ALPHA,  _TRUE)              |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _B_SOURCE, _REG_0)             |  // 1
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _C_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _C_ALPHA,  _TRUE)              |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _C_SOURCE, _REG_0)             |  // 0
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _D_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _D_ALPHA,  _TRUE)              |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _D_SOURCE, _REG_0),               // 0

    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _A_MAP,    _UNSIGNED_INVERT)   |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _A_ALPHA,  _TRUE)              |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _A_SOURCE, _REG_8)             |  // 1-aTex0
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _B_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _B_ALPHA,  _FALSE)             |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _B_SOURCE, _REG_4)             |  // cDiffuse
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _C_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _C_ALPHA,  _TRUE)              |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _C_SOURCE, _REG_8)             |  // aTex0
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _D_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _D_ALPHA,  _FALSE)             |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _D_SOURCE, _REG_8),               // cTex0

    DRF_DEF(097, _SET_COMBINER_ALPHA_OCW, _OPERATION,  _NOSHIFT) |
    DRF_DEF(097, _SET_COMBINER_ALPHA_OCW, _MUX_ENABLE, _FALSE)   |
    DRF_DEF(097, _SET_COMBINER_ALPHA_OCW, _SUM_DST,    _REG_C)   |  // a*b + c*d => r12
    DRF_DEF(097, _SET_COMBINER_ALPHA_OCW, _AB_DST,     _REG_0)   |  // dev/null
    DRF_DEF(097, _SET_COMBINER_ALPHA_OCW, _CD_DST,     _REG_0),     // dev/null

    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _BLUETOALPHA_AB, _DISABLE) |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _BLUETOALPHA_CD, _DISABLE) |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _OP,             _NOSHIFT) |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _MUX_ENABLE,     _FALSE)   |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _AB_DOT_ENABLE,  _FALSE)   |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _CD_DOT_ENABLE,  _FALSE)   |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _SUM_DST,        _REG_C)   |  // a*b + c*d => r12
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _AB_DST,         _REG_0)   |  // dev/null
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _CD_DST,         _REG_0),     // dev/null

    // i=4
    // D3DTBLEND_MODULATEALPHA
    // aPix = aTex * aDiffuse
    // cPix = cTex * cDiffuse

    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _A_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _A_ALPHA,  _TRUE)              |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _A_SOURCE, _REG_8)             |  // aTex0
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _B_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _B_ALPHA,  _TRUE)              |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _B_SOURCE, _REG_4)             |  // aDiffuse
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _C_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _C_ALPHA,  _TRUE)              |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _C_SOURCE, _REG_0)             |  // 0
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _D_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _D_ALPHA,  _TRUE)              |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _D_SOURCE, _REG_0),               // 0

    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _A_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _A_ALPHA,  _FALSE)             |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _A_SOURCE, _REG_8)             |  // cTex0
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _B_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _B_ALPHA,  _FALSE)             |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _B_SOURCE, _REG_4)             |  // cDiffuse
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _C_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _C_ALPHA,  _FALSE)             |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _C_SOURCE, _REG_0)             |  // 0
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _D_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _D_ALPHA,  _FALSE)             |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _D_SOURCE, _REG_0),               // 0

    DRF_DEF(097, _SET_COMBINER_ALPHA_OCW, _OPERATION,  _NOSHIFT) |
    DRF_DEF(097, _SET_COMBINER_ALPHA_OCW, _MUX_ENABLE, _FALSE)   |
    DRF_DEF(097, _SET_COMBINER_ALPHA_OCW, _SUM_DST,    _REG_C)   |  // a*b + c*d => r12
    DRF_DEF(097, _SET_COMBINER_ALPHA_OCW, _AB_DST,     _REG_0)   |  // dev/null
    DRF_DEF(097, _SET_COMBINER_ALPHA_OCW, _CD_DST,     _REG_0),     // dev/null

    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _BLUETOALPHA_AB, _DISABLE) |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _BLUETOALPHA_CD, _DISABLE) |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _OP,             _NOSHIFT) |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _MUX_ENABLE,     _FALSE)   |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _AB_DOT_ENABLE,  _FALSE)   |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _CD_DOT_ENABLE,  _FALSE)   |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _SUM_DST,        _REG_C)   |  // a*b + c*d => r12
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _AB_DST,         _REG_0)   |  // dev/null
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _CD_DST,         _REG_0),     // dev/null

    // i=5
    // D3DTBLEND_DECALMASK
    // aPix = aDiffuse
    // cPix = lsb(aTex) ? cTex : cDiffuse

    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _A_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _A_ALPHA,  _TRUE)              |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _A_SOURCE, _REG_4)             |  // aDiffuse
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _B_MAP,    _UNSIGNED_INVERT)   |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _B_ALPHA,  _TRUE)              |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _B_SOURCE, _REG_0)             |  // 1
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _C_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _C_ALPHA,  _TRUE)              |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _C_SOURCE, _REG_0)             |  // 0
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _D_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _D_ALPHA,  _TRUE)              |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _D_SOURCE, _REG_0),               // 0

    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _A_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _A_ALPHA,  _FALSE)             |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _A_SOURCE, _REG_4)             |  // cDiffuse
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _B_MAP,    _UNSIGNED_INVERT)   |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _B_ALPHA,  _FALSE)             |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _B_SOURCE, _REG_0)             |  // 1
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _C_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _C_ALPHA,  _FALSE)             |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _C_SOURCE, _REG_8)             |  // cTex0
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _D_MAP,    _UNSIGNED_INVERT)   |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _D_ALPHA,  _FALSE)             |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _D_SOURCE, _REG_0),               // 0

    DRF_DEF(097, _SET_COMBINER_ALPHA_OCW, _OPERATION,  _NOSHIFT) |
    DRF_DEF(097, _SET_COMBINER_ALPHA_OCW, _MUX_ENABLE, _FALSE)   |
    DRF_DEF(097, _SET_COMBINER_ALPHA_OCW, _SUM_DST,    _REG_C)   |  // a*b + c*d => r12
    DRF_DEF(097, _SET_COMBINER_ALPHA_OCW, _AB_DST,     _REG_0)   |  // dev/null
    DRF_DEF(097, _SET_COMBINER_ALPHA_OCW, _CD_DST,     _REG_0),     // dev/null

    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _BLUETOALPHA_AB, _DISABLE) |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _BLUETOALPHA_CD, _DISABLE) |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _OP,             _NOSHIFT) |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _MUX_ENABLE,     _TRUE)    |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _AB_DOT_ENABLE,  _FALSE)   |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _CD_DOT_ENABLE,  _FALSE)   |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _SUM_DST,        _REG_C)   |  // a*b + c*d => r12
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _AB_DST,         _REG_0)   |  // dev/null
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _CD_DST,         _REG_0),     // dev/null

    // i=6
    // D3DTBLEND_MODULATEMASK
    // aPix = aDiffuse
    // cPix = lsb(aTex) ? cTex * cDiffuse : cDiffuse

    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _A_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _A_ALPHA,  _TRUE)              |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _A_SOURCE, _REG_4)             |  // aDiffuse
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _B_MAP,    _UNSIGNED_INVERT)   |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _B_ALPHA,  _TRUE)              |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _B_SOURCE, _REG_0)             |  // 1
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _C_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _C_ALPHA,  _TRUE)              |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _C_SOURCE, _REG_0)             |  // 0
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _D_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _D_ALPHA,  _TRUE)              |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _D_SOURCE, _REG_0),               // 0

    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _A_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _A_ALPHA,  _FALSE)             |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _A_SOURCE, _REG_4)             |  // cDiffuse
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _B_MAP,    _UNSIGNED_INVERT)   |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _B_ALPHA,  _FALSE)             |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _B_SOURCE, _REG_0)             |  // 1
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _C_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _C_ALPHA,  _FALSE)             |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _C_SOURCE, _REG_8)             |  // cTex0
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _D_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _D_ALPHA,  _FALSE)             |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _D_SOURCE, _REG_4),               // cDiffuse

    DRF_DEF(097, _SET_COMBINER_ALPHA_OCW, _OPERATION,  _NOSHIFT) |
    DRF_DEF(097, _SET_COMBINER_ALPHA_OCW, _MUX_ENABLE, _FALSE)   |
    DRF_DEF(097, _SET_COMBINER_ALPHA_OCW, _SUM_DST,    _REG_C)   |  // a*b + c*d => r12
    DRF_DEF(097, _SET_COMBINER_ALPHA_OCW, _AB_DST,     _REG_0)   |  // dev/null
    DRF_DEF(097, _SET_COMBINER_ALPHA_OCW, _CD_DST,     _REG_0),     // dev/null

    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _BLUETOALPHA_AB, _DISABLE) |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _BLUETOALPHA_CD, _DISABLE) |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _OP,             _NOSHIFT) |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _MUX_ENABLE,     _TRUE)    |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _AB_DOT_ENABLE,  _FALSE)   |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _CD_DOT_ENABLE,  _FALSE)   |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _SUM_DST,        _REG_C)   |  // a*b + c*d => r12
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _AB_DST,         _REG_0)   |  // dev/null
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _CD_DST,         _REG_0),     // dev/null

    // i=7
    // D3DTBLEND_COPY (same as DECAL)
    // aPix = aTex
    // cPix = cTex

    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _A_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _A_ALPHA,  _TRUE)              |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _A_SOURCE, _REG_8)             |  // aTex0
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _B_MAP,    _UNSIGNED_INVERT)   |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _B_ALPHA,  _TRUE)              |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _B_SOURCE, _REG_0)             |  // 1
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _C_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _C_ALPHA,  _TRUE)              |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _C_SOURCE, _REG_0)             |  // 0
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _D_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _D_ALPHA,  _TRUE)              |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _D_SOURCE, _REG_0),               // 0

    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _A_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _A_ALPHA,  _FALSE)             |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _A_SOURCE, _REG_8)             |  // cTex0
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _B_MAP,    _UNSIGNED_INVERT)   |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _B_ALPHA,  _FALSE)             |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _B_SOURCE, _REG_0)             |  // 1
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _C_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _C_ALPHA,  _FALSE)             |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _C_SOURCE, _REG_0)             |  // 0
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _D_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _D_ALPHA,  _FALSE)             |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _D_SOURCE, _REG_0),               // 0

    DRF_DEF(097, _SET_COMBINER_ALPHA_OCW, _OPERATION,  _NOSHIFT) |
    DRF_DEF(097, _SET_COMBINER_ALPHA_OCW, _MUX_ENABLE, _FALSE)   |
    DRF_DEF(097, _SET_COMBINER_ALPHA_OCW, _SUM_DST,    _REG_C)   |  // a*b + c*d => r12
    DRF_DEF(097, _SET_COMBINER_ALPHA_OCW, _AB_DST,     _REG_0)   |  // dev/null
    DRF_DEF(097, _SET_COMBINER_ALPHA_OCW, _CD_DST,     _REG_0),     // dev/null

    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _BLUETOALPHA_AB, _DISABLE) |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _BLUETOALPHA_CD, _DISABLE) |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _OP,             _NOSHIFT) |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _MUX_ENABLE,     _FALSE)   |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _AB_DOT_ENABLE,  _FALSE)   |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _CD_DOT_ENABLE,  _FALSE)   |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _SUM_DST,        _REG_C)   |  // a*b + c*d => r12
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _AB_DST,         _REG_0)   |  // dev/null
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _CD_DST,         _REG_0),     // dev/null

    // i=8
    // D3DTBLEND_ADD
    // aPix = aDiffuse
    // cPix = cTex + cDiffuse

    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _A_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _A_ALPHA,  _TRUE)              |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _A_SOURCE, _REG_4)             |  // aDiffuse
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _B_MAP,    _UNSIGNED_INVERT)   |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _B_ALPHA,  _TRUE)              |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _B_SOURCE, _REG_0)             |  // 1
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _C_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _C_ALPHA,  _TRUE)              |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _C_SOURCE, _REG_0)             |  // 0
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _D_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _D_ALPHA,  _TRUE)              |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _D_SOURCE, _REG_0),               // 0

    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _A_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _A_ALPHA,  _FALSE)             |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _A_SOURCE, _REG_8)             |  // cTex0
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _B_MAP,    _UNSIGNED_INVERT)   |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _B_ALPHA,  _FALSE)             |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _B_SOURCE, _REG_0)             |  // 1
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _C_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _C_ALPHA,  _FALSE)             |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _C_SOURCE, _REG_4)             |  // cDiffuse
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _D_MAP,    _UNSIGNED_INVERT)   |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _D_ALPHA,  _FALSE)             |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _D_SOURCE, _REG_0),               // 1

    DRF_DEF(097, _SET_COMBINER_ALPHA_OCW, _OPERATION,  _NOSHIFT) |
    DRF_DEF(097, _SET_COMBINER_ALPHA_OCW, _MUX_ENABLE, _FALSE)   |
    DRF_DEF(097, _SET_COMBINER_ALPHA_OCW, _SUM_DST,    _REG_C)   |  // a*b + c*d => r12
    DRF_DEF(097, _SET_COMBINER_ALPHA_OCW, _AB_DST,     _REG_0)   |  // dev/null
    DRF_DEF(097, _SET_COMBINER_ALPHA_OCW, _CD_DST,     _REG_0),     // dev/null

    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _BLUETOALPHA_AB, _DISABLE) |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _BLUETOALPHA_CD, _DISABLE) |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _OP,             _NOSHIFT) |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _MUX_ENABLE,     _FALSE)   |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _AB_DOT_ENABLE,  _FALSE)   |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _CD_DOT_ENABLE,  _FALSE)   |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _SUM_DST,        _REG_C)   |  // a*b + c*d => r12
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _AB_DST,         _REG_0)   |  // dev/null
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _CD_DST,         _REG_0)      // dev/null
};

//---------------------------------------------------------------------------

// combiner settings used when they enable a texture blend but not a texture
// aPix = aDiffuse
// cPix = cDiffuse

DWORD kelvinTextureBlendDefault[4] =
{
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _A_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _A_ALPHA,  _TRUE)              |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _A_SOURCE, _REG_4)             |  // aDiffuse
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _B_MAP,    _UNSIGNED_INVERT)   |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _B_ALPHA,  _TRUE)              |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _B_SOURCE, _REG_0)             |  // 1
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _C_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _C_ALPHA,  _TRUE)              |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _C_SOURCE, _REG_0)             |  // 0
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _D_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _D_ALPHA,  _TRUE)              |
    DRF_DEF(097, _SET_COMBINER_ALPHA_ICW, _D_SOURCE, _REG_0),               // 0

    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _A_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _A_ALPHA,  _FALSE)             |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _A_SOURCE, _REG_4)             |  // cDiffuse
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _B_MAP,    _UNSIGNED_INVERT)   |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _B_ALPHA,  _FALSE)             |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _B_SOURCE, _REG_0)             |  // 1
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _C_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _C_ALPHA,  _FALSE)             |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _C_SOURCE, _REG_0)             |  // 0
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _D_MAP,    _UNSIGNED_IDENTITY) |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _D_ALPHA,  _FALSE)             |
    DRF_DEF(097, _SET_COMBINER_COLOR_ICW, _D_SOURCE, _REG_0),               // 0

    DRF_DEF(097, _SET_COMBINER_ALPHA_OCW, _OPERATION,  _NOSHIFT) |
    DRF_DEF(097, _SET_COMBINER_ALPHA_OCW, _MUX_ENABLE, _FALSE)   |
    DRF_DEF(097, _SET_COMBINER_ALPHA_OCW, _SUM_DST,    _REG_C)   |  // a*b + c*d => r12
    DRF_DEF(097, _SET_COMBINER_ALPHA_OCW, _AB_DST,     _REG_0)   |  // dev/null
    DRF_DEF(097, _SET_COMBINER_ALPHA_OCW, _CD_DST,     _REG_0),     // dev/null

    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _BLUETOALPHA_AB, _DISABLE) |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _BLUETOALPHA_CD, _DISABLE) |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _OP,             _NOSHIFT) |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _MUX_ENABLE,     _FALSE)   |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _AB_DOT_ENABLE,  _FALSE)   |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _CD_DOT_ENABLE,  _FALSE)   |
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _SUM_DST,        _REG_C)   |  // a*b + c*d => r12
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _AB_DST,         _REG_0)   |  // dev/null
    DRF_DEF(097, _SET_COMBINER_COLOR_OCW, _CD_DST,         _REG_0)      // dev/null
};

//---------------------------------------------------------------------------

// table mapping dependencies between d3d renderstates and kelvin state.

// kelvinDirtyBitsFromRenderState[D3DRENDERSTATE_FOO] contains the kelvin class
// dirty bits that should be set whenever D3DRENDERSTATE_FOO is changed

DWORD kelvinDirtyBitsFromRenderState[D3D_RENDERSTATE_MAX+1] =
{
    0,                                                            //  0   invalid
    KELVIN_DIRTY_TEXTURE_STATE | KELVIN_DIRTY_TEXTURE_TRANSFORM | //  1   D3DRENDERSTATE_TEXTUREHANDLE
    KELVIN_DIRTY_COMBINERS_COLOR,
    0,                                                            //  2   D3DRENDERSTATE_ANTIALIAS
    KELVIN_DIRTY_TEXTURE_STATE,                                   //  3   D3DRENDERSTATE_TEXTUREADDRESS
    KELVIN_DIRTY_TEXTURE_STATE,                                   //  4   D3DRENDERSTATE_TEXTUREPERSPECTIVE
    KELVIN_DIRTY_TEXTURE_STATE,                                   //  5   D3DRENDERSTATE_WRAPU
    KELVIN_DIRTY_TEXTURE_STATE,                                   //  6   D3DRENDERSTATE_WRAPV
    KELVIN_DIRTY_TRANSFORM | KELVIN_DIRTY_CONTROL0 |              //  7   D3DRENDERSTATE_ZENABLE
    KELVIN_DIRTY_TEXTURE_STATE | KELVIN_DIRTY_MISC_STATE |
    KELVIN_DIRTY_MISC_STATE,
    KELVIN_DIRTY_MISC_STATE,                                      //  8   D3DRENDERSTATE_FILLMODE
    KELVIN_DIRTY_MISC_STATE,                                      //  9   D3DRENDERSTATE_SHADEMODE
    0,                                                            //  10  D3DRENDERSTATE_LINEPATTERN
    0,                                                            //  11  D3DRENDERSTATE_MONOENABLE
    0,                                                            //  12  D3DRENDERSTATE_ROP2
    KELVIN_DIRTY_MISC_STATE,                                      //  13  D3DRENDERSTATE_PLANEMASK
    KELVIN_DIRTY_MISC_STATE,                                      //  14  D3DRENDERSTATE_ZWRITEENABLE
    KELVIN_DIRTY_MISC_STATE,                                      //  15  D3DRENDERSTATE_ALPHATESTENABLE
    0,                                                            //  16  D3DRENDERSTATE_LASTPIXEL
    KELVIN_DIRTY_TEXTURE_STATE,                                   //  17  D3DRENDERSTATE_TEXTUREMAG
    KELVIN_DIRTY_TEXTURE_STATE,                                   //  18  D3DRENDERSTATE_TEXTUREMIN
    KELVIN_DIRTY_MISC_STATE,                                      //  19  D3DRENDERSTATE_SRCBLEND
    KELVIN_DIRTY_MISC_STATE,                                      //  20  D3DRENDERSTATE_DESTBLEND
    KELVIN_DIRTY_COMBINERS_COLOR,                                 //  21  D3DRENDERSTATE_TEXTUREMAPBLEND
    KELVIN_DIRTY_MISC_STATE,                                      //  22  D3DRENDERSTATE_CULLMODE
    KELVIN_DIRTY_MISC_STATE,                                      //  23  D3DRENDERSTATE_ZFUNC
    KELVIN_DIRTY_MISC_STATE,                                      //  24  D3DRENDERSTATE_ALPHAREF
    KELVIN_DIRTY_MISC_STATE,                                      //  25  D3DRENDERSTATE_ALPHAFUNC
    KELVIN_DIRTY_MISC_STATE,                                      //  26  D3DRENDERSTATE_DITHERENABLE
    KELVIN_DIRTY_MISC_STATE,                                      //  27  D3DRENDERSTATE_ALPHABLENDENABLE
    KELVIN_DIRTY_COMBINERS_SPECFOG | KELVIN_DIRTY_VERTEX_SHADER,  //  28  D3DRENDERSTATE_FOGENABLE
    KELVIN_DIRTY_LIGHTS | KELVIN_DIRTY_COMBINERS_SPECFOG,         //  29  D3DRENDERSTATE_SPECULARENABLE
    0,                                                            //  30  D3DRENDERSTATE_ZVISIBLE
    0,                                                            //  31  D3DRENDERSTATE_SUBPIXEL
    0,                                                            //  32  D3DRENDERSTATE_SUBPIXELX
    0,                                                            //  33  D3DRENDERSTATE_STIPPLEDALPHA
    KELVIN_DIRTY_COMBINERS_SPECFOG,                               //  34  D3DRENDERSTATE_FOGCOLOR
    KELVIN_DIRTY_COMBINERS_SPECFOG | KELVIN_DIRTY_VERTEX_SHADER,  //  35  D3DRENDERSTATE_FOGTABLEMODE
    KELVIN_DIRTY_COMBINERS_SPECFOG,                               //  36  D3DRENDERSTATE_FOGTABLESTART   (D3DRENDERSTATE_FOGSTART)
    KELVIN_DIRTY_COMBINERS_SPECFOG,                               //  37  D3DRENDERSTATE_FOGTABLEEND     (D3DRENDERSTATE_FOGEND)
    KELVIN_DIRTY_COMBINERS_SPECFOG,                               //  38  D3DRENDERSTATE_FOGTABLEDENSITY (D3DRENDERSTATE_FOGDENSITY)
    0,                                                            //  39  D3DRENDERSTATE_STIPPLEENABLE
    KELVIN_DIRTY_MISC_STATE,                                      //  40  D3DRENDERSTATE_EDGEANTIALIAS
    KELVIN_DIRTY_TEXTURE_STATE,                                   //  41  D3DRENDERSTATE_COLORKEYENABLE
    0,                                                            //  42  D3DRENDERSTATE_OLDALPHABLENDENABLE
    KELVIN_DIRTY_TEXTURE_STATE,                                   //  43  D3DRENDERSTATE_BORDERCOLOR
    KELVIN_DIRTY_TEXTURE_STATE,                                   //  44  D3DRENDERSTATE_TEXTUREADDRESSU
    KELVIN_DIRTY_TEXTURE_STATE,                                   //  45  D3DRENDERSTATE_TEXTUREADDRESSV
    KELVIN_DIRTY_TEXTURE_STATE,                                   //  46  D3DRENDERSTATE_MIPMAPLODBIAS
    KELVIN_DIRTY_MISC_STATE,                                      //  47  D3DRENDERSTATE_ZBIAS
    KELVIN_DIRTY_COMBINERS_SPECFOG,                               //  48  D3DRENDERSTATE_RANGEFOGENABLE
    KELVIN_DIRTY_TEXTURE_STATE,                                   //  49  D3DRENDERSTATE_ANISOTROPY
    0,                                                            //  50  D3DRENDERSTATE_FLUSHBATCH
    0,                                                            //  51  D3DRENDERSTATE_TRANSLUCENTSORTINDEPENDENT
    KELVIN_DIRTY_CONTROL0 | KELVIN_DIRTY_MISC_STATE,              //  52  D3DRENDERSTATE_STENCILENABLE
    KELVIN_DIRTY_MISC_STATE,                                      //  53  D3DRENDERSTATE_STENCILFAIL
    KELVIN_DIRTY_MISC_STATE,                                      //  54  D3DRENDERSTATE_STENCILZFAIL
    KELVIN_DIRTY_MISC_STATE,                                      //  55  D3DRENDERSTATE_STENCILPASS
    KELVIN_DIRTY_MISC_STATE,                                      //  56  D3DRENDERSTATE_STENCILFUNC
    KELVIN_DIRTY_MISC_STATE,                                      //  57  D3DRENDERSTATE_STENCILREF
    KELVIN_DIRTY_MISC_STATE,                                      //  58  D3DRENDERSTATE_STENCILMASK
    KELVIN_DIRTY_MISC_STATE,                                      //  59  D3DRENDERSTATE_STENCILWRITEMASK
    KELVIN_DIRTY_MISC_STATE,                                      //  60  D3DRENDERSTATE_TEXTUREFACTOR
    0,                                                            //  61  D3DRENDERSTATE_EVICTMANAGEDTEXTURES
    0,                                                            //  62  D3DRENDERSTATE_SCENECAPTURE
    0,                                                            //  63  invalid
    0,                                                            //  64  D3DRENDERSTATE_STIPPLEPATTERN00
    0,                                                            //  65  D3DRENDERSTATE_STIPPLEPATTERN01
    0,                                                            //  66  D3DRENDERSTATE_STIPPLEPATTERN02
    0,                                                            //  67  D3DRENDERSTATE_STIPPLEPATTERN03
    0,                                                            //  68  D3DRENDERSTATE_STIPPLEPATTERN04
    0,                                                            //  69  D3DRENDERSTATE_STIPPLEPATTERN05
    0,                                                            //  70  D3DRENDERSTATE_STIPPLEPATTERN06
    0,                                                            //  71  D3DRENDERSTATE_STIPPLEPATTERN07
    0,                                                            //  72  D3DRENDERSTATE_STIPPLEPATTERN08
    0,                                                            //  73  D3DRENDERSTATE_STIPPLEPATTERN09
    0,                                                            //  74  D3DRENDERSTATE_STIPPLEPATTERN10
    0,                                                            //  75  D3DRENDERSTATE_STIPPLEPATTERN11
    0,                                                            //  76  D3DRENDERSTATE_STIPPLEPATTERN12
    0,                                                            //  77  D3DRENDERSTATE_STIPPLEPATTERN13
    0,                                                            //  78  D3DRENDERSTATE_STIPPLEPATTERN14
    0,                                                            //  79  D3DRENDERSTATE_STIPPLEPATTERN15
    0,                                                            //  80  D3DRENDERSTATE_STIPPLEPATTERN16
    0,                                                            //  81  D3DRENDERSTATE_STIPPLEPATTERN17
    0,                                                            //  82  D3DRENDERSTATE_STIPPLEPATTERN18
    0,                                                            //  83  D3DRENDERSTATE_STIPPLEPATTERN19
    0,                                                            //  84  D3DRENDERSTATE_STIPPLEPATTERN20
    0,                                                            //  85  D3DRENDERSTATE_STIPPLEPATTERN21
    0,                                                            //  86  D3DRENDERSTATE_STIPPLEPATTERN22
    0,                                                            //  87  D3DRENDERSTATE_STIPPLEPATTERN23
    0,                                                            //  88  D3DRENDERSTATE_STIPPLEPATTERN24
    0,                                                            //  89  D3DRENDERSTATE_STIPPLEPATTERN25
    0,                                                            //  90  D3DRENDERSTATE_STIPPLEPATTERN26
    0,                                                            //  91  D3DRENDERSTATE_STIPPLEPATTERN27
    0,                                                            //  92  D3DRENDERSTATE_STIPPLEPATTERN28
    0,                                                            //  93  D3DRENDERSTATE_STIPPLEPATTERN29
    0,                                                            //  94  D3DRENDERSTATE_STIPPLEPATTERN30
    0,                                                            //  95  D3DRENDERSTATE_STIPPLEPATTERN31
    0,                                                            //  96  invalid
    0,                                                            //  97  invalid
    0,                                                            //  98  invalid
    0,                                                            //  99  invalid
    0,                                                            //  100 invalid
    0,                                                            //  101 invalid
    0,                                                            //  102 invalid
    0,                                                            //  103 invalid
    0,                                                            //  104 invalid
    0,                                                            //  105 invalid
    0,                                                            //  106 invalid
    0,                                                            //  107 invalid
    0,                                                            //  108 invalid
    0,                                                            //  109 invalid
    0,                                                            //  110 invalid
    0,                                                            //  111 invalid
    0,                                                            //  112 invalid
    0,                                                            //  113 invalid
    0,                                                            //  114 invalid
    0,                                                            //  115 invalid
    0,                                                            //  116 invalid
    0,                                                            //  117 invalid
    0,                                                            //  118 invalid
    0,                                                            //  119 invalid
    0,                                                            //  120 invalid
    0,                                                            //  121 invalid
    0,                                                            //  122 invalid
    0,                                                            //  123 invalid
    0,                                                            //  124 invalid
    0,                                                            //  125 invalid
    0,                                                            //  126 invalid
    0,                                                            //  127 invalid
    KELVIN_DIRTY_TEXTURE_STATE,                                   //  128 D3DRENDERSTATE_WRAP0
    KELVIN_DIRTY_TEXTURE_STATE,                                   //  129 D3DRENDERSTATE_WRAP1
    KELVIN_DIRTY_TEXTURE_STATE,                                   //  130 D3DRENDERSTATE_WRAP2
    KELVIN_DIRTY_TEXTURE_STATE,                                   //  131 D3DRENDERSTATE_WRAP3
    KELVIN_DIRTY_TEXTURE_STATE,                                   //  132 D3DRENDERSTATE_WRAP4
    KELVIN_DIRTY_TEXTURE_STATE,                                   //  133 D3DRENDERSTATE_WRAP5
    KELVIN_DIRTY_TEXTURE_STATE,                                   //  134 D3DRENDERSTATE_WRAP6
    KELVIN_DIRTY_TEXTURE_STATE,                                   //  135 D3DRENDERSTATE_WRAP7
    0,                                                            //  136 D3DRENDERSTATE_CLIPPING
    KELVIN_DIRTY_LIGHTS,                                          //  137 D3DRENDERSTATE_LIGHTING
    0,                                                            //  138 D3DRENDERSTATE_EXTENTS
    KELVIN_DIRTY_LIGHTS,                                          //  139 D3DRENDERSTATE_AMBIENT
    KELVIN_DIRTY_COMBINERS_SPECFOG | KELVIN_DIRTY_VERTEX_SHADER,  //  140 D3DRENDERSTATE_FOGVERTEXMODE
    KELVIN_DIRTY_LIGHTS,                                          //  141 D3DRENDERSTATE_COLORVERTEX
    KELVIN_DIRTY_LIGHTS,                                          //  142 D3DRENDERSTATE_LOCALVIEWER
    KELVIN_DIRTY_TRANSFORM,                                       //  143 D3DRENDERSTATE_NORMALIZENORMALS
    0,                                                            //  144 D3DRENDERSTATE_COLORKEYBLENDENABLE
    KELVIN_DIRTY_LIGHTS,                                          //  145 D3DRENDERSTATE_DIFFUSEMATERIALSOURCE
    KELVIN_DIRTY_LIGHTS,                                          //  146 D3DRENDERSTATE_SPECULARMATERIALSOURCE
    KELVIN_DIRTY_LIGHTS,                                          //  147 D3DRENDERSTATE_AMBIENTMATERIALSOURCE
    KELVIN_DIRTY_LIGHTS,                                          //  148 D3DRENDERSTATE_EMISSIVEMATERIALSOURCE
    KELVIN_DIRTY_LIGHTS,                                          //  149 D3DRENDERSTATE_ALPHASOURCE
    KELVIN_DIRTY_LIGHTS,                                          //  150 D3DRENDERSTATE_FOGFACTORSOURCE
    KELVIN_DIRTY_MISC_STATE | KELVIN_DIRTY_TRANSFORM,             //  151 D3DRENDERSTATE_VERTEXBLEND
    KELVIN_DIRTY_TEXTURE_STATE,                                   //  152 D3DRENDERSTATE_CLIPPLANEENABLE
    0,                                                            //  153 D3DRENDERSTATE_SOFTWAREVEXTEXPROCESSING
    KELVIN_DIRTY_MISC_STATE,                                      //  154 D3DRENDERSTATE_POINTSIZE
    KELVIN_DIRTY_MISC_STATE,                                      //  155 D3DRENDERSTATE_POINTSIZEMIN
    KELVIN_DIRTY_MISC_STATE |                                     //
    KELVIN_DIRTY_TEXTURE_STATE | KELVIN_DIRTY_COMBINERS_COLOR,    //  156 D3DRENDERSTATE_POINTSPRITEENABLE
    KELVIN_DIRTY_MISC_STATE | KELVIN_DIRTY_TEXTURE_STATE,         //  157 D3DRENDERSTATE_POINTSCALEENABLE
    KELVIN_DIRTY_MISC_STATE,                                      //  158 D3DRENDERSTATE_POINTSCALEA
    KELVIN_DIRTY_MISC_STATE,                                      //  159 D3DRENDERSTATE_POINTSCALEB
    KELVIN_DIRTY_MISC_STATE,                                      //  150 D3DRENDERSTATE_POINTSCALEC
    0,                                                            //  161 D3DRS_MULTISAMPLEANTIALIAS
    KELVIN_DIRTY_MISC_STATE,                                      //  162 D3DRS_MULTISAMPLEMASK
    0,                                                            //  163 D3DRENDERSTATE_COLORKEYMASK
    0,                                                            //  164 D3DRS_PATCHSEGMENTS
    0,                                                            //  165 D3DRS_DEBUGMONITORTOKEN
    0,                                                            //  166 D3DRS_POINTSIZE_MAX
    0,                                                            //  167 D3DRS_INDEXEDVERTEXBLENDENABLE
    KELVIN_DIRTY_MISC_STATE,                                      //  168 D3DRS_COLORWRITEENABLE
    0,                                                            //  169 invalid
    0,                                                            //  170 D3DRS_TWEENFACTOR
    KELVIN_DIRTY_MISC_STATE                                       //  171 D3DRS_BLENDOP
};

//---------------------------------------------------------------------------

// table mapping dependencies between d3d texture stage state and kelvin state.

// kelvinDirtyBitsFromTextureStageState[D3DTSS_FOO] contains the kelvin class
// dirty bits that should be set whenever D3DTSS_FOO is changed

DWORD kelvinDirtyBitsFromTextureStageState[D3D_TEXSTAGESTATE_MAX+1] =
{
    KELVIN_DIRTY_TEXTURE_STATE | KELVIN_DIRTY_TEXTURE_TRANSFORM | //  0  D3DTSS_TEXTUREMAP
    KELVIN_DIRTY_COMBINERS_COLOR | KELVIN_DIRTY_PIXEL_SHADER,
    KELVIN_DIRTY_TEXTURE_TRANSFORM | KELVIN_DIRTY_COMBINERS_COLOR,//  1  D3DTSS_COLOROP
    KELVIN_DIRTY_COMBINERS_COLOR,                                 //  2  D3DTSS_COLORARG1
    KELVIN_DIRTY_COMBINERS_COLOR,                                 //  3  D3DTSS_COLORARG2
    KELVIN_DIRTY_COMBINERS_COLOR,                                 //  4  D3DTSS_ALPHAOP
    KELVIN_DIRTY_COMBINERS_COLOR,                                 //  5  D3DTSS_ALPHAARG1
    KELVIN_DIRTY_COMBINERS_COLOR,                                 //  6  D3DTSS_ALPHAARG2
    KELVIN_DIRTY_TEXTURE_STATE,                                   //  7  D3DTSS_BUMPENVMAT00
    KELVIN_DIRTY_TEXTURE_STATE,                                   //  8  D3DTSS_BUMPENVMAT01
    KELVIN_DIRTY_TEXTURE_STATE,                                   //  9  D3DTSS_BUMPENVMAT10
    KELVIN_DIRTY_TEXTURE_STATE,                                   //  10 D3DTSS_BUMPENVMAT11
    KELVIN_DIRTY_TEXTURE_TRANSFORM | KELVIN_DIRTY_TEXTURE_STATE | //  11 D3DTSS_TEXCOORDINDEX
    KELVIN_DIRTY_FVF,
    KELVIN_DIRTY_TEXTURE_STATE,                                   //  12 D3DTSS_ADDRESS
    KELVIN_DIRTY_TEXTURE_STATE,                                   //  13 D3DTSS_ADDRESSU
    KELVIN_DIRTY_TEXTURE_STATE,                                   //  14 D3DTSS_ADDRESSV
    KELVIN_DIRTY_TEXTURE_STATE,                                   //  15 D3DTSS_BORDERCOLOR
    KELVIN_DIRTY_TEXTURE_STATE,                                   //  16 D3DTSS_MAGFILTER
    KELVIN_DIRTY_TEXTURE_STATE,                                   //  17 D3DTSS_MINFILTER
    KELVIN_DIRTY_TEXTURE_STATE,                                   //  18 D3DTSS_MIPFILTER
    KELVIN_DIRTY_TEXTURE_STATE,                                   //  19 D3DTSS_MIPMAPLODBIAS
    KELVIN_DIRTY_TEXTURE_STATE,                                   //  20 D3DTSS_MAXMIPLEVEL
    KELVIN_DIRTY_TEXTURE_STATE,                                   //  21 D3DTSS_MAXANISOTROPY
    KELVIN_DIRTY_TEXTURE_STATE,                                   //  22 D3DTSS_BUMPENVLSCALE
    KELVIN_DIRTY_TEXTURE_STATE,                                   //  23 D3DTSS_BUMPENVLOFFSET
    KELVIN_DIRTY_TEXTURE_TRANSFORM,                               //  24 D3DTSS_TEXTURETRANSFORMFLAGS
    KELVIN_DIRTY_TEXTURE_STATE,                                   //  25 D3DTSS_ADDRESSW
    KELVIN_DIRTY_COMBINERS_COLOR,                                 //  26 D3DTSS_COLORARG0
    KELVIN_DIRTY_COMBINERS_COLOR,                                 //  27 D3DTSS_ALPHAARG0
    KELVIN_DIRTY_COMBINERS_COLOR                                  //  28 D3DTSS_RESULTARG
};

//---------------------------------------------------------------------------

// table mapping dp2ops to the kelvin method values associated with them.
// these are defined in term of NV097_SET_BEGIN_END_OP_X but the same values
// are used for all enumerants of type NV097_SET_BEGIN_ENDX_OP_X

DWORD kelvinBeginEndOp[D3D_DP2OP_MAX+1] =
{
    ~0,                                          //   0  invalid
    NV097_SET_BEGIN_END_OP_POINTS,               //   1  D3DDP2OP_POINTS
    NV097_SET_BEGIN_END_OP_LINES,                //   2  D3DDP2OP_INDEXEDLINELIST
    NV097_SET_BEGIN_END_OP_TRIANGLES,            //   3  D3DDP2OP_INDEXEDTRIANGLELIST
    ~0,                                          //   4  invalid
    ~0,                                          //   5  invalid
    ~0,                                          //   6  invalid
    ~0,                                          //   7  invalid
    ~0,                                          //   8  D3DDP2OP_RENDERSTATE
    ~0,                                          //   9  invalid
    ~0,                                          //  10  invalid
    ~0,                                          //  11  invalid
    ~0,                                          //  12  invalid
    ~0,                                          //  13  invalid
    ~0,                                          //  14  invalid
    NV097_SET_BEGIN_END_OP_LINES,                //  15  D3DDP2OP_LINELIST
    NV097_SET_BEGIN_END_OP_LINE_STRIP,           //  16  D3DDP2OP_LINESTRIP
    NV097_SET_BEGIN_END_OP_LINE_STRIP,           //  17  D3DDP2OP_INDEXEDLINESTRIP
    NV097_SET_BEGIN_END_OP_TRIANGLES,            //  18  D3DDP2OP_TRIANGLELIST
    NV097_SET_BEGIN_END_OP_TRIANGLE_STRIP,       //  19  D3DDP2OP_TRIANGLESTRIP
    NV097_SET_BEGIN_END_OP_TRIANGLE_STRIP,       //  20  D3DDP2OP_INDEXEDTRIANGLESTRIP
    NV097_SET_BEGIN_END_OP_TRIANGLE_FAN,         //  21  D3DDP2OP_TRIANGLEFAN
    NV097_SET_BEGIN_END_OP_TRIANGLE_FAN,         //  22  D3DDP2OP_INDEXEDTRIANGLEFAN
    NV097_SET_BEGIN_END_OP_TRIANGLE_FAN,         //  23  D3DDP2OP_TRIANGLEFAN_IMM
    NV097_SET_BEGIN_END_OP_LINES,                //  24  D3DDP2OP_LINELIST_IMM
    ~0,                                          //  25  D3DDP2OP_TEXTURESTAGESTATE
    NV097_SET_BEGIN_END_OP_TRIANGLES,            //  26  D3DDP2OP_INDEXEDTRIANGLELIST2
    NV097_SET_BEGIN_END_OP_LINES,                //  27  D3DDP2OP_INDEXEDLINELIST2
    ~0,                                          //  28  D3DDP2OP_VIEWPORTINFO
    ~0,                                          //  29  D3DDP2OP_WINFO
    ~0,                                          //  30  D3DDP2OP_SETPALETTE
    ~0,                                          //  31  D3DDP2OP_UPDATEPALETTE
    ~0,                                          //  32  D3DDP2OP_ZRANGE
    ~0,                                          //  33  D3DDP2OP_SETMATERIAL
    ~0,                                          //  34  D3DDP2OP_SETLIGHT
    ~0,                                          //  35  D3DDP2OP_CREATELIGHT
    ~0,                                          //  36  D3DDP2OP_SETTRANSFORM
    ~0,                                          //  37  D3DDP2OP_EXT
    ~0,                                          //  38  D3DDP2OP_TEXBLT
    ~0,                                          //  39  D3DDP2OP_STATESET
    ~0,                                          //  40  D3DDP2OP_SETPRIORITY
    ~0,                                          //  41  D3DDP2OP_SETRENDERTARGET
    ~0,                                          //  42  D3DDP2OP_CLEAR
    ~0,                                          //  43  D3DDP2OP_SETTEXLOD
    ~0                                           //  44  D3DDP2OP_SETCLIPPLANE
};

//---------------------------------------------------------------------------

// table mapping d3d vertex types to kelvin vertex sizes
DWORD kelvinVertexSize[8] = {
    NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_1,   // D3DVSDT_FLOAT1    0x00
    NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_2,   // D3DVSDT_FLOAT2    0x01
    NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_3,   // D3DVSDT_FLOAT3    0x02
    NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_4,   // D3DVSDT_FLOAT4    0x03
    NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_4,   // D3DVSDT_D3DCOLOR  0x04
    NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_4,   // D3DVSDT_UBYTE4    0x05
    NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_2,   // D3DVSDT_SHORT2    0x06
    NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_4    // D3DVSDT_SHORT4    0x07
};

//---------------------------------------------------------------------------

// table mapping d3d vertex types to kelvin vertex types
DWORD kelvinVertexType[8] = {
    NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_F,      // D3DVSDT_FLOAT1    0x00
    NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_F,      // D3DVSDT_FLOAT2    0x01
    NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_F,      // D3DVSDT_FLOAT3    0x02
    NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_F,      // D3DVSDT_FLOAT4    0x03
    NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_UB_D3D, // D3DVSDT_D3DCOLOR  0x04
    NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_UB_D3D, // D3DVSDT_UBYTE4    0x05 !!! BUG BUG !!!
    NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K,     // D3DVSDT_SHORT2    0x06
    NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K      // D3DVSDT_SHORT4    0x07
};

//---------------------------------------------------------------------------

// table mapping dp2ops to derivative information such as the scale and bias
// required to calculate the number of vertices from the number of primitives.

// nibble 0: bias
// nibble 1: scale (numVertices = scale * numPrimitives + bias)
// nibble 2: scale + bias (= number of vertices in one primitive)
// nibble 3: flags

DWORD kelvinPrimitiveToPrimitiveMagic[D3D_DP2OP_MAX+1] =
{
    ~0,                                          //   0  invalid
    0x00010100,                                  //   1  D3DDP2OP_POINTS
    0x00020200,                                  //   2  D3DDP2OP_INDEXEDLINELIST
    0x00030300,                                  //   3  D3DDP2OP_INDEXEDTRIANGLELIST
    ~0,                                          //   4  invalid
    ~0,                                          //   5  invalid
    ~0,                                          //   6  invalid
    ~0,                                          //   7  invalid
    ~0,                                          //   8  D3DDP2OP_RENDERSTATE
    ~0,                                          //   9  invalid
    ~0,                                          //  10  invalid
    ~0,                                          //  11  invalid
    ~0,                                          //  12  invalid
    ~0,                                          //  13  invalid
    ~0,                                          //  14  invalid
    0x00020200,                                  //  15  D3DDP2OP_LINELIST
    0x00020101,                                  //  16  D3DDP2OP_LINESTRIP
    0x00020101,                                  //  17  D3DDP2OP_INDEXEDLINESTRIP
    0x00030300,                                  //  18  D3DDP2OP_TRIANGLELIST
    0x40030102,                                  //  19  D3DDP2OP_TRIANGLESTRIP
    0x40030102,                                  //  20  D3DDP2OP_INDEXEDTRIANGLESTRIP
    0x80030102,                                  //  21  D3DDP2OP_TRIANGLEFAN
    0x80030102,                                  //  22  D3DDP2OP_INDEXEDTRIANGLEFAN
    0x80030102,                                  //  23  D3DDP2OP_TRIANGLEFAN_IMM
    0x00020200,                                  //  24  D3DDP2OP_LINELIST_IMM
    ~0,                                          //  25  D3DDP2OP_TEXTURESTAGESTATE
    0x00030300,                                  //  26  D3DDP2OP_INDEXEDTRIANGLELIST2
    0x00020200,                                  //  27  D3DDP2OP_INDEXEDLINELIST2
    ~0,                                          //  28  D3DDP2OP_VIEWPORTINFO
    ~0,                                          //  29  D3DDP2OP_WINFO
    ~0,                                          //  30  D3DDP2OP_SETPALETTE
    ~0,                                          //  31  D3DDP2OP_UPDATEPALETTE
    ~0,                                          //  32  D3DDP2OP_ZRANGE
    ~0,                                          //  33  D3DDP2OP_SETMATERIAL
    ~0,                                          //  34  D3DDP2OP_SETLIGHT
    ~0,                                          //  35  D3DDP2OP_CREATELIGHT
    ~0,                                          //  36  D3DDP2OP_SETTRANSFORM
    ~0,                                          //  37  D3DDP2OP_EXT
    ~0,                                          //  38  D3DDP2OP_TEXBLT
    ~0,                                          //  39  D3DDP2OP_STATESET
    ~0,                                          //  40  D3DDP2OP_SETPRIORITY
    ~0,                                          //  41  D3DDP2OP_SETRENDERTARGET
    ~0,                                          //  42  D3DDP2OP_CLEAR
    ~0,                                          //  43  D3DDP2OP_SETTEXLOD
    ~0                                           //  44  D3DDP2OP_SETCLIPPLANE
};


//---------------------------------------------------------------------------

// table mapping dp2ops to a name humans understand

#ifdef DEBUG
char* kelvinPrimitiveName[D3D_DP2OP_MAX+1] =
{
    "oops",                                      //   0  invalid
    "points",                                    //   1  D3DDP2OP_POINTS
    "indexed line list",                         //   2  D3DDP2OP_INDEXEDLINELIST
    "indexed tri list",                          //   3  D3DDP2OP_INDEXEDTRIANGLELIST
    "oops",                                      //   4  invalid
    "oops",                                      //   5  invalid
    "oops",                                      //   6  invalid
    "oops",                                      //   7  invalid
    "oops",                                      //   8  D3DDP2OP_RENDERSTATE
    "oops",                                      //   9  invalid
    "oops",                                      //  10  invalid
    "oops",                                      //  11  invalid
    "oops",                                      //  12  invalid
    "oops",                                      //  13  invalid
    "oops",                                      //  14  invalid
    "line list",                                 //  15  D3DDP2OP_LINELIST
    "line strip",                                //  16  D3DDP2OP_LINESTRIP
    "indexed line strip",                        //  17  D3DDP2OP_INDEXEDLINESTRIP
    "tri list",                                  //  18  D3DDP2OP_TRIANGLELIST
    "tri strip",                                 //  19  D3DDP2OP_TRIANGLESTRIP
    "indexed tri strip",                         //  20  D3DDP2OP_INDEXEDTRIANGLESTRIP
    "tri fan",                                   //  21  D3DDP2OP_TRIANGLEFAN
    "indexed tri fan",                           //  22  D3DDP2OP_INDEXEDTRIANGLEFAN
    "tri fan imm",                               //  23  D3DDP2OP_TRIANGLEFAN_IMM
    "line list imm",                             //  24  D3DDP2OP_LINELIST_IMM
    "oops",                                      //  25  D3DDP2OP_TEXTURESTAGESTATE
    "indexed tri list 2",                        //  26  D3DDP2OP_INDEXEDTRIANGLELIST2
    "indexed line list 2",                       //  27  D3DDP2OP_INDEXEDLINELIST2
    "oops",                                      //  28  D3DDP2OP_VIEWPORTINFO
    "oops",                                      //  29  D3DDP2OP_WINFO
    "oops",                                      //  30  D3DDP2OP_SETPALETTE
    "oops",                                      //  31  D3DDP2OP_UPDATEPALETTE
    "oops",                                      //  32  D3DDP2OP_ZRANGE
    "oops",                                      //  33  D3DDP2OP_SETMATERIAL
    "oops",                                      //  34  D3DDP2OP_SETLIGHT
    "oops",                                      //  35  D3DDP2OP_CREATELIGHT
    "oops",                                      //  36  D3DDP2OP_SETTRANSFORM
    "oops",                                      //  37  D3DDP2OP_EXT
    "oops",                                      //  38  D3DDP2OP_TEXBLT
    "oops",                                      //  39  D3DDP2OP_STATESET
    "oops",                                      //  40  D3DDP2OP_SETPRIORITY
    "oops",                                      //  41  D3DDP2OP_SETRENDERTARGET
    "oops",                                      //  42  D3DDP2OP_CLEAR
    "oops",                                      //  43  D3DDP2OP_SETTEXLOD
    "oops"                                       //  44  D3DDP2OP_SETCLIPPLANE
};
#endif

#endif  // NVARCH >= 0x020
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\common\inc\MINIVDD.H ===
//*****************************************************************************
//
//   (C) Copyright MICROSOFT Corp., 1988-1993
//
//   Title:      minivdd.inc - VDD definitions for other VxD's and multiple VDD's
//
//   Version:    4.00
//
//   Date:
//
//   Author: FredE for the Mini-VDD interface.  Adapted from VDD.INC in
//           the general include area.  Added services are ONLY for the
//           use of the Mini-VDD and should therefore not be documented.
//
//-----------------------------------------------------------------------------
//=============================================================================

#ifndef _MINIVDD_H_
#define _MINIVDD_H_

#ifndef Not_VxD

/*XLATOFF*/
#define VDD_Service Declare_Service
#pragma warning (disable:4003)      // turn off not enough params warning
/*XLATON*/

#ifdef MINIVDD
#ifdef NEC_98
/*MACROS*/
//
// VDD protect mode services for other devices and VMM (Get_Version must be first).
// Only define these if we're assembling either the "main" VDD or one of the
// mini-VDD's.  Don't define this if we're assembling a display driver or other
// caller of the MiniVDD stuff:
//
Begin_Service_Table(VDD)
VDD_Service(     VDD_Get_Version            ) // Get version number and ID string ptr
VDD_Service(     VDD_PIF_State              ) // Pass video PIF bits to VDD
VDD_Service(     VDD_Get_GrabRtn            ) // Get routine addr for video grab
VDD_Service(     VDD_Hide_Cursor            ) // Hide cursor when display is windowed
VDD_Service(     VDD_Set_VMType             ) // Set VM type(windowed, bckgrnd, excl)
VDD_Service(     VDD_Get_ModTime            ) // Return system time of last mod
VDD_Service(     VDD_Set_HCurTrk            ) // Track horiz cursor movement in window
VDD_Service(     VDD_Msg_ClrScrn            ) // Clear screen for sysmodal message
VDD_Service(     VDD_Msg_ForColor           ) // Set Msg_TextOut forground color
VDD_Service(     VDD_Msg_BakColor           ) // Set Msg_TextOut background color
VDD_Service(     VDD_Msg_TextOut            ) // Output a string
VDD_Service(     VDD_Msg_SetCursPos         ) // Set cursor position
VDD_Service(     VDD_Query_Access           ) // Is it OK to access video now?
VDD_Service(     VDD_Check_Update_Soon      ) // User action may update screen
VDD_Service(     VDD_Get_Mini_Dispatch_Table) // Get addr of dispatch table to mini-VDD
VDD_Service(     VDD_Register_Virtual_Port  ) // Mini-VDD asks us to setup I/O trap
VDD_Service(     VDD_Get_VM_Info            ) // Returns CRTC owner and MemC owners
                                              // and other special VM handles
VDD_Service(     VDD_Get_Special_VM_IDs     ) // returns planar & msg mode IDs
VDD_Service(     VDD_Register_Extra_Screen_Selector )
                                              // allows display driver to use second
                                              // screen selector for block moves
VDD_Service(     VDD_Takeover_VGA_Port      ) // allows MiniVDD to takeover a port
                                              // in range 3C0H through 3DFH
VDD_Service(     VDD_Get_DISPLAYINFO        ) // get DISPLAYINFO data structure
VDD_Service(     VDD_Do_Physical_IO         ) // perform physical I/O for trapped port
VDD_Service(     VDD_Register_Mini_VDD   )
VDD_Service(    VDD_Install_IO_Handler   )
VDD_Service(    VDD_Install_Mult_IO_Handlers    )
VDD_Service(    VDD_Enable_Local_Trapping       )
VDD_Service(    VDD_Disable_Local_Trapping      )
VDD_Service(    VDD_Trap_Suspend        )
VDD_Service(    Test_Vid_VM_Handle      )
VDD_Service(    VDD_Set_Core_Graphics   )
VDD_Service(    VDD_Load_AccBIOS        )
VDD_Service(    VDD_Map_AccBIOS         )
VDD_Service(    VDD_Map_VRAM            )
End_Service_Table(VDD)
/*ENDMACROS*/
#else  /*NEC_98*/
/*MACROS*/
//
// VDD protect mode services for other devices and VMM (Get_Version must be first).
// Only define these if we're assembling either the "main" VDD or one of the
// mini-VDD's.  Don't define this if we're assembling a display driver or other
// caller of the MiniVDD stuff:
//
Begin_Service_Table(VDD)
VDD_Service(     VDD_Get_Version             )// Get version number and ID string ptr
VDD_Service(     VDD_PIF_State               )// Pass video PIF bits to VDD
VDD_Service(     VDD_Get_GrabRtn             )// Get routine addr for video grab
VDD_Service(     VDD_Hide_Cursor             )// Hide cursor when display is windowed
VDD_Service(     VDD_Set_VMType              )// Set VM type(windowed, bckgrnd, excl)
VDD_Service(     VDD_Get_ModTime             )// Return system time of last mod
VDD_Service(     VDD_Set_HCurTrk             )// Track horiz cursor movement in window
VDD_Service(     VDD_Msg_ClrScrn             )// Clear screen for sysmodal message
VDD_Service(     VDD_Msg_ForColor            )// Set Msg_TextOut forground color
VDD_Service(     VDD_Msg_BakColor            )// Set Msg_TextOut background color
VDD_Service(     VDD_Msg_TextOut             )// Output a string
VDD_Service(     VDD_Msg_SetCursPos          )// Set cursor position
VDD_Service(     VDD_Query_Access            )// Is it OK to access video now?
VDD_Service(     VDD_Check_Update_Soon       )// User action may update screen
VDD_Service(     VDD_Get_Mini_Dispatch_Table )// Get addr of dispatch table to mini-VDD
VDD_Service(     VDD_Register_Virtual_Port   )// Mini-VDD asks us to setup I/O trap
VDD_Service(     VDD_Get_VM_Info             )// Returns CRTC owner and MemC owners
                                              // and other special VM handles
VDD_Service(     VDD_Get_Special_VM_IDs      )// returns planar & msg mode IDs
VDD_Service(     VDD_Register_Extra_Screen_Selector )
                                              // allows display driver to use second
                                              // screen selector for block moves
VDD_Service(     VDD_Takeover_VGA_Port   )    // allows MiniVDD to takeover a port
                                              // in range 3C0H through 3DFH
VDD_Service(     VDD_Get_DISPLAYINFO     )    // get DISPLAYINFO data structure
VDD_Service(     VDD_Do_Physical_IO      )    // perform physical I/O for trapped port
VDD_Service(     VDD_Set_Sleep_Flag_Addr )    // when display driver can't be interrupted
End_Service_Table(VDD)                   
/*ENDMACROS*/
#endif  /*NEC_98*/
#endif  /*MINIVDD*/

/*XLATOFF*/
#pragma warning (default:4003)              // turn off not enough params warning
/*XLATON*/

#define VDD_VerNum      0x0400  // version 4.00
#define VDD_MinVerNum   0x030A  // supports down to 3.10

//***************
// PIF_State service definitions
//
// These definitions cannot change without changing the PIF editor!!!
//
#ifdef NEC_98
#define bVidTextMd	 4	; Allocate text mode mem
#define fVidTextMd	 (1 << 4)
#define bVidNTModeFF	 0	; NoTrap: Mode F/F
#define fVidNTModeFF	 (1 << 0)
#define bVidNTModeFFC16	 1	; Default is 16 color mode
#define fVidNTModeFFC16	 (1 << 1)
#define bVidNTDispRW	 2	; NoTrap: Bank Register
#define fVidNTDispRW	 (1 << 2)
#define bVidNTPal	 3	; NoTrap: Palette
#define fVidNTPal	 (1 << 3)
#define bVidNTGDC	 5	; NoTrap: GDC
#define fVidNTGDC	 (1 << 5)
#define bVidNTGDCTON	 6	; Default Text on
#define fVidNTGDCTON	 (1 << 6)
#define bVidNTGDCGON	 7	; Default Grph on
#define fVidNTGDCGON	 (1 << 7)
#define bVidNTFont	 8	; NoTrap: KCG
#define fVidNTFont	 (1 << 8)
#define bVidCRTC	 9	; Use CRTC Tracer
#define fVidCRTC	 (1 << 9)
#define bVidDispDataXfer 10	; Transrate mode (0:Text, 1:Text/Grph)
#define fVidDispDataXfer (1 << 10)
#define bVidXFERPlane0	 11	; Transrate plane Blue
#define fVidXFERPlane0	 (1 << 11)
#define bVidXFERPlane1	 12	; 		  Red
#define fVidXFERPlane1	 (1 << 12)
#define bVidXFERPlane2	 13	; 		  Green
#define fVidXFERPlane2	 (1 << 13)
#define bVidXFERPlane3	 14	; 		  Intensity
#define fVidXFERPlane3	 (1 << 14)

#define mVidXFERPlane	(fVidXFERPlane0+fVidXFERPlane1+fVidXFERPlane2+fVidXFERPlane3)
#define mVidNTH98	(fVidNTModeFF+fVidNTModeFFC16+fVidNTDispRW+fVidNTPal+fVidNTGDC+fVidNTGDCTON+fVidNTGDCGON)
#else //NEC_98
#define fVidTxtEmulate  0x0001  // Do INT 10h TTY and cursor emulation
#define fVidNoTrpTxt    0x0002  // Do not trap text mode apps
#define fVidNoTrpLRGrfx 0x0004  // Do not trap lo res graphics mode apps
#define fVidNoTrpHRGrfx 0x0008  // Do not trap hi res graphics mode apps
#define fVidTextMd      0x0010  // Allocate text mode mem
#define fVidLowRsGrfxMd 0x0020  // Allocate lo res graphics mode mem
#define fVidHghRsGrfxMd 0x0040  // Allocate hi res graphics mode mem
#define fVidRetainAllo  0x0080  // Never deallocate once allocated
#endif //NEC_98

//
// The following stuff was added for mini-VDD support:
//
// Functions that we can call in the hardware-dependent mini-VDD.  Note that
// these equates are used to create the dispatch table for calling functions
// in the mini-VDD:
//
#ifdef NEC_98
#define REGISTER_DISPLAY_DRIVER 	     0
#define PRE_HIRES_TO_VGA		     1
#define SAVE_REGISTERS			     2
#define RESTORE_REGISTERS		     3
#define ENABLE_TRAPS			     4
#define DISABLE_TRAPS			     5
#define DISPLAY_DRIVER_DISABLING	     6
#define ENABLE_ACCELERATER		     7
#define DISABLE_ACCELERATER		     8
#define CHECK_UPDATE			     9
#define CHECK_WINDOWED			     10
#define ACC_VBE_PM			     11
#define ACC_VBE_DDC			     12
#define ACC_INT_10			     13
#define ACC_GET_CAPABILITIES		     14
#define ACC_GET_EXT_MODE_INFO		     15
#define ACC_GET_FLAT_SELECTOR		     16
#define ACC_ENABLE_BIOS			     17
#define ACC_DISABLE_BIOS		     18
#define ACC_SET_PALETTE			     19
#define ACC_GET_PALETTE			     20
#define ACC_SET_CURSOR			     21
#define ACC_SHOW_CURSOR			     22
#define ACC_HIDE_CURSOR			     23
#define ACC_SET_CURSOR_POS		     24
#define ACC_GET_CURSOR_POS		     25
;
#define NBR_MINI_VDD_FUNCTIONS               26      //REMEMBER TO RESET THIS!!!!!!
#else //NEC_98
#define REGISTER_DISPLAY_DRIVER              0
#define GET_VDD_BANK                         1
#define SET_VDD_BANK                         2
#define RESET_BANK                           3
#define PRE_HIRES_TO_VGA                     4
#define POST_HIRES_TO_VGA                    5
#define PRE_VGA_TO_HIRES                     6
#define POST_VGA_TO_HIRES                    7
#define SAVE_REGISTERS                       8
#define RESTORE_REGISTERS                    9
#define MODIFY_REGISTER_STATE                10
#define ACCESS_VGA_MEMORY_MODE               11
#define ACCESS_LINEAR_MEMORY_MODE            12
#define ENABLE_TRAPS                         13
#define DISABLE_TRAPS                        14
#define MAKE_HARDWARE_NOT_BUSY               15
#define VIRTUALIZE_CRTC_IN                   16
#define VIRTUALIZE_CRTC_OUT                  17
#define VIRTUALIZE_SEQUENCER_IN              18
#define VIRTUALIZE_SEQUENCER_OUT             19
#define VIRTUALIZE_GCR_IN                    20
#define VIRTUALIZE_GCR_OUT                   21
#define SET_LATCH_BANK                       22
#define RESET_LATCH_BANK                     23
#define SAVE_LATCHES                         24
#define RESTORE_LATCHES                      25
#define DISPLAY_DRIVER_DISABLING             26
#define SELECT_PLANE                         27
#define PRE_CRTC_MODE_CHANGE                 28
#define POST_CRTC_MODE_CHANGE                29
#define VIRTUALIZE_DAC_OUT                   30
#define VIRTUALIZE_DAC_IN                    31
#define GET_CURRENT_BANK_WRITE               32
#define GET_CURRENT_BANK_READ                33
#define SET_BANK                             34
#define CHECK_HIRES_MODE                     35
#define GET_TOTAL_VRAM_SIZE                  36
#define GET_BANK_SIZE                        37
#define SET_HIRES_MODE                       38
#define PRE_HIRES_SAVE_RESTORE               39
#define POST_HIRES_SAVE_RESTORE              40
#define VESA_SUPPORT                         41
#define GET_CHIP_ID                          42
#define CHECK_SCREEN_SWITCH_OK               43
#define VIRTUALIZE_BLTER_IO                  44
#define SAVE_MESSAGE_MODE_STATE              45
#define SAVE_FORCED_PLANAR_STATE             46
#define VESA_CALL_POST_PROCESSING            47
#define PRE_INT_10_MODE_SET                  48
#define NBR_MINI_VDD_FUNCTIONS_40            49      //REMEMBER TO RESET THIS!!!!!!

//
//  new miniVDD functions that a 4.1 miniVDD should implement
//
#define GET_NUM_UNITS                        49
#define TURN_VGA_OFF                         50
#define TURN_VGA_ON                          51
#define SET_ADAPTER_POWER_STATE              52
#define GET_ADAPTER_POWER_STATE_CAPS         53
#define SET_MONITOR_POWER_STATE              54
#define GET_MONITOR_POWER_STATE_CAPS         55
#define NBR_MINI_VDD_FUNCTIONS_41            56

#ifdef MAINVDD
#define NBR_MINI_VDD_FUNCTIONS  NBR_MINI_VDD_FUNCTIONS_41
#else
#define NBR_MINI_VDD_FUNCTIONS  NBR_MINI_VDD_FUNCTIONS_40
#endif

#endif //NEC_98

#endif /*NotVxD*/

//
// Following are function codes that can be called via the VDD's
// API entry point. These are mainly for display driver --> VDD communication.
// Since Windows 3.0 and 3.1 VDD's may have used the sequential numbers
// (after the Grabber functions) for other VDD API services, we start our
// numbering at 80H so as to avoid ugly conflicts with old 3.1 stuff:
//
// all these entry points take as input:
//
// Entry:
//      Client_EAX  - function code.
//      Client_EBX  - device handle, or device id (1-N)
//
#define VDD_QUERY_VERSION                   0
#define MINIVDD_SVC_BASE_OFFSET             0x80
#define VDD_DRIVER_REGISTER                 (0  + MINIVDD_SVC_BASE_OFFSET)
#define VDD_DRIVER_UNREGISTER               (1  + MINIVDD_SVC_BASE_OFFSET)
#define VDD_SAVE_DRIVER_STATE               (2  + MINIVDD_SVC_BASE_OFFSET)
#define VDD_REGISTER_DISPLAY_DRIVER_INFO    (3  + MINIVDD_SVC_BASE_OFFSET)
#define VDD_REGISTER_SSB_FLAGS              (4  + MINIVDD_SVC_BASE_OFFSET)
#define VDD_GET_DISPLAY_CONFIG              (5  + MINIVDD_SVC_BASE_OFFSET)
#define VDD_PRE_MODE_CHANGE                 (6  + MINIVDD_SVC_BASE_OFFSET)
#define VDD_POST_MODE_CHANGE                (7  + MINIVDD_SVC_BASE_OFFSET)
#define VDD_SET_USER_FLAGS                  (8  + MINIVDD_SVC_BASE_OFFSET)
#define VDD_SET_BUSY_FLAG_ADDR              (9  + MINIVDD_SVC_BASE_OFFSET)
#define VDD_PC98_RESERVED                   (10 + MINIVDD_SVC_BASE_OFFSET)
#define VDD_VBE_PM                          (10 + MINIVDD_SVC_BASE_OFFSET)
//
//   all functions >= VDD_ENABLE also take the following params:
//
//      Client_ES:DI    - buffer
//      Client_ECX      - buffer size
//      Client_EDX      - flags
//
// Exit:
//      Client_EAX  = function code  if the function is not supported.
//                  = 0              if the function succeded.
//                  = -1             if the function failed.
//
#define VDD_ENABLE                          (11 + MINIVDD_SVC_BASE_OFFSET)
#define VDD_GETMEMBASE                      (12 + MINIVDD_SVC_BASE_OFFSET)
#define VDD_OPEN                            (13 + MINIVDD_SVC_BASE_OFFSET)
#define VDD_CLOSE                           (14 + MINIVDD_SVC_BASE_OFFSET)
#define VDD_OPEN_KEY                        (15 + MINIVDD_SVC_BASE_OFFSET)
#define VDD_SET_POWER_STATE                 (16 + MINIVDD_SVC_BASE_OFFSET)
#define VDD_ENUM                            (17 + MINIVDD_SVC_BASE_OFFSET)

//
// special verion of VDD_GET_DISPLAY_CONFIG that always get the
// monitor data, even if the user has disabled using a refresh rate.
//
#define VDD_GET_DISPLAY_CONFIG2             0x8085

//
//  VDD_DRIVER_REGISTER
//
//  The display driver sends us some information needed to handle various
//  context changes.
//
//  Entry:
//         Client_ES:DI Selector:Offset of callback routine used
//                      to reset to Windows HiRes mode upon return
//                      from a full screen DOS VM to the Windows VM.
//         Client_ES    Main code segment of display driver.
//         Client_ECX   contains the total nbr of bytes on-screen (excluding
//                      off-screen memory).
//         Client_EDX   contain 0 if we are to attempt to allow 4 plane VGA
//                      virtualization.
//         Client_EDX   contains -1 if we are to not allow 4 plane VGA
//                      virtualization.
//         Client_EBX   device handle, or device id (1-N)
//  Exit:
//         Client_EAX   contains total bytes of memory used by visible screen
//                      AND the VDD virtualization area (ie: the start of
//                      off-screen memory available for use by the display
//                      driver as "scratch" memory).
//

//
//  VDD_DRIVER_UNREGISTER
//
//  Entry:
//          Client_EBX   device handle, or device id (1-N)
//  Exit:
//

//
//  VDD_ENABLE
//
//  entry:
//      Client_EAX      - VDD_ENABLE (0x008B)
//      Client_EBX      - device handle, or device id (1-N)
//      Client_EDX      - enable flags (see below)
//
//  exit:
//      Client_EAX      - previous enable state.
//
//  only one device at a time can have VGAMEM, VGAIO, or ROM access
//  at a time.
//
#define ENABLE_IO               0x00000001  // enable IO.
#define ENABLE_MEM              0x00000002  // enable memory.
#define ENABLE_VGA              0x00000030  // enable VGA
#define ENABLE_ROM              0x00000080  // enable ROM at C000.
#define ENABLE_ALL              0x000000FF  // enable all access to this device
#define ENABLE_NONE             0x00000000  // disable device.
#define ENABLE_VALID            0x000000FF  // valid flags.
#define ENABLE_ERROR            0xFFFFFFFF  // enable fail code

//
//  VDD_OPEN
//
//      open a device given a name
//
//  Entry:
//          Client_ES:EDI   - device name
//          Client_EDX      - flag
//  Exit:
//          Client_EAX      - device handle
//
#define VDD_OPEN_TEST       0x00000001


//
//  WIN32 IOCTLS
//
//  The following defines are used with the Win32 function DeviceIOControl
//
#define VDD_IOCTL_SET_NOTIFY    0x10000001  // set mode change notify
#define VDD_IOCTL_GET_DDHAL     0x10000002  // get DDHAL functions from miniVDD

//
//  VDD_IOCTL_SET_NOTIFY
//
//  sets a notification function that will be called when events
//  happen on the device.
//
//  input:
//          NotifyMask      - bitfield of events
//          NotifyType      - type of notify
//          NotifyProc      - notify procedure
//          NotifyData      - client data
//
//  output:
//           none
//
//  return:
//          ERROR_SUCCES
//
typedef struct tagVDD_IOCTL_SET_NOTIFY_INPUT {
    DWORD   NotifyMask;
    DWORD   NotifyType;
    DWORD   NotifyProc;
    DWORD   NotifyData;
}   VDD_IOCTL_SET_NOTIFY_INPUT;


//
// NotifyMask
//
#define VDD_NOTIFY_START_MODE_CHANGE    0x00000001
#define VDD_NOTIFY_END_MODE_CHANGE      0x00000002
#define VDD_NOTIFY_ENABLE               0x00000004
#define VDD_NOTIFY_DISABLE              0x00000008

//
//  NotifyType
//
#define VDD_NOTIFY_TYPE_CALLBACK        1


//
// Port size equates:
//
#define BYTE_LENGTHED                       1
#define WORD_LENGTHED                       2

//
// Flag equates:
//
#define GOING_TO_WINDOWS_MODE               1
#define GOING_TO_VGA_MODE                   2
#define DISPLAY_DRIVER_DISABLED             4
#define IN_WINDOWS_HIRES_MODE               8

//
//  DISPLAYINFO structure
//
typedef struct DISPLAYINFO {
        WORD  diHdrSize;
        WORD  diInfoFlags;
        //
        //  display mode specific data
        //
        DWORD diDevNodeHandle;
        char  diDriverName[16];
        WORD  diXRes;
        WORD  diYRes;
        WORD  diDPI;
        BYTE  diPlanes;
        BYTE  diBpp;
        //
        //  monitor specific data
        //
        WORD  diRefreshRateMax;
        WORD  diRefreshRateMin;
        WORD  diLowHorz;
        WORD  diHighHorz;
        WORD  diLowVert;
        WORD  diHighVert;
        DWORD diMonitorDevNodeHandle;
        BYTE  diHorzSyncPolarity;
        BYTE  diVertSyncPolarity;
        //
        // new 4.1 stuff
        //
        DWORD diUnitNumber;             // device unit number
        DWORD diDisplayFlags;           // mode specific flags
        DWORD diXDesktopPos;            // position of desktop
        DWORD diYDesktopPos;            // ...
        DWORD diXDesktopSize;           // size of desktop (for panning)
        DWORD diYDesktopSize;           // ...

} DISPLAYINFO;

/*ASM
DISPLAYINFO_SIZE    equ  diRefreshRateMax+2-diHdrSize
DISPLAYINFO_SIZE1   equ  diBpp+1-diHdrSize
DISPLAYINFO_SIZE2   equ  diVertSyncPolarity+1-diHdrSize
DISPLAYINFO_SIZE3   equ  diMemorySize+4-diHdrSize
*/

//
// Following are values for the diInfoFlags word in DISPLAYINFO:
//
#define RETURNED_DATA_IS_STALE           0x0001
#define MINIVDD_FAILED_TO_LOAD           0x0002
#define MINIVDD_CHIP_ID_DIDNT_MATCH      0x0004
#define REGISTRY_BPP_NOT_VALID           0x0008
#define REGISTRY_RESOLUTION_NOT_VALID    0x0010
#define REGISTRY_DPI_NOT_VALID           0x0020
#define MONITOR_DEVNODE_NOT_ACTIVE       0x0040
#define MONITOR_INFO_NOT_VALID           0x0080
#define MONITOR_INFO_DISABLED_BY_USER    0x0100
#define REFRESH_RATE_MAX_ONLY            0x0200
#define CARD_VDD_LOADED_OK               0x0400
#define DEVICE_IS_NOT_VGA                0x0800

//
//  Following are explanations for the diInfoFlags word in DISPLAYINFO:
//
//  RETURNED_DATA_IS_STALE, if set, means that this call to VDD_GET_DISPLAY_CONFIG
//  or VDD_GetDisplayInfo (which are the Ring 3 and Ring 0 methods by which a
//  program would get the DISPLAYINFO structure returned to him) caused the VDD
//  to return data that was read in a previous call to VDD_GET_DISPLAY_CONFIG
//  insted of actually going out and reading "fresh" data from the Registry.
//
//  This flag brings to light the fact that there are some circumstances when the
//  VDD cannot go out and read the registry in response to the call to
//  VDD_GET_DISPLAY_CONFIG or VDD_GetDisplayInfo (due to system multi-tasking
//  considerations).  In this case, this flag will be set to a 1 to indicate that
//  the information being returned isn't "fresh" -- that is -- it may be
//  incorrect and obsolete.  The caller should respond accordingly if this flag
//  is set.
//
//
//  MINIVDD_FAILED_TO_LOAD if set, indicates that for some reason (typically
//  that the MiniVDD didn't match the chipset installed in the machine), the
//  MiniVDD didn't load.  Callers can examine this flag and act accordingly.
//
//
//  MINIVDD_CHIP_ID_DIDNT_MATCH means that although the MiniVDD did load
//  successfully, when the ChipID that the MiniVDD calculated was compared
//  against the value saved in the registry, they didn't match.  An example of
//  when this would happen is when the user is happily using an S3-911 card
//  and then decides to upgrade his display card to an S3-864.  Since both
//  cards use S3.VXD, the MiniVDD will load, however, since the card model
//  is different, the VDD will return a defect to configuration manager and
//  set this flag.  Callers of the GET_DISPLAY_CONFIG functions can use this
//  flag to take appropriate actions to make sure that the user gets his
//  configuration correct.
//
//
//  REGISTRY_BPP_NOT_VALID if set, means that we failed to obtain the BPP value
//  from the registry when the VDD tried to read it.
//
//
//  REGISTRY_RESOLUTION_NOT_VALID if set, means that we failed to obtain the
//  resolution value from the registry when the VDD tried to read it.
//
//
//  REGISTRY_DPI_NOT_VALID if set, means that we failed to obtain the
//  DPI value from the registry when the VDD tried to read it.
//
//
//  MONITOR_DEVNODE_NOT_ACTIVE is set if someone tries to make a call to the
//  GET_DISPLAY_CONFIG function before the monitor DevNode has been created.
//  This is certainly not fatal by any means.  It simply means that the
//  monitor refresh rate info in the DISPLAYINFO data structure is totally
//  invalid!
//
//
//  MONITOR_INFO_NOT_VALID indicates that something within the code which
//  retrieves and calculates the refresh rate data has failed.  This indicates
//  that the values in diRefreshRateMax through diVertSyncPolarity are not
//  valid and could contain random data.
//
//
//  MONITOR_INFO_DISABLED_BY_USER indicates that the either the RefreshRate=
//  string in SYSTEM.INI had a negative number in it or that the string in
//  the display's software key RefreshRate = string was 0 or a negative number.
//
//
//  REFRESH_RATE_MAX_ONLY indicates that there was no diLowHorz, diHighHorz,
//  diLowVert, diHighVert, or sync polarity data in the registry.  The
//  value returned in diRefreshRateMax is the only refresh rate data that
//  we have available.  This was derived either from RefreshRate= in SYSTEM.INI
//  or the display software key RefreshRate = string in the registry.
//
//
//  CARD_VDD_LOADED_OK indicates that a second MiniVDD (which is useful for
//  display card manufacturers wishing to extend the capabilities of the chip level
//  MiniVDD's ) has successfully been loaded and initialized.
//
//  DEVICE_IS_NOT_VGA indicates that this device is not the primary vga
//

#define NoTrace_VIRTUALIZE_CRTC_IN
#define NoTrace_VIRTUALIZE_CRTC_OUT
#define NoTrace_VIRTUALIZE_SEQUENCER_IN
#define NoTrace_VIRTUALIZE_SEQUENCER_OUT
#define NoTrace_VIRTUALIZE_GCR_IN
#define NoTrace_VIRTUALIZE_GCR_OUT
#define NoTrace_VIRTUALIZE_DAC_OUT
#define NoTrace_VIRTUALIZE_DAC_IN
#define NoTrace_CHECK_HIRES_MODE
/*ASM

ifdef NEC_98
;******************************************************************************
;				 E Q U A T E S
;******************************************************************************

    ;
    ;	Mini-VDD Static Flags
    ;
vFlg_Machine_Std	equ			00000001b
vFlg_Machine_Multi	equ			00000010b
vFlg_Machine_Mate	equ			00000100b
vFlg_Machine_H98	equ			00001000b
vFlg_CRT_New		equ			00010000b
vFlg_CRT_NonInter	equ			00100000b
vFlg_GDC_5MHz		equ			01000000b
vFlg_GDC_Emulate	equ			10000000b
vFlg_Acc_Internal	equ		0000000100000000b
vFlg_Acc_External	equ		0000001000000000b
vFlg_Acc_PCI		equ		0000010000000000b
vFlg_Acc_ML		equ		0000100000000000b
vFlg_Acc_PVD		equ		0001000000000000b
vFlg_Mode_NH		equ		0010000000000000b
vFlg_Mode_H		equ		0100000000000000b
vFlg_Initialized	equ		1000000000000000b
vFlg_Opt_MFR		equ	000000010000000000000000b
vFlg_Opt_NewMFR		equ	000000100000000000000000b
vFlg_Opt_VDP		equ	000001000000000000000000b
vFlg_Opt_NewVDP		equ	000010000000000000000000b

vFlg_Local		equ	000000000100000010000000b

    ;
    ;	Mini-VDD Support Max
    ;
MaxMiniVDD	equ	16
MaxMiniTrap	equ	32
MaxMultiTrap	equ	3
MaxMultiFunc	equ	MaxMiniVDD

    ;
    ;	MiniVDD_LTrap_Struct.LTrap_Status
    ;	MiniVDD_LTrap_Struct.LTrap_Flags.xxxx
    ;
LT_Enable	equ	00000001b
LT_Enable_bit	equ	0
LT_Initialized	equ	10000000b
LT_Initialized_bit equ	7


;******************************************************************************
;			D A T A   S T R U C T U R E S
;******************************************************************************

    ;
    ;	Vids_struct
    ;

Vids_struct struc
   ;
   ;	Common Data supplied by Base-VDD. Some data(bits) set by Mini-VDD.
   ;
	Vids_SFlags		dd	?	; Static flags
	Vids_CB_Offset		dd	?	; 
	Vids_Msg_Pseudo_VM	dd	?	; 

   ;
   ;	Common Procedure supplied by Base-VDD
   ;
	VDD_TGDC_Draw_Off	dd	?	; 
	VDD_TGDC_Sync_Off	dd	?	; 
	VDD_TGDC_Sync_On	dd	?	; 
	VDD_TGDC_FIFO_Empty	dd	?	; 
	VDD_GGDC_Draw_Off	dd	?	; 
	VDD_GGDC_Sync_Off	dd	?	; 
	VDD_GGDC_Sync_On	dd	?	; 
	VDD_GGDC_FIFO_Empty	dd	?	; 
	VDD_GGDC_MOD_Emulate	dd	?	; 

   ;
   ;	Common Procedure supplied by Mini-VDD
   ;
	H98_FLORA_Change	dd	?	; H98 - NH mode
	H98_Clear_Text		dd	?	; H98 - NH mode
	H98_Rest_GCs		dd	?	; H98
	H98_Rest_etc		dd	?	; H98
	H98_Save_ModeFF		dd	?	; H98

Vids_struct ends


Vid_SFlags		equ	<Vids.Vids_SFlags>
VDD_CB_Offset		equ	<Vids.Vids_CB_Offset>
VDD_Msg_Pseudo_VM	equ	<Vids.Vids_Msg_Pseudo_VM>

TGDC_Draw_Off		equ	<Vids.VDD_TGDC_Draw_Off>
GGDC_Draw_Off		equ	<Vids.VDD_GGDC_Draw_Off>
TGDC_Sync_On		equ	<Vids.VDD_TGDC_Sync_On>
TGDC_Sync_Off		equ	<Vids.VDD_TGDC_Sync_Off>
TGDC_FIFO_Empty		equ	<Vids.VDD_TGDC_FIFO_Empty>
GGDC_FIFO_Empty		equ	<Vids.VDD_GGDC_FIFO_Empty>


    ;
    ;	RegTrapStruct
    ;
MiniFuncStruct	STRUC
MF_ProcAddr	dd	?
;;MF_Order	dw	?
;;MF_MiniID	db	?
;;MF_Flags	db	?
MiniFuncStruct	ENDS

    ;
    ;	MiniProcStruct
    ;
MiniVDD_Proc_Struct	STRUC
Proc_Address	dd	?
Proc_Order	dw	?
Proc_MiniID	db	?
Proc_Flags	db	?
MiniVDD_Proc_Struct	ENDS
.errnz	(size MiniVDD_Proc_Struct) mod 4

    ;
    ;	MiniTrapTable	- Global Info
    ;	LocalTrapTable	- Local Status
    ;
MiniVDD_GTrap_Struct	STRUC
GTrap_ProcAddr	dd	?
GTrap_PortAddr	dw	?
GTrap_NumMini	dw	?
GTrap_ProcTable	db	((size MiniVDD_Proc_Struct) * MaxMultiTrap) dup (?)
MiniVDD_GTrap_Struct	ENDS

MiniVDD_LTrap_Struct	STRUC
LTrap_ProcAddr	dd	?
LTrap_Status	db	?
LTrap_Flags	db	MaxMultiTrap dup (?)
MiniVDD_LTrap_Struct	ENDS


;******************************************************************************
;				M A C R O S
;******************************************************************************

    ;
    ;	BeginMiniFunc	TableName
    ;	    MiniFunc	Function-ID, ProcedureName
    ;		|	
    ;	EndMiniFunc	TableName
    ;
EndMiniFunc_	MACRO	n
ifdef	MiniFunc&n
	dd	OFFSET32 MiniFunc&n		; MiniFuncStruct
else
	dd	0
endif
		ENDM

MiniFunc_	MACRO	FuncID, FuncName
		MiniFunc&FuncID equ <FuncName>
		ENDM

BeginMiniFunc	MACRO	TableName
public	TableName
TableName	label	near
		ENDM

EndMiniFunc	MACRO	TableName
		x = 0
		REPT	NBR_MINI_VDD_FUNCTIONS
		EndMiniFunc_	%x
		x = x + 1
		ENDM
		ENDM

MiniFunc	MACRO	FuncID, FuncName
		MiniFunc_ %(FuncID), <FuncName>
		ENDM

    ;
    ;	MiniVDDCall	Function-ID
    ;
MiniVDDCall	MACRO	FuncID, SetCarry
		local	MiniCall_Loop
		local	MiniCall_Exit

		push	ecx
		push	esi
		lea	esi, [MiniVDD_Func_Table][(size MiniVDD_Proc_Struct) * MaxMultiFunc * FuncID]
		mov	ecx, [MiniVDD_NumMini]
MiniCall_Loop:
		cmp	dword ptr [esi.Proc_Address], 0
		jz	MiniCall_Exit
		pushad
ifnb <SetCarry>
		stc
endif
		call	dword ptr [esi.Proc_Address]
		popad
		jc	MiniCall_Exit
		add	esi, size MiniVDD_Proc_Struct
		loop	MiniCall_Loop
MiniCall_Exit:
		pop	esi
		pop	ecx
		ENDM

    ;
    ;	MiniVDDCall	Function-ID
    ;
MiniVDDFunc	MACRO	TmpReg, FuncID
		mov	TmpReg, [MiniVDD_Func_Table.Proc_Address][(size MiniVDD_Proc_Struct) * MaxMultiFunc * FuncID]
		ENDM

    ;
    ;	ExecMode/ExecModeThru
    ;	ExecModeNot/ExecModeThruNot
    ;	ExecModeOnly
    ;	ExecModeOnlyNot
    ;	ExecModeElse
    ;	ExecModeElseNot
    ;	ExecModeEnd
    ;

ExecModeLL	macro	Num
ExecMode_L&Num:
		endm

ExecModeLE	macro	Num
ExecMode_E&Num:
		endm

ExecModeJE	macro	Num
	jmp	ExecMode_E&Num
		endm

ExecModeJZ	macro	Num
	jz	ExecMode_L&Num
		endm

ExecModeJNZ	macro	Num
	jnz	ExecMode_L&Num
		endm

ExecModeJEZ	macro	Num
	jz	ExecMode_E&Num
		endm

ExecModeJENZ	macro	Num
	jnz	ExecMode_E&Num
		endm


ExecModeTest	macro	ModeFlag, CB_Reg
if	ModeFlag and vFlg_Local
ifidni	<CB_Reg>, <Vid>
	push	ebx
	mov	ebx, [Vid_VM_Handle]
	add	ebx, [VDD_CB_Offset]
	test	[ebx.VDD_SFlags], ModeFlag
	pop	ebx
else
ifidni	<CB_Reg>, <Cur>
	push	ebx
	VMMCall	Get_Cur_VM_Handle
	add	ebx, [VDD_CB_Offset]
	test	[ebx.VDD_SFlags], ModeFlag
	pop	ebx
else
ifb	<CB_Reg>
	push	ebx
	add	ebx, [VDD_CB_Offset]
	test	[ebx.VDD_SFlags], ModeFlag
	pop	ebx
else
	test	[CB_Reg.VDD_SFlags], ModeFlag
endif
endif
endif
else
	test	[Vid_SFlags], ModeFlag
endif
	endm


ExecModeChk	macro	HdrFlag, JmpFlag, JmpLabel, ModeFlag, CB_Reg
ifidni	<HdrFlag>, <Jmp>
.erre	FlgExecMode
	ExecModeJE	%EndExecMode
endif
ExecModeLL	%NumExecMode
NumExecMode = NumExecMode + 1
FlgExecMode = 1
ifnb	<ModeFlag>
	ExecModeTest	<ModeFlag>, <CB_Reg>
ifidni	<JmpLabel>, <End>
ifidni	<JmpFlag>, <Not>
	ExecModeJENZ	%EndExecMode
else
	ExecModeJEZ	%EndExecMode
endif
else
ifidni	<JmpFlag>, <Not>
	ExecModeJNZ	%NumExecMode
else
	ExecModeJZ	%NumExecMode
endif
endif
endif
		endm

ExecModeEnd	macro
ExecModeLL	%NumExecMode
ExecModeLE	%EndExecMode
NumExecMode = NumExecMode + 1
EndExecMode = EndExecMode + 1
FlgExecMode = 0
		endm

   ;
   ;	CB_Reg   = Regs/Vid/Cur
   ;	ModeFlag = vFlg_xxxx
   ;
ExecModeJmp	macro	JmpLabel, ModeFlag, CB_Reg
	ExecModeTest	%ModeFlag, <CB_Reg>
	jnz	JmpLabel
		endm

ExecModeJmpNot	macro	JmpLabel, ModeFlag, CB_Reg
	ExecModeTest	%ModeFlag, <CB_Reg>
	jz	JmpLabel
		endm

ExecMode	macro	ModeFlag, CB_Reg
	ExecModeChk Top, Equ, Next, %ModeFlag, CB_Reg
		endm

ExecModeNot	macro	ModeFlag, CB_Reg
	ExecModeChk Top, Not, Next, %ModeFlag, CB_Reg
		endm

ExecModeOnly	macro	ModeFlag, CB_Reg
	ExecModeChk Top, Equ, End, %ModeFlag, CB_Reg
		endm

ExecModeOnlyNot	macro	ModeFlag, CB_Reg
	ExecModeChk Top, Not, End, %ModeFlag, CB_Reg
		endm

ExecModeElse	macro	ModeFlag, CB_Reg
	ExecModeChk Jmp, Equ, Next, %ModeFlag, CB_Reg
		endm

ExecModeElseNot	macro	ModeFlag, CB_Reg
	ExecModeChk Jmp, Not, Next, %ModeFlag, CB_Reg
		endm

ExecModeThru	macro	ModeFlag, CB_Reg
	ExecModeChk Thru, Equ, Next, %ModeFlag, CB_Reg
		endm

ExecModeThruNot	macro	ModeFlag, CB_Reg
	ExecModeChk Thru, Not, Next, %ModeFlag, CB_Reg
		endm

NumExecMode = 1
EndExecMode = 1
FlgExecMode = 0

else ;NEC_98
;
;Some external definitions.  Only define these if we're assembling the
;device independent "main" portion of the Mini-VDD:
;
ifdef MAINVDD
externdef	MiniVDDDispatchTable:dword	;in VDDCTL.ASM
endif ;MAINVDD
;
;
MiniVDDDispatch 	macro	FunctionCode, HandlerAddr
	mov	[edi+(FunctionCode*4)],OFFSET32 MiniVDD_&HandlerAddr
endm
;
;
CardVDDDispatch 	macro	FunctionCode, HandlerAddr
	mov	[edi+(FunctionCode*4)],OFFSET32 CardVDD_&HandlerAddr
endm
;
;
MiniVDDCall		macro	FunctionCode, SaveFlags
local   MiniVDDCallExit, MiniVDDCallLeave

ifdef MAXDEBUG
  ifndef NoTrace_&FunctionCode&
        Trace_Out "MiniVDDCall: &FunctionCode&"
  endif
endif
        push    edi                     ;;save this register for now
ifnb    <SaveFlags>
	pushfd				;;save the flags state
endif
	mov	edi,OFFSET32 MiniVDDDispatchTable
	cmp	dword ptr [edi+(FunctionCode*4)],0
	je	MiniVDDCallLeave	;;MiniVDD doesn't support this
ifnb	<SaveFlags>
	popfd				;;just clear the Stack from the flags
endif
        call    dword ptr [edi+(FunctionCode*4)]
ifnb	<SaveFlags>
	jmp	MiniVDDCallExit 	;;we already restored the flags
endif
;
MiniVDDCallLeave:
ifnb	<SaveFlags>
	popfd				;;
endif
;
MiniVDDCallExit:
	pop	edi			;;we're done handling this call
endm
endif ;NEC_98
*/

#endif  // _MINIVDD_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\common\inc\ddkmapi.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddkmapi.h
 *  Content:    Kernel mode APIs for accessing DirectDraw support.
 *
 ***************************************************************************/

#ifndef __DDKMAPI_INCLUDED__
#define __DDKMAPI_INCLUDED__


/*
 * API entry point
 */
DWORD
FAR PASCAL
DxApi(
    DWORD dwFunctionNum,
    DWORD lpvInBuffer,
    DWORD cbInBuffer,
    DWORD lpvOutBuffer,
    DWORD cbOutBuffer
);


#define DXAPI_MAJORVERSION              1
#define DXAPI_MINORVERSION              0

#define DD_FIRST_DXAPI                                  0x500

typedef DWORD (FAR PASCAL *LPDD_NOTIFYCALLBACK)(DWORD dwFlags, PVOID pContext, DWORD dwParam1, DWORD dwParam2);

/*
 * Queries the DXAPI version number.
 *
 * Input:  Null
 * Output: LPDDGETVERSIONNUMBER
 */
#define DD_DXAPI_GETVERSIONNUMBER                       (DD_FIRST_DXAPI)

    typedef struct _DDGETVERSIONNUMBER
    {
        DWORD   ddRVal;
        DWORD   dwMajorVersion;
        DWORD   dwMinorVersion;
    } DDGETVERSIONNUMBER, FAR *LPDDGETVERSIONNUMBER;

/*
 * Closes the kernel mode handle.
 *
 * Input:  LPDDCLOSEHANDLE
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_CLOSEHANDLE                            (DD_FIRST_DXAPI+1)

    typedef struct _DDCLOSEHANDLE
    {
        HANDLE  hHandle;
    } DDCLOSEHANDLE, FAR *LPDDCLOSEHANDLE;

/*
 * Opens the DirectDraw object and returns a kernel mode handle.
 *
 * Input:  LPDDOPENDIRECTDRAWIN
 * Output: LPDDOPENDIRECTDRAWOUT
 */
#define DD_DXAPI_OPENDIRECTDRAW                         (DD_FIRST_DXAPI+2)

    typedef struct _DDOPENDIRECTDRAWIN
    {
        DWORD               dwDirectDrawHandle;
        LPDD_NOTIFYCALLBACK pfnDirectDrawClose;
        PVOID               pContext;
    } DDOPENDIRECTDRAWIN, FAR *LPDDOPENDIRECTDRAWIN;

    typedef struct _DDOPENDIRECTDRAWOUT
    {
        DWORD   ddRVal;
        HANDLE  hDirectDraw;
    } DDOPENDIRECTDRAWOUT, FAR *LPDDOPENDIRECTDRAWOUT;

/*
 * Opens the surface and returns a kernel mode handle.
 *
 * Input:  LPDDOPENSURFACEIN
 * Output: LPDDOPENSURFACEOUT
 */
#define DD_DXAPI_OPENSURFACE                            (DD_FIRST_DXAPI+3)

    typedef struct _DDOPENSURFACEIN
    {
        HANDLE              hDirectDraw;
        DWORD               dwSurfaceHandle;
        LPDD_NOTIFYCALLBACK pfnSurfaceClose;
        PVOID               pContext;
    } DDOPENSURFACEIN, FAR *LPDDOPENSURFACEIN;

    typedef struct _DDOPENSURFACEOUT
    {
        DWORD   ddRVal;
        HANDLE  hSurface;
    } DDOPENSURFACEOUT, FAR *LPDDOPENSURFACEOUT;

/*
 * Opens the VideoPort and returns a kernel mode handle.
 *
 * Input:  LPDDOPENVIDEOPORTIN
 * Output: LPDDOPENVIDEOPORTOUT
 */
#define DD_DXAPI_OPENVIDEOPORT                          (DD_FIRST_DXAPI+4)

    typedef struct _DDOPENVIDEOPORTIN
    {
        HANDLE              hDirectDraw;
        DWORD               dwVideoPortHandle;
        LPDD_NOTIFYCALLBACK pfnVideoPortClose;
        PVOID               pContext;
    } DDOPENVIDEOPORTIN, FAR *LPDDOPENVIDEOPORTIN;

    typedef struct _DDOPENVIDEOPORTOUT
    {
        DWORD   ddRVal;
        HANDLE  hVideoPort;
    } DDOPENVIDEOPORTOUT, FAR *LPDDOPENVIDEOPORTOUT;

/*
 * Returns the kernel mode capabilities supported by the device
 *
 * Input:  HANDLE hDirectDraw
 * Output: LPDDGETKERNELCAPSOUT
 */
#define DD_DXAPI_GETKERNELCAPS                          (DD_FIRST_DXAPI+5)

    typedef struct _DDGETKERNELCAPSOUT
    {
        DWORD   ddRVal;
        DWORD   dwCaps;
        DWORD   dwIRQCaps;
    } DDGETKERNELCAPSOUT, FAR *LPDDGETKERNELCAPSOUT;

/*
 * Gets the current field number
 *
 * Input:  LPDDGETFIELDNUMIN
 * Output: LPDDGETFIELDNUMOUT
 */
#define DD_DXAPI_GET_VP_FIELD_NUMBER                    (DD_FIRST_DXAPI+6)

    typedef struct _DDGETFIELDNUMIN
    {
        HANDLE  hDirectDraw;
        HANDLE  hVideoPort;
    } DDGETFIELDNUMIN, FAR *LPDDGETFIELDNUMIN;

    typedef struct _DDGETFIELDNUMOUT
    {
        DWORD   ddRVal;
        DWORD   dwFieldNum;
    } DDGETFIELDNUMOUT, FAR *LPDDGETFIELDNUMOUT;

/*
 * Sets the current field number
 *
 * Input:  LPDDSETFIELDNUM
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_SET_VP_FIELD_NUMBER                    (DD_FIRST_DXAPI+7)

    typedef struct _DDSETFIELDNUM
    {
        HANDLE  hDirectDraw;
        HANDLE  hVideoPort;
        DWORD   dwFieldNum;
    } DDSETFIELDNUM, FAR *LPDDSETFIELDNUM;

/*
 * Indicates which fields should be skipped to undo the 3:2 pulldown.
 *
 * Input:  LPDDSETSKIPFIELD
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_SET_VP_SKIP_FIELD                      (DD_FIRST_DXAPI+8)

    typedef struct _DDSETSKIPFIELD
    {
        HANDLE  hDirectDraw;
        HANDLE  hVideoPort;
        DWORD   dwStartField;
    } DDSETSKIPFIELD, FAR *LPDDSETSKIPFIELD;

/*
 * Notifies whether the surface is in bob or weave mode.
 *
 * Input:  LPDDGETSURFACESTATEIN
 * Output: LPDDGETSURFACESTATEOUT
 */
#define DD_DXAPI_GET_SURFACE_STATE                      (DD_FIRST_DXAPI+9)

    typedef struct _DDGETSURFACESTATEIN
    {
        HANDLE  hDirectDraw;
        HANDLE  hSurface;
    } DDGETSURFACESTATEIN, FAR *LPDDGETSURFACESTATEIN;

    typedef struct _DDGETSURFACESTATEOUT
    {
        DWORD   ddRVal;
        DWORD   dwStateCaps;
        DWORD   dwStateStatus;
    } DDGETSURFACESTATEOUT, FAR *LPDDGETSURFACESTATEOUT;

/*
 * Changes the surface between bob and weave mode.
 *
 * Input:  LPDDSETSURFACESTATE
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_SET_SURFACE_STATE                      (DD_FIRST_DXAPI+10)

    typedef struct _DDSETSURFACETATE
    {
        HANDLE  hDirectDraw;
        HANDLE  hSurface;
        DWORD   dwState;
        DWORD   dwStartField;
    } DDSETSURFACESTATE, FAR *LPDDSETSURFACESTATE;

/*
 * Allows direct access to the surface memory
 *
 * Input:  LPDDLOCKIN
 * Output: LPDDLOCKOUT
 */
#define DD_DXAPI_LOCK                                   (DD_FIRST_DXAPI+11)

    typedef struct _DDLOCKIN
    {
        HANDLE  hDirectDraw;
        HANDLE  hSurface;
    } DDLOCKIN, FAR *LPDDLOCKIN;

    typedef struct _DDLOCKOUT
    {
        DWORD   ddRVal;
        DWORD   dwSurfHeight;
        DWORD   dwSurfWidth;
        LONG    lSurfPitch;
        PVOID   lpSurface;
        DWORD   SurfaceCaps;
        DWORD   dwFormatFlags;
        DWORD   dwFormatFourCC;
        DWORD   dwFormatBitCount;
        union
        {
            DWORD       dwRBitMask;
            DWORD       dwYBitMask;
        };
        union
        {
            DWORD       dwGBitMask;
            DWORD       dwUBitMask;
        };
        union
        {
            DWORD       dwBBitMask;
            DWORD       dwVBitMask;
        };
    } DDLOCKOUT, FAR *LPDDLOCKOUT;

/*
 * Flips the overlay surface
 *
 * Input:  LPDDFLIPOVERLAY
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_FLIP_OVERLAY                           (DD_FIRST_DXAPI+12)

    typedef struct _DDFLIPOVERLAY
    {
        HANDLE  hDirectDraw;
        HANDLE  hCurrentSurface;
        HANDLE  hTargetSurface;
        DWORD   dwFlags;
    } DDFLIPOVERLAY, FAR *LPDDFLIPOVERLAY;

/*
 * Flips the video port
 *
 * Input:  LPDDFLIPOVERLAY
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_FLIP_VP                                (DD_FIRST_DXAPI+13)

    typedef struct _DDFLIPVIDEOPORT
    {
        HANDLE  hDirectDraw;
        HANDLE  hVideoPort;
        HANDLE  hCurrentSurface;
        HANDLE  hTargetSurface;
        DWORD   dwFlags;
    } DDFLIPVIDEOPORT, FAR *LPDDFLIPVIDEOPORT;

/*
 * Returns the current surface receiving the data while autoflipping
 *
 * Input:  LPDDGETAUTOFLIPIN
 * Output: LPDDGETAUTOFLIPOUT
 */
#define DD_DXAPI_GET_CURRENT_VP_AUTOFLIP_SURFACE        (DD_FIRST_DXAPI+14)

    typedef struct _DDGETAUTOFLIPIN
    {
        HANDLE  hDirectDraw;
        HANDLE  hVideoPort;
    } DDGETAUTOFLIPIN, FAR *LPDDGETAUTOFLIPIN;

    typedef struct _DDGETAUTOFLIPOUT
    {
        DWORD   ddRVal;
        HANDLE  hVideoSurface;
        HANDLE  hVBISurface;
        BOOL    bPolarity;
    } DDGETAUTOFLIPOUT, FAR *LPDDGETAUTOFLIPOUT;

/*
 * Returns the surface that received the previous field of data (could
 * be the same as current if video is interleaved)
 *
 * Input:  LPDDGETAUTOFLIPIN
 * Output: LPDDGETAUTOFLIPOUT
 */
#define DD_DXAPI_GET_LAST_VP_AUTOFLIP_SURFACE           (DD_FIRST_DXAPI+15)

/*
 * Registers a callback for when various events occur.
 *
 * Input:  LPDDREGISTERCALLBACK
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_REGISTER_CALLBACK                      (DD_FIRST_DXAPI+16)

    typedef struct _DDREGISTERCALLBACK
    {
        HANDLE              hDirectDraw;
        DWORD               dwEvents;
        LPDD_NOTIFYCALLBACK pfnCallback;
        DWORD               dwParam1;
        DWORD               dwParam2;
        PVOID               pContext;
    } DDREGISTERCALLBACK, FAR *LPDDREGISTERCALLBACK;

/*
 * Unregisters a callback for when various events occur.
 *
 * Input:  LPDDREGISTERCALLBACK
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_UNREGISTER_CALLBACK                    (DD_FIRST_DXAPI+17)

/*
 * Returns the polarity (odd/even) of the current field
 *
 * Input:  LPDDGETPOLARITYIN
 * Output: LPDDGETPOLARITYOUT
 */
#define DD_DXAPI_GET_POLARITY                           (DD_FIRST_DXAPI+18)

    typedef struct _DDGETPOLARITYIN
    {
        HANDLE  hDirectDraw;
        HANDLE  hVideoPort;
    } DDGETPOLARITYIN, FAR *LPDDGETPOLARITYIN;

    typedef struct _DDGETPOLARITYOUT
    {
        DWORD   ddRVal;
        BOOL    bPolarity;
    } DDGETPOLARITYOUT, FAR *LPDDGETPOLARITYOUT;

/*
 * Opens the device for capture
 *
 * Input:  LPDDOPENCAPTUREDEVICEIN
 * Output: LPDDOPENCAPTUREDEVICEOUT
 */
#define DD_DXAPI_OPENVPCAPTUREDEVICE                    (DD_FIRST_DXAPI+19)

    typedef struct _DDOPENVPCAPTUREDEVICEIN
    {
        HANDLE  hDirectDraw;
        HANDLE  hVideoPort;
        DWORD   dwStartLine;
        DWORD   dwEndLine;
        DWORD   dwCaptureEveryNFields;
        LPDD_NOTIFYCALLBACK pfnCaptureClose;
        PVOID   pContext;
    } DDOPENVPCAPTUREDEVICEIN, FAR * LPDDOPENVPCAPTUREDEVICEIN;

    typedef struct _DDOPENVPCAPTUREDEVICEOUT
    {
        DWORD   ddRVal;
        HANDLE  hCapture;
    } DDOPENVPCAPTUREDEVICEOUT, FAR * LPDDOPENVPCAPTUREDEVICEOUT;

/*
 * Adds a capture buffer to the internal video port capture queue
 *
 * Input:  LPDDADDVPCAPTUREBUFF
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_ADDVPCAPTUREBUFFER                     (DD_FIRST_DXAPI+20)

    typedef struct _DDCAPBUFFINFO
    {
        DWORD           dwFieldNumber;
        DWORD           bPolarity;
        LARGE_INTEGER   liTimeStamp;
        DWORD           ddRVal;
    } DDCAPBUFFINFO, FAR * LPDDCAPBUFFINFO;

    typedef struct _DDADDVPCAPTUREBUFF
    {
        HANDLE  hCapture;
        DWORD   dwFlags;
        PMDL    pMDL;
        PKEVENT pKEvent;
        LPDDCAPBUFFINFO lpBuffInfo;
    } DDADDVPCAPTUREBUFF, FAR * LPDDADDVPCAPTUREBUFF;

    #define DDADDBUFF_SYSTEMMEMORY      0x0001  // lpBuffer points to sys mem
    #define DDADDBUFF_NONLOCALVIDMEM    0x0002  // lpBuffer points to AGP mem
    #define DDADDBUFF_INVERT            0x0004  // invert the buffer during capture

/*
 * Flushes the internal video port capture queue
 *
 * Input:  HANDLE to capture device
 * Output: DWORD DirectDraw return value
 */
#define DD_DXAPI_FLUSHVPCAPTUREBUFFERS                  (DD_FIRST_DXAPI+21)


/*
 * State flags returned by DSVXD_DXAPI_DD_GET_SURFACE_STATE
 */
#define DDSTATE_BOB                             0x0001
#define DDSTATE_WEAVE                           0x0002
#define DDSTATE_EXPLICITLY_SET                  0x0004
#define DDSTATE_SOFTWARE_AUTOFLIP               0x0008

/*
 * Event flags - passed into RegisterCallback
 */
#define DDEVENT_DISPLAY_VSYNC                   0x0001
#define DDEVENT_VP_VSYNC                        0x0002
#define DDEVENT_VP_LINE                         0x0004
#define DDEVENT_PRERESCHANGE                    0x0008
#define DDEVENT_POSTRESCHANGE                   0x0010
#define DDEVENT_PREDOSBOX                       0x0020
#define DDEVENT_POSTDOSBOX                      0x0040

/*
 * Notification flags - passed to the notification proc
 */
#define DDNOTIFY_DISPLAY_VSYNC                  0x0001  // dwParam1 = hDirectDraw
#define DDNOTIFY_VP_VSYNC                       0x0002  // dwParam1 = hVideoPort
#define DDNOTIFY_VP_LINE                        0x0004  // dwParam1 = hVideoPort
#define DDNOTIFY_PRERESCHANGE                   0x0008  // dwParam1 = hDirectDraw
#define DDNOTIFY_POSTRESCHANGE                  0x0010  // dwParam1 = hDirectDraw
#define DDNOTIFY_PREDOSBOX                      0x0020  // dwParam1 = hDirectDraw
#define DDNOTIFY_POSTDOSBOX                     0x0040  // dwParam1 = hDirectDraw
#define DDNOTIFY_CLOSEDIRECTDRAW                0x0080  // dwParam1 = hDirectDraw
#define DDNOTIFY_CLOSESURFACE                   0x0100  // dwParam1 = hSurface
#define DDNOTIFY_CLOSEVIDEOPORT                 0x0200  // dwParam1 = hVideoPort
#define DDNOTIFY_CLOSECAPTURE                   0x0400  // dwParam1 = hCapture

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\inc\arb_fifo.h ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1997 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************** ARB Structures ****************************\
*                                                                           *
* Module: ARB_FIFO.H                                                        *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#ifndef _ARB_FIFO_H

#define ARB_FIFO_H

#define DEFAULT_GR_LWM 100
#define DEFAULT_VID_LWM 100
#define DEFAULT_GR_BURST_SIZE 256
#define DEFAULT_VID_BURST_SIZE 128


typedef struct {

  int graphics_lwm;  // GR LWM
  int video_lwm;    // Video LWM

  int graphics_burst_size;
  int video_burst_size;

  int valid;  // good values

} fifo_info;

typedef struct {
  int pclk_khz;
  int mclk_khz;
  int nvclk_khz;
  char mem_page_miss;
  char mem_latency; //cas_latency
  int memory_width;
  char enable_video;
  char gr_during_vid;
  char pix_bpp;
  char mem_aligned;
  char enable_mp;
} sim_state;

#define VIDEO		0
#define GRAPHICS	1
#define MPORT		2
#define ENGINE		3


#define GFIFO_SIZE	320 	/* Graphics Fifo Sizes */
#define GFIFO_SIZE_128	256 /* Graphics Fifo Sizes */
#define MFIFO_SIZE	120	    /* MP  Fifo Sizes */
#define VFIFO_SIZE	256	    /* Video Fifo Sizes */

#define	ABS(a)	(a>0?a:-a)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\kelvin\src\nvKelvinVbPrim.cpp ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// ********************************* Direct 3D ******************************
//
//  Module: nvKelvinVbPrim.cpp
//       indexed and ordered vb primitives
//
//***************************************************************************
//
//  History:
//       Craig Duttweiler         10Aug2000         ported from celsius
//
//***************************************************************************
#include "nvprecomp.h"

#if (NVARCH >= 0x20)

#include "x86.h"

#ifdef KELVIN_ILC

//////////////////////////////////////////////////////////////////////////////
// aliases
//
#define ilcData         global.dwILCData
#define ilcCount        global.dwILCCount
#define ilcMax          global.dwILCMax

//////////////////////////////////////////////////////////////////////////////
// externals
//
void ILCCompile_mul                      (DWORD reg,DWORD num);
void nvKelvinILCompile_beginEnd              (DWORD dwPrimType);
void nvKelvinILCompile_computeIndexAndOffset (DWORD dwVBStride,DWORD dwVBLogStride);
void nvKelvinILCompile_memcpy                 (DWORD dwCount, bool recurse);
void nvKelvinILCompile_indexcpy               (DWORD dwCount);
void nvKelvinILCompile_copyVertex            (PNVD3DCONTEXT pContext,DWORD dwFlags);
void nvKelvinILCompile_prefetch              (BOOL bIsIndexed,BOOL bLegacyStrides);
void nvKelvinILCompile_limit                 (DWORD regLimit,DWORD regDummy);

void __stdcall nvKelvinDispatchGetFreeSpace   (PNVD3DCONTEXT pContext);
void __stdcall nvKelvinDispatchGetPusherSpace (void);
#ifdef DEBUG
void __stdcall nvKelvinDispatchFlush          (void);
void __stdcall nvKelvinDispatchPrintVertex    (PNVD3DCONTEXT pContext,DWORD dwPutAddress);
#endif

//---------------------------------------------------------------------------

// vb primitive

DWORD nvKelvinILCompile_vb_prim
(
    PNVD3DCONTEXT pContext,
    DWORD         dwFlags
)
{
    //
    // get loop constants
    //
    DWORD  dwMagic                = kelvinPrimitiveToPrimitiveMagic[dwFlags & KELVIN_ILMASK_PRIMTYPE];
    DWORD  dwVerticesPerPrim      = (dwMagic >> 8) & 0xff;
    DWORD  dwStartVerticesPerPrim = (dwMagic >> 0) & 0xff;
    BOOL   bLegacyStrides         = dwFlags & KELVIN_ILFLAG_LEGACY;
    BOOL   bIsIndexed             = (dwFlags & KELVIN_ILMASK_LOOPTYPE) == KELVIN_ILFLAG_IX_VB_PRIM;

    //
    // align entry point
    //
    while (ilcCount & 31) { xINT3 }
    DWORD lEntry;
    xLABEL (lEntry);
    //
    // setup stack frame
    //
    xPUSH_r     (rEBP)
    xPUSH_r     (rEBX)
    xPUSH_r     (rESI)
    xPUSH_r     (rEDI)

    //
    // verify that we are using the correct inner loop - debug only
    //
#ifdef DEBUG
    DWORD ld1,ld2;
    xLABEL      (ld1)
    xJMP        (0)
    xLABEL      (ld2)
    xINT3

#define CHECK(a,x)                  \
{                                   \
    xMOV_rm_imm (rmREG(rEBX),a)     \
    xMOV_rm_imm (rmREG(rEAX),x)     \
    xCMP_r_i32  (rEAX,mMEM32(x))    \
    xJNZ32      (ld2)               \
}
#define CHECK2(a,x,y,t)             \
{                                   \
    xMOV_r_i32  (rEDX,mMEM32(global.kelvin.x))    \
    xMOV_rm_imm (rmREG(rEBX),a)     \
    xMOV_rm_imm (rmREG(rEAX),x->y)   \
    xCMP_r_rm   (rEAX,rmIND32(rEDX)) xOFS32(OFFSETOF(t,y)) \
    xJNZ32      (ld2)               \
}

    xTARGET_jmp (ld1)

/*
    CHECK (0x00000000,fvfData.dwVertexStride)

    CHECK (0x00010000,fvfData.dwVertexType)

    CHECK (0x00020000,fvfData.dwUVCount[0])
    CHECK (0x00020001,fvfData.dwUVCount[1])
    CHECK (0x00020002,fvfData.dwUVCount[2])
    CHECK (0x00020003,fvfData.dwUVCount[3])
    CHECK (0x00020004,fvfData.dwUVCount[4])
    CHECK (0x00020005,fvfData.dwUVCount[5])
    CHECK (0x00020006,fvfData.dwUVCount[6])
    CHECK (0x00020007,fvfData.dwUVCount[7])

    CHECK (0x00030000,fvfData.dwUVOffset[0])
    CHECK (0x00030001,fvfData.dwUVOffset[1])
    CHECK (0x00030002,fvfData.dwUVOffset[2])
    CHECK (0x00030003,fvfData.dwUVOffset[3])
    CHECK (0x00030004,fvfData.dwUVOffset[4])
    CHECK (0x00030005,fvfData.dwUVOffset[5])
    CHECK (0x00030006,fvfData.dwUVOffset[6])
    CHECK (0x00030007,fvfData.dwUVOffset[7])
*/

    //  - pContext->hwState.dwStateFlags & KELVIN_MASK_INNERLOOPUNIQUENESS
    xMOV_r_i32  (rEDX,mMEM32(global.kelvin.pContext))
    xMOV_rm_imm (rmREG(rEBX),0x00040000)
    xMOV_r_rm   (rEAX,rmIND32(rEDX)) xOFS32(OFFSETOF(NVD3DCONTEXT, hwState.dwStateFlags))
    xAND_rm_imm (rmREG(rEAX),KELVIN_MASK_INNERLOOPUNIQUENESS)
    xCMP_rm_imm (rmREG(rEAX),pContext->hwState.dwStateFlags & KELVIN_MASK_INNERLOOPUNIQUENESS)
    xJNZ32      (ld2)

    if (pContext->hwState.dwStateFlags & KELVIN_FLAG_USERTEXCOORDSNEEDED(0))
    {
        CHECK2 (0x00050000,pContext,hwState.dwTexUnitToTexStageMapping[0],NVD3DCONTEXT)
    }
    if (pContext->hwState.dwStateFlags & KELVIN_FLAG_USERTEXCOORDSNEEDED(1))
    {
        CHECK2 (0x00050001,pContext,hwState.dwTexUnitToTexStageMapping[1],NVD3DCONTEXT)
    }
#endif

    //
    // setup push buffer
    //
    xMOV_r_i32  (rEDX,mMEM32(pDriverData))
    xMOV_r_rm   (rEDI,rmIND32(rEDX)) xOFS32(OFFSETOF(CDriverContext,nvPusher.m_dwPut))

    //
    // start prim
    //
    xMOV_rm_imm (rmREG(rEAX),((sizeSetNv20KelvinBeginEndMthdCnt << 2) << 16) | ((NV_DD_KELVIN) << 13) | NV097_SET_BEGIN_END);
    xMOV_rm_imm (rmREG(rECX),kelvinBeginEndOp[dwFlags & KELVIN_ILMASK_PRIMTYPE])
    xMOV_rm_r   (rmIND(rEDI),rEAX)
    xMOV_rm_r   (rmIND8(rEDI),rECX) xOFS8(4)
    xLEA_r_rm   (rEDI,rmIND8(rEDI)) xOFS8(8)

    //
    // do work
    //
    if (bIsIndexed)
    {
        //
        // indexed VB
        //

        //
        // setup prefetcher
        //
        xMOV_r_i32  (rEBX,mMEM32(global.kelvin.dwPrimCount))
        ILCCompile_mul (rEBX,bLegacyStrides ? 4 : dwVerticesPerPrim);
        if (dwStartVerticesPerPrim)
        {
            xADD_rm_imm (rmREG(rEBX),dwStartVerticesPerPrim)
        }
        xLEA_r_rm   (rECX,rmSIB) xSIB(rEBX,rEBX,x1)

        xMOV_r_i32  (rEAX,mMEM32(global.kelvin.pIndices))
        xADD_r_rm   (rECX,rmREG(rEAX))
        xMOV_i32_r  (mMEM32(global.kelvin.dwPrefetchBase),rEAX)
        xMOV_i32_r  (mMEM32(global.kelvin.dwPrefetchMax),rECX)

        //
        // send indices
        //
        xMOV_r_i32  (rESI,mMEM32(global.kelvin.pIndices))
        DWORD labelNext;
        xLABEL      (labelNext)

        //
        // prefetch
        //
        DWORD labelPrefetch1;
        DWORD labelPrefetch2;
        DWORD labelPrefetch3;
        xMOV_r_i32  (rEDX,mMEM32(global.kelvin.dwPrefetchBase))
        xCMP_r_rm   (rEDX,rmREG(rESI))
        xLABEL      (labelPrefetch1)
        xJA32       (0)

        xMOV_rm_imm (rmREG(rECX),2048 / 32)
        xLABEL      (labelPrefetch2)
        {
            xCMP_r_i32  (rEDX,mMEM32(global.kelvin.dwPrefetchMax))
            xLABEL      (labelPrefetch3)
            xJAE32      (0)
            xMOV_r_rm   (rEAX,rmIND(rEDX))
            xDEC_rm     (rmREG(rECX))
            xLEA_r_rm   (rEDX,rmIND8(rEDX)) xOFS8(32)
            xJNZ32      (labelPrefetch2)
        }
        xTARGET_b32 (labelPrefetch3)
        xMOV_i32_r  (mMEM32(global.kelvin.dwPrefetchBase),rEDX)
        xTARGET_b32 (labelPrefetch1)

        //
        // copy indices
        //
        if (bLegacyStrides)
        {
            //
            // legacy - pretty simple since it MUST be a tri list
            //          source = index0:16,index1:16,index2:16,flags:16
            //
            xMOV_r_rm   (rEAX,rmIND(rESI))
            xMOV_r_rm   (rECX,rmIND8(rESI)) xOFS8(4)
            xLEA_r_rm   (rESI,rmIND8(rESI)) xOFS8(8)
            xMOV_r_rm   (rEBP,rmREG(rEAX))
            xAND_rm_imm (rmREG(rEAX),0xffff)
            xADD_r_i32  (rEAX, mMEM32(global.kelvin.dwBaseVertex) ) //add base index
            xMOV_rm_imm (rmREG(rEDX),((((3) << 2) << 16) | ((NV_DD_KELVIN) << 13) | (NVPUSHER_NOINC(NV097_ARRAY_ELEMENT32))))
            xSHR_rm_imm8(rmREG(rEBP),16)
            xADD_r_i32  (rEBP, mMEM32(global.kelvin.dwBaseVertex) ) //add base index
            xMOV_rm_r   (rmIND(rEDI),rEDX)
            xMOV_rm_r   (rmIND8(rEDI),rEAX) xOFS8(4)
            xLEA_r_rm   (rEDI,rmIND8(rEDI)) xOFS8(16)
            xAND_rm_imm (rmREG(rECX),0xffff)
            xADD_r_i32  (rECX, mMEM32(global.kelvin.dwBaseVertex) ) //add base index
            xMOV_rm_r   (rmIND8(rEDI),rEBP) xOFS8(8 - 16)
            xSUB_rm_imm (rmREG(rEBX),4)
            xMOV_rm_r   (rmIND8(rEDI),rECX) xOFS8(12 - 16)
            // next tri
            xJNZ32      (labelNext)
        }
        else
        {
            //
            // do a 64 index batch
            //
            DWORD labelCopy0;
            xCMP_rm_imm (rmREG(rEBX),64)
            xLABEL      (labelCopy0)
            xJB32       (0)
            {
                xMOV_rm_imm (rmREG(rEAX),((((32) << 2) << 16) | ((NV_DD_KELVIN) << 13) | (NVPUSHER_NOINC(NV097_ARRAY_ELEMENT16))))
                xMOV_rm_r   (rmIND(rEDI),rEAX)
                xLEA_r_rm   (rEDI,rmIND8(rEDI)) xOFS8(4)

                nvKelvinILCompile_indexcpy (128);

                // check for pusher space
                DWORD labelSpace;
                xMOV_r_i32  (rEDX,mMEM32(pDriverData))
                xCMP_r_rm   (rEDI,rmIND32(rEDX)) xOFS32(OFFSETOF(CDriverContext,nvPusher.m_dwThreshold))
                xLABEL      (labelSpace)
                xJL         (0)
                {
                    xMOV_rm_r   (rmIND32(rEDX),rEDI) xOFS32(OFFSETOF(CDriverContext,nvPusher.m_dwPut))
                    xMOV_rm_imm (rmREG(rEAX),(DWORD)nvKelvinDispatchGetPusherSpace)
                    xPUSH_r     (rEDX)
                    xCALL_rm    (rmREG(rEAX))
                    xPOP_r      (rEDX)
                    xMOV_r_rm   (rEDI,rmIND32(rEDX)) xOFS32(OFFSETOF(CDriverContext,nvPusher.m_dwPut))
                }
                xTARGET_b8  (labelSpace)

                xSUB_rm_imm (rmREG(rEBX),64)
                xJMP        (labelNext)
            }
            xTARGET_b32 (labelCopy0) // back to prefetch

            //
            // do a 16 index batch
            //
            DWORD labelCopy1;
            xCMP_rm_imm (rmREG(rEBX),16)
            xLABEL      (labelCopy1)
            xJB32       (0)
            {
                xMOV_rm_imm (rmREG(rEAX),((((8) << 2) << 16) | ((NV_DD_KELVIN) << 13) | (NVPUSHER_NOINC(NV097_ARRAY_ELEMENT16))))
                xMOV_rm_r   (rmIND(rEDI),rEAX)
                xLEA_r_rm   (rEDI,rmIND8(rEDI)) xOFS8(4)

                nvKelvinILCompile_indexcpy (32);

                xSUB_rm_imm (rmREG(rEBX),16)
                xJMP        (labelNext) // back to prefetch
            }
            xTARGET_b32 (labelCopy1)

            //
            // do a 4 index batch
            //
            DWORD labelCopy2,labelNext2;
            xLABEL      (labelNext2)
            xCMP_rm_imm (rmREG(rEBX),4)
            xLABEL      (labelCopy2)
            xJB32       (0)
            {
                xMOV_rm_imm (rmREG(rEAX),((((2) << 2) << 16) | ((NV_DD_KELVIN) << 13) | (NVPUSHER_NOINC(NV097_ARRAY_ELEMENT16))))
                xMOV_rm_r   (rmIND(rEDI),rEAX)
                xLEA_r_rm   (rEDI,rmIND8(rEDI)) xOFS8(4)

                nvKelvinILCompile_indexcpy (8);

                xSUB_rm_imm (rmREG(rEBX),4)
                xJMP        (labelNext2)
            }
            xTARGET_b32 (labelCopy2)

            //
            // do a single index
            //
            DWORD labelCopy3,labelNext3;
            xOR_r_rm    (rEBX,rmREG(rEBX))
            xLABEL      (labelCopy3)
            xJZ32       (0)
            xMOV_rm_imm (rmREG(rEDX),8)
            xLABEL      (labelNext3)
            {
                xXOR_r_rm   (rECX,rmREG(rECX))
                xMOV_rm_imm (rmREG(rEAX),((((1) << 2) << 16) | ((NV_DD_KELVIN) << 13) | (NVPUSHER_NOINC(NV097_ARRAY_ELEMENT32))))
           x16r xMOV_r_rm   (rCX,rmIND(rESI))
                xLEA_r_rm   (rESI,rmIND8(rESI)) xOFS8(2)
                xMOV_rm_r   (rmIND(rEDI),rEAX)
                xADD_r_rm   (rEDI,rmREG(rEDX))
                xADD_r_i32  (rECX, mMEM32(global.kelvin.dwBaseVertex) ) //add base index
                xDEC_rm     (rmREG(rEBX))
                xMOV_rm_r   (rmIND8(rEDI),rECX) xOFS8(4 - 8)
                xJNZ32      (labelNext3)
            }
            xTARGET_b32 (labelCopy3)
        }
    }
    else
    {
        //
        // ordered VB
        //

        //
        // compute how many vertices to send
        //
        xMOV_r_i32  (rEBX,mMEM32(global.kelvin.dwPrimCount))
        ILCCompile_mul (rEBX,dwVerticesPerPrim);
        if (dwStartVerticesPerPrim)
        {
            xADD_rm_imm (rmREG(rEBX),dwStartVerticesPerPrim)
        }

        //
        // zero out the index counter
        //
        xXOR_r_rm   (rESI,rmREG(rESI))

        //
        // send
        //
        DWORD labelNext1;
        DWORD labelNext3;
        xLABEL      (labelNext3)
        xCMP_rm_imm (rmREG(rEBX),128)
        xLABEL      (labelNext1)
        xJB32       (0)
        {
            // send 128 vertices
            xMOV_rm_imm (rmREG(rEAX),(((sizeSetNv20KelvinDrawArraysMthdCnt << 2) << 16) | ((NV_DD_KELVIN) << 13) | NV097_DRAW_ARRAYS))
            xMOV_rm_r   (rmREG(rECX),rESI)
            // xSHL_rm_imm (rmREG(rECX),0 ? NV056_DRAW_ARRAYS_START_INDEX)  // in principle this should be here, but it's a <<0
            xOR_rm_imm  (rmREG(rECX),DRF_NUM(056, _DRAW_ARRAYS, _COUNT, (128 - 1)))
            xMOV_rm_r   (rmIND(rEDI),rEAX)
            xMOV_rm_r   (rmIND8(rEDI),rECX) xOFS8(4)
            xLEA_r_rm   (rEDI,rmIND8(rEDI)) xOFS8(8)
            xSUB_rm_imm (rmREG(rEBX),128)  // decrement the vertex counter
            xADD_rm_imm (rmREG(rESI),128)  // increment the index counter

            // check for pusher space
            xMOV_r_i32  (rEDX,mMEM32(pDriverData))
            xCMP_r_rm   (rEDI,rmIND32(rEDX)) xOFS32(OFFSETOF(CDriverContext,nvPusher.m_dwThreshold))
            xJL32       (labelNext3)
            {
                xMOV_rm_r   (rmIND32(rEDX),rEDI) xOFS32(OFFSETOF(CDriverContext,nvPusher.m_dwPut))
                xMOV_rm_imm (rmREG(rEAX),(DWORD)nvKelvinDispatchGetPusherSpace)
                xPUSH_r     (rEDX)
                xCALL_rm    (rmREG(rEAX))
                xPOP_r      (rEDX)
                xMOV_r_rm   (rEDI,rmIND32(rEDX)) xOFS32(OFFSETOF(CDriverContext,nvPusher.m_dwPut))
            }
            xJMP        (labelNext3)
        }
        xTARGET_b32     (labelNext1)

        DWORD labelNext2;
        xOR_r_rm        (rEBX,rmREG(rEBX))
        xLABEL          (labelNext2)
        xJZ32           (0)
        {
            // send rest of vertices
            xMOV_rm_imm (rmREG(rEAX),(((sizeSetNv20KelvinDrawArraysMthdCnt << 2) << 16) | ((NV_DD_KELVIN) << 13) | NV097_DRAW_ARRAYS))
            xDEC_rm     (rmREG(rEBX))
            xSHL_rm_imm8(rmREG(rEBX),0 ? NV097_DRAW_ARRAYS_COUNT)
            // xSHL_rm_imm (rmREG(rESI),0 ? NV056_DRAW_ARRAYS_START_INDEX)  // in principle this should be here, but it's a <<0
            xOR_rm_r    (rmREG(rEBX),rESI)

            xMOV_rm_r   (rmIND(rEDI),rEAX)
            xMOV_rm_r   (rmIND8(rEDI),rEBX) xOFS8(4)
            xLEA_r_rm   (rEDI,rmIND8(rEDI)) xOFS8(8)
        }
        xTARGET_b32     (labelNext2)
    }

    //
    // end prim
    //
    xMOV_rm_imm (rmREG(rEAX),((sizeSetNv20KelvinBeginEndMthdCnt << 2) << 16) | ((NV_DD_KELVIN) << 13) | NV097_SET_BEGIN_END);
    xMOV_rm_imm (rmREG(rECX),NV097_SET_BEGIN_END_OP_END)
    xMOV_rm_r   (rmIND(rEDI),rEAX)
    xMOV_rm_r   (rmIND8(rEDI),rECX) xOFS8(4)
    xLEA_r_rm   (rEDI,rmIND8(rEDI)) xOFS8(8)

    // check for pusher space
    DWORD labelSpace;
    xMOV_r_i32  (rESI,mMEM32(pDriverData))
    xCMP_r_rm   (rEDI,rmIND32(rESI)) xOFS32(OFFSETOF(CDriverContext,nvPusher.m_dwThreshold))
    xLABEL      (labelSpace)
    xJL         (0)
    {
        xMOV_rm_r   (rmIND32(rESI),rEDI) xOFS32(OFFSETOF(CDriverContext,nvPusher.m_dwPut))
        xMOV_rm_imm (rmREG(rEAX),(DWORD)nvKelvinDispatchGetPusherSpace)
        xCALL_rm    (rmREG(rEAX))
        xMOV_r_rm   (rEDI,rmIND32(rESI)) xOFS32(OFFSETOF(CDriverContext,nvPusher.m_dwPut))
    }
    xTARGET_b8  (labelSpace)

    //
    // save off push buffer
    //
    xMOV_r_i32  (rEDX,mMEM32(pDriverData))
#ifndef NV_NULL_HW_DRIVER
    xMOV_rm_r   (rmIND32(rEDX),rEDI) xOFS32(OFFSETOF(CDriverContext,nvPusher.m_dwPut))
#endif

    //
    // done
    //
    xPOP_r      (rEDI)
    xPOP_r      (rESI)
    xPOP_r      (rEBX)
    xPOP_r      (rEBP)
    xRET
    return lEntry;
}

#endif KELVIN_ILC

#endif  // NVARCH == 0x20
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\common\src\surfaces.c ===
/***************************************************************************\
* (C) Copyright NVIDIA Corporation Inc.,                                    *
*  1996,1997, 1998. All rights reserved.                                    *
*                                                                           *
* Module: surfaces.c                                                        *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       schaefer           3/26/98                                          *
*                                                                           *
\***************************************************************************/

// MS includes
#include "windows.h"
#include "ddraw.h"
//#include "Ddrawp.h"
#include "ddrawi.h"
#include "ddmini.h"
#include "dvp.h"
#include "dmemmgr.h"
#include "ddkmmini.h"
#include "ddkmapi.h"

#ifndef NV4
#include "real3nv32.h"
#include "nvwin32.h"
#include "nvos.h"
#else
#include "realnv32.h"
#include "nvwin32.h"
#include "nvos.h"
#endif  //NV4
// NV includes



#ifdef  MULTI_MON
#include "nvrmapi.h"
#include "nvrmarch.inc"


// we're going to use this definition so that we can 
// do this under NT or Win9x "MULTI-MON" which is a cheeser way of saying
// that we're using the NValloc architecture
#define USE_NV_ALLOC_ARCH

#endif  // MULTI_MON

// unit specific includes
#include "surfaces.h"
#include "VidTex.h"
#include "nvcm.h"

// Hey Folks some storage right here
extern vpSurfaces*			pMySurfaces;
//vpSurfaces			MySurfaces;

NvChannel* 			pMyNvChan = NULL;
extern NvNotification*	nvMyVPNotifiers;

#define STARTINGBUF	(99)
#define UNKNOWNBUF	(123)


// This is a hack to fix up stuff which a contradiction between the two known systems
// CODE this should be cleaned up as the NV4 style RM moves into NV3 land


BOOLEAN checkScalingOk(U032 in, U032 out ) {
	U032 xIn,yIn,xOut,yOut;
	U032	xRatio;
	/*  Scaling works like this... the output MUST be smaller than the input, and the X ratio must be an integer value
		 there is no limit on the Y ratio since it's just a line dropping system
	*/
	
	xIn  = in & 0xFFFF;
	yIn  = in >> 16;
	xOut = out & 0xFFFF;
	yOut = out >> 16;
	
	if( xIn < xOut ) {
		DPF ("   In dimension X is SMALLER than out X dimension %d, %d",xIn,xOut);
		return FALSE;
	}
	if( yIn < yOut ) {
		DPF ("   In dimension Y is SMALLER than out Y dimension %d, %d",yIn,yOut);
		return FALSE;
	}
	if( xIn % xOut != 0 ) {
		DPF ("   X dimension In does not evenly divide by X out %d, %d",xIn,xOut);
		return FALSE;
	}	
	xRatio = xIn / xOut;
	
	switch (xRatio) {
			case 1:
			case 2:
			case 3:
			case 4:
			case 6:
			case 8:
			case 12:
			case 16:
			case 24:
				break;
			default:
				{
					DPF ("   Not one of the good scale factors %d, %d, %d",xIn,xOut,xRatio);
					return FALSE;
				}			
				break;
	}
		
	return TRUE;
}


BOOL GetField(void) {
	BOOL	retvalue = TRUE;
	U032	whiletime = 0;
	FIELDTYPE aField = UNKNOWN;
	
	// we're not hitting the channel
	//INIT_FREE_COUNT(0);


	// clear the notifiers
	nvMyVPNotifiers[NV04D_NOTIFIERS_GET_IMAGE_OFFSET_NOTIFY(0)+NUM04DOFFSET].status = NV04D_NOTIFICATION_STATUS_IN_PROGRESS;
	nvMyVPNotifiers[NV04D_NOTIFIERS_GET_IMAGE_OFFSET_NOTIFY(1)+NUM04DOFFSET].status = NV04D_NOTIFICATION_STATUS_IN_PROGRESS;
		
	// put the object into the channel
#ifndef NV4
	pMyNvChan->subchannel[0].control.object = MY_EXTERNAL_DECODER_OBJECT;
#else 
	pMyNvChan->subchannel[0].SetObject = MY_EXTERNAL_DECODER_OBJECT;
#endif // NV4

	// fire off the command
#ifndef NV4_HW
	pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.GetImageOffsetNotify[0] =  NV04D_GET_IMAGE_OFFSET_NOTIFY_WRITE_ONLY;
																									
	pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.GetImageOffsetNotify[1] =  NV04D_GET_IMAGE_OFFSET_NOTIFY_WRITE_ONLY;
#else   //NV4_HW
	pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.GetImageOffsetNotify[0] =  NV04D_GET_IMAGE_OFFSET_NOTIFY_WRITE_ONLY;
	pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.GetImageOffsetNotify[1] =  NV04D_GET_IMAGE_OFFSET_NOTIFY_WRITE_ONLY;
#endif  //NV4_HW		
	
	// wait for completion

	while ( ((nvMyVPNotifiers[NV04D_NOTIFIERS_GET_IMAGE_OFFSET_NOTIFY(0)+NUM04DOFFSET].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS) ||
				 (nvMyVPNotifiers[NV04D_NOTIFIERS_GET_IMAGE_OFFSET_NOTIFY(1)+NUM04DOFFSET].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS))	&&
				(whiletime++ < WHILETIMEOUT) );
	
	// only one of these should be running right now....
	if( nvMyVPNotifiers[NV04D_NOTIFIERS_GET_IMAGE_OFFSET_NOTIFY(0)+NUM04DOFFSET].info16 == NV04D_NOTIFICATION_INFO16_FIELD_VALID_OFFSET ) {
		aField = pMySurfaces->Surfaces[pMySurfaces->CurrentBufferSurface[0]]->field;
	}
	if( nvMyVPNotifiers[NV04D_NOTIFIERS_GET_IMAGE_OFFSET_NOTIFY(1)+NUM04DOFFSET].info16 == NV04D_NOTIFICATION_INFO16_FIELD_VALID_OFFSET ) {
		aField = pMySurfaces->Surfaces[pMySurfaces->CurrentBufferSurface[1]]->field;
	}
		
	if(aField == EVEN ) {
		retvalue = TRUE;
	} else {
		retvalue = FALSE;
	}
	
	return retvalue;
}
	
U032 checkNvAllocArchError(U032 error) {
	// returns true if there IS an error
	// otherwise false
	switch (error) {
			case NVOS04_STATUS_SUCCESS:
				return 0;
//				DPF("NVOS04_STATUS_SUCCESS");
				break;
			case NVOS04_STATUS_ERROR_OPERATING_SYSTEM:
				DPF("NVOS04_STATUS_ERROR_OPERATING_SYSTEM");
				return error;
				break;
			case NVOS04_STATUS_ERROR_BAD_OBJECT_PARENT:
				DPF("NVOS04_STATUS_ERROR_BAD_OBJECT_PARENT");
				return error;
				break;
			case NVOS04_STATUS_ERROR_BAD_OBJECT_NEW:
				DPF("NVOS04_STATUS_ERROR_BAD_OBJECT_NEW");
				return error;
				break;
			case NVOS04_STATUS_ERROR_BAD_CLASS:
				DPF("NVOS04_STATUS_ERROR_BAD_CLASS");
				return error;
				break;
			case NVOS04_STATUS_ERROR_BAD_OBJECT_ERROR:
				DPF("NVOS04_STATUS_ERROR_BAD_OBJECT_ERROR");
				return error;
				break;
			case NVOS04_STATUS_ERROR_BAD_FLAGS:
				DPF("NVOS04_STATUS_ERROR_BAD_FLAGS");
				return error;
				break;
			case NVOS04_STATUS_ERROR_INSUFFICIENT_RESOURCES:
				DPF("NVOS04_STATUS_ERROR_INSUFFICIENT_RESOURCES");
				return error;
				break;
			default:
					DPF("UNKNOWN ERROR");
					return 1;
	}
	
	return 0;
}

DWORD SetupVP (LPDDHAL_CREATEVPORTDATA lpInput) {
	U032 error;
	U032 i;
	INIT_FREE_COUNT(0);
	
	pMyNvChan = pMySurfaces->pVPChanPtr;
	if(pMyNvChan == NULL ) {
		//CODE
		error = NvRmAllocChannelPio ((GLOBDATAPTR)->ROOTHANDLE, 
					NV_WIN_DEVICE, 
					MY_VPE_CHANNEL, 
#ifndef NV4
					NV03_CHANNEL_PIO, 
#else
					//NV04_CHANNEL_PIO, 
					NV03_CHANNEL_PIO,
#endif
					0, 
					(PVOID)&(pMySurfaces->pVPChanPtr), 
					ALLOC_CHL_PIO_FLAGS_FIFO_IGNORE_RUNOUT);
		if(checkNvAllocArchError(error )) {
			DPF("   Warning: Unable to sucessfully complete NvRmAllocChannelPio");
	    	return DDHAL_DRIVER_NOTHANDLED;
		}
		
		
		pMyNvChan = pMySurfaces->pVPChanPtr;
		
		// Now store a copy in global land so that the brucerator's code can kill the channel on mode switches
		GLOBDATAPTR->NvDevFlatVPE = (U032) pMySurfaces->pVPChanPtr;

	}	

	if(pMyNvChan == NULL ) {	
		DPF("   Warning: the NV Channel for VPE is not initialized... sorry");
    	return DDHAL_DRIVER_NOTHANDLED;
	} else {
	
			error = NvRmAllocObject(  (GLOBDATAPTR)->ROOTHANDLE,
	                     		MY_VPE_CHANNEL,
	                     		MY_EXTERNAL_DECODER_OBJECT,
										NV03_EXTERNAL_VIDEO_DECODER
								);
		    
			if(checkNvAllocArchError(error )) {
				DPF("NVDD: Cannot allocate External Decoder Object %d",MY_EXTERNAL_DECODER_OBJECT);
				return FALSE;
			}
						 
			error = NvRmAllocObject(  (GLOBDATAPTR)->ROOTHANDLE,
	                     		MY_VPE_CHANNEL,
	                     		MY_TIMER_OBJECT,
#ifndef NV4
										NV_TIMER
#else
										NV01_TIMER
#endif
								);
			if(checkNvAllocArchError(error )) {
				DPF("NVDD: Cannot allocate Timer Object %d",MY_TIMER_OBJECT);
				return FALSE;
			}
						
			// setup Notify Context

			if (NvRmAllocContextDma(  (GLOBDATAPTR)->ROOTHANDLE,
	                     		MY_EXTERNAL_DECODER_NOTIFIER,
	                     		NV01_CONTEXT_DMA,
	                     		(	ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR |
                        				ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
	                     		(PVOID)(((U032)nvMyVPNotifiers) + NUM04DOFFSET*sizeof(NvNotification)),
	                     		(sizeof( NvNotification)*NUM04DNOTIFIER  - 1)
	                     ) != ALLOC_CTX_DMA_STATUS_SUCCESS )
		     {
		        DPF((1, "NVDD: Cannot allocate notifier context"));
		        return FALSE;
		     }
			
			
			if (NvRmAllocContextDma(  (GLOBDATAPTR)->ROOTHANDLE,
	                     		MY_TIMER_NOTIFIER,
	                     		NV01_CONTEXT_DMA,
	                     		(	ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR |
                        				ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
	                     		(PVOID)(((U032)nvMyVPNotifiers) + NUM004OFFSET*sizeof(NvNotification)),
	                     		(sizeof( NvNotification)*NUM004NOTIFIER  - 1)
	                     ) != ALLOC_CTX_DMA_STATUS_SUCCESS )
		     {
		        DPF((1, "NVDD: Cannot allocate notifier context"));
		        return FALSE;
		     }

		
			// Plug the notifiers into the main object
			// make sure the object is on the channel
#ifndef NV4
			pMyNvChan->subchannel[0].control.object = MY_EXTERNAL_DECODER_OBJECT;
#else 
			pMyNvChan->subchannel[0].SetObject  = MY_EXTERNAL_DECODER_OBJECT;
#endif // NV4
			
			pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetContextDmaNotifies = MY_EXTERNAL_DECODER_NOTIFIER;
			

#ifndef NV4
			pMyNvChan->subchannel[0].control.object = MY_TIMER_OBJECT;
			pMyNvChan->subchannel[0].timer.SetAlarmNotifyCtxDma = MY_TIMER_NOTIFIER;
#else 
			pMyNvChan->subchannel[0].SetObject  = MY_TIMER_OBJECT;
			pMyNvChan->subchannel[0].nv01Timer.SetContextDmaNotifies = MY_TIMER_NOTIFIER;
#endif // NV4
			
			
 //**************************************************************************
 // Allocate a DMA context which points to all of video memory. The limit
 // must be page aligned: i.e. limit = (size in bytes of video mem rounded to the
 // closest page boundary) - 1.
 //**************************************************************************
		
		{
			void*  pFrameBuffer = (void*)(GLOBDATAPTR)->PBASEADDRESS;
			U032	 dwFBLen= DWFBUFFERLEN;
						
			if (NvRmAllocContextDma(	(GLOBDATAPTR)->ROOTHANDLE,
											MY_IMAGE0_BUFFER_CONTEXT,
											NV01_CONTEXT_DMA,
											(	ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR |
			               				ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
											pFrameBuffer,
			                      	dwFBLen
										) != ALLOC_CTX_DMA_STATUS_SUCCESS )
			{
			  DPF((1, "NVDD: Cannot allocate dma in memory context for MY_IMAGE0_BUFFER_CONTEXT"));
			  return FALSE;
			}
			
			 if (NvRmAllocContextDma(  (GLOBDATAPTR)->ROOTHANDLE,
											MY_IMAGE1_BUFFER_CONTEXT,
											NV01_CONTEXT_DMA,
										 	(	ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR |
			               				ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
			                      	pFrameBuffer,
			                      	dwFBLen
			                      ) != ALLOC_CTX_DMA_STATUS_SUCCESS )
			  {
			  DPF((1, "NVDD: Cannot allocate dma in memory context for MY_IMAGE1_BUFFER_CONTEXT"));
			  return FALSE;
			  }
			
			if (NvRmAllocContextDma(  (GLOBDATAPTR)->ROOTHANDLE,
			                      MY_VBI0_BUFFER_CONTEXT,
			                      NV01_CONTEXT_DMA,
										 //NV01_CONTEXT_DMA,
			                      (	ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR |
			               			ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
			                      pFrameBuffer,
			                      dwFBLen
			                      ) != ALLOC_CTX_DMA_STATUS_SUCCESS )
			{
			  DPF((1, "NVDD: Cannot allocate dma in memory context for MY_VBI0_BUFFER_CONTEXT"));
			  return FALSE;
			}
			
			if (NvRmAllocContextDma(  (GLOBDATAPTR)->ROOTHANDLE,
			                      MY_VBI1_BUFFER_CONTEXT,
			                      NV01_CONTEXT_DMA,
										 //NV01_CONTEXT_DMA,
			                      (	ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR |
			               			ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
			                      pFrameBuffer,
			                      dwFBLen
			                      ) != ALLOC_CTX_DMA_STATUS_SUCCESS )
			{
			  DPF((1, "NVDD: Cannot allocate dma in memory context for MY_VBI1_BUFFER_CONTEXT"));
			  return FALSE;
			}

		}

			
			CHECK_FREE_COUNT(pMyNvChan,10*5);
			
			// make sure decoder object is in the channel....
#ifndef NV4
			pMyNvChan->subchannel[0].control.object = MY_EXTERNAL_DECODER_OBJECT;
#else 
			pMyNvChan->subchannel[0].SetObject = MY_EXTERNAL_DECODER_OBJECT;
#endif // NV4
			// plug in our buffer contexts
			pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetContextDmaImage[0] 	= MY_IMAGE0_BUFFER_CONTEXT;
			pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetContextDmaImage[1] 	= MY_IMAGE1_BUFFER_CONTEXT;
			pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetContextDmaVbi[0] 		= MY_VBI0_BUFFER_CONTEXT;
			pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetContextDmaVbi[1] 		= MY_VBI1_BUFFER_CONTEXT;
			
		// Ok, done setting up the various contexts
		// now we should setup the class with some boring default values
			
			CHECK_FREE_COUNT(pMyNvChan,10*10);
			
			for( i = 0; i < 2; i++ ) {		
				pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetImage[i].sizeIn	 = ((240 << 16 ) | 720 );	// *The next four method may fail if the scaling values do not work out properly.
				pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetImage[i].sizeOut = ((240 << 16 ) | 720 );		// changing either In or Out values will modify the scaling values
				pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetImage[i].offset		=0;			//	*indicates DMA "address" as on offset from frame buffer base
				
				//  we don't actually want to launch any captures at this point
				
				pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetVbi[i].offset		= 0;
				pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetVbi[i].size        = 0;				
				//  we don't actually want to launch any captures at this point
			}
			
			
		// Ok, reset all the notifiers:
		
			for (i = 0; i < NUMVPNOTIFIERS ; i++ ) {
				nvMyVPNotifiers[i].status 		= NV04D_NOTIFICATION_STATUS_NOT_LAUNCHED;
				nvMyVPNotifiers[i].info32 	= 0;
				nvMyVPNotifiers[i].info32	= 0;
				nvMyVPNotifiers[i].timeStamp.nanoseconds[0]	= 0;
				nvMyVPNotifiers[i].timeStamp.nanoseconds[1]	= 0;
			}


			// this means we're going to try for kevin's new cool callback dealy
			
			/*
			 * NvAllocEvent() specifies a Windows event or callback for NV to send to the
			 * application after requesting notifications with the
			 * NV_OS_WRITE_THEN_AWAKEN style.
			 *    first parameter is the NvChannel
			 *    second is the object name
			 *    third is the notify index
			 *    fourth is the notify event type (NV_OS_EVENT_*)
			 *    fifth is the lower 32bits of the 64bit event data       
			 *    sixth is the upper 32bits of the 64bit event data
			 */

 			// first object we're going to associate will be the MY_EXTERNAL_DECODER_OBJECT
			// we want to different notifiers associated here.
			
			pMySurfaces->bThreadDead = FALSE;
			pMySurfaces->bThreadRunning = TRUE;
			
			// I want VBI/Image/ 0 / 1  all to go to the same place


#ifndef NV4
// until someone gets this define in the right header file
#define  NV01_EVENT_KERNEL_CALLBACK                                (0x00000078)
#endif  // nv4

			{
				U032 status = 0;

				status = NvRmAllocEvent	(	(GLOBDATAPTR)->ROOTHANDLE,
	 									MY_EXTERNAL_DECODER_OBJECT,
	                      		MY_VBI0_BUFFER_EVENT,
	                      		NV01_EVENT_KERNEL_CALLBACK,
										NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(0),
										(void*)pMySurfaces->pNotifyCallbackProcV0);		    
							
				if( status !=  0x0 /* meaning sucess */ ) {
					DPF("Bad status returned from nvRmAllocEvent. status = %d",status);
				} 
				
				status = NvRmAllocEvent	(	(GLOBDATAPTR)->ROOTHANDLE,
	 									MY_EXTERNAL_DECODER_OBJECT,
	                      		MY_VBI1_BUFFER_EVENT,
	                      		NV01_EVENT_KERNEL_CALLBACK,
										NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(1),
										(void*)pMySurfaces->pNotifyCallbackProcV1);
			   if( status !=  0x0 /* meaning sucess */ ) {
					DPF("Bad status returned from nvRmAllocEvent. status = %d",status);
				} 
				status = NvRmAllocEvent	(	(GLOBDATAPTR)->ROOTHANDLE,
	 									MY_EXTERNAL_DECODER_OBJECT,
	                      		MY_IMAGE0_BUFFER_EVENT,
	                      		NV01_EVENT_KERNEL_CALLBACK,
										NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(0),
										(void*)pMySurfaces->pNotifyCallbackProcI0);
			   if( status !=  0x0 /* meaning sucess */ ) {
					DPF("Bad status returned from nvRmAllocEvent. status = %d",status);
				} 
				status = NvRmAllocEvent	(	(GLOBDATAPTR)->ROOTHANDLE,
	 									MY_EXTERNAL_DECODER_OBJECT,
	                      		MY_IMAGE1_BUFFER_EVENT,
	                      		NV01_EVENT_KERNEL_CALLBACK,
										NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(1),
										(void*)pMySurfaces->pNotifyCallbackProcI1);
			   if( status !=  0x0 /* meaning sucess */ ) {
					DPF("Bad status returned from nvRmAllocEvent. status = %d",status);
				} 
				 
				 // And finally one for the timer
#ifndef NV4
#define NV004_NOTIFIERS_SET_ALARM_NOTIFY                           (1)
#endif				 
				 status = NvRmAllocEvent	(	(GLOBDATAPTR)->ROOTHANDLE,
	 									MY_TIMER_OBJECT,
	                      		MY_TIMER_EVENT,
	                      		NV01_EVENT_KERNEL_CALLBACK,
										NV004_NOTIFIERS_SET_ALARM_NOTIFY,
										(void*)pMySurfaces->pTimerNotifyProc);
			   if( status !=  0x0 /* meaning sucess */ ) {
					DPF("Bad status returned from nvRmAllocEvent. status = %d",status);
				} 
				            		
			}	// event alloc block									 
			

			

		// Decrement the number of ports available count
			(pMySurfaces->pDriverData)->dwVideoPortsAvailable--;
			

	}

	// this sets up the structures for ring0 data transfers
	SetupMTM();
#ifdef NV4
	initTextureSurf();
#endif
	
	pMySurfaces->SetupComplete = TRUE;
	return DDHAL_DRIVER_HANDLED;
}

	
void 	tearDownVP(void) {
	U032	error;
	U032	i;
	U032	whiletime;
	INIT_FREE_COUNT(0);
	
	// stop things from running  ( check to make sure the channel is not null by which we'll assume
	//   that things are not running
	// tell the thread to exit
	pMySurfaces->bThreadRunning = FALSE;
	
	if(pMyNvChan != NULL)
		StopVP();
		
#ifdef NV4
	DestroyTextureSurf();
#endif

	TearDownMTM();
	
	// this should wake up the thread
//	SetEvent( pMySurfaces->hVPInterruptEvent );	

	// wait for it to die
	whiletime = 0;
	while( (!pMySurfaces->bThreadDead) &
			(whiletime++ < WHILETIMEOUT) );
	// make sure that the thread has really exited
	//TerminateThread((HANDLE)pMySurfaces->VpInterruptId,0);
	
	

	
	if(pMyNvChan != NULL ) {
		CHECK_FREE_COUNT(pMyNvChan,12*4);
					
		// stop the transfers	
#ifndef NV4
		pMyNvChan->subchannel[0].control.object = MY_EXTERNAL_DECODER_OBJECT;
#else 
		pMyNvChan->subchannel[0].SetObject  = MY_EXTERNAL_DECODER_OBJECT;
#endif // NV4
		
		pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.StopTransferImage   = 0;
		pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.StopTransferVbi = 0;
	
	
	}
	
	
#ifdef NOEVENTFREEFUNCTIONYETFOLKS	
	DPF("Now ditching the EVENTs ");
	
	error = NvRmFree((GLOBDATAPTR)->ROOTHANDLE, MY_EXTERNAL_DECODER_OBJECT, MY_IMAGE0_BUFFER_EVENT);
   checkNvAllocArchError(error);
	error = NvRmFree((GLOBDATAPTR)->ROOTHANDLE, MY_EXTERNAL_DECODER_OBJECT, MY_IMAGE1_BUFFER_EVENT);
   checkNvAllocArchError(error);
	error = NvRmFree((GLOBDATAPTR)->ROOTHANDLE, MY_EXTERNAL_DECODER_OBJECT, MY_VBI0_BUFFER_EVENT);
   checkNvAllocArchError(error);
	error = NvRmFree((GLOBDATAPTR)->ROOTHANDLE, MY_EXTERNAL_DECODER_OBJECT, MY_VBI1_BUFFER_EVENT);
   checkNvAllocArchError(error);
	error = NvRmFree((GLOBDATAPTR)->ROOTHANDLE, MY_TIMER_OBJECT, MY_TIMER_EVENT);
	checkNvAllocArchError(error);
	
#endif  

	DPF("Now setting notifiers to NULL");
	if(pMyNvChan != NULL ) {
	
// set notifiers to NULL context DMAs
#ifndef NV4
		pMyNvChan->subchannel[0].control.object = MY_EXTERNAL_DECODER_OBJECT;
#else 
		pMyNvChan->subchannel[0].SetObject  = MY_EXTERNAL_DECODER_OBJECT;
#endif // NV4
		
		pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetContextDmaNotifies = 0;
		

#ifndef NV4
		pMyNvChan->subchannel[0].control.object = MY_TIMER_OBJECT;
		pMyNvChan->subchannel[0].timer.SetAlarmNotifyCtxDma = 0;
#else 
		pMyNvChan->subchannel[0].SetObject  = MY_TIMER_OBJECT;
		pMyNvChan->subchannel[0].nv01Timer.SetContextDmaNotifies = 0;
#endif // NV4

// set DMA for transfers to NULL

#ifndef NV4
		pMyNvChan->subchannel[0].control.object = MY_EXTERNAL_DECODER_OBJECT;
#else 
		pMyNvChan->subchannel[0].SetObject = MY_EXTERNAL_DECODER_OBJECT;
#endif // NV4

		pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetContextDmaImage[0] 	= 0;
		pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetContextDmaImage[1] 	= 0;
		pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetContextDmaVbi[0] 		= 0;
		pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetContextDmaVbi[1] 		= 0;

	


	// spin waiting for empty fifo
#ifdef NV4
		while(NvGetFreeCount(pMyNvChan, 0) < NV06A_FIFO_GUARANTEED_SIZE );
#else
		while(NvGetFreeCount(pMyNvChan, 0) < NV_GUARANTEED_FIFO_SIZE );
#endif
	
	}
//  I'm a bit concerned about syncing the FIFO with these NVRM API calls. but we'll let this slide for now
 
	DPF("Now ditching the Notifiers");
	error = NvRmFree((GLOBDATAPTR)->ROOTHANDLE, (GLOBDATAPTR)->ROOTHANDLE, MY_EXTERNAL_DECODER_NOTIFIER);
	checkNvAllocArchError(error);
	error = NvRmFree((GLOBDATAPTR)->ROOTHANDLE, (GLOBDATAPTR)->ROOTHANDLE, MY_TIMER_NOTIFIER);
	checkNvAllocArchError(error);



	DPF("Now ditching the Buffer contexts");
	error = NvRmFree((GLOBDATAPTR)->ROOTHANDLE, (GLOBDATAPTR)->ROOTHANDLE, MY_IMAGE0_BUFFER_CONTEXT);
	if(checkNvAllocArchError(error)) {
		DPF("that was trouble freeing MY_IMAGE0_BUFFER_CONTEXT");
	}
	error = NvRmFree((GLOBDATAPTR)->ROOTHANDLE, (GLOBDATAPTR)->ROOTHANDLE, MY_IMAGE1_BUFFER_CONTEXT);
	if(checkNvAllocArchError(error)) {
		DPF("that was trouble freeing MY_IMAGE1_BUFFER_CONTEXT");
	}
	error = NvRmFree((GLOBDATAPTR)->ROOTHANDLE, (GLOBDATAPTR)->ROOTHANDLE, MY_VBI0_BUFFER_CONTEXT);
	if(checkNvAllocArchError(error)) {
		DPF("that was trouble freeing MY_VBI0_BUFFER_CONTEXT");
	}
	error = NvRmFree((GLOBDATAPTR)->ROOTHANDLE, (GLOBDATAPTR)->ROOTHANDLE, MY_VBI1_BUFFER_CONTEXT);
	if(checkNvAllocArchError(error)) {
		DPF("that was trouble freeing MY_VBI1_BUFFER_CONTEXT");
	}
	


	
	error = NvRmFree((GLOBDATAPTR)->ROOTHANDLE, MY_VPE_CHANNEL, MY_TIMER_OBJECT);
	if(checkNvAllocArchError(error)) {
		DPF("that was trouble freeing MY_TIMER_OBJECT");
	}
	error = NvRmFree((GLOBDATAPTR)->ROOTHANDLE, MY_VPE_CHANNEL, MY_EXTERNAL_DECODER_OBJECT);

	if(checkNvAllocArchError(error)) {
		DPF("that was trouble freeing MY_EXTERNAL_DECODER_OBJECT");
	}
	

	
// increment the number of ports available
	(pMySurfaces->pDriverData)->dwVideoPortsAvailable++;
// shut down Media Port channel

	pMyNvChan = pMySurfaces->pVPChanPtr;
	{
		ULONG status;
		
		status = NvRmFree((GLOBDATAPTR)->ROOTHANDLE,
								 NV_WIN_DEVICE, 
								 MY_VPE_CHANNEL);
		
		if( status == 0x0) {
			pMyNvChan = NULL;
			pMySurfaces->pVPChanPtr = NULL;
		} else {
			DPF("Uh Dude,  I couldn't deallocate the channel pointer... ");
		
		}	
	}


	(pMySurfaces->pDriverData)->NvDevFlatVPE = (DWORD) NULL;	
	pMyNvChan = NULL;
	
	// Ok, reset all the notifiers:
	
//	CloseHandle(pMySurfaces->hThreadHandle);
	for (i = 0; i < NUMVPNOTIFIERS ; i++ ) {
		nvMyVPNotifiers[i].status 		= NV04D_NOTIFICATION_STATUS_NOT_LAUNCHED;
		nvMyVPNotifiers[i].info32 	= 0;
		nvMyVPNotifiers[i].info32	= 0;
		nvMyVPNotifiers[i].timeStamp.nanoseconds[0]	= 0;
		nvMyVPNotifiers[i].timeStamp.nanoseconds[1]	= 0;
	}
	pMySurfaces->SetupComplete = FALSE;
	
}


void StopVP(void) {
	U032	whiletime;
	
	INIT_FREE_COUNT(0);
	
#ifndef NV4
		NV_DD_DMA_PUSHER_SYNC();
#endif //NV4		

	CHECK_FREE_COUNT(pMyNvChan,8);
	

#ifndef NV4
	pMyNvChan->subchannel[0].control.object = MY_EXTERNAL_DECODER_OBJECT;
#else 
	pMyNvChan->subchannel[0].SetObject  = MY_EXTERNAL_DECODER_OBJECT;
#endif // NV4
	DPF ("   Firing Off Stop commands");

	pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.StopTransferImage   = 0;
	pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.StopTransferVbi = 0;

// wait for the last few notifies to show up ?		
	
	pMySurfaces->bStopVP = TRUE;
	
	whiletime = 0;
	while ( ((nvMyVPNotifiers[NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(0)].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS) ||
				 (nvMyVPNotifiers[NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(1)].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS))	&&
				(whiletime++ < WHILETIMEOUT) );

// CODE wait for VBI notifies.. too
//	while (nvMyVPNotifiers[NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(0)].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS);
//	while (nvMyVPNotifiers[NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(1)].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS);
	DPF ("   Done waiting for stops");

	// one more time to make sure those register get cleared	
	pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.StopTransferImage   = 0;
	pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.StopTransferVbi = 0;
    	
}	

DWORD getCurLine(void) {
	U032	whiletime;
  	U032	possibleOffset = 0;
	U032	line;
	U032	returnLine;
	INIT_FREE_COUNT(0);
	
	nvMyVPNotifiers[NV04D_NOTIFIERS_GET_IMAGE_OFFSET_NOTIFY(0)].status = NV04D_NOTIFICATION_STATUS_IN_PROGRESS;
	nvMyVPNotifiers[NV04D_NOTIFIERS_GET_IMAGE_OFFSET_NOTIFY(1)].status = NV04D_NOTIFICATION_STATUS_IN_PROGRESS;
	
	returnLine = 0;

	// Put decoder object into the channel
	CHECK_FREE_COUNT(pMyNvChan,1*4);
#ifndef NV4
	pMyNvChan->subchannel[0].control.object = MY_EXTERNAL_DECODER_OBJECT;
#else 
	pMyNvChan->subchannel[0].SetObject = MY_EXTERNAL_DECODER_OBJECT;
#endif // NV4


	CHECK_FREE_COUNT(pMyNvChan,8);
	
	pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.GetImageOffsetNotify[0]		= 0;			// *allows programming of either ODD or EVEN fields
	pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.GetImageOffsetNotify[1]		= 0;			// *allows programming of either ODD or EVEN fields

//CODE   there may still be in issue with divide by ZERO here.. I can't imagine pitch = 0.. but you never know...

	whiletime = 0;

	while ( ((nvMyVPNotifiers[NV04D_NOTIFIERS_GET_IMAGE_OFFSET_NOTIFY(0)].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS) ||
				 (nvMyVPNotifiers[NV04D_NOTIFIERS_GET_IMAGE_OFFSET_NOTIFY(1)].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS))	&&
				(whiletime++ < WHILETIMEOUT) );


	if(nvMyVPNotifiers[NV04D_NOTIFIERS_GET_IMAGE_OFFSET_NOTIFY(0)].info32 == NV04D_NOTIFICATION_INFO16_FIELD_VALID_OFFSET ) {
		possibleOffset = nvMyVPNotifiers[NV04D_NOTIFIERS_GET_IMAGE_OFFSET_NOTIFY(0)].info32;
		line = possibleOffset - pMySurfaces->Surfaces[pMySurfaces->CurrentBufferSurface[0]]->dwOffset;
		returnLine = line / pMySurfaces->Surfaces[pMySurfaces->CurrentBufferSurface[0]]->dwPitch;
	}
	if(nvMyVPNotifiers[NV04D_NOTIFIERS_GET_IMAGE_OFFSET_NOTIFY(1)].info32 == NV04D_NOTIFICATION_INFO16_FIELD_VALID_OFFSET ) {
		possibleOffset = nvMyVPNotifiers[NV04D_NOTIFIERS_GET_IMAGE_OFFSET_NOTIFY(1)].info32;
		line = possibleOffset - pMySurfaces->Surfaces[pMySurfaces->CurrentBufferSurface[1]]->dwOffset;
		returnLine = line / pMySurfaces->Surfaces[pMySurfaces->CurrentBufferSurface[1]]->dwPitch;
	}
	
	return returnLine;
}
	
U032	notifyIndexFromBuffer(U032 dwBuffer) {
	switch (dwBuffer) {
			case 0:
				return NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(0);
				break;
			case 1:
				return NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(1);
				break;
			case 2:
				return NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(0);
				break;
			case 3:
				return NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(1);
				break;
			default:
				{
					DPF ("   Problem... trying get an index for an unknown buffer notify");
					return UNKNOWNBUF;
				}
	}
}


VPERRORS replaceSurfaceList(DWORD dwNumAutoflip,DWORD dwNumVBIAutoflip,
										LPDDRAWI_DDRAWSURFACE_INT   *lplpDDSurface,
										LPDDRAWI_DDRAWSURFACE_INT   *lplpDDVBISurface,
										U032 bAutoflip ) {
	VPERRORS	localError = NOVPERROR;
	U032 	imageSurfCount = 0;
	U032	VBISurfCount = 0;
	U032	i;
	U032	next;
	
	pMySurfaces->surfMemAllocCount = 0;
	
	ASSERT(!((lplpDDSurface 		!= NULL) ^ (dwNumAutoflip > 0)));
	ASSERT(!((lplpDDVBISurface 	!= NULL) ^ (dwNumVBIAutoflip > 0)));

	DPF ("   We have #Image=%d  #VB=%d autoflip surfaces",dwNumAutoflip,dwNumVBIAutoflip);
					
	localError = clearAllSurfaces();
	if( localError != NOVPERROR ) {
		return localError;
	}
	
	imageSurfCount = 0;
	
	if(lplpDDSurface != NULL) {
		// first count the surfaces
		imageSurfCount = 0;
		while(lplpDDSurface[imageSurfCount] != NULL ) {
			imageSurfCount++;
		}
		if(bAutoflip) {
			if(imageSurfCount > dwNumAutoflip ) {
				DPF("More in list than are autoflip!");
				imageSurfCount = dwNumAutoflip;
			}
		}
		// next add the surfaces to the list	
		i = 0;
		while((lplpDDSurface[i] != NULL ) && (i <imageSurfCount) ) {
			next = i + 1;
			if( next == imageSurfCount ) 
				next = 0;
			localError = addSurface(createSurface(lplpDDSurface[i], bAutoflip, FALSE, NULL,next));	
			i=i+1;
		}
		
		DPF("Added %d Image surfaces",imageSurfCount);
	}
	pMySurfaces->VBIstart = imageSurfCount;
	
	if(lplpDDVBISurface!=NULL ) {
		// now count VBI surfaces
		VBISurfCount = 0;
		while(lplpDDVBISurface[VBISurfCount] != NULL ) {
			VBISurfCount++;
		}
		if(bAutoflip) {
			if(VBISurfCount > dwNumVBIAutoflip ) {
				DPF("More in VBI list than are autoflip!");
				VBISurfCount = dwNumVBIAutoflip;
			}
		}
		// next add the surfaces to the list	
		i = 0;
		// All the VBI surfaces are offset by a certain amount
		while((lplpDDVBISurface[i] != NULL ) && (i <VBISurfCount) ) {
			next = i + 1;
			if( next == VBISurfCount ) 
				next = 0;
			localError = addSurface(createSurface(lplpDDVBISurface[i], bAutoflip, TRUE, NULL,next+pMySurfaces->VBIstart));	
			i=i+1;
		}
		DPF("Added %d VBI surfaces",VBISurfCount);
	}
	
	
	pMySurfaces->CurrentBufferSurface[0] = NOSURFACEPROGRAMED;
	pMySurfaces->CurrentBufferSurface[1] = NOSURFACEPROGRAMED;
	pMySurfaces->CurrentBufferSurface[2] = NOSURFACEPROGRAMED;
	pMySurfaces->CurrentBufferSurface[3] = NOSURFACEPROGRAMED;
	
	if( localError == NOVPERROR ) {
		DPF ("   Replaced surfaces - OK");
	} else {
		switch (localError) {
				case 	TOOMANYSURFACESERROR:
					DPF ("   Replaced surfaces - TOOMANYSURFACESERROR");
					break;
				case CANTCREATESURFACE:
					DPF ("   Replaced surfaces - CANTCREATESURFACE");
					break;
				case SURFACENOTFOUND:
					DPF ("   Replaced surfaces - SURFACENOTFOUND");
					break;
				case NOSURFACEPROGRAMED:
					DPF ("   Replaced surfaces - NOSURFACEPROGRAMED");
					break;
		}
		
		DPF ("   Replaced surfaces there was a problem = %d",localError);
	}

#if 0
#ifdef DEBUG	
	DPF("Now checking the surface thingie");
	{	
		U032	i;
		for(i=0;i<pMySurfaces->numberOfSurfaces;i++) {
			DPF("#Surfaces = %d surface = %d, nextSurface = %d, prevSurcace = %d",pMySurfaces->numberOfSurfaces,i,getNextSurface(i),getPrevSurface(i));
		}
	}
	
	DPF("done checking");
	
#endif

#endif
	return localError;
}


VPERRORS	addSurface(vpSurfaceInfo*	pNewSurface) {
	ASSERT(pNewSurface 	!= NULL);

	if(pMySurfaces->numberOfSurfaces >= MAXVPSURFACES ) {
		return	TOOMANYSURFACESERROR;
	}	
	if( pNewSurface == NULL) {
		return CANTCREATESURFACE;
	}
	
	pMySurfaces->Surfaces[pMySurfaces->numberOfSurfaces] = pNewSurface;
	pMySurfaces->numberOfSurfaces++;
		
	return NOVPERROR;
}

vpSurfaceInfo* createSurface(LPDDRAWI_DDRAWSURFACE_INT pNewSurface, U032 bAutoflip, 
										U032 bVBI, NvNotification* pToNotify,U032 nextSurface) {
	
	
	vpSurfaceInfo*		pSurface;
	U032 Delta;

	ASSERT( pNewSurface != NULL);
	// unlikely to ever be not NULL
	//ASSERT( pToNotify != NULL);
	ASSERT( nextSurface < MAXVPSURFACES);

	pSurface = &pMySurfaces->surfMemory[pMySurfaces->surfMemAllocCount];
	pMySurfaces->surfMemAllocCount++;
	
	pSurface->surfHandle = pNewSurface;
	pSurface->bAutoFlip = bAutoflip;	
	pSurface->pVidMem = pNewSurface->lpLcl->lpGbl->fpVidMem;
	pSurface->ddsCaps = pNewSurface->lpLcl->ddsCaps.dwCaps;
	pSurface->nextSurfaceNum = nextSurface;
	// store the offset of the intermediate hidden surface
	pSurface->dwRes1 = pNewSurface->lpLcl->lpGbl->dwReserved1;
//
	
	pSurface->dwPitch = pNewSurface->lpLcl->lpGbl->lPitch;

	
	
	// move things around in the surface
	Delta = pMySurfaces->dwOriginX*2 + pMySurfaces->dwOriginY*pSurface->dwPitch;
	
	pSurface->dwOffset = (unsigned long) pSurface->pVidMem 
					- (unsigned long)(pMySurfaces->pDriverData)->BaseAddress
					+ Delta;
	
	
	if(bVBI) {
		pSurface->dwStartLine = pMySurfaces->dwVBIStartLine;
	} else {
		if( pMySurfaces->CurrentScanMode == INTERLEAVBUF) {
				// both field have bigger pitch
				pSurface->dwPitch = pNewSurface->lpLcl->lpGbl->lPitch * 2;
			}
	
	
	
		//if( pMySurfaces->dwImageStartLine < 6 )
		//	pSurface->dwStartLine = 6;
		//else 
			if(pMySurfaces->dwImageStartLine == 1) {
				pSurface->dwStartLine = 16;	//tried 17 no much- 15 can see stuff on top of intercast disk - 16?
			} else {
				pSurface->dwStartLine = pMySurfaces->dwImageStartLine;
			}
	}	

#define VIDEOEXTRALEN (0)
	// make sure we're not trying to cram something into a surface that's too small
	if(bVBI ) {
		pSurface->dwHeight = pMySurfaces->dwVBIHeight;
	} else {
		if ( pMySurfaces->dwInHeight > pNewSurface->lpLcl->lpGbl->wHeight ) {
			pSurface->dwHeight = pNewSurface->lpLcl->lpGbl->wHeight + VIDEOEXTRALEN;
		} else {
			pSurface->dwHeight = pMySurfaces->dwInHeight + VIDEOEXTRALEN;
		}
	}
	if ( pMySurfaces->dwInWidth > pNewSurface->lpLcl->lpGbl->wWidth ) {
		pSurface->dwWidth = pNewSurface->lpLcl->lpGbl->wWidth;
	} else {
		pSurface->dwWidth = pMySurfaces->dwInWidth;
	}
	
	pSurface->dwPreScaleSize =  (pMySurfaces->dwPreWidth) | ((pMySurfaces->dwPreHeight+VIDEOEXTRALEN) << 16);
			// we know that there are TWO bytes per pixel in UYVY format
	//pSurface->dwLength = pNewSurface->lpLcl->lpGbl->lPitch * ((U032)pNewSurface->lpLcl->lpGbl->wHeight) * 2;
	pSurface->dwLength = pSurface->dwPitch * (((U032)pSurface->dwHeight) ) * 2;

	return pSurface;
}


VPERRORS replaceSurfaceWithSurface(U032 surfaceToReplace, LPDDRAWI_DDRAWSURFACE_LCL pNewSurface, U032  bVBI) {

	vpSurfaceInfo*		pSurface;
	U032 					Delta;

	ASSERT( pNewSurface != NULL);

	pSurface = pMySurfaces->Surfaces[surfaceToReplace];
// not sure if this is necessary or not....
//	pSurface->pNvNotify = &(nvMyVPNotifiers[notifyIndexFromBuffer(0)]);
	
	pSurface->surfHandle = pNewSurface;
	// pSurface->bAutoFlip = bAutoflip;	// leave this the same!
	pSurface->pVidMem = pNewSurface->lpGbl->fpVidMem;
	pSurface->ddsCaps = pNewSurface->ddsCaps.dwCaps;
	// pSurface->nextSurfaceNum = nextSurface;		// leave this the same!
	
	pSurface->dwPitch = pNewSurface->lpGbl->lPitch;

	// move things around in the surface
	Delta = pMySurfaces->dwOriginX*2 + pMySurfaces->dwOriginY*pSurface->dwPitch;
	
	pSurface->dwOffset = (unsigned long) pSurface->pVidMem 
					- (unsigned long)(pMySurfaces->pDriverData)->BaseAddress
					+ Delta;
	
	if( pMySurfaces->CurrentScanMode == INTERLEAVBUF) {
		// both field have bigger pitch
		pSurface->dwPitch = pNewSurface->lpGbl->lPitch * 2;
	}
	
	if(bVBI) {
		pSurface->dwStartLine = pMySurfaces->dwVBIStartLine;
	} else {
		//if( pMySurfaces->dwImageStartLine < 6 )
		//	pSurface->dwStartLine = 6;
		//else 
			if(pMySurfaces->dwImageStartLine == 1) {
				pSurface->dwStartLine = 16;	//tried 17 no much- 15 can see stuff on top of intercast disk - 16?
			} else {
				pSurface->dwStartLine = pMySurfaces->dwImageStartLine;
			}
	}	

#define VIDEOEXTRALEN (0)
	// make sure we're not trying to cram something into a surface that's too small
	if(bVBI ) {
		pSurface->dwHeight = pMySurfaces->dwVBIHeight;
	} else {
		if ( pMySurfaces->dwInHeight > pNewSurface->lpGbl->wHeight ) {
			pSurface->dwHeight = pNewSurface->lpGbl->wHeight + VIDEOEXTRALEN;
		} else {
			pSurface->dwHeight = pMySurfaces->dwInHeight + VIDEOEXTRALEN;
		}
	}
	if ( pMySurfaces->dwInWidth > pNewSurface->lpGbl->wWidth ) {
		pSurface->dwWidth = pNewSurface->lpGbl->wWidth;
	} else {
		pSurface->dwWidth = pMySurfaces->dwInWidth;
	}
	
	pSurface->dwPreScaleSize =  (pMySurfaces->dwPreWidth) | ((pMySurfaces->dwPreHeight+VIDEOEXTRALEN) << 16);
			// we know that there are TWO bytes per pixel in UYVY format
	//pSurface->dwLength = pNewSurface->lpGbl->lPitch * ((U032)pNewSurface->lpGbl->wHeight) * 2;
	pSurface->dwLength = pSurface->dwPitch * (((U032)pSurface->dwHeight) ) * 2;

	return NOVPERROR;

}

VPERRORS clearAllSurfaces() {
	U032	i;
	
	for (i=0;i<pMySurfaces->numberOfSurfaces; i++ ) {
		pMySurfaces->Surfaces[i] = NULL;
	}
	
	pMySurfaces->surfMemAllocCount = 0;
	pMySurfaces->numberOfSurfaces = 0;
	
	return NOVPERROR;
}

U032	findSurface(LPDDRAWI_DDRAWSURFACE_LCL pNewSurface ) {
	U032	i;
	
	for(i = 0 ; i < pMySurfaces->numberOfSurfaces; i ++ ) {
		if( pNewSurface->lpGbl->fpVidMem == pMySurfaces->Surfaces[i]->pVidMem ) {
			// Ok, we found the surface!
			return i;
		}
	
	}
	
	return SURFACENOTFOUND;
}

#if 0

FIELDTYPE	getNextFieldType(FIELDTYPE lastFieldType) {

	switch (pMySurfaces->CurrentCaptureMode) {
			case EVENODD:
				if(lastFieldType ==EVEN ) {
					return ODD;
				} else if( lastFieldType ==ODD ) {
					return EVEN;
				} else {
					return EVEN;
				}
				break;
			case EVENEVEN:
				if(lastFieldType ==EVEN ) {
					return EVEN;
				} else {
					return EVEN;
				}	
				break;
			case ODDODD:
				if(lastFieldType ==ODD ) {
					return ODD;
				} else {
					return ODD;
				}	
				break;
			default:
				ASSERT(pMySurfaces->CurrentCaptureMode == ODDODD );
	}
}



U032	ProgramBufferWithSurface(U032	dwBufferIndex,U032	newSurfaceIndex, U032 bZeroLength) {
	// This function is responsible for programming up and then launching buffer/surface combination
	// This will finish Asyncronously, and either be relaunched in the case of auto-flip, or be able 
	// to report back usefully with the VPE functions
	U032	nextField;
	U032	dwInterleaveAddition;
	INIT_FREE_COUNT(0);
	
	ASSERT(dwBufferIndex < 4 );
	ASSERT(newSurfaceIndex < MAXVPSURFACES );
	//Update the surface structures
		// notify

	
	pMySurfaces->Surfaces[newSurfaceIndex]->pNvNotify = &(nvMyVPNotifiers[notifyIndexFromBuffer(dwBufferIndex)]);
	pMySurfaces->CurrentBufferSurface[dwBufferIndex] = newSurfaceIndex;	
	
	
	// Figure out the whole field thing
	nextField = getNextFieldType(pMySurfaces->lastField);
	pMySurfaces->Surfaces[newSurfaceIndex]->field = nextField;
	pMySurfaces->lastField = nextField;
	pMySurfaces->curSurf = newSurfaceIndex;

#define PRINTPROGRAM
#ifdef PRINTPROGRAM		
	DPF("   ProgramBufferWithSurface");
	DPF("           dwBufferIndex = %d",dwBufferIndex);
	DPF("         newSurfaceIndex = %d",newSurfaceIndex);
	DPF("             bZeroLength = %d",bZeroLength);
	switch (nextField) {
			case ODD:
				 DPF("                   field = ODD");
				break;
			case EVEN:
				 DPF("                   field = EVEN");
				break;
			case UNKNOWN:
				 DPF("                   field = UNKNOWN");
				break;
	}
#endif //PRINTPROGRAM

	// if we're interleaving AND we're on the EVEN field then move everything down a bit
	//   OOD field is on top
	if(( pMySurfaces->CurrentScanMode == INTERLEAVBUF) && (nextField == EVEN ) ) {
		dwInterleaveAddition = pMySurfaces->Surfaces[newSurfaceIndex]->dwPitch/2;
	} else {
		dwInterleaveAddition = 0;
	}
	// choose which type of surface this is
	if( dwBufferIndex <2 ) {
		// Image surface
	 	// setup the field polarity, offset and fire it off
		

		// Put decoder object into the channel
		CHECK_FREE_COUNT(pMyNvChan,1*4);
#ifndef NV4
		pMyNvChan->subchannel[0].control.object = MY_EXTERNAL_DECODER_OBJECT;
#else 
		pMyNvChan->subchannel[0].SetObject = MY_EXTERNAL_DECODER_OBJECT;
#endif // NV4
	
		// for now use the same "in" as "out"
		
		CHECK_FREE_COUNT(pMyNvChan,5*4);
		
		pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetImageStartLine = 
			pMySurfaces->Surfaces[newSurfaceIndex]->dwStartLine;
		
// check for invalid scaling combo's	
		
		// if prescale is not on 2:1 integer boundaries from output, then fail...
		{
			BOOL bScale = checkScalingOk((pMySurfaces->Surfaces[newSurfaceIndex]->dwWidth) | 
													(pMySurfaces->Surfaces[newSurfaceIndex]->dwHeight << 16)
							,pMySurfaces->Surfaces[newSurfaceIndex]->dwPreScaleSize);
			
			if(! bScale ) {
				DPF("   Invalid Scaling parameters in use...");
	
				return (-7);		
			}
		}

		pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetImage[dwBufferIndex].sizeIn =
			(pMySurfaces->dwInWidth) | (pMySurfaces->dwInHeight << 16);

		if( bZeroLength ) {
			pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetImage[dwBufferIndex].sizeOut = 0;
		} else {
			pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetImage[dwBufferIndex].sizeOut = 
				pMySurfaces->Surfaces[newSurfaceIndex]->dwPreScaleSize;		
		}

#ifdef PRINTPROGRAM	
		DPF("                  offset = %x",pMySurfaces->Surfaces[newSurfaceIndex]->dwOffset + dwInterleaveAddition);
		DPF("                  pitch  = %x",pMySurfaces->Surfaces[newSurfaceIndex]->dwPitch);
#endif //PRINTPROGRAM	
		pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetImage[dwBufferIndex].offset	=
				pMySurfaces->Surfaces[newSurfaceIndex]->dwOffset + dwInterleaveAddition;
		
		// There is some sly behavior in the field statement...
		// since progressive fields are expected to be delivered in the EVEN fields we only check for OOD
		// and then everything else is considered to be even
		nvMyVPNotifiers[notifyIndexFromBuffer(dwBufferIndex)].status = NV04D_NOTIFICATION_STATUS_IN_PROGRESS;
		pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetImage[dwBufferIndex].format =		
				( pMySurfaces->Surfaces[newSurfaceIndex]->dwPitch & 0xFFFF )  |
				((( ( nextField == ODD ) ? NV04D_SET_IMAGE_FORMAT_FIELD_ODD_FIELD : NV04D_SET_IMAGE_FORMAT_FIELD_EVEN_FIELD) << 16 ) & 0xFF0000 )  |
				((NV_OS_WRITE_THEN_AWAKEN << 24 ) & 0xFF000000 ) ;
		
				
	} else {
		CHECK_FREE_COUNT(pMyNvChan,3*4);
		
		// VBI surface	
		pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetVbi[dwBufferIndex-2].size	=
			(pMySurfaces->Surfaces[newSurfaceIndex]->dwHeight << 16) | (pMySurfaces->Surfaces[newSurfaceIndex]->dwStartLine) ;
		
		pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetVbi[dwBufferIndex-2].offset	=
			pMySurfaces->Surfaces[newSurfaceIndex]->dwOffset;
		
		nvMyVPNotifiers[notifyIndexFromBuffer(dwBufferIndex)].status = NV04D_NOTIFICATION_STATUS_IN_PROGRESS;
		pMyNvChan->subchannel[0].nv03ExternalVideoDecoder.SetVbi[dwBufferIndex-2].format =		
			( pMySurfaces->Surfaces[newSurfaceIndex]->dwPitch & 0xFFFF )  |
			((( ( nextField == ODD ) ? NV04D_SET_IMAGE_FORMAT_FIELD_ODD_FIELD : NV04D_SET_IMAGE_FORMAT_FIELD_EVEN_FIELD) << 16 ) & 0xFF0000 )  |
			((NV_OS_WRITE_THEN_AWAKEN << 24 ) & 0xFF000000 ) ;
		
	}
	//Update the Capture Class
	
	return 0;
}


DWORD WINAPI VPInterruptThread(PVOID daParameter) {

	DWORD		waitReturnValue;
	HANDLE	myEvent = (HANDLE) daParameter;

	ASSERT(myEvent != NULL);
	
	DPF ("   |||||||| Thread Started");
				
	while(pMySurfaces->bThreadRunning) {
		// sit and wait... 
		// we'll wake up on the event which can be triggered EITHER by the RM 
		// OR by our parent telling us to wake up and then exit
		waitReturnValue = WaitForSingleObject(myEvent,INFINITE);   
		if( pMySurfaces->bThreadRunning ) {
			if(waitReturnValue == WAIT_OBJECT_0 ) {
				//DPF ("   interrupt");
				//HandleBufferInterrupt();
				if( pMySurfaces->myTable.handleBufferInterrupts != NULL ) {
						U032 retval = (pMySurfaces->myTable.handleBufferInterrupts)();
						if(retval != 0) 
							DPF("FUCKUP!!!!!!!!!   this is ab ad thing    what sometimes this is bad = %8x",retval);
					} else {
						ASSERT(1==0);
						// massive failure... hang out here for a while
					}
			}	
		}
	}		

	DPF ("   |||||||| Thread Ending");

	pMySurfaces->bThreadDead = TRUE;
	
	return 0;
}



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\common\src\TransInit.c ===
/***************************************************************************\
* (C) Copyright NVIDIA Corporation Inc.,                                    *
*  1996,1997, 1998. All rights reserved.                                    *
* THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO       *
* NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY  *
* IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.                *
*                                                                           *
* Module: TransInit.c                                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       schaefer           8/17/98                                          *
*                                                                           *
\***************************************************************************/
// these are intented to be called from surfaces.c setupvp and teardownvp

// MS includes
#include "windows.h"
#include "ddraw.h"
//#include "Ddrawp.h"
#include "ddrawi.h"
#include "ddmini.h"
#include "dvp.h"
#include "dmemmgr.h"
#include "ddkmmini.h"
#include "ddkmapi.h"

#ifndef NV4
#include "real3nv32.h"
#include "nvwin32.h"
#include "nvos.h"
#else
#include "realnv32.h"
#include "nvwin32.h"
#include "nvos.h"
#endif  //NV4

#include "nvrmapi.h"
#include "nvrmarch.inc"

#include "surfaces.h"
#include "transfer.h"

extern vpSurfaces*			pMySurfaces;
extern NvNotification*		nvMyVPNotifiers;
NvChannel* 			nvPtr = NULL;


U032 SetupMTM() {
	U032	i;
	U032	error;
	nvPtr = pMySurfaces->pVPChanPtr;
	
	// allocate the MTM object
	error = NvRmAllocObject(  (GLOBDATAPTR)->ROOTHANDLE,
	                     		MY_VPE_CHANNEL,
	                     		MY_MTM_OBJECT,
#ifndef NV4
										NV_MEMORY_TO_MEMORY_FORMAT
#else
										NV03_MEMORY_TO_MEMORY_FORMAT
#endif// NV4
								);    
	if(checkNvAllocArchError(error )) {
		DPF("NVDD: Cannot allocate MTM object %d",MY_EXTERNAL_DECODER_OBJECT);
		return FALSE;
	}
	

	// allocate the notify context
	error = NvRmAllocContextDma(  (GLOBDATAPTR)->ROOTHANDLE,
	                     		MY_MTM_NOTIFIER,
	                     		NV01_CONTEXT_DMA,
	                     		(	ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR |
                        				ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
	                     		(PVOID)(((U032)nvMyVPNotifiers) + NUM039OFFSET*sizeof(NvNotification)),
	                     		(sizeof( NvNotification)*NUM039NOTIFIER  - 1)
	                     );
	if(checkNvAllocArchError(error )) {
		DPF("NVDD: Cannot allocate MTM Notifier object %d",MY_EXTERNAL_DECODER_OBJECT);
		return FALSE;
	}
	
	// allocate the FROM context
	error = NvRmAllocContextDma(  (GLOBDATAPTR)->ROOTHANDLE,
	                     		MY_MTM_FROM_CONTEXT,
	                     		NV01_CONTEXT_DMA,		//NV_CONTEXT_DMA_FROM_MEMORY ?
	                     		(	ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR |
                        				ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
	                     		(PVOID)(void*)((GLOBALDATA*)(pMySurfaces->pDriverData))->BaseAddress,
	                     		((((GLOBALDATA*)(pMySurfaces->pDriverData))->VideoHeapEnd - ((GLOBALDATA*)(pMySurfaces->pDriverData))->BaseAddress)) -1
	                     );

	if(checkNvAllocArchError(error )) {
		DPF("NVDD: Cannot allocate MTM FROM context object %d",MY_EXTERNAL_DECODER_OBJECT);
		return FALSE;
	}
	
	// allocate the MTM event
	error = NvRmAllocEvent	(	(GLOBDATAPTR)->ROOTHANDLE,
	 									MY_MTM_OBJECT,
	                      		MY_MTM_EVENT,
	                      		NV01_EVENT_KERNEL_CALLBACK,
										NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(0),
										(void*)pMySurfaces->pMTMNotifyCallback);		    
							
	if(checkNvAllocArchError(error )) {
		DPF("NVDD: Cannot allocate MTM event object %d",MY_EXTERNAL_DECODER_OBJECT);
		return FALSE;
	} 
#if 0	
// second one until RM is working

	error = NvRmAllocEvent	(	(GLOBDATAPTR)->ROOTHANDLE,
	 									MY_MTM_OBJECT,
	                      		MY_MTM_EVENT2,
	                      		NV01_EVENT_KERNEL_CALLBACK,
										NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(0),
										(void*)pMySurfaces->pMTMNotifyCallback);		    
							
	if(checkNvAllocArchError(error )) {
		DPF("NVDD: Cannot allocate MTM event object %d",MY_EXTERNAL_DECODER_OBJECT);
		return FALSE;
	} 
// done with second one
#endif

#ifndef NV4
	nvPtr->subchannel[5].control.object = MY_MTM_OBJECT;
#else 
	nvPtr->subchannel[5].SetObject  = MY_MTM_OBJECT;
#endif // NV4
	
			
#ifndef NV4
	nvPtr->subchannel[5].memoryToMemoryFormat.SetBufferNotifyCtxDma = MY_MTM_NOTIFIER;
	nvPtr->subchannel[5].memoryToMemoryFormat.SetBufferInCtxDma = MY_MTM_FROM_CONTEXT;
#else
	nvPtr->subchannel[5].nv03MemoryToMemoryFormat.SetContextDmaNotifies = MY_MTM_NOTIFIER;
	nvPtr->subchannel[5].nv03MemoryToMemoryFormat.SetContextDmaBufferIn = MY_MTM_FROM_CONTEXT;
#endif //NV4
	
	// Null out the transfers
	for(i=0;i<MAXTRANSFERS;i++) {
		pMySurfaces->MyTransfers[i].TransferID = TRANSFERNOTINUSE;
	}
//	pMySurfaces->pLastTransfer =
	pMySurfaces->pCurrentTransfer = NULL;
	pMySurfaces->bContextCreated	= FALSE;
}



void TearDownMTM() {
	U032	i;
	U032	error;
	nvPtr = pMySurfaces->pVPChanPtr;
	
	
	// set the transfers to something useless
	for(i=0;i<MAXTRANSFERS;i++) {
		pMySurfaces->MyTransfers[i].TransferID = 0;
	}
	
	if(nvPtr != NULL ) {
#ifndef NV4
		nvPtr->subchannel[5].control.object = MY_MTM_OBJECT;
#else 
		nvPtr->subchannel[5].SetObject  = MY_MTM_OBJECT;
#endif // NV4

																			// plug in some null objects
#ifndef NV4
		nvPtr->subchannel[5].memoryToMemoryFormat.SetBufferNotifyCtxDma = 0;
		nvPtr->subchannel[5].memoryToMemoryFormat.SetBufferInCtxDma = 0;
		nvPtr->subchannel[5].memoryToMemoryFormat.SetBufferOutCtxDma = 0;
#else
		nvPtr->subchannel[5].nv03MemoryToMemoryFormat.SetContextDmaNotifies = 0;
		nvPtr->subchannel[5].nv03MemoryToMemoryFormat.SetContextDmaBufferIn = 0;
		nvPtr->subchannel[5].nv03MemoryToMemoryFormat.SetContextDmaBufferOut = 0;
#endif //NV4


	// DO a SYNC here.
		// spin waiting for empty fifo
#ifdef NV4
		while(NvGetFreeCount(nvPtr, 5) < NV06A_FIFO_GUARANTEED_SIZE );
#else
		while(NvGetFreeCount(nvPtr, 5) < NV_GUARANTEED_FIFO_SIZE );
#endif
	
	}
	
	if(pMySurfaces->bContextCreated) {
		error = NvRmFree((GLOBDATAPTR)->ROOTHANDLE, (GLOBDATAPTR)->ROOTHANDLE, MY_MTM_TO_CONTEXT);

		checkNvAllocArchError(error);
		pMySurfaces->bContextCreated = FALSE;
	
	}

#ifdef NOEVENTFREEFUNCTIONYETFOLKS	
	error = NvRmFree((GLOBDATAPTR)->ROOTHANDLE, MY_MTM_OBJECT, MY_MTM_EVENT);
   checkNvAllocArchError(error);
#if 0
	error = NvRmFree((GLOBDATAPTR)->ROOTHANDLE, MY_MTM_OBJECT, MY_MTM_EVENT2);
   checkNvAllocArchError(error);
#endif
	
#endif
	
	error = NvRmFree((GLOBDATAPTR)->ROOTHANDLE, (GLOBDATAPTR)->ROOTHANDLE, MY_MTM_NOTIFIER);
	checkNvAllocArchError(error);
	error = NvRmFree((GLOBDATAPTR)->ROOTHANDLE, (GLOBDATAPTR)->ROOTHANDLE, MY_MTM_FROM_CONTEXT);
	checkNvAllocArchError(error);
	error = NvRmFree((GLOBDATAPTR)->ROOTHANDLE, MY_VPE_CHANNEL, MY_MTM_OBJECT);
	checkNvAllocArchError(error);
	
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\common\src\Vp.c ===
/***************************************************************************\
* (C) Copyright NVIDIA Corporation Inc.,                                    *
*  1996,1997, 1998. All rights reserved.                                    *
*                                                                           *
* Module: VP.c                                                              *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       schaefer           3/26/98                                          *
*                                                                           *
\***************************************************************************/

/* #includes ---------------------------------------------*/

// MS includes
#include "windows.h"
#include "mmsystem.h"
#include "ddraw.h"
#include "ddrawi.h"
#include "ddmini.h"
#include "ddkmmini.h"
#include "minivdd.h"
#include "dvp.h"

// NV includes
#ifndef NV4
#include "nv32.h"
#include "nvwin32.h"
#else
#include "realnv32.h"
#include "realnvwin32.h"
#endif

#ifndef NV4
#include "nvddobj.h"
#endif // NV4

#include "nvdd.h"
#include "nvcm.h"

#include "surfaces.h"
								

// provides access to the global data structures in ddmini.h
extern 		GLOBALDATA*			pDriverData;


volatile U032* 	nvTimerPtr = NULL;


vpSurfaces*			pMySurfaces = NULL;
NvNotification*	nvMyVPNotifiers = NULL;

const DWORD MY_CONNECTION_CAPS=	//DDVPCONNECT_DOUBLECLOCK			|
											//DDVPCONNECT_VACT					|
											/* we're capable of inverting the polarity */
											DDVPCONNECT_INVERTPOLARITY		|					
											/* we discard at least until the V bit goes low, and potentially more depending
											  on the setting of YCROP  as well as the current VBI situation  */
											//DDVPCONNECT_DISCARDSVREFDATA	|
											/* we WILL count the halfline */
											DDVPCONNECT_HALFLINE				|
											/*  these next are "client" only 
											//DDVPCONNECT_INTERLACED			|
											//DDVPCONNECT_SHAREEVEN			|
											//DDVPCONNECT_SHAREODD				|
											*/
											0;

DDPIXELFORMAT pf[] = {
	{sizeof(DDPIXELFORMAT),DDPF_FOURCC,  mmioFOURCC('U','Y','V','Y'),16,(DWORD)-1,(DWORD)-1,(DWORD)-1},
};
/*DDPIXELFORMAT pfvbi[] = {
	{sizeof(DDPIXELFORMAT),DDPF_FOURCC,  mmioFOURCC('R','A','W','8'),8,(DWORD)-1,(DWORD)-1,(DWORD)-1},
};
*/
DDPIXELFORMAT pfvbi[] = {
	{sizeof(DDPIXELFORMAT),DDPF_FOURCC,  mmioFOURCC('R','A','W','8'),8,(DWORD)-1,(DWORD)-1,(DWORD)-1},
};



//#define TESTCALLBACK
#ifdef TESTCALLBACK

void JoeCoolDudesCallbackRoutine(sCallBack* pCallbackStruct);

#endif

U032	getMilliTime(void);


void	getCurrentNanoTimer(U032 *	Most, U032 * Least) {
	volatile U032* myTimerLo = nvTimerPtr;
	volatile U032* myTimerHi = (U032*)(((U032)nvTimerPtr)+0x10);
	ASSERT(nvTimerPtr != NULL);
	ASSERT(Most 		!= NULL);
	ASSERT(Least 		!= NULL);
	*Least = *myTimerLo;
	*Most	= *myTimerHi;
}

U032	getMilliTime(void) {
	U032	bigTime;
	U032	smallTime;
	
	getCurrentNanoTimer(&bigTime, &smallTime);
	return (smallTime / 1000000) + bigTime * (0xFFFFFFFF/1000000);
			
}
	
/*

It appears that BPC has been programmd in such a way as to violate the API for VP.
So we need to compensate.  The problem is that the following scenario can happen.
CanCreateVP   VBI
CreateVP   VBI
UpdateVP   VBI
time passes
CanCreateVP   IMAGE
CreateVP  Image
UpdateVP   VBI+Image
timepasses
Destroy VP.

The key thing here is that the video ports will use the SAME port ID. so that should help us.


*/	

DWORD __stdcall CanCreateVideoPort32 (LPDDHAL_CANCREATEVPORTDATA lpInput)
{
    /*
     * If the lpInput->lpDDVideoPortDesc can not be supported, set
     * lpInput->ddRVal to the correct error code and return
     * DDHAL_DRIVER_HANDLED
     */		
	/* 	this is only a query to see if VideoPort can handle a certain requirement, 
		no structures are defined here, or even chip query */
	DPF("***CanCreateVideoPort32");

	ASSERT(lpInput!=NULL);
	ASSERT(lpInput->lpDDVideoPortDesc !=NULL);	
	
	if( pDriverData == NULL ) {
		DPF("   ***VideoPort not creatable  -->  pDriverData = NULL!   YIKES!");
		lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
		return DDHAL_DRIVER_HANDLED;
	}
	// Ok, if we got to here that means we're talking to the VXD MiniVDD properly... onward ho!
	
	// Check structure size
	if(lpInput->lpDDVideoPortDesc->dwSize   < sizeof( DDVIDEOPORTDESC ) ) {
		DPF("   ***VideoPort not creatable  -->  stucture length is not large enough");
		lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
		return DDHAL_DRIVER_HANDLED;
	}
	
	// check input connection GUID
	if ( !IsEqualGUID(&(lpInput->lpDDVideoPortDesc->VideoPortType.guidTypeID), &DDVPTYPE_CCIR656) )	 {
		DPF("   ***VideoPort not creatable  -->  GUID should be DDVPTYPE_CCIR656");
		lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
		return DDHAL_DRIVER_HANDLED;
	}
	
	// check to see if there are ports available... by looking at local allocation
	if (pDriverData->dwVideoPortsAvailable <=0 ) {

			// check to see if there are ports available... by looking at IDs
	   if (lpInput->lpDDVideoPortDesc->dwVideoPortID != 0 ) {
			DPF("   ***VideoPort not creatable  --> not enough video ports");
			lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
			return DDHAL_DRIVER_HANDLED;
		}

		DPF("CanCreate for Second VP with same ID Allowed.... silly API");
	}
	
	// the restrictions we have FieldWidth are dependant on maximum pitch specifiable
	//  pitch is 2^13 in size...
	if (lpInput->lpDDVideoPortDesc->dwFieldWidth > NV_MAX_FIELDWIDTH) {
		DPF("   ***VideoPort not creatable  --> field Width is too great");
		lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
		return DDHAL_DRIVER_HANDLED;
	}
	
	// the restrictions we have VBIWidth are dependant on maximum pitch specifiable
	//  pitch is 2^13 in size...  but there are 2 bytes in each pixel
	if (lpInput->lpDDVideoPortDesc->dwVBIWidth > NV_MAX_VBIWIDTH) {
		DPF("   ***VideoPort not creatable  --> VBI field Width is too great");
		lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
		return DDHAL_DRIVER_HANDLED;
	}
	
	// the restrictions we have on Field Height are dependant on maximum length specifiable
	//  length is 2^19 in size... which is but there are 2 bytes in each pixel
	if (lpInput->lpDDVideoPortDesc->dwFieldHeight * lpInput->lpDDVideoPortDesc->dwFieldWidth > NV_MAX_BUFFERLENGTH) {
		DPF("   ***VideoPort not creatable  --> Maximum buffer length exceed by field height too high");
		lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
		return DDHAL_DRIVER_HANDLED;
	}

	if (lpInput->lpDDVideoPortDesc->dwMaxPixelsPerSecond > NV_MAX_PIXELRATE) {
		DPF("   ***VideoPort not creatable  --> Sorry incoming data rate is too high");
		lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
		return DDHAL_DRIVER_HANDLED;
	}

	// we don't have any restrictions on Microseconds per field that I know of....
	//    lpInput->lpDDVideoPortDesc->dwMicrosecondsPerField;	// Microseconds per video field
    
	if ( lpInput->lpDDVideoPortDesc->VideoPortType.dwPortWidth  != 8 ) {
		DPF("   ***VideoPort not creatable  --> incoming connection width is not 8");
		lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
		return DDHAL_DRIVER_HANDLED;
	}
	
#ifdef NOCHECKHERE
			// the ones I'm not capable of   ANDed   with the ones Dx is asking for
	if( (~MY_CONNECTION_CAPS) & lpInput->lpDDVideoPortDesc->VideoPortType.dwFlags ) {
		// if we get here this should indicate that Dx is asking for a capability we're incapable of
		DPF("   ***VideoPort not creatable  --> Some of the capability flags bits are wrong");
		lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
		return DDHAL_DRIVER_HANDLED;
	
	}
#endif
		
	//  Ok, we've pretty much checked everything we can possibly check here... let's tell'em that
	// we can work!		

	lpInput->ddRVal = DD_OK;
	DPF("   ***VideoPort creatable! ***");
	return DDHAL_DRIVER_HANDLED;
}


U032 	HookUpVxdStorage(void) {

	
	HANDLE 		aVXDHandle;
	U032 i;
	
	//DPF("NOW ATTEMPTING VXD stuff");
	

	
	//DPF("\n\n\n\nThe DeviceID is:%d\n\n\n\n",pDriverData->thisDeviceID);
		
	if( pDriverData->thisDeviceID == 0 ) {
		DPF("We are Primary controller! \n");
#ifdef NV4
	
		aVXDHandle = CreateFile("\\\\.\\NV4.VXD", 0,0,0, CREATE_NEW, FILE_FLAG_DELETE_ON_CLOSE, 0);
#else
		aVXDHandle = CreateFile("\\\\.\\NV3.VXD", 0,FILE_SHARE_READ,0, CREATE_NEW, FILE_FLAG_DELETE_ON_CLOSE, 0);
#endif
	
	} else {
		DPF("We are not primary controller :-( \n");
#ifdef NV4
	
		aVXDHandle = CreateFile("\\\\.\\NV4mini2.VXD", 0,0,0, CREATE_NEW, FILE_FLAG_DELETE_ON_CLOSE, 0);
#else
		aVXDHandle = CreateFile("\\\\.\\NV3mini2.VXD", 0,FILE_SHARE_READ,0, CREATE_NEW, FILE_FLAG_DELETE_ON_CLOSE, 0);
#endif
	
	
	}

	if((aVXDHandle == NULL) || (aVXDHandle ==INVALID_HANDLE_VALUE)) {
		U032	daError;
		DPF("Can't get Vxd handle   :-(");
		daError = GetLastError();
		DPF("The error was %d  or %x",daError,daError);
		if(daError == 50 ) {
			DPF("Which means most likely that you don't have a version of NVX.VXD or NVXmini2 which supports IOCTL");	
		}
		return FALSE;	
		
	} 
	
	// nother block
	{
		U032				inBuffer;
		NVVDDPROCTABLE	aTable;
		U032				outputSize = 0;
			
		// pass in the pointer to the direct draw object.. this may be useful later
//		inBuffer = (U032) lpInput->lpDD;
		
		aTable.getStoragePointer = NULL;
		aTable.dwPDDDriver = 0;
		aTable.handleBufferInterrupts = NULL;
		
		if(!DeviceIoControl(aVXDHandle,
							VDD_IOCTL_NV_FILLTABLE,		// control code of operation to perform
							&inBuffer,							// pointer to buffer to supply input data
							4,								// size of input buffer
							&aTable,					// pointer to buffer to receive output data
							sizeof(NVVDDPROCTABLE),	// size of output buffer
							&outputSize,				// pointer to variable to receive output byte count
							NULL 							// pointer to overlapped structure for asynchronous operation
		) ){
			// cool we made it.   Now copy our temporarly stuff into the real one!
			
			// first get the storage pointer
			if( aTable.getStoragePointer != NULL ) {
				pMySurfaces = (vpSurfaces*)(aTable.getStoragePointer)();
			} else {
				DPF("didn't get a valid pointer to a routine");
			
				CloseHandle(aVXDHandle);
				return FALSE;	
			}
			
			if( pMySurfaces != NULL ) {
				// we cool!  everybody get funky one more time!  and copy that stuff in
				pMySurfaces->myVXDhandle = aVXDHandle;
				memcpy (&pMySurfaces->myTable, &aTable,  sizeof (NVVDDPROCTABLE));
				
			} else {
				DPF("didn't get the storage pointer");
			
				CloseHandle(aVXDHandle);
				return FALSE;	
			}
			
		}	else {
			//	failure
			//close the VXD
			DPF("couldn't call the VXD via IOCTL properly");
			CloseHandle(aVXDHandle);
			return FALSE;	
		}
		
	}
	
	nvMyVPNotifiers = pMySurfaces->pTheNotifiers;
	pMySurfaces->numberOfSurfaces =0;

	for(i=0;i<MAXVPSURFACES;i++) {
		pMySurfaces->Surfaces[i] = NULL;
	}
	pMySurfaces->CurrentBufferSurface[4] = NOSURFACEPROGRAMED;				// to associate the HW buffer with an arrary index
			 
	pMySurfaces->CurrentScanMode =SEPERATEBUF;		// seperate or interleaved buffersx
	if(pMySurfaces->bInvertedFields ) 	{
		pMySurfaces->lastField = ODD;	// this should be even so we'll always start on odd ( hopefully... :-)
		pMySurfaces->lastVBIField = ODD;
	} else {
		pMySurfaces->lastField = EVEN;
		pMySurfaces->lastVBIField = EVEN;
	}	
	pMySurfaces->VBIstart = 0;;
	// general information
	pMySurfaces->bSkipNextField = FALSE;
	pMySurfaces->dwInHeight = 0;
	pMySurfaces->dwInWidth = 0;
	pMySurfaces->dwImageStartLine =10;				// ditch a minimum of 10 lines
	pMySurfaces->dwVBIStartLine = 0;
	pMySurfaces->dwVBIHeight = 0;
	pMySurfaces->dwPreHeight = 0;					// height and width before prescaling
	pMySurfaces->dwPreWidth = 0;
	pMySurfaces->dwOriginX = 0;						// orgins to move data within the surface
	pMySurfaces->dwOriginY = 0;
	pMySurfaces->bThreadDead = TRUE;
	pMySurfaces->bThreadRunning = FALSE;

	pMySurfaces->bStopVP = FALSE;							// indicates to the thread that it should NOT reprogram

	pMySurfaces->Timings.LoopCount=0;

	pMySurfaces->pBuffer0Mem = (U032) NULL;
	pMySurfaces->pBuffer1Mem = (U032) NULL;
	pMySurfaces->curOverlay = 0;			// this way we should start into 0
	
	// initialize all the callback stuff	
	pMySurfaces->ImageCallbackRoutine = NULL;			
	pMySurfaces->VBICallbackRoutine = NULL;			
	pMySurfaces->myIMGCallbackInfo.intCount = 0;			
	pMySurfaces->myVBICallbackInfo.intCount = 0;	
	pMySurfaces->myIMGCallbackInfo.dwFlags = 0;
	pMySurfaces->myVBICallbackInfo.dwFlags = 0;
	pMySurfaces->myIMGCallbackInfo.dwVersion = 0x100;
	pMySurfaces->myVBICallbackInfo.dwVersion = 0x100;		
	pMySurfaces->myIMGCallbackInfo.curBufferAddr = (U032)NULL;			
	pMySurfaces->myVBICallbackInfo.curBufferAddr = (U032)NULL;			
	pMySurfaces->myIMGCallbackInfo.lastBufferAddr = (U032)NULL;			
	pMySurfaces->myVBICallbackInfo.lastBufferAddr = (U032)NULL;			
	pMySurfaces->myIMGCallbackInfo.dwSize = sizeof(sCallBack);			
	pMySurfaces->myVBICallbackInfo.dwSize = sizeof(sCallBack);	
	if(pDriverData == NULL ) {
		// dude this is PROBLEM!!!
		return FALSE;
	}
	pMySurfaces->pDriverData = pDriverData;		
		
	pMySurfaces->DXIRQCallbackSources = 0;;
	pMySurfaces->pDXIRQCallback = (U032) NULL;
	pMySurfaces->dwIrqContext = 0;
	pMySurfaces->SetupComplete = FALSE;
	pMySurfaces->dwNextEmpty = 0;
	pMySurfaces->dwLastEmpty = (MAXTRANSFERS-1);
	pMySurfaces->lastSurface = 999;
	pMySurfaces->lastBuffer = 999;
	return TRUE;
}

/*
 * CreateVideoPort32
 *
 * This function is optional, define all objects if they have not already been defined.
 */
DWORD __stdcall CreateVideoPort32 (LPDDHAL_CREATEVPORTDATA lpInput)
{
    /*
     * This function allows the HAL to set internal flags and
     * become aware that a video port has been created. It should
     * always return DDHAL_DRIVER_NOTHANDLED.
     */

	/* According to DDHAL documentation, this procedure can return DDHAL_DRIVER_NOTHANDLED
	   as well, signifying that the createvideoport fn could not be completed
	   
	   DirectDraw MS layer will prevent creating more videoports that is
	   available.

	   */     
	DWORD		returnVal = DDHAL_DRIVER_HANDLED;
	// we should only have to get this once on creation
	
	if(pMySurfaces == NULL )
		if(!HookUpVxdStorage() )
		{
			lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
			return DDHAL_DRIVER_HANDLED;
		}
	if( pMySurfaces->pDriverData == NULL )
		if(!HookUpVxdStorage() )
		{
			lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
			return DDHAL_DRIVER_HANDLED;
		}
	
	
	if( pMySurfaces->SetupComplete ) {
			// we may be attempting a "second" CreateVideo port with the same ID..
			// let's check that.
			
			//CODE we should probably check here for non-duplicat VBI and Image, but we'll just let that slide for now.
			
			if (lpInput->lpDDVideoPortDesc->dwVideoPortID == 0 ) {
				// this is the second create
				DPF("***  HACKED second video port create has been called.");
				DPF("  now shunting to hyperspace modulator bypass code.  Turn reality distortion field driver code to 11");
	
				
				DPF("  Size of the DDVIDEOPORTDESC structure     %d",lpInput->lpDDVideoPortDesc->dwSize);
				DPF("  Width of the video port field.            %d",lpInput->lpDDVideoPortDesc->dwFieldWidth);
				DPF("  Width of the VBI data.                    %d",lpInput->lpDDVideoPortDesc->dwVBIWidth);
				DPF("  Height of the video port field.           %d",lpInput->lpDDVideoPortDesc->dwFieldHeight);
				DPF("  Microseconds per video field.             %d",lpInput->lpDDVideoPortDesc->dwMicrosecondsPerField);
				DPF("  Maximum pixel rate per second.            %d",lpInput->lpDDVideoPortDesc->dwMaxPixelsPerSecond);
				DPF("  Video port ID (0 - (dwMaxVideoPorts -1)). %d",lpInput->lpDDVideoPortDesc->dwVideoPortID);
				DPF("  Reserved for future use - set to zero.    %d",lpInput->lpDDVideoPortDesc->dwReserved1);
				
				DPF("  Size of the DDVIDEOPORTDESC.dwSize        %d",lpInput->lpDDVideoPortDesc->VideoPortType.dwSize);
				DPF("              DDVIDEOPORTDESC.dwPortWidth   %d",lpInput->lpDDVideoPortDesc->VideoPortType.dwPortWidth);
				DPF("              DDVIDEOPORTDESC.guidTypeID    %d",lpInput->lpDDVideoPortDesc->VideoPortType.guidTypeID);
				DPF("              DDVIDEOPORTDESC.dwFlags       %d",lpInput->lpDDVideoPortDesc->VideoPortType.dwFlags);
	
				lpInput->ddRVal = DD_OK;
				return returnVal;
			}
	}
		
	if(lpInput->lpDDVideoPortDesc->VideoPortType.dwFlags & DDVPCONNECT_INTERLACED ) {
		pMySurfaces->bInputInterLaced = TRUE;		
	} else {
		pMySurfaces->bInputInterLaced = FALSE;		
	}
	
	if(pMySurfaces->bInputInterLaced)
		pMySurfaces->CurrentCaptureMode =EVENODD;		// indicates which fields will be capture Even	
	else 
		pMySurfaces->CurrentCaptureMode =PROGRESSIVE;	// we're assuming progressive is ALWAYS even even even

		 
	 
	if(lpInput->lpDDVideoPortDesc->VideoPortType.dwFlags & DDVPCONNECT_INVERTPOLARITY ) {
		DPF("DDVPCONNECT_INVERTPOLARITY		on");
		pMySurfaces->bInvertedFields = TRUE;
		// Now check for the weird exception case when we want to skip half line as well...
		if(lpInput->lpDDVideoPortDesc->VideoPortType.dwFlags & DDVPCONNECT_HALFLINE ) {
			DPF("DDVPCONNECT_HALFLINE		on");
			pMySurfaces->bInvertedFields = FALSE;
		} else {
			DPF("DDVPCONNECT_HALFLINE		off");
		
		}
		
	} else {
		DPF("DDVPCONNECT_INVERTPOLARITY		off");
		pMySurfaces->bInvertedFields = FALSE;
	}
			 
	if(lpInput->lpDDVideoPortDesc->VideoPortType.dwFlags & DDVPCONNECT_HALFLINE ) {
		DPF("DDVPCONNECT_HALFLINE		      on");
	} else {
		DPF("DDVPCONNECT_HALFLINE		      off");
	}
		

#ifdef  MULTI_MON
	nvTimerPtr = (U032 *) NvDeviceBaseGet(NV_DEV_TIMER, pDriverData->dwDeviceIDNum );
#else   /* MULTI_MON */
	nvTimerPtr = (U032 *) NvDeviceBaseGet(NV_DEV_TIMER );
#endif  /* MULTI_MON */
	pMySurfaces->pNvTimer = nvTimerPtr;

	DPF("***CreateVideoPort32");


	DPF("  Size of the DDVIDEOPORTDESC structure     %d",lpInput->lpDDVideoPortDesc->dwSize);
	DPF("  Width of the video port field.            %d",lpInput->lpDDVideoPortDesc->dwFieldWidth);
	DPF("  Width of the VBI data.                    %d",lpInput->lpDDVideoPortDesc->dwVBIWidth);
	DPF("  Height of the video port field.           %d",lpInput->lpDDVideoPortDesc->dwFieldHeight);
	DPF("  Microseconds per video field.             %d",lpInput->lpDDVideoPortDesc->dwMicrosecondsPerField);
	DPF("  Maximum pixel rate per second.            %d",lpInput->lpDDVideoPortDesc->dwMaxPixelsPerSecond);
	DPF("  Video port ID (0 - (dwMaxVideoPorts -1)). %d",lpInput->lpDDVideoPortDesc->dwVideoPortID);
	DPF("  Reserved for future use - set to zero.    %d",lpInput->lpDDVideoPortDesc->dwReserved1);
	
	DPF("  Size of the DDVIDEOPORTDESC.dwSize        %d",lpInput->lpDDVideoPortDesc->VideoPortType.dwSize);
	DPF("              DDVIDEOPORTDESC.dwPortWidth   %d",lpInput->lpDDVideoPortDesc->VideoPortType.dwPortWidth);
	DPF("              DDVIDEOPORTDESC.guidTypeID    %d",lpInput->lpDDVideoPortDesc->VideoPortType.guidTypeID);
	DPF("              DDVIDEOPORTDESC.dwFlags       %d",lpInput->lpDDVideoPortDesc->VideoPortType.dwFlags);
	
	DPF("	Reserved for future use - set to zero.     %d",lpInput->lpDDVideoPortDesc->dwReserved2);
	DPF("	Reserved for future use - set to zero.     %d",lpInput->lpDDVideoPortDesc->dwReserved3);

	
	// We'll assume for now that since CanCreate passed that our parameters are valid at this point
	// we need to setup the entire NV object system at this point

	// theorectically we should not have a channel open... let's check that?

	// get our OWN copy of the driver data
		
	returnVal = SetupVP ( lpInput);
	

	//pMySurfaces->pVPChanPtr = (NvChannel * ) pDriverData->NvDevFlatVPE;


	// For the overlay flip, store away a channel pointer
#ifdef NV4
	pMySurfaces->pOverlayChanPtr = (NvChannel*) pDriverData->NvDevVideoFlatPio;
#else
	pMySurfaces->pOverlayChanPtr = (NvChannel*) pDriverData->NvDevFlatPio;
#endif	
	pMySurfaces->dwOverlaySubChan = NV_DD_SPARE;
	pMySurfaces->dwOverlayObjectID = NV_DD_YUV422_VIDEO_FROM_MEMORY;
	pMySurfaces->dwScalerObjectID = NV_DD_VIDEO_SCALER;
	pMySurfaces->dwDVDObjectID = NV_DD_DVD_SUBPICTURE;
	
#ifdef TESTCALLBACK

	// let's register an IMAGE callback here and see what happens
	{
		HANDLE bVXDHandle;
		U032	 inBuffer;
		//U032	 returnCode;
		U032	 outputSize;
		SETCALLBPROC	pSetCallback;
		
		inBuffer = 0;		
		
#ifdef NV4		
		bVXDHandle = CreateFile("\\\\.\\NV4", 0,0,0, CREATE_NEW, FILE_FLAG_DELETE_ON_CLOSE, 0);
#else
		bVXDHandle = CreateFile("\\\\.\\NV3", 0,0,0, CREATE_NEW, FILE_FLAG_DELETE_ON_CLOSE, 0);
#endif	// NV4		
		if(bVXDHandle != NULL ) {
			if(!DeviceIoControl(bVXDHandle,
										VDD_IOCTL_NV_GETSETCALLBACK,		// control code of operation to perform
										&inBuffer,							// pointer to buffer to supply input data
										4,										// size of input buffer
										&pSetCallback,						// pointer to buffer to receive output data
										4,										// size of output buffer
										&outputSize,						// pointer to variable to receive output byte count
										NULL 									// pointer to overlapped structure for asynchronous operation
									)
				 ){
						
						// things worked, the 
						inSCBStruct		inBuf;
						outSCBStruct	outBuf;
							// NOTE USE OF FLAGS FROM VPCALLBk.h
						inBuf.flags = IMAGESURFACE;
						inBuf.pTheCallback = JoeCoolDudesCallbackRoutine;
						
						(pSetCallback)(&inBuf,&outBuf);
						
			} else {
						
						// bummer, for some reason, we were unable to set your callback
			
			}
					
			CloseHandle(bVXDHandle);
									
		}
		
		
	}
#endif	

	// don't forget to decrement the number of video ports avail number which is 
	lpInput->ddRVal = DD_OK;
	
	return returnVal;
}


#ifdef TESTCALLBACK

void JoeCoolDudesCallbackRoutine(sCallBack* pCallbackStruct) {
	DPF("WoW we made it to JoeCoolDudesCallbackRoutine interrupt=%d",pCallbackStruct->intCount);
	
	
}


#endif
 /*
 * GetVideoPortBandwidth32
 *
 * This function is required
 */
DWORD __stdcall GetVideoPortBandwidth32 (LPDDHAL_GETVPORTBANDWIDTHDATA lpInput)
{

	DPF("***GetVideoPortBandwidth32");
	/*
	 * Determine how much bandwidth is available for the specified
	 * output format and fill in the information.
	 */
	 
	 // we are lucky in that we basically only support ONE format  YEAH!
	 
	if (lpInput->dwFlags & DDVPB_TYPE) {
		lpInput->lpBandwidth->dwCaps = DDVPBCAPS_DESTINATION;  // we are limited by the "shrink" of the overlay 			
	}
	 
	if (lpInput->dwFlags & DDVPB_VIDEOPORT) {
		// The following four should indicate the MINIMUM stretch values represented as percentages times 10
		//  so if we could not stretch below 75% of the orginal size, the we should put in 750
		// for now I'll leave these "as is" because I need to collect the correct values -CJS
		lpInput->lpBandwidth->dwOverlay 				= 1000;
		lpInput->lpBandwidth->dwColorkey 				= 1000;  // Overlay/video port/colorkey works at 1X
		lpInput->lpBandwidth->dwYInterpolate			= 1000;	 // Overlay/video port works at 1X
		lpInput->lpBandwidth->dwYInterpAndColorkey		= 1000;  // Overlay/video port/interpolation works at 2X
	}
	
	
	if (lpInput->dwFlags & DDVPB_OVERLAY) {
		DPF("   We are NOT an overlay limited device but a destination ");
		DPF("      limited device we should not have been called");
	}
	
	lpInput->ddRVal = DD_OK;
	return DDHAL_DRIVER_HANDLED; 
}

/*
 * GetVideoPortInputFormat32
 *
 * This function is required
 */
DWORD __stdcall GetVideoPortInputFormat32 (LPDDHAL_GETVPORTINPUTFORMATDATA lpInput)
{
   /* Only 1 input format supported UYVY 4:2:2 */
	/* Data stored in 32bit word as U[7:0] Y1[15:8] V[23:16] Y2[31:24] */
	DPF("   ***GetVideoPortInputFormat32");
	/*
	* The HAL is gaurenteed that the buffer in lpInput->lpddpfFormat
	* is large enough to hold the information
	*/

	
	if (lpInput->dwFlags & DDVPFORMAT_VIDEO ) {
		lpInput->dwNumFormats = 1;
		if (lpInput->lpddpfFormat != NULL) {
			memcpy (lpInput->lpddpfFormat, &pf[0],  sizeof (DDPIXELFORMAT));
		}
	}

/*
	if (lpInput->dwFlags & DDVPFORMAT_VBI ) {
		lpInput->dwNumFormats = 1;
		if (lpInput->lpddpfFormat != NULL) {
			memcpy (lpInput->lpddpfFormat, &pf[0],  sizeof (DDPIXELFORMAT));
		}
	}
*/
	if (lpInput->dwFlags & DDVPFORMAT_VBI ) {
		lpInput->dwNumFormats = 1;
		if (lpInput->lpddpfFormat != NULL) {
			memcpy (lpInput->lpddpfFormat, &pfvbi[0],  sizeof (DDPIXELFORMAT));
		}
	}

	lpInput->ddRVal = DD_OK;
	return DDHAL_DRIVER_HANDLED;
}


/*
 * GetVideoPortOutputFormat32
 *
 * This function is required
 */
DWORD __stdcall GetVideoPortOutputFormat32 (LPDDHAL_GETVPORTOUTPUTFORMATDATA lpInput)
{
  	/* OutputFormat does not convert UYUV to RGB, this would be done by Overlay control */
	/* Data stored in 32bit word as U[7:0] Y1[15:8] V[23:16] Y2[31:24] */

	DPF("***GetVideoPortOutputFormat32");

	/* OutputFormat does not convert UYUV to RGB, this would be done by Overlay control */
	/* Data stored in 32bit word as U[7:0] Y1[15:8] V[23:16] Y2[31:24] */

	// default
	lpInput->dwNumFormats = 1;
	if (lpInput->lpddpfOutputFormats != NULL) {
		memcpy (lpInput->lpddpfOutputFormats, lpInput->lpddpfInputFormat, sizeof (DDPIXELFORMAT));
	}

	// for the video data
	if (lpInput->dwFlags & DDVPFORMAT_VIDEO) {// video formats
		// is input format a FOURCC
		if (lpInput->lpddpfInputFormat->dwFlags & DDPF_FOURCC ) {
			// is it UYVY
			if (lpInput->lpddpfInputFormat->dwFourCC == mmioFOURCC('U','Y','V','Y')) {
				// translation of UYVY is UYVY (ie no translation)
   	    	lpInput->dwNumFormats = 1;
	   	   if (lpInput->lpddpfOutputFormats != NULL) {
					memcpy (lpInput->lpddpfOutputFormats, pf, sizeof (DDPIXELFORMAT) );
		    	}
			}
		}
	}
	
	// for the VBI data
	if (lpInput->dwFlags & DDVPFORMAT_VBI) {// VBI formats
		// is input format a FOURCC
		if (lpInput->lpddpfInputFormat->dwFlags & DDPF_FOURCC ) {
			// is it UYVY
			if (lpInput->lpddpfInputFormat->dwFourCC == mmioFOURCC('R','A','W','8')) {
				// translation of UYVY is UYVY (ie no translation)
   	    	lpInput->dwNumFormats = 1;
	   	   if (lpInput->lpddpfOutputFormats != NULL) {
					memcpy (lpInput->lpddpfOutputFormats, pfvbi, sizeof (DDPIXELFORMAT) );
		    	}
			} 		
		}
	}
	
	lpInput->ddRVal = DD_OK;
   return DDHAL_DRIVER_HANDLED;
}


/*
 * GetVideoPortField32
 *
 * This function is only required if readback of the current
 * field is supported.
 */
// needed defines for mediaport


DWORD __stdcall GetVideoPortField32 (LPDDHAL_GETVPORTFIELDDATA lpInput)
{
    /*
     * Make sure the video port is ON.  If not, set
     * lpInput->ddRVal to DDERR_VIDEONOTACTIVE and return.
     */

    /*
     * Readback whether the field is even or odd.  lpInput->bField is
     * set to TRUE if the current field is even.
     */
	//DPF("***GetVideoPortField32");
	
	if (pMySurfaces->dwVideoPortStatus == VP_NOT_RUNNING) {
		//DPF("   Video is not active!!!");
		lpInput->bField = 0;
	   lpInput->ddRVal = DDERR_VIDEONOTACTIVE;	
	} else {
	 /*
     * Readback the current line number and put it in
     * lpInput->dwLine
     */

		lpInput->bField = GetField();
		
		lpInput->ddRVal = DD_OK;

		lpInput->bField = 0;
	}	
	
	return DDHAL_DRIVER_HANDLED;
}

/*
 * GetVideoPortLine32
 *
 * This function is only required if readback of the current
 * video line number (0 relative) is supported.
 */
    /*
     * Make sure the video port is ON.  If not, set
     * lpInput->ddRVal to DDERR_VIDEONOTACTIVE and return.
     */

DWORD __stdcall GetVideoPortLine32 (LPDDHAL_GETVPORTLINEDATA lpInput)
{

	DPF("***GetVideoPortLine32");
 
 	// need channel poiner for this!
	if( GLOBDATAPTR->NvDevFlatVPE == (DWORD) NULL ) {
	 	lpInput->ddRVal = DDERR_SURFACELOST;
		return DDHAL_DRIVER_HANDLED; 
	}
	
	if (pMySurfaces->dwVideoPortStatus == VP_NOT_RUNNING) {
		//DPF("   Video is not active!!!");
		lpInput->dwLine = 0;
	   lpInput->ddRVal = DDERR_VIDEONOTACTIVE;	
	} else {
	 /*
     * Readback the current line number and put it in
     * lpInput->dwLine
     */

		lpInput->dwLine = getCurLine();
		lpInput->ddRVal = DD_OK;
		
	}	
	
	return DDHAL_DRIVER_HANDLED;
}


/*
 * GetVideoPortConnectInfo
 *
 * This is the old:
 * Returns the GUIDs describing the connections that can be supported.
 * Think of a GUID simply as a 128 bit FOURCC that you don't have to
 * register.  This function is required.

 * And this is the new:
 * Fills in specified array of connections
 *
 */
DWORD __stdcall GetVideoPortConnectInfo (LPDDHAL_GETVPORTCONNECTDATA lpInput)
{
    /*
     * If lpInput->lpGUIDs is NULL, simply return the number of GUIDS
     * supported
     */

	// eventually we should check dwPortId if there are more than one port in operation.
	// however since all the port will likely have the same capabilities maybe it's not an
	// issue
	
	DPF("***GetVideoPortConnectInfo");
	
	lpInput->dwNumEntries = 1;
	if(lpInput->lpConnect == NULL) {
		// this means that Dx is looking for the number of ways you can connect so that it can
		// allocate a structure for the next time around
		lpInput->ddRVal = DD_OK;
	} else {
		// fill in the one structure that we asked for..	
		memcpy (&(lpInput->lpConnect->guidTypeID), &DDVPTYPE_CCIR656, sizeof (GUID));
		lpInput->lpConnect->dwPortWidth = 8;
		lpInput->lpConnect->dwFlags = MY_CONNECTION_CAPS;	
	}

	return DDHAL_DRIVER_HANDLED;

}


/*
 * DestroyVideoPort32
 *
 * This optional function notifies the HAL when the video port
 * has been destroyed.
 */
DWORD __stdcall DestroyVideoPort32 (LPDDHAL_DESTROYVPORTDATA lpInput)
{
	
	DPF("***DestroyVideoPort32");

	
	pMySurfaces->ImageCallbackRoutine = NULL;			
	pMySurfaces->VBICallbackRoutine = NULL;			
		
	tearDownVP();

	nvTimerPtr = NULL;
	
	lpInput->ddRVal = DD_OK;
	
	CloseHandle(pMySurfaces->myVXDhandle);
	pMySurfaces->myVXDhandle = NULL;

	return DDHAL_DRIVER_HANDLED;
}


/*
 * GetVideoPortFlipStatus32
 *
 * This required function allows DDRAW to restrict access to a surface
 * until the physical flip has occurred, allowing doubled buffered capture.
 */

    /*
     * If the physical flip has not yet occurred, return
     * DDERR_WASSTILLDRAWING
     */

DWORD __stdcall GetVideoPortFlipStatus32 (LPDDHAL_GETVPORTFLIPSTATUSDATA lpInput)
{
	
	U032	dwIndex;
	
	//DPF("***GetVideoPortFlipStatus32");

#if 0
	if( GLOBDATAPTR->NvDevFlatVPE == NULL ) {
	 	lpInput->ddRVal = DDERR_SURFACELOST;
		return DDHAL_DRIVER_HANDLED; 
	}

#endif
	if( pMySurfaces->dwVideoPortStatus == VP_NOT_RUNNING ) {
   	lpInput->ddRVal = DD_OK;
		return DDHAL_DRIVER_HANDLED;
	}
	
	// search through all of our known surfaces looking for the one it's curious about
	for (dwIndex = 0; dwIndex < pMySurfaces->numberOfSurfaces ; dwIndex++) {
		if (pMySurfaces->Surfaces[dwIndex]->pVidMem == lpInput->fpSurface) {
			// this means we've found the surface that DX is curious about												
			if( pMySurfaces->Surfaces[dwIndex]->pNvNotify == NULL ) {
				ASSERT(1==0);
				DPF("   NOTIFY WAS NULL  !!!!!!!!!!!");
   			lpInput->ddRVal = DD_OK;
				return DDHAL_DRIVER_HANDLED;
			}
			
			
			if( pMySurfaces->Surfaces[dwIndex]->bAutoFlip ) {
				// in the case of auto-flipping just always say we're done...
				lpInput->ddRVal = DD_OK;
			} else {
				if (pMySurfaces->bFlipRequested == TRUE ) {
					lpInput->ddRVal = DDERR_WASSTILLDRAWING;
				} else {
					lpInput->ddRVal = DD_OK;
				}
			}
			// return here... we found the surface
			return DDHAL_DRIVER_HANDLED;
		}
	}
	
	DPF("   ***FlipStatus having trouble  --> Surface does");
	DPF("          not exist in my list of surfaces");
	lpInput->ddRVal = DD_OK;

	return DDHAL_DRIVER_HANDLED;
}


/*
 * FlipVideoPort32
 *
 * This function is required
 *
 * Issues:
 *			Correct use of notifiers
 *			Updating surface logging info
 *			What if new surface has not got same or less capabilites as replaced surface

 *			Does not work because class 66 doesn't allow insertion of buffers
 *
 */

/*
important:
			Curr surface should be known to us
			Targ surface could be new

			both surfaces should have this flag: DDSCAPS_LIVEVIDEO set in ->ddsCaps structure
*/
DWORD __stdcall FlipVideoPort32 (LPDDHAL_FLIPVPORTDATA lpInput)
{

    /*
     * Program registers to do the actual flip
     */

    /*
     * Save information for BOTH lpSurfCurr so we can know in the future
     * when the physical flip has occurred.
     */


	// Check that both surfaces are in our list
	U032	newSurfaceIndex;
	U032	oldSurfaceIndex;
        //	U032	counter;
	DPF("***FlipVideoPort32");
	if( GLOBDATAPTR->NvDevFlatVPE == (DWORD) NULL ) {
	 	lpInput->ddRVal = DDERR_SURFACELOST;
		return DDHAL_DRIVER_HANDLED; 
	}
	lpInput->ddRVal = DD_OK;
	
	oldSurfaceIndex = findSurface(lpInput->lpSurfCurr);
	if(oldSurfaceIndex  != SURFACENOTFOUND ) {
		newSurfaceIndex = findSurface(lpInput->lpSurfTarg);
		if(newSurfaceIndex == SURFACENOTFOUND ) {
			// in the case of non-interleaved surfaces this might be even more different
			// because we have essentially to replace TWO places where the old surface might be
			// residing...  not just one   non-auto flip SUCKS.  
			if( oldSurfaceIndex < pMySurfaces->VBIstart ) {
				replaceSurfaceWithSurface(oldSurfaceIndex,lpInput->lpSurfTarg, FALSE);
			} else {
				replaceSurfaceWithSurface(oldSurfaceIndex,lpInput->lpSurfTarg, TRUE);
			}
			newSurfaceIndex = oldSurfaceIndex;
		}
		pMySurfaces->bFlipRequested = TRUE;
		 
		if(newSurfaceIndex != SURFACENOTFOUND ) {
#if 0
			//  Now do some stuff... uh.. what?
			
			// Find out which of the buffers what programmed for the old surface
			U032	dwBufferIndex = NOSURFACEPROGRAMED;
			{
				U032 i;
				for(i=0;i<4;i++) {
					if(oldSurfaceIndex == pMySurfaces->CurrentBufferSurface[i] ) {
						dwBufferIndex = i;
						break;
					}
				}
				if (i == 4 ) {
					DPF("   Not sure which buffer was attached to the Current Surface in FlipVideoPort");
					return DDHAL_DRIVER_NOTHANDLED;
				}	
			}
			
			
			//  We could wait here until we know the hardware is done...
			//  instead we'll just check it real quick and print a whiner if it's not done
			//  and then fail
			{
				NvNotification* 	pNotify = pMySurfaces->Surfaces[oldSurfaceIndex]->pNvNotify;
				if(pNotify != NULL) {
					if (pNotify->status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS ) {
						DPF("   Attempting to flip out a surface which is still in progress");
						// we should hang out here until it's done....
						counter = 0;
						while((pNotify->status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS ) && (counter < 3000000)) {
							counter++;
						}
					}
					// check to see if we've had an error 
					//    there are LOTS of these....
					if ( (pNotify->status != NV04D_NOTIFICATION_STATUS_IN_PROGRESS ) |
						  (pNotify->status != NV04D_NOTIFICATION_STATUS_DONE_SUCCESS ) |
						  (pNotify->status != NV04D_NOTIFICATION_STATUS_NOT_LAUNCHED ) ){
						DPF("   Attempting to flip out a surface which had an error during capture");
						//return DDHAL_DRIVER_NOTHANDLED;
					}
				} else {
					DPF("   Attempting to flip out a surface where the notifier was NULL");
					return DDHAL_DRIVER_NOTHANDLED;
				}
			}

#endif			
			// Ok, program up the switch
			//ProgramBufferWithSurface(dwBufferIndex,newSurfaceIndex,FALSE);
			
		
		} else {
			DPF("   Unable to find Target Surface during FlipVideoPort32");
			DPF("   There was a note that we could be receiving new surfaces ");
			DPF("                      ( Tobin or MS ?)..... need to add code for this");
			
			return DDHAL_DRIVER_NOTHANDLED;
		}
	
	} else {
		DPF("   Unable to find Current Surface during FlipVideoPort32");
		return DDHAL_DRIVER_NOTHANDLED;
	}
  	
	lpInput->ddRVal = DD_OK;
	
	return DDHAL_DRIVER_HANDLED;
}

#if 0
U032 startSurfaces(U032	bInterleave, VPSTATE*	pVideoPortStatus ) {
	U032	rValue = DD_OK;
	VPSTATE	myState = *pVideoPortStatus;
	// figure out which buffers to program up and launch them...
	if(bInterleave) {
		 DPF("   Now Launching surfaces.... INTERLEAVED");
	} else {
		 DPF("   Now Launching surfaces.... NOT INTERLEAVED");
	}
	// zero out the last overlay scaler size so we're sure it gets reprogrammed
	pMySurfaces->lastsrcDeltaY = 0;
	pMySurfaces->bStopVP = FALSE;	
	if( bInterleave ) {
		// both buffers will point to the same surface
		if( pMySurfaces->VBIstart >0 ) {
			if( ProgramBufferWithSurface(0,0,FALSE) )
				rValue = DDERR_INVALIDPARAMS;
			
			// since this is interleave always start the second buffer with the first surface
			if( ProgramBufferWithSurface(1,0,FALSE) )
				rValue = DDERR_INVALIDPARAMS;
			myState |= VP_IMAGE_CAPTURING;
		}
	} else {
	
		// buffers will point to consecutive surfaces
		if( pMySurfaces->VBIstart >0 ) {
			if( ProgramBufferWithSurface(0,0,FALSE) )
				rValue = DDERR_INVALIDPARAMS;
			myState |= VP_IMAGE_CAPTURING;
		}
		// check for another surface
		if( pMySurfaces->VBIstart > 1 ) {
			if( ProgramBufferWithSurface(1,1,FALSE) )
				rValue = DDERR_INVALIDPARAMS;
		} else {
			// fire up the second buffer at the first surface
			if( ProgramBufferWithSurface(1,0,FALSE) )
				rValue = DDERR_INVALIDPARAMS;
		}
	}
			
	// Now do VBI
	// start first vbi on first surface
	if( (pMySurfaces->numberOfSurfaces - pMySurfaces->VBIstart) > 0 ) {
		if( ProgramBufferWithSurface(2,pMySurfaces->VBIstart,FALSE))
				rValue = DDERR_INVALIDPARAMS;
		myState |= VP_VBI_CAPTURING;
	
		// now check to see if we have another surface
		if( (pMySurfaces->numberOfSurfaces - pMySurfaces->VBIstart) > 1 ) {
			if( ProgramBufferWithSurface(3,pMySurfaces->VBIstart+1,FALSE))
					rValue = DDERR_INVALIDPARAMS;
		} else {
			// set second buffer to first surface
			if( ProgramBufferWithSurface(3,pMySurfaces->VBIstart+0,FALSE))
					rValue = DDERR_INVALIDPARAMS;
		}
	}	
	*pVideoPortStatus = myState;
	
	return rValue;
}

#endif 

U032 startNV3DelayedStart(U032	bInterleave, VPSTATE*	pVideoPortStatus, U032 milliSecondsOfDelay ) {
	
	// ain't nothing happenin here yet.

	// First thing we're goin to do is paint that surface BLACK so as folks don't be noticin' we's gonna do the
	// delay factor for our masters up at microsoft.
	
	if(milliSecondsOfDelay > 5 )
	{
		U032	n = 2;
		U032 	q;
		
		if(pMySurfaces->VBIstart <2 )
			n = 1;
		if(pMySurfaces->VBIstart <1 )
			return 0;
		for(q=0;q<n;q++) {
			// length in Long words
			U032	length = ( pMySurfaces->Surfaces[q]->dwPitch * pMySurfaces->Surfaces[q]->dwHeight ) / 4;
			U032	startOff = pMySurfaces->Surfaces[q]->pVidMem ;
			U032	i;
			U032*	pOverlay = (U032*) ((U032)startOff);
			for(i=0; i< length ; i++ ) {
			    *pOverlay = 0x10801080;
				pOverlay++;
			}
		}
	}
	
// deficiencies in NV32.h
#ifndef NV4
#define NV004_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV004_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV004_SET_ALARM_NOTIFY_WRITE_THEN_AWAKEN                   (0x00000001)
#endif
	
	nvMyVPNotifiers[NUM004OFFSET].status 		= NV04D_NOTIFICATION_STATUS_NOT_LAUNCHED;
				
#ifndef NV4
	pMySurfaces->pVPChanPtr->subchannel[0].control.object = MY_TIMER_OBJECT;
#else 
	pMySurfaces->pVPChanPtr->subchannel[0].SetObject  = MY_TIMER_OBJECT;
#endif // NV4

// get a 0.75 second delay in nanoseconds
#define NV3DELAYTIME ( milliSecondsOfDelay*1000*1000 )
	{
		U032	low;
		U032	low1;
		U032	high;
		
		getCurrentNanoTimer(&high, &low);
		low1 = low;
		
		
		low = low + NV3DELAYTIME;
		if( low < low1 ) {
			high = high + 1;
		}
#ifndef NV4
		pMySurfaces->pVPChanPtr->subchannel[0].timer.SetAlarmTime.nanoseconds[0] = low;
		pMySurfaces->pVPChanPtr->subchannel[0].timer.SetAlarmTime.nanoseconds[1] = high;
		pMySurfaces->pVPChanPtr->subchannel[0].timer.SetAlarmNotify =
			NV004_SET_ALARM_NOTIFY_WRITE_THEN_AWAKEN;

#else   //NV4
		pMySurfaces->pVPChanPtr->subchannel[0].nv01Timer.SetAlarmTime.nanoseconds[0] = low;
		pMySurfaces->pVPChanPtr->subchannel[0].nv01Timer.SetAlarmTime.nanoseconds[1] = high;
		pMySurfaces->pVPChanPtr->subchannel[0].nv01Timer.SetAlarmNotify =
			NV004_SET_ALARM_NOTIFY_WRITE_THEN_AWAKEN;
#endif  //NV4			
		
		// ok, 3/4 second later we should get a notify!
	}
	
	//return startSurfaces(bInterleave, pVideoPortStatus );
	return DD_OK;

}


/*
 * UpdateVideoPort32
 *
 * This required function sets up the video port
 */

/* Questions:
 *			What if I want VBI latching while image is not latching ?
 */
 
DWORD __stdcall UpdateVideoPort32 (LPDDHAL_UPDATEVPORTDATA lpInput)
{

	VPERRORS myErrors;
	U032		bAutoflip;
#ifndef NV4
	U032		bDelayNV3;
#endif
	
	DPF("***UpdateVideoPort32");
	if( GLOBDATAPTR->NvDevFlatVPE == (DWORD) NULL ) {
	 	lpInput->ddRVal = DDERR_SURFACELOST;
		return DDHAL_DRIVER_HANDLED; 
	}

// Since bruce changed the order of initialization, we should check if we need to reload this
	if(pMySurfaces->pOverlayChanPtr == NULL) {
		DPF("Late overlay channel update!");

#ifdef NV4
		pMySurfaces->pOverlayChanPtr = (NvChannel*) pDriverData->NvDevVideoFlatPio;
#else
		pMySurfaces->pOverlayChanPtr = (NvChannel*) pDriverData->NvDevFlatPio;
#endif	

	}
	
	
	lpInput->ddRVal = DD_OK;
		
	{		
		/*
		 * Turn off the video port
		 */
//CODE
		DPF("   now Stopping the Video Port");
		// prevent future interrupts from doing anything
		pMySurfaces->bThreadRunning = FALSE;
		// tell the classes to stop
		StopVP();
		// zero out the notifiers
		
		{
			U032 i;
			for(i=0;i<NUM04DNOTIFIER;i++ ) 
				nvMyVPNotifiers[i+NUM04DOFFSET].status = NV04D_NOTIFICATION_STATUS_NOT_LAUNCHED;
				nvMyVPNotifiers[i+NUM04DOFFSET].info32 = 0;
				nvMyVPNotifiers[i+NUM04DOFFSET].info16 = 0;
				nvMyVPNotifiers[i+NUM04DOFFSET].timeStamp.nanoseconds[0] = 0;
				nvMyVPNotifiers[i+NUM04DOFFSET].timeStamp.nanoseconds[1] = 0;
		}
		pMySurfaces->dwVideoPortStatus = VP_NOT_RUNNING;
    
	} 
	
	if (lpInput->dwFlags != DDRAWI_VPORTSTOP) { 
#ifndef NV4
		bDelayNV3 = FALSE;
#endif //NV4
		if (lpInput->dwFlags == DDRAWI_VPORTSTART) {
			DPF("   now Starting Video Port for the first time");

		// This is the first round....
#ifndef NV4
			bDelayNV3 = TRUE;
#endif	//NV4

		} 
		
		DPF("   now updating the video port");

		{
			
			
			// print some stuff out about the flags we're lookin at:
			if( pMySurfaces->bInvertedFields ) {
				DPF("      field polarity               inverted");	
			} else {
				DPF("      field polarity               normal");	
			}
			
			if(lpInput->lpVideoInfo->dwVPFlags & DDVP_AUTOFLIP	) {
				DPF("      FLAG DVP_AUTOFLIP            on");	
			} else {
				DPF("      FLAG DVP_AUTOFLIP            off");	
			}
			if(lpInput->lpVideoInfo->dwVPFlags & DDVP_CONVERT		) {
				DPF("      FLAG DDVP_CONVERT            on");	
			} else {
				DPF("      FLAG DDVP_CONVERT            off");	
			}
			if(lpInput->lpVideoInfo->dwVPFlags & DDVP_CROP					) {
				DPF("      FLAG DDVP_CROP               on");	
			} else {
				DPF("      FLAG DDVP_CROP               off");	
			}
			if(lpInput->lpVideoInfo->dwVPFlags & DDVP_INTERLEAVE			) {
				DPF("      FLAG DDVP_INTERLEAVE         on");	
			} else {
				DPF("      FLAG DDVP_INTERLEAVE         off");	
			}
			if(lpInput->lpVideoInfo->dwVPFlags & DDVP_MIRRORLEFTRIGHT		) {
				DPF("      FLAG DDVP_MIRRORLEFTRIGHT    on");	
			} else {
				DPF("      FLAG DDVP_MIRRORLEFTRIGHT    off");	
			}
			if(lpInput->lpVideoInfo->dwVPFlags & DDVP_MIRRORUPDOWN			) {
				DPF("      FLAG DDVP_MIRRORUPDOWN       on");	
			} else {
				DPF("      FLAG DDVP_MIRRORUPDOWN       off");	
			}
			if(lpInput->lpVideoInfo->dwVPFlags & DDVP_PRESCALE				) {
				DPF("      FLAG DDVP_PRESCALE           on");	
			} else {
				DPF("      FLAG DDVP_PRESCALE           off");	
			}
			if(lpInput->lpVideoInfo->dwVPFlags & DDVP_SKIPEVENFIELDS		) {
				DPF("      FLAG DDVP_SKIPEVENFIELDS     on");	
			} else {
				DPF("      FLAG DDVP_SKIPEVENFIELDS     off");	
			}
			if(lpInput->lpVideoInfo->dwVPFlags & DDVP_SKIPODDFIELDS			) {
				DPF("      FLAG DDVP_SKIPODDFIELDS      on");	
			} else {
				DPF("      FLAG DDVP_SKIPODDFIELDS      off");	
			}
			if(lpInput->lpVideoInfo->dwVPFlags & DDVP_SYNCMASTER				) {
				DPF("      FLAG DDVP_SYNCMASTER         on");	
			} else {
				DPF("      FLAG DDVP_SYNCMASTER         off");	
			}
			if(lpInput->lpVideoInfo->dwVPFlags & DDVP_VBICONVERT				) {
				DPF("      FLAG DDVP_VBICONVERT         on");	
			} else {
				DPF("      FLAG DDVP_VBICONVERT         off");	
			}
			if(lpInput->lpVideoInfo->dwVPFlags & DDVP_VBINOSCALE				) {
				DPF("      FLAG DDVP_VBINOSCALE         on");	
			} else {
				DPF("      FLAG DDVP_VBINOSCALE         off");	
			}
			if(lpInput->lpVideoInfo->dwVPFlags & DDVP_OVERRIDEBOBWEAVE		) {
				DPF("      FLAG DDVP_OVERRIDEBOBWEAVE   on");	
			} else {
				DPF("      FLAG DDVP_OVERRIDEBOBWEAVE   off");	
			}
			if(lpInput->lpVideoInfo->dwVPFlags & DDVP_IGNOREVBIXCROP		) {
				DPF("      FLAG DDVP_IGNOREVBIXCROP     on");	
			} else {
				DPF("      FLAG DDVP_IGNOREVBIXCROP     off");	
			}
			
		
		}
		
		// Decide which capture mode to be in given if we're trying to skip some types of fields
		
		
		if( lpInput->lpVideoInfo->dwVPFlags & DDVP_SKIPEVENFIELDS ) {
			pMySurfaces->CurrentCaptureMode = ODDODD;
		} else if ( lpInput->lpVideoInfo->dwVPFlags & DDVP_SKIPODDFIELDS ) {
			pMySurfaces->CurrentCaptureMode = EVENEVEN;
		} else {
			if(pMySurfaces->bInputInterLaced)
				pMySurfaces->CurrentCaptureMode = EVENODD;
			else
				pMySurfaces->CurrentCaptureMode = PROGRESSIVE;
		}
		
		if( lpInput->lpVideoInfo->dwVPFlags & DDVP_AUTOFLIP ) {
			bAutoflip = TRUE;
		} else {
			bAutoflip = FALSE;
		}
		
		if( lpInput->lpVideoInfo->dwVPFlags & DDVP_INTERLEAVE ) {
			pMySurfaces->CurrentScanMode = INTERLEAVBUF;
		} else {
			pMySurfaces->CurrentScanMode = SEPERATEBUF;
		}
		
		{	
			// Here's where we're going to try to figure out where to put things in the vertical and horz
			// dimensions
			
			// At key thing here are the two different modes which people are using to capture VBI
			// one is that the VBI data is captured to the very beginning of the VIDEO surface in one big surface
			// the other mode is with a seperate surface
			
			// we can detect which mode by examining the number of VBI surface if > 0 we're in the second mode
		
			// When there ARE VBI surfaces, then we should jam the Video data right to the very beginning of the
			// video surface, since we know this is where it will be expected.
			
			// additionally we've reported DDVPCONNECT_DISCARDSVREFDATA is true which means 
			// "/*
			//	 * Indicates that any data written to the video port during the VREF
			//	 * period will not be written into the frame buffer. This flag is read only.
			//	 */"
		   //  MS of course not really defining what the VREF period means in their land.
			
				
#define VBIVALIDDATALINE  (0x2)	

			
			if( lpInput->lplpDDVBISurface == NULL ) {
				// this indicates that there are NO VBI surfaces associated with this video port update.
				// therefore we should send all the line to the Image surface
				
				
				pMySurfaces->dwImageStartLine = 0;	// send all the data after line 0
				
				if ( lpInput->lpVideoInfo->dwVPFlags & DDVP_CROP ) {
					if(lpInput->lpVideoInfo->rCrop.top > (signed long) pMySurfaces->dwImageStartLine ) {
						pMySurfaces->dwImageStartLine = lpInput->lpVideoInfo->rCrop.top;
					}
				}
				
			} else {
				// there are some VBI surfaces associated with this video port,
				// so we should send the data to the VBI surfaces where applicable
				pMySurfaces->dwVBIStartLine = VBIVALIDDATALINE;	// at least we're not starting with zero this first four are always
																			// empty as best as I know
			
				pMySurfaces->dwVBIHeight = lpInput->lpVideoInfo->dwVBIHeight;
			
				// Image start line should be one line after the the sum of these two
				pMySurfaces->dwImageStartLine = 1 + pMySurfaces->dwVBIHeight + pMySurfaces->dwVBIStartLine - VBIVALIDDATALINE;
				// if  	dwImageStartLine < 1  then things don't work to well
				if(pMySurfaces->dwImageStartLine < 1) pMySurfaces->dwImageStartLine = 1;
				
				if ( lpInput->lpVideoInfo->dwVPFlags & DDVP_CROP ) {
					if(lpInput->lpVideoInfo->rCrop.top > (signed long) pMySurfaces->dwImageStartLine ) {
						pMySurfaces->dwImageStartLine = lpInput->lpVideoInfo->rCrop.top;
					}
				}
			}
						
			
			
			// this is the only way I know how to do the check for vertical cropping
			if ( lpInput->lpVideoInfo->dwVPFlags & DDVP_CROP ) {
				pMySurfaces->dwInHeight = (DWORD)lpInput->lpVideoInfo->rCrop.bottom - lpInput->lpVideoInfo->rCrop.top;				
				pMySurfaces->dwInWidth  = lpInput->lpVideoInfo->rCrop.right - lpInput->lpVideoInfo->rCrop.left;		
				DPF("   UPDATE:         crop TOP %d",lpInput->lpVideoInfo->rCrop.top);						
			} else {
				pMySurfaces->dwInHeight = lpInput->lpVideoPort->ddvpDesc.dwFieldHeight;
				pMySurfaces->dwInWidth  = lpInput->lpVideoPort->ddvpDesc.dwFieldWidth;
			}
			
			// this is something of a hack I suppose
			pMySurfaces->dwInHeight = pMySurfaces->dwInHeight;			
						
			// if we're prescaling then do something
			if (DDVP_PRESCALE & lpInput->lpVideoInfo->dwVPFlags) {
				pMySurfaces->dwPreHeight = lpInput->lpVideoInfo->dwPrescaleHeight;				
				pMySurfaces->dwPreWidth  = lpInput->lpVideoInfo->dwPrescaleWidth;
			} else {
				pMySurfaces->dwPreHeight = pMySurfaces->dwInHeight;
				pMySurfaces->dwPreWidth = pMySurfaces->dwInWidth;
			}
			
			
			pMySurfaces->dwOriginX = lpInput->lpVideoInfo->dwOriginX;
			pMySurfaces->dwOriginY = lpInput->lpVideoInfo->dwOriginY;
		}
		
		switch (pMySurfaces->CurrentCaptureMode) {
				case EVENODD:
					DPF("   UPDATE:     capture mode EVENODD");	
					break;
				case EVENEVEN:
					DPF("   UPDATE:     capture mode EVENEVEN");							
					break;
				case ODDODD:
					DPF("   UPDATE:     capture mode ODDODD");	
					break;
		}
		switch (pMySurfaces->CurrentScanMode) {
				case SEPERATEBUF:
					DPF("   UPDATE:        scan mode SEPERATEBUF");	
					break;
				case INTERLEAVBUF:
					DPF("   UPDATE:        scan mode INTERLEAVBUF");	
					break;
		}
		
		DPF("   UPDATE: image start line %d",pMySurfaces->dwImageStartLine);
		DPF("   UPDATE: image in dimens %d,%d",pMySurfaces->dwInWidth,pMySurfaces->dwInHeight);
		DPF("   UPDATE: image pre dimens %d,%d",pMySurfaces->dwPreWidth,pMySurfaces->dwPreHeight);
		DPF("   UPDATE:   image position %d,%d",pMySurfaces->dwOriginX,pMySurfaces->dwOriginY);

		myErrors = replaceSurfaceList(lpInput->dwNumAutoflip,lpInput->dwNumVBIAutoflip,
										lpInput->lplpDDSurface, lpInput->lplpDDVBISurface,bAutoflip);
		
		pMySurfaces->dwVPFlags = lpInput->lpVideoInfo->dwVPFlags;
		if( myErrors == NOVPERROR ) {
#ifndef NV4
			if(bDelayNV3) {
				lpInput->ddRVal = startNV3DelayedStart(lpInput->lpVideoInfo->dwVPFlags & DDVP_INTERLEAVE, &(pMySurfaces->dwVideoPortStatus), 1000*3/4);
				
			
			} else {
				lpInput->ddRVal = startNV3DelayedStart(lpInput->lpVideoInfo->dwVPFlags & DDVP_INTERLEAVE, &(pMySurfaces->dwVideoPortStatus), 0);
				
				//lpInput->ddRVal = startSurfaces( lpInput->lpVideoInfo->dwVPFlags & DDVP_INTERLEAVE, &(pMySurfaces->dwVideoPortStatus));
			}
#else
			{
				lpInput->ddRVal = startNV3DelayedStart(lpInput->lpVideoInfo->dwVPFlags & DDVP_INTERLEAVE, &(pMySurfaces->dwVideoPortStatus), 0);
				
				//lpInput->ddRVal = startSurfaces( lpInput->lpVideoInfo->dwVPFlags & DDVP_INTERLEAVE, &(pMySurfaces->dwVideoPortStatus));
			}
#endif //NV4
#ifndef NV4
						
		} else {
			DPF("   Problem updating the Video Port = %d",myErrors);

			switch (myErrors) {
					case CANTCREATESURFACE:
						lpInput->ddRVal = DDERR_OUTOFMEMORY;
						break;
					case TOOMANYSURFACESERROR:
					case  SURFACENOTFOUND:
					default:
						lpInput->ddRVal = DDERR_INVALIDPARAMS;
						break;
			}
				
			return DDHAL_DRIVER_HANDLED;
	
		
			
#endif //NV4
		}	// NOVPERROR
	}  // DDRAWI_VPORTSTOP

	// this is sort of a big hack since things aren't actually running yet, but DirectShow seems to require it
	pMySurfaces->dwVideoPortStatus = VP_BOTH_CAPTURING;
	
	return DDHAL_DRIVER_HANDLED;
}



/*
 * GetVideoSignalStatus32
 *
 * This function is required
 */
 
DWORD __stdcall GetVideoSignalStatus32 ( LPDDHAL_GETVPORTSIGNALDATA lpInput) {	
	
	U032	dwIndex;
	ASSERT(lpInput != NULL);

	DPF("***GetVideoSignalStatus32");
	if( GLOBDATAPTR->NvDevFlatVPE == (DWORD) NULL ) {
	 	lpInput->ddRVal = DDERR_SURFACELOST;
		return DDHAL_DRIVER_HANDLED; 
	}
	
	if( lpInput == NULL)
	{
		DPF("   Input NULL in GetVideoSignalStatus32");
		return DDHAL_DRIVER_NOTHANDLED;
	}
	// If the video port is not running, then we just don't know...
	if( pMySurfaces->dwVideoPortStatus == VP_NOT_RUNNING ) {
		DPF("   could not get the signal status, the video port is not running");
		// we'll return no signal in this case....
		lpInput->dwStatus = DDVPSQ_NOSIGNAL;
		lpInput->ddRVal = DDERR_VIDEONOTACTIVE;

		return DDHAL_DRIVER_HANDLED;
	}
	
	lpInput->ddRVal = DD_OK;
	// default for now is that the signal is good
	lpInput->dwStatus = DDVPSQ_SIGNALOK;
	// first check the notifiers to see if there has been ANY sync
	//     do this by seeing if the notify times are none zero

return DDHAL_DRIVER_HANDLED;
	
	{
		U032	probablyRunning = FALSE;
		for (dwIndex=0;dwIndex<pMySurfaces->numberOfSurfaces;dwIndex++) {
			if( pMySurfaces->Surfaces[dwIndex]->pNvNotify != NULL ) {
				if (pMySurfaces->Surfaces[dwIndex]->pNvNotify->timeStamp.nanoseconds[0]!=0) {
					probablyRunning = TRUE;
					break;
				}
			}
		}
		
		// if the timer are zero then wait at least 1/24 of a second and check again.
		if(!probablyRunning) {
			// find current time
			U032	 tempTime;
			tempTime = getMilliTime();
			//now wait for 1/24 of a second
			while(tempTime + (1000/24) > getMilliTime()); 
			// and then check one more time for a possible completion
			for (dwIndex=0;dwIndex<pMySurfaces->numberOfSurfaces;dwIndex++) {
				if( pMySurfaces->Surfaces[dwIndex]->pNvNotify != NULL ) {
					if (pMySurfaces->Surfaces[dwIndex]->pNvNotify->timeStamp.nanoseconds[0]!=0) {
						probablyRunning = TRUE;
						break;
					}
				}
			}
			
			// if it's still non zero report no signal
			if(!probablyRunning) {
				lpInput->dwStatus = DDVPSQ_NOSIGNAL;
			}

		}	
	}
	
	// have we already decided that the signal is bad...?
	if( lpInput->dwStatus != DDVPSQ_NOSIGNAL ) {
		
		// Now the default is that the signal is bad
		lpInput->dwStatus = DDVPSQ_NOSIGNAL;
		
		// check to see that at least one of of the notifiers is LESS than 1/24 of a second
		// hopefully there's been _some_ event in video land in the last 1/24 of a second
		for (dwIndex=0;dwIndex<pMySurfaces->numberOfSurfaces;dwIndex++) {
			if( pMySurfaces->Surfaces[dwIndex]->pNvNotify != NULL ) {
				if (pMySurfaces->Surfaces[dwIndex]->pNvNotify->timeStamp.nanoseconds[0]!=0) {
					U032 diff;
					// ok, we've got a non-zero surface, let's check to see how recent it is
					U032	BigCurrentTime;
					U032	SmallCurrentTime;
					
					getCurrentNanoTimer(&BigCurrentTime,&SmallCurrentTime);
					if(pMySurfaces->Surfaces[dwIndex]->pNvNotify->timeStamp.nanoseconds[1] < BigCurrentTime ) {
						// we've got a wrap around situation.  this means that we need to work in weirder math
						diff = (
									((0x80000000)  - (pMySurfaces->Surfaces[dwIndex]->pNvNotify->timeStamp.nanoseconds[0] >> 1))
									+  (SmallCurrentTime >> 1)
								 ) << 1;
					} else {
						// do a simple subtraction
						diff = SmallCurrentTime - pMySurfaces->Surfaces[dwIndex]->pNvNotify->timeStamp.nanoseconds[0];
					}
					//diff now has the delta between the notify and "now"  
					// if the notifier is LESS than a frame period then we've got a signal
					if(diff < MAXFRAMEPERIOD ) {
						lpInput->dwStatus = DDVPSQ_SIGNALOK;
					} else {
						diff = 0;
						// this is a place for chris's break point's while debugging
					}
					
				}
			}
		}

	}
	
	return DDHAL_DRIVER_HANDLED;
}


/*
 * WaitForVideoPortSync32
 *
 * This function is required
 */


DWORD __stdcall WaitForVideoPortSync32 (LPDDHAL_WAITFORVPORTSYNCDATA lpInput)
{
	DPF("***WaitForVideoPortSync32");
	
	if( GLOBDATAPTR->NvDevFlatVPE == (DWORD) NULL ) {
	 	lpInput->ddRVal = DDERR_SURFACELOST;
		return DDHAL_DRIVER_HANDLED; 
	}
	
	lpInput->ddRVal = DDVPSQ_NOSIGNAL;
	
	// if the port is running then
	if (pMySurfaces->dwVideoPortStatus != VP_NOT_RUNNING) {
		if( lpInput->dwFlags & DDVPWAIT_BEGIN ) {
			// wait for a vsync start.   timeout in lpInput->dwTimeOut
			U032	bigTime;
			U032	smallTime;
			U032	milliTime;
			U032	recentTime[MAXVPSURFACES];
			U032 	dwIndex;
			U032	searchMAX;
	
		// find out what time it is now
			getCurrentNanoTimer(&bigTime, &smallTime);
			milliTime = getMilliTime();
			
			if( pMySurfaces->VBIstart == 0 ) {
				// we're only running VBI so check ALL the surfaces
				searchMAX = pMySurfaces->numberOfSurfaces;
			} else {
				// there is at least one image surface, so check for that
				searchMAX = pMySurfaces->VBIstart;
			}
			//find the current notifiers for the IMAGE surfaces
			for (dwIndex=0;dwIndex<searchMAX;dwIndex++) {
				if( pMySurfaces->Surfaces[dwIndex]->pNvNotify != NULL ) {
					recentTime[dwIndex] = pMySurfaces->Surfaces[dwIndex]->pNvNotify->timeStamp.nanoseconds[0];
				} else {
					recentTime[dwIndex] = 0;
				}
			}
			while( (getMilliTime() < ( milliTime + lpInput->dwTimeOut)) && ( lpInput->ddRVal == DDVPSQ_NOSIGNAL) ) {
				for (dwIndex=0;dwIndex<searchMAX;dwIndex++) {
					if( pMySurfaces->Surfaces[dwIndex]->pNvNotify != NULL ) {
						if( recentTime[dwIndex] < pMySurfaces->Surfaces[dwIndex]->pNvNotify->timeStamp.nanoseconds[0] ) {
							// ok, ONE Of the notifiers moved foward
							lpInput->ddRVal = DD_OK; 	//  We found a sync
						}
					}
				}
			}
			// start a while		
		} else if (lpInput->dwFlags & DDVPWAIT_END ) {
			//  timeout in lpInput->dwTimeOut
			// we could wait for ysync that then see which buffer we're on then wait for the line counter
			// to change  .. YUCK
			DPF("   Sorry, don't handle waiting for the end");
	
			return DDHAL_DRIVER_NOTHANDLED;
		} else if (lpInput->dwFlags & DDVPWAIT_LINE ) {
			//timeout in lpInput->dwTimeOut
				// lpInput ->dwLine
			DPF("   Sorry, can't wait for a particular line");
			return DDHAL_DRIVER_NOTHANDLED;
		};
		
	}// videoport status
	
	return DDHAL_DRIVER_HANDLED;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\inc\GLOBAL.H ===
#ifndef _global_h // multiple include protection
#define _global_h

//////////////////////////////////////////////////////////////////////////////
// global flags
//
#define FS_MMX          0x00000001      //  ) do not change - some code 
#define FS_KATMAI       0x00000002      // )          relies on these values

//////////////////////////////////////////////////////////////////////////////
// All globals go into the 'global' structure. We divie the big structure up into
// banks. Every bank is a multiple of 32 bytes big. We place globals that are used 
// together in inner loops in the same bank. This way we minimize pentium cache 
// misses
//
// we assume that this structure starts 32-byte aligned. Will be so once all globs 
// are placed here - and the C libraries do not mess with us... Look at .map output
// for alignment info
//
#pragma pack(push,1) // we control alignment
typedef struct {
//////////
// debug and retail banks
    // bank 1
    PNVD3DCONTEXT pCurrentContext;
    DWORD         nvFifo;
    DWORD         nvFreeCount;
    DWORD         nvDmaPushOffsetMax;
    DWORD         nvDmaPushBase;
    DWORD         nvDmaLastPutAddr;
    DWORD         nvDmaMinPushCount;
    DWORD         dwCPUFeatureSet;

#ifdef NV_FASTLOOPS
    // bank 2.0
    DWORD         dwPrimCount;          // # of primitives to render
    DWORD         dwStrides;            // primitive stride info
    DWORD         pVertices;            // vertex base
    DWORD         pIndices;             // index base
    DWORD         dwIndex0;             // )
    DWORD         dwIndex1;             //  ) current index
    DWORD         dwIndex2;             // )
    DWORD         dwVertexSN;           // current vertex cache serial number
    // bank 2.1
    DWORD         dwVertex0;            // )
    DWORD         dwVertex1;            //  ) current vertex
    DWORD         dwVertex2;            // )
    DWORD         dwPrimSubCount;       // # of primitives in this batch
    DWORD        *pdwUVOffset;          // dx6 uv coord offset array
    DWORD         dwStripFanData;       // strip & fan storage (cull history & cull sense)
    DWORD         dwCullMask1;          //  ) cull masks
    DWORD         dwCullMask2;          // )
    // bank 2.2
    DWORD         dwTemp;               // temp for culling and fog calculations
    float         fRWFar;               // fixed w buffer scale
    DWORD         dwSpecCurr;           // )
    DWORD         dwBlend;              //  ) spec hack
    DWORD         dwSpecCount;          //  )
    DWORD         dwSpecularState;      // )
    DWORD         _pad2_2[2];
    // bank 2.3
    DWORD         dwVertexCache[16];    // vertex cache
    // bank 2.4
    float         fFogTableDensity;     // )
    float         fFogTableLinearScale; //  )
    float         fFogTableEnd;         //   ) fog parameters
    float         fFogC1;               //  )
    float         fFogC2;               // )
    DWORD         dwWMask1;             // ) w parameters
    DWORD         dwWMask2;             // )
    float         fTriangleArea;
    // bank 2.5
    DWORD         dwVertexGatherBuf[8];
    // bank 2.6
    DWORD         dwVertexGatherBuf2[3];
    BYTE*         dwILCData;
    DWORD         dwILCCount;
    DWORD         dwILCMax;
    DWORD         dwMemCopyOffset;
    float         fCTC1;
    DWORD         _pad2_6[1];
#else //!NV_FASTLOOPS
    // bank 2.1
    DWORD         dwVertexSN;
    DWORD         _pad2_1[7];
    // bank 2.2
    DWORD         dwVertexCache[16];
#endif //!NV_FASTLOOPS

#ifdef  NVD3D_DX6
    // bank 3
    NVD3DFVFDATA    fvfData;
#endif  // NVD3D_DX6

    // bank 4
    DWORD         dwProcessorSpeed;
    DWORD         dwHWTextureDate;
    DWORD         dwSWTextureDate;
    DWORD         _pad2[3];

//////////
// debug only banks
#ifdef _DEBUG
#endif

} global_struc;
extern global_struc global;
#pragma pack(pop)

//////////////////////////////////////////////////////////////////////////////
// To simplify implementation, the #define list below alias original names
#define nvDmaPushOffsetMax              global.nvDmaPushOffsetMax
#define nvDmaPushBase                   global.nvDmaPushBase
#define nvDmaLastPutAddr                global.nvDmaLastPutAddr
#define VCacheSerialNumber              global.VCacheSerialNumber
#define nvFifo                          global.nvFifo
#define nvFreeCount                     global.nvFreeCount
#define nvDmaMinPushCount               global.nvDmaMinPushCount
#define pCurrentContext                 global.pCurrentContext

#ifndef NV_FASTLOOPS
#define dwVertexSN                      global.dwVertexSN
#define dwVertexCache                   global.dwVertexCache
#endif //!NV_FASTLOOPS

#ifdef  NVD3D_DX6
#define fvfData                         global.fvfData
#endif  // NVD3D_DX6


//////////////////////////////////////////////////////////////////////////////
// this function initializes globals - see global.c
void init_globals (void);

//////////////////////////////////////////////////////////////////////////////
// Inter Process Memory
void* AllocIPM (unsigned size);
void* ReallocIPM (void* ptr,unsigned size);
void FreeIPM (void* ptr);
void DestroyIPM (void);

//////////////////////////////////////////////////////////////////////////////
// nvidia mem copy
#define NV_MEMCOPY_DONTCARE             0   // default to dest aligned
#define NV_MEMCOPY_WANTSRCALIGNED       1
#define NV_MEMCOPY_WANTDESTALIGNED      2

void nvMemCopy  (DWORD dwDest,DWORD dwSrc,DWORD dwCount,DWORD dwFlags);
void nvMemTouch (DWORD dwSrc,DWORD dwCount);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\inc\D3DINC.H ===
#ifndef _D3DINC_H_
#define _D3DINC_H_
/*
 * (C) Copyright NVIDIA Corporation Inc., 1996,1997. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: D3DINC.H                                                          *
*   NV specific direct 3d structure definitions.                            *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Eugene Lapidous             ??/??/96 - wrote it.                    *
*       Charles Inman (chasi)       01/02/97 - re-wrote and cleaned up.     *
*                                                                           *
\***************************************************************************/

/*
 * --------------------------------------------------------------------------
 * Vertex cache.
 * --------------------------------------------------------------------------
 */
#define VINDEX_MASK                 0x0F

/*
 * --------------------------------------------------------------------------
 * Data Cache macros
 * --------------------------------------------------------------------------
 */
#define PREFETCH(address)       ((volatile DWORD)*(DWORD*)(address))

/*
 * --------------------------------------------------------------------------
 * Texture heap management defines and structures.
 * --------------------------------------------------------------------------
 */
typedef struct _def_tex_heap_header TEXHEAPHEADER, *PTEXHEAPHEADER;

#define PACKCHARS(c0, c1, c2, c3)               \
    (((DWORD)(unsigned char)(c0))       |       \
     ((DWORD)(unsigned char)(c1) << 8)  |       \
     ((DWORD)(unsigned char)(c2) << 16) |       \
     ((DWORD)(unsigned char)(c3) << 24))

#define HEAP_SHARED                 0x04000000UL    // put heap in shared memory
#define HEAP_SIZE_ADJUST            0x00100000
#define HEAP_TAG_FREE               PACKCHARS('F', 'R', 'E', 'E')
#define HEAP_TAG_ALLOC              PACKCHARS('L', 'O', 'C', 'K')

struct _def_tex_heap_header
{
    DWORD           dwTag;
    DWORD           dwBlockSize;
    DWORD           dwBlockStartOffset;
    DWORD           dwReserved;
    PTEXHEAPHEADER  pNextFreeBlock;
    PTEXHEAPHEADER  pPrevFreeBlock;
    PTEXHEAPHEADER  pNextAllocBlock;
    PTEXHEAPHEADER  pPrevAllocBlock;
};

/*
 * --------------------------------------------------------------------------
 * General purpose constants
 * --------------------------------------------------------------------------
 */
#define CONTEXT_ARRAY_SIZE          64
#define CONTEXT_ARRAY_DELTA         64
#define TEXTURE_ARRAY_SIZE          256
#define TEXTURE_ARRAY_DELTA         256
#ifndef OLDSTUFF
#define AGPLIST_ARRAY_SIZE          1000
#else
#define AGPLIST_ARRAY_SIZE          256
#endif
#define AGPLIST_ARRAY_DELTA         256
#define NVD3D_DEFAULT_TL_NUM        0           // was: ((32 * 2048) / sizeof(D3DTLVERTEX))

#define MAX_STATE                   D3DSTATE_OVERRIDE_BIAS
#define DWORD_BITS                  32
#define DWORD_SHIFT                 5

#ifdef  DO_XF_LIGHT
#define PIPELINE_ARRAY_SIZE         64
#define PIPELINE_ARRAY_DELTA        64
#define MATERIAL_ARRAY_SIZE         64
#define MATERIAL_ARRAY_DELTA        64
#endif  // DO_XF_LIGHT

/*
 * --------------------------------------------------------------------------
 *  Data structures.
 * --------------------------------------------------------------------------
 */

/*
 * DWORD triangle
 */
typedef struct NVD3DTRIANGLE {
    union {
        struct {
            WORD v1,v2;
        };
        DWORD v1v2;
    };
    union {
        struct {
            WORD v3,wFlags;
        };
        DWORD v3wFlags;
    };
} NVD3DTRIANGLE,*LPNVD3DTRIANGLE;

/*
 * Define function pointer prototypes.
 */
typedef void  (*LPNVDRAWTRI) (DWORD, LPWORD, DWORD, DWORD, LPD3DTLVERTEX);
typedef void  (*PFNDRAWPRIMITIVEOP)(DWORD, LPD3DTLVERTEX);
typedef void  (*PFNDRAWINDEXPRIMITIVEOP)(DWORD, LPWORD, LPD3DTLVERTEX);

#ifdef  DO_XF_LIGHT
/*
 * Define the pipeline flags.
 */
typedef struct _def_nv_d3d_pipeline  NVD3DPIPELINE, *PNVD3DPIPELINE;

struct _def_nv_d3d_pipeline
{
    DWORD                       pid;            /* Process ID */
    DWORD                       hContext;       /* Context Handle */
};

/*
 * Define the material flags.
 */
typedef struct _def_nv_d3d_material  NVD3DMATERIAL, *PNVD3DMATERIAL;

struct _def_nv_d3d_material
{
    DWORD                       pid;            /* Process ID */
    DWORD                       hContext;       /* Context Handle */
};
#endif  // DO_XF_LIGHT

/*
 * Define structure type definitions.
 */
typedef struct _def_nv_d3d_texture              NVD3DTEXTURE, *PNVD3DTEXTURE;
typedef struct _def_nv_d3d_context              NVD3DCONTEXT, *PNVD3DCONTEXT;
typedef struct _def_nv_d3d_context_inner_loop   NVD3DCONTEXTINNERLOOP, *PNVD3DCONTEXTINNERLOOP;

/*
 * D3D state set data.
 */
typedef struct _nv_d3d_state_set
{
    DWORD   bits[MAX_STATE >> DWORD_SHIFT];
} NVD3DSTATESET;

/*
 * Hardware Independant Texture Flags
 * Flags specifing that a special work around is required for this texture.
 */
#define NV_TEXTURE_DEBUG_01_HEAVY_GEAR  0x00000001  // Heavy Gear Patch Color Key Workaround.

/*
 * Include hardware specific include files here.
 * In order to be compatible with old source code, these need to be
 * included here.
 */
#ifdef  NV4
#include "nv4dinc.h"
#endif  // NV4

/*
 * --------------------------------------------------------------------------
 * External data declarations.
 * --------------------------------------------------------------------------
 */
#include "global.h"

/*
 * Some statistical values.
 */

// omnitemporal texture counts
extern DWORD   statTextureOmniCountTotal;
extern DWORD   statTextureOmniCountPalette;

// omnitemporal texture sizes
extern DWORD   statTextureOmniSizeTotal;
extern DWORD   statTextureOmniSizePalette;

// extant texture counts
extern DWORD   statTextureCountTotal;
extern DWORD   statTextureCountVideo;
extern DWORD   statTextureCountAgpHeap;
extern DWORD   statTextureCountPciHeap;
extern DWORD   statTextureCountCache;

// extant texture sizes
extern DWORD   statTextureSizeTotal;
extern DWORD   statTextureSizeVideo;
extern DWORD   statTextureSizeAgpHeap;
extern DWORD   statTextureSizePciHeap;
extern DWORD   statTextureSizeCache;

// texture dimensions
extern DWORD   statTextureDimensionMinVideo;
extern DWORD   statTextureDimensionMinAgpHeap;
extern DWORD   statTextureDimensionMinPciHeap;
extern DWORD   statTextureDimensionMinCache;
extern DWORD   statTextureDimensionMaxVideo;
extern DWORD   statTextureDimensionMaxAgpHeap;
extern DWORD   statTextureDimensionMaxPciHeap;
extern DWORD   statTextureDimensionMaxCache;

// dma stats
extern DWORD   statDmaSyncLoop;
extern DWORD   statDmaSyncOverflow;
extern DWORD   statDmaBusyLoop;
extern DWORD   statDmaBusyOverflow;
extern DWORD   statDmaFlushLoop;
extern DWORD   statDmaFlushOverflow;

/*
 * --------------------------------------------------------------------------
 *  Prototypes.
 * --------------------------------------------------------------------------
 */

/*
 * d3dmini.c
 */
//BOOL __stdcall D3DGetDriverInfo(LPDDHAL_GETDRIVERINFODATA);
void D3DReadRegistry(void);
void D3DModifyCapabilities(D3DHAL_GLOBALDRIVERDATA  *pNvGlobal);
BOOL CreateItemArrays(void);

/*
 * d3dctxt.c
 */
BOOL  nvCreateContextListHeap(void);
BOOL  nvDestroyContextListHeap(void);
DWORD __stdcall nvContextCreate(LPD3DHAL_CONTEXTCREATEDATA);
DWORD __stdcall nvContextDestroy(LPD3DHAL_CONTEXTDESTROYDATA);
DWORD __stdcall nvContextDestroyAll(LPD3DHAL_CONTEXTDESTROYALLDATA);
void  nvAllocDefaultTexture(PNVD3DCONTEXT);
void  nvFreeDefaultTexture(PNVD3DCONTEXT);
void  nvD3DReenable();
BOOL  nvSetContextSurface(PNVD3DCONTEXT);
BOOL  nvSetupContext(PNVD3DCONTEXT);
BOOL  nvFinalContextCleanup(void);

/*
 * d3drendr.c
 */
void  nvDMAStartTransfer(void);
#ifndef WINNT
DWORD __stdcall nvRenderState(LPD3DHAL_RENDERSTATEDATA);
#endif
DWORD __stdcall nvSetRenderTarget(LPD3DHAL_SETRENDERTARGETDATA);
#ifndef WINNT
DWORD __stdcall nvRenderPrimitive(LPD3DHAL_RENDERPRIMITIVEDATA);
#endif
DWORD nvSetContextState(DWORD, DWORD, HRESULT *);
BOOL  nvSetHardwareState();
void  nvResetContext(PNVD3DTEXTURE);
DWORD __stdcall nvGetDmaFreeCount(long);
void  nvStartDmaBuffer(BOOL);
void  nvFlushDmaBuffers(void);
BOOL  nvD3DClearZBuffer(LPDDRAWI_DDRAWSURFACE_LCL, DWORD);

/*
 * d3dtex.c
 */

#ifdef NV_TEX2
/*
 * ver 2.0
 */
#define NV4_TEXWAIT_READACCESS      1
#define NV4_TEXWAIT_WRITEACCESS     2
#define NV4_TEXWAIT_AVAILABLENOW    4   // when semaphore is seen the resource is available
#define NV4_TEXWAIT_AVAILABLEAFTER  0   // resource is available after the next semaphore is seen

BOOL  nvTextureRef           (PNVD3DTEXTURE);
BOOL  nvTextureTestBlock     (DWORD); // report if we need to stall CPU until given texture is not in use
void  nvTextureBlock         (DWORD); // stall CPU until given texture is not in use
void  nvTextureSetBlockPoint (void);

DWORD nvTextureBlt          (LPDDHAL_BLTDATA);
DWORD nvTextureLock         (PNVD3DTEXTURE,LPDDHAL_LOCKDATA);
DWORD nvTextureUnlock       (PNVD3DTEXTURE,LPDDHAL_UNLOCKDATA);

BOOL  nvTextureAllocSwizzleSurface  (PNVD3DTEXTURE,DWORD,DWORD,DWORD);
BOOL  nvTextureFreeSwizzleSurface   (PNVD3DTEXTURE);
BOOL  nvTextureAllocLinearSurface   (PNVD3DTEXTURE,DWORD,DWORD,DWORD);
BOOL  nvTextureFreeLinearSurface    (PNVD3DTEXTURE);

BOOL  nvUpdateSwizzleSurface        (PNVD3DTEXTURE);
BOOL  nvUpdateLinearSurface         (PNVD3DTEXTURE);

#else // NV_TEX2
/*
 * ver 1.0
 */
BOOL  nvLoadTexture(PNVD3DTEXTURE);
void  nvTextureBlit16Bpp(LPDDHAL_BLTDATA);
void  nvTextureBlit32Bpp(LPDDHAL_BLTDATA);
void  nvSwizzleBlit16Bpp(DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,
                         DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD);
void  nvSwizzleBlit32Bpp(DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,
                         DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD);

#endif //NV_TEX2

/*
 * common
 */
BOOL  nvCreateTextureListHeap(void);
BOOL  nvDestroyTextureListHeap(void);
BOOL  nvDestroyTextureStructure(PNVD3DTEXTURE);
BOOL  nvDestroyTextureProcess(DWORD);
BOOL  nvDestroyTextureContext(DWORD);
BOOL  CreateAGPListArray(void);
BOOL  DestroyAGPListArray(void);
BOOL  CreateTextureHeap(void);
BOOL  DestroyTextureHeap(void);
DWORD AllocTextureHeap(DWORD);
BOOL  FreeTextureHeap(DWORD);
DWORD GetPointerTextureHeap(DWORD);
DWORD AllocAGPHeap(LPDDRAWI_DIRECTDRAW_GBL, DWORD);
BOOL  FreeAGPHeap(LPDDRAWI_DIRECTDRAW_GBL, DWORD);
BOOL  ResetAGPHeap(void);
DWORD DestroyAGPListCallback(LPVOID, HDDRVITEM, DWORD);
DWORD __stdcall nvTextureCreate(LPD3DHAL_TEXTURECREATEDATA);
DWORD __stdcall nvTextureDestroy(LPD3DHAL_TEXTUREDESTROYDATA);
DWORD __stdcall nvTextureSwap(LPD3DHAL_TEXTURESWAPDATA);
DWORD __stdcall nvTextureGetSurf(LPD3DHAL_TEXTUREGETSURFDATA);
BOOL  nvAllocateInternalTexture(PNVD3DTEXTURE);
BOOL  nvDestroyInternalTexture(PNVD3DCONTEXT, PNVD3DTEXTURE);
BOOL  nvGenerateColorKeyAutoMipMap(long, long, long, DWORD, unsigned short *);
BOOL  nvGenerateAutoMipMap(long, long, long, unsigned short *);
BOOL  nvAllocateUserTexture(PNVD3DTEXTURE);
BOOL  nvCreateTextureSurface(LPDDHAL_CREATESURFACEDATA, LPDDRAWI_DDRAWSURFACE_LCL, LPDDRAWI_DDRAWSURFACE_GBL);
BOOL  nvDestroyTextureSurface(LPDDHAL_DESTROYSURFACEDATA, LPDDRAWI_DDRAWSURFACE_LCL, LPDDRAWI_DDRAWSURFACE_GBL);
DWORD UnplugSystemMemoryTextureContext(void);
DWORD AdjustTextureLimit(DWORD, DWORD, DWORD, DWORD);
DWORD UpdateTriangleContexts(void);
BOOL  nvMarkTextureDirty(PNVD3DCONTEXT, PNVD3DTEXTURE);
BOOL  nvMarkAllTexturesDirty(PNVD3DCONTEXT);
BOOL  nvMarkTextureValid(PNVD3DCONTEXT, PNVD3DTEXTURE);

#ifndef WINNT
/*
 * d3dstate.c
 */
DWORD __stdcall nvGetState(LPD3DHAL_GETSTATEDATA);
#endif

/*
 * d3dscene.c
 */
DWORD __stdcall nvSceneCapture(LPD3DHAL_SCENECAPTUREDATA);

/*
 * d3dtri.c
 */
void  nvNoOp(DWORD, LPWORD, DWORD, DWORD, LPD3DTLVERTEX);

void  nvDmaPushTri(DWORD, LPWORD, DWORD, DWORD, LPD3DTLVERTEX);
void  nvDmaPushTriFog(DWORD, LPWORD, DWORD, DWORD, LPD3DTLVERTEX);
void  nvDmaPushTriSpecular(DWORD, LPWORD, DWORD, DWORD, LPD3DTLVERTEX);
void  nvDmaPushTriFogSpecular(DWORD, LPWORD, DWORD, DWORD, LPD3DTLVERTEX);
void  nvDmaPushTriFlat(DWORD, LPWORD, DWORD, DWORD, LPD3DTLVERTEX);
void  nvDmaPushTriFogFlat(DWORD, LPWORD, DWORD, DWORD, LPD3DTLVERTEX);
void  nvDmaPushTriSpecularFlat(DWORD, LPWORD, DWORD, DWORD, LPD3DTLVERTEX);
void  nvDmaPushTriFogSpecularFlat(DWORD, LPWORD, DWORD, DWORD, LPD3DTLVERTEX);
void  nvDmaPushTriDecal(DWORD, LPWORD, DWORD, DWORD, LPD3DTLVERTEX);
void  nvDmaPushTriFogDecal(DWORD, LPWORD, DWORD, DWORD, LPD3DTLVERTEX);
void  nvDmaPushTriSpecularDecal(DWORD, LPWORD, DWORD, DWORD, LPD3DTLVERTEX);
void  nvDmaPushTriFogSpecularDecal(DWORD, LPWORD, DWORD, DWORD, LPD3DTLVERTEX);

void  nvDmaPushTriScaled(DWORD, LPWORD, DWORD, DWORD, LPD3DTLVERTEX);
void  nvDmaPushTriScaledFog(DWORD, LPWORD, DWORD, DWORD, LPD3DTLVERTEX);
void  nvDmaPushTriScaledSpecular(DWORD, LPWORD, DWORD, DWORD, LPD3DTLVERTEX);
void  nvDmaPushTriScaledFogSpecular(DWORD, LPWORD, DWORD, DWORD, LPD3DTLVERTEX);
void  nvDmaPushTriScaledFlat(DWORD, LPWORD, DWORD, DWORD, LPD3DTLVERTEX);
void  nvDmaPushTriScaledFogFlat(DWORD, LPWORD, DWORD, DWORD, LPD3DTLVERTEX);
void  nvDmaPushTriScaledSpecularFlat(DWORD, LPWORD, DWORD, DWORD, LPD3DTLVERTEX);
void  nvDmaPushTriScaledFogSpecularFlat(DWORD, LPWORD, DWORD, DWORD, LPD3DTLVERTEX);
void  nvDmaPushTriScaledDecal(DWORD, LPWORD, DWORD, DWORD, LPD3DTLVERTEX);
void  nvDmaPushTriScaledFogDecal(DWORD, LPWORD, DWORD, DWORD, LPD3DTLVERTEX);
void  nvDmaPushTriScaledSpecularDecal(DWORD, LPWORD, DWORD, DWORD, LPD3DTLVERTEX);
void  nvDmaPushTriScaledFogSpecularDecal(DWORD, LPWORD, DWORD, DWORD, LPD3DTLVERTEX);

void  nvDmaPushSpecularPass(DWORD, LPWORD, DWORD, DWORD, LPD3DTLVERTEX);
void  nvDmaPushSpecularPassScaled(DWORD, LPWORD, DWORD, DWORD, LPD3DTLVERTEX);
void  nvDmaPushFlatSpecularPass(DWORD, LPWORD, DWORD, DWORD, LPD3DTLVERTEX);
void  nvDmaPushFlatSpecularPassScaled(DWORD, LPWORD, DWORD, DWORD, LPD3DTLVERTEX);
void  nvDmaPushFogSpecularPass(DWORD, LPWORD, DWORD, DWORD, LPD3DTLVERTEX);
void  nvDmaPushFogSpecularPassScaled(DWORD, LPWORD, DWORD, DWORD, LPD3DTLVERTEX);
void  nvDmaPushFogFlatSpecularPass(DWORD, LPWORD, DWORD, DWORD, LPD3DTLVERTEX);
void  nvDmaPushFogFlatSpecularPassScaled(DWORD, LPWORD, DWORD, DWORD, LPD3DTLVERTEX);
void  nvNonPerspectiveTriangle(DWORD, LPWORD, DWORD, DWORD, LPD3DTLVERTEX);
void  nvFogTableTriangle(DWORD, LPWORD, DWORD, DWORD, LPD3DTLVERTEX);
void  nvGapFillTriangle(DWORD, LPWORD, DWORD, DWORD, LPD3DTLVERTEX);
void  nvDmaPushTriangleOnePass(DWORD, LPWORD, DWORD, DWORD, LPD3DTLVERTEX);
void  nvDmaPushTriangleOnePassSpecular(DWORD, LPWORD, DWORD, DWORD, LPD3DTLVERTEX);
void  nvDmaPushTriangleTwoPass(DWORD, LPWORD, DWORD, DWORD, LPD3DTLVERTEX);
void  nvDmaPushTriangleTwoPassSpecular(DWORD, LPWORD, DWORD, DWORD, LPD3DTLVERTEX);
void  nvDmaPushTriangleTwoPassSpecularNoZeta(DWORD, LPWORD, DWORD, DWORD, LPD3DTLVERTEX);

void nvTriangleStateChange(DWORD, LPWORD, DWORD, DWORD, LPD3DTLVERTEX);

/*
 * d3dpoint.c
 */
void  nvPointTriangle(DWORD, LPWORD, DWORD, DWORD, LPD3DTLVERTEX, LPNVDRAWTRI, LPNVDRAWTRI, LPNVDRAWTRI);
void  nvDmaPushPointTriangle(DWORD, LPWORD, DWORD, DWORD, LPD3DTLVERTEX);
void  nvPoint(DWORD, LPD3DPOINT, LPD3DTLVERTEX);
DWORD nvRenderPointDmaPush(DWORD, LPWORD, LPD3DTLVERTEX);

/*
 * d3dline.c
 */
void  nvWireframeTriangle(DWORD, LPWORD, DWORD, DWORD, LPD3DTLVERTEX, LPNVDRAWTRI, LPNVDRAWTRI, LPNVDRAWTRI);
void  nvDmaPushWireframeTriangle(DWORD, LPWORD, DWORD, DWORD, LPD3DTLVERTEX);
void  nvLine(DWORD, LPWORD, DWORD, LPD3DTLVERTEX);
DWORD nvDrawLineDmaPush(DWORD, LPWORD, DWORD, LPD3DTLVERTEX);
DWORD nvRenderLineDmaPush(DWORD, LPWORD, LPD3DTLVERTEX);

/*
 * d3dmisc.c
 */
VOID  uvFixDmaPush(D3DVALUE, LPD3DTLVERTEX, LPD3DTLVERTEX, LPD3DTLVERTEX, DWORD, DWORD);

/*
 * d3dmip.c
 */
void  nvMipMapRenderPrimitive(DWORD, LPWORD, DWORD, DWORD, LPD3DTLVERTEX);
void  nvMidPointSubdivision(PNVD3DTEXTURE, D3DTLVERTEX, D3DTLVERTEX, D3DTLVERTEX, LPNVDRAWTRI);
int   nvLODCompare(int, int, DWORD, DWORD);
DWORD nvConcurrentPass (void);
DWORD nvGetCPUSpeed    (void);
BOOL  nvDetectMMX      (void);
BOOL  nvDetectKATMAI   (void);

#ifdef NV_TEX2
/*
 * nv4swiz.c
 */
#define NV_SWIZFLAG_SRCLINEAR       0x00000000
#define NV_SWIZFLAG_SRCSWIZZLED     0x00000001
#define NV_SWIZFLAG_DESTLINEAR      0x00000000
#define NV_SWIZFLAG_DESTSWIZZLED    0x00000002
#define NV_SWIZFLAG_PALETTIZED      0x00000004
#define NV_SWIZFLAG_ALLOWHW         0x80000000

#define NV_SWIZVAL_MAX              16

BOOL nvSwizzleBlt   (DWORD dwSrcAddr,DWORD dwSrcAlloc,
                          DWORD dwSrcLogW,DWORD dwSrcLogH,
                          DWORD dwSrcX0,DWORD dwSrcY0,DWORD dwSrcX1,DWORD dwSrcY1,
                          DWORD dwSrcPitch,
                          PNVD3DTEXTURE pSrcTexture,
                     DWORD dwDestAddr,DWORD dwDestAlloc,
                          DWORD dwDestLogW,DWORD dwDestLogH,
                          DWORD dwDestX,DWORD dwDestY,
                          DWORD dwDestPitch,
                          PNVD3DTEXTURE pDestTexture,
                     DWORD dwBPP,
                     DWORD dwFlags);

#endif // NV_TEX2

/*
 * d3danti.c
 */
BOOL nvAACreate           (void);
void nvAADestroy          (void);
BOOL nvAACreateBuffers    (void);
BOOL __stdcall nvAACapturePrimitive (DWORD,LPWORD,DWORD,LPBYTE);
BOOL nvAARenderPrimitive  (void);

#ifdef  DO_XF_LIGHT
/*
 * d3dmatrx.c
 */
BOOL  CreatePipelineArray(void);
BOOL  DestroyPipelineArray(void);
DWORD __stdcall nvMatrixCreate(LPD3DHAL_MATRIXCREATEDATA pmcd);
DWORD __stdcall nvMatrixDestroy(LPD3DHAL_MATRIXDESTROYDATA pmdd);
DWORD __stdcall nvMatrixSetData(LPD3DHAL_MATRIXSETDATADATA pmsd);
DWORD __stdcall nvMatrixGetData(LPD3DHAL_MATRIXGETDATADATA pmgd);
DWORD __stdcall nvSetViewportData(LPD3DHAL_SETVIEWPORTDATADATA pvsd);
DWORD DestroyPipelineCallback(LPVOID lpData, HDDRVITEM hItem, DWORD dwExtra);
DWORD DestroyPipelineProcessCallback(LPVOID, HDDRVITEM, DWORD);
DWORD DestroyPipelineContextCallback(LPVOID, HDDRVITEM, DWORD);

/*
 * d3dmater.c
 */
BOOL  CreateMaterialArray(void);
BOOL  DestroyMaterialArray(void);
DWORD __stdcall nvLightSet(LPD3DHAL_LIGHTSETDATA plsd);
DWORD __stdcall nvMaterialCreate(LPD3DHAL_MATERIALCREATEDATA pmcd);
DWORD __stdcall nvMaterialDestroy(LPD3DHAL_MATERIALDESTROYDATA pmdd);
DWORD __stdcall nvMaterialDestroy(LPD3DHAL_MATERIALDESTROYDATA pmdd);
DWORD __stdcall nvMaterialSetData(LPD3DHAL_MATERIALSETDATADATA pmsd);
DWORD __stdcall nvMaterialGetData(LPD3DHAL_MATERIALGETDATADATA pmgd);
DWORD DestroyMaterialCallback(LPVOID lpData, HDDRVITEM hItem, DWORD dwExtra);
DWORD DestroyMaterialProcessCallback(LPVOID, HDDRVITEM, DWORD);
DWORD DestroyMaterialContextCallback(LPVOID, HDDRVITEM, DWORD);
#endif  // DO_XF_LIGHT

/*
 * For easy compatability with old code.
 * These include files are protected from being loaded twice.
 */
#include    "nvd3dmac.h"

#define HEAP_ALLOC_DEPTH_WIDTH_HEIGHT        1
#define HEAP_ALLOC_SIZE                      2
#define HEAP_FREE                            3
#define HEAP_PURGE                           4
#define HEAP_INFO                            5
#define HEAP_ALLOC_TILED_PITCH_HEIGHT        6
#define TYPE_IMAGE                           0
#define TYPE_DEPTH                           1
#define TYPE_TEXTURE                         2
#define TYPE_OVERLAY                         3
#define TYPE_FONT                            4
#define TYPE_CURSOR                          5
#define TYPE_DMA                             6
#define TYPE_INSTANCE                        7
#define MEM_TYPE_IMAGE_TILED                 9
#define STATUS_SUCCESS                       (0x00000000)
#define STATUS_ERROR_INSUFFICIENT_RESOURCES  (0x00000001)
#define STATUS_ERROR_INVALID_FUNCTION        (0x00000002)
#define STATUS_ERROR_INVALID_OWNER           (0x00000003)

#ifdef NVHEAPMGR
/*
 * Heap manager interface.
 */
extern void __stdcall NvIoControl(DWORD, PVOID);

/* parameter values */
#ifndef WINNT
#ifdef MULTI_MON
#define NVHEAP_ALLOC(pvm,sz,tp)             \
{                                           \
    HeapParams.hRoot = pDriverData->dwRootHandle; \
    HeapParams.hObjectParent = NV_WIN_DEVICE; \
    HeapParams.function = HEAP_ALLOC_SIZE;  \
    HeapParams.owner    = 'NVDD';           \
    HeapParams.type     = (tp);             \
    HeapParams.size     = (sz);             \
    NvIoControl(11, (PVOID)&HeapParams);    \
    (pvm) = HeapParams.status ? 0 : HeapParams.address;\
    pDriverData->VideoHeapFree = HeapParams.free;\
}
#define NVHEAP_FREE(pvm)                    \
{                                           \
    HeapParams.hRoot = pDriverData->dwRootHandle; \
    HeapParams.hObjectParent = NV_WIN_DEVICE; \
    HeapParams.function = HEAP_FREE;        \
    HeapParams.owner    = 'NVDD';           \
    HeapParams.offset   = (U032)(pvm) - pDriverData->BaseAddress;\
    NvIoControl(11, (PVOID)&HeapParams);    \
    pDriverData->VideoHeapFree = HeapParams.free;\
}
#else   // !MULTI_HEAP
#define NVHEAP_ALLOC(pvm,sz,tp)             \
{                                           \
    HeapParams.function = HEAP_ALLOC_SIZE;  \
    HeapParams.device   = 0;                \
    HeapParams.owner    = 'NVDD';           \
    HeapParams.type     = (tp);             \
    HeapParams.size     = (sz);             \
    NvIoControl(11, (PVOID)&HeapParams);    \
    (pvm) = HeapParams.status ? 0 : HeapParams.address;\
    pDriverData->VideoHeapFree = HeapParams.free;\
}
#define NVHEAP_FREE(pvm)                    \
{                                           \
    HeapParams.function = HEAP_FREE;        \
    HeapParams.device   = 0;                \
    HeapParams.owner    = 'NVDD';           \
    HeapParams.offset   = (U032)(pvm) - pDriverData->BaseAddress;\
    NvIoControl(11, (PVOID)&HeapParams);    \
    pDriverData->VideoHeapFree = HeapParams.free;\
}
#endif  // !MULTI_HEAP
#else
#ifndef RM_HEAPMGR
#define NVHEAP_ALLOC(pvm,sz,tp)                                 \
{                                                               \
    (pvm) = heap_alloc(sz, pDriverData->ppdev->heap.heap_2d_ptr);       \
    if(!(pvm))                                                  \
    {                                                           \
        bMoveAllDfbsFromOffscreenToDibs(pDriverData->ppdev);    \
        (pvm) = heap_alloc(sz, pDriverData->ppdev->heap.heap_2d_ptr);   \
    }                                                           \
}

#define NVHEAP_FREE(pvm)             \
    heap_free((pvm), pDriverData->ppdev->heap.heap_2d_ptr)
#else
extern BOOL bMoveAllDfbsFromOffscreenToDibs(PDEV *);

#define NVHEAP_ALLOC(pvm,sz,tp)             \
{                                           \
    NVOS11_PARAMETERS   HeapParams;         \
    PVOID pParms = (PVOID) &HeapParams;     \
    DWORD cbReturned;                       \
                                            \
    if (pDriverData && !pDriverData->DDrawVideoSurfaceCount)         \
    {                                       \
        pDriverData->ppdev->cbGdiHeap = pDriverData->ppdev->VideoHeapTotal -   \
            pDriverData->ppdev->VideoHeapFree;                      \
                                                                    \
    }                                       \
                                                    \
    HeapParams.hRoot = pDriverData->ppdev->hClient;  \
    HeapParams.hObjectParent = pDriverData->ppdev->hDevice;                  \
    HeapParams.function = HEAP_ALLOC_SIZE;                      \
    HeapParams.owner    = 'NVDD';                               \
    HeapParams.type     = (tp);                                 \
    HeapParams.size     = (sz);                                 \
    EngDeviceIoControl(                         \
        pDriverData->ppdev->hDriver,            \
        (DWORD)IOCTL_NV01_ARCH_HEAP,            \
        (&pParms),                              \
        sizeof(PVOID),                          \
        pParms,                                 \
        sizeof(NVOS11_PARAMETERS),              \
        &cbReturned                             \
    );                                          \
    (pvm) = HeapParams.status ? 0 : HeapParams.offset;          \
    if (!(pvm))                                                 \
    {                                                           \
        bMoveAllDfbsFromOffscreenToDibs(pDriverData->ppdev);    \
        HeapParams.hRoot = pDriverData->ppdev->hClient;  \
        HeapParams.hObjectParent = pDriverData->ppdev->hDevice;                  \
        HeapParams.function = HEAP_ALLOC_SIZE;                      \
        HeapParams.owner    = 'NVDD';                               \
        HeapParams.type     = (tp);                                 \
        HeapParams.size     = (sz);                                 \
        EngDeviceIoControl(                         \
            pDriverData->ppdev->hDriver,            \
            (DWORD)IOCTL_NV01_ARCH_HEAP,            \
            (&pParms),                              \
            sizeof(PVOID),                          \
            pParms,                                 \
            sizeof(NVOS11_PARAMETERS),              \
            &cbReturned                             \
        );                                          \
        (pvm) = HeapParams.status ? 0 : HeapParams.offset;          \
    }                                               \
    if (pvm)                                        \
        pDriverData->ppdev->VideoHeapFree = HeapParams.free;    \
}

#define NVHEAP_ALLOC_TILED(pvm,pch,ht,tp)   \
{                                           \
    NVOS11_PARAMETERS HeapParams;           \
    PVOID pParms = (PVOID) &HeapParams;     \
    DWORD cbReturned;                       \
    HeapParams.hRoot = pDriverData->ppdev->hClient; \
    HeapParams.hObjectParent = pDriverData->ppdev->hDevice; \
    HeapParams.function = HEAP_ALLOC_TILED_PITCH_HEIGHT;\
    HeapParams.owner    = 'NVDD';           \
    HeapParams.type     = (tp);             \
    HeapParams.pitch    = (pch);            \
    HeapParams.height   = (ht);             \
    EngDeviceIoControl(                         \
        pDriverData->ppdev->hDriver,            \
        (DWORD)IOCTL_NV01_ARCH_HEAP,            \
        (&pParms),                              \
        sizeof(PVOID),                          \
        pParms,                                 \
        sizeof(NVOS11_PARAMETERS),              \
        &cbReturned                             \
    );                                          \
                                                \
    (pvm) = HeapParams.status ? 0 : HeapParams.offset;\
    (pch) = HeapParams.pitch;                   \
    if ((pvm))                                  \
        pDriverData->VideoHeapFree = HeapParams.free;\
}

#define NVHEAP_FREE(pvm)                    \
{                                           \
    NVOS11_PARAMETERS HeapParams;           \
    PVOID pParms = (PVOID) &HeapParams;     \
    DWORD cbReturned;                       \
    HeapParams.hRoot = pDriverData->ppdev->hClient;      \
    HeapParams.hObjectParent = pDriverData->ppdev->hDevice; \
    HeapParams.function = HEAP_FREE;        \
    HeapParams.owner    = 'NVDD';         \
    HeapParams.offset   = (U032)(pvm);      \
    EngDeviceIoControl(                         \
        pDriverData->ppdev->hDriver,                                \
        (DWORD)IOCTL_NV01_ARCH_HEAP,            \
        (&pParms),                              \
        sizeof(PVOID),                          \
        pParms,                                 \
        sizeof(NVOS11_PARAMETERS),              \
        &cbReturned                             \
    );                                          \
    pDriverData->ppdev->VideoHeapFree = HeapParams.free;              \
}

#endif // RM_HEAPMGR
#endif // #ifdef WINNT
#define AGP_HEAP                                    0
#else
#ifndef WINNT
#define NVHEAP_ALLOC(pvm,size,tp)                                                \
{                                                                                \
    DWORD _actual = size;                                                        \
    if ((tp) == TYPE_TEXTURE) _actual = (_actual + NV_TEXTURE_PAD + NV_TEXTURE_OFFSET_ALIGN) & ~NV_BYTE_ALIGNMENT_PAD;\
    (pvm) = DDHAL32_VidMemAlloc(pdrv, 0, _actual, 1);                            \
}
#define NVHEAP_FREE(pvm)                            DDHAL32_VidMemFree(pdrv, 0, pvm)
#define AGP_HEAP                                    1
#else
#define NVHEAP_ALLOC(pfm,size,tp) \
{                                                   \
SURFACEALIGNMENT    _align;                         \
ULONG               DummyPitch;                     \
switch (tp)                                         \
    {                                               \
    case TYPE_TEXTURE:                              \
        _align.Linear.dwSurfaceAlignment = NV_TEXTURE_OFFSET_ALIGN + 1; \
        _align.Linear.dwPitchAlignment = NV_BYTE_ALIGNMENT; \
        break;                                      \
                                                    \
    case TYPE_IMAGE:                                \
    case TYPE_OVERLAY:                              \
    case TYPE_DEPTH:                                \
        _align.Linear.dwSurfaceAlignment = _align.Linear.dwPitchAlignment = NV_BYTE_ALIGNMENT; \
        break;                                      \
                                                    \
    default:                                        \
        DPF("Bad allocation type passed to NVHEAP_ALLOC"); \
            _align.Linear.dwSurfaceAlignment = _align.Linear.dwPitchAlignment = NV_BYTE_ALIGNMENT_PAD; \
                                                    \
    }                                               \
(pfm) = HeapVidMemAllocAligned(pdrv, size, 1,       \
            &_align,                                \
            &DummyPitch                             \
            );                                      \
}

#define NVHEAP_FREE(pfm)            VidMemFree(pdrv, pfm)
#define AGP_HEAP                    0
#endif // #ifdef WINNT
#endif

#ifndef WINNT
#define NV_DELAY                                          \
{                                                         \
    __asm { push ecx                                    } \
    __asm { mov ecx,[global.dwProcessorSpeed]           } \
    __asm { shl ecx,3                                   } \
x:  __asm { loop x                                      } \
    __asm { pop ecx                                     } \
}

#define NV_DELAY_(x)                                      \
{                                                         \
    __asm { push ecx                                    } \
    __asm { mov ecx,[global.dwProcessorSpeed]           } \
    __asm { shl ecx,3                                   } \
x:  __asm { loop x                                      } \
    __asm { pop ecx                                     } \
}
#else
#define NV_DELAY
#endif // #ifdef WINNT

void WaitForVSync (void);

/*
 * wait for VSYNC strategy:
 *
 * 1) we should have the registry bit set that enable wait for VSYNC
 * 2) we should have a flip pending
 * 3) the flip should involve the current render target
 */
#define WAIT_FOR_VSYNC(_ctx)                                                                        \
{                                                                                                   \
    if (!(pDriverData->regD3DEnableBits1 & REG_BIT1_NO_WAIT_4_VSYNC) /* vsync == true */            \
      && pDriverData->flipPrimaryRecord.bFlipFlag)                                                  \
    {                                                                                               \
        /* skip wait if we do not render to any flipping surfaces */                                \
        if ((_ctx)                                                                                  \
         && (pDriverData->flipPrimaryRecord.fpFlipFrom != (_ctx)->lpLcl->lpGbl->fpVidMem)           \
         && (pDriverData->flipPrimaryRecord.fpFlipTo   != (_ctx)->lpLcl->lpGbl->fpVidMem))          \
        {                                                                                           \
            /* do nothing */                                                                        \
        }                                                                                           \
        else                                                                                        \
        {                                                                                           \
            /* have to wait for vsync */                                                            \
            WaitForVSync();                                                                         \
        }                                                                                           \
    }                                                                                               \
}


#endif // _D3DINC_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\inc\NV3DDBG.H ===
#ifndef _NV3DDBG_H_
#define _NV3DDBG_H_
/*
 * (C) Copyright NVIDIA Corporation Inc., 1996,1997. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: NV3DDBG.H                                                         *
*   Define debug related values.                                            *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Charles Inman (chasi)       11/18/97 - created                      *
*                                                                           *
\***************************************************************************/

/*
 * Bit definitions for dbgLevel debug output level flags.
 */
#define NVDBG_LEVEL_ERROR           0x80000000
#define NVDBG_LEVEL_DDI_ENTRY       0x40000000
#define NVDBG_LEVEL_FUNCTION_CALL   0x20000000
#define NVDBG_LEVEL_INFO            0x10000000
#define NVDBG_LEVEL_INFO2           0x08000000
#define NVDBG_LEVEL_COLORKEY_INFO   0x04000000
#define NVDBG_LEVEL_AA_INFO         0x02000000
#define NVDBG_LEVEL_FLIP            0x01000000
#define NVDBG_LEVEL_FASTLOOPS       0x00800000

/*
 * Bit definitions for the dbgShowState debug flags.
 */
#define NVDBG_SHOW_RENDER_STATE     0x80000000
#define NVDBG_SHOW_DX5_CLASS_STATE  0x40000000
#define NVDBG_SHOW_SURFACE_STATE    0x20000000
#define NVDBG_SHOW_VERTICES         0x10000000
#define NVDBG_SHOW_MTS_STATE        0x0F000000  // Selects number of multi-texture stage state values to display.
#define NVDBG_SHOW_MTS_STATE_MAX    8
#define NVDBG_SHOW_MTS_STATE_SHIFT  24
#define NVDBG_SHOW_DX6_CLASS_STATE  0x00800000
#define NVDBG_SHOW_DRAWPRIM2_INFO   0x00400000

/*
 * Define externs and constants when DEBUG is enabled.
 */
#ifdef  DEBUG
#define DBGFRONTRENDER  1
#define DBGPREVIEWTEX   1
#define DMAVALIDATE     1

/*
 * Bit definitions for the dbgFlush debug flags.
 */
#define NVDBG_FLUSH_TRIANGLE        0x80000000
#define NVDBG_FLUSH_PRIMITIVE       0x40000000
#define NVDBG_FLUSH_DDI             0x20000000

extern BOOL     dbgShowState;
extern BOOL     dbgFlush;
extern DWORD    dbgLeve;
void dbgD3DError(void);
void dbgDisplayContextState(DWORD, PNVD3DCONTEXT);
void dbgDisplayDrawPrimitives2Info(BYTE,WORD);
void dbgDisplayVertexData(DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD);
BOOL dbgTestPushBuffer(PNVD3DCONTEXT);
BOOL dbgValidateControlRegisters(PNVD3DCONTEXT);
extern void __cdecl DPF_LEVEL(DWORD dwLeve, LPSTR szFormat, ...);
#define dbgFlushType(pctxt, type)                                       \
{                                                                       \
    if (dbgFlush & type)                                                \
    {                                                                   \
        NV_D3D_GLOBAL_SAVE();                                           \
        nvFlushDmaBuffers();                                            \
        NV_D3D_GLOBAL_SETUP();                                          \
    }                                                                   \
}
/*
 * Legacy flush routines.
 */
#define dbgFlushDmaBuffers(pctxt)   dbgFlushType(pctxt, NVDBG_FLUSH_PRIMITIVE);
#define dbgFlushTriangle(pctxt)     dbgFlushType(pctxt, NVDBG_FLUSH_TRIANGLE);
#define dbgFlushDDI(pctxt)          dbgFlushType(pctxt, NVDBG_FLUSH_DDI);
#else   // DEBUG
#define dbgShowState                        FALSE
#define dbgTestPushBuffer(noop)             TRUE
#define dbgValidateControlRegisters(noop)   TRUE
#define dbgD3DError()
#define dbgDisplayContextState(f,x)
#define dbgDisplayDrawPrimitives2Info(x,y);
#define dbgDisplayVertexData(x, y, z, w, c, s, u, v);
#define DPF_LEVEL   1 ? (void)0 : (void)
#define dbgFlushDmaBuffers(noop)
#define dbgFlushTriangle(noop)
#define dbgFlushDDI(noop)
#endif  // DEBUG

/*
 * Define externs and constants when DBGFRONTRENDER is defined.
 */
#ifdef  DBGFRONTRENDER
extern BOOL     dbgFrontRender;
extern DWORD    dbgFrontRenderPitch;
#else   // DBGFRONTRENDER
#define dbgFrontRender      FALSE
#define dbgFrontRenderPitch 0
#endif  // DBGFRONTRENDER

/*
 * Define externs and constants when DBGPREVIEWTEX is defined.
 */
#ifdef  DBGPREVIEWTEX
extern BOOL     dbgPreviewTexture;
extern BOOL     dbgPreviewLinearTexture;
extern DWORD    dbgPreviewTexturePitch;
extern BOOL     dbgPreviewTextureClearFirst;
extern DWORD    dbgPreviewTextureMagX;
extern DWORD    dbgPreviewTextureMagY;
void dbgDisplayTexture(PNVD3DCONTEXT, PNVD3DTEXTURE);
void dbgDisplayLinearTexture(LPDDRAWI_DDRAWSURFACE_LCL, LPDDRAWI_DDRAWSURFACE_LCL, DWORD);
#else   // DBGPREVIEWTEX
#define dbgPreviewTexture       FALSE
#define dbgPreviewLinearTexture FALSE
#define dbgPreviewTexturePitch  0
#define dbgPreviewTextureClearFirst FALSE
#define dbgPreviewTextureMagX 1
#define dbgPreviewTextureMagY 1
#define dbgDisplayTexture(x,y)
#define dbgDisplayLinearTexture(x,y,z)
#endif  // DBGPREVIEWTEX

/*
 * Define externs and constants when DMAVALIDATE is defined.
 */
#ifdef  DMAVALIDATE
extern BOOL     dbgValidatePushBuffer;
void dbgValidatePushBufferError(void);
#ifdef  NEW_DMAPUSH
void dbgValidatePushBufferData(DWORD, DWORD);
#else   // OLD_DMAPUSH
void dbgValidatePushBufferData(void);
#endif  // OLD_DMAPUSH
#else   // DMAVALIDATE
#define dbgValidatePushBuffer   FALSE
#define dbgValidatePushBufferError()
#ifdef  NEW_DMAPUSH
#define dbgValidatePushBufferData(x,y)
#else   // OLD_DMAPUSH
#define dbgValidatePushBufferData() 
#endif  // OLD_DMAPUSH
#endif  // DMAVALIDATE

#endif // _NV3DDBG_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\inc\NV4dblnd.h ===
#ifndef _NV4DBLND_H_
#define _NV4DBLND_H_
#ifdef  NV4
/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: NV4DBLND.H                                                        *
*   DX6 Class Blending definitions.                                         *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Charles Inman (chasi)       09/09/98 - created.                     *
*                                                                           *
\***************************************************************************/

/*
 * Combine1 Pass Thru
 */
#define DX6TRI_COMBINE1ALPHA_PASS_THRU                      \
    (DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_0,  _NORMAL)   \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_0, _INPUT)    \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_1,  _INVERSE)  \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_1, _ZERO)     \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_2,  _NORMAL)   \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_2, _ZERO)     \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_3,  _NORMAL)   \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_3, _ZERO)     \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _OPERATION,  _ADD))


#define DX6TRI_COMBINE1COLOR_PASS_THRU                      \
    (DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_0,  _NORMAL)   \
  |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_0,    _COLOR)    \
  |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_0, _INPUT)    \
  |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_1,  _INVERSE)  \
  |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_1,    _COLOR)    \
  |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_1, _ZERO)     \
  |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_2,  _NORMAL)   \
  |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_2,    _COLOR)    \
  |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_2, _ZERO)     \
  |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_3,  _NORMAL)   \
  |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_3,    _COLOR)    \
  |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_3, _ZERO)     \
  |  DRF_DEF(055, _COMBINE_1_COLOR, _OPERATION,  _ADD))

/*
 * Combine0 Disable
 */
#define DX6TRI_COMBINE0ALPHA_DISABLE                        \
    (DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_0,  _NORMAL)   \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_0, _DIFFUSE)  \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_1,  _INVERSE)  \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_1, _ZERO)     \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_2,  _NORMAL)   \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_2, _ZERO)     \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_3,  _NORMAL)   \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_3, _ZERO)     \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADD))

#define DX6TRI_COMBINE0COLOR_DISABLE                        \
    (DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_0,  _NORMAL)   \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_0,    _COLOR)    \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_0, _ZERO)     \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_1,  _NORMAL)   \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_1,    _COLOR)    \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_1, _ZERO)     \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_2,  _NORMAL)   \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_2,    _COLOR)    \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_2, _ZERO)     \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _NORMAL)   \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _COLOR)    \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _ZERO)     \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD))

/*
 * Combine1 Disable
 */
#define DX6TRI_COMBINE1ALPHA_DISABLE                        \
    (DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_0,  _NORMAL)   \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_0, _DIFFUSE)  \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_1,  _INVERSE)  \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_1, _ZERO)     \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_2,  _NORMAL)   \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_2, _ZERO)     \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_3,  _NORMAL)   \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_3, _ZERO)     \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _OPERATION,  _ADD))

#define DX6TRI_COMBINE1COLOR_DISABLE                        \
    (DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_0,  _NORMAL)   \
  |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_0,    _COLOR)    \
  |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_0, _ZERO)     \
  |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_1,  _NORMAL)   \
  |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_1,    _COLOR)    \
  |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_1, _ZERO)     \
  |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_2,  _NORMAL)   \
  |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_2,    _COLOR)    \
  |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_2, _ZERO)     \
  |  DRF_DEF(055, _COMBINE_1_COLOR, _INVERSE_3,  _NORMAL)   \
  |  DRF_DEF(055, _COMBINE_1_COLOR, _ALPHA_3,    _COLOR)    \
  |  DRF_DEF(055, _COMBINE_1_COLOR, _ARGUMENT_3, _ZERO)     \
  |  DRF_DEF(055, _COMBINE_1_COLOR, _OPERATION,  _ADD))

/*
 * Default Combiner setup.
 */
#define DX6TRI_COMBINE0ALPHA_DEFAULT    DX6TRI_COMBINE0ALPHA_DISABLE

#define DX6TRI_COMBINE0COLOR_DEFAULT                            \
    (DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_0,  _INVERSE)      \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_0,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_0, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_1,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_1,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_1, _DIFFUSE)      \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_2,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_2,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_2, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD))

#define DX6TRI_COMBINE1ALPHA_DEFAULT                            \
    (DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_0,  _INVERSE)      \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_0, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_1,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_1, _INPUT)        \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_2,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_2, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_3,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_3, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _OPERATION,  _ADD))

#define DX6TRI_COMBINE1COLOR_DEFAULT    DX6TRI_COMBINE1COLOR_PASS_THRU

/*
 * Bump Mapping Combiner Setup.
 */
#define DX6TRI_COMBINE0ALPHA_BUMP                               \
    (DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_0,  _INVERSE)      \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_0, _TEXTURE0)     \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_1,  _INVERSE)      \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_1, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_2,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_2, _TEXTURE1)     \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_3,  _INVERSE)      \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_3, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADDSIGNED))

#define DX6TRI_COMBINE0COLOR_BUMP                               \
    (DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_0,  _INVERSE)      \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_0,    _ALPHA)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_0, _TEXTURE0)     \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_1,  _INVERSE)      \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_1,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_1, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_2,  _INVERSE)      \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_2,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_2, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _ALPHA)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _TEXTURE1)     \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADDSIGNED2))

#define DX6TRI_COMBINE1ALPHA_BUMP                               \
    (DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_0,  _INVERSE)      \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_0, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_1,  _INVERSE)      \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_1, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_2,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_2, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _INVERSE_3,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _ARGUMENT_3, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_1_ALPHA, _OPERATION,  _ADD))

#define DX6TRI_COMBINE1COLOR_BUMP                               \
    (DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_0,  _INVERSE)      \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_0,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_0, _INPUT)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_1,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_1,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_1, _TEXTURE0)     \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_2,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_2,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_2, _TEXTURE0)     \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _DIFFUSE)      \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD))

/*
 * DX6 Triangle Class combiner mappings for TEXTUREMAPBLEND_DECAL
 * cPix = cTex
 * aPix = aTex
 */
#define DX6TRI_COMBINE0ALPHA_TBLEND_DECAL                       \
    (DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_0,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_0, _TEXTURE0)     \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_1,  _INVERSE)      \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_1, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_2,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_2, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_3,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_3, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADD))

#define DX6TRI_COMBINE0COLOR_TBLEND_DECAL                       \
    (DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_0,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_0,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_0, _TEXTURE0)     \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_1,  _INVERSE)      \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_1,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_1, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_2,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_2,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_2, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD))

/*
 * DX6 Triangle Class combiner mappings for TEXTUREMAPBLEND_MODULATE
 * cPix = cTex * cSrc
 * aPix = aTex
 */
#define DX6TRI_COMBINE0ALPHA_TBLEND_MODULATE                    \
    (DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_0,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_0, _TEXTURE0)     \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_1,  _INVERSE)      \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_1, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_2,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_2, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_3,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_3, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADD))

#define DX6TRI_COMBINE0COLOR_TBLEND_MODULATE                    \
    (DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_0,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_0,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_0, _TEXTURE0)     \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_1,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_1,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_1, _DIFFUSE)      \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_2,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_2,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_2, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD))

/*
 * DX6 Triangle Class combiner mappings for TEXTUREMAPBLEND_DECALALPHA
 * cPix = ((1 - aTex) * cSrc) + (aTex * cTex)
 * aPix = aSrc
 */
#if 0
#define DX6TRI_COMBINE0ALPHA_TBLEND_DECALALPHA                  \
    (DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_0,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_0, _TEXTURE0)     \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_1,  _INVERSE)      \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_1, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_2,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_2, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_3,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_3, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADD))
#else
#define DX6TRI_COMBINE0ALPHA_TBLEND_DECALALPHA                  \
    (DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_0,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_0, _DIFFUSE)      \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_1,  _INVERSE)      \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_1, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_2,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_2, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_3,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_3, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADD))
#endif

#define DX6TRI_COMBINE0COLOR_TBLEND_DECALALPHA                  \
    (DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_0,  _INVERSE)      \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_0,    _ALPHA)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_0, _TEXTURE0)     \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_1,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_1,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_1, _DIFFUSE)      \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_2,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_2,    _ALPHA)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_2, _TEXTURE0)     \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _TEXTURE0)     \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD))

/*
 * DX6 Triangle Class combiner mappings for TEXTUREMAPBLEND_MODULATEALPHA
 * cPix = cTex * cSrc
 * aPix = aTex * aSrc
 */
#define DX6TRI_COMBINE0ALPHA_TBLEND_MODULATEALPHA               \
    (DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_0,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_0, _TEXTURE0)     \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_1,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_1, _DIFFUSE)      \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_2,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_2, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_3,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_3, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADD))

#define DX6TRI_COMBINE0COLOR_TBLEND_MODULATEALPHA               \
    (DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_0,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_0,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_0, _TEXTURE0)     \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_1,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_1,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_1, _DIFFUSE)      \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_2,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_2,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_2, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD))

/*
 * DX6 Triangle Class combiner mappings for TEXTUREMAPBLEND_DECALMASK
 * cPix = lsb(aTex) ? cTex : cSrc
 * aPix = aSrc
 */
#if 0
#define DX6TRI_COMBINE0ALPHA_TBLEND_DECALMASK                   \
    (DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_0,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_0, _DIFFUSE)      \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_1,  _INVERSE)      \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_1, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_2,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_2, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_3,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_3, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADD))
#else
#define DX6TRI_COMBINE0ALPHA_TBLEND_DECALMASK   DX6TRI_COMBINE0ALPHA_TBLEND_DECAL
#endif

#define DX6TRI_COMBINE0COLOR_TBLEND_DECALMASK   DX6TRI_COMBINE0COLOR_TBLEND_DECAL

/*
 * DX6 Triangle Class combiner mappings for TEXTUREMAPBLEND_MODULATEMASK
 * cPix = lsb(aTex) ? cTex * cSrc : cSrc
 * aPix = aSrc
 */
#if 0
#define DX6TRI_COMBINE0ALPHA_TBLEND_MODULATEMASK                \
    (DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_0,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_0, _DIFFUSE)      \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_1,  _INVERSE)      \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_1, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_2,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_2, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_3,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_3, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADD))
#else
#define DX6TRI_COMBINE0ALPHA_TBLEND_MODULATEMASK    DX6TRI_COMBINE0ALPHA_TBLEND_MODULATE
#endif

#define DX6TRI_COMBINE0COLOR_TBLEND_MODULATEMASK    DX6TRI_COMBINE0COLOR_TBLEND_MODULATE

/*
 * DX6 Triangle Class combiner mappings for TEXTUREMAPBLEND_COPY
 * cPix = cTex
 * aPix = aTex
 */
#define DX6TRI_COMBINE0ALPHA_TBLEND_COPY    DX6TRI_COMBINE0ALPHA_TBLEND_DECAL
#define DX6TRI_COMBINE0COLOR_TBLEND_COPY    DX6TRI_COMBINE0COLOR_TBLEND_DECAL

/*
 * DX6 Triangle Class combiner mappings for TEXTUREMAPBLEND_ADD
 * cPix = cTex + cSrc
 * aPix = aSrc
 */
#define DX6TRI_COMBINE0ALPHA_TBLEND_ADD                         \
    (DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_0,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_0, _DIFFUSE)      \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_1,  _INVERSE)      \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_1, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_2,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_2, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _INVERSE_3,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _ARGUMENT_3, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_ALPHA, _OPERATION,  _ADD))

#define DX6TRI_COMBINE0COLOR_TBLEND_ADD                         \
    (DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_0,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_0,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_0, _TEXTURE0)     \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_1,  _INVERSE)      \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_1,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_1, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_2,  _NORMAL)       \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_2,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_2, _DIFFUSE)      \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _INVERSE_3,  _INVERSE)      \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ALPHA_3,    _COLOR)        \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _ARGUMENT_3, _ZERO)         \
  |  DRF_DEF(055, _COMBINE_0_COLOR, _OPERATION,  _ADD))

#endif  // NV4
#endif  // _NV4DBLND_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\inc\D3DI.H ===
/*==========================================================================;
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       d3di.h
 *  Content:    Direct3D internal include file
 *
 ***************************************************************************/

#ifndef _D3DI_H
#define _D3DI_H

#include "ddraw.h"
#include "d3d.h"


typedef DWORD D3DI_BUFFERHANDLE, *LPD3DI_BUFFERHANDLE;

/*
 * Internal version of executedata
 */
typedef struct _D3DI_ExecuteData {
    DWORD       dwSize;
    D3DI_BUFFERHANDLE dwHandle;         /* Handle allocated by driver */
    DWORD       dwVertexOffset;
    DWORD       dwVertexCount;
    DWORD       dwInstructionOffset;
    DWORD       dwInstructionLength;
    DWORD       dwHVertexOffset;
    D3DSTATUS   dsStatus;               /* Status after execute */
} D3DI_EXECUTEDATA, *LPD3DI_EXECUTEDATA;

/*
 * Internal version of lightdata and constants for flags
 */

#define D3DLIGHTI_ATT0_IS_NONZERO       (0x00010000)    
#define D3DLIGHTI_ATT1_IS_NONZERO       (0x00020000)
#define D3DLIGHTI_ATT2_IS_NONZERO       (0x00040000)
#define D3DLIGHTI_LINEAR_FALLOFF        (0x00080000)
#define D3DLIGHTI_UNIT_SCALE            (0x00100000)
#define D3DLIGHTI_LIGHT_AT_EYE          (0x00200000)

typedef struct _D3DI_LIGHT {
    D3DLIGHTTYPE        type;
        DWORD                   version;        /* matches number on D3DLIGHT struct */
    BOOL                        valid;
    D3DVALUE            red, green, blue, shade;
    D3DVECTOR           position;
    D3DVECTOR           model_position;
    D3DVECTOR           direction;
    D3DVECTOR           model_direction;
    D3DVECTOR           halfway;
        D3DVECTOR               model_eye;              /* direction from eye in model space */
        D3DVECTOR               model_scale;    /* model scale for proper range computations */
    D3DVALUE            range;
    D3DVALUE            range_squared;
    D3DVALUE            falloff;
    D3DVALUE            attenuation0;
    D3DVALUE            attenuation1;
    D3DVALUE            attenuation2;
    D3DVALUE            cos_theta_by_2;
    D3DVALUE            cos_phi_by_2;
        DWORD                   flags;
} D3DI_LIGHT, *LPD3DI_LIGHT;


#endif /* _D3DI_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\inc\NV4DCAPS.H ===
#ifndef _NV4DCAPS_H_
#define _NV4DCAPS_H_
#ifdef  NV4
/*
 * (C) Copyright NVIDIA Corporation Inc., 1996,1997. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: NV4DCAPS.H                                                        *
*   Define the capabilities of the NV4 D3D driver.                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Charles Inman (chasi)       01/26/98 - created                      *
*                                                                           *
\***************************************************************************/

/*
 * --------------------------------------------------------------------------
 *  Direct 3D HAL Capabilities
 * --------------------------------------------------------------------------
 */

/*
 * Define which fields of the D3DDEVICECAPS structure are valid.
 */
#define NV4_DEVDESC_FLAGS           D3DDD_COLORMODEL                    |   \
                                    D3DDD_DEVCAPS                       |   \
                                    D3DDD_LINECAPS                      |   \
                                    D3DDD_TRICAPS                       |   \
                                    D3DDD_DEVICERENDERBITDEPTH          |   \
                                    D3DDD_DEVICEZBUFFERBITDEPTH

/*
 * Define the color model for the D3D driver.
 */
#define NV4_COLORMODEL              D3DCOLOR_RGB

/*
 * Define the device capabilities.
 */
#define NV4_DEVCAPS_FLAGS           D3DDEVCAPS_EXECUTESYSTEMMEMORY      |   \
                                    D3DDEVCAPS_FLOATTLVERTEX            |   \
                                    D3DDEVCAPS_TEXTUREVIDEOMEMORY       |   \
                                    D3DDEVCAPS_TLVERTEXSYSTEMMEMORY     |   \
                                    D3DDEVCAPS_DRAWPRIMTLVERTEX         |   \
                                    D3DDEVCAPS_TEXTURENONLOCALVIDMEM
//                                    D3DDEVCAPS_CANRENDERAFTERFLIP

/*
 * Define the transformation capabilities.
 */
#define NV4_TRANSFORMCAPS_FLAGS     0
#define NV4_TRANSFORMCAPS                                                   \
{                                                                           \
    sizeof(D3DTRANSFORMCAPS),                                               \
    NV4_TRANSFORMCAPS_FLAGS                                                 \
}

/*
 * Define 3D clipping capabilities.
 */
#define NV4_3DCLIPPINGCAPS          FALSE

/*
 * Define the lighting capabilities.
 */
#define NV4_LIGHTINGCAPS_FLAGS      0
#define NV4_LIGHTINGCAPS                                                    \
{                                                                           \
    sizeof(D3DLIGHTINGCAPS),                                                \
    NV4_LIGHTINGCAPS_FLAGS                                                  \
}

/*
 * Define NULL primary capabilities.
 */
#define NV4_PRIMCAPS_NULL           0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

/*
 * Define the line capabilities.
 *
 * Miscellaneous capabilities (dwMiscCaps)
 */
#define NV4_LINECAPS_MISC           D3DPMISCCAPS_MASKZ                  |   \
                                    D3DPMISCCAPS_CULLNONE               |   \
                                    D3DPMISCCAPS_CULLCW                 |   \
                                    D3DPMISCCAPS_CULLCCW

/*
 * Raster capabilities (dwRasterCaps)
 */
#define NV4_LINECAPS_RASTER         D3DPRASTERCAPS_DITHER               |   \
                                    D3DPRASTERCAPS_SUBPIXEL             |   \
                                    D3DPRASTERCAPS_FOGVERTEX            |   \
                                    D3DPRASTERCAPS_WFOG                 |   \
                                    D3DPRASTERCAPS_MIPMAPLODBIAS        |   \
                                    D3DPRASTERCAPS_ANISOTROPY           |   \
                                    D3DPRASTERCAPS_WBUFFER

/*
 * Z Compare capabilities (dwZCmpCaps)
 */
#define NV4_LINECAPS_ZCMP           D3DPCMPCAPS_NEVER                   |   \
                                    D3DPCMPCAPS_LESS                    |   \
                                    D3DPCMPCAPS_EQUAL                   |   \
                                    D3DPCMPCAPS_LESSEQUAL               |   \
                                    D3DPCMPCAPS_GREATER                 |   \
                                    D3DPCMPCAPS_NOTEQUAL                |   \
                                    D3DPCMPCAPS_GREATEREQUAL            |   \
                                    D3DPCMPCAPS_ALWAYS

/*
 * Source blend capabilities (dwSrcBlendCaps)
 */
#define NV4_LINECAPS_SRCBLEND       D3DPBLENDCAPS_ZERO                  |   \
                                    D3DPBLENDCAPS_ONE                   |   \
                                    D3DPBLENDCAPS_SRCCOLOR              |   \
                                    D3DPBLENDCAPS_INVSRCCOLOR           |   \
                                    D3DPBLENDCAPS_SRCALPHA              |   \
                                    D3DPBLENDCAPS_INVSRCALPHA           |   \
                                    D3DPBLENDCAPS_DESTALPHA             |   \
                                    D3DPBLENDCAPS_INVDESTALPHA          |   \
                                    D3DPBLENDCAPS_DESTCOLOR             |   \
                                    D3DPBLENDCAPS_INVDESTCOLOR          |   \
                                    D3DPBLENDCAPS_SRCALPHASAT           |   \
                                    D3DPBLENDCAPS_BOTHSRCALPHA          |   \
                                    D3DPBLENDCAPS_BOTHINVSRCALPHA

/*
 * Destination blend capabilities (dwDestBlendCaps)
 */
#define NV4_LINECAPS_DESTBLEND      D3DPBLENDCAPS_ZERO                  |   \
                                    D3DPBLENDCAPS_ONE                   |   \
                                    D3DPBLENDCAPS_SRCCOLOR              |   \
                                    D3DPBLENDCAPS_INVSRCCOLOR           |   \
                                    D3DPBLENDCAPS_SRCALPHA              |   \
                                    D3DPBLENDCAPS_INVSRCALPHA           |   \
                                    D3DPBLENDCAPS_DESTALPHA             |   \
                                    D3DPBLENDCAPS_INVDESTALPHA          |   \
                                    D3DPBLENDCAPS_DESTCOLOR             |   \
                                    D3DPBLENDCAPS_INVDESTCOLOR          |   \
                                    D3DPBLENDCAPS_SRCALPHASAT           |   \
                                    D3DPBLENDCAPS_BOTHSRCALPHA          |   \
                                    D3DPBLENDCAPS_BOTHINVSRCALPHA

/*
 * Alpha compare capabilities (dwAlphaCmpCaps)
 */
#define NV4_LINECAPS_ALPHACMP       D3DPCMPCAPS_NEVER                   |   \
                                    D3DPCMPCAPS_LESS                    |   \
                                    D3DPCMPCAPS_EQUAL                   |   \
                                    D3DPCMPCAPS_LESSEQUAL               |   \
                                    D3DPCMPCAPS_GREATER                 |   \
                                    D3DPCMPCAPS_NOTEQUAL                |   \
                                    D3DPCMPCAPS_GREATEREQUAL            |   \
                                    D3DPCMPCAPS_ALWAYS

/*
 * Shading capabilities (dwShadeCaps)
 */
#define NV4_LINECAPS_SHADE          D3DPSHADECAPS_COLORFLATMONO         |   \
                                    D3DPSHADECAPS_COLORFLATRGB          |   \
                                    D3DPSHADECAPS_COLORGOURAUDMONO      |   \
                                    D3DPSHADECAPS_COLORGOURAUDRGB       |   \
                                    D3DPSHADECAPS_SPECULARFLATRGB       |   \
                                    D3DPSHADECAPS_SPECULARGOURAUDRGB    |   \
                                    D3DPSHADECAPS_ALPHAFLATBLEND        |   \
                                    D3DPSHADECAPS_ALPHAGOURAUDBLEND     |   \
                                    D3DPSHADECAPS_FOGFLAT               |   \
                                    D3DPSHADECAPS_FOGGOURAUD

/*
 * Texture capabilities (dwTextureCaps)
 */
#define NV4_LINECAPS_TEXTURE        D3DPTEXTURECAPS_PERSPECTIVE         |   \
                                    D3DPTEXTURECAPS_POW2                |   \
                                    D3DPTEXTURECAPS_ALPHA               |   \
                                    D3DPTEXTURECAPS_TRANSPARENCY

// ???                                   D3DPTEXTURECAPS_TEXREPEATNOTSCALEDBYSIZE

/*
 * Texture filtering capabilities (dwTextureFilterCaps)
 */
#ifdef  NVD3D_DX6
#define NV4_LINECAPS_TEXTUREFILTER  D3DPTFILTERCAPS_NEAREST             |   \
                                    D3DPTFILTERCAPS_LINEAR              |   \
                                    D3DPTFILTERCAPS_MIPNEAREST          |   \
                                    D3DPTFILTERCAPS_MIPLINEAR           |   \
                                    D3DPTFILTERCAPS_LINEARMIPNEAREST    |   \
                                    D3DPTFILTERCAPS_LINEARMIPLINEAR     |   \
                                    D3DPTFILTERCAPS_MINFPOINT           |   \
                                    D3DPTFILTERCAPS_MINFLINEAR          |   \
                                    D3DPTFILTERCAPS_MIPFPOINT           |   \
                                    D3DPTFILTERCAPS_MIPFLINEAR          |   \
                                    D3DPTFILTERCAPS_MAGFPOINT           |   \
                                    D3DPTFILTERCAPS_MAGFLINEAR

// ???                                    D3DPTFILTERCAPS_MINFANISOTROPIC
// ???                                    D3DPTFILTERCAPS_MAGFANISOTROPIC

#else   // !NVD3D_DX6
#define NV4_LINECAPS_TEXTUREFILTER  D3DPTFILTERCAPS_NEAREST             |   \
                                    D3DPTFILTERCAPS_LINEAR              |   \
                                    D3DPTFILTERCAPS_MIPNEAREST          |   \
                                    D3DPTFILTERCAPS_MIPLINEAR           |   \
                                    D3DPTFILTERCAPS_LINEARMIPNEAREST    |   \
                                    D3DPTFILTERCAPS_LINEARMIPLINEAR
#endif  // !NVD3D_DX6

/*
 * Texture blending capabilities (dwTextureBlendCaps)
 */
#define NV4_LINECAPS_TEXTUREBLEND   D3DPTBLENDCAPS_DECAL                |   \
                                    D3DPTBLENDCAPS_MODULATE             |   \
                                    D3DPTBLENDCAPS_DECALALPHA           |   \
                                    D3DPTBLENDCAPS_MODULATEALPHA        |   \
                                    D3DPTBLENDCAPS_DECALMASK            |   \
                                    D3DPTBLENDCAPS_MODULATEMASK         |   \
                                    D3DPTBLENDCAPS_COPY                 |   \
                                    D3DPTBLENDCAPS_ADD

/*
 * Texture addressing capabilities (dwTextureAddressCaps)
 */
#define NV4_LINECAPS_TEXTUREADDRESS D3DPTADDRESSCAPS_WRAP               |   \
                                    D3DPTADDRESSCAPS_MIRROR             |   \
                                    D3DPTADDRESSCAPS_CLAMP              |   \
                                    D3DPTADDRESSCAPS_INDEPENDENTUV

/*
 * Maximum stipple dimensions.
 */
#define NV4_LINECAPS_STIPPLEWIDTH    0
#define NV4_LINECAPS_STIPPLEHEIGHT   0

/*
 * Put all the line capabilities into the structure.
 */
#define NV4_LINECAPS                                                        \
{                                                                           \
    sizeof(D3DPRIMCAPS),                                                    \
    NV4_LINECAPS_MISC,                                                      \
    NV4_LINECAPS_RASTER,                                                    \
    NV4_LINECAPS_ZCMP,                                                      \
    NV4_LINECAPS_SRCBLEND,                                                  \
    NV4_LINECAPS_DESTBLEND,                                                 \
    NV4_LINECAPS_ALPHACMP,                                                  \
    NV4_LINECAPS_SHADE,                                                     \
    NV4_LINECAPS_TEXTURE,                                                   \
    NV4_LINECAPS_TEXTUREFILTER,                                             \
    NV4_LINECAPS_TEXTUREBLEND,                                              \
    NV4_LINECAPS_TEXTUREADDRESS,                                            \
    NV4_LINECAPS_STIPPLEWIDTH,                                              \
    NV4_LINECAPS_STIPPLEHEIGHT                                              \
}

/*
 * Define the triangle capabilities.
 *
 * Miscellaneous capabilities (dwMiscCaps)
 */
#define NV4_TRICAPS_MISC            D3DPMISCCAPS_MASKZ                  |   \
                                    D3DPMISCCAPS_CULLNONE               |   \
                                    D3DPMISCCAPS_CULLCW                 |   \
                                    D3DPMISCCAPS_CULLCCW
                                    
/*
 * Raster capabilities (dwRasterCaps)
 */
#define NV4_TRICAPS_RASTER          D3DPRASTERCAPS_DITHER               |   \
                                    D3DPRASTERCAPS_SUBPIXEL             |   \
                                    D3DPRASTERCAPS_FOGVERTEX            |   \
                                    D3DPRASTERCAPS_FOGTABLE             |   \
                                    D3DPRASTERCAPS_WFOG                 |   \
                                    D3DPRASTERCAPS_MIPMAPLODBIAS        |   \
                                    D3DPRASTERCAPS_ANISOTROPY           |   \
                                    D3DPRASTERCAPS_WBUFFER

/*
 * Z Compare capabilities (dwZCmpCaps)
 */
#define NV4_TRICAPS_ZCMP            D3DPCMPCAPS_NEVER                   |   \
                                    D3DPCMPCAPS_LESS                    |   \
                                    D3DPCMPCAPS_EQUAL                   |   \
                                    D3DPCMPCAPS_LESSEQUAL               |   \
                                    D3DPCMPCAPS_GREATER                 |   \
                                    D3DPCMPCAPS_NOTEQUAL                |   \
                                    D3DPCMPCAPS_GREATEREQUAL            |   \
                                    D3DPCMPCAPS_ALWAYS

/*
 * Source blend capabilities (dwSrcBlendCaps)
 */
#define NV4_TRICAPS_SRCBLEND        D3DPBLENDCAPS_ZERO                  |   \
                                    D3DPBLENDCAPS_ONE                   |   \
                                    D3DPBLENDCAPS_SRCCOLOR              |   \
                                    D3DPBLENDCAPS_INVSRCCOLOR           |   \
                                    D3DPBLENDCAPS_SRCALPHA              |   \
                                    D3DPBLENDCAPS_INVSRCALPHA           |   \
                                    D3DPBLENDCAPS_DESTALPHA             |   \
                                    D3DPBLENDCAPS_INVDESTALPHA          |   \
                                    D3DPBLENDCAPS_DESTCOLOR             |   \
                                    D3DPBLENDCAPS_INVDESTCOLOR          |   \
                                    D3DPBLENDCAPS_SRCALPHASAT           |   \
                                    D3DPBLENDCAPS_BOTHSRCALPHA          |   \
                                    D3DPBLENDCAPS_BOTHINVSRCALPHA

/*
 * Destination blend capabilities (dwDestBlendCaps)
 */
#define NV4_TRICAPS_DESTBLEND       D3DPBLENDCAPS_ZERO                  |   \
                                    D3DPBLENDCAPS_ONE                   |   \
                                    D3DPBLENDCAPS_SRCCOLOR              |   \
                                    D3DPBLENDCAPS_INVSRCCOLOR           |   \
                                    D3DPBLENDCAPS_SRCALPHA              |   \
                                    D3DPBLENDCAPS_INVSRCALPHA           |   \
                                    D3DPBLENDCAPS_DESTALPHA             |   \
                                    D3DPBLENDCAPS_INVDESTALPHA          |   \
                                    D3DPBLENDCAPS_DESTCOLOR             |   \
                                    D3DPBLENDCAPS_INVDESTCOLOR          |   \
                                    D3DPBLENDCAPS_SRCALPHASAT           |   \
                                    D3DPBLENDCAPS_BOTHSRCALPHA          |   \
                                    D3DPBLENDCAPS_BOTHINVSRCALPHA

/*
 * Alpha compare capabilities (dwAlphaCmpCaps)
 */
#define NV4_TRICAPS_ALPHACMP        D3DPCMPCAPS_NEVER                   |   \
                                    D3DPCMPCAPS_LESS                    |   \
                                    D3DPCMPCAPS_EQUAL                   |   \
                                    D3DPCMPCAPS_LESSEQUAL               |   \
                                    D3DPCMPCAPS_GREATER                 |   \
                                    D3DPCMPCAPS_NOTEQUAL                |   \
                                    D3DPCMPCAPS_GREATEREQUAL            |   \
                                    D3DPCMPCAPS_ALWAYS

/*
 * Shading capabilities (dwShadeCaps)
 */
#define NV4_TRICAPS_SHADE           D3DPSHADECAPS_COLORFLATMONO         |   \
                                    D3DPSHADECAPS_COLORFLATRGB          |   \
                                    D3DPSHADECAPS_COLORGOURAUDMONO      |   \
                                    D3DPSHADECAPS_COLORGOURAUDRGB       |   \
                                    D3DPSHADECAPS_SPECULARFLATRGB       |   \
                                    D3DPSHADECAPS_SPECULARGOURAUDRGB    |   \
                                    D3DPSHADECAPS_ALPHAFLATBLEND        |   \
                                    D3DPSHADECAPS_ALPHAGOURAUDBLEND     |   \
                                    D3DPSHADECAPS_FOGFLAT               |   \
                                    D3DPSHADECAPS_FOGGOURAUD

/*
 * Texture capabilities (dwTextureCaps)
 */
#define NV4_TRICAPS_TEXTURE         D3DPTEXTURECAPS_PERSPECTIVE         |   \
                                    D3DPTEXTURECAPS_POW2                |   \
                                    D3DPTEXTURECAPS_ALPHA               |   \
                                    D3DPTEXTURECAPS_TRANSPARENCY

// ???                                   D3DPTEXTURECAPS_TEXREPEATNOTSCALEDBYSIZE

/*
 * Texture filtering capabilities (dwTextureFilterCaps)
 */
#ifdef  NVD3D_DX6
#define NV4_TRICAPS_TEXTUREFILTER   D3DPTFILTERCAPS_NEAREST             |   \
                                    D3DPTFILTERCAPS_LINEAR              |   \
                                    D3DPTFILTERCAPS_MIPNEAREST          |   \
                                    D3DPTFILTERCAPS_MIPLINEAR           |   \
                                    D3DPTFILTERCAPS_LINEARMIPNEAREST    |   \
                                    D3DPTFILTERCAPS_LINEARMIPLINEAR     |   \
                                    D3DPTFILTERCAPS_MINFPOINT           |   \
                                    D3DPTFILTERCAPS_MINFLINEAR          |   \
                                    D3DPTFILTERCAPS_MIPFPOINT           |   \
                                    D3DPTFILTERCAPS_MIPFLINEAR          |   \
                                    D3DPTFILTERCAPS_MAGFPOINT           |   \
                                    D3DPTFILTERCAPS_MAGFLINEAR          |   \
                                    D3DPTFILTERCAPS_MINFANISOTROPIC     |   \
                                    D3DPTFILTERCAPS_MAGFANISOTROPIC

#else   // !NVD3D_DX6
#define NV4_TRICAPS_TEXTUREFILTER   D3DPTFILTERCAPS_NEAREST             |   \
                                    D3DPTFILTERCAPS_LINEAR              |   \
                                    D3DPTFILTERCAPS_MIPNEAREST          |   \
                                    D3DPTFILTERCAPS_MIPLINEAR           |   \
                                    D3DPTFILTERCAPS_LINEARMIPNEAREST    |   \
                                    D3DPTFILTERCAPS_LINEARMIPLINEAR
#endif  // !NVD3D_DX6

/*
 * Texture blending capabilities (dwTextureBlendCaps)
 */
#define NV4_TRICAPS_TEXTUREBLEND    D3DPTBLENDCAPS_DECAL                |   \
                                    D3DPTBLENDCAPS_MODULATE             |   \
                                    D3DPTBLENDCAPS_DECALALPHA           |   \
                                    D3DPTBLENDCAPS_MODULATEALPHA        |   \
                                    D3DPTBLENDCAPS_DECALMASK            |   \
                                    D3DPTBLENDCAPS_MODULATEMASK         |   \
                                    D3DPTBLENDCAPS_COPY                 |   \
                                    D3DPTBLENDCAPS_ADD

/*
 * Texture addressing capabilities (dwTextureAddressCaps)
 */
#define NV4_TRICAPS_TEXTUREADDRESS  D3DPTADDRESSCAPS_WRAP               |   \
                                    D3DPTADDRESSCAPS_MIRROR             |   \
                                    D3DPTADDRESSCAPS_CLAMP              |   \
                                    D3DPTADDRESSCAPS_INDEPENDENTUV

/*
 * Maximum stipple dimensions.
 */
#define NV4_TRICAPS_STIPPLEWIDTH    0
#define NV4_TRICAPS_STIPPLEHEIGHT   0

/*
 * Put all the triangle capabilities into the structure.
 */
#define NV4_TRICAPS                                                         \
{                                                                           \
    sizeof(D3DPRIMCAPS),                                                    \
    NV4_TRICAPS_MISC,                                                       \
    NV4_TRICAPS_RASTER,                                                     \
    NV4_TRICAPS_ZCMP,                                                       \
    NV4_TRICAPS_SRCBLEND,                                                   \
    NV4_TRICAPS_DESTBLEND,                                                  \
    NV4_TRICAPS_ALPHACMP,                                                   \
    NV4_TRICAPS_SHADE,                                                      \
    NV4_TRICAPS_TEXTURE,                                                    \
    NV4_TRICAPS_TEXTUREFILTER,                                              \
    NV4_TRICAPS_TEXTUREBLEND,                                               \
    NV4_TRICAPS_TEXTUREADDRESS,                                             \
    NV4_TRICAPS_STIPPLEWIDTH,                                               \
    NV4_TRICAPS_STIPPLEHEIGHT                                               \
}

/*
 * Define the render bit depth capabilites.
 */
#define NV4_RENDERBITDEPTHCAPS      (DDBD_16 | DDBD_32)

/*
 * Define the Z buffer bit depth capabilities.
 */
#define NV4_ZBUFFERBITDEPTHCAPS     (DDBD_16 | DDBD_24)

/*
 * Define the maximum execute buffer size capabilites.
 */
#define NV4_MAXBUFFERSIZE           0

/*
 * Define the maximum vertex count
 */
#define NV4_MAXVERTEXCOUNT          NVD3D_DEFAULT_TL_NUM

#ifdef  NVD3D_DX6
#define NV_CAPS_MAX_TEXTURE_REPEAT          0
#define NV_CAPS_MAX_TEXTURE_ASPECT_RATIO    0
#define NV_CAPS_MAX_ANISOTROPY              2 // Means we support anisotropic filtering.
#define NV_CAPS_GUARD_BAND_LEFT             -2048
#define NV_CAPS_GUARD_BAND_TOP              -2048
#define NV_CAPS_GUARD_BAND_RIGHT            2047
#define NV_CAPS_GUARD_BAND_BOTTOM           2047
#define NV_CAPS_EXTENTS_ADJUST              0
#define NV_CAPS_MAX_UV_PAIRS                8 // Number of texture uv's supported.
#define NV_CAPS_FVF_CAPS                    (NV_CAPS_MAX_UV_PAIRS | D3DFVFCAPS_DONOTSTRIPELEMENTS)
#define NV_CAPS_MAX_TEXTURE_BLEND_STATES    4
#define NV_CAPS_MAX_SIMULTANEOUS_TEXTURES   2
#endif  // NVD3D_DX6

#endif  // NV4
#endif  // _NV4DCAPS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\inc\NV4DMAC.H ===
#ifndef _NV4DMAC_H_
#define _NV4DMAC_H_

#ifdef  NV4
/*
 * (C) Copyright NVIDIA Corporation Inc., 1996,1998. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: NV4DMAC.H                                                         *
*   Define various macros used in the D3D driver.                           *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Charles Inman (chasi)       1/26/98 - Created                       *
*                                                                           *
\***************************************************************************/

/*
 * Defining this macro will cause the driver to use the PIO hardware registers
 * when the driver is compiled for PIO.
 * When this macro is not defined, a system memory buffer will be allocated and
 * used in place of the real hardware registers.
 */
#define D3D_HARDWARE
#define DDPUSH

/* 
 * NV Reference Manual register access definitions.
 */
#define BIT(b)                  (1<<(b))
#define DEVICE_BASE(d)          (0?d)
#define DEVICE_EXTENT(d)        (1?d)
#define DRF_SHIFT(drf)          ((0?drf) % 32)
#define DRF_MASK(drf)           (0xFFFFFFFF>>(31-((1?drf) % 32)+((0?drf) % 32)))
#define DRF_DEF(d,r,f,c)        ((NV ## d ## r ## f ## c)<<DRF_SHIFT(NV ## d ## r ## f))
#define DRF_NUM(d,r,f,n)        (((n)&DRF_MASK(NV ## d ## r ## f))<<DRF_SHIFT(NV ## d ## r ## f))
#define DRF_VAL(d,r,f,v)        (((v)>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))
#define REG_WR_DRF_NUM(d,r,f,n) REG_WR32(NV ## d ## r, DRF_NUM(d,r,f,n))
#define REG_WR_DRF_DEF(d,r,f,c) REG_WR32(NV ## d ## r, DRF_DEF(d,r,f,c))
#define FLD_WR_DRF_NUM(d,r,f,n) REG_WR32(NV##d##r,(REG_RD32(NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define FLD_WR_DRF_DEF(d,r,f,c) REG_WR32(NV##d##r,(REG_RD32(NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
#define REG_RD_DRF(d,r,f)       (((REG_RD32(NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))

/*
 * Fast floating point operations.
 */
#define nvFloor(fp,fretval)                             \
{                                                       \
    int fpbits;                                         \
    int expo;                                           \
                                                        \
    if (fp < 0.0f) fp -= 0.9999999f;                    \
    fpbits = *(int *)&fp;                               \
    if ((fpbits >= 0) && (fpbits < 0x3F800000)) {       \
        fretval = 0.0f;                                 \
    }                                                   \
    else {                                              \
        expo = 150 - ((fpbits >> 23) & 0xFF);           \
        if (expo < 1) {                                 \
            fretval = fp;                               \
        }                                               \
        else {                                          \
            fpbits &= 0xFFFFFFFF << expo;               \
            fretval = *(float *)&fpbits;                \
        }                                               \
    }                                                   \
}

/*
 * Number of DWORDS the push macros set.
 */
#define sizeSetSurfaceDmaPush   0
#define sizeSetZBufferDmaPush   0
#define sizeSetHeaderDmaPush    0

/*
 * --------------------------------------------------------------------------
 *  Define some handy macros.
 * --------------------------------------------------------------------------
 */

#ifdef  NVD3D_DX6
#define NEXTINSTRUCTION(ptr, type, num, extrabytes)                             \
    ptr = (LPD3DHAL_DP2COMMAND)((LPBYTE)ptr + sizeof(D3DHAL_DP2COMMAND) +       \
                                ((num) * sizeof(type)) + (extrabytes))

#define NEXTINSTRUCTION_S(ptr, typesize, num, extrabytes)                       \
    ptr = (LPD3DHAL_DP2COMMAND)((LPBYTE)ptr + sizeof(D3DHAL_DP2COMMAND) +       \
                                ((num) * (typesize)) + (extrabytes))

#define GET_FVF_POINTER(ptr, lpvert, mask, offset, index, stride)               \
    (ptr) = (DWORD)((((DWORD)(lpvert) + ((index) * (stride))) & (DWORD)(mask))  \
          + (offset));
#endif  // NVD3D_DX6

/*
 * Function index calculation
 *      4 fog modes - straight, supersampled, edgeAA (only for non-alphablended)
 */
#ifndef NV_FASTLOOPS
#ifdef FLOAT_W
#define _CALC_FUNCTION_INDEX(_ctx_ptr)                                                              \
                                   ((_ctx_ptr)->dwRenderState[D3DRENDERSTATE_FOGENABLE]             \
                                 ?  (_ctx_ptr)->dwRenderState[D3DRENDERSTATE_FOGTABLEMODE]          \
                                 :  0)
#else // fixed w
#define _CALC_FUNCTION_INDEX(_ctx_ptr)                                                              \
                                  (((_ctx_ptr)->dwRenderState[D3DRENDERSTATE_FOGENABLE]             \
                                 ?  (_ctx_ptr)->dwRenderState[D3DRENDERSTATE_FOGTABLEMODE]          \
                                 :  0)                                                              \
                                | (((_ctx_ptr)->dwRenderState[D3DRENDERSTATE_ZENABLE] == D3DZB_USEW)\
                                 ?  4                                                               \
                                 :  0))
#endif // fixed w
#define CALC_FUNCTION_INDEX(_ctx_ptr)                                                       \
{                                                                                           \
    (_ctx_ptr)->dwFunctionLookup = ((_ctx_ptr)->dwAntiAliasFlags & AA_ENABLED_MASK)         \
                                 ? NV_AA_FUNCTION_INDEX                                     \
                                 : (_CALC_FUNCTION_INDEX(_ctx_ptr));                        \
}
#else //NV_FASTLOOPS
/*
// basic flags
#define FIFLAG_FOGMODE          0x00000003
#define FIFLAG_INDEXED          0x00000004
#define FIFLAG_FVF              0x00000008
#define FIFLAG_DX6              0x00000010
#define FIFLAG_MMX              0x00000020
#define FIFLAG_MAXIMUM          0x0000003f

// flag macros
#define MODFLAGS_DX5(x)             (((x) & (FIFLAG_FOGMODE)))
#define MODFLAGS_DX5FVF(x)          (((x) & (FIFLAG_FOGMODE)) | (FIFLAG_FVF))
#define MODFLAGS_DX5INDEXED(x)      (((x) & (FIFLAG_FOGMODE)) | (FIFLAG_INDEXED))
#define MODFLAGS_DX5FVFINDEXED(x)   (((x) & (FIFLAG_FOGMODE)) | (FIFLAG_FVF | FIFLAG_INDEXED))

// aa not included
#define _CALC_FUNCTION_INDEX(_ctx,_indices,_storage)                    \
        (((_ctx)->dwRenderState[D3DRENDERSTATE_FOGENABLE] ? (_ctx)->dwRenderState[D3DRENDERSTATE_FOGTABLEMODE] : 0)\
       | ((_inidices) ? FIFLAG_INDEXED : 0)                             \
       | ((fxfData.dwVertexType == D3DFVF_TLVERTEX) ? 0 : FIFLAG_FVF)   \
       | ((_ctx)->bUseDX6Class ? (FIFLAG_DX6 | FIFLAG_FVF) : 0)         \
       | (global.bIsMMX ? FIFLAG_MMX : 0))

// aa included
#define CALC_FUNCTION_INDEX(_ctx,_indices,_storage)              \
{                                                                \
    (_storage)  = ((_ctx)->dwAntiAliasFlags & AA_ENABLED_MASK)   \
                ? NV_AA_FUNCTION_INDEX                           \
                : _CALC_FUNCTION_INDEX(_ctx,_indices,_storage);  \
}
// code creation code
#define LOAD_FUNCTION_INDEX(_funcIndex)                                 \
{                                                                       \
    if (!fnDrawPrimitiveTabel[_funcIndex])                              \
        fnDrawPrimitiveTabel[_funcIndex] = ILCCompileCode(_funcIndex);  \
}
*/
#endif //NV_FASTLOOPS

/*
 * Need to make sure that an unfriendly mode switch didn't sneak and not cause
 * us to get re-enabled properly.
 */
#define DOS_FULLSCREEN_CHECK(pp)

/*
 * Set up all the current context state per call.  This should be as efficient as
 * possible as it is executed for every rendering entrypoint.
 */
#define SET_CURRENT_CONTEXT(pp)                                                 \
{                                                                               \
    if (!(pCurrentContext = (PNVD3DCONTEXT)(pp)->dwhContext))                   \
    {                                                                           \
        DPF("D3D: - Bad Context");                                              \
        (pp)->ddrval = D3DHAL_CONTEXT_BAD;                                      \
        return (DDHAL_DRIVER_HANDLED);                                          \
    }                                                                           \
    if (!pCurrentContext->lpLcl)                                                \
    {                                                                           \
        (pp)->ddrval = D3DHAL_CONTEXT_BAD;                                      \
        return (DDHAL_DRIVER_HANDLED);                                          \
    }                                                                           \
}

/*
 * Macro for fog table calculation. (others are elsewhere, should consolidate).
 */
#define FP_NORM_TO_BIT24(i,p)                                                \
{                                                                            \
    float _n = (p) + 1.0f;                                                   \
    (i) = *(int *)&_n;                                                       \
    if ((i) >= 0x40000000)     (i) = 0xFF000000;                             \
    else if ((i) <=0x3F800000) (i) = 0;                                      \
    else (i) = ((i) << 9) & 0xFF000000;                                      \
}

/*
 * Some cool macros for use during texture swizzling.
 */

// the goal here is to interleave bits (pushing all higher order
// bits to the left as we go) until the texture width exceeds the
// height. at that point, we treat square chunks of the texture as 
// swizzled 'blocks' that are indexed linearly by the higher order
// bits above those that are interleaved. (thus, we freeze the value
// of 'shift' when bit == h) 
 
#define U_INTERLEAVE(u,uu,w,h)                              \
{                                                           \
    int bit,shift;                                          \
    u = 0;                                                  \
    if (uu != 0)                                            \
    {                                                       \
        shift = 0;                                          \
        for (bit = 1; bit < (int)(w); bit <<= 1)            \
        {                                                   \
            u |= (uu & bit) << shift;                       \
            if (bit < (int)(h)) shift++;                    \
        }                                                   \
    }                                                       \
}
#define U_UNINTERLEAVE(u,uu,w,h)                            \
{                                                           \
    int bit, shift;                                         \
    u = 0;                                                  \
    shift = 0;                                              \
    for (bit = 1; bit < (int)(w); bit << = 1)               \
    {                                                       \
        u |= (uu >> shift) & bit;                           \
        if (bit < (int)(h)) shift++;                        \
    }                                                       \
}
#define V_INTERLEAVE(v,vv,w,h)                              \
{                                                           \
    int bit,shift;                                          \
    v = 0;                                                  \
    if (vv != 0)                                            \
    {                                                       \
        shift = 0;                                          \
        for (bit = 1; bit < (int)(h); bit <<= 1)            \
        {                                                   \
            if (bit < (int)(w)) shift++;                    \
            v |= (vv & bit) << shift;                       \
        }                                                   \
    }                                                       \
}
#define V_UNINTERLEAVE(v,vv,w,h)                            \
{                                                           \
    int bit,shift;                                          \
    v = 0;                                                  \
    shift = 0;                                              \
    for (bit = 1; bit < (int)(h); bit <<= 1)                \
    {                                                       \
        if (bit < (int)(w)) shift++;                        \
        v |= (vv >> shift) & bit;                           \
    }                                                       \
}
#define U_INC_MASK(i,m,h)                                   \
{                                                           \
    int logh;                                               \
    int hh = (int)(h) - 1;                                  \
    for (logh = 0; hh != 0; hh >>= 1, logh++);              \
    m = ((1 << (2 * logh)) - 1);                            \
    i = (0xAAAAAAAA & m) + 1;                               \
    m = (0x55555555 & m) | (~m);                            \
}
#define U_INC2_MASK(i1,i2,m,h)                              \
{                                                           \
    int logh;                                               \
    int hh = (int)(h) - 1;                                  \
    for (logh = 0; hh != 0; hh >>= 1,logh++);               \
    m = ((1 << (2 * logh)) - 1);                            \
    i1 = (0xAAAAAAAA & m) + 1;                              \
    i2 = (0xAAAAAAAA & m) + 2;                              \
    m = (0x55555555 & m) | (~m);                            \
}
#define V_INC_MASK(i,m,w)                                   \
{                                                           \
    int logw;                                               \
    int ww = (int)(w) - 1;                                  \
    for (logw = 0; ww != 0; ww >>= 1, logw++);              \
    m = ((1 << (2 * logw)) - 1);                            \
    i = (0x55555555 & m) + 1;                               \
    m = (0xAAAAAAAA & m) | (~m);                            \
}
#define UV_INC(uv,i,m)      (((uv) + i) & m)
#define UV_OFFSET(uu,vv)    ((uu) | (vv))

/*
 *
 */
#define NV_D3D_GLOBAL_SETUP()                                               \
{                                                                           \
    nvDmaPushBase      = pDriverData->NvDmaPusherBufferBase;                \
    nvDmaPushOffsetMax = pDriverData->dwDmaPushOffsetMax;                   \
    nvFifo             = pDriverData->NvDmaPusherPutAddress;                \
    if (pDriverData->TwoDRenderingOccurred)                                 \
        nvDmaLastPutAddr = nvFifo;                                          \
}
#define NV_D3D_GLOBAL_SAVE()                                                \
{                                                                           \
    pDriverData->NvDmaPusherPutAddress = nvFifo;                            \
}

#define NV_D3D_CONTEXT_SETUP()                                              \
{                                                                           \
}

#if D3D_PUSH
/*
 * Hardware connection macros.
 */
#ifdef  D3D_HARDWARE
#define nvglOpenChannel(handle, address, size, fifo)                        \
{                                                                           \
    if (pDriverData->GARTLinearBase > 0)                                    \
    {                                                                       \
        (handle) = (DWORD)AllocAGPHeap(pCurrentContext->lpLcl->lpGbl->lpDD, size); \
        (address) = (handle);                                               \
    }                                                                       \
    else                                                                    \
    {                                                                       \
        (handle)  = (DWORD)HeapCreate(HEAP_SHARED, (size), 0);              \
        (address) = (DWORD)HeapAlloc((HANDLE)(handle), HEAP_ZERO_MEMORY, (size)); \
    }                                                                       \
    (fifo)    = NvOpenDma(0, NvGetFlatDataSelector(), (int)(address), (int)((size) - 1)); \
}
#define nvglCloseChannel(handle, address, fifo)                             \
{                                                                           \
    NvClose((NvChannel *)(fifo));                                           \
    if (pDriverData->GARTLinearBase > 0)                                    \
    {                                                                       \
        FreeAGPHeap(pCurrentContext->lpLcl->lpGbl->lpDD, (handle));         \
    }                                                                       \
    else                                                                    \
    {                                                                       \
        HeapFree((HANDLE)(handle), 0, (PVOID)(address));                    \
        HeapDestroy((HANDLE)(handle));                                      \
    }                                                                       \
    (fifo)    = 0;                                                          \
    (handle)  = (DWORD)0;                                                   \
    (address) = (DWORD)0;                                                   \
}
#else   // D3D_EMULATION
#define nvglOpenChannel(handle, address, size, fifo)                        \
{                                                                           \
    (handle)  = (DWORD)HeapCreate(HEAP_SHARED, (size), 0);                  \
    (address) = (DWORD)HeapAlloc((HANDLE)(handle), HEAP_ZERO_MEMORY, (size)); \
    (fifo)    = 0;                                                          \
}
#define nvglCloseChannel(handle, address, fifo)                             \
{                                                                           \
    HeapFree((HANDLE)(handle), 0, (PVOID)(address));                        \
    HeapDestroy((HANDLE)(handle));                                          \
    (fifo)    = 0;                                                          \
    (handle)  = (DWORD)0;                                                   \
    (address) = (DWORD)0;                                                   \
}
#endif  // D3D_EMULATION

/*
 * DMA Pusher macros
 */
#define nvglGetFreeCount(fifo, freecount, ch, size)                         \
    (freecount) = nvGetDmaFreeCount((long)(size));

#define sizeSetObject                       2
#define nvglSetObject(fifo, freecount, ch, obj)                             \
{                                                                           \
    ((DWORD *)(fifo))[0] = (0x00040000 | ((ch) << 13));                     \
    ((DWORD *)(fifo))[1] = obj;                                             \
    (DWORD *)(fifo) += sizeSetObject;                                       \
    freecount -= sizeSetObject;                                             \
}
#define sizeSetStartMethod                  1
#define nvglSetStartMethod(fifo, freecount, ch, method, methodcount)        \
{                                                                           \
    ((DWORD *)(fifo))[0] = ((((methodcount) << 2) << 16) | ((ch) << 13) | (method)); \
    (DWORD *)(fifo) += sizeSetStartMethod;                                  \
    freecount -= sizeSetStartMethod;                                        \
}
#define sizeSetData                         1
#define nvglSetData(fifo, freecount, data)                                  \
{                                                                           \
    ((DWORD *)(fifo))[0] = (data);                                          \
    (DWORD *)(fifo) += sizeSetData;                                         \
    freecount -= sizeSetData;                                               \
}

/*
 * Create Object macro.
 */
#define sizeCreateObjectMthdCnt             1
#define sizeCreateObject                    2
#define nvglCreateObject(fifo, freecount, ch, obj)                          \
{                                                                           \
    ((DWORD *)(fifo))[0] = NVFFF_CREATE((ch)) | ((sizeCreateObjectMthdCnt << 2) << 16); \
    ((DWORD *)(fifo))[1] = (obj);                                           \
    (DWORD *)(fifo) += sizeCreateObject;                                    \
    freecount -= sizeCreateObject;                                          \
}

/*
 * Destroy Object macro.
 */
#define sizeDestroyObjectMthdCnt            1
#define sizeDestroyObject                   2
#define nvglDestroyObject(fifo, freecount, ch, obj)                         \
{                                                                           \
    ((DWORD *)(fifo))[0] = NVFFF_DESTROY((ch)) | ((sizeDestroyObjectMthdCnt << 2) << 16); \
    ((DWORD *)(fifo))[1] = (obj);                                           \
    (DWORD *)(fifo) += sizeDestroyObject;                                   \
    freecount -= sizeDestroyObject;                                         \
}

/*
 * Define DX5 Triangle class macros.
 */
#define sizeSetDx5TriangleContextsMthdCnt   2
#define sizeSetDx5TriangleContexts          3
#define nvglSetDx5TriangleContexts(fifo, freecount, ch, ctxa, ctxb)         \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((sizeSetDx5TriangleContextsMthdCnt << 2) << 16) | ((ch) << 13) | NV054_SET_CONTEXT_DMA_A); \
    ((DWORD *)(fifo))[1] = (ctxa);                                          \
    ((DWORD *)(fifo))[2] = (ctxb);                                          \
    (DWORD *)(fifo) += sizeSetDx5TriangleContexts;                          \
    freecount -= sizeSetDx5TriangleContexts;                                \
}
#define sizeSetDx5TriangleSurfaceMthdCnt    1
#define sizeSetDx5TriangleSurface           2
#define nvglSetDx5TriangleSurface(fifo, freecount, ch, ctxs)                \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((sizeSetDx5TriangleSurfaceMthdCnt << 2) << 16) | ((ch) << 13) | NV054_SET_CONTEXT_SURFACES); \
    ((DWORD *)(fifo))[1] = (ctxs);                                          \
    (DWORD *)(fifo) += sizeSetDx5TriangleSurface;                           \
    freecount -= sizeSetDx5TriangleSurface;                                 \
}
#define sizeDx5TriangleStateMthdCnt         7
#define sizeDx5TriangleState                8
#define nvglDx5TriangleState(fifo, freecount, ch,                           \
                             ckey, offset, format, filter,                  \
                             blend, control, fogcolor)                      \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((sizeDx5TriangleStateMthdCnt << 2) << 16) | ((ch) << 13) | NV054_COLOR_KEY); \
    ((DWORD *)(fifo))[1] = (ckey);                                          \
    ((DWORD *)(fifo))[2] = (offset);                                        \
    ((DWORD *)(fifo))[3] = (format);                                        \
    ((DWORD *)(fifo))[4] = (filter);                                        \
    ((DWORD *)(fifo))[5] = (blend);                                         \
    ((DWORD *)(fifo))[6] = (control);                                       \
    ((DWORD *)(fifo))[7] = (fogcolor);                                      \
    (DWORD *)(fifo) += sizeDx5TriangleState;                                \
    freecount -= sizeDx5TriangleState;                                      \
}

/*
 * Unused Vertex Macros - good reference
 */
/*
#define sizeDx5TriangleTLVertexMthdCnt      8
#define sizeDx5TriangleTLVertex             9
#define nvglDx5TriangleTLVertex(fifo, freecount, ch, alias, vd)             \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((sizeDx5TriangleTLVertexMthdCnt << 2) << 16) | ((ch) << 13) | NV054_TLVERTEX((alias))); \
    ((DWORD *)(fifo))[1] = *(U032 *)&(vd.sx);                               \
    ((DWORD *)(fifo))[2] = *(U032 *)&(vd.sy);                               \
    ((DWORD *)(fifo))[3] = *(U032 *)&(vd.sz);                               \
    ((DWORD *)(fifo))[4] = *(U032 *)&(vd.rhw);                              \
    ((DWORD *)(fifo))[5] = (vd.color);                                      \
    ((DWORD *)(fifo))[6] = (vd.specular);                                   \
    ((DWORD *)(fifo))[7] = *(U032 *)&(vd.tu);                               \
    ((DWORD *)(fifo))[8] = *(U032 *)&(vd.tv);                               \
    (DWORD *)(fifo) += sizeDx5TriangleTLVertex;                             \
    freecount -= sizeDx5TriangleTLVertex;                                   \
    dbgDisplayVertexData(*(DWORD *)&(vd.sx),  *(DWORD *)&(vd.sy),  *(DWORD *)&(vd.sz),  \
                         *(DWORD *)&(vd.rhw),  (DWORD)vd.color,     (DWORD)vd.specular, \
                         *(DWORD *)&(vd.tu),  *(DWORD *)&(vd.tv));                      \
}
#define nvglDx5TriangleTLVertexExpFog(fifo, freecount, ch, alias, vd)       \
{                                                                           \
    float ffog, z;                                                          \
    int   ifog, specular;                                                   \
    specular  = (vd.specular) & 0x00FFFFFF;                                 \
    FP_INV(z, (vd.rhw));                                                    \
    ffog  = z * pCurrentContext->fFogTableDensity;                          \
    FP_EXP(ffog, ffog);                                                     \
    FP_NORM_TO_BIT24(ifog, ffog);                                           \
    specular |= ifog;                                                       \
    ((DWORD *)(fifo))[0] = (((sizeDx5TriangleTLVertexMthdCnt << 2) << 16) | ((ch) << 13) | NV054_TLVERTEX((alias))); \
    ((DWORD *)(fifo))[1] = *(U032 *)&(vd.sx);                               \
    ((DWORD *)(fifo))[2] = *(U032 *)&(vd.sy);                               \
    ((DWORD *)(fifo))[3] = *(U032 *)&(vd.sz);                               \
    ((DWORD *)(fifo))[4] = *(U032 *)&(vd.rhw);                              \
    ((DWORD *)(fifo))[5] = (vd.color);                                      \
    ((DWORD *)(fifo))[6] = specular;                                        \
    ((DWORD *)(fifo))[7] = *(U032 *)&(vd.tu);                               \
    ((DWORD *)(fifo))[8] = *(U032 *)&(vd.tv);                               \
    (DWORD *)(fifo) += sizeDx5TriangleTLVertex;                             \
    freecount -= sizeDx5TriangleTLVertex;                                   \
    dbgDisplayVertexData(*(DWORD *)&(vd.sx),  *(DWORD *)&(vd.sy),  *(DWORD *)&(vd.sz),  \
                         *(DWORD *)&(vd.rhw),  (DWORD)vd.color,     (DWORD)vd.specular, \
                         *(DWORD *)&(vd.tu),  *(DWORD *)&(vd.tv));                      \
}
#define nvglDx5TriangleTLVertexExp2Fog(fifo, freecount, ch, alias, vd)      \
{                                                                           \
    float ffog, z;                                                          \
    int   ifog, specular;                                                   \
    specular  = (vd.specular) & 0x00FFFFFF;                                 \
    FP_INV(z, (vd.rhw));                                                    \
    ffog  = z * pCurrentContext->fFogTableDensity;                          \
    ffog *= ffog;                                                           \
    FP_EXP(ffog, ffog);                                                     \
    FP_NORM_TO_BIT24(ifog, ffog);                                           \
    specular |= ifog;                                                       \
    ((DWORD *)(fifo))[0] = (((sizeDx5TriangleTLVertexMthdCnt << 2) << 16) | ((ch) << 13) | NV054_TLVERTEX((alias))); \
    ((DWORD *)(fifo))[1] = *(U032 *)&(vd.sx);                               \
    ((DWORD *)(fifo))[2] = *(U032 *)&(vd.sy);                               \
    ((DWORD *)(fifo))[3] = *(U032 *)&(vd.sz);                               \
    ((DWORD *)(fifo))[4] = *(U032 *)&(vd.rhw);                              \
    ((DWORD *)(fifo))[5] = (vd.color);                                      \
    ((DWORD *)(fifo))[6] = specular;                                        \
    ((DWORD *)(fifo))[7] = *(U032 *)&(vd.tu);                               \
    ((DWORD *)(fifo))[8] = *(U032 *)&(vd.tv);                               \
    (DWORD *)(fifo) += sizeDx5TriangleTLVertex;                             \
    freecount -= sizeDx5TriangleTLVertex;                                   \
    dbgDisplayVertexData(*(DWORD *)&(vd.sx),  *(DWORD *)&(vd.sy),  *(DWORD *)&(vd.sz),  \
                         *(DWORD *)&(vd.rhw),  (DWORD)vd.color,     (DWORD)vd.specular, \
                         *(DWORD *)&(vd.tu),  *(DWORD *)&(vd.tv));                      \
}
#define nvglDx5TriangleTLVertexLinearFog(fifo, freecount, ch, alias, vd)    \
{                                                                           \
    float ffog, z;                                                          \
    int   ifog, specular;                                                   \
    specular  = (vd.specular) & 0x00FFFFFF;                                 \
    FP_INV(z, (vd.rhw));                                                    \
    ffog = (pCurrentContext->fFogTableEnd - z) * pCurrentContext->fFogTableLinearScale; \
    FP_NORM_TO_BIT24(ifog, ffog);                                           \
    specular |= ifog;                                                       \
    ((DWORD *)(fifo))[0] = (((sizeDx5TriangleTLVertexMthdCnt << 2) << 16) | ((ch) << 13) | NV054_TLVERTEX((alias))); \
    ((DWORD *)(fifo))[1] = *(U032 *)&(vd.sx);                               \
    ((DWORD *)(fifo))[2] = *(U032 *)&(vd.sy);                               \
    ((DWORD *)(fifo))[3] = *(U032 *)&(vd.sz);                               \
    ((DWORD *)(fifo))[4] = *(U032 *)&(vd.rhw);                              \
    ((DWORD *)(fifo))[5] = (vd.color);                                      \
    ((DWORD *)(fifo))[6] = specular;                                        \
    ((DWORD *)(fifo))[7] = *(U032 *)&(vd.tu);                               \
    ((DWORD *)(fifo))[8] = *(U032 *)&(vd.tv);                               \
    (DWORD *)(fifo) += sizeDx5TriangleTLVertex;                             \
    freecount -= sizeDx5TriangleTLVertex;                                   \
    dbgDisplayVertexData(*(DWORD *)&(vd.sx),  *(DWORD *)&(vd.sy),  *(DWORD *)&(vd.sz),  \
                         *(DWORD *)&(vd.rhw),  (DWORD)vd.color,     (DWORD)vd.specular, \
                         *(DWORD *)&(vd.tu),  *(DWORD *)&(vd.tv));                      \
}
*/

#define sizeDx5TriangleDrawPrimitiveMthdCnt 1
#define sizeDx5TriangleDrawPrimitive        2
#define nvglDx5TriangleDrawPrimitive(fifo, freecount, ch, alias, vertices)  \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((sizeDx5TriangleDrawPrimitiveMthdCnt << 2) << 16) | ((ch) << 13) | NV054_DRAW_PRIMITIVE((alias))); \
    ((DWORD *)(fifo))[1] = (vertices);                                      \
    (DWORD *)(fifo) += sizeDx5TriangleDrawPrimitive;                        \
    freecount -= sizeDx5TriangleDrawPrimitive;                              \
}
#define sizeDx5TriangleNotify               4
#define nvglDx5TriangleNotify(fifo, freecount, ch)                          \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((1 << 2) << 16) | ((ch) << 13) | NV054_NOTIFY);\
    ((DWORD *)(fifo))[1] = NV054_NOTIFY_WRITE_ONLY;                         \
    ((DWORD *)(fifo))[2] = (((1 << 2) << 16) | ((ch) << 13) | NV054_NO_OPERATION); \
    ((DWORD *)(fifo))[3] = 0x00000000;                                      \
    (DWORD *)(fifo) += sizeDx5TriangleNotify;                               \
    freecount -= sizeDx5TriangleNotify;                                     \
}

/*
 * Define DX6 Triangle class macros.
 */
#define sizeSetDx6TriangleContextsMthdCnt   2
#define sizeSetDx6TriangleContexts          3
#define nvglSetDx6TriangleContexts(fifo, freecount, ch, ctxa, ctxb)         \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((sizeSetDx6TriangleContextsMthdCnt << 2) << 16) | ((ch) << 13) | NV055_SET_CONTEXT_DMA_A); \
    ((DWORD *)(fifo))[1] = (ctxa);                                          \
    ((DWORD *)(fifo))[2] = (ctxb);                                          \
    (DWORD *)(fifo) += sizeSetDx6TriangleContexts;                          \
    freecount -= sizeSetDx6TriangleContexts;                                \
}
#define sizeSetDx6TriangleSurfaceMthdCnt    1
#define sizeSetDx6TriangleSurface           2
#define nvglSetDx6TriangleSurface(fifo, freecount, ch, ctxs)                \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((sizeSetDx6TriangleSurfaceMthdCnt << 2) << 16) | ((ch) << 13) | NV055_SET_CONTEXT_SURFACES); \
    ((DWORD *)(fifo))[1] = (ctxs);                                          \
    (DWORD *)(fifo) += sizeSetDx6TriangleSurface;                           \
    freecount -= sizeSetDx6TriangleSurface;                                 \
}
#define sizeDx6TriangleOffsetMthdCnt        1
#define sizeDx6TriangleOffset               2
#define nvglDx6TriangleOffset(fifo, freecount, ch,                          \
                              offset, buffer)                               \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((sizeDx6TriangleOffsetMthdCnt << 2) << 16) | ((ch) << 13) | NV055_OFFSET(buffer)); \
    ((DWORD *)(fifo))[1] = (offset);                                        \
    (DWORD *)(fifo) += sizeDx6TriangleOffset;                               \
    freecount -= sizeDx6TriangleOffset;                                     \
}
#define sizeDx6TriangleFormatMthdCnt        1
#define sizeDx6TriangleFormat               2
#define nvglDx6TriangleFormat(fifo, freecount, ch,                          \
                              format, buffer)                               \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((sizeDx6TriangleFormatMthdCnt << 2) << 16) | ((ch) << 13) | NV055_FORMAT(buffer)); \
    ((DWORD *)(fifo))[1] = (format);                                        \
    (DWORD *)(fifo) += sizeDx6TriangleFormat;                               \
    freecount -= sizeDx6TriangleFormat;                                     \
}
#define sizeDx6TriangleFilterMthdCnt        1
#define sizeDx6TriangleFilter               2
#define nvglDx6TriangleFilter(fifo, freecount, ch,                          \
                              filter, buffer)                               \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((sizeDx6TriangleFilterMthdCnt << 2) << 16) | ((ch) << 13) | NV055_FILTER(buffer)); \
    ((DWORD *)(fifo))[1] = (filter);                                        \
    (DWORD *)(fifo) += sizeDx6TriangleFilter;                               \
    freecount -= sizeDx6TriangleFilter;                                     \
}
#define sizeDx6TriangleStageState           12
#define nvglDx6TriangleStageState(fifo, freecount, ch,                      \
                                  c0alpha, c0color, c1alpha, c1color,       \
                                  factor, blend,                            \
                                  control0, control1, control2,             \
                                  fogcolor)                                 \
{                                                                           \
    ((DWORD *)(fifo))[0]  = (((2 << 2) << 16) | ((ch) << 13) | NV055_COMBINE_0_ALPHA); \
    ((DWORD *)(fifo))[1]  = (c0alpha);                                      \
    ((DWORD *)(fifo))[2]  = (c0color);                                      \
    ((DWORD *)(fifo))[3]  = (((8 << 2) << 16) | ((ch) << 13) | NV055_COMBINE_1_ALPHA); \
    ((DWORD *)(fifo))[4]  = (c1alpha);                                      \
    ((DWORD *)(fifo))[5]  = (c1color);                                      \
    ((DWORD *)(fifo))[6]  = (factor);                                       \
    ((DWORD *)(fifo))[7]  = (blend);                                        \
    ((DWORD *)(fifo))[8]  = (control0);                                     \
    ((DWORD *)(fifo))[9]  = (control1);                                     \
    ((DWORD *)(fifo))[10] = (control2);                                     \
    ((DWORD *)(fifo))[11] = (fogcolor);                                     \
    (DWORD *)(fifo) += sizeDx6TriangleStageState;                           \
    freecount -= sizeDx6TriangleStageState;                                 \
}
#define sizeDX6TriangleState    (((sizeDx6TriangleOffset + sizeDx6TriangleFormat + sizeDx6TriangleFilter) * 2) + sizeDx6TriangleStageState)

#define sizeDx6TriangleTLVertexMthdCnt      10
#define sizeDx6TriangleTLVertex1            11
#define nvglDx6TriangleTLVertex(fifo, freecount, ch, alias, vd)             \
{                                                                           \
    ((DWORD *)(fifo))[0]  = (((sizeDx6TriangleTLVertexMthdCnt << 2) << 16) | ((ch) << 13) | NV055_TLMTVERTEX((alias))); \
    ((DWORD *)(fifo))[1]  = *(U032 *)&(vd.sx);                              \
    ((DWORD *)(fifo))[2]  = *(U032 *)&(vd.sy);                              \
    ((DWORD *)(fifo))[3]  = *(U032 *)&(vd.sz);                              \
    ((DWORD *)(fifo))[4]  = *(U032 *)&(vd.rhw);                             \
    ((DWORD *)(fifo))[5]  = (vd.color);                                     \
    ((DWORD *)(fifo))[6]  = (vd.specular);                                  \
    ((DWORD *)(fifo))[7]  = *(U032 *)&(vd.tu);                              \
    ((DWORD *)(fifo))[8]  = *(U032 *)&(vd.tv);                              \
    ((DWORD *)(fifo))[9]  = 0;                                              \
    ((DWORD *)(fifo))[10] = 0;                                              \
    (DWORD *)(fifo) += sizeDx6TriangleTLVertex1;                            \
    freecount -= sizeDx6TriangleTLVertex1;                                  \
    dbgDisplayVertexData(*(DWORD *)&(vd.sx),  *(DWORD *)&(vd.sy),  *(DWORD *)&(vd.sz),  \
                         *(DWORD *)&(vd.rhw),  (DWORD)vd.color,     (DWORD)vd.specular, \
                         *(DWORD *)&(vd.tu),  *(DWORD *)&(vd.tv));          \
}

#define sizeDx6TriangleDrawPrimitiveMthdCnt 1
#define sizeDx6TriangleDrawPrimitive        2
#define nvglDx6TriangleDrawPrimitive(fifo, freecount, ch, alias, vertices)  \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((sizeDx6TriangleDrawPrimitiveMthdCnt << 2) << 16) | ((ch) << 13) | NV055_DRAW_PRIMITIVE((alias))); \
    ((DWORD *)(fifo))[1] = (vertices);                                      \
    (DWORD *)(fifo) += sizeDx6TriangleDrawPrimitive;                        \
    freecount -= sizeDx6TriangleDrawPrimitive;                              \
}

/*
 * Define NV4 Render Solid Rectangle class macros.
 */
#define sizeSetNv4SolidRectangleSurfaceMthdCnt  1
#define sizeSetNv4SolidRectangleSurface         2
#define nvglSetNv4SolidRectangleSurface(fifo, freecount, ch, ctx)           \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((sizeSetNv4SolidRectangleSurfaceMthdCnt << 2) << 16) | ((ch) << 13) | NV05E_SET_CONTEXT_SURFACE); \
    ((DWORD *)(fifo))[1] = (ctx);                                           \
    (DWORD *)(fifo) += sizeSetNv4SolidRectangleSurface;                     \
    freecount -= sizeSetNv4SolidRectangleSurface;                           \
}

#define sizeSetNv4SolidRectangleOperationMthdCnt    1
#define sizeSetNv4SolidRectangleOperation           2
#define nvglSetNv4SolidRectangleOperation(fifo, freecount, ch, op)          \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((sizeSetNv4SolidRectangleOperationMthdCnt << 2) << 16) | ((ch) << 13) | NV05E_SET_OPERATION); \
    ((DWORD *)(fifo))[1] = (op);                                            \
    (DWORD *)(fifo) += sizeSetNv4SolidRectangleOperation;                   \
    freecount -= sizeSetNv4SolidRectangleOperation;                         \
}

#define sizeSetNv4SolidRectangleColorFormatMthdCnt  1
#define sizeSetNv4SolidRectangleColorFormat         2
#define nvglSetNv4SolidRectangleColorFormat(fifo, freecount, ch, cfmt)      \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((sizeSetNv4SolidRectangleColorFormatMthdCnt << 2) << 16) | ((ch) << 13) | NV05E_SET_COLOR_FORMAT); \
    ((DWORD *)(fifo))[1] = (cfmt);                                          \
    (DWORD *)(fifo) += sizeSetNv4SolidRectangleColorFormat;                 \
    freecount -= sizeSetNv4SolidRectangleColorFormat;                       \
}

#define sizeNv4SolidRectangleColorMthdCnt           1
#define sizeNv4SolidRectangleColor                  2
#define nvglNv4SolidRectangleColor(fifo, freecount, ch, color)              \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((sizeNv4SolidRectangleColorMthdCnt << 2) << 16) | ((ch) << 13) | NV05E_COLOR); \
    ((DWORD *)(fifo))[1] = (color);                                         \
    (DWORD *)(fifo) += sizeNv4SolidRectangleColor;                          \
    freecount -= sizeNv4SolidRectangleColor;                                \
}

#define sizeNv4SolidRectanglePointSizeMthdCnt       2
#define sizeNv4SolidRectanglePointSize              3
#define nvglNv4SolidRectanglePointSize(fifo, freecount, ch,                 \
                                       x, y, width, height)                 \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((sizeNv4SolidRectanglePointSizeMthdCnt << 2) << 16) | ((ch) << 13) | NV05E_RECTANGLE(0)); \
    ((DWORD *)(fifo))[1] = ((((y) & 0x0000FFFF) << 16) | ((x) & 0x0000FFFF)); \
    ((DWORD *)(fifo))[2]  = ((((height) & 0x0000FFFF) << 16) | ((width) & 0x0000FFFF)); \
    (DWORD *)(fifo) += sizeNv4SolidRectanglePointSize;                      \
    freecount -= sizeNv4SolidRectanglePointSize;                            \
}

/*
 * Define Context Surfaces ARGB Zeta/Stencil macros.
 */
#define sizeSetRenderTargetContextsMthdCnt  2
#define sizeSetRenderTargetContexts         3
#define nvglSetRenderTargetContexts(fifo, freecount, ch,                    \
                                    ctxdmacolor, ctxdmazeta)                \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((sizeSetRenderTargetContextsMthdCnt << 2) << 16) | ((ch) << 13) | NV053_SET_CONTEXT_DMA_COLOR); \
    ((DWORD *)(fifo))[1] = (ctxdmacolor);                                   \
    ((DWORD *)(fifo))[2] = (ctxdmazeta);                                    \
    (DWORD *)(fifo) += sizeSetRenderTargetContexts;                         \
    freecount -= sizeSetRenderTargetContexts;                               \
}

#define sizeSetRenderTarget                 8
#define nvglSetRenderTarget(fifo, freecount, ch,                            \
                            cliphorizontal, clipvertical, format, pitch,    \
                            coloroffset, zetaoffset)                        \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((3 << 2) << 16) | ((ch) << 13) | NV053_SET_CLIP_HORIZONTAL); \
    ((DWORD *)(fifo))[1] = (cliphorizontal);                                \
    ((DWORD *)(fifo))[2] = (clipvertical);                                  \
    ((DWORD *)(fifo))[3] = (format);                                        \
    ((DWORD *)(fifo))[4] = (((3 << 2) << 16) | ((ch) << 13) | NV053_SET_PITCH); \
    ((DWORD *)(fifo))[5] = (pitch);                                         \
    ((DWORD *)(fifo))[6] = (coloroffset);                                   \
    ((DWORD *)(fifo))[7] = (zetaoffset);                                    \
    (DWORD *)(fifo) += sizeSetRenderTarget;                                 \
    freecount -= sizeSetRenderTarget;                                       \
}

#define sizeSetRenderTarget2MthdCnt         5
#define sizeSetRenderTarget2                6
#define nvglSetRenderTarget2(fifo, freecount, ch,                           \
                            format, clipsize, pitch,                        \
                            coloroffset, zetaoffset)                        \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((sizeSetRenderTarget2MthdCnt << 2) << 16) | ((ch) << 13) | NV053_SET_FORMAT); \
    ((DWORD *)(fifo))[1] = (format);                                        \
    ((DWORD *)(fifo))[2] = (clipsize);                                      \
    ((DWORD *)(fifo))[3] = (pitch);                                         \
    ((DWORD *)(fifo))[4] = (coloroffset);                                   \
    ((DWORD *)(fifo))[5] = (zetaoffset);                                    \
    (DWORD *)(fifo) += sizeSetRenderTarget2;                                \
    freecount -= sizeSetRenderTarget2;                                      \
}

#define sizeSetRenderTargetViewportMthdCnt  2
#define sizeSetRenderTargetViewport         3
#define nvglSetRenderTargetViewport(fifo, freecount, ch,                    \
                            cliphorizontal, clipvertical)                   \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((sizeSetRenderTargetViewportMthdCnt << 2) << 16) | ((ch) << 13) | NV053_SET_CLIP_HORIZONTAL); \
    ((DWORD *)(fifo))[1] = (cliphorizontal);                                \
    ((DWORD *)(fifo))[2] = (clipvertical);                                  \
    (DWORD *)(fifo) += sizeSetRenderTargetViewport;                         \
    freecount -= sizeSetRenderTargetViewport;                               \
}

/*
 * Swizzled surface context setup macros.
 */
#define sizeSetSwizzledSurfaceContextImageMthdCnt   1
#define sizeSetSwizzledSurfaceContextImage          2
#define nvglSetSwizzledSurfaceContextImage(fifo, freecount, ch,             \
                                     ctxdmaimage)                           \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((sizeSetSwizzledSurfaceContextImageMthdCnt << 2) << 16) | ((ch) << 13) | NV052_SET_CONTEXT_DMA_IMAGE); \
    ((DWORD *)(fifo))[1] = (ctxdmaimage);                                   \
    (DWORD *)(fifo) += sizeSetSwizzledSurfaceContextImage;                  \
    freecount -= sizeSetSwizzledSurfaceContextImage;                        \
}

#define sizeSetSwizzledSurfaceMthdCnt        2
#define sizeSetSwizzledSurface               3
#define nvglSetSwizzledSurface(fifo, freecount, ch,                         \
                              format, offset)                               \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((sizeSetSwizzledSurfaceMthdCnt << 2) << 16) | ((ch) << 13) | NV052_SET_FORMAT); \
    ((DWORD *)(fifo))[1] = (format);                                        \
    ((DWORD *)(fifo))[2] = (offset);                                        \
    (DWORD *)(fifo) += sizeSetSwizzledSurface;                              \
    freecount -= sizeSetSwizzledSurface;                                    \
}

/*
 * Indexed Image from CPU setup macros
 */
#define sizeSetIndexedImageDmaNotifiesMthdCnt           1
#define sizeSetIndexedImageDmaNotifies                  2
#define nvglSetIndexedImageDmaNotifies(fifo, freecount, ch,             \
                                      ctxdmanotify)                     \
{                                                                       \
    ((DWORD *)(fifo))[0] = (((sizeSetIndexedImageDmaNotifiesMthdCnt << 2) << 16) | ((ch) << 13) | NV060_SET_CONTEXT_DMA_NOTIFIES); \
    ((DWORD *)(fifo))[1] = (ctxdmanotify);                              \
    (DWORD *)(fifo) += sizeSetIndexedImageDmaNotifies;                  \
    freecount -= sizeSetIndexedImageDmaNotifies;                        \
}

#define sizeSetIndexedImageContextDmaLUTMthdCnt           1
#define sizeSetIndexedImageContextDmaLUT                  2
#define nvglSetIndexedImageContextDmaLUT(fifo, freecount, ch,           \
                                         handle)                        \
{                                                                       \
    ((DWORD *)(fifo))[0] = (((sizeSetIndexedImageContextDmaLUTMthdCnt << 2) << 16) | ((ch) << 13) | NV060_SET_CONTEXT_DMA_LUT); \
    ((DWORD *)(fifo))[1] = (handle);                                    \
    (DWORD *)(fifo) += sizeSetIndexedImageContextDmaLUT;                \
    freecount -= sizeSetIndexedImageContextDmaLUT;                      \
}

#define sizeSetIndexedImageContextSurfaceMthdCnt        1
#define sizeSetIndexedImageContextSurface               2
#define nvglSetIndexedImageContextSurface(fifo, freecount, ch,          \
                                          surface)                      \
{                                                                       \
    ((DWORD *)(fifo))[0] = (((sizeSetIndexedImageContextSurfaceMthdCnt << 2) << 16) | ((ch) << 13) | NV060_SET_CONTEXT_SURFACE); \
    ((DWORD *)(fifo))[1] = (surface);                                   \
    (DWORD *)(fifo) += sizeSetIndexedImageContextSurface;               \
    freecount -= sizeSetIndexedImageContextSurface;                     \
}

#define sizeSetIndexedImageOperationMthdCnt     1
#define sizeSetIndexedImageOperation            2
#define nvglSetIndexedImageOperation(fifo, freecount, ch,               \
                                     operation)                         \
{                                                                       \
    ((DWORD *)(fifo))[0] = (((sizeSetIndexedImageOperationMthdCnt << 2) << 16) | ((ch) << 13) | NV060_SET_OPERATION); \
    ((DWORD *)(fifo))[1] = (operation);                                 \
    (DWORD *)(fifo) += sizeSetIndexedImageOperation;                    \
    freecount -= sizeSetIndexedImageOperation;                          \
}

#define sizeSetIndexedImageColorFormatMthdCnt   1
#define sizeSetIndexedImageColorFormat          2
#define nvglSetIndexedImageColorFormat(fifo, freecount, ch,             \
                                       colorformat)                     \
{                                                                       \
    ((DWORD *)(fifo))[0] = (((sizeSetIndexedImageColorFormatMthdCnt << 2) << 16) | ((ch) << 13) | NV060_SET_COLOR_FORMAT); \
    ((DWORD *)(fifo))[1] = (colorformat);                               \
    (DWORD *)(fifo) += sizeSetIndexedImageColorFormat;                  \
    freecount -= sizeSetIndexedImageColorFormat;                        \
}

#define sizeSetIndexedImageIndexFormatMthdCnt   1
#define sizeSetIndexedImageIndexFormat          2
#define nvglSetIndexedImageIndexFormat(fifo, freecount, ch,             \
                                       indexformat)                     \
{                                                                       \
    ((DWORD *)(fifo))[0] = (((sizeSetIndexedImageIndexFormatMthdCnt << 2) << 16) | ((ch) << 13) | NV060_INDEX_FORMAT); \
    ((DWORD *)(fifo))[1] = (indexformat);                               \
    (DWORD *)(fifo) += sizeSetIndexedImageIndexFormat;                  \
    freecount -= sizeSetIndexedImageIndexFormat;                        \
}

#define sizeSetIndexedImageLUTOffsetMthdCnt     1
#define sizeSetIndexedImageLUTOffset            2
#define nvglSetIndexedImageLUTOffset(fifo, freecount, ch,               \
                                     offset)                            \
{                                                                       \
    ((DWORD *)(fifo))[0] = (((sizeSetIndexedImageLUTOffsetMthdCnt << 2) << 16) | ((ch) << 13) | NV060_LUT_OFFSET); \
    ((DWORD *)(fifo))[1] = (offset);                                    \
    (DWORD *)(fifo) += sizeSetIndexedImageLUTOffset;                    \
    freecount -= sizeSetIndexedImageLUTOffset;                          \
}

#define sizeSetIndexedImagePointMthdCnt         1
#define sizeSetIndexedImagePoint                2
#define nvglSetIndexedImagePoint(fifo, freecount, ch,                   \
                                 x, y)                                  \
{                                                                       \
    ((DWORD *)(fifo))[0] = (((sizeSetIndexedImagePointMthdCnt << 2) << 16) | ((ch) << 13) | NV060_POINT); \
    ((DWORD *)(fifo))[1] = ( (((x) & 0x0000ffff) << 0) |                \
                             (((y) & 0x0000ffff) << 16) );              \
    (DWORD *)(fifo) += sizeSetIndexedImagePoint;                        \
    freecount -= sizeSetIndexedImagePoint;                              \
}

#define sizeSetIndexedImageSizesMthdCnt         2
#define sizeSetIndexedImageSizes                3
#define nvglSetIndexedImageSizes(fifo, freecount, ch,                   \
                                 w_out, h_out, w_in, h_in)              \
{                                                                       \
    ((DWORD *)(fifo))[0] = (((sizeSetIndexedImageSizesMthdCnt << 2) << 16) | ((ch) << 13) | NV060_SIZE_OUT); \
    ((DWORD *)(fifo))[1] = ( (((w_out) & 0x0000ffff) << 0) |            \
                             (((h_out) & 0x0000ffff) << 16) );          \
    ((DWORD *)(fifo))[2] = ( (((w_in) & 0x0000ffff) << 0) |             \
                             (((h_in) & 0x0000ffff) << 16) );           \
    (DWORD *)(fifo) += sizeSetIndexedImageSizes;                        \
    freecount -= sizeSetIndexedImageSizes;                              \
}

#define nvglSetIndexedImageIndices(fifo, freecount, ch,                 \
                                   dataSizeInWords, indices)            \
{                                                                       \
    DWORD ii;                                                           \
    ((DWORD *)(fifo))[0] = (((dataSizeInWords << 2) << 16) | ((ch) << 13) | NV060_INDICES(0)); \
    (DWORD *)(fifo) += 1;                                               \
    for (ii=0; ii<dataSizeInWords; ii++) {                              \
        *(DWORD *)fifo = *(DWORD *)indices;                             \
        (DWORD *)fifo += 1;                                             \
        (DWORD *)indices += 1;                                          \
    }                                                                   \
    freecount -= (1 + dataSizeInWords);                                 \
}

/*
 * Scaled image from memory context setup macros.
 */
#define sizeSetScaledImageContextNotifiesMthdCnt    1
#define sizeSetScaledImageContextNotifies           2
#define nvglSetScaledImageContextNotifies(fifo, freecount, ch,              \
                                       ctxdmanotify)                        \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((sizeSetScaledImageContextNotifiesMthdCnt << 2) << 16) | ((ch) << 13) | NV077_SET_CONTEXT_DMA_NOTIFIES); \
    ((DWORD *)(fifo))[1] = (ctxdmanotify);                                  \
    (DWORD *)(fifo) += sizeSetScaledImageContextNotifies;                   \
    freecount -= sizeSetScaledImageContextNotifies;                         \
}

#define sizeSetScaledImageContextImageMthdCnt       1
#define sizeSetScaledImageContextImage              2
#define nvglSetScaledImageContextImage(fifo, freecount, ch,                 \
                                       ctxdmaimage)                         \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((sizeSetScaledImageContextImageMthdCnt << 2) << 16) | ((ch) << 13) | NV077_SET_CONTEXT_DMA_IMAGE); \
    ((DWORD *)(fifo))[1] = (ctxdmaimage);                                   \
    (DWORD *)(fifo) += sizeSetScaledImageContextImage;                      \
    freecount -= sizeSetScaledImageContextImage;                            \
}

#define sizeSetScaledImageContextSurfaceMthdCnt     1
#define sizeSetScaledImageContextSurface            2
#define nvglSetScaledImageContextSurface(fifo, freecount, ch,               \
                                       ctxdmasurface)                       \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((sizeSetScaledImageContextSurfaceMthdCnt << 2) << 16) | ((ch) << 13) | NV077_SET_CONTEXT_SURFACE); \
    ((DWORD *)(fifo))[1] = (ctxdmasurface);                                 \
    (DWORD *)(fifo) += sizeSetScaledImageContextSurface;                    \
    freecount -= sizeSetScaledImageContextSurface;                          \
}

#define sizeSetScaledImageFormatMthdCnt             1
#define sizeSetScaledImageFormat                    2
#define nvglSetScaledImageFormat(fifo, freecount, ch,                       \
                                 format)                                    \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((sizeSetScaledImageFormatMthdCnt << 2) << 16) | ((ch) << 13) | NV077_SET_COLOR_FORMAT); \
    ((DWORD *)(fifo))[1] = (format);                                        \
    (DWORD *)(fifo) += sizeSetScaledImageFormat;                            \
    freecount -= sizeSetScaledImageFormat;                                  \
}

#define sizeSetScaledImageOperationMthdCnt          1
#define sizeSetScaledImageOperation                 2
#define nvglSetScaledImageOperation(fifo, freecount, ch,                    \
                                    operation)                              \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((sizeSetScaledImageOperationMthdCnt << 2) << 16) | ((ch) << 13) | NV077_SET_OPERATION); \
    ((DWORD *)(fifo))[1] = (operation);                                     \
    (DWORD *)(fifo) += sizeSetScaledImageOperation;                         \
    freecount -= sizeSetScaledImageOperation;                               \
}

#define sizeScaledImageClipMthdCnt                  2
#define sizeScaledImageClip                         3
#define nvglScaledImageClip(fifo, freecount, ch,                            \
                            x, y, width, height)                            \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((sizeScaledImageClipMthdCnt << 2) << 16) | ((ch) << 13) | NV077_CLIP_POINT); \
    ((DWORD *)(fifo))[1] = ((((y) & 0x0000FFFF) << 16) | ((x) & 0x0000FFFF)); \
    ((DWORD *)(fifo))[2] = ((((height) & 0x0000FFFF) << 16) | ((width) & 0x0000FFFF)); \
    (DWORD *)(fifo) += sizeScaledImageClip;                                 \
    freecount -= sizeScaledImageClip;                                       \
}

#define sizeScaledImageOutMthdCnt                   2
#define sizeScaledImageOut                          3
#define nvglScaledImageOut(fifo, freecount, ch,                             \
                           x, y, width, height)                             \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((sizeScaledImageOutMthdCnt << 2) << 16) | ((ch) << 13) | NV077_IMAGE_OUT_POINT); \
    ((DWORD *)(fifo))[1] = ((((y) & 0x0000FFFF) << 16) | ((x) & 0x0000FFFF)); \
    ((DWORD *)(fifo))[2] = ((((height) & 0x0000FFFF) << 16) | ((width) & 0x0000FFFF)); \
    (DWORD *)(fifo) += sizeScaledImageOut;                                  \
    freecount -= sizeScaledImageOut;                                        \
}

#define sizeScaledImageDeltaDuDxDvDyMthdCnt         2
#define sizeScaledImageDeltaDuDxDvDy                3
#define nvglScaledImageDeltaDuDxDvDy(fifo, freecount, ch,                   \
                                     dudx, dvdy)                            \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((sizeScaledImageDeltaDuDxDvDyMthdCnt << 2) << 16) | ((ch) << 13) | NV077_DELTA_DU_DX); \
    ((DWORD *)(fifo))[1] = (dudx);                                          \
    ((DWORD *)(fifo))[2] = (dvdy);                                          \
    (DWORD *)(fifo) += sizeScaledImageDeltaDuDxDvDy;                        \
    freecount -= sizeScaledImageDeltaDuDxDvDy;                              \
}

#define sizeScaledImageInSizeMthdCnt                1
#define sizeScaledImageInSize                       2
#define nvglScaledImageInSize(fifo, freecount, ch,                          \
                              width, height)                                \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((sizeScaledImageInSizeMthdCnt << 2) << 16) | ((ch) << 13) | NV077_IMAGE_IN_SIZE); \
    ((DWORD *)(fifo))[1] = ((((height) & 0x0000FFFF) << 16) | ((width) & 0x0000FFFF)); \
    (DWORD *)(fifo) += sizeScaledImageInSize;                               \
    freecount -= sizeScaledImageInSize;                                     \
}

#define sizeScaledImageInFormatMthdCnt              1
#define sizeScaledImageInFormat                     2
#define nvglScaledImageInFormat(fifo, freecount, ch,                        \
                                format)                                     \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((sizeScaledImageInFormatMthdCnt << 2) << 16) | ((ch) << 13) | NV077_IMAGE_IN_FORMAT); \
    ((DWORD *)(fifo))[1] = (format);                                        \
    (DWORD *)(fifo) += sizeScaledImageInFormat;                             \
    freecount -= sizeScaledImageInFormat;                                   \
}

#define sizeScaledImageInOffsetMthdCnt              1
#define sizeScaledImageInOffset                     2
#define nvglScaledImageInOffset(fifo, freecount, ch,                        \
                                offset)                                     \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((sizeScaledImageInOffsetMthdCnt << 2) << 16) | ((ch) << 13) | NV077_IMAGE_IN_OFFSET); \
    ((DWORD *)(fifo))[1] = (offset);                                        \
    (DWORD *)(fifo) += sizeScaledImageInOffset;                             \
    freecount -= sizeScaledImageInOffset;                                   \
}

#define sizeScaledImageInPointMthdCnt               1
#define sizeScaledImageInPoint                      2
#define nvglScaledImageInPoint(fifo, freecount, ch,                         \
                               x, y)                                        \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((sizeScaledImageInPointMthdCnt << 2) << 16) | ((ch) << 13) | NV077_IMAGE_IN); \
    ((DWORD *)(fifo))[1] = ((((y) & 0x0000FFFF) << 16) | ((x) & 0x0000FFFF)); \
    (DWORD *)(fifo) += sizeScaledImageInPoint;                              \
    freecount -= sizeScaledImageInPoint;                                    \
}

#define sizeScaledImageNotify                       4
#define nvglScaledImageNotify(fifo, freecount, ch)                          \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((1 << 2) << 16) | ((ch) << 13) | NV077_NOTIFY); \
    ((DWORD *)(fifo))[1] = NV077_NOTIFY_WRITE_ONLY;                         \
    ((DWORD *)(fifo))[2] = (((1 << 2) << 16) | ((ch) << 13) | NV077_NO_OPERATION); \
    ((DWORD *)(fifo))[3] = 0;                                               \
    (DWORD *)(fifo) += sizeScaledImageNotify;                               \
    freecount -= sizeScaledImageNotify;                                     \
}

/*
 * Context DMA from memory setup macros.
 */
#define sizeSetDmaFromMemoryMthdCnt                 3
#define sizeSetDmaFromMemory                        4
#define nvglSetDmaFromMemory(fifo, freecount, ch,                           \
                            base, selector, limit)                          \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((sizeSetDmaFromMemoryMthdCnt << 2) << 16) | ((ch) << 13) | 0x300); \
    ((DWORD *)(fifo))[1] = (base);                                          \
    ((DWORD *)(fifo))[2] = (selector);                                      \
    ((DWORD *)(fifo))[3] = (limit);                                         \
    (DWORD *)(fifo) += sizeSetDmaFromMemory;                                \
    freecount -= sizeSetDmaFromMemory;                                      \
}

#define sizeSetDmaFromMemoryContextNotifyMthdCnt    1
#define sizeSetDmaFromMemoryContextNotify           2
#define nvglSetDmaFromMemoryContextNotify(fifo, freecount, ch,              \
                                       ctxdmanotify)                        \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((sizeSetDmaFromMemoryContextNotifyMthdCnt << 2) << 16) | ((ch) << 13) | 0x180); \
    ((DWORD *)(fifo))[1] = (ctxdmanotify);                                  \
    (DWORD *)(fifo) += sizeSetDmaFromMemoryContextNotify;                   \
    freecount -= sizeSetDmaFromMemoryContextNotify;                         \
}

#define sizeSetDmaFromMemoryNotify                  7
#define nvglSetDmaFromMemoryNotify(fifo, freecount, ch,                     \
                                   base, selector, limit, notify)           \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((2 << 2) << 16) | ((ch) << 13) | 0x300);       \
    ((DWORD *)(fifo))[1] = (base);                                          \
    ((DWORD *)(fifo))[2] = (selector);                                      \
    ((DWORD *)(fifo))[3] = (((1 << 2) << 16) | ((ch) << 13) | 0x104);       \
    ((DWORD *)(fifo))[4] = (notify);                                        \
    ((DWORD *)(fifo))[5] = (((1 << 2) << 16) | ((ch) << 13) | 0x308);       \
    ((DWORD *)(fifo))[6] = (limit);                                         \
    (DWORD *)(fifo) += sizeSetDmaFromMemoryNotify;                          \
    freecount -= sizeSetDmaFromMemoryNotify;                                \
}

/*
 * Context DMA to memory setup macros.
 */
#define sizeSetDmaToMemoryMthdCnt                 3
#define sizeSetDmaToMemory                        4
#define nvglSetDmaToMemory(fifo, freecount, ch,                             \
                           base, selector, limit)                           \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((sizeSetDmaToMemoryMthdCnt << 2) << 16) | ((ch) << 13) | 0x300); \
    ((DWORD *)(fifo))[1] = (base);                                          \
    ((DWORD *)(fifo))[2] = (selector);                                      \
    ((DWORD *)(fifo))[3] = (limit);                                         \
    (DWORD *)(fifo) += sizeSetDmaToMemory;                                  \
    freecount -= sizeSetDmaToMemory;                                        \
}

#define sizeSetDmaToMemoryContextNotifyMthdCnt    1
#define sizeSetDmaToMemoryContextNotify           2
#define nvglSetDmaToMemoryContextNotify(fifo, freecount, ch,                \
                                       ctxdmanotify)                        \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((sizeSetDmaToMemoryContextNotifyMthdCnt << 2) << 16) | ((ch) << 13) | 0x180); \
    ((DWORD *)(fifo))[1] = (ctxdmanotify);                                  \
    (DWORD *)(fifo) += sizeSetDmaToMemoryContextNotify;                     \
    freecount -= sizeSetDmaToMemoryContextNotify;                           \
}

#define sizeSetDmaToMemoryNotify                  7
#define nvglSetDmaToMemoryNotify(fifo, freecount, ch,                       \
                                 base, selector, limit, notify)             \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((2 << 2) << 16) | ((ch) << 13) | 0x300);       \
    ((DWORD *)(fifo))[1] = (base);                                          \
    ((DWORD *)(fifo))[2] = (selector);                                      \
    ((DWORD *)(fifo))[3] = (((1 << 2) << 16) | ((ch) << 13) | 0x104);       \
    ((DWORD *)(fifo))[4] = (notify);                                        \
    ((DWORD *)(fifo))[5] = (((1 << 2) << 16) | ((ch) << 13) | 0x308);       \
    ((DWORD *)(fifo))[6] = (limit);                                         \
    (DWORD *)(fifo) += sizeSetDmaToMemoryNotify;                            \
    freecount -= sizeSetDmaToMemoryNotify;                                  \
}

/*
 * Context DMA in memory setup macros.
 */
#define sizeSetDmaInMemoryMthdCnt                 3
#define sizeSetDmaInMemory                        4
#define nvglSetDmaInMemory(fifo, freecount, ch,                             \
                           base, selector, limit)                           \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((sizeSetDmaInMemoryMthdCnt << 2) << 16) | ((ch) << 13) | 0x300); \
    ((DWORD *)(fifo))[1] = (base);                                          \
    ((DWORD *)(fifo))[2] = (selector);                                      \
    ((DWORD *)(fifo))[3] = (limit);                                         \
    (DWORD *)(fifo) += sizeSetDmaInMemory;                                  \
    freecount -= sizeSetDmaInMemory;                                        \
}

#define sizeSetDmaInMemoryContextNotifyMthdCnt    1
#define sizeSetDmaInMemoryContextNotify           2
#define nvglSetDmaInMemoryContextNotify(fifo, freecount, ch,                \
                                       ctxdmanotify)                        \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((sizeSetDmaInMemoryContextNotifyMthdCnt << 2) << 16) | ((ch) << 13) | 0x180); \
    ((DWORD *)(fifo))[1] = (ctxdmanotify);                                  \
    (DWORD *)(fifo) += sizeSetDmaInMemoryContextNotify;                     \
    freecount -= sizeSetDmaInMemoryContextNotify;                           \
}

#define sizeSetDmaInMemoryNotify                  7
#define nvglSetDmaInMemoryNotify(fifo, freecount, ch,                       \
                                 base, selector, limit, notify)             \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((2 << 2) << 16) | ((ch) << 13) | 0x300);       \
    ((DWORD *)(fifo))[1] = (base);                                          \
    ((DWORD *)(fifo))[2] = (selector);                                      \
    ((DWORD *)(fifo))[3] = (((1 << 2) << 16) | ((ch) << 13) | 0x104);       \
    ((DWORD *)(fifo))[4] = (notify);                                        \
    ((DWORD *)(fifo))[5] = (((1 << 2) << 16) | ((ch) << 13) | 0x308);       \
    ((DWORD *)(fifo))[6] = (limit);                                         \
    (DWORD *)(fifo) += sizeSetDmaInMemoryNotify;                            \
    freecount -= sizeSetDmaInMemoryNotify;                                  \
}

/*
 * DrawRopRectAndText macros.
 */
#define sizeDrawRopRectAndTextColor1AMthdCnt        1 
#define sizeDrawRopRectAndTextColor1A               2
#define nvglDrawRopRectAndTextColor1A(fifo, freecount, ch, color)           \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((sizeDrawRopRectAndTextColor1AMthdCnt << 2) << 16) | ((ch) << 13) | NV04A_COLOR1_A); \
    ((DWORD *)(fifo))[1] = (color);                                         \
    (DWORD *)(fifo) += sizeDrawRopRectAndTextColor1A;                       \
    freecount -= sizeDrawRopRectAndTextColor1A;                             \
}

#define sizeDrawRopRectAndTextPointSizeMthdCnt      2
#define sizeDrawRopRectAndTextPointSize             3
#define nvglDrawRopRectAndTextPointSize(fifo, freecount, ch,                \
                                        x, y, width, height)                \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((sizeDrawRopRectAndTextPointSizeMthdCnt << 2) << 16) | ((ch) << 13) | NV04A_UNCLIPPED_RECTANGLE_POINT(0)); \
    ((DWORD *)(fifo))[1] = ((((x) & 0x0000FFFF) << 16) | ((y) & 0x0000FFFF)); \
    ((DWORD *)(fifo))[2] = ((((width) & 0x0000FFFF) << 16) | ((height) & 0x0000FFFF)); \
    (DWORD *)(fifo) += sizeDrawRopRectAndTextPointSize;                     \
    freecount -= sizeDrawRopRectAndTextPointSize;                           \
}

/*
 * Surfaces2D macros.
 */
#define sizeSet2DSurfacesContextsMthdCnt            2
#define sizeSet2DSurfacesContexts                   3
#define nvglSet2DSurfacesContexts(fifo, freecount, ch, ctxsrc, ctxdest)     \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((sizeSet2DSurfacesContextsMthdCnt << 2) << 16) | ((ch) << 13) | NV042_SET_CONTEXT_DMA_IMAGE_SOURCE); \
    ((DWORD *)(fifo))[1] = (ctxsrc);                                        \
    ((DWORD *)(fifo))[2] = (ctxdest);                                       \
    (DWORD *)(fifo) += sizeSet2DSurfacesContexts;                           \
    freecount -= sizeSet2DSurfacesContexts;                                 \
}

#define sizeSet2DSurfacesColorFormatMthdCnt         1
#define sizeSet2DSurfacesColorFormat                2
#define nvglSet2DSurfacesColorFormat(fifo, freecount, ch, format)           \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((sizeSet2DSurfacesColorFormatMthdCnt << 2) << 16) | ((ch) << 13) | NV042_SET_COLOR_FORMAT); \
    ((DWORD *)(fifo))[1] = (format);                                        \
    (DWORD *)(fifo) += sizeSet2DSurfacesColorFormat;                        \
    freecount -= sizeSet2DSurfacesColorFormat;                              \
}

#define sizeSet2DSurfacesDestinationMthdCnt         1
#define sizeSet2DSurfacesDestination                2
#define nvglSet2DSurfacesDestination(fifo, freecount, ch, offset)           \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((sizeSet2DSurfacesDestinationMthdCnt << 2) << 16) | ((ch) << 13) | NV042_SET_OFFSET_DESTIN); \
    ((DWORD *)(fifo))[1] = (offset);                                        \
    (DWORD *)(fifo) += sizeSet2DSurfacesDestination;                        \
    freecount -= sizeSet2DSurfacesDestination;                              \
}

#define sizeSet2DSurfacesPitchMthdCnt               1
#define sizeSet2DSurfacesPitch                      2
#define nvglSet2DSurfacesPitch(fifo, freecount, ch,                         \
                               srcpitch, dstpitch)                          \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((sizeSet2DSurfacesPitchMthdCnt << 2) << 16) | ((ch) << 13) | NV042_SET_PITCH); \
    ((DWORD *)(fifo))[1] = ((((dstpitch) & 0x0000FFFF) << 16) | ((srcpitch) & 0x0000FFFF)); \
    (DWORD *)(fifo) += sizeSet2DSurfacesPitch;                              \
    freecount -= sizeSet2DSurfacesPitch;                                    \
}


/*
 * Set image black rectangle
 */
#define sizeSetClipMthdCnt                          2
#define sizeSetClip                                 3
#define nvglSetClip(fifo, freecount, ch,                                    \
                    x, y, w, h)                                             \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((sizeSetClipMthdCnt << 2) << 16) | ((ch) << 13) | NV019_SET_POINT); \
    ((DWORD *)(fifo))[1] = ((DWORD)y << 16) | (DWORD)x;                     \
    ((DWORD *)(fifo))[2] = ((DWORD)h << 16) | (DWORD)w;                     \
    (DWORD *)(fifo) += sizeSetClip;                                         \
    freecount -= sizeSetClip;                                               \
}

/*
 * Rop5 macros.
 */
#define sizeSetRop5MthdCnt                          1
#define sizeSetRop5                                 2
#define nvglSetRop5(fifo, freecount, ch, rop5)                              \
{                                                                           \
    ((DWORD *)(fifo))[0] = (((sizeSetRop5MthdCnt << 2) << 16) | ((ch) << 13) | NV043_SET_ROP5); \
    ((DWORD *)(fifo))[1] = (rop5);                                          \
    (DWORD *)(fifo) += sizeSetRop5;                                         \
    freecount -= sizeSetRop5;                                               \
}

/*
 * Define the DMA jump operation.
 */
#define sizeDmaJump         1
#define nvglDmaJump(fifo, freecount, ch, offset)                            \
{                                                                           \
    ((DWORD *)(fifo))[0] = (0x20000000 | (offset));                         \
    (DWORD *)(fifo) += sizeDmaJump;                                         \
    freecount -= sizeDmaJump;                                               \
}

/*
 *
 */
#define nvglIdleKickoff(minsize)                                            \
{                                                                           \
}



#define DMA_PUSHER_SYNC()                                                   \
{                                                                           \
}
#else   // D3D_CPU
/*
 * Hardware connection macros.
 */
#ifdef  D3D_HARDWARE
#define nvglOpenChannel(handle, address, size, fifo)                        \
{                                                                           \
    (address) = (DWORD)NvOpen(0);                                           \
    (fifo)    = (Nv4ControlDma *)0;                                         \
}
#define nvglCloseChannel(handle, address, fifo)                             \
{                                                                           \
    NvClose((NvChannel *)(address));                                        \
    (fifo)    = 0;                                                          \
    (handle)  = (DWORD)0;                                                   \
    (address) = (DWORD)0;                                                   \
}
#else   // D3D_EMULATION
#define nvglOpenChannel(handle, address, size, fifo)                        \
{                                                                           \
    (handle)  = (DWORD)HeapCreate(HEAP_SHARED, sizeof(Nv03ChannelPio), 0);  \
    (address) = (DWORD)HeapAlloc((HANDLE)(handle), HEAP_ZERO_MEMORY, sizeof(Nv03ChannelPio)); \
    (fifo)    = (Nv4ControlDma *)0;                                         \
}
#define nvglCloseChannel(handle, address, fifo)                             \
{                                                                           \
    HeapFree((HANDLE)(handle), 0, (PVOID)(address));                        \
    HeapDestroy((HANDLE)(handle));                                          \
    (fifo)    = 0;                                                          \
    (handle)  = (DWORD)0;                                                   \
    (address) = (DWORD)0;                                                   \
}
#endif  // D3D_EMULATION

/*
 * CPU Pushing macros.
 */
#ifdef  D3D_HARDWARE
#define nvglGetFreeCount(fifo, freecount, ch, size, retval)                 \
{                                                                           \
    (freecount) = ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].control.Free;\
    (retval) = FALSE;                                                       \
}
#else   // D3D_EMULATION
#define nvglGetFreeCount(fifo, freecount, ch, size, retval)                 \
{                                                                           \
    nvGetDmaFreeCount(size);                                                \
    (retval) = FALSE;                                                       \
}
#endif  // D3D_EMULATION.

#define sizeSetObjectMthdCnt    1
#define sizeSetObject           (sizeSetObjectMthdCnt * 4)
#define nvglSetObject(fifo, freecount, ch, obj)                             \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].SetObject = (obj);         \
    freecount -= sizeSetObject;                                             \
}

/*
 * Multiple data setting macros don't convert well from DMA to CPU pushing
 * methodologies.  These will need to be special cased.
 */
#define sizeSetStartMethod   0
#define nvglSetStartMethod(fifo, freecount, ch, method, methodcount)
#define sizeSetData          0
#define nvglSetData(fifo, freecount, data)

/*
 * Create Object macro.
 */
#define sizeCreateObjectMthdCnt             1
#define sizeCreateObject                    (sizeCreateObjectMthdCnt * 4)
#define nvglCreateObject(fifo, freecount, ch, obj)                          \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nvClass.Create = (obj);    \
    freecount -= sizeCreateObject;                                          \
}

/*
 * Destroy Object macro.
 */
#define sizeDestroyObjectMthdCnt            1
#define sizeDestroyObject                   (sizeDestroyObjectMthdCnt * 4)
#define nvglDestroyObject(fifo, freecount, ch, obj)                         \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nvClass.Destroy = (obj);   \
    freecount -= sizeDestroyObject;                                         \
}

/*
 * Define DX5 Triangle class macros.
 */
#define sizeSetDx5TriangleContextsMthdCnt   2
#define sizeSetDx5TriangleContexts          (sizeSetDx5TriangleContextsMthdCnt * 4)
#define nvglSetDx5TriangleContexts(fifo, freecount, ch, ctxa, ctxb)         \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx5TexturedTriangle.SetContextDmaA = (ctxa); \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx5TexturedTriangle.SetContextDmaB = (ctxb); \
    freecount -= sizeSetDx5TriangleContexts;                                \
}
#define sizeSetDx5TriangleSurfaceMthdCnt    1
#define sizeSetDx5TriangleSurface           (sizeSetDx5TriangleSurfaceMthdCnt * 4)
#define nvglSetDx5TriangleSurface(fifo, freecount, ch, ctxs)                \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx5TexturedTriangle.SetContextSurfaces = (ctxs); \
    freecount -= sizeSetDx5TriangleSurface;                                 \
}
#define sizeDx5TriangleStateMthdCnt         7
#define sizeDx5TriangleState                (sizeDx5TriangleStateMthdCnt * 4)
#define nvglDx5TriangleState(fifo, freecount, ch,                           \
                             ckey, offset, format, filter,                  \
                             blend, control, fogcolor)                      \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx5TexturedTriangle.ColorKey = (ckey);     \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx5TexturedTriangle.Offset   = (offset);   \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx5TexturedTriangle.Format   = (format);   \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx5TexturedTriangle.Filter   = (filter);   \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx5TexturedTriangle.Blend    = (blend);    \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx5TexturedTriangle.Control  = (control);  \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx5TexturedTriangle.FogColor = (fogcolor); \
    freecount -= sizeDx5TriangleState;                                      \
}
#define sizeDx5TriangleTLVertexMthdCnt      8
#define sizeDx5TriangleTLVertex             (sizeDx5TriangleTLVertexMthdCnt * 4)
#define nvglDx5TriangleTLVertex(fifo, freecount, ch, alias, vd)                                                   \
{                                                                                                                 \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx5TexturedTriangle.Tlvertex[(alias)].sx       = vd.sx;       \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx5TexturedTriangle.Tlvertex[(alias)].sy       = vd.sy;       \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx5TexturedTriangle.Tlvertex[(alias)].sz       = vd.sz;       \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx5TexturedTriangle.Tlvertex[(alias)].rhw      = vd.rhw;      \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx5TexturedTriangle.Tlvertex[(alias)].color    = vd.color;    \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx5TexturedTriangle.Tlvertex[(alias)].specular = vd.specular; \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx5TexturedTriangle.Tlvertex[(alias)].tu       = vd.tu;       \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx5TexturedTriangle.Tlvertex[(alias)].tv       = vd.tv;       \
    freecount -= sizeDx5TriangleTLVertex;                                                                         \
    dbgDisplayVertexData(*(DWORD *)&(vd.sx),  *(DWORD *)&(vd.sy),  *(DWORD *)&(vd.sz),                            \
                         *(DWORD *)&(vd.rhw),  (DWORD)vd.color,     (DWORD)vd.specular,                           \
                         *(DWORD *)&(vd.tu),  *(DWORD *)&(vd.tv));                                                \
}
#define nvglDx5TriangleTLVertexExpFog(fifo, freecount, ch, alias, vd)                                             \
{                                                                                                                 \
    float ffog, z;                                                                                                \
    int   ifog, specular;                                                                                         \
    specular  = (vd.specular) & 0x00FFFFFF;                                                                       \
    FP_INV(z, (vd.rhw));                                                                                          \
    ffog  = z * pCurrentContext->fFogTableDensity;                                                                \
    FP_EXP(ffog, ffog);                                                                                           \
    FP_NORM_TO_BIT24(ifog, ffog);                                                                                 \
    specular |= ifog;                                                                                             \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx5TexturedTriangle.Tlvertex[(alias)].sx       = vd.sx;       \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx5TexturedTriangle.Tlvertex[(alias)].sy       = vd.sy;       \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx5TexturedTriangle.Tlvertex[(alias)].sz       = vd.sz;       \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx5TexturedTriangle.Tlvertex[(alias)].rhw      = vd.rhw;      \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx5TexturedTriangle.Tlvertex[(alias)].color    = vd.color;    \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx5TexturedTriangle.Tlvertex[(alias)].specular = specular;    \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx5TexturedTriangle.Tlvertex[(alias)].tu       = vd.tu;       \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx5TexturedTriangle.Tlvertex[(alias)].tv       = vd.tv;       \
    freecount -= sizeDx5TriangleTLVertex;                                                                         \
    dbgDisplayVertexData(*(DWORD *)&(vd.sx),  *(DWORD *)&(vd.sy),  *(DWORD *)&(vd.sz),                            \
                         *(DWORD *)&(vd.rhw),  (DWORD)vd.color,     (DWORD)vd.specular,                           \
                         *(DWORD *)&(vd.tu),  *(DWORD *)&(vd.tv));                                                \
}
#define nvglDx5TriangleTLVertexExp2Fog(fifo, freecount, ch, alias, vd)                                            \
{                                                                                                                 \
    float ffog, z;                                                                                                \
    int   ifog, specular;                                                                                         \
    specular  = (vd.specular) & 0x00FFFFFF;                                                                       \
    FP_INV(z, (vd.rhw));                                                                                          \
    ffog  = z * pCurrentContext->fFogTableDensity;                                                                \
    ffog *= ffog;                                                                                                 \
    FP_EXP(ffog, ffog);                                                                                           \
    FP_NORM_TO_BIT24(ifog, ffog);                                                                                 \
    specular |= ifog;                                                                                             \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx5TexturedTriangle.Tlvertex[(alias)].sx       = vd.sx;       \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx5TexturedTriangle.Tlvertex[(alias)].sy       = vd.sy;       \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx5TexturedTriangle.Tlvertex[(alias)].sz       = vd.sz;       \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx5TexturedTriangle.Tlvertex[(alias)].rhw      = vd.rhw;      \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx5TexturedTriangle.Tlvertex[(alias)].color    = vd.color;    \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx5TexturedTriangle.Tlvertex[(alias)].specular = specular;    \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx5TexturedTriangle.Tlvertex[(alias)].tu       = vd.tu;       \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx5TexturedTriangle.Tlvertex[(alias)].tv       = vd.tv;       \
    freecount -= sizeDx5TriangleTLVertex;                                                                         \
    dbgDisplayVertexData(*(DWORD *)&(vd.sx),  *(DWORD *)&(vd.sy),  *(DWORD *)&(vd.sz),                            \
                         *(DWORD *)&(vd.rhw),  (DWORD)vd.color,     (DWORD)vd.specular,                           \
                         *(DWORD *)&(vd.tu),  *(DWORD *)&(vd.tv));                                                \
}
#define nvglDx5TriangleTLVertexLinearFog(fifo, freecount, ch, alias, vd)                                          \
{                                                                                                                 \
    float ffog, z;                                                                                                \
    int   ifog, specular;                                                                                         \
    specular  = (vd.specular) & 0x00FFFFFF;                                                                       \
    FP_INV(z, (vd.rhw));                                                                                          \
    ffog = (pCurrentContext->fFogTableEnd - z) * pCurrentContext->fFogTableLinearScale;                           \
    FP_NORM_TO_BIT24(ifog, ffog);                                                                                 \
    specular |= ifog;                                                                                             \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx5TexturedTriangle.Tlvertex[(alias)].sx       = vd.sx;       \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx5TexturedTriangle.Tlvertex[(alias)].sy       = vd.sy;       \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx5TexturedTriangle.Tlvertex[(alias)].sz       = vd.sz;       \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx5TexturedTriangle.Tlvertex[(alias)].rhw      = vd.rhw;      \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx5TexturedTriangle.Tlvertex[(alias)].color    = vd.color;    \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx5TexturedTriangle.Tlvertex[(alias)].specular = specular;    \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx5TexturedTriangle.Tlvertex[(alias)].tu       = vd.tu;       \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx5TexturedTriangle.Tlvertex[(alias)].tv       = vd.tv;       \
    freecount -= sizeDx5TriangleTLVertex;                                                                         \
    dbgDisplayVertexData(*(DWORD *)&(vd.sx),  *(DWORD *)&(vd.sy),  *(DWORD *)&(vd.sz),                            \
                         *(DWORD *)&(vd.rhw),  (DWORD)vd.color,     (DWORD)vd.specular,                           \
                         *(DWORD *)&(vd.tu),  *(DWORD *)&(vd.tv));                                                \
}
#define sizeDx5TriangleDrawPrimitiveMthdCnt 1
#define sizeDx5TriangleDrawPrimitive        (sizeDx5TriangleDrawPrimitiveMthdCnt * 4)
#define nvglDx5TriangleDrawPrimitive(fifo, freecount, ch, alias, vertices)  \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx5TexturedTriangle.DrawPrimitive[(alias)] = (vertices); \
    freecount -= sizeDx5TriangleDrawPrimitive;                              \
}
#define sizeDx5TriangleNotifyMthdCnt        2
#define sizeDx5TriangleNotify               (sizeDx5TriangleNotifyMthdCnt * 4)
#define nvglDx5TriangleNotify(fifo, freecount, ch)                          \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx5TexturedTriangle.Notify      = NV054_NOTIFY_WRITE_ONLY; \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx5TexturedTriangle.NoOperation = 0x00000000;              \
    freecount -= sizeDx5TriangleNotify;                                     \
}

/*
 * Define DX6 Triangle class macros.
 */
#define sizeSetDx6TriangleContextsMthdCnt   2
#define sizeSetDx6TriangleContexts          (sizeSetDx6TriangleContextsMthdCnt * 4)
#define nvglSetDx6TriangleContexts(fifo, freecount, ch, ctxa, ctxb)         \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx6MultiTexturedTriangle.SetContextDmaA = (ctxa); \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx6MultiTexturedTriangle.SetContextDmaB = (ctxb); \
    freecount -= sizeSetDx6TriangleContexts;                                \
}
#define sizeSetDx6TriangleSurfaceMthdCnt    1
#define sizeSetDx6TriangleSurface           (sizeSetDx6TriangleSurfaceMthdCnt * 4)
#define nvglSetDx6TriangleSurface(fifo, freecount, ch, ctxs)                \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx6MultiTexturedTriangle.SetContextSurfaces = (ctxs); \
    freecount -= sizeSetDx6TriangleSurface;                                 \
}
#define sizeDx6TriangleOffsetMthdCnt        1
#define sizeDx6TriangleOffset               (sizeDx6TriangleOffsetMthdCnt * 4)
#define nvglDx6TriangleOffset(fifo, freecount, ch,                          \
                              offset, buffer)                               \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx6TexturedTriangle.Offset[buffer] = (offset); \
    freecount -= sizeDx6TriangleOffset;                                     \
}
#define sizeDx6TriangleFormatMthdCnt        1
#define sizeDx6TriangleFormat               (sizeDx6TriangleFormatMthdCnt * 4)
#define nvglDx6TriangleFormat(fifo, freecount, ch,                          \
                              format, buffer)                               \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx6TexturedTriangle.Format[buffer] = (format); \
    freecount -= sizeDx6TriangleFormat;                                     \
}
#define sizeDx6TriangleFilterMthdCnt        1
#define sizeDx6TriangleFilter               (sizeDx6TriangleFormatMthdCnt * 4)
#define nvglDx6TriangleFilter(fifo, freecount, ch,                          \
                              filter, buffer)                               \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx6TexturedTriangle.Filter[buffer] = (filter); \
    freecount -= sizeDx6TriangleFilter;                                     \
}


#define sizeDx6TriangleStageStateMthdCnt    1
#define sizeDx6TriangleStageState           (sizeDx6TriangleStageStateMthdCnt * 4)
#define nvglDx6TriangleStageState(fifo, freecount, ch,                      \
                                  c0alpha, c0color, c1alpha, c1color,       \
                                  factor, blend,                            \
                                  control0, control1, control2,             \
                                  fogcolor)                                 \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx6TexturedTriangle.Combine0Alpha = (c0alpha); \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx6TexturedTriangle.Combine0Color = (c0color); \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx6TexturedTriangle.Combine1Alpha = (c1alpha); \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx6TexturedTriangle.Combine1Color = (c1color); \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx6TexturedTriangle.CombineFactor = (factor);  \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx6TexturedTriangle.Blend = (blend);           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx6TexturedTriangle.Control0 = (control0);     \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx6TexturedTriangle.Control1 = (control1);     \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx6TexturedTriangle.Control2 = (control2);     \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx6TexturedTriangle.FogColor = (fogcolor);     \
    freecount -= sizeDx6TriangleStageState;                                 \
}
#define sizeDx6TriangleTLVertexMthdCnt      8
#define sizeDx6TriangleTLVertex             (sizeDx6TriangleTLVertexMthdCnt * 4)
#define nvglDx6TriangleTLVertex(fifo, freecount, ch, alias, vd)                                                   \
{                                                                                                                 \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx6TexturedTriangle.Tlvertex[(alias)].sx       = vd.sx;       \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx6TexturedTriangle.Tlvertex[(alias)].sy       = vd.sy;       \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx6TexturedTriangle.Tlvertex[(alias)].sz       = vd.sz;       \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx6TexturedTriangle.Tlvertex[(alias)].rhw      = vd.rhw;      \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx6TexturedTriangle.Tlvertex[(alias)].color    = vd.color;    \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx6TexturedTriangle.Tlvertex[(alias)].specular = vd.specular; \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx6TexturedTriangle.Tlvertex[(alias)].tu0      = vd.tu;       \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx6TexturedTriangle.Tlvertex[(alias)].tv0      = vd.tv;       \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx6TexturedTriangle.Tlvertex[(alias)].tu1      = 0;           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx6TexturedTriangle.Tlvertex[(alias)].tv1      = 0;           \
    freecount -= sizeDx6TriangleTLVertex;                                                                         \
    dbgDisplayVertexData(*(DWORD *)&(vd.sx),  *(DWORD *)&(vd.sy),  *(DWORD *)&(vd.sz),                            \
                         *(DWORD *)&(vd.rhw),  (DWORD)vd.color,     (DWORD)vd.specular,                           \
                         *(DWORD *)&(vd.tu),  *(DWORD *)&(vd.tv));                                                \
}
#define sizeDx6TriangleDrawPrimitiveMthdCnt 1
#define sizeDx6TriangleDrawPrimitive        (sizeDx6TriangleDrawPrimitiveMthdCnt * 4)
#define nvglDx6TriangleDrawPrimitive(fifo, freecount, ch, alias, vertices)  \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4Dx6TexturedTriangle.DrawPrimitive[(alias)] = (vertices); \
    freecount -= sizeDx6TriangleDrawPrimitive;                              \
}

/*
 * Define NV4 Render Solid Rectangle class macros.
 */
#define sizeSetNv4SolidRectangleSurfaceMthdCnt  1
#define sizeSetNv4SolidRectangleSurface         (sizeSetNv4SolidRectangleSurfaceMthdCnt * 4)
#define nvglSetNv4SolidRectangleSurface(fifo, freecount, ch, ctx)           \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4RenderSolidRectangle.SetContextSurface = (ctx); \
    freecount -= sizeSetNv4SolidRectangleSurface;                           \
}

#define sizeSetNv4SolidRectangleOperationMthdCnt    1
#define sizeSetNv4SolidRectangleOperation           (sizeSetNv4SolidRectangleOperationMthdCnt * 4)
#define nvglSetNv4SolidRectangleOperation(fifo, freecount, ch, op)          \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4RenderSolidRectangle.SetOperation = (op); \
    freecount -= sizeSetNv4SolidRectangleOperation;                         \
}

#define sizeSetNv4SolidRectangleColorFormatMthdCnt  1
#define sizeSetNv4SolidRectangleColorFormat         (sizeSetNv4SolidRectangleColorFormatMthdCnt * 4)
#define nvglSetNv4SolidRectangleColorFormat(fifo, freecount, ch, cfmt)      \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4RenderSolidRectangle.SetColorFormat = (cfmt); \
    freecount -= sizeSetNv4SolidRectangleColorFormat;                       \
}

#define sizeNv4SolidRectangleColorMthdCnt           1
#define sizeNv4SolidRectangleColor                  (sizeNv4SolidRectangleColorMthdCnt * 4)
#define nvglNv4SolidRectangleColor(fifo, freecount, ch, color)              \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4RenderSolidRectangle.Color = (color); \
    freecount -= sizeNv4SolidRectangleColor;                                \
}

#define sizeNv4SolidRectanglePointSizeMthdCnt       2
#define sizeNv4SolidRectanglePointSize              (sizeNv4SolidRectanglePointSizeMthdCnt * 4)
#define nvglNv4SolidRectanglePointSize(fifo, freecount, ch,                 \
                                       x, y, width, height)                 \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4RenderSolidRectangle.Rectangle[0].point = ((((y) & 0x0000FFFF) << 16) | ((x) & 0x0000FFFF)); \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4RenderSolidRectangle.Rectangle[0].size  = ((((height) & 0x0000FFFF) << 16) | ((width) & 0x0000FFFF)); \
    freecount -= sizeNv4SolidRectanglePointSize;                            \
}

/*
 * Define Context Surfaces ARGB Zeta/Stencil macros.
 */
#define sizeSetRenderTargetContextsMthdCnt  2
#define sizeSetRenderTargetContexts         (sizeSetRenderTargetContextsMthdCnt * 4)
#define nvglSetRenderTargetContexts(fifo, freecount, ch,                    \
                                    ctxdmacolor, ctxdmazeta)                \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4ContextSurfacesArgbZs.SetContextDmaColor = (ctxdmacolor);                        \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4ContextSurfacesArgbZs.SetContextDmaZeta  = (ctxdmazeta);                         \
    freecount -= sizeSetRenderTargetContexts;                               \
}

#define sizeSetRenderTargetMthdCnt          5
#define sizeSetRenderTarget                 (sizeSetRenderTargetMthdCnt * 4)
#define nvglSetRenderTarget(fifo, freecount, ch,                            \
                            format, clipsize, pitch,                        \
                            coloroffset, zetaoffset)                        \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4ContextSurfacesArgbZs.SetFormat      = (format);      \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4ContextSurfacesArgbZs.SetClipSize    = (clipsize);    \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4ContextSurfacesArgbZs.SetPitch       = (pitch);       \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4ContextSurfacesArgbZs.SetOffsetColor = (coloroffset); \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4ContextSurfacesArgbZs.SetOffsetZeta  = (zetaoffset);  \
    freecount -= sizeSetRenderTarget;                                       \
}

/*
 * Swizzled surface context setup macros.
 */
#define sizeSetSwizzledSurfaceContextImageMthdCnt   1
#define sizeSetSwizzledSurfaceContextImage      (sizeSetSwizzledSurfaceContextImageMthdCnt * 4)
#define nvglSetSwizzledSurfaceContextImage(fifo, freecount, ch,             \
                                          ctxdmaimage)                      \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4ContextSurfaceSwizzled.SetContextDmaImage = (ctxdmaimage); \
    freecount -= sizeSetSwizzledSurfaceContextImage;                        \
}

#define sizeSetSwizzledSurfaceMthdCnt               2
#define sizeSetSwizzledSurface                      (sizeSetSwizzledSurfaceMthdCnt * 4)
#define nvglSetSwizzledSurface(fifo, freecount, ch,                         \
                              format, offset)                               \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4ContextSurfaceSwizzled.SetFormat = (format); \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4ContextSurfaceSwizzled.SetOffset = (offset); \
    freecount -= sizeSetSwizzledSurface;                                    \
}

/*
 * Scaled image from memory context setup macros.
 */
#define sizeSetScaledImageContextNotifiesMthdCnt     1
#define sizeSetScaledImageContextNotifies           (sizeSetScaledImageContextNotifiesMthdCnt * 4)
#define nvglSetScaledImageContextNotifies(fifo, freecount, ch,              \
                                       ctxdmanotify)                        \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4ScaledImageFromMemory.SetContextDmaNotifies = (ctxdmanotify); \
    freecount -= sizeSetScaledImageContextNotifies;                         \
}

#define sizeSetScaledImageContextImageMthdCnt       1
#define sizeSetScaledImageContextImage              (sizeSetScaledImageContextImageMthdCnt * 4)
#define nvglSetScaledImageContextImage(fifo, freecount, ch,                 \
                                       ctxdmaimage)                         \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4ScaledImageFromMemory.SetContextDmaImage = (ctxdmaimage); \
    freecount -= sizeSetScaledImageContextImage;                            \
}

#define sizeSetScaledImageContextSurfaceMthdCnt     1
#define sizeSetScaledImageContextSurface            (sizeSetScaledImageContextSurfaceMthdCnt * 4)
#define nvglSetScaledImageContextSurface(fifo, freecount, ch,               \
                                       ctxdmasurface)                       \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4ScaledImageFromMemory.SetContextSurface = (ctxdmasurface); \
    freecount -= sizeSetScaledImageContextSurface;                          \
}

#define sizeSetScaledImageFormatMthdCnt             1
#define sizeSetScaledImageFormat                    (sizeSetScaledImageFormatMthdCnt * 4)
#define nvglSetScaledImageFormat(fifo, freecount, ch,                       \
                                 format)                                    \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4ScaledImageFromMemory.SetColorFormat = (format); \
    freecount -= sizeSetScaledImageFormat;                                  \
}

#define sizeSetScaledImageOperationMthdCnt          1
#define sizeSetScaledImageOperation                 (sizeSetScaledImageOperationMthdCnt * 4)
#define nvglSetScaledImageOperation(fifo, freecount, ch,                    \
                                    operation)                              \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4ScaledImageFromMemory.SetOperation = (operation); \
    freecount -= sizeSetScaledImageOperation;                               \
}



#define sizeScaledImageClipMthdCnt                  2
#define sizeScaledImageClip                         (sizeScaledImageClipMthdCnt * 4)
#define nvglScaledImageClip(fifo, freecount, ch,                            \
                            x, y, width, height)                            \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4ScaledImageFromMemory.ClipPoint = ((((y) & 0x0000FFFF) << 16) | ((x) & 0x0000FFFF)); \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4ScaledImageFromMemory.ClipSize  = ((((height) & 0x0000FFFF) << 16) | ((width) & 0x0000FFFF)); \
    freecount -= sizeScaledImageClip;                                       \
}

#define sizeScaledImageOutMthdCnt                   2
#define sizeScaledImageOut                          (sizeScaledImageOutMthdCnt * 4)
#define nvglScaledImageOut(fifo, freecount, ch,                             \
                           x, y, width, height)                             \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4ScaledImageFromMemory.ImageOutPoint = ((((y) & 0x0000FFFF) << 16) | ((x) & 0x0000FFFF)); \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4ScaledImageFromMemory.ImageOutSize  = ((((height) & 0x0000FFFF) << 16) | ((width) & 0x0000FFFF)); \
    freecount -= sizeScaledImageOut;                                        \
}

#define sizeScaledImageDeltaDuDxDvDyMthdCnt         2
#define sizeScaledImageDeltaDuDxDvDy                (sizeScaledImageDeltaDuDxDvDyMthdCnt * 4)
#define nvglScaledImageDeltaDuDxDvDy(fifo, freecount, ch,                   \
                                     dudx, dvdy)                            \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4ScaledImageFromMemory.DeltaDuDx = (dudx); \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4ScaledImageFromMemory.DeltaDvDy = (dvdy); \
    freecount -= sizeScaledImageDeltaDuDxDvDy;                              \
}

#define sizeScaledImageInSizeMthdCnt                1
#define sizeScaledImageInSize                       (sizeScaledImageInSizeMthdCnt * 4)
#define nvglScaledImageInSize(fifo, freecount, ch,                          \
                              width, height)                                \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4ScaledImageFromMemory.ImageInSize = ((((height) & 0x0000FFFF) << 16) | ((width) & 0x0000FFFF)); \
    freecount -= sizeScaledImageInSize;                                     \
}

#define sizeScaledImageInFormatMthdCnt              1
#define sizeScaledImageInFormat                     (sizeScaledImageInFormatMthdCnt * 4)
#define nvglScaledImageInFormat(fifo, freecount, ch,                        \
                                format)                                     \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4ScaledImageFromMemory.ImageInFormat = (format); \
    freecount -= sizeScaledImageInFormat;                                   \
}

#define sizeScaledImageInOffsetMthdCnt              1
#define sizeScaledImageInOffset                     (sizeScaledImageInOffsetMthdCnt * 4)
#define nvglScaledImageInOffset(fifo, freecount, ch,                        \
                                offset)                                     \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4ScaledImageFromMemory.ImageInOffset = (offset); \
    freecount -= sizeScaledImageInOffset;                                   \
}

#define sizeScaledImageInPointMthdCnt               1
#define sizeScaledImageInPoint                      (sizeScaledImageInPointMthdCnt * 4)
#define nvglScaledImageInPoint(fifo, freecount, ch,                         \
                               x, y)                                        \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4ScaledImageFromMemory.ImageInPoint = ((((y) & 0x0000FFFF) << 16) | ((x) & 0x0000FFFF)); \
    freecount -= sizeScaledImageInPoint;                                    \
}

#define sizeScaledImageNotifyMthdCnt                2
#define sizeScaledImageNotify                       (sizeScaledImageNotifyMthdCnt * 4)
#define nvglScaledImageNotify(fifo, freecount, ch)                          \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4ScaledImageFromMemory.Notify = NV077_NOTIFY_WRITE_ONLY; \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4ScaledImageFromMemory.NoOperation = 0; \
    freecount -= sizeScaledImageNotify;                                     \
}

/*
 * Context DMA from memory setup macros.
 */
#define sizeSetDmaFromMemoryMthdCnt                 3
#define sizeSetDmaFromMemory                        (sizeSetDmaFromMemoryMthdCnt * 4)
#define nvglSetDmaFromMemory(fifo, freecount, ch,                           \
                            base, selector, ctxlimit)                       \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].contextDmaFromMemory.SetDmaSpecifier.address[0] = (base); \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].contextDmaFromMemory.SetDmaSpecifier.address[1] = (selector); \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].contextDmaFromMemory.SetDmaSpecifier.limit = (ctxlimit); \
    freecount -= sizeSetDmaFromMemory;                                      \
}

#define sizeSetDmaFromMemoryContextNotifyMthdCnt    1
#define sizeSetDmaFromMemoryContextNotify           (sizeSetDmaFromMemoryContextNotifyMthdCnt * 4)
#define nvglSetDmaFromMemoryContextNotify(fifo, freecount, ch,              \
                                       ctxdmanotify)                        \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].contextDmaFromMemory.SetNotifyCtxDma = (ctxdmanotify); \
    freecount -= sizeSetDmaFromMemoryContextNotify;                         \
}

#define sizeSetDmaFromMemoryNotifyMthdCnt           4
#define sizeSetDmaFromMemoryNotify                  (sizeSetDmaFromMemoryNotifyMthdCnt * 4)
#define nvglSetDmaFromMemoryNotify(fifo, freecount, ch,                     \
                                   base, selector, ctxlimit, notify)        \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].contextDmaFromMemory.SetDmaSpecifier.address[0] = (base); \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].contextDmaFromMemory.SetDmaSpecifier.address[1] = (selector); \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].contextDmaFromMemory.SetNotify = (notify); \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].contextDmaFromMemory.SetDmaSpecifier.limit = (ctxlimit); \
    freecount -= sizeSetDmaFromMemoryNotify;                                \
}

/*
 * Context DMA to memory setup macros.
 */
#define sizeSetDmaToMemoryMthdCnt                   3
#define sizeSetDmaToMemory                          (sizeSetDmaToMemoryMthdCnt * 4)
#define nvglSetDmaToMemory(fifo, freecount, ch,                             \
                            base, selector, ctxlimit)                       \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].contextDmaToMemory.SetDmaSpecifier.address[0] = (base); \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].contextDmaToMemory.SetDmaSpecifier.address[1] = (selector); \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].contextDmaToMemory.SetDmaSpecifier.limit = (ctxlimit); \
    freecount -= sizeSetDmaToMemory;                                        \
}

#define sizeSetDmaToMemoryContextNotifyMthdCnt      1
#define sizeSetDmaToMemoryContextNotify             (sizeSetDmaToMemoryContextNotifyMthdCnt * 4)
#define nvglSetDmaToMemoryContextNotify(fifo, freecount, ch,                \
                                       ctxdmanotify)                        \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].contextDmaToMemory.SetNotifyCtxDma = (ctxdmanotify); \
    freecount -= sizeSetDmaToMemoryContextNotify;                           \
}

#define sizeSetDmaToMemoryNotifyMthdCnt             4
#define sizeSetDmaToMemoryNotify                    (sizeSetDmaToMemoryNotifyMthdCnt * 4)
#define nvglSetDmaToMemoryNotify(fifo, freecount, ch,                       \
                                   base, selector, ctxlimit, notify)        \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].contextDmaToMemory.SetDmaSpecifier.address[0] = (base); \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].contextDmaToMemory.SetDmaSpecifier.address[1] = (selector); \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].contextDmaToMemory.SetNotify = (notify); \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].contextDmaToMemory.SetDmaSpecifier.limit = (ctxlimit); \
    freecount -= sizeSetDmaToMemoryNotify;                                  \
}

/*
 * Context DMA in memory setup macros.
 */
#define sizeSetDmaInMemoryMthdCnt                   3
#define sizeSetDmaInMemory                          (sizeSetDmaInMemoryMthdCnt * 4)
#define nvglSetDmaInMemory(fifo, freecount, ch,                             \
                            base, selector, ctxlimit)                       \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].contextDmaInMemory.SetDmaSpecifier.address[0] = (base); \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].contextDmaInMemory.SetDmaSpecifier.address[1] = (selector); \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].contextDmaInMemory.SetDmaSpecifier.limit = (ctxlimit); \
    freecount -= sizeSetDmaToMemory;                                        \
}

#define sizeSetDmaInMemoryContextNotifyMthdCnt      1
#define sizeSetDmaInMemoryContextNotify             (sizeSetDmaInMemoryContextNotifyMthdCnt * 4)
#define nvglSetDmaInMemoryContextNotify(fifo, freecount, ch,                \
                                       ctxdmanotify)                        \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].contextDmaInMemory.SetNotifyCtxDma = (ctxdmanotify); \
    freecount -= sizeSetDmaInMemoryContextNotify;                           \
}

#define sizeSetDmaInMemoryNotifyMthdCnt             4
#define sizeSetDmaInMemoryNotify                    (sizeSetDmaInMemoryNotifyMthdCnt * 4)
#define nvglSetDmaInMemoryNotify(fifo, freecount, ch,                       \
                                   base, selector, ctxlimit, notify)        \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].contextDmaInMemory.SetDmaSpecifier.address[0] = (base); \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].contextDmaInMemory.SetDmaSpecifier.address[1] = (selector); \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].contextDmaInMemory.SetNotify = (notify); \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].contextDmaInMemory.SetDmaSpecifier.limit = (ctxlimit); \
    freecount -= sizeSetDmaInMemoryNotify;                                  \
}

/*
 * DrawRopRectAndText macros.
 */
#define sizeDrawRopRectAndTextColor1AMthdCnt        1 
#define sizeDrawRopRectAndTextColor1A               (sizeDrawRopRectAndTextColor1AMthdCnt * 4)
#define nvglDrawRopRectAndTextColor1A(fifo, freecount, ch, color)           \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4GdiRectangleText.Color1A = (color); \
    freecount -= sizeDrawRopRectAndTextColor1A;                             \
}

#define sizeDrawRopRectAndTextPointSizeMthdCnt      2
#define sizeDrawRopRectAndTextPointSize             (sizeDrawRopRectAndTextPointSizeMthdCnt * 4)
#define nvglDrawRopRectAndTextPointSize(fifo, freecount, ch,                \
                                        x, y, width, height)                \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4GdiRectangleText.UnclippedRectangle[0].point = ((((x) & 0x0000FFFF) << 16) | ((y) & 0x0000FFFF)); \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4GdiRectangleText.UnclippedRectangle[0].size  = ((((width) & 0x0000FFFF) << 16) | ((height) & 0x0000FFFF)); \
    freecount -= sizeDrawRopRectAndTextPointSize;                           \
}

/*
 * Surfaces2D macros.
 */
#define sizeSet2DSurfacesContextsMthdCnt            2
#define sizeSet2DSurfacesContexts                   (sizeSet2DSurfacesContextsMthdCnt * 4)
#define nvglSet2DSurfacesContexts(fifo, freecount, ch, ctxsrc, ctxdest)     \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4ContextSurfaces2D.SetContextDmaImageSource = (ctxsrc); \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4ContextSurfaces2D.SetContextDmaImageDestin = (ctxdest); \
    freecount -= sizeSet2DSurfacesContexts;                                 \
}

#define sizeSet2DSurfacesColorFormatMthdCnt         1
#define sizeSet2DSurfacesColorFormat                (sizeSet2DSurfacesColorFormatMthdCnt * 4)
#define nvglSet2DSurfacesColorFormat(fifo, freecount, ch, format)           \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4ContextSurfaces2D.SetColorFormat = (format); \
    freecount -= sizeSet2DSurfacesColorFormat;                              \
}

#define sizeSet2DSurfacesDestinationMthdCnt         1
#define sizeSet2DSurfacesDestination                (sizeSet2DSurfacesDestinationMthdCnt * 4)
#define nvglSet2DSurfacesDestination(fifo, freecount, ch, offset)           \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4ContextSurfaces2D.SetOffsetDestin = (offset); \
    freecount -= sizeSet2DSurfacesDestination;                              \
}

#define sizeSet2DSurfacesPitchMthdCnt               1
#define sizeSet2DSurfacesPitch                      (sizeSet2DSurfacesPitchMthdCnt * 4)
#define nvglSet2DSurfacesPitch(fifo, freecount, ch,                         \
                               srcpitch, dstpitch)                          \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv4ContextSurfaces2D.SetPitch = ((((dstpitch) & 0x0000FFFF) << 16) | ((srcpitch) & 0x0000FFFF)); \
    freecount -= sizeSet2DSurfacesPitch;                                    \
}

/*
 * Rop5 macros.
 */
#define sizeSetRop5MthdCnt                          1
#define sizeSetRop5                                 (sizeSetRop5MthdCnt * 4)
#define nvglSetRop5(fifo, freecount, ch, rop5)                              \
{                                                                           \
    ((Nv03ChannelPio *)(fifo))->subchannel[(ch)].nv3ContextRop.SetRop5 = (rop5); \
    freecount -= sizeSetRop5;                                               \
}

/*
 * Define the DMA jump operation.
 */
#define sizeDmaJump         0
#define nvglDmaJump(fifo, freecount, ch, offset)                            \
{                                                                           \
}

/*
 *
 */
#define nvglIdleKickoff(minsize)                                            \
{                                                                           \
}

#define DMA_PUSHER_SYNC()                                                   \
{                                                                           \
}
#endif  // D3D_CPU

#endif  // NV4
#endif  // _NV4DMAC_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\inc\nv4dinc.h ===
#ifndef _NV4DINC_H_
#define _NV4DINC_H_
#ifdef  NV4
/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: NV4DINC.H                                                         *
*   NV4 specific direct 3d structure definitions.                           *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Charles Inman (chasi)       01/31/97 - created.                     *
*                                                                           *
\***************************************************************************/

/*
 * Always build for D3D.
 * Always build a non-syncing driver.
 */
#ifndef WINNT
#define NVD3D       1
#endif // #ifndef WINNT
#define D3D_NOSYNC  1
/*
 * Specular contribution check.
 */
#define SPEC_HACK   1
#ifdef  SPEC_HACK
#define SPEC_CHECK(SpecState, SpecCurr, S0, S1, S2, count, blend)           \
{                                                                           \
    if (SpecState)                                                          \
    {                                                                       \
        if (((S0) | (S1) | (S2)) & 0x00FCFCFC)                              \
        {                                                                   \
            if (!SpecCurr)                                                  \
            {                                                               \
                (blend) |= DRF_DEF(054, _BLEND, _SPECULARENABLE, _TRUE);    \
                while (nvFreeCount < 2)                                     \
                    nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, 2);  \
                ((DWORD *)(nvFifo))[0] = (((1 << 2) << 16) | (NV_DD_SPARE << 13) | NV054_BLEND); \
                ((DWORD *)(nvFifo))[1] = (blend);                           \
                nvFreeCount -= 2;                                           \
                (DWORD *)nvFifo += 2;                                       \
                (count) = 0;                                                \
                (SpecCurr) = TRUE;                                          \
            }                                                               \
        }                                                                   \
        else                                                                \
        {                                                                   \
            (count)++;                                                      \
            if ((count) == 5)                                               \
            {                                                               \
                (blend) &= 0xFFFF0FFF;                                      \
                while (nvFreeCount < 2)                                     \
                    nvglGetFreeCount(nvFifo, nvFreeCount, NV_DD_SPARE, 2);  \
                ((DWORD *)(nvFifo))[0] = (((1 << 2) << 16) | (NV_DD_SPARE << 13) | NV054_BLEND); \
                ((DWORD *)(nvFifo))[1] = (blend);                           \
                nvFreeCount -= 2;                                           \
                (DWORD *)nvFifo += 2;                                       \
                (SpecCurr) = FALSE;                                         \
            }                                                               \
        }                                                                   \
    }                                                                       \
}
#else   // !SPEC_HACK
#define SPEC_CHECK(SpecState, SpecCurr, S0, S1, S2, count, blend)
#endif  // !SPEC_HACK

/*
 * Check current FVF vertex type to determine if recalculation is needed.
 */
#define NVFVF_NOTEXTURE_VERTEX  (D3DFVF_TLVERTEX & ~D3DFVF_TEXCOUNT_MASK)
#define CHECK_FVF_DATA_AND_LOAD_TL(_fvfData,_vertexType,_dwVertexStride,_bNeedFVFReload)\
{                                                                           \
    (_bNeedFVFReload) = FALSE;                                              \
    if ((_fvfData).dwVertexType != (_vertexType))                           \
    {                                                                       \
        if ((_vertexType) == D3DFVF_TLVERTEX) /* load TL vertex */          \
        {                                                                   \
            extern NVD3DFVFDATA   constFVFData;                             \
            (_fvfData)          = constFVFData;                             \
            (_dwVertexStride)   = 32;                                       \
        }                                                                   \
        else if (((_vertexType) & ~D3DFVF_TEXCOUNT_MASK) == NVFVF_NOTEXTURE_VERTEX) \
        {                                                                   \
            extern NVD3DFVFDATA   constFVFData;                             \
            extern D3DTLVERTEX    tlvDefault;                               \
            DWORD dwUVCount;                                                \
            DPF_LEVEL(NVDBG_LEVEL_INFO, "D3D:Calculate TLVERTEX with extra UV data"); \
            dwUVCount = (((_vertexType) & D3DFVF_TEXCOUNT_MASK) >> D3DFVF_TEXCOUNT_SHIFT); \
            (_fvfData)          = constFVFData;                             \
            (_dwVertexStride)   = 24 + (dwUVCount * 2 * 4);                 \
            (_fvfData).dwVertexType   = (_vertexType);                      \
            (_fvfData).dwVertexStride = (_dwVertexStride);                  \
            (_fvfData).dwUVCount      = dwUVCount;                          \
            if (!dwUVCount)                                                 \
            {                                                               \
                (_fvfData).dwUVMask   = 0x00000000;                         \
                (_fvfData).dwUVOffset = (DWORD)&tlvDefault.tu;              \
            }                                                               \
        }                                                                   \
        else                                  /* tag external fvfData calc*/\
        {                                                                   \
            (_bNeedFVFReload) = TRUE;                                       \
        }                                                                   \
    }                                                                       \
    else                                      /* load cached stride */      \
    {                                                                       \
        (_dwVertexStride) = (_fvfData).dwVertexStride;                      \
    }                                                                       \
}

#ifdef  NVD3D_DX6
typedef struct _def_nv_d3d_fvf_data     NVD3DFVFDATA, *PNVD3DFVFDATA;
struct _def_nv_d3d_fvf_data
{
    DWORD   dwVertexType;
    DWORD   dwVertexStride;
    DWORD   dwXYZMask;
    DWORD   dwXYZOffset;
    DWORD   dwRHWMask;
    DWORD   dwRHWOffset;
    DWORD   dwARGBMask;
    DWORD   dwARGBOffset;
    DWORD   dwSpecularMask;
    DWORD   dwSpecularOffset;
    DWORD   dwUVMask;
    DWORD   dwUVOffset;
    DWORD   dwUVCount;
    DWORD   _pad0;
    DWORD   _pad1;
    DWORD   _pad2;
};

typedef DWORD (*PFNRENDERPRIMITIVEOP)(DWORD, LPBYTE, LPD3DTLVERTEX);
typedef void  (*LPNVINDEXEDPRIM)     (DWORD, LPWORD, DWORD, LPD3DTLVERTEX);
typedef void  (*LPNVDRAWPRIM)        ( WORD,         DWORD, LPD3DTLVERTEX);
typedef void  (*LPNVFVFINDEXEDPRIM)  (DWORD, LPWORD, DWORD, LPBYTE);
typedef void  (*LPNVFVFDRAWPRIM)     ( WORD,         DWORD, LPBYTE);

#define NV_UV_COORDINATE_COUNT_MAX          2
#endif  // NVD3D_DX6

/*
 * Anti Aliasing context
 */
#define AA_MODE_SUPER                       0x00000001  // super sampled AA enabled
#define AA_MODE_SINGLECHUNK                 0x00000002  // single chunk super aa
#define AA_MODE_EDGE                        0x00000004  // edge AA enabled
#define AA_ENABLED_MASK                     0x0000000f  // all types of AA
#define AA_BUFALLOC_SUPER                   0x00000010  // super sampled aa buffers allocated
#define AA_BUFALLOC_SINGLECHUNK             0x00000020  // single chunk super sampled aa buffers allocated
#define AA_BUFALLOC_EDGE                    0x00000040  // edge aa buffers allocated
#define AA_BUFALLOC_MASK                    0x000000f0  // internal buffers allocated
#define AA_INVALID_SEMANTICS                0x00000100  // app behaves badly - aa is disabled
#define AA_CAPTURE_PUSHBUFFER               0x00000200  // aa captures to sysmem push buffer
#define AA_RENDER                           0x00000400  // aa is rendering
#define AA_CLEAR_SCREEN                     0x00000800  // set when we need to clear buffers
#define AA_CHECK_SEMANTICS                  0x00001000  // used to detect bad semantics (2d during 3d)
#define AA_COPY_SCREEN                      0x00002000  // copy frame buffer to super buffer instead of clear
#define AA_PENDING_DATA                     0x00004000  // set in singlechunk mode if we actually have rendered tris
#define AA_IN_SCENE                         0x00008000  // inside a scene - 2d is not tolerated
#define AA_2D_ADD                           0x10000000  // see below
#define AA_2D_MAX                           0x50000000  // see below ... max 2d to disable
#define AA_2D_COUNT_MASK                    0x70000000  // used to detect the app mixing 2d & 3d
#define AA_MIX_DP_NOAA                      0x00010000  // we drew primitives without aa
#define AA_MIX_DP_AA                        0x00020000  // we drew primitives with aa
#define AA_MIX_MASK                         0x00030000  // both

#define NV_AA_SEMANTICS_SETUP(_ctx)                                                 \
{                                                                                   \
    DPF_LEVEL(NVDBG_LEVEL_AA_INFO,"macro NV_AA_SEMANTICS_SETUP");                   \
    if ((_ctx)->dwAntiAliasFlags & (AA_MODE_SUPER | AA_MODE_SINGLECHUNK))           \
    {                                                                               \
        if (pDriverData->TwoDRenderingOccurred)                                     \
        {                                                                           \
            DPF_LEVEL(NVDBG_LEVEL_AA_INFO,"    2D rendering Occurred");             \
            (_ctx)->dwAntiAliasFlags |= AA_COPY_SCREEN;                             \
        }                                                                           \
        (_ctx)->dwAntiAliasFlags &= ~(AA_2D_COUNT_MASK | AA_MIX_MASK);              \
    }                                                                               \
    DPF_LEVEL(NVDBG_LEVEL_AA_INFO,"endm");                                          \
}
#define NV_AA_SEMANTICS_CHECK(_ctx)                                                 \
{                                                                                   \
    DPF_LEVEL(NVDBG_LEVEL_AA_INFO,"macro NV_AA_SEMANTICS_CHECK");                   \
    if ((_ctx)->dwAntiAliasFlags & (AA_MODE_SUPER | AA_MODE_SINGLECHUNK))           \
    {                                                                               \
        if (pDriverData->TwoDRenderingOccurred)                                     \
        {                                                                           \
            DPF_LEVEL(NVDBG_LEVEL_AA_INFO,"    2D rendering Occurred");             \
            (_ctx)->dwAntiAliasFlags += AA_2D_ADD;                                  \
            if (((_ctx)->dwAntiAliasFlags & AA_2D_COUNT_MASK) > AA_2D_MAX)          \
            {                                                                       \
                DPF_LEVEL(NVDBG_LEVEL_AA_INFO,"    Invalid Semantics Tagged");      \
                (_ctx)->dwAntiAliasFlags &= ~(AA_2D_COUNT_MASK | AA_ENABLED_MASK);  \
                (_ctx)->dwAntiAliasFlags |=  AA_2D_ADD | AA_INVALID_SEMANTICS;      \
                NV_FORCE_TRI_SETUP(_ctx);                                           \
                NV_D3D_GLOBAL_SAVE();                                               \
                nvFlushDmaBuffers();                                                \
                NV_D3D_GLOBAL_SETUP();                                              \
                pDriverData->lpLast3DSurfaceRendered = 0;                           \
                nvSetD3DSurfaceState (_ctx);                                        \
            }                                                                       \
            else                                                                    \
            {                                                                       \
                if (!((_ctx)->dwAntiAliasFlags & AA_PENDING_DATA))                  \
                {                                                                   \
                    (_ctx)->dwAntiAliasFlags |= AA_COPY_SCREEN;                     \
                }                                                                   \
            }                                                                       \
        }                                                                           \
    }                                                                               \
    DPF_LEVEL(NVDBG_LEVEL_AA_INFO,"endm");                                          \
}

typedef struct
{
    // bank 0
    DWORD dwChunkWidth;         // screen chunk width
    DWORD dwChunkHeight;        // screen chunk height
    DWORD dwSuperAddr;          // address of super buffer
    DWORD dwSuperOffset;        // aligned HW offset of super buffer
    DWORD dwSuperPitch;         // super surface pitch
    DWORD dwSuperWidth;         // super surface dimensions
    DWORD dwSuperHeight;        // super surface dimensions
    DWORD dwBPP;                // bytes per pixel
    // bank 1
    union {
        DWORD dwCapAddr;        // capture buffer address (chunking / edge)
        DWORD dwSuperZAddr;     // z buffer (single chunk)
    };
    union {
        DWORD dwCapSize;        // capture buffer size (chunking / edge)
        DWORD dwSuperZOffset;   // z buffer offset (single chunk)
    };
    union {
        DWORD dwCapIndex;       // capture index (chunking / edge)
        DWORD dwSuperZPitch;    // z buffer offset (single chunk)
    };
    float fAAScaleX;            // super sample in X
    float fAAScaleY;            // super sample in Y
    DWORD dwAASuperMode;        // lut index
    DWORD dwCFill;              // c fill     (super)
    DWORD dwZFill;              // z fill     (super)
} NVAACONTEXT,*PNVAACONTEXT;

/*
 * --------------------------------------------------------------------------
 * Define NV4 specific texture heap constants
 * --------------------------------------------------------------------------
 */
#define NV_MIN_TEXTURE_SIZE         ((1 * 2) * 1)
#define NV_MIN_TEXTURE_HEAP_SIZE    0x00100000
#define NV_TEXTURE_PAD              512
#define NV_TEXTURE_OFFSET_ALIGN     255

/*
 * Define Application DirectX version levels.
 */
#define APP_VERSION_DX2             0
#define APP_VERSION_DX3             0
#define APP_VERSION_DX5             1
#define APP_VERSION_DX6             2

/*
 * Define texture attributes
 */
#define NV4_TEXDEFAULT_AUTOMIPMAPTIME   3           // # of scenes before automips kick in
#define NV4_TEXDEFAULT_MAXBLTCOUNT      10          // # of CPU swizzle blits to take before staging
#define NV3_TEXDEFAULT_MIPSPERSCENE     3           // # if auto mips we allow to be generated per scene

#ifdef NV_TEX2
/*
 * texture manager 2.0 flags
 */
#define NV4_TEXCOUNT_SWIZZLE            8           // # of possible swizzle surface (must be power of 2)

#define NV4_TEXFLAG_SWIZZLE_INDEX       0x0000000f  // index of current swizzle surface
#define NV4_TEXFLAG_SWIZZLE_INDEX_MAX   0x000000f0  // max index of current swizzle surface

#define NV4_TEXFLAG_LINEAR_VALID        0x00010000  // linear copy has valid texels (up to date)
#define NV4_TEXMASK_LINEAR_LOCATION     0x00000f00  // linear copy location (vid,agp or pci)
#define NV4_TEXMASK_LINEAR_SHIFT        8

#define NV4_TEXFLAG_HANDLE_ALLOCATED    0x00020000  // Texture handle allocated for this texture.
#define NV4_TEXFLAG_AUTOMIPMAP          0x00040000  // we are allowed to automipmap this texture
#define NV4_TEXFLAG_AUTOMIPMAP_VALID    0x00080000  // we have valid automipmapped texels
#define NV4_TEXFLAG_USER_MIP_LEVEL      0x00100000  // This texture is a user defined mip level.
#define NV4_TEXFLAG_PALETTIZED          0x00200000  // set if texture is 8-bit palettized

#define NV4_TEXLOC_NOWHERE              0           // surface is not allocated
#define NV4_TEXLOC_VID                  1           // surface is (or may go) in video  (hw r/w)
#define NV4_TEXLOC_AGP                  2           // surface is (or may go) in agp    (hw r/-)
#define NV4_TEXLOC_PCI                  4           // surface is (or may go) in pci    (hw r/-)
#define NV4_TEXLOC_SYS                  8           // surface is (or may go) in sysmem (hw -/-)
#define NV4_TEXLOC_ANYWHERE             15          // texture may go anywhere

/*
 * swizzle surface flags
 */
#define NV4_TEXMASK_LOCATION            0x0000000f  // location of swizzle texture (do not move - hard coded)
#define NV4_TEXMASK_MIPMASK             0x0000fff0  // mask if updated mipmaps for this texture (0 means valid)
#define NV4_TEXFLAG_VALID               0x00010000  // texture is valid (mips dont have to be all valid)

/*
 * handy macros
 */
#define TEX_SWIZZLE_INDEX(flags)        ((flags) & NV4_TEXFLAG_SWIZZLE_INDEX)
#define TEX_SWIZZLE_ADDR(tex,flags)     ((tex)->dwSwizzleAddr[TEX_SWIZZLE_INDEX(flags)])
#define TEX_SWIZZLE_OFFSET(tex,flags)   ((tex)->dwSwizzleOffset[TEX_SWIZZLE_INDEX(flags)])
#define TEX_SWIZZLE_FLAGS(tex,flags)    ((tex)->dwSwizzleFlags[TEX_SWIZZLE_INDEX(flags)])
#define TEX_SWIZZLE_DATE(tex,flags)     ((tex)->dwSwizzleDate[TEX_SWIZZLE_INDEX(flags)])

#else //NV_TEX2
/*
 * texture manager 1.0 flags
 */
#define NV3_TEXTURE_VIDEO_MEMORY        0x00000001
#define NV3_TEXTURE_BLIT_UPDATE         0x00000002  // Texture modified with a DDRAW blit.
#define NV4_TEXTURE_CAN_AUTO_MIPMAP     0x00000004  // Specifies a texture can be automipmaped.
#define NV3_TEXTURE_MODIFIED            0x00000008  // texture memory has changed - force a internal reload
#define NV3_TEXTURE_IS_LOCKED           0x00000010  // texture is currently locked 
#define NV3_TEXTURE_MUST_RELOAD         0x00000020  // force current buffre DMA before reload (blt during scene)
#define NV3_TEXTURE_HANDLE_ALLOCATED    0x00000040  // Texture handle allocated for this texture.
#define NV3_TEXTURE_SURFACE_ALLOCATED   0x00000080  // Texture surface allocated for this texture.
#define NV3_TEXTURE_USER_ALLOCATED      0x00000100  // User system memory texture surface is allocated.
#define NV3_TEXTURE_INTERNAL_ALLOCATED  0x00000200  // Internal texture surface is allocated.
#define NV3_TEXTURE_USER_MIP_LEVEL      0x00000400  // This texture is a user defined mip level.
#define NV4_TEXTURE_WAS_IN_VIDEO_MEMORY 0x00000800  // texture was move from video memory by AA
#define NV4_TEXTURE_AUTOMIPMAPPED       0x00001000  // texture mipmaps are driver supplied (auto mipmapped)
#endif //NV_TEX2

/*
 * common flags
 */

struct _def_nv_d3d_texture
{
    /*
     * Second (final) pass texture definition.
     */
    DWORD                       pid;                /* Process ID */
    DWORD                       hContext;           /* Context Handle */
    DWORD                       hMipBaseTexture;    /* User Mip Base Texture Handle */

    LPDDRAWI_DIRECTDRAW_GBL     lpDriverObject;     /* Driver object used for allocating memory */
#ifndef WINNT
    LPDIRECTDRAWSURFACE         lpDDS;              /* Texture Surface */
#else
    HANDLE                      hDDS;               /* NT texture handle */
#endif
    LPDDRAWI_DDRAWSURFACE_LCL   lpLcl;              /* Texture */
    DWORD                       dwDriverData;       /* address of pDriverData */

    /*
     * Basic texture characteristics.
     */
    DWORD                       dwWidth;
    DWORD                       dwHeight;
    DWORD                       dwPitch;
#ifdef NV_TEX2
    DWORD                       dwBPP;               // bytes per pixel
    DWORD                       dwLockUpdateCount;   // # of lock performed
    DWORD                       dwBlitUpdateCount;   // # of blits performed
#else
    DWORD                       dwUpdateCount;       /* # of texture blts / locks performed */
#endif

    /*
     * MipMap Texture Information.
     */
    DWORD                       dwMipMapLevels;
    DWORD                       dwMipMapBaseU;
    DWORD                       dwMipMapBaseV;
    DWORD                       dwMipMapSizeBytes;

    /*
     * Internal hardware texture format information.
     */
    HANDLE                      hTextureMem;
    DWORD                       dwTextureFlags;
    DWORD                       dwTextureContextDma;
    DWORD                       dwTextureColorFormat;
#ifdef NV_TEX2
    DWORD                       dwSwizzleAddr  [NV4_TEXCOUNT_SWIZZLE];    // actual swizle surface address (not aligned)
    DWORD                       dwSwizzleOffset[NV4_TEXCOUNT_SWIZZLE];    // offset of swizzle surface
    DWORD                       dwSwizzleFlags [NV4_TEXCOUNT_SWIZZLE];    // flags for this surface
    DWORD                       dwSwizzleDate  [NV4_TEXCOUNT_SWIZZLE];    // scene it retires in
    DWORD                       dwRetireDate   [NV4_TEXCOUNT_SWIZZLE+1];  // when the texture surface retires, extra is for linear
    DWORD                       dwLinearAddr;       // actual linear address (not aligned)
    DWORD                       dwLinearOffset;     // offset of linear surface
#else
    DWORD                       dwTexturePointer;
    DWORD                       dwTextureOffset;    /* Texture offset within heap */
#endif

    /*
     * Reference pointer to texture data.
     * This is used only for validation and checking to see if the texture
     * pointer in the texture surface has changed.  This may occur during
     * texture flipping.  If this pointer does not match what is stored in
     * in the texture surface, then the texture needs to be reloaded.
     */
    FLATPTR                     fpTexture;

#ifdef NV_TEX2
    /*
     * auto mipmap code
     */
    DWORD                       dwAutoMipMapScene;      // scene # that automips kick in
    DWORD                       dwAutoMipMapCount;      // mipmap count (when activated)
    /*
     * dirty rectangle
     */
    DWORD                       dwDirtyX0;              // dirty rect (for efficient lin<->swiz)
    DWORD                       dwDirtyY0;              // dirty rect (for efficient lin<->swiz)
    DWORD                       dwDirtyX1;              // dirty rect (for efficient lin<->swiz)
    DWORD                       dwDirtyY1;              // dirty rect (for efficient lin<->swiz)
#else // !NV_TEX2
    /*
     * User texture surface allocated for this texture.
     */
    HANDLE                      hUserTexture;
    FLATPTR                     fpUserTexture;
#endif // !NV_TEX2

    /*
     * Application Texture Bug Workarounds.
     * Just handy for fixing developers bugs while we wait for the
     * real fix.
     */
    DWORD                       dwDebugFlags01;
    DWORD                       dwDebugFlags02;

    PNVD3DTEXTURE               pTexturePrev;
    PNVD3DTEXTURE               pTextureNext;
};

/*
 * Look in D3DTYPES.H to determine what this value is.
 * I'm not including any of the stipple state on purpose.
 */
#ifdef  NVD3D_DX6
#define D3D_RENDERSTATE_MAX     D3DRENDERSTATE_WRAP7
#else   // !NVD3D_DX6
#define D3D_RENDERSTATE_MAX     D3DRENDERSTATE_FLUSHBATCH
#endif  // !NVD3D_DX6

/*
 * Cache aligned inner loop context data.
 * Note also, that the hardware registers should be defined in the order that
 * they appear in the in the object class.
 */
struct _def_nv_d3d_context_inner_loop
{
// bank 0       !!!Don't change bank or element ordering!!!
    /*
     * Current rendering state.
     */
    DWORD                       dwColorKey;
    DWORD                       dwTextureOffset;       // Offset within DMA context to start of texture.
    DWORD                       dwFormat;
    DWORD                       dwFilter;              // Current filtering state.
    DWORD                       dwBlend;
    DWORD                       dwControl;
    DWORD                       dwFogColor;             // Current fog color.
    DWORD                       _dwPad0[1];

// bank 1       !!!Don't change bank or element ordering!!!!
#ifdef  SPEC_HACK
    /*
     * Values used for temporarily disabling hardware specular enable bit when
     * the vertex specular components do not contribute any specular highlight.
     * This is so that we can get two pixels per clock out of the DX5 class
     * whenever possible.

     */
    DWORD                       dwCurrentBlend;
    DWORD                       dwCurrentSpecularState;
    DWORD                       dwNoSpecularTriangleCount;
    DWORD                       _dwPad1[5];
#endif  // SPEC_HACK
};
#ifdef  NVD3D_DX6
typedef struct _def_nv_d3d_texture_stage_state NVD3DTEXSTAGESTATE, *PNVD3DTEXSTAGESTATE;
struct _def_nv_d3d_texture_stage_state
{
    DWORD   dwTextureMap;
    DWORD   dwAddressU;
    DWORD   dwAddressV;
    DWORD   dwMagFilter;
    DWORD   dwMinFilter;
    DWORD   dwMipFilter;
    DWORD   dwColorOp;
    DWORD   dwColorArg1;
    DWORD   dwColorArg2;
    DWORD   dwAlphaOp;
    DWORD   dwAlphaArg1;
    DWORD   dwAlphaArg2;
    DWORD   dwBumpEnvMat00;
    DWORD   dwBumpEnvMat01;
    DWORD   dwBumpEnvMat10;
    DWORD   dwBumpEnvMat11;
    DWORD   dwTexCoordIndex;
    DWORD   dwBorderColor;
    DWORD   dwMipMapLODBias;
    DWORD   dwMaxMipLevel;
    DWORD   dwMaxAnisotropy;
    DWORD   dwBumpEnvlScale;
    DWORD   dwBumpEnvlOffset;
    /*
     * Extra per stage state.
     */
    BYTE    bStageNumber;
    BYTE    bWrapU;
    BYTE    bWrapV;
    BYTE    bLODBias;
};

typedef struct _def_nv_d3d_multi_texture_state NVD3DMULTITEXTURESTATE, *PNVD3DMULTITEXTURESTATE;
struct _def_nv_d3d_multi_texture_state
{
    DWORD   dwTextureOffset[2];
    DWORD   dwTextureFormat[2];
    DWORD   dwTextureFilter[2];
    DWORD   dwCombine0Alpha;
    DWORD   dwCombine0Color;
    DWORD   dwCombine1Alpha;
    DWORD   dwCombine1Color;
    DWORD   dwCombineFactor;
    DWORD   dwBlend;
    DWORD   dwControl0;
    DWORD   dwControl1;
    DWORD   dwControl2;
    DWORD   dwFogColor;

    /*
     * The hardware requires the the UVx texture coordinates match up with
     * TEXTUREx.  i.e. tu0, tv0 are the coordinates for TEXTURE0, and tu1,
     * tv1 are the coordinates for TEXTURE1.
     * To simplify life, I am making TEXTURE0 always correspond to texture
     * stage 0, TEXTURE1 will always correspond to texture stage 1, etc.
     * However, there does not always have to be a one to one correspondence
     * to the Texture stage and the order in which the UV coordinate pairs
     * appear in the FVF Vertices.  The texture stage state defines which
     * set of UV coordinates applies to the texture in that stage.  This
     * allows for a single set of UV coordinates to be used for the multiple
     * texture stages.
     * The following offset array gives the byte offset from the start of the
     * FVF UV corrdinate pairs to the actual UV coordinates to be used for
     * a particular UVx pair.  They are initialized when the multi-texture state
     * is caclulated.
     */
    DWORD   dwUVOffset[8];

    /*
     * This flag defines if the current texture stage state is
     * valid.  This flag basicly defines whether or not multi-texturing
     * is possible with the current state.
     * This flag can be used during the ValidateTextureStageState callback
     * to report whether we can mulit-texture with the current state.
     * If the state is not valid, ddrval will contain the error that should
     * be returned during a ValidateTextureStageState callback.
     */
    BOOL    bTSSValid;
    HRESULT ddrval;
};
#endif  // NVD3D_DX6

/*
 * Define the context flags.
 */
#define NV_CONTEXT_ZETA_BUFFER_MISMATCH         0x00000001
#define NV_CONTEXT_TBLEND_UNINITIALIZED         0x00000002  // This flag will be cleared after the first TBLEND call.

#ifdef NV_CONTROLTRAFFIC
#define NV_CT_DISABLED          0x00000000
#define NV_CT_ENABLED           0x00000001
#define NV_CT_FRONT             0x00000002
#define NV_CT_DRAWPRIM          0x00010000
#endif //NV_CONTROLTRAFFIC

/*
 * Define the context header.
 */
struct _def_nv_d3d_context
{
    /*
     * The following structure is designed for a fast copy from the context data structure
     * to cache aligned global data for fast access within the inner loops.
     */
    NVD3DCONTEXTINNERLOOP       ctxInnerLoop;           // Context data used within inner loops.
    NVD3DCONTEXTINNERLOOP       ctxInnerLoopShadow;     // hw image of above

    /*
     * Application DX version.
     */
    DWORD                       dwDXVersionLevel;       // Tells the applications DX version level.
                                                        // 0=DX2, DX3; 1=DX5; 2=DX6

    /*
     * D3D Context Flags.
     */
    DWORD                       dwContextFlags;         // Various context related flags.

    /*
     * Default texture state for this context.
     */
    DWORD                       dwDefaultTextureContextDma;  // Default texture rendering object.
    DWORD                       dwDefaultTextureBase;
    DWORD                       dwDefaultTextureOffset;      // Offset within DMA context to start of default texture.
    DWORD                       dwDefaultTextureColorFormat; // Default texture format.

#ifdef NV_TEX2
    PNVD3DTEXTURE               pTexture0;              // texture HW is currently setup with
    PNVD3DTEXTURE               pTexture1;              // texture HW is currently setup with
    
    DWORD                       dwTexturePaletteStagingHandle;
    DWORD                       dwTexturePaletteAddr;   // address of palette staging area
    DWORD                       dwTexturePaletteOffset; // offset of palette staging area
#endif

    /*
     * Surface clip rectangle.
     */
    struct  _surface_viewport                           // Surface clip region.
    {
        union
        {
            DWORD   dwClipHorizontal;
            struct  _clip_horizontal
            {
                WORD    wX;                             // Surface left edge
                WORD    wWidth;                         // Surface Clip Width
            } clipHorizontal;
        };
        union
        {
            DWORD   dwClipVertical;
            struct  _clip_vertical
            {
                WORD    wY;                             // Surface top edge
                WORD    wHeight;                        // Surface Clip Height
            } clipVertical;
        };
    } surfaceViewport;

    /*
     * Surface Pitch
     */
    union
    {
        DWORD   dwSurfacePitch;                         // Surface pitches.
        struct _surface_pitch
        {
            WORD    wColorPitch;                        // Render target pitch.
            WORD    wZetaPitch;                         // Zeta buffer pitch.
        } surfacePitch;
    };

    /*
     * Current Surface.
     */
    DWORD                       dwSurfaceAddr;
    DWORD                       dwSurfaceOffset;
    DWORD                       dwSurfaceFormat;

    /*
     * Current Z Buffer address.
     */
    DWORD                       ZBufferAddr;            // Pointer to Z Buffer
    DWORD                       ZBufferOffset;

    /*
     * Current rendering state.
     */
    DWORD                       dwStateChange;
    DWORD                       dwRenderState[D3D_RENDERSTATE_MAX];
    DWORD                       dwFogTableMode;         // Current fog table mode.
    float                       fFogTableStart;         // Current fog table start.
    float                       fFogTableEnd;           // Current fog table end.
    float                       fFogTableDensity;       // Current fog table density.
    float                       fFogTableLinearScale;   // Current fog table linear scale.
    DWORD                       dwFunctionLookup;       // Lookup index for the appropriate render function.
    DWORD                       dwMipMapLODBias;        // LOD Bias value to stuff into the hardware.
    DWORD                       dwSceneCount;           // # of scenes we have rendered in this context
    DWORD                       dwMipMapsInThisScene;   // # of auto mips generated in this scene

    /*
     * Anti aliasing context storage
     */
    DWORD                       dwAntiAliasFlags;
    NVAACONTEXT                *pAAContext;

    /*
     * Optimized Z data
     */
#ifdef NV_CONTROLTRAFFIC
    DWORD                       dwCTFlags;
#endif

    /*
     * Miscellaneous context data.
     */
    LPDDRAWI_DDRAWSURFACE_LCL   lpLcl;                  // Rendering surface.
    LPDDRAWI_DDRAWSURFACE_LCL   lpLclZ;                 // Z surface.
    DWORD                       pid;                    // Process ID
    NVD3DSTATESET               overrides;              // Render state override bits.

    DWORD                       dwContextReset;         // This is set when a mode switch occurs.
    PNVD3DCONTEXT               pContextPrev;
    PNVD3DCONTEXT               pContextNext;

#ifdef  NVD3D_DX6
    /*
     * DX6 Texture Stage State.
     */
    DWORD                       dwStageCount;           // Number of enabled/valid texture stages.
    BOOL                        bUseDX6Class;           // Use DX6 Multi-Texture Triangle Class.
    BOOL                        bUseTBlendSettings;     //
    DWORD                       dwTBlendCombine0Alpha;
    DWORD                       dwTBlendCombine0Color;
    NVD3DMULTITEXTURESTATE      mtsState;               // DX6 Multi-Texture Triangle State.
    NVD3DMULTITEXTURESTATE      mtsShadowState;         //  for state update optimizations
    NVD3DTEXSTAGESTATE          tssState[8];            // Texture Stage State.

    /*
     * Near/Far Clip planes.
     */
    D3DVALUE                    dvWNear;
    D3DVALUE                    dvWFar;
    D3DVALUE                    dvRWFar;                // Reciprocal of WFar.
#endif  // NVD3D_DX6
#ifdef WINNT
    /*
     * Need this for Winnt to access the PDEV state struct maintained by display
     * driver. PDEV also contains a ptr to the GLOBALDATA struct.
     *
     */
    PDD_DIRECTDRAW_GLOBAL        lpDD;
#endif // #ifdef WINNT
};

/*
 * Function Prototypes
 */
void nvD3DCreateObjects(void);
void nvD3DDestroyObjects(void);
#ifndef WINNT
DWORD __stdcall Clear32(LPD3DHAL_CLEARDATA);
#endif

void  nvSetD3DSurfaceState(PNVD3DCONTEXT);
void  nvSetD3DSurfaceViewport(PNVD3DCONTEXT);
void  nvSetDx5TriangleState(PNVD3DCONTEXT);
DWORD nvRenderNoOp(DWORD, LPBYTE, LPD3DTLVERTEX);
DWORD nvRenderTriangle(DWORD, LPBYTE, LPD3DTLVERTEX);
DWORD nvRenderPoint(DWORD, LPBYTE, LPD3DTLVERTEX);
DWORD nvRenderLine(DWORD, LPBYTE, LPD3DTLVERTEX);

#ifndef WINNT
DWORD nvClear(LPD3DHAL_CLEARDATA);
#endif
void  nvTriangle(DWORD, LPD3DTRIANGLE, LPD3DTLVERTEX);
void  nvIndexedTriangle(DWORD, WORD, LPWORD, LPD3DTLVERTEX);

#ifdef  MULTI_MON
void D3DDestroyTextureContexts(void);
#endif  // MULTI_MON
#ifndef WINNT
/*
 * Non-Indexed Primitive Routines.
 */
DWORD __stdcall DrawOnePrimitive32(LPD3DHAL_DRAWONEPRIMITIVEDATA);
DWORD __stdcall DrawPrimitives32(LPD3DHAL_DRAWPRIMITIVESDATA);
DWORD nvDrawOnePrimitive(LPD3DHAL_DRAWONEPRIMITIVEDATA);
DWORD nvDrawPrimitives(LPD3DHAL_DRAWPRIMITIVESDATA);

/*
 * Indexed Primitive Routines.
 */
DWORD __stdcall DrawOneIndexedPrimitive32(LPD3DHAL_DRAWONEINDEXEDPRIMITIVEDATA);
DWORD nvDrawOneIndexedPrimitive(LPD3DHAL_DRAWONEINDEXEDPRIMITIVEDATA);
#endif
void nvDrawLine(DWORD, DWORD, LPD3DTLVERTEX);
void nvIndexedLine(DWORD, LPWORD, DWORD, LPD3DTLVERTEX);
void nvDrawPointList(DWORD, LPD3DTLVERTEX);

void nvIndexedWireframeTriangle(DWORD, LPWORD, DWORD, LPD3DTLVERTEX);
void nvDrawWireframeTriangle(DWORD, DWORD, LPD3DTLVERTEX);
void nvIndexedPointTriangle(DWORD, LPWORD, DWORD, LPD3DTLVERTEX);
void nvDrawPointTriangle(DWORD, DWORD, LPD3DTLVERTEX);

#ifdef  NVD3D_DX6
DWORD FAR PASCAL DrawPrimitives2(LPD3DHAL_DRAWPRIMITIVES2DATA);
DWORD FAR PASCAL Clear2(LPD3DHAL_CLEAR2DATA pc2d);

void  nvSetMultiTextureHardwareState(void);
DWORD FAR PASCAL nvValidateTextureStageState(LPD3DHAL_VALIDATETEXTURESTAGESTATEDATA);
DWORD nvDrawPrimitives2(LPD3DHAL_DRAWPRIMITIVES2DATA);
DWORD nvClear2(LPD3DHAL_CLEAR2DATA pc2d);

void nvFVFDrawLine(DWORD, DWORD, LPBYTE);
void nvFVFIndexedLine(DWORD, LPWORD, DWORD, LPBYTE);
void nvFVFDrawPointList(DWORD, LPBYTE);

void nvFVFIndexedWireframeTriangle(DWORD, LPWORD, DWORD, LPBYTE);
void nvFVFDrawWireframeTriangle(DWORD, DWORD, LPBYTE);
void nvFVFIndexedPointTriangle(DWORD, LPWORD, DWORD, LPBYTE);
void nvFVFDrawPointTriangle(DWORD, DWORD, LPBYTE);

void nvSetDx6MultiTextureState(PNVD3DCONTEXT);
#endif  // NVD3D_DX6

/*
 * External data.
 */
extern PFNRENDERPRIMITIVEOP     pfnRenderPrimitiveOperation[];
extern DWORD                    uvInterleave[];

#ifdef  NVD3D_DX6
extern PFND3DPARSEUNKNOWNCOMMAND    fnD3DParseUnknownCommandCallback;
/* - not used anymore ?
extern LPNVFVFDRAWPRIM              fnMultiDrawTriangleList[];
extern LPNVFVFDRAWPRIM              fnMultiDrawTriangleStrip[];
extern LPNVFVFDRAWPRIM              fnMultiDrawTriangleFan[];
extern LPNVFVFINDEXEDPRIM           fnMultiIndexedTriangleList[];
extern LPNVFVFINDEXEDPRIM           fnMultiIndexedTriangleStrip[];
extern LPNVFVFINDEXEDPRIM           fnMultiIndexedTriangleFan[];
*/
#endif  // NVD3D_DX6

/*
 * Texture Staging Manager Functions
 */
//#define TM_STAGER_IN_AGP
#define TM_STAGESPACE              (2*1024*1024) // 2048k

#define NV_PN_TEX_RETIRE           0    // depreciated in for nv_tex2
#define NV_PN_SPOOFED_FLIP_COUNT   4
#define NV_PN_TEXTURE_RETIRE       8

void __stdcall nvFastCopy          (DWORD,DWORD,DWORD);
DWORD nvPlacePsuedoNotifier        (DWORD,DWORD);
DWORD nvTMCreate                   (void);
void  nvTMDestroy                  (void);
DWORD nvTMAllocTextureStagingSpace (DWORD,DWORD*,DWORD*);
void  nvTMUpdateRetirementDate     (DWORD);
void  nvTMVideoTextureBlt          (DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD);

/*
 * Embedded Profiler Functions
 */
#ifdef NV_PROFILE

#if 0
/*
 * Constants
 */
#define NVP_T_CLOCK                 0x00    // 00000001
#define NVP_T_FLUSH                 0x01    // 00000002
#define NVP_T_SCENE                 0x02    // 00000004
#define NVP_T_FLIP                  0x03    // 00000008
#define NVP_T_DP2                   0x04    // 00000010
#define NVP_T_FREECOUNT             0x05    // 00000020
#define NVP_T_TSTAGE                0x06    // 00000040

#define NVP_E_PUT                   0x10    // 00010000
#define NVP_E_BEGINSCENE            0x11    // 00020000

#define NVP_C_PENDING               0x18    // 01000000

#define NVP_EVERYTHING                       0x0103007f

/*
 * Macros
 */
#define _NVP_PUSH  __asm push eax __asm push edx __asm push ebx
#define _NVP_POP   __asm pop ebx __asm pop edx __asm pop eax
#define _NVP_SYNC  __asm xchg al,al __asm nop __asm nop
#define _NVP_RDTSC _NVP_SYNC __asm _emit 0x0f __asm _emit 0x31

#define NVP_START(_t) { nvpTime[_t]=0; NVP_RESTART(_t); }
#define NVP_RESTART(_t) { _NVP_PUSH _NVP_RDTSC __asm mov ebx,(OFFSET nvpTime+(_t)*8) __asm sub [ebx],eax __asm sbb [ebx+4],edx _NVP_POP }
#define NVP_STOP(_t)  { _NVP_PUSH _NVP_RDTSC __asm mov ebx,(OFFSET nvpTime+(_t)*8) __asm add [ebx],eax __asm adc [ebx+4],edx _NVP_POP }

extern __int64 nvpTime[256];

/*
 * protoypes
 */
void nvpFlush    (void);
void nvpCreate   (void);
void nvpDestroy  (void);
void nvpLogCount (DWORD id,__int64 count);
void nvpLogTime  (DWORD id,__int64 time);
void nvpLogEvent (DWORD id);
#endif // 0

#if 1

/*
 * Constants
 */
#define NVP_E_BEGINSCENE            0
#define NVP_E_PUT                   1
#define NVP_E_TRIDISP               2

#define NVP_T_SCENE                 3
#define NVP_T_FREECOUNT             4
#define NVP_T_FLIP                  5
#define NVP_T_TSTAGE                6
#define NVP_T_DP2                   7
#define NVP_T_HDFLUSH               8
#define NVP_T_TEXWAIT               9
#define NVP_T_TEXSWBLT              10
#define NVP_T_TEXHWBLT              11
#define NVP_T_INNERLOOP             12
#define NVP_T_BUILDLOOP             13

#define NVP_C_PENDING               14
#define NVP_C_BLTSIZE               15
#define NVP_C_1PIXCLK               16
#define NVP_C_2PIXCLK               17
#define NVP_C_TRIAREA               18
#define NVP_C_PIXPERSEC             19
#define NVP_C_TRICOUNT              20

/*
 * Macros
 */
#define _NVP_PUSH  __asm push eax __asm push edx __asm push ebx
#define _NVP_POP   __asm pop ebx __asm pop edx __asm pop eax
#define _NVP_SYNC  __asm xchg al,al __asm nop __asm nop
#define _NVP_RDTSC _NVP_SYNC __asm _emit 0x0f __asm _emit 0x31

#define NVP_START(_t) { nvpTime[_t]=0; NVP_RESTART(_t); }
#define NVP_RESTART(_t) { _NVP_PUSH _NVP_RDTSC __asm mov ebx,(OFFSET nvpTime+(_t)*8) __asm sub [ebx],eax __asm sbb [ebx+4],edx _NVP_POP }
#define NVP_STOP(_t)  { _NVP_PUSH _NVP_RDTSC __asm mov ebx,(OFFSET nvpTime+(_t)*8) __asm add [ebx],eax __asm adc [ebx+4],edx _NVP_POP }

extern __int64 nvpTime[256];
extern DWORD   nvpEnableBits;
extern DWORD   nvpTriPerSecWindow;

/*
 * functions
 */
void nvpCreate   (void);
void nvpDestroy  (void);
void nvpFlush    (void);
void nvpLogEvent (DWORD id);
void nvpLogCount (DWORD id,int count);
void nvpLogTime  (DWORD id,__int64 time);

#endif // 1

#endif // NV_PROFILE

#ifdef NV_FASTLOOPS
/*
 * nv4comp.h
 */
typedef void (__stdcall *PFNDRAWPRIMITIVE)(DWORD dwPrimCount,LPWORD pIndices,DWORD dwStrides,LPBYTE pVertices);

#endif //NV_FASTLOOPS

#endif  // NV4
#endif  // _NV4DINC_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\inc\NVD3DCAP.H ===
#ifndef _NVD3DCAP_H_
#define _NVD3DCAP_H_
/*
 * (C) Copyright NVIDIA Corporation Inc., 1996,1997. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: NVD3DCAP.H                                                        *
*   Define the capabilities of the NV D3D driver.                           *
*   This is mainly just a hardware selection include file.  The specific    *
*   hardware device capabilities are in the files:                          *
*   nv3dcaps.h, nv4dcaps.h, ...                                             *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Charles Inman (chasi)       01/31/98 - created.                     *
*                                                                           *
\***************************************************************************/
/*
 * Select the NV3 hardware capabilities.
 */
#ifdef  NV3
#include    "nv3dcaps.h"

#define NV_DEVDESC_FLAGS            NV3_DEVDESC_FLAGS
#define NV_COLORMODEL               NV3_COLORMODEL
#define NV_DEVCAPS_FLAGS            NV3_DEVCAPS_FLAGS
#define NV_TRANSFORMCAPS            NV3_TRANSFORMCAPS
#define NV_3DCLIPPINGCAPS           NV3_3DCLIPPINGCAPS
#define NV_LIGHTINGCAPS             NV3_LIGHTINGCAPS
#define NV_LINECAPS                 NV3_LINECAPS
#define NV_TRICAPS                  NV3_TRICAPS
#define NV_RENDERBITDEPTHCAPS       NV3_RENDERBITDEPTHCAPS
#define NV_ZBUFFERBITDEPTHCAPS      NV3_ZBUFFERBITDEPTHCAPS
#define NV_MAXBUFFERSIZE            NV3_MAXBUFFERSIZE
#define NV_MAXVERTEXCOUNT           NV3_MAXVERTEXCOUNT
#endif  // NV3

/*
 * Select the NV4 hardware capabilities.
 */
#ifdef  NV4
#include    "nv4dcaps.h"

#define NV_DEVDESC_FLAGS            NV4_DEVDESC_FLAGS
#define NV_COLORMODEL               NV4_COLORMODEL
#define NV_DEVCAPS_FLAGS            NV4_DEVCAPS_FLAGS
#define NV_TRANSFORMCAPS            NV4_TRANSFORMCAPS
#define NV_3DCLIPPINGCAPS           NV4_3DCLIPPINGCAPS
#define NV_LIGHTINGCAPS             NV4_LIGHTINGCAPS
#define NV_LINECAPS                 NV4_LINECAPS
#define NV_TRICAPS                  NV4_TRICAPS
#define NV_RENDERBITDEPTHCAPS       NV4_RENDERBITDEPTHCAPS
#define NV_ZBUFFERBITDEPTHCAPS      NV4_ZBUFFERBITDEPTHCAPS
#define NV_MAXBUFFERSIZE            NV4_MAXBUFFERSIZE
#define NV_MAXVERTEXCOUNT           NV4_MAXVERTEXCOUNT
#endif  // NV4
#endif  // _NVD3DCAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\inc\NV4DREG.H ===
#ifndef _NV4DREG_H_
#define _NV4DREG_H_
#ifdef  NV4
/*
 * (C) Copyright NVIDIA Corporation Inc., 1996,1997,1998. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: NV4DREG.H                                                         *
*   Define the D3D driver registry strings and default settings.            *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Charles Inman (chasi)       01/31/98 - Created.                     *
*                                                                           *
\***************************************************************************/

#define REG_BIT1_FOG_TABLE_ENABLE           0x00000001
#define REG_BIT1_ANTI_ALIAS_ENABLE          0x00000002
#define REG_BIT1_USER_MIPMAPS_ENABLE        0x00000004
#define REG_BIT1_VIDEO_TEXTURE_ENABLE       0x00000008
#define REG_BIT1_DMA_PUSH_SIZE_OVERRIDE     0x00000010
#define REG_BIT1_DMA_PUSH_COUNT_OVERRIDE    0x00000020
#define REG_BIT1_MIPMAP_DITHER_ENABLE       0x00000040
#define REG_BIT1_NO_WAIT_4_VSYNC            0x00000080
#define REG_BIT1_RESTRICT_AUTO_MIPMAPS      0x00000100
#define REG_BIT1_CKCOMPATABILITY_ENABLE     0x00000200
#define REG_BIT1_CONTROLTRAFFIC             0x00000400

/*
 * Value defines for some registry settings.
 * These are the values that are actually set in the registry.
 */
/*
 * FogTableEnable definitioans.
 */
#define REG_FTE_DISABLE                     0           // Disable Fog Table support.
#define REG_FTE_ENABLE                      1           // Enable Fog Table support
#define REG_FTE_MAX                         1

/*
 * AntiAliasEnable definitioans.
 */
#define REG_AAE_DISABLE                     0           // Disable Anti-Aliasing support.
#define REG_AAE_ENABLE                      1           // Enable Anti-Aliasing support.
#define REG_AAE_MAX                         1

/*
 * UserMipmaps definitioans.
 */
#define REG_UMM_DISABLE                     0           // Disable User supplied mipmaps.
#define REG_UMM_ENABLE                      1           // Enable User supplied mipmaps.
#define REG_UMM_MAX                         1

/*
 * VideoTexture definitioans.
 */
#define REG_VT_DISABLE                      0           // Disable texturing from video memory.
#define REG_VT_ENABLE                       1           // Enable texturing from video memory.
#define REG_VT_MAX                          1

/*
 * MipmapLevels definitioans.
 */
#define REG_MML_DISABLE                     0           // Disable Auto generated mipmaps.
#define REG_MML_ENABLE                      12          // Enable Auto generated mipmaps.
#define REG_MML_RESTRICTED                  13          // Restrict auto generation to non-colorkey/non-alpha textures.
#define REG_MML_MAX                         13

/*
 * AutoMipMapMethod definitions
 */
#define REG_AMMM_BILINEAR                   0
#define REG_AMMM_TRILINEAR                  1
#define REG_AMMM_MAX                        1

/*
 * TexelAlignment definitions.
 * Bit flags (bit 0 = ZOH, bit 1 = FOH, bit 2 = Texel Origin)
 */
#define REG_TA_ZOH_CENTER                   0x00
#define REG_TA_ZOH_CORNER                   0x01
#define REG_TA_FOH_CENTER                   0x00
#define REG_TA_FOH_CORNER                   0x02
#define REG_TA_TEXEL_CENTER                 0x00
#define REG_TA_TEXEL_CORNER                 0x04
#define REG_TA_MAX                          0x07
#define REG_TA_ZOH_MASK                     0x01
#define REG_TA_FOH_MASK                     0x02
#define REG_TA_TEXEL_MASK                   0x04

/*
 * MipMapDitherEnable definitions.
 */
#define REG_MMDE_FALSE                      0           // Disable mipmap dithering (true trilinear)
#define REG_MMDE_TRUE                       1           // Enable mipmap dithering (fake trilinear)
#define REG_MMDE_MAX                        1

/*
 * Pal8TextureConvert definitions
 */
#define REG_P8TC_NONE                       0           // Don't support 8 bit palettized textures.
#define REG_P8TC_8TOR5G6B5                  1           // Convert 8 bit palettized textures to 16 bit R5G6B5 textures.
#define REG_P8TC_8TOX1R5G5B5                2           // Convert 8 bit palettized textures to 16 bit X1R5G5B5 textures.
#define REG_P8TC_8TOA1R5G5B5                3           // Convert 8 bit palettized textures to 16 bit A1R5G5B5 textures.
#define REG_P8TC_8TOX8R8G8B8                4           // Convert 8 bit palettized textures to 32 bit X8R8G8B8 textures.
#define REG_P8TC_8TOA8R8G8B8                5           // Convert 8 bit palettized textures to 32 bit A8R8G8B8 textures.
#define REG_P8TC_Y8ONLY                     6           // Support Luminance Textures only
#define REG_P8TC_MAX                        6

/*
 * DX6Enable definitions.
 */
#define REG_DX6E_DISABLE                    0           // Don't export DX6 callbacks (DX5 Equivalent)
#define REG_DX6E_OPTIMIZED                  1           // Enable optimal DX6 functionality.
#define REG_DX6E_FORCE_FVF                  2           // Force use of FVF inner loops for non-multi pass cases.
#define REG_DX6E_FORCE_MULTI                3           // Force use of DX6 Multi-Texture inner loops for all cases.
#define REG_DX6E_MAX                        3

/*
 * Prerender limits
 */
#define REG_PRERENDER_MIN                   1
#define REG_PRERENDER_MAX                   100

/*
 * AAMethod limits
 */
#define REG_AAMETHOD_MIN                    0
#define REG_AAMETHOD_2x1                    0
#define REG_AAMETHOD_2x2                    1
#define REG_AAMETHOD_3x2                    2
#define REG_AAMETHOD_3x3                    3
#define REG_AAMETHOD_4x2                    4
#define REG_AAMETHOD_4x3                    5
#define REG_AAMETHOD_4x4                    6
#define REG_AAMETHOD_MAX                    6

/*
 * ValidateZMethod definitions.
 */
#define REG_VZM_STRICT                      0           // Z-Buffer must always match rendering depth.
#define REG_VZM_MIXED                       1           // DX6 applications = STRICT, DX5 applications = flexible
#define REG_VZM_FLEXIBLE                    2           // Driver will match z-buffer to rendering depth.
#define REG_VZM_MAX                         2

/*
 * Colorkey Reference Values range.
 */
#define REG_CKREF_MIN                       0x00
#define REG_CKREF_MAX                       0x7F

/*
 * CKCompatabilityEnable definitions.
 */
#define REG_CKCE_FALSE                      0x00
#define REG_CKCE_TRUE                       0x01
#define REG_CKCE_MAX                        0x01

#define NV4D3D_APP_STRING                       "SOFTWARE\\NVIDIA Corporation\\RIVA TNT\\Direct3D"
/*
 * Driver registry strings.
 *
 * Enable/Disable settings.
 */
#define NVD3D_FOG_TABLE_STRING                  "FOGTABLEENABLE"
#define NVD3D_ANTI_ALIAS_ENABLE_STRING          "ANTIALIASENABLE"
#define NVD3D_USER_MIPMAPS_STRING               "USERMIPMAPS"
#define NVD3D_VIDEO_TEXTURE_STRING              "VIDEOTEXTURE"
#define NVD3D_NO_WAIT_4_VSYNC_STRING            "NOVSYNC"
#define NVD3D_TEXEL_ALIGNMENT_STRING            "TEXELALIGNMENT"
#define NVD3D_MIPMAP_DITHER_ENABLE_STRING       "MIPMAPDITHERENABLE"
#define NVD3D_CKCOMPATABILITY_ENABLE_STRING     "CKCOMPATABILITYENABLE"
#define NVD3D_CKREF_STRING                      "CKREF"
#define NVD3D_CONTROLTRAFFIC_STRING             "CONTROLTRAFFIC"

/*
 * Value defined settings.
 */
#define NVD3D_MIPMAP_LEVELS_STRING              "MIPMAPLEVELS"
#define NVD3D_AUTO_MIPMAP_METHOD_STRING         "AUTOMIPMAPMETHOD"
#define NVD3D_TEX_HEAP_STRING                   "TEXHEAP"
#define NVD3D_MIN_VIDEO_TEX_SIZE_STRING         "MINVIDEOTEXSIZE"
#define NVD3D_DMA_MIN_PUSH_COUNT_STRING         "DMAMINPUSHCOUNT"
#define NVD3D_DMA_PUSH_BUFFER_SIZE_MAX_STRING   "DMAPUSHBUFFERSIZEMAX"
#define NVD3D_CONTEXT_MAX_STRING                "D3DCONTEXTMAX"
#define NVD3D_TEXTURE_MAX_STRING                "D3DTEXTUREMAX"
#define NVD3D_LOD_BIAS_ADJUST_STRING            "LODBIASADJUST"
#define NVD3D_PAL8_TEXTURE_CONVERT_STRING       "PAL8TEXTURECONVERT"
#define NVD3D_DX6_ENABLE_STRING                 "DX6ENABLE"
#define NVD3D_PRERENDER_LIMIT_STRING            "NOVSYNCPRERENDERLIMIT"
#define NVD3D_AAMETHOD_STRING                   "AAMETHOD"
#define NVD3D_VALIDATE_Z_METHOD_STRING          "VALIDATEZMETHOD"
#define NVD3D_AGPTEXTURE_CUTOFF                 "AGPTEXCUTOFF"

/*
 * Default values for registry configurable driver settings.
 */
#define DEFAULT_FOG_TABLE               REG_BIT1_FOG_TABLE_ENABLE       // Enable software implemented fog table support.
#define DEFAULT_ANTI_ALIAS_ENABLE       0//REG_BIT1_ANTI_ALIAS_ENABLE      // Enable software implemented Anti Aliasing.
#define DEFAULT_USER_MIPMAPS            REG_BIT1_USER_MIPMAPS_ENABLE    // Enable use of user supplied mip maps.
#define DEFAULT_VIDEO_TEXTURE           REG_BIT1_VIDEO_TEXTURE_ENABLE   // Enable texturing from video memory.
#define DEFAULT_NO_WAIT_4_VSYNC         0                               // Enable Proper VSync & Flip
#define DEFAULT_TEXEL_ALIGNMENT         (REG_TA_ZOH_CORNER | REG_TA_FOH_CORNER | REG_TA_TEXEL_CENTER)
#define DEFAULT_MIPMAP_DITHER_ENABLE    0                               //
#define DEFAULT_PRERENDER_LIMIT         5
#define DEFAULT_CKCOMPATABILITY_ENABLE  REG_BIT1_CKCOMPATABILITY_ENABLE // Perform application colorkey fixups.
#define DEFAULT_CONTROLTRAFFIC          0

/*
 * The definitions for ZOH and ZOH_MS are reversed.
 * The way they are implemented in hardware is actually:
 * ZOH_MS = 0
 * ZOH    = 1
 * The mode we really want to use by default is ZOH_MS.
 */
#define DEFAULT_MIPMAP_LEVELS           REG_MML_DISABLE                 // Set max number of mip map levels to auto-generate.
#define DEFAULT_AUTO_MIPMAP_METHOD      REG_AMMM_BILINEAR               // Bilinearly filter auto-generated mipmaps.
#define DEFAULT_TEX_HEAP                0x00500000                      // Set maximum size of PCI system memory texture heap.
#define DEFAULT_MIN_VIDEO_TEX_SIZE      1                               // Set minimum texture size to be placed in video memory.
#define DEFAULT_DMA_MIN_PUSH_COUNT_PCI  0x600                           // Set the minimum push count.
#define DEFAULT_DMA_MIN_PUSH_COUNT_AGP  0x900                           // Set the minimum push count.
#define DEFAULT_PUSH_BUFFER_SIZE_MAX_PCI 0x40000                        // Set the maximum push buffer size.
#define DEFAULT_PUSH_BUFFER_SIZE_MAX_AGP 0x200000                       // Set the maximum push buffer size.
#define DEFAULT_D3D_CONTEXT_MAX         64                              // D3D Context heap allocation max.
#define DEFAULT_D3D_TEXTURE_MAX         1024                            // D3D Texture heap allocation max.
#define DEFAULT_LOD_BIAS_ADJUST         0                               //
#define DEFAULT_PAL8_TEXTURE_CONVERT    REG_P8TC_NONE                   //
#define DEFAULT_AAMETHOD                REG_AAMETHOD_2x2                // 2x2 Supersampling.
#define DEFAULT_VALIDATE_Z_METHOD       REG_VZM_FLEXIBLE                // REG_VZM_MIXED
#define DEFAULT_CKREF                   REG_CKREF_MIN
#define DEFAULT_AGPTEX_CUTOFF           1024

/*
 * This will eventually go away.
 */
#define DEFAULT_DX6_ENABLE              REG_DX6E_OPTIMIZED
#endif  // NV4
#endif _NV4DREG_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\inc\nv4vxmac.h ===
/*
 * **** MACHINE GENERATED - DO NOT EDIT ****
 * **** MACHINE GENERATED - DO NOT EDIT ****
 * **** MACHINE GENERATED - DO NOT EDIT ****
 *
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 *
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */

/*
 * Inner Loop Prototypes and Vertex Macros
 */

/*
 * General Constants
 */
#define NV_FORCE_TRI_SETUP(_ctx) (_ctx)->dwFunctionLookup = NV_SETUP_FUNCTION_INDEX;

#ifdef NV_FASTLOOPS
#define NV_DX6_FUNCTION_ADJUST      2
#define NV_FIXED_FUNCTION_INDEX     1024
#define NV_AA_FUNCTION_INDEX        1024
#define NV_SETUP_FUNCTION_INDEX     1025
#else //!NV_FASTLOOPS
#define NV_AA_FUNCTION_INDEX        8
#define NV_SETUP_FUNCTION_INDEX     10
#endif //!NV_FASTLOOPS

#define sizeDX5TriangleVertex       9
#define sizeDx5TriangleTLVertex     sizeDX5TriangleVertex

#define sizeDX6TriangleVertex       11
#define sizeDx6TriangleTLVertex     sizeDX6TriangleVertex

#define LIST_STRIDES                0x00000303
#define STRIP_STRIDES               0x01010101
#define FAN_STRIDES                 0x02000001
#define LEGACY_STRIDES              0x03000404

#ifdef NV_FASTLOOPS

void __stdcall nvTriangleDispatch (DWORD, LPWORD, DWORD, LPBYTE);
void __stdcall nvDX5TriangleSetup (DWORD, LPWORD, DWORD, LPBYTE);
void __stdcall nvDX6TriangleSetup (DWORD, LPWORD, DWORD, LPBYTE);

extern DWORD dwDrawPrimitiveTable[];

#else //!NV_FASTLOOPS

/*
 * Inner Loop Prototypes
 */
void nvDX5Triangle                            ( WORD,         DWORD, LPD3DTLVERTEX);
void nvDX5TriangleExpFog                      ( WORD,         DWORD, LPD3DTLVERTEX);
void nvDX5TriangleExp2Fog                     ( WORD,         DWORD, LPD3DTLVERTEX);
void nvDX5TriangleLinearFog                   ( WORD,         DWORD, LPD3DTLVERTEX);
void nvDX5TriangleWBuf                        ( WORD,         DWORD, LPD3DTLVERTEX);
void nvDX5TriangleExpFogWBuf                  ( WORD,         DWORD, LPD3DTLVERTEX);
void nvDX5TriangleExp2FogWBuf                 ( WORD,         DWORD, LPD3DTLVERTEX);
void nvDX5TriangleLinearFogWBuf               ( WORD,         DWORD, LPD3DTLVERTEX);
void nvDX5TriangleIndexed                     (DWORD, LPWORD, DWORD, LPD3DTLVERTEX);
void nvDX5TriangleExpFogIndexed               (DWORD, LPWORD, DWORD, LPD3DTLVERTEX);
void nvDX5TriangleExp2FogIndexed              (DWORD, LPWORD, DWORD, LPD3DTLVERTEX);
void nvDX5TriangleLinearFogIndexed            (DWORD, LPWORD, DWORD, LPD3DTLVERTEX);
void nvDX5TriangleIndexedWBuf                 (DWORD, LPWORD, DWORD, LPD3DTLVERTEX);
void nvDX5TriangleExpFogIndexedWBuf           (DWORD, LPWORD, DWORD, LPD3DTLVERTEX);
void nvDX5TriangleExp2FogIndexedWBuf          (DWORD, LPWORD, DWORD, LPD3DTLVERTEX);
void nvDX5TriangleLinearFogIndexedWBuf        (DWORD, LPWORD, DWORD, LPD3DTLVERTEX);
void nvDX5TriangleAACapture                   ( WORD,         DWORD, LPD3DTLVERTEX);
void nvDX5TriangleAACaptureWBuf               ( WORD,         DWORD, LPD3DTLVERTEX);
void nvDX5TriangleIndexedAACapture            (DWORD, LPWORD, DWORD, LPD3DTLVERTEX);
void nvDX5TriangleIndexedAACaptureWBuf        (DWORD, LPWORD, DWORD, LPD3DTLVERTEX);
void nvDX5FlexTriangle                        ( WORD,         DWORD, LPBYTE);
void nvDX5FlexTriangleExpFog                  ( WORD,         DWORD, LPBYTE);
void nvDX5FlexTriangleExp2Fog                 ( WORD,         DWORD, LPBYTE);
void nvDX5FlexTriangleLinearFog               ( WORD,         DWORD, LPBYTE);
void nvDX5FlexTriangleWBuf                    ( WORD,         DWORD, LPBYTE);
void nvDX5FlexTriangleExpFogWBuf              ( WORD,         DWORD, LPBYTE);
void nvDX5FlexTriangleExp2FogWBuf             ( WORD,         DWORD, LPBYTE);
void nvDX5FlexTriangleLinearFogWBuf           ( WORD,         DWORD, LPBYTE);
void nvDX5FlexTriangleIndexed                 (DWORD, LPWORD, DWORD, LPBYTE);
void nvDX5FlexTriangleExpFogIndexed           (DWORD, LPWORD, DWORD, LPBYTE);
void nvDX5FlexTriangleExp2FogIndexed          (DWORD, LPWORD, DWORD, LPBYTE);
void nvDX5FlexTriangleLinearFogIndexed        (DWORD, LPWORD, DWORD, LPBYTE);
void nvDX5FlexTriangleIndexedWBuf             (DWORD, LPWORD, DWORD, LPBYTE);
void nvDX5FlexTriangleExpFogIndexedWBuf       (DWORD, LPWORD, DWORD, LPBYTE);
void nvDX5FlexTriangleExp2FogIndexedWBuf      (DWORD, LPWORD, DWORD, LPBYTE);
void nvDX5FlexTriangleLinearFogIndexedWBuf    (DWORD, LPWORD, DWORD, LPBYTE);
void nvDX5FlexTriangleAACapture               ( WORD,         DWORD, LPBYTE);
void nvDX5FlexTriangleAACaptureWBuf           ( WORD,         DWORD, LPBYTE);
void nvDX5FlexTriangleIndexedAACapture        (DWORD, LPWORD, DWORD, LPBYTE);
void nvDX5FlexTriangleIndexedAACaptureWBuf    (DWORD, LPWORD, DWORD, LPBYTE);
void nvDX6FlexTriangle                        ( WORD,         DWORD, LPBYTE);
void nvDX6FlexTriangleExpFog                  ( WORD,         DWORD, LPBYTE);
void nvDX6FlexTriangleExp2Fog                 ( WORD,         DWORD, LPBYTE);
void nvDX6FlexTriangleLinearFog               ( WORD,         DWORD, LPBYTE);
void nvDX6FlexTriangleWBuf                    ( WORD,         DWORD, LPBYTE);
void nvDX6FlexTriangleExpFogWBuf              ( WORD,         DWORD, LPBYTE);
void nvDX6FlexTriangleExp2FogWBuf             ( WORD,         DWORD, LPBYTE);
void nvDX6FlexTriangleLinearFogWBuf           ( WORD,         DWORD, LPBYTE);
void nvDX6FlexTriangleIndexed                 (DWORD, LPWORD, DWORD, LPBYTE);
void nvDX6FlexTriangleExpFogIndexed           (DWORD, LPWORD, DWORD, LPBYTE);
void nvDX6FlexTriangleExp2FogIndexed          (DWORD, LPWORD, DWORD, LPBYTE);
void nvDX6FlexTriangleLinearFogIndexed        (DWORD, LPWORD, DWORD, LPBYTE);
void nvDX6FlexTriangleIndexedWBuf             (DWORD, LPWORD, DWORD, LPBYTE);
void nvDX6FlexTriangleExpFogIndexedWBuf       (DWORD, LPWORD, DWORD, LPBYTE);
void nvDX6FlexTriangleExp2FogIndexedWBuf      (DWORD, LPWORD, DWORD, LPBYTE);
void nvDX6FlexTriangleLinearFogIndexedWBuf    (DWORD, LPWORD, DWORD, LPBYTE);
void nvDX6FlexTriangleAACapture               ( WORD,         DWORD, LPBYTE);
void nvDX6FlexTriangleAACaptureWBuf           ( WORD,         DWORD, LPBYTE);
void nvDX6FlexTriangleIndexedAACapture        (DWORD, LPWORD, DWORD, LPBYTE);
void nvDX6FlexTriangleIndexedAACaptureWBuf    (DWORD, LPWORD, DWORD, LPBYTE);

extern LPNVDRAWPRIM fnDX5Table[];
void nvDX5TriangleSetup  ( WORD,         DWORD, LPD3DTLVERTEX);
extern LPNVINDEXEDPRIM fnDX5IndexedTable[];
void nvDX5IndexedTriangleSetup  (DWORD, LPWORD, DWORD, LPD3DTLVERTEX);
extern LPNVFVFDRAWPRIM fnDX5FlexTable[];
void nvDX5FlexTriangleSetup  ( WORD,         DWORD, LPBYTE);
extern LPNVFVFINDEXEDPRIM fnDX5FlexIndexedTable[];
void nvDX5FlexIndexedTriangleSetup  (DWORD, LPWORD, DWORD, LPBYTE);
extern LPNVFVFDRAWPRIM fnDX6FlexTable[];
void nvDX6FlexTriangleSetup  ( WORD,         DWORD, LPBYTE);
extern LPNVFVFINDEXEDPRIM fnDX6FlexIndexedTable[];
void nvDX6FlexIndexedTriangleSetup  (DWORD, LPWORD, DWORD, LPBYTE);

#endif //!NV_FASTLOOPS
/*
 * Vertex Macros
 */

#define nvglDX5TriangleVertex(fifo,freecount,ch,alias,vertex)\
{\
    *(DWORD*)(fifo +  0) = ((sizeDX5TriangleVertex-1)<<18) | ((ch)<<13) | NV054_TLVERTEX((alias));\
    memcpy ((void*)(fifo + 4),(void*)(vertex),32);\
    dbgDisplayVertexData(((DWORD*)nvFifo)[1],((DWORD*)nvFifo)[2],((DWORD*)nvFifo)[3],\
                         ((DWORD*)nvFifo)[4],((DWORD*)nvFifo)[5],((DWORD*)nvFifo)[6],\
                         ((DWORD*)nvFifo)[7],((DWORD*)nvFifo)[8]);\
    fifo      += sizeDX5TriangleVertex * 4;\
    freecount -= sizeDX5TriangleVertex;\
}

#define nvglDX5TriangleVertexExpFog(fifo,freecount,ch,alias,vertex)\
{\
    DWORD dwTemp;\
    DWORD zmask,dwrhw,dwz;\
    int   ifog;\
    float ffog,fz,fw;\
    float frhw;\
    *(DWORD*)(fifo +  0) = ((sizeDX5TriangleVertex-1)<<18) | ((ch)<<13) | NV054_TLVERTEX((alias));\
    *(DWORD*)(fifo +  4) = (*(DWORD*)(vertex +  0));\
    *(DWORD*)(fifo +  8) = (*(DWORD*)(vertex +  4));\
    *(DWORD*)(fifo + 12) = dwz = (*(DWORD*)(vertex +  8));\
    dwTemp = (*(DWORD*)(vertex + 12));\
    *(DWORD*)(fifo + 16) = dwrhw = dwTemp;\
    *(DWORD*)(fifo + 20) = (*(DWORD*)(vertex + 16));\
    dwTemp = (*(DWORD*)(vertex + 20));\
    zmask = ((*(DWORD *)&(pCurrentContext->dvWNear) == 0x3f800000) && (*(DWORD *)&(pCurrentContext->dvWFar) == 0x3f800000)) ? 0xffffffff : 0;\
    frhw = *(float*)&dwrhw;\
    FP_INV (fw, frhw);\
    dwz = (dwz & zmask) | (*(DWORD *)&fw & ~zmask);\
    fz = *(float *)&dwz;\
    ffog  = fz * pCurrentContext->fFogTableDensity;\
    FP_EXP (ffog,ffog);\
    FP_NORM_TO_BIT24 (ifog,ffog);\
    dwTemp = (dwTemp & 0x00ffffff) | ifog;\
    *(DWORD*)(fifo + 24) = dwTemp;\
    *(DWORD*)(fifo + 28) = (*(DWORD*)(vertex + 24));\
    *(DWORD*)(fifo + 32) = (*(DWORD*)(vertex + 28));\
    dbgDisplayVertexData(((DWORD*)nvFifo)[1],((DWORD*)nvFifo)[2],((DWORD*)nvFifo)[3],\
                         ((DWORD*)nvFifo)[4],((DWORD*)nvFifo)[5],((DWORD*)nvFifo)[6],\
                         ((DWORD*)nvFifo)[7],((DWORD*)nvFifo)[8]);\
    fifo      += sizeDX5TriangleVertex * 4;\
    freecount -= sizeDX5TriangleVertex;\
}

#define nvglDX5TriangleVertexExp2Fog(fifo,freecount,ch,alias,vertex)\
{\
    DWORD dwTemp;\
    DWORD zmask,dwrhw,dwz;\
    int   ifog;\
    float ffog,fz,fw;\
    float frhw;\
    *(DWORD*)(fifo +  0) = ((sizeDX5TriangleVertex-1)<<18) | ((ch)<<13) | NV054_TLVERTEX((alias));\
    *(DWORD*)(fifo +  4) = (*(DWORD*)(vertex +  0));\
    *(DWORD*)(fifo +  8) = (*(DWORD*)(vertex +  4));\
    *(DWORD*)(fifo + 12) = dwz = (*(DWORD*)(vertex +  8));\
    dwTemp = (*(DWORD*)(vertex + 12));\
    *(DWORD*)(fifo + 16) = dwrhw = dwTemp;\
    *(DWORD*)(fifo + 20) = (*(DWORD*)(vertex + 16));\
    dwTemp = (*(DWORD*)(vertex + 20));\
    zmask = ((*(DWORD *)&(pCurrentContext->dvWNear) == 0x3f800000) && (*(DWORD *)&(pCurrentContext->dvWFar) == 0x3f800000)) ? 0xffffffff : 0;\
    frhw = *(float*)&dwrhw;\
    FP_INV (fw, frhw);\
    dwz = (dwz & zmask) | (*(DWORD *)&fw & ~zmask);\
    fz = *(float *)&dwz;\
    ffog  = fz * pCurrentContext->fFogTableDensity;\
    ffog *= ffog;\
    FP_EXP (ffog,ffog);\
    FP_NORM_TO_BIT24 (ifog,ffog);\
    dwTemp = (dwTemp & 0x00ffffff) | ifog;\
    *(DWORD*)(fifo + 24) = dwTemp;\
    *(DWORD*)(fifo + 28) = (*(DWORD*)(vertex + 24));\
    *(DWORD*)(fifo + 32) = (*(DWORD*)(vertex + 28));\
    dbgDisplayVertexData(((DWORD*)nvFifo)[1],((DWORD*)nvFifo)[2],((DWORD*)nvFifo)[3],\
                         ((DWORD*)nvFifo)[4],((DWORD*)nvFifo)[5],((DWORD*)nvFifo)[6],\
                         ((DWORD*)nvFifo)[7],((DWORD*)nvFifo)[8]);\
    fifo      += sizeDX5TriangleVertex * 4;\
    freecount -= sizeDX5TriangleVertex;\
}

#define nvglDX5TriangleVertexLinearFog(fifo,freecount,ch,alias,vertex)\
{\
    DWORD dwTemp;\
    DWORD zmask,dwrhw,dwz;\
    int   ifog;\
    float ffog,fz,fw;\
    float frhw;\
    *(DWORD*)(fifo +  0) = ((sizeDX5TriangleVertex-1)<<18) | ((ch)<<13) | NV054_TLVERTEX((alias));\
    *(DWORD*)(fifo +  4) = (*(DWORD*)(vertex +  0));\
    *(DWORD*)(fifo +  8) = (*(DWORD*)(vertex +  4));\
    *(DWORD*)(fifo + 12) = dwz = (*(DWORD*)(vertex +  8));\
    dwTemp = (*(DWORD*)(vertex + 12));\
    *(DWORD*)(fifo + 16) = dwrhw = dwTemp;\
    *(DWORD*)(fifo + 20) = (*(DWORD*)(vertex + 16));\
    dwTemp = (*(DWORD*)(vertex + 20));\
    zmask = ((*(DWORD *)&(pCurrentContext->dvWNear) == 0x3f800000) && (*(DWORD *)&(pCurrentContext->dvWFar) == 0x3f800000)) ? 0xffffffff : 0;\
    frhw = *(float*)&dwrhw;\
    FP_INV (fw, frhw);\
    dwz = (dwz & zmask) | (*(DWORD *)&fw & ~zmask);\
    fz = *(float *)&dwz;\
    ffog = (fz >= pCurrentContext->fFogTableEnd) ? 0.0f :\
           (fz <= pCurrentContext->fFogTableStart) ? 1.0f :\
           (pCurrentContext->fFogTableEnd - fz) * pCurrentContext->fFogTableLinearScale;\
    FP_NORM_TO_BIT24 (ifog,ffog);\
    dwTemp = (dwTemp & 0x00ffffff) | ifog;\
    *(DWORD*)(fifo + 24) = dwTemp;\
    *(DWORD*)(fifo + 28) = (*(DWORD*)(vertex + 24));\
    *(DWORD*)(fifo + 32) = (*(DWORD*)(vertex + 28));\
    dbgDisplayVertexData(((DWORD*)nvFifo)[1],((DWORD*)nvFifo)[2],((DWORD*)nvFifo)[3],\
                         ((DWORD*)nvFifo)[4],((DWORD*)nvFifo)[5],((DWORD*)nvFifo)[6],\
                         ((DWORD*)nvFifo)[7],((DWORD*)nvFifo)[8]);\
    fifo      += sizeDX5TriangleVertex * 4;\
    freecount -= sizeDX5TriangleVertex;\
}

#define nvglDX5TriangleVertexWBuf(fifo,freecount,ch,alias,vertex)\
{\
    DWORD dwTemp;\
    float frhw;\
    *(DWORD*)(fifo +  0) = ((sizeDX5TriangleVertex-1)<<18) | ((ch)<<13) | NV054_TLVERTEX((alias));\
    *(DWORD*)(fifo +  4) = (*(DWORD*)(vertex +  0));\
    *(DWORD*)(fifo +  8) = (*(DWORD*)(vertex +  4));\
    *(DWORD*)(fifo + 12) = (*(DWORD*)(vertex +  8));\
    dwTemp = (*(DWORD*)(vertex + 12));\
    frhw = (*(float*)&dwTemp) * pCurrentContext->dvRWFar;\
    *(DWORD*)(fifo + 16) = *(DWORD*)&frhw;\
    *(DWORD*)(fifo + 20) = (*(DWORD*)(vertex + 16));\
    dwTemp = (*(DWORD*)(vertex + 20));\
    *(DWORD*)(fifo + 24) = dwTemp;\
    *(DWORD*)(fifo + 28) = (*(DWORD*)(vertex + 24));\
    *(DWORD*)(fifo + 32) = (*(DWORD*)(vertex + 28));\
    dbgDisplayVertexData(((DWORD*)nvFifo)[1],((DWORD*)nvFifo)[2],((DWORD*)nvFifo)[3],\
                         ((DWORD*)nvFifo)[4],((DWORD*)nvFifo)[5],((DWORD*)nvFifo)[6],\
                         ((DWORD*)nvFifo)[7],((DWORD*)nvFifo)[8]);\
    fifo      += sizeDX5TriangleVertex * 4;\
    freecount -= sizeDX5TriangleVertex;\
}

#define nvglDX5TriangleVertexExpFogWBuf(fifo,freecount,ch,alias,vertex)\
{\
    DWORD dwTemp;\
    DWORD zmask,dwrhw,dwz;\
    int   ifog;\
    float ffog,fz,fw;\
    float frhw;\
    *(DWORD*)(fifo +  0) = ((sizeDX5TriangleVertex-1)<<18) | ((ch)<<13) | NV054_TLVERTEX((alias));\
    *(DWORD*)(fifo +  4) = (*(DWORD*)(vertex +  0));\
    *(DWORD*)(fifo +  8) = (*(DWORD*)(vertex +  4));\
    *(DWORD*)(fifo + 12) = dwz = (*(DWORD*)(vertex +  8));\
    dwTemp = (*(DWORD*)(vertex + 12));\
    frhw = (*(float*)&dwTemp) * pCurrentContext->dvRWFar;\
    *(DWORD*)(fifo + 16) = dwrhw = *(DWORD*)&frhw;\
    *(DWORD*)(fifo + 20) = (*(DWORD*)(vertex + 16));\
    dwTemp = (*(DWORD*)(vertex + 20));\
    zmask = ((*(DWORD *)&(pCurrentContext->dvWNear) == 0x3f800000) && (*(DWORD *)&(pCurrentContext->dvWFar) == 0x3f800000)) ? 0xffffffff : 0;\
    frhw = *(float*)&dwrhw;\
    FP_INV (fw, frhw);\
    dwz = (dwz & zmask) | (*(DWORD *)&fw & ~zmask);\
    fz = *(float *)&dwz;\
    ffog  = fz * pCurrentContext->fFogTableDensity;\
    FP_EXP (ffog,ffog);\
    FP_NORM_TO_BIT24 (ifog,ffog);\
    dwTemp = (dwTemp & 0x00ffffff) | ifog;\
    *(DWORD*)(fifo + 24) = dwTemp;\
    *(DWORD*)(fifo + 28) = (*(DWORD*)(vertex + 24));\
    *(DWORD*)(fifo + 32) = (*(DWORD*)(vertex + 28));\
    dbgDisplayVertexData(((DWORD*)nvFifo)[1],((DWORD*)nvFifo)[2],((DWORD*)nvFifo)[3],\
                         ((DWORD*)nvFifo)[4],((DWORD*)nvFifo)[5],((DWORD*)nvFifo)[6],\
                         ((DWORD*)nvFifo)[7],((DWORD*)nvFifo)[8]);\
    fifo      += sizeDX5TriangleVertex * 4;\
    freecount -= sizeDX5TriangleVertex;\
}

#define nvglDX5TriangleVertexExp2FogWBuf(fifo,freecount,ch,alias,vertex)\
{\
    DWORD dwTemp;\
    DWORD zmask,dwrhw,dwz;\
    int   ifog;\
    float ffog,fz,fw;\
    float frhw;\
    *(DWORD*)(fifo +  0) = ((sizeDX5TriangleVertex-1)<<18) | ((ch)<<13) | NV054_TLVERTEX((alias));\
    *(DWORD*)(fifo +  4) = (*(DWORD*)(vertex +  0));\
    *(DWORD*)(fifo +  8) = (*(DWORD*)(vertex +  4));\
    *(DWORD*)(fifo + 12) = dwz = (*(DWORD*)(vertex +  8));\
    dwTemp = (*(DWORD*)(vertex + 12));\
    frhw = (*(float*)&dwTemp) * pCurrentContext->dvRWFar;\
    *(DWORD*)(fifo + 16) = dwrhw = *(DWORD*)&frhw;\
    *(DWORD*)(fifo + 20) = (*(DWORD*)(vertex + 16));\
    dwTemp = (*(DWORD*)(vertex + 20));\
    zmask = ((*(DWORD *)&(pCurrentContext->dvWNear) == 0x3f800000) && (*(DWORD *)&(pCurrentContext->dvWFar) == 0x3f800000)) ? 0xffffffff : 0;\
    frhw = *(float*)&dwrhw;\
    FP_INV (fw, frhw);\
    dwz = (dwz & zmask) | (*(DWORD *)&fw & ~zmask);\
    fz = *(float *)&dwz;\
    ffog  = fz * pCurrentContext->fFogTableDensity;\
    ffog *= ffog;\
    FP_EXP (ffog,ffog);\
    FP_NORM_TO_BIT24 (ifog,ffog);\
    dwTemp = (dwTemp & 0x00ffffff) | ifog;\
    *(DWORD*)(fifo + 24) = dwTemp;\
    *(DWORD*)(fifo + 28) = (*(DWORD*)(vertex + 24));\
    *(DWORD*)(fifo + 32) = (*(DWORD*)(vertex + 28));\
    dbgDisplayVertexData(((DWORD*)nvFifo)[1],((DWORD*)nvFifo)[2],((DWORD*)nvFifo)[3],\
                         ((DWORD*)nvFifo)[4],((DWORD*)nvFifo)[5],((DWORD*)nvFifo)[6],\
                         ((DWORD*)nvFifo)[7],((DWORD*)nvFifo)[8]);\
    fifo      += sizeDX5TriangleVertex * 4;\
    freecount -= sizeDX5TriangleVertex;\
}

#define nvglDX5TriangleVertexLinearFogWBuf(fifo,freecount,ch,alias,vertex)\
{\
    DWORD dwTemp;\
    DWORD zmask,dwrhw,dwz;\
    int   ifog;\
    float ffog,fz,fw;\
    float frhw;\
    *(DWORD*)(fifo +  0) = ((sizeDX5TriangleVertex-1)<<18) | ((ch)<<13) | NV054_TLVERTEX((alias));\
    *(DWORD*)(fifo +  4) = (*(DWORD*)(vertex +  0));\
    *(DWORD*)(fifo +  8) = (*(DWORD*)(vertex +  4));\
    *(DWORD*)(fifo + 12) = dwz = (*(DWORD*)(vertex +  8));\
    dwTemp = (*(DWORD*)(vertex + 12));\
    frhw = (*(float*)&dwTemp) * pCurrentContext->dvRWFar;\
    *(DWORD*)(fifo + 16) = dwrhw = *(DWORD*)&frhw;\
    *(DWORD*)(fifo + 20) = (*(DWORD*)(vertex + 16));\
    dwTemp = (*(DWORD*)(vertex + 20));\
    zmask = ((*(DWORD *)&(pCurrentContext->dvWNear) == 0x3f800000) && (*(DWORD *)&(pCurrentContext->dvWFar) == 0x3f800000)) ? 0xffffffff : 0;\
    frhw = *(float*)&dwrhw;\
    FP_INV (fw, frhw);\
    dwz = (dwz & zmask) | (*(DWORD *)&fw & ~zmask);\
    fz = *(float *)&dwz;\
    ffog = (fz >= pCurrentContext->fFogTableEnd) ? 0.0f :\
           (fz <= pCurrentContext->fFogTableStart) ? 1.0f :\
           (pCurrentContext->fFogTableEnd - fz) * pCurrentContext->fFogTableLinearScale;\
    FP_NORM_TO_BIT24 (ifog,ffog);\
    dwTemp = (dwTemp & 0x00ffffff) | ifog;\
    *(DWORD*)(fifo + 24) = dwTemp;\
    *(DWORD*)(fifo + 28) = (*(DWORD*)(vertex + 24));\
    *(DWORD*)(fifo + 32) = (*(DWORD*)(vertex + 28));\
    dbgDisplayVertexData(((DWORD*)nvFifo)[1],((DWORD*)nvFifo)[2],((DWORD*)nvFifo)[3],\
                         ((DWORD*)nvFifo)[4],((DWORD*)nvFifo)[5],((DWORD*)nvFifo)[6],\
                         ((DWORD*)nvFifo)[7],((DWORD*)nvFifo)[8]);\
    fifo      += sizeDX5TriangleVertex * 4;\
    freecount -= sizeDX5TriangleVertex;\
}

#define nvglDX5FlexTriangleVertex(fifo,freecount,ch,alias,vertex,fvf,uvoff)\
{\
    DWORD dwTemp;\
    *(DWORD*)(fifo +  0) = ((sizeDX5TriangleVertex-1)<<18) | ((ch)<<13) | NV054_TLVERTEX((alias));\
    *(DWORD*)(fifo +  4) = (*(DWORD*)(vertex +  0));\
    *(DWORD*)(fifo +  8) = (*(DWORD*)(vertex +  4));\
    *(DWORD*)(fifo + 12) = (*(DWORD*)(vertex +  8));\
    dwTemp = *(DWORD*)((vertex & fvf.dwRHWMask) + fvf.dwRHWOffset);\
    *(DWORD*)(fifo + 16) = dwTemp;\
    *(DWORD*)(fifo + 20) = *(DWORD*)((vertex & fvf.dwARGBMask) + fvf.dwARGBOffset);\
    dwTemp = *(DWORD*)((vertex & fvf.dwSpecularMask) + fvf.dwSpecularOffset);\
    *(DWORD*)(fifo + 24) = dwTemp;\
    dwTemp = (vertex & fvf.dwUVMask) + fvf.dwUVOffset;\
    *(DWORD*)(fifo + 28) = *(DWORD*)(dwTemp + (uvoff)[0] + 0);\
    *(DWORD*)(fifo + 32) = *(DWORD*)(dwTemp + (uvoff)[0] + 4);\
    dbgDisplayVertexData(((DWORD*)nvFifo)[1],((DWORD*)nvFifo)[2],((DWORD*)nvFifo)[3],\
                         ((DWORD*)nvFifo)[4],((DWORD*)nvFifo)[5],((DWORD*)nvFifo)[6],\
                         ((DWORD*)nvFifo)[7],((DWORD*)nvFifo)[8]);\
    fifo      += sizeDX5TriangleVertex * 4;\
    freecount -= sizeDX5TriangleVertex;\
}

#define nvglDX5FlexTriangleVertexExpFog(fifo,freecount,ch,alias,vertex,fvf,uvoff)\
{\
    DWORD dwTemp;\
    DWORD zmask,dwrhw,dwz;\
    int   ifog;\
    float ffog,fz,fw;\
    float frhw;\
    *(DWORD*)(fifo +  0) = ((sizeDX5TriangleVertex-1)<<18) | ((ch)<<13) | NV054_TLVERTEX((alias));\
    *(DWORD*)(fifo +  4) = (*(DWORD*)(vertex +  0));\
    *(DWORD*)(fifo +  8) = (*(DWORD*)(vertex +  4));\
    *(DWORD*)(fifo + 12) = dwz = (*(DWORD*)(vertex +  8));\
    dwTemp = *(DWORD*)((vertex & fvf.dwRHWMask) + fvf.dwRHWOffset);\
    *(DWORD*)(fifo + 16) = dwrhw = dwTemp;\
    *(DWORD*)(fifo + 20) = *(DWORD*)((vertex & fvf.dwARGBMask) + fvf.dwARGBOffset);\
    dwTemp = *(DWORD*)((vertex & fvf.dwSpecularMask) + fvf.dwSpecularOffset);\
    zmask = ((*(DWORD *)&(pCurrentContext->dvWNear) == 0x3f800000) && (*(DWORD *)&(pCurrentContext->dvWFar) == 0x3f800000)) ? 0xffffffff : 0;\
    frhw = *(float*)&dwrhw;\
    FP_INV (fw, frhw);\
    dwz = (dwz & zmask) | (*(DWORD *)&fw & ~zmask);\
    fz = *(float *)&dwz;\
    ffog  = fz * pCurrentContext->fFogTableDensity;\
    FP_EXP (ffog,ffog);\
    FP_NORM_TO_BIT24 (ifog,ffog);\
    dwTemp = (dwTemp & 0x00ffffff) | ifog;\
    *(DWORD*)(fifo + 24) = dwTemp;\
    dwTemp = (vertex & fvf.dwUVMask) + fvf.dwUVOffset;\
    *(DWORD*)(fifo + 28) = *(DWORD*)(dwTemp + (uvoff)[0] + 0);\
    *(DWORD*)(fifo + 32) = *(DWORD*)(dwTemp + (uvoff)[0] + 4);\
    dbgDisplayVertexData(((DWORD*)nvFifo)[1],((DWORD*)nvFifo)[2],((DWORD*)nvFifo)[3],\
                         ((DWORD*)nvFifo)[4],((DWORD*)nvFifo)[5],((DWORD*)nvFifo)[6],\
                         ((DWORD*)nvFifo)[7],((DWORD*)nvFifo)[8]);\
    fifo      += sizeDX5TriangleVertex * 4;\
    freecount -= sizeDX5TriangleVertex;\
}

#define nvglDX5FlexTriangleVertexExp2Fog(fifo,freecount,ch,alias,vertex,fvf,uvoff)\
{\
    DWORD dwTemp;\
    DWORD zmask,dwrhw,dwz;\
    int   ifog;\
    float ffog,fz,fw;\
    float frhw;\
    *(DWORD*)(fifo +  0) = ((sizeDX5TriangleVertex-1)<<18) | ((ch)<<13) | NV054_TLVERTEX((alias));\
    *(DWORD*)(fifo +  4) = (*(DWORD*)(vertex +  0));\
    *(DWORD*)(fifo +  8) = (*(DWORD*)(vertex +  4));\
    *(DWORD*)(fifo + 12) = dwz = (*(DWORD*)(vertex +  8));\
    dwTemp = *(DWORD*)((vertex & fvf.dwRHWMask) + fvf.dwRHWOffset);\
    *(DWORD*)(fifo + 16) = dwrhw = dwTemp;\
    *(DWORD*)(fifo + 20) = *(DWORD*)((vertex & fvf.dwARGBMask) + fvf.dwARGBOffset);\
    dwTemp = *(DWORD*)((vertex & fvf.dwSpecularMask) + fvf.dwSpecularOffset);\
    zmask = ((*(DWORD *)&(pCurrentContext->dvWNear) == 0x3f800000) && (*(DWORD *)&(pCurrentContext->dvWFar) == 0x3f800000)) ? 0xffffffff : 0;\
    frhw = *(float*)&dwrhw;\
    FP_INV (fw, frhw);\
    dwz = (dwz & zmask) | (*(DWORD *)&fw & ~zmask);\
    fz = *(float *)&dwz;\
    ffog  = fz * pCurrentContext->fFogTableDensity;\
    ffog *= ffog;\
    FP_EXP (ffog,ffog);\
    FP_NORM_TO_BIT24 (ifog,ffog);\
    dwTemp = (dwTemp & 0x00ffffff) | ifog;\
    *(DWORD*)(fifo + 24) = dwTemp;\
    dwTemp = (vertex & fvf.dwUVMask) + fvf.dwUVOffset;\
    *(DWORD*)(fifo + 28) = *(DWORD*)(dwTemp + (uvoff)[0] + 0);\
    *(DWORD*)(fifo + 32) = *(DWORD*)(dwTemp + (uvoff)[0] + 4);\
    dbgDisplayVertexData(((DWORD*)nvFifo)[1],((DWORD*)nvFifo)[2],((DWORD*)nvFifo)[3],\
                         ((DWORD*)nvFifo)[4],((DWORD*)nvFifo)[5],((DWORD*)nvFifo)[6],\
                         ((DWORD*)nvFifo)[7],((DWORD*)nvFifo)[8]);\
    fifo      += sizeDX5TriangleVertex * 4;\
    freecount -= sizeDX5TriangleVertex;\
}

#define nvglDX5FlexTriangleVertexLinearFog(fifo,freecount,ch,alias,vertex,fvf,uvoff)\
{\
    DWORD dwTemp;\
    DWORD zmask,dwrhw,dwz;\
    int   ifog;\
    float ffog,fz,fw;\
    float frhw;\
    *(DWORD*)(fifo +  0) = ((sizeDX5TriangleVertex-1)<<18) | ((ch)<<13) | NV054_TLVERTEX((alias));\
    *(DWORD*)(fifo +  4) = (*(DWORD*)(vertex +  0));\
    *(DWORD*)(fifo +  8) = (*(DWORD*)(vertex +  4));\
    *(DWORD*)(fifo + 12) = dwz = (*(DWORD*)(vertex +  8));\
    dwTemp = *(DWORD*)((vertex & fvf.dwRHWMask) + fvf.dwRHWOffset);\
    *(DWORD*)(fifo + 16) = dwrhw = dwTemp;\
    *(DWORD*)(fifo + 20) = *(DWORD*)((vertex & fvf.dwARGBMask) + fvf.dwARGBOffset);\
    dwTemp = *(DWORD*)((vertex & fvf.dwSpecularMask) + fvf.dwSpecularOffset);\
    zmask = ((*(DWORD *)&(pCurrentContext->dvWNear) == 0x3f800000) && (*(DWORD *)&(pCurrentContext->dvWFar) == 0x3f800000)) ? 0xffffffff : 0;\
    frhw = *(float*)&dwrhw;\
    FP_INV (fw, frhw);\
    dwz = (dwz & zmask) | (*(DWORD *)&fw & ~zmask);\
    fz = *(float *)&dwz;\
    ffog = (fz >= pCurrentContext->fFogTableEnd) ? 0.0f :\
           (fz <= pCurrentContext->fFogTableStart) ? 1.0f :\
           (pCurrentContext->fFogTableEnd - fz) * pCurrentContext->fFogTableLinearScale;\
    FP_NORM_TO_BIT24 (ifog,ffog);\
    dwTemp = (dwTemp & 0x00ffffff) | ifog;\
    *(DWORD*)(fifo + 24) = dwTemp;\
    dwTemp = (vertex & fvf.dwUVMask) + fvf.dwUVOffset;\
    *(DWORD*)(fifo + 28) = *(DWORD*)(dwTemp + (uvoff)[0] + 0);\
    *(DWORD*)(fifo + 32) = *(DWORD*)(dwTemp + (uvoff)[0] + 4);\
    dbgDisplayVertexData(((DWORD*)nvFifo)[1],((DWORD*)nvFifo)[2],((DWORD*)nvFifo)[3],\
                         ((DWORD*)nvFifo)[4],((DWORD*)nvFifo)[5],((DWORD*)nvFifo)[6],\
                         ((DWORD*)nvFifo)[7],((DWORD*)nvFifo)[8]);\
    fifo      += sizeDX5TriangleVertex * 4;\
    freecount -= sizeDX5TriangleVertex;\
}

#define nvglDX5FlexTriangleVertexWBuf(fifo,freecount,ch,alias,vertex,fvf,uvoff)\
{\
    DWORD dwTemp;\
    float frhw;\
    *(DWORD*)(fifo +  0) = ((sizeDX5TriangleVertex-1)<<18) | ((ch)<<13) | NV054_TLVERTEX((alias));\
    *(DWORD*)(fifo +  4) = (*(DWORD*)(vertex +  0));\
    *(DWORD*)(fifo +  8) = (*(DWORD*)(vertex +  4));\
    *(DWORD*)(fifo + 12) = (*(DWORD*)(vertex +  8));\
    dwTemp = *(DWORD*)((vertex & fvf.dwRHWMask) + fvf.dwRHWOffset);\
    frhw = (*(float*)&dwTemp) * pCurrentContext->dvRWFar;\
    *(DWORD*)(fifo + 16) = *(DWORD*)&frhw;\
    *(DWORD*)(fifo + 20) = *(DWORD*)((vertex & fvf.dwARGBMask) + fvf.dwARGBOffset);\
    dwTemp = *(DWORD*)((vertex & fvf.dwSpecularMask) + fvf.dwSpecularOffset);\
    *(DWORD*)(fifo + 24) = dwTemp;\
    dwTemp = (vertex & fvf.dwUVMask) + fvf.dwUVOffset;\
    *(DWORD*)(fifo + 28) = *(DWORD*)(dwTemp + (uvoff)[0] + 0);\
    *(DWORD*)(fifo + 32) = *(DWORD*)(dwTemp + (uvoff)[0] + 4);\
    dbgDisplayVertexData(((DWORD*)nvFifo)[1],((DWORD*)nvFifo)[2],((DWORD*)nvFifo)[3],\
                         ((DWORD*)nvFifo)[4],((DWORD*)nvFifo)[5],((DWORD*)nvFifo)[6],\
                         ((DWORD*)nvFifo)[7],((DWORD*)nvFifo)[8]);\
    fifo      += sizeDX5TriangleVertex * 4;\
    freecount -= sizeDX5TriangleVertex;\
}

#define nvglDX5FlexTriangleVertexExpFogWBuf(fifo,freecount,ch,alias,vertex,fvf,uvoff)\
{\
    DWORD dwTemp;\
    DWORD zmask,dwrhw,dwz;\
    int   ifog;\
    float ffog,fz,fw;\
    float frhw;\
    *(DWORD*)(fifo +  0) = ((sizeDX5TriangleVertex-1)<<18) | ((ch)<<13) | NV054_TLVERTEX((alias));\
    *(DWORD*)(fifo +  4) = (*(DWORD*)(vertex +  0));\
    *(DWORD*)(fifo +  8) = (*(DWORD*)(vertex +  4));\
    *(DWORD*)(fifo + 12) = dwz = (*(DWORD*)(vertex +  8));\
    dwTemp = *(DWORD*)((vertex & fvf.dwRHWMask) + fvf.dwRHWOffset);\
    frhw = (*(float*)&dwTemp) * pCurrentContext->dvRWFar;\
    *(DWORD*)(fifo + 16) = dwrhw = *(DWORD*)&frhw;\
    *(DWORD*)(fifo + 20) = *(DWORD*)((vertex & fvf.dwARGBMask) + fvf.dwARGBOffset);\
    dwTemp = *(DWORD*)((vertex & fvf.dwSpecularMask) + fvf.dwSpecularOffset);\
    zmask = ((*(DWORD *)&(pCurrentContext->dvWNear) == 0x3f800000) && (*(DWORD *)&(pCurrentContext->dvWFar) == 0x3f800000)) ? 0xffffffff : 0;\
    frhw = *(float*)&dwrhw;\
    FP_INV (fw, frhw);\
    dwz = (dwz & zmask) | (*(DWORD *)&fw & ~zmask);\
    fz = *(float *)&dwz;\
    ffog  = fz * pCurrentContext->fFogTableDensity;\
    FP_EXP (ffog,ffog);\
    FP_NORM_TO_BIT24 (ifog,ffog);\
    dwTemp = (dwTemp & 0x00ffffff) | ifog;\
    *(DWORD*)(fifo + 24) = dwTemp;\
    dwTemp = (vertex & fvf.dwUVMask) + fvf.dwUVOffset;\
    *(DWORD*)(fifo + 28) = *(DWORD*)(dwTemp + (uvoff)[0] + 0);\
    *(DWORD*)(fifo + 32) = *(DWORD*)(dwTemp + (uvoff)[0] + 4);\
    dbgDisplayVertexData(((DWORD*)nvFifo)[1],((DWORD*)nvFifo)[2],((DWORD*)nvFifo)[3],\
                         ((DWORD*)nvFifo)[4],((DWORD*)nvFifo)[5],((DWORD*)nvFifo)[6],\
                         ((DWORD*)nvFifo)[7],((DWORD*)nvFifo)[8]);\
    fifo      += sizeDX5TriangleVertex * 4;\
    freecount -= sizeDX5TriangleVertex;\
}

#define nvglDX5FlexTriangleVertexExp2FogWBuf(fifo,freecount,ch,alias,vertex,fvf,uvoff)\
{\
    DWORD dwTemp;\
    DWORD zmask,dwrhw,dwz;\
    int   ifog;\
    float ffog,fz,fw;\
    float frhw;\
    *(DWORD*)(fifo +  0) = ((sizeDX5TriangleVertex-1)<<18) | ((ch)<<13) | NV054_TLVERTEX((alias));\
    *(DWORD*)(fifo +  4) = (*(DWORD*)(vertex +  0));\
    *(DWORD*)(fifo +  8) = (*(DWORD*)(vertex +  4));\
    *(DWORD*)(fifo + 12) = dwz = (*(DWORD*)(vertex +  8));\
    dwTemp = *(DWORD*)((vertex & fvf.dwRHWMask) + fvf.dwRHWOffset);\
    frhw = (*(float*)&dwTemp) * pCurrentContext->dvRWFar;\
    *(DWORD*)(fifo + 16) = dwrhw = *(DWORD*)&frhw;\
    *(DWORD*)(fifo + 20) = *(DWORD*)((vertex & fvf.dwARGBMask) + fvf.dwARGBOffset);\
    dwTemp = *(DWORD*)((vertex & fvf.dwSpecularMask) + fvf.dwSpecularOffset);\
    zmask = ((*(DWORD *)&(pCurrentContext->dvWNear) == 0x3f800000) && (*(DWORD *)&(pCurrentContext->dvWFar) == 0x3f800000)) ? 0xffffffff : 0;\
    frhw = *(float*)&dwrhw;\
    FP_INV (fw, frhw);\
    dwz = (dwz & zmask) | (*(DWORD *)&fw & ~zmask);\
    fz = *(float *)&dwz;\
    ffog  = fz * pCurrentContext->fFogTableDensity;\
    ffog *= ffog;\
    FP_EXP (ffog,ffog);\
    FP_NORM_TO_BIT24 (ifog,ffog);\
    dwTemp = (dwTemp & 0x00ffffff) | ifog;\
    *(DWORD*)(fifo + 24) = dwTemp;\
    dwTemp = (vertex & fvf.dwUVMask) + fvf.dwUVOffset;\
    *(DWORD*)(fifo + 28) = *(DWORD*)(dwTemp + (uvoff)[0] + 0);\
    *(DWORD*)(fifo + 32) = *(DWORD*)(dwTemp + (uvoff)[0] + 4);\
    dbgDisplayVertexData(((DWORD*)nvFifo)[1],((DWORD*)nvFifo)[2],((DWORD*)nvFifo)[3],\
                         ((DWORD*)nvFifo)[4],((DWORD*)nvFifo)[5],((DWORD*)nvFifo)[6],\
                         ((DWORD*)nvFifo)[7],((DWORD*)nvFifo)[8]);\
    fifo      += sizeDX5TriangleVertex * 4;\
    freecount -= sizeDX5TriangleVertex;\
}

#define nvglDX5FlexTriangleVertexLinearFogWBuf(fifo,freecount,ch,alias,vertex,fvf,uvoff)\
{\
    DWORD dwTemp;\
    DWORD zmask,dwrhw,dwz;\
    int   ifog;\
    float ffog,fz,fw;\
    float frhw;\
    *(DWORD*)(fifo +  0) = ((sizeDX5TriangleVertex-1)<<18) | ((ch)<<13) | NV054_TLVERTEX((alias));\
    *(DWORD*)(fifo +  4) = (*(DWORD*)(vertex +  0));\
    *(DWORD*)(fifo +  8) = (*(DWORD*)(vertex +  4));\
    *(DWORD*)(fifo + 12) = dwz = (*(DWORD*)(vertex +  8));\
    dwTemp = *(DWORD*)((vertex & fvf.dwRHWMask) + fvf.dwRHWOffset);\
    frhw = (*(float*)&dwTemp) * pCurrentContext->dvRWFar;\
    *(DWORD*)(fifo + 16) = dwrhw = *(DWORD*)&frhw;\
    *(DWORD*)(fifo + 20) = *(DWORD*)((vertex & fvf.dwARGBMask) + fvf.dwARGBOffset);\
    dwTemp = *(DWORD*)((vertex & fvf.dwSpecularMask) + fvf.dwSpecularOffset);\
    zmask = ((*(DWORD *)&(pCurrentContext->dvWNear) == 0x3f800000) && (*(DWORD *)&(pCurrentContext->dvWFar) == 0x3f800000)) ? 0xffffffff : 0;\
    frhw = *(float*)&dwrhw;\
    FP_INV (fw, frhw);\
    dwz = (dwz & zmask) | (*(DWORD *)&fw & ~zmask);\
    fz = *(float *)&dwz;\
    ffog = (fz >= pCurrentContext->fFogTableEnd) ? 0.0f :\
           (fz <= pCurrentContext->fFogTableStart) ? 1.0f :\
           (pCurrentContext->fFogTableEnd - fz) * pCurrentContext->fFogTableLinearScale;\
    FP_NORM_TO_BIT24 (ifog,ffog);\
    dwTemp = (dwTemp & 0x00ffffff) | ifog;\
    *(DWORD*)(fifo + 24) = dwTemp;\
    dwTemp = (vertex & fvf.dwUVMask) + fvf.dwUVOffset;\
    *(DWORD*)(fifo + 28) = *(DWORD*)(dwTemp + (uvoff)[0] + 0);\
    *(DWORD*)(fifo + 32) = *(DWORD*)(dwTemp + (uvoff)[0] + 4);\
    dbgDisplayVertexData(((DWORD*)nvFifo)[1],((DWORD*)nvFifo)[2],((DWORD*)nvFifo)[3],\
                         ((DWORD*)nvFifo)[4],((DWORD*)nvFifo)[5],((DWORD*)nvFifo)[6],\
                         ((DWORD*)nvFifo)[7],((DWORD*)nvFifo)[8]);\
    fifo      += sizeDX5TriangleVertex * 4;\
    freecount -= sizeDX5TriangleVertex;\
}

#define nvglDX6FlexTriangleVertex(fifo,freecount,ch,alias,vertex,fvf,uvoff)\
{\
    DWORD dwTemp;\
    *(DWORD*)(fifo +  0) = ((sizeDX6TriangleVertex-1)<<18) | ((ch)<<13) | NV055_TLMTVERTEX((alias));\
    *(DWORD*)(fifo +  4) = (*(DWORD*)(vertex +  0));\
    *(DWORD*)(fifo +  8) = (*(DWORD*)(vertex +  4));\
    *(DWORD*)(fifo + 12) = (*(DWORD*)(vertex +  8));\
    dwTemp = *(DWORD*)((vertex & fvf.dwRHWMask) + fvf.dwRHWOffset);\
    *(DWORD*)(fifo + 16) = dwTemp;\
    *(DWORD*)(fifo + 20) = *(DWORD*)((vertex & fvf.dwARGBMask) + fvf.dwARGBOffset);\
    dwTemp = *(DWORD*)((vertex & fvf.dwSpecularMask) + fvf.dwSpecularOffset);\
    *(DWORD*)(fifo + 24) = dwTemp;\
    dwTemp = (vertex & fvf.dwUVMask) + fvf.dwUVOffset;\
    *(DWORD*)(fifo + 28) = *(DWORD*)(dwTemp + (uvoff)[0] + 0);\
    *(DWORD*)(fifo + 32) = *(DWORD*)(dwTemp + (uvoff)[0] + 4);\
    *(DWORD*)(fifo + 36) = *(DWORD*)(dwTemp + (uvoff)[1] + 0);\
    *(DWORD*)(fifo + 40) = *(DWORD*)(dwTemp + (uvoff)[1] + 4);\
    dbgDisplayVertexData(((DWORD*)nvFifo)[1],((DWORD*)nvFifo)[2],((DWORD*)nvFifo)[3],\
                         ((DWORD*)nvFifo)[4],((DWORD*)nvFifo)[5],((DWORD*)nvFifo)[6],\
                         ((DWORD*)nvFifo)[7],((DWORD*)nvFifo)[8]);\
    fifo      += sizeDX6TriangleVertex * 4;\
    freecount -= sizeDX6TriangleVertex;\
}

#define nvglDX6FlexTriangleVertexExpFog(fifo,freecount,ch,alias,vertex,fvf,uvoff)\
{\
    DWORD dwTemp;\
    DWORD zmask,dwrhw,dwz;\
    int   ifog;\
    float ffog,fz,fw;\
    float frhw;\
    *(DWORD*)(fifo +  0) = ((sizeDX6TriangleVertex-1)<<18) | ((ch)<<13) | NV055_TLMTVERTEX((alias));\
    *(DWORD*)(fifo +  4) = (*(DWORD*)(vertex +  0));\
    *(DWORD*)(fifo +  8) = (*(DWORD*)(vertex +  4));\
    *(DWORD*)(fifo + 12) = dwz = (*(DWORD*)(vertex +  8));\
    dwTemp = *(DWORD*)((vertex & fvf.dwRHWMask) + fvf.dwRHWOffset);\
    *(DWORD*)(fifo + 16) = dwrhw = dwTemp;\
    *(DWORD*)(fifo + 20) = *(DWORD*)((vertex & fvf.dwARGBMask) + fvf.dwARGBOffset);\
    dwTemp = *(DWORD*)((vertex & fvf.dwSpecularMask) + fvf.dwSpecularOffset);\
    zmask = ((*(DWORD *)&(pCurrentContext->dvWNear) == 0x3f800000) && (*(DWORD *)&(pCurrentContext->dvWFar) == 0x3f800000)) ? 0xffffffff : 0;\
    frhw = *(float*)&dwrhw;\
    FP_INV (fw, frhw);\
    dwz = (dwz & zmask) | (*(DWORD *)&fw & ~zmask);\
    fz = *(float *)&dwz;\
    ffog  = fz * pCurrentContext->fFogTableDensity;\
    FP_EXP (ffog,ffog);\
    FP_NORM_TO_BIT24 (ifog,ffog);\
    dwTemp = (dwTemp & 0x00ffffff) | ifog;\
    *(DWORD*)(fifo + 24) = dwTemp;\
    dwTemp = (vertex & fvf.dwUVMask) + fvf.dwUVOffset;\
    *(DWORD*)(fifo + 28) = *(DWORD*)(dwTemp + (uvoff)[0] + 0);\
    *(DWORD*)(fifo + 32) = *(DWORD*)(dwTemp + (uvoff)[0] + 4);\
    *(DWORD*)(fifo + 36) = *(DWORD*)(dwTemp + (uvoff)[1] + 0);\
    *(DWORD*)(fifo + 40) = *(DWORD*)(dwTemp + (uvoff)[1] + 4);\
    dbgDisplayVertexData(((DWORD*)nvFifo)[1],((DWORD*)nvFifo)[2],((DWORD*)nvFifo)[3],\
                         ((DWORD*)nvFifo)[4],((DWORD*)nvFifo)[5],((DWORD*)nvFifo)[6],\
                         ((DWORD*)nvFifo)[7],((DWORD*)nvFifo)[8]);\
    fifo      += sizeDX6TriangleVertex * 4;\
    freecount -= sizeDX6TriangleVertex;\
}

#define nvglDX6FlexTriangleVertexExp2Fog(fifo,freecount,ch,alias,vertex,fvf,uvoff)\
{\
    DWORD dwTemp;\
    DWORD zmask,dwrhw,dwz;\
    int   ifog;\
    float ffog,fz,fw;\
    float frhw;\
    *(DWORD*)(fifo +  0) = ((sizeDX6TriangleVertex-1)<<18) | ((ch)<<13) | NV055_TLMTVERTEX((alias));\
    *(DWORD*)(fifo +  4) = (*(DWORD*)(vertex +  0));\
    *(DWORD*)(fifo +  8) = (*(DWORD*)(vertex +  4));\
    *(DWORD*)(fifo + 12) = dwz = (*(DWORD*)(vertex +  8));\
    dwTemp = *(DWORD*)((vertex & fvf.dwRHWMask) + fvf.dwRHWOffset);\
    *(DWORD*)(fifo + 16) = dwrhw = dwTemp;\
    *(DWORD*)(fifo + 20) = *(DWORD*)((vertex & fvf.dwARGBMask) + fvf.dwARGBOffset);\
    dwTemp = *(DWORD*)((vertex & fvf.dwSpecularMask) + fvf.dwSpecularOffset);\
    zmask = ((*(DWORD *)&(pCurrentContext->dvWNear) == 0x3f800000) && (*(DWORD *)&(pCurrentContext->dvWFar) == 0x3f800000)) ? 0xffffffff : 0;\
    frhw = *(float*)&dwrhw;\
    FP_INV (fw, frhw);\
    dwz = (dwz & zmask) | (*(DWORD *)&fw & ~zmask);\
    fz = *(float *)&dwz;\
    ffog  = fz * pCurrentContext->fFogTableDensity;\
    ffog *= ffog;\
    FP_EXP (ffog,ffog);\
    FP_NORM_TO_BIT24 (ifog,ffog);\
    dwTemp = (dwTemp & 0x00ffffff) | ifog;\
    *(DWORD*)(fifo + 24) = dwTemp;\
    dwTemp = (vertex & fvf.dwUVMask) + fvf.dwUVOffset;\
    *(DWORD*)(fifo + 28) = *(DWORD*)(dwTemp + (uvoff)[0] + 0);\
    *(DWORD*)(fifo + 32) = *(DWORD*)(dwTemp + (uvoff)[0] + 4);\
    *(DWORD*)(fifo + 36) = *(DWORD*)(dwTemp + (uvoff)[1] + 0);\
    *(DWORD*)(fifo + 40) = *(DWORD*)(dwTemp + (uvoff)[1] + 4);\
    dbgDisplayVertexData(((DWORD*)nvFifo)[1],((DWORD*)nvFifo)[2],((DWORD*)nvFifo)[3],\
                         ((DWORD*)nvFifo)[4],((DWORD*)nvFifo)[5],((DWORD*)nvFifo)[6],\
                         ((DWORD*)nvFifo)[7],((DWORD*)nvFifo)[8]);\
    fifo      += sizeDX6TriangleVertex * 4;\
    freecount -= sizeDX6TriangleVertex;\
}

#define nvglDX6FlexTriangleVertexLinearFog(fifo,freecount,ch,alias,vertex,fvf,uvoff)\
{\
    DWORD dwTemp;\
    DWORD zmask,dwrhw,dwz;\
    int   ifog;\
    float ffog,fz,fw;\
    float frhw;\
    *(DWORD*)(fifo +  0) = ((sizeDX6TriangleVertex-1)<<18) | ((ch)<<13) | NV055_TLMTVERTEX((alias));\
    *(DWORD*)(fifo +  4) = (*(DWORD*)(vertex +  0));\
    *(DWORD*)(fifo +  8) = (*(DWORD*)(vertex +  4));\
    *(DWORD*)(fifo + 12) = dwz = (*(DWORD*)(vertex +  8));\
    dwTemp = *(DWORD*)((vertex & fvf.dwRHWMask) + fvf.dwRHWOffset);\
    *(DWORD*)(fifo + 16) = dwrhw = dwTemp;\
    *(DWORD*)(fifo + 20) = *(DWORD*)((vertex & fvf.dwARGBMask) + fvf.dwARGBOffset);\
    dwTemp = *(DWORD*)((vertex & fvf.dwSpecularMask) + fvf.dwSpecularOffset);\
    zmask = ((*(DWORD *)&(pCurrentContext->dvWNear) == 0x3f800000) && (*(DWORD *)&(pCurrentContext->dvWFar) == 0x3f800000)) ? 0xffffffff : 0;\
    frhw = *(float*)&dwrhw;\
    FP_INV (fw, frhw);\
    dwz = (dwz & zmask) | (*(DWORD *)&fw & ~zmask);\
    fz = *(float *)&dwz;\
    ffog = (fz >= pCurrentContext->fFogTableEnd) ? 0.0f :\
           (fz <= pCurrentContext->fFogTableStart) ? 1.0f :\
           (pCurrentContext->fFogTableEnd - fz) * pCurrentContext->fFogTableLinearScale;\
    FP_NORM_TO_BIT24 (ifog,ffog);\
    dwTemp = (dwTemp & 0x00ffffff) | ifog;\
    *(DWORD*)(fifo + 24) = dwTemp;\
    dwTemp = (vertex & fvf.dwUVMask) + fvf.dwUVOffset;\
    *(DWORD*)(fifo + 28) = *(DWORD*)(dwTemp + (uvoff)[0] + 0);\
    *(DWORD*)(fifo + 32) = *(DWORD*)(dwTemp + (uvoff)[0] + 4);\
    *(DWORD*)(fifo + 36) = *(DWORD*)(dwTemp + (uvoff)[1] + 0);\
    *(DWORD*)(fifo + 40) = *(DWORD*)(dwTemp + (uvoff)[1] + 4);\
    dbgDisplayVertexData(((DWORD*)nvFifo)[1],((DWORD*)nvFifo)[2],((DWORD*)nvFifo)[3],\
                         ((DWORD*)nvFifo)[4],((DWORD*)nvFifo)[5],((DWORD*)nvFifo)[6],\
                         ((DWORD*)nvFifo)[7],((DWORD*)nvFifo)[8]);\
    fifo      += sizeDX6TriangleVertex * 4;\
    freecount -= sizeDX6TriangleVertex;\
}

#define nvglDX6FlexTriangleVertexWBuf(fifo,freecount,ch,alias,vertex,fvf,uvoff)\
{\
    DWORD dwTemp;\
    float frhw;\
    *(DWORD*)(fifo +  0) = ((sizeDX6TriangleVertex-1)<<18) | ((ch)<<13) | NV055_TLMTVERTEX((alias));\
    *(DWORD*)(fifo +  4) = (*(DWORD*)(vertex +  0));\
    *(DWORD*)(fifo +  8) = (*(DWORD*)(vertex +  4));\
    *(DWORD*)(fifo + 12) = (*(DWORD*)(vertex +  8));\
    dwTemp = *(DWORD*)((vertex & fvf.dwRHWMask) + fvf.dwRHWOffset);\
    frhw = (*(float*)&dwTemp) * pCurrentContext->dvRWFar;\
    *(DWORD*)(fifo + 16) = *(DWORD*)&frhw;\
    *(DWORD*)(fifo + 20) = *(DWORD*)((vertex & fvf.dwARGBMask) + fvf.dwARGBOffset);\
    dwTemp = *(DWORD*)((vertex & fvf.dwSpecularMask) + fvf.dwSpecularOffset);\
    *(DWORD*)(fifo + 24) = dwTemp;\
    dwTemp = (vertex & fvf.dwUVMask) + fvf.dwUVOffset;\
    *(DWORD*)(fifo + 28) = *(DWORD*)(dwTemp + (uvoff)[0] + 0);\
    *(DWORD*)(fifo + 32) = *(DWORD*)(dwTemp + (uvoff)[0] + 4);\
    *(DWORD*)(fifo + 36) = *(DWORD*)(dwTemp + (uvoff)[1] + 0);\
    *(DWORD*)(fifo + 40) = *(DWORD*)(dwTemp + (uvoff)[1] + 4);\
    dbgDisplayVertexData(((DWORD*)nvFifo)[1],((DWORD*)nvFifo)[2],((DWORD*)nvFifo)[3],\
                         ((DWORD*)nvFifo)[4],((DWORD*)nvFifo)[5],((DWORD*)nvFifo)[6],\
                         ((DWORD*)nvFifo)[7],((DWORD*)nvFifo)[8]);\
    fifo      += sizeDX6TriangleVertex * 4;\
    freecount -= sizeDX6TriangleVertex;\
}

#define nvglDX6FlexTriangleVertexExpFogWBuf(fifo,freecount,ch,alias,vertex,fvf,uvoff)\
{\
    DWORD dwTemp;\
    DWORD zmask,dwrhw,dwz;\
    int   ifog;\
    float ffog,fz,fw;\
    float frhw;\
    *(DWORD*)(fifo +  0) = ((sizeDX6TriangleVertex-1)<<18) | ((ch)<<13) | NV055_TLMTVERTEX((alias));\
    *(DWORD*)(fifo +  4) = (*(DWORD*)(vertex +  0));\
    *(DWORD*)(fifo +  8) = (*(DWORD*)(vertex +  4));\
    *(DWORD*)(fifo + 12) = dwz = (*(DWORD*)(vertex +  8));\
    dwTemp = *(DWORD*)((vertex & fvf.dwRHWMask) + fvf.dwRHWOffset);\
    frhw = (*(float*)&dwTemp) * pCurrentContext->dvRWFar;\
    *(DWORD*)(fifo + 16) = dwrhw = *(DWORD*)&frhw;\
    *(DWORD*)(fifo + 20) = *(DWORD*)((vertex & fvf.dwARGBMask) + fvf.dwARGBOffset);\
    dwTemp = *(DWORD*)((vertex & fvf.dwSpecularMask) + fvf.dwSpecularOffset);\
    zmask = ((*(DWORD *)&(pCurrentContext->dvWNear) == 0x3f800000) && (*(DWORD *)&(pCurrentContext->dvWFar) == 0x3f800000)) ? 0xffffffff : 0;\
    frhw = *(float*)&dwrhw;\
    FP_INV (fw, frhw);\
    dwz = (dwz & zmask) | (*(DWORD *)&fw & ~zmask);\
    fz = *(float *)&dwz;\
    ffog  = fz * pCurrentContext->fFogTableDensity;\
    FP_EXP (ffog,ffog);\
    FP_NORM_TO_BIT24 (ifog,ffog);\
    dwTemp = (dwTemp & 0x00ffffff) | ifog;\
    *(DWORD*)(fifo + 24) = dwTemp;\
    dwTemp = (vertex & fvf.dwUVMask) + fvf.dwUVOffset;\
    *(DWORD*)(fifo + 28) = *(DWORD*)(dwTemp + (uvoff)[0] + 0);\
    *(DWORD*)(fifo + 32) = *(DWORD*)(dwTemp + (uvoff)[0] + 4);\
    *(DWORD*)(fifo + 36) = *(DWORD*)(dwTemp + (uvoff)[1] + 0);\
    *(DWORD*)(fifo + 40) = *(DWORD*)(dwTemp + (uvoff)[1] + 4);\
    dbgDisplayVertexData(((DWORD*)nvFifo)[1],((DWORD*)nvFifo)[2],((DWORD*)nvFifo)[3],\
                         ((DWORD*)nvFifo)[4],((DWORD*)nvFifo)[5],((DWORD*)nvFifo)[6],\
                         ((DWORD*)nvFifo)[7],((DWORD*)nvFifo)[8]);\
    fifo      += sizeDX6TriangleVertex * 4;\
    freecount -= sizeDX6TriangleVertex;\
}

#define nvglDX6FlexTriangleVertexExp2FogWBuf(fifo,freecount,ch,alias,vertex,fvf,uvoff)\
{\
    DWORD dwTemp;\
    DWORD zmask,dwrhw,dwz;\
    int   ifog;\
    float ffog,fz,fw;\
    float frhw;\
    *(DWORD*)(fifo +  0) = ((sizeDX6TriangleVertex-1)<<18) | ((ch)<<13) | NV055_TLMTVERTEX((alias));\
    *(DWORD*)(fifo +  4) = (*(DWORD*)(vertex +  0));\
    *(DWORD*)(fifo +  8) = (*(DWORD*)(vertex +  4));\
    *(DWORD*)(fifo + 12) = dwz = (*(DWORD*)(vertex +  8));\
    dwTemp = *(DWORD*)((vertex & fvf.dwRHWMask) + fvf.dwRHWOffset);\
    frhw = (*(float*)&dwTemp) * pCurrentContext->dvRWFar;\
    *(DWORD*)(fifo + 16) = dwrhw = *(DWORD*)&frhw;\
    *(DWORD*)(fifo + 20) = *(DWORD*)((vertex & fvf.dwARGBMask) + fvf.dwARGBOffset);\
    dwTemp = *(DWORD*)((vertex & fvf.dwSpecularMask) + fvf.dwSpecularOffset);\
    zmask = ((*(DWORD *)&(pCurrentContext->dvWNear) == 0x3f800000) && (*(DWORD *)&(pCurrentContext->dvWFar) == 0x3f800000)) ? 0xffffffff : 0;\
    frhw = *(float*)&dwrhw;\
    FP_INV (fw, frhw);\
    dwz = (dwz & zmask) | (*(DWORD *)&fw & ~zmask);\
    fz = *(float *)&dwz;\
    ffog  = fz * pCurrentContext->fFogTableDensity;\
    ffog *= ffog;\
    FP_EXP (ffog,ffog);\
    FP_NORM_TO_BIT24 (ifog,ffog);\
    dwTemp = (dwTemp & 0x00ffffff) | ifog;\
    *(DWORD*)(fifo + 24) = dwTemp;\
    dwTemp = (vertex & fvf.dwUVMask) + fvf.dwUVOffset;\
    *(DWORD*)(fifo + 28) = *(DWORD*)(dwTemp + (uvoff)[0] + 0);\
    *(DWORD*)(fifo + 32) = *(DWORD*)(dwTemp + (uvoff)[0] + 4);\
    *(DWORD*)(fifo + 36) = *(DWORD*)(dwTemp + (uvoff)[1] + 0);\
    *(DWORD*)(fifo + 40) = *(DWORD*)(dwTemp + (uvoff)[1] + 4);\
    dbgDisplayVertexData(((DWORD*)nvFifo)[1],((DWORD*)nvFifo)[2],((DWORD*)nvFifo)[3],\
                         ((DWORD*)nvFifo)[4],((DWORD*)nvFifo)[5],((DWORD*)nvFifo)[6],\
                         ((DWORD*)nvFifo)[7],((DWORD*)nvFifo)[8]);\
    fifo      += sizeDX6TriangleVertex * 4;\
    freecount -= sizeDX6TriangleVertex;\
}

#define nvglDX6FlexTriangleVertexLinearFogWBuf(fifo,freecount,ch,alias,vertex,fvf,uvoff)\
{\
    DWORD dwTemp;\
    DWORD zmask,dwrhw,dwz;\
    int   ifog;\
    float ffog,fz,fw;\
    float frhw;\
    *(DWORD*)(fifo +  0) = ((sizeDX6TriangleVertex-1)<<18) | ((ch)<<13) | NV055_TLMTVERTEX((alias));\
    *(DWORD*)(fifo +  4) = (*(DWORD*)(vertex +  0));\
    *(DWORD*)(fifo +  8) = (*(DWORD*)(vertex +  4));\
    *(DWORD*)(fifo + 12) = dwz = (*(DWORD*)(vertex +  8));\
    dwTemp = *(DWORD*)((vertex & fvf.dwRHWMask) + fvf.dwRHWOffset);\
    frhw = (*(float*)&dwTemp) * pCurrentContext->dvRWFar;\
    *(DWORD*)(fifo + 16) = dwrhw = *(DWORD*)&frhw;\
    *(DWORD*)(fifo + 20) = *(DWORD*)((vertex & fvf.dwARGBMask) + fvf.dwARGBOffset);\
    dwTemp = *(DWORD*)((vertex & fvf.dwSpecularMask) + fvf.dwSpecularOffset);\
    zmask = ((*(DWORD *)&(pCurrentContext->dvWNear) == 0x3f800000) && (*(DWORD *)&(pCurrentContext->dvWFar) == 0x3f800000)) ? 0xffffffff : 0;\
    frhw = *(float*)&dwrhw;\
    FP_INV (fw, frhw);\
    dwz = (dwz & zmask) | (*(DWORD *)&fw & ~zmask);\
    fz = *(float *)&dwz;\
    ffog = (fz >= pCurrentContext->fFogTableEnd) ? 0.0f :\
           (fz <= pCurrentContext->fFogTableStart) ? 1.0f :\
           (pCurrentContext->fFogTableEnd - fz) * pCurrentContext->fFogTableLinearScale;\
    FP_NORM_TO_BIT24 (ifog,ffog);\
    dwTemp = (dwTemp & 0x00ffffff) | ifog;\
    *(DWORD*)(fifo + 24) = dwTemp;\
    dwTemp = (vertex & fvf.dwUVMask) + fvf.dwUVOffset;\
    *(DWORD*)(fifo + 28) = *(DWORD*)(dwTemp + (uvoff)[0] + 0);\
    *(DWORD*)(fifo + 32) = *(DWORD*)(dwTemp + (uvoff)[0] + 4);\
    *(DWORD*)(fifo + 36) = *(DWORD*)(dwTemp + (uvoff)[1] + 0);\
    *(DWORD*)(fifo + 40) = *(DWORD*)(dwTemp + (uvoff)[1] + 4);\
    dbgDisplayVertexData(((DWORD*)nvFifo)[1],((DWORD*)nvFifo)[2],((DWORD*)nvFifo)[3],\
                         ((DWORD*)nvFifo)[4],((DWORD*)nvFifo)[5],((DWORD*)nvFifo)[6],\
                         ((DWORD*)nvFifo)[7],((DWORD*)nvFifo)[8]);\
    fifo      += sizeDX6TriangleVertex * 4;\
    freecount -= sizeDX6TriangleVertex;\
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\inc\nvHeap.h ===
#ifndef _NV_HEAP_H
#define _NV_HEAP_H

/*
 * heap manager interface
 */
#ifdef  MULTI_MON
#include "nvrmapi.h"
#include "nvrmarch.inc"
#endif  // MULTI_MON

#ifdef NVHEAPMGR
#define AGP_HEAP 0
#else
#define AGP_HEAP 1
#endif

#ifdef NVHEAPMGR
#ifdef MULTI_MON
static NVIOControl_Param HeapParams;
#else   // !MULTI_MON
static struct
{
  U032 function;
  U032 device;
  U032 owner;
  U032 type;
  U032 depth;
  U032 width;
  U032 height;
  S032 pitch;
  U032 offset;
  U032 size;
  U032 address;
  U032 limit;
  U032 total;
  U032 free;
  V032 status;
} HeapParams;
#endif  // !MULTI_MON
#endif  // NVHEAPMGR

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\inc\NVD3DMAC.H ===
#ifndef _NVD3DMAC_H_
#define _NVD3DMAC_H_
/*
 * (C) Copyright NVIDIA Corporation Inc., 1996,1997,1998. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: NVD3DMAC.H                                                        *
*   Define various macros used in the D3D driver.                           *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Charles Inman (chasi)       01/31/98 - Created.                     *
*                                                                           *
\***************************************************************************/
#ifdef  NV4
#include    "nv4dmac.h"
#endif

/*
 * Global memory allocation macros.
 */
#ifdef  WINNT
#define HEAPCREATE(nop)                 (!NULL)
#define HEAPDESTROY(heap)               ((heap) = NULL)
#define HEAPALLOC(nop, size)            EngAllocMem(FL_ZERO_MEMORY, (size), 'amxD')
#define HEAPFREE(nop, ptr)              { \
    if (ptr != NULL)            \
    {                           \
    EngFreeMem((ptr));          \
    (ptr) = NULL;               \
    }                           \
}
#define HEAPREALLOC(nop, ptr, size)     {   \
                                            HEAPFREE(nop, (ptr)); \
                                            (ptr) = HEAPALLOC(nop, size); \
                                        }
/*
 * User mode memory allocation functions. There are no Globalxxx fcts in NT
 * kernel mode.
 */
#define GlobalAlloc(nop, size)  \
    EngAllocUserMem((size), 'amxD')
#define GlobalLock(ptr)  (ptr)
#define GlobalUnlock(nop)
#define GlobalFree(ptr)         \
    {                           \
    if (ptr != NULL)            \
    {                           \
    EngFreeUserMem(ptr);        \
    (ptr) = NULL;               \
    }                           \
    }
#else   // !WINNT
#define HEAPCREATE(size)                HeapCreate(HEAP_SHARED, (size), 0)
#define HEAPDESTROY(handle)             HeapDestroy((HANDLE)(handle))
#define HEAPALLOC(handle, size)         HeapAlloc((HANDLE)(handle), HEAP_ZERO_MEMORY, (size))
#define HEAPFREE(handle, ptr)           HeapFree((HANDLE)(handle), 0, (VOID *)(ptr))
#define HEAPREALLOC(handle, ptr, size)  (ptr) = HeapReAlloc((HANDLE)(handle), 0, (ptr), (size))

#endif  // !WINNT

/*
 * Convert th FP representation into a DWORD.  Used for magnitude comparisons.
 */
#define FP_BITS(fp) (*(DWORD *)&(fp))
#define FP_ABS_BITS(fp) (FP_BITS(fp)&0x7FFFFFFF)
#define FP_SIGN_BIT(fp) (FP_BITS(fp)&0x80000000)
#define FP_ONE_BITS 0x3F800000
/*
 * Some FP macros used in table fog. Thanks Jim!
 */
#define FP_INV(r,p)                                                          \
{                                                                            \
    int _i = 2 * FP_ONE_BITS - *(int *)&(p);                                 \
    r = *(float *)&_i;                                                       \
    r = r * (2.0f - (p) * r);                                                \
}
#define FP_EXP(e,p)                                                          \
{                                                                            \
    int _i;                                                                  \
    e = -1.44269504f * (float)0x00800000 * (p);                              \
    _i = (int)e + 0x3F800000;                                                \
    e = *(float *)&_i;                                                       \
}
#define FP_NORM_TO_BYTE(i,p)                                                 \
{                                                                            \
    float _n = (p) + 1.0f;                                                   \
    (i) = *(int *)&_n;                                                       \
    if ((i) >= 0x40000000)     (i) = 0xFF;                                   \
    else if ((i) <=0x3F800000) (i) = 0;                                      \
    else (i) = ((i) >> 15) & 0xFF;                                           \
}

/*
 * D3D state macros.
 */

#define IS_OVERRIDE(type)       ((DWORD)(type) > D3DSTATE_OVERRIDE_BIAS)
#define GET_OVERRIDE(type)      ((DWORD)(type) - D3DSTATE_OVERRIDE_BIAS)

#define STATESET_MASK(set, state)                                           \
        (set).bits[((state) - 1) >> DWORD_SHIFT]

#define STATESET_BIT(state)     (1 << (((state) - 1) & (DWORD_BITS - 1)))

#define STATESET_ISSET(set, state)                                          \
        STATESET_MASK(set, state) & STATESET_BIT(state)

#define STATESET_SET(set, state)                                            \
        STATESET_MASK(set, state) |= STATESET_BIT(state)

#define STATESET_CLEAR(set, state)                                          \
        STATESET_MASK(set, state) &= ~STATESET_BIT(state)

#define STATESET_INIT(set)      memset(&(set), 0, sizeof(set))

#if 0
/*
 * Memory management macros.
 */
#define GlobalUnlockPtr32(lp)                                               \
        GlobalUnlock(GlobalHandle((LPCVOID)lp))

#define GlobalAllocPtr32(flags, cb)                                         \
        (GlobalLock(GlobalAlloc((flags), (cb))))

#define GlobalFreePtr32(lp)                                                 \
        (GlobalUnlockPtr32(lp), (BOOL)GlobalFree(GlobalHandle((LPCVOID)lp)))
#endif

#ifdef  DO_XF_LIGHT
// TODO move dwCurrentPipelineHandle into pDriverData structure
// TODO move dwCurrentPipelinePtr into pDriverData structure
#define GET_PIPELINE_PTR(ptr, harray, hpipeline)                            \
{                                                                           \
    if ((hpipeline) != dwCurrentPipelineHandle)                             \
    {                                                                       \
        (ptr) = (PNVD3DPIPELINE)DDrvItemArrayGetPtr((harray), (HDDRVITEM)(hpipeline));\
        dwCurrentPipelineHandle = (DWORD)(hpipeline);                       \
        dwCurrentPipelinePtr    = (DWORD)(ptr);                             \
    }                                                                       \
    else                                                                    \
        (ptr) = (PNVD3DPIPELINE)dwCurrentPipelinePtr;                       \
}

#define DESTROY_PIPELINES_FROM_PROCESS(pid)                                 \
{                                                                           \
    DDrvItemArrayApplyValid(pDriverData->hPipelines_gbl,                    \
                            DestroyPipelineProcessCallback,                 \
                            pid);                                           \
}

#define DESTROY_PIPELINES_FROM_CONTEXT(hctx)                                \
{                                                                           \
    DDrvItemArrayApplyValid(pDriverData->hPipelines_gbl,                    \
                            DestroyPipelineContextCallback,                 \
                            hctx);                                          \
}

// TODO move dwCurrentMaterialHandle into pDriverData structure
// TODO move dwCurrentMaterialPtr into pDriverData structure
#define GET_MATERIAL_PTR(ptr, harray, hmaterial)                            \
{                                                                           \
    if ((hmaterial) != dwCurrentMaterialHandle)                             \
    {                                                                       \
        (ptr) = (PNVD3DMATERIAL)DDrvItemArrayGetPtr((harray), (HDDRVITEM)(hmaterial));\
        dwCurrentMaterialHandle = (DWORD)(hmaterial);                       \
        dwCurrentMaterialPtr    = (DWORD)(ptr);                             \
    }                                                                       \
    else                                                                    \
        (ptr) = (PNVD3DMATERIAL)dwCurrentMaterialPtr;                       \
}

#define DESTROY_MATERIALS_FROM_PROCESS(pid)                                 \
{                                                                           \
    DDrvItemArrayApplyValid(pDriverData->hMaterials_gbl,                    \
                            DestroyMaterialProcessCallback,                 \
                            pid);                                           \
}

#define DESTROY_MATERIALS_FROM_CONTEXT(hctx)                                \
{                                                                           \
    DDrvItemArrayApplyValid(pDriverData->hMaterials_gbl,                    \
                            DestroyMaterialContextCallback,                 \
                            hctx);                                          \
}

#endif  // DO_XF_LIGHT

#ifndef WINNT
#define NV_LOCK_TEXTURE_SURFACE(pTex)
#define NV_UNLOCK_TEXTURE_SURFACE(pTex)
#else
#define NV_LOCK_TEXTURE_SURFACE(pTex) \
    pTex->lpLcl = EngLockDirectDrawSurface(pTex->hDDS)

#define NV_UNLOCK_TEXTURE_SURFACE(pTex) \
{                                            \
    EngUnlockDirectDrawSurface(pTex->lpLcl); \
    pTex->lpLcl = NULL;                      \
}
#endif // #ifdef WINNT

#endif  // _NVD3DMAC_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\inc\NVTEXFMT.H ===
#ifndef _NVTEXFMT_H_
#define _NVTEXFMT_H_
/*
 * (C) Copyright NVIDIA Corporation Inc., 1996,1997,1998. All rights reserved.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: NVTEXFMT.H                                                        *
*   Define the texture format available for the NV D3D driver.              *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Charles Inman (chasi)       01/31/98 - created.                     *
*                                                                           *
\***************************************************************************/

/*
 * Define the various texture format definitions.
 * For any given hardware, the texture format definitions don't change,
 * just the formats that are available on that hardware change.
 */
/*
 * RGB 16 BPP (R5xG5xB5)
 */
#define NV_TFMT_X1R5G5B5                                                        \
{                                                                               \
    sizeof(DDSURFACEDESC),              /* dwSize */                            \
    DDSD_CAPS | DDSD_PIXELFORMAT,       /* dwFlags */                           \
    0,                                  /* dwHeight */                          \
    0,                                  /* dwWidth */                           \
    0,                                  /* lPitch */                            \
    0,                                  /* dwBackBufferCount */                 \
    0,                                  /* dwZBufferBitDepth */                 \
    0,                                  /* dwAlphaBitDepth */                   \
    0,                                  /* dwReserved */                        \
    NULL,                               /* lpSurface */                         \
    { 0, 0 },                           /* ddckCKDestOverlay */                 \
    { 0, 0 },                           /* ddckCKDestBlt */                     \
    { 0, 0 },                           /* ddckCKSrcOverlay */                  \
    { 0, 0 },                           /* ddckCKSrcBlt */                      \
    {                                                                           \
      sizeof(DDPIXELFORMAT),            /* ddpfPixelFormat.dwSize */            \
      DDPF_RGB,                         /* ddpfPixelFormat.dwFlags */           \
      0,                                /* FOURCC code */                       \
      16,                               /* ddpfPixelFormat.dwRGBBitCount */     \
      0x7C00,                                                                   \
      0x03E0,                                                                   \
      0x001F,                                                                   \
      0x0000                                                                    \
    },                                                                          \
    DDSCAPS_TEXTURE,                    /* ddscaps.dwCaps */                    \
}

/*
 * RGB 16 BPP Alpha (A1xR5xG5xB5)
 */
#define NV_TFMT_A1R5G5B5                                                        \
{                                                                               \
    sizeof(DDSURFACEDESC),              /* dwSize */                            \
    DDSD_CAPS | DDSD_PIXELFORMAT,       /* dwFlags */                           \
    0,                                  /* dwHeight */                          \
    0,                                  /* dwWidth */                           \
    0,                                  /* lPitch */                            \
    0,                                  /* dwBackBufferCount */                 \
    0,                                  /* dwZBufferBitDepth */                 \
    0,                                  /* dwAlphaBitDepth */                   \
    0,                                  /* dwReserved */                        \
    NULL,                               /* lpSurface */                         \
    { 0, 0 },                           /* ddckCKDestOverlay */                 \
    { 0, 0 },                           /* ddckCKDestBlt */                     \
    { 0, 0 },                           /* ddckCKSrcOverlay */                  \
    { 0, 0 },                           /* ddckCKSrcBlt */                      \
    {                                                                           \
      sizeof(DDPIXELFORMAT),            /* ddpfPixelFormat.dwSize */            \
      DDPF_RGB | DDPF_ALPHAPIXELS,      /* ddpfPixelFormat.dwFlags */           \
      0,                                /* FOURCC code */                       \
      16,                               /* ddpfPixelFormat.dwRGBBitCount */     \
      0x7C00,                                                                   \
      0x03E0,                                                                   \
      0x001F,                                                                   \
      0x8000                                                                    \
    },                                                                          \
    DDSCAPS_TEXTURE,                    /* ddscaps.dwCaps */                    \
}

/*
 * RGB 16 BPP Alpha (A4xR4xG4xB4)
 */
#define NV_TFMT_A4R4G4B4                                                        \
{                                                                               \
    sizeof(DDSURFACEDESC),              /* dwSize */                            \
    DDSD_CAPS | DDSD_PIXELFORMAT,       /* dwFlags */                           \
    0,                                  /* dwHeight */                          \
    0,                                  /* dwWidth */                           \
    0,                                  /* lPitch */                            \
    0,                                  /* dwBackBufferCount */                 \
    0,                                  /* dwZBufferBitDepth */                 \
    0,                                  /* dwAlphaBitDepth */                   \
    0,                                  /* dwReserved */                        \
    NULL,                               /* lpSurface */                         \
    { 0, 0 },                           /* ddckCKDestOverlay */                 \
    { 0, 0 },                           /* ddckCKDestBlt */                     \
    { 0, 0 },                           /* ddckCKSrcOverlay */                  \
    { 0, 0 },                           /* ddckCKSrcBlt */                      \
    {                                                                           \
      sizeof(DDPIXELFORMAT),            /* ddpfPixelFormat.dwSize */            \
      DDPF_RGB | DDPF_ALPHAPIXELS,      /* ddpfPixelFormat.dwFlags */           \
      0,                                /* FOURCC code */                       \
      16,                               /* ddpfPixelFormat.dwRGBBitCount */     \
      0x0F00,                                                                   \
      0x00F0,                                                                   \
      0x000F,                                                                   \
      0xF000                                                                    \
    },                                                                          \
    DDSCAPS_TEXTURE,                    /* ddscaps.dwCaps */                    \
}

/*
 * RGB 16 BPP (R5xG6xB5)
 */
#define NV_TFMT_R5G6B5                                                          \
{                                                                               \
    sizeof(DDSURFACEDESC),              /* dwSize */                            \
    DDSD_CAPS | DDSD_PIXELFORMAT,       /* dwFlags */                           \
    0,                                  /* dwHeight */                          \
    0,                                  /* dwWidth */                           \
    0,                                  /* lPitch */                            \
    0,                                  /* dwBackBufferCount */                 \
    0,                                  /* dwZBufferBitDepth */                 \
    0,                                  /* dwAlphaBitDepth */                   \
    0,                                  /* dwReserved */                        \
    NULL,                               /* lpSurface */                         \
    { 0, 0 },                           /* ddckCKDestOverlay */                 \
    { 0, 0 },                           /* ddckCKDestBlt */                     \
    { 0, 0 },                           /* ddckCKSrcOverlay */                  \
    { 0, 0 },                           /* ddckCKSrcBlt */                      \
    {                                                                           \
      sizeof(DDPIXELFORMAT),            /* ddpfPixelFormat.dwSize */            \
      DDPF_RGB,                         /* ddpfPixelFormat.dwFlags */           \
      0,                                /* FOURCC code */                       \
      16,                               /* ddpfPixelFormat.dwRGBBitCount */     \
      0xF800,                                                                   \
      0x07E0,                                                                   \
      0x001F,                                                                   \
      0x0000                                                                    \
    },                                                                          \
    DDSCAPS_TEXTURE,                    /* ddscaps.dwCaps */                    \
}

/*
 * RGB 32 BPP (X8xR8xG8xB8)
 */
#define NV_TFMT_X8R8G8B8                                                        \
{                                                                               \
    sizeof(DDSURFACEDESC),              /* dwSize */                            \
    DDSD_CAPS | DDSD_PIXELFORMAT,       /* dwFlags */                           \
    0,                                  /* dwHeight */                          \
    0,                                  /* dwWidth */                           \
    0,                                  /* lPitch */                            \
    0,                                  /* dwBackBufferCount */                 \
    0,                                  /* dwZBufferBitDepth */                 \
    0,                                  /* dwAlphaBitDepth */                   \
    0,                                  /* dwReserved */                        \
    NULL,                               /* lpSurface */                         \
    { 0, 0 },                           /* ddckCKDestOverlay */                 \
    { 0, 0 },                           /* ddckCKDestBlt */                     \
    { 0, 0 },                           /* ddckCKSrcOverlay */                  \
    { 0, 0 },                           /* ddckCKSrcBlt */                      \
    {                                                                           \
      sizeof(DDPIXELFORMAT),            /* ddpfPixelFormat.dwSize */            \
      DDPF_RGB,                         /* ddpfPixelFormat.dwFlags */           \
      0,                                /* FOURCC code */                       \
      32,                               /* ddpfPixelFormat.dwRGBBitCount */     \
      0x00FF0000,                       /* Red Component Mask */                \
      0x0000FF00,                       /* Green Component Mask */              \
      0x000000FF,                       /* Blue Component Mask */               \
      0x00000000                        /* Alpha Component Mask */              \
    },                                                                          \
    DDSCAPS_TEXTURE,                    /* ddscaps.dwCaps */                    \
}

/*
 * RGB 32 BPP (A8xR8xG8xB8)
 */
#define NV_TFMT_A8R8G8B8                                                        \
{                                                                               \
    sizeof(DDSURFACEDESC),              /* dwSize */                            \
    DDSD_CAPS | DDSD_PIXELFORMAT,       /* dwFlags */                           \
    0,                                  /* dwHeight */                          \
    0,                                  /* dwWidth */                           \
    0,                                  /* lPitch */                            \
    0,                                  /* dwBackBufferCount */                 \
    0,                                  /* dwZBufferBitDepth */                 \
    0,                                  /* dwAlphaBitDepth */                   \
    0,                                  /* dwReserved */                        \
    NULL,                               /* lpSurface */                         \
    { 0, 0 },                           /* ddckCKDestOverlay */                 \
    { 0, 0 },                           /* ddckCKDestBlt */                     \
    { 0, 0 },                           /* ddckCKSrcOverlay */                  \
    { 0, 0 },                           /* ddckCKSrcBlt */                      \
    {                                                                           \
      sizeof(DDPIXELFORMAT),            /* ddpfPixelFormat.dwSize */            \
      DDPF_RGB | DDPF_ALPHAPIXELS,      /* ddpfPixelFormat.dwFlags */           \
      0,                                /* FOURCC code */                       \
      32,                               /* ddpfPixelFormat.dwRGBBitCount */     \
      0x00FF0000,                       /* Red Component Mask */                \
      0x0000FF00,                       /* Green Component Mask */              \
      0x000000FF,                       /* Blue Component Mask */               \
      0xFF000000                        /* Alpha Component Mask */              \
    },                                                                          \
    DDSCAPS_TEXTURE,                    /* ddscaps.dwCaps */                    \
}

/*
 * RGB 24 BPP (R8xG8xB8)
 * Hardware doesn't actually support this.  The texture would actually
 * have to be expanded to a 32bpp X8xR8xG8xB8 format.
 * Haven't decided if I really want to do this.
 */
#define NV_TFMT_R8G8B8                                                          \
{                                                                               \
    sizeof(DDSURFACEDESC),              /* dwSize */                            \
    DDSD_CAPS | DDSD_PIXELFORMAT,       /* dwFlags */                           \
    0,                                  /* dwHeight */                          \
    0,                                  /* dwWidth */                           \
    0,                                  /* lPitch */                            \
    0,                                  /* dwBackBufferCount */                 \
    0,                                  /* dwZBufferBitDepth */                 \
    0,                                  /* dwAlphaBitDepth */                   \
    0,                                  /* dwReserved */                        \
    NULL,                               /* lpSurface */                         \
    { 0, 0 },                           /* ddckCKDestOverlay */                 \
    { 0, 0 },                           /* ddckCKDestBlt */                     \
    { 0, 0 },                           /* ddckCKSrcOverlay */                  \
    { 0, 0 },                           /* ddckCKSrcBlt */                      \
    {                                                                           \
      sizeof(DDPIXELFORMAT),            /* ddpfPixelFormat.dwSize */            \
      DDPF_RGB,                         /* ddpfPixelFormat.dwFlags */           \
      0,                                /* FOURCC code */                       \
      24,                               /* ddpfPixelFormat.dwRGBBitCount */     \
      0x00FF0000,                       /* Red Component Mask */                \
      0x0000FF00,                       /* Green Component Mask */              \
      0x000000FF,                       /* Blue Component Mask */               \
      0x00000000                        /* Alpha Component Mask */              \
    },                                                                          \
    DDSCAPS_TEXTURE,                    /* ddscaps.dwCaps */                    \
}

/*
 * FFVII REQUIRES 8bit textures.  What a pain.  Of course so does PC98/PC99.
 */
#define NV_TFMT_RGB8                                                            \
{                                                                               \
    sizeof(DDSURFACEDESC),              /* dwSize */                            \
    DDSD_CAPS | DDSD_PIXELFORMAT,       /* dwFlags */                           \
    0,                                  /* dwHeight */                          \
    0,                                  /* dwWidth */                           \
    0,                                  /* lPitch */                            \
    0,                                  /* dwBackBufferCount */                 \
    0,                                  /* dwZBufferBitDepth */                 \
    0,                                  /* dwAlphaBitDepth */                   \
    0,                                  /* dwReserved */                        \
    NULL,                               /* lpSurface */                         \
    { 0, 0 },                           /* ddckCKDestOverlay */                 \
    { 0, 0 },                           /* ddckCKDestBlt */                     \
    { 0, 0 },                           /* ddckCKSrcOverlay */                  \
    { 0, 0 },                           /* ddckCKSrcBlt */                      \
    {                                                                           \
      sizeof(DDPIXELFORMAT),            /* ddpfPixelFormat.dwSize */            \
      DDPF_RGB | DDPF_PALETTEINDEXED8,  /* ddpfPixelFormat.dwFlags */           \
      0,                                /* FOURCC code */                       \
      8,                                /* ddpfPixelFormat.dwRGBBitCount */     \
      0x00000000,                       /* Red Component Mask */                \
      0x00000000,                       /* Green Component Mask */              \
      0x00000000,                       /* Blue Component Mask */               \
      0x00000000                        /* Alpha Component Mask */              \
    },                                                                          \
    DDSCAPS_TEXTURE,                    /* ddscaps.dwCaps */                    \
}

/*
 * Y8 Texture Format
 */
#define NV_TFMT_Y8                                                              \
{                                                                               \
    sizeof(DDSURFACEDESC),              /* dwSize */                            \
    DDSD_CAPS | DDSD_PIXELFORMAT,       /* dwFlags */                           \
    0,                                  /* dwHeight */                          \
    0,                                  /* dwWidth */                           \
    0,                                  /* lPitch */                            \
    0,                                  /* dwBackBufferCount */                 \
    0,                                  /* dwZBufferBitDepth */                 \
    0,                                  /* dwAlphaBitDepth */                   \
    0,                                  /* dwReserved */                        \
    NULL,                               /* lpSurface */                         \
    { 0, 0 },                           /* ddckCKDestOverlay */                 \
    { 0, 0 },                           /* ddckCKDestBlt */                     \
    { 0, 0 },                           /* ddckCKSrcOverlay */                  \
    { 0, 0 },                           /* ddckCKSrcBlt */                      \
    {                                                                           \
      sizeof(DDPIXELFORMAT),            /* ddpfPixelFormat.dwSize */            \
      DDPF_LUMINANCE,                   /* ddpfPixelFormat.dwFlags */           \
      0,                                /* FOURCC code */                       \
      8,                                /* ddpfPixelFormat.dwRGBBitCount */     \
      0x000000FF,                       /* Red Component Mask */                \
      0x00000000,                       /* Green Component Mask */              \
      0x00000000,                       /* Blue Component Mask */               \
      0x00000000                        /* Alpha Component Mask */              \
    },                                                                          \
    DDSCAPS_TEXTURE,                    /* ddscaps.dwCaps */                    \
}

/*
 * Potentially need 4bpp and 8bpp palettized textures.
 */

/*
 * Define the texture formats available on NV3 hardware.
 * NV_TFMT_R5G6B5 texture format should be the last format in the
 * structure so it can be easily enabled/disabled at runtime.
 */
#define NV3_TEXTURE_FORMATS NV_TFMT_X1R5G5B5,   \
                            NV_TFMT_A1R5G5B5,   \
                            NV_TFMT_A4R4G4B4,   \
                            NV_TFMT_R5G6B5

/*
 * Define the texture formats available on NV4 hardware.
 */
#define NV_NUM_8BIT_TEXTURE_FORMATS             2
#define NV_NUM_8BIT_Y8ONLY_TEXTURE_FORMATS      (NV_NUM_8BIT_TEXTURE_FORMATS - 1)
#define NV4_TEXTURE_FORMATS NV_TFMT_X1R5G5B5,   \
                            NV_TFMT_A1R5G5B5,   \
                            NV_TFMT_A4R4G4B4,   \
                            NV_TFMT_R5G6B5,     \
                            NV_TFMT_X8R8G8B8,   \
                            NV_TFMT_A8R8G8B8,   \
                            NV_TFMT_Y8,         \
                            NV_TFMT_RGB8

/*
 * Based on the compile flag choose the texture formats available
 * for this driver build.
 */
#ifdef  NV3
#define NV_TEXTURE_FORMATS  NV3_TEXTURE_FORMATS
#endif  // NV3
#ifdef  NV4
#define NV_TEXTURE_FORMATS  NV4_TEXTURE_FORMATS
#endif  // NV4
#endif  // _NVTEXFMT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\ddraw\win9x.nt5\nv4\MakeTri\main.cpp ===
#include <stdio.h>
#include <string.h>

//////////////////////////////////////////////////////////////////////////////
// constants

// output files
#define VXMAC_FILE      "nv4vxmac.h"
#define VXIMP_FILE      "nv4vx.c"

// combinations
typedef enum { DX5,DX6 } MTClass;
typedef enum { None,ExpFog,Exp2Fog,LinFog } MTFogMode;
typedef enum { NoAA,AA } MTScaleMode;
typedef enum { FixedVF,FlexVF } MTVFormat;
//typedef enum { List,Strip,Fan,Ind } MTGeometry;
typedef enum { NonIndexed,Indexed,NA } MTIndexType;
typedef enum { w0,w1 } MTW;

// strings
char *szMTClass[]     = { "DX5","DX6" };
char *szMTFogMode[]   = { "","ExpFog","Exp2Fog","LinearFog" };
char *szMTScaleMode[] = { "","AACapture" };
char *szMTVFormat[]   = { "","Flex" };
//char *szMTGeometry[]  = { "List","Strip","Fan","" } ;
char *szMTIndexType[] = { "","Indexed","" } ;
char *szMTW[]         = { "","WBuf"} ;


//////////////////////////////////////////////////////////////////////////////
// macros
#define SUCC(x,y)       (x)(y+1)
#define FOR_ALL_COMBINATIONS_VX\
    for (mtClass=DX5; mtClass<=DX6; mtClass=SUCC(MTClass,mtClass)) {\
      for (mtVFormat=(mtClass==DX6)?FlexVF:FixedVF; mtVFormat<=FlexVF; mtVFormat=SUCC(MTVFormat,mtVFormat)) {\
        for (mtScaleMode=NoAA; mtScaleMode<=AA; mtScaleMode=SUCC(MTScaleMode,SUCC(MTScaleMode,mtScaleMode))) {\
          mtIndexType = NA;/*for (mtIndexType=NonIndexed; mtIndexType<=Indexed; mtIndexType=SUCC(MTIndexType,mtIndexType)) */{\
          for (mtW=w0; mtW<=w1; mtW=SUCC(MTW,mtW)) {\
            for (mtFogMode=None; mtFogMode<=LinFog; mtFogMode=SUCC(MTFogMode,mtFogMode)) {\
              {\
                init();
#define FOR_ALL_COMBINATIONS_PROC\
    for (mtClass=DX5; mtClass<=DX6; mtClass=SUCC(MTClass,mtClass)) {\
      for (mtVFormat=(mtClass==DX6)?FlexVF:FixedVF; mtVFormat<=FlexVF; mtVFormat=SUCC(MTVFormat,mtVFormat)) {\
        for (mtScaleMode=NoAA; mtScaleMode<=AA; mtScaleMode=SUCC(MTScaleMode,mtScaleMode)) {\
          for (mtIndexType=NonIndexed; mtIndexType<=Indexed; mtIndexType=SUCC(MTIndexType,mtIndexType)) {\
            for (mtW=w0; mtW<=w1; mtW=SUCC(MTW,mtW)) {\
              for (mtFogMode=None; mtFogMode<=((mtScaleMode!=NoAA)?None:LinFog); mtFogMode=SUCC(MTFogMode,mtFogMode)) {\
                {/*for (mtGeometry=(mtIndexType==Indexed?Ind:List); mtGeometry<=(mtIndexType==Indexed?Ind:Fan); mtGeometry=SUCC(MTGeometry,mtGeometry)) {*/\
                  init();
#define NEXT    } } } } } } }

//////////////////////////////////////////////////////////////////////////////
// globals
FILE       *fHdr;
FILE       *fImp;
MTClass     mtClass;
MTVFormat   mtVFormat;
MTScaleMode mtScaleMode;
MTFogMode   mtFogMode;
MTW         mtW;
//MTGeometry  mtGeometry;
MTIndexType mtIndexType;
char        szTableName[512];
char        szProcName[512];
char        szVertexName[512];
char        szILParameter[512];

/*
typedef void  (*LPNVINDEXEDPRIM) (DWORD, LPWORD, DWORD,DWORD, LPD3DTLVERTEX);
typedef void  (*LPNVDRAWPRIM) (WORD, DWORD,DWORD, LPD3DTLVERTEX);

typedef void  (*LPNVFVFINDEXEDPRIM) (DWORD, LPWORD, DWORD,DWORD, LPBYTE);
typedef void  (*LPNVFVFDRAWPRIM) (WORD, DWORD,DWORD, LPBYTE);
*/

char *szHeader = 
"/*\n"
" * **** MACHINE GENERATED - DO NOT EDIT ****\n"
" * **** MACHINE GENERATED - DO NOT EDIT ****\n"
" * **** MACHINE GENERATED - DO NOT EDIT ****\n"
" *\n"
" * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.\n"
" *\n"
" * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO\n"
" * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY\n"
" * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.\n"
" */\n\n"
"/********************************* Direct 3D *******************************\\\n"
"*                                                                           *\n"
"* Module: NV4VX.C                                                           *\n"
"*   NV4 Triangle Inner Loops. (Originally Machine Generated)                *\n"
"*                                                                           *\n"
"*****************************************************************************\n"
"*                                                                           *\n"
"* History:                                                                  *\n"
"*       Ben de Waal                 05/23/98 - NV4 development.             *\n"
"*                                                                           *\n"
"\\***************************************************************************/\n"
"#include <math.h>\n"
"#include <windows.h>\n"
"#include \"ddrawi.h\"\n"
"#include \"ddrvmem.h\"\n"
"#include \"ddmini.h\"\n"
"#include \"nv432.h\"\n"
"#include \"nvddobj.h\"\n"
"#include \"d3d.h\"\n"
"#include \"d3dhal.h\"\n"
"#include \"d3dinc.h\"\n"
"#include \"nvd3dmac.h\"\n"
"#include \"nv3ddbg.h\"\n"
"#include \"nv4vxmac.h\"\n"
"\n"
"#ifdef NV_FASTLOOPS\n"
"\n"
"DWORD dwDrawPrimitiveTable[] =\n"
"{\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x040*/\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x080*/\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x0c0*/\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x100*/\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x140*/\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x180*/\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x1c0*/\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x200*/\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x240*/\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x280*/\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x2c0*/\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x300*/\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x340*/\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x380*/\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x3c0*/\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,\n"
"   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, /*0x400*/\n"
"   (DWORD)nvAACapturePrimitive,\n"
"   (DWORD)nvDX5TriangleSetup,\n"
"   (DWORD)nvAACapturePrimitive,\n"
"   (DWORD)nvDX6TriangleSetup,\n"
"};\n"
"\n"
"#else //~NV_FASTLOOPS\n"
"\n";

//////////////////////////////////////////////////////////////////////////////
// create names
void init (void) {
// inner loops
    sprintf(szProcName,"nv%s%sTriangle%s%s%s%s",
                        szMTClass[mtClass],
                        szMTVFormat[mtVFormat],
                        szMTFogMode[mtFogMode],
                        szMTIndexType[mtIndexType],
                        //szMTGeometry[mtGeometry],
                        szMTScaleMode[mtScaleMode],
                        szMTW[mtW]);
    while (strlen(szProcName)<40) strcat (szProcName," ");
    if (mtVFormat == FlexVF) {
        if (mtIndexType == Indexed) {
            strcpy (szILParameter,"DWORD, LPWORD, DWORD, LPBYTE");
        } else {
            strcpy (szILParameter," WORD,         DWORD, LPBYTE");
        }
    } else {
        if (mtIndexType == Indexed) {
            strcpy (szILParameter,"DWORD, LPWORD, DWORD, LPD3DTLVERTEX");
        } else {
            strcpy (szILParameter," WORD,         DWORD, LPD3DTLVERTEX");
        }
    }
// vertex macro
    sprintf(szVertexName,"nvgl%s%sTriangleVertex%s%s%s",
                        szMTClass[mtClass],
                        szMTVFormat[mtVFormat],
                        /*szMTIndexType[mtIndexType],*/
                        szMTScaleMode[mtScaleMode],
                        szMTFogMode[mtFogMode],
                        szMTW[mtW]);
}

//////////////////////////////////////////////////////////////////////////////
// main
int main (void) {
// create files
    fHdr = fopen(VXMAC_FILE,"wt");
    if (!fHdr) return 1;
    fImp = fopen(VXIMP_FILE,"wt");
    if (!fImp) return 1;

// emit basic stuff
    fprintf (fHdr,"/*\n");
    fprintf (fHdr," * **** MACHINE GENERATED - DO NOT EDIT ****\n");
    fprintf (fHdr," * **** MACHINE GENERATED - DO NOT EDIT ****\n");
    fprintf (fHdr," * **** MACHINE GENERATED - DO NOT EDIT ****\n");
    fprintf (fHdr," *\n");
    fprintf (fHdr," * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.\n");
    fprintf (fHdr," *\n");
    fprintf (fHdr," * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO\n");
    fprintf (fHdr," * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY\n");
    fprintf (fHdr," * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.\n");
    fprintf (fHdr," */\n\n");
    fprintf (fHdr,"/*\n * Inner Loop Prototypes and Vertex Macros\n */\n\n");
    fprintf (fHdr,"/*\n * General Constants\n */\n");
    fprintf (fHdr,"#define NV_FORCE_TRI_SETUP(_ctx) (_ctx)->dwFunctionLookup = NV_SETUP_FUNCTION_INDEX;\n\n");
    fprintf (fHdr,"#ifdef NV_FASTLOOPS\n");
    fprintf (fHdr,"#define NV_DX6_FUNCTION_ADJUST      2\n");
    fprintf (fHdr,"#define NV_FIXED_FUNCTION_INDEX     1024\n");
    fprintf (fHdr,"#define NV_AA_FUNCTION_INDEX        1024\n");
    fprintf (fHdr,"#define NV_SETUP_FUNCTION_INDEX     1025\n");
    fprintf (fHdr,"#else //!NV_FASTLOOPS\n");
    fprintf (fHdr,"#define NV_AA_FUNCTION_INDEX        8\n");
    fprintf (fHdr,"#define NV_SETUP_FUNCTION_INDEX     10\n");
    fprintf (fHdr,"#endif //!NV_FASTLOOPS\n");
    fprintf (fHdr,"\n");
    fprintf (fHdr,"#define sizeDX5TriangleVertex       9\n");
    fprintf (fHdr,"#define sizeDx5TriangleTLVertex     sizeDX5TriangleVertex\n");
    fprintf (fHdr,"\n");
    fprintf (fHdr,"#define sizeDX6TriangleVertex       11\n");
    fprintf (fHdr,"#define sizeDx6TriangleTLVertex     sizeDX6TriangleVertex\n");
    fprintf (fHdr,"\n");
    fprintf (fHdr,"#define LIST_STRIDES                0x00000303\n");
    fprintf (fHdr,"#define STRIP_STRIDES               0x01010101\n");
    fprintf (fHdr,"#define FAN_STRIDES                 0x02000001\n");
    fprintf (fHdr,"#define LEGACY_STRIDES              0x03000404\n");
    fprintf (fHdr,"\n");

    fprintf (fImp,"%s",szHeader);

// emit inner loop prototypes
    fprintf (fHdr,"#ifdef NV_FASTLOOPS\n\n");
    fprintf (fHdr,"void __stdcall nvTriangleDispatch (DWORD, LPWORD, DWORD, LPBYTE);\n");
    fprintf (fHdr,"void __stdcall nvDX5TriangleSetup (DWORD, LPWORD, DWORD, LPBYTE);\n");
    fprintf (fHdr,"void __stdcall nvDX6TriangleSetup (DWORD, LPWORD, DWORD, LPBYTE);\n\n");
    fprintf (fHdr,"extern DWORD dwDrawPrimitiveTable[];\n\n");
    fprintf (fHdr,"#else //!NV_FASTLOOPS\n\n");

    fprintf (fHdr,"/*\n * Inner Loop Prototypes\n */\n");
    FOR_ALL_COMBINATIONS_PROC
        fprintf (fHdr,"void %s (%s);\n",szProcName,szILParameter);
    NEXT
    fprintf (fHdr,"\n");

// emit inner loop tables
    fprintf (fImp,"/*\n * Function Tables\n */\n");
    for (mtClass=DX5; mtClass<=DX6; mtClass=SUCC(MTClass,mtClass)) {\
      for (mtVFormat=(mtClass==DX6)?FlexVF:FixedVF; mtVFormat<=FlexVF; mtVFormat=SUCC(MTVFormat,mtVFormat)) {\
        for (mtIndexType=NonIndexed; mtIndexType<=Indexed; mtIndexType=SUCC(MTIndexType,mtIndexType)) {\
            /*for (mtGeometry=(mtIndexType==Indexed?Ind:List); mtGeometry<=(mtIndexType==Indexed?Ind:Fan); mtGeometry=SUCC(MTGeometry,mtGeometry)) */{\
            char sz[256];
            sprintf(sz,"%s%s%s",
                        szMTClass[mtClass],
                        szMTVFormat[mtVFormat],
                        szMTIndexType[mtIndexType]/*,
                        szMTGeometry[mtGeometry]*/);
            char *rt = (mtIndexType == Indexed) ? ((mtVFormat == FixedVF) ? "LPNVINDEXEDPRIM" : "LPNVFVFINDEXEDPRIM")
                                                : ((mtVFormat == FixedVF) ? "LPNVDRAWPRIM" : "LPNVFVFDRAWPRIM");
            sprintf(szTableName,"%s fn%sTable",rt,sz);
            fprintf (fImp,"%s[] =\n{\n",szTableName);
            for (mtScaleMode=NoAA; mtScaleMode<=AA; mtScaleMode=SUCC(MTScaleMode,mtScaleMode)) {\
              for (mtW=w0; mtW<=w1; mtW=SUCC(MTW,mtW)) {\
                for (mtFogMode=None; mtFogMode<=((mtScaleMode!=NoAA)?None:LinFog); mtFogMode=SUCC(MTFogMode,mtFogMode)) {\
                  init();
                  fprintf (fImp,"    %s,\n",szProcName);
                }
              }
            }
            fprintf (fImp,"    nv%sTriangleSetup\n",sz);
            fprintf (fImp,"};\n\n");

                        fprintf (fHdr,"extern %s fn%sTable[];\n",rt,sz);
                        fprintf (fHdr,"void nv%sTriangleSetup  (%s);\n",sz,szILParameter);
          }
        }
      }
    }
    fprintf (fImp,"\n");
                        fprintf (fHdr,"\n");

// emit inner loops
    fprintf (fImp,"/*\n * Function declarations\n */\n\n");
    FOR_ALL_COMBINATIONS_PROC
        char *size = (mtClass == DX5) ? "sizeDX5TriangleVertex" : "sizeDX6TriangleVertex";
                                    fprintf (fImp,"// %s\n",szProcName);
                                    fprintf (fImp,"#define  PROC_        \"%s\"\n",szProcName);
                                    fprintf (fImp,"#define  PROC         %s\n",szProcName);
                                    fprintf (fImp,"#define  VERTEX       %s\n",szVertexName);
        if (mtClass == DX6)         fprintf (fImp,"#define  DX6\n");
                                    fprintf (fImp,"#define  VXSIZE       %s\n",size);
        if (mtFogMode != None)      fprintf (fImp,"#define  FOG          %d\n",mtFogMode);
        if (mtW == w1)              fprintf (fImp,"#define  WBUFFER\n");
        if (mtIndexType == Indexed) fprintf (fImp,"#define  INDEXED\n");
        if (mtVFormat == FlexVF)    fprintf (fImp,"#define  FVF\n");
        if (mtScaleMode == AA)      fprintf (fImp,"#define  ANTIALIAS\n");
        //if (mtIndexType != Indexed) fprintf (fImp,"#define  GEOMETRY     %d\n",mtGeometry);
                                    //fprintf (fImp,"#ifdef NV_FASTLOOPS2\n");
                                    //fprintf (fImp,"#include \"nv4fast.c\"\n");
                                    //fprintf (fImp,"#else //!NV_FASTLOOPS2\n");
                                    fprintf (fImp,"#include \"nv4loop.c\"\n");
                                    //fprintf (fImp,"#endif //!NV_FASTLOOPS2\n");
        //if (mtIndexType != Indexed) fprintf (fImp,"#undef   GEOMETRY\n");
        if (mtScaleMode == AA)      fprintf (fImp,"#undef   ANTIALIAS\n");
        if (mtVFormat == FlexVF)    fprintf (fImp,"#undef   FVF\n");
        if (mtIndexType == Indexed) fprintf (fImp,"#undef   INDEXED\n");
        if (mtW == w1)              fprintf (fImp,"#undef   WBUFFER\n");
        if (mtFogMode != None)      fprintf (fImp,"#undef   FOG\n");
                                    fprintf (fImp,"#undef   VXSIZE\n");
        if (mtClass == DX6)         fprintf (fImp,"#undef   DX6\n");
                                    fprintf (fImp,"#undef   VERTEX\n");
                                    fprintf (fImp,"#undef   PROC\n");
                                    fprintf (fImp,"#undef   PROC_\n");
        fprintf (fImp,"\n");
    NEXT

// emit vertex macros
    fprintf (fHdr,"#endif //!NV_FASTLOOPS\n");

    fprintf (fHdr,"/*\n * Vertex Macros\n */\n\n");
    FOR_ALL_COMBINATIONS_VX
        char *size = (mtClass == DX5) ? "sizeDX5TriangleVertex" : "sizeDX6TriangleVertex";
            //fprintf (fHdr,"// vertex macro for %s\n",szProcName);
            fprintf (fHdr,"#define %s(fifo,freecount,ch,alias,vertex%s)\\\n",szVertexName,
                            (mtVFormat == FlexVF) ? ",fvf,uvoff" : "");

        if (!strcmp(szVertexName,"nvglDX5TriangleVertex"))
        {
            fprintf (fHdr,"{\\\n");
            fprintf (fHdr,"    *(DWORD*)(fifo +  0) = ((sizeDX5TriangleVertex-1)<<18) | ((ch)<<13) | NV054_TLVERTEX((alias));\\\n");
            fprintf (fHdr,"    memcpy ((void*)(fifo + 4),(void*)(vertex),32);\\\n");
            /*
            fprintf (fHdr,"    __asm { mov eax,[vertex]              }\\\n");
            fprintf (fHdr,"    __asm { mov ebx,[fifo]                }\\\n");
            fprintf (fHdr,"    __asm { movq mm0,qword ptr [eax+ 0]   }\\\n");
            fprintf (fHdr,"    __asm { movq mm1,qword ptr [eax+ 8]   }\\\n");
            fprintf (fHdr,"    __asm { movq mm2,qword ptr [eax+16]   }\\\n");
            fprintf (fHdr,"    __asm { movq mm3,qword ptr [eax+24]   }\\\n");
            fprintf (fHdr,"    __asm { movq qword ptr [ebx+ 0+4],mm0 }\\\n");
            fprintf (fHdr,"    __asm { movq qword ptr [ebx+ 8+4],mm1 }\\\n");
            fprintf (fHdr,"    __asm { movq qword ptr [ebx+16+4],mm2 }\\\n");
            fprintf (fHdr,"    __asm { movq qword ptr [ebx+24+4],mm3 }\\\n");
            fprintf (fHdr,"    __asm { emms                          }\\\n");
            */

        }
        else
        {
            fprintf (fHdr,"{\\\n");
            fprintf (fHdr,"    DWORD dwTemp;\\\n");
            if (mtFogMode != None) {
                fprintf (fHdr,"    DWORD zmask,dwrhw,dwz;\\\n");
                fprintf (fHdr,"    int   ifog;\\\n");
                fprintf (fHdr,"    float ffog,fz,fw;\\\n");
            }
            if ((mtW == w1) || (mtFogMode != None)) {
                fprintf (fHdr,"    float frhw;\\\n");
            }
            // placement
            fprintf (fHdr,"    *(DWORD*)(fifo +  0) = ((%s-1)<<18) | ((ch)<<13) | %s((alias));\\\n",size,(mtClass == DX5) ? "NV054_TLVERTEX" : "NV055_TLMTVERTEX");
            // sx & sy
            if (mtScaleMode == AA) {
                fprintf (fHdr,"    *(float*)(fifo +  4) = (*(float*)(vertex +  0)) * fAAScaleX + fAAOffsetX;\\\n");
                fprintf (fHdr,"    *(float*)(fifo +  8) = (*(float*)(vertex +  4)) * fAAScaleY + fAAOffsetY;\\\n");
            } else {
                fprintf (fHdr,"    *(DWORD*)(fifo +  4) = (*(DWORD*)(vertex +  0));\\\n");
                fprintf (fHdr,"    *(DWORD*)(fifo +  8) = (*(DWORD*)(vertex +  4));\\\n");
            }
            // sz
            fprintf (fHdr,"    *(DWORD*)(fifo + 12) = ");
            if (mtFogMode != None) fprintf (fHdr,"dwz = ");
            fprintf (fHdr,"(*(DWORD*)(vertex +  8));\\\n");
            // rhw
            if (mtVFormat == FlexVF) {
                fprintf (fHdr,"    dwTemp = *(DWORD*)((vertex & fvf.dwRHWMask) + fvf.dwRHWOffset);\\\n");
            } else {
                fprintf (fHdr,"    dwTemp = (*(DWORD*)(vertex + 12));\\\n");
            }
            if (mtW == w1) {
                fprintf (fHdr,"    frhw = (*(float*)&dwTemp) * pCurrentContext->dvRWFar;\\\n");
                fprintf (fHdr,"    *(DWORD*)(fifo + 16) = ");
                if (mtFogMode != None) fprintf (fHdr,"dwrhw = ");
                fprintf (fHdr,"*(DWORD*)&frhw;\\\n");
            }
            else {
                fprintf (fHdr,"    *(DWORD*)(fifo + 16) = ");
                if (mtFogMode != None) fprintf (fHdr,"dwrhw = ");
                fprintf (fHdr,"dwTemp;\\\n");
            }
            // color
            if (mtVFormat == FlexVF) {
                fprintf (fHdr,"    *(DWORD*)(fifo + 20) = *(DWORD*)((vertex & fvf.dwARGBMask) + fvf.dwARGBOffset);\\\n");
            } else {
                fprintf (fHdr,"    *(DWORD*)(fifo + 20) = (*(DWORD*)(verte