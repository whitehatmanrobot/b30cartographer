cturalObject.SetValidValue(value);
                this.ReportPropertyChanged("videoEncodingId");
                this.OnvideoEncodingIdChanged();
            }
        }
        private int _videoEncodingId;
        partial void OnvideoEncodingIdChanging(int value);
        partial void OnvideoEncodingIdChanged();
        /// <summary>
        /// There are no comments for Property name in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public string name
        {
            get
            {
                return this._name;
            }
            set
            {
                this.OnnameChanging(value);
                this.ReportPropertyChanging("name");
                this._name = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value, false);
                this.ReportPropertyChanged("name");
                this.OnnameChanged();
            }
        }
        private string _name;
        partial void OnnameChanging(string value);
        partial void OnnameChanged();
        /// <summary>
        /// There are no comments for Property modifiedDate in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.DateTime modifiedDate
        {
            get
            {
                return this._modifiedDate;
            }
            set
            {
                this.OnmodifiedDateChanging(value);
                this.ReportPropertyChanging("modifiedDate");
                this._modifiedDate = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("modifiedDate");
                this.OnmodifiedDateChanged();
            }
        }
        private global::System.DateTime _modifiedDate;
        partial void OnmodifiedDateChanging(global::System.DateTime value);
        partial void OnmodifiedDateChanged();
        /// <summary>
        /// There are no comments for VideoInstance in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmRelationshipNavigationPropertyAttribute("RawCatalogDBModel", "FK_VideoInstance_VideoEncoding", "VideoInstance")]
        [global::System.Xml.Serialization.XmlIgnoreAttribute()]
        [global::System.Xml.Serialization.SoapIgnoreAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Data.Objects.DataClasses.EntityCollection<VideoInstance> VideoInstance
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedCollection<VideoInstance>("RawCatalogDBModel.FK_VideoInstance_VideoEncoding", "VideoInstance");
            }
            set
            {
                if ((value != null))
                {
                    ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.InitializeRelatedCollection<VideoInstance>("RawCatalogDBModel.FK_VideoInstance_VideoEncoding", "VideoInstance", value);
                }
            }
        }
    }
    /// <summary>
    /// There are no comments for RawCatalogDBModel.VideoFile in the schema.
    /// </summary>
    /// <KeyProperties>
    /// videoFileid
    /// </KeyProperties>
    [global::System.Data.Objects.DataClasses.EdmEntityTypeAttribute(NamespaceName="RawCatalogDBModel", Name="VideoFile")]
    [global::System.Runtime.Serialization.DataContractAttribute(IsReference=true)]
    [global::System.Serializable()]
    public partial class VideoFile : global::System.Data.Objects.DataClasses.EntityObject
    {
        /// <summary>
        /// Create a new VideoFile object.
        /// </summary>
        /// <param name="videoFileid">Initial value of videoFileid.</param>
        /// <param name="size">Initial value of size.</param>
        /// <param name="fileIndex">Initial value of fileIndex.</param>
        /// <param name="modifiedDate">Initial value of modifiedDate.</param>
        public static VideoFile CreateVideoFile(global::System.Guid videoFileid, long size, int fileIndex, global::System.DateTime modifiedDate)
        {
            VideoFile videoFile = new VideoFile();
            videoFile.videoFileid = videoFileid;
            videoFile.size = size;
            videoFile.fileIndex = fileIndex;
            videoFile.modifiedDate = modifiedDate;
            return videoFile;
        }
        /// <summary>
        /// There are no comments for Property videoFileid in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(EntityKeyProperty=true, IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Guid videoFileid
        {
            get
            {
                return this._videoFileid;
            }
            set
            {
                this.OnvideoFileidChanging(value);
                this.ReportPropertyChanging("videoFileid");
                this._videoFileid = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("videoFileid");
                this.OnvideoFileidChanged();
            }
        }
        private global::System.Guid _videoFileid;
        partial void OnvideoFileidChanging(global::System.Guid value);
        partial void OnvideoFileidChanged();
        /// <summary>
        /// There are no comments for Property fileUrl in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public string fileUrl
        {
            get
            {
                return this._fileUrl;
            }
            set
            {
                this.OnfileUrlChanging(value);
                this.ReportPropertyChanging("fileUrl");
                this._fileUrl = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value, true);
                this.ReportPropertyChanged("fileUrl");
                this.OnfileUrlChanged();
            }
        }
        private string _fileUrl;
        partial void OnfileUrlChanging(string value);
        partial void OnfileUrlChanged();
        /// <summary>
        /// There are no comments for Property size in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public long size
        {
            get
            {
                return this._size;
            }
            set
            {
                this.OnsizeChanging(value);
                this.ReportPropertyChanging("size");
                this._size = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("size");
                this.OnsizeChanged();
            }
        }
        private long _size;
        partial void OnsizeChanging(long value);
        partial void OnsizeChanged();
        /// <summary>
        /// There are no comments for Property durationSecs in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Nullable<int> durationSecs
        {
            get
            {
                return this._durationSecs;
            }
            set
            {
                this.OndurationSecsChanging(value);
                this.ReportPropertyChanging("durationSecs");
                this._durationSecs = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("durationSecs");
                this.OndurationSecsChanged();
            }
        }
        private global::System.Nullable<int> _durationSecs;
        partial void OndurationSecsChanging(global::System.Nullable<int> value);
        partial void OndurationSecsChanged();
        /// <summary>
        /// There are no comments for Property fileIndex in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public int fileIndex
        {
            get
            {
                return this._fileIndex;
            }
            set
            {
                this.OnfileIndexChanging(value);
                this.ReportPropertyChanging("fileIndex");
                this._fileIndex = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("fileIndex");
                this.OnfileIndexChanged();
            }
        }
        private int _fileIndex;
        partial void OnfileIndexChanging(int value);
        partial void OnfileIndexChanged();
        /// <summary>
        /// There are no comments for Property modifiedDate in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.DateTime modifiedDate
        {
            get
            {
                return this._modifiedDate;
            }
            set
            {
                this.OnmodifiedDateChanging(value);
                this.ReportPropertyChanging("modifiedDate");
                this._modifiedDate = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("modifiedDate");
                this.OnmodifiedDateChanged();
            }
        }
        private global::System.DateTime _modifiedDate;
        partial void OnmodifiedDateChanging(global::System.DateTime value);
        partial void OnmodifiedDateChanged();
        /// <summary>
        /// There are no comments for VideoInstance in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmRelationshipNavigationPropertyAttribute("RawCatalogDBModel", "FK_VideoFile_VideoInstance", "VideoInstance")]
        [global::System.Xml.Serialization.XmlIgnoreAttribute()]
        [global::System.Xml.Serialization.SoapIgnoreAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public VideoInstance VideoInstance
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<VideoInstance>("RawCatalogDBModel.FK_VideoFile_VideoInstance", "VideoInstance").Value;
            }
            set
            {
                ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<VideoInstance>("RawCatalogDBModel.FK_VideoFile_VideoInstance", "VideoInstance").Value = value;
            }
        }
        /// <summary>
        /// There are no comments for VideoInstance in the schema.
        /// </summary>
        [global::System.ComponentModel.BrowsableAttribute(false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Data.Objects.DataClasses.EntityReference<VideoInstance> VideoInstanceReference
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<VideoInstance>("RawCatalogDBModel.FK_VideoFile_VideoInstance", "VideoInstance");
            }
            set
            {
                if ((value != null))
                {
                    ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.InitializeRelatedReference<VideoInstance>("RawCatalogDBModel.FK_VideoFile_VideoInstance", "VideoInstance", value);
                }
            }
        }
    }
    /// <summary>
    /// There are no comments for RawCatalogDBModel.VideoInstance in the schema.
    /// </summary>
    /// <KeyProperties>
    /// videoMediaInstanceId
    /// </KeyProperties>
    [global::System.Data.Objects.DataClasses.EdmEntityTypeAttribute(NamespaceName="RawCatalogDBModel", Name="VideoInstance")]
    [global::System.Runtime.Serialization.DataContractAttribute(IsReference=true)]
    [global::System.Serializable()]
    public partial class VideoInstance : global::System.Data.Objects.DataClasses.EntityObject
    {
        /// <summary>
        /// Create a new VideoInstance object.
        /// </summary>
        /// <param name="videoMediaInstanceId">Initial value of videoMediaInstanceId.</param>
        /// <param name="isDRM">Initial value of isDRM.</param>
        /// <param name="videoAspectRatio">Initial value of videoAspectRatio.</param>
        /// <param name="videoResolution">Initial value of videoResolution.</param>
        /// <param name="videoBitRate">Initial value of videoBitRate.</param>
        /// <param name="modifiedDate">Initial value of modifiedDate.</param>
        /// <param name="enabled">Initial value of enabled.</param>
        public static VideoInstance CreateVideoInstance(global::System.Guid videoMediaInstanceId, byte isDRM, string videoAspectRatio, string videoResolution, int videoBitRate, global::System.DateTime modifiedDate, byte enabled)
        {
            VideoInstance videoInstance = new VideoInstance();
            videoInstance.videoMediaInstanceId = videoMediaInstanceId;
            videoInstance.isDRM = isDRM;
            videoInstance.videoAspectRatio = videoAspectRatio;
            videoInstance.videoResolution = videoResolution;
            videoInstance.videoBitRate = videoBitRate;
            videoInstance.modifiedDate = modifiedDate;
            videoInstance.enabled = enabled;
            return videoInstance;
        }
        /// <summary>
        /// There are no comments for Property videoMediaInstanceId in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(EntityKeyProperty=true, IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Guid videoMediaInstanceId
        {
            get
            {
                return this._videoMediaInstanceId;
            }
            set
            {
                this.OnvideoMediaInstanceIdChanging(value);
                this.ReportPropertyChanging("videoMediaInstanceId");
                this._videoMediaInstanceId = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("videoMediaInstanceId");
                this.OnvideoMediaInstanceIdChanged();
            }
        }
        private global::System.Guid _videoMediaInstanceId;
        partial void OnvideoMediaInstanceIdChanging(global::System.Guid value);
        partial void OnvideoMediaInstanceIdChanged();
        /// <summary>
        /// There are no comments for Property isDRM in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public byte isDRM
        {
            get
            {
                return this._isDRM;
            }
            set
            {
                this.OnisDRMChanging(value);
                this.ReportPropertyChanging("isDRM");
                this._isDRM = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("isDRM");
                this.OnisDRMChanged();
            }
        }
        private byte _isDRM;
        partial void OnisDRMChanging(byte value);
        partial void OnisDRMChanged();
        /// <summary>
        /// There are no comments for Property audioChannel in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public string audioChannel
        {
            get
            {
                return this._audioChannel;
            }
            set
            {
                this.OnaudioChannelChanging(value);
                this.ReportPropertyChanging("audioChannel");
                this._audioChannel = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value, true);
                this.ReportPropertyChanged("audioChannel");
                this.OnaudioChannelChanged();
            }
        }
        private string _audioChannel;
        partial void OnaudioChannelChanging(string value);
        partial void OnaudioChannelChanged();
        /// <summary>
        /// There are no comments for Property audioSamplingRate in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Nullable<int> audioSamplingRate
        {
            get
            {
                return this._audioSamplingRate;
            }
            set
            {
                this.OnaudioSamplingRateChanging(value);
                this.ReportPropertyChanging("audioSamplingRate");
                this._audioSamplingRate = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("audioSamplingRate");
                this.OnaudioSamplingRateChanged();
            }
        }
        private global::System.Nullable<int> _audioSamplingRate;
        partial void OnaudioSamplingRateChanging(global::System.Nullable<int> value);
        partial void OnaudioSamplingRateChanged();
        /// <summary>
        /// There are no comments for Property audioCC in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Nullable<byte> audioCC
        {
            get
            {
                return this._audioCC;
            }
            set
            {
                this.OnaudioCCChanging(value);
                this.ReportPropertyChanging("audioCC");
                this._audioCC = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("audioCC");
                this.OnaudioCCChanged();
            }
        }
        private global::System.Nullable<byte> _audioCC;
        partial void OnaudioCCChanging(global::System.Nullable<byte> value);
        partial void OnaudioCCChanged();
        /// <summary>
        /// There are no comments for Property audioBitRate in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Nullable<int> audioBitRate
        {
            get
            {
                return this._audioBitRate;
            }
            set
            {
                this.OnaudioBitRateChanging(value);
                this.ReportPropertyChanging("audioBitRate");
                this._audioBitRate = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("audioBitRate");
                this.OnaudioBitRateChanged();
            }
        }
        private global::System.Nullable<int> _audioBitRate;
        partial void OnaudioBitRateChanging(global::System.Nullable<int> value);
        partial void OnaudioBitRateChanged();
        /// <summary>
        /// There are no comments for Property videoAspectRatio in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public string videoAspectRatio
        {
            get
            {
                return this._videoAspectRatio;
            }
            set
            {
                this.OnvideoAspectRatioChanging(value);
                this.ReportPropertyChanging("videoAspectRatio");
                this._videoAspectRatio = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value, false);
                this.ReportPropertyChanged("videoAspectRatio");
                this.OnvideoAspectRatioChanged();
            }
        }
        private string _videoAspectRatio;
        partial void OnvideoAspectRatioChanging(string value);
        partial void OnvideoAspectRatioChanged();
        /// <summary>
        /// There are no comments for Property videoResolution in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public string videoResolution
        {
            get
            {
                return this._videoResolution;
            }
            set
            {
                this.OnvideoResolutionChanging(value);
                this.ReportPropertyChanging("videoResolution");
                this._videoResolution = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value, false);
                this.ReportPropertyChanged("videoResolution");
                this.OnvideoResolutionChanged();
            }
        }
        private string _videoResolution;
        partial void OnvideoResolutionChanging(string value);
        partial void OnvideoResolutionChanged();
        /// <summary>
        /// There are no comments for Property videoBitRate in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public int videoBitRate
        {
            get
            {
                return this._videoBitRate;
            }
            set
            {
                this.OnvideoBitRateChanging(value);
                this.ReportPropertyChanging("videoBitRate");
                this._videoBitRate = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("videoBitRate");
                this.OnvideoBitRateChanged();
            }
        }
        private int _videoBitRate;
        partial void OnvideoBitRateChanging(int value);
        partial void OnvideoBitRateChanged();
        /// <summary>
        /// There are no comments for Property videoFrame in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Nullable<int> videoFrame
        {
            get
            {
                return this._videoFrame;
            }
            set
            {
                this.OnvideoFrameChanging(value);
                this.ReportPropertyChanging("videoFrame");
                this._videoFrame = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("videoFrame");
                this.OnvideoFrameChanged();
            }
        }
        private global::System.Nullable<int> _videoFrame;
        partial void OnvideoFrameChanging(global::System.Nullable<int> value);
        partial void OnvideoFrameChanged();
        /// <summary>
        /// There are no comments for Property modifiedDate in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.DateTime modifiedDate
        {
            get
            {
                return this._modifiedDate;
            }
            set
            {
                this.OnmodifiedDateChanging(value);
                this.ReportPropertyChanging("modifiedDate");
                this._modifiedDate = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("modifiedDate");
                this.OnmodifiedDateChanged();
            }
        }
        private global::System.DateTime _modifiedDate;
        partial void OnmodifiedDateChanging(global::System.DateTime value);
        partial void OnmodifiedDateChanged();
        /// <summary>
        /// There are no comments for Property enabled in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public byte enabled
        {
            get
            {
                return this._enabled;
            }
            set
            {
                this.OnenabledChanging(value);
                this.ReportPropertyChanging("enabled");
                this._enabled = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("enabled");
                this.OnenabledChanged();
            }
        }
        private byte _enabled;
        partial void OnenabledChanging(byte value);
        partial void OnenabledChanged();
        /// <summary>
        /// There are no comments for AudioEncoding in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmRelationshipNavigationPropertyAttribute("RawCatalogDBModel", "FK_VideoInstance_AudioEncoding", "AudioEncoding")]
        [global::System.Xml.Serialization.XmlIgnoreAttribute()]
        [global::System.Xml.Serialization.SoapIgnoreAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public AudioEncoding AudioEncoding
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<AudioEncoding>("RawCatalogDBModel.FK_VideoInstance_AudioEncoding", "AudioEncoding").Value;
            }
            set
            {
                ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<AudioEncoding>("RawCatalogDBModel.FK_VideoInstance_AudioEncoding", "AudioEncoding").Value = value;
            }
        }
        /// <summary>
        /// There are no comments for AudioEncoding in the schema.
        /// </summary>
        [global::System.ComponentModel.BrowsableAttribute(false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Data.Objects.DataClasses.EntityReference<AudioEncoding> AudioEncodingReference
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<AudioEncoding>("RawCatalogDBModel.FK_VideoInstance_AudioEncoding", "AudioEncoding");
            }
            set
            {
                if ((value != null))
                {
                    ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.InitializeRelatedReference<AudioEncoding>("RawCatalogDBModel.FK_VideoInstance_AudioEncoding", "AudioEncoding", value);
                }
            }
        }
        /// <summary>
        /// There are no comments for Locale in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmRelationshipNavigationPropertyAttribute("RawCatalogDBModel", "FK_VideoInstance_BurntInSubtitleLcid", "Locale")]
        [global::System.Xml.Serialization.XmlIgnoreAttribute()]
        [global::System.Xml.Serialization.SoapIgnoreAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public Locale Locale
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<Locale>("RawCatalogDBModel.FK_VideoInstance_BurntInSubtitleLcid", "Locale").Value;
            }
            set
            {
                ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<Locale>("RawCatalogDBModel.FK_VideoInstance_BurntInSubtitleLcid", "Locale").Value = value;
            }
        }
        /// <summary>
        /// There are no comments for Locale in the schema.
        /// </summary>
        [global::System.ComponentModel.BrowsableAttribute(false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Data.Objects.DataClasses.EntityReference<Locale> LocaleReference
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<Locale>("RawCatalogDBModel.FK_VideoInstance_BurntInSubtitleLcid", "Locale");
            }
            set
            {
                if ((value != null))
                {
                    ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.InitializeRelatedReference<Locale>("RawCatalogDBModel.FK_VideoInstance_BurntInSubtitleLcid", "Locale", value);
                }
            }
        }
        /// <summary>
        /// There are no comments for MediaInstance in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmRelationshipNavigationPropertyAttribute("RawCatalogDBModel", "FK_VideoInstance_MediaInstance", "MediaInstance")]
        [global::System.Xml.Serialization.XmlIgnoreAttribute()]
        [global::System.Xml.Serialization.SoapIgnoreAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public MediaInstance MediaInstance
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<MediaInstance>("RawCatalogDBModel.FK_VideoInstance_MediaInstance", "MediaInstance").Value;
            }
            set
            {
                ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<MediaInstance>("RawCatalogDBModel.FK_VideoInstance_MediaInstance", "MediaInstance").Value = value;
            }
        }
        /// <summary>
        /// There are no comments for MediaInstance in the schema.
        /// </summary>
        [global::System.ComponentModel.BrowsableAttribute(false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Data.Objects.DataClasses.EntityReference<MediaInstance> MediaInstanceReference
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<MediaInstance>("RawCatalogDBModel.FK_VideoInstance_MediaInstance", "MediaInstance");
            }
            set
            {
                if ((value != null))
                {
                    ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.InitializeRelatedReference<MediaInstance>("RawCatalogDBModel.FK_VideoInstance_MediaInstance", "MediaInstance", value);
                }
            }
        }
        /// <summary>
        /// There are no comments for VideoDefinition in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmRelationshipNavigationPropertyAttribute("RawCatalogDBModel", "FK_VideoInstance_VideoDefinition", "VideoDefinition")]
        [global::System.Xml.Serialization.XmlIgnoreAttribute()]
        [global::System.Xml.Serialization.SoapIgnoreAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public VideoDefinition VideoDefinition
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<VideoDefinition>("RawCatalogDBModel.FK_VideoInstance_VideoDefinition", "VideoDefinition").Value;
            }
            set
            {
                ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<VideoDefinition>("RawCatalogDBModel.FK_VideoInstance_VideoDefinition", "VideoDefinition").Value = value;
            }
        }
        /// <summary>
        /// There are no comments for VideoDefinition in the schema.
        /// </summary>
        [global::System.ComponentModel.BrowsableAttribute(false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Data.Objects.DataClasses.EntityReference<VideoDefinition> VideoDefinitionReference
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<VideoDefinition>("RawCatalogDBModel.FK_VideoInstance_VideoDefinition", "VideoDefinition");
            }
            set
            {
                if ((value != null))
                {
                    ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.InitializeRelatedReference<VideoDefinition>("RawCatalogDBModel.FK_VideoInstance_VideoDefinition", "VideoDefinition", value);
                }
            }
        }
        /// <summary>
        /// There are no comments for VideoEncoding in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmRelationshipNavigationPropertyAttribute("RawCatalogDBModel", "FK_VideoInstance_VideoEncoding", "VideoEncoding")]
        [global::System.Xml.Serialization.XmlIgnoreAttribute()]
        [global::System.Xml.Serialization.SoapIgnoreAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public VideoEncoding VideoEncoding
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<VideoEncoding>("RawCatalogDBModel.FK_VideoInstance_VideoEncoding", "VideoEncoding").Value;
            }
            set
            {
                ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<VideoEncoding>("RawCatalogDBModel.FK_VideoInstance_VideoEncoding", "VideoEncoding").Value = value;
            }
        }
        /// <summary>
        /// There are no comments for VideoEncoding in the schema.
        /// </summary>
        [global::System.ComponentModel.BrowsableAttribute(false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Data.Objects.DataClasses.EntityReference<VideoEncoding> VideoEncodingReference
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<VideoEncoding>("RawCatalogDBModel.FK_VideoInstance_VideoEncoding", "VideoEncoding");
            }
            set
            {
                if ((value != null))
                {
                    ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.InitializeRelatedReference<VideoEncoding>("RawCatalogDBModel.FK_VideoInstance_VideoEncoding", "VideoEncoding", value);
                }
            }
        }
        /// <summary>
        /// There are no comments for VideoFile in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmRelationshipNavigationPropertyAttribute("RawCatalogDBModel", "FK_VideoFile_VideoInstance", "VideoFile")]
        [global::System.Xml.Serialization.XmlIgnoreAttribute()]
        [global::System.Xml.Serialization.SoapIgnoreAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Data.Objects.DataClasses.EntityCollection<VideoFile> VideoFile
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedCollection<VideoFile>("RawCatalogDBModel.FK_VideoFile_VideoInstance", "VideoFile");
            }
            set
            {
                if ((value != null))
                {
                    ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.InitializeRelatedCollection<VideoFile>("RawCatalogDBModel.FK_VideoFile_VideoInstance", "VideoFile", value);
                }
            }
        }
    }
    /// <summary>
    /// There are no comments for RawCatalogDBModel.VisibilityLevel in the schema.
    /// </summary>
    /// <KeyProperties>
    /// visibilityLevelId
    /// </KeyProperties>
    [global::System.Data.Objects.DataClasses.EdmEntityTypeAttribute(NamespaceName="RawCatalogDBModel", Name="VisibilityLevel")]
    [global::System.Runtime.Serialization.DataContractAttribute(IsReference=true)]
    [global::System.Serializable()]
    public partial class VisibilityLevel : global::System.Data.Objects.DataClasses.EntityObject
    {
        /// <summary>
        /// Create a new VisibilityLevel object.
        /// </summary>
        /// <param name="visibilityLevelId">Initial value of visibilityLevelId.</param>
        /// <param name="name">Initial value of name.</param>
        /// <param name="modifiedDate">Initial value of modifiedDate.</param>
        public static VisibilityLevel CreateVisibilityLevel(int visibilityLevelId, string name, global::System.DateTime modifiedDate)
        {
            VisibilityLevel visibilityLevel = new VisibilityLevel();
            visibilityLevel.visibilityLevelId = visibilityLevelId;
            visibilityLevel.name = name;
            visibilityLevel.modifiedDate = modifiedDate;
            return visibilityLevel;
        }
        /// <summary>
        /// There are no comments for Property visibilityLevelId in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(EntityKeyProperty=true, IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public int visibilityLevelId
        {
            get
            {
                return this._visibilityLevelId;
            }
            set
            {
                this.OnvisibilityLevelIdChanging(value);
                this.ReportPropertyChanging("visibilityLevelId");
                this._visibilityLevelId = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("visibilityLevelId");
                this.OnvisibilityLevelIdChanged();
            }
        }
        private int _visibilityLevelId;
        partial void OnvisibilityLevelIdChanging(int value);
        partial void OnvisibilityLevelIdChanged();
        /// <summary>
        /// There are no comments for Property name in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public string name
        {
            get
            {
                return this._name;
            }
            set
            {
                this.OnnameChanging(value);
                this.ReportPropertyChanging("name");
                this._name = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value, false);
                this.ReportPropertyChanged("name");
                this.OnnameChanged();
            }
        }
        private string _name;
        partial void OnnameChanging(string value);
        partial void OnnameChanged();
        /// <summary>
        /// There are no comments for Property modifiedDate in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.DateTime modifiedDate
        {
            get
            {
                return this._modifiedDate;
            }
            set
            {
                this.OnmodifiedDateChanging(value);
                this.ReportPropertyChanging("modifiedDate");
                this._modifiedDate = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("modifiedDate");
                this.OnmodifiedDateChanged();
            }
        }
        private global::System.DateTime _modifiedDate;
        partial void OnmodifiedDateChanging(global::System.DateTime value);
        partial void OnmodifiedDateChanged();
        /// <summary>
        /// There are no comments for OfferInstance in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmRelationshipNavigationPropertyAttribute("RawCatalogDBModel", "FK_OfferInstance_VisibilityLevel", "OfferInstance")]
        [global::System.Xml.Serialization.XmlIgnoreAttribute()]
        [global::System.Xml.Serialization.SoapIgnoreAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Data.Objects.DataClasses.EntityCollection<OfferInstance> OfferInstance
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedCollection<OfferInstance>("RawCatalogDBModel.FK_OfferInstance_VisibilityLevel", "OfferInstance");
            }
            set
            {
                if ((value != null))
                {
                    ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.InitializeRelatedCollection<OfferInstance>("RawCatalogDBModel.FK_OfferInstance_VisibilityLevel", "OfferInstance", value);
                }
            }
        }
    }
    /// <summary>
    /// There are no comments for RawCatalogDBModel.VisibilityStatus in the schema.
    /// </summary>
    /// <KeyProperties>
    /// visibilityStatusId
    /// </KeyProperties>
    [global::System.Data.Objects.DataClasses.EdmEntityTypeAttribute(NamespaceName="RawCatalogDBModel", Name="VisibilityStatus")]
    [global::System.Runtime.Serialization.DataContractAttribute(IsReference=true)]
    [global::System.Serializable()]
    public partial class VisibilityStatus : global::System.Data.Objects.DataClasses.EntityObject
    {
        /// <summary>
        /// Create a new VisibilityStatus object.
        /// </summary>
        /// <param name="visibilityStatusId">Initial value of visibilityStatusId.</param>
        /// <param name="name">Initial value of name.</param>
        /// <param name="modifiedDate">Initial value of modifiedDate.</param>
        public static VisibilityStatus CreateVisibilityStatus(int visibilityStatusId, string name, global::System.DateTime modifiedDate)
        {
            VisibilityStatus visibilityStatus = new VisibilityStatus();
            visibilityStatus.visibilityStatusId = visibilityStatusId;
            visibilityStatus.name = name;
            visibilityStatus.modifiedDate = modifiedDate;
            return visibilityStatus;
        }
        /// <summary>
        /// There are no comments for Property visibilityStatusId in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(EntityKeyProperty=true, IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public int visibilityStatusId
        {
            get
            {
                return this._visibilityStatusId;
            }
            set
            {
                this.OnvisibilityStatusIdChanging(value);
                this.ReportPropertyChanging("visibilityStatusId");
                this._visibilityStatusId = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("visibilityStatusId");
                this.OnvisibilityStatusIdChanged();
            }
        }
        private int _visibilityStatusId;
        partial void OnvisibilityStatusIdChanging(int value);
        partial void OnvisibilityStatusIdChanged();
        /// <summary>
        /// There are no comments for Property name in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public string name
        {
            get
            {
                return this._name;
            }
            set
            {
                this.OnnameChanging(value);
                this.ReportPropertyChanging("name");
                this._name = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value, false);
                this.ReportPropertyChanged("name");
                this.OnnameChanged();
            }
        }
        private string _name;
        partial void OnnameChanging(string value);
        partial void OnnameChanged();
        /// <summary>
        /// There are no comments for Property modifiedDate in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.DateTime modifiedDate
        {
            get
            {
                return this._modifiedDate;
            }
            set
            {
                this.OnmodifiedDateChanging(value);
                this.ReportPropertyChanging("modifiedDate");
                this._modifiedDate = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("modifiedDate");
                this.OnmodifiedDateChanged();
            }
        }
        private global::System.DateTime _modifiedDate;
        partial void OnmodifiedDateChanging(global::System.DateTime value);
        partial void OnmodifiedDateChanged();
        /// <summary>
        /// There are no comments for Media in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmRelationshipNavigationPropertyAttribute("RawCatalogDBModel", "FK_Media_VisibilityStatus", "Media")]
        [global::System.Xml.Serialization.XmlIgnoreAttribute()]
        [global::System.Xml.Serialization.SoapIgnoreAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Data.Objects.DataClasses.EntityCollection<Media> Media
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedCollection<Media>("RawCatalogDBModel.FK_Media_VisibilityStatus", "Media");
            }
            set
            {
                if ((value != null))
                {
                    ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.InitializeRelatedCollection<Media>("RawCatalogDBModel.FK_Media_VisibilityStatus", "Media", value);
                }
            }
        }
        /// <summary>
        /// There are no comments for OfferInstanceMedia in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmRelationshipNavigationPropertyAttribute("RawCatalogDBModel", "FK_OfferInstanceMedia_VisibilityStatus", "OfferInstanceMedia")]
        [global::System.Xml.Serialization.XmlIgnoreAttribute()]
        [global::System.Xml.Serialization.SoapIgnoreAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Data.Objects.DataClasses.EntityCollection<OfferInstanceMedia> OfferInstanceMedia
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedCollection<OfferInstanceMedia>("RawCatalogDBModel.FK_OfferInstanceMedia_VisibilityStatus", "OfferInstanceMedia");
            }
            set
            {
                if ((value != null))
                {
                    ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.InitializeRelatedCollection<OfferInstanceMedia>("RawCatalogDBModel.FK_OfferInstanceMedia_VisibilityStatus", "OfferInstanceMedia", value);
                }
            }
        }
        /// <summary>
        /// There are no comments for OfferInstanceMediaInstance in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmRelationshipNavigationPropertyAttribute("RawCatalogDBModel", "FK_OfferInstanceMediaInstance_VisibilityStatus", "OfferInstanceMediaInstance")]
        [global::System.Xml.Serialization.XmlIgnoreAttribute()]
        [global::System.Xml.Serialization.SoapIgnoreAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Data.Objects.DataClasses.EntityCollection<OfferInstanceMediaInstance> OfferInstanceMediaInstance
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedCollection<OfferInstanceMediaInstance>("RawCatalogDBModel.FK_OfferInstanceMediaInstance_VisibilityStatus", "OfferInstanceMediaInstance");
            }
            set
            {
                if ((value != null))
                {
                    ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.InitializeRelatedCollection<OfferInstanceMediaInstance>("RawCatalogDBModel.FK_OfferInstanceMediaInstance_VisibilityStatus", "OfferInstanceMediaInstance", value);
                }
            }
        }
    }
    /// <summary>
    /// There are no comments for RawCatalogDBModel.LegacyOfferMapping in the schema.
    /// </summary>
    /// <KeyProperties>
    /// offerId
    /// </KeyProperties>
    [global::System.Data.Objects.DataClasses.EdmEntityTypeAttribute(NamespaceName="RawCatalogDBModel", Name="LegacyOfferMapping")]
    [global::System.Runtime.Serialization.DataContractAttribute(IsReference=true)]
    [global::System.Serializable()]
    public partial class LegacyOfferMapping : global::System.Data.Objects.DataClasses.EntityObject
    {
        /// <summary>
        /// Create a new LegacyOfferMapping object.
        /// </summary>
        /// <param name="offerId">Initial value of offerId.</param>
        /// <param name="liveOfferId">Initial value of liveOfferId.</param>
        /// <param name="modifiedDate">Initial value of modifiedDate.</param>
        public static LegacyOfferMapping CreateLegacyOfferMapping(global::System.Guid offerId, long liveOfferId, global::System.DateTime modifiedDate)
        {
            LegacyOfferMapping legacyOfferMapping = new LegacyOfferMapping();
            legacyOfferMapping.offerId = offerId;
            legacyOfferMapping.liveOfferId = liveOfferId;
            legacyOfferMapping.modifiedDate = modifiedDate;
            return legacyOfferMapping;
        }
        /// <summary>
        /// There are no comments for Property offerId in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(EntityKeyProperty=true, IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Guid offerId
        {
            get
            {
                return this._offerId;
            }
            set
            {
                this.OnofferIdChanging(value);
                this.ReportPropertyChanging("offerId");
                this._offerId = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("offerId");
                this.OnofferIdChanged();
            }
        }
        private global::System.Guid _offerId;
        partial void OnofferIdChanging(global::System.Guid value);
        partial void OnofferIdChanged();
        /// <summary>
        /// There are no comments for Property liveOfferId in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public long liveOfferId
        {
            get
            {
                return this._liveOfferId;
            }
            set
            {
                this.OnliveOfferIdChanging(value);
                this.ReportPropertyChanging("liveOfferId");
                this._liveOfferId = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("liveOfferId");
                this.OnliveOfferIdChanged();
            }
        }
        private long _liveOfferId;
        partial void OnliveOfferIdChanging(long value);
        partial void OnliveOfferIdChanged();
        /// <summary>
        /// There are no comments for Property modifiedDate in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.DateTime modifiedDate
        {
            get
            {
                return this._modifiedDate;
            }
            set
            {
                this.OnmodifiedDateChanging(value);
                this.ReportPropertyChanging("modifiedDate");
                this._modifiedDate = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("modifiedDate");
                this.OnmodifiedDateChanged();
            }
        }
        private global::System.DateTime _modifiedDate;
        partial void OnmodifiedDateChanging(global::System.DateTime value);
        partial void OnmodifiedDateChanged();
        /// <summary>
        /// There are no comments for Offer in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmRelationshipNavigationPropertyAttribute("RawCatalogDBModel", "FK_LegacyOfferMapping_Offer", "Offer")]
        [global::System.Xml.Serialization.XmlIgnoreAttribute()]
        [global::System.Xml.Serialization.SoapIgnoreAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public Offer Offer
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<Offer>("RawCatalogDBModel.FK_LegacyOfferMapping_Offer", "Offer").Value;
            }
            set
            {
                ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<Offer>("RawCatalogDBModel.FK_LegacyOfferMapping_Offer", "Offer").Value = value;
            }
        }
        /// <summary>
        /// There are no comments for Offer in the schema.
        /// </summary>
        [global::System.ComponentModel.BrowsableAttribute(false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Data.Objects.DataClasses.EntityReference<Offer> OfferReference
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<Offer>("RawCatalogDBModel.FK_LegacyOfferMapping_Offer", "Offer");
            }
            set
            {
                if ((value != null))
                {
                    ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.InitializeRelatedReference<Offer>("RawCatalogDBModel.FK_LegacyOfferMapping_Offer", "Offer", value);
                }
            }
        }
    }
    /// <summary>
    /// There are no comments for RawCatalogDBModel.App in the schema.
    /// </summary>
    /// <KeyProperties>
    /// appMediaId
    /// </KeyProperties>
    [global::System.Data.Objects.DataClasses.EdmEntityTypeAttribute(NamespaceName="RawCatalogDBModel", Name="App")]
    [global::System.Runtime.Serialization.DataContractAttribute(IsReference=true)]
    [global::System.Serializable()]
    public partial class App : global::System.Data.Objects.DataClasses.EntityObject
    {
        /// <summary>
        /// Create a new App object.
        /// </summary>
        /// <param name="appMediaId">Initial value of appMediaId.</param>
        /// <param name="liveTitleId">Initial value of liveTitleId.</param>
        /// <param name="modifiedDate">Initial value of modifiedDate.</param>
        public static App CreateApp(global::System.Guid appMediaId, int liveTitleId, global::System.DateTime modifiedDate)
        {
            App app = new App();
            app.appMediaId = appMediaId;
            app.liveTitleId = liveTitleId;
            app.modifiedDate = modifiedDate;
            return app;
        }
        /// <summary>
        /// There are no comments for Property appMediaId in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(EntityKeyProperty=true, IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Guid appMediaId
        {
            get
            {
                return this._appMediaId;
            }
            set
            {
                this.OnappMediaIdChanging(value);
                this.ReportPropertyChanging("appMediaId");
                this._appMediaId = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("appMediaId");
                this.OnappMediaIdChanged();
            }
        }
        private global::System.Guid _appMediaId;
        partial void OnappMediaIdChanging(global::System.Guid value);
        partial void OnappMediaIdChanged();
        /// <summary>
        /// There are no comments for Property liveTitleId in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public int liveTitleId
        {
            get
            {
                return this._liveTitleId;
            }
            set
            {
                this.OnliveTitleIdChanging(value);
                this.ReportPropertyChanging("liveTitleId");
                this._liveTitleId = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("liveTitleId");
                this.OnliveTitleIdChanged();
            }
        }
        private int _liveTitleId;
        partial void OnliveTitleIdChanging(int value);
        partial void OnliveTitleIdChanged();
        /// <summary>
        /// There are no comments for Property modifiedDate in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.DateTime modifiedDate
        {
            get
            {
                return this._modifiedDate;
            }
            set
            {
                this.OnmodifiedDateChanging(value);
                this.ReportPropertyChanging("modifiedDate");
                this._modifiedDate = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("modifiedDate");
                this.OnmodifiedDateChanged();
            }
        }
        private global::System.DateTime _modifiedDate;
        partial void OnmodifiedDateChanging(global::System.DateTime value);
        partial void OnmodifiedDateChanged();
        /// <summary>
        /// There are no comments for Media in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmRelationshipNavigationPropertyAttribute("RawCatalogDBModel", "FK_App_Media", "Media")]
        [global::System.Xml.Serialization.XmlIgnoreAttribute()]
        [global::System.Xml.Serialization.SoapIgnoreAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public Media Media
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<Media>("RawCatalogDBModel.FK_App_Media", "Media").Value;
            }
            set
            {
                ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<Media>("RawCatalogDBModel.FK_App_Media", "Media").Value = value;
            }
        }
        /// <summary>
        /// There are no comments for Media in the schema.
        /// </summary>
        [global::System.ComponentModel.BrowsableAttribute(false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Data.Objects.DataClasses.EntityReference<Media> MediaReference
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<Media>("RawCatalogDBModel.FK_App_Media", "Media");
            }
            set
            {
                if ((value != null))
                {
                    ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.InitializeRelatedReference<Media>("RawCatalogDBModel.FK_App_Media", "Media", value);
                }
            }
        }
        /// <summary>
        /// There are no comments for AppAppType in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmRelationshipNavigationPropertyAttribute("RawCatalogDBModel", "FK_AppAppType_App", "AppAppType")]
        [global::System.Xml.Serialization.XmlIgnoreAttribute()]
        [global::System.Xml.Serialization.SoapIgnoreAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Data.Objects.DataClasses.EntityCollection<AppAppType> AppAppType
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedCollection<AppAppType>("RawCatalogDBModel.FK_AppAppType_App", "AppAppType");
            }
            set
            {
                if ((value != null))
                {
                    ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.InitializeRelatedCollection<AppAppType>("RawCatalogDBModel.FK_AppAppType_App", "AppAppType", value);
                }
            }
        }
        /// <summary>
        /// There are no comments for AppLocale in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmRelationshipNavigationPropertyAttribute("RawCatalogDBModel", "FK_AppLocale_App", "AppLocale")]
        [global::System.Xml.Serialization.XmlIgnoreAttribute()]
        [global::System.Xml.Serialization.SoapIgnoreAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Data.Objects.DataClasses.EntityCollection<AppLocale> AppLocale
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedCollection<AppLocale>("RawCatalogDBModel.FK_AppLocale_App", "AppLocale");
            }
            set
            {
                if ((value != null))
                {
                    ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.InitializeRelatedCollection<AppLocale>("RawCatalogDBModel.FK_AppLocale_App", "AppLocale", value);
                }
            }
        }
    }
    /// <summary>
    /// There are no comments for RawCatalogDBModel.AppAppType in the schema.
    /// </summary>
    /// <KeyProperties>
    /// appMediaId
    /// appTypeId
    /// </KeyProperties>
    [global::System.Data.Objects.DataClasses.EdmEntityTypeAttribute(NamespaceName="RawCatalogDBModel", Name="AppAppType")]
    [global::System.Runtime.Serialization.DataContractAttribute(IsReference=true)]
    [global::System.Serializable()]
    public partial class AppAppType : global::System.Data.Objects.DataClasses.EntityObject
    {
        /// <summary>
        /// Create a new AppAppType object.
        /// </summary>
        /// <param name="appMediaId">Initial value of appMediaId.</param>
        /// <param name="appTypeId">Initial value of appTypeId.</param>
        /// <param name="modifiedDate">Initial value of modifiedDate.</param>
        public static AppAppType CreateAppAppType(global::System.Guid appMediaId, int appTypeId, global::System.DateTime modifiedDate)
        {
            AppAppType appAppType = new AppAppType();
            appAppType.appMediaId = appMediaId;
            appAppType.appTypeId = appTypeId;
            appAppType.modifiedDate = modifiedDate;
            return appAppType;
        }
        /// <summary>
        /// There are no comments for Property appMediaId in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(EntityKeyProperty=true, IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Guid appMediaId
        {
            get
            {
                return this._appMediaId;
            }
            set
            {
                this.OnappMediaIdChanging(value);
                this.ReportPropertyChanging("appMediaId");
                this._appMediaId = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("appMediaId");
                this.OnappMediaIdChanged();
            }
        }
        private global::System.Guid _appMediaId;
        partial void OnappMediaIdChanging(global::System.Guid value);
        partial void OnappMediaIdChanged();
        /// <summary>
        /// There are no comments for Property appTypeId in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(EntityKeyProperty=true, IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public int appTypeId
        {
            get
            {
                return this._appTypeId;
            }
            set
            {
                this.OnappTypeIdChanging(value);
                this.ReportPropertyChanging("appTypeId");
                this._appTypeId = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("appTypeId");
                this.OnappTypeIdChanged();
            }
        }
        private int _appTypeId;
        partial void OnappTypeIdChanging(int value);
        partial void OnappTypeIdChanged();
        /// <summary>
        /// There are no comments for Property modifiedDate in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.DateTime modifiedDate
        {
            get
            {
                return this._modifiedDate;
            }
            set
            {
                this.OnmodifiedDateChanging(value);
                this.ReportPropertyChanging("modifiedDate");
                this._modifiedDate = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("modifiedDate");
                this.OnmodifiedDateChanged();
            }
        }
        private global::System.DateTime _modifiedDate;
        partial void OnmodifiedDateChanging(global::System.DateTime value);
        partial void OnmodifiedDateChanged();
        /// <summary>
        /// There are no comments for App in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmRelationshipNavigationPropertyAttribute("RawCatalogDBModel", "FK_AppAppType_App", "App")]
        [global::System.Xml.Serialization.XmlIgnoreAttribute()]
        [global::System.Xml.Serialization.SoapIgnoreAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public App App
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<App>("RawCatalogDBModel.FK_AppAppType_App", "App").Value;
            }
            set
            {
                ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<App>("RawCatalogDBModel.FK_AppAppType_App", "App").Value = value;
            }
        }
        /// <summary>
        /// There are no comments for App in the schema.
        /// </summary>
        [global::System.ComponentModel.BrowsableAttribute(false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Data.Objects.DataClasses.EntityReference<App> AppReference
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<App>("RawCatalogDBModel.FK_AppAppType_App", "App");
            }
            set
            {
                if ((value != null))
                {
                    ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.InitializeRelatedReference<App>("RawCatalogDBModel.FK_AppAppType_App", "App", value);
                }
            }
        }
        /// <summary>
        /// There are no comments for AppType in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmRelationshipNavigationPropertyAttribute("RawCatalogDBModel", "FK_AppAppType_AppType", "AppType")]
        [global::System.Xml.Serialization.XmlIgnoreAttribute()]
        [global::System.Xml.Serialization.SoapIgnoreAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public AppType AppType
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<AppType>("RawCatalogDBModel.FK_AppAppType_AppType", "AppType").Value;
            }
            set
            {
                ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<AppType>("RawCatalogDBModel.FK_AppAppType_AppType", "AppType").Value = value;
            }
        }
        /// <summary>
        /// There are no comments for AppType in the schema.
        /// </summary>
        [global::System.ComponentModel.BrowsableAttribute(false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Data.Objects.DataClasses.EntityReference<AppType> AppTypeReference
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<AppType>("RawCatalogDBModel.FK_AppAppType_AppType", "AppType");
            }
            set
            {
                if ((value != null))
                {
                    ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.InitializeRelatedReference<AppType>("RawCatalogDBModel.FK_AppAppType_AppType", "AppType", value);
                }
            }
        }
    }
    /// <summary>
    /// There are no comments for RawCatalogDBModel.AppInstance in the schema.
    /// </summary>
    /// <KeyProperties>
    /// appInstanceId
    /// </KeyProperties>
    [global::System.Data.Objects.DataClasses.EdmEntityTypeAttribute(NamespaceName="RawCatalogDBModel", Name="AppInstance")]
    [global::System.Runtime.Serialization.DataContractAttribute(IsReference=true)]
    [global::System.Serializable()]
    public partial class AppInstance : global::System.Data.Objects.DataClasses.EntityObject
    {
        /// <summary>
        /// Create a new AppInstance object.
        /// </summary>
        /// <param name="appInstanceId">Initial value of appInstanceId.</param>
        /// <param name="installSize">Initial value of installSize.</param>
        /// <param name="packageSize">Initial value of packageSize.</param>
        /// <param name="liveContentId">Initial value of liveContentId.</param>
        /// <param name="modifiedDate">Initial value of modifiedDate.</param>
        public static AppInstance CreateAppInstance(global::System.Guid appInstanceId, long installSize, long packageSize, byte[] liveContentId, global::System.DateTime modifiedDate)
        {
            AppInstance appInstance = new AppInstance();
            appInstance.appInstanceId = appInstanceId;
            appInstance.installSize = installSize;
            appInstance.packageSize = packageSize;
            appInstance.liveContentId = liveContentId;
            appInstance.modifiedDate = modifiedDate;
            return appInstance;
        }
        /// <summary>
        /// There are no comments for Property appInstanceId in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(EntityKeyProperty=true, IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Guid appInstanceId
        {
            get
            {
                return this._appInstanceId;
            }
            set
            {
                this.OnappInstanceIdChanging(value);
                this.ReportPropertyChanging("appInstanceId");
                this._appInstanceId = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("appInstanceId");
                this.OnappInstanceIdChanged();
            }
        }
        private global::System.Guid _appInstanceId;
        partial void OnappInstanceIdChanging(global::System.Guid value);
        partial void OnappInstanceIdChanged();
        /// <summary>
        /// There are no comments for Property installSize in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public long installSize
        {
            get
            {
                return this._installSize;
            }
            set
            {
                this.OninstallSizeChanging(value);
                this.ReportPropertyChanging("installSize");
                this._installSize = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("installSize");
                this.OninstallSizeChanged();
            }
        }
        private long _installSize;
        partial void OninstallSizeChanging(long value);
        partial void OninstallSizeChanged();
        /// <summary>
        /// There are no comments for Property packageSize in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public long packageSize
        {
            get
            {
                return this._packageSize;
            }
            set
            {
                this.OnpackageSizeChanging(value);
                this.ReportPropertyChanging("packageSize");
                this._packageSize = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("packageSize");
                this.OnpackageSizeChanged();
            }
        }
        private long _packageSize;
        partial void OnpackageSizeChanging(long value);
        partial void OnpackageSizeChanged();
        /// <summary>
        /// There are no comments for Property liveContentId in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public byte[] liveContentId
        {
            get
            {
                return global::System.Data.Objects.DataClasses.StructuralObject.GetValidValue(this._liveContentId);
            }
            set
            {
                this.OnliveContentIdChanging(value);
                this.ReportPropertyChanging("liveContentId");
                this._liveContentId = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value, false);
                this.ReportPropertyChanged("liveContentId");
                this.OnliveContentIdChanged();
            }
        }
        private byte[] _liveContentId;
        partial void OnliveContentIdChanging(byte[] value);
        partial void OnliveContentIdChanged();
        /// <summary>
        /// There are no comments for Property modifiedDate in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.DateTime modifiedDate
        {
            get
            {
                return this._modifiedDate;
            }
            set
            {
                this.OnmodifiedDateChanging(value);
                this.ReportPropertyChanging("modifiedDate");
                this._modifiedDate = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("modifiedDate");
                this.OnmodifiedDateChanged();
            }
        }
        private global::System.DateTime _modifiedDate;
        partial void OnmodifiedDateChanging(global::System.DateTime value);
        partial void OnmodifiedDateChanged();
        /// <summary>
        /// There are no comments for MediaInstance in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmRelationshipNavigationPropertyAttribute("RawCatalogDBModel", "FK_AppInstance_MediaInstance", "MediaInstance")]
        [global::System.Xml.Serialization.XmlIgnoreAttribute()]
        [global::System.Xml.Serialization.SoapIgnoreAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public MediaInstance MediaInstance
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<MediaInstance>("RawCatalogDBModel.FK_AppInstance_MediaInstance", "MediaInstance").Value;
            }
            set
            {
                ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<MediaInstance>("RawCatalogDBModel.FK_AppInstance_MediaInstance", "MediaInstance").Value = value;
            }
        }
        /// <summary>
        /// There are no comments for MediaInstance in the schema.
        /// </summary>
        [global::System.ComponentModel.BrowsableAttribute(false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Data.Objects.DataClasses.EntityReference<MediaInstance> MediaInstanceReference
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<MediaInstance>("RawCatalogDBModel.FK_AppInstance_MediaInstance", "MediaInstance");
            }
            set
            {
                if ((value != null))
                {
                    ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.InitializeRelatedReference<MediaInstance>("RawCatalogDBModel.FK_AppInstance_MediaInstance", "MediaInstance", value);
                }
            }
        }
        /// <summary>
        /// There are no comments for PackageType in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmRelationshipNavigationPropertyAttribute("RawCatalogDBModel", "FK_AppInstance_PackageType", "PackageType")]
        [global::System.Xml.Serialization.XmlIgnoreAttribute()]
        [global::System.Xml.Serialization.SoapIgnoreAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public PackageType PackageType
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<PackageType>("RawCatalogDBModel.FK_AppInstance_PackageType", "PackageType").Value;
            }
            set
            {
                ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<PackageType>("RawCatalogDBModel.FK_AppInstance_PackageType", "PackageType").Value = value;
            }
        }
        /// <summary>
        /// There are no comments for PackageType in the schema.
        /// </summary>
        [global::System.ComponentModel.BrowsableAttribute(false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Data.Objects.DataClasses.EntityReference<PackageType> PackageTypeReference
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<PackageType>("RawCatalogDBModel.FK_AppInstance_PackageType", "PackageType");
            }
            set
            {
                if ((value != null))
                {
                    ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.InitializeRelatedReference<PackageType>("RawCatalogDBModel.FK_AppInstance_PackageType", "PackageType", value);
                }
            }
        }
        /// <summary>
        /// There are no comments for AppInstanceEncryptedKey in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmRelationshipNavigationPropertyAttribute("RawCatalogDBModel", "FK_AppInstanceEncryptedKey_AppInstance", "AppInstanceEncryptedKey")]
        [global::System.Xml.Serialization.XmlIgnoreAttribute()]
        [global::System.Xml.Serialization.SoapIgnoreAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public AppInstanceEncryptedKey AppInstanceEncryptedKey
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<AppInstanceEncryptedKey>("RawCatalogDBModel.FK_AppInstanceEncryptedKey_AppInstance", "AppInstanceEncryptedKey").Value;
            }
            set
            {
                ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<AppInstanceEncryptedKey>("RawCatalogDBModel.FK_AppInstanceEncryptedKey_AppInstance", "AppInstanceEncryptedKey").Value = value;
            }
        }
        /// <summary>
        /// There are no comments for AppInstanceEncryptedKey in the schema.
        /// </summary>
        [global::System.ComponentModel.BrowsableAttribute(false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Data.Objects.DataClasses.EntityReference<AppInstanceEncryptedKey> AppInstanceEncryptedKeyReference
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<AppInstanceEncryptedKey>("RawCatalogDBModel.FK_AppInstanceEncryptedKey_AppInstance", "AppInstanceEncryptedKey");
            }
            set
            {
                if ((value != null))
                {
                    ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.InitializeRelatedReference<AppInstanceEncryptedKey>("RawCatalogDBModel.FK_AppInstanceEncryptedKey_AppInstance", "AppInstanceEncryptedKey", value);
                }
            }
        }
        /// <summary>
        /// There are no comments for AppInstanceFile in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmRelationshipNavigationPropertyAttribute("RawCatalogDBModel", "FK_AppInstanceFile_AppInstance", "AppInstanceFile")]
        [global::System.Xml.Serialization.XmlIgnoreAttribute()]
        [global::System.Xml.Serialization.SoapIgnoreAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Data.Objects.DataClasses.EntityCollection<AppInstanceFile> AppInstanceFile
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedCollection<AppInstanceFile>("RawCatalogDBModel.FK_AppInstanceFile_AppInstance", "AppInstanceFile");
            }
            set
            {
                if ((value != null))
                {
                    ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.InitializeRelatedCollection<AppInstanceFile>("RawCatalogDBModel.FK_AppInstanceFile_AppInstance", "AppInstanceFile", value);
                }
            }
        }
    }
    /// <summary>
    /// There are no comments for RawCatalogDBModel.AppInstanceEncryptedKey in the schema.
    /// </summary>
    /// <KeyProperties>
    /// appInstanceId
    /// </KeyProperties>
    [global::System.Data.Objects.DataClasses.EdmEntityTypeAttribute(NamespaceName="RawCatalogDBModel", Name="AppInstanceEncryptedKey")]
    [global::System.Runtime.Serialization.DataContractAttribute(IsReference=true)]
    [global::System.Serializable()]
    public partial class AppInstanceEncryptedKey : global::System.Data.Objects.DataClasses.EntityObject
    {
        /// <summary>
        /// Create a new AppInstanceEncryptedKey object.
        /// </summary>
        /// <param name="appInstanceId">Initial value of appInstanceId.</param>
        /// <param name="modifiedDate">Initial value of modifiedDate.</param>
        public static AppInstanceEncryptedKey CreateAppInstanceEncryptedKey(global::System.Guid appInstanceId, global::System.DateTime modifiedDate)
        {
            AppInstanceEncryptedKey appInstanceEncryptedKey = new AppInstanceEncryptedKey();
            appInstanceEncryptedKey.appInstanceId = appInstanceId;
            appInstanceEncryptedKey.modifiedDate = modifiedDate;
            return appInstanceEncryptedKey;
        }
        /// <summary>
        /// There are no comments for Property appInstanceId in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(EntityKeyProperty=true, IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Guid appInstanceId
        {
            get
            {
                return this._appInstanceId;
            }
            set
            {
                this.OnappInstanceIdChanging(value);
                this.ReportPropertyChanging("appInstanceId");
                this._appInstanceId = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("appInstanceId");
                this.OnappInstanceIdChanged();
            }
        }
        private global::System.Guid _appInstanceId;
        partial void OnappInstanceIdChanging(global::System.Guid value);
        partial void OnappInstanceIdChanged();
        /// <summary>
        /// There are no comments for Property encryptedSymKey in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public byte[] encryptedSymKey
        {
            get
            {
                return global::System.Data.Objects.DataClasses.StructuralObject.GetValidValue(this._encryptedSymKey);
            }
            set
            {
                this.OnencryptedSymKeyChanging(value);
                this.ReportPropertyChanging("encryptedSymKey");
                this._encryptedSymKey = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value, true);
                this.ReportPropertyChanged("encryptedSymKey");
                this.OnencryptedSymKeyChanged();
            }
        }
        private byte[] _encryptedSymKey;
        partial void OnencryptedSymKeyChanging(byte[] value);
        partial void OnencryptedSymKeyChanged();
        /// <summary>
        /// There are no comments for Property encryptedPublicKey in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public byte[] encryptedPublicKey
        {
            get
            {
                return global::System.Data.Objects.DataClasses.StructuralObject.GetValidValue(this._encryptedPublicKey);
            }
            set
            {
                this.OnencryptedPublicKeyChanging(value);
                this.ReportPropertyChanging("encryptedPublicKey");
                this._encryptedPublicKey = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value, true);
                this.ReportPropertyChanged("encryptedPublicKey");
                this.OnencryptedPublicKeyChanged();
            }
        }
        private byte[] _encryptedPublicKey;
        partial void OnencryptedPublicKeyChanging(byte[] value);
        partial void OnencryptedPublicKeyChanged();
        /// <summary>
        /// There are no comments for Property modifiedDate in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.DateTime modifiedDate
        {
            get
            {
                return this._modifiedDate;
            }
            set
            {
                this.OnmodifiedDateChanging(value);
                this.ReportPropertyChanging("modifiedDate");
                this._modifiedDate = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("modifiedDate");
                this.OnmodifiedDateChanged();
            }
        }
        private global::System.DateTime _modifiedDate;
        partial void OnmodifiedDateChanging(global::System.DateTime value);
        partial void OnmodifiedDateChanged();
        /// <summary>
        /// There are no comments for AppInstance in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmRelationshipNavigationPropertyAttribute("RawCatalogDBModel", "FK_AppInstanceEncryptedKey_AppInstance", "AppInstance")]
        [global::System.Xml.Serialization.XmlIgnoreAttribute()]
        [global::System.Xml.Serialization.SoapIgnoreAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public AppInstance AppInstance
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<AppInstance>("RawCatalogDBModel.FK_AppInstanceEncryptedKey_AppInstance", "AppInstance").Value;
            }
            set
            {
                ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<AppInstance>("RawCatalogDBModel.FK_AppInstanceEncryptedKey_AppInstance", "AppInstance").Value = value;
            }
        }
        /// <summary>
        /// There are no comments for AppInstance in the schema.
        /// </summary>
        [global::System.ComponentModel.BrowsableAttribute(false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Data.Objects.DataClasses.EntityReference<AppInstance> AppInstanceReference
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<AppInstance>("RawCatalogDBModel.FK_AppInstanceEncryptedKey_AppInstance", "AppInstance");
            }
            set
            {
                if ((value != null))
                {
                    ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.InitializeRelatedReference<AppInstance>("RawCatalogDBModel.FK_AppInstanceEncryptedKey_AppInstance", "AppInstance", value);
                }
            }
        }
    }
    /// <summary>
    /// There are no comments for RawCatalogDBModel.AppInstanceFile in the schema.
    /// </summary>
    /// <KeyProperties>
    /// appInstanceFileId
    /// </KeyProperties>
    [global::System.Data.Objects.DataClasses.EdmEntityTypeAttribute(NamespaceName="RawCatalogDBModel", Name="AppInstanceFile")]
    [global::System.Runtime.Serialization.DataContractAttribute(IsReference=true)]
    [global::System.Serializable()]
    public partial class AppInstanceFile : global::System.Data.Objects.DataClasses.EntityObject
    {
        /// <summary>
        /// Create a new AppInstanceFile object.
        /// </summary>
        /// <param name="appInstanceFileId">Initial value of appInstanceFileId.</param>
        /// <param name="sortOrder">Initial value of sortOrder.</param>
        /// <param name="modifiedDate">Initial value of modifiedDate.</param>
        public static AppInstanceFile CreateAppInstanceFile(global::System.Guid appInstanceFileId, int sortOrder, global::System.DateTime modifiedDate)
        {
            AppInstanceFile appInstanceFile = new AppInstanceFile();
            appInstanceFile.appInstanceFileId = appInstanceFileId;
            appInstanceFile.sortOrder = sortOrder;
            appInstanceFile.modifiedDate = modifiedDate;
            return appInstanceFile;
        }
        /// <summary>
        /// There are no comments for Property appInstanceFileId in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(EntityKeyProperty=true, IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Guid appInstanceFileId
        {
            get
            {
                return this._appInstanceFileId;
            }
            set
            {
                this.OnappInstanceFileIdChanging(value);
                this.ReportPropertyChanging("appInstanceFileId");
                this._appInstanceFileId = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("appInstanceFileId");
                this.OnappInstanceFileIdChanged();
            }
        }
        private global::System.Guid _appInstanceFileId;
        partial void OnappInstanceFileIdChanging(global::System.Guid value);
        partial void OnappInstanceFileIdChanged();
        /// <summary>
        /// There are no comments for Property fileUrl in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public string fileUrl
        {
            get
            {
                return this._fileUrl;
            }
            set
            {
                this.OnfileUrlChanging(value);
                this.ReportPropertyChanging("fileUrl");
                this._fileUrl = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value, true);
                this.ReportPropertyChanged("fileUrl");
                this.OnfileUrlChanged();
            }
        }
        private string _fileUrl;
        partial void OnfileUrlChanging(string value);
        partial void OnfileUrlChanged();
        /// <summary>
        /// There are no comments for Property sortOrder in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public int sortOrder
        {
            get
            {
                return this._sortOrder;
            }
            set
            {
                this.OnsortOrderChanging(value);
                this.ReportPropertyChanging("sortOrder");
                this._sortOrder = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("sortOrder");
                this.OnsortOrderChanged();
            }
        }
        private int _sortOrder;
        partial void OnsortOrderChanging(int value);
        partial void OnsortOrderChanged();
        /// <summary>
        /// There are no comments for Property modifiedDate in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.DateTime modifiedDate
        {
            get
            {
                return this._modifiedDate;
            }
            set
            {
                this.OnmodifiedDateChanging(value);
                this.ReportPropertyChanging("modifiedDate");
                this._modifiedDate = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("modifiedDate");
                this.OnmodifiedDateChanged();
            }
        }
        private global::System.DateTime _modifiedDate;
        partial void OnmodifiedDateChanging(global::System.DateTime value);
        partial void OnmodifiedDateChanged();
        /// <summary>
        /// There are no comments for AppInstance in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmRelationshipNavigationPropertyAttribute("RawCatalogDBModel", "FK_AppInstanceFile_AppInstance", "AppInstance")]
        [global::System.Xml.Serialization.XmlIgnoreAttribute()]
        [global::System.Xml.Serialization.SoapIgnoreAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public AppInstance AppInstance
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<AppInstance>("RawCatalogDBModel.FK_AppInstanceFile_AppInstance", "AppInstance").Value;
            }
            set
            {
                ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<AppInstance>("RawCatalogDBModel.FK_AppInstanceFile_AppInstance", "AppInstance").Value = value;
            }
        }
        /// <summary>
        /// There are no comments for AppInstance in the schema.
        /// </summary>
        [global::System.ComponentModel.BrowsableAttribute(false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Data.Objects.DataClasses.EntityReference<AppInstance> AppInstanceReference
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<AppInstance>("RawCatalogDBModel.FK_AppInstanceFile_AppInstance", "AppInstance");
            }
            set
            {
                if ((value != null))
                {
                    ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.InitializeRelatedReference<AppInstance>("RawCatalogDBModel.FK_AppInstanceFile_AppInstance", "AppInstance", value);
                }
            }
        }
    }
    /// <summary>
    /// There are no comments for RawCatalogDBModel.AppLocale in the schema.
    /// </summary>
    /// <KeyProperties>
    /// appMediaId
    /// lcid
    /// </KeyProperties>
    [global::System.Data.Objects.DataClasses.EdmEntityTypeAttribute(NamespaceName="RawCatalogDBModel", Name="AppLocale")]
    [global::System.Runtime.Serialization.DataContractAttribute(IsReference=true)]
    [global::System.Serializable()]
    public partial class AppLocale : global::System.Data.Objects.DataClasses.EntityObject
    {
        /// <summary>
        /// Create a new AppLocale object.
        /// </summary>
        /// <param name="appMediaId">Initial value of appMediaId.</param>
        /// <param name="lcid">Initial value of lcid.</param>
        /// <param name="modifiedDate">Initial value of modifiedDate.</param>
        public static AppLocale CreateAppLocale(global::System.Guid appMediaId, int lcid, global::System.DateTime modifiedDate)
        {
            AppLocale appLocale = new AppLocale();
            appLocale.appMediaId = appMediaId;
            appLocale.lcid = lcid;
            appLocale.modifiedDate = modifiedDate;
            return appLocale;
        }
        /// <summary>
        /// There are no comments for Property appMediaId in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(EntityKeyProperty=true, IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Guid appMediaId
        {
            get
            {
                return this._appMediaId;
            }
            set
            {
                this.OnappMediaIdChanging(value);
                this.ReportPropertyChanging("appMediaId");
                this._appMediaId = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("appMediaId");
                this.OnappMediaIdChanged();
            }
        }
        private global::System.Guid _appMediaId;
        partial void OnappMediaIdChanging(global::System.Guid value);
        partial void OnappMediaIdChanged();
        /// <summary>
        /// There are no comments for Property lcid in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(EntityKeyProperty=true, IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public int lcid
        {
            get
            {
                return this._lcid;
            }
            set
            {
                this.OnlcidChanging(value);
                this.ReportPropertyChanging("lcid");
                this._lcid = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("lcid");
                this.OnlcidChanged();
            }
        }
        private int _lcid;
        partial void OnlcidChanging(int value);
        partial void OnlcidChanged();
        /// <summary>
        /// There are no comments for Property modifiedDate in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.DateTime modifiedDate
        {
            get
            {
                return this._modifiedDate;
            }
            set
            {
                this.OnmodifiedDateChanging(value);
                this.ReportPropertyChanging("modifiedDate");
                this._modifiedDate = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("modifiedDate");
                this.OnmodifiedDateChanged();
            }
        }
        private global::System.DateTime _modifiedDate;
        partial void OnmodifiedDateChanging(global::System.DateTime value);
        partial void OnmodifiedDateChanged();
        /// <summary>
        /// There are no comments for Property developer in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public string developer
        {
            get
            {
                return this._developer;
            }
            set
            {
                this.OndeveloperChanging(value);
                this.ReportPropertyChanging("developer");
                this._developer = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value, true);
                this.ReportPropertyChanged("developer");
                this.OndeveloperChanged();
            }
        }
        private string _developer;
        partial void OndeveloperChanging(string value);
        partial void OndeveloperChanged();
        /// <summary>
        /// There are no comments for Property publisher in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public string publisher
        {
            get
            {
                return this._publisher;
            }
            set
            {
                this.OnpublisherChanging(value);
                this.ReportPropertyChanging("publisher");
                this._publisher = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value, true);
                this.ReportPropertyChanged("publisher");
                this.OnpublisherChanged();
            }
        }
        private string _publisher;
        partial void OnpublisherChanging(string value);
        partial void OnpublisherChanged();
        /// <summary>
        /// There are no comments for App in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmRelationshipNavigationPropertyAttribute("RawCatalogDBModel", "FK_AppLocale_App", "App")]
        [global::System.Xml.Serialization.XmlIgnoreAttribute()]
        [global::System.Xml.Serialization.SoapIgnoreAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public App App
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<App>("RawCatalogDBModel.FK_AppLocale_App", "App").Value;
            }
            set
            {
                ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<App>("RawCatalogDBModel.FK_AppLocale_App", "App").Value = value;
            }
        }
        /// <summary>
        /// There are no comments for App in the schema.
        /// </summary>
        [global::System.ComponentModel.BrowsableAttribute(false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Data.Objects.DataClasses.EntityReference<App> AppReference
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<App>("RawCatalogDBModel.FK_AppLocale_App", "App");
            }
            set
            {
                if ((value != null))
                {
                    ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.InitializeRelatedReference<App>("RawCatalogDBModel.FK_AppLocale_App", "App", value);
                }
            }
        }
        /// <summary>
        /// There are no comments for Locale in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmRelationshipNavigationPropertyAttribute("RawCatalogDBModel", "FK_AppLocale_Locale", "Locale")]
        [global::System.Xml.Serialization.XmlIgnoreAttribute()]
        [global::System.Xml.Serialization.SoapIgnoreAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public Locale Locale
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<Locale>("RawCatalogDBModel.FK_AppLocale_Locale", "Locale").Value;
            }
            set
            {
                ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<Locale>("RawCatalogDBModel.FK_AppLocale_Locale", "Locale").Value = value;
            }
        }
        /// <summary>
        /// There are no comments for Locale in the schema.
        /// </summary>
        [global::System.ComponentModel.BrowsableAttribute(false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Data.Objects.DataClasses.EntityReference<Locale> LocaleReference
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<Locale>("RawCatalogDBModel.FK_AppLocale_Locale", "Locale");
            }
            set
            {
                if ((value != null))
                {
                    ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.InitializeRelatedReference<Locale>("RawCatalogDBModel.FK_AppLocale_Locale", "Locale", value);
                }
            }
        }
    }
    /// <summary>
    /// There are no comments for RawCatalogDBModel.AppType in the schema.
    /// </summary>
    /// <KeyProperties>
    /// appTypeId
    /// </KeyProperties>
    [global::System.Data.Objects.DataClasses.EdmEntityTypeAttribute(NamespaceName="RawCatalogDBModel", Name="AppType")]
    [global::System.Runtime.Serialization.DataContractAttribute(IsReference=true)]
    [global::System.Serializable()]
    public partial class AppType : global::System.Data.Objects.DataClasses.EntityObject
    {
        /// <summary>
        /// Create a new AppType object.
        /// </summary>
        /// <param name="appTypeId">Initial value of appTypeId.</param>
        /// <param name="internalName">Initial value of internalName.</param>
        /// <param name="modifiedDate">Initial value of modifiedDate.</param>
        public static AppType CreateAppType(int appTypeId, string internalName, global::System.DateTime modifiedDate)
        {
            AppType appType = new AppType();
            appType.appTypeId = appTypeId;
            appType.internalName = internalName;
            appType.modifiedDate = modifiedDate;
            return appType;
        }
        /// <summary>
        /// There are no comments for Property appTypeId in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(EntityKeyProperty=true, IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public int appTypeId
        {
            get
            {
                return this._appTypeId;
            }
            set
            {
                this.OnappTypeIdChanging(value);
                this.ReportPropertyChanging("appTypeId");
                this._appTypeId = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("appTypeId");
                this.OnappTypeIdChanged();
            }
        }
        private int _appTypeId;
        partial void OnappTypeIdChanging(int value);
        partial void OnappTypeIdChanged();
        /// <summary>
        /// There are no comments for Property internalName in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public string internalName
        {
            get
            {
                return this._internalName;
            }
            set
            {
                this.OninternalNameChanging(value);
                this.ReportPropertyChanging("internalName");
                this._internalName = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value, false);
                this.ReportPropertyChanged("internalName");
                this.OninternalNameChanged();
            }
        }
        private string _internalName;
        partial void OninternalNameChanging(string value);
        partial void OninternalNameChanged();
        /// <summary>
        /// There are no comments for Property modifiedDate in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.DateTime modifiedDate
        {
            get
            {
                return this._modifiedDate;
            }
            set
            {
                this.OnmodifiedDateChanging(value);
                this.ReportPropertyChanging("modifiedDate");
                this._modifiedDate = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("modifiedDate");
                this.OnmodifiedDateChanged();
            }
        }
        private global::System.DateTime _modifiedDate;
        partial void OnmodifiedDateChanging(global::System.DateTime value);
        partial void OnmodifiedDateChanged();
        /// <summary>
        /// There are no comments for AppAppType in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmRelationshipNavigationPropertyAttribute("RawCatalogDBModel", "FK_AppAppType_AppType", "AppAppType")]
        [global::System.Xml.Serialization.XmlIgnoreAttribute()]
        [global::System.Xml.Serialization.SoapIgnoreAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Data.Objects.DataClasses.EntityCollection<AppAppType> AppAppType
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedCollection<AppAppType>("RawCatalogDBModel.FK_AppAppType_AppType", "AppAppType");
            }
            set
            {
                if ((value != null))
                {
                    ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.InitializeRelatedCollection<AppAppType>("RawCatalogDBModel.FK_AppAppType_AppType", "AppAppType", value);
                }
            }
        }
    }
    /// <summary>
    /// There are no comments for RawCatalogDBModel.CapabilityType in the schema.
    /// </summary>
    /// <KeyProperties>
    /// capabilityTypeId
    /// </KeyProperties>
    [global::System.Data.Objects.DataClasses.EdmEntityTypeAttribute(NamespaceName="RawCatalogDBModel", Name="CapabilityType")]
    [global::System.Runtime.Serialization.DataContractAttribute(IsReference=true)]
    [global::System.Serializable()]
    public partial class CapabilityType : global::System.Data.Objects.DataClasses.EntityObject
    {
        /// <summary>
        /// Create a new CapabilityType object.
        /// </summary>
        /// <param name="capabilityTypeId">Initial value of capabilityTypeId.</param>
        /// <param name="internalName">Initial value of internalName.</param>
        /// <param name="unitTypeRequired">Initial value of unitTypeRequired.</param>
        /// <param name="modifiedDate">Initial value of modifiedDate.</param>
        public static CapabilityType CreateCapabilityType(int capabilityTypeId, string internalName, bool unitTypeRequired, global::System.DateTime modifiedDate)
        {
            CapabilityType capabilityType = new CapabilityType();
            capabilityType.capabilityTypeId = capabilityTypeId;
            capabilityType.internalName = internalName;
            capabilityType.unitTypeRequired = unitTypeRequired;
            capabilityType.modifiedDate = modifiedDate;
            return capabilityType;
        }
        /// <summary>
        /// There are no comments for Property capabilityTypeId in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(EntityKeyProperty=true, IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public int capabilityTypeId
        {
            get
            {
                return this._capabilityTypeId;
            }
            set
            {
                this.OncapabilityTypeIdChanging(value);
                this.ReportPropertyChanging("capabilityTypeId");
                this._capabilityTypeId = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("capabilityTypeId");
                this.OncapabilityTypeIdChanged();
            }
        }
        private int _capabilityTypeId;
        partial void OncapabilityTypeIdChanging(int value);
        partial void OncapabilityTypeIdChanged();
        /// <summary>
        /// There are no comments for Property internalName in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public string internalName
        {
            get
            {
                return this._internalName;
            }
            set
            {
                this.OninternalNameChanging(value);
                this.ReportPropertyChanging("internalName");
                this._internalName = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value, false);
                this.ReportPropertyChanged("internalName");
                this.OninternalNameChanged();
            }
        }
        private string _internalName;
        partial void OninternalNameChanging(string value);
        partial void OninternalNameChanged();
        /// <summary>
        /// There are no comments for Property unitTypeRequired in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public bool unitTypeRequired
        {
            get
            {
                return this._unitTypeRequired;
            }
            set
            {
                this.OnunitTypeRequiredChanging(value);
                this.ReportPropertyChanging("unitTypeRequired");
                this._unitTypeRequired = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("unitTypeRequired");
                this.OnunitTypeRequiredChanged();
            }
        }
        private bool _unitTypeRequired;
        partial void OnunitTypeRequiredChanging(bool value);
        partial void OnunitTypeRequiredChanged();
        /// <summary>
        /// There are no comments for Property modifiedDate in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.DateTime modifiedDate
        {
            get
            {
                return this._modifiedDate;
            }
            set
            {
                this.OnmodifiedDateChanging(value);
                this.ReportPropertyChanging("modifiedDate");
                this._modifiedDate = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("modifiedDate");
                this.OnmodifiedDateChanged();
            }
        }
        private global::System.DateTime _modifiedDate;
        partial void OnmodifiedDateChanging(global::System.DateTime value);
        partial void OnmodifiedDateChanged();
        /// <summary>
        /// There are no comments for DataType in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmRelationshipNavigationPropertyAttribute("RawCatalogDBModel", "FK_CapabilityType_DataType", "DataType")]
        [global::System.Xml.Serialization.XmlIgnoreAttribute()]
        [global::System.Xml.Serialization.SoapIgnoreAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public DataType DataType
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<DataType>("RawCatalogDBModel.FK_CapabilityType_DataType", "DataType").Value;
            }
            set
            {
                ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<DataType>("RawCatalogDBModel.FK_CapabilityType_DataType", "DataType").Value = value;
            }
        }
        /// <summary>
        /// There are no comments for DataType in the schema.
        /// </summary>
        [global::System.ComponentModel.BrowsableAttribute(false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Data.Objects.DataClasses.EntityReference<DataType> DataTypeReference
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<DataType>("RawCatalogDBModel.FK_CapabilityType_DataType", "DataType");
            }
            set
            {
                if ((value != null))
                {
                    ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.InitializeRelatedReference<DataType>("RawCatalogDBModel.FK_CapabilityType_DataType", "DataType", value);
                }
            }
        }
        /// <summary>
        /// There are no comments for MediaCapabilityCountry in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmRelationshipNavigationPropertyAttribute("RawCatalogDBModel", "FK_MediaCapabilityCountry_CapabilityType", "MediaCapabilityCountry")]
        [global::System.Xml.Serialization.XmlIgnoreAttribute()]
        [global::System.Xml.Serialization.SoapIgnoreAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Data.Objects.DataClasses.EntityCollection<MediaCapabilityCountry> MediaCapabilityCountry
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedCollection<MediaCapabilityCountry>("RawCatalogDBModel.FK_MediaCapabilityCountry_CapabilityType", "MediaCapabilityCountry");
            }
            set
            {
                if ((value != null))
                {
                    ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.InitializeRelatedCollection<MediaCapabilityCountry>("RawCatalogDBModel.FK_MediaCapabilityCountry_CapabilityType", "MediaCapabilityCountry", value);
                }
            }
        }
    }
    /// <summary>
    /// There are no comments for RawCatalogDBModel.DataType in the schema.
    /// </summary>
    /// <KeyProperties>
    /// dataTypeId
    /// </KeyProperties>
    [global::System.Data.Objects.DataClasses.EdmEntityTypeAttribute(NamespaceName="RawCatalogDBModel", Name="DataType")]
    [global::System.Runtime.Serialization.DataContractAttribute(IsReference=true)]
    [global::System.Serializable()]
    public partial class DataType : global::System.Data.Objects.DataClasses.EntityObject
    {
        /// <summary>
        /// Create a new DataType object.
        /// </summary>
        /// <param name="dataTypeId">Initial value of dataTypeId.</param>
        /// <param name="internalName">Initial value of internalName.</param>
        /// <param name="modifiedDate">Initial value of modifiedDate.</param>
        public static DataType CreateDataType(int dataTypeId, string internalName, global::System.DateTime modifiedDate)
        {
            DataType dataType = new DataType();
            dataType.dataTypeId = dataTypeId;
            dataType.internalName = internalName;
            dataType.modifiedDate = modifiedDate;
            return dataType;
        }
        /// <summary>
        /// There are no comments for Property dataTypeId in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(EntityKeyProperty=true, IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public int dataTypeId
        {
            get
            {
                return this._dataTypeId;
            }
            set
            {
                this.OndataTypeIdChanging(value);
                this.ReportPropertyChanging("dataTypeId");
                this._dataTypeId = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("dataTypeId");
                this.OndataTypeIdChanged();
            }
        }
        private int _dataTypeId;
        partial void OndataTypeIdChanging(int value);
        partial void OndataTypeIdChanged();
        /// <summary>
        /// There are no comments for Property internalName in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public string internalName
        {
            get
            {
                return this._internalName;
            }
            set
            {
                this.OninternalNameChanging(value);
                this.ReportPropertyChanging("internalName");
                this._internalName = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value, false);
                this.ReportPropertyChanged("internalName");
                this.OninternalNameChanged();
            }
        }
        private string _internalName;
        partial void OninternalNameChanging(string value);
        partial void OninternalNameChanged();
        /// <summary>
        /// There are no comments for Property modifiedDate in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.DateTime modifiedDate
        {
            get
            {
                return this._modifiedDate;
            }
            set
            {
                this.OnmodifiedDateChanging(value);
                this.ReportPropertyChanging("modifiedDate");
                this._modifiedDate = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("modifiedDate");
                this.OnmodifiedDateChanged();
            }
        }
        private global::System.DateTime _modifiedDate;
        partial void OnmodifiedDateChanging(global::System.DateTime value);
        partial void OnmodifiedDateChanged();
        /// <summary>
        /// There are no comments for CapabilityType in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmRelationshipNavigationPropertyAttribute("RawCatalogDBModel", "FK_CapabilityType_DataType", "CapabilityType")]
        [global::System.Xml.Serialization.XmlIgnoreAttribute()]
        [global::System.Xml.Serialization.SoapIgnoreAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Data.Objects.DataClasses.EntityCollection<CapabilityType> CapabilityType
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedCollection<CapabilityType>("RawCatalogDBModel.FK_CapabilityType_DataType", "CapabilityType");
            }
            set
            {
                if ((value != null))
                {
                    ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.InitializeRelatedCollection<CapabilityType>("RawCatalogDBModel.FK_CapabilityType_DataType", "CapabilityType", value);
                }
            }
        }
    }
    /// <summary>
    /// There are no comments for RawCatalogDBModel.MediaCapabilityCountry in the schema.
    /// </summary>
    /// <KeyProperties>
    /// mediaId
    /// capabilityTypeId
    /// countryCode
    /// </KeyProperties>
    [global::System.Data.Objects.DataClasses.EdmEntityTypeAttribute(NamespaceName="RawCatalogDBModel", Name="MediaCapabilityCountry")]
    [global::System.Runtime.Serialization.DataContractAttribute(IsReference=true)]
    [global::System.Serializable()]
    public partial class MediaCapabilityCountry : global::System.Data.Objects.DataClasses.EntityObject
    {
        /// <summary>
        /// Create a new MediaCapabilityCountry object.
        /// </summary>
        /// <param name="mediaId">Initial value of mediaId.</param>
        /// <param name="capabilityTypeId">Initial value of capabilityTypeId.</param>
        /// <param name="countryCode">Initial value of countryCode.</param>
        /// <param name="value">Initial value of value.</param>
        /// <param name="modifiedDate">Initial value of modifiedDate.</param>
        public static MediaCapabilityCountry CreateMediaCapabilityCountry(global::System.Guid mediaId, int capabilityTypeId, string countryCode, string value, global::System.DateTime modifiedDate)
        {
            MediaCapabilityCountry mediaCapabilityCountry = new MediaCapabilityCountry();
            mediaCapabilityCountry.mediaId = mediaId;
            mediaCapabilityCountry.capabilityTypeId = capabilityTypeId;
            mediaCapabilityCountry.countryCode = countryCode;
            mediaCapabilityCountry.value = value;
            mediaCapabilityCountry.modifiedDate = modifiedDate;
            return mediaCapabilityCountry;
        }
        /// <summary>
        /// There are no comments for Property mediaId in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(EntityKeyProperty=true, IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Guid mediaId
        {
            get
            {
                return this._mediaId;
            }
            set
            {
                this.OnmediaIdChanging(value);
                this.ReportPropertyChanging("mediaId");
                this._mediaId = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("mediaId");
                this.OnmediaIdChanged();
            }
        }
        private global::System.Guid _mediaId;
        partial void OnmediaIdChanging(global::System.Guid value);
        partial void OnmediaIdChanged();
        /// <summary>
        /// There are no comments for Property capabilityTypeId in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(EntityKeyProperty=true, IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public int capabilityTypeId
        {
            get
            {
                return this._capabilityTypeId;
            }
            set
            {
                this.OncapabilityTypeIdChanging(value);
                this.ReportPropertyChanging("capabilityTypeId");
                this._capabilityTypeId = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("capabilityTypeId");
                this.OncapabilityTypeIdChanged();
            }
        }
        private int _capabilityTypeId;
        partial void OncapabilityTypeIdChanging(int value);
        partial void OncapabilityTypeIdChanged();
        /// <summary>
        /// There are no comments for Property countryCode in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(EntityKeyProperty=true, IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public string countryCode
        {
            get
            {
                return this._countryCode;
            }
            set
            {
                this.OncountryCodeChanging(value);
                this.ReportPropertyChanging("countryCode");
                this._countryCode = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value, false);
                this.ReportPropertyChanged("countryCode");
                this.OncountryCodeChanged();
            }
        }
        private string _countryCode;
        partial void OncountryCodeChanging(string value);
        partial void OncountryCodeChanged();
        /// <summary>
        /// There are no comments for Property value in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public string value
        {
            get
            {
                return this._value;
            }
            set
            {
                this.OnvalueChanging(value);
                this.ReportPropertyChanging("value");
                this._value = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value, false);
                this.ReportPropertyChanged("value");
                this.OnvalueChanged();
            }
        }
        private string _value;
        partial void OnvalueChanging(string value);
        partial void OnvalueChanged();
        /// <summary>
        /// There are no comments for Property modifiedDate in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.DateTime modifiedDate
        {
            get
            {
                return this._modifiedDate;
            }
            set
            {
                this.OnmodifiedDateChanging(value);
                this.ReportPropertyChanging("modifiedDate");
                this._modifiedDate = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("modifiedDate");
                this.OnmodifiedDateChanged();
            }
        }
        private global::System.DateTime _modifiedDate;
        partial void OnmodifiedDateChanging(global::System.DateTime value);
        partial void OnmodifiedDateChanged();
        /// <summary>
        /// There are no comments for CapabilityType in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmRelationshipNavigationPropertyAttribute("RawCatalogDBModel", "FK_MediaCapabilityCountry_CapabilityType", "CapabilityType")]
        [global::System.Xml.Serialization.XmlIgnoreAttribute()]
        [global::System.Xml.Serialization.SoapIgnoreAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public CapabilityType CapabilityType
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<CapabilityType>("RawCatalogDBModel.FK_MediaCapabilityCountry_CapabilityType", "CapabilityType").Value;
            }
            set
            {
                ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<CapabilityType>("RawCatalogDBModel.FK_MediaCapabilityCountry_CapabilityType", "CapabilityType").Value = value;
            }
        }
        /// <summary>
        /// There are no comments for CapabilityType in the schema.
        /// </summary>
        [global::System.ComponentModel.BrowsableAttribute(false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Data.Objects.DataClasses.EntityReference<CapabilityType> CapabilityTypeReference
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<CapabilityType>("RawCatalogDBModel.FK_MediaCapabilityCountry_CapabilityType", "CapabilityType");
            }
            set
            {
                if ((value != null))
                {
                    ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.InitializeRelatedReference<CapabilityType>("RawCatalogDBModel.FK_MediaCapabilityCountry_CapabilityType", "CapabilityType", value);
                }
            }
        }
        /// <summary>
        /// There are no comments for Country in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmRelationshipNavigationPropertyAttribute("RawCatalogDBModel", "FK_MediaCapabilityCountry_Country", "Country")]
        [global::System.Xml.Serialization.XmlIgnoreAttribute()]
        [global::System.Xml.Serialization.SoapIgnoreAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public Country Country
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<Country>("RawCatalogDBModel.FK_MediaCapabilityCountry_Country", "Country").Value;
            }
            set
            {
                ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<Country>("RawCatalogDBModel.FK_MediaCapabilityCountry_Country", "Country").Value = value;
            }
        }
        /// <summary>
        /// There are no comments for Country in the schema.
        /// </summary>
        [global::System.ComponentModel.BrowsableAttribute(false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Data.Objects.DataClasses.EntityReference<Country> CountryReference
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<Country>("RawCatalogDBModel.FK_MediaCapabilityCountry_Country", "Country");
            }
            set
            {
                if ((value != null))
                {
                    ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.InitializeRelatedReference<Country>("RawCatalogDBModel.FK_MediaCapabilityCountry_Country", "Country", value);
                }
            }
        }
        /// <summary>
        /// There are no comments for Media in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmRelationshipNavigationPropertyAttribute("RawCatalogDBModel", "FK_MediaCapabilityCountry_Media", "Media")]
        [global::System.Xml.Serialization.XmlIgnoreAttribute()]
        [global::System.Xml.Serialization.SoapIgnoreAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public Media Media
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<Media>("RawCatalogDBModel.FK_MediaCapabilityCountry_Media", "Media").Value;
            }
            set
            {
                ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<Media>("RawCatalogDBModel.FK_MediaCapabilityCountry_Media", "Media").Value = value;
            }
        }
        /// <summary>
        /// There are no comments for Media in the schema.
        /// </summary>
        [global::System.ComponentModel.BrowsableAttribute(false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Data.Objects.DataClasses.EntityReference<Media> MediaReference
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<Media>("RawCatalogDBModel.FK_MediaCapabilityCountry_Media", "Media");
            }
            set
            {
                if ((value != null))
                {
                    ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.InitializeRelatedReference<Media>("RawCatalogDBModel.FK_MediaCapabilityCountry_Media", "Media", value);
                }
            }
        }
        /// <summary>
        /// There are no comments for UnitType in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmRelationshipNavigationPropertyAttribute("RawCatalogDBModel", "FK_MediaCapabilityCountry_UnitType", "UnitType")]
        [global::System.Xml.Serialization.XmlIgnoreAttribute()]
        [global::System.Xml.Serialization.SoapIgnoreAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public UnitType UnitType
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<UnitType>("RawCatalogDBModel.FK_MediaCapabilityCountry_UnitType", "UnitType").Value;
            }
            set
            {
                ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<UnitType>("RawCatalogDBModel.FK_MediaCapabilityCountry_UnitType", "UnitType").Value = value;
            }
        }
        /// <summary>
        /// There are no comments for UnitType in the schema.
        /// </summary>
        [global::System.ComponentModel.BrowsableAttribute(false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Data.Objects.DataClasses.EntityReference<UnitType> UnitTypeReference
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<UnitType>("RawCatalogDBModel.FK_MediaCapabilityCountry_UnitType", "UnitType");
            }
            set
            {
                if ((value != null))
                {
                    ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.InitializeRelatedReference<UnitType>("RawCatalogDBModel.FK_MediaCapabilityCountry_UnitType", "UnitType", value);
                }
            }
        }
    }
    /// <summary>
    /// There are no comments for RawCatalogDBModel.MediaLocaleUnmapped in the schema.
    /// </summary>
    /// <KeyProperties>
    /// mediaId
    /// lcid
    /// </KeyProperties>
    [global::System.Data.Objects.DataClasses.EdmEntityTypeAttribute(NamespaceName="RawCatalogDBModel", Name="MediaLocaleUnmapped")]
    [global::System.Runtime.Serialization.DataContractAttribute(IsReference=true)]
    [global::System.Serializable()]
    public partial class MediaLocaleUnmapped : global::System.Data.Objects.DataClasses.EntityObject
    {
        /// <summary>
        /// Create a new MediaLocaleUnmapped object.
        /// </summary>
        /// <param name="mediaId">Initial value of mediaId.</param>
        /// <param name="lcid">Initial value of lcid.</param>
        /// <param name="modifiedDate">Initial value of modifiedDate.</param>
        public static MediaLocaleUnmapped CreateMediaLocaleUnmapped(global::System.Guid mediaId, int lcid, global::System.DateTime modifiedDate)
        {
            MediaLocaleUnmapped mediaLocaleUnmapped = new MediaLocaleUnmapped();
            mediaLocaleUnmapped.mediaId = mediaId;
            mediaLocaleUnmapped.lcid = lcid;
            mediaLocaleUnmapped.modifiedDate = modifiedDate;
            return mediaLocaleUnmapped;
        }
        /// <summary>
        /// There are no comments for Property mediaId in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(EntityKeyProperty=true, IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Guid mediaId
        {
            get
            {
                return this._mediaId;
            }
            set
            {
                this.OnmediaIdChanging(value);
                this.ReportPropertyChanging("mediaId");
                this._mediaId = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("mediaId");
                this.OnmediaIdChanged();
            }
        }
        private global::System.Guid _mediaId;
        partial void OnmediaIdChanging(global::System.Guid value);
        partial void OnmediaIdChanged();
        /// <summary>
        /// There are no comments for Property lcid in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(EntityKeyProperty=true, IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public int lcid
        {
            get
            {
                return this._lcid;
            }
            set
            {
                this.OnlcidChanging(value);
                this.ReportPropertyChanging("lcid");
                this._lcid = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("lcid");
                this.OnlcidChanged();
            }
        }
        private int _lcid;
        partial void OnlcidChanging(int value);
        partial void OnlcidChanged();
        /// <summary>
        /// There are no comments for Property keywords in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public string keywords
        {
            get
            {
                return this._keywords;
            }
            set
            {
                this.OnkeywordsChanging(value);
                this.ReportPropertyChanging("keywords");
                this._keywords = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value, true);
                this.ReportPropertyChanged("keywords");
                this.OnkeywordsChanged();
            }
        }
        private string _keywords;
        partial void OnkeywordsChanging(string value);
        partial void OnkeywordsChanged();
        /// <summary>
        /// There are no comments for Property modifiedDate in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.DateTime modifiedDate
        {
            get
            {
                return this._modifiedDate;
            }
            set
            {
                this.OnmodifiedDateChanging(value);
                this.ReportPropertyChanging("modifiedDate");
                this._modifiedDate = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("modifiedDate");
                this.OnmodifiedDateChanged();
            }
        }
        private global::System.DateTime _modifiedDate;
        partial void OnmodifiedDateChanging(global::System.DateTime value);
        partial void OnmodifiedDateChanged();
        /// <summary>
        /// There are no comments for Locale in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmRelationshipNavigationPropertyAttribute("RawCatalogDBModel", "FK_MediaLocaleUnmapped_Locale", "Locale")]
        [global::System.Xml.Serialization.XmlIgnoreAttribute()]
        [global::System.Xml.Serialization.SoapIgnoreAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public Locale Locale
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<Locale>("RawCatalogDBModel.FK_MediaLocaleUnmapped_Locale", "Locale").Value;
            }
            set
            {
                ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<Locale>("RawCatalogDBModel.FK_MediaLocaleUnmapped_Locale", "Locale").Value = value;
            }
        }
        /// <summary>
        /// There are no comments for Locale in the schema.
        /// </summary>
        [global::System.ComponentModel.BrowsableAttribute(false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Data.Objects.DataClasses.EntityReference<Locale> LocaleReference
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<Locale>("RawCatalogDBModel.FK_MediaLocaleUnmapped_Locale", "Locale");
            }
            set
            {
                if ((value != null))
                {
                    ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.InitializeRelatedReference<Locale>("RawCatalogDBModel.FK_MediaLocaleUnmapped_Locale", "Locale", value);
                }
            }
        }
        /// <summary>
        /// There are no comments for Media in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmRelationshipNavigationPropertyAttribute("RawCatalogDBModel", "FK_MediaLocaleUnmapped_Media", "Media")]
        [global::System.Xml.Serialization.XmlIgnoreAttribute()]
        [global::System.Xml.Serialization.SoapIgnoreAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public Media Media
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<Media>("RawCatalogDBModel.FK_MediaLocaleUnmapped_Media", "Media").Value;
            }
            set
            {
                ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<Media>("RawCatalogDBModel.FK_MediaLocaleUnmapped_Media", "Media").Value = value;
            }
        }
        /// <summary>
        /// There are no comments for Media in the schema.
        /// </summary>
        [global::System.ComponentModel.BrowsableAttribute(false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Data.Objects.DataClasses.EntityReference<Media> MediaReference
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<Media>("RawCatalogDBModel.FK_MediaLocaleUnmapped_Media", "Media");
            }
            set
            {
                if ((value != null))
                {
                    ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.InitializeRelatedReference<Media>("RawCatalogDBModel.FK_MediaLocaleUnmapped_Media", "Media", value);
                }
            }
        }
    }
    /// <summary>
    /// There are no comments for RawCatalogDBModel.UnitType in the schema.
    /// </summary>
    /// <KeyProperties>
    /// unitTypeId
    /// </KeyProperties>
    [global::System.Data.Objects.DataClasses.EdmEntityTypeAttribute(NamespaceName="RawCatalogDBModel", Name="UnitType")]
    [global::System.Runtime.Serialization.DataContractAttribute(IsReference=true)]
    [global::System.Serializable()]
    public partial class UnitType : global::System.Data.Objects.DataClasses.EntityObject
    {
        /// <summary>
        /// Create a new UnitType object.
        /// </summary>
        /// <param name="unitTypeId">Initial value of unitTypeId.</param>
        /// <param name="internalName">Initial value of internalName.</param>
        /// <param name="modifiedDate">Initial value of modifiedDate.</param>
        public static UnitType CreateUnitType(int unitTypeId, string internalName, global::System.DateTime modifiedDate)
        {
            UnitType unitType = new UnitType();
            unitType.unitTypeId = unitTypeId;
            unitType.internalName = internalName;
            unitType.modifiedDate = modifiedDate;
            return unitType;
        }
        /// <summary>
        /// There are no comments for Property unitTypeId in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(EntityKeyProperty=true, IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public int unitTypeId
        {
            get
            {
                return this._unitTypeId;
            }
            set
            {
                this.OnunitTypeIdChanging(value);
                this.ReportPropertyChanging("unitTypeId");
                this._unitTypeId = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("unitTypeId");
                this.OnunitTypeIdChanged();
            }
        }
        private int _unitTypeId;
        partial void OnunitTypeIdChanging(int value);
        partial void OnunitTypeIdChanged();
        /// <summary>
        /// There are no comments for Property internalName in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public string internalName
        {
            get
            {
                return this._internalName;
            }
            set
            {
                this.OninternalNameChanging(value);
                this.ReportPropertyChanging("internalName");
                this._internalName = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value, false);
                this.ReportPropertyChanged("internalName");
                this.OninternalNameChanged();
            }
        }
        private string _internalName;
        partial void OninternalNameChanging(string value);
        partial void OninternalNameChanged();
        /// <summary>
        /// There are no comments for Property modifiedDate in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.DateTime modifiedDate
        {
            get
            {
                return this._modifiedDate;
            }
            set
            {
                this.OnmodifiedDateChanging(value);
                this.ReportPropertyChanging("modifiedDate");
                this._modifiedDate = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("modifiedDate");
                this.OnmodifiedDateChanged();
            }
        }
        private global::System.DateTime _modifiedDate;
        partial void OnmodifiedDateChanging(global::System.DateTime value);
        partial void OnmodifiedDateChanged();
        /// <summary>
        /// There are no comments for MediaCapabilityCountry in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmRelationshipNavigationPropertyAttribute("RawCatalogDBModel", "FK_MediaCapabilityCountry_UnitType", "MediaCapabilityCountry")]
        [global::System.Xml.Serialization.XmlIgnoreAttribute()]
        [global::System.Xml.Serialization.SoapIgnoreAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Data.Objects.DataClasses.EntityCollection<MediaCapabilityCountry> MediaCapabilityCountry
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedCollection<MediaCapabilityCountry>("RawCatalogDBModel.FK_MediaCapabilityCountry_UnitType", "MediaCapabilityCountry");
            }
            set
            {
                if ((value != null))
                {
                    ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.InitializeRelatedCollection<MediaCapabilityCountry>("RawCatalogDBModel.FK_MediaCapabilityCountry_UnitType", "MediaCapabilityCountry", value);
                }
            }
        }
    }
    /// <summary>
    /// There are no comments for RawCatalogDBModel.MediaTerm in the schema.
    /// </summary>
    /// <KeyProperties>
    /// mediaId
    /// lcid
    /// termTypeId
    /// term
    /// </KeyProperties>
    [global::System.Data.Objects.DataClasses.EdmEntityTypeAttribute(NamespaceName="RawCatalogDBModel", Name="MediaTerm")]
    [global::System.Runtime.Serialization.DataContractAttribute(IsReference=true)]
    [global::System.Serializable()]
    public partial class MediaTerm : global::System.Data.Objects.DataClasses.EntityObject
    {
        /// <summary>
        /// Create a new MediaTerm object.
        /// </summary>
        /// <param name="mediaId">Initial value of mediaId.</param>
        /// <param name="lcid">Initial value of lcid.</param>
        /// <param name="termTypeId">Initial value of termTypeId.</param>
        /// <param name="term">Initial value of term.</param>
        /// <param name="modifiedDate">Initial value of modifiedDate.</param>
        public static MediaTerm CreateMediaTerm(global::System.Guid mediaId, int lcid, int termTypeId, string term, global::System.DateTime modifiedDate)
        {
            MediaTerm mediaTerm = new MediaTerm();
            mediaTerm.mediaId = mediaId;
            mediaTerm.lcid = lcid;
            mediaTerm.termTypeId = termTypeId;
            mediaTerm.term = term;
            mediaTerm.modifiedDate = modifiedDate;
            return mediaTerm;
        }
        /// <summary>
        /// There are no comments for Property mediaId in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(EntityKeyProperty=true, IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Guid mediaId
        {
            get
            {
                return this._mediaId;
            }
            set
            {
                this.OnmediaIdChanging(value);
                this.ReportPropertyChanging("mediaId");
                this._mediaId = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("mediaId");
                this.OnmediaIdChanged();
            }
        }
        private global::System.Guid _mediaId;
        partial void OnmediaIdChanging(global::System.Guid value);
        partial void OnmediaIdChanged();
        /// <summary>
        /// There are no comments for Property lcid in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(EntityKeyProperty=true, IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public int lcid
        {
            get
            {
                return this._lcid;
            }
            set
            {
                this.OnlcidChanging(value);
                this.ReportPropertyChanging("lcid");
                this._lcid = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("lcid");
                this.OnlcidChanged();
            }
        }
        private int _lcid;
        partial void OnlcidChanging(int value);
        partial void OnlcidChanged();
        /// <summary>
        /// There are no comments for Property termTypeId in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(EntityKeyProperty=true, IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public int termTypeId
        {
            get
            {
                return this._termTypeId;
            }
            set
            {
                this.OntermTypeIdChanging(value);
                this.ReportPropertyChanging("termTypeId");
                this._termTypeId = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("termTypeId");
                this.OntermTypeIdChanged();
            }
        }
        private int _termTypeId;
        partial void OntermTypeIdChanging(int value);
        partial void OntermTypeIdChanged();
        /// <summary>
        /// There are no comments for Property term in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(EntityKeyProperty=true, IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public string term
        {
            get
            {
                return this._term;
            }
            set
            {
                this.OntermChanging(value);
                this.ReportPropertyChanging("term");
                this._term = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value, false);
                this.ReportPropertyChanged("term");
                this.OntermChanged();
            }
        }
        private string _term;
        partial void OntermChanging(string value);
        partial void OntermChanged();
        /// <summary>
        /// There are no comments for Property modifiedDate in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.DateTime modifiedDate
        {
            get
            {
                return this._modifiedDate;
            }
            set
            {
                this.OnmodifiedDateChanging(value);
                this.ReportPropertyChanging("modifiedDate");
                this._modifiedDate = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("modifiedDate");
                this.OnmodifiedDateChanged();
            }
        }
        private global::System.DateTime _modifiedDate;
        partial void OnmodifiedDateChanging(global::System.DateTime value);
        partial void OnmodifiedDateChanged();
        /// <summary>
        /// There are no comments for Locale in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmRelationshipNavigationPropertyAttribute("RawCatalogDBModel", "FK_MediaTerm_Locale", "Locale")]
        [global::System.Xml.Serialization.XmlIgnoreAttribute()]
        [global::System.Xml.Serialization.SoapIgnoreAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public Locale Locale
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<Locale>("RawCatalogDBModel.FK_MediaTerm_Locale", "Locale").Value;
            }
            set
            {
                ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<Locale>("RawCatalogDBModel.FK_MediaTerm_Locale", "Locale").Value = value;
            }
        }
        /// <summary>
        /// There are no comments for Locale in the schema.
        /// </summary>
        [global::System.ComponentModel.BrowsableAttribute(false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Data.Objects.DataClasses.EntityReference<Locale> LocaleReference
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<Locale>("RawCatalogDBModel.FK_MediaTerm_Locale", "Locale");
            }
            set
            {
                if ((value != null))
                {
                    ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.InitializeRelatedReference<Locale>("RawCatalogDBModel.FK_MediaTerm_Locale", "Locale", value);
                }
            }
        }
        /// <summary>
        /// There are no comments for Media in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmRelationshipNavigationPropertyAttribute("RawCatalogDBModel", "FK_MediaTerm_Media", "Media")]
        [global::System.Xml.Serialization.XmlIgnoreAttribute()]
        [global::System.Xml.Serialization.SoapIgnoreAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public Media Media
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<Media>("RawCatalogDBModel.FK_MediaTerm_Media", "Media").Value;
            }
            set
            {
                ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<Media>("RawCatalogDBModel.FK_MediaTerm_Media", "Media").Value = value;
            }
        }
        /// <summary>
        /// There are no comments for Media in the schema.
        /// </summary>
        [global::System.ComponentModel.BrowsableAttribute(false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Data.Objects.DataClasses.EntityReference<Media> MediaReference
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<Media>("RawCatalogDBModel.FK_MediaTerm_Media", "Media");
            }
            set
            {
                if ((value != null))
                {
                    ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.InitializeRelatedReference<Media>("RawCatalogDBModel.FK_MediaTerm_Media", "Media", value);
                }
            }
        }
        /// <summary>
        /// There are no comments for TermType in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmRelationshipNavigationPropertyAttribute("RawCatalogDBModel", "FK_MediaTerm_TermType", "TermType")]
        [global::System.Xml.Serialization.XmlIgnoreAttribute()]
        [global::System.Xml.Serialization.SoapIgnoreAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public TermType TermType
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<TermType>("RawCatalogDBModel.FK_MediaTerm_TermType", "TermType").Value;
            }
            set
            {
                ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<TermType>("RawCatalogDBModel.FK_MediaTerm_TermType", "TermType").Value = value;
            }
        }
        /// <summary>
        /// There are no comments for TermType in the schema.
        /// </summary>
        [global::System.ComponentModel.BrowsableAttribute(false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Data.Objects.DataClasses.EntityReference<TermType> TermTypeReference
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedReference<TermType>("RawCatalogDBModel.FK_MediaTerm_TermType", "TermType");
            }
            set
            {
                if ((value != null))
                {
                    ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.InitializeRelatedReference<TermType>("RawCatalogDBModel.FK_MediaTerm_TermType", "TermType", value);
                }
            }
        }
    }
    /// <summary>
    /// There are no comments for RawCatalogDBModel.TermType in the schema.
    /// </summary>
    /// <KeyProperties>
    /// termTypeId
    /// </KeyProperties>
    [global::System.Data.Objects.DataClasses.EdmEntityTypeAttribute(NamespaceName="RawCatalogDBModel", Name="TermType")]
    [global::System.Runtime.Serialization.DataContractAttribute(IsReference=true)]
    [global::System.Serializable()]
    public partial class TermType : global::System.Data.Objects.DataClasses.EntityObject
    {
        /// <summary>
        /// Create a new TermType object.
        /// </summary>
        /// <param name="termTypeId">Initial value of termTypeId.</param>
        /// <param name="internalName">Initial value of internalName.</param>
        /// <param name="modifiedDate">Initial value of modifiedDate.</param>
        public static TermType CreateTermType(int termTypeId, string internalName, global::System.DateTime modifiedDate)
        {
            TermType termType = new TermType();
            termType.termTypeId = termTypeId;
            termType.internalName = internalName;
            termType.modifiedDate = modifiedDate;
            return termType;
        }
        /// <summary>
        /// There are no comments for Property termTypeId in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(EntityKeyProperty=true, IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public int termTypeId
        {
            get
            {
                return this._termTypeId;
            }
            set
            {
                this.OntermTypeIdChanging(value);
                this.ReportPropertyChanging("termTypeId");
                this._termTypeId = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("termTypeId");
                this.OntermTypeIdChanged();
            }
        }
        private int _termTypeId;
        partial void OntermTypeIdChanging(int value);
        partial void OntermTypeIdChanged();
        /// <summary>
        /// There are no comments for Property internalName in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public string internalName
        {
            get
            {
                return this._internalName;
            }
            set
            {
                this.OninternalNameChanging(value);
                this.ReportPropertyChanging("internalName");
                this._internalName = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value, false);
                this.ReportPropertyChanged("internalName");
                this.OninternalNameChanged();
            }
        }
        private string _internalName;
        partial void OninternalNameChanging(string value);
        partial void OninternalNameChanged();
        /// <summary>
        /// There are no comments for Property modifiedDate in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmScalarPropertyAttribute(IsNullable=false)]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.DateTime modifiedDate
        {
            get
            {
                return this._modifiedDate;
            }
            set
            {
                this.OnmodifiedDateChanging(value);
                this.ReportPropertyChanging("modifiedDate");
                this._modifiedDate = global::System.Data.Objects.DataClasses.StructuralObject.SetValidValue(value);
                this.ReportPropertyChanged("modifiedDate");
                this.OnmodifiedDateChanged();
            }
        }
        private global::System.DateTime _modifiedDate;
        partial void OnmodifiedDateChanging(global::System.DateTime value);
        partial void OnmodifiedDateChanged();
        /// <summary>
        /// There are no comments for MediaTerm in the schema.
        /// </summary>
        [global::System.Data.Objects.DataClasses.EdmRelationshipNavigationPropertyAttribute("RawCatalogDBModel", "FK_MediaTerm_TermType", "MediaTerm")]
        [global::System.Xml.Serialization.XmlIgnoreAttribute()]
        [global::System.Xml.Serialization.SoapIgnoreAttribute()]
        [global::System.Runtime.Serialization.DataMemberAttribute()]
        public global::System.Data.Objects.DataClasses.EntityCollection<MediaTerm> MediaTerm
        {
            get
            {
                return ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.GetRelatedCollection<MediaTerm>("RawCatalogDBModel.FK_MediaTerm_TermType", "MediaTerm");
            }
            set
            {
                if ((value != null))
                {
                    ((global::System.Data.Objects.DataClasses.IEntityWithRelationships)(this)).RelationshipManager.InitializeRelatedCollection<MediaTerm>("RawCatalogDBModel.FK_MediaTerm_TermType", "MediaTerm", value);
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\token\TokenJob.cs ===
using System;
using System.Data;
using System.Data.SqlClient;
using System.Collections.Generic;
using System.IO;
using System.Security.Cryptography;

using xonline.common.billing;
using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.sql.sqlclient;
using xonline.common.sql.webstore;

namespace xonline.common.token
{
    public enum TokenJobStatusEnum : byte
    {
        Pending     = 1,
        InProgress  = 2,
        Delivered   = 3,
        Failed      = 4,
    }

    public class TokenJobStatus
    {
        internal TokenJobStatus(Guid id, TokenJobStatusEnum status, DateTime lastActivity, int numTokensRequested, int numTokensCompleted, bool jobIsStale, DateTime submitted, int numFailures, DateTime nextProcessing, bool isTest, string tokenFile)
        {
            _id = id;
            _status = status;
            _lastActivity = lastActivity;
            _numTokensRequested = numTokensRequested;
            _numTokensCompleted = numTokensCompleted;
            _jobIsStale = jobIsStale;
            _submitted = submitted;
            _numFailures = numFailures;
            _nextProcessing = nextProcessing;
            _isTest = isTest;
            _tokenFile = tokenFile;
        }

        public Guid Id
        {
            get { return _id; }
        }
        public TokenJobStatusEnum Status
        {
            get { return _status; }
        }
        public DateTime LastActivity
        {
            get { return _lastActivity; }
        }
        public int NumTokensRequested
        {
            get { return _numTokensRequested; }
        }
        public int NumTokensCompleted
        {
            get { return _numTokensCompleted; }
        }
        public bool JobIsStale
        {
            get { return _jobIsStale; }
        }
        public DateTime Submitted
        {
            get { return _submitted; }
        }
        public int NumFailures
        {
            get { return _numFailures; }
        }
        public DateTime NextProcessing
        {
            get { return _nextProcessing; }
        }
        public bool IsTest
        {
            get { return _isTest; }
        }
        public string TokenFile
        {
            get { return _tokenFile; }
        }

        protected Guid _id;
        protected TokenJobStatusEnum _status;
        protected DateTime _lastActivity;
        protected int _numTokensRequested;
        protected int _numTokensCompleted;
        protected bool _jobIsStale;
        protected DateTime _submitted;
        protected int _numFailures;
        protected DateTime _nextProcessing;
        protected bool _isTest;
        protected string _tokenFile;
        protected int _baseSequenceNumber;
    }

    public class TokenJob
    {
        public const int MaxKeyLength = 16; // token file encryption keys can be at most 16 bytes (128 bits)

        public TokenJob(Guid jobId, Guid tokenCategoryId, string pkpn, int numTokensRequested, byte[] key, bool isTest, string behaviorInjection)
        {
            if (numTokensRequested <= 0)
            {
                throw new XRLExceptionWithoutEvent(HResult.E_INVALIDARG, "numTokens must be greater than zero.");
            }

            if (key == null || key.Length > MaxKeyLength)
            {
                throw new XRLExceptionWithoutEvent(HResult.E_INVALIDARG, "key must be non-null and no more than 16 bytes.");
            }

            _id = jobId;
            _jobHistoryId = Guid.Empty;
            _tokenCategoryId = tokenCategoryId;
            _pkpn = pkpn;
            _numTokensRequested = numTokensRequested;
            _outputPath = GetFinalOutputPath(jobId);
            _key = key;
            _isStale = false;
            _isTest = isTest;
            _behaviorInjection = (behaviorInjection == null) ? string.Empty : behaviorInjection;
        }

        public static string GetTempOutputPath(Guid jobId)
        {
            string tempDirectory = Config.GetSetting(Setting.tokenService_tempOutputDirectory);

            if ( !Directory.Exists(tempDirectory) )
            {

                Xom.Trace(XomAreaName.tokenTrace, LogLevel.L_NORMAL, "GetTempOutputPath: creating temporary output directory: " + tempDirectory);

                Directory.CreateDirectory(tempDirectory);
            }

            string tempPath = string.Format(@"{0}\{1}.tmp", tempDirectory, jobId.ToString());

            return tempPath;
        }

        public static string GetFinalOutputPath(Guid jobId)
        {
            string outputDirectory = Config.GetSetting(Setting.tokenService_finalOutputDirectory);

            if ( !Directory.Exists(outputDirectory) )
            {
                Xom.Trace(XomAreaName.tokenTrace, LogLevel.L_NORMAL, "GetFinalOutputPath: creating final output directory: " + outputDirectory);

                Directory.CreateDirectory(outputDirectory);
            }

            string path = string.Format(@"{0}\{1}.xtx", outputDirectory, jobId.ToString());

            return path;
        }

        public static Guid[] GetPendingJobIds()
        {
            List<Guid> jobIdList = new List<Guid>();

            using (SqlClient cmd = new SqlClient(Interface.npdb))
            {
                cmd.StoredProc = "dbo.p_token_job_get_pending_jobs";

                cmd.AddParameter(ParameterDirection.ReturnValue, "@hr", 0);
                cmd.AddParameter("@i_consider_stale_seconds", Config.GetIntSetting(Setting.tokenService_considerStaleSeconds));
                cmd.AddParameter("@fl_delay_base_number", Config.GetDoubleSetting(Setting.tokenService_delayBaseNumber));
                cmd.AddParameter("@fl_delay_exponent_factor", Config.GetDoubleSetting(Setting.tokenService_delayExponentFactor));
                cmd.AddParameter("@i_max_failure_threshold", Config.GetIntSetting(Setting.tokenService_maxFailureThreshold));

                using (SqlDataReader r = cmd.Execute())
                {
                    while ( r.Read() )
                    {
                        Guid jobId = r.GetGuid(0);

                        jobIdList.Add(jobId);
                    }
                }
            }

            Xom.Trace(XomAreaName.tokenTrace, LogLevel.L_NORMAL, string.Format("TokenJob.GetPendingJobIds: found {0} pending job(s).", jobIdList.Count) );

            return jobIdList.ToArray();
        }

        public static void GetStatus(Guid id, out TokenJobStatusEnum status, out DateTime lastActivity, out bool jobIsStale, out int numTokensRequested, out int numTokensCompleted, out DateTime submitted, out int numFailures, out DateTime nextProcessing)
        {
            status = TokenJobStatusEnum.Pending;
            lastActivity = DateTime.MinValue;
            jobIsStale = true;
            numTokensRequested = -1;
            numTokensCompleted = -1;
            submitted = DateTime.MinValue;
            numFailures = -1;
            nextProcessing = DateTime.MinValue;
            TokenJobStatus tjs = null;

            tjs = GetStatus(id); // Note: all failure paths throw exceptoins

            if(tjs != null)
            {
                status = tjs.Status;
                lastActivity = tjs.LastActivity;
                jobIsStale = tjs.JobIsStale;
                numTokensRequested = tjs.NumTokensRequested;
                numTokensCompleted = tjs.NumTokensCompleted;
                submitted = tjs.Submitted;
                numFailures = tjs.NumFailures;
                nextProcessing = tjs.NextProcessing;
            }
        }

        public static TokenJobStatus GetStatus(Guid id)
        {
            TokenJobStatus tjs = null;

            using (SqlClient cmd = new SqlClient(Interface.npdb))
            {
                cmd.StoredProc = "dbo.p_token_job_get_status";

                cmd.AddParameter(ParameterDirection.ReturnValue, "@hr", 0);
                cmd.AddParameter("@uid_job_id", id);
                cmd.AddParameter("@i_consider_stale_seconds", Config.GetIntSetting(Setting.tokenService_considerStaleSeconds));

                using (SqlDataReader r = cmd.Execute())
                {
                    if ( r.Read() )
                    {
                        TokenJobStatusEnum status = (TokenJobStatusEnum) r.GetByte(0);
                        DateTime lastActivity = r.GetDateTime(1);
                        int numTokensRequested = r.GetInt32(2);
                        int numTokensCompleted = r.GetInt32(3);
                        bool jobIsStale = ( 1 == r.GetByte(4) );
                        DateTime submitted = r.GetDateTime(5);
                        int numFailures = r.GetInt32(6);
                        DateTime nextProcessing = r.GetDateTime(7);
                        bool isTest = ( 1 == r.GetByte(8) );
                        string tokenFile = r.GetString(9);
                        Guid tokenCategoryId = r.GetGuid(10);
                        int baseSequenceNumber = r.GetInt32(11);

                        // only delivered tokens have valid paths
                        if (status == TokenJobStatusEnum.Delivered)
                        {
                            tokenFile = Path.GetFileName(tokenFile);
                        }
                        else
                        {
                            tokenFile = String.Empty;
                        }

                        // fill out the return TokenJobStatus object
                        tjs = new TokenJobStatus(id, status, lastActivity, numTokensRequested, numTokensCompleted, jobIsStale, submitted, numFailures, nextProcessing, isTest, tokenFile);
                    }
                    else
                    {
                        throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_TOKEN_JOB_NOT_FOUND, "TokenJob.GetStatus: dbo.p_token_job_get_status returned no data!");
                    }

                    HResult hr = (uint) cmd.GetIntParameter("@hr");
                    if (HResult.Failed(hr))
                    {
                        throw new XRLExceptionWithoutEvent(hr, "TokenJob.GetStatus failed!");
                    }
                }
            }

            Xom.Trace( XomAreaName.tokenTrace, LogLevel.L_NORMAL, "TokenJob.GetStatus: returning: status={0}, lastActivity={1}, jobIsStale={2}, numTokensRequested={3}, numTokensCompleted={4}, submitted={5}, numFailures={6}, nextProcessing={7}", tjs.Status.ToString(), tjs.LastActivity.ToString(), tjs.JobIsStale.ToString(), tjs.NumTokensRequested, tjs.NumTokensCompleted, tjs.Submitted.ToString(), tjs.NumFailures, tjs.NextProcessing.ToString() );

            return tjs;
        }

        public static List<TokenJobStatus> GetStatusByCategory(Guid tokenCategoryId)
        {
            // creating empty instance of TokenCategory class to fill and return it back to the caller
            List<TokenJobStatus> tjsList = new List<TokenJobStatus>();
            string tokenFile = String.Empty;
            Guid jobId = Guid.Empty;
            int numTokensRequested = -1;
            int numTokensCompleted = -1;
            TokenJobStatusEnum status;

            using (SqlClient cmd = new SqlClient(Interface.npdb))
            {
                cmd.StoredProc = "dbo.p_token_job_get_status_by_category";

                cmd.AddParameter("@uid_token_category_id", tokenCategoryId);
                cmd.AddParameter("@i_consider_stale_seconds", Config.GetIntSetting(Setting.tokenService_considerStaleSeconds));

                using (SqlDataReader r = cmd.Execute())
                {
                    while (r.Read())
                    {
                        jobId = r.GetGuid(0);
                        status = (TokenJobStatusEnum) r.GetByte(1);
                        numTokensRequested = r.GetInt32(3);
                        numTokensCompleted = r.GetInt32(4);
                        tokenFile = r.GetString(10);
                        int baseSequenceNumber = r.GetInt32(11);

                        // only delivered tokens have valid paths
                        if (status == TokenJobStatusEnum.Delivered)
                        {
                            tokenFile = Path.GetFileName(tokenFile);
                        }
                        else
                        {
                            tokenFile = String.Empty;
                        }

                        // reading data and adding current TokenJobStatus object to object collection
                        tjsList.Add(
                            new TokenJobStatus
                                (
                                jobId,                              // id
                                status,                             // status
                                r.GetDateTime(2),                   // lastActivity
                                numTokensRequested,                 // numTokensRequested
                                numTokensCompleted,                 // numTokensCompleted
                                ( 1 == r.GetByte(5) ),              // jobIsStale
                                r.GetDateTime(6),                   // submitted
                                r.GetInt32(7),                      // numFailures
                                r.GetDateTime(8),                   // nextProcessing
                                ( 1 == r.GetByte(9) ),              // isTest
                                 tokenFile                          // tokenFile
                                )
                            );
                    }

                    r.Close();
                }
            }

            Xom.Trace( XomAreaName.tokenTrace, LogLevel.L_NORMAL, string.Format("TokenJob.GetStatusByCategory: returning: array of {0} TokenJobStatuses", tjsList.Count) );

            return tjsList;
        }

        public static TokenJob GetPendingJob(Guid jobId)
        {
            TokenJob job = null;

            // load job from NPDB and mark it as InProgress
            using (SqlClient cmd = new SqlClient(Interface.npdb))
            {
                cmd.StoredProc = "dbo.p_token_job_get_pending_job";

                cmd.AddParameter(ParameterDirection.ReturnValue, "@hr", 0);
                cmd.AddParameter("@uid_job_id", jobId);
                cmd.AddParameter("@i_consider_stale_seconds", Config.GetIntSetting(Setting.tokenService_considerStaleSeconds));

                TokenJob tempJob = null;

                using (SqlDataReader r = cmd.Execute())
                {
                    if ( r.Read() )
                    {
                        Guid dbJobId = r.GetGuid(r.GetOrdinal("uid_job_id"));
                        Guid tokenCategoryId = r.GetGuid(r.GetOrdinal("uid_token_category_id"));
                        int numTokensRequested = r.GetInt32(r.GetOrdinal("i_num_tokens_requested"));
                        int baseSequenceNumber = r.GetInt32(r.GetOrdinal("i_base_sequence_number"));
                        string outputPath = r.GetString(r.GetOrdinal("vc_output_path"));
                        int keyEncryptionKeyVersion = r.GetInt32(r.GetOrdinal("i_key_encryption_key_version"));
                        byte[] encryptedKey = SqlClient.GetBytes(r, "bin_key");
                        byte[] iv = SqlClient.GetBytes(r, "bin_iv");
                        byte previousJobStatusId = r.GetByte(r.GetOrdinal("ti_previous_job_status_id"));
                        Guid jobHistoryId = r.GetGuid(r.GetOrdinal("uid_job_history_id"));
                        bool isTest = (r.GetByte(r.GetOrdinal("f_is_test")) != 0);
                        string behaviorInjection = r.GetString(r.GetOrdinal("vc_behavior_injection"));

                        // decrypt the encrypted Token File Encryption Key
                        byte[] key = TokenCrypto.GetDecryptedTokenKey(encryptedKey, iv, keyEncryptionKeyVersion);

                        // load the token category to find the PKPN
                        TokenCategory tc = TokenCategory.GetTokenCategory(tokenCategoryId);

                        tempJob = new TokenJob(dbJobId, tc.Id, tc.Pkpn, numTokensRequested, key, isTest, behaviorInjection);
                        tempJob._baseSequenceNumber = baseSequenceNumber;
                        tempJob._outputPath = outputPath;
                        tempJob._jobHistoryId = jobHistoryId;

                        // if the job was previously InProgress, cleanup any stale progress
                        tempJob._isStale = ( previousJobStatusId == (byte) TokenJobStatusEnum.InProgress );

                        job = tempJob;
                    }
                    else
                    {
                        throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_TOKEN_JOB_NOT_FOUND, "TokenJob.GetPendingJob: dbo.p_token_job_get_pending_job no data!");
                    }

                }

                HResult hr = (uint) cmd.GetIntParameter("@hr");
                if (HResult.Failed(hr))
                {
                    throw new XRLExceptionWithoutEvent(hr, "TokenJob.GetPendingJob failed!");
                }
            }

            Xom.Trace( XomAreaName.tokenTrace, LogLevel.L_NORMAL, string.Format("TokenJob.GetPendingJob: returning details for jobId={0}", jobId.ToString()) );

            return job;
        }

        public void RecordJobPending()
        {
            // generate a random IV for encrypting the TFEK
            RNGCryptoServiceProvider rng = new RNGCryptoServiceProvider();
            byte[] iv = new byte[TokenCrypto.IVSize];
            rng.GetBytes(iv);

            int keyEncryptionKeyVersion = -1;
            byte[] encryptedKey;
            TokenCrypto.GetEncryptedTokenFileEncryptionKey(this.Key, iv, out keyEncryptionKeyVersion, out encryptedKey);

            using (SqlClient cmd = new SqlClient(Interface.npdb))
            {
                cmd.StoredProc = "dbo.p_token_job_record_pending";

                cmd.AddParameter(ParameterDirection.ReturnValue, "@hr", 0);
                cmd.AddParameter("@uid_job_id", this.Id);
                cmd.AddParameter("@uid_token_category_id", this.TokenCategoryId);
                cmd.AddParameter("@i_num_tokens_requested", this.NumTokensRequested);
                cmd.AddParameter("@i_key_encryption_key_version", keyEncryptionKeyVersion);
                cmd.AddParameter("@bin_key", encryptedKey);
                cmd.AddParameter("@bin_iv", iv);
                cmd.AddParameter("@vc_output_path", this.OutputPath);
                cmd.AddParameter("@vc_pkpn", this.Pkpn);
                cmd.AddParameter("@i_max_sequence_number_index", SequenceNumberGenerator.MaxIndex);
                cmd.AddParameter("@f_is_test", this.IsTest ? 1 : 0);
                cmd.AddParameter("@vc_behavior_injection", this.BehaviorInjection);

                cmd.ExecuteNonQuery();

                HResult hr = (uint) cmd.GetIntParameter("@hr");
                if (HResult.Failed(hr))
                {
                    throw new XRLExceptionWithoutEvent(hr, "TokenJob.RecordJobPending failed!");
                }
            }

            Xom.Trace( XomAreaName.tokenTrace, LogLevel.L_NORMAL, string.Format("TokenJob.RecordJobPending: completed successfully for jobId={0}", this.Id.ToString()) );
        }

        public void RecordJobDelivered()
        {
            using (SqlClient cmd = new SqlClient(Interface.npdb))
            {
                cmd.StoredProc = "dbo.p_token_job_record_delivered";

                cmd.AddParameter(ParameterDirection.ReturnValue, "@hr", 0);
                cmd.AddParameter("@uid_job_id", this.Id);
                cmd.AddParameter("@uid_job_history_id", this.JobHistoryId);

                cmd.ExecuteNonQuery();

                HResult hr = (uint) cmd.GetIntParameter("@hr");
                if (HResult.Failed(hr))
                {
                    throw new XRLExceptionWithoutEvent(hr, "TokenJob.RecordJobDelivered failed!");
                }
            }

            Xom.Trace( XomAreaName.tokenTrace, LogLevel.L_NORMAL, string.Format("TokenJob.RecordJobDelivered: completed successfully for jobId={0}", this.Id.ToString()) );
        }

        public void RecordJobProgress(int numTokensCompleted)
        {
            using (SqlClient cmd = new SqlClient(Interface.npdb))
            {
                cmd.StoredProc = "dbo.p_token_job_record_progress";

                cmd.AddParameter(ParameterDirection.ReturnValue, "@hr", 0);
                cmd.AddParameter("@uid_job_id", this.Id);
                cmd.AddParameter("@i_num_tokens_completed", numTokensCompleted);

                cmd.ExecuteNonQuery();

                HResult hr = (uint) cmd.GetIntParameter("@hr");
                if (HResult.Failed(hr))
                {
                    throw new XRLExceptionWithoutEvent(hr, "TokenJob.RecordJobProgress failed!");
                }
            }

            Xom.Trace( XomAreaName.tokenTrace, LogLevel.L_NORMAL, string.Format("TokenJob.RecordJobProgress: completed successfully for jobId={0}, numTokensCompleted={1}", this.Id.ToString(), numTokensCompleted.ToString()) );
        }

        public void RecordJobFailure(HResult hr, string errorMessage)
        {
            using (SqlClient cmd = new SqlClient(Interface.npdb))
            {
                cmd.StoredProc = "dbo.p_token_job_record_failure";

                cmd.AddParameter(ParameterDirection.ReturnValue, "@hr", 0);
                cmd.AddParameter("@uid_job_id", this.Id);
                cmd.AddParameter("@uid_job_history_id", this.JobHistoryId);
                cmd.AddParameter("@i_hresult", (uint)hr);
                cmd.AddParameter("@vc_error_message", errorMessage);

                cmd.ExecuteNonQuery();

                HResult dbHr = (uint) cmd.GetIntParameter("@hr");
                if (HResult.Failed(dbHr))
                {
                    throw new XRLExceptionWithoutEvent(dbHr, "TokenJob.RecordJobFailed failed!");
                }
            }

            Xom.Trace( XomAreaName.tokenTrace, LogLevel.L_NORMAL, string.Format("TokenJob.RecordJobFailed: completed successfully for jobId={0}, hr={1}, errorMessage={2}", this.Id.ToString(), hr.ToString(), errorMessage) );
        }

        public void MarkJobFailure(HResult hr, string errorMessage)
        {
            using (SqlClient cmd = new SqlClient(Interface.npdb))
            {
                cmd.StoredProc = "dbo.p_token_job_mark_failure";

                cmd.AddParameter(ParameterDirection.ReturnValue, "@hr", 0);
                cmd.AddParameter("@uid_job_id", this.Id);
                cmd.AddParameter("@uid_job_history_id", this.JobHistoryId);
                cmd.AddParameter("@i_hresult", (uint)hr);
                cmd.AddParameter("@vc_error_message", errorMessage);

                cmd.ExecuteNonQuery();

                HResult dbHr = (uint)cmd.GetIntParameter("@hr");
                if (HResult.Failed(dbHr))
                {
                    throw new XRLExceptionWithoutEvent(dbHr, "TokenJob.MarkJobFailed failed!");
                }
            }

            Xom.Trace(XomAreaName.tokenTrace, LogLevel.L_NORMAL, string.Format("TokenJob.MarkJobFailed: completed successfully for jobId={0}, hr={1}, errorMessage={2}", this.Id.ToString(), hr.ToString(), errorMessage));
        }

        internal void CleanupTokenDb()
        {
            foreach (int physicalPartition in WSClient.GetPhysicalPartitions(ConfigUtil.TokendbWebstoreApp))
            {
                using (WSClient ws = new WSClient(ConfigUtil.TokendbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
                {
                    HResult hr = HResult.E_FAIL;

                    ws.StoredProc = "dbo.p_delete_incomplete_tokens";
                    ws.PhysicalPartition = physicalPartition;
                    ws.Command.CommandTimeout = 60;
                    ws.AddParameter(ParamType.RETVAL, "@hr", hr);
                    ws.AddParameter("@uid_job_id", this.Id);

                    ws.ExecuteNonQuery();

                    hr = (uint)ws.GetIntParameter("@hr");
                    if (HResult.Failed(hr))
                    {
                        throw new XRLExceptionWithoutEvent(hr, string.Format("dbo.p_delete_incomplete_tokens failed with for @uid_job_id={0}", this.Id.ToString()));
                    }
                }
            }
        }

        public void ResetStaleJob()
        {
            string tempPath = GetTempOutputPath(Id);
            if ( !string.IsNullOrEmpty(tempPath) && File.Exists(tempPath) )
            {
                Xom.Trace(XomAreaName.tokenTrace, LogLevel.L_LOW, string.Format("ResetStaleJob: removing stale temp file: {0}...", tempPath));
                File.Delete(tempPath);
            }

            if ( !string.IsNullOrEmpty(OutputPath) && File.Exists(OutputPath) )
            {
                Xom.Trace(XomAreaName.tokenTrace, LogLevel.L_LOW, string.Format("ResetStaleJob: removing stale output file: {0}...", OutputPath));
                File.Delete(OutputPath);
            }

            CleanupTokenDb();

            using (SqlClient cmd = new SqlClient(Interface.npdb))
            {
                cmd.StoredProc = "dbo.p_token_job_reset_stale_job";

                cmd.AddParameter(ParameterDirection.ReturnValue, "@hr", 0);
                cmd.AddParameter("@uid_job_id", this.Id);

                cmd.ExecuteNonQuery();

                HResult hr = (uint) cmd.GetIntParameter("@hr");
                if (HResult.Failed(hr))
                {
                    throw new XRLExceptionWithoutEvent(hr, "TokenJob.ResetStaleJob failed!");
                }
            }

            this._isStale = false;

            Xom.Trace( XomAreaName.tokenTrace, LogLevel.L_NORMAL, string.Format("TokenJob.ResetStaleJob: completed successfully for jobId={0}", this.Id.ToString()) );
        }

        public void GenerateTokens()
        {
            TokenServiceFramework.GenerateTokens(this);
            RecordJobDelivered();
        }

        public Guid Id
        {
            get { return _id; }
        }

        public Guid JobHistoryId
        {
            get { return _jobHistoryId; }
        }

        public Guid TokenCategoryId
        {
            get { return _tokenCategoryId; }
        }

        public int NumTokensRequested
        {
            get { return _numTokensRequested; }
        }

        public string OutputPath
        {
            get { return _outputPath; }
        }

        public string Pkpn
        {
            get { return _pkpn; }
        }

        public int BaseSequenceNumber
        {
            get { return _baseSequenceNumber; }
        }

        public byte[] Key
        {
            get { return _key; }
        }

        public bool IsStale
        {
            get { return _isStale; }
        }

        public bool IsTest
        {
            get { return _isTest; }
        }

        public string BehaviorInjection
        {
            get { return _behaviorInjection; }
        }

        protected Guid _id;
        protected Guid _jobHistoryId;
        protected Guid _tokenCategoryId;
        protected int _numTokensRequested;
        protected string _outputPath;
        protected string _pkpn;
        protected int _baseSequenceNumber;
        protected byte [] _key;
        protected bool _isStale;
        protected bool _isTest;
        protected string _behaviorInjection;

        // RSM GroupId
        public static int GroupId
        {
            get { return _groupId; }
        }
        const int _groupId = 26;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\token\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_common_token_none_12.4.56.0_none_03ebeb7768ae3b4f
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_common_token_no-public-key_12.4.56.0_x-ww_0b192c3b
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=common_token
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_common_token_no-public-key_12.4.56.0_x-ww_0b192c3b
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_common_token_no-public-key_12.4.56.0_x-ww_0b192c3b.manifest
XP_MANIFEST_PATH=manifests\x86_common_token_no-public-key_12.4.56.0_x-ww_0b192c3b.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_common_token_no-public-key_12.4.56.0_x-ww_0b192c3b.cat
XP_CATALOG_PATH=manifests\x86_common_token_no-public-key_12.4.56.0_x-ww_0b192c3b.cat
XP_PAYLOAD_PATH=x86_common_token_no-public-key_12.4.56.0_x-ww_0b192c3b
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=common_token,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\token\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_common_token_none_12.4.56.0_none_03ebeb7768ae3b4f
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_common_token_no-public-key_12.4.56.0_x-ww_0b192c3b
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=common_token
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_common_token_no-public-key_12.4.56.0_x-ww_0b192c3b
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_common_token_no-public-key_12.4.56.0_x-ww_0b192c3b.manifest
XP_MANIFEST_PATH=manifests\x86_common_token_no-public-key_12.4.56.0_x-ww_0b192c3b.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_common_token_no-public-key_12.4.56.0_x-ww_0b192c3b.cat
XP_CATALOG_PATH=manifests\x86_common_token_no-public-key_12.4.56.0_x-ww_0b192c3b.cat
XP_PAYLOAD_PATH=x86_common_token_no-public-key_12.4.56.0_x-ww_0b192c3b
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=common_token,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\token\TokenService.cs ===
using System;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.IO;
using System.IO.Compression;
using System.Security.Cryptography;

using xonline.common.billing;
using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.sql.sqlclient;
using xonline.common.sql.webstore;
using xonline.common.user;

using Microsoft.Webstore.WstClient;

[assembly: XomAreaDefinition(XomAreaName.tokenTrace)]

namespace xonline.common.token
{
    internal class HashEntry
    {
        public byte[] hash;
        public uint seqNum;
    }

    internal class TokenEntry
    {
        internal TokenEntry(string token, uint sequenceNumber)
        {
            this.token = token;
            this.sequenceNumber = sequenceNumber;
        }

        public string token;
        public uint sequenceNumber;
    }

    internal class HashList : List<HashEntry>
    {
        public HashList(int logicalPartition)
        {
            LogicalPartition = logicalPartition;
        }

        public int LogicalPartition;

    }

    public class TokenServiceFramework
    {
        public static int NumLogicalPartitions = -1;

        static TokenServiceFramework()
        {
            try
            {
                Init();
            }
            catch (Exception)
            {
            }
        }

        #region
        private static object syncObject = new object();
        private static bool isInitialized = false;
        private static int fileBufferSize = 8192;

        public static void Init()
        {
            if (isInitialized == false)
            {
                lock (syncObject)
                {
                    if (isInitialized == false)
                    {
                        // initialize xmgmt if necessary
                        //XomLoggingControl.Init();

                        using (WSClient ws = new WSClient(ConfigUtil.TokendbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
                        {
                            NumLogicalPartitions = ws.LogicalPartitions;
                        }

                        isInitialized = true;
                    }
                }
            }
        }
        #endregion

        /// <summary>
        /// Gets next available start number for new sequence range
        /// </summary>
        /// <param name="pkpn">varchar(16)</param>
        /// <param name="batchSize">number of tokens in batch to be generated</param>
        /// <returns></returns>
        private static uint GetNextSequenceStartPoint(string pkpn, int batchSize, Guid jobId, uint maxSequenceNumber)
        {
            int nextSequenceStartPoint = -1;

            // do all required database calls here
            using (SqlClient cmd = new SqlClient(Interface.npdb))
            {
                HResult hr = HResult.E_FAIL;
                cmd.StoredProc = "dbo.p_token_get_next_sequence_number_for_pkpn";
                cmd.AddParameter(ParameterDirection.ReturnValue, "@hr", hr);
                cmd.AddParameter("@vc_pkpn", pkpn);
                cmd.AddParameter("@i_batch_size", batchSize);
                cmd.AddParameter("@uid_job_id", jobId);
                cmd.AddParameter("@i_max_sequence_number", (int)maxSequenceNumber);

                using (SqlDataReader r = cmd.Execute())
                {
                    if (r.Read())
                    {
                        nextSequenceStartPoint = r.GetInt32(0);
                        Xom.Trace(XomAreaName.tokenTrace, LogLevel.L_NORMAL, "Sequence number index starting at {0}", nextSequenceStartPoint);
                    }
                    else
                    {
                        throw new XRLException(HResult.XONLINE_E_TOKEN_NO_CATEGORY_FOUND, XEvent.Id.TOKEN_GENERATION_GET_SEQUENCE_NUMBER_FOR_PKPN_FAILURE, "dbo.p_tokens_get_next_sequence_number_for_pkpn returned no rows for PKPN: {0}", pkpn);
                    }
                }

                hr = (uint)cmd.GetIntParameter("@hr");

                if (HResult.Failed(hr))
                {
                    throw new XRLException(hr, XEvent.Id.TOKEN_GENERATION_GET_SEQUENCE_NUMBER_FOR_PKPN_FAILURE, "dbo.p_token_get_next_sequence_number_for_pkpn failed with hr: 0x{0}", hr.ToString());
                }
            }

            if (nextSequenceStartPoint < 0)
            {
                throw new XRLExceptionWithoutEvent(HResult.E_INVALIDARG, "Invalid PKPN sequence number index!");
            }
            return (uint)nextSequenceStartPoint;
        }

        public static void GenerateTokens(TokenJob job)
        {
            bool vetTokens = Config.GetBoolSetting(Setting.tokenService_vetTokens);

            GenerateTokens(job, vetTokens);
        }

        public static void GenerateTokens(TokenJob job, bool vetTokens)
        {
            Init();

            int remainingTokens = job.NumTokensRequested;
            TokenCategory tc = TokenCategory.GetTokenCategory(job.TokenCategoryId);
            uint sequenceNumberIndex = (uint)job.BaseSequenceNumber;

            List<TokenEntry> tokenList = new List<TokenEntry>();

            while (remainingTokens > 0)
            {
                int batchSize = Math.Min(remainingTokens, Config.GetIntSetting(Setting.tokenService_batchSize));
                GenerateTokenBatch(job, tc, batchSize, sequenceNumberIndex, vetTokens, tokenList, job.IsTest);
                remainingTokens -= batchSize;
                sequenceNumberIndex += (uint)batchSize;
            }

            // load Token Instances in SCS for Content codes
            LoadTokensInScsIfNeeded(tc, tokenList, job);

            // write final token list to encrypted output file
            WriteTokenOutput(job, tc, tokenList);
        }

        internal static void GenerateToken(bool vetToken, out string token, out byte[] tokenHash, out int logicalPartition)
        {
            token = null;
            tokenHash = null;
            logicalPartition = -1;

            for (; ; )
            {
                string candidate = TokenGenerator.GenerateToken();

                if (vetToken)
                {
                    string exact = null;
                    string substring = null;

                    foreach (string tuple in candidate.Split('-'))
                    {
                        if (!ForbiddenNameList.VetName(tuple, ref exact, ref substring))
                        {
                            Xom.Trace(XomAreaName.tokenTrace, LogLevel.L_LOW, "GenerateToken: token: {0} failed vetting due to: {1} match: {2}", candidate, (string.IsNullOrEmpty(exact) ? "substring" : "exact"), (string.IsNullOrEmpty(exact) ? substring : exact));

                            continue;
                        }
                    }
                }

                token = candidate;

                //The SHA 256 hash is written to the TokenDB, and are also used for content
                tokenHash = VoucherUtil.GetSha256TokenHash(token);

                //Always determine the logical partition based on the SHA 256 hash
                logicalPartition = WstHash.GetHash(BitConverter.ToInt64(tokenHash, 0), TokenServiceFramework.NumLogicalPartitions);

                break;
            }
        }

        internal static void GenerateTokenBatch(TokenJob job, TokenCategory tokenCategory, int batchSize, uint sequenceNumberIndex, bool vetTokens, List<TokenEntry> tokenList, bool isTest)
        {
            var hashLists = new HashList[TokenServiceFramework.NumLogicalPartitions];
            for (int i = 0; i < hashLists.Length; i++)
            {
                hashLists[i] = new HashList(i);
            }

            int sqlBatchSize = Config.GetIntSetting(Setting.tokenService_sqlBatchSize);

            for (uint i = 0; i < batchSize; i++)
            {
                // generate a vetted token
                string token;
                byte[] tokenHash;
                int logicalPartition;
                GenerateToken(vetTokens, out token, out tokenHash, out logicalPartition);

                HashEntry hashEntry = new HashEntry();
                hashEntry.hash = tokenHash;

                hashEntry.seqNum = SequenceNumberGenerator.GenerateSequenceNumber(sequenceNumberIndex + i);

                hashLists[logicalPartition].Add(hashEntry);

                // Later when we write out the Sha1 hash file, we calculate those hash values directly from the tokens themselves
                // So, we won't lose any hash values for that file, because we keep a complete list of all tokens in tokenList
                if (hashLists[logicalPartition].Count >= sqlBatchSize)
                {
                    WriteHashesToTokenDb(job.Id, tokenCategory, hashLists[logicalPartition], isTest);
                    hashLists[logicalPartition].Clear();
                }

                tokenList.Add(new TokenEntry(token, hashEntry.seqNum));
            }

            foreach (HashList hashList in hashLists)
            {
                WriteHashesToTokenDb(job.Id, tokenCategory, hashList, isTest);
            }

            // update token job to indicate another batch was processed
            job.RecordJobProgress(batchSize);

            Xom.Trace(XomAreaName.tokenTrace, LogLevel.L_NORMAL, "GenerateTokenBatch: successfully generated {0} tokens.", batchSize);
        }

        internal static void WriteTokenOutput(TokenJob job, TokenCategory tokenCategory, List<TokenEntry> tokenList)
        {
            XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

            string tempPath = TokenJob.GetTempOutputPath(job.Id);

            byte[] iv = job.Id.ToByteArray();

            try
            {
                using (FileStream outputFile = File.Create(tempPath, fileBufferSize, FileOptions.None))
                using (CryptoStream cryptoStream = TokenCrypto.GetTokenFileCryptoStream(outputFile, job.Key, iv, CryptoStreamMode.Write))
                using (GZipStream gzipStream = new GZipStream(cryptoStream, CompressionMode.Compress, false))

                using (StreamWriter writer = new StreamWriter(gzipStream))
                {
                    for (int i = 0; i < tokenList.Count; i++)
                    {
                        TokenEntry te = tokenList[i];
                        writer.WriteLine(string.Format("{0},{1},{2}", te.token, tokenCategory.Pkpn, te.sequenceNumber.ToString("d")));
                    }
                }
            }
            catch (Exception ex)
            {
                throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_IO_ERROR, ex, String.Format("Error encountered writing out the encrypted token file to {0}", tempPath));
            }

            Xom.Trace(XomAreaName.tokenTrace, LogLevel.L_LOW, "WriteTokenOutput: wrote {0} tokens in {1} milliseconds.", tokenList.Count, timeElapsed.MillisecondsElapsed);

#if false //Debug
            Xom.Trace(XomAreaName.tokenTrace, LogLevel.L_HIGH, "WriteTokenOutput: verifying encrypted output...");

            using (FileStream inputFile = File.Open(tempPath, FileMode.Open, FileAccess.Read, FileShare.None))
            using (CryptoStream cryptoStream = TokenCrypto.GetTokenFileCryptoStream(inputFile, job.Key, iv, CryptoStreamMode.Read))
            using (GZipStream gzipStream = new GZipStream(cryptoStream, CompressionMode.Decompress, false))
            using (StreamReader reader = new StreamReader(gzipStream))
            {
                string line = null;
                while ((line = reader.ReadLine()) != null)
                {
                    Xom.Trace(XomAreaName.tokenTrace, LogLevel.L_HIGH, "WriteTokenOutput: " + line);
                }
            }
#endif

            if (tempPath != job.OutputPath)
            {
                try
                {
                    File.Move(tempPath, job.OutputPath);
                }
                catch (Exception ex)
                {
                    throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_IO_ERROR, ex, String.Format("Error encountered while moving the the encrypted token file from temporary location at {0} to {1}.", tempPath, job.OutputPath));
                }

                Xom.Trace(XomAreaName.tokenTrace, LogLevel.L_NORMAL, "WriteTokenOutput: successfully moved temp output file: {0} to final output file: {1}", tempPath, job.OutputPath);
            }
        }

        internal static void WriteHashesToTokenDb(Guid jobId, TokenCategory tokenCategory, HashList tokenHashList, bool isTest)
        {
            int status = 0;
            int useCount = 1;

            HResult hr = HResult.E_FAIL;

            // return now if the partition has no tokens
            if (tokenHashList.Count == 0)
            {
                return;
            }

            XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

            // create a DataTable to serve as the table-valued parameter
            DataTable tokensList = new DataTable();
            tokensList.Columns.Add("bin_token_hash", typeof(byte[]));
            tokensList.Columns.Add("i_token_sequence_number", typeof(int));

            // populate data table with all rows for the token batch
            foreach (HashEntry tokenHashEntry in tokenHashList)
            {
                DataRow dr = tokensList.NewRow();
                dr["bin_token_hash"] = tokenHashEntry.hash;
                dr["i_token_sequence_number"] = tokenHashEntry.seqNum;
                tokensList.Rows.Add(dr);
            }

            using (WSClient ws = new WSClient(ConfigUtil.TokendbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.ClearParameters();
                ws.StoredProc = "dbo.p_add_tokens";
                ws.Partition = tokenHashList.LogicalPartition;
                ws.Command.CommandTimeout = 60;

                ws.AddParameter(ParamType.RETVAL, "@hr", hr);

                ws.AddParameter("@useCount", useCount);
                ws.AddParameter("@tokenStatusId", status);
                ws.AddParameter("@flagConsoleVersion", 2 /* Xbox 360 */ );
                ws.AddParameter("@hashBucket", ws.Partition);
                ws.AddParameter("@tokenCategoryId", tokenCategory.Id);
                ws.AddParameter("@jobId", jobId);
                ws.AddParameter("@f_is_test", (isTest ? 1 : 0));

                ws.Parameters.AddWithValue("TokensList", tokensList);

                ws.ExecuteNonQuery();

                hr = (uint)ws.GetIntParameter("@hr");

                if (HResult.Failed(hr))
                {
                    throw new XRLException(hr, XEvent.Id.TOKEN_GENERATION_TOKENDB_ADD_TOKENS_FAILED, string.Format("dbo.p_add_tokens failed with hr: 0x{0}", hr.ToString()));
                }

                Xom.Trace(XomAreaName.tokenTrace, LogLevel.L_LOW, "WriteToTokenDb: partition {0}: inserted {1} tokens in {2} milliseconds.", tokenHashList.LogicalPartition, tokenHashList.Count, timeElapsed.MillisecondsElapsed);
            }
        }

        internal static void LoadTokensInScsIfNeeded(TokenCategory tc, List<TokenEntry> tokenList, TokenJob job)
        {
            // Load token hashes in SCS only for Content Codes
            if ((tc.IsRevenueBearing || tc.IsRoyaltyBearing || tc.InCsat) && (!CatalogUtil.IsPointsBundleMediaType((int)tc.MediaTypeId) && !CatalogUtil.IsSubscriptionMediaType((int)tc.MediaTypeId)))
            {
                int remainingSCSTokens = tokenList.Count;
                int scsIndex = 0;

                try
                {
                    while (remainingSCSTokens > 0)
                    {
                        int scsBatchSize = Math.Min(remainingSCSTokens, Config.GetIntSetting(Setting.tokenService_scsBatchSize));
                        LoadTokenInstance(tc, tokenList, scsBatchSize, scsIndex, job.IsTest);
                        remainingSCSTokens -= scsBatchSize;
                        scsIndex += scsBatchSize;
                    }
                }

                catch (Exception e)
                {
                    job.ResetStaleJob();

                    HResult hr = BillingProviderException.ToHResult(e, HResult.XONLINE_E_TOKEN_LOAD_SCS_ERROR);

                    // exceptions with events or exceptions explicitly flagged as not event-worthy are thrown as-is
                    if ((e is ExceptionWithEvent) || (e is ExceptionWithoutEvent)) throw;

                    // all others result in a request-specific event id and are considered retryable
                    throw new XRLException(hr, XEvent.Id.TOKEN_LOAD_SCS_UNKNOWN_ERROR, e.Message, true, e);
                }
            }
        }


        internal static void LoadTokenInstance(TokenCategory tokenCategory, List<TokenEntry> tokenList, int scsBatchSize, int scsIndex, bool isTest)
        {
            string responseXML = string.Empty;
            XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

            // create a Reseller Token List
            ResellerToken[] resellerTokenList = new ResellerToken[scsBatchSize];

            // populate Reseller tokens from token list
            for (int i = 0; i < scsBatchSize; i++)
            {
                ResellerToken resellerToken = new ResellerToken();
                resellerToken.IsBlackListed = false;
                resellerToken.IsTest = isTest;
                resellerToken.MaxUsage = 1;
                resellerToken.State = true;
                resellerToken.ID = ByteConvert.ToString(VoucherUtil.GetSha256TokenHash(tokenList[scsIndex + i].token)).ToUpper();

                resellerTokenList[i] = resellerToken;
            }

            ResellerTokenInfoXML resellerTokenInfoXML = new ResellerTokenInfoXML();
            resellerTokenInfoXML.PKPN = tokenCategory.Pkpn;
            resellerTokenInfoXML.InputTokenList = resellerTokenList;

            BillingProvider bdk = new BillingProvider();
            bdk.LoadTokenInstance(Guid.NewGuid(), resellerTokenInfoXML.ToXml(), out responseXML);

            Xom.Trace(XomAreaName.tokenTrace, LogLevel.L_LOW, string.Format("{0} of {1} tokens loaded to SCS in {2} milliseconds.", scsIndex + scsBatchSize, tokenList.Count, timeElapsed.MillisecondsElapsed));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\token\PartnerConfigObject.cs ===
﻿using System;
using System.Xml;
using System.Text;
using System.IO;
using System.Diagnostics;
using xonline.common.service;
using xonline.common.mgmt;
using System.Xml.Serialization;


namespace xonline.common.token
{

    /// <summary>
    /// The PartnerConfigObjectXML class is used for CTP Offer configuration 
    /// when a token category is configured and IsRevenueBearing flag is true.  
    /// This class is serialized and passed as string parameter to CTP SetPartnerConfiguration API.
    /// GetPartnerConfiguration will retrieve the data from CTP
    /// </summary>

    [System.Xml.Serialization.XmlTypeAttribute(AnonymousType = true, Namespace = "urn:schemas-microsoft-com:billing-data")]
    [System.Xml.Serialization.XmlRootAttribute(Namespace = "urn:schemas-microsoft-com:billing-data", IsNullable = false)]
    public class PartnerConfigObjectXML
    {
        /// <summary>
        /// Reseller Config Type
        /// </summary>
        public ResellerConfigType PartnerConfigObjectType { get; set; }

        /// <summary>
        /// Channel SKU / PKPN
        /// </summary>
        [System.Xml.Serialization.XmlElementAttribute("ChannelSKU", typeof(ChannelSKU))]
        [System.Xml.Serialization.XmlElementAttribute("PKPN", typeof(PKPN))]
        public object Item { get; set; }

        public string ToXml()
        {
            StringWriter Output = new StringWriter(new StringBuilder());
            string xmlString = string.Empty;

            try
            {
                XmlSerializer s = new XmlSerializer(this.GetType());
                s.Serialize(Output, this);
                xmlString = Output.ToString();

                // Strip extra xml
                xmlString = Output.ToString().Replace("xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\"", "");
                xmlString = xmlString.Replace("xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"", "");
                xmlString = xmlString.Replace("<?xml version=\"1.0\" encoding=\"utf-16\"?>", "").Trim();
            }
            catch (Exception) { }
            return xmlString;
        }
    }

    public enum ResellerConfigType
    {
        PKPN,
        ChannelSKU,
    }

    public enum GetConfigType
    {
        equals,
    }

    public class PKPN
    {
        /// <summary>
        /// PKPN Value
        /// </summary>
        public string ID { get; set; }

        /// <summary>
        /// Percentage allocation of the PKPN in Channel SKU
        /// </summary>
        public string ExpirationDate { get; set; }

        /// <summary>
        /// If it is a marketing promotional PKPN
        /// </summary>
        public bool IsMarketing { get; set; }

        /// <summary>
        /// Partner Guid
        /// </summary>
        public string SourcePartner { get; set; }

        /// <summary>
        /// Channel Type
        /// </summary>
        public string ChannelType { get; set; }

        /// <summary>
        /// Token Type
        /// </summary>
        public string TokenType { get; set; }
    }
    public class ChannelSKU
    {

        /// <summary>
        /// Partner GUID, which is preconfigured in PCT
        /// </summary>
        public string PartnerID { get; set; }

        /// <summary>
        /// Channel SKU Value
        /// </summary>
        public string ID { get; set; }

        /// <summary>
        /// List of PKPN
        /// </summary>
        public PKPNSet[] PKPNSetList { get; set; }
    }

    public class PKPNSet
    {
        /// <summary>
        /// PKPN Value
        /// </summary>
        public string PKPNID { get; set; }

        /// <summary>
        /// Percentage allocation of the PKPN in Channel SKU
        /// </summary>
        public double PercentageAllocation { get; set; }

        /// <summary>
        /// Bill of meterial's quantity
        /// </summary>
        public int BOMQuantity { get; set; }

        /// <summary>
        /// Min price of the PKPN sold
        /// </summary>
        public double MinPriceUSD { get; set; }

        /// <summary>
        /// Max price of the PKPN sold
        /// </summary>
        public double MaxPriceUSD { get; set; }
    }

    public partial class PartnerConfigurationResponse
    {
        public ResellerConfigType PartnerConfigObjectType { get; set; }

        public string ResultDetails { get; set; }

        public int Version { get; set; }

        public PartnerConfigQueryResult[] PartnerConfigQueryResultSet { get; set; }
    }

    public partial class PartnerConfigQueryResult
    {
        public PartnerConfigObjectXML PartnerConfigObjectXML { get; set; }
    }

    public partial class PartnerConfigQueryResultSet
    {
        public PartnerConfigQueryResult[] PartnerConfigQueryResult { get; set; }
    }

    public partial class PartnerConfigQuery
    {
        public GetConfigType QueryType { get; set; }

        public ResellerConfigType PartnerConfigObjectType { get; set; }

        public string Value { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\user\GamertagSuggestionType.cs ===
namespace xonline.common.user
{
    public enum GamertagSuggestionType
    {
        NounAdjectiveSuggestion,
        SeedSuggestion,
        UniqueNounAdjectiveSuggestion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\user\NounAdjectiveGamertagSuggestions.cs ===
using System;
using System.Collections.Specialized;

using xonline.common.mgmt;
using xonline.common.service;

namespace xonline.common.user
{
    public class NounAdjectiveGamertagSuggestions : GamertagSuggestions
    {
        public override ushort GetNameSuggestions(GamertagSuggestionParameters parameters, out string[] names)
        {
            ushort i = 0;
            string seed = string.Empty;
            string gamertag;

            StringCollection adjList = null;
            StringCollection nounList = null;

            if (parameters.MaxNames == 0)
            {
                // nothing to do
                names = null;
                return 0;
            }

            if (!NameUtil.VerifyGamerTag(parameters.Seed, false) || !NameUtil.VetName(parameters.Seed) || parameters.Seed.Length > NameUtil.MAX_BASE_NAME_LEN)
            {
                nounList = NounList.CreateInstance((ushort)parameters.CountryId);
            }
            else
            {
                seed = Char.ToUpper(parameters.Seed[0]) + parameters.Seed.Substring(1);
            }

            adjList = AdjectiveList.CreateInstance((ushort)parameters.CountryId);
            names = new string[parameters.MaxNames];

            for (int attempt = 0; i < parameters.MaxNames && attempt < parameters.MaxNames * NameUtil.MAX_ATTEMPTS_MULTIPLIER; attempt++)
            {
                if (string.IsNullOrEmpty(seed))
                {
                    gamertag = adjList[Random.Next(adjList.Count)] + nounList[Random.Next(nounList.Count)];
                }
                else
                {
                    gamertag = adjList[Random.Next(adjList.Count)] + seed;
                }
                
                if (ValidateGamertag(gamertag, names))
                {
                    names[i] = gamertag;
                    i++;
                }
            }

            if (i < parameters.MaxNames)
            {
                Xom.Trace(XomAreaName.nametrace, LogLevel.L_WARNING, "NameUtil.GetNameSuggestions: Couldn't find " + parameters.MaxNames + " variations of '" + parameters.Seed + "'.  (Found " + i + ")");
            }

            return i;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\user\Machine.cs ===
using System;

using Microsoft.Webstore.WstClient;

using xonline.common.config;
using xonline.common.crypto;
using xonline.common.service;
using xonline.common.sql.webstore;

namespace xonline.common.user
{
    public class Machine
    {
        // Typical entry point to load from UODB

        public uint Load(ulong puid)
        {
            HResult hr;

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {

                hr = Load(puid, ws);
            }

            return hr;
        }

        public uint Load(ulong puid, WSClient ws)
        {
            HResult hr = 0x0;

            _puid = puid;
            _resetDate = DateTime.MinValue;
            _betaUser = 0;
            _betaTitleId = 0;
            _lastChangeDate = DateTime.MinValue;

            ws.ClearParameters();
            ws.StoredProc = "dbo.p_xmacs_get_machine_account";
            ws.SetHashVal(puid);

            ws.AddParameter(ParamType.RETVAL, "@RETVAL", 0);
            ws.AddParameter(ParamType.INPUT, "@bi_machine_puid", (long)_puid);

            // call the procedure
            using (WstDataReader rdr = ws.Execute())
            {
                if ( rdr.Read() )
                {
                    _serialNumber = rdr.GetString(0);
                    _resetDate = rdr.GetDateTime(2);
                    _betaUser = rdr.GetByte(3);
                    _betaTitleId = (uint) rdr.GetInt32(4);
                    _lastChangeDate = rdr.GetDateTime(5);
                }

                rdr.Close();

                hr = (uint)ws.GetIntParameter("@RETVAL");
            }
            return hr;
        }

        static public bool VerifyConsoleId(string consoleId)
        {
            int stringIdx = 0;
            uint actualChecksum = 0;
            uint reportedChecksum = 0;
            uint digit = 0;
            ulong ulConsoleId;

            // Validate the console length
            if (consoleId.Length != CONSOLE_ID_SIZE)
            {
                return false;
            }

            try
            {
                ulConsoleId = ulong.Parse(consoleId.Substring( 0, consoleId.Length - 1));

            }
            catch (FormatException)
            {
                return false;
            }

            if (ulConsoleId == 0 || ulConsoleId > 0x0FFFFFFFFF)
            {
                return false;
            }
            reportedChecksum = uint.Parse(consoleId[consoleId.Length - 1].ToString());

            // From XMACSProvider.cpp:
            // The console id is made of 11 significant digits + 1 checksum  digit
            // For example: XE.123456789016
            // Where 6 is the checksum of 12345678901
            // Calculate checksum now. At the same time calculate binary form
            // of the console id
            for (stringIdx = 0; stringIdx < consoleId.Length - 1; stringIdx++)
            {
                // ensure the character is a digit.
                if (!char.IsDigit(consoleId, stringIdx))
                {
                    return false;
                }

                digit = uint.Parse(consoleId[stringIdx].ToString());
                actualChecksum += digit;
            }

            actualChecksum = actualChecksum % 10;

            // verify the checksum
            if (reportedChecksum != actualChecksum)
            {
                return false;
            }
            return true;
        }

        // GetTrialCount
        // Retrieves from the database the number of trial offers consumed by
        // the console identified by machineId
        public static int GetTrialCount(ulong machineId)
        {
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.StoredProc = "dbo.p_xuacs_get_trial_count";
                ws.SetHashVal(machineId);
                ws.AddParameter("@bi_machine_id", (long)machineId);
                ws.AddParameter(ParamType.OUTPUT, "@@i_trial_count", (int)0);
                ws.ExecuteNonQuery();

                int trialCount = ws.GetIntParameter("@@i_trial_count");
                return trialCount;
            }
        }

        // IncrementTrialCount
        // Increment the number of trial offers consumed by the console
        // identified by machineId
        public static void IncrementTrialCount(ulong machineId)
        {
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.StoredProc = "dbo.p_xuacs_increment_trial_count";
                ws.SetHashVal(machineId);
                ws.AddParameter("@bi_machine_id", (long)machineId);
                ws.AddParameter("@si_hash_bucket", ws.Partition);
                ws.ExecuteNonQuery();
            }
        }

        public ulong Puid
        {
            get { return _puid; }
            set { _puid = value; }
        }

        public string SerialNumber
        {
            get { return _serialNumber; }
            set { _serialNumber = value; }
        }

        public DateTime ResetDate
        {
            get { return _resetDate; }
            set { _resetDate = value; }
        }

        public byte BetaUser
        {
            get { return _betaUser; }
            set { _betaUser = value; }
        }

        public uint BetaTitleId
        {
            get { return _betaTitleId; }
            set { _betaTitleId = value; }
        }

        public DateTime LastChangeDate
        {
            get { return _lastChangeDate; }
            set { _lastChangeDate = value; }
        }

        private ulong _puid;
        private string _serialNumber;
        private DateTime _resetDate;
        private byte _betaUser;
        private uint _betaTitleId;
        private DateTime _lastChangeDate;

        public const int CONSOLE_ID_SIZE = 12;
        public const string CONSOLE_NAME_PREFIX = "XE.";

        // in XMACS, this is a preprocessor #define
        public static int INITIAL_KEY_VERSION = 1;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\user\nameutil.cs ===
using System;
using System.Web;
using System.Text.RegularExpressions;

using Microsoft.Webstore.WstClient;

using xonline.common.billing;
using xonline.common.config;
using xonline.common.crypto;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.sql.webstore;

namespace xonline.common.user
{
    public class NameUtil
    {
        // REVIEW: should these be config settings?
        internal const int  MAX_ATTEMPTS_MULTIPLIER  = 10;
        internal const int CHANCE_MATCHING_1ST_CHAR = 80;
        internal const uint MAX_BASE_NAME_LEN = XOn.XONLINE_NAME_MAX_SIZE - 5;
        internal const uint DEFAULT_NAME_RESERVATION_MINS = 60;

        public static bool VetName(string strName)
        {
            return VetName(strName, 0);
        }

        // VetName
        //
        //  makes sure the given name is sutiable for usage on xbox live!
        //

        public static bool VetName(string name, uint titleId)
        {
            string strExact = "";
            string strSubstr = "";
            bool fNameIsOk = ForbiddenNameList.VetName( name, ref strExact, ref strSubstr, titleId );

            if ( !fNameIsOk )
            {
                if ( strExact != "" )
                {
                    Xom.Trace(XomAreaName.nametrace, LogLevel.L_INFO, "NameUtil.VetName: Rejecting '" + name + "' because '" + strExact + "' is in the exact match words list!" );
                }
                else
                {
                    Xom.Trace(XomAreaName.nametrace, LogLevel.L_INFO, "NameUtil.VetName: Rejecting '" + name + "' because it contains the word '" + strSubstr + "'!" );
                }
            }

            return( fNameIsOk );
        }


        public static bool VerifyGamerTag(string name, bool isXonWatch)
        {
            if ( name == null || name == string.Empty )
            {
                Xom.Trace(XomAreaName.nametrace, LogLevel.L_HIGH, "NameUtil.VerifyGamerTag: rejecting empty gamertag.  Clients should not be sending these!");
                return false;
            }

            if (Regex.IsMatch(name, "[^a-zA-Z0-9 ]"))
            {
                Xom.Trace(XomAreaName.nametrace, LogLevel.L_INFO, "NameUtil.VerifyGamerTag: rejecting " + name + " because it failed the check [^a-zA-Z0-9 ]");
                return false;
            }

            if (Regex.IsMatch(name, "  "))
            {
                Xom.Trace(XomAreaName.nametrace, LogLevel.L_INFO, "NameUtil.VerifyGamerTag: rejecting " + name + " because it contains two spaces in a row (  )");
                return false;
            }

            if (name[0] == ' ' || name[name.Length-1] == ' ')
            {
                Xom.Trace(XomAreaName.nametrace, LogLevel.L_INFO, "NameUtil.VerifyGamerTag: rejecting " + name + " because it starts or ends with a space");
                return false;
            }

            if (Regex.IsMatch(name, @"^\d"))
            {
                if (!isXonWatch)
                {
                    Xom.Trace(XomAreaName.nametrace, LogLevel.L_INFO, "NameUtil.VerifyGamerTag: rejecting " + name + " because it starts or ends with a space");
                    return false;
                }
                // else it's xonwatch
            }

            return true;
        }


        // best effort to validate email based on rfc 822
        public static bool VerifyEmail(string email)
        {
            // this is not perfect RFC 822 but it is much closer than it used to be
            string emailRegex =
                @"^([_a-z0-9-]+)((\.|\+)[_a-z0-9-]+)*" +             // username
                @"@([a-z0-9-]+)(\.[a-z0-9-]+)*(\.[a-z]{2,6})$";      // @hostname

            bool isMatch = Regex.IsMatch(email, emailRegex, RegexOptions.IgnoreCase);

            Xom.Trace(XomAreaName.nametrace, LogLevel.L_LOW, "NameUtil.VerifyEmail: address is " + (isMatch ? "valid" : "invalid") + " (address: " + email + ")");

            return isMatch;
        }

        public static uint ReserveGamertag(string name, ulong userPuid, ulong machinePuid, int keyEncKeyVersion, byte[] xenonKey, byte[] xenonIV, byte[] xenonSPPA, byte[] xenonPPA)
        {
            // Need a slightly different xboxKey
            XConsoleKey xbox1Key = null;
            if ( null != xenonKey )
                xbox1Key = new XConsoleKey( name );
            
            return ReserveGamertag( name,
                                    userPuid,
                                    machinePuid,
                                    keyEncKeyVersion,
                                    (null != xbox1Key) ? xbox1Key.EncryptedKey : null,
                                    (null != xbox1Key) ? xbox1Key.IV : null,
                                    (null != xbox1Key) ? xbox1Key.SPPA : null,
                                    (null != xbox1Key) ? xbox1Key.PPA : null,
                                    xenonKey,
                                    xenonIV,
                                    xenonSPPA,
                                    xenonPPA);
        }

        public static uint ReserveGamertag(string name, ulong userPuid, ulong machinePuid, int keyEncKeyVersion, byte[] xboxKey, byte[] xboxIV, byte[] xboxSPPA, byte[] xboxPPA, byte[] xenonKey, byte[] xenonIV, byte[] xenonSPPA, byte[] xenonPPA)
        {
            uint minsToReserve = NameUtil.DEFAULT_NAME_RESERVATION_MINS;
            return ReserveGamertag(name,
                                    userPuid,
                                    machinePuid,
                                    keyEncKeyVersion,
                                    xboxKey,
                                    xboxIV,
                                    xboxSPPA,
                                    xboxPPA,
                                    xenonKey,
                                    xenonIV,
                                    xenonSPPA,
                                    xenonPPA,
                                    minsToReserve);
        }

        public static uint ReserveGamertag(string name, ulong userPuid, ulong machinePuid, int keyEncKeyVersion, byte[] xboxKey, byte[] xboxIV, byte[] xboxSPPA, byte[] xboxPPA, byte[] xenonKey, byte[] xenonIV, byte[] xenonSPPA, byte[] xenonPPA, uint minsToReserve)
        {
            return ReserveGamertag(name,
                                    userPuid,
                                    machinePuid,
                                    keyEncKeyVersion,
                                    xboxKey,
                                    xboxIV,
                                    xboxSPPA,
                                    xboxPPA,
                                    xenonKey,
                                    xenonIV,
                                    xenonSPPA,
                                    xenonPPA,
                                    minsToReserve,
                                    true);
        }

        public static uint ReserveGamertag(string name, ulong userPuid, ulong machinePuid, int keyEncKeyVersion, byte[] xboxKey, byte[] xboxIV, byte[] xboxSPPA, byte[] xboxPPA, byte[] xenonKey, byte[] xenonIV, byte[] xenonSPPA, byte[] xenonPPA, uint minsToReserve, bool freeOldReservation)
        {
            string prevName = null;

            string cacheKey = "hold_name:" + machinePuid;
            HResult hr = 0x0;
            HttpContext ctx = HttpContext.Current;
            DateTime expires = DateTime.UtcNow;

            string setting = "";

            //Debug.Assert(ctx != null);

            if (userPuid == 0)
            {
                // reserving for new user
                if ( ctx != null )
                {
                    prevName = (string)ctx.Cache[cacheKey];
                }

                if (prevName != null && freeOldReservation)
                {
                    string[] prevNames = prevName.Split('|');
                    foreach (string nameToFree in prevNames)
                    {
                        if (nameToFree.Equals(""))
                        {
                            continue;
                        }
                        Xom.Trace(XomAreaName.nametrace, LogLevel.L_WARNING, "NameUtil.ReserveGamertag: Releasing '" + nameToFree + "' from puid: 0x" + machinePuid.ToString("x") + ".");
                        using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
                        {
                            ws.StoredProc = "dbo.p_xuacs_release_name";
                            ws.SetHashVal(nameToFree);

                            ws.AddParameter("@vc_gamertag", nameToFree);
                            ws.AddParameter("@bi_puid", (Int64)machinePuid);

                            ws.ExecuteNonQuery();
                        }
                    }
                    ctx.Cache.Remove(cacheKey);
                }

                // If this code appears to be running in a server context, see if XCache
                // already has a puid associated with the gamertag.  If so, it is taken
                // and there is no need to scan UODB.
                //
                // If XCache does not know about it, UODB still must be scanned to make
                // sure there is not a variant with different spacing, an in-progress
                // reservation by a different console, etc.  Still, checking XCache will
                // quickly see if a single word gamertag already exists, which is still
                // a win.
                if ( HttpContext.Current != null )
                {
                    try
                    {
                        ulong xcachePuid = XCache.LookupPUID(name);

                        if ( xcachePuid != 0 )
                        {
                            Xom.Trace(XomAreaName.nametrace, LogLevel.L_LOW, "NameUtil.ReserveGamertag: Found an existing match for '" + name + "' in XCache (puid: 0x" + xcachePuid.ToString("x") + ").  Skipping UODB partition scan." );
                            hr = HResult.XONLINE_E_ACCOUNTS_NAME_TAKEN;
                            goto Cleanup;
                        }
                        else
                        {
                            Xom.Trace(XomAreaName.nametrace, LogLevel.L_LOW, "NameUtil.ReserveGamertag: did not find match for '" + name + "' in XCache.  Checking UODB partitions now..." );
                        }
                    }
                    catch (Exception e)
                    {
                      Xom.Trace(XomAreaName.nametrace, LogLevel.L_LOW, "NameUtil.ReserveGamertag: XCache failed with exception:\r\n" + e );
                    }
                }

                // If reserving a gamertag for a new user, first call p_xuacs_check_name
                // to make sure the name (or a variation of the name differening only
                // by spaces) does not exist in any of the partitions.  All partitions
                // must be checked because the differing spaces could cause the names to
                // hash to different WebStore partitions.
                hr = NameUtil.CheckName(name, machinePuid);
                if ( HResult.XONLINE_E_ACCOUNTS_NAME_TAKEN == hr )
                {
                    Xom.Trace(XomAreaName.nametrace, LogLevel.L_INFO, "NameUtil.ReserveGamertag: Rejecting ('" + name + "', " + machinePuid + ") because p_xuacs_check_name returned hr = " + hr);
                    goto Cleanup;
                }

                try
                {
                    setting = Config.GetSetting(Setting.user_nameReservationMinutes);
                    if (setting != null && setting != "")
                    {
                        minsToReserve = Convert.ToUInt32(setting);
                    }
                }
                catch(Exception e)
                {
                    Xom.NtEvent( XEvent.Id.MC_BAD_CONFIG_DATA_8, e, "Error casting NameReservationMins setting ('" + setting + "') to uint.");
                }

                expires = expires.AddMinutes(minsToReserve);
            }

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.ClearParameters();

                ws.StoredProc = "dbo.p_xuacs_reserve_gamertag";
                ws.SetHashVal(name);

                ws.AddParameter(ParamType.RETVAL, "@RETVAL", 0);
                ws.AddParameter("@vc_gamertag", name );
                ws.AddParameter("@bi_puid", userPuid );
                ws.AddParameter("@i_kek_version", keyEncKeyVersion );
                ws.AddParameter("@bin_xbox_key", xboxKey );
                ws.AddParameter("@bin_xbox_iv", xboxIV );
                ws.AddParameter("@bin_xbox_sppa", xboxSPPA );
                ws.AddParameter("@bin_xbox_ppa", xboxPPA );
                ws.AddParameter("@bin_xenon_key", xenonKey );
                ws.AddParameter("@bin_xenon_iv", xenonIV );
                ws.AddParameter("@bin_xenon_sppa", xenonSPPA );
                ws.AddParameter("@bin_xenon_ppa", xenonPPA );
                ws.AddParameter("@dt_expires", expires );
                ws.AddParameter("@bi_machine_puid", (Int64) machinePuid );
                ws.AddParameter("@si_hash_bucket", ws.Partition );

                ws.ExecuteNonQuery();

                hr = (uint)ws.GetIntParameter("@RETVAL");
            }

            if (HResult.Failed(hr))
            {
                goto Cleanup;
            }

            if (userPuid == 0)
            {
                // associate name w/ puid, to prevent attacks
                //  that flood with name reservation requests.
                //
                // NOTE: this isn't meant to be foolproof --
                //  the user can easily reserve additional names
                //  on other servers.  but at least it's limited
                //  to ~one per server!
                //
                if ( ctx != null )
                {
                    prevName = (string)ctx.Cache[cacheKey];
                    ctx.Cache.Insert(cacheKey, prevName + "|" + name, null, DateTime.MaxValue, TimeSpan.FromMinutes( minsToReserve ));
                }
            }
            else
            {
                // now assocaited with an actual account, so remove
                // the reservation.
                if ( ctx != null )
                {
                    ctx.Cache.Remove(cacheKey);
                }
            }

            Cleanup:
            return hr;
        }

        public static uint CheckName(string name, ulong machinePuid)
        {
            return CheckName(name, machinePuid, true);
        }

        public static uint CheckName(string name, ulong machinePuid, bool checkAllPhysicalPartitions)
        {
            HResult hr = 0x0;
            // If reserving a gamertag for a new user, first call p_xuacs_check_name
            // to make sure the name does not exist
            //
            // Unless one of the stored procedures returns the error
            // XONLINE_E_ACCOUNTS_NAME_TAKEN, assume that the name is ok.
            // We don't want to block all account creations if any one
            // of the UODB servers is offline.  It should only fail if the
            // server the new name hashes to is offline.

            if ( checkAllPhysicalPartitions )
            {
                foreach (int physicalPartition in WSClient.GetPhysicalPartitions(ConfigUtil.UodbWebstoreApp))
                {
                    Xom.Trace(XomAreaName.nametrace, LogLevel.L_LOW, string.Format("CheckName: physical partition {0} is deployed.  Checking...", physicalPartition) );

                    hr = ExecuteCheckName(name, machinePuid, physicalPartition);

                    if ( hr == HResult.XONLINE_E_ACCOUNTS_NAME_TAKEN )
                    {
                        Xom.Trace(XomAreaName.nametrace, LogLevel.L_HIGH, string.Format("NameUtil.CheckName: Rejecting ('{0}', 0x{1}) because p_xuacs_check_name returned hr = {2}", name, machinePuid.ToString("x"), hr.ToString()) );
                        return hr;
                    }

                    Xom.Trace(XomAreaName.nametrace, LogLevel.L_LOW, string.Format("NameUtil.CheckName: For ('{0}, 0x{1})  p_xuacs_check_name returned hr = {2}", name, machinePuid.ToString("x"), hr.ToString()) );
                }
            }
            else
            {
                // specifying -1 for physicalParititon indicates it should use logical partition
                // based on gamertag hash
                hr = ExecuteCheckName(name, machinePuid, -1);

                Xom.Trace(XomAreaName.nametrace, LogLevel.L_LOW, string.Format("NameUtil.CheckName: For ('{0}, 0x{1})  p_xuacs_check_name returned hr = {2}", name, machinePuid.ToString("x"), hr.ToString()) );
            }

            return hr;
        }

        public static uint ExecuteCheckName(string name, ulong machinePuid, int physicalPartition)
        {
            HResult hr = HResult.E_FAIL;

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.StoredProc = "dbo.p_xuacs_check_name";

                if ( -1 == physicalPartition )
                {
                    ws.SetHashVal(name);
                }
                else
                {
                    ws.PhysicalPartition = physicalPartition;
                }

                ws.AddParameter("@vc_gamertag", name);
                ws.AddParameter("@bi_machine_puid", machinePuid);

                using (WstDataReader rs = ws.Execute())
                {
                    if ( rs.Read() )
                    {
                        hr = (uint) rs.GetInt32(0);
                    }
                }
            }

            return hr;
        }

        public static void RecordGamertagChange(ulong userPuid, string newGamertag)
        {
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                // Data is partitioned by gamertag
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(userPuid);

                ws.StoredProc = "dbo.p_xuacs_record_gamertag_change";

                ws.AddParameter(ParamType.RETVAL, "@hr", 0);
                ws.AddParameter("@bi_user_puid", userPuid);
                ws.AddParameter("@vc_new_gamertag", newGamertag);

                ws.ExecuteNonQuery();

                HResult hr = (uint)ws.GetIntParameter("@hr");
                if (HResult.Failed(hr))
                {
                    string msg = ws.GetCallSignature() + " failed with hr = " + hr;

                    throw new XRLException(hr, XEvent.Id.COMMON_CODE_210, msg);
                }
            }
        }

        public static void DeleteGamertag(string gamertag)
        {
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                // Data is partitioned by gamertag
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(gamertag);

                ws.StoredProc = "dbo.p_xuacs_delete_gamertag";

                ws.AddParameter(ParamType.RETVAL, "@ret", 0);
                ws.AddParameter("@vc_gamertag", gamertag);

                ws.ExecuteNonQuery();

                HResult hr = (uint)ws.GetIntParameter("@ret");
                if (HResult.Failed(hr))
                {
                    string msg = ws.GetCallSignature() + " failed with hr = " + hr;

                    throw new XRLException(hr, XEvent.Id.COMMON_CODE_211, msg);
                }
            }
        }

        // Flatten
        //
        // Collapse a given string into a form more suitable for
        // use in vetting naughty words using a one-way transform.
        //
        public static string Flatten(string name)
        {
            name = name.ToLower();

            name = Regex.Replace(name, "[^a-z0-9!<>|()$?/\\\\]", "");

            // 4 char substitutions
            name = name.Replace(@"/\/\", "m");
            name = name.Replace(@"\/\/", "w");

            // 2 char substitutions
            name = name.Replace("|<", "k");
            name = name.Replace("|)", "d");
            name = name.Replace("|>", "d");
            name = name.Replace("i)", "d");
            name = name.Replace("i>", "d");
            name = name.Replace("1)", "d");
            name = name.Replace("1>", "d");
            name = name.Replace("l)", "d");
            name = name.Replace("l>", "d");
            name = name.Replace(@"\/", "u");
            name = name.Replace("()", "o");
            name = name.Replace(")(", "h");

            // 1 char substitutions
            name = name.Replace("4", "a");
            name = name.Replace("8", "b");
            name = name.Replace("3", "b");
            name = name.Replace("6", "b");
            name = name.Replace("<", "c");
            name = name.Replace("(", "c");
            name = name.Replace(">", "d");
            name = name.Replace("9", "g");
            name = name.Replace("1", "i");
            name = name.Replace("!", "i");
            name = name.Replace("|", "i");
            name = name.Replace("l", "i");
            name = name.Replace('0', 'o');
            name = name.Replace('5', 's');
            name = name.Replace('$', 's');
            name = name.Replace('7', 't');
            name = name.Replace('v', 'u');
            name = name.Replace('x', 'h');

            return name;
        }


        // ChangeGamertag
        //
        // Change a user's gamerTag, either immediately, or by requiring
        // them to do so at next login
        //
        public static bool ChangeGamerTag(ulong puid, string newGamerTag)
        {
            bool ret = true;
            User u = new User();
            u.Load(puid);

            ret = ChangeGamerTag(ref u, newGamerTag);

            u.Save();

            return ret;
        }

        public static bool ChangeGamerTag(ref User u, string newGamerTag)
        {
            string oldGamerTag = u.GamerTag;
            bool ret = true;
            HResult hr = 0;

            // Change the actual GamerTag in UODB for the User (also for auth)
            // Doing so may cause user to have to recover their GamerTag
            if( NameUtil.VerifyGamerTag(newGamerTag, BillingProvider.IsXonWatchId(u.AccountId))
                && NameUtil.VetName(newGamerTag)
                && HResult.Succeeded(NameUtil.ReserveGamertag(newGamerTag, 0, u.MachinePuid, 0, null, null, null, null, null, null, null, null)))
            {

                u.GamerTag = newGamerTag;

                // generate a new Xbox1 key.
                byte [] xboxIV;
                byte [] encXboxKey;
                byte [] rawXboxKey;
                KEKCryptoMgr.GenerateNewKey(out xboxIV, out encXboxKey, out rawXboxKey);

                // generate new Xbox1 PPA data
                byte [] xboxSPPA;
                byte [] xboxPPA;
                KEKCryptoMgr.GenPPAforDBWrp(u.GamerTag, (byte []) rawXboxKey.Clone(), out xboxSPPA, out xboxPPA);

                // generate a new Xenon key.
                byte [] xenonIV;
                byte [] encXenonKey;
                byte [] rawXenonKey;
                KEKCryptoMgr.GenerateNewKey(out xenonIV, out encXenonKey, out rawXenonKey);

                // generate new Xenon PPA data
                byte [] xenonSPPA;
                byte [] xenonPPA;
                KEKCryptoMgr.GenPPAforDBWrp(u.GamerTag, (byte []) rawXenonKey.Clone(), out xenonSPPA, out xenonPPA);

                // change the name reserved for this user
                //
                hr = NameUtil.ReserveGamertag(
                    u.GamerTag,
                    u.Puid,
                    u.MachinePuid,
                    KEKCryptoMgr.GetKeyVersion(),
                    encXboxKey,
                    xboxIV,
                    xboxSPPA,
                    xboxPPA,
                    encXenonKey,
                    xenonIV,
                    xenonSPPA,
                    xenonPPA);

                if (HResult.Failed(hr))
                {
                    // unexpected failure
                    Xom.Trace(XomAreaName.nametrace, LogLevel.L_WARNING, "NameUtil.ChangeGamerTag: For ('" + newGamerTag + "', " + u.MachinePuid + ") ReserveGamertag returned hr = " + hr );
                }
                else
                {
                    // success
                    Xom.Trace(XomAreaName.nametrace, LogLevel.L_INFO, "NameUtil.ChangeGamerTag: For ('" + newGamerTag + "', " + u.MachinePuid + ") ReserveGamertag returned hr = " + hr );
                }
            }
            else
            {
                // unexpected failure
                Xom.Trace(XomAreaName.nametrace, LogLevel.L_WARNING, "NameUtil.ChangeGamerTag: For ('" + newGamerTag + "', " + u.MachinePuid + ") failed to Verify or Vet" );
                ret = false;
            }

            return ret;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\user\GamerTagSuggestionsFactory.cs ===
namespace xonline.common.user
{
    public class GamertagSuggestionsFactory
    {
        public static GamertagSuggestions GetGamerTagSuggestions(GamertagSuggestionType suggestionType)
        {
            GamertagSuggestions suggestion = null;
            switch(suggestionType)
            {
                case GamertagSuggestionType.NounAdjectiveSuggestion:
                    suggestion = new NounAdjectiveGamertagSuggestions();
                    break;
                case GamertagSuggestionType.SeedSuggestion:
                    suggestion = new SeedBasedGamertagSuggestions();
                    break;
                case GamertagSuggestionType.UniqueNounAdjectiveSuggestion:
                    suggestion = new UniqueNounAdjectiveGamertagSuggestions();
                    break;
            }

            return suggestion;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\user\GamertagSuggestionParameters.cs ===
﻿
using xonline.common.service;

namespace xonline.common.user
{
    public class GamertagSuggestionParameters
    {
        private GamertagSuggestionParameters()
        {
        }

        public GamertagSuggestionParameters(string seed)
        {
            this.Seed = seed;
            this.MaxNames = 10;
            this.CountryId = (byte)XOn.XONLINE_COUNTRY_UNITED_STATES;
        }

        public GamertagSuggestionParameters(string seed, byte countryId)
        {
            this.Seed = seed;
            this.MaxNames = 10;
            this.CountryId = countryId;
        }

        public GamertagSuggestionParameters(string seed, byte countryId, uint minsToReserve, ulong machinePuid)
        {
            this.Seed = seed;
            this.MaxNames = 10;
            this.CountryId = countryId;
            this.MinsToReserve = minsToReserve;
            this.MachinePuid = machinePuid;
        }

        public GamertagSuggestionParameters(string seed, ushort maxNames, byte countryId)
        {
            this.Seed = seed;
            this.MaxNames = maxNames;
            this.CountryId = countryId;
        }

        public GamertagSuggestionParameters(byte countryId)
        {
            this.MaxNames = 10;
            this.CountryId = countryId;
        }

        public string Seed { get; set; }

        public ushort MaxNames { get; set; }

        public byte CountryId { get; set; }

        public ulong MachinePuid { get; set; }

        public uint MinsToReserve { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\user\GamertagSuggestions.cs ===
﻿using System;
using System.Text;
using System.Web;

using xonline.common.mgmt;
using xonline.common.service;

namespace xonline.common.user
{
    public abstract class GamertagSuggestions
    {
        [ThreadStatic]
        protected static Random _random;

        protected Random Random {
            get {
                if (_random == null) _random = new Random();
                return _random;
            }
        }

        protected string GetNumericSuffix(int length)
        {
            StringBuilder stringBuilder = new StringBuilder(length);
            
            for (int i = 0; i < length; i++) {
                stringBuilder.Append(Random.Next(10).ToString());
            }
            
            return stringBuilder.ToString();
        }

        public abstract ushort GetNameSuggestions(GamertagSuggestionParameters p, out string[] names);

        public virtual bool IsGamertagAlreadyReserved() { return false; }
            
        public virtual bool ValidateGamertag(string gamertag, string[] gamertagArray)
        {
            // make sure new name is not too large
            if (gamertag.Length > XOn.XONLINE_NAME_MAX_SIZE)
            {
                Xom.Trace(XomAreaName.nametrace, LogLevel.L_LOW, "GetNameSuggestions: suggested name: '" + gamertag + "' is too long.  Skipping...");
                return false;
            }

            if (NameUtil.VetName(gamertag) == false)
            {
                Xom.Trace(XomAreaName.nametrace, LogLevel.L_LOW, "GetNameSuggestions: suggested name: '" + gamertag + "' failed to vet.  Skipping...");
                return false;
            }

            // check for dups
            for (int j = 0; j < gamertagArray.Length; j++)
            {
                if (gamertag.Equals(gamertagArray[j]))
                {
                    Xom.Trace(XomAreaName.nametrace, LogLevel.L_LOW, "GetNameSuggestions: suggested name: '" + gamertag + "' was suggested more than once.  Skipping this instance...");
                    return false;
                }
            }


            if (HttpContext.Current != null)
            {
                try
                {
                    ulong puid = XCache.LookupPUID(gamertag);
                    if (puid != 0)
                    {
                        Xom.Trace(XomAreaName.nametrace, LogLevel.L_LOW,
                                  "GetNameSuggestions: XCache already has an entry for suggested name: '" +
                                  gamertag + "'.  Skipping...");
                        return false;
                    }

                    Xom.Trace(XomAreaName.nametrace, LogLevel.L_LOW,
                              "GetNameSuggestions: no XCache entry for suggested name: '" + gamertag + "'.");
                }
                catch (Exception e)
                {
                    Xom.Trace(XomAreaName.nametrace, LogLevel.L_ERROR,
                              "GetNameSuggestions: XCache failed with exception:\r\n" + e);
                }
            }

            // name is a good suugestion
            Xom.Trace(XomAreaName.nametrace, LogLevel.L_LOW, "NameUtil.GetNameSuggestions: suggested name: '" + gamertag + "' validated properly.");    
            return true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\user\SeedBasedGamertagSuggestions.cs ===
using System;
using xonline.common.config;
using xonline.common.service;
using Config=xonline.common.config.Config;

namespace xonline.common.user
{
    public class SeedBasedGamertagSuggestions : GamertagSuggestions
    {
        public override ushort GetNameSuggestions(GamertagSuggestionParameters parameters, out string[] names)
        {
            const uint MAX_SEED_LEN = XOn.XONLINE_NAME_MAX_SIZE - 6;

            ushort namesCounter = 0;

            names = new string[parameters.MaxNames];
            
            if (NameUtil.VerifyGamerTag(parameters.Seed, false) && NameUtil.VetName(parameters.Seed))
            {
                if (ValidateGamertag(parameters.Seed, names))
                {
                    names[namesCounter] = parameters.Seed;
                    namesCounter++;
                }
            }
            else
            {
                parameters.Seed = Config.GetSetting(Setting.xuacs_seedbasedGamertagDefault);
            }

            //truncate the seed if it is more than allowed length
            if (parameters.Seed.Length > MAX_SEED_LEN)
            {
                parameters.Seed = parameters.Seed.Substring(0, (int)MAX_SEED_LEN);
            }

            //truncate the randomPart if it is more than allowed length
            int lengthRandomPart = 10;
            if ( XOn.XONLINE_NAME_MAX_SIZE - parameters.Seed.Length < lengthRandomPart )
            {
                lengthRandomPart = (int)XOn.XONLINE_NAME_MAX_SIZE - parameters.Seed.Length;
            }
            
            for (int i = 0; namesCounter < names.Length && i < parameters.MaxNames * NameUtil.MAX_ATTEMPTS_MULTIPLIER; i++)
            {

                string gamertag = parameters.Seed + GetNumericSuffix(lengthRandomPart);

                if (ValidateGamertag(gamertag, names))
                {
                    names[namesCounter] = gamertag;
                    namesCounter++;
                }
            }

            return namesCounter;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\trackedapi\TrackedApiCall.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.IO;
using System.Text;
using System.Threading;
using System.Transactions;
using System.Web;
using System.Xml;
using System.Xml.Serialization;

using Microsoft.Webstore.WstClient;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.offer;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.sql.webstore;
using xonline.common.user;
using xonline.common.utilities;

namespace xonline.common.trackedapi
{
    public class TrackedApiResult
    {
        public Guid TrackingGuid {get;set;}
        public string Component {get;set;}
        public string ApiName {get;set;}
        public string InputParams {get;set;}
        public string OutputParams {get;set;}
        public HResult HResult {get;set;}
        public string Message {get;set;}
    }

    public class TrackedApiCall
    {
        public static bool RecordPending(Guid trackingGuid, string component, string apiName, string inputParams, out TrackedApiResult result)
        {
            bool hasResult = false;

            result = null;

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.SetHashVal(trackingGuid);
                ws.StoredProc = "dbo.p_tracked_api_call_record_pending";

                ws.AddParameter(ParamType.RETVAL, "@hr", 0);
                ws.AddParameter(ParamType.INPUT, "@uid_tracking_guid", trackingGuid);
                ws.AddParameter(ParamType.INPUT, "@vc_component", component);
                ws.AddParameter(ParamType.INPUT, "@vc_api_name", apiName);
                ws.AddParameter(ParamType.INPUT, "@xml_input_params", inputParams ?? string.Empty);
                ws.AddParameter(ParamType.INPUT, "@si_hash_bucket", ws.Partition);

                using (WstDataReader r = ws.Execute())
                {
                    if ( r.Read() )
                    {
                        TrackedApiResult apiResult = new TrackedApiResult();
                        apiResult.TrackingGuid = trackingGuid;
                        apiResult.Component = component;
                        apiResult.ApiName = apiName;
                        apiResult.InputParams = inputParams;
                        apiResult.HResult = (uint) r.GetInt32(0);
                        apiResult.Message = r.IsDBNull(1) ? string.Empty : r.GetString(1);
                        apiResult.OutputParams = r.IsDBNull(2) ? string.Empty : r.GetString(2);

                        hasResult = true;

                        result = apiResult;
                    }
                }

                HResult hr = (uint) ws.GetIntParameter("@hr");
                if ( HResult.Failed(hr) )
                {
                    throw new XRLException(hr, XEvent.Id.TRACKED_API_CALL_DATABASE_ERROR, "TrackedApiResult: p_tracked_api_call_record_pending failed with hr: 0x{0}", hr);
                }
            }

            return hasResult;
        }

        public static void RecordResult(Guid trackingGuid, HResult apiHResult, string message, string outputParams)
        {
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.SetHashVal(trackingGuid);
                ws.StoredProc = "dbo.p_tracked_api_call_record_result";

                ws.AddParameter(ParamType.RETVAL, "@hr", 0);
                ws.AddParameter(ParamType.INPUT, "@uid_tracking_guid", trackingGuid);
                ws.AddParameter(ParamType.INPUT, "@i_hresult", apiHResult);
                ws.AddParameter(ParamType.INPUT, "@vc_message", message ?? string.Empty);
                ws.AddParameter(ParamType.INPUT, "@xml_output_params", outputParams ?? string.Empty);

                ws.ExecuteNonQuery();

                HResult hr = (uint) ws.GetIntParameter("@hr");
                if ( HResult.Failed(hr) )
                {
                    throw new XRLException(hr, XEvent.Id.TRACKED_API_CALL_DATABASE_ERROR, "TrackedApiCall.RecordPending: p_tracked_api_call_record_result failed with hr: 0x{0}", hr);
                }
            }
        }

        /// <summary>
        /// Records the pending Commerce Action in t_tracked_apis in UCDB
        /// </summary>
        public static bool RecordCommerceActionPending( Guid trackingGuid, Puid userPuid, string component, string apiName, string inputParams, out TrackedApiResult result )
        {
            bool hasResult = false;

            result = null;

            using ( WSClient ws = new WSClient( ConfigUtil.UserCommercedbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE ) )
            {
                ws.SetHashVal( userPuid );
                ws.StoredProc = "dbo.p_tracked_api_call_record_pending";

                ws.AddParameter( ParamType.RETVAL, "@hr", 0 );
                ws.AddParameter( ParamType.INPUT, "@uid_tracking_guid", trackingGuid );
                ws.AddParameter( ParamType.INPUT, "@bi_user_puid", userPuid );
                ws.AddParameter( ParamType.INPUT, "@vc_component", component );
                ws.AddParameter( ParamType.INPUT, "@vc_api_name", apiName );
                ws.AddParameter( ParamType.INPUT, "@xml_input_params", inputParams ?? string.Empty );
                ws.AddParameter( ParamType.INPUT, "@si_hash_bucket", ws.Partition );

                using ( WstDataReader r = ws.Execute() )
                {
                    if ( r.Read() )
                    {
                        TrackedApiResult apiResult = new TrackedApiResult();
                        apiResult.TrackingGuid = trackingGuid;
                        apiResult.Component = component;
                        apiResult.ApiName = apiName;
                        apiResult.InputParams = inputParams;
                        apiResult.HResult = (uint)r.GetInt32( 0 );
                        apiResult.Message = r.IsDBNull( 1 ) ? string.Empty : r.GetString( 1 );
                        apiResult.OutputParams = r.IsDBNull( 2 ) ? string.Empty : r.GetString( 2 );

                        hasResult = true;

                        result = apiResult;
                    }
                }

                HResult hr = (uint)ws.GetIntParameter( "@hr" );
                if ( HResult.Failed( hr ) )
                {
                    throw new XRLException( hr, XEvent.Id.TRACKED_API_CALL_UCDB_DATABASE_ERROR, "TrackedApiResult.RecordCommerceActionPending: p_tracked_api_call_record_pending failed with hr: 0x{0}", hr );
                }
            }

            return hasResult;
        }
        /// <summary>
        /// Records Commerce Action Result in t_tracked_apis in UCDB
        /// </summary>
        public static void RecordCommerceActionResult( Guid trackingGuid, Puid userPuid, HResult apiHResult, string message, string outputParams )
        {
            using ( WSClient ws = new WSClient( ConfigUtil.UserCommercedbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE ) )
            {
                ws.SetHashVal( userPuid );
                ws.StoredProc = "dbo.p_tracked_api_call_record_result";

                ws.AddParameter( ParamType.RETVAL, "@hr", 0 );
                ws.AddParameter( ParamType.INPUT, "@uid_tracking_guid", trackingGuid );
                ws.AddParameter( ParamType.INPUT, "@bi_user_puid", userPuid );
                ws.AddParameter( ParamType.INPUT, "@i_hresult", apiHResult );
                ws.AddParameter( ParamType.INPUT, "@vc_message", message ?? string.Empty );
                ws.AddParameter( ParamType.INPUT, "@xml_output_params", outputParams ?? string.Empty );

                ws.ExecuteNonQuery();

                HResult hr = (uint)ws.GetIntParameter( "@hr" );
                if ( HResult.Failed( hr ) )
                {
                    throw new XRLException( hr, XEvent.Id.TRACKED_API_CALL_UCDB_DATABASE_ERROR, "TrackedApiCall.RecordCommerceActionResult: p_tracked_api_call_record_result failed with hr: 0x{0}", hr );
                }
            }
        }

    }

    public class TrackedApiParameters
    {
        protected class TrackedApiParameter
        {
            public string Name {get; set;}
            public string Value {get; set;}

            public TrackedApiParameter(string name, string value)
            {
                Name = name;
                Value = value;
            }
        }

        protected List<TrackedApiParameter> paramList = new List<TrackedApiParameter>();

        public void AddParameter(string name, string value)
        {
            paramList.Add(new TrackedApiParameter(name, value ?? string.Empty));
        }

        public void AddParameter(string name, bool value)
        {
            paramList.Add(new TrackedApiParameter(name, value.ToString()));
        }

        public void AddParameter(string name, int value)
        {
            paramList.Add(new TrackedApiParameter(name, value.ToString()));
        }

        public void AddParameter(string name, long value)
        {
            paramList.Add(new TrackedApiParameter(name, value.ToString()));
        }

        public void AddParameter(string name, uint value)
        {
            paramList.Add(new TrackedApiParameter(name, value.ToString("x")));
        }

        public void AddParameter(string name, ulong value)
        {
            paramList.Add(new TrackedApiParameter(name, value.ToString("x")));
        }

        public void AddParameter(string name, DateTime value)
        {
            paramList.Add(new TrackedApiParameter(name, value.ToString("o")));
        }

        public void AddParameter(string name, Guid value)
        {
            paramList.Add(new TrackedApiParameter(name, value.ToString()));
        }

        public void AddSerializedParameter<T>(string name, T value)
        {
            if ( value == null )
            {
                AddParameter(name, string.Empty);
                return;
            }

            // NB: this version of the XmlSerializer constructor does not suffer
            // from the notorious memory leak that plagued us elsewhere
            XmlSerializer serializer = new XmlSerializer(typeof(T));

            using (StringWriter sw = new StringWriter())
            using (XmlTextWriter xtw = new XmlTextWriter(sw))
            {
                xtw.Formatting = Formatting.None;
                serializer.Serialize(xtw, value);
                string xmlText = sw.ToString();
                AddParameter(name, HttpUtility.HtmlEncode(xmlText));
            }
        }

        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            for (int i=0; i < paramList.Count; i++)
            {
                sb.AppendFormat("<{0}>{1}</{0}>", paramList[i].Name, paramList[i].Value);
            }

            return sb.ToString();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\user\test\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\user\userutil.cs ===
using System;
using System.Text;
using xonline.common.service;
using xonline.common.billing;



namespace xonline.common.user
{

public class UserUtil
{


    //-----------------------------------------------------
    // CheckBillingPIN
    //
    public static uint CheckBillingPIN(ulong passportId, byte[] acctPIN, bool autoGenCC)
    {
        HResult hr;
        User     u   = new User();
        int i;

        u.Load(passportId);

        // We should only care about the DB if the AutoGenCC setting is true.
        // Elsewise we open an (impersonation) security hole.
        //
        if(autoGenCC == true)
        {
            for(i = 0; i < acctPIN.Length; i++)
            {
                if(acctPIN[i] != u.BillingPIN[i])
                {
                    // failed, but see if they know the real number?
                    //
                    goto CheckBilling;
                }
            }

            // passed
            hr = HResult.S_OK;
            goto Cleanup;
        }

CheckBilling:

        if (BillingProvider.IsDummyId(u.AccountId))
        {
            hr = CheckQueuedAccountPIN(u, acctPIN);
        }
        else
        {
            // get the service instance id of the base subscription
            ulong baseOfferId = 0;
            string baseInstanceId = "";
            u.GetBaseSubscription(out baseInstanceId, out baseOfferId);

            // get the payment instrument id for the base subscription
            SubscriptionInfo subInfo = Subscription.GetSubscriptionInfo(u.BillingPuid, baseInstanceId);
            if ( subInfo.PaymentInstrumentId != null && subInfo.PaymentInstrumentId != "" && subInfo.PaymentInstrumentId != u.PaymentInfoId )
            {
                u.PaymentInfoId = subInfo.PaymentInstrumentId;
                u.Save();
            }

            // check for real
            //
            hr = CheckPINAgainstBillingProvider(u.BillingPuid, u.AccountId, u.PaymentInfoId, acctPIN);
        }

Cleanup:
        return hr;
    }

    //-----------------------------------------------------
    // CheckPINAgainstBillingProvider
    //
    private static HResult CheckPINAgainstBillingProvider(ulong passportId, string acctId, string payinfoId, byte[] acctPIN)
    {
        HResult hr;

        StringBuilder sb = new StringBuilder();

        for(int i = 0; i < XOn.ACCOUNT_PIN_LENGTH; i++)
        {
            // add the 48 (+ '0') so that the number gets into the right ASCII range
            sb.Append(Convert.ToChar(acctPIN[i] + 48));
        }


        if(Account.VerifyLastFourAccountDigits(passportId, acctId, payinfoId, sb.ToString()) == false)
        {
            hr = HResult.XONLINE_E_ACCOUNTS_PERMISSION_DENIED;
        }
        else
        {
            hr = HResult.S_OK;
        }

        return hr;
    }

    //-----------------------------------------------------
    // CheckQueuedAccountPIN
    //
    internal static HResult CheckQueuedAccountPIN(User u, byte[] acctPIN)
    {
        HResult hr = HResult.S_OK;

        for(int i = 0; i < XOn.ACCOUNT_PIN_LENGTH; i++)
        {
            // use the billing pin stored in t_users
            if (u.BillingPIN[i] != acctPIN[i])
            {
                hr = HResult.XONLINE_E_ACCOUNTS_PERMISSION_DENIED;
                break;
            }
        }

        return hr;
    }
}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\user\UniqueNounAdjectiveGamertagSuggestion.cs ===
using System;
using System.Text;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;

namespace xonline.common.user
{
    public class UniqueNounAdjectiveGamertagSuggestions : GamertagSuggestions
    {
        ///////////////////////////////////////////////
        // Implementation: Public
        ///////////////////////////////////////////////

        public override bool IsGamertagAlreadyReserved() { return true; }
        
        public override ushort GetNameSuggestions(GamertagSuggestionParameters parameters, out string[] names)
        {
            bool    isReserved = false;
            string  gamertag = string.Empty;
            int     extraSpace;
            
            while ( !isReserved )
            {
                ushort suggestionCount = GetNames(parameters, out names);
                
                foreach (string baseGamertag in names)
                {
                    extraSpace = (int)XOn.XONLINE_NAME_MAX_SIZE - baseGamertag.Length;
                    if ( 0 < extraSpace )
                    {
                        gamertag = DecorateGamertagWithNumericSuffix( baseGamertag );
                        if (HResult.Succeeded(NameUtil.ReserveGamertag(gamertag, 0, parameters.MachinePuid, 0, null, null, null, null, null, null, null, null, parameters.MinsToReserve)))
                        {
                            isReserved = true;
                            break;
                        }
                    }
                }
            }
            names = new string[1];
            names[0] = gamertag;
            return 1;
        }

        ///////////////////////////////////////////////
        // Implementation: Protected
        ///////////////////////////////////////////////
        
        protected ushort GetNames(GamertagSuggestionParameters parameters, out string [ ] names)
        {
            NounAdjectiveGamertagSuggestions gamerTagSuggestions = new NounAdjectiveGamertagSuggestions();
            
            return gamerTagSuggestions.GetNameSuggestions(parameters, out names);
        }

        protected string DecorateGamertagWithNumericSuffix( string gamertag )
        {
            int extraSpace;
            string decoratedGamertag;
            string[] stringarray = new string[0];

            extraSpace = (int)XOn.XONLINE_NAME_MAX_SIZE - gamertag.Length;
            if ( 0 == extraSpace )
                throw new ArgumentException( "gamertag length = XONLINE_NAME_MAX_SIZE" );

            do
            {
                // add a random number of numbers [1,extraSpace] to the end of the gamertag
                decoratedGamertag = gamertag + GetNumericSuffix(Random.Next(1, extraSpace + 1));
            } while (!ValidateGamertag(decoratedGamertag, stringarray));

            return decoratedGamertag;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\user\test\cursetest.cs ===
using System;
using System.Collections.Specialized;
using xonline.common.user;

namespace xonline.common.user.test 
{
    class CCurseTestApp  
    {
        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        [STAThread]
        static int Main( string[] args )
        {
            // Build up the bad string lists
            StringCollection newSubWords = new StringCollection();
            StringCollection newExactWords = new StringCollection();

            newSubWords.Add( "substring" );
            newExactWords.Add( "exact" );
      
            UnicodeCurseManager ucm = new UnicodeCurseManager();
            ucm.Load( newSubWords, newExactWords );

            string strTable;
            ucm.OutputTable( out strTable );
            Console.Write( strTable );

            string strExact = "";
            string strSubstr = "";
            string strName;
            bool fRet;

            // CASE 1: completely unrelated word
            strName = "bird";
            fRet = ucm.VetName( strName, ref strExact, ref strSubstr );
            Console.WriteLine( "String='{0}', Vet={1}", strName, fRet );

            // CASE 2: exact word in exact list
            strName = "exact";
            fRet = ucm.VetName( strName, ref strExact, ref strSubstr );
            Console.WriteLine( "String='{0}', Vet={1}", strName, fRet );

            // CASE 3: exact word in substring list
            strName = "substring";
            fRet = ucm.VetName( strName, ref strExact, ref strSubstr );
            Console.WriteLine( "String='{0}', Vet={1}", strName, fRet );

            // CASE 4: longer word in exact list
            strName = "exactly";
            fRet = ucm.VetName( strName, ref strExact, ref strSubstr );
            Console.WriteLine( "String='{0}', Vet={1}", strName, fRet );

            // CASE 5: longer word in substring list
            strName = "substringlist";
            fRet = ucm.VetName( strName, ref strExact, ref strSubstr );
            Console.WriteLine( "String='{0}', Vet={1}", strName, fRet );

            // CASE 6: word with spaces in exact list
            strName = "ex act";
            fRet = ucm.VetName( strName, ref strExact, ref strSubstr );
            Console.WriteLine( "String='{0}', Vet={1}", strName, fRet );

            // CASE 7: word with spaces in substring list
            strName = "sub string";
            fRet = ucm.VetName( strName, ref strExact, ref strSubstr );
            Console.WriteLine( "String='{0}', Vet={1}", strName, fRet );

            // CASE 8: exact word with letters before
            strName = "inexact";
            fRet = ucm.VetName( strName, ref strExact, ref strSubstr );
            Console.WriteLine( "String='{0}', Vet={1}", strName, fRet );

            // CASE 9: substring word with letters before
            strName = "unsubstring";
            fRet = ucm.VetName( strName, ref strExact, ref strSubstr );
            Console.WriteLine( "String='{0}', Vet={1}", strName, fRet );

            // CASE 10: exact word with letters after
            strName = "exaction";
            fRet = ucm.VetName( strName, ref strExact, ref strSubstr );
            Console.WriteLine( "String='{0}', Vet={1}", strName, fRet );

            // CASE 11: substring word with letters after
            strName = "substringer";
            fRet = ucm.VetName( strName, ref strExact, ref strSubstr );
            Console.WriteLine( "String='{0}', Vet={1}", strName, fRet );

            // CASE 12: exact word with spaces and letters before
            strName = "inex act";
            fRet = ucm.VetName( strName, ref strExact, ref strSubstr );
            Console.WriteLine( "String='{0}', Vet={1}", strName, fRet );

            // CASE 13: substring word with spaces and letters before
            strName = "unsub string";
            fRet = ucm.VetName( strName, ref strExact, ref strSubstr );
            Console.WriteLine( "String='{0}', Vet={1}", strName, fRet );

            // CASE 14: exact word with spaces and letters after
            strName = "ex actor";
            fRet = ucm.VetName( strName, ref strExact, ref strSubstr );
            Console.WriteLine( "String='{0}', Vet={1}", strName, fRet );

            // CASE 15: substring word with spaces and letters after
            strName = "sub stringer";
            fRet = ucm.VetName( strName, ref strExact, ref strSubstr );
            Console.WriteLine( "String='{0}', Vet={1}", strName, fRet );

            // CASE 16: exact word with letters before and after
            strName = "inexactor";
            fRet = ucm.VetName( strName, ref strExact, ref strSubstr );
            Console.WriteLine( "String='{0}', Vet={1}", strName, fRet );

            // CASE 17: substring word with letters before and after
            strName = "unsubstringer";
            fRet = ucm.VetName( strName, ref strExact, ref strSubstr );
            Console.WriteLine( "String='{0}', Vet={1}", strName, fRet );

            // CASE 18: exact word with spaces and letters before and after
            strName = "inex actor";
            fRet = ucm.VetName( strName, ref strExact, ref strSubstr );
            Console.WriteLine( "String='{0}', Vet={1}", strName, fRet );

            // CASE 19: substring word with spaces and letters before and after
            strName = "unsub stringer";
            fRet = ucm.VetName( strName, ref strExact, ref strSubstr );
            Console.WriteLine( "String='{0}', Vet={1}", strName, fRet );

            // CASE 20: exact word with space before
            strName = "in exact";
            fRet = ucm.VetName( strName, ref strExact, ref strSubstr );
            Console.WriteLine( "String='{0}', Vet={1}", strName, fRet );

            // CASE 21: substring word with space before
            strName = "un substring";
            fRet = ucm.VetName( strName, ref strExact, ref strSubstr );
            Console.WriteLine( "String='{0}', Vet={1}", strName, fRet );

            // CASE 22: exact word with space after
            strName = "exact word";
            fRet = ucm.VetName( strName, ref strExact, ref strSubstr );
            Console.WriteLine( "String='{0}', Vet={1}", strName, fRet );

            // CASE 23: substring word with space after
            strName = "substring word";
            fRet = ucm.VetName( strName, ref strExact, ref strSubstr );
            Console.WriteLine( "String='{0}', Vet={1}", strName, fRet );

            // CASE 24: exact word with space before and after
            strName = "in exact ly";
            fRet = ucm.VetName( strName, ref strExact, ref strSubstr );
            Console.WriteLine( "String='{0}', Vet={1}", strName, fRet );

            // CASE 25: substring word with space before and after
            strName = "un substring er";
            fRet = ucm.VetName( strName, ref strExact, ref strSubstr );
            Console.WriteLine( "String='{0}', Vet={1}", strName, fRet );

            // CASE 26: exact word with space before, after, and within
            strName = "in ex act ly";
            fRet = ucm.VetName( strName, ref strExact, ref strSubstr );
            Console.WriteLine( "String='{0}', Vet={1}", strName, fRet );

            // CASE 27: substring word with space before, after, and within
            strName = "un sub string er";
            fRet = ucm.VetName( strName, ref strExact, ref strSubstr );
            Console.WriteLine( "String='{0}', Vet={1}", strName, fRet );

            return 0;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\user\UniqueSeedTweakingGamertagSuggestions.cs ===
using System;
using xonline.common.config;
using xonline.common.service;
using Config = xonline.common.config.Config;
using System.Collections.Generic;

namespace xonline.common.user
{
    public class UniqueSeedTweakingGamertagSuggestions : GamertagSuggestions
    {
        private struct GamertagStringReplacement
        {
            public readonly string originalString;
            public readonly string replacementString;

            public GamertagStringReplacement(string original, string replacement)
            {
                originalString = original;
                replacementString = replacement;
            }
        };

        private GamertagStringReplacement[] GamertagStringReplacements = new GamertagStringReplacement[]
        {
            new GamertagStringReplacement("O", "0"),
            new GamertagStringReplacement("o", "0"),
            new GamertagStringReplacement("I", "1"),
            new GamertagStringReplacement("i", "1"),
            new GamertagStringReplacement("L", "1"),
            new GamertagStringReplacement("l", "1"),
            new GamertagStringReplacement("Z", "2"),
            new GamertagStringReplacement("z", "2"),
            new GamertagStringReplacement("E", "3"),
            new GamertagStringReplacement("e", "3"),
            new GamertagStringReplacement("A", "4"),
            new GamertagStringReplacement("a", "4"),
            new GamertagStringReplacement("S", "5"),
            new GamertagStringReplacement("s", "5"),
            new GamertagStringReplacement("G", "6"),
            new GamertagStringReplacement("b", "6"),
            new GamertagStringReplacement("T", "7"),
            new GamertagStringReplacement("t", "7"),
            new GamertagStringReplacement("B", "8"),
            new GamertagStringReplacement("g", "9"),
        };

        public override ushort GetNameSuggestions(GamertagSuggestionParameters parameters, out string[] names)
        {
            const uint MAX_SEED_LEN = XOn.XONLINE_NAME_MAX_SIZE;

            ushort namesCounter = 0;

            List<string> possibleTags = new List<string>();

            names = new string[parameters.MaxNames];

            if (NameUtil.VerifyGamerTag(parameters.Seed, false) && NameUtil.VetName(parameters.Seed))
            {
                if (ValidateGamertag(parameters.Seed, names))
                {
                    possibleTags.Add(parameters.Seed);
                }
            }
            else
            {
                parameters.Seed = "";
            }

            //truncate the seed if it is more than allowed length
            if (parameters.Seed.Length > MAX_SEED_LEN)
            {
                parameters.Seed = parameters.Seed.Substring(0, (int)MAX_SEED_LEN);
            }

            string bogusReservation = Config.GetSetting(Setting.xuacs_seedbasedGamertagDefault);

            //Make a bogus call to reserve gamertag in order to free up any previous reservations.  (pass true as last param)
            NameUtil.ReserveGamertag(bogusReservation, 0, parameters.MachinePuid, 0, null, null, null, null, null, null, null, null, parameters.MinsToReserve, true);

            
            //Add a bunch of tags to possibleTags here

            if(!String.IsNullOrEmpty(parameters.Seed))
            {
                foreach (GamertagStringReplacement stringReplacement in GamertagStringReplacements)
                {
                    possibleTags.AddRange(GetVariantsWithLetterReplacement(
                        stringReplacement.originalString,
                        stringReplacement.replacementString,
                        parameters.Seed));
                }
                
                //Throw in enough number suggestions to try and get at least half our suggestions from the seed
                int suggestionsWithNumberAdded = Math.Max(parameters.MaxNames / 2, possibleTags.Count);
                for (int i = 0; i < suggestionsWithNumberAdded; i++)
                {
                    possibleTags.Add(parameters.Seed + GetNumericSuffix(2));
                }

                //Add an additional possibleTags.Count elements from the NounAdjectiveSuggestion algorithm without a seed to mix things up.
                GamertagSuggestionParameters extraTagsParameters = new GamertagSuggestionParameters(string.Empty, (ushort)Math.Max(parameters.MaxNames, possibleTags.Count), parameters.CountryId);
                GamertagSuggestions extraTagBuilder = GamertagSuggestionsFactory.GetGamerTagSuggestions(GamertagSuggestionType.NounAdjectiveSuggestion);
                string[] altNames = null;
                extraTagBuilder.GetNameSuggestions(extraTagsParameters, out altNames);
                possibleTags.AddRange(altNames);

                //now randomly permute the possibleTags list so we can pick tags quicker
                for (int i = 0; i < possibleTags.Count; i++)
                {
                    int newIndex = Random.Next(possibleTags.Count);
                    string temp = possibleTags[newIndex];
                    possibleTags[newIndex] = possibleTags[i];
                    possibleTags[i] = temp;
                }

                //Pick from these tags
                for (int i = 0; namesCounter < names.Length && i < possibleTags.Count; i++)
                {
                    string gamertag = possibleTags[i];

                    if (ValidateGamertag(gamertag, names))
                    {
                        if (HResult.Succeeded(NameUtil.ReserveGamertag(gamertag, 0, parameters.MachinePuid, 0, null, null, null, null, null, null, null, null, parameters.MinsToReserve, false)))
                        {
                            names[namesCounter] = gamertag;
                            namesCounter++;
                        }
                    }
                }
            }            

            //If this didn't generate enough tags, lets just fill in the remaining suggestions with a NounAdjective suggestion
            for (int numAttempts = 0; namesCounter < names.Length && numAttempts < parameters.MaxNames * NameUtil.MAX_ATTEMPTS_MULTIPLIER; numAttempts++)
            {
                ushort additionalNeededTags = (ushort)(names.Length - namesCounter);
                GamertagSuggestionParameters extraTagsParameters = new GamertagSuggestionParameters(string.Empty, additionalNeededTags, parameters.CountryId);
                GamertagSuggestions extraTagBuilder = GamertagSuggestionsFactory.GetGamerTagSuggestions(GamertagSuggestionType.NounAdjectiveSuggestion);
                string[] altNames = null;
                extraTagBuilder.GetNameSuggestions(extraTagsParameters, out altNames);
                for (int i = 0; namesCounter < names.Length && i < altNames.Length; i++)
                {
                    string altName = altNames[i];

                    //If we're getting up in attempts then we're having trouble getting reservations and we should try adding numbers to our suggestions
                    if (numAttempts > parameters.MaxNames)
                    {
                        altName = altNames[i] + GetNumericSuffix((int)(MAX_SEED_LEN - altNames[i].Length));
                    }

                    if (ValidateGamertag(altName, names))
                    {
                        if (HResult.Succeeded(NameUtil.ReserveGamertag(altName, 0, parameters.MachinePuid, 0, null, null, null, null, null, null, null, null, parameters.MinsToReserve, false)))
                        {
                            names[namesCounter] = altName;
                            namesCounter++;
                        }
                    }
                }
            }

            return namesCounter;
        }

        private string AddPrefixPostfix(string prepost, string seed)
        {
            return prepost + seed + prepost;
        }

        private List<string> GetVariantsWithLetterReplacement(string original, string replacement, string seed)
        {
            List<string> possibleTags = new List<string>();
            if (seed.Contains(original))
            {
                string modified = seed.Replace(original, replacement);
                if (modified.StartsWith(replacement))
                {
                    modified = original + modified.Substring(original.Length);
                }
                if (!modified.Equals(seed))
                {
                    possibleTags.Add(modified);
                }
            }
            return possibleTags;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\venturarr\SharedKeyMessageSigner.cs ===
﻿using System;
using System.Security.Cryptography;

//
// NOTE:
// NOTE: Code in this file taken from Ventura code-base.
// NOTE:
//

namespace xonline.common.venturarr
{
    /// <summary>
    /// Signs a message using a shared key from a pool
    /// </summary>
    public class SharedKeyMessageSigner
    {
        public static string DefaultAlgorithm { get; set; }

        static SharedKeyMessageSigner()
        {
            DefaultAlgorithm = "HMACSHA512";
        }

        private readonly byte[] _data;


        public SharedKeyMessageSigner(byte[] raw, SharedKeyPool pool, byte keyIndex, string hmacAlg)
        {
            if (string.IsNullOrEmpty(hmacAlg))//if (string.IsNullOrWhiteSpace(hmacAlg))
            {
                throw new ArgumentException("hmacAlg");
            }

            if (raw == null)
            {
                throw new ArgumentException("raw");
            }

            if (pool == null || pool.KeyCount <= keyIndex)
            {
                throw new ArgumentException("pool");
            }

            using (HMAC h = CryptoConfig.CreateFromName(hmacAlg) as HMAC)
            {
                if (h == null)
                {
                    throw new ArgumentException("No such algorithm", "hmacAlg");
                }
                int hashSizeBytes = h.HashSize / 8;
                // raw data + 1 byte key index + bytes of hash
                _data = new byte[raw.Length + 1 + hashSizeBytes];
                Array.Copy(raw, _data, raw.Length);

                // identify which key index is being used, and sign that as well
                _data[raw.Length] = keyIndex;
                h.Key = pool[keyIndex];
                Array.Copy(h.ComputeHash(_data, 0, raw.Length + 1), 0, _data, raw.Length + 1, hashSizeBytes);
            }
        }

        public SharedKeyMessageSigner(byte[] raw, SharedKeyPool pool, byte keyIndex)
            : this(raw, pool, keyIndex, DefaultAlgorithm)
        {
        }


        public byte[] GetSignedData()
        {
            byte[] fresh = new byte[_data.Length];
            Array.Copy(_data, fresh, fresh.Length);
            return fresh;
        }
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\venturarr\venturarrperf.cs ===
using System.Diagnostics;

using xonline.common.mgmt;


namespace xonline.common.venturarr
{
    [XomPerformanceCounterCategoryAttr( "Partner: Ventura Ratings and Reviews", "Ventura Ratings and Reviews Counters", true )]
    public class VenturaRRCounters : XomPerformanceCounterCategory
    {
    
        public static VenturaRRCounters Counters = new VenturaRRCounters();

        public VenturaRRCounters this[string api]
        {
            get
            {
                return (VenturaRRCounters) GetInstance(api);
            }
        }

        [XomPerformanceCounterAttr(
            "VenturaRR API requests/sec",
            "VenturaRR REST API requests per second",
            PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter CallsPerSecond;

        [XomPerformanceCounterAttr(
            "VenturaRR API requests total",
            "Total VenturaRR REST API requests made in the the current AppDomain.",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter CallsTotal;

        [XomPerformanceCounterAttr(
            "VenturaRR API failures/sec",
            "Number of unsuccessful results returned per second in the current AppDomain.",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter CallsFailedPerSecond;

        [XomPerformanceCounterAttr(
            "VenturaRR API total failures",
            "Total number unsuccessful results returned in the current AppDomain.",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter CallsFailedTotal;

        [XomPerformanceCounterAttr(
            "VenturaRR API timeouts/sec",
            "Number of timeouts making VenturaRR REST API calls per second in the current AppDomain.",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter TimeoutsPerSecond;

        [XomPerformanceCounterAttr(
            "VenturaRR API total timeouts",
            "Total number of timeouts making VenturaRR REST API calls in the current AppDomain.",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter TimeoutsTotal;

        [XomPerformanceCounterAttr(
            "VenturaRR API blocked calls/sec",
            "Number of VenturaRR REST API calls blocked due to blacklisting per second in the current AppDomain.",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter BlockedCallsPerSecond;

        [XomPerformanceCounterAttr(
            "VenturaRR API total blocked calls",
            "Total number of VenturaRR REST API calls blocked due to blacklisting per second in the current AppDomain.",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter BlockedCallsTotal;

        [XomPerformanceCounterAttr(
            "Avg. execution time",
            "Average time taken to execute REST requests against VenturaRR",
             PerformanceCounterType.AverageTimer32)]
        public PerformanceCounter CallsTime;

        [XomPerformanceCounterAttr(
            "Avg. execution time base",
            "Base average time taken to execute REST requests against VenturaRR",
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter CallsTimeBase;

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\venturarr\Methods.cs ===
﻿using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Net;
using System.Runtime.Serialization;
using System.Web;
using System.Xml;

//
// NOTE:
// NOTE: Code in this file taken from Ventura code-base.
// NOTE:
//
// Adds to Ventura code:
// 1. Caching of Credentials
// 2. Tracking Expiry of ServiceManifest and Credentials 
// 3. RW-Lock protection of ServiceManifest and Credentials for multi-threaded use
//


namespace xonline.common.venturarr
{
    class Methods
    {
        private ServiceManifest _serviceManifest;
        private DateTime        _serviceManifestExpiry = DateTime.UtcNow;
        private string          _cachedCredentials = string.Empty;
        private DateTime        _cachedCredentialsExpiry = DateTime.UtcNow;
        private string          _cachedHttpBody = string.Empty;
        private double          _padExpiry;

        private ReaderWriterLockSlim _lock = new ReaderWriterLockSlim();

        private const string UserIdToken = "{userId}";
        private const string EventIdToken = "{eventId}";
        private const string MediaIdToken = "{mediaId}";
        private const string AuthModeToken = "{authMode}";
        private const string CustomerGroupToken = "{customerGroup}";
        private const string GenreToken = "{genre}";
        private const string RatingToken = "{rating}";
        private const string ListIdToken = "{listId}";
        private const string TargetUserIdToken = "{targetUserId}";
        private const string MessageId = "{messageId}";
        private const string ManifestIdToken = "{manifestId}";
        private const string CgToken = "{cg}";
        private const string RegistrationIdToken = "{registrationId}";
        private const string TaskNameToken = "{taskName}";

        private const string SharedKeyAuthMode = "sharedkey";

        public Methods(uint milliSeconds)
        {
            _padExpiry = (Double)milliSeconds;
        }

        /// <summary>
        /// Sets WebProxy.
        /// </summary>
        /// <param name="proxy">The WebProxy.</param>
        internal void SetWebProxy(WebProxy proxy)
        {
            _lock.EnterWriteLock();
            try
            {
                WebUtility.Proxy = proxy;
            }
            finally
            {
                _lock.ExitWriteLock();
            }
        }

        /// <summary>
        /// Sets WebProxy.
        /// </summary>
        /// <param name="proxy">The WebProxy.</param>
        internal void SetTimeout(int timeout)
        {
            _lock.EnterWriteLock();
            try
            {
                WebUtility.Timeout = timeout;
            }
            finally
            {
                _lock.ExitWriteLock();
            }
        }

        /// <summary>
        /// Gets the endpoint URL.
        /// </summary>
        /// <param name="endpointName">Name of the endpoint.</param>
        /// <returns>endpoint url</returns>
        private string GetEndpointUrl(string endpointName)
        {
            if (_serviceManifest != null && _serviceManifest.ServiceDirectory != null)
            {
                EndPointEntry endpoint = _serviceManifest.ServiceDirectory.Find(ep => ep.Name == endpointName);
                if (endpoint != null && endpoint.UriOrderedList != null)
                {
                    return endpoint.UriOrderedList.FirstOrDefault();
                }
            }

            throw new Exception("Unable to find the endpoint " + endpointName + "in the service directory manifest");
        }

        /// <summary>
        /// Generates the manifest.
        /// </summary>
        /// <param name="endUserCustomerGroup"></param>
        internal void GenerateManifestfromSds(string endUserCustomerGroup, string uri, string clientVersion, string deviceId, string locale, string userId)
        {
            bool haveLock = _lock.TryEnterUpgradeableReadLock(0);
            try
            {
                if (haveLock && IsServiceManifestExpired())
                {
                    ClientInfo clientInfo = new ClientInfo
                    {
                        CG = new CustomerGroup(endUserCustomerGroup),
                        ClientVersion = clientVersion,
                        DeviceId = deviceId,
                        Locale = locale,
                        UserId = userId
                    };

                    string clientInfoXml = WebUtility.GetXmlFromObject(clientInfo);
                    Dictionary<string, string> outHeaders = null;
                    // create a request to SDS manifest generate
                    string manifest = WebUtility.GetWebResponseWithPost(new Uri(uri), clientInfoXml, out outHeaders, null /*no credentials needed*/);

                    _lock.EnterWriteLock();
                    try
                    {
                        _serviceManifestExpiry = GetServiceManifestExpiry(outHeaders);
                        _serviceManifest = WebUtility.GetObjectFromXmlString<ServiceManifest>(manifest);
                    }
                    finally
                    {
                        _lock.ExitWriteLock();
                    }
                }
            }
            finally
            {
                if (haveLock)
                {
                    _lock.ExitUpgradeableReadLock();
                }
            }
        }

        /// <summary>
        /// Get Expiry of Service Manifest.
        /// </summary>
        /// <param name="headers">The http headers.</param>
        /// <returns>The expiry DateTime</returns>
        private DateTime GetServiceManifestExpiry(Dictionary<string, string> headers)
        {
            DateTime expiry = DateTime.UtcNow;
            string expiryString;

            headers.TryGetValue("Expires", out expiryString);

            if (!string.IsNullOrEmpty(expiryString))
            {
                expiry = DateTime.Parse(expiryString);
            }

            return expiry;
        }

        /// <summary>
        /// Get Expiry of Credentials.
        /// </summary>
        /// <param name="credentials">The credentials.</param>
        /// <returns>The expiry DateTime</returns>
        private DateTime GetCredentialsExpiry(string credentials)
        {
            DateTime expiry = DateTime.UtcNow;
            string expiryString;
            string[] credentialStringParts = credentials.Split(';');

            if (credentialStringParts.Length > 1)
            {
                if (credentialStringParts.Any(p => p.Trim().StartsWith("expires=")))
                {
                    expiryString = credentialStringParts.First(p => p.Trim().StartsWith("expires=")).Split('=').Last();

                    if (!string.IsNullOrEmpty(expiryString))
                    {
                        expiry = DateTime.Parse(expiryString);
                    }
                }
            }

            return expiry;
        }

        /// <summary>
        /// Check Expiry of Service Manifest.
        /// </summary>
        /// <returns>Whether manifest is expired</returns>
        internal bool IsServiceManifestExpired()
        {
            _lock.EnterReadLock();
            try
            {
                return IsDateTimeExpired(_serviceManifestExpiry);
            }
            finally
            {
                _lock.ExitReadLock();
            }
        }

        /// <summary>
        /// Check Expiry of Credentials.
        /// </summary>
        /// <param name="credentials">The credentials.</param>
        /// <returns>Whether credentials are expired</returns>
        internal bool AreCredentialsExpired(string credentials)
        {
            _lock.EnterReadLock();
            try
            {
                DateTime expiry = _cachedCredentialsExpiry;

                if (!_cachedCredentials.Equals(credentials))
                {
                    expiry = GetCredentialsExpiry(credentials);
                }

                return IsDateTimeExpired(expiry);
            }
            finally
            {
                _lock.ExitReadLock();
            }
        }

        /// <summary>
        /// Check Expiry of Credentials.
        /// </summary>
        /// <param name="credentials">The credentials.</param>
        /// <returns>Whether credentials are expired</returns>
        internal bool AreCredentialsExpired()
        {
            _lock.EnterReadLock();
            try
            {
                return IsDateTimeExpired(_cachedCredentialsExpiry);
            }
            finally
            {
                _lock.ExitReadLock();
            }
        }

        /// <summary>
        /// Check Expiry of DateTime.
        /// </summary>
        /// <param name="datetime">The DateTime.</param>
        /// <returns>Whether DateTime is expired</returns>
        private bool IsDateTimeExpired(DateTime dt)
        {
            return DateTime.Compare(DateTime.UtcNow.AddMilliseconds(_padExpiry), dt.ToUniversalTime()) >= 0;
        }

        /// <summary>
        /// Sends the delete request to ventura service.
        /// </summary>
        /// <param name="method">The method.</param>
        /// <param name="replacementTokens">The replacement tokens.</param>
        /// <param name="credentials">The credentials.</param>
        private void SendDeleteRequestToVenturaService(string method, Dictionary<string, string> replacementTokens, string credentials)
        {
            string url = GetUrl(method, replacementTokens);
            WebUtility.DeleteWebRequest(url, credentials);
        }

        /// <summary>
        /// Puts the data to ventura service.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="method">The method.</param>
        /// <param name="obj">The obj.</param>
        /// <param name="replacementTokens">The replacement tokens.</param>
        /// <param name="credentials">The credentials.</param>
        private void PutDataToVenturaService<T>(string method, T obj, Dictionary<string, string> replacementTokens, string credentials)
        {
            string xml = WebUtility.GetXmlFromObject(obj);
            string url = GetUrl(method, replacementTokens);
            WebUtility.PutWebRequest(url, xml, credentials);
        }

        /// <summary>
        /// Puts the data to ventura service.
        /// </summary>
        /// <param name="method">end point name</param>
        /// <param name="httpbody">The httpbody to be sent in request</param>
        /// <param name="replacementTokens">To tokens will be replacd in URI</param>
        /// <param name="credentials">The ventura signin ticket</param>
        private void PutDataToVenturaService(string method, string httpbody, Dictionary<string, string> replacementTokens, string credentials)
        {
            string url = GetUrl(method, replacementTokens);
            WebUtility.PutWebRequest(url, httpbody, credentials);
        }

        /// <summary>
        /// Posts the data to ventura service.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="method">The method.</param>
        /// <param name="obj">The obj.</param>
        /// <param name="replacementTokens">The replacement tokens.</param>
        /// <param name="credentials">The credentials.</param>
        private void PostDataToVenturaService<T>(string method, T obj, Dictionary<string, string> replacementTokens, string credentials)
        {
            string url = GetUrl(method, replacementTokens);

            if (obj != null)
            {
                string xml = WebUtility.GetXmlFromObject(obj);
                WebUtility.PostWebRequest(url, xml, credentials);
            }
            else
            {
                WebUtility.PostWebRequest(url, null, credentials);
            }
        }

        /// <summary>
        /// Gets the data from ventura service.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="method">The method.</param>
        /// <param name="replacementTokens">The replacement tokens.</param>
        /// <param name="credentials">The credentials.</param>
        /// <param name="puid">The puid of the user.</param>
        /// <returns>The deserialized object</returns>
        private T GetDataFromVenturaService<T>(string method, Dictionary<string, string> replacementTokens, string credentials, string puid)
        {
            string url = GetUrl(method, replacementTokens);
            string xml = WebUtility.GetWebResponse(url, credentials, puid);
            return WebUtility.GetObjectFromXmlString<T>(xml);
        }

        /// <summary>
        /// Gets the data from ventura service.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="method">The method.</param>
        /// <param name="replacementTokens">The replacement tokens.</param>
        /// <param name="credentials">The credentials.</param>
        /// <returns>The deserialized object</returns>
        private T GetDataFromVenturaService<T>(string method, Dictionary<string, string> replacementTokens, string credentials)
        {
            string url = GetUrl(method, replacementTokens);
            string xml = WebUtility.GetWebResponse(url, credentials);
            return WebUtility.GetObjectFromXmlString<T>(xml);
        }

        /// <summary>
        /// Gets the data from ventura service.
        /// </summary>
        /// <param name="method">The method.</param>
        /// <param name="replacementTokens">The replacement tokens.</param>
        /// <param name="credentials">The credentials.</param>
        /// <param output name="results">Raw xml results.</param>
        /// <returns>The deserialized object</returns>
        private T GetDataFromVenturaService<T>(string method, Dictionary<string, string> replacementTokens, string credentials, out XmlNode result)
        {
            string url = GetUrl(method, replacementTokens);
            string xml = WebUtility.GetWebResponse(url, credentials);
            XmlDocument doc = new XmlDocument();
            doc.LoadXml(xml);
            result = doc;
            return WebUtility.GetObjectFromXmlString<T>(xml);
        }
        
        /// <summary>
        /// Gets the data from ventura service.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="method">The method.</param>
        /// <param name="replacementTokens">The replacement tokens.</param>
        /// <param name="queryStringParameters">query string parameters</param>
        /// <param name="credentials">The credentials.</param>
        /// <returns>The deserialized object</returns>
        private T GetDataFromVenturaService<T>(string method, Dictionary<string, string> replacementTokens, Dictionary<string, string> queryStringParameters, string credentials)
        {
            string url = GetUrl(method, replacementTokens);

            if (queryStringParameters.Count > 0)
            {
                url += "?";
            }

            foreach (var parameter in queryStringParameters)
            {
                url += parameter.Key + "=" + parameter.Value;
                url += "&";
            }

            string xml = WebUtility.GetWebResponse(url, credentials);
            return WebUtility.GetObjectFromXmlString<T>(xml);
        }

        /// <summary>
        /// Gets the URL.
        /// </summary>
        /// <param name="method">The method.</param>
        /// <param name="replacementTokens">The replacement tokens.</param>
        /// <returns>The url.</returns>
        private string GetUrl(string method, Dictionary<string, string> replacementTokens)
        {
            string url = GetEndpointUrl(method);
            foreach (KeyValuePair<string, string> replacementToken in replacementTokens)
            {
                url = url.Replace(replacementToken.Key, replacementToken.Value);
            }
            return url;
        }

        /// <summary>
        /// Signs in the user (V2).
        /// </summary>
        /// <param name="tokenXml">The token xml.</param>
        /// <param name="customerGroup">The customer group.</param>
        /// <returns>user credentials</returns>
        internal string SignInVenturaTicketCreateV2(string tokenXml, string customerGroup)
        {
            string signInUrl = null;
            _lock.EnterReadLock();
            try
            {
                signInUrl = GetEndpointUrl("SignIn.VenturaTicket.Create.V2");
            }
            finally
            {
                _lock.ExitReadLock();
            }

            string httpBody = null;
            
            return SignInVenturaTicketCreate(signInUrl, SharedKeyAuthMode, customerGroup, null, tokenXml, out httpBody);
        }

        /// <summary>
        /// Signs in the user (V2).
        /// </summary>
        /// <param name="tokenXml">The token xml.</param>
        /// <param name="customerGroup">The customer group.</param>
        /// <param name="authMode">The auth mode.</param>
        /// <param name="timeMachine">The time machine.</param>
        /// <param output name="httpBody">The Http Body of response.</param>
        /// <returns>user credentials</returns>
        internal string SignInVenturaTicketCreateV2(string tokenXml, string customerGroup, string authMode, string timeMachine, out string httpBody)
        {
            string signInUrl = null;
            _lock.EnterReadLock();
            try
            {
                signInUrl = GetEndpointUrl("SignIn.VenturaTicket.Create.V2");
            }
            finally
            {
                _lock.ExitReadLock();
            }

            return SignInVenturaTicketCreate(signInUrl, authMode, customerGroup, timeMachine, tokenXml, out httpBody);
        }

        /// <summary>
        /// Signs in the user.
        /// </summary>
        /// <param name="signInUrl">The url to call for SignIn.</param>
        /// <param name="authMode">The auth mode.</param>
        /// <param name="customerGroup">The customer group.</param>
        /// <param name="timeMachine">The time machine.</param>
        /// <param name="tokenXml">The token xml.</param>
        /// <param output name="httpBody">The Http Body of response.</param>
        /// <returns>user credentials</returns>
        private string SignInVenturaTicketCreate(string signInUrl, string authMode, string customerGroup, string timeMachine, string tokenXml, out string httpBody)
        {
            bool haveLock = _lock.TryEnterUpgradeableReadLock(0);
            try
            {
                if (haveLock && AreCredentialsExpired())
                {
                    signInUrl = signInUrl.Replace(AuthModeToken, authMode).Replace(CustomerGroupToken, customerGroup);
                    Dictionary<string, string> outHeaders = null;

                    Dictionary<string, string> customizedHeaders = new Dictionary<string, string>();
                    if (timeMachine != null)
                    {
                        customizedHeaders.Add("x-ms-ventura-timemachine", timeMachine);
                    }

                    httpBody = WebUtility.GetWebResponseWithPost(new Uri(signInUrl), customizedHeaders, tokenXml, out outHeaders, null);

                    string credentials = outHeaders["Set-Cookie"];
                    Regex regex = new Regex("^Ventura-t");

                    if (regex.IsMatch(credentials))
                    {
                        _lock.EnterWriteLock();
                        try
                        {
                            _cachedCredentials = credentials;
                            _cachedCredentialsExpiry = GetCredentialsExpiry(credentials);
                            _cachedHttpBody = httpBody;
                        }
                        finally
                        {
                            _lock.ExitWriteLock();
                        }
                        
                        return credentials;
                    }

                    throw new WebException("Error Signing in", WebExceptionStatus.UnknownError);
                }    
                else
                {
                    httpBody = _cachedHttpBody;
                    return _cachedCredentials;
                }
            }
            finally
            {
                if (haveLock)
                {
                    _lock.ExitUpgradeableReadLock();
                }
            }
        }

        /// <summary>
        /// Signs in the user.
        /// </summary>
        /// <param name="vuid">The vuid.</param>
        /// <param name="customerGroup">The customer group.</param>
        /// <returns>user credentials</returns>
        internal string SignInVenturaTicketCreate(string vuid, string customerGroup)
        {
            SignInToken token = new SignInToken()
            {
                CG = new CustomerGroup(customerGroup),
                IssueInstant = DateTime.UtcNow.AddMinutes(60),
                NotBefore = DateTime.UtcNow.AddMinutes(-60),
                NotOnOrAfter = DateTime.UtcNow.AddMinutes(60),
                VUID = vuid
            };
            string tokenXml = WebUtility.GetXmlFromObject(token);

            string httpBody = null;

            return SignInVenturaTicketCreate(tokenXml, customerGroup, "fake", null, out httpBody);
        }

        /// <summary>
        /// Signs in the user.
        /// </summary>
        /// <param name="tokenXml">The token xml.</param>
        /// <param name="customerGroup">The customer group.</param>
        /// <param name="authMode">The auth mode.</param>
        /// <param name="timeMachine">The time machine.</param>
        /// <param output name="httpBody">The Http Body of response.</param>
        /// <returns>user credentials</returns>
        internal string SignInVenturaTicketCreate(string tokenXml, string customerGroup, string authMode, string timeMachine, out string httpBody)
        {
            string signInUrl = null;
            _lock.EnterReadLock();
            try
            {
                signInUrl = GetEndpointUrl("SignIn.VenturaTicket.Create");
            }
            finally
            {
                _lock.ExitReadLock();
            }
            
            return SignInVenturaTicketCreate(signInUrl, authMode, customerGroup, timeMachine, tokenXml, out httpBody);
        }


        /// <summary>
        /// Gets the ratings, using the V2 API.
        /// </summary>
        /// <param name="vuid">The vuid.</param>
        /// <param name="mediaId">The media id.</param>
        /// <returns>User Ratings</returns>
        internal MediaReviewWithDictionaryEntriesV2 RatingsUserGetV2(string vuid, string mediaId, string puid)
        {
            Dictionary<string, string> replacementTokens = new Dictionary<string, string>
                                                               {
                                                                   {UserIdToken, vuid}, 
                                                                   {MediaIdToken, mediaId}
                                                               };
            _lock.EnterReadLock();
            try
            {
                return GetDataFromVenturaService<MediaReviewWithDictionaryEntriesV2>("Ratings.User.Get.V2", replacementTokens, _cachedCredentials, puid);
            }
            finally
            {
                _lock.ExitReadLock();
            }
        }

        /// <summary>
        /// Posts the ratings, uding th V2 API
        /// </summary>
        /// <param name="vuid">The vuid.</param>
        /// <param name="mediaId">The media id.</param>
        /// <param name="ratings">The ratings.</param>
        internal void RatingsUserPutV2(string vuid, string mediaId, MediaReviewWithDictionaryEntriesV2 ratings)
        {
            Dictionary<string, string> replacementTokens = new Dictionary<string, string>
                                                               {
                                                                   {UserIdToken, vuid}, 
                                                                   {MediaIdToken, mediaId}
                                                               };
            _lock.EnterReadLock();
            try
            {
                PutDataToVenturaService("Ratings.User.Put.V2", ratings, replacementTokens, _cachedCredentials);
            }
            finally
            {
                _lock.ExitReadLock();
            }
        }        

        /// <summary>
        /// Gets the editorial lists.
        /// </summary>
        /// <param name="start">start item in list pagination</param>
        /// <param name="length">number of items per pagination</param>
        /// <returns>The Media Lists.</returns>
        internal MediaLists ListsActivityGet(string start, string length)
        {
            Dictionary<string, string> replacementTokens = new Dictionary<string, string>();
            Dictionary<string, string> queryStringParameters = new Dictionary<string, string>
                                                                   {
                                                                       {"$skip", start},
                                                                       {"$top", length},
                                                                   };

            _lock.EnterReadLock();
            try
            {
                return GetDataFromVenturaService<MediaLists>("Lists.Activity.Get", replacementTokens, queryStringParameters, null);
            }
            finally
            {
                _lock.ExitReadLock();
            }
        }

        /// <summary>
        /// Gets the editorial list items.
        /// </summary>
        /// <param name="listId">The list id.</param>
        /// <returns>The media List.</returns>
        internal MediaList ListsActivityListGet(string listId)
        {
            Dictionary<string, string> replacementTokens = new Dictionary<string, string> { { ListIdToken, listId } };

            _lock.EnterReadLock();
            try
            {
                return GetDataFromVenturaService<MediaList>("Lists.Activity.List.Get", replacementTokens, null /*no credentials needed*/);
            }
            finally
            {
                _lock.ExitReadLock();
            }
        }

        /// <summary>
        /// Gets the editorial list items.
        /// </summary>
        /// <param name="listId">The list id.</param>
        /// <param output name="result">The raw xml results.</param>
        /// <returns>The media List.</returns>
        internal MediaList ListsActivityListGet(string listId, out XmlNode result)
        {
            Dictionary<string, string> replacementTokens = new Dictionary<string, string> { { ListIdToken, listId } };

            _lock.EnterReadLock();
            try
            {
                return GetDataFromVenturaService<MediaList>("Lists.Activity.List.Get", replacementTokens, null /*no credentials needed*/, out result); 
            }
            finally
            {
                _lock.ExitReadLock();
            }
        }
    }


    [DataContract(Name = "MediaReview", Namespace = Constants.VenturaNamespace)]
    public class MediaReviewWithDictionaryEntriesV2
    {
        public MediaReviewWithDictionaryEntriesV2() { }

        [DataMember(Order = 100, IsRequired = true)]
        public float? Rating { get; set; }

        [DataMember(Order = 200, IsRequired = true)]
        public String Review { get; set; }

        [DataMember(Order = 300, IsRequired = true)]
        public List<DictionaryEntryResult> Entries { get; set; }

        [DataMember(Order = 400, IsRequired = false)]
        public String Emote { get; set; }
    }


    [DataContract(Name = "Entry", Namespace = Constants.VenturaNamespace)]
    public class DictionaryEntryResult
    {
        [DataMember(Order = 100)]
        public string Id { get; set; }

        [DataMember(Order = 200)]
        public string Text { get; set; }
    }

    [DataContract(Name = "Property", Namespace = Constants.VenturaNamespace)]
    public class Property
    {
        [DataMember(Order = 100)]
        public string Name { get; set; }

        [DataMember(Order = 200)]
        public string Value { get; set; }
    }

    [DataContract(Name = "Item", Namespace = Constants.VenturaNamespace)]
    public class Item
    {
        [DataMember(Order = 100)]
        public string Id { get; set; }

        [DataMember(Order = 200)]
        public string Name { get; set; }

        [DataMember(Order = 300)]
        public List<Property> Properties { get; set; }
    }

    [DataContract(Name = "List", Namespace = Constants.VenturaNamespace)]
    public class MediaList
    {
        [DataMember(Order = 100)]
        public string ContextId { get; set; }

        [DataMember(Order = 200)]
        public string Id { get; set; }

        [DataMember(Order = 300)]
        public string Name { get; set; }

        [DataMember(Order = 400, IsRequired = false, EmitDefaultValue = false)]
        public List<Property> Properties { get; set; }

        [DataMember(Order = 500, IsRequired = false, EmitDefaultValue = false)]
        public List<Item> Items { get; set; }
    }

    [CollectionDataContract(Name = "Lists", Namespace = Constants.VenturaNamespace)]
    public class MediaLists : List<MediaList>
    {
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\match\dll\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\venturarr\SharedKeyPool.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security;
using System.Security.Cryptography;

//
// NOTE:
// NOTE: Code in this file taken from Ventura code-base.
// NOTE:
//

namespace xonline.common.venturarr
{
    /// <summary>
    /// An immutable shared key pool mapping ids to keys
    /// </summary>
    public class SharedKeyPool
    {
        private readonly SortedDictionary<byte, byte[]> _idToKeyMap;

        private SharedKeyPool(SortedDictionary<byte, byte[]> idToKeyMap)
        {
            _idToKeyMap = new SortedDictionary<byte, byte[]>(idToKeyMap);
        }

        /// <summary>
        /// Returns the key at idx
        /// </summary>
        public byte[] this[byte idx]
        {
            get
            {
                return _idToKeyMap[idx];
            }
        }

        /// <summary>
        /// Checks whether a key at idx exists
        /// </summary>
        /// <param name="idx"></param>
        /// <returns></returns>
        public bool ContainsIndex(byte idx)
        {
            return _idToKeyMap.ContainsKey(idx);
        }

        /// <summary>
        /// A serialized form of the key pool, which can be interpreted by FromString
        /// </summary>
        public override string ToString()
        {
            if (_idToKeyMap.Count == 0)
            {
                return "";
            }
            StringBuilder sb = new StringBuilder();
            foreach (var kvp in _idToKeyMap)
            {
                sb.Append(kvp.Key);
                sb.Append(intraKeyDelim);
                sb.Append(Convert.ToBase64String(kvp.Value));
                sb.Append(interKeyDelim);
            }
            // chop off the last inter-key delim
            return sb.ToString(0, sb.Length - 1);
        }

        /// <summary>
        /// Enumeration of all the key indices
        /// </summary>
        public IEnumerable<byte> KeyIndices
        {
            get
            {
                return _idToKeyMap.Keys;
            }
        }

        /// <summary>
        /// Number of keys
        /// </summary>
        public int KeyCount
        {
            get
            {
                return _idToKeyMap.Count;
            }
        }

        private const char interKeyDelim = '|', intraKeyDelim = ':';

        /// <summary>
        /// Creates an empty SharedKeyPool
        /// </summary>
        public static SharedKeyPool CreateEmpty()
        {
            return CreateKeyPool(0, 1 /* irrelevant */);
        }

        /// <summary>
        /// Creates a SharedKeyPool with n keys of size sizeInBytes
        /// </summary>
        public static SharedKeyPool CreateKeyPool(byte n, int keySizeInBytes)
        {
            SortedDictionary<byte, byte[]> idToKeyMap;
            if (n > 0)
            {
                if (keySizeInBytes <= 0)
                {
                    throw new ArgumentException("keySizeInBytes");
                }
                idToKeyMap = new SortedDictionary<byte, byte[]>(
                    Enumerable.Range(0, n).ToDictionary(
                        i => (byte)i,
                        i => GenerateKey(keySizeInBytes)));
            }
            else
            {
                idToKeyMap = new SortedDictionary<byte, byte[]>();
            }
            return new SharedKeyPool(idToKeyMap);
        }

        /// <summary>
        /// Parses a key pool from a string (as generated by ToString())
        /// </summary>
        /// <param name="poolstring">A string returned by KeyPool.ToString()</param>
        public static SharedKeyPool FromString(string poolstring)
        {
            SortedDictionary<byte, byte[]> idToKeyMap = new SortedDictionary<byte, byte[]>();
            if ("" != poolstring)
            {
                try
                {
                    foreach (var x in poolstring.Split(interKeyDelim))
                    {
                        var kv = x.Split(intraKeyDelim);
                        if (string.IsNullOrEmpty(kv[1]))//if (string.IsNullOrWhiteSpace(kv[1]))
                        {
                            throw new FormatException("key must be non-empty");
                        }
                        idToKeyMap[byte.Parse(kv[0])] = Convert.FromBase64String(kv[1]);
                    }
                }
                catch (Exception x)
                {
                    // anything thrown above is due to misformated argument
                    throw new ArgumentException("poolstring", x);
                }
            }
            return new SharedKeyPool(idToKeyMap);
        }

        /// <summary>
        /// Returns a new key pool identical to this one
        /// </summary>
        public SharedKeyPool AddNewRandomKey(int keySizeInBytes)
        {
            byte dummy;
            return AddNewRandomKey(keySizeInBytes, out dummy);
        }

        /// <summary>
        /// Creates a cryptographically random key of size keySizeInBytes
        /// </summary>
        public static byte[] GenerateKey(int keySizeInBytes)
        {
            if (keySizeInBytes <= 0)
            {
                throw new ArgumentException("keySizeInBytes < 0", "keySizeInBytes");
            }
            var nkey = new byte[keySizeInBytes];
            //using (var x = CreateRNG())
            {
                var x = CreateRNG() ; // .Net 3.5 RNGCriptoServiceProvider does not implement IDisposble
                x.GetBytes(nkey);
            }
            return nkey;
        }

        protected static RandomNumberGenerator CreateRNG()
        {
            return RNGCryptoServiceProvider.Create();
        }

        /// <summary>
        /// Returns a new key pool identical to this one, with a new key at index newKeyIndex
        /// </summary>
        public SharedKeyPool AddNewRandomKey(int keySizeInBytes, out byte newKeyIndex)
        {
            var nkey = GenerateKey(keySizeInBytes);

            // by default, find the largest id and take the next one until an empty one is found
            // start at 0 if nothing's in the pool
            byte lid = _idToKeyMap.Count == 0 ? (byte)255 : _idToKeyMap.Last().Key;
            byte ret = _idToKeyMap.Count == 0 ? (byte)0 : (byte)((lid + 1) % 256);
            while (ret != lid && _idToKeyMap.ContainsKey(ret))
            {
                ret = (byte)((ret + 1) % 256);
            }
            if (ret == lid)
            {
                throw new InvalidOperationException("SharedKeyPool already contains maximum 256 keys");
            }

            SortedDictionary<byte, byte[]> idToKeyMap = new SortedDictionary<byte, byte[]>(_idToKeyMap);
            idToKeyMap[ret] = nkey;
            newKeyIndex = ret;
            return new SharedKeyPool(idToKeyMap);
        }

        /// <summary>
        /// Returns a new key pool identical to this one, without the key at idx
        /// </summary>
        public SharedKeyPool RemoveKey(byte idx)
        {
            SortedDictionary<byte, byte[]> idToKeyMap = new SortedDictionary<byte, byte[]>(_idToKeyMap);
            idToKeyMap.Remove(idx);
            return new SharedKeyPool(idToKeyMap);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\match\dll\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\wholesale\WholesalePartner.cs ===
using System;
using System.Data.SqlClient;

using xonline.common.config;
using xonline.common.sql.sqlclient;

namespace xonline.common.wholesale
{
    public class WholesalePartner
    {
        private uint   _id;
        private string _name;
        private string _prefix;

        private int    _passwordLength;
        private bool   _passwordChange;

        private int    _gamertagLength;
        private bool   _gamertagChange;

        public WholesalePartner(uint id) {
            this._id = id;
            Load();
        }

        private void Load() {

            using (SqlClient cmd = new SqlClient(Interface.npdb))
            {
                // get a list of all the methods for the specific api

                cmd.StoredProc = "p_wholesale_partner_get";
                cmd.AddParameter("@i_partner_id", _id);

                using (SqlDataReader reader = cmd.Execute())
                {
                    if (! reader.Read()) {
                        throw new Exception("Provider " + _name + " not found");
                    }

                    _name             = reader.GetString(reader.GetOrdinal("vc_partner_name"));
                    _prefix           = reader.GetString(reader.GetOrdinal("vc_partner_prefix"));

                    _passwordLength   = reader.GetByte(reader.GetOrdinal("ti_password_length"));
                    _passwordChange   = reader.GetByte(reader.GetOrdinal("ti_password_change")) != 0;

                    _gamertagLength   = reader.GetByte(reader.GetOrdinal("ti_gamertag_length"));
                    _gamertagChange   = reader.GetByte(reader.GetOrdinal("ti_gamertag_change")) != 0;

                    reader.Close();
                }
            }
        }

        public uint Id {
            get { return _id; }
        }

        public string Name {
            get { return _name; }
        }

        public string Prefix {
            get { return _prefix; }
        }

        public int PasswordLength {
            get { return _passwordLength; }
        }

        public bool PasswordChange {
            get { return _passwordChange; }
        }

        public int GamertagLength {
            get { return _gamertagLength; }
        }

        public bool GamertagChange {
            get { return _gamertagChange; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\user\user.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Data.SqlClient;
using System.Text;
using System.Threading;
using System.Transactions;

using xonline.common.audit;
using xonline.common.billing;
using xonline.common.config;
using xonline.common.crypto;
using xonline.common.mgmt;
using xonline.common.offer;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.sql.webstore;
using xonline.common.utilities;

using Microsoft.Webstore.WstClient;

using System.Web;
using System.Data;
using xonline.common.sql.sqlclient;
using xonline.core.history;


namespace xonline.common.user
{
    public enum UserTypeEnum : byte
    {
        Xbox1User           = 0,
        XboxComUser         = 1,
        XenonUser           = 2,
        Xbox1LinkedUser     = 3
    }

    public class PerServiceTypeData
    {
        public DateTime DateAcceptedTermsOfService;
        public DateTime DateLatestTermsOfService;
        public DateTime DateProvisioned;
        public DateTime DateSuspendedUntil;
        public DateTime DateLastSuspended;
        public int      TimesSuspended;
        public DateTime DateLastWebActivity;
    }

    public class XConsoleKey
    {
        private string _gamertag;
        private byte[] _rawKey;
        private byte[] _encryptedKey;
        private byte[] _IV;
        private byte[] _SPPA;
        private byte[] _PPA;

        public XConsoleKey(string gamertag)
        {
            _gamertag = gamertag;
            KEKCryptoMgr.GenerateNewKey(out _IV, out _encryptedKey, out _rawKey);
            KEKCryptoMgr.GenPPAforDBWrp(gamertag, (byte[]) _rawKey.Clone(), out _SPPA, out _PPA);
        }

        public XConsoleKey(string gamertag, byte[] rawKey, byte[] encryptedKey, byte[] IV, byte[] SPPA, byte[] PPA)
        {
            _gamertag     = gamertag;
            _rawKey       = rawKey;
            _encryptedKey = encryptedKey;
            _IV           = IV;
            _SPPA         = SPPA;
            _PPA          = PPA;
        }

        public byte[] RawKey
        {
            get { return _rawKey; }
            set { _rawKey = value; }
        }

        public byte[] EncryptedKey
        {
            get { return _encryptedKey; }
            set { _encryptedKey = value; }
        }

        public byte[] IV
        {
            get { return _IV; }
            set { _IV = value; }
        }

        public byte[] SPPA
        {
            get { return _SPPA; }
            set { _SPPA = value; }
        }

        public byte[] PPA
        {
            get { return _PPA; }
            set { _PPA = value; }
        }

    }
    
    public class ServiceTypeData : IEnumerable<KeyValuePair<ServiceTypeEnum, PerServiceTypeData>>
    {
        public ServiceTypeData()
        {
            serviceTypeData = new SortedDictionary<ServiceTypeEnum, PerServiceTypeData>();
        }

        public void Add(ServiceTypeEnum serviceType, PerServiceTypeData pstd)
        {
            serviceTypeData.Add(serviceType, pstd);
        }

        public PerServiceTypeData this[ServiceTypeEnum index]
        {
            get
            {
                PerServiceTypeData pstd = null;

                if ( serviceTypeData == null || !serviceTypeData.TryGetValue(index, out pstd) )
                {
                    return null;
                }

                Debug.Assert( serviceTypeData != null );
                Debug.Assert( pstd != null );

                return pstd;
            }

            set
            {
                PerServiceTypeData pstd = null;
                if ( !serviceTypeData.TryGetValue(index, out pstd) )
                {
                    serviceTypeData.Add(index, value);
                }
                else
                {
                    pstd = value;
                }
            }
        }

        public IEnumerator<KeyValuePair<ServiceTypeEnum, PerServiceTypeData>> GetEnumerator()
        {
            return serviceTypeData.GetEnumerator();
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return serviceTypeData.GetEnumerator();
        }
    
        SortedDictionary<ServiceTypeEnum, PerServiceTypeData> serviceTypeData = null;
    }

public class User
{
    // user account types
    public const byte Xbox1Account      = 0;
    public const byte XboxComAccount    = 1;
    public const byte XenonAccount      = 2;
    public const byte ZuneAccount       = 3;
    public const byte PanoramaAccount   = 4;

    // Typical entry point to load from UODB
    //
    public void Load(ulong puid)
    {
        HResult hr;
        using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
        {
            hr = Load(puid, ws);
            if (HResult.Failed(hr))
            {
                throw new XRLException(hr, XEvent.Id.COMMON_CODE_213, "Can't find user: 0x" + puid.ToString("x") + " in UODB!  hr = " + hr);
            }
        }
    }


    // This is the BYOWebstore version
    //
    public HResult Load(ulong puid, WSClient ws)
    {
        HResult hr = 0x0;

        _puid = puid;
        _ownerPuid = 0;
        _passportPuid = 0;
        _ownerPassportPuid = 0;
        _countryId = 0;
        _accountId = "";
        _paymentInfoId = "";
        _serviceTypeData = null;

        ws.ClearParameters();
        ws.StoredProc = "dbo.p_xuacs_get_user_account_info";
        ws.SetHashVal(puid);

        ws.AddParameter(ParamType.RETVAL, "@hr", 0);
        ws.AddParameter(ParamType.INPUT, "@bi_user_puid", _puid);
        ws.AddParameter(ParamType.INPUT, "@ti_backwards_compatibility", (byte) 0);

        // call the procedure
        using (WstDataReader rdr = ws.Execute())
        {
            if ( !rdr.Read() )
            {
                hr = HResult.XONLINE_E_ACCOUNTS_INVALID_USER;
                return hr;
            }

            _ownerPuid = WSClient.GetUInt64(rdr, "bi_owner_puid");
            _offlineXuid = WSClient.GetUInt64(rdr, "bi_offline_xuid");
            _passportPuid = WSClient.GetUInt64(rdr, "bi_user_passport_puid");
            _ownerPassportPuid = WSClient.GetUInt64(rdr, "bi_owner_passport_puid");
            _accountType = WSClient.GetByte(rdr, "ti_account_type");
            _createdAccountType = WSClient.GetByte(rdr, "ti_created_account_type");
            _allowXbox1Logon = WSClient.GetByte(rdr, "f_allow_xbox1_logon" );
            _machinePuid = WSClient.GetUInt64(rdr, "bi_machine_puid");
            _countryId = WSClient.GetByte(rdr, "ti_country_id");
            _languageId = WSClient.GetInt32(rdr, "i_language_id");
            _cultureId = WSClient.GetInt32(rdr, "i_culture_id");
            _accountId = WSClient.GetString(rdr, "vc_billing_account_id");
            _paymentInfoId = WSClient.GetString(rdr, "vc_billing_payinfo_id");
            _gamerTag  = WSClient.GetString(rdr, "vc_gamertag");
            _birthdate = WSClient.GetDateTime(rdr, "dt_birthdate");
            _ticketFlags = WSClient.GetInt16(rdr, "si_ticket_flags");
            _accountResumeDate = WSClient.GetDateTime(rdr, "dt_acct_resume_date");
            _suspensionLength  = WSClient.GetInt32(rdr, "i_suspension_length");
            _voiceResumeDate   = WSClient.GetDateTime(rdr, "dt_voice_resume_date");
            _voiceBanLength = WSClient.GetInt32(rdr, "i_voice_ban_length");
            _nameChangeRequired = WSClient.GetByte(rdr, "ti_name_change_required");
            _acceptedTOSDate = WSClient.GetDateTime(rdr, "dt_accepted_tos");
            _resetDate = WSClient.GetDateTime(rdr, "dt_reset_date");
            _billingAccountStatus = WSClient.GetUInt32(rdr, "i_billing_account_status");
            _billingPIN = WSClient.GetBytes(rdr, "bin_acct_pin");
            _parentalControlGroupId = WSClient.GetInt32(rdr, "i_parental_control_group_id");
            _lastChangeDate = WSClient.GetDateTime(rdr, "dt_change_datetime");
            _downgraded = WSClient.GetByte(rdr, "f_downgraded");
            _lastActivityDate = WSClient.GetDateTime(rdr, "dt_last_activity");
            _lastWebActivityDate = WSClient.GetDateTime(rdr, "dt_last_web_activity");
            _acceptMsSpam = WSClient.GetByte(rdr, "f_ms_opt_in");
            _acceptPartnerSpam = WSClient.GetByte(rdr, "f_partner_opt_in");
            _hasMusicnetAccount = (byte) WSClient.GetInt32(rdr, "i_has_musicnet_account");
            _isGeoFenceExempt = WSClient.GetByte(rdr, "f_geofence_exempt");
            _tier = WSClient.GetInt32(rdr, "i_tier_id");
            _wholesalePartnerId = WSClient.GetUInt32(rdr, "i_wholesale_partner_id");
            _hasPiiForPurchase = WSClient.GetByte(rdr, "ti_has_pii_for_purchase");
            _userPassportInvalid = WSClient.GetByte(rdr, "ti_invalid_user_passport");
            _ownerPassportInvalid = WSClient.GetByte(rdr, "ti_invalid_owner_passport");
            _gamertagRecycled = WSClient.GetByte(rdr, "ti_recycled_gamertag");
            _freeGamertagEligible = WSClient.GetByte(rdr, "f_free_gamertag_eligible");

            if ( rdr.NextResult() )
            {
                _serviceTypeData = new ServiceTypeData();

                while ( rdr.Read() )
                {
                    PerServiceTypeData pstd = new PerServiceTypeData();

                    ServiceTypeEnum serviceType = (ServiceTypeEnum) WSClient.GetByte(rdr, "ti_service_type");

                    pstd.DateAcceptedTermsOfService = WSClient.GetDateTime(rdr, "dt_accepted_tos");
                    pstd.DateProvisioned = WSClient.GetDateTime(rdr, "dt_provisioned");
                    pstd.DateSuspendedUntil = WSClient.GetDateTime(rdr, "dt_suspended_until");
                    pstd.DateLastSuspended = WSClient.GetDateTime(rdr, "dt_last_suspended");
                    pstd.TimesSuspended = WSClient.GetInt32(rdr, "i_times_suspended");
                    pstd.DateLastWebActivity = WSClient.GetDateTime(rdr, "dt_last_web_activity");
                    pstd.DateLatestTermsOfService = WSClient.GetDateTime(rdr, "dt_latest_tos");

                    _serviceTypeData.Add(serviceType, pstd);
                }
            }

            rdr.Close();

            hr = (uint)ws.GetIntParameter("@hr");
            if (HResult.Failed(hr))
            {
                //string msg = ws.GetCallSignature() + " failed with hr = " + hr;
                return hr;
            }

            _isNew = false;
        }

        return hr;
    }


    // Overload to get user from gamertag.
    // NOTE: WILL NOT EXCEPT if the gamertag dosen't exist; it'll just return the failed hr.
    //       -- slamb, 18268
    //
    public HResult LoadFromGamerTag(string gamertag)
    {
        HResult hr = 0x0;

        _puid      = 0;
        _ownerPuid = 0;
        _passportPuid = 0;
        _ownerPassportPuid = 0;
        _countryId = 0;
        _accountId = "";
        _paymentInfoId = "";

        // if this code appears to be running in a server context, try using
        // XCache to lookup the user puid rather than making a separate stored
        // procedure call to UODB.
        if ( HttpContext.Current != null )
        {
            try
            {
                _puid = XCache.LookupPUID(gamertag);
            }
            catch (Exception)
            {
                _puid = 0;
            }
        }

        using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
        {

            if ( _puid == 0 )
            {
                ws.StoredProc = "dbo.p_xuacs_get_user_acct_by_name";
                ws.SetHashVal(gamertag);

                ws.AddParameter(ParamType.RETVAL, "@RETVAL", 0);
                ws.AddParameter(ParamType.INPUT,  "@vc_gamertag", gamertag, 16);
                ws.AddParameter(ParamType.OUTPUT, "@bi_user_puid", _puid);

                ws.ExecuteNonQuery();

                hr = (uint)ws.GetIntParameter("@RETVAL");
                if (HResult.Failed(hr))
                {
                    return hr;
                }

                _puid = (ulong)ws.GetLongParameter("@bi_user_puid");
            }

            // call through with puid and the current webstore object.
            hr = Load(_puid, ws);
        }

        //
        // We have a data integrity problem if we can't find the user.  We allow the hr
        // E_IS_MACHINE to pass through because a name currently reserved
        // can display that hiccup.
        //

        if (hr == HResult.XONLINE_E_ACCOUNTS_INVALID_USER)
        {
            throw new XRLException(hr, XEvent.Id.COMMON_CODE_214, "User.LoadFromGamertag: Can't find user: 0x" + _puid.ToString("x") + " in UODB!  hr = " + hr);
        }

        return hr;

    }



    // Method to get user from Passport puid.
    //
    public HResult LoadFromPassportPuid(ulong passportPuid)
    {
        HResult hr = 0x0;

        _puid      = 0;
        _ownerPuid = 0;
        _passportPuid = passportPuid;
        _ownerPassportPuid = 0;
        _countryId = 0;
        _accountId = "";
        _paymentInfoId = "";

        // if this code appears to be running in a server context, try using
        // XCache to lookup the user puid rather than making a separate stored
        // procedure call to UODB.
        if ( HttpContext.Current != null )
        {
            try
            {
                _puid = XCache.LookupPUID(passportPuid);
            }
            catch (Exception)
            {
                _puid = 0;
            }
        }

        using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
        {

            if ( _puid == 0 )
            {
                ws.StoredProc = "dbo.p_xuacs_get_user_by_passport";
                ws.SetHashVal(passportPuid);

                ws.AddParameter(ParamType.RETVAL, "@RETVAL", 0);
                ws.AddParameter(ParamType.INPUT,  "@bi_user_passport_puid", _passportPuid);
                ws.AddParameter(ParamType.OUTPUT, "@bi_user_puid", _puid);

                ws.ExecuteNonQuery();

                hr = (uint)ws.GetIntParameter("@RETVAL");
                if (HResult.Failed(hr))
                {
                    return hr;
                }

                _puid = (ulong)ws.GetLongParameter("@bi_user_puid");
            }

            // call through with puid and the current webstore object.
            hr = Load(_puid, ws);
        }

        if (hr == HResult.XONLINE_E_ACCOUNTS_INVALID_USER)
        {
            throw new XRLException(hr, XEvent.Id.COMMON_CODE_215, "User.LoadFromPassportPuid: can't find user 0x" + _puid.ToString("X") + " in UODB!");
        }

        return hr;
    }

    // Method to get user from owner puid.
    //
    public HResult LoadFromOwnerPuid(ulong ownerPuid)
    {
        HResult hr = 0x0;

        _puid      = 0;
        _ownerPuid = ownerPuid;
        _passportPuid = 0;
        _ownerPassportPuid = 0;
        _countryId = 0;
        _accountId = "";
        _paymentInfoId = "";

        using (WstConnection c = new WstConnection(ConfigUtil.UodbWebstoreApp))
        {
            c.Open();

            for (int i=0; i < c.SqlPartitions.Count; i++)
            {
                using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
                {

                    ws.StoredProc = "dbo.p_xcsr_get_related_accounts";
                    ws.PhysicalPartition = i;

                    ws.AddParameter("@bi_puid", ownerPuid);

                    using (WstDataReader rs = ws.Execute())
                    {
                        while(rs.Read())
                        {
                            _puid = (ulong) rs.GetInt64(0);
                            break;
                        }
                    }

                    if ( _puid != 0 )
                    {
                        break;
                    }

                }
            }
        }

        if ( _puid == 0 )
        {
            return HResult.XONLINE_E_ACCOUNTS_INVALID_USER;
        }

        // use the user puid to load the entire object
        using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
        {
            hr = Load(_puid, ws);
        }

        if (hr == HResult.XONLINE_E_ACCOUNTS_INVALID_USER)
        {
            throw new XRLException(hr, XEvent.Id.COMMON_CODE_216, "User.LoadFromOwnerPuid: can't find user 0x" + _puid.ToString("X") + " in UODB!");
        }

        return hr;
    }


    public void Save()
    {
        WSClient ws = null;
        Save(ref ws);
    }

    public void Save(ref WSClient ws)
    {
        HResult hr;

        if (_isNew == true)
        {
            throw new Exception("NYI");
        }

        if (ws == null)
        {
            ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE);
        }

        ws.ClearParameters();
        ws.StoredProc = "dbo.p_xuacs_set_user_acct";
        ws.SetHashVal(_puid);

        ws.AddParameter(ParamType.RETVAL, "@RETVAL", 0);        // hr
        ws.AddParameter("@bi_user_puid", _puid );               // user puid
        ws.AddParameter("@bi_owner_puid", _ownerPuid );         // owner puid
        ws.AddParameter("@bi_offline_xuid", _offlineXuid);      // offline xuid
        ws.AddParameter("@bi_user_passport_puid", _passportPuid); // user passport puid
        ws.AddParameter("@bi_owner_passport_puid", _ownerPassportPuid); // owner passport puid
        ws.AddParameter("@ti_account_type", _accountType);
        ws.AddParameter("@f_allow_xbox1_logon", _allowXbox1Logon);
        ws.AddParameter("@ti_country_id", _countryId );         // country id
        ws.AddParameter("@i_language_id", _languageId );        // language id
        ws.AddParameter("@i_culture_id", _cultureId );          // culture id
        ws.AddParameter("@vc_billing_account_id", _accountId ); // billing account id
        ws.AddParameter("@vc_billing_payinfo_id", _paymentInfoId ); // billing payment inst id
        ws.AddParameter("@vc_gamertag", _gamerTag );
        ws.AddParameter("@dt_birthdate", _birthdate );
        ws.AddParameter("@si_ticket_flags", _ticketFlags );
        ws.AddParameter("@dt_acct_resume_date", _accountResumeDate );
        ws.AddParameter("@i_suspension_length", _suspensionLength );
        ws.AddParameter("@dt_voice_resume_date", _voiceResumeDate );
        ws.AddParameter("@i_voice_ban_length", _voiceBanLength );
        ws.AddParameter("@ti_name_change_required", _nameChangeRequired );
        ws.AddParameter("@dt_accepted_tos", _acceptedTOSDate );
        ws.AddParameter("@dt_reset_date", _resetDate );
        ws.AddParameter("@i_billing_account_status", _billingAccountStatus );
        ws.AddParameter("@bin_acct_pin", _billingPIN );
        ws.AddParameter("@i_parental_control_group_id", _parentalControlGroupId);
        ws.AddParameter("@f_ms_opt_in", _acceptMsSpam );
        ws.AddParameter("@f_partner_opt_in", _acceptPartnerSpam );
        ws.AddParameter("@f_downgraded", _downgraded );
        ws.AddParameter("@f_geofence_exempt", _isGeoFenceExempt );
        ws.AddParameter("@i_wholesale_partner_id", _wholesalePartnerId);
        ws.AddParameter("@f_has_pii_for_purchase", _hasPiiForPurchase);
        ws.AddParameter("@dt_change_datetime", _lastChangeDate);
        ws.AddParameter("@ti_invalid_user_passport", _userPassportInvalid);
        ws.AddParameter("@ti_invalid_owner_passport", _ownerPassportInvalid);
        ws.AddParameter("@ti_recycled_gamertag", _gamertagRecycled);
        ws.AddParameter("@f_free_gamertag_eligible", _freeGamertagEligible);

        ws.ExecuteNonQuery();

        hr = (uint)ws.GetIntParameter("@RETVAL");
        if (HResult.Failed(hr))
        {
            throw new Exception("Error saving " + _puid + " in UODB! hr = " + hr);
        }
    }

    public void SaveWithSubscription(ulong offerId, string serviceInstanceId)
    {
        Debug.Assert(_isNew == true);       // updating existing users with this not supported

        Guid? catalogOfferId;
        Guid? catalogOfferInstanceId;

        XeSubscriptionUtil.GetCatalogOfferForNewUser(
            offerId, _countryId, (uint) PaymentTypeEnum.CreditCard,
            out catalogOfferId, out catalogOfferInstanceId
        );

        using (TransactionScope transaction = new TransactionScope())
        {
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.StoredProc = "dbo.p_xuacs_add_user_v2";
                ws.SetHashVal(_puid);

                ws.AddParameter("@bi_user_puid", _puid);
                ws.AddParameter("@bi_owner_puid", _ownerPuid);
                ws.AddParameter("@bi_machine_puid", _machinePuid);
                ws.AddParameter("@ti_country_id", _countryId);
                ws.AddParameter("@i_language_id", _languageId);
                ws.AddParameter("@vc_billing_account_id", _accountId);
                ws.AddParameter("@vc_billing_payinfo_id", _paymentInfoId);
                ws.AddParameter("@vc_gamertag", _gamerTag);
                ws.AddParameter("@dt_birthdate", _birthdate);
                ws.AddParameter("@si_ticket_flags", _ticketFlags);
                ws.AddParameter("@dt_acct_resume_date", _accountResumeDate);
                ws.AddParameter("@i_suspension_length", _suspensionLength);
                ws.AddParameter("@dt_voice_resume_date", _voiceResumeDate);
                ws.AddParameter("@i_voice_ban_length", _voiceBanLength);
                ws.AddParameter("@ti_name_change_required", _nameChangeRequired);
                ws.AddParameter("@dt_accepted_tos", _acceptedTOSDate);
                ws.AddParameter("@dt_reset_date", _resetDate);
                ws.AddParameter("@i_billing_account_status", _billingAccountStatus);
                ws.AddParameter("@bin_acct_pin", _billingPIN);
                ws.AddParameter("@f_ms_opt_in", _acceptMsSpam);
                ws.AddParameter("@f_partner_opt_in", _acceptPartnerSpam);
                ws.AddParameter("@ti_service_type", (byte)ServiceTypeEnum.XboxLive);

                ws.AddParameter("@si_hash_bucket", ws.Partition);

                ws.ExecuteNonQuery();
                AuditStream.Write(_puid, AuditSubsystem.XUACS, ws, string.Empty);

                XeSubscriptionUtil.CreateSubscriptionForNewUser(
                    _puid, offerId, serviceInstanceId, catalogOfferId, catalogOfferInstanceId
                );

                // also add the association of the passport puid to the user puid
                if (_passportPuid != 0)
                {
                    ws.ClearParameters();
                    ws.StoredProc = "dbo.p_xuacs_add_user_by_passport";
                    ws.SetHashVal(_passportPuid);

                    ws.AddParameter("@bi_user_passport_puid", _passportPuid);
                    ws.AddParameter("@bi_user_puid", _puid);
                    ws.AddParameter("@si_hash_bucket", ws.Partition);

                    ws.ExecuteNonQuery();
                }

                // Add an entry in the family membership table
                AddFamilyMembershipEntry(ws);
                transaction.Complete();
            }
        }
    }

    public void CreateLiveAccount(ulong offerId, string serviceInstanceId, ServiceTypeEnum provisionedServiceType, uint uodbPaymentType)
    {
        Debug.Assert(_isNew == true);       // updating existing users with this not supported
        if ( _isNew == false )
        {
            throw new Exception("User.CreateLiveAccount: updating existing users not allowed.  gamertag: '" + _gamerTag + "'");
        }

        Guid? catalogOfferId;
        Guid? catalogOfferInstanceId;

        XeSubscriptionUtil.GetCatalogOfferForNewUser(
            offerId, _countryId, uodbPaymentType, out catalogOfferId, out catalogOfferInstanceId
        );

        using (TransactionScope transaction = new TransactionScope())
        {
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.StoredProc = "dbo.p_xuacs_create_live_account_v3";
                ws.SetHashVal(_puid);

                ws.AddParameter("@bi_user_puid", _puid);
                ws.AddParameter("@bi_owner_puid", _ownerPuid);
                ws.AddParameter("@bi_offline_xuid", _offlineXuid);
                ws.AddParameter("@bi_user_passport_puid", _passportPuid);
                ws.AddParameter("@bi_owner_passport_puid", _ownerPassportPuid);
                ws.AddParameter("@bi_machine_puid", _machinePuid);
                ws.AddParameter("@ti_country_id", _countryId);
                ws.AddParameter("@i_language_id", _languageId);
                ws.AddParameter("@vc_billing_account_id", _accountId);
                ws.AddParameter("@vc_gamertag", _gamerTag);
                ws.AddParameter("@f_allow_xbox1_logon", _allowXbox1Logon);
                ws.AddParameter("@dt_birthdate", _birthdate);
                ws.AddParameter("@si_ticket_flags", _ticketFlags);
                ws.AddParameter("@dt_acct_resume_date", _accountResumeDate);
                ws.AddParameter("@i_suspension_length", _suspensionLength);
                ws.AddParameter("@dt_voice_resume_date", _voiceResumeDate);
                ws.AddParameter("@i_voice_ban_length", _voiceBanLength);
                ws.AddParameter("@ti_name_change_required", _nameChangeRequired);
                ws.AddParameter("@dt_accepted_tos", _acceptedTOSDate);
                ws.AddParameter("@dt_reset_date", _resetDate);
                ws.AddParameter("@i_billing_account_status", _billingAccountStatus);
                ws.AddParameter("@bin_acct_pin", _billingPIN);
                ws.AddParameter("@i_parental_control_group_id", _parentalControlGroupId);
                ws.AddParameter("@f_ms_opt_in", _acceptMsSpam);
                ws.AddParameter("@f_partner_opt_in", _acceptPartnerSpam);
                ws.AddParameter("@ti_created_account_type", _createdAccountType);
                ws.AddParameter("@ti_service_type", (byte)provisionedServiceType);
                ws.AddParameter("@i_wholesale_partner_id", _wholesalePartnerId);
                ws.AddParameter("@f_free_gamertag_eligible", _freeGamertagEligible);

                ws.AddParameter("@si_hash_bucket", ws.Partition);
                ws.AddParameter(ParamType.OUTPUT, "@i_culture_id", 0);

                ws.ExecuteNonQuery();
                AuditStream.Write(_puid, AuditSubsystem.XUACS, ws, "success");

                _cultureId = ws.GetIntParameter("@i_culture_id");

                XeSubscriptionUtil.CreateSubscriptionForNewUser(
                    _puid, offerId, serviceInstanceId, catalogOfferId, catalogOfferInstanceId
                );

                // also add the association of the passport puid to the user puid
                if (_passportPuid != 0)
                {
                    ws.ClearParameters();
                    ws.StoredProc = "dbo.p_xuacs_add_user_by_passport";
                    ws.SetHashVal(_passportPuid);

                    ws.AddParameter("@bi_user_passport_puid", _passportPuid);
                    ws.AddParameter("@bi_user_puid", _puid);
                    ws.AddParameter("@si_hash_bucket", ws.Partition);

                    ws.ExecuteNonQuery();
                }

                // Add an entry in the family membership table
                AddFamilyMembershipEntry(ws);
                transaction.Complete();
            }
        }

        AccountUtil.RegisterOfflineXuid(_offlineXuid, _puid);

        // call presence outside of the transaction
        if (_passportPuid != _ownerPassportPuid)
        {
            QueueFamilyAutoFriend();
        }
    }

    public void Create(ServiceTypeEnum provisionedServiceType, out XConsoleKey xenonKey)
    {
        Debug.Assert(_isNew == true);       // updating existing users with this not supported
        if ( _isNew == false )
        {
            throw new Exception("User.CreateUserAccount: updating existing users not allowed.  gamertag: '" + _gamerTag + "'");
        }

        // generate Xenon keys
        xenonKey = new XConsoleKey( _gamerTag );

        Guid? catalogOfferId;
        Guid? catalogOfferInstanceId;

        XeSubscriptionUtil.GetCatalogOfferForNewUser(
            XOn.SILVER_OFFER, _countryId, (uint) PaymentTypeEnum.CreditCard,
            out catalogOfferId, out catalogOfferInstanceId
        );

        // Rather than using reserved entries in t_user_passport_puids, let's wrap this up in a transaction
        using (TransactionScope txnScope = new TransactionScope())
        {
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.StoredProc = "dbo.p_xuacs_create_user_v3";
                ws.SetHashVal(_puid);

                ws.AddParameter("@bi_user_puid", _puid );
                ws.AddParameter("@bi_owner_puid", _ownerPuid );
                ws.AddParameter("@bi_offline_xuid", _offlineXuid);
                ws.AddParameter("@bi_user_passport_puid", _passportPuid);
                ws.AddParameter("@bi_owner_passport_puid", _ownerPassportPuid);
                ws.AddParameter("@bi_machine_puid", _machinePuid );
                ws.AddParameter("@ti_country_id", _countryId );
                ws.AddParameter("@i_language_id", _languageId );
                ws.AddParameter("@vc_billing_account_id", _accountId );
                ws.AddParameter("@vc_gamertag", _gamerTag );
                ws.AddParameter("@f_allow_xbox1_logon", _allowXbox1Logon);
                ws.AddParameter("@dt_birthdate", _birthdate );
                ws.AddParameter("@si_ticket_flags", _ticketFlags );
                ws.AddParameter("@dt_acct_resume_date", _accountResumeDate );
                ws.AddParameter("@i_suspension_length", _suspensionLength );
                ws.AddParameter("@dt_voice_resume_date", _voiceResumeDate );
                ws.AddParameter("@i_voice_ban_length", _voiceBanLength );
                ws.AddParameter("@ti_name_change_required", _nameChangeRequired );
                ws.AddParameter("@dt_accepted_tos", _acceptedTOSDate );
                ws.AddParameter("@dt_reset_date", _resetDate );
                ws.AddParameter("@i_billing_account_status", _billingAccountStatus );
                ws.AddParameter("@bin_acct_pin", _billingPIN );
                ws.AddParameter("@i_parental_control_group_id", _parentalControlGroupId );
                ws.AddParameter("@f_ms_opt_in", _acceptMsSpam );
                ws.AddParameter("@f_partner_opt_in", _acceptPartnerSpam );
                ws.AddParameter("@ti_created_account_type", _createdAccountType);
                ws.AddParameter("@ti_service_type", (byte) provisionedServiceType );
                ws.AddParameter("@i_wholesale_partner_id", _wholesalePartnerId);
                ws.AddParameter("@f_free_gamertag_eligible", _freeGamertagEligible);

                ws.AddParameter("@si_hash_bucket", ws.Partition );
                ws.AddParameter(ParamType.OUTPUT, "@i_culture_id", 0);

                ws.ExecuteNonQuery();
                AuditStream.Write(_puid, AuditSubsystem.XUACS, ws, "success");

                _cultureId = ws.GetIntParameter("@i_culture_id");

                XeSubscriptionUtil.CreateSubscriptionForNewUser(
                    _puid, XOn.SILVER_OFFER, string.Empty, catalogOfferId, catalogOfferInstanceId
                );

                // also add the association of the passport puid to the user puid
                if ( _passportPuid != 0 )
                {
                    ws.ClearParameters();
                    ws.StoredProc = "dbo.p_xuacs_add_user_by_passport";
                    ws.SetHashVal(_passportPuid);

                    ws.AddParameter("@bi_user_passport_puid", _passportPuid);
                    ws.AddParameter("@bi_user_puid", _puid);
                    ws.AddParameter("@si_hash_bucket", ws.Partition);

                    ws.ExecuteNonQuery();
                }

                // Add an entry in the family membership table
                AddFamilyMembershipEntry(ws);
            }
            
            // save the user name & key
            HResult hr = NameUtil.ReserveGamertag
                ( _gamerTag
                , _puid
                , _machinePuid
                , KEKCryptoMgr.GetKeyVersion()
                , xenonKey.EncryptedKey
                , xenonKey.IV
                , xenonKey.SPPA
                , xenonKey.PPA
                );

            if (hr.IsFailure()) {
                throw new XRLException(hr, XEvent.Id.XUACS_ACCOUNTS_RESERVE_GAMERTAG_ERROR, "Error reserving gamertag {0} for user {1}", _gamerTag, (Puid) _puid);
            }
            
            // commit the distributed transaction
            txnScope.Complete();
        }

        AccountUtil.RegisterOfflineXuid(_offlineXuid, _puid);

        // whatever passports we are using must not  expire or the account can become orphaned. set NoAgeOut
        SetNoAgeOutUtil.SetNoAgeOut(_puid, _passportPuid);
        if (_passportPuid != _ownerPassportPuid) SetNoAgeOutUtil.SetNoAgeOut(_puid, _ownerPassportPuid);

        // call presence outside of the transaction
        if (_passportPuid != _ownerPassportPuid)
        {
            QueueFamilyAutoFriend();
        }

        _isNew = false;
    }

    public void CreateXboxComAccount()
    {
        Debug.Assert(_isNew == true);       // updating existing users with this not supported
        if ( _isNew == false )
        {
            throw new Exception("User.CreateXboxComAccount: updating existing users not allowed.  gamertag: '" + _gamerTag + "'");
        }

        using (TransactionScope transaction = new TransactionScope())
        {
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.StoredProc = "dbo.p_xuacs_create_xbox_com_account_v3";
                ws.SetHashVal(_puid);

                ws.AddParameter("@bi_user_puid", _puid);
                ws.AddParameter("@bi_owner_puid", _ownerPuid);
                ws.AddParameter("@bi_offline_xuid", _offlineXuid);
                ws.AddParameter("@bi_user_passport_puid", _passportPuid);
                ws.AddParameter("@bi_owner_passport_puid", _ownerPassportPuid);
                ws.AddParameter("@bi_machine_puid", _machinePuid);
                ws.AddParameter("@ti_country_id", _countryId);
                ws.AddParameter("@i_language_id", _languageId);
                ws.AddParameter("@vc_billing_account_id", _accountId);
                ws.AddParameter("@vc_gamertag", _gamerTag);
                ws.AddParameter("@f_allow_xbox1_logon", _allowXbox1Logon);
                ws.AddParameter("@dt_birthdate", _birthdate);
                ws.AddParameter("@si_ticket_flags", _ticketFlags);
                ws.AddParameter("@dt_acct_resume_date", _accountResumeDate);
                ws.AddParameter("@i_suspension_length", _suspensionLength);
                ws.AddParameter("@dt_voice_resume_date", _voiceResumeDate);
                ws.AddParameter("@i_voice_ban_length", _voiceBanLength);
                ws.AddParameter("@ti_name_change_required", _nameChangeRequired);
                ws.AddParameter("@dt_accepted_tos", _acceptedTOSDate);
                ws.AddParameter("@dt_reset_date", _resetDate);
                ws.AddParameter("@i_billing_account_status", _billingAccountStatus);
                ws.AddParameter("@bin_acct_pin", _billingPIN);
                ws.AddParameter("@i_parental_control_group_id", _parentalControlGroupId);
                ws.AddParameter("@f_ms_opt_in", _acceptMsSpam);
                ws.AddParameter("@f_partner_opt_in", _acceptPartnerSpam);
                ws.AddParameter("@ti_service_type", (byte)ServiceTypeEnum.XboxLive);

                ws.AddParameter("@si_hash_bucket", ws.Partition);
                ws.AddParameter(ParamType.OUTPUT, "@i_culture_id", 0);

                ws.ExecuteNonQuery();

                _cultureId = ws.GetIntParameter("@i_culture_id");

                // also add the association of the passport puid to the user puid
                if (_passportPuid != 0)
                {
                    ws.ClearParameters();
                    ws.StoredProc = "dbo.p_xuacs_add_user_by_passport";
                    ws.SetHashVal(_passportPuid);

                    ws.AddParameter("@bi_user_passport_puid", _passportPuid);
                    ws.AddParameter("@bi_user_puid", _puid);
                    ws.AddParameter("@si_hash_bucket", ws.Partition);

                    ws.ExecuteNonQuery();
                }

                // Add an entry in the family membership table
                AddFamilyMembershipEntry(ws);
            }

            transaction.Complete();
        }

        AccountUtil.RegisterOfflineXuid(_offlineXuid, _puid);

        if (_passportPuid != _ownerPassportPuid)
        {
            QueueFamilyAutoFriend();
        }
    }

    public void CreateMobileAccount(ulong offerId, string serviceInstanceId, bool insertSubscriptionOnly, uint uodbPaymentType)
    {
        Guid? catalogOfferId;
        Guid? catalogOfferInstanceId;

        XeSubscriptionUtil.GetCatalogOfferForNewUser(
            offerId, _countryId, uodbPaymentType, out catalogOfferId, out catalogOfferInstanceId
        );

        using (TransactionScope transaction = new TransactionScope())
        {
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                if (!insertSubscriptionOnly)
                {
                    ws.StoredProc = "dbo.p_xuacs_create_mobile_account_v3";
                    ws.SetHashVal(_puid);

                    ws.AddParameter("@bi_user_puid", _puid);
                    ws.AddParameter("@bi_owner_puid", _ownerPuid);
                    ws.AddParameter("@bi_offline_xuid", _offlineXuid);
                    ws.AddParameter("@bi_user_passport_puid", _passportPuid);
                    ws.AddParameter("@bi_owner_passport_puid", _ownerPassportPuid);
                    ws.AddParameter("@bi_machine_puid", _machinePuid);
                    ws.AddParameter("@ti_country_id", _countryId);
                    ws.AddParameter("@i_language_id", _languageId);
                    ws.AddParameter("@vc_billing_account_id", _accountId);
                    ws.AddParameter("@vc_gamertag", _gamerTag);
                    ws.AddParameter("@f_allow_xbox1_logon", _allowXbox1Logon);
                    ws.AddParameter("@dt_birthdate", _birthdate);
                    ws.AddParameter("@si_ticket_flags", _ticketFlags);
                    ws.AddParameter("@dt_acct_resume_date", _accountResumeDate);
                    ws.AddParameter("@i_suspension_length", _suspensionLength);
                    ws.AddParameter("@dt_voice_resume_date", _voiceResumeDate);
                    ws.AddParameter("@i_voice_ban_length", _voiceBanLength);
                    ws.AddParameter("@ti_name_change_required", _nameChangeRequired);
                    ws.AddParameter("@dt_accepted_tos", _acceptedTOSDate);
                    ws.AddParameter("@dt_reset_date", _resetDate);
                    ws.AddParameter("@i_billing_account_status", _billingAccountStatus);
                    ws.AddParameter("@bin_acct_pin", _billingPIN);
                    ws.AddParameter("@i_parental_control_group_id", _parentalControlGroupId);
                    ws.AddParameter("@f_ms_opt_in", _acceptMsSpam);
                    ws.AddParameter("@f_partner_opt_in", _acceptPartnerSpam);
                    ws.AddParameter("@ti_service_type", (byte)ServiceTypeEnum.XboxLive);
                    ws.AddParameter("@f_free_gamertag_eligible", _freeGamertagEligible);
                    ws.AddParameter("@ti_account_type", _accountType);
                    ws.AddParameter("@si_hash_bucket", ws.Partition);

                    ws.AddParameter(ParamType.OUTPUT, "@i_culture_id", 0);

                    ws.ExecuteNonQuery();

                    _cultureId = ws.GetIntParameter("@i_culture_id");

                    // also add the association of the passport puid to the user puid
                    if (_passportPuid != 0)
                    {
                        ws.ClearParameters();
                        ws.StoredProc = "dbo.p_xuacs_add_user_by_passport";
                        ws.SetHashVal(_passportPuid);

                        ws.AddParameter("@bi_user_passport_puid", _passportPuid);
                        ws.AddParameter("@bi_user_puid", _puid);
                        ws.AddParameter("@si_hash_bucket", ws.Partition);

                        ws.ExecuteNonQuery();
                    }
                }

                XeSubscriptionUtil.CreateSubscriptionForNewUser(
                    _puid, offerId, serviceInstanceId, catalogOfferId, catalogOfferInstanceId
                );

                // CreateMobileAccount can be used to either create a new account
                // or add a mobile subscription to an existing account
                if (_isNew)
                {
                    // Add an entry in the family membership table
                    AddFamilyMembershipEntry(ws);

                }
            }

            transaction.Complete();
        }

        AccountUtil.RegisterOfflineXuid(_offlineXuid, _puid);

        // Auto-friending not supported at this time.
        // We need to add it.
    }

    private void ReportFamilyMembershipChange(ulong ownerPassportPuid, ulong userPuid, HistoryReason reason)
    {
        ulong machineId = 0;
        string clientIp = string.Empty;

        XRLUtil.GetClientInfo(out clientIp, out machineId);

        string reasonString = string.Empty;
        switch (reason)
        {
            case HistoryReason.AddMember:
                reasonString = "AddMember";
                break;
            case HistoryReason.RemoveMember:
                reasonString = "RemoveMember";
                break;
            case HistoryReason.Graduate:
                reasonString = "Graduate";
                break;
        }

        string logLine = string.Join("|", new string[]
                {
                    "FamilyMembershipChange",
                    ownerPassportPuid.ToString(),
                    machineId.ToString("X"), // machine puid
                    clientIp, // ip address
                    DateTime.Now.ToString(),
                    "", // hr
                    userPuid.ToString(),
                    "", // familySubscriptionGoldUser
                    reasonString
                });
        Xom.Log(XomAreaName.Reporting, logLine);

        FamilyHistory.Log(ownerPassportPuid, machineId, clientIp, HResult.S_OK, reason, _puid, false);
    }

    public void AddFamilyMembershipEntry(WSClient ws)
    {
        AddFamilyMembershipEntry(ws, _ownerPassportPuid);
    }

    public void AddFamilyMembershipEntry(WSClient ws, ulong newOwnerPassportPuid)
    {
        // Users without valid owner passports aren't represented in family membership.
        // As soon as their owner passport becomes valid, they should be added.
        if (newOwnerPassportPuid == 0 || newOwnerPassportPuid == XOn.XONLINE_PASSPORT_INVALID_ID)
        {
            return;
        }

        ws.ClearParameters();
        ws.StoredProc = "dbo.p_xuacs_add_family_membership";
        ws.SetHashVal(newOwnerPassportPuid);
        ws.AddParameter("@bi_owner_passport_puid", newOwnerPassportPuid);
        ws.AddParameter("@bi_user_puid", _puid);
        ws.AddParameter("@si_hash_bucket", ws.Partition);
        ws.ExecuteNonQuery();

        ReportFamilyMembershipChange(newOwnerPassportPuid, _puid, HistoryReason.AddMember);
    }

    public void RemoveFamilyMembershipEntry(WSClient ws, ulong oldOwnerPassportPuid)
    {
        RemoveFamilyMembershipEntry(ws, oldOwnerPassportPuid, HistoryReason.RemoveMember);
    }

    public void RemoveFamilyMembershipEntry(WSClient ws, ulong oldOwnerPassportPuid, HistoryReason reason)
    {
        // Users without valid owner passports aren't represented in family membership.
        // As soon as their owner passport becomes valid, they should be added.
        if (oldOwnerPassportPuid == 0 || oldOwnerPassportPuid == XOn.XONLINE_PASSPORT_INVALID_ID)
        {
            return;
        }

        ReportFamilyMembershipChange(oldOwnerPassportPuid, _puid, reason);

        ws.ClearParameters();
        ws.StoredProc = "dbo.p_xuacs_remove_family_membership";
        ws.SetHashVal(oldOwnerPassportPuid);
        ws.AddParameter("@bi_owner_passport_puid", oldOwnerPassportPuid);
        ws.AddParameter("@bi_user_puid", _puid);
        ws.ExecuteNonQuery();
    }

    public static bool IsFamilyOwner(ulong ownerPassportPuid)
    {
        using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
        {
            ws.StoredProc = "dbo.p_xuacs_enum_family_members";
            ws.SetHashVal(ownerPassportPuid);
            ws.AddParameter("@bi_owner_passport_puid", ownerPassportPuid);

            using (WstDataReader wsReader = ws.Execute())
            {
                if (wsReader.Read())
                {
                    return true;
                }
            }
        }

        return false;
    }

    public void GetFamilyMembers(out FamilyMember[] familyMembers)
    {
        // Users with invalid owner passports or owner passports of 0
        // aren't represented in family membership.
        // As soon as their owner passport becomes valid, they should be added.
        if (_ownerPassportPuid == 0 || _ownerPassportInvalid != 0)
        {
            familyMembers = new FamilyMember[0];
            return;
        }

        ulong ownerPuid = 0;

        // Enumerate the children
        List<FamilyMember> familyList = new List<FamilyMember>();
        using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
        {
            ws.StoredProc = "dbo.p_xuacs_enum_family_members";
            ws.SetHashVal(_ownerPassportPuid);
            ws.AddParameter("@bi_owner_passport_puid", _ownerPassportPuid);

            using(WstDataReader wsReader = ws.Execute())
            {
                while(wsReader.Read())
                {
                    FamilyMember familyMember = new FamilyMember();

                    familyMember.userPuid = WSClient.GetPuid(wsReader, "bi_user_puid");
                    if ((bool)wsReader["b_family_subscription_gold_user"])
                    {
                        familyMember.userFlags |= FamilyDefs.FAMILY_SUBSCRIPTION_GOLD;
                    }

                    familyList.Add(familyMember);
                }

                if (wsReader.NextResult() && wsReader.Read())
                {
                    ownerPuid = WSClient.GetPuid(wsReader, "bi_user_puid");
                }
            }
        }

        familyMembers = familyList.ToArray();

        // Look up the owner from the family array. We may not have an owner in the array
        // if the owner is WLID-only. In that scenario, the Find() call will simply return null.
        FamilyMember tempFamilyMember = Array.Find(familyMembers, fm => fm.userPuid == ownerPuid);
        if (tempFamilyMember != null)
        {
            tempFamilyMember.userFlags |= FamilyDefs.FAMILY_OWNER;
        }

        // Now retrieve the users from XCache to fill in gamertags.
        XCacheUserResponseData[] users = XCache.LookupUsersByXUID(Array.ConvertAll<FamilyMember, ulong>(familyMembers, fm => fm.userPuid));
        foreach (XCacheUserResponseData user in users)
        {
            FamilyMember familyMember = Array.Find(familyMembers, fm => fm.userPuid == user.qwUserID);
            if (familyMember != null)
            {
                familyMember.gamertag = user.szGamertag;
            }
        }
    }

    public Puid[] MoveFamilyMembershipRecords(Puid oldPassportPuid, Puid newPassportPuid)
    {
        List<Puid> puids = new List<Puid>();

        using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
        {
            ws.ClearParameters();
            ws.StoredProc = "dbo.p_xuacs_extract_family_membership";
            ws.SetHashVal(oldPassportPuid);
            ws.AddParameter("@bi_owner_passport_puid", oldPassportPuid);
            WstDataReader reader = ws.Execute();

            // Generate new rows to insert into the new partition based on the rows we extract from the old partition.
            DataTable dtFamilyMembership = new DataTable();
            dtFamilyMembership.Columns.Add("bi_owner_passport_puid", typeof(long));
            dtFamilyMembership.Columns.Add("bi_user_puid", typeof(long));
            dtFamilyMembership.Columns.Add("b_family_subscription_gold_user", typeof(bool));
            dtFamilyMembership.Columns.Add("si_hash_bucket", typeof(short));

            while (reader.Read())
            {
                // for each row in the original family membership, generate a new row with the owner passport replaced.
                dtFamilyMembership.Rows.Add(
                    (long)(ulong)newPassportPuid,
                    reader["bi_user_puid"],
                    reader["b_family_subscription_gold_user"],
                    ws.CalcPartition(newPassportPuid));
                puids.Add((Puid)(long)reader["bi_user_puid"]);
            }

            if (!reader.NextResult())
            {
                throw new XRLException(HResult.E_FAIL, XEvent.Id.USER_FAMILY_DATA_MISSING, "Only one recordset returned from p_xuacs_extract_family_membership!");
            }

            DataTable dtFamilyMembershipHistory = new DataTable();
            dtFamilyMembershipHistory.Columns.Add("bi_owner_passport_puid", typeof(long));
            dtFamilyMembershipHistory.Columns.Add("bi_machine_puid", typeof(long));
            dtFamilyMembershipHistory.Columns.Add("vc_ip_address", typeof(string));
            dtFamilyMembershipHistory.Columns.Add("dt_timestamp", typeof(DateTime));
            dtFamilyMembershipHistory.Columns.Add("i_hr", typeof(int));
            dtFamilyMembershipHistory.Columns.Add("bi_dependent_puid", typeof(long));
            dtFamilyMembershipHistory.Columns.Add("b_family_subscription_gold_user", typeof(bool));
            dtFamilyMembershipHistory.Columns.Add("ti_reason", typeof(byte));
            dtFamilyMembershipHistory.Columns.Add("si_hash_bucket", typeof(short));

            while (reader.Read())
            {
                // for each row in the original family membership, generate a new row with the owner passport replaced.
                dtFamilyMembershipHistory.Rows.Add(
                    (long)(ulong)newPassportPuid,
                    reader["bi_machine_puid"],
                    reader["vc_ip_address"],
                    reader["dt_timestamp"],
                    reader["i_hr"],
                    reader["bi_dependent_puid"],
                    reader["b_family_subscription_gold_user"],
                    reader["ti_reason"],
                    ws.CalcPartition(newPassportPuid));
            }

            reader.Close();

            ws.ClearParameters();
            ws.StoredProc = "dbo.p_xuacs_import_family_membership";
            ws.SetHashVal(newPassportPuid);
            ws.Parameters.AddWithValue("@family_membership", dtFamilyMembership);
            ws.Parameters.AddWithValue("@family_membership_history", dtFamilyMembershipHistory);
            ws.ExecuteNonQuery();
        }

        return puids.ToArray();
    }
    internal void UpdateFamilyMemberGoldSeat(bool bNewValue, HistoryReason reason)
    {
        User.UpdateFamilyMemberGoldSeat(_ownerPassportPuid, _puid, bNewValue, reason);
    }
    public static void UpdateFamilyMemberGoldSeat(Puid ownerPassportPuid,Puid puid,bool bNewValue, HistoryReason reason)
    {
        using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
        {
            ws.ClearParameters();
            ws.SetHashVal((long)ownerPassportPuid);
            ws.StoredProc = "dbo.p_xuacs_update_family_gold_assignment";
            ws.AddParameter("@bi_owner_passport_puid", (long)ownerPassportPuid);
            ws.AddParameter("@bi_user_puid", (long)puid);
            ws.AddParameter("@b_family_subscription_gold_user", bNewValue ? 1 : 0);

            ws.ExecuteNonQuery();
        }

        // Update history. This is best case.
        ulong machineId = 0;
        string clientIp = string.Empty;

        XRLUtil.GetClientInfo(out clientIp, out machineId);

        FamilyHistory.Log(ownerPassportPuid, machineId, clientIp, HResult.S_OK, reason, puid, bNewValue);
    }

    public void AssignToFamilyGoldSeat(Puid ownerPuid)
    {
        XeSubscriptionUtil.AddDependentToSubscription(ownerPuid, this);
    }

    public void RemoveFromFamilyGoldSeat(Puid ownerPuid, HistoryReason reason)
    {
       //sets the downgrade bit and saves the user. 
       XeSubscriptionUtil.RemoveDependentFromSubscription(ownerPuid, this, reason);
    }

    // Wrapper that will check if the user is assigned to a gold seat in a family subscription
    // and remove them if necessary. If the caller already knows that the user occupies a gold seat,
    // call RemoveFromFamilyGoldSeat. It's more efficient.
    public void RemoveFromFamilyGoldSeatIfAssigned(HistoryReason reason)
    {
        FamilyMember[] familyMembers;
        GetFamilyMembers(out familyMembers);
        int indexUser = Array.FindIndex(familyMembers, fm => fm.userPuid == _puid);
        if (indexUser != -1 && ((familyMembers[indexUser].userFlags & FamilyDefs.FAMILY_SUBSCRIPTION_GOLD) == FamilyDefs.FAMILY_SUBSCRIPTION_GOLD))
        {
            // Find the owner
            FamilyMember owner = Array.Find(familyMembers, fm => (fm.userFlags & FamilyDefs.FAMILY_OWNER) == FamilyDefs.FAMILY_OWNER);

            RemoveFromFamilyGoldSeat(owner.userPuid, reason);
        }

    }

    #region AutoFriendingWork

    private class FamilyAutoFriendTPState
    {
        public WaitCallback work;
        public DateTime timeStamp;
        public string authData;
        public Puid userPuid;
    }

    private static Queue<FamilyAutoFriendTPState> _autoFriendQueue;
    private static Timer _autoFriendTimer;
    private static object _lockobject = new object();

    // This overload called by FDs that don't need the 
    // autofriending queued.
    private void QueueFamilyAutoFriend()
    {
        QueueFamilyAutoFriend(string.Empty);
    }

    private void QueueFamilyAutoFriend(string authdataString)
    {

        if (_autoFriendQueue == null)
        {
            lock (_lockobject)
            {
                if (_autoFriendQueue == null)
                {
                    _autoFriendQueue = new Queue<FamilyAutoFriendTPState>();
                }
            }
        }

        // This is a first queuing of this user's request.
        if (string.IsNullOrEmpty(authdataString))
        {
            // Ensure SGInfo is properly set up for call to XPNFD
            HTTPAuthData authData = new HTTPAuthData(Floken.NewFloken(),
                SGInfo.Current.ClientPort,
                0,
                0,
                Puid,
                XOn.DASH_TITLE_ID,
                (uint)XOService.User_Account,
                0);

                authdataString = authData.ConstructBase64String();
        }

        int xcachePollingInterval = Config.GetIntSetting(Setting.xcache_db_pollingInterval);

        FamilyAutoFriendTPState state = new FamilyAutoFriendTPState();
        state.timeStamp = DateTime.UtcNow.AddSeconds(xcachePollingInterval * 1.5);
        state.authData = authdataString;
        state.work = new WaitCallback(this.MakeFriendsWithFamily);
        state.userPuid = Puid;

        lock (_autoFriendQueue)
        {
            _autoFriendQueue.Enqueue(state);
        }

        if (_autoFriendTimer == null)
        {
            lock (_lockobject)
            {
                if (_autoFriendTimer == null)
                {
                    TimerCallback tcb = new TimerCallback(ProcessQueue);

                    _autoFriendTimer = new Timer(tcb, 
                        null,
                        TimeSpan.FromSeconds(xcachePollingInterval), // wait for a litle longer than  polling interval
                        TimeSpan.FromSeconds(xcachePollingInterval));
                }
            }
        }
    }

    private static bool AutoFriendingQueueHasWork()
    {
        lock (_autoFriendQueue)
        {
            return (_autoFriendQueue.Count > 0 &&
                (_autoFriendQueue.Peek().timeStamp < DateTime.UtcNow));
        }
    }

    private static void ProcessQueue(object o)
    {
        if (_autoFriendQueue == null) 
        {
            _autoFriendTimer = null;
            return;
        }

        FamilyAutoFriendTPState state;

        while (AutoFriendingQueueHasWork())
        {
           
            lock (_autoFriendQueue)
            {
                 try
                {
                state = _autoFriendQueue.Dequeue();
                }
                catch (InvalidOperationException)
                {
                   // swallow it. Some other thread got there first.
                   return;
                }
             }

            try
            {
                state.work.Invoke(state.authData);
            }
            catch (Exception e)
            {
                // this is best effort only. 
                // if it fails, it fails.
                Xom.Log("xuacs", e, "Error executing auto friend queue", "");
            }
        }
     }

    //------------------------------------------------------
    // MakeFriendsWithFamily()
    //
    //      Make friends between all family members.
    //      Best effort only. Ignore the results.
    public void MakeFriendsWithFamily()
    {
        MakeFriendsWithFamily(string.Empty);
    }

    public void MakeFriendsWithFamily(object stateData)
    {
        string authData = (string)stateData;

        if (string.IsNullOrEmpty(authData))
        {
            if (AAInfo.IsActiveAuthAvailable)
            {
                // The mobile scenario is not supported currently.
                return;
            }
            else
            {
                authData = SGInfo.Current.ConstructBase64String();
            }
        }

        try
        {
            HResult hr;
            FamilyMember[] familyMembers;
            GetFamilyMembers(out familyMembers);

            foreach (FamilyMember member in familyMembers)
            {
                //
                //      Make friends with family
                //      Best effort only. 
                //
                if (member.userPuid != Puid)
                {
                    PresenceAddBuddy2Msg msg = new PresenceAddBuddy2Msg();
                    msg.qwSenderID = member.userPuid;
                    msg.qwBuddyID = Puid;

                    XRLObject2 throwAwayObject = new XRLObject2();
                    hr = XRLUtil.PostXrlRequest(VirtualInterface.xpnfd_presence_int,
                        "/xpnfront/xpresence.srf",
                        authData,
                        msg,
                        ref throwAwayObject);

                    if (HResult.Succeeded(hr))
                    {
                        PresenceAcceptBuddyMsg acceptMsg = new PresenceAcceptBuddyMsg();
                        acceptMsg.qwUserID = Puid;
                        acceptMsg.qwBuddyID = member.userPuid;

                        XRLUtil.PostXrlRequest(VirtualInterface.xpnfd_presence_int,
                             "/xpnfront/xpresence.srf",
                             authData,
                             acceptMsg,
                             ref throwAwayObject);
                    }
                }
            }
        }
        catch
        {
            throw new XRLExceptionWithoutEvent(HResult.E_FAIL, "Error autofriending family members for user {0}", Puid);
        }

    }

    #endregion

    public void ResetPassword()
    {
        if (_isNew == true)
        {
            throw new Exception("NYI");
        }

        byte[] rawKey;
        byte[] encKey;
        byte[] iv;
        byte[] SPPA;
        byte[] PPA;

        // generate a new key.
        KEKCryptoMgr.GenerateNewKey( out iv, out encKey, out rawKey );

        // generate new PPA data
        KEKCryptoMgr.GenPPAforDBWrp( _gamerTag, (byte[])rawKey.Clone(), out SPPA, out PPA );

        ResetPassword(encKey, iv, SPPA, PPA);
    }

    public void ResetPassword(byte[] key, byte[] iv, byte[] SPPA, byte[] PPA)
    {
        if (_isNew == true)
        {
            throw new Exception("NYI");
        }

        HResult hr;
        using (WSClient wsReset = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
        {
            //
            //  Use the gamertag to hash for the key entry, and set the key
            //
            wsReset.ClearParameters();
            wsReset.SetHashVal(_gamerTag);
            wsReset.StoredProc = "dbo.p_xuacs_set_user_key";

            // intput and output params
            wsReset.AddParameter(ParamType.RETVAL, "@RETVAL", 0);
            wsReset.AddParameter("@vc_gamertag", _gamerTag );
            wsReset.AddParameter("@key", key );
            wsReset.AddParameter("@iv", iv );
            wsReset.AddParameter("@i_kek_version", KEKCryptoMgr.GetKeyVersion() );
            wsReset.AddParameter("@bin_SPPA", SPPA );
            wsReset.AddParameter("@bin_PPA", PPA );

            // call the procedure
            wsReset.ExecuteNonQuery();

            // the SP should return zero on OK, nonzero on failure
            hr = (uint)wsReset.GetIntParameter("@RETVAL");
        }

        if (hr != HResult.S_OK)
        {
            throw new XRLException( hr, XEvent.Id.COMMON_CODE_217, "Error setting key for user " + _puid + "." );
        }

        //
        // Having updated the key, now update the user table with the key reset time.
        //

        _resetDate = DateTime.UtcNow;
    }

    public void XeResetPassword(byte[] key, byte[] iv, byte[] SPPA, byte[] PPA)
    {
        if (_isNew == true)
        {
            throw new Exception("NYI");
        }

        HResult hr;
        using (WSClient wsReset = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
        {
            //
            //  Use the gamertag to hash for the key entry, and set the key
            //
            wsReset.ClearParameters();
            wsReset.SetHashVal(_gamerTag);
            wsReset.StoredProc = "dbo.p_xuacs_set_xenon_user_key";

            // intput and output params
            wsReset.AddParameter(ParamType.RETVAL, "@RETVAL", 0);
            wsReset.AddParameter("@vc_gamertag", _gamerTag );
            wsReset.AddParameter("@key", key );
            wsReset.AddParameter("@iv", iv );
            wsReset.AddParameter("@i_kek_version", KEKCryptoMgr.GetKeyVersion() );
            wsReset.AddParameter("@bin_SPPA", SPPA );
            wsReset.AddParameter("@bin_PPA", PPA );
            wsReset.AddParameter("@si_hash_bucket", wsReset.Partition );

            // call the procedure
            wsReset.ExecuteNonQuery();

            // the SP should return zero on OK, nonzero on failure
            hr = (uint)wsReset.GetIntParameter("@RETVAL");
        }

        if (hr != HResult.S_OK)
        {
            throw new XRLException( hr, XEvent.Id.COMMON_CODE_218, "Error setting key for user " + _puid + "." );
        }

        //
        // Having updated the key, now update the user table with the key reset time.
        //

        _resetDate = DateTime.UtcNow;
    }

    public void ResetUserFreeGamertagEligibleFlag()
    {
        if (FreeGamertagEligible == 1)
        {
            FreeGamertagEligible = 0;
            Save();
        }
    }

    public void XeGetBaseSubscription(out string instanceId, out int subscriptionStatusId, out Guid catalogOfferId, out Guid catalogOfferInstanceId)
    {
        instanceId = string.Empty;

        subscriptionStatusId = 0;

        catalogOfferId = Guid.Empty;

        catalogOfferInstanceId = Guid.Empty;

        int tier = 0;

        Puid subscriptionOwner = 0;

        ulong legayOfferId = 0;

        User.XeGetBaseSubscription(_puid, out instanceId, out subscriptionStatusId, out  catalogOfferId, out catalogOfferInstanceId, out tier, out subscriptionOwner, out legayOfferId);

    }
    public static void XeGetBaseSubscription(ulong userPuid, out string instanceId, out int subscriptionStatusId, out Guid catalogOfferId, out Guid catalogOfferInstanceId, out int tierProvided, out Puid subscriptionOwnerPuid, out ulong legacyOfferId)
    {
        instanceId = string.Empty;

        subscriptionStatusId = 0;

        catalogOfferId = Guid.Empty;

        catalogOfferInstanceId = Guid.Empty;

        tierProvided = 0;

        subscriptionOwnerPuid = 0;

        legacyOfferId = 0;

        int instances = 0;

        int transactionFlags = 0;

        XeGetBaseSubscription
            (
                  userPuid
                , out instanceId
                , out subscriptionStatusId
                , out catalogOfferId
                , out catalogOfferInstanceId
                , out tierProvided
                , out subscriptionOwnerPuid
                , out legacyOfferId
                , out transactionFlags
                , out instances
            );


    }
    /// <summary>
    /// Queries UODB and further queries catalog to identify the base subscriptions
    /// This uses the new logic to determine the base subscriptions
    /// </summary>
    public static void XeGetBaseSubscription(ulong userPuid, out string instanceId, out int subscriptionStatusId, out Guid catalogOfferId, out Guid catalogOfferInstanceId, out int tierProvided, out Puid subscriptionOwnerPuid, out ulong legacyOfferId,out int transactionFlags,out int instances)
    {
        instanceId = string.Empty;

        subscriptionStatusId = 0;

        catalogOfferId = Guid.Empty;

        catalogOfferInstanceId = Guid.Empty;

        tierProvided = 0;

        subscriptionOwnerPuid = 0;

        legacyOfferId = 0;

        instances = 0;

        transactionFlags = 0;

        using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
        {
            // Data is partitioned by user puid
            ws.PartitionType = WstPartitionType.Logical;
            ws.SetHashVal(userPuid);

            ws.StoredProc = "dbo.p_xuacs_get_base_subscription_v2";

            ws.AddParameter(ParamType.RETVAL, "@RETVAL", 0);
            ws.AddParameter("@bi_user_puid", userPuid);

            ws.ExecuteNonQuery();

            using (WstDataReader r = ws.Execute())
            {
                if (r.Read())
                {

                    catalogOfferId = r.GetGuid(r.GetOrdinal("uid_catalog_offerid"));

                    catalogOfferInstanceId = r.GetGuid(r.GetOrdinal("uid_catalog_offerinstance_id"));

                    instanceId = r.GetString(r.GetOrdinal("vc_svc_instance_id"));

                    subscriptionStatusId = r.GetInt32(r.GetOrdinal("i_subscription_status_id"));

                    if (!r.IsDBNull(r.GetOrdinal("bi_subscription_owner_puid")))
                    {
                        subscriptionOwnerPuid = (Puid)r.GetInt64(r.GetOrdinal("bi_subscription_owner_puid"));
                    }

                    tierProvided = r.GetInt32(r.GetOrdinal("i_tier_id"));

                    legacyOfferId = (ulong)r.GetInt64(r.GetOrdinal("bi_offer_id"));

                    instances = r.GetInt32(r.GetOrdinal("i_instances"));

                    transactionFlags = r.GetInt32(r.GetOrdinal("i_transaction_flags"));

                }

                r.Close();

                HResult hr = (uint)ws.GetIntParameter("@RETVAL");
                if (HResult.Failed(hr))
                {
                    string msg = ws.GetCallSignature() + " failed with hr = " + hr;
                    throw new XRLException(hr, XEvent.Id.COMMON_USER_2, msg);
                }
            }
        }
    }

    /// <summary>
    /// Overloaded method does not return subscriptionownerPuid as an out parameter
    /// </summary>
    public static void XeGetBaseSubscription(ulong userPuid, out string instanceId, out int subscriptionStatusId, out Guid catalogOfferId, out Guid catalogOfferInstanceId, out int tierProvided)
    {
        instanceId = string.Empty;

        subscriptionStatusId = 0;

        catalogOfferId = Guid.Empty;

        catalogOfferInstanceId = Guid.Empty;

        tierProvided = 0;

        Puid subscriptionOwner = 0;

        ulong legayOfferId = 0;

        User.XeGetBaseSubscription(userPuid, out instanceId, out subscriptionStatusId, out  catalogOfferId, out catalogOfferInstanceId, out tierProvided, out subscriptionOwner, out legayOfferId);
    }

    /// <summary>
    /// Gets XML representation for subscriptions
    /// </summary>
    /// <returns></returns>
    private static string GetAllSubscriptionInfoXML(ulong userPuid)
    {
        StringBuilder offerInstanceList = new StringBuilder();

        using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
        {
            // Data is partitioned by user puid
            ws.PartitionType = WstPartitionType.Logical;
            ws.SetHashVal(userPuid);

            ws.StoredProc = "dbo.p_xuacs_get_all_subscriptions";

            ws.AddParameter(ParamType.RETVAL, "@RETVAL", 0);
            ws.AddParameter("@bi_user_puid", userPuid);

            ws.ExecuteNonQuery();

            using (WstDataReader r = ws.Execute())
            {
               while (r.Read())
                {
                   offerInstanceList.Append("<item ");
                   
                   offerInstanceList.Append(" oid='" + r.GetGuid(r.GetOrdinal("uid_catalog_offerid")) + "'");
                   
                   offerInstanceList.Append(" oiid='" + r.GetGuid(r.GetOrdinal("uid_catalog_offerinstance_id")) + "'");
                   
                   offerInstanceList.Append(" instanceId='" + r.GetString(r.GetOrdinal("vc_svc_instance_id")) + "'");
                   
                   offerInstanceList.Append(" statusid='" + r.GetInt32(r.GetOrdinal("i_subscription_status_id")) + "'");

                   offerInstanceList.Append(" transactionFlags='" + r.GetInt32(r.GetOrdinal("i_transaction_flags")) + "'");

                   offerInstanceList.Append(" isPuidMachine='" + r.GetInt32(r.GetOrdinal("i_puid_is_machine")) + "'");

                   offerInstanceList.Append(" instances='" + r.GetInt32(r.GetOrdinal("i_instances")) + "'");

                   offerInstanceList.Append(" uodbofferId='" + r.GetInt64(r.GetOrdinal("bi_offer_id")) + "'");
                   
                   offerInstanceList.Append(" />");
                }

                r.Close();

                HResult hr = (uint)ws.GetIntParameter("@RETVAL");
                if (HResult.Failed(hr))
                {
                    string msg = ws.GetCallSignature() + " failed with hr = " + hr;
                    throw new XRLException(hr, XEvent.Id.COMMON_USER_2, msg);
                }
            }
        }

        return offerInstanceList.ToString();
    }

    public void XeGetBaseSubscription(out string instanceId, out ulong offerId)
    {
        int subscriptionStatusId = 0;

        XeGetBaseSubscription(out instanceId, out offerId, out subscriptionStatusId);
    }

    public void XeGetBaseSubscription(out string instanceId, out ulong offerId, out int subscriptionStatusId)
    {
        instanceId = null;

        offerId = 0;
        
        subscriptionStatusId = 0;

        using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
        {
            // Data is partitioned by user puid
            ws.PartitionType = WstPartitionType.Logical;
            ws.SetHashVal(_puid);

            ws.StoredProc = "dbo.p_xuacs_get_base_subscription";

            ws.AddParameter(ParamType.RETVAL, "@RETVAL", 0);
            ws.AddParameter("@bi_user_puid", _puid);

            ws.ExecuteNonQuery();

            using (WstDataReader r = ws.Execute())
            {
                if (r.Read())
                {
                    instanceId = r.GetString(0);
                    offerId = (ulong)r.GetInt64(1);
                    subscriptionStatusId = r.GetInt32(2);
                }

                r.Close();

                HResult hr = (uint)ws.GetIntParameter("@RETVAL");
                if (HResult.Failed(hr))
                {
                    string msg = ws.GetCallSignature() + " failed with hr = " + hr;

                    throw new XRLException(hr, XEvent.Id.COMMON_CODE_219, msg);
                }
            }
        }
    }

    public void GetBaseSubscription(out string baseInstanceId, out ulong baseOfferId)
    {
        HResult hr = 0;
        uint serviceId = (uint) XOService.PresNotification;

        using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
        {
            ws.ClearParameters();
            ws.SetHashVal((long)_puid);
            ws.StoredProc = "dbo.p_xbos_get_instance_from_service";

            // intput and output params
            ws.AddParameter(ParamType.RETVAL, "@RETVAL", 0);
            ws.AddParameter(ParamType.INPUT, "@userpuid", _puid);
            ws.AddParameter(ParamType.INPUT, "@serviceid", serviceId);
            ws.AddParameter(ParamType.OUTPUT, "@instanceid", String.Empty, 16);
            ws.AddParameter(ParamType.OUTPUT, "@offerid", (long)0);

            // call the procedure
            ws.ExecuteNonQuery();

            hr = (uint)ws.GetIntParameter("@RETVAL");

            if (HResult.Failed(hr))
            {
                throw new XRLException(hr, XEvent.Id.COMMON_CODE_220, "User.GetBaseSubscription: cannot find a good service instance for user " + _puid + ", service " + serviceId);
            }

            baseInstanceId = ws.GetStringParameter("@instanceid");
            baseOfferId    = (ulong)ws.GetLongParameter("@offerid");
        }
    }

    public void GetSubscriptionFromServiceId(uint serviceId, out string instanceId, out ulong offerId)
    {
        GetSubscriptionFromServiceId(_puid, serviceId, out instanceId, out offerId);
    }

    public static void GetSubscriptionFromServiceId(ulong userPuid, uint serviceId, out string instanceId, out ulong offerId)
    {
        HResult hr = 0;

        using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
        {
            ws.ClearParameters();
            ws.SetHashVal(userPuid);
            ws.StoredProc = "dbo.p_xbos_get_instance_from_service";

            // intput and output params
            ws.AddParameter(ParamType.RETVAL, "@RETVAL", 0);
            ws.AddParameter(ParamType.INPUT, "@userpuid", userPuid);
            ws.AddParameter(ParamType.INPUT, "@serviceid", serviceId);
            ws.AddParameter(ParamType.OUTPUT, "@instanceid", String.Empty, 16);
            ws.AddParameter(ParamType.OUTPUT, "@offerid", (long)0);

            // call the procedure
            ws.ExecuteNonQuery();

            hr = (uint)ws.GetIntParameter("@RETVAL");

            if (HResult.Failed(hr) && hr != HResult.XONLINE_E_INVALID_SERVICE_ID )
            {
                throw new XRLException(hr, XEvent.Id.COMMON_CODE_221, "User.GetSubscriptionFromServiceId: cannot find a good service instance for user: 0x" + userPuid.ToString("X") + ", service: " + ( serviceId > 255 ? serviceId.ToString("X") : serviceId.ToString("d") ) );
            }

            if ( hr == HResult.XONLINE_E_INVALID_SERVICE_ID )
            {
                instanceId = string.Empty;
                offerId = 0;
            }
            else
            {
                instanceId = ws.GetStringParameter("@instanceid");
                offerId    = (ulong)ws.GetLongParameter("@offerid");
            }
        }
    }

    public static HResult GetSubscriptionFromServiceComponentId(ulong userPuid,string serviceComponentId, out string instanceId, out Guid catalogOfferInstanceId,out Guid catalogOfferId, out int subscriptionStatusId)
    {
        string userSubscriptionXML = GetAllSubscriptionInfoXML(userPuid);

        instanceId = string.Empty;

        catalogOfferId = Guid.Empty;

        catalogOfferInstanceId = Guid.Empty;

        subscriptionStatusId = 0;


        HResult hr;

        using (SqlClient c = new SqlClient(Interface.fecatalogdbxbox, true))
        {
            hr = HResult.S_OK;

            c.StoredProc = "dbo.GetSubscriptionOfferInfoByServiceComponentId";

            // Params always added
            c.AddParameter(System.Data.ParameterDirection.ReturnValue, "@hr", hr);

            c.AddParameter("@offerInstanceXml", userSubscriptionXML);

            c.AddParameter("@billingSvcComponentId", serviceComponentId);

            using (SqlDataReader r = c.Execute())
            {

                hr = (uint)c.GetIntParameter("@hr");

                if (HResult.Failed(hr))
                {
                    throw new XRLException(hr,
                                            XEvent.Id.COMMON_CODE_219,
                                            String.Format("Error occured retrieving base subscriptions for the offer Instances {0} and billingSvcComponentId {1}", userSubscriptionXML, serviceComponentId.ToString()));
                }
                if (r.Read())
                {
                    instanceId = r.GetString(r.GetOrdinal("svcInstanceId"));

                    subscriptionStatusId = r.GetInt32(r.GetOrdinal("statusId"));

                    catalogOfferId = r.GetGuid(r.GetOrdinal("offerId"));

                    catalogOfferInstanceId = r.GetGuid(r.GetOrdinal("offerInstanceId"));

                }
            }
        }

        return hr;

    }

    public HResult GetSubscriptionFromServiceComponentId(string serviceComponentId, out string instanceId,out Guid catalogOfferInstanceId, out Guid catalogOfferId,out int subscriptionStatusId)
    {
        instanceId=string.Empty;

        catalogOfferId = Guid.Empty;

        subscriptionStatusId = 0;

        return GetSubscriptionFromServiceComponentId(_puid, serviceComponentId, out instanceId, out catalogOfferInstanceId, out catalogOfferId, out subscriptionStatusId);
    }

    public HResult GetSubscriptionFromServiceComponentId(string serviceComponentId, out string instanceId, out ulong offerId, out int subscriptionStatusId)
    {
        return GetSubscriptionFromServiceComponentId(_puid, serviceComponentId, out instanceId, out offerId, out subscriptionStatusId);
    }

    public static uint GetSubscriptionFromServiceComponentId(ulong userPuid, string serviceComponentId, out string instanceId, out ulong offerId, out int subscriptionStatusId)
    {
         HResult hr = 0;

        instanceId = string.Empty;
        offerId = 0;
        subscriptionStatusId = -1;


        using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
        {
            ws.SetHashVal(userPuid);
            ws.StoredProc = "dbo.p_xbos_get_instance_from_service_component_id";

            // intput and output params
            ws.AddParameter(ParamType.RETVAL, "@hr", 0);
            ws.AddParameter(ParamType.INPUT,  "@bi_user_puid", userPuid);
            ws.AddParameter(ParamType.INPUT,  "@vc_billing_svc_component_id", serviceComponentId, serviceComponentId.Length);
            ws.AddParameter(ParamType.OUTPUT, "@vc_instance_id", String.Empty, 16);
            ws.AddParameter(ParamType.OUTPUT, "@bi_offer_id", (long)0);
            ws.AddParameter(ParamType.OUTPUT, "@i_subscription_status_id", (int)0);


            // call the procedure
            ws.ExecuteNonQuery();

            hr = (uint)ws.GetIntParameter("@hr");

            if (HResult.Failed(hr) && hr != HResult.XONLINE_E_OFFERING_SUBSCRIPTION_NOT_FOUND)
            {
                throw new XRLException(hr, XEvent.Id.COMMON_USER_1, "User.GetSubscriptionFromServiceComponentId: unexpected failure: hr = " + hr);
            }

            if (HResult.Succeeded(hr))
            {
                instanceId = ws.GetStringParameter("@vc_instance_id");

                offerId = (ulong)ws.GetLongParameter("@bi_offer_id");
                
                subscriptionStatusId = ws.GetIntParameter("@i_subscription_status_id");
            }
        }

        return hr;
    }

    /// <summary>
    /// Returns user subscription info
    /// </summary>
    public static UserSubscriptionInfo GetBaseSubscriptionInfo(ulong userPuid)
    {

        string instanceId = string.Empty;

        int subscriptionStatusId = 0;

        Guid catalogOfferId = Guid.Empty;

        Guid catalogOfferInstanceId = Guid.Empty;

        int tierProvided = 0;

        Puid subscriptionOwnerPuid = 0;

        ulong legacyOfferId = 0;

        int instances = 0;

        int transactionFlags = 0;

        XeGetBaseSubscription
            (
                  userPuid
                , out instanceId
                , out subscriptionStatusId
                , out catalogOfferId
                , out catalogOfferInstanceId
                , out tierProvided
                , out subscriptionOwnerPuid
                , out legacyOfferId
                , out transactionFlags
                , out instances
            );

        UserSubscriptionInfo subscriptionInfo = new UserSubscriptionInfo();

        subscriptionInfo.SvcInstanceId = instanceId;

        subscriptionInfo.SubscriptionStatusId = subscriptionStatusId;

        subscriptionInfo.CatalogOfferId = catalogOfferId;

        subscriptionInfo.CatalogOfferInstanceId = catalogOfferInstanceId;

        subscriptionInfo.Instances = instances;

        subscriptionInfo.LegacyOfferId = legacyOfferId;

        subscriptionInfo.TransactionFlags = transactionFlags;

        subscriptionInfo.TierId = tierProvided;

        return subscriptionInfo;

    }

    public HResult GetSubscriptionFromOffer(ulong offerId, out string instanceId)
    {
        return GetSubscriptionFromOffer(_puid, offerId, out instanceId);
    }

    public static uint GetSubscriptionFromOffer(ulong userPuid, ulong offerId, out string instanceId)
    {
        HResult hr = HResult.E_FAIL;

        instanceId = string.Empty;

        using(WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
        {
            // Data is partitioned by user puid
            ws.PartitionType = WstPartitionType.Logical;
            ws.SetHashVal(userPuid);

            ws.StoredProc = "dbo.p_xuacs_get_subscription_instance";

            ws.AddParameter(ParamType.RETVAL, "@hr", 0);
            ws.AddParameter("@bi_user_puid", userPuid);
            ws.AddParameter("@bi_offer_id", offerId);

            using (WstDataReader r = ws.Execute())
            {
                if (r.Read())
                {
                    instanceId = r.GetString(0);
                }
            }

            hr = (uint) ws.GetIntParameter("@hr");
            if (HResult.Failed(hr))
            {
                instanceId = string.Empty;
            }
        }

        return hr;
    }

    public void GetOfferIdFromInstance(string instanceId, out ulong offerId)
    {
        HResult hr = 0;

        using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
        {
            ws.ClearParameters();
            ws.SetHashVal((long)_puid);
            ws.StoredProc = "dbo.p_xbos_get_offer_from_instance";

            // intput and output params
            ws.AddParameter(ParamType.RETVAL, "@RETVAL", 0);
            ws.AddParameter("@bi_user_puid", _puid);
            ws.AddParameter("@vc_instance_id", instanceId);
            ws.AddParameter(ParamType.OUTPUT, "@bi_offer_id", (long)0);

            // call the procedure
            ws.ExecuteNonQuery();

            hr = (uint)ws.GetIntParameter("@RETVAL");

            if (HResult.Failed(hr))
            {
                throw new XRLException(hr, XEvent.Id.COMMON_CODE_223, "User.GetOfferIdFromInstance: cannot find a good offer for user 0x" + _puid.ToString("X") + ", instanceId " + instanceId);
            }

            offerId = (ulong)ws.GetLongParameter("@bi_offer_id");
        }
    }

    public Puid GetOwnerPuid()
    {

        Puid ownerPuid = 0;
        if (HttpContext.Current != null)
        {
            try
            {
                ownerPuid = XCache.LookupPUID(OwnerPassportPuid);
            }
            catch (Exception)
            {
                ownerPuid = 0;
            }
        }

        if (ownerPuid == 0)
        {
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {


                ws.StoredProc = "dbo.p_xuacs_get_user_by_passport";
                ws.SetHashVal(OwnerPassportPuid);

                ws.AddParameter(ParamType.RETVAL, "@RETVAL", 0);
                ws.AddParameter(ParamType.INPUT, "@bi_user_passport_puid", _ownerPassportPuid);
                ws.AddParameter(ParamType.OUTPUT, "@bi_user_puid", ownerPuid);

                ws.ExecuteNonQuery();

                HResult hr = (uint)ws.GetIntParameter("@RETVAL");
                if (HResult.Failed(hr))
                {
                    ownerPuid = 0;
                    return ownerPuid;
                }

                ownerPuid = (ulong)ws.GetLongParameter("@bi_user_puid");
            }

        }
        return ownerPuid;
    }


    public void GetSubscription(string instanceId, out ulong offerId, out int subscriptionStatusId)
    {
        Guid catalogOfferId = Guid.Empty;
        Guid catalogOfferInstanceId = Guid.Empty;
        GetSubscription(this._puid, instanceId, out offerId, out subscriptionStatusId, out catalogOfferId, out catalogOfferInstanceId);
    }
    public static void GetSubscription(ulong userPuid, string instanceId, out ulong offerId, out int subscriptionStatusId)
    {
        Guid catalogOfferId = Guid.Empty;
        Guid catalogOfferInstanceId = Guid.Empty;
        GetSubscription(userPuid, instanceId, out offerId, out subscriptionStatusId, out catalogOfferId, out catalogOfferInstanceId);
    }
    public static void GetSubscription(ulong userPuid,string instanceId, out Guid catalogOfferId, out Guid catalogOfferInstanceId,out int subscriptionStatusId)
    {
        ulong offerId = 0;
        GetSubscription(userPuid, instanceId, out offerId, out subscriptionStatusId, out catalogOfferId, out catalogOfferInstanceId);
    }
    public static void GetSubscription(ulong userPuid, string instanceId, out ulong offerId, out int subscriptionStatusId,out Guid catalogOfferId,out Guid catalogOfferInstanceId)
    {
        catalogOfferId = Guid.Empty;
        catalogOfferInstanceId = Guid.Empty;
        offerId = 0;
        subscriptionStatusId = Subscription.PENDING;

        using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
        {
            // Data is partitioned by user puid
            ws.PartitionType = WstPartitionType.Logical;
            ws.SetHashVal(userPuid);

            ws.StoredProc = "dbo.p_xuacs_get_subscription";

            ws.AddParameter(ParamType.RETVAL, "@hr", 0);
            ws.AddParameter("@bi_user_puid", userPuid);
            ws.AddParameter("@vc_svc_instance_id", instanceId);

            ws.ExecuteNonQuery();

            using (WstDataReader r = ws.Execute())
            {
                if (r.Read())
                {
                    offerId = (ulong) r.GetInt64(0);
                    subscriptionStatusId = r.GetInt32(1);
                    if (!r.IsDBNull(2))
                    {
                        catalogOfferId = r.GetGuid(2);
                    }
                    if (!r.IsDBNull(3))
                    {
                        catalogOfferInstanceId = r.GetGuid(3);
                    }
                }

                r.Close();

                HResult hr = (uint) ws.GetIntParameter("@hr");
                if (HResult.Failed(hr))
                {
                    string msg = ws.GetCallSignature() + " failed with hr = " + hr;

                    throw new XRLException(hr, XEvent.Id.COMMON_CODE_224, msg);
                }
            }
        }
    }

    public HResult LinkWebAccount()
    {
        return LinkWebAccount(this._puid, this._passportPuid);
    }

    public static uint LinkWebAccount(ulong xboxPuid, ulong passportPuid)
    {
        HResult hr = HResult.E_FAIL;

        using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
        {
            ws.ClearParameters();
            ws.StoredProc = "dbo.p_xuacs_add_user_by_passport";
            ws.SetHashVal(passportPuid);

            ws.AddParameter(ParamType.RETVAL, "@hr", 0);
            ws.AddParameter("@bi_user_passport_puid", passportPuid);
            ws.AddParameter("@bi_user_puid", xboxPuid);
            ws.AddParameter("@si_hash_bucket", ws.Partition);

            ws.ExecuteNonQuery();

            hr = (uint) ws.GetIntParameter("@hr");
        }

        return hr;
    }

    public HResult SetSubscriptionStatusId(string instanceId, int subscriptionStatusId)
    {
        return SetSubscriptionStatusId(this._puid, instanceId, subscriptionStatusId);
    }

    public static uint SetSubscriptionStatusId(ulong xboxPuid, string instanceId, int subscriptionStatusId)
    {
        HResult hr = HResult.E_FAIL;

        using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
        {
            ws.ClearParameters();
            ws.StoredProc = "dbo.p_xcbk_change_state";
            ws.SetHashVal(xboxPuid);

            // input and output params
            ws.AddParameter(ParamType.RETVAL, "@hr", 0);
            ws.AddParameter("@userpuid", xboxPuid);
            ws.AddParameter("@componentid", string.Empty);
            ws.AddParameter("@instanceid", instanceId);
            ws.AddParameter("@newstate", subscriptionStatusId);
            ws.AddParameter("@bitmask", 0xFFFFFFFF);
            ws.AddParameter("@bitflags", 0);

            // call the procedure
            ws.ExecuteNonQuery();

            hr = (uint)ws.GetIntParameter("@hr");
        }

        return hr;
    }

    public HResult SetSubscriptionInstanceId(ulong offerId, string instanceId)
    {
        return SetSubscriptionInstanceId(this._puid, offerId, instanceId);
    }

    public HResult SetSubscriptionInstanceId(ulong userPuid, ulong offerId, string instanceId)
    {
        HResult hr = HResult.E_FAIL;

        using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
        {
            ws.ClearParameters();
            ws.StoredProc = "dbo.p_xuacs_set_sub_instance_id";
            ws.SetHashVal(userPuid);

            // input and output params
            ws.AddParameter(ParamType.RETVAL, "@hr", 0);
            ws.AddParameter("@bi_user_puid", userPuid);
            ws.AddParameter("@bi_offer_id", offerId);
            ws.AddParameter("@vc_svc_instance_id", instanceId);

            // call the procedure
            ws.ExecuteNonQuery();

            hr = (uint)ws.GetIntParameter("@hr");
        }

        return hr;
    }

    public HResult UpdateClientActivity(ServiceTypeEnum serviceType, ClientTypeEnum clientType)
    {
        return UpdateClientActivity(this._puid, serviceType, clientType);
    }

    public HResult UpdateClientActivity(ulong userPuid, ServiceTypeEnum serviceType, ClientTypeEnum clientType)
    {
        HResult hr = HResult.E_FAIL;

        using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
        {
            ws.ClearParameters();
            ws.StoredProc = "dbo.p_xuacs_update_client_activity";
            ws.SetHashVal(userPuid);

            // input and output params
            ws.AddParameter(ParamType.RETVAL, "@hr", 0);
            ws.AddParameter("@bi_user_puid", userPuid);
            ws.AddParameter("@ti_service_type", (byte) serviceType);
            ws.AddParameter("@ti_client_type", (byte) clientType);

            // call the procedure
            ws.ExecuteNonQuery();

            hr = (uint)ws.GetIntParameter("@hr");
        }

        return hr;
    }

    public static uint UnlinkWebAccount(ulong xboxPuid, ulong passportPuid)
    {
        HResult hr = HResult.E_FAIL;

        using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
        {
            ws.ClearParameters();
            ws.StoredProc = "dbo.p_xuacs_delete_user_by_passport";
            ws.SetHashVal(passportPuid);

            ws.AddParameter(ParamType.RETVAL, "@hr", 0);
            ws.AddParameter("@bi_user_passport_puid", passportPuid);
            ws.AddParameter("@bi_user_puid", xboxPuid);

            ws.ExecuteNonQuery();

            hr = (uint) ws.GetIntParameter("@hr");
        }

        return hr;
    }

    public HResult AcceptTermsOfService()
    {
        return AcceptTermsOfService(this._puid, XOn.XENON_DASH_TITLE_ID);
    }

    public HResult AcceptTermsOfService(uint titleId)
    {
        return AcceptTermsOfService(this._puid, titleId);
    }

    public HResult AcceptTermsOfService(ServiceTypeEnum serviceType)
    {
        return AcceptTermsOfService(this._puid, serviceType);
    }

    public static HResult AcceptTermsOfService(ulong userPuid)
    {
        return AcceptTermsOfService(userPuid, XOn.XENON_DASH_TITLE_ID);
    }

    public static HResult AcceptTermsOfService(ulong userPuid, uint titleId)
    {
        HResult hr = HResult.E_FAIL;

        using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
        {
            ws.ClearParameters();
            ws.StoredProc = "dbo.p_xuacs_accept_terms_of_service_v2";
            ws.SetHashVal(userPuid);

            // input and output params
            ws.AddParameter(ParamType.RETVAL, "@hr", 0);
            ws.AddParameter("@bi_user_puid", userPuid);
            ws.AddParameter("@i_title_id", titleId);

            // call the procedure
            ws.ExecuteNonQuery();

            hr = (uint)ws.GetIntParameter("@hr");
        }

        return hr;
    }

    public static uint AcceptTermsOfService(ulong userPuid, ServiceTypeEnum serviceType)
    {
        HResult hr = HResult.E_FAIL;

        using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
        {
            ws.ClearParameters();
            ws.StoredProc = "dbo.p_xuacs_accept_terms_of_service_v2";
            ws.SetHashVal(userPuid);

            // input and output params
            ws.AddParameter(ParamType.RETVAL, "@hr", 0);
            ws.AddParameter("@bi_user_puid", userPuid);
            ws.AddParameter("@ti_service_type", (byte) serviceType);

            // call the procedure
            ws.ExecuteNonQuery();

            hr = (uint)ws.GetIntParameter("@hr");
        }

        return hr;
    }

    public static void AddUserByPassport(ulong userPuid, ulong passportPuid)
    {
        if ( userPuid == 0 )
        {
            throw new ArgumentException("userPuid");
        }

        if ( passportPuid == 0 )
        {
            throw new ArgumentException("passportPuid");
        }

        using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
        {
            ws.ClearParameters();
            ws.StoredProc = "dbo.p_xuacs_add_user_by_passport";
            ws.SetHashVal(passportPuid);

            ws.AddParameter(ParamType.RETVAL, "@hr", 0);
            ws.AddParameter("@bi_user_passport_puid", passportPuid);
            ws.AddParameter("@bi_user_puid", userPuid);
            ws.AddParameter("@si_hash_bucket", ws.Partition);

            ws.ExecuteNonQuery();

            HResult hr = (uint)ws.GetIntParameter("@hr");
            if ( HResult.Failed(hr) )
            {
                throw new XRLExceptionWithoutEvent(hr, string.Format("dbo.p_xuacs_add_user_by_passport(@bi_user_passport_puid=0x{0}, @bi_user_puid=0x{1}) returned hr = {2}", passportPuid.ToString("x"), userPuid.ToString("x"), hr));
            }
        }
    }

    public static void DeleteUserByPassport(ulong userPuid, ulong passportPuid)
    {
        if ( userPuid == 0 )
        {
            throw new ArgumentException("userPuid");
        }

        if ( passportPuid == 0 )
        {
            throw new ArgumentException("passportPuid");
        }

        using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
        {
            ws.ClearParameters();
            ws.StoredProc = "dbo.p_xuacs_delete_user_by_passport";
            ws.SetHashVal(passportPuid);

            ws.AddParameter("@bi_user_passport_puid", passportPuid);
            ws.AddParameter("@bi_user_puid", userPuid);

            ws.ExecuteNonQuery();
        }
    }

    public static byte GetCountryId(ulong userPuid)
    {
        using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
        {
            ws.ClearParameters();
            ws.SetHashVal(userPuid);
            ws.StoredProc = "dbo.p_xbos_get_country";

            // intput and output params
            ws.AddParameter(ParamType.RETVAL, "@RETVAL", 0);
            ws.AddParameter(ParamType.INPUT, "@userpuid", userPuid);
            ws.AddParameter(ParamType.OUTPUT, "@countryid", 0);

            // call the procedure
            ws.ExecuteNonQuery();

            HResult hr = (uint)ws.GetIntParameter("@RETVAL");
            if( hr != HResult.S_OK )
            {
                throw new XRLException(HResult.XOFF_E_INVALID_USER, XEvent.Id.COMMON_CODE_225,
                                       "user: 0x" + userPuid.ToString("x") + " not found." );
            }

            byte countryId = (byte)ws.GetIntParameter("@countryid");
            return countryId;
        }
    }

    public static float DefaultGamercardReputation()
    {
        float defaultGamercardReputation = 58.0F;

        try
        {
            string seedVal = Config.GetSetting(Setting.xuacs_defaultGamercardReputation);
            string biasVal = Config.GetSetting(Setting.feedback_coeffBias);
            string slopeVal = Config.GetSetting(Setting.feedback_coeffSlope);
            string rangeVal = Config.GetSetting(Setting.feedback_coeffRange);
            if ( seedVal != null && seedVal != "" && biasVal != null && biasVal != "" && slopeVal != null && slopeVal != "" && rangeVal != null && rangeVal != "" )
            {
                // Normalization coefficients
                double coeffBias = Double.Parse(biasVal);
                double coeffSlope = Double.Parse(slopeVal);
                double coeffRange = Double.Parse(rangeVal);
                double ratingSeed = Double.Parse(seedVal);

                // Now normalize to our 1-100 scale
                // f(x) = exp((x-bias)*slope))/(1+exp((x-bias)*slope))*Range
                defaultGamercardReputation = (float)
                    (Math.Exp((ratingSeed-coeffBias)*coeffSlope)
                     /(1+Math.Exp((ratingSeed-coeffBias)*coeffSlope))*coeffRange);
            }
        }
        catch (Exception e)
        {
            Xom.NtEvent(XEvent.Id.COMMON_CONFIG_286, e, "User.DefaultGamercardReputation: using default value of " + defaultGamercardReputation.ToString());
        }

        return defaultGamercardReputation;
    }

    public ulong Puid
    {
        get { return _puid; }
        set { _puid = value; }
    }

    public ulong OwnerPuid
    {
        get { return _ownerPuid; }
        set { _ownerPuid = value; }
    }

    public ulong OfflineXuid
    {
        get { return _offlineXuid; }
        set { _offlineXuid = value; }
    }

    public ulong PassportPuid
    {
        get { return _passportPuid; }
        set { _passportPuid = value; }
    }

    public ulong OwnerPassportPuid
    {
        get { return _ownerPassportPuid; }
        set { _ownerPassportPuid = value; }
    }

    public ulong BillingPuid
    {
        //
        // For Xbox1 accounts, the owner puid is used for SCS calls.
        //
        // For Xenon accounts (and Xbox.com accounts being migrated), the
        // user's Passport puid is what is used.
        //
        get
        {
            if ( _accountType == Xbox1Account )
            {
                return _ownerPuid;
            }
            else
            {
                return _passportPuid;
            }
        }
    }

    public ulong MachinePuid
    {
        get { return _machinePuid; }
        set { _machinePuid = value; }
    }

    public string GamerTag
    {
        get { return _gamerTag; }
        set { _gamerTag = value; }
    }

    public byte CountryId
    {
        get { return _countryId; }
        set { _countryId = value; }
    }

    public int LanguageId
    {
        get { return _languageId; }
        set { _languageId = value; }
    }

    public int CultureId
    {
        get { return _cultureId; }
        set { _cultureId = value; }
    }

    public string AccountId
    {
        get { return _accountId; }
        set { _accountId = value; }
    }

    public string PaymentInfoId
    {
        get { return _paymentInfoId; }
        set { _paymentInfoId = value; }
    }

    public uint BillingAccountStatus
    {
        get { return _billingAccountStatus; }
        set { _billingAccountStatus = value; }
    }

    public DateTime Birthdate
    {
        get { return _birthdate; }
        set { _birthdate = value; }
    }

    public int Age
    {
        get
        {
            return ComputeAge(_birthdate);
        }
    }

    public int AgeGroupId
    {
        get
        {
            int age = this.Age;
            
            MinAge minAge = CountryDictionary.MinAge(_countryId);
            
            if ( age < minAge.User)
            {
                return XOn.PARENTAL_CONTROL_GROUP_RESTRICTED;
            }
            else if ( age < minAge.Billing )
            {
                return XOn.PARENTAL_CONTROL_GROUP_MEDIUM;
            }
            else
            {
                return XOn.PARENTAL_CONTROL_GROUP_OPEN;
            }
        }
    }
    
    public short TicketFlags
    {
        get { return _ticketFlags; }
        set { _ticketFlags = value; }
    }

    public byte[] BillingPIN
    {
        get { return _billingPIN; }
        set { _billingPIN = value; }
    }

    public int ParentalControlGroupId
    {
        get { return _parentalControlGroupId; }
        set { _parentalControlGroupId = value; }
    }

    public DateTime AccountResumeDate
    {
        get { return _accountResumeDate; }
        set { _accountResumeDate = value; }
    }

    public int SuspensionLength
    {
        get { return _suspensionLength; }
        set { _suspensionLength = value; }
    }

    public DateTime VoiceResumeDate
    {
        get { return _voiceResumeDate; }
        set { _voiceResumeDate = value; }
    }

    public int VoiceBanLength
    {
        get { return _voiceBanLength; }
        set { _voiceBanLength = value; }
    }


    public byte NameChangeRequired
    {
        get { return _nameChangeRequired; }
        set { _nameChangeRequired = value; }
    }

    public DateTime AcceptedTOSDate
    {
        get { return _acceptedTOSDate; }
        set { _acceptedTOSDate = value; }
    }

    public DateTime ResetDate
    {
        get { return _resetDate; }
        set { _resetDate = value; }
    }

    public string BillingPMN
    {
        get
        {
            if ( _accountType == User.Xbox1Account )
            {
                return _gamerTag.Replace(' ', '_');
            }
            else
            {
                return PassportHelper.GetPassportMemberName(_passportPuid);
            }
        }
    }


    public string BillingOwnerPMN
    {
        get
        {
            if ( _accountType == User.Xbox1Account )
            {
                if ( _puid != _ownerPuid )
                {
                    return _gamerTag.Replace(' ', '_') + ".Owner";
                }
                else
                {
                    return _gamerTag.Replace(' ', '_');
                }
            }
            else
            {
                return this.BillingPMN;
            }
        }
    }

    public int Tier
    {
        get { return _tier; }
    }

    public int EmsUserTypeId
    {
        get
        {
            switch (_tier)
            {
            
            case (int) TierEnum.Gold:
                return (int) CatalogUserTypeEnum.XboxLiveGoldUser;

            case (int) TierEnum.Silver:
                return (int) CatalogUserTypeEnum.XboxLiveSilverUser;

            //Hack to ensure that family gold behaves like gold
            case (int)TierEnum.FamilyGold:
                return (int)CatalogUserTypeEnum.XboxLiveGoldUser;

            default:
                throw new Exception(string.Format("Tier '{0}' is invalid.", _tier));
            }
        }
    }

    public byte AccountType
    {
        get { return _accountType; }
        set { _accountType = value; }
    }

    public byte CreatedAccountType
    {
        get { return _createdAccountType; }
        set { _createdAccountType = value; }
    }

    public bool IsXenonAccount
    {
        get { return (_accountType == XenonAccount); }
    }

    public bool IsJuvenileAccount
    {
        get { return _puid != _ownerPuid; }
    }

    public bool IsParentallyControlled
    {
        get { return _ownerPassportPuid != _passportPuid;  }
    }

    public bool IsFamilySecondary
    {
        get { return _ownerPassportPuid != _passportPuid && _tier == (int)TierEnum.FamilyGold; }
    }


    public bool AllowXbox1Logon
    {
        get { return _allowXbox1Logon != 0; }
        set { _allowXbox1Logon = (value == true) ? (byte)1 : (byte)0; }
    }

    public bool IsDowngraded
    {
        get { return _downgraded != 0; }
        set { _downgraded = (value ? (byte)1 : (byte)0); }
    }

    public DateTime LastActivityDate
    {
        get { return _lastActivityDate; }
    }

    public DateTime LastWebActivityDate
    {
        get { return _lastWebActivityDate; }
    }

    public byte AcceptMsSpam
    {
        get { return _acceptMsSpam; }
        set { _acceptMsSpam = value; }
    }

    public byte AcceptPartnerSpam
    {
        get { return _acceptPartnerSpam; }
        set { _acceptPartnerSpam = value; }
    }

    public bool HasMusicnetAccount
    {
        get { return _hasMusicnetAccount == 1; }
    }

    public bool IsGeoFenceExempt
    {
        get { return _isGeoFenceExempt == 1; }
        set { _isGeoFenceExempt = (value ? (byte)1 : (byte)0); }
    }

    public uint WholesalePartnerId
    {
        get { return _wholesalePartnerId;  }
        set { _wholesalePartnerId = value; }
    }

    public bool IsWholesaleUser
    {
        get { return _wholesalePartnerId != 0; }
    }

    public bool HasPiiForPurchase
    {
        get { return _hasPiiForPurchase != 0; }
        set { _hasPiiForPurchase = (value ? (byte) 1 : (byte) 0); }
    }

    public byte FreeGamertagEligible
    {
        get { return _freeGamertagEligible; }
        set { _freeGamertagEligible = value; }
    }

    public bool IsChildOf(Puid parentXuid)
    {
        User parent = new User();
        parent.Load(parentXuid);

        return _ownerPassportPuid == parent.PassportPuid;
    }

    public bool IsChildOf(PassportToken token, out ulong ownerPassportPuid)
    {
        PassportSessionToken.Verify(token, out ownerPassportPuid);

        return _ownerPassportPuid == ownerPassportPuid;
    }

    //
    // UserType differs from AccountType in that the console needs to
    // be able to distinguish Xbox1 users who already have linked gamertags
    // from Xbox1 users without an associated Passport.
    //
    public UserTypeEnum UserType
    {
        get
        {
            switch( _accountType )
            {
            case User.Xbox1Account:
                if (0 == _passportPuid)
                {
                    return UserTypeEnum.Xbox1User;
                }
                return UserTypeEnum.Xbox1LinkedUser;
            case User.XboxComAccount:
                return UserTypeEnum.XboxComUser;
            case User.XenonAccount:
                return UserTypeEnum.XenonUser;
            default:
                throw new XRLException(HResult.XONLINE_E_ACCOUNTS_INVALID_USER, XEvent.Id.COMMON_CODE_226, "Can't find user");
            }
        }
    }

    public ServiceTypeData ServiceTypeData
    {
        get
        {
            return _serviceTypeData;
        }
    }

    public byte UserPassportInvalid
    {
        get {   return _userPassportInvalid;    }
        set {   _userPassportInvalid = value;   }
    }

    public byte OwnerPassportInvalid
    {
        get {   return _ownerPassportInvalid;    }
        set {   _ownerPassportInvalid = value;   }
    }

    public byte GamertagRecycled
    {
        get { return _gamertagRecycled; }
        set { _gamertagRecycled = value; }
    }

#if false
    public PerServiceTypeData GetServiceTypeData(ServiceTypeEnum serviceType)
    {
        PerServiceTypeData pstd = null;

        if ( _serviceTypeData == null || !_serviceTypeData.TryGetValue(serviceType, out pstd) )
        {
            return null;
        }

        Debug.Assert( _serviceTypeData != null );
        Debug.Assert( pstd != null );

        return pstd;
    }
#endif

    public HResult SaveServiceTypeData(ServiceTypeEnum serviceType)
    {
        HResult hr = HResult.S_OK;

        PerServiceTypeData pstd = _serviceTypeData[serviceType];

        if ( pstd == null )
        {
            return hr;
        }

        Debug.Assert( pstd != null );

        using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
        {
            ws.StoredProc = "dbo.p_xuacs_set_user_per_service_type_data_v2";
            ws.SetHashVal(_puid);

            ws.AddParameter(ParamType.RETVAL, "@hr", 0);
            ws.AddParameter(ParamType.INPUT, "@bi_user_puid", _puid);
            ws.AddParameter(ParamType.INPUT, "@ti_service_type", (byte) serviceType);

            if ( pstd.DateAcceptedTermsOfService > DateTime.MinValue )
            {
                ws.AddParameter(ParamType.INPUT, "@dt_accepted_tos", pstd.DateAcceptedTermsOfService);
            }

            if ( pstd.DateProvisioned > DateTime.MinValue )
            {
                ws.AddParameter(ParamType.INPUT, "@dt_provisioned", pstd.DateProvisioned);
            }

            if ( pstd.DateProvisioned > DateTime.MinValue )
            {
                ws.AddParameter(ParamType.INPUT, "@dt_suspended_until", pstd.DateSuspendedUntil);
            }

            if ( pstd.DateLastSuspended > DateTime.MinValue )
            {
                ws.AddParameter(ParamType.INPUT, "@dt_last_suspended", pstd.DateLastSuspended);
            }

            ws.AddParameter(ParamType.INPUT, "@i_times_suspended", pstd.TimesSuspended);

            ws.ExecuteNonQuery();

            hr = (uint) ws.GetIntParameter("@hr");
            if ( HResult.Failed(hr) )
            {
                return hr;
            }
        }

        return hr;
    }

    public static int ComputeAge(DateTime birthdate)
    {
        DateTime now = DateTime.UtcNow;
        int age = now.Year - birthdate.Year;

        if ((birthdate.Month >  now.Month) ||
            (birthdate.Month == now.Month) &&
            (birthdate.Day   >  now.Day))
        {
            age--;
        }

        return age;
    }

    private ulong           _puid;
    private ulong           _ownerPuid;
    private ulong           _offlineXuid;
    private ulong           _passportPuid;
    private ulong           _ownerPassportPuid;
    private ulong           _machinePuid;
    private string          _gamerTag;
    private byte            _countryId;
    private int             _languageId;
    private int             _cultureId;
    private string          _accountId;
    private string          _paymentInfoId;
    private byte[]          _billingPIN;
    private int             _parentalControlGroupId = 0;
    private int             _tier = 0;

    private DateTime        _birthdate;
    private short           _ticketFlags;
    private DateTime        _accountResumeDate;
    private int             _suspensionLength;
    private DateTime        _voiceResumeDate;
    private int             _voiceBanLength;
    private byte            _nameChangeRequired;
    private DateTime        _acceptedTOSDate;
    private DateTime        _resetDate;
    private uint            _billingAccountStatus;
    private DateTime        _lastChangeDate;

    private DateTime        _lastActivityDate;
    private DateTime        _lastWebActivityDate;

    private byte            _accountType = 0;
    private byte            _createdAccountType = 0;
    private byte            _allowXbox1Logon = 0;
    private byte            _downgraded = 0;

    private bool            _isNew = true;

    private byte            _acceptMsSpam;
    private byte            _acceptPartnerSpam;

    private byte            _hasMusicnetAccount;
    private byte            _isGeoFenceExempt;

    private ServiceTypeData _serviceTypeData;
    private uint            _wholesalePartnerId;

    private byte            _hasPiiForPurchase;

    private byte            _userPassportInvalid = 0;
    private byte            _ownerPassportInvalid = 0;

    private byte            _gamertagRecycled = 0;

    private byte            _freeGamertagEligible = 0;
}


    public class UserServices
    {
        private uint[] _services;

        public UserServices(uint [] services)
        {
            _services = services;
        }

        public UserServices(ulong puid, ServiceTypeEnum serviceType, ClientTypeEnum clientType, uint titleId)
        {
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.SetHashVal(puid);

                ws.StoredProc = "dbo.p_signin_get_user_services";
                ws.AddParameter(ParamType.RETVAL, "@RETVAL", 0);
                ws.AddParameter(ParamType.INPUT, "@bi_user_puid", puid);
                ws.AddParameter(ParamType.INPUT, "@ti_service_type", (byte) serviceType);
                ws.AddParameter(ParamType.INPUT, "@ti_client_type", (byte) clientType);

                // the i_title_id parameter is optional and will be null if not specified
                if ( titleId != 0 )
                {
                    ws.AddParameter(ParamType.INPUT, "@i_title_id", titleId);
                }

                List<uint> services = new List<uint>();

                using (WstDataReader r = ws.Execute())
                {
                    HResult hr = (uint) ws.GetIntParameter("@RETVAL");

                    if (HResult.Failed(hr))
                    {
                        throw new Exception("UserServices: failed to get user services from UODB, hr = " + hr);
                    }

                    // initially the privilege set is all set to false, so cycle through
                    // the privileges that are returned and set them to true
                    while (r.Read())
                    {
                        services.Add((uint) r.GetInt32(r.GetOrdinal("i_service_id")));
                    }
                }

                _services = services.ToArray();
            }
        }

        public static explicit operator uint[] (UserServices us)
        {
            return us._services;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\match\dll\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_match_none_12.4.56.0_none_ef3694a2cb172018
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_match_no-public-key_12.4.56.0_x-ww_18be4ea8
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=match
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_match_no-public-key_12.4.56.0_x-ww_18be4ea8
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_match_no-public-key_12.4.56.0_x-ww_18be4ea8.manifest
XP_MANIFEST_PATH=manifests\msil_match_no-public-key_12.4.56.0_x-ww_18be4ea8.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_match_no-public-key_12.4.56.0_x-ww_18be4ea8.cat
XP_CATALOG_PATH=manifests\msil_match_no-public-key_12.4.56.0_x-ww_18be4ea8.cat
XP_PAYLOAD_PATH=msil_match_no-public-key_12.4.56.0_x-ww_18be4ea8
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=match,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\venturarr\DataContract.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.Serialization;
using System.Text.RegularExpressions;
using System.Xml;
using System.Xml.Schema;
using System.Xml.Serialization;
using System.IO;

//
// NOTE:
// NOTE: Code in this file taken from Ventura code-base.
// NOTE:
//
// Adds to Ventura code:
// 1. Replaced .Net 4.0 objects with 3.5 equivalents
//

namespace xonline.common.venturarr
{
    public class Constants
    {
        public const String VenturaNamespace = "http://schemas.xbox.com/ventura/";
    }

    /// <summary>
    /// A set of names describing which EndPoints are exposed to a particular set of clients.
    /// This class is not thread-safe.
    /// </summary>
    // the comment about thread-safety allows us to optimize IntersectionWithMerged in the future
    [CollectionDataContract(Namespace = Constants.VenturaNamespace, ItemName = "EndPointName")]
    public class EndPointSet : List<String>
    {
        public EndPointSet()
        {

        }

        public EndPointSet(string oneUri)
            : base(new[] { oneUri })
        {
        }

        public EndPointSet(IEnumerable<string> allUris)
            : base(allUris)
        {

        }


        /// <summary>
        /// Generates a new manifest with only the endpoints contained with this set.
        /// </summary>
        /// <param name="manifest">The manifest.</param>
        /// <returns>A new manifest with only endpoints both in this set and the input manifest.</returns>
        public ServiceManifest IntersectWithManifest(ServiceManifest manifest)
        {
            // don't think it is worth replacing O(|this|*|manifest|)-time intersection with
            // extra time and space for construction of a hashset, or with sorting this EndPointSet for binary search
            ServiceManifest outManifest = new ServiceManifest()
            {
                ServiceConfiguration = manifest.ServiceConfiguration,
                ServiceDirectory =
                    new List<EndPointEntry>(manifest.ServiceDirectory.Count)
            };
            foreach (EndPointEntry p in manifest.ServiceDirectory.Where(p => Contains(p.Name)))
            {
                outManifest.ServiceDirectory.Add(p);
            }
            return outManifest;
        }
    }



    [DataContract(Namespace = Constants.VenturaNamespace)]
    public class ClientInfo
    {
        public ClientInfo() { }

        [DataMember(Order = 100)]
        public string UserId { get; set; }

        [DataMember(Order = 200)]
        public string DeviceId { get; set; }

        [DataMember(Order = 300)]
        public string Locale { get; set; }

        [DataMember(Order = 400, Name="CustomerGroup")]
        public CustomerGroup CG { get; set; }

        [DataMember(Order = 500)]
        public string ClientVersion { get; set; }

        [DataMember(IsRequired = false)]
        public string DeviceType { get; set; }

        /// <summary>
        /// Mask this client info.
        /// </summary>
        /// <param name="mask">The mask.</param>
        /// <returns></returns>
        //public ClientInfo Masked(ClientInfoMask mask)
        //{
        //    return new ClientInfo()
        //               {
        //                   ClientVersion = mask.HasFlag(ClientInfoMask.ClientVersion) ? this.ClientVersion : null,
        //                   CG = mask.HasFlag(ClientInfoMask.CustomerGroup) ? this.CG : null,
        //                   DeviceId = mask.HasFlag(ClientInfoMask.DeviceId) ? this.DeviceId : null,
        //                   Locale = mask.HasFlag(ClientInfoMask.Locale) ? this.Locale : null,
        //                   DeviceType = mask.HasFlag(ClientInfoMask.DeviceType) ? this.DeviceType : null,
        //                   UserId = mask.HasFlag(ClientInfoMask.UserId) ? this.ClientVersion : null,
        //               };
        //}

        /// <summary>
        /// Determines whether the specified <see cref="System.Object"/> is equal to this instance.
        /// </summary>
        /// <param name="obj">The <see cref="System.Object"/> to compare with this instance.</param>
        /// <returns>
        /// 	<c>true</c> if the specified <see cref="System.Object"/> is equal to this instance; otherwise, <c>false</c>.
        /// </returns>
        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) { return false; }
            if (ReferenceEquals(this, obj)) { return true; }
            if (obj.GetType() != typeof(ClientInfo)) { return false; }
            return Equals((ClientInfo)obj);
        }

        /// <summary>
        /// Determines whether the specified clientInfo is equal to this instance.
        /// </summary>
        /// <param name="other">The other.</param>
        /// <returns></returns>
        public bool Equals(ClientInfo other)
        {
            if (ReferenceEquals(null, other)) { return false; }
            if (ReferenceEquals(this, other)) { return true; }
            return Equals(other.UserId, UserId)
                && Equals(other.DeviceId, DeviceId)
                && Equals(other.Locale, Locale)
                && Equals(other.CG, CG)
                && Equals(other.ClientVersion, ClientVersion)
                && Equals(other.DeviceType, DeviceType);
        }

        /// <summary>
        /// Determines whether the specified clientInfo is equal to this instance, examining only the components indicated in the mask.
        /// </summary>
        /// <param name="other">The other.</param>
        /// <param name="mask">The mask.</param>
        /// <returns></returns>
        //public bool EqualsMasked(ClientInfo other, ClientInfoMask mask)
        //{
        //    if (ReferenceEquals(null, other)) { return false; }
        //    if (ReferenceEquals(this, other)) { return true; }
        //    return (mask.HasFlag(ClientInfoMask.UserId) | Equals(other.UserId, UserId))
        //        && (mask.HasFlag(ClientInfoMask.DeviceId) | Equals(other.DeviceId, DeviceId))
        //        && (mask.HasFlag(ClientInfoMask.Locale) | Equals(other.Locale, Locale))
        //        && (mask.HasFlag(ClientInfoMask.CustomerGroup) | Equals(other.CG, CG))
        //        && (mask.HasFlag(ClientInfoMask.ClientVersion) | Equals(other.ClientVersion, ClientVersion))
        //        && (mask.HasFlag(ClientInfoMask.DeviceType) | Equals(other.DeviceType, DeviceType));
        //}

        /// <summary>
        /// Returns a hash code for this instance.
        /// </summary>
        /// <returns>
        /// A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table. 
        /// </returns>
        public override int GetHashCode()
        {
            unchecked
            {
                int result = (UserId != null ? UserId.GetHashCode() : 0);
                result = (result * 397) ^ (DeviceId != null ? DeviceId.GetHashCode() : 0);
                result = (result * 397) ^ (Locale != null ? Locale.GetHashCode() : 0);
                result = (result * 397) ^ (CG != null ? CG.GetHashCode() : 0);
                result = (result * 397) ^ (ClientVersion != null ? ClientVersion.GetHashCode() : 0);
                result = (result * 397) ^ (DeviceType != null ? DeviceType.GetHashCode() : 0);
                return result;
            }
        }

        /// <summary>
        /// Implements the operator ==.
        /// </summary>
        /// <param name="left">The left.</param>
        /// <param name="right">The right.</param>
        /// <returns>The result of the operator.</returns>
        public static bool operator ==(ClientInfo left, ClientInfo right)
        {
            return Equals(left, right);
        }

        /// <summary>
        /// Implements the operator !=.
        /// </summary>
        /// <param name="left">The left.</param>
        /// <param name="right">The right.</param>
        /// <returns>The result of the operator.</returns>
        public static bool operator !=(ClientInfo left, ClientInfo right)
        {
            return !Equals(left, right);
        }
    }

    /// <summary>
    /// Describes which parts of a ClientInfo structure are relevant
    /// </summary>
    [Flags]
    [DataContract(Namespace = Constants.VenturaNamespace)]
    public enum ClientInfoMask
    {
        CustomerGroup = 0x01,
        ClientVersion = 0x02,
        Locale = 0x04,
        DeviceId = 0x08,
        UserId = 0x10,
        DeviceType = 0x20,
    }

    [DataContract(Namespace = Constants.VenturaNamespace)]
    public class ServiceManifest
    {
        public ServiceManifest()
        {
            ServiceConfiguration = new ConfigurationDictionary();
            ServiceDirectory = new List<EndPointEntry>();
        }

        [DataMember(Order = 100)]
        public ConfigurationDictionary ServiceConfiguration { get; set; }

        [DataMember(Order = 200)]
        public List<EndPointEntry> ServiceDirectory { get; set; }

    }
    
    [CollectionDataContract(Namespace = Constants.VenturaNamespace, ItemName = "Setting", KeyName = "Name", ValueName = "Value")]
    public class ConfigurationDictionary : Dictionary<string, string>
    {
        public ConfigurationDictionary()
        {
        }
    }

    [XmlSchemaProvider("GetXmlSchema")]
    public class CustomerGroup : IXmlSerializable, IComparable<CustomerGroup>, IComparable<string>
    {
        public static readonly Regex CgValidationExp =
            new Regex("\\A[a-z0-9]+\\z", RegexOptions.Compiled | RegexOptions.Singleline);

        private string m_cgName;
        public string Name
        {
            get
            {
                if (!IsValidCg(m_cgName))
                {
                    throw new InvalidDataException("Must set CG to a valid name before using");
                }
                return m_cgName;
            }

            private set
            {
                if (!IsValidCg(value))
                {
                    throw new ArgumentException(string.Format(
                        "'{0}' is not a valid customer group name", value));
                }
                m_cgName = value;
            }
        }

        public CustomerGroup()
        {
            m_cgName = "";
        }

        public CustomerGroup(string cg)
        {
            Name = cg;
        }

        public static bool IsValidCg(string cg)
        {
//            return !string.IsNullOrWhiteSpace(cg) && CgValidationExp.IsMatch(cg);
            return !string.IsNullOrEmpty(cg) && CgValidationExp.IsMatch(cg);
        }

        public bool IsValid()
        {
            return IsValidCg(Name);
        }

        // IComparable<CustomerGroup>
        public int CompareTo(CustomerGroup other)
        {
            if (other == null)
            {
                // Treat null object like min value
                return 1;
            }
            return Name.CompareTo(other.Name);
        }

        // IComparable<string>
        public int CompareTo(string other)
        {
            return Name.CompareTo(other);
        }

        public static bool operator ==(CustomerGroup left, CustomerGroup right)
        {
            // Need to cast for null neck to avoid recursion
            if ((object)left == null)
            {
                return (object)right == null;
            }
            return left.Equals(right);
        }

        public static bool operator !=(CustomerGroup left, CustomerGroup right)
        {
            return !(left == right);
        }

        public override bool Equals(object obj)
        {
            return Equals(obj as CustomerGroup);
        }

        public bool Equals(CustomerGroup other)
        {
            return CompareTo(other) == 0;
        }

        public bool Equals(string other)
        {
            return CompareTo(other) == 0;
        }

        public override int GetHashCode()
        {
            return Name.GetHashCode();
        }

        public override string ToString()
        {
            return Name;
        }

        public XmlSchema GetSchema()
        {
            // This should not be used and simply returns null. See 
            // http://msdn.microsoft.com/en-us/library/system.xml.serialization.ixmlserializable.getschema.aspx 
            // for more info.
            return null;
        }

        public static XmlQualifiedName GetXmlSchema(XmlSchemaSet xs)
        {
            string xmlSchema = string.Format(
                @"<xs:schema elementFormDefault='qualified' targetNamespace='{0}' xmlns:xs='http://www.w3.org/2001/XMLSchema' xmlns:tns='{0}'>" +
                  @"<xs:element name='CustomerGroup'>" +
                    @"<xs:simpleType>" +
                      @"<xs:restriction base='xs:string'>" +
                        @"<xs:pattern value='{1}'/>" +
                      @"</xs:restriction>" +
                    @"</xs:simpleType>" +
                  @"</xs:element>" +
                @"</xs:schema>",
                Constants.VenturaNamespace,
                CgValidationExp.ToString()
                );

            XmlSchema schema = XmlSchema.Read(new StringReader(xmlSchema), null);
            xs.XmlResolver = new XmlUrlResolver();
            xs.Add(schema);
            return new XmlQualifiedName("CustomerGroup", Constants.VenturaNamespace);
        }

        public void ReadXml(XmlReader reader)
        {
            Name = reader.ReadString();
        }

        public void WriteXml(XmlWriter writer)
        {
            writer.WriteString(Name);
        }
    }

    [DataContract(Namespace = Constants.VenturaNamespace, Name = "EndPoint")]
    public class EndPointEntry
    {
        public EndPointEntry() { }

        [DataMember(Order = 100)]
        public String Name { get; set; }

        [DataMember(Order = 200)]
        public UriOrderedList UriOrderedList { get; set; }
    }

    [CollectionDataContract(Namespace = Constants.VenturaNamespace, ItemName = "Uri")]
    public class UriOrderedList : List<String>
    {
        public UriOrderedList()
        {
        }

        public UriOrderedList(string oneUri)
            : base(new string[] { oneUri })
        {
        }

        public UriOrderedList(IEnumerable<string> allUris)
            : base(allUris)
        {
        }
    }

    [DataContract(Name = "VTkn", Namespace = Constants.VenturaNamespace)]
    public class SignInToken
    {
        public SignInToken() { }

        [DataMember(Order = 100, Name = "C")]
        public CustomerGroup CG { get; set; }

        [DataMember(Order = 200, Name = "V")]
        public string VUID { get; set; }

        [DataMember(Order = 300, Name = "B")]
        public RoundTripDateTime NotBefore { get; set; }

        [DataMember(Order = 400, Name = "A")]
        public RoundTripDateTime NotOnOrAfter { get; set; }

        [DataMember(Order = 500, Name = "I")]
        public RoundTripDateTime IssueInstant { get; set; }

        [DataMember(Order = 600, Name = "S", IsRequired = false, EmitDefaultValue = false), Obsolete]
        public string Signature { get; set; }

        [DataMember(Order = 700, Name = "P", IsRequired = false)]
        public bool IsSuperUser { get; set; }

        public override bool Equals(object obj)
        {
            var other = obj as SignInToken;
            if (other == null)
            {
                return false;
            }
            return CG == other.CG
                && VUID == other.VUID
                && NotBefore == other.NotBefore
                && NotOnOrAfter == other.NotOnOrAfter
                && IssueInstant == other.IssueInstant;
        }

        public override int GetHashCode()
        {
            int hc = CG.GetHashCode();
            hc ^= VUID.GetHashCode();
            hc ^= NotBefore.GetHashCode();
            hc ^= NotOnOrAfter.GetHashCode();
            hc ^= IssueInstant.GetHashCode();
            return hc;
        }
    }

    [XmlSchemaProvider("GetXmlSchema")]
    public class RoundTripDateTime : IXmlSerializable
    {
        public DateTime Value { get; set; }

        public static implicit operator RoundTripDateTime(DateTime value)
        {
            return new RoundTripDateTime() { Value = value };
        }

        public static implicit operator DateTime(RoundTripDateTime value)
        {
            return value.Value;
        }



        public static XmlQualifiedName GetXmlSchema(XmlSchemaSet xs)
        {
            XmlSchema schema = XmlSchema.Read(new StringReader(
              @"<xs:schema elementFormDefault='qualified' targetNamespace='http://schemas.xbox.com/ventura/' xmlns:xs='http://www.w3.org/2001/XMLSchema' xmlns:tns='http://schemas.xbox.com/ventura/'> " +
                @"<xs:element name='RoundTripDateTime' type='tns:RoundTripDateTime' /> " +
                @"<xs:simpleType name='RoundTripDateTime' > " +
                  @"<xs:restriction base='xs:string' /> " +
                @"</xs:simpleType> " +
              @"</xs:schema>"
                ), null);

            xs.XmlResolver = new XmlUrlResolver();
            xs.Add(schema);

            return new XmlQualifiedName("RoundTripDateTime", "http://schemas.xbox.com/ventura/");
        }


        public void ReadXml(XmlReader reader)
        {
            Value = DateTime.Parse(reader.ReadString()).ToUniversalTime();
        }

        public void WriteXml(XmlWriter writer)
        {
            writer.WriteString(Value.ToString("o"));
        }

        public XmlSchema GetSchema()
        {
            return null;
        }

        public override string ToString()
        {
            return Value.ToString("o");
        }

        public override bool Equals(object obj)
        {
            return Equals(obj as RoundTripDateTime);
        }

        public bool Equals(RoundTripDateTime obj)
        {
            if (null == (object)obj)
            {
                return false;
            }
            return Value.Equals(obj.Value);
        }

        public override int GetHashCode()
        {
            return Value.GetHashCode();
        }

        public static bool operator ==(RoundTripDateTime a, RoundTripDateTime b)
        {
            return (null == (object)a && null == (object)b) || ((null != (object)a) && a.Equals(b));
        }

        public static bool operator !=(RoundTripDateTime a, RoundTripDateTime b)
        {
            return !(a == b);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\match\dll\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\match\match\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\match\dll\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_match_none_12.4.56.0_none_ef3694a2cb172018
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_match_no-public-key_12.4.56.0_x-ww_18be4ea8
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=match
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_match_no-public-key_12.4.56.0_x-ww_18be4ea8
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_match_no-public-key_12.4.56.0_x-ww_18be4ea8.manifest
XP_MANIFEST_PATH=manifests\msil_match_no-public-key_12.4.56.0_x-ww_18be4ea8.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_match_no-public-key_12.4.56.0_x-ww_18be4ea8.cat
XP_CATALOG_PATH=manifests\msil_match_no-public-key_12.4.56.0_x-ww_18be4ea8.cat
XP_PAYLOAD_PATH=msil_match_no-public-key_12.4.56.0_x-ww_18be4ea8
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=match,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\venturarr\venturaRRServiceWrapper.cs ===
using System;
using System.Globalization;
using System.Net;
using System.Text;
using System.Threading;
using System.Web.Services.Protocols;
using System.Xml;

using xonline.common.config;
using xonline.common.service;
using xonline.common.mgmt;

using msnrr.wsdl.rating.single;
using msnrr.wsdl.aggregator;

[assembly: XomAreaDefinition(XomAreaName.msnrrTrace)]
[assembly: XomAreaDefinition(XomAreaName.msnrrLog)]


namespace xonline.common.venturarr
{
    public class VenturaRRClient
    {
        public static readonly float VenturaConvertRatio = 5.0f;

        public static int SingleRatingTimeoutSeconds
        {
            get
            {
                return Config.GetIntSetting(Setting.venturarr_singleRatingTimeoutSeconds);
            }
        }
        
        public static int AggregateRatingTimeoutSeconds
        {
            get
            {
                return Config.GetIntSetting(Setting.venturarr_aggregateRatingTimeoutSeconds);
            }
        }          

        public static void SaveRating(object itemId, ulong authorsXuid, int ratingValue)
        {
            VenturaServiceWrapper service = new VenturaServiceWrapper(true, SingleRatingTimeoutSeconds);
            try 
            {
                service.SaveRating(VenturaConvertRatio, itemId, authorsXuid, ratingValue);
            } 
            catch (Exception) 
            {
                // place to filter exceptions based on error code if needed 
                throw;
            }
        }

        public static void GetRatingByUser(object itemId, ulong xuid, Puid puid, out int userRating)
        {
        
            VenturaServiceWrapper service = new VenturaServiceWrapper(true, SingleRatingTimeoutSeconds);
            try 
            {
                service.GetRatingByUser(VenturaConvertRatio, itemId, xuid, puid, out userRating);
            } 
            catch (Exception) 
            {
                // place to filter exceptions based on error code if needed 
                throw;
            }
        }

        // returns the list-of-aggregate lists...
        public static MediaLists GetRatingAveragesListOfLists(string start, string count)
        {
            VenturaServiceWrapper service = new VenturaServiceWrapper(false, AggregateRatingTimeoutSeconds);
            try 
            {
                return service.GetRatingAveragesListOfLists(start, count);
            } 
            catch (Exception) 
            {
                // place to filter exceptions based on error code if needed 
                throw;
            }
        }

        // returns contents of a single list...
        public static MediaList GetRatingAveragesList(string listId)
        {
            VenturaServiceWrapper service = new VenturaServiceWrapper(false, AggregateRatingTimeoutSeconds);
            try 
            {
                return service.GetRatingAveragesList(listId);
            } 
            catch (Exception) 
            {
                // place to filter exceptions based on error code if needed 
                throw;
            }
        }

        // returns contents of a single list, including raw-xml...
        public static MediaList GetRatingAveragesList(string listId, out XmlNode result)
        {
            VenturaServiceWrapper service = new VenturaServiceWrapper(false, AggregateRatingTimeoutSeconds);
            try 
            {
                return service.GetRatingAveragesList(listId, out result);
            } 
            catch (Exception) 
            {
                // place to filter exceptions based on error code if needed 
                throw;
            }
        }
    }

    public class VenturaServiceWrapper
    {
        private static Methods m_vapi; 

        private static volatile bool _fInitializedProxy = false;

        private static readonly string customerGroup = Config.GetSetting(Setting.venturarr_customerGroup); /*"xboxratings";*/
        private static readonly string superUserVuidPart = Config.GetSetting(Setting.venturarr_superUserVuidPart); /*"superuser";*/ 
        private static readonly string formatVuid = Config.GetSetting(Setting.venturarr_formatVuid); /*"{0}_{1:X}";*/
        private static readonly string formatSuperVuid = Config.GetSetting(Setting.venturarr_formatSuperVuid); /*"{0}_{1}";*/

        private const string getRatingApiName = "venturaGetRating";
        private const string saveRatingApiName = "venturaSaveRating";
        private const string getAveragesListofListsApiName = "venturaGetRatingAveragesListOfLists";
        private const string getAveragesListApiName = "venturaGetRatingAveragesList";
        
        private static readonly string generateManifestFromSdsApiName = "venturaGenerateManifestFromSds";
        private static readonly string signInVenturaTicketCreateApiName = "venturaSignInVenturaTicketCreate";

        //////////////////////////////////////////////////////////
        // InitializeManifest
        //
        // Methods of this class MUST call this method (InitializeManifest) to guarantee
        // the SDS Manifest has been properly initialized before doing any work
        private static void InitializeManifest()
        {
            if (m_vapi.IsServiceManifestExpired())
            {
                string apiName = generateManifestFromSdsApiName;
                APIResultEnum apiResult = APIResultEnum.Failed;
                XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();
                FastFailTracker fastFailTracker = null;
                string errorMessage = null;
                
                string ClientVersion = Config.GetSetting(Setting.venturarr_clientVersion); // "11.2.7.0";
                string DeviceId = Config.GetSetting(Setting.venturarr_deviceId); //"1127";
                string Locale = Config.GetSetting(Setting.venturarr_locale); //"en-us";
                string UserId = string.Format(CultureInfo.InvariantCulture, formatSuperVuid, customerGroup, superUserVuidPart);

                string Url = Config.GetSetting(Setting.venturarr_serviceDirectoryServiceUrl);
                
                try
                {
                    CheckFastFail(apiName, ref apiResult, ref fastFailTracker);
                    HandlePerfCountersBegin(apiName);
                
                    m_vapi.GenerateManifestfromSds(customerGroup, Url, ClientVersion, DeviceId, Locale, UserId);

                    apiResult = APIResultEnum.Success;
                }
                catch (Exception ex)
                {
                    if (CheckExceptionForFastFail(ex))
                    {
                        apiResult = APIResultEnum.Timeout;
                        HandleTimeout(apiName, fastFailTracker);
                    }
                    else
                    {
                        errorMessage = ex.Message;
                    }
                    throw;
                }
                finally
                {
                    HandlePerfCountersEnd(apiName, apiResult, timeElapsed);

                    LogApiCall(apiName, apiResult, timeElapsed.MillisecondsElapsed,
                        new string [] { UserId, Url },
                        null,
                        errorMessage,
                        fastFailTracker
                        );
                }
            }
        }

        //////////////////////////////////////////////////////////
        // InitializeCredentials
        //
        // Methods of this class MUST call this method (InitializeCredentials) to guarantee
        // the Ventura Credentials has been properly initialized before doing any work
        private static void InitializeCredentials()
        {
            if (m_vapi.AreCredentialsExpired())
            {
                string apiName = signInVenturaTicketCreateApiName;
                APIResultEnum apiResult = APIResultEnum.Failed;
                XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();
                FastFailTracker fastFailTracker = null;
                string errorMessage = null;
                
                //Format of the token should be <predefined user id>;<DateTime>
                string token = superUserVuidPart + ";" + DateTime.UtcNow;
                string sharedKey = Config.GetSetting(Setting.venturarr_serviceAuthKeyArray);
                byte keyIndex = (byte)Config.GetIntSetting(Setting.venturarr_serviceAuthKeyIndex);
                
                //This class will add the signature to the end of the token. The value in the FromString method is the shared key that we should agree on
                //The format fo the shared key is 0:xxx where 0 means use the first key, and xxx is the value of the key (1234 in this case)
                //On the server we will have multiple keys so that you can use key 1 while we renew key 0, etc.
                //The last value in this class explains which key to use (key index 1 in this case)
                SharedKeyMessageSigner signer = new SharedKeyMessageSigner(Encoding.Unicode.GetBytes(token), SharedKeyPool.FromString(sharedKey), keyIndex);
                
                string tokenXML = Convert.ToBase64String(signer.GetSignedData());
                
                try
                {
                    CheckFastFail(apiName, ref apiResult, ref fastFailTracker);
                    HandlePerfCountersBegin(apiName);
                
                    m_vapi.SignInVenturaTicketCreateV2(tokenXML, customerGroup);
                
                    apiResult = APIResultEnum.Success;
                }
                catch (Exception ex)
                {
                    if (CheckExceptionForFastFail(ex))
                    {
                        apiResult = APIResultEnum.Timeout;
                        HandleTimeout(apiName, fastFailTracker);
                    }
                    else
                    {
                        errorMessage = ex.Message;
                    }
                    throw;
                }
                finally
                {
                    HandlePerfCountersEnd(apiName, apiResult, timeElapsed);

                    LogApiCall(apiName, apiResult, timeElapsed.MillisecondsElapsed,
                        new string [] { token, sharedKey, keyIndex.ToString() },
                        null,
                        errorMessage,
                        fastFailTracker
                        );
                }
            }
        }

        //////////////////////////////////////////////////////////
        // InitializeWebProxy
        //
        // Methods of this class MUST call this method (InitializeWebProxy) to guarantee
        // the static m_proxy member has been properly initialized before doing any work
        private static void InitializeWebProxyAndTimeout(int timeout)
        {
            if ( !_fInitializedProxy )
            {
                string proxy = Config.GetSetting(Setting.billing_proxy);
                if (!string.IsNullOrEmpty(proxy))
                {
                    m_vapi.SetWebProxy(new WebProxy(proxy, true));
                }
                m_vapi.SetTimeout(timeout * 1000);
                
                _fInitializedProxy = true;
            }
        }

        static VenturaServiceWrapper()
        {
            if(Config.GetBoolSetting(Setting.venturarr_failFastEnabled))
            {
                // Retrieve configuration and setup fast fail
                int maxThreshold = Config.GetIntSetting(Setting.venturarr_failFastMaxThreshold);
                int minThreshold = Config.GetIntSetting(Setting.venturarr_failFastMinThreshold);
                int timeWindow = Config.GetIntSetting(Setting.venturarr_failFastTimeWindow);

                FastFailResourceConfig fastFailResourceConfig = new FastFailResourceConfig();
                fastFailResourceConfig.MaximumThreshold = (uint)maxThreshold;
                fastFailResourceConfig.MinimumThreshold = (uint)minThreshold;
                fastFailResourceConfig.ThrottlingSelector = new VenturaThrottleSelector(0.5f); // If we reach 50 % timeouts begin throttling back requests
                fastFailResourceConfig.CaptureTimeWindow = new TimeSpan(0, 0, timeWindow);

                FastFail.ConfigureResource(getRatingApiName, fastFailResourceConfig);
                FastFail.ConfigureResource(saveRatingApiName, fastFailResourceConfig);
                FastFail.ConfigureResource(getAveragesListofListsApiName, fastFailResourceConfig);
                FastFail.ConfigureResource(getAveragesListApiName, fastFailResourceConfig);
                FastFail.ConfigureResource(generateManifestFromSdsApiName, fastFailResourceConfig);
                FastFail.ConfigureResource(signInVenturaTicketCreateApiName, fastFailResourceConfig);
            }

            m_vapi = new Methods( Config.GetUIntSetting(Setting.venturarr_padCredentialExpiryMilliseconds /*60000*/) ); 
        }

        public VenturaServiceWrapper(bool signInRequired, int timeout)
        {
            // Ensure instance initialization complete
            InitializeWebProxyAndTimeout(timeout);
            InitializeManifest();
            if (signInRequired)
            {
                InitializeCredentials();
            }
        }


        /* ************************************************************** */
        /* **********                PUBLIC API CALLS         *********** */
        /* ************************************************************** */

        public MediaLists GetRatingAveragesListOfLists(string start, string count)
        {
            string apiName = getAveragesListofListsApiName;
            APIResultEnum apiResult = APIResultEnum.Failed;
            XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();
            FastFailTracker fastFailTracker = null;
            string errorMessage = null;

            MediaLists lists = null;
            
            try
            {
                CheckFastFail(apiName, ref apiResult, ref fastFailTracker);
                HandlePerfCountersBegin(apiName);
                
                lists = m_vapi.ListsActivityGet(start, count);

                apiResult = APIResultEnum.Success;

                return lists;
            }
            catch (Exception ex)
            {
                if (CheckExceptionForFastFail(ex))
                {
                    apiResult = APIResultEnum.Timeout;
                    HandleTimeout(apiName, fastFailTracker);
                }
                else
                {
                    errorMessage = ex.Message;
                }
                throw;
            }
            finally
            {
                HandlePerfCountersEnd(apiName, apiResult, timeElapsed);

                LogApiCall(apiName, apiResult, timeElapsed.MillisecondsElapsed,
                    new string [] { start.ToString(), count.ToString() },
                    new string [] { (lists == null ? "" : lists.Count.ToString()) },
                    errorMessage,
                    fastFailTracker
                    );
            }
        }

        public MediaList GetRatingAveragesList(string listId)
        {
            string apiName = getAveragesListApiName;
            APIResultEnum apiResult = APIResultEnum.Failed;
            XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();
            FastFailTracker fastFailTracker = null;
            string errorMessage = null;

            MediaList list = null;
            
            try
            {
                CheckFastFail(apiName, ref apiResult, ref fastFailTracker);
                HandlePerfCountersBegin(apiName);
                
                list = m_vapi.ListsActivityListGet(listId);

                apiResult = APIResultEnum.Success;

                return list;
            }
            catch (Exception ex)
            {
                if (CheckExceptionForFastFail(ex))
                {
                    apiResult = APIResultEnum.Timeout;
                    HandleTimeout(apiName, fastFailTracker);
                }
                else
                {
                    errorMessage = ex.Message;
                }
                throw;
            }
            finally
            {
                HandlePerfCountersEnd(apiName, apiResult, timeElapsed);

                LogApiCall(apiName, apiResult, timeElapsed.MillisecondsElapsed,
                    new string [] { listId },
                    new string [] { (list == null ? "" : list.Id), (list == null ? "" : list.Items.Count.ToString()) },
                    errorMessage,
                    fastFailTracker
                    );
            }
        }

        public MediaList GetRatingAveragesList(string listId, out XmlNode result)
        {
            string apiName = getAveragesListApiName;
            APIResultEnum apiResult = APIResultEnum.Failed;
            XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();
            FastFailTracker fastFailTracker = null;
            string errorMessage = null;

            MediaList list = null;
            result = null;
            
            try
            {
                CheckFastFail(apiName, ref apiResult, ref fastFailTracker);
                HandlePerfCountersBegin(apiName);
                
                list = m_vapi.ListsActivityListGet(listId, out result);

                apiResult = APIResultEnum.Success;

                return list;
            }
            catch (Exception ex)
            {
                if (CheckExceptionForFastFail(ex))
                {
                    apiResult = APIResultEnum.Timeout;
                    HandleTimeout(apiName, fastFailTracker);
                }
                else
                {
                    errorMessage = ex.Message;
                }
                throw;
            }
            finally
            {
                HandlePerfCountersEnd(apiName, apiResult, timeElapsed);

                LogApiCall(apiName, apiResult, timeElapsed.MillisecondsElapsed,
                    new string [] { listId },
                    new string [] { (list == null ? "" : list.Id), (list == null ? "" : list.Items.Count.ToString()), (result == null ? "" : result.InnerXml) },
                    errorMessage,
                    fastFailTracker
                    );
            }
        }
        
        public void GetRatingByUser(float convertRatio, object itemId, ulong xuid, Puid puid, out int userRating)
        {
            string apiName = getRatingApiName;
            APIResultEnum apiResult = APIResultEnum.Failed;
            XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();
            FastFailTracker fastFailTracker = null;
            string errorMessage = null;

            userRating = 0;

            try
            {
                CheckFastFail(apiName, ref apiResult, ref fastFailTracker);
                HandlePerfCountersBegin(apiName);
                
                string vuid = String.Format(CultureInfo.InvariantCulture, formatVuid, customerGroup, xuid);

                var mr2 = m_vapi.RatingsUserGetV2(vuid, itemId.ToString(), puid.ToString());

                userRating = 0;
                if (mr2.Rating != null)
                {
                    userRating = (int)(mr2.Rating * convertRatio);
                }

                apiResult = APIResultEnum.Success;

                return;
            }
            catch (Exception ex)
            {
                if (CheckExceptionForFastFail(ex))
                {
                    apiResult = APIResultEnum.Timeout;
                    HandleTimeout(apiName, fastFailTracker);
                }
                else if (ex is WebException 
                        && ((WebException)ex).Response is HttpWebResponse
                        && ((HttpWebResponse)((WebException)ex).Response).StatusCode == HttpStatusCode.NotFound)
                {   
                    // if we fail with 404, consider as success
                    apiResult = APIResultEnum.Success;
                }
                else
                {
                    errorMessage = ex.Message;
                }
                throw;
            }
            finally
            {
                HandlePerfCountersEnd(apiName, apiResult, timeElapsed);

                LogApiCall(apiName, apiResult, timeElapsed.MillisecondsElapsed,
                    new string [] { itemId.ToString(), xuid.ToString("X") },
                    new string [] { userRating.ToString() },
                    errorMessage,
                    fastFailTracker
                    );
            }
        }

        public void SaveRating(float convertRatio, object itemId, ulong xuid, int ratingValue)
        {
            string apiName = saveRatingApiName;
            APIResultEnum apiResult = APIResultEnum.Failed;
            XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();
            FastFailTracker fastFailTracker = null;
            string errorMessage = null;

            try
            {
                CheckFastFail(apiName, ref apiResult, ref fastFailTracker);
                HandlePerfCountersBegin(apiName);
                
                MediaReviewWithDictionaryEntriesV2 mr = new MediaReviewWithDictionaryEntriesV2();
                mr.Rating = ((float)ratingValue) / convertRatio;
                string vuid = String.Format(CultureInfo.InvariantCulture, formatVuid, customerGroup, xuid);

                m_vapi.RatingsUserPutV2(vuid, itemId.ToString(), mr);
                
                apiResult = APIResultEnum.Success;

                return;
            }
            catch (Exception ex)
            {
                if (CheckExceptionForFastFail(ex))
                {
                    apiResult = APIResultEnum.Timeout;
                    HandleTimeout(apiName, fastFailTracker);
                }
                else
                {
                    errorMessage = ex.Message;
                }
                throw;
            }
            finally
            {
                HandlePerfCountersEnd(apiName, apiResult, timeElapsed);

                LogApiCall(apiName, apiResult, timeElapsed.MillisecondsElapsed,
                    new string [] { itemId.ToString(), xuid.ToString("X"), ratingValue.ToString() },
                    null,
                    errorMessage,
                    fastFailTracker
                    );
            }
        }

        private static void CheckFastFail(string apiName, ref APIResultEnum result, ref FastFailTracker fft)
        {
            fft = null;

            try
            {
                if (Config.GetBoolSetting(Setting.venturarr_failFastEnabled))
                {
                    fft = new FastFailTracker(apiName);
                }
            }
            catch (FastFailException)
            {
                VenturaRRCounters.Counters.BlockedCallsPerSecond.Increment();
                VenturaRRCounters.Counters.BlockedCallsTotal.Increment();

                VenturaRRCounters apiCounters = VenturaRRCounters.Counters[apiName];
                apiCounters.BlockedCallsPerSecond.Increment();
                apiCounters.BlockedCallsTotal.Increment();

                result = APIResultEnum.FailFast;

                throw; // We are in fast fail
            }

            return;
        }

        private static Boolean CheckExceptionForFastFail(Exception ex)
        {
            Exception innerException = ex.InnerException;
            while (innerException != null)
            {
                if (IsExceptionFastFail(innerException))
                {
                    return true;
                }
                innerException = innerException.InnerException;
            }
            return false;
        }

        private static Boolean IsExceptionFastFail(Exception ex)
        {
            if (FastFailHelper.ConsiderExceptionAsTimeout(ex))
            {
                return true;
            }
            return false;
        }

        private enum APIResultEnum
        {
            Success,
            FailFast,
            Failed,
            Timeout
        }
        
        private static void HandlePerfCountersBegin(string apiName)
        {
            VenturaRRCounters.Counters.CallsPerSecond.Increment();
            VenturaRRCounters.Counters.CallsTotal.Increment();

            VenturaRRCounters apiCounters = VenturaRRCounters.Counters[apiName];
            apiCounters.CallsPerSecond.Increment();
            apiCounters.CallsTotal.Increment();
        }

        private static void HandleTimeout(string apiName, FastFailTracker fft)
        {
            VenturaRRCounters.Counters.TimeoutsPerSecond.Increment();
            VenturaRRCounters.Counters.TimeoutsTotal.Increment();

            VenturaRRCounters apiCounters = VenturaRRCounters.Counters[apiName];
            apiCounters.TimeoutsPerSecond.Increment();
            apiCounters.TimeoutsTotal.Increment();

            if ( fft != null )
            {
                fft.IndicateTimeout();
            }
        }

        private static void HandlePerfCountersEnd(string apiName, APIResultEnum result, XomRequestTimeElapsed timeElapsed)
        {
            VenturaRRCounters.Counters.CallsTime.IncrementBy(timeElapsed.TimeElapsed);
            VenturaRRCounters.Counters.CallsTimeBase.Increment();

            VenturaRRCounters apiCounters = VenturaRRCounters.Counters[apiName];
            apiCounters.CallsTime.IncrementBy(timeElapsed.TimeElapsed);
            apiCounters.CallsTimeBase.Increment();

            if (result != APIResultEnum.Success && result != APIResultEnum.FailFast)
            {
                VenturaRRCounters.Counters.CallsFailedPerSecond.Increment();
                VenturaRRCounters.Counters.CallsFailedTotal.Increment();

                apiCounters.CallsFailedPerSecond.Increment();
                apiCounters.CallsFailedTotal.Increment();
            }
        }

        private static void LogApiCall(string apiName, APIResultEnum result, long millisecondsElapsed, string [] inParams,
            string [] outParams, string errorDetails, FastFailTracker fft)
        {
            if (result != APIResultEnum.Timeout && fft != null)
            {
                fft.IndicateSuccess();
            }
            
            string resultString;
            switch (result)
            {
                case APIResultEnum.Success:
                    resultString = "Success";
                    break;
        
                case APIResultEnum.FailFast:
                    resultString = "FailFast";
                    break;
        
                case APIResultEnum.Failed:
                    resultString = "Failed";
                    break;
        
                case APIResultEnum.Timeout:
                    resultString = "Timeout";
                    break;
        
                default:
                    resultString = "Unknown";
                    break;
            }
        
            string outParamsString;
            if (result == APIResultEnum.Success)
            {
                if (outParams == null)
                    outParamsString = "";
                else
                    outParamsString = string.Join("|", outParams);
            }
            else
            {
                outParamsString = "Failed";
            }
        
            string szLog = string.Join("|", new string []
            {
                apiName,
                resultString,
                millisecondsElapsed.ToString(),
                string.Join("|", inParams),
                outParamsString,
                errorDetails == null ? "" : errorDetails
            });
        
            Xom.Log(XomAreaName.msnrrLog, szLog);
        }
    }

    public class VenturaThrottleSelector : FastFailThrottleSelector
    {
        public VenturaThrottleSelector() : this(0.5f) { }
        public VenturaThrottleSelector(float tolerance)
        {
            Tolerance = tolerance;
        }

        public override float SelectThrottle(FastFailStatistics statistics)
        {
            // Once we hit the tolerance, we will want to start throttling back requests instead of cutting them off altogether

            // If we hit close to 100% timeouts, we will want to only allow in the minimum number of calls per the configuration
            // As we return back down to the tolerance threshold we are ok with, we will want to start letting in more calls

            // If the timeout ratio is .75, and our tolerance is .5, we will throttle calls by 50% of (max - min) + min
            // If the timeout ratio is .60, and our tolerance is .5, we will throttle calls by 20% of (max - min) + min
            // A timeout ratio of 1.0 will reduce calls to the min allowed
            if (statistics.AggregatedFeatures.TimeoutRatio > tolerance)
            {
                return (tolerance - (statistics.AggregatedFeatures.TimeoutRatio - tolerance)) / tolerance;
            }

            return 1.0f;
        }

        public float Tolerance
        {
            get { return tolerance; }
            set
            {
                if (tolerance > 1 || tolerance < 0)
                    throw new ArgumentOutOfRangeException("value", tolerance, "range must be in [0, 1]");
                tolerance = value;
            }
        }

        private float tolerance;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\match\match\MatchDBCommon.cs ===
//
// Database.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Matchmaking Common Database Methods
// Xbox Online Service
//

using System;
using System.Data;
using System.Data.SqlClient;
using xonline.common;
using xonline.common.config;
using xonline.common.service;
using xonline.common.mgmt;

[assembly: XomAreaDefinition(XomAreaName.matchdbtrace)]

namespace xonline.common.match
{

    // ------------------------------------------------------------------------
    // BreadcrumbState
    // Enumeration for the possible states that a row in any of the session
    // tables can be in.
    // ------------------------------------------------------------------------
    public enum BreadcrumbState
    {
        Unknown = 0, // we don't know.  This is a special case, used to tell the DB to go with what it's got.
        Breadcrumb,   // This is the original row.  It may point to another row, using the i_sw_bucket column.
        Sandwich,           // there are 2 rows for the session, in 2 different buckets.  This is the newest, or sandwich.     
        Both                    // there's 1 row, but it "contains" both the breadcrumb and sandwich
    };
    
public class MatchSql
{

    // ------------------------------------------------------------------------
    // SQLDefs class - provide symbolic names for SQL Error codes so we don't
    // have literal values in switch statements in DBLayer
    // ------------------------------------------------------------------------
    public class SQLDefs
    {
        // These errors are not from SQL Server, they must be from the data access layer, SqlClient.
        public const int ERROR_SQLCLIENT_TIMEOUT = -2;              // "Timeout expired.  The timeout period elapsed prior to completion of the operation or the server is not responding."
        public const int ERROR_SQLCLIENT_CONNECTION_FAILED = 2;     // "An error has occurred while establishing a connection to the server.  When connecting to SQL Server 2005, this failure may be caused by the fact that under the default settings SQL Server does not allow remote connections. (provider: Named Pipes Provider, error: 40 - Could not open a connection to SQL Server)"

        // These errors are from SQL Server (sysmessages)
        public const int ERROR_PARAM_MISSING = 201;
        public const int ERROR_COULD_NOT_CONTINUE_SCAN_WITH_NOLOCK = 601;
        public const int ERROR_DEADLOCKED_PROCESS_KILLED = 1205;
        public const int ERROR_PRIMARY_KEY_VIOLATION = 2627;
        public const int ERROR_COULD_NOT_FIND_STORED_PROC = 2812;
        public const int ERROR_TOO_MANY_PARAM = 8144;
        public const int ERROR_INVALID_PARAM_NAME = 8145;
        public const int ERROR_PARAMETER_PROVIDED_MULTIPLE_TIMES = 8143;
        public const int ERROR_DATA_TRUNCATED = 8152;
        public const int ERROR_LOGIN_TIMEOUT = 17197;
        public const int ERROR_LOGIN_NETWORK_ERROR = 17829;
        public const int ERROR_NETWORK_TIMEOUT = 17830;
    }

    
    // -----------------------------------------------------------------------
    // FBucketInMigration - determine whether the given bucket is currently
    // being migrated.  
    // -----------------------------------------------------------------------
    public static bool FBucketInMigration(IBucketServer ibsBucket)
    {
        if (ibsBucket.NextServerName != "" &&
            ibsBucket.NextServerName != ibsBucket.CurrentServerName &&
            ibsBucket.NextServerStart < DateTime.UtcNow)
        {
            return true;
        }
        return false;
    }


    // ----------------------------------------------------------------------
    // LockAndReadForBucket - locks the row (breadcrumb) on whichever of its migrating
    // pair it currently resides on.  Returns all the row's data.
    // NOTE: this is currently only used by livematch's rush migrate code.
    // OTHER NOTE: this is 360 ONLY..
    // ----------------------------------------------------------------------
public static uint LockAndReadForBucket(ulong qwSessionId, uint dwTitleId, IBucketServer ibsBreadcrumb, out SqlConnection cxnBreadcrumb, out SqlDataReader reader)
{
    // call both next and current 
    int nTries = 0;
    bool fRetry = true;
    string strServer = "";
    HResult hr = HResult.S_OK;
    cxnBreadcrumb = null;
    reader = null;
    try
    {
        strServer = (string)ibsBreadcrumb.NextServerName;
        SqlCommand cmd = CreateLockAndReadSqlCommand(dwTitleId);
        SqlAddParam(cmd, ParameterDirection.Input,
            "@bi_session_id", qwSessionId);
        while(nTries++ < 2 && fRetry)
        {
            fRetry = false;
            cxnBreadcrumb = MatchSql.OpenSqlConnectionToMatchDBNoFastfail(strServer);
            cmd.Connection = cxnBreadcrumb;
            reader = cmd.ExecuteReader();
            if(!reader.Read())
            {
                hr = HResult.E_FAIL;
            }
            else
            {
                hr = (uint)(int)reader["i_return_code"];
                if(hr != HResult.S_OK) // failed to take the lock, but why?
                {
                    reader.Close();
                    if (FBucketInMigration(ibsBreadcrumb) &&
                        (hr == HResult.XONLINE_E_MATCH_INVALID_SESSION_ID ||        // the session wasn't there
                         hr == HResult.XONLINE_E_MATCH_SESSION_TYPE_MISMATCH))  // the SW or BC was there, but we were looking for the other.
                    {
                        strServer = (string)ibsBreadcrumb.CurrentServerName; // try the other server
                        fRetry = true;
                    }
                    cxnBreadcrumb.Close(); // it's got no rows... no point to keeping it open.
                }
            }
        }
    }
    catch(SqlException e)
    {
        throw new XRLException(
        HResult.XONLINE_E_MATCH_CRITICAL_DB_ERR,
        XEvent.Id.MATCH_CODE_8, // TODOTHEOM: new error
        "Common.Match.ReleaseLock: Unexpected SqlException(" + SqlExceptionToString(e) + "): "
        + " TitleID=0x" + dwTitleId.ToString("X8"), e);
    }
    return hr;
}


    // ----------------------------------------------------------------------
    // ReleaseLock - unlocks a row.  Takes the server on which the row resides, based
    // on the assumption that if the caller took the lock, they know where the row is.
    // NOTE: this is currently only used by livematch's rush migrate code.
    // OTHER NOTE: this is 360 ONLY..
    // Returns an HResult: S_OK for success, S_FALSE if the row is not found, or error.
    // ----------------------------------------------------------------------
public static uint ReleaseLock(ulong qwSessionId, uint dwTitleId, SqlConnection cxnBreadcrumb)
{
    HResult hr = HResult.S_OK;
    try
    {
        SqlCommand cmd = CreateReleaseLockSqlCommand(dwTitleId, cxnBreadcrumb);
        SqlAddParam(cmd, ParameterDirection.Input,
                "@bi_session_id", qwSessionId);
        SqlAddParam(cmd, ParameterDirection.ReturnValue,
                "@retval", (uint)0);

        cmd.ExecuteNonQuery();

        hr = (uint)(int)cmd.Parameters["@retval"].Value;
        if (HResult.Failed(hr))
        {
            switch (hr)
            {
                case HResult.XONLINE_E_MATCH_INVALID_SESSION_ID:
                case HResult.XONLINE_E_MATCH_SESSION_TYPE_MISMATCH:                                
                    // This is either a game issue (A game shouldn't
                    // try to delete a session that is already gone) or we're doing a migration
                    // and just tried the server that the session isn't on. 
                    // Alternatively, it could be that the wrong part of the session (bc or sw)
                    // is present there.
                    hr = HResult.S_FALSE;
                    break;
                default:
                    // we expect that SQL errors will generate a
                    // SQLException that will be caught below. Therefore
                    // we treat this as a development error.
                    throw new XRLException(hr, XEvent.Id.MATCH_CODE_7,
                            "XMatchFD.DBLayer.DeleteSession: Unexpected return code from stored proc hr = "
                            + hr
                            + " TitleID=0x" + dwTitleId.ToString("X8"));
            }
        }
    }
    catch(SqlException e)
    {
        throw new XRLException(
        HResult.XONLINE_E_MATCH_CRITICAL_DB_ERR,
        XEvent.Id.MATCH_CODE_8, // TODOTHEOM: new error
        "Common.Match.ReleaseLock(" + SqlExceptionToString(e) + "): "
        + " TitleID=0x" + dwTitleId.ToString("X8"), e);
    }
    return hr;
}

    
    // ----------------------------------------------------------------------
    // InsertCmdFromReaderRow - takes a reader that's advanced to a row.
    // Creates a SQL command object that will insert the relevant data from 
    // that reader into a new row.
    // NOTE: this is currently only used when moving the data for a row
    // from its original location to a new location.  (breadcrumb target)
    // OTHER NOTE: this is 360 ONLY
    // ----------------------------------------------------------------------
    public static SqlCommand InsertCmdFromReaderRow(SqlDataReader reader, 
                                                    uint dwTitleId, bool fCarryLock)
    {
        SqlCommand cmd = CreateInsertSqlCommand(dwTitleId,
                                    false); // islegacyxbox

        // TODO2THEOM: get rid of these unnecessary double-casts.  (sql to .net and back to sql)

        SqlAddParam(cmd, ParameterDirection.ReturnValue,
                "@retval", (uint)0);

        int iOrd = reader.GetOrdinal("bi_session_id");
        ulong qwSessionId = (ulong)reader.GetInt64(iOrd);

        SqlAddParam(cmd, ParameterDirection.Input,
                "@bi_session_id", qwSessionId);
        SqlAddParam(cmd, ParameterDirection.Input,
                "@i_ip_addr", (int)reader["i_ip_addr"]);
        SqlAddParam(cmd, ParameterDirection.Input,
                "@i_sg_ip", (int)reader["i_sg_ip"]);
        SqlAddParam(cmd, ParameterDirection.Input,
                "@b_box_id", (byte[])reader["b_box_id"]);
        SqlAddParam(cmd, ParameterDirection.Input,
                "@b_host_address", (byte[])reader["b_host_address"]);
        SqlAddParam(cmd, ParameterDirection.Input,
                "@b_key_exchange_key", (byte[])reader["b_key_exchange_key"]);
        SqlAddParam(cmd, ParameterDirection.Input,
                "@i_public_available", (int)reader["i_public_available"]);
        SqlAddParam(cmd, ParameterDirection.Input,
                "@i_private_available", (int)reader["i_private_available"]);
        SqlAddParam(cmd, ParameterDirection.Input,
                "@i_public_current", (int)reader["i_public_current"]);
        SqlAddParam(cmd, ParameterDirection.Input,
                "@i_private_current", (int)reader["i_private_current"]);
        SqlAddParam(cmd, ParameterDirection.Input,
                "@dt_session_expire", (DateTime)reader["dt_session_expiration"]);
        SqlAddParam(cmd, ParameterDirection.Input,
                "@ti_nat_type",(byte)reader["ti_nat_type"]);
        // .net will likely not be happy at runtime casting a null value (which can exist in i_sw_bucket)
        // to an int.  Either that, or it'll successfully cast it to some value that's meaningless.  Try
        // to preserve the possible SQL null...
        SqlParameter param = new SqlParameter();
        param.ParameterName = "@i_sw_bucket";
        param.Direction = ParameterDirection.Input;
        param.Value = reader.GetSqlValue(reader.GetOrdinal("i_sw_bucket"));
        cmd.Parameters.Add(param);

        if(fCarryLock)
        {
            param = new SqlParameter();
            param.ParameterName = "@dt_lock_expire";
            param.Direction = ParameterDirection.Input;
            param.Value = reader.GetSqlValue(reader.GetOrdinal("dt_lock_expire"));
            cmd.Parameters.Add(param);
        }

        // missing params:
        // - dt_deletion_time: we shouldn't insert something that's already deleted, so not a big deal
        // - i_hash: it's a random number, and will just be recreated.
        // - ti_is_available: easy to (re)deduce
        
        // NOTE: this doesn't need to handle flegacyxbox, because those won't 
        // move partitions.
        
        // get count of columns from reader.FieldCount;
        // loop through columns from N to end, calling GetName(ordinal) to get the
        // name of the column, and calling SqlAddParam for each.

        int iTitleColumn = 21;  // TODOTHEOM: need a const, or better way of getting this.  Maybe just start from zero?
        for (; iTitleColumn < reader.FieldCount; iTitleColumn++)
        {

            param = new SqlParameter();
            param.ParameterName = "@" + reader.GetName(iTitleColumn);
            param.Direction = ParameterDirection.Input;
            param.Value = reader.GetSqlValue(iTitleColumn);
            cmd.Parameters.Add(param);
        }

        return cmd;
    }

    // ----------------------------------------------------------------------
    // DeleteSessionCore 
    // encapsulates the core logic of creating a delete command, executing
    // it against a server, and retrying where appropriate.
    // (and all kinds of crazy error handling)
    // ----------------------------------------------------------------------
    public static uint DeleteSessionCore(SqlConnection cxn,
                                        BreadcrumbState bcs,
                                        uint dwTitleId,
                                        ulong qwSessionId,
                                        ref uint dwSWBucket) 
    {
        HResult hr = HResult.S_OK;
        bool fRetry = true;
        dwSWBucket = UInt32.MaxValue; // tell the caller that no i_sw_bucket came back by default.  TODOTHEOM: use a better const here.

        SqlCommand cmd = CreateDeleteSqlCommand(dwTitleId, false /*fIsLegacyXboxTitle*/, cxn);
      
        SqlAddParam(cmd, ParameterDirection.Output, "@i_sw_bucket", (uint)0);
        SqlAddParam(cmd, ParameterDirection.Input, "@ti_target_rowtype", (byte)bcs);            
        SqlAddParam(cmd, ParameterDirection.ReturnValue,
                "@retval", (uint)0);
        SqlAddParam(cmd, ParameterDirection.Input,
                "@bi_session_id", qwSessionId);

        Xom.Trace(XomAreaName.matchdbtrace, LogLevel.L_NORMAL,
                "XMatchCommon.SqlDefs.DeleteSessionCore: Using db=" + cxn.DataSource
                + " to delete session id=" + qwSessionId.ToString("X16")
                + ". TitleID=0x" + dwTitleId.ToString("X8"));

        // Retry logic, we should not retry more than once.  
        // Note that retry is only used for 1 case, ERROR_INVALID_PARAM_NAME (see below)
        fRetry = true;
        for (int currentTry = 0, allowedTries = 2;
                fRetry == true &&
                currentTry < allowedTries;
                currentTry++)
        {
            try
            {
                cmd.ExecuteNonQuery();

                // If we failed to issue this command with the parameter the title
                // is likely misconfigured
                hr = (uint)(int)cmd.Parameters["@retval"].Value;
                if (HResult.Failed(hr))
                {
                    switch (hr)
                    {
                        case HResult.XONLINE_E_MATCH_INVALID_SESSION_ID:
                        case HResult.XONLINE_E_MATCH_SESSION_TYPE_MISMATCH:
                            // This is either a game issue (A game shouldn't
                            // try to delete a session that is already gone) or we're doing a migration
                            // and just tried the server that the session isn't on. 
                            // Alternatively, it could be that the wrong part of the session (bc or sw)
                            // is present there.
                            hr = HResult.S_FALSE;
                            fRetry = false; // if the session wasn't found, no reason to retry.
                            break;
                        default:
                            // we expect that SQL errors will generate a
                            // SQLException that will be caught below. Therefore
                            // we treat this as a development error.
                            throw new XRLException(hr, XEvent.Id.MATCH_CODE_7,
                                    "XMatchCommon.SqlDefs.DeleteSession: Unexpected return code from stored proc hr = "
                                    + hr
                                    + " TitleID=0x" + dwTitleId.ToString("X8"));
                    }
                }
                else
                {
                    fRetry = false; // all is well
                    dwSWBucket = UInt32.MaxValue; // tell the caller that no i_sw_bucket came back by default.  TODOTHEOM: use a better const here.
                    SqlParameter paramSWBucket = cmd.Parameters["@i_sw_bucket"];
                    if (paramSWBucket.Value != DBNull.Value)
                    {
                        dwSWBucket = (uint)(int)paramSWBucket.Value;
                    }
                }
            }
            catch (SqlException e)
            {
                throw new XRLException(
                        HResult.XONLINE_E_MATCH_CRITICAL_DB_ERR,
                        XEvent.Id.MATCH_CODE_8,  // TODOTHEOM: new error code
                        "XMatchCommon.SqlDefs.DeleteSession: Unexpected SqlException(" + SqlExceptionToString(e) + "): "
                        + " TitleID=0x" + dwTitleId.ToString("X8"), e);
            }
        } // end retry loop
        return hr;
    }



    public static SqlConnection OpenSqlConnectionToMatchDBNoFastfail(string server)
    {
        IInterfaceInfo iface = Config.GetInterface(server, Interface.xmatch);
        SqlConnection cxn = new SqlConnection(iface.SqlConnectionString);
        cxn.Open();
        return cxn;
    }



    // ------------------------------------------------------------------------
    // InsertSessionCore
    // Shared code to call the Insert stored proc, and handle errors 
    // appropriately.  (shared by standard insert and breadcrumb code paths)
    // returns true if the DB call failed with PK_VIOLATION.  Throws on other
    // failures, and returns false if all is well.
    // ------------------------------------------------------------------------
    public static bool InsertSessionCore(
                            SqlCommand cmd,
                            BreadcrumbState bcsInsert, // the type of row we're inserting.  Either breadcrumb or sandwich
                            ulong dwTitleId,
                            string strServerName) // TODOTHEOM: this is for logging only... crummy
    {
        HResult hr = HResult.E_FAIL;
        try
        {
            SqlAddParam(cmd, ParameterDirection.Input,
                        "@ti_breadcrumb_state", (byte)bcsInsert);  

            cmd.ExecuteNonQuery();

            hr = (uint)(int)cmd.Parameters["@retval"].Value;
            if (HResult.Failed(hr))
            {
                if(hr == HResult.XONLINE_E_MATCH_INVALID_SESSION_ID ||        // the session wasn't there
                 hr == HResult.XONLINE_E_MATCH_SESSION_TYPE_MISMATCH)
                {
                    return true;
                }
                // we expect that SQL errors will generate a SQLException that
                // will be caught below. Therefore we treat this as a
                // development error.
                throw new XRLException(hr, XEvent.Id.MATCH_CODE_1,
                    "MatchSql.InsertSessionCore: Unexpected return code from stored proc hr = "
                    + hr
                    + ". TitleID=0x" + dwTitleId.ToString("X8"));
            }
        }
        catch (SqlException e)
        {
            Xom.Trace(XomAreaName.matchdbtrace, LogLevel.L_ERROR,
                "MatchSql.InsertSessionCore: TitleID=0x" + dwTitleId.ToString("X8")
                + ", SqlException(" + SqlExceptionToString(e) + ")");

            throw new XRLException(
                HResult.XONLINE_E_MATCH_CRITICAL_DB_ERR,
                XEvent.Id.MATCH_CODE_3,
                "MatchSql.InsertSessionCore: Unexpected SqlException(" + SqlExceptionToString(e) + ")"
                + " TitleID=0x" + dwTitleId.ToString("X8"), e);
        }
        return false;
    }

    // -----------------------------------------------------------------------
    // The insert, update, and delete stored procs generated for each title
    // have a root name that is fixed, with a suffix based on the titleid.
    // This method encapsulates attaching the suffix and creating a
    // SqlCommand object, given a particular root stored proc name and titleid
    // -----------------------------------------------------------------------
    public static SqlCommand CreateTitleSqlCommand(
        string storedProcRoot,
        uint dwTitleId,
        bool isLegacyXboxTitle,
        SqlConnection cxn)
    {
        SqlCommand cmd = new SqlCommand(storedProcRoot
            + IdToSqlSuffix(dwTitleId, isLegacyXboxTitle),
            cxn);
        cmd.CommandType = CommandType.StoredProcedure;
        return cmd;
    }

    // -----------------------------------------------------------------------
    // This method encapsulates the generation of stored proc and attribute name,
    // suffixes
    // -----------------------------------------------------------------------
    public static string IdToSqlSuffix(
        uint id,
        bool isLegacyXboxTitle)
    {
        if (isLegacyXboxTitle)
        {
            // legacy titles use decimal suffixes
            return id.ToString();
        }
        // xenon titles use hex suffixes, plus "v2" designation
        // for the latest release to allow upgrade
        return "0x" + id.ToString("X8");
    }


    // -----------------------------------------------------------------------
    // This method encapsulates the name of the insert session stored proc
    // -----------------------------------------------------------------------
    public static SqlCommand CreateInsertSqlCommand(
        uint dwTitleId,
        bool isLegacyXboxTitle)
    {
        string procName;
        if (isLegacyXboxTitle)
        {
            procName = "p_match_session_insert_" + IdToSqlSuffix(dwTitleId, isLegacyXboxTitle);
        }
        else
        {
            procName = "p_match_session_v2_" + IdToSqlSuffix(dwTitleId, isLegacyXboxTitle)
                + "_insert";
        }
        SqlCommand cmd = new SqlCommand(procName);
        cmd.CommandType = CommandType.StoredProcedure;
        return cmd;
    }

    // -----------------------------------------------------------------------
    // This method encapsulates the root name of the delete session stored proc
    // -----------------------------------------------------------------------
    public static SqlCommand CreateDeleteSqlCommand(
        uint dwTitleId,
        bool isLegacyXboxTitle,
        SqlConnection cxn)
    {
        string procName;
        if (isLegacyXboxTitle)
        {
            procName = "p_match_session_delete_" + IdToSqlSuffix(dwTitleId, isLegacyXboxTitle);
        }
        else
        {
            procName = "p_match_session_v2_" + IdToSqlSuffix(dwTitleId, isLegacyXboxTitle)
                + "_delete";
        }
        SqlCommand cmd = new SqlCommand(procName, cxn);
        cmd.CommandType = CommandType.StoredProcedure;
        return cmd;
    }

    // -----------------------------------------------------------------------
    // This method encapsulates the root name of the lock and read proc
    // This is 360-only
    // -----------------------------------------------------------------------
    public static SqlCommand CreateLockAndReadSqlCommand(
        uint dwTitleId)
    {
        string procName;
        procName = "p_match_session_v2_" + IdToSqlSuffix(dwTitleId, false /* isLegacyXbox */)
            + "_lock_and_read";
        SqlCommand cmd = new SqlCommand(procName);
        cmd.CommandType = CommandType.StoredProcedure;
        return cmd;
    }

    // -----------------------------------------------------------------------
    // This method encapsulates the root name of the release lock proc
    // This is 360-only
    // -----------------------------------------------------------------------
    public static SqlCommand CreateReleaseLockSqlCommand(
        uint dwTitleId,
        SqlConnection cxn)
    {
        string procName;
        procName = "p_match_session_v2_" + IdToSqlSuffix(dwTitleId, false /* isLegacyXbox */)
            + "_release_lock";
        SqlCommand cmd = new SqlCommand(procName, cxn);
        cmd.CommandType = CommandType.StoredProcedure;
        return cmd;
    }


    // -----------------------------------------------------------------------
    // Adds a ulong parameter to a SqlCommand
    // -----------------------------------------------------------------------
    public static void SqlAddParam(
        SqlCommand cmd,
        ParameterDirection dir,
        string strName,
        ulong qwValue )
    {
        SqlParameter param = new SqlParameter();
        param.ParameterName = strName;
        param.Direction = dir;
        param.DbType = DbType.Int64;
        if(ParameterDirection.Input == dir)
        {
            param.Value = (long)qwValue;
        }
        cmd.Parameters.Add(param);
    }

    // -----------------------------------------------------------------------
    // Adds a uint parameter to a SqlCommand
    // -----------------------------------------------------------------------
    public static void SqlAddParam(
        SqlCommand cmd,
        ParameterDirection dir,
        string strName,
        uint dwValue )
    {
        SqlParameter param = new SqlParameter();
        param.ParameterName = strName;
        param.Direction = dir;
        param.DbType = DbType.Int32;
        if(ParameterDirection.Input == dir)
        {
            param.Value = (int)dwValue;
        }
        cmd.Parameters.Add(param);
    }

    // -----------------------------------------------------------------------
    // Adds a ushort parameter to a SqlCommand
    // -----------------------------------------------------------------------
    public static void SqlAddParam(
        SqlCommand cmd,
        ParameterDirection dir,
        string strName,
        ushort wValue )
    {
        SqlParameter param = new SqlParameter();
        param.ParameterName = strName;
        param.Direction = dir;
        param.DbType = DbType.Int16;
        if(ParameterDirection.Input == dir)
        {
            param.Value = (short)wValue;
        }
        cmd.Parameters.Add(param);
    }

    // -----------------------------------------------------------------------
    // Adds a byte parameter to a SqlCommand
    // -----------------------------------------------------------------------
    public static void SqlAddParam(
        SqlCommand cmd,
        ParameterDirection dir,
        string strName,
        byte bValue )
    {
        SqlParameter param = new SqlParameter();
        param.ParameterName = strName;
        param.Direction = dir;
        param.DbType = DbType.Byte;
        if(ParameterDirection.Input == dir)
        {
            param.Value = bValue;
        }
        cmd.Parameters.Add(param);
    }

    // -----------------------------------------------------------------------
    // Adds a byte array parameter to a SqlCommand
    // -----------------------------------------------------------------------
    public static void SqlAddParam(
        SqlCommand cmd,
        ParameterDirection dir,
        string strName,
        byte[] rgbValue )
    {
        SqlParameter param = new SqlParameter();
        param.ParameterName = strName;
        param.Direction = dir;
        param.DbType = DbType.Binary;
        if(ParameterDirection.Input == dir)
        {
            param.Value = rgbValue;
        }
        cmd.Parameters.Add(param);
    }

    // -----------------------------------------------------------------------
    // Adds a string parameter to a SqlCommand
    // -----------------------------------------------------------------------
    public static void SqlAddParam(
        SqlCommand cmd,
        ParameterDirection dir,
        string strName,
        string strValue )
    {
        SqlParameter param = new SqlParameter();
        param.ParameterName = strName;
        param.Direction = dir;
        param.DbType = DbType.String;
        if(ParameterDirection.Input == dir)
        {
            param.Value = strValue;
        }
        cmd.Parameters.Add(param);
    }

    // -----------------------------------------------------------------------
    // Adds a float parameter to a SqlCommand
    // -----------------------------------------------------------------------
    public static void SqlAddParam(
        SqlCommand cmd,
        ParameterDirection dir,
        string strName,
        float fValue)
    {
        SqlParameter param = new SqlParameter();
        param.ParameterName = strName;
        param.Direction = dir;
        param.DbType = DbType.Single;
        if(ParameterDirection.Input == dir)
        {
            param.Value = fValue; 
        }
        cmd.Parameters.Add(param);
    }

    // -----------------------------------------------------------------------
    // Adds a double parameter to a SqlCommand
    // -----------------------------------------------------------------------
    public static void SqlAddParam(
        SqlCommand cmd,
        ParameterDirection dir,
        string strName,
        double dValue)
    {
        SqlParameter param = new SqlParameter();
        param.ParameterName = strName;
        param.Direction = dir;
        param.DbType = DbType.Double;
        if(ParameterDirection.Input == dir)
        {
            param.Value = dValue;
        }
        cmd.Parameters.Add(param);
    }

    // -----------------------------------------------------------------------
    // Adds a DateTime parameter to a SqlCommand
    // -----------------------------------------------------------------------
    public static void SqlAddParam(
        SqlCommand cmd,
        ParameterDirection dir,
        string strName,
        DateTime dtValue)
    {
        SqlParameter param = new SqlParameter();
        param.ParameterName = strName;
        param.Direction = dir;
        param.DbType = DbType.DateTime;
        if(ParameterDirection.Input == dir)
        {
            param.Value = dtValue;
        }
        cmd.Parameters.Add(param);
    }


    public static string SqlExceptionToString(SqlException e)
    {
        return String.Format("State: {0}, Error: {1}, Message: {2}",
                e.State.ToString(),
                e.Errors[0].Number.ToString(),
                e.Message);
    }

}


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\match\match\MatchAdmin.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.IO;
using System.Net;
using System.Text;
using System.Xml;
using System.Xml.XPath;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.tools;
using xonline.common.protocol;
using xonline.tools.framework;

namespace xonline.common.match
{

public class MatchXmgmtCommand
{
    public const string HELP = "help";
    public const string RELOADTITLEINFO = "reloadtitleinfo";
    public const string GETCACHEEXPIRATION = "getcacheexpiration";
}

public  enum CrossPlatformRevokeState
{
    NotSupported,
    Allow,
    Revoke
}

public class MatchAdmin
{

    static private TextWriter _log;

    static MatchAdmin()
    {
        _log = Console.Out;
    }

    public static void SetLogTarget(TextWriter log)
    {
        _log = log;
    }

    public static void Log(string msg)
    {
        if (_log == Console.Out) {
            CommandUtility.WriteOutput(msg);
        }
        else {
            _log.WriteLine(msg);
        }
    }
    public static void LogError(string msg)
    {
        if (_log == Console.Out) {
            CommandUtility.WriteError(msg);
        }
        else {
            _log.WriteLine(msg);
        }
    }

    public static void ConfigureTitle(
        uint titleId,
        bool droptable,
        bool reload,
        string strNewModeServer)
    {
        string xlastXml = GetGameConfig(titleId);
        string ltcXml = GetLiveTitleConfig(titleId);

        MatchGameConfig matchGameConfig;
        MatchLtcConfig matchLtcConfig;
        XmlDocument doc = new XmlDocument();

        // Load match specific part of the xlast config
        doc.LoadXml(xlastXml);
        MatchXlastConfigLoader xlastLoader = new MatchXlastConfigLoader();
        xlastLoader.Load(doc, _log, out matchGameConfig);

        // Load the ltc config
        doc.LoadXml(ltcXml);
        MatchLtcConfigLoader ltcLoader = new MatchLtcConfigLoader();
        ltcLoader.Load(doc, _log, out matchLtcConfig);

        ConfigureTitle(matchGameConfig, 
                        matchLtcConfig, 
                        strNewModeServer, 
                        false /*fRemoveModeOk*/, 
                        droptable, 
                        reload, 
                        false /* fOverrideBuckets */, 
                        null);
    }

    public static void ConfigureTitle(
        MatchGameConfig matchGameConfig,
        MatchLtcConfig matchLtcConfig,
        string strNewModeServer,
        bool fRemoveModeOk,
        bool droptable,
        bool reload,
        bool fOverrideBuckets,
        string script)
    {
        if (script != null && script != "")
        {
            WriteScript(matchGameConfig, matchLtcConfig, droptable, script);
        }
        else
        {
            ConfigureMatch(matchGameConfig, matchLtcConfig, strNewModeServer, null /* strMigrationDestServer */, fRemoveModeOk, droptable, reload, fOverrideBuckets, false /* fIgnoreNonDestErrors */ );
        }
    }

    public static void ConfigureXboxTitle(
        string xmsPath,
        MatchLtcConfig matchLtcConfig,
        bool droptable,
        bool reload,
        bool fHandsOffTitleSql,
        string script,
        string add,
        string delete,
        string fallback)
    {
        if (script != null)
        {
            ConvertXmsToSql(matchLtcConfig.TitleId, xmsPath, droptable);
        }
        else
        {
            ConfigureXboxMatch(xmsPath, matchLtcConfig, droptable, reload, fHandsOffTitleSql, add, delete, fallback);
        }
    }

    public static void WriteScript(
        MatchGameConfig matchGameConfig,
        MatchLtcConfig matchLtcConfig,
        bool droptable,
        string script)
    {
        string[] sqlStatements = MatchSqlCodeGen.All(matchGameConfig, matchLtcConfig, droptable);
        string[] rgstrCleanupJobSqlStatements = MatchSqlCodeGen.SessionCleanupJob(matchGameConfig, matchLtcConfig);
        
        Log("[MatchAdmin.WriteScript]: Writing " + sqlStatements.Length + " general sql statements to " + script);

        using (StreamWriter writer = new StreamWriter(script, false))
        {
            foreach (string statement in sqlStatements)
            {
                writer.Write(statement);
                writer.Write("\nGO\n");
            }

            Log("[MatchAdmin.WriteScript]: Writing " + rgstrCleanupJobSqlStatements.Length + " sql statements for cleanup job creation to " + script);
            foreach (string statement in rgstrCleanupJobSqlStatements)
            {
                writer.Write(statement);
                writer.Write("\nGO\n");
            }
            
        }
    }

    // -----------------------------------------------------------------------
    // ResolveMatchBuckets
    // returns a list of servers referred to by the "current" server of the interface buckets 
    // in the passed in LTC config.  Does not look at the "next" server of the buckets, since
    // the LTC config doesn't actually know about the "next".  (strNewServer is used to get
    // around this)
    // -----------------------------------------------------------------------
    public static string[] ResolveMatchBuckets(
        MatchGameConfig matchGameConfig,
        MatchLtcConfig matchLtcConfig,
        string strNewServer)
    {
        Hashtable hashServer = new Hashtable(4);

        foreach(MatchInterfaceBucket mib in matchLtcConfig.MatchInterfaceBuckets)
        {
                if (!hashServer.Contains(mib.strServerName.ToLower()))
                {
                    // make sure all  servers are valid match server (Xenon 106407)
                    // buckets that are already in the DB will have pre-checked servers, but /newmodeserver
                    // and /overridebuckets may introduce bad servers, so we need to double-check.
                    ConfirmServer(mib.strServerName);
                    hashServer.Add(mib.strServerName.ToLower(), null);
                }
        }

        // if the  server that was passed in is not already referred to by any buckets, add it to the server list.
        if(!String.IsNullOrEmpty(strNewServer) && !hashServer.Contains(strNewServer.ToLower()))
        {
            hashServer.Add(strNewServer.ToLower(), null);
        }
        
        string[] arrstrServers = new string[hashServer.Keys.Count];
        hashServer.Keys.CopyTo(arrstrServers, 0);
        return arrstrServers;
    }




    public static void ConfigureMatch(
        MatchGameConfig matchGameConfig,
        MatchLtcConfig matchLtcConfig,
        string strNewModeServer,
        string strMigrationDestServer,
        bool fRemoveModeOk,
        bool droptable,
        bool reload,
        bool fOverrideBuckets,
        bool fIgnoreNonDestErrors)
    {
        string[] addServers;
        string[] deleteServers;
        bool updateLtc;
        bool fUpdateBuckets = false;
        SqlDataAdapter sdaBuckets= null;
        DataSet dsBuckets = null;

        int cDbBuckets = 0;
        int iDbBucket = 0;
        int iLtcBucket = 0;
        uint dwLtcBucket = 0;
        uint dwDbBucket = 0;
        string strDBNextServer = "";
        string strDBCurrServer = "";
        string strLtcServer = "";

        // get the buckets that are currently configured for this title in the npdb
        GetTitleBucketsDataset(matchLtcConfig.TitleId, out dsBuckets, out sdaBuckets);
        cDbBuckets = dsBuckets.Tables["t_interface_buckets"].Rows.Count;


        // if this title hasn't been upgraded to the buckety way of doing things (according to the LTC)
        // give it buckets, and skip the full syncing of buckets between LTC and NPDB.
        if (matchLtcConfig.MatchInterfaceBuckets == null ||
            matchLtcConfig.MatchInterfaceBuckets.Count <= 0)
        {
            // resolve to get the list of servers that we'll operate on (addServers)
            ResolveServers(
                matchLtcConfig,
                strNewModeServer,  // TODOTHEOM: is this still needed for 360?  Will migrate ever get here?
                null,  // delete ... no longer used for 360
                null,  // fallback... no longer used for 360
                out addServers,
                out deleteServers, // not used
                out updateLtc);

            // if we're "overriding", just wipe the buckets from the DB
            if(fOverrideBuckets)
            {
                Log("[MatchAdmin.ConfigureMatch]: /overridebuckets specified with no buckets in LTC: removing all existing buckets from t_interface_buckets and replacing with default buckets.");

                foreach (DataRow drCurrent in dsBuckets.Tables["t_interface_buckets"].Rows)
                {
                    drCurrent.Delete();
                }
            }
            // if there are any buckets in the DB, this is an "out of sync" condition
            else if(cDbBuckets> 0)
            {
                throw new ExceptionWithEventId(XEvent.Id.COMMON_CONFIG_MATCH_LTC_TIB_COUNTS_OUTOFSYNC,
                "[MatchAdmin.ConfigureMatch]: Error - LTC has no buckets, but t_interface_buckets does.  You may use /overridebuckets to rewrite t_interface_buckets with default buckets.");
            }

            // make up default buckets based on MatchServerList, and put 'em in the LTC and database.
            MakeDefaultBuckets(ref matchLtcConfig, ref matchGameConfig, ref dsBuckets);
            fUpdateBuckets = true;
            updateLtc = true;
        }
        else // the title has partitions defined, so we need to give them the full syncing up
        {
            // TODOTHEOM: can we intelligently set UpdateLtc in the new buckets case?
            updateLtc = true;

            if (fOverrideBuckets) // let the ltc partitionmap override the buckets in t_interface_buckets.
            {
                Log("[MatchAdmin.ConfigureMatch]: /overridebuckets specified: removing all existing buckets from t_interface_buckets and replacing with buckets from the LTC.");

                // clear out the t_interface_buckets list, and replace those
                // buckets with brand new buckets from the LTC
                // Using DataRowCollection.Clear() does not trigger the correct actions on 
                // dataadapter update, so delete them individually.
                // (either way, this translated to a series of stored proc calls)
                foreach (DataRow drCurrent in dsBuckets.Tables["t_interface_buckets"].Rows)
                {
                    drCurrent.Delete();         
                }
                foreach (MatchInterfaceBucket mib in matchLtcConfig.MatchInterfaceBuckets)
                {
                    DataRow drNewBucket = dsBuckets.Tables["t_interface_buckets"].NewRow();

                    drNewBucket["vc_environment"] = Config.Environment;
                    drNewBucket["vc_interface"] = Interface.xmatch;
                    drNewBucket["i_title_id"] = (int)matchLtcConfig.TitleId;
                    drNewBucket["i_bucket"] = (int)mib.dwBucketId;
                    drNewBucket["vc_server"] = mib.strServerName;
                    drNewBucket["vc_next_server"] = mib.strServerName;
                    drNewBucket["dt_migration_start"] = new DateTime(1900, 1, 1, 12, 00, 00);
                    drNewBucket["vc_info1"] = "";
                    drNewBucket["vc_info2"] = "";
                    drNewBucket["vc_info3"] = "";
                    drNewBucket["vc_info4"] = "";

                    dsBuckets.Tables["t_interface_buckets"].Rows.Add(drNewBucket);
                }
                fUpdateBuckets = true;
            }
            else // make sure t_interface_buckets and the LTC partition map are in sync.
            {
                if (cDbBuckets != matchLtcConfig.MatchInterfaceBuckets.Count)
                {
                    throw new ExceptionWithEventId(XEvent.Id.COMMON_CONFIG_MATCH_LTC_TIB_COUNTS_OUTOFSYNC,
                    "[MatchAdmin.ConfigureMatch]: LTC is out of sync with t_interface_buckets.  You may use /overridebuckets to rewrite t_interface_buckets based on the LTC partitions.");
                }
            
                while (iDbBucket < cDbBuckets &&
                        iLtcBucket < matchLtcConfig.MatchInterfaceBuckets.Count)
                { 
                    dwLtcBucket = matchLtcConfig.MatchInterfaceBuckets[iLtcBucket].dwBucketId;
                    dwDbBucket = (uint)(int)(dsBuckets.Tables["t_interface_buckets"].Rows[iDbBucket]["i_bucket"]);
                    strLtcServer = matchLtcConfig.MatchInterfaceBuckets[iLtcBucket].strServerName;
                    strDBNextServer = (string)(dsBuckets.Tables["t_interface_buckets"].Rows[iDbBucket]["vc_next_server"]);
                    strDBCurrServer = (string)(dsBuckets.Tables["t_interface_buckets"].Rows[iDbBucket]["vc_server"]);
                    
                    // if buckets are the same and servers are the same, all is well... advance both iterators
                    if (dwDbBucket == dwLtcBucket)
                    {
                        if(String.Compare(strDBNextServer, strLtcServer, true /*case insensitive */) == 0 &&
                            String.Compare(strDBNextServer, strDBCurrServer, true) == 0) // make sure the bucket's not in migration... we don't want deployments during migration.
                        {
                            iDbBucket++;
                            iLtcBucket++;
                        }
                        else
                        {
                            if(String.Compare(strDBNextServer, strDBCurrServer, true) == 0)
                            {
                                throw new ExceptionWithEventId(XEvent.Id.COMMON_CONFIG_MATCH_LTC_TIB_SERVERS_OUTOFSYNC_1,  
                                    "[MatchAdmin.ConfigureMatch]: Server name in LTC is out of sync with the server names in t_interface_buckets, for bucket ID " + 
                                    dwDbBucket + ".  You may use /overridebuckets to rewrite t_interface_buckets based on the LTC partitions.");
                            }
                            else
                            {
                                throw new ExceptionWithEventId(XEvent.Id.COMMON_CONFIG_MATCH_LTC_TIB_SERVERS_OUTOFSYNC_2,  
                                    "[MatchAdmin.ConfigureMatch]: Server name in LTC is out of sync with one of the server names in t_interface_buckets, for bucket ID " + 
                                    dwDbBucket + ".  This is probably due to the bucket being in migration, in which case migration should be completed before deploying.");
                            }
                        }
                    }
                    else
                    {
                        throw new ExceptionWithEventId(XEvent.Id.COMMON_CONFIG_MATCH_LTC_TIB_OUTOFSYNC,  
                            "[MatchAdmin.ConfigureMatch]: LTC is out of sync with t_interface_buckets.  You may use /overridebuckets to rewrite t_interface_buckets based on the LTC partitions.");
                    }
                }
            }

            // do the types/modes represented by the buckets in the LTC match the 
            // types/modes in the xlast?  If not, the buckets of some types/modes will need to be removed
            // from the LTC and t_interface_buckets.

            // do it the slowest way possible
            // TODOTHEOM: don't do it the slowest way possible

            // first, make sure each mode in the xlast has at least one bucket.  For those that don't
            // we should create a bucket
            uint dwBucketId = 0;
            bool fFoundBucket = false;
            for (byte bType = 0; bType < 2; bType++)  // TODOTHEOM: number of types should be a constant somewhere.
            {
                for (byte iCurrentXlastMode = 0;
                    iCurrentXlastMode < matchGameConfig.GameModes.Count;
                    iCurrentXlastMode++)
                {
                    fFoundBucket = false;
                    dwBucketId = (uint)(bType << 16) |
                                    (uint)(matchGameConfig.GameModes[iCurrentXlastMode].Id << 8) |
                                    (uint)0; // just to be explicit... we're looking for the 0 rrid.  We know if there are any buckets there will be one with rrid=0.
                    foreach(MatchInterfaceBucket mib in matchLtcConfig.MatchInterfaceBuckets)
                    {
                        if(mib.dwBucketId == dwBucketId)
                        {
                            fFoundBucket = true;
                            break;
                        }
                    }
                    if(!fFoundBucket)
                    {
                        // we have a new mode.  Add a bucket to the LTC bucket list
                        fUpdateBuckets = true;
                        if(strNewModeServer == null || strNewModeServer == String.Empty)
                        {
                            throw new ExceptionWithEventId(XEvent.Id.COMMON_CONFIG_MATCH_UNEXPECTED_MODE_IN_XLAST,
                            "[MatchAdmin.ConfigureMatch]: Error: new mode added to xlast, but no /newmodeserver specified. '");
                        }
                        MatchInterfaceBucket mib = new MatchInterfaceBucket();
                        mib.bGameTypeId = bType;
                        mib.bGameModeId = matchGameConfig.GameModes[iCurrentXlastMode].Id;
                        mib.bRRId = 0;
                        mib.dwBucketId = dwBucketId;
                        mib.strServerName = strNewModeServer;
                        matchLtcConfig.MatchInterfaceBuckets.Add(mib);
                        
                        // add the bucket to the database too
                        DataRow drNewBucket = dsBuckets.Tables["t_interface_buckets"].NewRow();

                        drNewBucket["vc_environment"] = Config.Environment;
                        drNewBucket["vc_interface"] = Interface.xmatch;  
                        drNewBucket["i_title_id"] = (int)matchLtcConfig.TitleId;
                        drNewBucket["i_bucket"] = (int)dwBucketId;
                        drNewBucket["vc_server"] = strNewModeServer;
                        drNewBucket["vc_next_server"] = strNewModeServer;
                        drNewBucket["dt_migration_start"] = new DateTime(1900, 1, 1, 12, 00, 00);
                        drNewBucket["vc_info1"] = "";
                        drNewBucket["vc_info2"] = "";
                        drNewBucket["vc_info3"] = "";
                        drNewBucket["vc_info4"] = "";

                        dsBuckets.Tables["t_interface_buckets"].Rows.Add(drNewBucket);
                    }
                }
            }

            // re-sort the list of matchinterfacebuckets
            MatchInterfaceBucketComparer mibc = new MatchInterfaceBucketComparer();
            matchLtcConfig.MatchInterfaceBuckets.Sort(mibc);


            // next, make sure each bucket in the bucket list has a mode in the xlast.  For any that don't
            // we should delete the bucket.
            bool fFoundMode = false;
            int iDBBucket = 0;
            MatchInterfaceBucket mibTemp = null;
            for(iLtcBucket = 0; iLtcBucket < matchLtcConfig.MatchInterfaceBuckets.Count; iLtcBucket++)
            {
                mibTemp = matchLtcConfig.MatchInterfaceBuckets[iLtcBucket];
                fFoundMode = false;
                for (byte bType = 0; bType < 2; bType++)  // TODOTHEOM: number of types should be a constant somewhere.
                {
                    for (byte iCurrentXlastMode = 0;
                        iCurrentXlastMode < matchGameConfig.GameModes.Count;
                        iCurrentXlastMode++)
                    {
                        if(mibTemp.bGameTypeId == bType && mibTemp.bGameModeId == matchGameConfig.GameModes[iCurrentXlastMode].Id)
                        {
                            fFoundMode = true;
                            break;
                        }
                    }
                    if(fFoundMode)
                    {
                        break;
                    }
                }
                if(!fFoundMode)
                {
                    
                    // we have a type/mode combo in LTC/DB that's not in xlast.  Need to remove from LTC/DB
                    fUpdateBuckets = true;
                    if(!fRemoveModeOk)
                    {
                        throw new ExceptionWithEventId(XEvent.Id.COMMON_CONFIG_MATCH_MISSING_MODE_IN_XLAST,
                        "[MatchAdmin.ConfigureMatch]: Error: mode removed from xlast, but no /removemode param passed. '");
                    }
                    matchLtcConfig.MatchInterfaceBuckets.RemoveAt(iLtcBucket);
                    iLtcBucket--;
                    dsBuckets.Tables["t_interface_buckets"].Rows[iDBBucket].Delete();
                }
                iDBBucket++; // the database buckets aren't shifted down on delete, so they need a separate index.
            }

            // get the list of servers we'll be operating on.
            addServers = ResolveMatchBuckets(matchGameConfig, matchLtcConfig, strMigrationDestServer);

        }


        // ok, we're all settled... deploy the code to the relevant servers

        string[] rgstrGenericSqlStatements = MatchSqlCodeGen.All(matchGameConfig, matchLtcConfig, droptable);
        string[] rgstrCleanupJobSqlStatements = MatchSqlCodeGen.SessionCleanupJob(matchGameConfig, matchLtcConfig);

        // for Sql agent job creation, we want to pass some info about how many servers are running this job
        // this helps determine the job schedules, since we want the job to run at different times on different servers.
        int iServer = 0;
        SqlParameter[] rgParams = new SqlParameter[2];
        rgParams[0] = new SqlParameter("@adoparam_servercount", addServers.Length);
        rgParams[1] = new SqlParameter("@adoparam_serverindex", iServer);

        // NOTE: addServer contains all servers that the title is on, not just
        // the new ones.

        foreach (string addServer in addServers)
        {
            try
            {
                ApplyTitleConfigToMatchDB(rgstrGenericSqlStatements, addServer);
                // if the title is configured to do session limits automatically, run the SQL scripts that create the session
                // limit control jobs.  
                if (matchLtcConfig.MatchSessionLimitJobExists == true)
                {
                    ApplyTitleConfigToMatchDBWithParams(rgstrCleanupJobSqlStatements, addServer, rgParams);
                }
                rgParams[1].Value = ++iServer;
            }
            catch (Exception e)
            {
                if (!String.IsNullOrEmpty(strMigrationDestServer) && String.Compare(addServer, strMigrationDestServer, true /*case insensitive */) == 0)
                {
                    Log("[MatchAdmin.ConfigureMatch]: Error: Could not write SQL to destination server: " + addServer + ".");
                    throw e;
                }
                else if (!String.IsNullOrEmpty(strMigrationDestServer) && fIgnoreNonDestErrors)
                {
                    Log("[MatchAdmin.ConfigureMatch]: Warning: Could not write SQL to server: " + addServer + ".  Ignoring " +
                        "failed server.");
                    Log(e.Message);
                }
                else if (!String.IsNullOrEmpty(strMigrationDestServer))
                {
                    Log("[MatchAdmin.ConfigureMatch]: Error: Could not write SQL to server: " + addServer + ".  Please check " +
                        "if it is down.  If so, use the /ignorenondesterrors flag to bypass errors on failed servers.");
                    throw e;
                }
                else
                {
                    throw e;
                }
            }
        }

        if (updateLtc)
        {
            UpdateLtc(matchLtcConfig);
        }

        if(fUpdateBuckets)
        {
            sdaBuckets.Update(dsBuckets.Tables["t_interface_buckets"]);
        }
        
        ApplyTitleConfigToNPDB(matchLtcConfig, addServers);

        if (reload)
        {
            HealthCheck();
            ReloadTitleInfo();
        }
    }

    public static void ConfigureXboxMatch(
        string xmsPath,
        MatchLtcConfig matchLtcConfig,
        bool droptable,
        bool reload, 
        bool fHandsOffTitleSql,
        string add,
        string delete,
        string fallback)
    {
        string[] addServers;
        string[] deleteServers;
        bool updateLtc;
        SqlConnection cxn = null;
        SqlDataAdapter sdaBuckets = null;
        DataSet dsBuckets = null;

        ResolveServers(
                matchLtcConfig, 
                add, 
                delete,
                fallback,
                out addServers, // the final resolved list of servers
                out deleteServers,  // not used
                out updateLtc);

        // All titles (even xbox1) use t_interface_buckets, so we need to populate
        // that table with one bucket for each server in the serverlist
        try
        {
            GetTitleBucketsDataset(matchLtcConfig.TitleId, out dsBuckets, out sdaBuckets);

            // basically we want to rebuild the server list based on addServers.  This server list used to be in 
            // t_match_titles, but it's now moved to t_interface_buckets, with each bucket = 1 server.
            // deleting a recreating all the buckets is the easiest way to do this, so that's what I'll do for now.
            
            // NOTE: the code is susceptible to reordering of servers in the addServers list, but the old
            // way of doing it had the same issue.  Reordering is bad, and causes lost sessions.
            int iBucket = 0;
            for (iBucket = 0; iBucket < Math.Min(dsBuckets.Tables["t_interface_buckets"].Rows.Count, addServers.Length); iBucket++)
            {
                // 
                if(String.Compare((string)dsBuckets.Tables["t_interface_buckets"].Rows[iBucket]["vc_server"], addServers[iBucket], true) != 0)
                {
                    dsBuckets.Tables["t_interface_buckets"].Rows[iBucket]["vc_server"] = addServers[iBucket];
                    dsBuckets.Tables["t_interface_buckets"].Rows[iBucket]["vc_next_server"] = addServers[iBucket];
                }
            }
            // now if there are any additional servers in addServers, add buckets for them.
            if(addServers.Length > dsBuckets.Tables["t_interface_buckets"].Rows.Count)
            {
                while(iBucket < addServers.Length)
                {
                    // add the bucket to the database too
                    DataRow drNewBucket = dsBuckets.Tables["t_interface_buckets"].NewRow();

                    // all xbox 1 buckets have the same game type and mode.
                    byte bGameType = (byte)(MatchDefs.XMATCH_MAX_GAMETYPE + 1);;
                    byte bGameMode = (byte)(MatchDefs.XMATCH_MAX_GAMEMODE + 1);
                    
                    drNewBucket["vc_environment"] = Config.Environment;
                    drNewBucket["vc_interface"] = Interface.xmatch;  
                    drNewBucket["i_title_id"] = (int)matchLtcConfig.TitleId;
                    drNewBucket["i_bucket"] = (uint)(bGameType << 16) |
                                                             (uint)(bGameMode << 8) |
                                                             (uint)iBucket; 
                    drNewBucket["vc_server"] = addServers[iBucket];
                    drNewBucket["vc_next_server"] = addServers[iBucket];
                    drNewBucket["dt_migration_start"] = new DateTime(1900, 1, 1, 12, 00, 00);;
                    drNewBucket["vc_info1"] = "";
                    drNewBucket["vc_info2"] = "";
                    drNewBucket["vc_info3"] = "";
                    drNewBucket["vc_info4"] = "";

                    dsBuckets.Tables["t_interface_buckets"].Rows.Add(drNewBucket);
                    iBucket++;
                }
            }
            // or if there are more buckets than there are servers, drop the buckets
            else if(addServers.Length < dsBuckets.Tables["t_interface_buckets"].Rows.Count)
            {
                while(iBucket < dsBuckets.Tables["t_interface_buckets"].Rows.Count)
                {
                    dsBuckets.Tables["t_interface_buckets"].Rows[iBucket].Delete();
                    iBucket++;
                }
            }
            // commit the changes to the database
            sdaBuckets.Update(dsBuckets.Tables["t_interface_buckets"]);
        }
        finally
        {
            if(cxn!= null)
            {
                cxn.Close();
            }
        }

        if(!fHandsOffTitleSql)
        {
            ConvertXmsToSql(matchLtcConfig.TitleId, xmsPath, droptable);
            RunXmsToSqlScript(matchLtcConfig.TitleId, addServers);
        }

        if (updateLtc)
        {
            UpdateLtc(matchLtcConfig);
        }

        ApplyTitleConfigToNPDB(matchLtcConfig, addServers);

        if (reload)
        {
            HealthCheck();
            ReloadTitleInfo();
        }
    }

    public static void ResolveServers(
        MatchLtcConfig matchLtcConfig,
        string add,
        string delete,
        string fallback,
        out string[] addServers,
        out string[] deleteServers,
        out bool updateLtc)
    {
        ArrayList existingList = new ArrayList();
        ArrayList addList = new ArrayList();
        ArrayList deleteList = new ArrayList();

        // Default no update of LTC 
        updateLtc = false;

        //
        // Get the list of servers from the ltc file
        //
        if (matchLtcConfig.MatchServerList.Trim() != String.Empty)
        {
            string[] serversInLtc = ServerListFromString(matchLtcConfig.MatchServerList);

            // check that all the servers in the ltc file are valid
            foreach (string server in serversInLtc)
            {
                Log("[MatchAdmin.ResolveServers]: Resolving interface for server: '" + server + "'");
                try
                {
                    Config.GetInterface(server, Interface.xmatch);
                    if(!existingList.Contains(server))
                    {
                        existingList.Add(server);
                    }
                }
                catch (ApplicationException)
                {
                    LogError("[MatchAdmin.ResolveServers]: Error: Bad server name: '" + server + "' will be deleted from server list");
                    if(!deleteList.Contains(server))
                    {
                        updateLtc = true;
                        deleteList.Add(server);
                    }
                }
            }
        }

        //
        // If the LTC file lookups fail to give any servers we can add the fallback
        // servers to the add list.
        //
        if(0 == existingList.Count && null != fallback && String.Empty != fallback.Trim())
        {
            LogError("[MatchAdmin.ResolveServers]: Unable to resolve any servers from LTC adding fallback servers: '" + fallback + "'");

            add += ";";
            add += fallback;
        }

        //
        // Parse the add server list from the command line
        //
        if (null != add && String.Empty != add.Trim())
        {
            string[] addServersFromUser = ServerListFromString(add);

            // check that all the add servers are valid
            foreach(string server in addServersFromUser)
            {
                try
                {
                    Config.GetInterface(server, Interface.xmatch);
                    if(existingList.Contains(server))
                    {
                        LogError("[MatchAdmin.ResolveServers]: Error: duplicate server: '" + server + "' it already exists in the stored LTC");
                        continue;
                    }
                    if(addList.Contains(server))
                    {
                        LogError("[MatchAdmin.ResolveServers]: Error: duplicate server: '" + server + "' it already exists in the stored LTC");
                        continue;
                    }

                    addList.Add(server);
                    updateLtc = true;
                }
                catch (ApplicationException)
                {
                    LogError("[MatchAdmin.ResolveServers]: Error: Bad server name: '" + server + "' from user cannot be added to server list"); 
                }
            }
        }

        //
        // Parse the delete server list from the command line
        //
        if (null != delete && String.Empty != delete.Trim())
        {
            string [] deleteServersFromUser = ServerListFromString(delete);

            // check that all the delete servers are valid
            foreach (string server in deleteServersFromUser)
            {
                try
                {
                    Config.GetInterface(server, Interface.xmatch);
                }
                catch (ApplicationException)
                {
                    LogError("[MatchAdmin.ResolveServers]: Error: server name '" + server + "' specified with /delete is not a valid match database server name in configdb");
                }

                // We are still going to try and remove the server if the name doesn't exist 
                // in the config database
                if(!existingList.Contains(server))
                {
                    LogError("[MatchAdmin.ResolveServers]: Error: cannot delete server '" + server + "' it doesn't exist in the LTC file");
                    continue;
                }
                else
                {
                    existingList.Remove(server);
                }

                if(!deleteList.Contains(server))
                {
                    deleteList.Add(server);
                }
                if(addList.Contains(server))
                {
                    addList.Remove(server);
                }
                updateLtc = true;
            }
        }

        // Any existing servers that were not deleted should be 'added' as well
        addList.AddRange(existingList);
        
        deleteServers = (string[])deleteList.ToArray(typeof(string));
        addServers = (string[])addList.ToArray(typeof(string));

        if (addServers.Length == 0)
        {
            LogError("[MatchAdmin.ResolveServers]: WARNING: this title is not assigned to any matchmaking servers, "
                + "you must add servers before this title will support matchmaking.");
        }
        else
        {
            updateLtc = true;
            matchLtcConfig.MatchServerList = ServerListToString(addServers);
            Log("[MatchAdmin.ResolveServers]: New server list for this title: " + 
                    matchLtcConfig.MatchServerList);
        }

        return;
    }

    private static string[] GetServersFromNPDB(uint titleId)
    {
        // see if t_match_titles in npdb has a row for this title

        SqlConnection cxn = new SqlConnection(Config.NpdbConnectionString);
        cxn.Open();

        SqlCommand cmd = cxn.CreateCommand();
        cmd.CommandText = "p_match_title_get";
        cmd.CommandType = CommandType.StoredProcedure;

        SqlParameter param = new SqlParameter();
        param.ParameterName = "@i_title_id";
        param.Direction = ParameterDirection.Input;
        param.DbType = DbType.Int32;
        param.Value = (int)titleId;
        cmd.Parameters.Add(param);

        SqlDataReader reader = cmd.ExecuteReader();

        string[] serverList = null;
        if (reader.Read())
        {
            string servers = (string)reader["vc_db_list"];
            if (servers.Trim() == String.Empty)
            {
                serverList = new string[0];
            }
            else
            {
                serverList = ServerListFromString(servers);
            }
        }
        else
        {
            serverList = new string[0];
        }
        return serverList;
    }

    public static string GetGameConfig(uint titleId)
    {
        string xlast = null;
        using (SqlConnection npdbConnection = new SqlConnection(Config.NpdbConnectionString))
        {
            npdbConnection.Open();

            SqlCommand cmd = npdbConnection.CreateCommand();

            cmd.CommandText = "p_game_get_config";
            cmd.CommandType = CommandType.StoredProcedure;

            cmd.Parameters.Add("@i_title_id", SqlDbType.Int).Value = (int)titleId;
            SqlDataReader reader = cmd.ExecuteReader();
            if (reader.Read())
            {
                xlast = (string)reader["xml_config"];
            }

            reader.Close();
        }
        return xlast;
    }

    public static string[] GetAllGameConfigs(DateTime dtChanged)
    {
        ArrayList alXlast = new ArrayList();
        using (SqlConnection npdbConnection = new SqlConnection(Config.NpdbConnectionString))
        {
            npdbConnection.Open();

            SqlCommand cmd = npdbConnection.CreateCommand();

            cmd.CommandText = "p_game_get_all_configs";
            cmd.CommandType = CommandType.StoredProcedure;

            cmd.Parameters.Add("@dt_changed", SqlDbType.DateTime).Value = dtChanged;
            SqlDataReader reader = cmd.ExecuteReader();
            while (reader.Read())
            {
                alXlast.Add((string)reader["xml_config"]);
            }

            reader.Close();
        }

        return (string[])alXlast.ToArray(typeof(string));
    }

    public static MatchGameConfig[] GetAllMatchGameConfigs(DateTime dtChanged)
    {
        ArrayList alMatchGameConfigs = new ArrayList();
        string[] gameConfigs = GetAllGameConfigs(dtChanged);
        MatchXlastConfigLoader loader = new MatchXlastConfigLoader();
        XmlDocument doc = new XmlDocument();
        MatchGameConfig matchGameConfig;
        

        foreach (string gameConfig in gameConfigs)
        {
            StringWriter tempLog = new StringWriter();

            try
            {
                // Load the match config, use a string writer to cache the log
                doc.LoadXml(gameConfig);
                loader.Load(doc, tempLog, out matchGameConfig);

                if (matchGameConfig.MatchQueries.Count > 0)
                {
                    alMatchGameConfigs.Add(matchGameConfig);
                }
            }
            catch (ExceptionWithEventId ex)
            {
                tempLog.Flush();

                // Log the error and move on to the next config
                LogError("[MatchAdmin.GetAllMatchGameConfigs]: Exception: " + ex.ToString() + ", Log: " + tempLog.ToString());
            }
        }
        return (MatchGameConfig[])alMatchGameConfigs.ToArray(typeof(MatchGameConfig));
    }

    public static string GetLiveTitleConfig(uint titleId)
    {
        string ltc = null;
        using (SqlConnection npdbConnection = new SqlConnection(Config.NpdbConnectionString))
        {
            npdbConnection.Open();

            SqlCommand cmd = npdbConnection.CreateCommand();

            cmd.CommandText = "p_live_title_config_get";
            cmd.CommandType = CommandType.StoredProcedure;

            cmd.Parameters.Add("@i_title_id", SqlDbType.Int).Value = (int)titleId;
            SqlDataReader reader = cmd.ExecuteReader();
            if (reader.Read())
            {
                ltc = (string)reader["xml_title_config"];
            }

            reader.Close();
        }

        // Bug 114431 -- check for null or empty string 
        // this used to be done in livematch's implementation of this function
        // but now that that function has been eliminated, it should be done here.
        if (ltc == null)
        {
            throw new ExceptionWithEventId(XEvent.Id.TOOLS_CONFIG_42,
                "Unable to find live title configuration for title id 0x"
                + titleId.ToString("X8") + " in NPDB");
        }


        return ltc;
    }

    public static void SetLiveTitleConfig(uint titleId, string ltc)
    {
        Log("[MatchAdmin.SetLiveTitleConfig]: Writing updated LTC XML to npdb for title: 0x" + titleId.ToString("X"));

        using (SqlConnection npdbConnection = new SqlConnection(Config.NpdbConnectionString))
        {
            npdbConnection.Open();

            SqlCommand cmd = npdbConnection.CreateCommand();

            cmd.CommandText = "p_live_title_config_set";
            cmd.CommandType = CommandType.StoredProcedure;

            cmd.Parameters.Add("@i_title_id", SqlDbType.Int).Value = (int)titleId;
            cmd.Parameters.Add("@xml_title_config", SqlDbType.NText).Value = ltc;

            cmd.ExecuteNonQuery();
        }
    }

    private static void ApplyTitleConfigToMatchDB(
        string[] sqlStatements,
        string server)
    {
        Log("[MatchAdmin.ApplyTitleConfigToMatchDB]: Writing: " 
                + sqlStatements.Length + " statements to server: " + server);

        using (SqlConnection cxn = MatchSql.OpenSqlConnectionToMatchDBNoFastfail(server))
        {
            RunSqlStatements(sqlStatements, cxn, null);
        }
    }

    private static void ApplyTitleConfigToMatchDBWithParams(
        string[] sqlStatements,
        string server,
        SqlParameter[] rgParams)
    {
        Log("[MatchAdmin.ApplyTitleConfigToMatchDBWithParam]: Writing: " 
                + sqlStatements.Length + " statements to server: " + server);
        
        using (SqlConnection cxn = MatchSql.OpenSqlConnectionToMatchDBNoFastfail(server))
        {
            RunSqlStatements(sqlStatements, cxn, rgParams);
        }
    }

    static public void StartMigrationForBucket(uint dwTitleID, uint dwBucketID, string strNextServer, MatchLtcConfig matchLtcConfig)
    {
        // First, check to see if any buckets for this title are in the "drain" state - if so, log this fact and exit.
        if (TitleHasDrainingBuckets(dwTitleID, null))
        {
            Log(string.Format("[MatchAdmin.StartMigrationForBucket]:   Can't start migration for title {0:X} because a bucket drain for this title is in progress.", dwTitleID));
            return;
        }

        SqlConnection cxn = null;
        uint nCacheRefreshInterval = Convert.ToUInt32(Config.GetSetting(Setting.config_cacheRefreshInterval));
        uint nBuffer = 60000; // buffer a minute to make sure all the FDs get the setting.
        DateTime dtMigrationStart = DateTime.Now.AddMilliseconds(nCacheRefreshInterval + nBuffer);
        strNextServer = strNextServer.ToLower(); // standardize on lower case server names.

        try
        {
            cxn = OpenSqlConnectionToNPDB();

            SqlCommand cmd = cxn.CreateCommand();
            cmd.CommandType = CommandType.StoredProcedure;
            cmd.CommandText = "dbo.p_match_migrate_bucket_start";

            cmd.Parameters.AddWithValue("@i_title_id", SqlDbType.Int);
            cmd.Parameters["@i_title_id"].Direction = ParameterDirection.Input;
            cmd.Parameters["@i_title_id"].Value = (int)dwTitleID;

            cmd.Parameters.AddWithValue("@i_bucket_id", SqlDbType.Int);
            cmd.Parameters["@i_bucket_id"].Direction = ParameterDirection.Input;
            cmd.Parameters["@i_bucket_id"].Value = (int)dwBucketID;

            cmd.Parameters.AddWithValue("@vc_next_server", SqlDbType.VarChar);
            cmd.Parameters["@vc_next_server"].Direction = ParameterDirection.Input;
            cmd.Parameters["@vc_next_server"].Value = strNextServer;

            cmd.Parameters.AddWithValue("@dt_migration_start", SqlDbType.DateTime);
            cmd.Parameters["@dt_migration_start"].Direction = ParameterDirection.Input;
            cmd.Parameters["@dt_migration_start"].Value = dtMigrationStart;

            cmd.Parameters.AddWithValue("@result", SqlDbType.Int);
            cmd.Parameters["@result"].Direction = ParameterDirection.ReturnValue;

            cmd.ExecuteNonQuery();

            int nReturnValue = (int)cmd.Parameters["@result"].Value;

            if (nReturnValue != 0)
            {
                // xonline:100605 -- create some friendly error messages for the return codes from the 
                // stored proc.  Long term, either these should be hresults, and/or we should switch
                // to using the SqlDataAdapter that's used elsewhere in this file.
                string strError = "";
                switch (nReturnValue)
                {
                    case 1:
                        strError = "Bucket may be invalid.";
                        break;
                    case 2:
                        strError = "Environment not found.";
                        break;
                    case 3:
                        strError = "Server not found.";
                        break;
                    case 4:
                        strError = "The bucket you are migrating is already in migration.";
                        break;
                    default:
                        strError = "Stored proc failed with an unknown error.";
                        break;
                };
                throw new ExceptionWithEventId(XEvent.Id.COMMON_CODE_MATCH_STARTMIGRATE_FAILED, 
                    "[MatchAdmin.StartMigrationForBucket]: Failed to start migration.  " + strError);
            }
        }
        finally
        {
            if (cxn != null)
            {
                cxn.Close();
                cxn= null;
            }
        }
    }

    static public void EndMigrationForBucket(uint dwTitleID, uint dwBucketID, MatchLtcConfig matchLtcConfig)
    {
        string strNextServer = "";
        int iDbBucket = 0;
        bool fFoundBucket = false;
        DataSet dsBuckets = null;
        SqlDataAdapter sdaBuckets = null;

        GetTitleBucketsDataset(dwTitleID, out dsBuckets, out sdaBuckets);

        // first, update the LTC (everywhere) to move the bucket in question over to the new server
        // this is done first because it's the most likely the fail and least easy to redo.

        // we need to go to the dataset to get the destination server for the migration, since that's not 
        // serialized into the LTC.
        foreach(MatchInterfaceBucket mib in matchLtcConfig.MatchInterfaceBuckets)
        {
            if(mib.dwBucketId == dwBucketID && 
                mib.dwBucketId == (uint)(int)(dsBuckets.Tables["t_interface_buckets"].Rows[iDbBucket]["i_bucket"]))
            {
                strNextServer = (string)dsBuckets.Tables["t_interface_buckets"].Rows[iDbBucket]["vc_next_server"];
                if(strNextServer == null || strNextServer == String.Empty)
                {
                    throw new ExceptionWithEventId(XEvent.Id.COMMON_CONFIG_MATCH_ENDMIGRATE_FAILED_NONEXT,  
                        "[MatchAdmin.EndMigrationForBucket]: The bucket you're trying to migrate does not have a 'next' server.");
                }
                mib.strServerName = strNextServer;
                dsBuckets.Tables["t_interface_buckets"].Rows[iDbBucket]["vc_server"] = strNextServer;
                fFoundBucket = true;
                break;
            }
            iDbBucket++;
        }
        if(!fFoundBucket)
        {
            throw new ExceptionWithEventId(XEvent.Id.COMMON_CONFIG_MATCH_ENDMIGRATE_FAILED_MISSING_BUCKET,
                "[MatchAdmin.EndMigrationForBucket]: Either the bucket you're trying to migrate does not exist, or t_interface_buckets and LTC are out of sync.");
        }

        // first titlevault then npdb
        UpdateLtc(matchLtcConfig);
        
        // finally t_interface_buckets
        sdaBuckets.Update(dsBuckets.Tables["t_interface_buckets"]);
        
        // TODOTHEOM: should this code also delete any unmigrated sessions on the current server?
        // or can we count on the searches to filter these out, and on session expiration to remove them?
    }


// MigrationStatusForBucket -- returns a count of the number of sessions that still need
// to be migrated, and prints it out.  
    static public uint MigrationStatusForBucket(uint dwTitleID, uint dwBucketID)
    {
        SqlConnection cxn = null;
        int nBreadcrumbSessions = 0;
        int nSandwichSessions = 0;
        try
        {
            byte bGameTypeID = 0;
            byte bGameModeID = 0;
            byte bRRID = 0;
            string strTitleID = "";
            uint dwSessionizedBucketID = 0;
            SqlDataReader reader = null;

            // first, get the rowset containing a list of the sessions that are ready to be migrated
            // for the bucket in question.

            bGameTypeID = (byte)(dwBucketID >> 16);
            bGameModeID = (byte)((dwBucketID >> 8) & 0xFF);
            bRRID = (byte)(dwBucketID & 0xFF);
            
            strTitleID = "0x" + dwTitleID.ToString("X");
            // make the bucketID look like the tail end of a sessionID, to 
            // make it easy to compare with the sessionID.  
            // TODOTHEOM: In retrospect, maybe all bucketIDs should look like this for consistency?
            dwSessionizedBucketID = (uint)(bGameModeID << 10) |
                                                    (uint)((bGameTypeID & 0x03) << 8) | // mask out the two lower bits just to be explicit.
                                                    (uint)bRRID;

  
            IBucketServer ibsMigrating = Config.GetTitleBucketServer(Interface.xmatch, dwTitleID, dwBucketID);
            cxn = MatchSql.OpenSqlConnectionToMatchDBNoFastfail((string)ibsMigrating.CurrentServerName);            

            SqlCommand cmdMatch = cxn.CreateCommand();
            cmdMatch.CommandType = CommandType.StoredProcedure;
            cmdMatch.CommandText = "p_match_get_migratable_sessions_for_bucket";

            cmdMatch.Parameters.Add("@i_bucket_id", SqlDbType.Int);
            cmdMatch.Parameters["@i_bucket_id"].Direction = ParameterDirection.Input;
            cmdMatch.Parameters["@i_bucket_id"].Value = (int)dwBucketID;

            cmdMatch.Parameters.Add("@i_sessionized_bucket_id", SqlDbType.Int);
            cmdMatch.Parameters["@i_sessionized_bucket_id"].Direction = ParameterDirection.Input;
            cmdMatch.Parameters["@i_sessionized_bucket_id"].Value = (int)dwSessionizedBucketID;

            // pass titleid as a character string to make it easier for the stored proc to 
            // compose the table name.
            cmdMatch.Parameters.Add("@c_title_id", SqlDbType.Char, 10);
            cmdMatch.Parameters["@c_title_id"].Direction = ParameterDirection.Input;
            cmdMatch.Parameters["@c_title_id"].Value = strTitleID;

            cmdMatch.Parameters.Add("@ti_game_type_id", SqlDbType.TinyInt);
            cmdMatch.Parameters["@ti_game_type_id"].Direction = ParameterDirection.Input;
            cmdMatch.Parameters["@ti_game_type_id"].Value = bGameTypeID;

            // tell the stored proc to just get the counts, not the actual rowsets
            cmdMatch.Parameters.Add("@f_count_only", SqlDbType.Bit);
            cmdMatch.Parameters["@f_count_only"].Direction = ParameterDirection.Input;
            cmdMatch.Parameters["@f_count_only"].Value = true;            

            cmdMatch.Parameters.Add("@result", SqlDbType.Int);
            cmdMatch.Parameters["@result"].Direction = ParameterDirection.ReturnValue;

            reader = cmdMatch.ExecuteReader();

            // process the two result sets here.  Each one will have a single row
            // with a single column, which contains the count of rows of that type (BC or SW)

            reader.Read(); // advance to the first and only row.
            nBreadcrumbSessions = (int)reader["numsessions"];
            reader.NextResult();
            reader.Read();
            nSandwichSessions = (int)reader["numsessions"];
            reader.Close();

            int nReturnValue = (int)cmdMatch.Parameters["@result"].Value;

            if (nReturnValue != 0)
            {
                throw new ExceptionWithEventId(XEvent.Id.COMMON_CODE_MATCH_MIGRATESTATUS_FAILED_SPROC,
                    "[MatchAdmin.MigrationStatusForBucket]: stored proc returned error code: " + nReturnValue + ".");
            }

            Log("[MatchAdmin]: -- Migration status session counts for title: 0x" + dwTitleID.ToString("X") + " and bucketid: 0x" + dwBucketID.ToString("X") + " --");
            Log("[MatchAdmin]:      Total Sessions: " + (nBreadcrumbSessions + nSandwichSessions));
            Log("[MatchAdmin]:      Breadcrumb Sessions: " + nBreadcrumbSessions);
            Log("[MatchAdmin]:      Sandwich Sessions: " + nSandwichSessions);
            
        }
        finally
        {
            if (cxn != null)
            {
                cxn.Close();
                cxn = null;
            }
        }
        return (uint)(nBreadcrumbSessions + nSandwichSessions);
    }

    static public void ManualMigrateForBucket(uint dwTitleID, uint dwBucketID)
    {
        // TODOTHEOM: should this code also delete any unmigrated sessions on the current server?
        // or can we count on the searches to filter these out, and on session expiration to remove them?
        SqlConnection cxn = null;
        try
        {
            byte bGameTypeID = 0;
            byte bGameModeID = 0;
            byte bRRID = 0;
            string strTitleID = "";
            uint dwSessionizedBucketID = 0;
            uint dwBreadcrumbCount = 0;
            uint dwSandwichCount = 0;

            // first, get the rowset containing a list of the sessions that are ready to be migrated
            // for the bucket in question.

            bGameTypeID = (byte)(dwBucketID >> 16);
            bGameModeID = (byte)((dwBucketID >> 8) & 0xFF);
            bRRID = (byte)(dwBucketID & 0xFF);
            
            strTitleID = "0x" + dwTitleID.ToString("X");
            // make the bucketID look like the tail end of a sessionID, to 
            // make it easy to compare with the sessionID.  
            // TODOTHEOM: In retrospect, maybe all bucketIDs should look like this for consistency?
            dwSessionizedBucketID = (uint)(bGameModeID << 10) |
                                                    (uint)((bGameTypeID & 0x03) << 8) | // mask out the two lower bits just to be explicit.
                                                    (uint)bRRID;

            IBucketServer ibsMigrating = Config.GetTitleBucketServer(Interface.xmatch, dwTitleID, dwBucketID);

            // check that there is a migration in progress for this bucket, and that it has started
            if(String.Compare(ibsMigrating.CurrentServerName, ibsMigrating.NextServerName, true) == 0 ||
                Convert.ToDateTime(ibsMigrating.NextServerStart) > DateTime.Now)
            {
                throw new ExceptionWithEventId(XEvent.Id.COMMON_CONFIG_MATCH_EXPMIGRATE_FAILED_NOTSTARTED,
                    "[MatchAdmin.ExpediteMigration]: Failed expedite -- you can't expedite a bucket that's not set for migration, or for which the migration has not yet started.");
            }
            
            cxn = MatchSql.OpenSqlConnectionToMatchDBNoFastfail((string)ibsMigrating.CurrentServerName); 

            SqlCommand cmd = cxn.CreateCommand();
            cmd.CommandType = CommandType.StoredProcedure;
            cmd.CommandText = "p_match_get_migratable_sessions_for_bucket";

            cmd.Parameters.Add("@i_bucket_id", SqlDbType.Int);
            cmd.Parameters["@i_bucket_id"].Direction = ParameterDirection.Input;
            cmd.Parameters["@i_bucket_id"].Value = (int)dwBucketID;

            cmd.Parameters.Add("@i_sessionized_bucket_id", SqlDbType.Int);
            cmd.Parameters["@i_sessionized_bucket_id"].Direction = ParameterDirection.Input;
            cmd.Parameters["@i_sessionized_bucket_id"].Value = (int)dwSessionizedBucketID;

            cmd.Parameters.Add("@c_title_id", SqlDbType.Char, 10);
            cmd.Parameters["@c_title_id"].Direction = ParameterDirection.Input;
            cmd.Parameters["@c_title_id"].Value = strTitleID;

            cmd.Parameters.Add("@ti_game_type_id", SqlDbType.TinyInt);
            cmd.Parameters["@ti_game_type_id"].Direction = ParameterDirection.Input;
            cmd.Parameters["@ti_game_type_id"].Value = bGameTypeID;

            cmd.Parameters.Add("@result", SqlDbType.Int);
            cmd.Parameters["@result"].Direction = ParameterDirection.ReturnValue;

            SqlDataReader reader = cmd.ExecuteReader();

            // migrate the breadcrumbs for this bucket
            Log("[MatchAdmin]:      Migrating Breadcrumb Sessions");
            while(reader.Read())
            {
                MigrateBCSession(reader, dwBucketID, dwTitleID, ibsMigrating);
                dwBreadcrumbCount++;
            }

            // migrate the sandwiches for this bucket
            reader.NextResult();
            Log("[MatchAdmin]:      " + dwBreadcrumbCount + " Breadcrumb Session migrations attempted.");
            Log("[MatchAdmin]:      Migrating Sandwich Sessions");
            while(reader.Read())
            {
                MigrateSWSession(reader, dwBucketID, dwTitleID, ibsMigrating);
                dwSandwichCount++;
            }
            Log("[MatchAdmin]:      " + dwSandwichCount + " Sandwich Session migrations attempted.");

        }
        finally
        {
            if (cxn != null)
            {
                cxn.Close();
                cxn = null;
            }
        }
    }


    static private bool TitleHasDrainingBuckets(uint dwTitleID, DataSet dsBuckets)
    {
        if (dsBuckets == null)
        {
            SqlDataAdapter sdaBuckets = null;
            GetTitleBucketsDataset(dwTitleID, out dsBuckets, out sdaBuckets);
        }

        // First, check to see if any buckets for this title are in the "drain" state - if so, log this fact and do nothing.
        foreach (DataRow drCurrent in dsBuckets.Tables["t_interface_buckets"].Rows)
        {
            string drainFlag = (string)drCurrent["vc_info1"];
            if (string.Compare(szDrainFlag, drainFlag, true) == 0)
            {
                return(true);
            }
        }

        return (false);
    }

    static public void StartMigrationForTitle(uint dwTitleID, string strCurrentServer, string strNextServer)
    {
        DataSet dsBuckets = null;
        SqlDataAdapter sdaBuckets = null;
        bool fFoundABucket = false;

        uint nCacheRefreshInterval = Convert.ToUInt32(Config.GetSetting(Setting.config_cacheRefreshInterval));
        uint nBuffer = 60000; // buffer a minute to make sure all the FDs get the setting.
        DateTime dtMigrationStart = DateTime.Now.AddMilliseconds(nCacheRefreshInterval + nBuffer);
        strNextServer = strNextServer.ToLower(); // standardize on lower case server names.

        GetTitleBucketsDataset(dwTitleID, out dsBuckets, out sdaBuckets);

        // First, check to see if any buckets for this title are in the "drain" state - if so, log this fact and exit.
        if (TitleHasDrainingBuckets(dwTitleID, dsBuckets))
        {
            Log(string.Format("[MatchAdmin.StartMigrationForTitle]:   Can't start migration for title {0:X} because a bucket drain for this title is in progress.", dwTitleID));
            return;
        }

        // go through the dataset, mark all buckets as migrating to strNextServer
        // any buckets that are already migrating should be skipped, most likely.  (with detailed error)
        foreach (DataRow drCurrent in dsBuckets.Tables["t_interface_buckets"].Rows)
        {
            // only migrate buckets that currently live on strCurrentServer
            if(String.Compare(drCurrent["vc_server"].ToString(), strCurrentServer, true /*ignore case*/) == 0)
            {
                fFoundABucket = true;
                if(String.Compare(drCurrent["vc_server"].ToString(), drCurrent["vc_next_server"].ToString(), true /* ignore case */) != 0)
                {
                    Log("[MatchAdmin.StartMigrationForTitle]:   Can't start migration for bucket" + Convert.ToString(drCurrent["i_bucket"]) + " because it's already in progress.");
                }
                else 
                {
                    Log("[MatchAdmin.StartMigrationForTitle]:   Starting migration for bucket " + Convert.ToString(drCurrent["i_bucket"]));
                    drCurrent["vc_next_server"] = strNextServer;
                    drCurrent["dt_migration_start"] = dtMigrationStart;
                }
            }
        }

        if(!fFoundABucket)
        {
            Log("[MatchAdmin.StartMigrationForTitle]:   No buckets found for title " + dwTitleID.ToString("X") + " on server " + strCurrentServer);
        }

        // update t_interface_buckets
        sdaBuckets.Update(dsBuckets.Tables["t_interface_buckets"]);
    }


    static public void EndMigrationForTitle(uint dwTitleID, string strCurrentServer, MatchLtcConfig matchLtcConfig)
    {
        string strNextServer = "";
        int iDbBucket = 0;
        DataSet dsBuckets = null;
        SqlDataAdapter sdaBuckets = null;
        bool fFoundABucket = false;

        GetTitleBucketsDataset(dwTitleID, out dsBuckets, out sdaBuckets);

        // first, update the LTC (everywhere) to move the bucket in question over to the new server
        // this is done first because it's the most likely the fail and least easy to redo.

        // we need to go to the dataset to get the destination server for the migration, since that's not 
        // serialized into the LTC.
        foreach(MatchInterfaceBucket mib in matchLtcConfig.MatchInterfaceBuckets)
        {
            // only operate on buckets that are living on strCurrentServer
            if(String.Compare(mib.strServerName, strCurrentServer, true /* case insensitive */) == 0)
            {
                fFoundABucket = true;
                // confirm that things are in sync between ltc and db, while updating both
                if(mib.dwBucketId == (uint)(int)(dsBuckets.Tables["t_interface_buckets"].Rows[iDbBucket]["i_bucket"]) &&
                    String.Compare(strCurrentServer, (string)dsBuckets.Tables["t_interface_buckets"].Rows[iDbBucket]["vc_server"], true) == 0)
                {
                    strNextServer = (string)dsBuckets.Tables["t_interface_buckets"].Rows[iDbBucket]["vc_next_server"];
                    if(strNextServer == null || strNextServer == String.Empty)
                    {
                        Log("[MatchAdmin.EndMigrationForBucket]: error --bucket " + mib.dwBucketId+ " does not have a 'next' server.");
                    }
                    strNextServer = strNextServer.ToLower();
                    mib.strServerName = strNextServer;
                    dsBuckets.Tables["t_interface_buckets"].Rows[iDbBucket]["vc_server"] = strNextServer;
                }
                else
                {
                        throw new ExceptionWithEventId(XEvent.Id.COMMON_CONFIG_MATCH_ENDMIGRATE_FAILED_LTC_TIB_OUTOFSYNC,
                            "[MatchAdmin.EndMigrationForBucket]: t_interface_buckets and LTC are out of sync at bucket (" 
                                + mib.dwBucketId +  "/" + dsBuckets.Tables["t_interface_buckets"].Rows[iDbBucket]["i_bucket"] 
                                + ") (ltc/npdb) Halting EndMigration.");
                }
            }
            iDbBucket++;
        }

        if(!fFoundABucket)
        {
            Log("[MatchAdmin.StartMigrationForTitle]:   No buckets found for title " + dwTitleID.ToString("X") + " on server " + strCurrentServer);
        }

        // update the LTC in titlevault and npdb
        UpdateLtc(matchLtcConfig);
        
        // finally t_interface_buckets
        sdaBuckets.Update(dsBuckets.Tables["t_interface_buckets"]);
        
        // TODOTHEOM: should this code also delete any unmigrated sessions on the current server?
        // or can we count on the searches to filter these out, and on session expiration to remove them?

    }



    static public uint MigrationStatusForTitle(uint dwTitleID, string strCurrentServer)
    {
        DataSet dsBuckets = null;
        SqlDataAdapter sdaBuckets = null;
        uint dwSessions = 0;
        bool fFoundABucket = false;

        // get a dataset containing all the buckets for the title.
        GetTitleBucketsDataset(dwTitleID, out dsBuckets, out sdaBuckets);

        // run migrationstatusforbucket on each of those buckets
        foreach(DataRow drCurrent in dsBuckets.Tables["t_interface_buckets"].Rows)
        {
            // only get status for buckets that currently live on strCurrentServer
            if(String.Compare(drCurrent["vc_server"].ToString(), strCurrentServer, true /*ignore case*/) == 0)
            {
                fFoundABucket = true;
                dwSessions += MigrationStatusForBucket(dwTitleID, (uint)(int)(drCurrent["i_bucket"]));
            }
        }

         if(!fFoundABucket)
        {
            Log("[MatchAdmin.StartMigrationForTitle]:   No buckets found for title " + dwTitleID.ToString("X") + " on server " + strCurrentServer);
        }
        
        // write out a very simple summary
        Log("[MatchAdmin.MigrationStatusForTitle]: -- Migration status session count for title: 0x" + dwTitleID.ToString("X") + " --");
        Log("[MatchAdmin.MigrationStatusForTitle]:      Total Sessions remaining: " + dwSessions);
        return dwSessions;
    }



    static public void ManualMigrateForTitle(uint dwTitleID, string strCurrentServer)
    {
        DataSet dsBuckets = null;
        SqlDataAdapter sdaBuckets = null;
        bool fFoundABucket = false;
        
        // get a dataset containing all the buckets for the title.
        GetTitleBucketsDataset(dwTitleID, out dsBuckets, out sdaBuckets);

        // run migrationstatusforbucket on each of those buckets
        foreach(DataRow drCurrent in dsBuckets.Tables["t_interface_buckets"].Rows)
        {
            // only migrate buckets that currently live on strCurrentServer
            if(String.Compare(drCurrent["vc_server"].ToString(), strCurrentServer, true /*ignore case*/) == 0)
            {
                fFoundABucket = true;
                Log("[MatchAdmin.ManualMigrateForTitle]: moving sessions for bucket " + drCurrent["i_bucket"]);
                ManualMigrateForBucket(dwTitleID, (uint)(int)(drCurrent["i_bucket"]));
            }
        }

         if(!fFoundABucket)
        {
            Log("[MatchAdmin.StartMigrationForTitle]:   No buckets found for title " + dwTitleID.ToString("X") + " on server " + strCurrentServer);
        }
         
    }




    static public void StartMigrationForServer(string strCurrentServer, string strNextServer, bool fHandsOffTitleSql, bool fIgnoreNonDestErrors)
    {
        DataSet dsTitles = null;
        CTitleId tid = null;
        MatchGameConfig matchGameConfig = null;
        MatchLtcConfig matchLtcConfig = null;
        bool fTitleFailed = false;

        GetServerTitlesDataset(strCurrentServer, out dsTitles);
        strNextServer = strNextServer.ToLower();

        if(dsTitles.Tables["t_interface_buckets"].Rows.Count > 0)
        {
            foreach(DataRow drCurrent in dsTitles.Tables["t_interface_buckets"].Rows)
            {
                tid = new CTitleId((uint)(int)drCurrent["i_title_id"]);
                Log("MatchAdmin.StartMigrationForServer]: =============== Processing title " + tid.sTitleIdHex + "===============");
                try
                {
                    if(!XmsExists(tid)) // only migrate 360 titles
                    {
                        // first, since we're migrating a title and we don't know if the server that title is going 
                        // to already has match deployed to it, deploy match to all servers including the new one, to 
                        // make sure all the bits are in sync.
                        // TODOTHEOM: could check whether the server is already a match server, and skip this step in that case.

                        // get the the ltc config for the title
                        PrepLiveTitleConfig(tid.uiTitleId, out matchLtcConfig, true /*fRequireBuckets */);

                        // deploy it
                        if (!fHandsOffTitleSql)
                        {
                            // get the the xlast config for the title, but only if we're deploying SQL code
                            PrepGameConfig(tid.uiTitleId, out matchGameConfig);
                            MatchAdmin.ConfigureMatch(
                                    matchGameConfig,
                                    matchLtcConfig,
                                    null, // strNewModeServer is null because you can't add a mode while you're migrating.
                                    strNextServer,
                                    false, // fRemoveModeOk
                                    false,  // droptable
                                    false,  // no reload here... we'll do it after updating the DB
                                    false, // don't override the interface_buckets with the ones from ltc.  
                                    fIgnoreNonDestErrors); // ignore errors on all but the destination server if true
                        }

                        StartMigrationForTitle(tid.uiTitleId, strCurrentServer, strNextServer);
                    }
                    else
                    {
                        Log("[MatchAdmin.StartMigrationForServer]: Skipping XBox 1 title " + tid.sTitleIdHex);
                    }
                }
                catch(Exception e)
                {
                    fTitleFailed = true;
                    LogError("Error While starting migration for title " + tid.sTitleIdHex);
                    LogError(e.Message);
                }
                Log("MatchAdmin.StartMigrationForServer]: =============== End of title " + tid.sTitleIdHex + "===============");
            }
            if (fTitleFailed)
            {
                Log("[MatchAdmin.StartMigrationForServer]: WARNING: failed to start migration for one or more titles.  Failed titles were skipped.");
            }
        }
        else
        {
            Log("[MatchAdmin.StartMigrationForServer]: No titles found for source server " + strCurrentServer);
        }
    }


    static public void EndMigrationForServer(string strCurrentServer)
    {
        DataSet dsTitles = null;
        MatchLtcConfig matchLtcConfig = null;
        CTitleId tid = null;
        bool fTitleFailed = false;

        GetServerTitlesDataset(strCurrentServer, out dsTitles);

        if(dsTitles.Tables["t_interface_buckets"].Rows.Count > 0)
        {
            foreach(DataRow drCurrent in dsTitles.Tables["t_interface_buckets"].Rows)
            {
                tid = new CTitleId((uint)(int)drCurrent["i_title_id"]);
                Log("[MatchAdmin.EndMigrationForServer]: =============== Processing title " + tid.sTitleIdHex + "===============");
                try
                {
                    if (!XmsExists(tid)) // only migration 360 titles
                    {
                        PrepLiveTitleConfig(tid.uiTitleId, out matchLtcConfig, true /*fRequireBuckets */);
                        EndMigrationForTitle(tid.uiTitleId, strCurrentServer, matchLtcConfig);
                    }
                    else
                    {
                        Log("[MatchAdmin.EndMigrationForServer]: Skipping Xbox 1 title " + tid.sTitleIdHex);
                    }
                }
                catch (Exception e)
                {
                    fTitleFailed = true;
                    LogError("Error While ending migration for title " + tid.sTitleIdHex);
                    LogError(e.Message);
                }
                Log("[MatchAdmin.EndMigrationForServer]: =============== End of title " + tid.sTitleIdHex + "===============");
            }
            if (fTitleFailed)
            {
                Log("[MatchAdmin.EndMigrationForServer]: WARNING: failed to end migration for one or more titles.  Failed titles were skipped.");
            }
        }
        else
        {
            Log("[MatchAdmin.EndMigrationForServer]: No titles found for source server " + strCurrentServer);
        }
    }



    static public void MigrationStatusForServer(string strCurrentServer)
    {
        DataSet dsTitles = null;
        uint dwSessions = 0;
        CTitleId tid = null;
        bool fTitleFailed = false;

        GetServerTitlesDataset(strCurrentServer, out dsTitles);
        
        if(dsTitles.Tables["t_interface_buckets"].Rows.Count > 0)
        {
            // run migrationstatusfortitle on each of those titles
            foreach(DataRow drCurrent in dsTitles.Tables["t_interface_buckets"].Rows)
            {
                tid = new CTitleId((uint)(int)drCurrent["i_title_id"]);
                Log("[MatchAdmin.MigrationStatusForServer]: =============== Processing title " + tid.sTitleIdHex + "===============");
                try
                {
                    if (!XmsExists(tid)) // only migrate 360 titles
                    {
                        dwSessions += MigrationStatusForTitle(tid.uiTitleId, strCurrentServer);
                    }
                    else
                    {
                        Log("[MatchAdmin.MigrationStatusForServer]: Skipping Xbox 1 title " + tid.sTitleIdHex);
                    }
                }
                catch (Exception e)
                {
                    fTitleFailed = true;
                    LogError("Error While getting migration status for title " + tid.sTitleIdHex);
                    LogError(e.Message);
                }
                Log("[MatchAdmin.MigrationStatusForServer]: =============== End of title " + tid.sTitleIdHex + "===============");
            }
            if (fTitleFailed)
            {
                Log("[MatchAdmin.MigrationStatusForServer]: WARNING: failed to get migration status for one or more titles.  Failed titles were skipped.");
            }
        }
        else
        {
            Log("[MatchAdmin.MigrationStatusForServer]: No titles found for source server " + strCurrentServer);
        }
        
        // write out a very simple summary
        Log("[MatchAdmin.MigrationStatusForServer]: -- Migration status session count for server: " + strCurrentServer + " --");
        Log("[MatchAdmin.MigrationStatusForServer]:      Total Sessions remaining: " + dwSessions);
    }



    static public void ManualMigrateForServer(string strCurrentServer)
    {
        DataSet dsTitles = null;
        CTitleId tid = null;
        bool fTitleFailed = false;

        GetServerTitlesDataset(strCurrentServer, out dsTitles);
        if(dsTitles.Tables["t_interface_buckets"].Rows.Count > 0)
        {
            // run manualmigratefortitle on each of those titles
            foreach(DataRow drCurrent in dsTitles.Tables["t_interface_buckets"].Rows)
            {
                tid = new CTitleId((uint)(int)drCurrent["i_title_id"]);
                Log("[MatchAdmin.ManualMigrateForServer]: =============== Processing title " + tid.sTitleIdHex + "===============");
                try
                {
                    if (!XmsExists(tid)) // only migrate 360 titles
                    {
                        ManualMigrateForTitle(tid.uiTitleId, strCurrentServer);
                    }
                    else
                    {
                        Log("[MatchAdmin.ManualMigrateForServer]: skipping Xbox 1 title " + tid.sTitleIdHex);
                    }
                }
                catch (Exception e)
                {
                    fTitleFailed = true;
                    LogError("Error While expediting migration for title " + tid.sTitleIdHex);
                    LogError(e.Message);
                }
                Log("[MatchAdmin.ManualMigrateForServer]: =============== End of title " + tid.sTitleIdHex + "===============");
            }
            if (fTitleFailed)
            {
                Log("[MatchAdmin.ManualMigrateForSerer]: WARNING: failed to expedite migration for one or more titles.  Failed titles were skipped.");
            }
        }
        else
        {
            Log("[MatchAdmin.ManualMigrateForServer]: No titles found for source server " + strCurrentServer);
        }
    }

    

// used to migrate a single sandwich instance of a single session from one
// server to another.
 static public void MigrateSWSession(SqlDataReader rdrMigrating,   // iterator is already set to appropriate row
                                                    uint dwBucketID, // bucket of the row that's migrating
                                                    uint dwTitleID,
                                                    IBucketServer ibsMigrating) // info about the bucket that's migrating
    {
        // figure out the breadcrumb sessionid/bucketid/old + new servers
        // lock the breadcrumb (whether it's on old or new server) and get its data
        // Write new SW row to new SW server, using returned data to populate.  (ok to use BC data to write SW because they're in sync). 
        // If there's already a row there, bail with warning.
        // Delete old SW row.  (or should this happen first?)
        // Call ReleaseLock on the BC for the session.
        // If ReleaseLock finds that the row is gone, delete that row you wrote to the new server.  (or could we detect this when we go to delete the old SW?)

        SqlConnection cxnBreadcrumb = null;
        SqlConnection cxnMigrateTo = null;
        SqlConnection cxnMigrateFrom = null;
        SqlDataReader rdrBreadcrumb = null;
        uint dwSWBucket = 0; //TODOTHEOM: remove
        HResult hr = HResult.S_OK;
        bool fLocked = false;
        ulong qwSessionId = 0;
        try
        {
            qwSessionId = (ulong)(long)rdrMigrating["bi_session_id"];
            uint dwBreadcrumbBucket = MatchDefs.GetBucketIdFromSessionId(qwSessionId);
            IBucketServer ibsBreadcrumb= Config.GetTitleBucketServer(Interface.xmatch, dwTitleID, dwBreadcrumbBucket);

            // LockAndRead finds the breadcrumb in its bucket and locks it. (looks for the row in both svrs of its migrating pair if it's migrating)
            // makes a connection to the breadcrumb's server, which we must close below.
            hr = MatchSql.LockAndReadForBucket(qwSessionId, dwTitleID, ibsBreadcrumb, out cxnBreadcrumb, out rdrBreadcrumb); 

            if(hr == HResult.S_OK) // we got the lock
            {
                fLocked = true;
                cxnMigrateTo = MatchSql.OpenSqlConnectionToMatchDBNoFastfail((string)ibsMigrating.NextServerName);
                SqlCommand cmdInsert = MatchSql.InsertCmdFromReaderRow(rdrBreadcrumb, dwTitleID, false /* don't carry the lock */);
                cmdInsert.Connection = cxnMigrateTo;
                bool fRet = MatchSql.InsertSessionCore(cmdInsert, 
                                                                BreadcrumbState.Sandwich, 
                                                                dwTitleID, 
                                                                (string)ibsMigrating.NextServerName); 
                rdrBreadcrumb.Close(); // to be clear, we no longer need contents of the reader.
                if(fRet == true)
                {
                    // unlock and bail for this session with warning... someone migrated this already???
                    Log("ERROR: migration failed for session 0x" + qwSessionId.ToString("X8") + ": Session already on target server.");
                }
                else // we wrote the new session, so delete the old...
                {
                    cxnMigrateFrom = MatchSql.OpenSqlConnectionToMatchDBNoFastfail((string)ibsMigrating.CurrentServerName);

                    hr = MatchSql.DeleteSessionCore(cxnMigrateFrom, 
                                                                        (BreadcrumbState)2, 
                                                                        dwTitleID, 
                                                                        qwSessionId, 
                                                                        ref dwSWBucket);
                    if(hr == HResult.S_FALSE)
                    {
                        // unlock and bail for this session with warning -- someone migrated this already???
                        Log("ERROR: migration failed for session 0x" + qwSessionId.ToString("X8") + ": Session missing from source server.");
                    }
                }
            }
            else if(hr == HResult.XONLINE_E_MATCH_INVALID_SESSION_ID ||        // the session wasn't there
                     hr == HResult.XONLINE_E_MATCH_SESSION_TYPE_MISMATCH)
            {
                // bail for this session with warning... it was deleted???
                Log("ERROR: migration failed for session 0x" + qwSessionId.ToString("X8") + ": Failed to acquire the lock.  Session not found.");
            }
            else if(hr == HResult.XONLINE_E_MATCH_CONCURRENT_REQ_CONFLICT)
            {
                Log("ERROR: migration failed for session 0x" + qwSessionId.ToString("X8") + ": Failed to acquire the lock.  Session already locked.");
            }
            else
            {
                Log("ERROR: migration failed for session 0x" + qwSessionId.ToString("X8") + ": Failed to acquire the lock.  Unknown error.");
            }
        }
        catch(Exception e)
        {
            Log("---------------------------------------------------------------------------");
            Log("ERROR: Migration failed for session 0x" + qwSessionId.ToString("X8") + ": Exception thrown -- details should follow:\n" + e.ToString());
            Log("---------------------------------------------------------------------------");
            // swallow the exception, because we want the migration to go onto the next row.
        }
        finally
        {
            try
            {
                // close the reader, so that we can potentially reuse the connection to delete the migrated row.
                if (rdrBreadcrumb != null)
                {
                    rdrBreadcrumb.Close();
                }
                // try to release the lock, even if there was an exception.  
                if(fLocked && cxnBreadcrumb != null)
                {
                    hr = MatchSql.ReleaseLock(qwSessionId, dwTitleID, cxnBreadcrumb);
                    if(hr == HResult.S_FALSE) // if the BC has gone away, that means a delete came in.  Clean up with new row we created.
                    {
                        Log("INFO: migration succeded for session 0x" + qwSessionId.ToString("X8") + ", but session was deleted during migration.");
                        if(cxnMigrateTo != null)
                        {
                            hr = MatchSql.DeleteSessionCore(cxnMigrateTo, 
                                                                            (BreadcrumbState)2, 
                                                                            dwTitleID, 
                                                                            qwSessionId, 
                                                                            ref dwSWBucket);
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Log("---------------------------------------------------------------------------");
                Log("ERROR: Failure during cleanup for session 0x" + qwSessionId.ToString("X8") + ": Exception thrown -- details should follow:\n" + e.ToString());
                Log("---------------------------------------------------------------------------");
                // swallow the exception, because we want the migration to go onto the next row.
            }
            finally // make sure the connections get closed, even if the above cleanup throws an exception.
            {
                if(cxnMigrateTo != null)
                {
                    cxnMigrateTo.Close();
                }
                if(cxnBreadcrumb != null)
                {
                    cxnBreadcrumb.Close();
                }
            }
        }
        
    }


// used to migrate a single sandwich instance of a single session from one
// server to another.
 static public void MigrateBCSession(SqlDataReader rdrMigrating,   // iterator is already set to appropriate row
                                                    uint dwBucketID, // bucket of the row that's migrating
                                                    uint dwTitleID,
                                                    IBucketServer ibsMigrating) // info about the bucket that's migrating
    {
/*
- For each breadcrumb row (including 3s):
- GetTitleBucket on the BC bucket.  Get old and new BC servers from that.
- ReadDataAndLock on the old BC server
- Write BC row to new server from returned data, keeping the lock on the new BC row.
- Delete the old BC row.  If the old BC row is already deleted, delete the new row and finish it means a delete snuck in.
- ReleaseLock on the new BC row.
- If ReleaseLock finds that the new row is gone, fine just leave it gone.
*/

        SqlConnection cxnMigrateFrom = null;
        SqlConnection cxnMigrateTo = null;
        SqlDataReader rdrBreadcrumb = null;
        HResult hr = HResult.S_OK;
        bool fLocked = false;
        ulong qwSessionId = 0;
        uint dwSWBucket = 0;
        try
        {
            qwSessionId = (ulong)(long)rdrMigrating["bi_session_id"];

            // Since we know we're migrating a breadcrumb, we know if must be on its "current" server.  So lock 
            // and read it there, and keep the connection to that server.

            SqlCommand cmd = MatchSql.CreateLockAndReadSqlCommand(dwTitleID);
            MatchSql.SqlAddParam(cmd, ParameterDirection.Input,
                "@bi_session_id", qwSessionId);
            cxnMigrateFrom = MatchSql.OpenSqlConnectionToMatchDBNoFastfail(ibsMigrating.CurrentServerName);
            cmd.Connection = cxnMigrateFrom;
            rdrBreadcrumb = cmd.ExecuteReader();
            if (!rdrBreadcrumb.Read()) // the thing's got no rows
            {
                Log("ERROR: migration failed for session 0x" + qwSessionId.ToString("X8") + ": Failed to acquire the lock.  Stored proc returned no row.");
            }
            else if ((int)rdrBreadcrumb["i_return_code"] != 0) // stored proc returned an error
            {
                hr = (uint)(int)rdrBreadcrumb["i_return_code"];
                if (hr == HResult.XONLINE_E_MATCH_INVALID_SESSION_ID ||        // the session wasn't there
                         hr == HResult.XONLINE_E_MATCH_SESSION_TYPE_MISMATCH)
                {
                    // bail for this session with warning... it was deleted???
                    Log("ERROR: migration failed for session 0x" + qwSessionId.ToString("X8") + ": Failed to acquire the lock.  Session not found.");
                }
                else if (hr == HResult.XONLINE_E_MATCH_CONCURRENT_REQ_CONFLICT)
                {
                    Log("ERROR: migration failed for session 0x" + qwSessionId.ToString("X8") + ": Failed to acquire the lock.  Session already locked.");
                }
                else
                {
                    Log("ERROR: migration failed for session 0x" + qwSessionId.ToString("X8") + ": Failed to acquire the lock.  Unknown error.");
                }
                rdrBreadcrumb.Close();
            }
            else // all is well, the session is locked.
            {
                fLocked = true;
                cxnMigrateTo = MatchSql.OpenSqlConnectionToMatchDBNoFastfail((string)ibsMigrating.NextServerName);
                SqlCommand cmdInsert = MatchSql.InsertCmdFromReaderRow(rdrBreadcrumb, dwTitleID, true /* carry the lock over */);
                cmdInsert.Connection = cxnMigrateTo;
                bool fRet = MatchSql.InsertSessionCore(cmdInsert,
                                                                BreadcrumbState.Breadcrumb,
                                                                dwTitleID,
                                                                (string)ibsMigrating.NextServerName);
                rdrBreadcrumb.Close(); // to be clear, we no longer need contents of the reader.
                if (fRet == true)
                {
                    // unlock and bail for this session with warning... someone migrated this already???
                    Log("ERROR: migration failed for session 0x" + qwSessionId.ToString("X8") + ": Session already on target server.");
                }
                else // we wrote the new session, so delete the old...
                {
                    //                    cxnMigrateFrom = MatchSql.OpenSqlConnectionToMatchDBNoFastfail((string)ibsMigrating.CurrentServerName);

                    hr = MatchSql.DeleteSessionCore(cxnMigrateFrom,
                                                                        BreadcrumbState.Breadcrumb,
                                                                        dwTitleID,
                                                                        qwSessionId,
                                                                        ref dwSWBucket);
                    if (hr == HResult.S_FALSE)
                    {
                        // someone deleted the source row out from under us?  Must be a delete... delete the migrated row.
                        Log("ERROR: migration failed for session 0x" + qwSessionId.ToString("X8") + ": Session missing from source server.");
                        if (cxnMigrateTo != null)
                        {
                            hr = MatchSql.DeleteSessionCore(cxnMigrateTo,
                                                                            BreadcrumbState.Breadcrumb,
                                                                            dwTitleID,
                                                                            qwSessionId,
                                                                            ref dwSWBucket);
                        }

                    }
                }
            }

        }
        catch(Exception e)
        {
            Log("---------------------------------------------------------------------------");
            Log("ERROR: Migration failed for session 0x" + qwSessionId.ToString("X8") + ": Exception thrown -- details should follow:\n" + e.ToString());
            Log("---------------------------------------------------------------------------");
            // swallow the exception, because we want the migration to go onto the next row.
        }
        finally
        {
            try
            {
                // try to release the lock, even if there was an exception.  
                if(fLocked && cxnMigrateTo != null)
                {
                    hr = MatchSql.ReleaseLock(qwSessionId, dwTitleID, cxnMigrateTo);
                    if(hr == HResult.S_FALSE) // if the BC has gone away, that means a delete came in.  Clean up with new row we created.
                    {
                        Log("INFO: migration succeded for session 0x" + qwSessionId.ToString("X8") + ", but session was deleted during migration.");
                    }
                }
            }
            catch (Exception e)
            {
                Log("---------------------------------------------------------------------------");
                Log("ERROR: Failure during cleanup for session 0x" + qwSessionId.ToString("X8") + ": Exception thrown -- details should follow:\n" + e.ToString());
                Log("---------------------------------------------------------------------------");
                // swallow the exception, because we want the migration to go onto the next row.
            }
            finally // make sure the connections get closed, even if the above cleanup throws an exception.
            {
                if(cxnMigrateTo != null)
                {
                    cxnMigrateTo.Close();
                }
                if(cxnMigrateFrom != null)
                {
                    cxnMigrateFrom.Close();
                }
            }
        }
        
    }

    static public void AddRRBucket(uint dwTitleID, string strServer, byte bType, byte bMode, MatchGameConfig matchGameConfig, MatchLtcConfig matchLtcConfig, bool fHandsOffTitleSql)
    {
        SqlDataAdapter sdaBuckets = null;
        DataSet dsBuckets = null;
        byte bNewRRId = 0;
        Hashtable hashServer = new Hashtable(4);
        strServer = strServer.ToLower();

        uint dwPartitionId = (uint)(bType << 16) |
                (uint)(bMode << 8);
        
        // query the DB for the number of buckets that currently exist for the type/mode
        // ideally this is a single query, but for now use the dataadapter and iterate.
        uint minDrainingRRId = uint.MaxValue;
        DataRow drToUndrain = null;
        GetTitleBucketsDataset(dwTitleID, out dsBuckets, out sdaBuckets);
        foreach(DataRow drCurrent in dsBuckets.Tables["t_interface_buckets"].Rows)
        {
            uint bucketId = (uint)(int)drCurrent["i_bucket"];
            if((bucketId & dwPartitionIdMask) == dwPartitionId)
            {
                bNewRRId++;
                if (!hashServer.Contains(((string)drCurrent["vc_server"]).ToLower()))
                {
                    hashServer.Add(((string)drCurrent["vc_server"]).ToLower(), null);
                }

                // If bucket is marked to drain, save the round-robin ID of the bucket. Since buckets with higher RRIDs are drained first,
                // save the lowest RRID being drained.  That bucket will then be "un-drained" instead of creating a new one for the add.
                if (string.Compare(szDrainFlag, (string)drCurrent["vc_info1"], true) == 0)
                {
                    uint rrId = bucketId & dwRRIdMask;
                    if (rrId < minDrainingRRId)
                    {
                        minDrainingRRId = rrId;
                        drToUndrain = drCurrent;
                    }
                }
            }
        }
        if(bNewRRId == 0)
        {
            throw new ExceptionWithEventId(XEvent.Id.COMMON_CONFIG_MATCH_ADDRR_FAILED_MISSING_BUCKET,
                "[MatchAdmin.AddRRServer]: No existing buckets found with the type/mode you specified.  No RR server can be added.");
        }
        if(hashServer.Contains(strServer))
        {
            throw new ExceptionWithEventId(XEvent.Id.COMMON_CONFIG_MATCH_ADDRR_FAILED_DUPE_SERVER,
                "[MatchAdmin.AddRRServer]: You are trying to add an RR bucket using a server already used by the type/mode you specified.  This is not supported.");
        }

        // A draining bucket was found, so just "un-drain" it to reactivate it instead of adding a new bucket.
        if (drToUndrain != null)
        {
            // Clear the drain flag
            drToUndrain["vc_info1"] = "";
            Log(string.Format("[MatchAdmin.AddRRServer]: INFO: Adding bucket by un-draining bucket RRID = {0}.", minDrainingRRId));
        }

        // Create a new bucket
        else
        {
            if(!fHandsOffTitleSql)
            {
                // ok, we think all is well.  Deploy the title so that the new server gets
                // the code, and make sure all the bits are in sync.
                // TODOTHEOM: could check whether the server already has modes for this title, and skip this step in that case.
                ConfigureMatch(
                    matchGameConfig,
                    matchLtcConfig,
                    null,
                    // strNewModeServer -- null because we don't support adding a new mode which adding an RR bucket.
                    strServer, // forces configurematch to put code on the new server
                    false, // fRemoveModeOk
                    false, // droptable
                    false, // no reload here... we'll do it after updating the DB
                    false, // don't override the interface_buckets with the ones from ltc.  
                    false); // fIgnoreNonDestErrors
            }

            // now we need to actually create that new bucket...
            // because we already have the dataadapter, might as well use it.
            // add the bucket to the database too
            DataRow drNewBucket = dsBuckets.Tables["t_interface_buckets"].NewRow();

            drNewBucket["vc_environment"] = Config.Environment;
            drNewBucket["vc_interface"] = Interface.xmatch;
            drNewBucket["i_title_id"] = (int)dwTitleID;
            drNewBucket["i_bucket"] = (int)dwPartitionId | bNewRRId;
            drNewBucket["vc_server"] = strServer;
            drNewBucket["vc_next_server"] = strServer;
            drNewBucket["dt_migration_start"] = new DateTime(1900, 1, 1, 12, 00, 00);
            drNewBucket["vc_info1"] = "";
            drNewBucket["vc_info2"] = "";
            drNewBucket["vc_info3"] = "";
            drNewBucket["vc_info4"] = "";

            dsBuckets.Tables["t_interface_buckets"].Rows.Add(drNewBucket);

            MatchInterfaceBucket mib = new MatchInterfaceBucket();
            mib.bGameTypeId = bType;
            mib.bGameModeId = bMode;
            mib.bRRId = bNewRRId;
            mib.dwBucketId = dwPartitionId | bNewRRId;
            mib.strServerName = strServer;
            matchLtcConfig.MatchInterfaceBuckets.Add(mib);

            // re-sort the list of matchinterfacebuckets, to be sure they're sorted in the LTC
            MatchInterfaceBucketComparer mibc = new MatchInterfaceBucketComparer();
            matchLtcConfig.MatchInterfaceBuckets.Sort(mibc);

            // if all of the above succeeded, we can now start updating config to point to that new bucket
            // first titlevault then npdb
            UpdateLtc(matchLtcConfig);
        }

        // finally t_interface_buckets
        sdaBuckets.Update(dsBuckets.Tables["t_interface_buckets"]);
    }

    private const string szDrainFlag        = "drain";
    private const uint   dwPartitionIdMask  = 0x00FFFF00;
    private const uint   dwRRIdMask         = 0x000000FF;

    static public void DrainTopRRBucket(uint dwTitleID, byte bType, byte bMode)
    {
        // Query the DB for the number of buckets that currently exist for the type/mode
        // Ideally this is a single query, but for now use the dataadapter and iterate.
        SqlDataAdapter sdaBuckets;
        DataSet        dsBuckets;
        GetTitleBucketsDataset(dwTitleID, out dsBuckets, out sdaBuckets);
        if (dsBuckets.Tables["t_interface_buckets"].Rows.Count == 0)
        {
            throw new ExceptionWithEventId(XEvent.Id.LIVEMATCH_DRAINRR_FAILED_NO_BUCKETS_FOUND,
                "[MatchAdmin.DrainTopRRBucket]: No existing buckets found for the titleID you specified.  No buckets can be drained.");
        }

        // First make sure no buckets are currently in migration
        foreach (DataRow drCurrent in dsBuckets.Tables["t_interface_buckets"].Rows)
        {
            string server     = (string)drCurrent["vc_server"];
            string nextServer = (string)drCurrent["vc_next_server"];
            if(string.Compare(server, nextServer, true) != 0) 
            {
                throw new ExceptionWithEventId(XEvent.Id.LIVEMATCH_DRAINRR_FAILED_MIGRATION_UNDERWAY,
                    "[MatchAdmin.DrainTopRRBucket]: A migration for this title is in process.  No buckets can be drained.");
            }
        }

        // Find the bucket with the highest RRID not already draining
        DataRow drToDrain     = null;
        uint    maxRRId       = 0;
        int     numCandidates = 0;
        uint    dwPartitionId = (uint)(bType << 16) | (uint)(bMode << 8);
        foreach (DataRow drCurrent in dsBuckets.Tables["t_interface_buckets"].Rows)
        {
            // Only consider buckets for the specified game mode and game type 
            uint bucketId = (uint)(int)drCurrent["i_bucket"];
            if ((bucketId & dwPartitionIdMask) == dwPartitionId)
            {
                // Only consider buckets not already marked for draining
                string drainState = (string)drCurrent["vc_info1"];
                if (string.Compare(drainState, szDrainFlag, true) != 0) 
                {
                    numCandidates++;
                    uint rrId = bucketId & dwRRIdMask;

                    // Select this row if it is the first row considered, or if the RRID is highest.
                    if(drToDrain == null || rrId > maxRRId) 
                    {
                        drToDrain = drCurrent;
                        maxRRId   = rrId;
                    } 
                }
            }
        }
        // If no eligible buckets were found, can't drain
        if (drToDrain == null || numCandidates == 0)
        {
            throw new ExceptionWithEventId(XEvent.Id.LIVEMATCH_DRAINRR_FAILED_NO_ELIGIBLE_BUCKETS,
                "[MatchAdmin.DrainTopRRBucket]: No non-draining buckets found for the type/mode you specified.  No buckets can be drained.");
        }
        // If a single bucket was found, can't drain since one must remain undrained
        if (numCandidates == 1)
        {
            throw new ExceptionWithEventId(XEvent.Id.LIVEMATCH_DRAINRR_FAILED_NO_ELIGIBLE_BUCKETS,
                "[MatchAdmin.DrainTopRRBucket]: Only one bucket exists for the type/mode you specified, and it can not be drained.");
        }

        // Mark the selected bucket for draining.
        drToDrain["vc_info1"] = szDrainFlag;

        // Save change to t_interface_buckets
        sdaBuckets.Update(dsBuckets.Tables["t_interface_buckets"]);
    }

    static public void RemoveTopRRBucket(uint dwTitleID, byte bType, byte bMode, MatchLtcConfig matchLtcConfig, bool bForce)
    {
        // Query the DB for the number of buckets that currently exist for the type/mode
        // Ideally this is a single query, but for now use the dataadapter and iterate.
        SqlDataAdapter sdaBuckets;
        DataSet dsBuckets;
        GetTitleBucketsDataset(dwTitleID, out dsBuckets, out sdaBuckets);
        if (dsBuckets.Tables["t_interface_buckets"].Rows.Count == 0)
        {
            throw new ExceptionWithEventId(XEvent.Id.LIVEMATCH_REMOVERR_FAILED_NO_BUCKETS_FOUND,
                "[MatchAdmin.RemoveTopRRBucket]: No existing buckets found for the titleID you specified.  No buckets can be removed.");
        }

        // First make sure no buckets are currently in migration
        foreach (DataRow drCurrent in dsBuckets.Tables["t_interface_buckets"].Rows)
        {
            string server = (string)drCurrent["vc_server"];
            string nextServer = (string)drCurrent["vc_next_server"];
            if (string.Compare(server, nextServer, true) != 0)
            {
                throw new ExceptionWithEventId(XEvent.Id.LIVEMATCH_REMOVERR_FAILED_MIGRATION_UNDERWAY,
                    "[MatchAdmin.RemoveTopRRBucket]: A migration for this title is in process.  No buckets can be removed.");
            }
        }

        // Find the bucket with the highest RRID 
        DataRow drToRemove = null;
        uint maxRRId = 0;
        int numCandidates = 0;
        uint dwPartitionId = (uint)(bType << 16) | (uint)(bMode << 8);
        foreach (DataRow drCurrent in dsBuckets.Tables["t_interface_buckets"].Rows)
        {
            // Only consider buckets for the specified game mode and game type 
            uint bucketId = (uint)(int)drCurrent["i_bucket"];
            if ((bucketId & dwPartitionIdMask) == dwPartitionId)
            {
                numCandidates++;
                uint rrId = bucketId & dwRRIdMask;

                // Select this row if it is the first row considered, or if the RRID is highest.
                if (drToRemove == null || rrId > maxRRId)
                {
                    drToRemove = drCurrent;
                    maxRRId = rrId;
                }
            }
        }
        // If no buckets were found for this type/mode, can't remove
        if (drToRemove == null || numCandidates == 0)
        {
            throw new ExceptionWithEventId(XEvent.Id.LIVEMATCH_REMOVERR_FAILED_NO_ELIGIBLE_BUCKETS,
                "[MatchAdmin.RemoveTopRRBucket]: No buckets found for the type/mode you specified.");
        }
        // If a single bucket was found, can't remove since one must remain 
        if (numCandidates == 1)
        {
            throw new ExceptionWithEventId(XEvent.Id.LIVEMATCH_REMOVERR_FAILED_NO_ELIGIBLE_BUCKETS,
                "[MatchAdmin.RemoveTopRRBucket]: Only one bucket exists for the type/mode you specified, and it can not be removed.");
        }

        // If draining, or not draining and the force flag is specified, remove the bucket
        bool bDraining = (string.Compare(szDrainFlag, (string)drToRemove["vc_info1"], true) == 0);
        if (bDraining || bForce)
        {
            // Find the bucket in the LTC and remove it
            uint bucketId = dwPartitionId | maxRRId;
            foreach (MatchInterfaceBucket mib in matchLtcConfig.MatchInterfaceBuckets)
            {
                if (mib.dwBucketId == bucketId)
                {
                    matchLtcConfig.MatchInterfaceBuckets.Remove(mib);
                    break;
                }
            }

            // Update the LTC
            UpdateLtc(matchLtcConfig);

            // Remove the bucket from t_interface_buckets
            drToRemove.Delete();

            // Save change to t_interface_buckets
            sdaBuckets.Update(dsBuckets.Tables["t_interface_buckets"]);
        }

        // Not draining and no force flag - warn the user and do nothing
        else
        {
            throw new ExceptionWithEventId(XEvent.Id.LIVEMATCH_REMOVERR_FAILED_NOT_DRAINING,
                "[MatchAdmin.RemoveTopRRBucket]: The top bucket is not marked for draining.  To remove it, you must specify the 'force' flag.");
        }
    }

    static public uint SessionCountForBucket(uint dwTitleID, uint dwBucketID)
    {
        // Query the DB for the number of buckets that currently exist for the type/mode
        // Ideally this is a single query, but for now use the dataadapter and iterate.
        SqlDataAdapter sdaBuckets;
        DataSet dsBuckets;
        GetTitleBucketsDataset(dwTitleID, out dsBuckets, out sdaBuckets);

        // Find the specified bucket
        foreach (DataRow drCurrent in dsBuckets.Tables["t_interface_buckets"].Rows)
        {
            if((uint)(int)drCurrent["i_bucket"] == dwBucketID) 
            {
                string drainState = (string)drCurrent["vc_info1"];
                if (string.Compare(drainState, szDrainFlag, true) == 0)
                {
                    Log("[MatchAdmin.SessionCountForBucket]: Bucket is DRAINING");
                } else
                {
                    Log("[MatchAdmin.SessionCountForBucket]: Bucket is not draining");
                }

                return(MigrationStatusForBucket(dwTitleID, dwBucketID));
            }
        }

        return (0);
    }


    static public void ConfigureSessionLimits(uint dwTitleID, 
                                                                        bool fEnabled, 
                                                                        uint uiMaxAvail, 
                                                                        uint uiTruncateAvail, 
                                                                        uint uiWarnAvail, 
                                                                        uint uiMaxUnavail, 
                                                                        uint uiTruncateUnavail, 
                                                                        uint uiWarnUnavail, 
                                                                        uint uiPeriod, 
                                                                        uint uiOffset, 
                                                                        MatchLtcConfig matchLtcConfig)
    {
        matchLtcConfig.MatchSessionLimitJobExists = true;
        matchLtcConfig.MatchSessionLimitEnabled = fEnabled;
        matchLtcConfig.MatchSessionMaxAvail = uiMaxAvail;
        matchLtcConfig.MatchSessionTruncateLevelAvail = uiTruncateAvail;
        matchLtcConfig.MatchSessionWarnLevelAvail = uiWarnAvail;
        matchLtcConfig.MatchSessionMaxUnavail = uiMaxUnavail;
        matchLtcConfig.MatchSessionTruncateLevelUnavail = uiTruncateUnavail;
        matchLtcConfig.MatchSessionWarnLevelUnavail = uiWarnUnavail;
        matchLtcConfig.MatchSessionCleanupPeriodMinutes = uiPeriod;
        matchLtcConfig.MatchSessionCleanupOffsetMinutes = uiOffset;

        UpdateLtc(matchLtcConfig);
    }


    public static void ApplyTitleConfigToNPDB(
        MatchLtcConfig matchLtcConfig,
        string[] servers)
    {
        Log("[MatchAdmin.ApplyTitleConfigToNPDB]: Updating t_match_titles table in npdb");

        using (SqlConnection cxn = OpenSqlConnectionToNPDB())
        {
            SqlCommand cmd = cxn.CreateCommand();
            cmd.CommandType = CommandType.StoredProcedure;
            cmd.CommandText = "p_match_title_insert";

            SqlParameter param = new SqlParameter();
            param.ParameterName = "@i_title_id";
            param.Direction = ParameterDirection.Input;
            param.DbType = DbType.Int32;
            param.Value = (int)matchLtcConfig.TitleId;
            cmd.Parameters.Add(param);

            param = new SqlParameter();
            param.ParameterName = "@i_session_expiration";
            param.Direction = ParameterDirection.Input;
            param.DbType = DbType.Int32;
            param.Value = (int)matchLtcConfig.MatchExpiration;
            cmd.Parameters.Add(param);

            param = new SqlParameter();
            param.ParameterName = "@vc_db_list";
            param.Direction = ParameterDirection.Input;
            param.DbType = DbType.String;
            param.Value = ServerListToString(servers);
            cmd.Parameters.Add(param);
            
            param = new SqlParameter();
            param.ParameterName = "@i_delete_delay_seconds";
            param.Direction = ParameterDirection.Input;
            param.DbType = DbType.Int32;
            param.Value = (int)matchLtcConfig.DeleteDelaySeconds;
            cmd.Parameters.Add(param);

            param = new SqlParameter();
            param.ParameterName = "@ti_revoke_cross_platform";
            param.Direction = ParameterDirection.Input;
            param.DbType = DbType.Byte;

            if(CrossPlatformRevokeState.NotSupported == matchLtcConfig.CrossPlatform)
            {
                param.Value = DBNull.Value;
            }
            else
            {
                param.Value = (byte)(CrossPlatformRevokeState.Allow == matchLtcConfig.CrossPlatform ? 0 : 1);
            }
            cmd.Parameters.Add(param);

            cmd.ExecuteNonQuery();
        }
    }


// returns a list of buckets (from t_interface_buckets) for the given title, in the dataset dsBuckets.
// also returns a sqldataadapter sdaBuckets, which can be used by the caller to update those buckets.
public static void GetTitleBucketsDataset(uint dwTitleId, out DataSet dsBuckets, out SqlDataAdapter sdaBuckets)
{
    dsBuckets = new DataSet();
    sdaBuckets = new SqlDataAdapter();
    SqlParameter param = new SqlParameter();
    SqlConnection cxn = OpenSqlConnectionToNPDB();

    // SELECT command

    try
    {
        sdaBuckets.SelectCommand = new SqlCommand(
            "p_match_get_buckets_for_interface_title", cxn);
        sdaBuckets.SelectCommand.CommandType = CommandType.StoredProcedure;
        param = sdaBuckets.SelectCommand.Parameters.Add(
                            "@vc_environment", SqlDbType.NVarChar, 64);
        param.Value = Config.Environment; 
        
        param = sdaBuckets.SelectCommand.Parameters.Add(
                            "@vc_interface", SqlDbType.NVarChar, 64);
        param.Value = Interface.xmatch;

        param = sdaBuckets.SelectCommand.Parameters.Add(
                            "@i_title_id", SqlDbType.Int);
        param.Value = (int)dwTitleId;

        // UPDATE command

        sdaBuckets.UpdateCommand = new SqlCommand(
            "p_config_update_interface_bucket",
            cxn);
        sdaBuckets.UpdateCommand.CommandType = CommandType.StoredProcedure;

        param = sdaBuckets.UpdateCommand.Parameters.Add(
            "@vc_environment", SqlDbType.NVarChar, 64);
        param.SourceColumn = "vc_environment";

        param = sdaBuckets.UpdateCommand.Parameters.Add(
            "@vc_interface", SqlDbType.NVarChar, 64);
        param.SourceColumn = "vc_interface";

        param = sdaBuckets.UpdateCommand.Parameters.Add(
                            "@i_title_id", SqlDbType.Int);
        param.SourceColumn = "i_title_id";

        param = sdaBuckets.UpdateCommand.Parameters.Add(
                            "@i_bucket", SqlDbType.Int);
        param.SourceColumn = "i_bucket";

        param = sdaBuckets.UpdateCommand.Parameters.Add(
            "@vc_server", SqlDbType.NVarChar, 64);
        param.SourceColumn = "vc_server";

        param = sdaBuckets.UpdateCommand.Parameters.Add(
            "@vc_next_server", SqlDbType.NVarChar, 64);
        param.SourceColumn = "vc_next_server";

        param = sdaBuckets.UpdateCommand.Parameters.Add(
            "@dt_migration_start", SqlDbType.DateTime);
        param.SourceColumn = "dt_migration_start";

        param = sdaBuckets.UpdateCommand.Parameters.Add(
            "@vc_info1", SqlDbType.NVarChar, 256);
        param.SourceColumn = "vc_info1";

        param = sdaBuckets.UpdateCommand.Parameters.Add(
            "@vc_info2", SqlDbType.NVarChar, 256);
        param.SourceColumn = "vc_info2";

        param = sdaBuckets.UpdateCommand.Parameters.Add(
            "@vc_info3", SqlDbType.NVarChar, 256);
        param.SourceColumn = "vc_info3";

        param = sdaBuckets.UpdateCommand.Parameters.Add(
            "@vc_info4", SqlDbType.NVarChar, 256);
        param.SourceColumn = "vc_info4";


        // INSERT command

        sdaBuckets.InsertCommand = new SqlCommand(
            "p_config_insert_interface_bucket",
            cxn);
        sdaBuckets.InsertCommand.CommandType = CommandType.StoredProcedure;

        param = sdaBuckets.InsertCommand.Parameters.Add(
            "@vc_environment", SqlDbType.NVarChar, 64);
        param.SourceColumn = "vc_environment";

        param = sdaBuckets.InsertCommand.Parameters.Add(
            "@vc_interface", SqlDbType.NVarChar, 64);
        param.SourceColumn = "vc_interface";

        param = sdaBuckets.InsertCommand.Parameters.Add(
                            "@i_title_id", SqlDbType.Int);
        param.SourceColumn = "i_title_id";

        param = sdaBuckets.InsertCommand.Parameters.Add(
                            "@i_bucket", SqlDbType.Int);
        param.SourceColumn = "i_bucket";

        param = sdaBuckets.InsertCommand.Parameters.Add(
            "@vc_server", SqlDbType.NVarChar, 64);
        param.SourceColumn = "vc_server";

        param = sdaBuckets.InsertCommand.Parameters.Add(
            "@vc_next_server", SqlDbType.NVarChar, 64);
        param.SourceColumn = "vc_next_server";

        param = sdaBuckets.InsertCommand.Parameters.Add(
            "@dt_migration_start", SqlDbType.DateTime);
        param.SourceColumn = "dt_migration_start";

        param = sdaBuckets.InsertCommand.Parameters.Add(
            "@vc_info1", SqlDbType.NVarChar, 256);
        param.SourceColumn = "vc_info1";

        param = sdaBuckets.InsertCommand.Parameters.Add(
            "@vc_info2", SqlDbType.NVarChar, 256);
        param.SourceColumn = "vc_info2";

        param = sdaBuckets.InsertCommand.Parameters.Add(
            "@vc_info3", SqlDbType.NVarChar, 256);
        param.SourceColumn = "vc_info3";

        param = sdaBuckets.InsertCommand.Parameters.Add(
            "@vc_info4", SqlDbType.NVarChar, 256);
        param.SourceColumn = "vc_info4";


        // DELETE command

        sdaBuckets.DeleteCommand = new SqlCommand(
            "p_config_delete_interface_bucket",
            cxn);
        sdaBuckets.DeleteCommand.CommandType = CommandType.StoredProcedure;

        param = sdaBuckets.DeleteCommand.Parameters.Add(
            "@vc_environment", SqlDbType.NVarChar, 64);
        param.SourceColumn = "vc_environment";

        param = sdaBuckets.DeleteCommand.Parameters.Add(
            "@vc_interface", SqlDbType.NVarChar, 64);
        param.SourceColumn = "vc_interface";

        param = sdaBuckets.DeleteCommand.Parameters.Add(
                            "@i_title_id", SqlDbType.Int);
        param.SourceColumn = "i_title_id";

        param = sdaBuckets.DeleteCommand.Parameters.Add(
                            "@i_bucket", SqlDbType.Int);
        param.SourceColumn = "i_bucket";

        sdaBuckets.Fill(dsBuckets, "t_interface_buckets");
        
    }
    finally
    {
        if(cxn != null)
        {
            cxn.Close();
        }
    }

}

// returns a dataset containing all the titles for the given server (in dsBuckets)
// because it's not expected that this list will neet to be modified, the accompanying
// sqldataadapter is not returned.
public static void GetServerTitlesDataset(string strServerName, out DataSet dsBuckets)
{
    dsBuckets = new DataSet();
    SqlDataAdapter sdaBuckets = new SqlDataAdapter();
    SqlParameter param = new SqlParameter();
    SqlConnection cxn = OpenSqlConnectionToNPDB();

    // SELECT command

    try
    {
        sdaBuckets.SelectCommand = new SqlCommand(
            "p_match_get_titles_for_server", cxn);
        sdaBuckets.SelectCommand.CommandType = CommandType.StoredProcedure;
        param = sdaBuckets.SelectCommand.Parameters.Add(
                            "@vc_environment", SqlDbType.NVarChar, 64);
        param.Value = Config.Environment; 
        
        param = sdaBuckets.SelectCommand.Parameters.Add(
                            "@vc_interface", SqlDbType.NVarChar, 64);
        param.Value = Interface.xmatch;

        param = sdaBuckets.SelectCommand.Parameters.Add(
                            "@vc_server", SqlDbType.NVarChar, 64);
        param.Value = strServerName;

        sdaBuckets.Fill(dsBuckets, "t_interface_buckets");
        
    }
    finally
    {
        if(cxn != null)
        {
            cxn.Close();
        }
    }

}

    private static string ServerListToString(string[] servers)
    {
        // convert the array of servers to a semicolon delimited list of servers
        StringBuilder sb = new StringBuilder();
        bool firstServer = true;
        foreach (string server in servers)
        {
            if (firstServer)
            {
                firstServer = false;
            }
            else
            {
                sb.Append(";");
            }
            sb.Append(server.ToLower());
        }
        return sb.ToString();
    }

    private static string[] ServerListFromString(string serverListString)
    {
         string []serverListArray = serverListString.Trim().ToLower().Split(new char[]{';'}, StringSplitOptions.RemoveEmptyEntries);
         return serverListArray;
    }

    private static SqlConnection OpenSqlConnectionToNPDB()
    {
        SqlConnection cxn = new SqlConnection(Config.NpdbConnectionString);
        cxn.Open();
        return cxn;
    }

    private static void RunSqlStatements(string[] sqlStatements, SqlConnection cxn, SqlParameter[] rgParams)
    {
        for(int i = 0; i < sqlStatements.Length; ++i)
        {
            try
            {
                RunSqlStatement(sqlStatements[i], cxn, rgParams);
            }
            catch(Exception ex)
            {
                // Log the failure sql statement and rethrow
                LogError("[MatchAdmin.RunSqlStatements]: An exception occurred: " + ex.ToString() 
                        + "\n-----------------\nThe following statement failed:\n-----------------\n" 
                        + sqlStatements[i]);
                throw;
            }
        }
    }

    private static void RunSqlStatement(string sqlStatement, SqlConnection cxn, SqlParameter[] rgParams)
    {
        using (SqlCommand cmd = cxn.CreateCommand())
        {
            cmd.CommandText = sqlStatement;
            cmd.CommandType = CommandType.Text;

            if(rgParams != null && rgParams.Length > 0)
            {
                for(int iParam = 0; iParam < rgParams.Length; iParam++)
                {
                    cmd.Parameters.Add(rgParams[iParam]);
                }
            }
            
            cmd.ExecuteNonQuery();
            cmd.Parameters.Clear();
        }
    }

    // TODO: the match LTC serialization code really needs to be moved into the general
    // LTC serialization... the only gotcha right now is the partition map, which doesn't deserialize
    // like we'd want it to.
    private static void UpdateLtc(MatchLtcConfig matchLtcConfig)
    {
        string ltc = GetLiveTitleConfig(matchLtcConfig.TitleId);

        Log("[MatchAdmin.UpdateLtc]: Loading live title config data into XmlDocument");
        XmlDocument doc = new XmlDocument();
        doc.LoadXml(ltc);

        XmlNamespaceManager nsmgr = new XmlNamespaceManager(doc.NameTable);
        nsmgr.AddNamespace("ltc", "http://www.xboxlive.com/livetitleconfig");
        XmlNode node = null;

        // serialize the MatchInterfaceBuckets list into the LTC file.  (it'll be null for Xbox1)
        string strPartitionXml = null;
        if(matchLtcConfig.MatchInterfaceBuckets != null)
        {
            strPartitionXml = matchLtcConfig.SerializeBuckets();
        }
        
        if(strPartitionXml != null && strPartitionXml != String.Empty)
        {
            node = doc.SelectSingleNode("/ltc:LiveTitleConfig/ltc:MatchPartitions", nsmgr);
            if (node != null)   // we're replacing the old partition map.
            {
                node.InnerXml = strPartitionXml;
            }
            else    // we're putting a partition map in for the first time.
            {
                //Create a new node and stick it under LiveTitleConfig
                XmlNode nodeLtc = doc.SelectSingleNode("/ltc:LiveTitleConfig", nsmgr);
                XmlElement xelt = doc.CreateElement("MatchPartitions", "http://www.xboxlive.com/livetitleconfig");  
                xelt.InnerXml = strPartitionXml;
                nodeLtc.AppendChild(xelt);
            }
        }
        else // we're just using a server list
        {
            node = doc.SelectSingleNode("/ltc:LiveTitleConfig/ltc:MatchServerList", nsmgr);
            if (node == null)
            {
                throw new ExceptionWithEventId(XEvent.Id.COMMON_CONFIG_MATCH_UPDLTC_INVALID_LTC,
                    "[MatchAdmin.UpdateLtc]: Invalid live title config xml: Could not find /LiveTitleConfig/MatchServerList");
            }

            string curMatchServerList = node.InnerText;

            Log("[MatchAdmin.UpdateLtc]: Updating servers in live title config: ("
                    + curMatchServerList + ") -> (" + matchLtcConfig.MatchServerList + ")");

            node.InnerText = matchLtcConfig.MatchServerList;
        }

        // 
        // Update DeleteDelaySeconds in the XML document
        //
        node = doc.SelectSingleNode("/ltc:LiveTitleConfig/ltc:MatchDeleteDelaySeconds",  nsmgr);
        if(node != null)
        {
            node.InnerText = matchLtcConfig.DeleteDelaySeconds.ToString();
            Log("[MatchAdmin.UpdateLtc]: Updated delete delay seconds in live title config to: " + node.InnerText);
        }
        else
        {
            Log("[MatchAdmin.UpdateLtc]: Could not find /LiveTitleConfig/MatchDeleteDelaySeconds element it will default to zero on the server");
        }

        //
        // Update cross platform status in the XML document
        //
        node = doc.SelectSingleNode("/ltc:LiveTitleConfig/ltc:MatchCrossPlatform", nsmgr);
        if(node != null)
        {
            node.InnerText = matchLtcConfig.CrossPlatform.ToString();
            Log("[MatchAdmin.UpdateLtc]: Cross platform state updated to: " + node.InnerText);
        }
        else
        {
            Log("[MatchAdmin.UpdateLtc]: Could not find /LiveTitleConfig/MatchCrossPlatform element it will default to NotSupported"); 
        }

        //
        // Update/create session cleanup configuration params in the XML document
        //

        AddSimpleElementToLtc(doc, nsmgr, "MatchSessionLimitJobExists", matchLtcConfig.MatchSessionLimitJobExists.ToString().ToLower());
        AddSimpleElementToLtc(doc, nsmgr, "MatchSessionLimitEnabled", matchLtcConfig.MatchSessionLimitEnabled.ToString().ToLower());
        AddSimpleElementToLtc(doc, nsmgr, "MatchSessionMaxAvail", matchLtcConfig.MatchSessionMaxAvail.ToString());
        AddSimpleElementToLtc(doc, nsmgr, "MatchSessionTruncateLevelAvail", matchLtcConfig.MatchSessionTruncateLevelAvail.ToString());
        AddSimpleElementToLtc(doc, nsmgr, "MatchSessionWarnLevelAvail", matchLtcConfig.MatchSessionWarnLevelAvail.ToString());
        AddSimpleElementToLtc(doc, nsmgr, "MatchSessionMaxUnavail", matchLtcConfig.MatchSessionMaxUnavail.ToString());
        AddSimpleElementToLtc(doc, nsmgr, "MatchSessionTruncateLevelUnavail", matchLtcConfig.MatchSessionTruncateLevelUnavail.ToString());
        AddSimpleElementToLtc(doc, nsmgr, "MatchSessionWarnLevelUnavail", matchLtcConfig.MatchSessionWarnLevelUnavail.ToString());
        AddSimpleElementToLtc(doc, nsmgr, "MatchSessionCleanupPeriodMinutes", matchLtcConfig.MatchSessionCleanupPeriodMinutes.ToString());
        AddSimpleElementToLtc(doc, nsmgr, "MatchSessionCleanupOffsetMinutes", matchLtcConfig.MatchSessionCleanupOffsetMinutes.ToString());
        
        MemoryStream memStream = new MemoryStream();
        XmlTextWriter xmlWriter = new XmlTextWriter(memStream, null); // UTF8
        xmlWriter.Formatting = Formatting.Indented;
        doc.WriteTo(xmlWriter);
        xmlWriter.Flush();
        memStream.Seek(0, SeekOrigin.Begin);
        StreamReader reader = new StreamReader(memStream);
        string newXml = reader.ReadToEnd();

        // codyluit: We are removing this because now with MIX we are no longer using TitleVault and keeping this would break the tool.
        //           We will be removing all of titlevault soon.
        // stick it in the titlevault
        //string strTempFile = "";
        //try
        //{
        //    string strTitleRoot = TitleVault.GetTitleVaultRootPath(matchLtcConfig.TitleId);
        //    string strFilename = matchLtcConfig.TitleId.ToString("X8") + "_LTC.xml";
        //    strTempFile = Path.Combine(Path.GetTempPath(), strFilename);
        //    StreamWriter swLtc= new StreamWriter(strTempFile);
        //    swLtc.Write(newXml);
        //    swLtc.Close();
        //    TitleVault.TitleVaultCopy(strTitleRoot, strTempFile, strFilename);
        //}
        //catch(Exception e)
        //{
        //    throw new ExceptionWithEventId(XEvent.Id.COMMON_CODE_MATCH_UPDLTC_TV_FAILED,
        //        "[MatchAdmin.UpdateLtc]: Failed to update LTC in titlevault.  Exception: " + e.ToString());
        //}
        //finally
        //{
        //    File.Delete(strTempFile);
        //}

        // stick it in the NPDB
        try
        {
        SetLiveTitleConfig(matchLtcConfig.TitleId, newXml);
        }
        catch(Exception e)
        {
            throw new ExceptionWithEventId(XEvent.Id.COMMON_CODE_MATCH_UPDLTC_NPDB_FAILED,  
                "[MatchAdmin.UpdateLtc]: Failed to update LTC in NPDB, but TitleVault may be updated.  Please fix manually!  Exception: " + e.ToString());
        }
    }

    private static void AddSimpleElementToLtc(XmlDocument doc, XmlNamespaceManager nsmgr, string strEltName, string strEltValue)
    {
        XmlNode node = doc.SelectSingleNode("/ltc:LiveTitleConfig/ltc:" + strEltName, nsmgr);
        if(node != null)
        {
            node.InnerText = strEltValue;
            Log("[MatchAdmin.UpdateLtc]: " + strEltName + " updated to: " + node.InnerText);
        }
        else
        {
            Log("[MatchAdmin.UpdateLtc]: Could not find /LiveTitleConfig/" + strEltName + " element -- creating!"); 
            //Create a new node and stick it under LiveTitleConfig
            XmlNode nodeLtc = doc.SelectSingleNode("/ltc:LiveTitleConfig", nsmgr);
            XmlElement xelt = doc.CreateElement(strEltName, "http://www.xboxlive.com/livetitleconfig");  
            xelt.InnerText = strEltValue;
            nodeLtc.AppendChild(xelt);
        }
    }

    public static void HealthCheck()
    {
        string[] servers = Config.GetServerListByInterface(Interface.xmatchfd_int);

        Log("[MatchAdmin.HealthCheck]: Sending health check XRL to: " + ServerListToString(servers));

        foreach (string server in servers)
        {
            try
            {
                HealthCheck(server);
            }
            catch (Exception e)
            {
                LogError("[MatchAdmin.HealthCheck]: HealthCheck on " + server + " threw exception, details:"
                    + e.Message + "\n" + e.StackTrace);
                // do not rethrow, continue with next server
            }
        }
    }

    public static void HealthCheck(string server)
    {
        byte[] postData = new byte[0];
        byte[] responseData;
        string xErr;
        HResult hr;

        IInterfaceInfo iinfo = Config.GetInterface(server, Interface.xmatchfd_int);
        string url = iinfo.Url + iinfo.VDir + "/health.ashx";
        WebClient myWebClient = new WebClient();
        try
        {
            Log("[MatchAdmin.HealthCheck]: Posting request to " + server + " (" + url +
                ") to ensure match component is loaded");

            // match is service 6 - must have this header or xrlscan will reject
            // the request
            myWebClient.Headers.Add("Content-Type", "xon/6");

            responseData = myWebClient.UploadData(url, "POST", postData);

            hr = HResult.S_OK;
            xErr = myWebClient.ResponseHeaders["X-Err"];
            if (xErr != null)
            {
                hr = HResult.Parse(xErr);
            }
            if (HResult.Failed(hr))
            {
                LogError("[MatchAdmin.HealthCheck]: Health Check Failed with X-Err: " + hr);
            }
        }
        catch (WebException e)
        {
            LogError("[MatchAdmin.HealthCheck]: Health Check Failed by throwing WebException, e.Message: " + e.Message);
        }
    }

    public static void ReloadTitleInfo()
    {
        string[] servers = Config.GetServerListByInterface(Interface.xmatchfd_int);

        Log("[MatchAdmin.ReloadTitleInfo]: Sending " + MatchXmgmtCommand.RELOADTITLEINFO 
                + " xmgmt command to " + ServerListToString(servers));
        foreach (string server in servers)
        {
            try
            {
                ReloadTitleInfo(server);
            }
            catch (Exception e)
            {
                LogError("[MatchAdmin.ReloadTitleInfo]: Sending " + MatchXmgmtCommand.RELOADTITLEINFO 
                    + " xmgmt command to " + server + " threw exception, details:"
                    + e.Message + "\n" + e.StackTrace);
                // do not rethrow, continue with next server
            }
        }
    }

    public static void ReloadTitleInfo(string server)
    {
        IInterfaceInfo iinfo = Config.GetInterface(server, Interface.xmatchfd_int);
        XomAdminSession xomAdminSession = new XomAdminSession(iinfo.IPAddress);
        try
        {
            string[] responses;
            HResult hr;
            Log("[MatchAdmin.ReloadTitleInfo]: Sending " + MatchXmgmtCommand.RELOADTITLEINFO + " command to " + server);
            xomAdminSession.SendCommand(null, Component.xmatchfd.ToString(),
                MatchXmgmtCommand.RELOADTITLEINFO, iinfo.Timeout, out responses, out hr);
            if (HResult.Failed((uint)hr))
            {
                LogError("[MatchAdmin.ReloadTitleInfo]: Command failed, hr = " + hr);
                foreach (string response in responses)
                {
                    LogError(response);
                }
            }
            else
            {
                Log("[MatchAdmin.ReloadTitleInfo]: Command successful, Responses: ===");
                foreach (string response in responses)
                {
                    Log(response);
                }
                Log("[MatchAdmin.ReloadTitleInfo]: End of xmgmt command responses ===");
            }
        }
        finally
        {
            xomAdminSession.Close();
        }
    }

    private static void ConvertXmsToSql(
        uint titleid,
        string xmsPath,
        bool droptable)
    {
        MatchGameConfig config;

        // Load xml
        XmlDocument doc = new XmlDocument();
        doc.Load(xmsPath);

        // Load xml into game config object
        MatchXmsConfigLoader loader = new MatchXmsConfigLoader();
        loader.Load(doc, _log, out config);

        // Create the sql code generator settings
        MatchSqlCodeGenXbox1.Settings settings = new MatchSqlCodeGenXbox1.Settings();
        settings.DropTable = droptable;
        settings.OutputPath = Config.GetSetting(Setting.titlevault_root) + "\\" + titleid.ToString("X8") + "\\";

        // Emit sql code
        MatchSqlCodeGenXbox1 emitter = new MatchSqlCodeGenXbox1(Console.Out);
        emitter.EmitTitleSQL(config, settings);
    }

    private static void RunXmsToSqlScript(
        uint titleid,
        string[] addServers)
    {
        string workingDir = Config.GetSetting(Setting.titlevault_root)
            + "\\" + titleid.ToString("X8");

        string scriptName = workingDir + "\\" + titleid.ToString("X8") + ".sql";
        foreach (string server in addServers)
        {
            RunSqlScript(workingDir, scriptName, server);
        }
    }

    private static void RunSqlScript(string workingDir, string script, string server)
    {
        string file = "sqlcmd.exe";
        string args = "-S " + server + " -i \"" + script + "\" -d xmatch -E";

        Log("[MatchAdmin.RunSqlScript]: Running Xbox1 SQL script on database " + server + " : " + file + " " + args);

        Process p = new Process();
        p.StartInfo.WorkingDirectory = workingDir;
        p.StartInfo.FileName = file;
        p.StartInfo.Arguments = args;
        p.StartInfo.CreateNoWindow = true;
        p.StartInfo.UseShellExecute = false;
        p.StartInfo.RedirectStandardOutput = true;
        p.StartInfo.RedirectStandardError = true;
        p.Start();

        string output = p.StandardOutput.ReadToEnd();
        output += p.StandardError.ReadToEnd();
        p.WaitForExit();

        Log("[MatchAdmin.RunSqlScript]: sqlcmd.exe exit code: " + p.ExitCode);
        Log(output);

        if (p.ExitCode != 0)
        {
            throw new ExceptionWithEventId(XEvent.Id.MATCH_CONFIG_5,
                "[MatchAdmin.RunSqlScript]: Error executing sqlcmd.exe.\n"
                + "sqlcmd.exe output follows this line ===\n"
                + output);
        }
    }

    public static void SetCrossPlatformRevokeState(uint dwTitleId, CrossPlatformRevokeState revoke)
    {
        SqlConnection cxn = OpenSqlConnectionToNPDB();
        string []revokeSql = { "NULL", "0", "1" };
        string stmt = String.Format(
                "update t_match_titles set ti_revoke_cross_platform = {0} where i_title_id = 0x{1:X}",
                revokeSql[(int)revoke],
                dwTitleId);

        RunSqlStatement(stmt, cxn, null);
    }


// based on the serverlist in matchLtcConfig and the types/modes in matchGameConfig, 
    // create a list of buckets for the title.  THis is for use when the title is using a server list
    // instead of a partition map in the LTC.
    // modifies matchLtcConfig.
    public static void MakeDefaultBuckets(ref MatchLtcConfig matchLtcConfig, ref MatchGameConfig matchGameConfig, ref DataSet dsBuckets)
    {
        string[] serversInLtc = {};
        
        if(matchLtcConfig.MatchInterfaceBuckets != null && matchLtcConfig.MatchInterfaceBuckets.Count > 0)
        {
            throw new ExceptionWithEventId(XEvent.Id.COMMON_CONFIG_MATCH_DEFAULTBUCKETS_OVERWRITE,
            "ERROR: MatchAdmin.MakeDefaultBuckets tried to overwrite existing partition map in LTC");
        }

        //
        // Get the list of servers from the ltc file
        //
        if (matchLtcConfig.MatchServerList.Trim() != String.Empty)
        {
            serversInLtc = ServerListFromString(matchLtcConfig.MatchServerList);

            // check that all the servers in the ltc file are valid
            foreach (string server in serversInLtc)
            {
                Log("[MatchAdmin.MakeDefaultBuckets]: Resolving interface for server: '" + server + "'");
                ConfirmServer(server);
            }
        }
        
        matchLtcConfig.MatchInterfaceBuckets = new List<MatchInterfaceBucket>();  
        for (byte bType = 0; bType < 2; bType++)  // TODOTHEOM: number of types should be a constant somewhere.
        {
            for (byte iCurrentXlastMode = 0;
                iCurrentXlastMode < matchGameConfig.GameModes.Count;
                iCurrentXlastMode++)
            {
                for (byte bRRId = 0; bRRId < serversInLtc.Length; bRRId++)
                {
                    // create a new bucket and fill out its data
                    MatchInterfaceBucket mib = new MatchInterfaceBucket();
                    mib.bGameTypeId = (byte)bType;
                    mib.bGameModeId = (byte)(matchGameConfig.GameModes[iCurrentXlastMode]).Id;
                    mib.strServerName = serversInLtc[bRRId];
                    mib.bRRId = bRRId;
                    mib.dwBucketId = (uint)(mib.bGameTypeId << 16) |
                                    (uint)(mib.bGameModeId << 8) |
                                    (uint)mib.bRRId;

                    // stick the bucket in the list
                    matchLtcConfig.MatchInterfaceBuckets.Add(mib);

                    // add the bucket to the database too
                    DataRow drNewBucket = dsBuckets.Tables["t_interface_buckets"].NewRow();

                    drNewBucket["vc_environment"] = Config.Environment;
                    drNewBucket["vc_interface"] = Interface.xmatch;  
                    drNewBucket["i_title_id"] = (int)matchLtcConfig.TitleId;
                    drNewBucket["i_bucket"] = (int)mib.dwBucketId;
                    drNewBucket["vc_server"] = serversInLtc[bRRId];
                    drNewBucket["vc_next_server"] = serversInLtc[bRRId];
                    drNewBucket["dt_migration_start"] = new DateTime(1900, 1, 1, 12, 00, 00);
                    drNewBucket["vc_info1"] = "";
                    drNewBucket["vc_info2"] = "";
                    drNewBucket["vc_info3"] = "";
                    drNewBucket["vc_info4"] = "";

                    dsBuckets.Tables["t_interface_buckets"].Rows.Add(drNewBucket);
                    
                }
            }
        }
    }

// checks that the server has the match interface
    public static void ConfirmServer(string strNewServer)
    {
        try
        {
            Config.GetInterface(strNewServer, Interface.xmatch);
        }
        catch (ApplicationException)
        {
            throw new ExceptionWithEventId(XEvent.Id.COMMON_CONFIG_MATCH_CONFIRMSERVER_BADSERVER,
            "[MatchAdmin.ConfirmServer]: Error: Bad server name: '" + strNewServer + "'\n");
        }
    }

    public static string XmsPath(CTitleId tid)
    {
        return Config.GetSetting(Setting.titlevault_root) + "\\" + tid.sTitleIdHexNoPrefix
            + "\\" + tid.sTitleIdHexNoPrefix + ".xms";
    }

    public static bool XmsExists(CTitleId tid)
    {
        string xmsPath = XmsPath(tid);
        Log("[MatchAdmin.XmsExists]: Looking for xms file at: " + xmsPath);
        return File.Exists(xmsPath);
    }

    public static void PrepLiveTitleConfig(uint dwTitleId, out MatchLtcConfig matchLtcConfig, bool fRequireBuckets)
    {
        // retrieve and parse the live title config for this title
        string strLtc = GetLiveTitleConfig(dwTitleId);
        matchLtcConfig = MatchLtcConfig.FromXml(strLtc, Console.Out);
        if (dwTitleId != matchLtcConfig.TitleId)
        {
            throw new ExceptionWithEventId(XEvent.Id.COMMON_CONFIG_MATCH_PREPLTC_TID_MISMATCH,
                "titleid in live title config (ltc) file does not match titleid specified on "
                + "command line");
        }

        if(fRequireBuckets &&
            (matchLtcConfig.MatchInterfaceBuckets == null || matchLtcConfig.MatchInterfaceBuckets.Count == 0))
        {
            throw new ExceptionWithEventId(XEvent.Id.COMMON_CONFIG_MATCH_NO_PARTMAP,    // TODOTHEOM: new eventid
                "You can't perform this operation on a title that has no partition map in the LTC.");
        }
    }

    public static void PrepGameConfig(uint dwTitleId, out MatchGameConfig matchGameConfig)
    {
        // Get Xml from database and parse into dom
        string strXlast = GetGameConfig(dwTitleId);
        matchGameConfig = MatchGameConfig.FromXlast(strXlast, Console.Out);
        if (dwTitleId != matchGameConfig.TitleId)
        {
            throw new ExceptionWithEventId(XEvent.Id.COMMON_CONFIG_MATCH_PREPCONFIG_TID_MISMATCH,
                "titleid in xlast file does not match titleid specified on command line");
        }

        // bug 47263: we've allowed xlast files with maxresults > 50 to get into npdb.
        // we don't want to generate queries with maxresults > 50, so we check the
        // queries here, and set maxresults = 50 if it is currently > 50.
        FixupMaxResults(matchGameConfig);
    }


    public static void FixupMaxResults(MatchGameConfig matchGameConfig)
    {
        foreach (xonline.common.match.MatchQuery query in matchGameConfig.MatchQueries.Values)
        {
            if (query.MaxResults > 50)
            {
                LogError("Warning: Query id " + query.Id + " has MaxResults = " 
                    + query.MaxResults + " in the xlast file. Setting MaxResults=50");
                query.MaxResults = 50;
            }
        }
    }
}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\venturarr\WebUtility.cs ===
﻿using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Net;
using System.Net.Security;
using System.Runtime.Serialization;
using System.Security.Cryptography.X509Certificates;
using System.Text;
using System.Xml;

using xonline.common.config;
using xonline.common.service;
using xonline.common.mgmt;

[assembly: XomAreaDefinition(XomAreaName.msnrrTrace)]
[assembly: XomAreaDefinition(XomAreaName.msnrrLog)]

//
// NOTE:
// NOTE: Code in this file taken from Ventura code-base.
// NOTE:
//
// Adds to Ventura code:
// 1. Replaced .Net 4.0 objects with 3.5 equivalents
//

namespace xonline.common.venturarr
{
    public static class WebUtility
    {
        public static WebProxy Proxy { private get; set; }
        public static int Timeout { private get; set; }

        /// <summary>
        /// Ignores the cert errors.
        /// </summary>
        /// <param name="sender">The sender.</param>
        /// <param name="certificate">The certificate.</param>
        /// <param name="chain">The chain.</param>
        /// <param name="sslPolicyErrors">The SSL policy errors.</param>
        /// <returns>true always</returns>
        public static bool IgnoreCertErrors(object sender, X509Certificate certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors)
        {
            if ( sslPolicyErrors == SslPolicyErrors.None )
            {
                Xom.Trace(XomAreaName.msnrrTrace, LogLevel.L_LOW, "CertificateValidationCallback: no SSL policy errors, returning true.");
                return true;
            }

            Xom.Trace(XomAreaName.msnrrTrace, LogLevel.L_HIGH, "CertificateValidationCallback: SslPolicyErrors={0}", sslPolicyErrors);

            if ( Config.GetBoolSetting(Setting.venturarr_ignoreSslPolicyErrors) )
            {
                Xom.Trace(XomAreaName.msnrrTrace, LogLevel.L_LOW, "CertificateValidationCallback: venturarr_ignoreSslPolicyErrors is true, ignoring the error.");
                return true;
            }

            Xom.Trace(XomAreaName.msnrrTrace, LogLevel.L_LOW, "CertificateValidationCallback: failing due to SSL policy errors.");
            return false;
        }

        /// <summary>
        /// Initializes the <see cref="WebUtility"/> class.
        /// </summary>
        static WebUtility()
        {
            ServicePointManager.ServerCertificateValidationCallback += IgnoreCertErrors;
            ServicePointManager.DefaultConnectionLimit = Config.GetIntSetting(Setting.venturarr_defaultConnectionLimit);;
        }

        /// <summary>
        /// Gets the XML from object.
        /// </summary>
        /// <typeparam name="T">Object type</typeparam>
        /// <param name="obj">The obj.</param>
        /// <returns>object as Xml</returns>
        public static string GetXmlFromObject<T>(T obj)
        {
            string objectAsXml;
            DataContractSerializer dataContractSerializer = new DataContractSerializer(typeof(T));

            using (StringWriter stringWriter = new StringWriter())
            {
                using (XmlTextWriter xmlTextWriter = new XmlTextWriter(stringWriter))
                {
                    dataContractSerializer.WriteObject(xmlTextWriter, obj);
                    objectAsXml = stringWriter.ToString();
                }
            }

            return objectAsXml;
        }

        /// <summary>
        /// Gets the object from XML string.
        /// </summary>
        /// <typeparam name="T">Type </typeparam>
        /// <param name="s">The string.</param>
        /// <returns>object </returns>
        public static T GetObjectFromXmlString<T>(string s)
        {
            T obj = Activator.CreateInstance<T>();
            using (MemoryStream ms = new MemoryStream(Encoding.UTF8.GetBytes(s)))
            {
                DataContractSerializer serializer = new DataContractSerializer(obj.GetType());
                obj = (T)serializer.ReadObject(ms);
            }
            return obj;
        }

        /// <summary>
        /// Gets the web response with post.
        /// </summary>
        /// <param name="url">The URL.</param>
        /// <param name="postData">The post data.</param>
        /// <param name="outHeaders">The out headers.</param>
        /// <param name="credentials">The credentials.</param>
        /// <returns>the httpbody of respose</returns>
        public static string GetWebResponseWithPost(Uri uri, string postData, out Dictionary<string, string> outHeaders, string credentials)
        {
            Dictionary<string, string> customizedHeaders = new Dictionary<string, string>();
            if (credentials != null)
            {
                customizedHeaders.Add("Cookie", credentials);
            }

            return GetWebResponseWithPost(uri, customizedHeaders, postData, out outHeaders, credentials);
        }

        /// <summary>
        /// Gets the web response with post.
        /// </summary>
        /// <param name="url">The URL.</param>
        /// <param name="customizedHeaders">The customized headers.</param>
        /// <param name="postData">The post data.</param>
        /// <param name="contentType">The ContentType of in the header.</param>
        /// <returns>string content of respose</returns>
        public static string GetWebResponseWithPost(Uri uri, Dictionary<string, string> customizedHeaders, string postData, out Dictionary<string, string> outHeaders, string contentType)
        {
            string responseFromServer = string.Empty;
            outHeaders = null;

            try
            {
                HttpWebRequest request = (HttpWebRequest)WebRequest.Create(uri);
                UseWebProxy(ref request);
                request.Method = "POST";
                byte[] byteArray = Encoding.UTF8.GetBytes(postData);
                if (contentType != null)
                {
                    request.ContentType = contentType;
                }
                else
                {
                    request.ContentType = "text/xml";
                }

                request.ContentLength = byteArray.Length;

                if (customizedHeaders != null)
                {
                    foreach (KeyValuePair<string, string> kvp in customizedHeaders)
                    {
                        request.Headers.Set(kvp.Key, kvp.Value);
                    }
                }

                using (Stream dataStream = request.GetRequestStream())
                {
                    dataStream.Write(byteArray, 0, byteArray.Length);
                }

                using (HttpWebResponse response = (HttpWebResponse)request.GetResponse())
                {
                    ProcessResponse(response, true);
                    using (Stream dataStream = response.GetResponseStream())
                    {
                        if (dataStream != null)
                        {
                            using (StreamReader reader = new StreamReader(dataStream))
                            {
                                responseFromServer = reader.ReadToEnd();
                            }
                        }
                    }

                    outHeaders = new Dictionary<string, string>();
                    foreach (var header in response.Headers.AllKeys)
                    {
                        outHeaders.Add(header, response.Headers[header]);
                    }
                }
            }
            catch (WebException wex)
            {
                Xom.Trace(XomAreaName.msnrrTrace, LogLevel.L_LOW, "{0}", wex);
                throw;
            }

            return responseFromServer;
        }

        /// <summary>
        /// Gets the web response.
        /// </summary>
        /// <param name="url">The URL.</param>
        /// <param name="credentials">The credentials.</param>
        /// <returns>response from url</returns>
        public static string GetWebResponse(string url, string credentials)
        {
            return GetWebResponse(url, credentials, null);
        }

        /// <summary>
        /// Gets the web response.
        /// </summary>
        /// <param name="url">The URL.</param>
        /// <param name="credentials">The credentials.</param>
        /// <param name="puid">The puid of the user.</param>
        /// <returns>response from url</returns>
        public static string GetWebResponse(string url, string credentials, string puid)
        {
            string responseFromServer = string.Empty;

            try
            {
                HttpWebRequest request = (HttpWebRequest)WebRequest.Create(url);
                UseWebProxy(ref request);
                request.Method = "GET";

                // add the credentials to the request header
                if (credentials != null)
                {
                    request.Headers.Add("Cookie", credentials);
                }

                // add the puid to the request header
                if (puid != null)
                {
                    request.Headers.Add("x-puid", puid);
                }
                
                using (HttpWebResponse response = (HttpWebResponse)request.GetResponse())
                {
                    ProcessResponse(response, true);
                    using (Stream dataStream = response.GetResponseStream())
                    {
                        if (dataStream != null)
                        {
                            using (StreamReader reader = new StreamReader(dataStream))
                            {
                                responseFromServer = reader.ReadToEnd();
                            }
                        }
                    }
                }
            }
            catch (WebException wex)
            {
                Xom.Trace(XomAreaName.msnrrTrace, LogLevel.L_LOW, "{0}", wex);
                throw;
            }

            return responseFromServer;
        }

        /// <summary>
        /// Posts the web request.
        /// </summary>
        /// <param name="url">The URL.</param>
        /// <param name="postData">The post data.</param>
        /// <param name="credentials">The credentials.</param>
        public static void PostWebRequest(string url, string postData, string credentials)
        {
            SendWebRequest(url, "POST", postData, credentials);
        }

        /// <summary>
        /// Puts the web request.
        /// </summary>
        /// <param name="url">The URL.</param>
        /// <param name="putData">The put data.</param>
        /// <param name="credentials">The credentials.</param>
        public static void PutWebRequest(string url, string putData, string credentials)
        {
            SendWebRequest(url, "PUT", putData, credentials);
        }

        public static void DeleteWebRequest(string url, string credentials)
        {
            SendWebRequest(url, "DELETE", null, credentials);
        }

        /// <summary>
        /// Sends the web request.
        /// </summary>
        /// <param name="url">The URL.</param>
        /// <param name="httpVerb">The HTTP verb.</param>
        /// <param name="data">The data.</param>
        /// <param name="credentials">The credentials.</param>
        private static void SendWebRequest(string url, string httpVerb, string data, string credentials)
        {
            try
            {
                HttpWebRequest request = HttpWebRequest.Create(url) as HttpWebRequest;
                UseWebProxy(ref request);
                request.Method = httpVerb;

                // add the credentials to the request header
                if (credentials != null)
                {
                    request.Headers[HttpRequestHeader.Cookie] = credentials;
                }

                if (data != null)
                {
                    byte[] byteArray = Encoding.UTF8.GetBytes(data);
                    request.ContentType = "text/xml";
                    request.ContentLength = byteArray.Length;
                    using (Stream dataStream = request.GetRequestStream())
                    {
                        dataStream.Write(byteArray, 0, byteArray.Length);
                    }
                }
                else
                {
                    request.ContentLength = 0;
                }

                using (HttpWebResponse response = (HttpWebResponse)request.GetResponse())
                {
                    ProcessResponse(response, false);
                }
            }
            catch (WebException wex)
            {
                Xom.Trace(XomAreaName.msnrrTrace, LogLevel.L_LOW, "{0}", wex);
                throw;
            }
        }

        /// <summary>
        /// Processes the response.
        /// </summary>
        /// <param name="response">The response.</param>
        /// <param name="checkForNullResponse">if set to <c>true</c> [check for null response].</param>
        private static void ProcessResponse(HttpWebResponse response, bool checkForNullResponse)
        {
            if (response.StatusCode != HttpStatusCode.OK)
            {
                throw new WebException(String.Format("StatusCode:{0}", response.StatusCode), (WebExceptionStatus)response.StatusCode);
            }
            if (checkForNullResponse && response.ContentLength == 0)
            {
                throw new WebException(String.Format("StatusCode:{0} but content length is 0", response.StatusCode), (WebExceptionStatus)response.StatusCode);
            }
        }

        /// <summary>
        /// Set WebProxy when needed.
        /// </summary>
        /// <param name="request">The HttpWebRequest.</param>
        public static void UseWebProxy(ref HttpWebRequest request)
        {
            if (Proxy != null)
            {
                request.Proxy = Proxy;
            }
            request.Timeout = Timeout;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\match\match\MatchGameConfig.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Reflection;
using System.Text;
using System.Xml;
using System.Xml.XPath;
using System.IO;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.service;

namespace xonline.common.match
{
    // Exceptions thrown on invalid configuration data
    public class InvalidConfigException : Exception
    {
        public string Context;

        public InvalidConfigException(MatchGameConfig config, string context, string message)
            : base("Invalid configuration title: [" + config.TitleId.ToString("x") + 
                    "], context: [" + context + "], message: " + message) 
        { 

            Context = context;
        }
    }

    // Container for game specific match config data
    public class MatchGameConfig
    {
        public const uint  TYPE_XMS_CONFIG      = 0;
        public const uint  TYPE_XLAST_CONFIG    = 1;

        public uint                TitleId;
        public string              XlastVersion;
        public string              ProjectVersion;

        // Attributes used by XMS files
        public uint                SessionExpiration;
        public uint                Type;
        public string              TitleName;

        // Key: attribute id
        public SortedList          MatchConstants;

        // use an arraylist for MatchSchema to preserve order. This is important
        // for generating SQL code for xbox 1 titles
        public ArrayList           MatchSchema;

        // Key: query id
        public SortedList          MatchQueries;

	    // Stores the list of game modes for this title.  Key is Mode ID.
	    public List<GameMode>   GameModes; 

        public MatchGameConfig(uint type)
        {
            if(type != TYPE_XMS_CONFIG && type != TYPE_XLAST_CONFIG)
            {
                throw new ArgumentException("Unrecognized match config type: " + type);
            }

            Type = type;
        }

        public static MatchGameConfig FromXlast(string xlastXml, TextWriter log)
        {
            XmlDocument doc = new XmlDocument();
            doc.LoadXml(xlastXml);

            // Load the match game config object from the xml
            MatchGameConfig matchGameConfig;
            MatchXlastConfigLoader loader = new MatchXlastConfigLoader();
            loader.Load(doc, log, out matchGameConfig);
            loader.ValidateXlastSemantics(matchGameConfig);
            return matchGameConfig;
        }

        public static MatchGameConfig FromXms(string xmsXml, TextWriter log)
        {
            XmlDocument doc = new XmlDocument();
            doc.LoadXml(xmsXml);

            // Load the match game config object from the xml
            MatchGameConfig matchGameConfig;
            MatchXmsConfigLoader loader = new MatchXmsConfigLoader();
            loader.Load(doc, log, out matchGameConfig);

            return matchGameConfig;
        }
    }

    public class MatchConstant
    {
        public string   Name;
        public uint     Id;
        public string   Value;
        public string   Kind;
    }

    public class MatchSchemaAttribute
    {
        public uint     Id;
        public string   Name;
        public string   Kind;
        public ushort   MaxLength;
    }

    public class MatchQuery
    {
        public uint         Id;
        public string       FriendlyName;
        public uint         MaxResults;
        public string       Type;
        public uint         TypeId;
        public uint         GroupBy;
        public bool         QosProbe;

        // order is significant in parameters for xbox 1 titles, so
        // use array list
        public ArrayList Parameters;

        // filters don't have an order, but also don't have a natural key
        // so use an array list
        public ArrayList Filters;

        // sort operations have an explicit ordering by the ordinal attribute
        // so use a sorted list
        public SortedList SortOps;

        // returns also have an explicity ordering by ordinal
        public SortedList Returns;

        public bool HasParameter(uint id)
        {
            uint paramIndex = (id & MatchDefs.X_ATTRIBUTE_ID_MASK);
            if(paramIndex < Parameters.Count)
            {
                return true;
            }
            else
            {
                return false;
            }
        }

        public bool ParamAllowsNull(uint id)
        {
            if(!MatchDefs.IsAttributeTypeParam(id))
            {
                return false;
            }

            for(int i = 0, c = Parameters.Count; i < c; ++i)
            {
                MatchQueryParam param = Parameters[i] as MatchQueryParam;
                if(     (MatchDefs.IsAttributeDatatypeNull(id) && 
                        ((id & MatchDefs.X_ATTRIBUTE_ID_MASK) == (param.Id & MatchDefs.X_ATTRIBUTE_ID_MASK))) 
                        || id == param.Id)
                {
                    return param.NullOk;
                }
            }
            return false;
        }
    }

    public class MatchQueryParam
    {
        public uint     Id;
        public string   Name;
        public string   Kind;
        public uint     MaxLength;
        public bool     NullOk;
        public bool     IsWeighted;
        public bool     IsExactMatch;
    }

    public class MatchQueryFilter
    {
        public uint     Left;
        public string   LeftType;
        public string   Op;
        public uint     OpId;
        public uint     Right;
        public string   RightType;
    }

    public class MatchQuerySortOp
    {
        public uint     Id;
        public string   Type;
        public uint     TypeId;
        public uint     DistanceId;
        public uint     Ordinal;
    }

    public class MatchQueryReturn
    {
        public uint     Id;
        public string   Type;
        public uint     TypeId;
        public uint     Ordinal;
    }


    public class GameMode
    {
        public byte Id;
        public string FriendlyName;
    }

    public class GameModeComparer : IComparer<GameMode>
    {
        public int Compare(GameMode x, GameMode y)
        {
            if (x == null || y == null)
            {
                throw new ArgumentException("GameModeComparer requires that both buckets be non-null.");
            }
            else
            {
                // ...and y is not null, compare the values.

                // x > y -- 1
                // y > x -- =1
                // x==y -- 0

                return x.Id - y.Id;
            }
        }
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\match\match\MatchLtcConfig.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Reflection;
using System.Text;
using System.IO;
using System.Xml;
using System.Xml.XPath;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.service;

namespace xonline.common.match
{
    public class MatchLtcConfig
    {
        public uint                         TitleId;
        public string                       MatchServerList;
        public uint                         MatchExpiration;
        public uint                         DeleteDelaySeconds;
        public CrossPlatformRevokeState     CrossPlatform;
        public List<MatchInterfaceBucket>   MatchInterfaceBuckets; 
        public string                       strMatchPartitionXml;
        public bool                         MatchSessionLimitJobExists;
        public bool                         MatchSessionLimitEnabled;
        public uint                         MatchSessionMaxAvail;
        public uint                         MatchSessionTruncateLevelAvail;
        public uint                         MatchSessionWarnLevelAvail;
        public uint                         MatchSessionMaxUnavail;
        public uint                         MatchSessionTruncateLevelUnavail;
        public uint                         MatchSessionWarnLevelUnavail;
        public uint                         MatchSessionCleanupPeriodMinutes;
        public uint                         MatchSessionCleanupOffsetMinutes;

        public MatchLtcConfig()
        {
        }

        public static MatchLtcConfig FromXml(string xml, TextWriter log)
        {
            XmlDocument doc = new XmlDocument();
            doc.LoadXml(xml);

            MatchLtcConfig matchLtcConfig;
            MatchLtcConfigLoader loader = new MatchLtcConfigLoader();
            loader.Load(doc, log, out matchLtcConfig);

            return matchLtcConfig;
        }

        // returns a string (xml) representation of the contents of MatchInterfaceBuckets.
        public string SerializeBuckets()
        {
            byte bCurrentType = 0;
            byte bCurrentMode = 0;
            int iRR = 0;
            bCurrentType = MatchInterfaceBuckets[0].bGameTypeId;
            bCurrentMode = MatchInterfaceBuckets[0].bGameModeId;
            string strXml = "<GameType xmlns=\"http://www.xboxlive.com/livetitleconfig\" typeid=\"" + bCurrentType + "\">\r\n      <GameMode modeid=\"" + bCurrentMode + "\">\r\n";

            // assumes that the buckets are sorted by bucket id.
            foreach(MatchInterfaceBucket mib in MatchInterfaceBuckets)
            {
                if(mib.bGameModeId != bCurrentMode && mib.bGameTypeId == bCurrentType)
                {
                    // new game mode, same game type.  Just open a new mode...
                    bCurrentMode = mib.bGameModeId;
                    strXml += "      </GameMode>\r\n      <GameMode modeid=\"" + bCurrentMode + "\">\r\n";
                    iRR = 0;
                }
                else if(mib.bGameTypeId != bCurrentType)
                {
                    // new game type... close the old type + mode, open a new type + mode.
                    bCurrentMode = mib.bGameModeId;
                    bCurrentType = mib.bGameTypeId;
                    strXml += "      </GameMode>\r\n    </GameType>\r\n    <GameType xmlns=\"http://www.xboxlive.com/livetitleconfig\" typeid=\"" + bCurrentType + "\">\r\n" + "      <GameMode modeid=\"" + bCurrentMode + "\">\r\n";
                    iRR = 0;
                }
                // write the actual data...
                strXml += "        <RRServer servername=\"" + mib.strServerName + "\" />\r\n";
                if(iRR != (int)mib.bRRId)
                {
                    throw new ExceptionWithEventId(XEvent.Id.MATCH_CONFIG_47,  // TODOTHEOM: new event ID
                            "MatchLtcConfig.SerializeBuckets: Error when serializing... mismatched RR indexes.");
                }
                iRR++; // keep track of the RR index, to double-check against rrid.
            }
            // close up the final type/mode
            strXml += "      </GameMode>\r\n    </GameType>\r\n";
            return strXml;
        }
    }

    public class MatchInterfaceBucket
    {
        public byte bGameTypeId;
        public byte bGameModeId;
        public byte bRRId;              // offset of this server
        public string strServerName;    // name of this server
        public uint dwBucketId;
    }

    public class MatchInterfaceBucketComparer : IComparer<MatchInterfaceBucket>
    {
        public int Compare(MatchInterfaceBucket x, MatchInterfaceBucket y)
        {
            if (x == null || y == null)
            {
                throw new ArgumentException("MatchInterfaceBucketComparer requires that both buckets be non-null.");
            }
            else
            {
                // x > y -- 1
                // y > x -- =1
                // x==y -- 0

                // would just do x-y, but afraid of overflow.
                if (x.dwBucketId == y.dwBucketId)
                    return 0;
                else if (x.dwBucketId > y.dwBucketId)
                    return 1;
                else
                    return -1;
            }
        }
    }


    public class MatchLtcConfigLoader
    {
        TextWriter _log;

        private void Log(string msg)
        {
            _log.WriteLine(msg);
        }

        private void LogError(string msg)
        {
            _log.WriteLine(msg);
        }

        public void Load(XmlDocument doc, TextWriter log, out MatchLtcConfig config)
        {
            if(null == doc || null == log)
            {
                throw new ArgumentException("Load() requires a valid DOM document and log destination");
            }

            _log = log;
            config = new MatchLtcConfig();

            Log("Loading live title config data into XmlDocument");


            XPathNavigator root = doc.CreateNavigator();
            XmlNamespaceManager nsmgr = new XmlNamespaceManager(root.NameTable);
            nsmgr.AddNamespace("ltc", "http://www.xboxlive.com/livetitleconfig");

            //
            // TitleID
            //
            XPathNodeIterator it = SelectWithNamespace(root, nsmgr, "/ltc:LiveTitleConfig/ltc:TitleID");
            if (it.Count == 0)
            {
                throw new ExceptionWithEventId(XEvent.Id.MATCH_CONFIG_47,
                        "Invalid live title config xml: Could not find /LiveTitleConfig/TitleID");
            }
            if (it.Count > 1)
            {
                throw new ExceptionWithEventId(XEvent.Id.MATCH_CONFIG_48,
                        "Invalid live title config xml: More than one /LiveTitleConfig/TitleID node");
            }
            it.MoveNext();

            string titleId = it.Current.Value;
            if (titleId == String.Empty)
            {
                throw new ExceptionWithEventId(XEvent.Id.MATCH_CONFIG_49,
                        "Invalid live title config xml: /LiveTitleConfig/TitleID element is empty");
            }
            try
            {
                config.TitleId = MatchXlastConfigLoader.ParseUInt32(titleId);
            }
            catch (Exception e)
            {
                throw new ExceptionWithEventId(XEvent.Id.MATCH_CONFIG_50,
                        "Invalid live title config xml: Exception parsing /LiveTitleConfig/TitleID element "
                        + "as integer, value: " + titleId, e);
            }
            Log("TitleID: " + config.TitleId.ToString("X8"));


            //
            // MatchPartitions
            //
            // TODOTHEOM: put this in its own function
            it = SelectWithNamespace(root, nsmgr, "/ltc:LiveTitleConfig/ltc:MatchPartitions");
            if(it.Count > 0) // this title is configured for partitioning
            {
                // TODO2THEOM: this saving should be temporary... better to round-trip using deserialize/serialize?
                // take the matchpartitions subtree, and save it off so that we can write it back 
                // to the LTC later.  (once we've determined everything's ok with it)

                it = SelectWithNamespace(root, nsmgr, "/ltc:LiveTitleConfig/ltc:MatchPartitions/ltc:GameType");
                if (it.Count < 2)
                {
                    throw new ExceptionWithEventId(XEvent.Id.MATCH_CONFIG_51,  // TODOTHEOM: new id here.
                            "Invalid live title config xml: Error in /LiveTitleConfig/MatchPartitions/GameType, " +
                            "number of game types is < 2.");
                }
                if (it.Count > 2)
                {
                    throw new ExceptionWithEventId(XEvent.Id.MATCH_CONFIG_52, // TODOTHEOM: new id here.
                            "Invalid live title config xml: Error in /LiveTitleConfig/MatchPartitions/GameType, " +
                            "number of game types is > 2");
                }
                
                config.MatchInterfaceBuckets = new List<MatchInterfaceBucket>();

                while(it.MoveNext()) // loop over types
                {
                    XPathNodeIterator itModes = it.Current.SelectChildren(XPathNodeType.Element);
                    while(itModes.MoveNext()) // loop over modes for the type
                    {
                        XPathNodeIterator itRR = itModes.Current.SelectChildren(XPathNodeType.Element);
                        byte bRR = 0;
                        while(itRR.MoveNext()) // loop over RR servers for the mode+type
                        {
                            // create a new bucket and fill out its data
                            MatchInterfaceBucket mib = new MatchInterfaceBucket();
                            mib.bGameTypeId = Convert.ToByte(GetCurrentAttributeValueFromIter(it, "typeid", true));
                            mib.bGameModeId = Convert.ToByte(GetCurrentAttributeValueFromIter(itModes, "modeid", true));
                            mib.strServerName = GetCurrentAttributeValueFromIter(itRR, "servername", true);
                            mib.bRRId = bRR;

                            mib.dwBucketId = (uint)(mib.bGameTypeId << 16) |
                                            (uint)(mib.bGameModeId << 8) |
                                            (uint)mib.bRRId;


                            // stick the bucket in the list
                            config.MatchInterfaceBuckets.Add(mib);
                            bRR++;
                        }
                    }
                }
                // sort the list of matchinterfacebuckets, for use later.
                MatchInterfaceBucketComparer mibc = new MatchInterfaceBucketComparer();
                config.MatchInterfaceBuckets.Sort(mibc);

            // TODOTHEOM: do we want to validate that the LTC does (not) have both?
            }
            else // this title has plain old server list configuration
            {
                //
                // MatchServerList
                //
                it = SelectWithNamespace(root, nsmgr, "/ltc:LiveTitleConfig/ltc:MatchServerList");
                if (it.Count == 0)
                {
                    throw new ExceptionWithEventId(XEvent.Id.MATCH_CONFIG_51,
                            "Invalid live title config xml: Could not find /LiveTitleConfig/MatchServerList");
                }
                if (it.Count > 1)
                {
                    throw new ExceptionWithEventId(XEvent.Id.MATCH_CONFIG_52,
                            "Invalid live title config xml: More than one /LiveTitleConfig/MatchServerList node");
                }
                it.MoveNext();

                config.MatchServerList = it.Current.Value;

                // we allow MatchServerList to be empty - we want to be able to delete a title
                // from all match servers
                Log("MatchServerList: " + config.MatchServerList);
            }
            // 
            // Match Expiration
            //
            it = SelectWithNamespace(root, nsmgr, "/ltc:LiveTitleConfig/ltc:MatchExpiration");
            if (it.Count == 0)
            {
                throw new ExceptionWithEventId(XEvent.Id.MATCH_CONFIG_53,
                        "Invalid live title config xml: Could not find /LiveTitleConfig/MatchExpiration");
            }
            if (it.Count > 1)
            {
                throw new ExceptionWithEventId(XEvent.Id.MATCH_CONFIG_54,
                        "Invalid live title config xml: More than one /LiveTitleConfig/MatchExpiration node");
            }
            it.MoveNext();

            string matchExpiration = it.Current.Value;
            if (matchExpiration == String.Empty)
            {
                throw new ExceptionWithEventId(XEvent.Id.MATCH_CONFIG_55,
                        "Invalid live title config xml: /LiveTitleConfig/MatchExpiration element is empty");
            }
            try
            {
                config.MatchExpiration = MatchXlastConfigLoader.ParseUInt32(matchExpiration);
            }
            catch (Exception e)
            {
                throw new ExceptionWithEventId(XEvent.Id.MATCH_CONFIG_56,
                        "Invalid live title config xml: Exception parsing /LiveTitleConfig/MatchExpiration element "
                        + "as integer, value: " + matchExpiration, e);
            }
            Log("MatchExpiration: " + config.MatchExpiration);

            //
            // Delete Delay Seconds
            //
            // Delete delay seconds will default to zero if it does not exist
            //
            it = SelectWithNamespace(root, nsmgr, "/ltc:LiveTitleConfig/ltc:MatchDeleteDelaySeconds");
            if (it.Count > 1)
            {
                throw new ExceptionWithEventId(XEvent.Id.MATCH_CONFIG_70,
                        "Invalid live title config xml: More than one /LiveTitleConfig/MatchDeleteDelaySeconds node");
            }
            else if (it.Count == 1)
            {
                it.MoveNext();

                string matchDeleteDelaySeconds = it.Current.Value;
                if (matchDeleteDelaySeconds != String.Empty)
                {
                    try
                    {
                        config.DeleteDelaySeconds = MatchXlastConfigLoader.ParseUInt32(matchDeleteDelaySeconds);
                    }
                    catch (Exception e)
                    {
                        throw new ExceptionWithEventId(XEvent.Id.MATCH_CONFIG_71,
                                "Invalid live title config xml: Exception parsing /LiveTitleConfig/MatchDeleteDelaySeconds element "
                                + "as integer, value: " + matchDeleteDelaySeconds, e);
                    }
                }
            }
            
            Log("MatchDeleteDelaySeconds: " + config.DeleteDelaySeconds);

            //
            // Cross Platform Revoke
            //
            // Tri-state: NotSupported, Allow or Revoke
            //
            // Defaults and logs to NotSupported when not found or mis-configured
            //
            it = SelectWithNamespace(root, nsmgr, "/ltc:LiveTitleConfig/ltc:MatchCrossPlatform");
            if (it.Count > 1)
            {
                throw new ExceptionWithEventId(XEvent.Id.MATCH_CONFIG_70,
                        "Invalid live title config xml: More than one /LiveTitleConfig/MatchCrossPlatform node");
            }
            else if (it.Count == 1)
            {
                it.MoveNext();

                string crossPlatformRevoke = it.Current.Value;
                if(null != crossPlatformRevoke && String.Empty != crossPlatformRevoke)
                {
                    crossPlatformRevoke = crossPlatformRevoke.Trim().ToLower();
                    switch(crossPlatformRevoke)
                    {
                        default:
                            LogError("Unrecognized /LiveTitleConfig/MatchCrossPlatform element value: " 
                                    + it.Current.Value 
                                    + ", must be one of NotSupported, Allow, Revoke");
                            config.CrossPlatform = CrossPlatformRevokeState.NotSupported;
                            break;
                        case "notsupported":
                            config.CrossPlatform = CrossPlatformRevokeState.NotSupported;
                            break;
                        case "allow":
                            config.CrossPlatform = CrossPlatformRevokeState.Allow;
                            break;
                        case "revoke":
                            config.CrossPlatform = CrossPlatformRevokeState.Revoke;
                            break;
                    }
                }
            }
            else
            {
                config.CrossPlatform = CrossPlatformRevokeState.NotSupported;
            }
            
            Log("MatchCrossPlatform: " + config.CrossPlatform);

            config.MatchSessionLimitJobExists = GetBoolValueFromXml(root, nsmgr, "/ltc:LiveTitleConfig/ltc:MatchSessionLimitJobExists", false /*fRequired*/);

            if(config.MatchSessionLimitJobExists == true)
            {
                config.MatchSessionLimitEnabled = GetBoolValueFromXml(root, nsmgr, "/ltc:LiveTitleConfig/ltc:MatchSessionLimitEnabled", true /*fRequired*/);
                config.MatchSessionMaxAvail = GetUIntValueFromXml(root, nsmgr, "/ltc:LiveTitleConfig/ltc:MatchSessionMaxAvail", true /*fRequired*/);
                config.MatchSessionMaxUnavail = GetUIntValueFromXml(root, nsmgr, "/ltc:LiveTitleConfig/ltc:MatchSessionMaxUnavail", true /*fRequired*/);
                config.MatchSessionTruncateLevelAvail = GetUIntValueFromXml(root, nsmgr, "/ltc:LiveTitleConfig/ltc:MatchSessionTruncateLevelAvail", true /*fRequired*/);
                config.MatchSessionWarnLevelAvail = GetUIntValueFromXml(root, nsmgr, "/ltc:LiveTitleConfig/ltc:MatchSessionWarnLevelAvail", true /*fRequired*/);
                config.MatchSessionTruncateLevelUnavail = GetUIntValueFromXml(root, nsmgr, "/ltc:LiveTitleConfig/ltc:MatchSessionTruncateLevelUnavail", true /*fRequired*/);
                config.MatchSessionWarnLevelUnavail = GetUIntValueFromXml(root, nsmgr, "/ltc:LiveTitleConfig/ltc:MatchSessionWarnLevelUnavail", true /*fRequired*/);
                config.MatchSessionCleanupPeriodMinutes = GetUIntValueFromXml(root, nsmgr, "/ltc:LiveTitleConfig/ltc:MatchSessionCleanupPeriodMinutes", true /*fRequired*/);
                config.MatchSessionCleanupOffsetMinutes = GetUIntValueFromXml(root, nsmgr, "/ltc:LiveTitleConfig/ltc:MatchSessionCleanupOffsetMinutes", true /*fRequired*/);
            }
        }

        private XPathNodeIterator SelectWithNamespace(
                XPathNavigator nav,
                XmlNamespaceManager nsmgr,
                string xpathString)
        {
            XPathExpression xpath = nav.Compile(xpathString);
            xpath.SetContext(nsmgr);
            return nav.Select(xpath);
        }

        private string GetCurrentAttributeValueFromIter(
                XPathNodeIterator it, 
                string strAttrName, 
                bool fFailOnEmpty)
        {
            string strAttrValue = String.Empty;

            strAttrValue = it.Current.GetAttribute(strAttrName, "");
            if (fFailOnEmpty && strAttrValue == String.Empty)
            {
                throw new ExceptionWithEventId(XEvent.Id.MATCH_CONFIG_70, // TODOTHEOM: new eventid here!
                "Error parsing live title config xml: Empty value for attribute which expected a value. " +
                "Attribute name: " + strAttrName);
            }
            return strAttrValue;
        }

        // do some standard parsing of uints.  If something is not required and is absent, return 0.
        private uint GetUIntValueFromXml(XPathNavigator root, XmlNamespaceManager nsmgr, string strXPath, bool fRequired)
        {
            uint uiValue = 0;
            XPathNodeIterator it = SelectWithNamespace(root, nsmgr, strXPath);
            if (it.Count == 0)
            {
                if(fRequired == true)
                {
                    throw new ExceptionWithEventId(XEvent.Id.MATCH_CONFIG_LTC_ELEMENT_MISSING,
                            "Invalid live title config xml: Could not find " + strXPath);
                }
                else
                {
                    return 0;
                }
            }
            if (it.Count > 1)
            {
                throw new ExceptionWithEventId(XEvent.Id.MATCH_CONFIG_LTC_ELEMENT_TOO_MANY,
                        "Invalid live title config xml: More than one " + strXPath + " node");
            }
            it.MoveNext();

            string matchExpiration = it.Current.Value;
            if (matchExpiration == String.Empty)
            {
                throw new ExceptionWithEventId(XEvent.Id.MATCH_CONFIG_LTC_ELEMENT_EMPTY,
                        "Invalid live title config xml: " + strXPath + " element is empty");
            }
            try
            {
                uiValue = MatchXlastConfigLoader.ParseUInt32(matchExpiration);
            }
            catch (Exception e)
            {
                throw new ExceptionWithEventId(XEvent.Id.MATCH_CONFIG_LTC_ELEMENT_PARSE_FAILED,
                        "Invalid live title config xml: Exception parsing " + strXPath + "  element "
                        + "as uint, value: " + uiValue, e);
            }
            Log(strXPath + " resulted had a value of " + uiValue);
            return uiValue;
        }

        // do some standard parsing of bools.  If something is not required and is absent, return 0.
        private bool GetBoolValueFromXml(XPathNavigator root, XmlNamespaceManager nsmgr, string strXPath, bool fRequired)
        {
            bool fValue = false;
            XPathNodeIterator it = SelectWithNamespace(root, nsmgr, strXPath);
            if (it.Count == 0)
            {
                if(fRequired == true)
                {
                    throw new ExceptionWithEventId(XEvent.Id.MATCH_CONFIG_LTC_ELEMENT_MISSING,
                            "Invalid live title config xml: Could not find " + strXPath);
                }
                else
                {
                    return fValue;
                }
            }
            if (it.Count > 1)
            {
                throw new ExceptionWithEventId(XEvent.Id.MATCH_CONFIG_LTC_ELEMENT_TOO_MANY,
                        "Invalid live title config xml: More than one " + strXPath + " node");
            }
            it.MoveNext();

            string strCurrentValue = it.Current.Value;
            if (strCurrentValue == String.Empty)
            {
                throw new ExceptionWithEventId(XEvent.Id.MATCH_CONFIG_LTC_ELEMENT_EMPTY,
                        "Invalid live title config xml: " + strXPath + " element is empty");
            }
            try
            {
                fValue = Convert.ToBoolean(strCurrentValue);
            }
            catch (Exception e)
            {
                throw new ExceptionWithEventId(XEvent.Id.MATCH_CONFIG_LTC_ELEMENT_PARSE_FAILED,
                        "Invalid live title config xml: Exception parsing " + strXPath + "  element "
                        + "as uint, value: " + strCurrentValue, e);
            }
            Log(strXPath + " resulted had a value of " + fValue);
            return fValue;
        }



        
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\match\match\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__match_2_none_12.4.56.0_none_da24a66d67f370e9
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__match_2_no-public-key_12.4.56.0_x-ww_249b730f
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_match_2
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__match_2_no-public-key_12.4.56.0_x-ww_249b730f
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__match_2_no-public-key_12.4.56.0_x-ww_249b730f.manifest
XP_MANIFEST_PATH=manifests\x86__match_2_no-public-key_12.4.56.0_x-ww_249b730f.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__match_2_no-public-key_12.4.56.0_x-ww_249b730f.cat
XP_CATALOG_PATH=manifests\x86__match_2_no-public-key_12.4.56.0_x-ww_249b730f.cat
XP_PAYLOAD_PATH=x86__match_2_no-public-key_12.4.56.0_x-ww_249b730f
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_match_2,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\match\match\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__match_2_none_12.4.56.0_none_da24a66d67f370e9
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__match_2_no-public-key_12.4.56.0_x-ww_249b730f
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_match_2
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__match_2_no-public-key_12.4.56.0_x-ww_249b730f
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__match_2_no-public-key_12.4.56.0_x-ww_249b730f.manifest
XP_MANIFEST_PATH=manifests\x86__match_2_no-public-key_12.4.56.0_x-ww_249b730f.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__match_2_no-public-key_12.4.56.0_x-ww_249b730f.cat
XP_CATALOG_PATH=manifests\x86__match_2_no-public-key_12.4.56.0_x-ww_249b730f.cat
XP_PAYLOAD_PATH=x86__match_2_no-public-key_12.4.56.0_x-ww_249b730f
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_match_2,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\Memcache\Acceleration\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\match\match\MatchXmsConfigLoader.cs ===
using System;
using System.Collections;
using System.Text;
using System.Xml;
using System.IO;

using xonline.common.protocol;

namespace xonline.common.match
{
    // Loader for xbox 1 match data. This was ported from xenon\main\core\private\tools\match\xmltosql 
    // and xenon\main\core\private\tools\match\xmslib
    public class MatchXmsConfigLoader
    {
        MatchGameConfig     _outputConfig;
        TextWriter          _outputLog;
        Hashtable           _globals;

        public MatchXmsConfigLoader()
        {
            // Initialize global attribute Ids
            _globals = new Hashtable();
            _globals["SESSION.ID"]               = MatchDefs.X_ATTRIBUTE_XBOX1_SESSION_ID;
            _globals["SESSION.PUBAVAIL"]         = MatchDefs.X_ATTRIBUTE_XBOX1_PUB_AVAIL;
            _globals["SESSION.PRIVAVAIL"]        = MatchDefs.X_ATTRIBUTE_XBOX1_PRIV_AVAIL;
            _globals["SESSION.PUBCURR"]          = MatchDefs.X_ATTRIBUTE_XBOX1_PUB_CURR;
            _globals["SESSION.PRIVCURR"]         = MatchDefs.X_ATTRIBUTE_XBOX1_PRIV_CURR;
            _globals["SESSION.DISTANCE"]         = MatchDefs.X_ATTRIBUTE_XBOX1_DISTANCE;
            _globals["SESSION.APPROXDISTANCE"]   = MatchDefs.X_ATTRIBUTE_XBOX1_APPROX_DISTANCE;
            _globals["SESSION.NUMATTRS"]         = MatchDefs.X_ATTRIBUTE_XBOX1_NUM_ATTRS;
            _globals["SESSION.HOSTADDR"]         = MatchDefs.X_ATTRIBUTE_XBOX1_HOST_ADDR;
            _globals["SESSION.SESSIONKEY"]       = MatchDefs.X_ATTRIBUTE_XBOX1_SESSION_KEY;
        }

        public void Load(XmlDocument input, TextWriter log, out MatchGameConfig output)
        {
            if(null == input || null == log)
            {
                throw new ArgumentException("Load() requires a valid DOM document and log destination");
            }

            output = new MatchGameConfig(MatchGameConfig.TYPE_XMS_CONFIG);
            _outputLog = log;
            _outputConfig = output;

            XmlElement documentEl = input.DocumentElement;
            if(null == documentEl)
            {
                throw new InvalidConfigException(
                        _outputConfig,
                        "Load",
                        "Invalid XMS file, document element was not found");
            }
            if("matchsim" != documentEl.Name)
            {
                throw new InvalidConfigException(
                        _outputConfig, 
                        NodeContext(documentEl),
                        "Invalid XMS file, document element was not 'matchsim'");
            }

            XmlNodeList nodeList = documentEl.SelectNodes("title");
            if(0 == nodeList.Count)
            {
                throw new InvalidConfigException(
                        _outputConfig, 
                        NodeContext(documentEl), 
                        "No <title> elements found in document");
            }

            foreach(XmlNode node in nodeList)
            {
                XmlElement titleEl = node as XmlElement;
                if(null == titleEl)
                {
                    throw new InvalidConfigException(
                            _outputConfig, 
                            NodeContext(node),
                            "Invalid title element");
                }

                // Parse the title out of the config
                ParseTitle(titleEl);
            }
        }

        private void ParseTitle(XmlElement titleElement)
        {
            uint titleId = GetUintAttribute(titleElement, "id", false);
            if(0 != _outputConfig.TitleId)
            {
                throw new InvalidConfigException(
                        _outputConfig, 
                        NodeContext(titleElement),
                        "Title element already defined in this file: " + titleId.ToString("x"));
            }

            // Load basic title configuration settings
            _outputConfig.TitleId           = titleId;
            _outputConfig.TitleName         = GetStringAttribute(titleElement, "name", "");
            _outputConfig.SessionExpiration = GetUintAttribute(titleElement, "sessionexpiration", MatchDefs.XMATCH_SCHEMA_DEFAULT_SESSION_EXPIRATION);

            Log("Loaded title element title:  0x" + _outputConfig.TitleId.ToString("x"));

            // Parse sub elements
            ParseAttributes(titleElement);
            ParseConstants(titleElement);
            ParseQueries(titleElement);
        }

        private void ParseAttributes(XmlElement titleElement)
        {
            XmlNodeList nodeList = titleElement.SelectNodes("schema/attribute");
            uint index = 0;

            if(nodeList.Count > MatchDefs.X_MATCH_MAX_TITLE_SCHEMA_ATTRS)
            {
                throw new InvalidConfigException(
                        _outputConfig, 
                        NodeContext(titleElement),
                        "Too many attributes specified: " + nodeList.Count + " > " + MatchDefs.X_MATCH_MAX_TITLE_SCHEMA_ATTRS);
            }

            _outputConfig.MatchSchema = new ArrayList();

            foreach(XmlNode node in nodeList)
            {
                XmlElement el = node as XmlElement;
                if(null == el)
                {
                    throw new InvalidConfigException(
                            _outputConfig, 
                            NodeContext(node),
                            "Invalid 'attribute' node index: " + index + " element: " + node.Name);
                }

                MatchSchemaAttribute attr = new MatchSchemaAttribute();

                attr.Name       = GetStringAttribute(el, "id", false);
                attr.Id         = GetUintAttribute(el, "hexid", false);
                attr.Kind       = GetStringAttribute(el, "kind", false);
                attr.MaxLength  = (ushort)GetUintAttribute(el, "maxlen", 0);

                ValidateSchemaAttribute(attr.Kind, attr.Id, attr.MaxLength);

                if(attr.Name.Length > MatchDefs.XMATCH_SCHEMA_MAX_ATTR_NAME_LEN)
                {
                    throw new InvalidConfigException(
                            _outputConfig,
                            NodeContext(node),
                            "attribute name: " + attr.Name + " exceeds max length: " + MatchDefs.XMATCH_SCHEMA_MAX_ATTR_NAME_LEN);
                }

                _outputConfig.MatchSchema.Add(attr);
            }

            Log("Loaded: " + _outputConfig.MatchSchema.Count + " attributes");
        }

        private void ParseConstants(XmlElement titleElement)
        {
            XmlNodeList nodeList = titleElement.SelectNodes("schema/constant");
            uint index = 0;

            if(nodeList.Count > MatchDefs.XMATCH_SCHEMA_MAX_CONSTS)
            {
                throw new InvalidConfigException(
                        _outputConfig, 
                        NodeContext(titleElement),
                        "Too many attributes specified: " + nodeList.Count + " > " + MatchDefs.X_MATCH_MAX_TITLE_SCHEMA_ATTRS);
            }

            _outputConfig.MatchConstants = new SortedList(nodeList.Count);

            foreach(XmlNode node in nodeList)
            {
                XmlElement el = node as XmlElement;
                if(null == el)
                {
                    throw new InvalidConfigException(
                            _outputConfig, 
                            NodeContext(node),
                            "Invalid 'constant' node index: " + index + " element: " + node.Name);
                }

                MatchConstant konst = new MatchConstant();

                konst.Name       = GetStringAttribute(el, "id", false);
                konst.Id         = GetUintAttribute(el, "hexid", MatchDefs.X_ATTRIBUTE_TYPE_CONSTANT | MatchDefs.X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC | (index + 1));
                konst.Kind       = GetStringAttribute(el, "kind", false);
                konst.Value      = GetUlongAttribute(el, "value").ToString();

                if("INT" != konst.Kind.ToUpper())
                {
                    throw new InvalidConfigException(
                            _outputConfig, 
                            NodeContext(node),
                            "Only 'int' may be specified for constants");
                }

                if(konst.Name.Length > MatchDefs.XMATCH_SCHEMA_MAX_CONST_NAME_LEN)
                {
                    throw new InvalidConfigException(
                            _outputConfig,
                            NodeContext(node),
                            "query name: " + konst.Name + " exceeds max length: " + MatchDefs.XMATCH_SCHEMA_MAX_CONST_NAME_LEN);
                }

                if(!MatchDefs.IsAttributeTypeConst(konst.Id))
                {
                    throw new InvalidConfigException(
                            _outputConfig, 
                            NodeContext(node),
                            "Constant type: 0x" + MatchDefs.X_ATTRIBUTE_TYPE_CONSTANT.ToString("x") + 
                            " was not specified in constant id: 0x" + konst.Id.ToString("x"));
                }

                if(!MatchDefs.IsAttributeTitleSpecific(konst.Id))
                {
                    throw new InvalidConfigException(
                            _outputConfig, 
                            NodeContext(node),
                            "Title specific flag: 0x" + MatchDefs.X_ATTRIBUTE_SCOPE_TITLE_SPECIFIC.ToString("x") +
                            " was not specified in constant id: 0x" + konst.Id.ToString("x"));
                }

                _outputConfig.MatchConstants.Add(konst.Id, konst);
                index++;
            }

            Log("Loaded: " + _outputConfig.MatchConstants.Count + " constants");
        }

        private void ParseQueries(XmlElement titleElement)
        {
            XmlNodeList nodeList = titleElement.SelectNodes("queries/query");
            uint index = 0;

            if(nodeList.Count > MatchDefs.XMATCH_SCHEMA_MAX_TITLE_QUERIES)
            {
                throw new InvalidConfigException(
                        _outputConfig, 
                        NodeContext(titleElement),
                        "Too many queries specified: " + nodeList.Count + " > " + MatchDefs.XMATCH_SCHEMA_MAX_TITLE_QUERIES);
            }

            _outputConfig.MatchQueries = new SortedList(nodeList.Count);

            foreach(XmlNode node in nodeList)
            {
                XmlElement el = node as XmlElement;
                if(null == el)
                {
                    throw new InvalidConfigException(
                            _outputConfig, 
                            NodeContext(node),
                            "Invalid 'query' node index: " + index + " element: " + node.Name);
                }

                MatchQuery query = new MatchQuery();

                // Get the query attributes
                query.Id            = GetUintAttribute(el, "id", true);
                query.FriendlyName  = GetStringAttribute(el, "name", false);
                query.MaxResults    = GetUintAttribute(el, "maxresults", MatchDefs.XMATCH_SCHEMA_DEFAULT_MAX_QUERY_RESULTS);
                query.Type          = GetStringAttribute(el, "type", String.Empty);
                query.QosProbe      = 0 != GetUintAttribute(el, "qosprobe", 0);

                // Xbox1 queries may not specify a type
                if(String.Empty == query.Type)
                {
                    query.TypeId = MatchDefs.XMATCH_QUERY_TYPE_NORMAL;
                }
                else
                {
                    query.TypeId = MatchDefs.GetQueryTypeFromString(query.Type);
                }

                if(query.FriendlyName.Length > MatchDefs.XMATCH_SCHEMA_MAX_QUERY_NAME_LEN)
                {
                    throw new InvalidConfigException(
                            _outputConfig,
                            NodeContext(node),
                            "query name: " + query.FriendlyName + " exceeds max length: " + MatchDefs.XMATCH_SCHEMA_MAX_QUERY_NAME_LEN);
                }

                // Some older configs did have a valid maxresults field 
                if(0 == query.MaxResults)
                {
                    query.MaxResults = MatchDefs.XMATCH_SCHEMA_DEFAULT_MAX_QUERY_RESULTS; 
                }

                // Validate max results
                if(query.MaxResults > MatchDefs.X_MATCH_MAX_QUERY_RESULTS)
                {
                    throw new InvalidConfigException(
                            _outputConfig, 
                            NodeContext(node),
                            "'maxresults' for query: " + query.FriendlyName + " exceeds maximum: " + MatchDefs.X_MATCH_MAX_QUERY_RESULTS);
                }
                
                
                // Do per-type validation
                if(MatchDefs.XMATCH_QUERY_TYPE_INVALID == query.TypeId)
                {
                    throw new InvalidConfigException(
                            _outputConfig, 
                            NodeContext(node),
                            "Unrecognized query type: " + query.Type);
                }

                if(MatchDefs.XMATCH_QUERY_TYPE_AGGREGATE == query.TypeId)
                {
                    query.GroupBy = GetUintAttribute(el, "groupid", 0);

                    if(!MatchDefs.IsSummaryQuery(query.Id))
                    {
                        throw new InvalidConfigException(
                                _outputConfig, 
                                NodeContext(node),
                                "Aggregate query type must have the summary bit set");
                    }
                }
                else if(MatchDefs.IsSummaryQuery(query.Id))
                {
                    throw new InvalidConfigException(
                            _outputConfig, 
                            NodeContext(node),
                            "Only Aggregate query type may have the summary bit set");
                }

                // Ensure no reserved bits in the procid
                if(!MatchDefs.IsValidQueryProcId(query.Id))
                {
                    throw new InvalidConfigException(
                            _outputConfig, 
                            NodeContext(node),
                            "The query procedure id: 0x" + query.Id.ToString("x") + " contains reserved bits");
                }

                // Parse all subelements
                ParseParameters(el, query);
                ParseFilters(el, query);
                ParseSortOps(el, query);
                ParseReturns(el, query);

                // Xbox 1 queries are stored in order
                _outputConfig.MatchQueries.Add(index, query);
                index++;

                Log("Loaded query: id: 0x" + query.Id.ToString("x") + 
                        ", type: " + query.Type +
                        ", maxresults: " + query.MaxResults +
                        ", params: " + query.Parameters.Count + 
                        ", filters: " + query.Filters.Count +
                        ", sortops: " + query.SortOps.Count + 
                        ", returns: " + query.Returns.Count);
            }
        }

        private void ParseParameters(XmlElement queryEl, MatchQuery query)
        {
            XmlNodeList nodeList = queryEl.SelectNodes("params/param");
            int index = 0;

            if(nodeList.Count > MatchDefs.X_MATCH_MAX_QUERY_PARAMS)
            {
                throw new InvalidConfigException(
                        _outputConfig, 
                        NodeContext(queryEl),
                        "Too many query parameters: " + 
                        nodeList.Count + " > " + MatchDefs.X_MATCH_MAX_QUERY_PARAMS);
            }

            MatchQueryParam []parameters = new MatchQueryParam[nodeList.Count];

            foreach(XmlNode node in nodeList)
            {
                XmlElement el = node as XmlElement;
                if(null == el)
                {
                    throw new InvalidConfigException(
                            _outputConfig, 
                            NodeContext(node),
                            "Invalid 'param' node index: " + index + " element: " + node.Name);
                }
                
                MatchQueryParam param = new MatchQueryParam();
                param.Name      = GetStringAttribute(el, "id", false);
                param.Id        = GetUintAttribute(el, "hexid", 0xffffffff);
                param.MaxLength = (ushort)GetUintAttribute(el, "maxlen", 0);
                param.Kind      = GetStringAttribute(el, "kind", false);
                param.NullOk    = 0 != GetUintAttribute(el, "nullok", 0);

                // Originally the ID was determined strickly by the order which led to broken
                // filters when the order was changed.
                if(0xffffffff == param.Id)
                {
                    param.Id = (uint)(
                            ((uint)MatchDefs.X_ATTRIBUTE_TYPE_PARAM) | 
                            ((uint)GetDatatypeFromKind(param.Kind)) | 
                            ((uint)index));
                }

                ValidateSchemaAttribute(param.Kind, param.Id, param.MaxLength);

                if(param.Name.Length > MatchDefs.XMATCH_SCHEMA_MAX_PARAM_NAME_LEN)
                {
                    throw new InvalidConfigException(
                            _outputConfig,
                            NodeContext(node),
                            "parameter name: " + param.Name + " exceeds max length: " + MatchDefs.XMATCH_SCHEMA_MAX_PARAM_NAME_LEN);
                }

                // Check for dups
                foreach(MatchQueryParam compare in parameters)
                {
                    if(null != compare && compare.Id == param.Id)
                    {
                        throw new InvalidConfigException(
                                _outputConfig, 
                                NodeContext(node),
                                "Query parameter [" + param.Name + "] 0x" + param.Id.ToString("x") + 
                                " already appears in query");
                    }
                }

                // Ensure that the ID is not greater than maximum parameters
                if((param.Id & MatchDefs.X_ATTRIBUTE_ID_MASK) >= MatchDefs.X_MATCH_MAX_QUERY_PARAMS)
                {
                    throw new InvalidConfigException(
                            _outputConfig, 
                            NodeContext(node),
                            "Query parameter: [" + param.Name + "] 0x" + param.Id.ToString("x") + 
                            " must be between 0 and " + MatchDefs.X_MATCH_MAX_QUERY_PARAMS);
                }

                // Query order and make sure order is not more than the number of parameter
                // elements specified
                int order = (int)GetUintAttribute(el, "order", true);
                if(order >= nodeList.Count)
                {
                    throw new InvalidConfigException(
                            _outputConfig, 
                            NodeContext(node),
                            "Query parameter: [" + param.Name + "] 0x" + param.Id.ToString("x") + 
                            " order: " + order + " >= " + nodeList.Count);
                }

                parameters[order] = param;
                index++;
            }

            // Make sure we don't have any holes in the parameter array
            for(int i = 0; i < parameters.Length; ++i)
            {
                if(null == parameters[i])
                {
                    throw new InvalidConfigException(
                            _outputConfig,
                            NodeContext(queryEl),
                            "Missing param at index: " + i + 
                            " in parameter array for query: 0x" + query.Id.ToString("x"));
                }
            }

            // Add parameters to query object
            query.Parameters = new ArrayList(parameters.Length);
            query.Parameters.AddRange(parameters);
        }

        private void ParseFilters(XmlElement queryEl, MatchQuery query)
        {
            XmlNodeList nodeList = queryEl.SelectNodes("filters/filter");
            uint index = 0;

            if(nodeList.Count > MatchDefs.XMATCH_SCHEMA_MAX_QUERY_FILTERS)
            {
                throw new InvalidConfigException(
                        _outputConfig, 
                        NodeContext(queryEl),
                        "Too many query filters: " + 
                        nodeList.Count + " > " + MatchDefs.XMATCH_SCHEMA_MAX_QUERY_FILTERS);
            }

            query.Filters = new ArrayList(nodeList.Count);

            foreach(XmlNode node in nodeList)
            {
                XmlElement el = node as XmlElement;
                if(null == el)
                {
                    throw new InvalidConfigException(
                            _outputConfig, 
                            NodeContext(node),
                            "Invalid 'filter' node index: " + index + " element: " + node.Name);
                }

                MatchQueryFilter filter = new MatchQueryFilter();

                string strLeft = GetStringAttribute(el, "left", false);
                string strRight = GetStringAttribute(el, "right", false);

                filter.Left     = ParseUInt32(strLeft);
                filter.Right    = ParseUInt32(strRight);
                filter.Op       = GetStringAttribute(el, "op", false);
                filter.OpId     = MatchDefs.GetFilterOpFromString(filter.Op);

                if(MatchDefs.XMATCH_FILTEROP_INVALID == filter.OpId)
                {
                    throw new InvalidConfigException(
                            _outputConfig, 
                            NodeContext(node),
                            "Invalid operation type: " + filter.Op);
                }

                // Try to resolve a name reference for the filter id or validate that it is a real 
                // attribute id
                if(0 == filter.Left)
                {
                    filter.Left = LookupAttributeId(strLeft, query, false);
                }
                else
                {
                    ValidateAttributeReference(query, "filter.Left", filter.Left);
                }

                if(0 == filter.Right)
                {
                    filter.Right = LookupAttributeId(strRight, query, true);
                }
                else
                {
                    ValidateAttributeReference(query, "filter.Right", filter.Right);
                }
                
                query.Filters.Add(filter);
            }
        }

        private void ParseSortOps(XmlElement queryEl, MatchQuery query)
        {
            XmlNodeList nodeList = queryEl.SelectNodes("sortops/sortop");
            uint index = 0;

            if(nodeList.Count > MatchDefs.XMATCH_SCHEMA_MAX_QUERY_SORTOPS)
            {
                throw new InvalidConfigException(
                        _outputConfig, 
                        NodeContext(queryEl),
                        "Too many sortops: " + 
                        nodeList.Count + " > " + MatchDefs.XMATCH_SCHEMA_MAX_QUERY_SORTOPS);
            }

            query.SortOps = new SortedList(nodeList.Count);

            foreach(XmlNode node in nodeList)
            {
                XmlElement el = node as XmlElement;
                if(null == el)
                {
                    throw new InvalidConfigException(
                            _outputConfig, 
                            NodeContext(node),
                            "Invalid 'param' node index: " + index + " element: " + node.Name);
                }

                MatchQuerySortOp sortop = new MatchQuerySortOp();

                string dir     = GetStringAttribute(el, "dir", String.Empty);
                bool ascending = true;
                if("DESCENDING" == dir.ToUpper())
                {
                    ascending = false;
                }

                // Id can be an ID reference or a name that should be resolved
                string strOpId = GetStringAttribute(el, "id", false);
                sortop.Id = ParseUInt32(strOpId);

                // Try to resolve the id if it not a hexid
                if(0 == sortop.Id)
                {
                    sortop.Id = LookupAttributeId(strOpId, query, false);
                }
                else
                {
                    ValidateAttributeReference(query, "sortop", sortop.Id);
                }

                // Get the distance
                sortop.DistanceId =GetUintAttribute(el, "distanceid", 0);

                // Figure out the type or set it to a default based on the 
                // 'dir' attribute
                sortop.Type = GetStringAttribute(el, "type", String.Empty);
                if(String.Empty == sortop.Type)
                {
                    sortop.TypeId = ascending ? MatchDefs.XMATCH_SORTOP_ASCENDING : MatchDefs.XMATCH_SORTOP_DESCENDING;
                }
                else
                {
                    sortop.TypeId = MatchDefs.GetSortOpFromString(sortop.Type);
                }

                if(MatchDefs.XMATCH_SORTOP_INVALID == sortop.TypeId)
                {
                    throw new InvalidConfigException(
                            _outputConfig, 
                            NodeContext(node),
                            "Invalid sortop type: " + sortop.Type);
                }

                if((MatchDefs.XMATCH_SORTOP_NEAR == sortop.TypeId || MatchDefs.XMATCH_SORTOP_FAR == sortop.TypeId) 
                        && 0 == sortop.DistanceId)
                {
                    throw new InvalidConfigException(
                            _outputConfig, 
                            NodeContext(node),
                            "'distanceid' must be not be zero for 'near' or 'far' sortops");
                }

                // Validate the sort for the type of query
                switch(query.TypeId)
                {
                    default:
                        throw new InvalidConfigException(
                                _outputConfig, 
                                NodeContext(node),
                                "Unexpected query typeid: " + query.TypeId);
                    case MatchDefs.XMATCH_QUERY_TYPE_NORMAL:
                    case MatchDefs.XMATCH_QUERY_TYPE_FINDFROMID:
                        // When creating normal or findfronid any sortops are allowed
                        break;
                    case MatchDefs.XMATCH_QUERY_TYPE_AGGREGATE:
                        if(0 == query.GroupBy && query.GroupBy != sortop.Id)
                        {
                            throw new InvalidConfigException(
                                    _outputConfig,
                                    NodeContext(node),
                                    "Sorting on aggregates must match the groupby attribute, sort id: 0x" + 
                                    sortop.Id.ToString("x") + " does not match: 0x" + query.GroupBy.ToString("x"));
                        }
                        break;
                }

                // Check for dups
                foreach(MatchQuerySortOp compare in query.SortOps.Values)
                {
                    if(sortop.Id == compare.Id && sortop.DistanceId == compare.DistanceId)
                    {
                        throw new InvalidConfigException(
                                _outputConfig, 
                                NodeContext(node),
                                "Duplicate sort operation id: " + sortop.Id + ", distanceid: " + sortop.DistanceId);
                    }
                }

                // Xbox 1 sortops are stored in order
                query.SortOps.Add(index, sortop);
                index++;
            }
        }

        private void ParseReturns(XmlElement queryEl, MatchQuery query)
        {
            XmlNodeList nodeList = queryEl.SelectNodes("returns/return");
            uint index = 0;

            if(nodeList.Count > MatchDefs.XMATCH_SCHEMA_MAX_QUERY_RETURNS)
            {
                throw new InvalidConfigException(
                        _outputConfig, 
                        NodeContext(queryEl),
                        "Too many query returns: " + 
                        nodeList.Count + " > " + MatchDefs.XMATCH_SCHEMA_MAX_QUERY_RETURNS);
            }

            query.Returns = new SortedList(nodeList.Count);

            foreach(XmlNode node in nodeList)
            {
                XmlElement el = node as XmlElement;
                if(null == el)
                {
                    throw new InvalidConfigException(
                            _outputConfig, 
                            NodeContext(node),
                            "Invalid 'return' node index: " + index + " element: " + node.Name);
                }

                MatchQueryReturn ret = new MatchQueryReturn();

                string strId = GetStringAttribute(el, "id", false);

                ret.Id      = ParseUInt32(strId);
                ret.Type    = GetStringAttribute(el, "type", String.Empty);
                ret.Ordinal = index;

                if(String.Empty == ret.Type)
                {
                    ret.TypeId = MatchDefs.XMATCH_RETURN_TYPE_NORMAL;
                }
                else
                {
                    ret.TypeId = MatchDefs.GetReturnTypeFromString(ret.Type);
                }

                if(MatchDefs.XMATCH_RETURN_TYPE_INVALID == ret.TypeId)
                {
                    throw new InvalidConfigException(
                            _outputConfig, 
                            NodeContext(node),
                            "Invalid return type specified in config: " + ret.Type);
                }

                if(0 == ret.Id)
                {
                    ret.Id = LookupAttributeId(strId, query, false);
                }
                else
                {
                    ValidateAttributeReference(query, "return.Id", ret.Id);
                }

                // Validate return type against query type
                if((MatchDefs.XMATCH_QUERY_TYPE_NORMAL == query.TypeId || MatchDefs.XMATCH_QUERY_TYPE_FINDFROMID == query.TypeId) 
                        && ret.TypeId != MatchDefs.XMATCH_RETURN_TYPE_NORMAL)
                {
                    throw new InvalidConfigException(
                            _outputConfig, 
                            NodeContext(node),
                            "Return type must be normal for normal or findfromid query types");
                }
                else if((MatchDefs.XMATCH_QUERY_TYPE_AGGREGATE == query.TypeId))
                {
                    // If there is a group ID then returns can be aggregate types or the group attribute
                    if(0 != query.GroupBy)
                    {
                        if(MatchDefs.XMATCH_RETURN_TYPE_NORMAL == ret.TypeId && query.GroupBy != ret.Id)
                        {
                            throw new InvalidConfigException(
                                    _outputConfig, 
                                    NodeContext(node),
                                    "Normal return types for aggregates must be linked to the group attribute: 0x" + query.GroupBy);
                        }
                    }
                    else
                    {
                        if(MatchDefs.XMATCH_RETURN_TYPE_NORMAL == ret.TypeId)
                        {
                            throw new InvalidConfigException(
                                    _outputConfig, 
                                    NodeContext(node),
                                    "Normal return type is invalid on aggregate queries when the group attribute is not specified");
                        }
                    }
                }

                // Check for dups
                foreach(MatchQueryReturn compare in query.Returns.Values)
                {
                    if(ret.Id == compare.Id && ret.TypeId == compare.TypeId)
                    {
                        throw new InvalidConfigException(
                                _outputConfig, 
                                NodeContext(node),
                                "Duplicate return id: " + ret.Id);
                    }
                }

                // Xbox 1 match returns are sorted by index
                query.Returns.Add(index, ret);
                index++;
            }
        }

        // Xml Config Utils
        private uint GetUintAttribute(XmlElement el, string name, bool allowZero)
        {
            string strValue = GetRequiredAttribute(el, name);
            uint dwValue = ParseUInt32(strValue); 
            if(!allowZero && 0 == dwValue)
            {
                throw new InvalidConfigException(
                    _outputConfig,
                    NodeContext(el),
                    "Zero is not allowed for attribute: " + name + " on element: " + el.Name);
            }

            return dwValue;
        }

        private uint GetUintAttribute(XmlElement el, string name, uint defaultValue)
        {
            string strValue = el.GetAttribute(name);
            uint dwValue = defaultValue;
            if(null != strValue && String.Empty != strValue)
            {
                dwValue = ParseUInt32(strValue);
            }

            return dwValue;
        }

        private uint ParseUInt32(string str)
        {
            uint dwValue;
            try
            {
                int fromBase = 10;

                if(str.StartsWith("0x"))
                {
                    fromBase = 16;
                    str = str.Substring(2);
                }

                dwValue = Convert.ToUInt32(str, fromBase);
            }
            catch(Exception)
            {
                // Ignore and return 0
                dwValue = 0;
            }

            return dwValue;
        }

        private ulong ParseUInt64(string str)
        {
            ulong qwValue;
            try
            {
                int fromBase = 10;

                if(str.StartsWith("0x"))
                {
                    fromBase = 16;
                    str = str.Substring(2);
                }

                qwValue = Convert.ToUInt64(str, fromBase);
            }
            catch(Exception)
            {
                // Ignore and return 0
                qwValue = 0;
            }

            return qwValue;
        }

        private string NodeContext(XmlNode node)
        {
            return node.GetType().Name + ": " + node.Name;
        }

        private string GetStringAttribute(XmlElement el, string name, bool allowEmpty)
        {
            string strValue = GetRequiredAttribute(el, name);
            if(!allowEmpty && 0 == strValue.Length)
            {
                throw new InvalidConfigException(
                        _outputConfig,
                        NodeContext(el),
                        "Empty strings are not allowed for attribute: " + name + " on element: " + el.Name);
            }

            return strValue;
        }

        private string GetStringAttribute(XmlElement el, string name, string defaultValue)
        {
            string strValue = el.GetAttribute(name);
            if(null == strValue || String.Empty == strValue)
            {
                return defaultValue;
            }
            else
            {
                return strValue;
            }
        }

        private ulong GetUlongAttribute(XmlElement el, string name)
        {
            string strValue = GetRequiredAttribute(el, name);
            ulong qwValue = ParseUInt64(strValue);

            return qwValue;
        }

        private string GetRequiredAttribute(XmlElement el, string name)
        {
            string strValue = el.GetAttribute(name);
            if(null == strValue || String.Empty == strValue)
            {
                throw new InvalidConfigException(
                        _outputConfig,
                        NodeContext(el),
                        "No attribute named: " + name + " on element: " + el.Name);
            }

            return strValue;
        }

        // Resolve an attribute nameid to attribute hexid
        private uint LookupAttributeId(string name, MatchQuery query, bool allowConsts)
        {
            name = name.ToUpper();

            // Look in globals
            if(_globals.Contains(name))
            {
                uint attrId = (uint)_globals[name];
                return attrId;
            }

            // Look in the schema attributes
            foreach(MatchSchemaAttribute attr in _outputConfig.MatchSchema)
            {
                if(name == attr.Name.ToUpper())
                {
                    return attr.Id;
                }
            }

            // Look in the query parameters if specified
            if(null != query)
            {
                foreach(MatchQueryParam param in query.Parameters)
                {
                    if(name == param.Name.ToUpper())
                    {
                        return param.Id;
                    }
                }
            }

            // Look at consts
            if(false != allowConsts)
            {
                foreach(MatchConstant konst in _outputConfig.MatchConstants)
                {
                    if(name == konst.Name.ToUpper())
                    {
                        return konst.Id;
                    }
                }
            }

            throw new InvalidConfigException(
                    _outputConfig, 
                    "LookupAttributeId",
                    "Could not resolve the id: " + name + " specified in query: " + query.Id);
        }

        private uint GetDatatypeFromKind(string kind)
        {
            uint datatype;
            switch(kind.ToUpper())
            {
                default:
                    throw new InvalidConfigException(
                            _outputConfig,
                            "GetDatatypeFromKind",
                            "Could not convert kind: " + kind + " to datatype");
                case "INT":
                    datatype = MatchDefs.X_ATTRIBUTE_DATATYPE_INTEGER;
                    break;
                case "STRING":
                    datatype = MatchDefs.X_ATTRIBUTE_DATATYPE_STRING;
                    break;
                case "BLOB":
                    datatype = MatchDefs.X_ATTRIBUTE_DATATYPE_BLOB;
                    break;
            }

            return datatype;
        }

        // Validation routines
        private void ValidateSchemaAttribute(string  kind, uint id, uint maxLength)
        {
            if("INT" == kind.ToUpper())
            {
                ValidateId(id, MatchDefs.X_ATTRIBUTE_DATATYPE_INTEGER);
                if(0 != maxLength)
                {
                    throw new InvalidConfigException(
                            _outputConfig, 
                            "ValidateSchemaAttribute",
                            "'maxlen' is invalid on an 'int' attribute");
                }
            }
            else if("STRING" == kind.ToUpper())
            {
                ValidateId(id, MatchDefs.X_ATTRIBUTE_DATATYPE_STRING);
                ValidateMaxLength(kind, maxLength, MatchDefs.X_MAX_STRING_ATTRIBUTE_LEN);
            }
            else if("BLOB" == kind.ToUpper())
            {
                ValidateId(id, MatchDefs.X_ATTRIBUTE_DATATYPE_BLOB);
                ValidateMaxLength(kind, maxLength, MatchDefs.X_MAX_BLOB_ATTRIBUTE_LEN);
            }
            else
            {
                throw new InvalidConfigException(
                        _outputConfig, 
                        "ValidateSchemaAttribute",
                        "'" + kind + "' was not one of 'int', 'string' or 'blob'");
            }
        }

        private void ValidateMaxLength(string kind, uint specifiedMaxLength, uint allowedMaxLength)
        {
            if(0 == specifiedMaxLength)
            {
                throw new InvalidConfigException(
                        _outputConfig, 
                        "ValidateMaxLength",
                        "'maxlen' is required for a '" + kind + "' attribute");
            }
            else if(allowedMaxLength < specifiedMaxLength)
            {
                throw new InvalidConfigException(
                        _outputConfig, 
                        "ValidateMaxLength",
                        "'maxlen' exceeds maximum '" + kind + "' length: " + allowedMaxLength);
            }
        }

        private void ValidateId(uint id, uint typebits)
        {
            if((id & MatchDefs.X_ATTRIBUTE_DATATYPE_MASK) != typebits)
            {
                throw new InvalidConfigException(
                        _outputConfig,
                        "ValidateId",
                        "Invalid type mask in id: 0x" + id.ToString("x") + ", did not match type: " + typebits);
            }

            if(!MatchDefs.IsAttributeTitleSpecific(id))
            {
                throw new InvalidConfigException(
                        _outputConfig,
                        "ValidateId",
                        "Invalid scope for id: 0x" + id.ToString("x") + ", is not title specific");
            }
        }

        public void ValidateAttributeReference(MatchQuery query, string friendlyName, uint attrId)
        {
            friendlyName = "Query: 0x" + query.Id.ToString("x") + ": " + friendlyName;
            if(0 == attrId)
            {
                throw new InvalidConfigException(
                        _outputConfig, 
                        "ValidateAttributeReference",
                        "Failed for unspecified attribute: " + friendlyName);
            }
            
            // Resolve attribute references
            foreach(UInt32 globalId in _globals.Values)
            {
                if(globalId == attrId)
                {
                    goto lbFound;
                }
            }

            // Look in schema attributes
            foreach(MatchSchemaAttribute attr in _outputConfig.MatchSchema)
            {
                if(attr.Id == attrId)
                {
                    goto lbFound;
                }
            }

            // Look in query parameters
            foreach(MatchQueryParam param in query.Parameters)
            {
                if(param.Id == attrId)
                {
                    goto lbFound;
                }
            }

            // Look in constants
            foreach(MatchConstant konst in _outputConfig.MatchConstants.Values)
            {
                if(konst.Id == attrId)
                {
                    goto lbFound;
                }
            }

            throw new InvalidConfigException(
                    _outputConfig, 
                    "ValidateAttributeReference",
                    "Failed to find attribute id: 0x" + attrId.ToString("x") + 
                    " in globals, schema attributes, params or constants");
lbFound:
            return;
        }

        // General utility
        protected void Log(string msg)
        {
            _outputLog.WriteLine(msg);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\Memcache\Acceleration\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\Memcache\interface\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\match\match\MatchXlastConfigLoader.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using System.Xml;
using System.Xml.XPath;
using System.IO;

using xonline.common.protocol;
using xonline.common.service;

namespace xonline.common.match
{
    public class MatchXlastConfigLoader
    {
        XmlDocument         _inputConfig;
        MatchGameConfig     _outputConfig;
        TextWriter          _outputLog;
        XmlNamespaceManager _nsmgr;

        public MatchXlastConfigLoader()
        {
        }

        public void Load(XmlDocument input, TextWriter log, out MatchGameConfig output)
        {
            if(null == input || null == log)
            {
                throw new ArgumentException("Load() requires a valid DOM document and log destination");
            }

            output = new MatchGameConfig(MatchGameConfig.TYPE_XLAST_CONFIG);
            _outputLog = log;

            _inputConfig = input;
            _outputConfig = output;

            // Create the namespace manager and add the default namespace
            _nsmgr = new XmlNamespaceManager(input.NameTable);
            _nsmgr.AddNamespace("xl", "http://www.xboxlive.com/xlast");

            // Create the root xpath navigator
            XPathNavigator root = input.CreateNavigator();

            ParseXboxLiveSubmissionProject(root);
            ParseGameConfigProject(root);
            ParseMatchConstants(root);
            ParseMatchSchema(root);
            ParseMatchQueries(root);
            ParseGameModes(root);
        }


        // this method is used to validate things that are not naturally part of XML schema validation.
        public void ValidateXlastSemantics(MatchGameConfig input)
        {
            // validate that any weighted parameters associated with match queries are allowed to be weighted
            foreach(DictionaryEntry deQuery in input.MatchQueries)
            {
                foreach(MatchQueryParam param in ((MatchQuery)(deQuery.Value)).Parameters)
                {
                    if(param.IsWeighted)
                    {
                        // there are some system attributes that we don't allow to be weighted.  (e.g. game type or mode) Check for those.
                        if(MatchDefs.IsSystemAttribute(param.Id) && Array.LastIndexOf(MatchDefs.rgWeightablePlatformAttrs, param.Id) == -1)
                        {
                            throw new Exception("Invalid game config xml: An unweightable system attribute was marked as weighted. " 
                                + "(Attribute ID: 0x" + param.Id.ToString("X") + ", Query ID: " + ((MatchQuery)(deQuery.Value)).Id.ToString() + ")"); // TODOTHEOM: is this the right type of exception?
                        }
                        // there are some attribute data types that cannot be weighted.  
                        if ((MatchDefs.AttributeXenonDatatype(param.Id) == MatchDefs.X_ATTRIBUTE_XENON_DATATYPE_DATETIME)
                            || (MatchDefs.AttributeXenonDatatype(param.Id) == MatchDefs.X_ATTRIBUTE_XENON_DATATYPE_BINARY)
                            || (MatchDefs.AttributeXenonDatatype(param.Id) == MatchDefs.X_ATTRIBUTE_XENON_DATATYPE_UNICODE))
                        {
                            throw new Exception("Invalid game config xml: An attribute of an unweightable type was marked as weighted. "
                                + "(Attribute ID: 0x" + param.Id.ToString("X") + ", Query ID: " + ((MatchQuery)(deQuery.Value)).Id.ToString() + ")"); // TODOTHEOM: is this the right type of exception?
                        }
                    }
                }
            }
        }


        private void ParseXboxLiveSubmissionProject(XPathNavigator root)
        {
            XPathNodeIterator it = Select(root, "/xl:XboxLiveSubmissionProject");
            if (it.Count == 0)
            {
                throw new ExceptionWithEventId(XEvent.Id.MATCH_CONFIG_6,
                        "Invalid game config xml: Could not find /XboxLiveSubmissionProject node");
            }
            if (it.Count > 1)
            {
                throw new ExceptionWithEventId(XEvent.Id.MATCH_CONFIG_7,
                        "Invalid game config xml: More than one /XboxLiveSubmissionProject node found");
            }
            it.MoveNext();

            _outputConfig.XlastVersion = it.Current.GetAttribute("Version", "");
            if (_outputConfig.XlastVersion == String.Empty)
            {
                throw new ExceptionWithEventId(XEvent.Id.MATCH_CONFIG_8,
                        "Invalid game config xml: Version attribute missing on /XboxLiveSubmissionProject node");
            }
        }

        private void ParseGameConfigProject(XPathNavigator root)
        {
            XPathNodeIterator it = Select(root, "/xl:XboxLiveSubmissionProject/xl:GameConfigProject");
            if (it.Count == 0)
            {
                throw new ApplicationException("Invalid game config xml: Could not find "
                        + "/XboxLiveSubmissionProject/GameConfigProject");
            }
            if (it.Count > 1)
            {
                throw new ApplicationException("Invalid game config xml: Too many GameConfigProject "
                        + "nodes!");
            }
            it.MoveNext();

            string titleId = it.Current.GetAttribute("titleId", "");
            if (titleId == String.Empty)
            {
                throw new ExceptionWithEventId(XEvent.Id.MATCH_CONFIG_9,
                        "Invalid game config xml: titleId attribute missing on "
                        + "/XboxLiveSubmissionProject/GameConfigProject node");
            }
            try
            {
                _outputConfig.TitleId = ParseUInt32(it.Current.GetAttribute("titleId", ""));
            }
            catch (Exception e)
            {
                throw new ExceptionWithEventId(XEvent.Id.MATCH_CONFIG_10,
                        "Invalid game config xml: Exception parsing titleId attribute on "
                        + "/XboxLiveSubmissionProject/GameConfigProject node, value: "
                        + titleId, e);
            }

            _outputConfig.ProjectVersion = it.Current.GetAttribute("projectVersion", "");
            if (_outputConfig.ProjectVersion == String.Empty)
            {
                throw new ExceptionWithEventId(XEvent.Id.MATCH_CONFIG_11,
                        "Invalid game config xml found: projectVersion attribute missing on "
                        + "/XboxLiveSubmissionProject/GameConfigProject node");
            }
        }

        private void ParseMatchConstants(XPathNavigator root)
        {
            Log("Parsing /XboxLiveSubmissionProject/GameConfigProject/Constants");

            XPathNodeIterator it = Select(root, "/xl:XboxLiveSubmissionProject/xl:GameConfigProject/xl:Matchmaking/xl:Constants/xl:Constant");

            _outputConfig.MatchConstants = new SortedList(it.Count);

            int i = 0;
            while (it.MoveNext())
            {
                Log("Parsing /XboxLiveSubmissionProject/GameConfigProject/Matchmaking/"
                        + "Constants/Constant, ordinal " + i);
                ++i;

                MatchConstant c = new MatchConstant();

                string id = it.Current.GetAttribute("id", "");
                if (id == String.Empty)
                {
                    throw new ExceptionWithEventId(XEvent.Id.MATCH_CONFIG_12,
                            "Invalid game config xml: id attribute missing on "
                            + "/XboxLiveSubmissionProject/GameConfigProject/Matchmaking/Constants/Constant");
                }

                try
                {
                    c.Id = ParseUInt32(id);
                }
                catch (Exception e)
                {
                    throw new ExceptionWithEventId(XEvent.Id.MATCH_CONFIG_13,
                            "Invalid game config xml found: unable to parse id attribute as integer on "
                            + "/XboxLiveSubmissionProject/GameConfigProject/Matchmaking/Constants/Constant"
                            + " value: " + id, e);
                }

                c.Name = it.Current.GetAttribute("name", "");
                if (c.Name == String.Empty)
                {
                    throw new ExceptionWithEventId(XEvent.Id.MATCH_CONFIG_14,
                            "Invalid game config xml found: name attribute missing on "
                            + "/XboxLiveSubmissionProject/GameConfigProject/Matchmaking/Constants/Constant");
                }

                c.Value = it.Current.GetAttribute("value", "");
                if (c.Value == String.Empty)
                {
                    throw new ExceptionWithEventId(XEvent.Id.MATCH_CONFIG_15,
                            "Invalid game config xml found: value attribute missing on "
                            + "/XboxLiveSubmissionProject/GameConfigProject/Matchmaking/Constants/Constant");
                }

                _outputConfig.MatchConstants.Add(c.Id, c);
            }
        }

        private void ParseMatchSchema(XPathNavigator root)
        {
            Log("Parsing /XboxLiveSubmissionProject/GameConfigProject/Matchmaking/Schema");

            XPathNodeIterator it = Select(root, "/xl:XboxLiveSubmissionProject/xl:GameConfigProject/xl:Matchmaking/xl:Schema/xl:Attribute");

            _outputConfig.MatchSchema = new ArrayList(it.Count);

            int i = 0;
            while (it.MoveNext())
            {
                Log("Parsing /XboxLiveSubmissionProject/GameConfigProject/Matchmaking"
                        + "/Schema/Attribute, ordinal " + i);
                ++i;

                MatchSchemaAttribute a = new MatchSchemaAttribute();

                string id = it.Current.GetAttribute("id", "");
                if (id == String.Empty)
                {
                    throw new ExceptionWithEventId(XEvent.Id.MATCH_CONFIG_16,
                            "Invalid game config xml found: id attribute missing on "
                            + "/XboxLiveSubmissionProject/GameConfigProject/Matchmaking/Schema/Attribute");
                }

                try 
                {
                    a.Id = ParseUInt32(id);
                }
                catch (Exception e)
                {
                    throw new ExceptionWithEventId(XEvent.Id.MATCH_CONFIG_17,
                            "Invalid game config xml found: unable to parse id attribute as integer on "
                            + "/XboxLiveSubmissionProject/GameConfigProject/Matchmaking/Schema/Attribute, "
                            + " value: " + id, e);
                }

                _outputConfig.MatchSchema.Add(a);
            }
        }

        private void ParseMatchQueries(XPathNavigator root)
        {
            Log("Parsing /XboxLiveSubmissionProject/GameConfigProject/Matchmaking/Queries");

            XPathNodeIterator it = Select(root, "/xl:XboxLiveSubmissionProject/xl:GameConfigProject/xl:Matchmaking/xl:Queries/xl:Query");

            _outputConfig.MatchQueries = new SortedList(it.Count);

            int i = 0;
            while (it.MoveNext())
            {
                Log("Parsing /XboxLiveSubmissionProject/GameConfigProject/Matchmaking/"
                        + "Queries/Query, ordinal " + i);
                ++i;

                MatchQuery q = ParseMatchQuery(it.Current);
                _outputConfig.MatchQueries.Add(q.Id, q);
            }
        }

        private MatchQuery ParseMatchQuery(XPathNavigator query)
        {
            MatchQuery q = new MatchQuery();

            string id = query.GetAttribute("id", "");
            if (id == String.Empty)
            {
                throw new ExceptionWithEventId(XEvent.Id.MATCH_CONFIG_18,
                        "Invalid game config xml found: id attribute missing on "
                        + "/XboxLiveSubmissionProject/GameConfigProject/Matchmaking/Queries/Query node");
            }

            try
            {
                q.Id = ParseUInt32(id);
            }
            catch (Exception e)
            {
                throw new ExceptionWithEventId(XEvent.Id.MATCH_CONFIG_19,
                        "Invalid game config xml found: unable to parse id attribute as integer on "
                        + "/XboxLiveSubmissionProject/GameConfigProject/Matchmaking/Queries/Query, "
                        + "value: " + id, e);
            }

            q.FriendlyName = query.GetAttribute("friendlyName", "");
            if (q.FriendlyName == String.Empty)
            {
                throw new ExceptionWithEventId(XEvent.Id.MATCH_CONFIG_20,
                        "Invalid game config xml found: friendlyName attribute missing on "
                        + "/XboxLiveSubmissionProject/GameConfigProject/Matchmaking/Queries/Query");
            }

            string maxResults = query.GetAttribute("maxResults", "");
            if (maxResults == String.Empty)
            {
                throw new ExceptionWithEventId(XEvent.Id.MATCH_CONFIG_21,
                        "Invalid game config xml: maxResults attribute missing on "
                        + "/XboxLiveSubmissionProject/GameConfigProject/Matchmaking/Queries/Query");
            }

            try
            {
                q.MaxResults = ParseUInt32(maxResults);
            }
            catch (Exception e)
            {
                throw new ExceptionWithEventId(XEvent.Id.MATCH_CONFIG_22,
                        "Invalid game config xml found: unable to parse maxResults attribute as integer on "
                        + "/XboxLiveSubmissionProject/GameConfigProject/Matchmaking/Queries/Query,"
                        + " value: " + maxResults, e);
            }

            q.Type = query.GetAttribute("type", "");
            if (q.Type == String.Empty)
            {
                throw new ExceptionWithEventId(XEvent.Id.MATCH_CONFIG_23,
                        "Invalid game config xml found: type attribute missing on "
                        + "/XboxLiveSubmissionProject/GameConfigProject/Matchmaking/Queries/Query");
            }

            string groupBy = query.GetAttribute("groupBy", "");
            if (groupBy == String.Empty)
            {
                throw new ExceptionWithEventId(XEvent.Id.MATCH_CONFIG_24,
                        "Invalid game config xml found: groupBy attribute missing on "
                        + "/XboxLiveSubmissionProject/GameConfigProject/Matchmaking/Queries/Query");
            }

            try
            {
                q.GroupBy = ParseUInt32(groupBy);
            }
            catch (Exception e)
            {
                throw new ExceptionWithEventId(XEvent.Id.MATCH_CONFIG_25,
                        "Invalid game config xml: unable to parse maxResults attribute as integer on "
                        + "/XboxLiveSubmissionProject/GameConfigProject/Matchmaking/Queries/Query, "
                        + "value: " + groupBy, e);
            }

            q.Parameters = ParseMatchQueryParams(query);
            q.Filters = ParseMatchQueryFilters(query);
            q.SortOps = ParseMatchQuerySortOps(query);
            q.Returns = ParseMatchQueryReturns(query);

            return q;
        }

        private ArrayList ParseMatchQueryParams(XPathNavigator query)
        {
            XPathNodeIterator it = Select(query, "xl:Parameters/xl:Parameter");

            ArrayList paramList = new ArrayList(it.Count);

            int i = 0;
            while (it.MoveNext())
            {
                Log("Parsing /XboxLiveSubmissionProject/GameConfigProject/Matchmaking/"
                        + "Queries/Query/Parameters/Parameter, ordinal " + i);
                ++i;

                MatchQueryParam p = new MatchQueryParam();

                string id = it.Current.GetAttribute("id", "");
                if (id == String.Empty)
                {
                    throw new ExceptionWithEventId(XEvent.Id.MATCH_CONFIG_26,
                            "Invalid game config xml found: id attribute missing on "
                            + "/XboxLiveSubmissionProject/GameConfigProject/Matchmaking/Queries/Query"
                            + "/Parameters/Parameter");
                }

                try
                {
                    p.Id = ParseUInt32(id);
                }
                catch (Exception e)
                {
                    throw new ExceptionWithEventId(XEvent.Id.MATCH_CONFIG_27,
                            "Invalid game config xml found: unable to parse id attribute as integer on "
                            + "/XboxLiveSubmissionProject/GameConfigProject/Matchmaking/Queries/Query"
                            + "/Parameters/Parameter, value: " + id, e);
                }

                // TODOTHEOM: do we need to validate that one attribute does not exist without the other? (either direction?)

                // grab the value of the "weighted" attribute, if it's there.  But it's not required...
                string strWeighted = it.Current.GetAttribute("weighted", "");
                if(strWeighted != String.Empty)
                {
                    try
                    {
                        p.IsWeighted= Convert.ToBoolean(strWeighted);
                    }
                    catch (Exception e)
                    {
                        throw new ExceptionWithEventId(XEvent.Id.MATCH_CONFIG_27, // TODOTHEOM: need a new event ID, if we're still using events.
                                "Invalid game config xml found: unable to parse weighted attribute as boolean on "
                                + "/XboxLiveSubmissionProject/GameConfigProject/Matchmaking/Queries/Query"
                                + "/Parameters/Parameter, value: " + strWeighted, e);
                    }
                }

                // grab the value of the "boolean" attribute, if it's there.  But it's not required...
                string strExactMatch = it.Current.GetAttribute("exactMatch", "");
                if(strExactMatch != String.Empty)
                {
                    try
                    {
                        p.IsExactMatch= Convert.ToBoolean(strExactMatch);
                    }
                    catch (Exception e)
                    {
                        throw new ExceptionWithEventId(XEvent.Id.MATCH_CONFIG_27, // TODOTHEOM: need a new event ID, if we're still using events.
                                "Invalid game config xml found: unable to parse 'exactMatch' attribute as boolean on "
                                + "/XboxLiveSubmissionProject/GameConfigProject/Matchmaking/Queries/Query"
                                + "/Parameters/Parameter, value: " + strExactMatch, e);
                    }
                }


                paramList.Add(p);
            }

            return paramList;
        }

        private ArrayList ParseMatchQueryFilters(XPathNavigator query)
        {
            XPathNodeIterator it = Select(query, "xl:Filters/xl:Filter");

            ArrayList filters = new ArrayList(it.Count);

            int i = 0;
            while (it.MoveNext())
            {
                Log("Parsing /XboxLiveSubmissionProject/GameConfigProject/Matchmaking/"
                        + "Queries/Query/Filters/Filter, ordinal " + i);
                ++i;

                MatchQueryFilter f = new MatchQueryFilter();

                string left = it.Current.GetAttribute("left", "");
                if (left == String.Empty)
                {
                    throw new ExceptionWithEventId(XEvent.Id.MATCH_CONFIG_28,
                            "Invalid game config xml found: left attribute missing on "
                            + "/XboxLiveSubmissionProject/GameConfigProject/Matchmaking/Queries/Query"
                            + "/Filters/Filter");
                }

                try
                {
                    f.Left = ParseUInt32(left);
                }
                catch (Exception e)
                {
                    throw new ExceptionWithEventId(XEvent.Id.MATCH_CONFIG_29,
                            "Invalid game config xml found: unable to parse left attribute as integer on "
                            + "/XboxLiveSubmissionProject/GameConfigProject/Matchmaking/Queries/Query"
                            + "/Filters/Filter, value: " + left, e);
                }

                f.LeftType = it.Current.GetAttribute("leftType", "");
                if (f.LeftType == String.Empty)
                {
                    throw new ExceptionWithEventId(XEvent.Id.MATCH_CONFIG_30,
                            "Invalid game config xml found: leftType attribute missing on "
                            + "/XboxLiveSubmissionProject/GameConfigProject/Matchmaking/Queries/Query"
                            + "/Filters/Filter");
                }

                f.Op = it.Current.GetAttribute("op", "");
                if (f.Op == String.Empty)
                {
                    throw new ExceptionWithEventId(XEvent.Id.MATCH_CONFIG_31,
                            "Invalid game config xml found: op attribute missing on "
                            + "/XboxLiveSubmissionProject/GameConfigProject/Matchmaking/Queries/Query"
                            + "/Filters/Filter");
                }

                string right = it.Current.GetAttribute("right", "");
                if (right == String.Empty)
                {
                    throw new ExceptionWithEventId(XEvent.Id.MATCH_CONFIG_32,
                            "Invalid game config xml found: right attribute missing on "
                            + "/XboxLiveSubmissionProject/GameConfigProject/Matchmaking/Queries/Query"
                            + "/Filters/Filter");
                }

                try
                {
                    f.Right = ParseUInt32(right);
                }
                catch (Exception e)
                {
                    throw new ExceptionWithEventId(XEvent.Id.MATCH_CONFIG_33,
                            "Invalid game config xml found: unable to parse right attribute as integer on "
                            + "/XboxLiveSubmissionProject/GameConfigProject/Matchmaking/Queries/Query"
                            + "/Filters/Filter, value: " + right, e);
                }

                f.RightType = it.Current.GetAttribute("rightType", "");
                if (f.RightType == String.Empty)
                {
                    throw new ExceptionWithEventId(XEvent.Id.MATCH_CONFIG_34,
                            "Invalid game config xml found: rightType attribute missing on "
                            + "/XboxLiveSubmissionProject/GameConfigProject/Matchmaking/Queries/Query"
                            + "/Filters/Filter");
                }

                filters.Add(f);
            }

            return filters;
        }

        private SortedList ParseMatchQuerySortOps(XPathNavigator query)
        {
            XPathNodeIterator it = Select(query, "xl:SortOperations/xl:SortOperation");

            SortedList sortOps = new SortedList(it.Count);

            int i = 0;
            while (it.MoveNext())
            {
                Log("Parsing /XboxLiveSubmissionProject/GameConfigProject/Matchmaking/"
                        + "Queries/Query/SortOperations/SortOperation, ordinal " + i);
                ++i;

                MatchQuerySortOp s = new MatchQuerySortOp();

                string id = it.Current.GetAttribute("id", "");
                if (id == String.Empty)
                {
                    throw new ExceptionWithEventId(XEvent.Id.MATCH_CONFIG_35,
                            "Invalid game config xml found: id attribute missing on "
                            + "/XboxLiveSubmissionProject/GameConfigProject/Matchmaking/Queries/Query"
                            + "/SortOperations/SortOperation");
                }

                try
                {
                    s.Id = ParseUInt32(id);
                }
                catch (Exception e)
                {
                    throw new ExceptionWithEventId(XEvent.Id.MATCH_CONFIG_36,
                            "Invalid game config xml found: unable to parse id attribute as integer on "
                            + "/XboxLiveSubmissionProject/GameConfigProject/Matchmaking/Queries/Query"
                            + "/SortOperations/SortOperation, value: " + id, e);
                }

                s.Type = it.Current.GetAttribute("type", "");
                if (s.Type == String.Empty)
                {
                    throw new ExceptionWithEventId(XEvent.Id.MATCH_CONFIG_37,
                            "Invalid game config xml found: type attribute missing on "
                            + "/XboxLiveSubmissionProject/GameConfigProject/Matchmaking/Queries/Query"
                            + "/SortOperations/SortOperation");
                }

                string distanceid  = it.Current.GetAttribute("distanceid", "");
                if (distanceid == String.Empty)
                {
                    throw new ExceptionWithEventId(XEvent.Id.MATCH_CONFIG_38,
                            "Invalid game config xml found: distanceid attribute missing on "
                            + "/XboxLiveSubmissionProject/GameConfigProject/Matchmaking/Queries/Query"
                            + "/SortOperations/SortOperation");
                }

                try
                {
                    s.DistanceId = ParseUInt32(distanceid);
                }
                catch (Exception e)
                {
                    throw new ExceptionWithEventId(XEvent.Id.MATCH_CONFIG_39,
                            "Invalid game config xml found: unable to parse distanceid attribute as integer on "
                            + "/XboxLiveSubmissionProject/GameConfigProject/Matchmaking/Queries/Query"
                            + "/SortOperations/SortOperation, value: " + distanceid, e);
                }

                string ordinal = it.Current.GetAttribute("ordinal", "");
                if (ordinal == String.Empty)
                {
                    throw new ExceptionWithEventId(XEvent.Id.MATCH_CONFIG_40,
                            "Invalid game config xml found: ordinal attribute missing on "
                            + "/XboxLiveSubmissionProject/GameConfigProject/Matchmaking/Queries/Query"
                            + "/SortOperations/SortOperation");
                }

                try
                {
                    s.Ordinal = ParseUInt32(ordinal);
                }
                catch (Exception e)
                {
                    throw new ExceptionWithEventId(XEvent.Id.MATCH_CONFIG_41,
                            "Invalid game config xml found: unable to parse ordinal attribute as integer on "
                            + "/XboxLiveSubmissionProject/GameConfigProject/Matchmaking/Queries/Query"
                            + "/SortOperations/SortOperation, value: " + ordinal, e);
                }

                sortOps.Add(s.Ordinal, s);
            }

            return sortOps;
        }

        private SortedList ParseMatchQueryReturns(XPathNavigator query)
        {
            XPathNodeIterator it = Select(query, "xl:Returns/xl:Return");

            SortedList returns = new SortedList(it.Count);

            int i = 0;
            while (it.MoveNext())
            {
                Log("Parsing /XboxLiveSubmissionProject/GameConfigProject/Matchmaking/"
                        + "Queries/Query/Returns/Return, ordinal " + i);
                ++i;

                MatchQueryReturn r = new MatchQueryReturn();


                r.Id = ParseUInt32(it.Current.GetAttribute("id", ""));
                string id = it.Current.GetAttribute("id", "");
                if (id == String.Empty)
                {
                    throw new ExceptionWithEventId(XEvent.Id.MATCH_CONFIG_42,
                            "Invalid game config xml found: id attribute missing on "
                            + "/XboxLiveSubmissionProject/GameConfigProject/Matchmaking/Queries/Query"
                            + "/Returns/Return");
                }

                try
                {
                    r.Id = ParseUInt32(id);
                }
                catch (Exception e)
                {
                    throw new ExceptionWithEventId(XEvent.Id.MATCH_CONFIG_43,
                            "Invalid game config xml found: unable to parse id attribute as integer on "
                            + "/XboxLiveSubmissionProject/GameConfigProject/Matchmaking/Queries/Query"
                            + "/Returns/Return, value: " + id, e);
                }

                r.Type = it.Current.GetAttribute("type", "");
                if (r.Type == String.Empty)
                {
                    throw new ExceptionWithEventId(XEvent.Id.MATCH_CONFIG_44,
                            "Invalid game config xml found: type attribute missing on "
                            + "/XboxLiveSubmissionProject/GameConfigProject/Matchmaking/Queries/Query"
                            + "/Returns/Return");
                }

                string ordinal = it.Current.GetAttribute("ordinal", "");
                if (ordinal == String.Empty)
                {
                    throw new ExceptionWithEventId(XEvent.Id.MATCH_CONFIG_45,
                            "Invalid game config xml found: ordinal attribute missing on "
                            + "/XboxLiveSubmissionProject/GameConfigProject/Matchmaking/Queries/Query"
                            + "/Returns/Return");
                }

                try
                {
                    r.Ordinal = ParseUInt32(ordinal);
                }
                catch (Exception e)
                {
                    throw new ExceptionWithEventId(XEvent.Id.MATCH_CONFIG_46,
                            "Invalid game config xml found: unable to parse ordinal attribute as integer on "
                            + "/XboxLiveSubmissionProject/GameConfigProject/Matchmaking/Queries/Query"
                            + "/Returns/Return, value: " + ordinal, e);
                }

                returns.Add(r.Ordinal, r);
            }

            return returns;
        }


        private void ParseGameModes(XPathNavigator root)
        {
            Log("Parsing /XboxLiveSubmissionProject/GameConfigProject/GameModes");

            // TODO2THEOM: I noticed a "defaultvalue" of 0 on the gamemodes node.  Any point to this?

            XPathNodeIterator it = Select(root, "/xl:XboxLiveSubmissionProject/xl:GameConfigProject/xl:GameModes/xl:GameMode");

            _outputConfig.GameModes = new List<GameMode>(it.Count);

            int i = 0;
            while (it.MoveNext())
            {
                Log("Parsing /XboxLiveSubmissionProject/GameConfigProject/"
                        + "GameModes/GameMode, ordinal " + i);
                ++i;

                GameMode gm = ParseGameMode(it.Current);
                _outputConfig.GameModes.Add(gm);
            }

            // sort the list by game mode ID, for use later.
            GameModeComparer gmc = new GameModeComparer();
            _outputConfig.GameModes.Sort(gmc);
        }


        private GameMode ParseGameMode(XPathNavigator xpnMode)
        {
            GameMode gm = new GameMode();

            string id = xpnMode.GetAttribute("value", "");
            if (id == String.Empty)
            {
                throw new ExceptionWithEventId(XEvent.Id.MATCH_CONFIG_18,  // TODOTHEOM: new ID here.
                        "Invalid game config xml found: id attribute missing for a node within "
                        + "/XboxLiveSubmissionProject/GameConfigProject/GameModes/");
            }

            try
            {
                gm.Id = (byte)ParseUInt32(id);
            }
            catch (Exception e)
            {
                throw new ExceptionWithEventId(XEvent.Id.MATCH_CONFIG_19,  // TODOTHEOM: new ID here.
                        "Invalid game config xml found: unable to parse id attribute as integer on "
                        + "/XboxLiveSubmissionProject/GameConfigProject/GameModes/GameMode, "
                        + "value: " + id, e);
            }

            gm.FriendlyName = xpnMode.GetAttribute("friendlyName", "");
            if (gm.FriendlyName == String.Empty)
            {
                throw new ExceptionWithEventId(XEvent.Id.MATCH_CONFIG_20,  // TODOTHEOM: new ID here.
                        "Invalid game config xml found: friendlyName attribute missing on "
                        + "/XboxLiveSubmissionProject/GameConfigProject/GameModes/GameMode");
            }
            return gm;
        }


        private void Log(string msg)
        {
            _outputLog.WriteLine(msg);
        }

        public static uint ParseUInt32(string str)
        {
            int fromBase = 10;

            if (str.StartsWith("0x"))
            {
                fromBase = 16;
                str = str.Substring(2);
            }

            return Convert.ToUInt32(str, fromBase);
        }

        private XPathNodeIterator Select(XPathNavigator nav, string strExpr)
        {
            XPathExpression expr = nav.Compile(strExpr);
            expr.SetContext(_nsmgr);
            return nav.Select(expr);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\Memcache\interface\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\Memcache\XBanc\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\Memcache\Acceleration\AccelerationMemCache.cs ===
using System;
using System.Text;
using xonline.common.service;
using xonline.common.config;

namespace xonline.server.XConnSrv
{
    public class MemCacheImpl : IMemCache
    {
        private Acceleration m_accel;
        private DataChangeNotification m_notificationCallback;
        private DataChangeFailureNotification m_failureCallback;
        
        public MemCacheImpl() : this (Interface.NotificationCache)
        {
        }
        public MemCacheImpl(string iface)
        {
            m_accel = new Acceleration(iface);
        }

        public string GetImplementationName()
        {
            return "Acceleration -- " + m_accel.InterfaceName;
        }
        
        public byte[] RequestData(string sKey, Object keyState)
        {
            uint version;
            return RequestData(sKey, keyState, out version);
        }

        public byte[] RequestData(string sKey, Object keyState, out uint version)
        {
            byte[] rgbValue;
            RequestData(sKey, keyState, out version, out rgbValue);
            return rgbValue;
        }
        
        public uint RequestData(string sKey, Object keyState, out uint version, out byte[] rgbValue)
        {
            byte[] rgbKey = keyState as byte[];
            if ((rgbKey == null) && (sKey != null))
            {
                rgbKey = Encoding.ASCII.GetBytes(sKey);
            }
            uint validSeconds;
            return m_accel.Query(rgbKey, out rgbValue, out validSeconds, out version);
        }
        
        
        public byte[][] BulkRequestData(string[] rgKeys, Object[] rgKeyStates)
        {
            uint[] rgVersions = new uint[rgKeys.Length];
            return BulkRequestData(rgKeys, rgKeyStates, out rgVersions);
        }

        public byte[][] BulkRequestData(string[] rgKeys, Object[] rgKeyStates, out uint[] rgVersions)
        {
            byte[][] rgValues;
            BulkRequestData(rgKeys, rgKeyStates, out rgVersions, out rgValues);
            return rgValues;
        }

        public uint[] BulkRequestData(string[] rgKeys, Object[] rgKeyStates, out uint[] rgVersions, out byte[][] rgValues)
        {
            byte[][] rgbKeys = new byte[rgKeys.Length][];
            uint[] rgValidSeconds;
            for (int iKey = 0; iKey < rgbKeys.Length; iKey++)
            {
                rgbKeys[iKey] = rgKeyStates[iKey] as byte[];
                if ((rgbKeys[iKey] == null) && (rgKeys[iKey] != null))
                {
                    rgbKeys[iKey] = Encoding.ASCII.GetBytes(rgKeys[iKey]);
                }
            }
            return m_accel.Query(rgbKeys, out rgValues, out rgValidSeconds, out rgVersions);
        }
        
        public void PublishData(string sKey, byte[] rgbValue, Object keyState)
        {
            uint version = AccelerationDefs.ACCELERATION_SET_DATA_VERSION_OVERWRITE;
            PublishData(sKey, rgbValue, keyState, ref version, 0);
        }

        public uint PublishData(string sKey, byte[] rgbValue, Object keyState, ref uint version)
        {
            return PublishData(sKey, rgbValue, keyState, ref version, 0);
        }

        public uint PublishData(string sKey, byte[] rgbValue, Object keyState, ref uint version, uint expirySeconds)
        {
            byte[] rgbKey = keyState as byte[];
            if ((rgbKey == null) && (sKey != null))
            {
                rgbKey = Encoding.ASCII.GetBytes(sKey);
            }
            return m_accel.SetData(rgbKey, rgbValue, expirySeconds, 0, ref version);
        }

        public void BulkPublishData(string[] rgKeys, byte[][] rgbValues, Object[] rgKeyStates)
        {
            uint[] rgVersions = new uint[rgKeys.Length];
            for (int iKey = 0; iKey < rgKeys.Length; iKey++)
            {
                rgVersions[iKey] = AccelerationDefs.ACCELERATION_SET_DATA_VERSION_OVERWRITE;
            }
            BulkPublishData(rgKeys, rgbValues, rgKeyStates, rgVersions);
        }
        
        public uint[] BulkPublishData(string[] rgKeys, byte[][] rgbValues, Object[] rgKeyStates, uint[] rgVersions)
        {
            byte[][] rgRealKeys = new byte[rgKeys.Length][];
            for (int iKey = 0; iKey < rgKeys.Length; iKey++)
            {
                rgRealKeys[iKey] = rgKeyStates[iKey] as byte[];
                if ((rgRealKeys[iKey] == null) && (rgKeys[iKey] != null))
                {
                    rgRealKeys[iKey] = Encoding.ASCII.GetBytes(rgKeys[iKey]);
                }
            }
            return m_accel.SetData(rgRealKeys, rgbValues, new uint[rgKeys.Length], new uint[rgKeys.Length], rgVersions);
        }

        public void RemoveData(string sKey)
        {
            byte[] key = null;
            if (sKey != null)
            {
                key = Encoding.ASCII.GetBytes(sKey);
            }
            m_accel.Remove(key);
        }

        public void BulkRemoveData(string[] sKeys)
        {
            byte[][] keys = new byte[sKeys.Length][];
            for (int i = 0; i < sKeys.Length; i++ )
            {
                if (sKeys[i] != null)
                {
                    keys[i] = Encoding.ASCII.GetBytes(sKeys[i]);
                }
            }
            m_accel.Remove(keys);
        }

        public void RegisterNotificationHandler(DataChangeNotification notificationCallback)
        {
            if (notificationCallback == null)
            {
                return;
            }

            if (m_notificationCallback == null)
            {
                m_accel.RegisterNotificationHandler(AccelerationNotificationHandler);
            }

            m_notificationCallback += notificationCallback;
        }
        
        public void RegisterNotificationFailureHandler(DataChangeFailureNotification failureCallback)
        {
            if (failureCallback == null)
            {
                return;
            }

            if (m_failureCallback == null)
            {
                m_accel.RegisterNotificationFailureHandler(AccelerationNotificationFailureHandler);
            }

            m_failureCallback += failureCallback;
        }
        
        public void UnregisterHandlers()
        {
            m_notificationCallback = null;
            m_failureCallback = null;

            m_accel.UnregisterHandlers();
        }

        public void AccelerationNotificationHandler(byte[][] keys)
        {
            if (m_notificationCallback == null)
            {
                return;
            }
            
            string[] rgsKeys = new string[keys.Length];
            for (int iKey = 0; iKey < rgsKeys.Length; iKey++)
            {
                rgsKeys[iKey] = Encoding.ASCII.GetString(keys[iKey]);
            }
            m_notificationCallback(rgsKeys, keys);
        }

        public void AccelerationNotificationFailureHandler()
        {
            if (m_failureCallback == null)
            {
                return;
            }
            
            m_failureCallback();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\Memcache\interface\IMemCache.cs ===
using System;
using xonline.common.service;

namespace xonline.server.XConnSrv
{
    public delegate void DataChangeNotification(string[] rgChangedKeys, Object[] rgKeyStates);
    public delegate void DataChangeFailureNotification();

    public interface IMemCache
    {
        string GetImplementationName();

        byte[] RequestData(string sKey, Object keyState);
        byte[] RequestData(string sKey, Object keyState, out uint version);
        uint RequestData(string sKey, Object keyState, out uint version, out byte[] rgbValue);
        byte[][] BulkRequestData(string[] rgKeys, Object[] rgKeyStates);
        byte[][] BulkRequestData(string[] rgKeys, Object[] rgKeyStates, out uint[] rgVersions);
        uint[] BulkRequestData(string[] rgKeys, Object[] rgKeyStates, out uint[] rgVersions, out byte[][] rgbValues);
        
        void PublishData(string sKey, byte[] rgbValue, Object keyState);
        uint PublishData(string sKey, byte[] rgbValue, Object keyState, ref uint version);
        uint PublishData(string sKey, byte[] rgbValue, Object keyState, ref uint version, uint expirySeconds);
        void BulkPublishData(string[] rgKeys, byte[][] rgbValues, Object[] rgKeyStates);
        uint[] BulkPublishData(string[] rgKeys, byte[][] rgbValues, Object[] rgKeyStates, uint[] rgVersions);
        
        void RegisterNotificationHandler(DataChangeNotification notificationCallback);
        void RegisterNotificationFailureHandler(DataChangeFailureNotification failureCallback);
        void UnregisterHandlers();

        void RemoveData(string sKey);
        void BulkRemoveData(string[] sKeys);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\Memcache\XBanc\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\msi\installutil\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\match\match\MatchSqlCodeGenXbox1.cs ===
using System;
using System.Collections;
using System.Reflection;
using System.Text;
using System.IO;
using System.Xml;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.service;

namespace xonline.common.match
{
    public class MatchSqlCodeGenXbox1
    {
        public class Settings
        {
            public string InputFilename = "";
            public string OutputPath = "";
            public string ServerList = "";
            public bool DropTable = false;
            public bool NoNat = false;
        }

        const string c_szUsage = 
            "Converts Matchmaking XMS files into SQL scripts\n" +
            "\n" +
            "XMLtoSQL /in:<input XML file> [/dblist:<server1,server2,etc>] [/droptable]\n" +
            "\n" +
            "Output file will have the form: <titleid>.sql (and <titleid>_title_info.sql if /dblist is used)\n" +
            "\n" +
            "Example: XMLtoSQL /in:sample.XMS\n" +
            "\n" +
            "  /droptable    Specifies that the generated SQL script should drop any existing table\n" +
            "                before creating the new one.  This is necessary when attributes have\n" +
            "                been added or removed.  In Production, this should be used very\n" +
            "                cautiously because it will drop all current sessions.  In other\n" +
            "                environments using this switch should be the default because attribute\n" +
            "                definitions frequently change during development.\n" +
            "\n" +
            "  /dblist       Specifies the database to be filled into the t_match_titles table as\n" +
            "                the active database for this title.  Multiple addresses are allowed\n" +
            "                in order to support failover on multiple NICs for the specified\n" +
            "                database.\n" +
            "\n" +
            "  /nonat        Specifies that filtering by NAT type should be turned off.\n" +
            "\n";

        const string c_szInPrefix = "/in:";
        const string c_szDBListPrefix = "/dblist:";
        const string c_szDropTablePrefix = "/droptable";
        const string c_szNoNatPrefix = "/nonat";
        const string c_szOutFileTemplate = "{0:X08}.sql"; // TitleID filled in later
        const string c_szDBListOutFileTemplate = "{0:X08}_title_info.sql"; // TitleID filled in later

        class IdFragment
        {
            public IdFragment(string sql, uint attrId)
            {
                Sql = sql;
                Id = attrId;
            }

            public uint Id;
            public string Sql;
        }

        ArrayList           _globalFragments;
        ArrayList           _opFragments;
        string              _outputFilename;
        StreamWriter        _outputFile;
        MatchGameConfig     _config;
        TextWriter          _log;
        Settings            _settings;
        string              _buildVer;

/*
        static void Usage()
        {
            Log(c_szUsage);
        }

        static void Main(string []args)
        {
            //
            // Parse and fully qualify the filename arguments
            //
            if( args.Length < 1 )
            {
                Usage();
                return;
            }

            // Parse command line into a settings object
            MatchSqlCodeGenXbox1.Settings settings = new MatchSqlCodeGenXbox1.Settings();
            foreach(string arg in args)
            {
                string []parts = arg.Split(":");
                string strName = parts[0];
                string strValue = "";
                if(parts > 1)
                {
                    strValue = parts[1];
                }

                switch(strName)
                {
                    case "/in":
                        settings.InputFilename = strValue;
                    break;
                    case "/dblist":
                        settings.ServerList = strValue;
                    break;
                    case "/droptable":
                        settings.DropTable = true;
                    break;
                    case "/nonat":
                        settings.NoNat = true;
                    break;
                }
            }

            // Check for valid input file
            if(settings.InputFilename == String.Empty)
            {
                Usage();
                return;
            }

            if(!File.Exists(settings.InputFilename))
            {
                Log("Could not find XMS file: " + settings.InputFilename);
                Usage();
                return;
            }

            Log( "MatchSqlCodeGen(Xbox1) processing input file: " + settings.InputFilename);

            // Load the match game config
            MatchXmsConfigLoader loader = new MatchXmsConfigLoader();
            XmlDocument doc = new XmlDocument();
            doc.Load(settings.InputFilename);
            loader.Load(doc, Console.Out, out config);

            //
            // Load and validate the input XML file
            //
            
            MatchSqlCodeGenXbox1 emitter = new MatchSqlCodeGenXbox1(Console.Out);
            emitter.EmitTitleSQL(config, settings);
        }

*/
        public MatchSqlCodeGenXbox1(TextWriter log)
        {
            // Initialize the global sql fragments table
            _globalFragments = new ArrayList();
            _globalFragments.Add(new IdFragment( "s.bi_session_id",         MatchDefs.X_ATTRIBUTE_XBOX1_SESSION_ID ));
            _globalFragments.Add(new IdFragment( "s.i_public_available",    MatchDefs.X_ATTRIBUTE_XBOX1_PUB_AVAIL ));
            _globalFragments.Add(new IdFragment( "s.i_private_available",   MatchDefs.X_ATTRIBUTE_XBOX1_PRIV_AVAIL ));
            _globalFragments.Add(new IdFragment( "s.i_public_current",      MatchDefs.X_ATTRIBUTE_XBOX1_PUB_CURR ));
            _globalFragments.Add(new IdFragment( "s.i_private_current",     MatchDefs.X_ATTRIBUTE_XBOX1_PRIV_CURR ));
            _globalFragments.Add(new IdFragment( "i_dist",                  MatchDefs.X_ATTRIBUTE_XBOX1_DISTANCE ));
            _globalFragments.Add(new IdFragment( "( i_dist & 0xff )",       MatchDefs.X_ATTRIBUTE_XBOX1_APPROX_DISTANCE ));

            // Initialize the filter op fragments table
            _opFragments = new ArrayList();
            _opFragments.Add(new IdFragment("=",    MatchDefs.XMATCH_FILTEROP_EQUALS));
            _opFragments.Add(new IdFragment("!=",   MatchDefs.XMATCH_FILTEROP_NOTEQUALS));
            _opFragments.Add(new IdFragment("<=",   MatchDefs.XMATCH_FILTEROP_LESSEQUAL));
            _opFragments.Add(new IdFragment(">=",   MatchDefs.XMATCH_FILTEROP_GREATEREQUAL));
            _opFragments.Add(new IdFragment("<",    MatchDefs.XMATCH_FILTEROP_LESS));
            _opFragments.Add(new IdFragment(">",    MatchDefs.XMATCH_FILTEROP_GREATER));

            _log = log; 
        }

        // Common emitter
        void Emit(string fmt, params object[] args)
        {
            string str = String.Format(fmt, args);

            // Fix newlines to emulate old tool
            string str2 = str.Replace("\n", "\r\n");
            
            _outputFile.Write(str2);
        }


        // Common logging
        void Log(string msg)
        {
            _log.WriteLine(msg);
        }

        void LogError(string msg)
        {
            _log.WriteLine(msg);
        }

        // Assembly contains the build version (from bldver.cs)
        string GetBuildVer()
        {
            if(null == _buildVer)
            {
                string fullVersion = Assembly.GetExecutingAssembly().FullName;
                
                int start = fullVersion.IndexOf("Version=");
                int end = fullVersion.IndexOf(",", start);

                if(start < 0 || end < 0)
                {
                    throw new Exception("Unexpected error: could not parse version number from assembly name: " + fullVersion);
                }

                start += "Version=".Length;
                _buildVer = fullVersion.Substring(start, end-start);
            }

            return _buildVer;
        }

        void EmitQueryParameters(MatchQuery query)
        {
            if(null == query.Parameters || 0 == query.Parameters.Count)
            {
                Emit("\n");
            }
            else
            {
                for(uint i = 0; i < query.Parameters.Count; ++i)
                {
                    MatchQueryParam param =  query.Parameters[(int)i] as MatchQueryParam;
                    string paramSqlType = GetSQLReturnType(param.Id, param.MaxLength);
                    string paramPrefix = GetSQLVariablePrefix(param.Id);

                    Emit("    ,{0}param_{1,-21} {2,-15} {3} -- [{4}]\n",
                            paramPrefix,
                            i + 1,
                            paramSqlType,
                            param.NullOk ? "= NULL" : "      ",
                            param.Name
                        );

                } 
            }
        }

        void EmitQueryReturns(MatchQuery query, string spaces)
        {
            if( null == query.Returns || 0 == query.Returns.Count )
            {
                Emit("\n");
            }
            else
            {
                for( int i = 0; i < query.Returns.Count; i++ )
                {
                    MatchQueryReturn ret = query.Returns.GetByIndex(i) as MatchQueryReturn;

                    switch( ret.TypeId ) 
                    {
                        case MatchDefs.XMATCH_RETURN_TYPE_NORMAL:
                            Emit(",\n{0}s.att_{1}", 
                                    spaces,
                                    ret.Id 
                                );
                            break;
                        case MatchDefs.XMATCH_RETURN_TYPE_AVERAGE:
                            Emit( ",\n{0}CAST( AVG( s.att_{1} ) AS bigint )", 
                                    spaces,
                                    ret.Id
                                );
                            break;
                        case MatchDefs.XMATCH_RETURN_TYPE_SUM:
                            Emit( ",\n{0}CAST( ( SUM( s.att_{1} ) * @ti_server_count ) AS bigint )", 
                                    spaces,
                                    ret.Id
                                );
                            break;
                        case MatchDefs.XMATCH_RETURN_TYPE_MINIMUM:
                            Emit( ",\n{0}CAST( MIN( s.att_{1} ) AS bigint )", 
                                    spaces,
                                    ret.Id
                                );
                            break;
                        case MatchDefs.XMATCH_RETURN_TYPE_MAXIMUM:
                            Emit( ",\n{0}CAST( MAX( s.att_{1} ) AS bigint )", 
                                    spaces,
                                    ret.Id
                                );
                            break;
                        case MatchDefs.XMATCH_RETURN_TYPE_COUNT:
                            Emit( ",\n{0}CAST( ( COUNT( * ) * @ti_server_count ) AS bigint )", 
                                    spaces
                                );
                            break;
                        default:
                            throw new InvalidConfigException(
                                    _config, 
                                    "Query: 0x" + query.Id.ToString("x"),
                                    "Invalid return type in game config: " + ret.Type);
                    }

                }

                Emit("\n");
            }
        }

        void EmitQuerySortOps(MatchQuery query)
        {
            string beginLine;
            string sql;
            string sql2;
            string direction;

            if(null == query.SortOps)
            {
                return;
            }

            for( int i = 0; i < query.SortOps.Count; ++i)
            {
                MatchQuerySortOp sortop = query.SortOps.GetByIndex(i) as MatchQuerySortOp;

                if( 0 == i )
                {
                    beginLine = "    ORDER BY ";
                }
                else
                {
                    beginLine = "             ,";
                }

                sql = QueryObjSQLForAttr(query, sortop.Id);
                    
                if( MatchDefs.XMATCH_SORTOP_ASCENDING == sortop.TypeId ||
                        MatchDefs.XMATCH_SORTOP_NEAR == sortop.TypeId )
                {
                    direction = "ASC";
                }
                else
                {
                    direction = "DESC";
                }

                switch( sortop.TypeId ) 
                {
                    case MatchDefs.XMATCH_SORTOP_ASCENDING:
                    case MatchDefs.XMATCH_SORTOP_DESCENDING:
                        Emit("{0}{1} {2}\n", beginLine, sql, direction);
                        break;
                    case MatchDefs.XMATCH_SORTOP_NEAR:
                    case MatchDefs.XMATCH_SORTOP_FAR:
                        sql2 = QueryObjSQLForAttr(query, sortop.DistanceId);
                        Emit("{0}ABS( {1} - {2} ) {3}\n", beginLine, sql, sql2, direction);
                        break;
                    default:
                        throw new InvalidConfigException(
                                _config,
                                "query: 0x" + query.Id.ToString("x"),
                                "unknown sortop type: " + sortop.TypeId);
                }
            }
        }


        const string c_szQueryFilterNullOk = 
            "{0}( 1 = CASE WHEN {1} IS NULL THEN 1 WHEN {2} {3} {4} THEN 1 ELSE 0 END )"; // spacing, null param, left, op, right

        const string c_szQueryFilterNonNull = 
            "{0}( {1} {2} {3} )"; // spacing, left, op, right


        void EmitQueryFilters(MatchQuery query, bool fInitialAND, string spaces )
        {
            if(null == query.Filters)
            {
                return;
            }

            for( int i = 0; i < query.Filters.Count; i++ )
            {
                MatchQueryFilter filter = query.Filters[i] as MatchQueryFilter;
                if( !fInitialAND && 0 == i )
                {
                    Emit("    WHERE\n");
                }

                if( fInitialAND || 0 != i )
                {
                    Emit(" AND\n");
                }

                bool fLeftNullOk = query.ParamAllowsNull( filter.Left );
                bool fRightNullOk = query.ParamAllowsNull( filter.Right );

                if( fLeftNullOk && fRightNullOk )
                {
                    throw new InvalidConfigException(
                            _config,
                            "query: 0x" + query.Id.ToString("x"),
                            "Filter contains nullable parameter on both sides [" + i + "] in query [" + query.FriendlyName + "]");
                }

                string left = QueryObjSQLForAttr( query, filter.Left);
                string right = QueryObjSQLForAttr( query, filter.Right);

                // We use CASE/WHEN to cover the three cases that would not work properly with ISNULL, 
                // namely '>', '<', and '!='.
                if( fLeftNullOk )
                {
                    Emit(c_szQueryFilterNullOk,
                            spaces,      // spacing
                            left, 
                            left, 
                            GetOpIDSQLString( filter.OpId ),
                            right
                        );
                }
                else if( fRightNullOk )
                {
                    Emit(c_szQueryFilterNullOk,
                            spaces,      // spacing
                            right, 
                            left, 
                            GetOpIDSQLString( filter.OpId ),
                            right
                        );
                }
                else
                {
                    Emit(c_szQueryFilterNonNull,
                            spaces,      // spacing
                            left, 
                            GetOpIDSQLString( filter.OpId ),
                            right
                        );
                }
            }

            if( 0 != query.Filters.Count )
            {
                Emit("\n");
            }
        }


        // TitleId
        const string c_szSessionInsertTemplate1 =
            "-----------------------------------------------------------------------------------------------\n" +
            "--\n" +
            "-- Proc: p_match_session_insert_{0}\n" +
            "--\n" +
            "-----------------------------------------------------------------------------------------------\n" +
            "\n" +
            "IF NOT EXISTS (SELECT name FROM dbo.sysobjects WHERE  type = 'p' AND name = 'p_match_session_insert_{0}')\n" +
            "BEGIN\n" +
            "    EXEC('create procedure dbo.p_match_session_insert_{0} as raiserror(\"Empty Stored Procedure!!\", 16, 1) with seterror')\n" +
            "    IF (@@error != 0)\n" +
            "    BEGIN\n" +
            "        PRINT 'FAILED to create p_match_session_insert_{0}'\n" +
            "    END\n" +
            "END\n" +
            "GO\n" +
            "\n" +
            "ALTER PROCEDURE [dbo].[p_match_session_insert_{0}]\n" +
            "     @bi_session_id                 bigint\n" +
            "    ,@i_ip_addr                     int\n" +
            "    ,@i_sg_ip                       int\n" +
            "    ,@b_box_id                      binary(16)\n" +
            "    ,@b_host_address                binary(36)\n" +
            "    ,@b_key_exchange_key            binary(16)\n" +
            "    ,@i_public_available            int\n" +
            "    ,@i_private_available           int\n" +
            "    ,@i_public_current              int\n" +
            "    ,@i_private_current             int\n" +
            "    ,@i_expiration                  int\n" +
            "    ,@ti_nat_type                   tinyint\n";

        // AttributeId, SqlType, AttributeName
        const string c_szSessionInsertTemplate2 = 
            "    ,@att_{0,-26}{1,-15} = NULL -- [{2}]\n";

        // TitleId, BuildVer
        const string c_szSessionInsertTemplate3 = 
            "AS\n" +
            "-- Do not modify. Build Info - !!Version={1}\n" +
            "BEGIN\n" +
            "    DECLARE\n" +
            "        -- Generic\n" +
            "         @i_return_code             int\n" +
            "        ,@i_ip_end                  int\n" +
            "        ,@error_var                 int\n" +
            "        ,@dt_expire_date            datetime\n" +
            "        ,@si_zoneID                 smallint\n" +
            "        ,@si_providerID             smallint\n" +
            "        ,@ti_is_available           tinyint\n" +
            "\n" +
            "    SET nocount on\n" +
            "\n" +
            "    --\n" +
            "    --  Lookup the zone id\n" +
            "    --\n" +
            "\n" +
            "    SET @i_ip_end = null\n" +
            "\n" +
            "    SELECT TOP 1 @si_zoneID = si_zoneID, @si_providerID = si_providerID, @i_ip_end = i_ip_end\n" +
            "    FROM v_match_zone_map m\n" +
            "    WHERE m.i_ip_start <= @i_ip_addr\n" +
            "\n" +
            "    IF @i_ip_end is null or @i_ip_addr > @i_ip_end   -- don't need to check ip start again\n" +
            "    BEGIN\n" +
            "        SET @si_zoneID = -1  -- no zone match\n" +
            "        SET @si_providerID = -1\n" +
            "    END\n" +
            "\n" +
            "    SELECT @dt_expire_date = DATEADD(second,@i_expiration,GETUTCDATE())\n" +
            "\n" +
            "    --\n" +
            "    --  Insert the session\n" +
            "    --\n" +
            "\n" +
            "    SET @ti_is_available = CASE WHEN @i_public_available > 0 THEN 1 ELSE 0 END\n" +
            "\n" +
            "    INSERT INTO dbo.t_match_sessions_{0} (\n" +
            "         bi_session_id\n" +
            "        ,i_ip_addr\n" +
            "        ,i_sg_ip\n" +
            "        ,b_box_id\n" +
            "        ,b_host_address\n" +
            "        ,si_zoneID\n" +
            "        ,si_providerID\n" +
            "        ,b_key_exchange_key\n" +
            "        ,i_public_available\n" +
            "        ,i_private_available\n" +
            "        ,i_public_current\n" +
            "        ,i_private_current\n" +
            "        ,dt_session_expiration\n" +
            "        ,ti_is_available\n" +
            "        ,i_hash\n" +
            "        ,ti_nat_type\n";

        // AttributeId
        const string c_szSessionInsertTemplate4 = 
            "        ,att_{0}\n";

        // Noargs
        const string c_szSessionInsertTemplate5 = 
            "    ) VALUES (\n" +
            "         @bi_session_id\n" +
            "        ,@i_ip_addr\n" +
            "        ,@i_sg_ip\n" +
            "        ,@b_box_id\n" +
            "        ,@b_host_address\n" +
            "        ,@si_zoneID\n" +
            "        ,@si_providerID\n" +
            "        ,@b_key_exchange_key\n" +
            "        ,@i_public_available\n" +
            "        ,@i_private_available\n" +
            "        ,@i_public_current\n" +
            "        ,@i_private_current\n" +
            "        ,@dt_expire_date\n" +
            "        ,@ti_is_available\n" +
            "        ,RAND() * 1000\n" +
            "        ,@ti_nat_type\n";

        // AttributeId
        const string c_szSessionInsertTemplate6 = 
            "        ,@att_{0}\n";

        // TitleId
        const string c_szSessionInsertTemplate7 = 
            "    )\n" +
            "\n" +
            "    SELECT @error_var = @@ERROR\n" +
            "\n" +
            "    IF @error_var != 0\n" +
            "    BEGIN\n" +
            "        IF @error_var = 2627 -- integrity violation\n" +
            "        BEGIN\n" +
            "            -- setting the return code is really pointless since xstorage will receive DB_E_INTEGRITYVIOLATION\n" +
            "            -- but it is important to set error_var to 0 since this occurs in normal operation and we don't want\n" +
            "            -- event spew on every occurance.\n" +
            "            SET @i_return_code = 0x80155112  -- XONLINE_E_MATCH_SESSION_ALREADY_EXISTS\n" +
            "            SET @error_var = 0\n" +
            "            GOTO exit_label\n" +
            "        END\n" +
            "\n" +
            "        SET @i_return_code = 0x80155115  -- XONLINE_E_MATCH_CRITICAL_DB_ERR\n" +
            "        GOTO exit_label\n" +
            "    END\n" +
            "\n" +
            "    RETURN 0\n" +
            "\n" +
            "exit_label:\n" +
            "    IF @error_var != 0\n" +
            "    BEGIN\n" +
            "        DECLARE @message varchar(255)\n" +
            "        SELECT @message = 'Session insert failed: p_match_session_insert_{0} - ' + CAST(CAST(CAST(@error_var AS binary(4)) AS int) AS varchar(64))\n" +
            "        EXEC master.dbo.xp_logevent 51709, @message, error\n" +
            "    END\n" +
            "    RETURN @i_return_code\n" +
            "END\n" +
            "GO\n" +
            "GRANT EXECUTE ON p_match_session_insert_{0} TO ClientLib\n" +
            "GO\n" +
            "\n";

        void EmitInsertProcSQL()
        {
            Emit(c_szSessionInsertTemplate1, _config.TitleId);

            // Print each attribute
            foreach(MatchSchemaAttribute attr in _config.MatchSchema)
            {
                // NOTE: SQL will truncate the parameters to the specified size.  In other words, if
                // the parameter is declared as 20 and you pass 21, it will just truncate it to 20. 
                // This is a problem because we would like to return an error to the client if they 
                // attempt to pass more than the declared size of an attribute.  In order to make
                // that happen, we add 1 here to the MaxLen and SQL will fail with DB_E_OVERFLOW.
                string type = GetSQLReturnType(attr.Id, (uint)(attr.MaxLength + 1));

                Emit(c_szSessionInsertTemplate2, 
                        attr.Id,
                        type,
                        attr.Name);
            }

            Emit(c_szSessionInsertTemplate3, _config.TitleId, GetBuildVer());

            // Print each attribute
            foreach(MatchSchemaAttribute attr in _config.MatchSchema)
            {
                Emit(c_szSessionInsertTemplate4, attr.Id);
            }

            Emit(c_szSessionInsertTemplate5);

            // Print each attribute
            foreach(MatchSchemaAttribute attr in _config.MatchSchema)
            {
                Emit(c_szSessionInsertTemplate6, attr.Id);
            }

            Emit(c_szSessionInsertTemplate7, _config.TitleId);
        }

        const string c_szSessionUpdateTemplate1 =
            "-----------------------------------------------------------------------------------------------\n" +
            "--\n" +
            "-- Proc: p_match_session_update_{0}\n" +
            "--\n" +
            "-----------------------------------------------------------------------------------------------\n" +
            "\n" +
            "IF NOT EXISTS (SELECT name FROM dbo.sysobjects WHERE  type = 'p' AND name = 'p_match_session_update_{0}')\n" +
            "BEGIN\n" +
            "    EXEC('create procedure dbo.p_match_session_update_{0} as raiserror(\"Empty Stored Procedure!!\", 16, 1) with seterror')\n" +
            "    IF (@@error != 0)\n" +
            "    BEGIN\n" +
            "        PRINT 'FAILED to create p_match_session_update_{0}'\n" +
            "    END\n" +
            "END\n" +
            "GO\n" +
            "\n" +
            "ALTER PROCEDURE [dbo].[p_match_session_update_{0}]\n" +
            "     @bi_session_id                 bigint\n" +
            "    ,@i_public_available            int\n" +
            "    ,@i_private_available           int\n" +
            "    ,@i_public_current              int\n" +
            "    ,@i_private_current             int\n" +
            "    ,@i_expiration                  int\n";

        // Id, SqlType, Name
        const string c_szSessionUpdateTemplate2 = 
            "    ,@att_{0,-26}{1,-15} = NULL -- [{2}]\n";

        // TitleId, BuildVer
        const string c_szSessionUpdateTemplate3 = 
            "AS\n" +
            "-- Do not modify. Build Info - !!Version={1}\n" +
            "BEGIN\n" +
            "    DECLARE\n" +
            "         @i_return_code             int\n" +
            "        ,@error_var                 int\n" +
            "        ,@rowcount_var              int\n" +
            "        ,@dt_expire_date            datetime\n" +
            "        ,@ti_is_available           tinyint\n" +
            "\n" +
            "    SET nocount on\n" +
            "\n" +
            "    SELECT @dt_expire_date = DATEADD(second,@i_expiration,GETUTCDATE())\n" +
            "\n" +
            "    --\n" +
            "    --  Update the session\n" +
            "    --\n" +
            "\n" +
            "    SET @ti_is_available = CASE WHEN @i_public_available > 0 THEN 1 ELSE 0 END\n" +
            "\n" +
            "    UPDATE dbo.t_match_sessions_{0} SET\n" +
            "         i_public_available = @i_public_available\n" +
            "        ,i_private_available = @i_private_available\n" +
            "        ,i_public_current = @i_public_current\n" +
            "        ,i_private_current = @i_private_current\n" +
            "        ,dt_session_expiration = @dt_expire_date\n"  +
            "        ,ti_is_available = @ti_is_available\n";

        // AttributeId
        const string c_szSessionUpdateTemplate4 = 
            "        ,att_{0} = ISNULL(@att_{0}, att_{0})\n";

        // TitleId
        const string c_szSessionUpdateTemplate5 = 
            "        WHERE bi_session_id = @bi_session_id\n" +
            "\n" +
            "    SELECT @error_var = @@ERROR, @rowcount_var = @@ROWCOUNT\n" +
            "\n" +
            "    IF @error_var != 0\n" +
            "    BEGIN\n" +
            "        SET @i_return_code = 0x80155115  -- XONLINE_E_MATCH_CRITICAL_DB_ERR\n" +
            "        GOTO exit_label\n" +
            "    END\n" +
            "\n" +
            "    IF @rowcount_var = 0\n" +
            "    BEGIN\n" +
            "        SET @i_return_code = 0x80155100  -- XONLINE_E_MATCH_INVALID_SESSION_ID\n" +
            "        GOTO exit_label\n" +
            "    END\n" +
            "\n" +
            "    RETURN 0\n" +
            "\n" +
            "exit_label:\n" +
            "    IF @error_var != 0\n" +
            "    BEGIN\n" +
            "        DECLARE @message varchar(255)\n" +
            "        SELECT @message = 'Session update failed: p_match_session_update_{0} - ' + CAST(CAST(CAST(@error_var AS binary(4)) AS int) AS varchar(64))\n" +
            "        EXEC master.dbo.xp_logevent 51710, @message, error\n" +
            "    END\n" +
            "    RETURN @i_return_code\n" +
            "END\n" +
            "GO\n" +
            "GRANT EXECUTE ON p_match_session_update_{0} TO ClientLib\n" +
            "GO\n" +
            "\n";    

        void EmitUpdateProcSQL()
        {
            Emit(c_szSessionUpdateTemplate1, _config.TitleId);

            // Print each attribute
            foreach(MatchSchemaAttribute attr in _config.MatchSchema)
            {
                // NOTE: SQL will truncate the parameters to the specified size.  In other words, if
                // the parameter is declared as 20 and you pass 21, it will just truncate it to 20. 
                // This is a problem because we would like to return an error to the client if they 
                // attempt to pass more than the declared size of an attribute.  In order to make
                // that happen, we add 1 here to the MaxLen and SQL will fail with DB_E_OVERFLOW.
                string type = GetSQLReturnType( attr.Id, (uint)(attr.MaxLength + 1));

                Emit(c_szSessionUpdateTemplate2, attr.Id, type, attr.Name);
            }

            Emit(c_szSessionUpdateTemplate3, _config.TitleId, GetBuildVer());

            // Print each attribute
            foreach(MatchSchemaAttribute attr in _config.MatchSchema)
            {
                Emit(c_szSessionUpdateTemplate4, attr.Id);
            }

            Emit(c_szSessionUpdateTemplate5, _config.TitleId); 
        }

        // TitleId, BuildVer
        const string c_szSessionDeleteTemplate1 =
            "-----------------------------------------------------------------------------------------------\n" +
            "--\n" +
            "-- Proc: p_match_session_delete_{0}\n" +
            "--\n" +
            "-----------------------------------------------------------------------------------------------\n" +
            "\n" +
            "IF NOT EXISTS (SELECT name FROM dbo.sysobjects WHERE  type = 'p' AND name = 'p_match_session_delete_{0}')\n" +
            "BEGIN\n" +
            "    EXEC('create procedure dbo.p_match_session_delete_{0} as raiserror(\"Empty Stored Procedure!!\", 16, 1) with seterror')\n" +
            "    IF (@@error != 0)\n" +
            "    BEGIN\n" +
            "        PRINT 'FAILED to create p_match_session_delete_{0}'\n" +
            "    END\n" +
            "END\n" +
            "GO\n" +
            "\n" +
            "ALTER PROCEDURE [dbo].[p_match_session_delete_{0}]\n" +
            "     @bi_session_id                 bigint\n" +
            "AS\n" +
            "-- Do not modify. Build Info - !!Version={1}\n" +
            "BEGIN\n" +
            "    DECLARE\n" +
            "         @i_return_code             int\n" +
            "        ,@error_var                 int\n" +
            "        ,@rowcount_var              int\n" +
            "\n" +
            "    SET nocount on\n" +
            "\n" +
            "    --\n" +
            "    --  Delete the session\n" +
            "    --\n" +
            "\n" +
            "    DELETE dbo.t_match_sessions_{0} WHERE bi_session_id = @bi_session_id\n" +
            "\n" +
            "    SELECT @error_var = @@ERROR, @rowcount_var = @@ROWCOUNT\n" +
            "\n" +
            "    IF @error_var != 0\n" +
            "    BEGIN\n" +
            "        SET @i_return_code = 0x80155115  -- XONLINE_E_MATCH_CRITICAL_DB_ERR\n" +
            "        GOTO exit_label\n" +
            "    END\n" +
            "\n" +
            "    IF @rowcount_var = 0\n" +
            "    BEGIN\n" +
            "        SET @i_return_code = 0x80155100 -- XONLINE_E_MATCH_INVALID_SESSION_ID\n" +
            "        GOTO exit_label\n" +
            "    END\n" +
            "\n" +
            "    RETURN 0\n" +
            "\n" +
            "exit_label:\n" +
            "    IF @error_var != 0\n" +
            "    BEGIN\n" +
            "        DECLARE @message varchar(255)\n" +
            "        SELECT @message = 'Session delete failed: p_match_session_delete_{0} - ' + CAST(CAST(CAST(@error_var AS binary(4)) AS int) AS varchar(64))\n" +
            "        EXEC master.dbo.xp_logevent 51711, @message, error\n" +
            "    END\n" +
            "    RETURN @i_return_code\n" +
            "END\n" +
            "go\n" +
            "GRANT EXECUTE ON p_match_session_delete_{0} TO ClientLib\n" +
            "GO\n" +
            "\n";

        void EmitDeleteProcSQL()
        {
            Emit(c_szSessionDeleteTemplate1, _config.TitleId, GetBuildVer());
        }

        // TitleId, BuildVer
        const string c_szSessionDeadXboxTemplate1 =
            "-----------------------------------------------------------------------------------------------\n" +
            "--\n" +
            "-- Proc: p_match_session_0x{0:X08}_deadxbox\n" +
            "--\n" +
            "-----------------------------------------------------------------------------------------------\n" +
            "\n" +
            "IF NOT EXISTS (SELECT name FROM dbo.sysobjects WHERE  type = 'p' AND name = 'p_match_session_0x{0:X08}_deadxbox')\n" +
            "BEGIN\n" +
            "    EXEC('create procedure dbo.p_match_session_0x{0:X08}_deadxbox as raiserror(\"Empty Stored Procedure!!\", 16, 1) with seterror')\n" +
            "    IF (@@error != 0)\n" +
            "    BEGIN\n" +
            "        PRINT 'FAILED to create p_match_session_0x{0:X08}_deadxbox'\n" +
            "    END\n" +
            "END\n" +
            "GO\n" +
            "\n" +
            "ALTER PROCEDURE [dbo].[p_match_session_0x{0:X08}_deadxbox]\n" +
            "     @b_box_id                 binary(16)\n" +
            "AS\n" +
            "-- Do not modify. Build Info - !!Version={1}\n" +
            "BEGIN\n" +
            "    DECLARE\n" +
            "         @i_return_code             int\n" +
            "        ,@error_var                 int\n" +
            "\n" +
            "    SET nocount on\n" +
            "\n" +
            "    --\n" +
            "    --  Delete all sessions with matching box id\n" +
            "    --\n" +
            "\n" +
            "    DELETE dbo.t_match_sessions_{0} WHERE b_box_id = @b_box_id\n" +
            "\n" +
            "    SELECT @error_var = @@ERROR\n" +
            "\n" +
            "    IF @error_var != 0\n" +
            "    BEGIN\n" +
            "        SET @i_return_code = 0x80155115  -- XONLINE_E_MATCH_CRITICAL_DB_ERR\n" +
            "        GOTO exit_label\n" +
            "    END\n" +
            "\n" +
            "    RETURN 0\n" +
            "\n" +
            "exit_label:\n" +
            "    IF @error_var != 0\n" +
            "    BEGIN\n" +
            "        DECLARE @message varchar(255)\n" +
            "        SELECT @message = 'Session deadxbox failed: p_match_session_0x{0:X08}_deadxbox - ' + CAST(CAST(CAST(@error_var AS binary(4)) AS int) AS varchar(64))\n" +
            "        EXEC master.dbo.xp_logevent 51711, @message, error\n" +
            "    END\n" +
            "    RETURN @i_return_code\n" +
            "END\n" +
            "go\n" +
            "GRANT EXECUTE ON p_match_session_0x{0:X08}_deadxbox TO ClientLib\n" +
            "GO\n" +
            "\n" ;

        void EmitDeadXboxProcSQL()
        {
            Emit(c_szSessionDeadXboxTemplate1, _config.TitleId, GetBuildVer());
        }


        // OutputFile, InputFilename, TitleName, TitleId, TitleId (uint), TitleId (int)
        const string c_szStandardHeader = 
            "-----------------------------------------------------------------------------------------------\n" +
            "--\n" +
            "-- Filename         = {0}\n" +      // Output file
            "-- Generated from   = {1}\n" +      // Input file
            "--\n" +
            "-- Title Name       = {2}\n" +      // Title name
            "-- Title ID (hex)   = 0x{3:X}\n" +  // TitleID
            "-- Title ID (uint)  = {4}\n" +      // TitleID
            "-- Title ID (int)   = {5}\n" +      // TitleID
            "--\n" +
            "-- Title-defined Attributes:\n";

        // Name, AttributeId
        const string c_szAttributeHeader = 
            "--     {0,-24} = 0x{1:X08}\n";      // Attrib name, attrib id

        // Noargs
        const string c_szEndHeader = 
            "--\n" +
            "-----------------------------------------------------------------------------------------------\n" +
            "\n" +
            "SET QUOTED_IDENTIFIER OFF\n" +
            "GO\n" +
            "\n" +
            "SET ANSI_NULLS OFF\n" +
            "GO\n" +
            "\n";

        // Noargs
        const string c_szFooter = 
            "\nSET ANSI_NULLS ON\nGO\n";

        // TitleId
        const string c_szTable1a = 
            "-----------------------------------------------------------------------------------------------\n" +
            "--\n" +
            "-- Table: t_match_sessions_{0}\n" +
            "--\n" +
            "-----------------------------------------------------------------------------------------------\n" +
            "\n" +
            "IF EXISTS (SELECT * FROM dbo.sysobjects WHERE name = 't_match_sessions_{0}' and type = 'u')\n" +
            "BEGIN\n";

        // TitleId
        const string c_szTable1bDropIfExists = 
            "    PRINT 'Dropping table t_match_sessions_{0}'\n" +
            "    DROP TABLE [dbo].[t_match_sessions_{0}]\n" +
            "END\n";

        // TitleId
        const string c_szTable1bSkipIfExists = 
            "    PRINT '**Note: t_match_sessions_{0} table already exists.  Creation has been skipped.'\n" +
            "END\n" +
            "ELSE\n";

        // TitleId
        const string c_szTable1c = 
            "BEGIN\n" +
            "    PRINT 'Creating t_match_sessions_{0} table.'\n" +
            "    CREATE TABLE dbo.t_match_sessions_{0} (\n" +
            "\n" +
            "         bi_session_id           bigint                  NOT NULL\n" +
            "\n" +
            "        ,i_ip_addr               int                     NOT NULL\n" +
            "        ,i_sg_ip                 int                     NOT NULL\n" +
            "        ,b_box_id                binary(16)              NOT NULL\n" +
            "        ,b_host_address          binary(36)              NOT NULL\n" +
            "        ,si_zoneID               smallint                NOT NULL\n" +
            "        ,si_providerID           smallint                NOT NULL\n" +
            "        ,b_key_exchange_key      binary(16)              NOT NULL\n" +
            "        ,i_public_available      int                     NOT NULL\n" +
            "        ,i_private_available     int                     NOT NULL\n" +
            "        ,i_public_current        int                     NOT NULL\n" +
            "        ,i_private_current       int                     NOT NULL\n" +
            "        ,dt_session_expiration   datetime                NOT NULL\n" +
            "        ,ti_is_available         tinyint                 NOT NULL\n" +
            "        ,i_hash                  int                     NOT NULL\n" +
            "        ,ti_nat_type             tinyint                 NOT NULL\n" +
            "\n";

        // AttributeId
        const string c_szTableAttribute =
            "        ,att_{0,-10}          ";

        // Noargs
        const string c_szTableAttributeEndInt = 
            "bigint\n";

        // Maxlength
        const string c_szTableAttributeEndStr = 
            "nvarchar({0})\n";

        // Maxlength
        const string c_szTableAttributeEndBlob = 
            "varbinary({0})\n";

        // TitleId
        const string c_szTable2 = 
            "\n" +
            "        CONSTRAINT t_match_sessions_{0}_PK  PRIMARY KEY NONCLUSTERED\n" +
            "                    (bi_session_id),\n" +
            "    )\n" +
            "\n" +
            "    CREATE CLUSTERED INDEX ndx_match_sessions_{0} on t_match_sessions_{0}(\n" +
            "         ti_is_available, i_hash\n" +
            "    )\n" +
            "    CREATE NONCLUSTERED INDEX ndx_match_sessions_{0}_boxid_NC on t_match_sessions_{0}(\n" +
            "         b_box_id\n" +
            "    )\n";

        // TitleId, AttributeId (linked)
        const string c_szTableAdditionalIndex = 
            "    CREATE NONCLUSTERED INDEX ndx_match_sessions_{0}_att_{1}_NC on t_match_sessions_{0}(\n" +
            "         att_{1}\n" +
            "    )\n";

        // TitleId
        const string c_szTable3 = 
            "\n" +
            "    -- set permissions\n" +
            "    GRANT SELECT, INSERT, UPDATE, DELETE ON dbo.t_match_sessions_{0} TO ClientLib\n" +
            "END\n" +
            "GO\n" +
            "\n";

        // TitleId, SessionExpire, DbList
        const string c_szTitleSettings = 
            "EXEC p_match_title_insert {0}, {1}, '{2}'\n" + 
            "GO\n" +
            "\n";

        public void EmitTitleSQL(MatchGameConfig config, Settings settings)
        {
            // Store the config object
            _config = config;
            _settings = settings;


            // If we are asked to make the separate p_match_title_insert call, then do it.  This has 
            // to be in a separate SQL file because we designate one SQL server as holding all of the
            // title info regardless of what SQL server each title is actually assigned to.
            if( String.Empty != _settings.ServerList )
            {
                string dblistOutputFilename = String.Format(c_szDBListOutFileTemplate, _config.TitleId);

                Log( "Creating title info output file: " + dblistOutputFilename );

                StreamWriter writer = File.CreateText(dblistOutputFilename);
                writer.Write(c_szTitleSettings, _config.TitleId, _config.SessionExpiration, _settings.ServerList);
                writer.Close(); 
            }

            _outputFilename = settings.OutputPath + String.Format(c_szOutFileTemplate, _config.TitleId);

            Log( "Creating output file: " + _outputFilename );
            _outputFile = File.CreateText(_outputFilename);

            //
            // Add a standard header to the generated SQL that includes any
            // necessary prologue before the stored proc definitions
            //
            Emit(c_szStandardHeader, 
                    _outputFilename, 
                    _settings.InputFilename,
                    _config.TitleName,
                    _config.TitleId,
                    (uint)_config.TitleId,
                    (int)_config.TitleId
                );

            foreach(MatchSchemaAttribute attr in _config.MatchSchema)
            {
                Emit(c_szAttributeHeader, attr.Name, attr.Id);
            }

            Emit(c_szEndHeader);

            //
            // Generate the table for this title
            //
            Emit(c_szTable1a, _config.TitleId);

            if(_settings.DropTable)
            {
                Emit(c_szTable1bDropIfExists, _config.TitleId);
            }
            else
            {
                Emit(c_szTable1bSkipIfExists, _config.TitleId);
            }

            Emit(c_szTable1c, _config.TitleId);

            // Print each attribute
            foreach(MatchSchemaAttribute attr in _config.MatchSchema)
            {
                Emit(c_szTableAttribute, attr.Id);

                if(MatchDefs.IsAttributeDatatypeInt(attr.Id))
                {
                    Emit(c_szTableAttributeEndInt);
                }
                else if(MatchDefs.IsAttributeDatatypeString(attr.Id))
                {
                    Emit(c_szTableAttributeEndStr, attr.MaxLength);
                }
                else
                {
                    if(!MatchDefs.IsAttributeDatatypeBlob(attr.Id))
                    {
                        throw new InvalidConfigException(
                                _config,
                                "",
                                "Invalid attribute id, type should have been blob: 0x" + attr.Id.ToString("x"));
                    }

                    Emit(c_szTableAttributeEndBlob, attr.MaxLength);
                }
            }

            Emit(c_szTable2, _config.TitleId);

            // Output any additional indexes for FindFromId queries
            foreach(MatchQuery query in _config.MatchQueries.Values)
            {
                if( MatchDefs.XMATCH_QUERY_TYPE_FINDFROMID == query.TypeId)
                {
                    if( 1 < query.Filters.Count )
                    {
                        throw new InvalidConfigException(
                                _config,
                                "query: 0x" + query.Id.ToString("x"),
                                "FindFromId queries are only allowed to have one filter");
                    }

                    // The idea here is that if the title is using an attribute to look for sessions explicitly,
                    // we want to index on it.  The query used by XOnlineMatchFindFromID is one example, but
                    // we already have an index on bi_session_id by default since it is a primary key on the table
                    // so we don't need to add one for that.  We need to look for any title specific attribute
                    // being used in this way.  That means we need to rule out built-ins, parameters, and constants.

                    uint leftAttrId = (query.Filters[0] as MatchQueryFilter).Left;

                    // Check the Left attribute
                    if(     !MatchDefs.IsAttributeTypeBuiltin(leftAttrId)  &&
                            !MatchDefs.IsAttributeTypeParam(leftAttrId) &&
                            !MatchDefs.IsAttributeTypeConst(leftAttrId))
                    {
                        Emit(c_szTableAdditionalIndex, _config.TitleId, leftAttrId);
                    }
                    else 
                    {
                        uint rightAttrId = (query.Filters[0] as MatchQueryFilter).Right;
                        // Check the right attribute
                        if(     !MatchDefs.IsAttributeTypeBuiltin(rightAttrId ) &&
                                !MatchDefs.IsAttributeTypeParam(rightAttrId) &&
                                !MatchDefs.IsAttributeTypeConst(rightAttrId) )
                        {
                            Emit(c_szTableAdditionalIndex, _config.TitleId, rightAttrId);
                        }
                    }
                }
            }

            Emit(c_szTable3, _config.TitleId);

            //
            // Generate the title-specific procedures
            //
            EmitInsertProcSQL();
            EmitUpdateProcSQL();
            EmitDeleteProcSQL();
            EmitDeadXboxProcSQL();

            //
            // Ask each query object to export itself as SQL
            //
            foreach(MatchQuery query in _config.MatchQueries.Values)
            {
                Log( "    Generating SQL for query 0x" + query.Id.ToString("x") + ", type: " + query.Type);

                if(MatchDefs.XMATCH_QUERY_TYPE_NORMAL != query.TypeId)
                {
                    EmitQueryObjSQLNoPub(query);
                }
                else
                {
                    EmitQueryObjSQL(query);
                }
            }

            //
            // Generate the special FindFromID query
            // This query takes one parameter which is the session ID to be found
            //
            MatchQuery findfromid = new MatchQuery();
            findfromid.FriendlyName                   = "FindFromID";
            findfromid.Id                             = MatchDefs.X_SSINDEX_GET_SESSION;
            findfromid.MaxResults                     = 1;
            findfromid.Parameters                     = new ArrayList(1);
            findfromid.Filters                        = new ArrayList(1);
            findfromid.Type                           = "FindFromId";
            findfromid.TypeId                         = MatchDefs.XMATCH_QUERY_TYPE_FINDFROMID;
            
            MatchQueryParam param = new MatchQueryParam();
            findfromid.Parameters.Add(param);

            param.Name           = "session_id";
            param.MaxLength      = 0xffffffff;
            param.Id             = MatchDefs.X_ATTRIBUTE_TYPE_PARAM | 0x00000001;
            param.NullOk         = false;

            MatchQueryFilter filter = new MatchQueryFilter();
            findfromid.Filters.Add(filter);

            filter.Left              = MatchDefs.X_ATTRIBUTE_TYPE_PARAM | 0x00000001;
            filter.OpId              = MatchDefs.XMATCH_FILTEROP_EQUALS;    
            filter.Right             = MatchDefs.X_ATTRIBUTE_XBOX1_SESSION_ID;

            Log( "    Generating SQL for query 0x" + findfromid.Id.ToString("x") + ", type: " + findfromid.Type);

            EmitQueryObjSQLNoPub(findfromid);

            Emit(c_szFooter);

            // Release the output file
            _outputFile.Close();
            _outputFile = null;

            // release the config object
            _config = null;
        }
        
        // TitleId, QueryId, QueryName
        const string c_szQueryTemplate1 = 
            "-----------------------------------------------------------------------------------------------\n" +
            "--\n" +
            "-- Query: p_match_search_{0}_{1}    [ {2} ]\n" +
            "--\n" +
            "-----------------------------------------------------------------------------------------------\n" +
            "\n" +
            "IF NOT EXISTS (SELECT name FROM dbo.sysobjects WHERE  type = 'p' AND name = 'p_match_search_{0}_{1}')\n" +
            "BEGIN \n" +
            "    EXEC('create procedure dbo.p_match_search_{0}_{1} as raiserror(\"Empty Stored Procedure!!\", 16, 1) with seterror')\n" +
            "    IF (@@error != 0)\n" +
            "    BEGIN\n" +
            "        PRINT 'FAILED to create stored procedure.'\n" +
            "    END\n" +
            "END\n" +
            "GO\n" +
            "\n" +
            "ALTER PROCEDURE [dbo].[p_match_search_{0}_{1}]\n" +
            "     @si_required_slots              smallint\n" +
            "    ,@i_client_ip                    int\n" +
            "    ,@ti_nat_type                    tinyint\n" +
            "    ,@ti_server_count                tinyint\n";
        // PARAM_DECLS follow

        // TitleId, BuildVer
        const string c_szQueryTemplate2 = 
            "AS\n" +
            "-- Do not modify. Build Info - !!Version={1}\n" +
            "BEGIN\n" +
            "    DECLARE @si_client_zoneID       smallint\n" +
            "    DECLARE @si_client_providerID   smallint\n" +
            "    DECLARE @i_ip_end               int\n" +
            "\n" +
            "    SET @i_ip_end = null\n" +
            "\n" +
            "    SELECT TOP 1 @si_client_zoneID = si_zoneID, @si_client_providerID = si_providerID, @i_ip_end = i_ip_end\n" +
            "    FROM v_match_zone_map m\n" +
            "    WHERE m.i_ip_start <= @i_client_ip\n" +
            "\n" +
            "    IF @i_ip_end is null OR @i_client_ip > @i_ip_end\n" +
            "    BEGIN\n" +
            "        SET @si_client_zoneID = -1     -- no zone match\n" +
            "        SET @si_client_providerID = -1 -- no zone match\n" +
            "    END\n" +
            "\n" +
            "    -- Calculate bucket range\n" +
            "\n" +
            "    DECLARE @bucketstart1 int,\n" +
            "            @bucketend1 int,\n" +
            "            @bucketstart2 int,\n" +
            "            @bucketend2 int,\n" +
            "            @bucketcount int,\n" +
            "            @rowcount int\n" +
            "\n" +
            "    SELECT @rowcount = COUNT(*)\n"  +
            "    FROM t_match_sessions_{0} s WITH (NOLOCK)\n" +
            "    WHERE\n" +
            "          ( s.ti_is_available = 1 ) AND\n" +
            "          ( s.i_public_available >= @si_required_slots ) AND\n" +
            "          ( s.i_ip_addr = @i_client_ip OR s.ti_nat_type + @ti_nat_type < 5 ) AND\n" + // Match if inaOnline matches (behind same NAT) or NATs are compatible
            "          i_hash = CAST(RAND() * 1000 AS int)";

        // TitleId, BuildVer
        const string c_szQueryTemplate2NoNat = 
            "AS\n" +
            "-- Do not modify. Build Info - !!Version={1}\n" +
            "BEGIN\n" +
            "    DECLARE @si_client_zoneID       smallint\n" +
            "    DECLARE @si_client_providerID   smallint\n" +
            "    DECLARE @i_ip_end               int\n" +
            "\n" +
            "    SET @i_ip_end = null\n" +
            "\n" +
            "    SELECT TOP 1 @si_client_zoneID = si_zoneID, @si_client_providerID = si_providerID, @i_ip_end = i_ip_end\n" +
            "    FROM v_match_zone_map m\n" +
            "    WHERE m.i_ip_start <= @i_client_ip\n" +
            "\n" +
            "    IF @i_ip_end is null OR @i_client_ip > @i_ip_end\n" +
            "    BEGIN\n" +
            "        SET @si_client_zoneID = -1     -- no zone match\n" +
            "        SET @si_client_providerID = -1 -- no zone match\n" +
            "    END\n" +
            "\n" +
            "    -- Calculate bucket range\n" +
            "\n" +
            "    DECLARE @bucketstart1 int,\n" +
            "            @bucketend1 int,\n" +
            "            @bucketstart2 int,\n" +
            "            @bucketend2 int,\n" +
            "            @bucketcount int,\n" +
            "            @rowcount int\n" +
            "\n" +
            "    SELECT @rowcount = COUNT(*)\n" +
            "    FROM t_match_sessions_{0} s WITH (NOLOCK)\n" +
            "    WHERE\n" +
            "          ( s.ti_is_available = 1 ) AND\n" +
            "          ( s.i_public_available >= @si_required_slots ) AND\n" +
            "          i_hash = CAST(RAND() * 1000 AS int)";

        // MaxResults
        const string c_szQueryTemplate4 = 
            "\n" +
            "    IF @rowcount > 0\n" +
            "    BEGIN\n" +
            "        SET @bucketcount = (1000 / @rowcount) + 1\n" +
            "    END\n" +
            "    ELSE\n" +
            "    BEGIN\n" +
            "        SET @bucketcount = 1000\n" +
            "    END\n" +
            "\n" +
            "    SET @bucketstart1 = RAND() * 1000\n" +
            "    SET @bucketend1 = @bucketstart1 + @bucketcount\n" +
            "\n" +
            "    IF @bucketend1 >= 1000\n" +
            "    BEGIN\n" +
            "        SET @bucketstart2 = 0\n" +
            "        SET @bucketend2 = @bucketend1 - 999\n" +
            "        SET @bucketend1 = 999\n" +
            "    END\n" +
            "    ELSE\n" +
            "    BEGIN\n" +
            "        SET @bucketstart2 = @bucketstart1\n" +
            "        SET @bucketend2 = @bucketend1\n" +
            "    END\n" +
            "\n" +
            "    SELECT TOP {0} s.*\n" +
            "    FROM (\n" +
            "        SELECT TOP 1000\n" +
            "            s.bi_session_id,\n" +
            "            s.b_host_address,\n" +
            "            s.b_key_exchange_key,\n" +
            "            s.i_public_available,\n" +
            "            s.i_private_available,\n" +
            "            s.i_public_current,\n" +
            "            s.i_private_current,\n" +
            "            'i_dist' = CASE\n" +
            "                           WHEN d.i_distance IS NULL THEN 2147483647\n" +
            "                           WHEN s.si_zoneID = @si_client_zoneID AND s.si_providerID = @si_client_providerID THEN d.i_distance - 256\n" +
            "                           ELSE d.i_distance\n" +
            "                       END";


        // TitleId
        const string c_szQueryTemplate5 = 
            "        FROM t_match_sessions_{0} s WITH (NOLOCK)\n" +
            "        LEFT OUTER JOIN v_match_zone_dists d ON d.si_src_zoneID = @si_client_zoneID AND\n" +
            "                                                d.si_dst_zoneID = s.si_zoneID\n" +
            "        WHERE\n" +
            "              ( s.ti_is_available = 1 ) AND\n" +
            "              ( s.i_public_available >= @si_required_slots ) AND\n" +
            "              ( s.i_ip_addr = @i_client_ip OR s.ti_nat_type + @ti_nat_type < 5 ) AND\n" + // Match if inaOnline matches (behind same NAT) or NATs are compatible
            "              ( ( s.i_hash >= @bucketstart1 AND s.i_hash <= @bucketend1 ) OR\n" +
            "                ( s.i_hash >= @bucketstart2 AND s.i_hash <= @bucketend2 ) )";

        // TitleId
        const string c_szQueryTemplate5NoNat = 
            "        FROM t_match_sessions_{0} s WITH (NOLOCK)\n" +
            "        LEFT OUTER JOIN v_match_zone_dists d ON d.si_src_zoneID = @si_client_zoneID AND\n" +
            "                                                d.si_dst_zoneID = s.si_zoneID\n" +
            "        WHERE\n" +
            "              ( s.ti_is_available = 1 ) AND\n" +
            "              ( s.i_public_available >= @si_required_slots ) AND\n" +
            "              ( ( s.i_hash >= @bucketstart1 AND s.i_hash <= @bucketend1 ) OR\n" +
            "                ( s.i_hash >= @bucketstart2 AND s.i_hash <= @bucketend2 ) )";

        // Noargs
        const string c_szQueryTemplate7 = 
            "    ) s\n";

        // TitleId, QueryId
        const string c_szQueryTemplate8 = 
            "\n" +
            "END\n" +
            "GO\n" +
            "\n" +
            "GRANT EXECUTE ON [dbo].[p_match_search_{0}_{1}] TO ClientLib\n" +
            "GO\n";

        void EmitQueryObjSQL(MatchQuery query)
        {
            //
            // Print the standard header portion
            //
            Emit(c_szQueryTemplate1, _config.TitleId, query.Id, query.FriendlyName);

            //
            // Print any parameter declarations
            //
            EmitQueryParameters(query);

            if(_settings.NoNat)
            {
                Emit(c_szQueryTemplate2NoNat, _config.TitleId, GetBuildVer());
            }
            else
            {
                Emit(c_szQueryTemplate2, _config.TitleId, GetBuildVer());
            }

            //
            // Print any WHERE clauses (part 1)
            //
            EmitQueryFilters(query, true, "          " );

            Emit(c_szQueryTemplate4, query.MaxResults);

            //
            // Print any return values
            //
            EmitQueryReturns(query, "            " );

            if(_settings.NoNat)
            {
                Emit(c_szQueryTemplate5NoNat, _config.TitleId);
            }
            else
            {
                Emit(c_szQueryTemplate5, _config.TitleId);
            }

            //
            // Print any WHERE clauses (part 2)
            //
            EmitQueryFilters(query, true, "              " );

            Emit(c_szQueryTemplate7);

            //
            // Print any ORDER_BY clauses
            //
            EmitQuerySortOps(query);

            //
            // Print the footer
            //
            Emit(c_szQueryTemplate8, _config.TitleId, query.Id);
        }

        // TitleId, QueryId, QueryName
        const string c_szQueryNoPubTemplate1 = 
            "-----------------------------------------------------------------------------------------------\n" +
            "--\n" +
            "-- Query: p_match_search_{0}_{1}    [ {2} ]\n" +
            "--\n" +
            "-----------------------------------------------------------------------------------------------\n" +
            "\n" +
            "IF NOT EXISTS (SELECT name FROM dbo.sysobjects WHERE  type = 'p' AND name = 'p_match_search_{0}_{1}')\n" +
            "BEGIN \n" +
            "    EXEC('create procedure dbo.p_match_search_{0}_{1} as raiserror(\"Empty Stored Procedure!!\", 16, 1) with seterror')\n" +
            "    IF (@@error != 0)\n" +
            "    BEGIN\n" +
            "        PRINT 'FAILED to create stored procedure.'\n" +
            "    END\n" +
            "END\n" +
            "GO\n" +
            "\n" +
            "ALTER PROCEDURE [dbo].[p_match_search_{0}_{1}]\n" +
            "     @si_required_slots              smallint\n" +
            "    ,@i_client_ip                    int\n" +
            "    ,@ti_nat_type                    tinyint\n" +
            "    ,@ti_server_count                tinyint\n";
        // PARAM_DECLS follow

        // MaxResults, BuildVer
        const string c_szQueryFindFromIdTemplate2 = 
            "AS\n" +
            "-- Do not modify. Build Info - !!Version={1}\n" +
            "BEGIN\n" +
            "\n" +
            "    SELECT TOP {0}\n" +
            "        s.bi_session_id,\n" +
            "        s.b_host_address,\n" +
            "        s.b_key_exchange_key,\n" +
            "        s.i_public_available,\n" +
            "        s.i_private_available,\n" +
            "        s.i_public_current,\n" +
            "        s.i_private_current,\n" +
            "        'i_dist' = 2147483647";
        // RETURNS FOLLOW

        // MaxResults, BuildVer
        const string c_szQueryAggregateTemplate2 = 
            "AS\n" +
            "-- Do not modify. Build Info - !!Version={1}\n" +
            "BEGIN\n" +
            "\n" +
            "    SELECT TOP {0}\n" +
            "        'bi_session_id' = CAST( 0 AS bigint ),\n" +
            "        'b_host_address' = CAST( 0 AS binary(36) ),\n" +
            "        'b_key_exchange_key' = CAST( 0 AS binary(16) ),\n" +
            "        'i_public_available' = 0,\n" +
            "        'i_private_available' = 0,\n" +
            "        'i_public_current' = 0,\n" +
            "        'i_private_current' = 0,\n" +
            "        'i_dist' = 2147483647";
        // RETURNS FOLLOW

        // TitleId
        const string c_szQueryNoPubTemplate3 = 
            "    FROM dbo.t_match_sessions_{0} s WITH (NOLOCK)\n";
        // FILTERS FOLLOW
        // SORTS FOLLOW

        // Noargs
        const string c_szQueryFindFromIDTemplateReturnValue = 
            "\n" +
            "    IF 0 = @@ROWCOUNT\n" +
            "    BEGIN\n" +
            "        RETURN 1 -- S_FALSE, tells front door to try other servers\n" +
            "    END\n" +
            "    ELSE\n" +
            "    BEGIN\n" +
            "        RETURN 0 -- Found it, no need to keep looking\n" +
            "    END\n";

        // TitleId,
        const string c_szQueryNoPubTemplate4 = 
            "\n" +
            "END\n" +
            "GO\n" +
            "\n" +
            "GRANT EXECUTE ON [dbo].[p_match_search_{0}_{1}] TO ClientLib\n" +
            "GO\n";

        void EmitQueryObjSQLNoPub(MatchQuery query)
        {
            //
            // Print the standard header portion
            //
            Emit(c_szQueryNoPubTemplate1, _config.TitleId, query.Id, query.FriendlyName);

            //
            // Print any parameter declarations
            //
            EmitQueryParameters(query);

            if(MatchDefs.XMATCH_QUERY_TYPE_FINDFROMID == query.TypeId)
            {
                Emit(c_szQueryFindFromIdTemplate2, query.MaxResults, GetBuildVer());
            }
            else if( MatchDefs.XMATCH_QUERY_TYPE_AGGREGATE == query.TypeId)
            {
                Emit(c_szQueryAggregateTemplate2, query.MaxResults, GetBuildVer());
            }
            else
            {
                throw new InvalidConfigException(
                        _config,
                        "query: 0x" + query.Id.ToString("x"),
                        "Unexpected query type in QueryObjOutputSQLNoPub for title=0x" + _config.TitleId);
            }

            //
            // Print any return values
            //
            EmitQueryReturns(query, "        " );

            Emit(c_szQueryNoPubTemplate3, _config.TitleId);

            //
            // Print any WHERE clauses
            //
            EmitQueryFilters(query, false, "        " );

            // 
            // Print any GROUP BY attribute
            //
            if( 0 != query.GroupBy)
            {
                string attr = QueryObjSQLForAttr( query, query.GroupBy);

                Emit("    GROUP BY {0}\n", attr);
            }

            //
            // Print any ORDER_BY clauses
            //
            EmitQuerySortOps(query);

            //
            // For FindFromID queries, we need to return S_FALSE if we didn't find the session so that the front
            // door realizes, a) this was a FindFromID query, and b) we need to look on other servers for the session.
            if(MatchDefs.XMATCH_QUERY_TYPE_FINDFROMID == query.TypeId)
            {
                Emit(c_szQueryFindFromIDTemplateReturnValue);
            }

            //
            // Print the footer
            //
            Emit(c_szQueryNoPubTemplate4, _config.TitleId, query.Id);
        }

        string GetSQLReturnType( uint dwAttrID, uint iMaxLen)
        {
            uint dwKind = dwAttrID & MatchDefs.X_ATTRIBUTE_DATATYPE_MASK;
            string type;

            switch( dwKind )
            {
                case MatchDefs.X_ATTRIBUTE_DATATYPE_INTEGER:
                    type = "bigint";
                    break;

                case MatchDefs.X_ATTRIBUTE_DATATYPE_STRING:

                    if( 0 == iMaxLen )
                    {
                        iMaxLen = MatchDefs.X_MAX_STRING_ATTRIBUTE_LEN;
                    }

                    type = String.Format("nvarchar({0})" , iMaxLen);
                    break;

                case MatchDefs.X_ATTRIBUTE_DATATYPE_BLOB:

                    if( 0 == iMaxLen )
                    {
                        iMaxLen = MatchDefs.X_MAX_BLOB_ATTRIBUTE_LEN;
                    }

                    type = String.Format("varbinary({0})" , iMaxLen);
                    break;

                default:
                    throw new InvalidConfigException(
                            _config,
                            "GetSQLReturnType",
                            "Invalid attribute type for SQL type conversion: " + dwKind);
            }

            return type;
        }

        string GetSQLVariablePrefix(uint dwAttrID)
        {
            uint dwKind = dwAttrID & MatchDefs.X_ATTRIBUTE_DATATYPE_MASK;
            string prefix;

            switch( dwKind )
            {
                case MatchDefs.X_ATTRIBUTE_DATATYPE_INTEGER:
                    prefix = "@bi_";
                    break;

                case MatchDefs.X_ATTRIBUTE_DATATYPE_STRING:
                    prefix = "@nvc_";
                    break;

                case MatchDefs.X_ATTRIBUTE_DATATYPE_BLOB:
                    prefix = "@vb_";
                    break;

                default:
                    throw new InvalidConfigException(
                            _config,
                            "GetSQLVariablePrefix",
                            "Invalid attribute type for SQL type conversion: " + dwKind);
            }

            return prefix;
        }

        string QueryObjSQLForAttr(MatchQuery query, uint dwAttrID)
        {
            string attrSql;

            // Search built-ins global fragments
            foreach(IdFragment attr in _globalFragments)
            {
                if(dwAttrID == attr.Id)
                {
                    attrSql = attr.Sql;
                    goto lbFound;
                }
            }

            // Search the query parameters
            uint iParam = 1;
            foreach(MatchQueryParam param in query.Parameters)
            {
                if( dwAttrID == param.Id )
                {
                    attrSql = GetSQLVariablePrefix( param.Id);
                    attrSql += "param_" + iParam.ToString();
                    goto lbFound;
                }
                iParam++;
            }

            // Search the schema attributes
            foreach(MatchSchemaAttribute attr in _config.MatchSchema)
            {
                if(dwAttrID == attr.Id)
                {
                    attrSql = "att_" + attr.Id.ToString();
                    goto lbFound;
                }
            }

            // Search the constants
            foreach(MatchConstant konst in _config.MatchConstants.Values)
            {
                if(dwAttrID == konst.Id)
                {
                    attrSql = konst.Value.ToString();
                    goto lbFound;
                }
            }

            // No one claimed this AttrID
            throw new InvalidConfigException(
                    _config,
                    "query: 0x" + query.Id.ToString("x"),
                    "Coult not resolve attribute: 0x" + dwAttrID);

lbFound:
            return attrSql;
        }

        string GetOpIDSQLString(uint opid)
        {
            foreach(IdFragment opfrag in _opFragments)
            {
                if(opfrag.Id == opid)
                {
                    return opfrag.Sql;
                }
            }

            throw new InvalidConfigException(
                    _config, 
                    "GetOPIDSQLString", 
                    "Invalid operation ID, no sql fragment stored for: " + opid);
        }

    } // end MatchSqlCodeGenXbox1
} // end xonline.common.match
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\msi\installutil\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_installutil_none_12.4.56.0_none_da640e642d7bada7
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_installutil_no-public-key_12.4.56.0_x-ww_5143eaf3
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=installutil
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_installutil_no-public-key_12.4.56.0_x-ww_5143eaf3
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_installutil_no-public-key_12.4.56.0_x-ww_5143eaf3.manifest
XP_MANIFEST_PATH=manifests\x86_installutil_no-public-key_12.4.56.0_x-ww_5143eaf3.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_installutil_no-public-key_12.4.56.0_x-ww_5143eaf3.cat
XP_CATALOG_PATH=manifests\x86_installutil_no-public-key_12.4.56.0_x-ww_5143eaf3.cat
XP_PAYLOAD_PATH=x86_installutil_no-public-key_12.4.56.0_x-ww_5143eaf3
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=installutil,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\msi\installutil\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_installutil_none_12.4.56.0_none_da640e642d7bada7
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_installutil_no-public-key_12.4.56.0_x-ww_5143eaf3
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=installutil
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_installutil_no-public-key_12.4.56.0_x-ww_5143eaf3
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_installutil_no-public-key_12.4.56.0_x-ww_5143eaf3.manifest
XP_MANIFEST_PATH=manifests\x86_installutil_no-public-key_12.4.56.0_x-ww_5143eaf3.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_installutil_no-public-key_12.4.56.0_x-ww_5143eaf3.cat
XP_CATALOG_PATH=manifests\x86_installutil_no-public-key_12.4.56.0_x-ww_5143eaf3.cat
XP_PAYLOAD_PATH=x86_installutil_no-public-key_12.4.56.0_x-ww_5143eaf3
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=installutil,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\msi\msierrors\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\Memcache\XBanc\XBancMemCache.cs ===
using System;
using System.Text;
using xonline.common.service;

namespace xonline.server.XConnSrv
{
    public class XBancMemCacheImpl : IMemCache
    {
        private static XBanc m_xbanc;
        
        static XBancMemCacheImpl()
        {
            m_xbanc = new XBanc();
            XBanc.Init();
        }

        public XBancMemCacheImpl()
        {
        }

        public string GetImplementationName()
        {
            return "XBanc";
        }
        
        public byte[] RequestData(string sKey, Object keyState)
        {
            uint version;
            return RequestData(sKey, keyState, out version);
        }
        
        public byte[] RequestData(string sKey, Object keyState, out uint version)
        {
            byte[] rgbValue;
            RequestData(sKey, keyState, out version, out rgbValue);
            return rgbValue;
        }

        public uint RequestData(string sKey, Object keyState, out uint version, out byte[] rgbValue)
        {
            version = unchecked((uint)(-1));
            byte[] rgbKey = keyState as byte[];
            if ((rgbKey == null) && (sKey != null))
            {
                rgbKey = Encoding.ASCII.GetBytes(sKey);
            }
            return m_xbanc.Query(rgbKey, out rgbValue);
        }
        
        public byte[][] BulkRequestData(string[] rgKeys, Object[] rgKeyStates)
        {
            uint[] rgVersions = new uint[rgKeys.Length];
            return BulkRequestData(rgKeys, rgKeyStates, out rgVersions);
        }

        public byte[][] BulkRequestData(string[] rgKeys, Object[] rgKeyStates, out uint[] rgVersions)
        {
            byte[][] rgValues;
            BulkRequestData(rgKeys, rgKeyStates, out rgVersions, out rgValues);
            return rgValues;
        }

        public uint[] BulkRequestData(string[] rgKeys, Object[] rgKeyStates, out uint[] rgVersions, out byte[][] rgValues)
        {
            rgVersions = new uint[rgKeys.Length];
            for (int iKey = 0; iKey < rgKeys.Length; iKey++)
            {
                rgVersions[iKey] = unchecked((uint)(-1));
            }

            byte[][] rgbKeys = new byte[rgKeys.Length][];
            uint[] rgValidSeconds;
            for (int iKey = 0; iKey < rgbKeys.Length; iKey++)
            {
                rgbKeys[iKey] = rgKeyStates[iKey] as byte[];
                if ((rgbKeys[iKey] == null) && (rgKeys[iKey] != null))
                {
                    rgbKeys[iKey] = Encoding.ASCII.GetBytes(rgKeys[iKey]);
                }
            }
            return m_xbanc.Query(rgbKeys, out rgValues, out rgValidSeconds);
        }
        
        public void PublishData(string sKey, byte[] rgbValue, Object keyState)
        {
            uint version = 0;
            PublishData(sKey, rgbValue, keyState, ref version, 0);
        }

        public uint PublishData(string sKey, byte[] rgbValue, Object keyState, ref uint version)
        {
            PublishData(sKey, rgbValue, keyState);
            return HResult.S_OK;
        }

        public uint PublishData(string sKey, byte[] rgbValue, Object keyState, ref uint version, uint expirySeconds)
        {
            byte[] rgbKey = keyState as byte[];
            if ((rgbKey == null) && (sKey != null))
            {
                rgbKey = Encoding.ASCII.GetBytes(sKey);
            }
            m_xbanc.SetData(rgbKey, rgbValue, expirySeconds, 0);
            return HResult.S_OK;
        }
        
        public void BulkPublishData(string[] rgKeys, byte[][] rgbValues, Object[] rgKeyStates)
        {
            byte[][] rgbKeys = new byte[rgKeys.Length][];
            for (int iKey = 0; iKey < rgbKeys.Length; iKey++)
            {
                rgbKeys[iKey] = rgKeyStates[iKey] as byte[];
                if ((rgbKeys[iKey] == null) && (rgKeys[iKey] != null))
                {
                    rgbKeys[iKey] = Encoding.ASCII.GetBytes(rgKeys[iKey]);
                }
            }

            m_xbanc.SetData(rgbKeys, rgbValues, new uint[rgKeys.Length], new uint[rgKeys.Length]);
        }

        public uint[] BulkPublishData(string[] rgKeys, byte[][] rgbValues, Object[] rgKeyStates, uint[] rgVersions)
        {
            BulkPublishData(rgKeys, rgbValues, rgKeyStates);
            return new uint[rgKeys.Length];
        }

        public void RemoveData(string sKey)
        {
            byte[] key = null;
            if (sKey != null)
            {
                key = Encoding.ASCII.GetBytes(sKey);
            }
            m_xbanc.Remove(key);
        }

        public void BulkRemoveData(string[] sKeys)
        {
            byte[][] keys = new byte[sKeys.Length][];
            for (int i = 0; i < sKeys.Length; i++)
            {
                if (sKeys[i] != null)
                {
                    keys[i] = Encoding.ASCII.GetBytes(sKeys[i]);
                }
            }
            m_xbanc.Remove(keys);
        }

        public void RegisterNotificationHandler(DataChangeNotification notificationCallback)
        {
            // no notifications
        }
        
        public void RegisterNotificationFailureHandler(DataChangeFailureNotification failureCallback)
        {
            // no notifications
        }
        
        public void UnregisterHandlers()
        {
            // no notifications
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\Memcache\Velocity\VelocityMemCache.cs ===
using System;
using System.Threading;
using xonline.common.service;
using xonline.common.config;
using Microsoft.Data.Caching;
using System.Collections;
using System.Collections.Specialized;
using System.Collections.Generic;
using System.Collections.ObjectModel;

namespace xonline.server.XConnSrv
{
    public class MemCacheImpl : IMemCache
    {
        protected static DataCacheFactory s_CacheFactory = null;
        public static DataCache s_Cache = null;
        protected static DataCacheNotificationDescriptor s_ndNotification = null;
        protected static DataCacheNotificationDescriptor s_ndFailure = null;
        private DataChangeNotification m_notificationCallback;
        private DataChangeFailureNotification m_failureCallback;
        
        static MemCacheImpl()
        {
            string[] serverList = Config.GetServerListByInterface(Interface.XNotiCache);
            
            DataCacheServerEndpoint[] rgEndpoints = new DataCacheServerEndpoint[serverList.Length];
            for (int iServer = 0; iServer < serverList.Length; iServer++)
            {
                IInterfaceInfo iface = Config.GetInterface(serverList[iServer], Interface.XNotiCache);
                rgEndpoints[iServer] = new DataCacheServerEndpoint(serverList[iServer], iface.Port, "DistributedCacheService");
            }
            
            s_CacheFactory = new DataCacheFactory(rgEndpoints, true, false, DataCacheLocalCacheSyncPolicy.NotificationBased, 1, 1);
            s_Cache = s_CacheFactory.GetCache(Interface.XNotiCache);
        }
        
        public MemCacheImpl()
        {
            s_ndNotification = s_Cache.AddBulkNotificationCallback(OnVelocityNotificationBatch);
            s_ndFailure = s_Cache.AddFailureNotificationCallback(OnVelocityNotificationFailure);
        }

        public string GetImplementationName()
        {
            return "Velocity";
        }
        
        public byte[] RequestData(string sKey, Object keyState)
        {
            return s_Cache.Get(sKey) as byte[];
        }
        
        public byte[][] BulkRequestData(string[] rgKeys, Object[] rgKeyStates)
        {
            BulkGetWaitObject wo = new BulkGetWaitObject(rgKeys.Length);
            Hashtable htRegions = new Hashtable();
            for (int iKey = 0; iKey < rgKeys.Length; iKey++)
            {
                string sRegion = rgKeyStates[iKey] as string;
                if (sRegion == null)
                {
                    // TODO: need a build of velocity that supports GetDefaultRegionName()
                    // sRegion = s_Cache.GetDefaultRegionName(rgKeys[iKey]);
                }

                VelocityBulkGetContext ctx = (VelocityBulkGetContext)htRegions[sRegion];
                if (ctx == null)
                {
                    ctx = new VelocityBulkGetContext(sRegion);
                    htRegions[sRegion] = ctx;
                }

                ctx.AddKey(rgKeys[iKey], iKey);

                if (ctx.NumObjects >= VelocityBulkGetContext.MAX_VELOCITY_BULK_GET_SIZE)
                {
                    // context has reached max size.  post it now.
                    htRegions.Remove(sRegion);
                    ThreadPool.QueueUserWorkItem(new WaitCallback(ctx.ProcessContext), wo);
                }
            }

            // post the remaining contexts.
            foreach (VelocityBulkGetContext ctx in htRegions.Values)
            {
                ThreadPool.QueueUserWorkItem(new WaitCallback(ctx.ProcessContext), wo);
            }

            wo.m_wait.WaitOne();

            return wo.m_rgValues;
            
        }
        
        public void PublishData(string sKey, byte[] rgbValue, Object keyState)
        {
            s_Cache.Put(sKey, rgbValue);
        }

        public void BulkPublishData(string[] rgKeys, byte[][] rgbValues, Object[] rgKeyStates)
        {
            throw new InvalidOperationException("Bulk Publishing not available for Velocity");
        }

        public void RemoveData(string sKey)
        {
            s_Cache.Remove(sKey);
        }

        public void BulkRemoveData(string[] sKeys)
        {
            foreach (string key in sKeys)
            {
                s_Cache.Remove(key);
            }
        }

        public void RegisterNotificationHandler(DataChangeNotification notificationCallback)
        {
            m_notificationCallback += notificationCallback;
        }
        
        public void RegisterNotificationFailureHandler(DataChangeFailureNotification failureCallback)
        {
            m_failureCallback += failureCallback;
        }
        
        public void UnregisterHandlers()
        {
            m_notificationCallback = null;
            m_failureCallback = null;
        }

        public void OnVelocityNotificationBatch(
            string cacheName,
            ReadOnlyCollection<DataCacheOperationNotification> notifications,
            DataCacheNotificationDescriptor nd)
        {
            if (m_notificationCallback == null)
            {
                return;
            }
            
            string[] rgKeys = new string[notifications.Count];
            string[] rgRegions = new string[notifications.Count];
            int iKey = 0;
            foreach (DataCacheOperationNotification notif in notifications)
            {
                rgKeys[iKey] = notif.Key;
                rgRegions[iKey] = notif.RegionName;
                iKey++;
            }

            m_notificationCallback(rgKeys, rgRegions);
        }

        public void OnVelocityNotificationFailure(string cacheName, DataCacheNotificationDescriptor nd)
        {
            if (m_failureCallback == null)
            {
                return;
            }
            
            m_failureCallback();
        }
        

    }

    internal class VelocityBulkGetContext
    {
        public const int MAX_VELOCITY_BULK_GET_SIZE = 32;
        
        private string m_sRegion;
        private Hashtable m_htItems;

        public int NumObjects
        {
            get
            {
                return m_htItems.Count;
            }
        }

        private class VelocityItem
        {
            public string m_sKey;
            public int m_iIndex;
        }
        
        public VelocityBulkGetContext(string sRegion)
        {
            m_sRegion = sRegion;
            m_htItems = new Hashtable(MAX_VELOCITY_BULK_GET_SIZE);
        }

        public void AddKey(string sKey, int iIndex)
        {
            VelocityItem item = new VelocityItem();
            item.m_sKey = sKey;
            item.m_iIndex = iIndex;

            m_htItems[sKey] = item;
        }
        
        public void ProcessContext(Object state)
        {
            List<string> keyList = new List<string>(m_htItems.Count);
            foreach (VelocityItem item in m_htItems.Values)
            {
                keyList.Add(item.m_sKey);
            }

            List<KeyValuePair<string, Object>> response = MemCacheImpl.s_Cache.BulkGet(keyList, m_sRegion);

            BulkGetWaitObject wo = (BulkGetWaitObject)state;

            foreach (KeyValuePair<string, Object> pair in response)
            {
                VelocityItem item = (VelocityItem)m_htItems[pair.Key];
                wo.CompleteBulkGet(pair.Key, (byte[])pair.Value, item.m_iIndex);
            }
        }
    }

    internal class BulkGetWaitObject
    {
        public ManualResetEvent m_wait;
        public byte[][] m_rgValues;
        public int m_cKeysRemaining;

        public BulkGetWaitObject(int cKeys)
        {
            m_wait = new ManualResetEvent(false);
            m_rgValues = new byte[cKeys][];
            m_cKeysRemaining = cKeys;
        }
        
        public void CompleteBulkGet(string sKey, byte[] rgbValue, Object state)
        {
            int iKey = (int)state;
            m_rgValues[iKey] = rgbValue;
            if (0 == Interlocked.Decrement(ref m_cKeysRemaining))
            {
                m_wait.Set();
            }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\msi\tempdiracl\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\nunit\dll\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\msi\msierrors\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__msierrors_0_none_12.4.56.0_none_4add3e38a9f6ccee
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__msierrors_0_no-public-key_12.4.56.0_x-ww_a16937f6
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_msierrors_0
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__msierrors_0_no-public-key_12.4.56.0_x-ww_a16937f6
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__msierrors_0_no-public-key_12.4.56.0_x-ww_a16937f6.manifest
XP_MANIFEST_PATH=manifests\x86__msierrors_0_no-public-key_12.4.56.0_x-ww_a16937f6.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__msierrors_0_no-public-key_12.4.56.0_x-ww_a16937f6.cat
XP_CATALOG_PATH=manifests\x86__msierrors_0_no-public-key_12.4.56.0_x-ww_a16937f6.cat
XP_PAYLOAD_PATH=x86__msierrors_0_no-public-key_12.4.56.0_x-ww_a16937f6
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_msierrors_0,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\nunit\dll\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\msi\msierrors\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__msierrors_0_none_12.4.56.0_none_4add3e38a9f6ccee
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__msierrors_0_no-public-key_12.4.56.0_x-ww_a16937f6
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_msierrors_0
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__msierrors_0_no-public-key_12.4.56.0_x-ww_a16937f6
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__msierrors_0_no-public-key_12.4.56.0_x-ww_a16937f6.manifest
XP_MANIFEST_PATH=manifests\x86__msierrors_0_no-public-key_12.4.56.0_x-ww_a16937f6.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__msierrors_0_no-public-key_12.4.56.0_x-ww_a16937f6.cat
XP_CATALOG_PATH=manifests\x86__msierrors_0_no-public-key_12.4.56.0_x-ww_a16937f6.cat
XP_PAYLOAD_PATH=x86__msierrors_0_no-public-key_12.4.56.0_x-ww_a16937f6
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_msierrors_0,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\nunit\dll\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\nunit\dll\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_xblnunit_none_12.4.56.0_none_f82f5c47a0646e03
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_xblnunit_no-public-key_12.4.56.0_x-ww_fb9ec133
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xblnunit
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_xblnunit_no-public-key_12.4.56.0_x-ww_fb9ec133
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_xblnunit_no-public-key_12.4.56.0_x-ww_fb9ec133.manifest
XP_MANIFEST_PATH=manifests\msil_xblnunit_no-public-key_12.4.56.0_x-ww_fb9ec133.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_xblnunit_no-public-key_12.4.56.0_x-ww_fb9ec133.cat
XP_CATALOG_PATH=manifests\msil_xblnunit_no-public-key_12.4.56.0_x-ww_fb9ec133.cat
XP_PAYLOAD_PATH=msil_xblnunit_no-public-key_12.4.56.0_x-ww_fb9ec133
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xblnunit,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\nunit\nunit\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\nunit\dll\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_xblnunit_none_12.4.56.0_none_f82f5c47a0646e03
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_xblnunit_no-public-key_12.4.56.0_x-ww_fb9ec133
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xblnunit
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_xblnunit_no-public-key_12.4.56.0_x-ww_fb9ec133
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_xblnunit_no-public-key_12.4.56.0_x-ww_fb9ec133.manifest
XP_MANIFEST_PATH=manifests\msil_xblnunit_no-public-key_12.4.56.0_x-ww_fb9ec133.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_xblnunit_no-public-key_12.4.56.0_x-ww_fb9ec133.cat
XP_CATALOG_PATH=manifests\msil_xblnunit_no-public-key_12.4.56.0_x-ww_fb9ec133.cat
XP_PAYLOAD_PATH=msil_xblnunit_no-public-key_12.4.56.0_x-ww_fb9ec133
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xblnunit,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\nunit\nunit\nUnitUser.cs ===
using System;
using System.IO;
using System.Collections;
using System.Text;
using xonline.common.service;

namespace xonline.common.nUnit
{
    public struct GamerTagAndWebID
    {
        public string gamerTag;
        public string teamName;
        public byte[] webID;
    }
        
    public struct UserAndTeam
    {
        public ulong userPuid;
        public ulong teamPuid;
    }
    
    public class User
    {
        private const int     c_puids = 1024;
        private const ulong   c_puid_ceiling = 0x0009FFFFFFFFFFFF;
        private const ulong   c_team_ceiling = 0xFEFE00000000FFFF;
        private const ulong   c_webid_ceiling = 0x0001FFFFFFFFFFFF;
        private const string  c_gamerTag = "webuser";
        private const string  c_teamName = "webteam";
        
        //
        // returns a random 64bit number from the set of PUIDs that are mapped to gamertags and webids.
        //  NOTE: This method will return the same PUID if called multiple times in succession due to the 
        //  way Random works
        //
        public static ulong GetRandomPuid()
        {
            Random r = new Random();
            
            return c_puid_ceiling - (ulong)(r.Next() % c_puids);
        }

        //
        // returns a random 64bit number from the set of PUIDs that are mapped to gamertags and webids.
        //  NOTE: The provided seed value allows this method to return different Puids on consecutive calls
        //
        public static ulong GetRandomPuid(int seed)
        {
            Random r = new Random(seed);
            
            return c_puid_ceiling - (ulong)(r.Next() % c_puids);
        }
        
        //
        // returns a set of 64bit numbers from the set of PUIDs that are mapped to gamertags and webids.
        //  NOTE: This method retuns a set of puids that are in a contiguous range always
        //
        public static ulong [] GetRandomPuids(int cPuids)
        {
            Random r = new Random();
            ulong [] puids = new ulong[cPuids];

            ulong puidStart = c_puid_ceiling - (ulong)(r.Next() % (c_puids - cPuids)) - (ulong)cPuids;
            
            for (int i=0; i < cPuids; i++)
            {
                puids[i] = puidStart + (ulong)i;
            }

            return puids;
        }


        //
        // returns a random user and assocated team from the set of PUIDs and Teams.
        //  NOTE: This method will return the same PUID if called multiple times in succession due to the 
        //  way Random works
        //
        public static UserAndTeam GetRandomUserAndTeam(uint titleId)
        {        
            Random          r = new Random();
            UserAndTeam     uat = new UserAndTeam();
            int             index = r.Next() % c_puids;

            uat.userPuid = c_puid_ceiling - (ulong)index;
            uat.teamPuid = c_team_ceiling + (((ulong)titleId) << 16) - (ulong)index / 8;

            return uat;
        }

        public static UserAndTeam GetRandomUserAndTeam(uint titleId, int seed)
        {        
            Random          r = new Random(seed);
            UserAndTeam     uat = new UserAndTeam();
            int             index = r.Next() % c_puids;

            uat.userPuid = c_puid_ceiling - (ulong)index;
            uat.teamPuid = c_team_ceiling + (((ulong)titleId) << 16) - (ulong)index / 8;

            return uat;
        }

        static Random s_rand = new Random();

        //
        // returns a random 64bit number from the set of PUIDs that are mapped to gamertags and webids.
        //
        public static GamerTagAndWebID GetRandomWebCredential()
        {
            
            GamerTagAndWebID creds = new GamerTagAndWebID();

            int iUser = s_rand.Next() % c_puids;
            int iTeam = iUser/8;
            ulong webID = c_webid_ceiling - (ulong)c_puids + (ulong)iUser;

            MemoryStream            stream = new MemoryStream();
            BinaryWriter            writer = new BinaryWriter(stream);

            writer.Write(webID);
            writer.Flush();

            creds.gamerTag = c_gamerTag + iUser.ToString();
            creds.teamName = c_teamName + iTeam.ToString();
            creds.webID = stream.ToArray();
            
            return creds;
        }        

        public static GamerTagAndWebID GetWebCredentialFromPuid(ulong puid)
        {
            GamerTagAndWebID creds = new GamerTagAndWebID();

            if ( (puid > c_puid_ceiling) || (puid < c_puid_ceiling -c_puids) )
            {
                throw new Exception("Invalid puid");
            }

            int iUser = c_puids - (int)(c_puid_ceiling - puid);
            
            int iTeam = iUser/8;
            ulong webID = c_webid_ceiling - (ulong)c_puids + (ulong)iUser;

            MemoryStream            stream = new MemoryStream();
            BinaryWriter            writer = new BinaryWriter(stream);

            writer.Write(webID);
            writer.Flush();

            creds.gamerTag = c_gamerTag + iUser.ToString();
            creds.teamName = c_teamName + iTeam.ToString();
            creds.webID = stream.ToArray();
            
            return creds;
        }        
    }    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\offerutil\dll\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\nunit\nunit\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__nunit_2_none_12.4.56.0_none_ea3588c146ae0f78
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__nunit_2_no-public-key_12.4.56.0_x-ww_6434387c
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_nunit_2
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__nunit_2_no-public-key_12.4.56.0_x-ww_6434387c
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__nunit_2_no-public-key_12.4.56.0_x-ww_6434387c.manifest
XP_MANIFEST_PATH=manifests\x86__nunit_2_no-public-key_12.4.56.0_x-ww_6434387c.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__nunit_2_no-public-key_12.4.56.0_x-ww_6434387c.cat
XP_CATALOG_PATH=manifests\x86__nunit_2_no-public-key_12.4.56.0_x-ww_6434387c.cat
XP_PAYLOAD_PATH=x86__nunit_2_no-public-key_12.4.56.0_x-ww_6434387c
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_nunit_2,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\offerutil\dll\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\nunit\nunit\xmgmt.cs ===
using System;
using System.IO;
using System.Text;
using System.Net;
using System.Net.Sockets;
using System.Collections;
using System.Collections.Specialized;
using xonline.common.service;
using xonline.common.mgmt;

// note: copied/modified from titlemgr

namespace xonline.common.nUnit
{
	public class XMgmt
	{
        public static string Exec(string target, string command)
        {
            IPAddress ipAddress = null;
            
            string[] responses;
            HResult hr;

            try
            {
                ipAddress = IPAddress.Parse(target);
            }
            catch (FormatException)
            {
                // sServer is not parsable as an IP address, see if we can look it up 
                // through DNS...
                System.Console.WriteLine("Attempting to resolve hostname " + target);
                IPHostEntry ipHostEntry = Dns.GetHostEntry(target);
                if (ipHostEntry.AddressList.Length == 0)
                {
                    System.Console.WriteLine("Error: Unable to resolve hostname: " + target);
                    return "";
                }

                // use the first address in IPHostEntry, whatever it is...
                ipAddress = ipHostEntry.AddressList[0];
            }


            
            // create the XomAdmin object
            System.Console.WriteLine("Attempting to connect to " + ipAddress.ToString());
            XomAdminSession xomAdminSession = new XomAdminSession(ipAddress);

            
            xomAdminSession.SendRequest(command, 10000, out responses, out hr);
            
            xomAdminSession.Close();
            
            return String.Join("\r\n", responses);
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\offerutil\dll\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\offerutil\dll\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_offerutil_none_12.4.56.0_none_14e6b934d30c9bcf
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_offerutil_no-public-key_12.4.56.0_x-ww_efdd1761
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=offerutil
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_offerutil_no-public-key_12.4.56.0_x-ww_efdd1761
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_offerutil_no-public-key_12.4.56.0_x-ww_efdd1761.manifest
XP_MANIFEST_PATH=manifests\msil_offerutil_no-public-key_12.4.56.0_x-ww_efdd1761.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_offerutil_no-public-key_12.4.56.0_x-ww_efdd1761.cat
XP_CATALOG_PATH=manifests\msil_offerutil_no-public-key_12.4.56.0_x-ww_efdd1761.cat
XP_PAYLOAD_PATH=msil_offerutil_no-public-key_12.4.56.0_x-ww_efdd1761
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=offerutil,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\nunit\nunit\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__nunit_2_none_12.4.56.0_none_ea3588c146ae0f78
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__nunit_2_no-public-key_12.4.56.0_x-ww_6434387c
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_nunit_2
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__nunit_2_no-public-key_12.4.56.0_x-ww_6434387c
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__nunit_2_no-public-key_12.4.56.0_x-ww_6434387c.manifest
XP_MANIFEST_PATH=manifests\x86__nunit_2_no-public-key_12.4.56.0_x-ww_6434387c.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__nunit_2_no-public-key_12.4.56.0_x-ww_6434387c.cat
XP_CATALOG_PATH=manifests\x86__nunit_2_no-public-key_12.4.56.0_x-ww_6434387c.cat
XP_PAYLOAD_PATH=x86__nunit_2_no-public-key_12.4.56.0_x-ww_6434387c
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_nunit_2,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\offerutil\offerutil\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\offerutil\dll\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_offerutil_none_12.4.56.0_none_14e6b934d30c9bcf
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_offerutil_no-public-key_12.4.56.0_x-ww_efdd1761
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=offerutil
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_offerutil_no-public-key_12.4.56.0_x-ww_efdd1761
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_offerutil_no-public-key_12.4.56.0_x-ww_efdd1761.manifest
XP_MANIFEST_PATH=manifests\msil_offerutil_no-public-key_12.4.56.0_x-ww_efdd1761.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_offerutil_no-public-key_12.4.56.0_x-ww_efdd1761.cat
XP_CATALOG_PATH=manifests\msil_offerutil_no-public-key_12.4.56.0_x-ww_efdd1761.cat
XP_PAYLOAD_PATH=msil_offerutil_no-public-key_12.4.56.0_x-ww_efdd1761
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=offerutil,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\match\match\MatchSqlCodeGen.cs ===
using System;
using System.Collections;
using System.Reflection;
using System.Text;
using System.IO;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.service;

namespace xonline.common.match
{

public class MatchSqlCodeGen
{
    static TextWriter _log;

    static MatchSqlCodeGen()
    {
        _log = Console.Out;
    }

    public static void SetLogTarget(TextWriter log)
    {
        _log = log;
    }

    public static void Log(string msg)
    {
    _log.WriteLine(msg);
    }

    public static string[] All(MatchGameConfig matchGameConfig, MatchLtcConfig matchLtcConfig, bool droptable)
    {
        Log("Generating sql statements for titleid 0x" + matchGameConfig.TitleId.ToString("X8"));

        ArrayList statements = new ArrayList();
        statements.AddRange(MatchSqlCodeGen.StandardTable(matchGameConfig, droptable));
        statements.AddRange(MatchSqlCodeGen.RankedTable(matchGameConfig, droptable));
        statements.AddRange(MatchSqlCodeGen.TableAlterations(matchGameConfig, droptable));
        statements.AddRange(MatchSqlCodeGen.InsertProc(matchGameConfig));
        statements.AddRange(MatchSqlCodeGen.UpdateProc(matchGameConfig));
        statements.AddRange(MatchSqlCodeGen.UpdateCompleteProc(matchGameConfig));
        statements.AddRange(MatchSqlCodeGen.DeleteProc(matchGameConfig));
        statements.AddRange(MatchSqlCodeGen.DeadXboxProc(matchGameConfig));
        statements.AddRange(MatchSqlCodeGen.SystemFindByIdQueryProc(matchGameConfig));
        statements.AddRange(MatchSqlCodeGen.SystemFindByIdGetAttributesQueryProc(matchGameConfig));
        statements.AddRange(MatchSqlCodeGen.SystemFindByIdListQueryProc(matchGameConfig));
        statements.AddRange(MatchSqlCodeGen.LockAndReadProc(matchGameConfig));
        statements.AddRange(MatchSqlCodeGen.ReleaseLockProc(matchGameConfig));
        statements.AddRange(MatchSqlCodeGen.SessionCleanupProc(matchGameConfig, matchLtcConfig));

        foreach (DictionaryEntry de in matchGameConfig.MatchQueries)
        {
            uint queryId = (uint)de.Key;
            statements.AddRange(MatchSqlCodeGen.StandardQueryProc(matchGameConfig, queryId));
            statements.AddRange(MatchSqlCodeGen.RankedQueryProc(matchGameConfig, queryId));
            // weighted queries can hit standard or ranked tables, and do identical work either way.
            // we create 2 sprocs so that there is no chance of SQL getting execution plans confused.
            statements.AddRange(MatchSqlCodeGen.WeightedQueryProc(matchGameConfig, queryId, false /*standard*/));
            statements.AddRange(MatchSqlCodeGen.WeightedQueryProc(matchGameConfig, queryId, true /*ranked*/));
            statements.AddRange(MatchSqlCodeGen.AffiliatesQueryProc(matchGameConfig, queryId));
        }

        return (string[])statements.ToArray(typeof(string));
    }

    class TableModification
    {
        public string Table;
        public string Name;
        public string Decl;
    }

    class ColumnModification : TableModification
    {
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("-- Conditionally add " + Name + " column\n");
            sb.Append("    IF NOT EXISTS\n");
            sb.Append("       (SELECT NULL FROM syscolumns\n");
            sb.Append("          WHERE id = (SELECT id FROM sysobjects\n");
            sb.Append("                         WHERE name = '" + Table + "'\n");
            sb.Append("                         AND type = 'u')\n");
            sb.Append("                AND name = '" + Name + "')\n");
            sb.Append("    BEGIN\n");
            sb.Append("        PRINT 'Adding column " + Name + " to table " + Table + "'\n");
            sb.Append("        ALTER TABLE " + Table + " ADD " + Name + " " + Decl + "\n"); 
            sb.Append("    END\n\n");

            return sb.ToString();
        }
    }

    class IndexModification : TableModification
    {
        public bool Clustered;

        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            string indexName = Table + "_" + Name;
            string clusteredDecl = Clustered ? "CLUSTERED" : "NONCLUSTERED";

            sb.Append("-- Conditionally add " + Table + "_" + Name + " index\n");
            sb.Append("  IF NOT EXISTS\n");
            sb.Append("     (SELECT NULL FROM sysindexes\n");
            sb.Append("         WHERE name = '" + indexName + "')\n");
            sb.Append("  BEGIN\n"); 
            sb.Append("         PRINT 'Adding index " + indexName + " to table " + Table + "'\n");
            sb.Append("         CREATE " + clusteredDecl  + " INDEX " + indexName + " on " + Table + " (\n");
            sb.Append("              " + Decl + "\n");
            sb.Append("         )\n");
            sb.Append("  END\n"); 

            return sb.ToString();
        }
    }

    // Add any required table updates that are required for additional system
    // behavior here in existing titles. 
    public static string[] TableAlterations(MatchGameConfig matchGameConfig, bool dropTable)
    {
        ArrayList statements = new ArrayList();

        // Add columns to tables that already exist. This is to support title
        // upgrades of existing titles
        StringBuilder sb = new StringBuilder(1024);
        ArrayList modifications = new ArrayList();

        ColumnModification column;
        IndexModification index;

        column = new ColumnModification();
        column.Table = StandardTableName(matchGameConfig);
        column.Name  = AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_PUID);
        column.Decl  = IdToSqlType(MatchDefs.X_ATTRIBUTE_GAMER_PUID);
        modifications.Add(column);

        column =  new ColumnModification();
        column.Table = RankedTableName(matchGameConfig);
        column.Name  = AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_PUID);
        column.Decl  = IdToSqlType(MatchDefs.X_ATTRIBUTE_GAMER_PUID);
        modifications.Add(column);

        column = new ColumnModification();
        column.Table = StandardTableName(matchGameConfig);
        column.Name  = AttributeName(MatchDefs.X_ATTRIBUTE_PLATFORM_TYPE);
        column.Decl  = IdToSqlType(MatchDefs.X_ATTRIBUTE_PLATFORM_TYPE);
        modifications.Add(column);

        column =  new ColumnModification();
        column.Table = RankedTableName(matchGameConfig);
        column.Name  = AttributeName(MatchDefs.X_ATTRIBUTE_PLATFORM_TYPE);
        column.Decl  = IdToSqlType(MatchDefs.X_ATTRIBUTE_PLATFORM_TYPE);
        modifications.Add(column);

        column = new ColumnModification();
        column.Table = StandardTableName(matchGameConfig);
        column.Name  = AttributeName(MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK);
        column.Decl  = IdToSqlType(MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK);
        modifications.Add(column);

        column =  new ColumnModification();
        column.Table = RankedTableName(matchGameConfig);
        column.Name  = AttributeName(MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK);
        column.Decl  = IdToSqlType(MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK);
        modifications.Add(column);

        column =  new ColumnModification();
        column.Table = StandardTableName(matchGameConfig);
        column.Name  = "dt_deletion_time";
        column.Decl  = "DATETIME";
        modifications.Add(column);

        column = new ColumnModification();
        column.Table = RankedTableName(matchGameConfig);
        column.Name  = "dt_deletion_time";
        column.Decl  = "DATETIME";
        modifications.Add(column);

        // Begin column adds for partitioning/migration

        column = new ColumnModification();
        column.Table = StandardTableName(matchGameConfig);
        column.Name = "dt_lock_expire";
        column.Decl = "DATETIME NULL";
        modifications.Add(column);

        column = new ColumnModification();
        column.Table = RankedTableName(matchGameConfig);
        column.Name = "dt_lock_expire";
        column.Decl = "DATETIME NULL";
        modifications.Add(column);

        column = new ColumnModification();
        column.Table = StandardTableName(matchGameConfig);
        column.Name = "i_sw_bucket";
        column.Decl = "int NULL";
        modifications.Add(column);

        column = new ColumnModification();
        column.Table = RankedTableName(matchGameConfig);
        column.Name = "i_sw_bucket";
        column.Decl = "int NULL";
        modifications.Add(column);

        column = new ColumnModification();
        column.Table = StandardTableName(matchGameConfig);
        column.Name = "ti_breadcrumb_state";
        column.Decl = "TINYINT NULL CONSTRAINT " + StandardTableName(matchGameConfig) + "_ti_breadcrumb_state_default DEFAULT 1 WITH VALUES";
        modifications.Add(column);

        column = new ColumnModification();
        column.Table = RankedTableName(matchGameConfig);
        column.Name = "ti_breadcrumb_state";
        column.Decl = "TINYINT NULL CONSTRAINT " + RankedTableName(matchGameConfig) + "_ti_breadcrumb_state_default DEFAULT 1 WITH VALUES";
        modifications.Add(column);
        // end column adds for partitioning/migration


        index = new IndexModification();
        index.Clustered = false;
        index.Table = StandardTableName(matchGameConfig);
        index.Name = "ndx_deletion_time_nc";
        index.Decl = "dt_deletion_time, bi_session_id";
        modifications.Add(index);

        index = new IndexModification();
        index.Clustered = false;
        index.Table = RankedTableName(matchGameConfig);
        index.Name = "ndx_deletion_time_nc";
        index.Decl = "dt_deletion_time, bi_session_id";
        modifications.Add(index);

        sb.Append("--\n");
        sb.Append("-- Begin table alterations to support title upgrades\n");
        sb.Append("--\n");

        foreach(TableModification tableMod in modifications)
        {
            // Make sure the table exists to modify
            sb.Append("IF EXISTS\n");
            sb.Append("    (SELECT NULL FROM sysobjects WHERE name = '" + tableMod.Table + "'\n");
            sb.Append("       AND type = 'u')\n");
            sb.Append("BEGIN\n");

            // Generate modification SQL code
            Log(String.Format("Generating {0} alteration code for Table {1} ({2}, {3})",
                        tableMod.GetType().Name,
                        tableMod.Table,
                        tableMod.Name,
                        tableMod.Decl));
            sb.Append(tableMod.ToString());

            sb.Append("END\n");
            sb.Append("\n");
        }

        // Make the newlines in the string Windows style
        sb.Replace("\n", "\r\n");
        statements.Add(sb.ToString());

        Log("TableAlterations generated " + statements.Count + " sql statements");

        return (string[])statements.ToArray(typeof(string));
    }

    public static string[] StandardTable(
        MatchGameConfig matchGameConfig,
        bool droptable)
    {
        string tableName = StandardTableName(matchGameConfig);

        string msg = "Generating sql statements for table " + tableName;
        Log(msg);

        StringBuilder sb = new StringBuilder();
        sb.Append("IF EXISTS\n");
        sb.Append("    (SELECT * FROM dbo.sysobjects\n");
        sb.Append("        WHERE name = '" + tableName + "'\n");
        sb.Append("        AND type = 'u')\n");
        sb.Append("BEGIN\n");

        if (droptable)
        {
            Log("Any existing table will be dropped");
            sb.Append("    PRINT 'Dropping table "+ tableName + "'\n");
            sb.Append("    DROP TABLE [dbo].["+ tableName + "]\n");
            sb.Append("END\n");
        }
        else
        {
            Log("Any existing table will be unchanged");
            sb.Append("    PRINT '**Note: " + tableName + " table already exists."
                +"  Creation has been skipped.'\n");
            sb.Append("END\n");
            sb.Append("ELSE\n");
        }

        sb.Append("BEGIN\n");
        sb.Append("    PRINT 'Creating " + tableName + " table.'\n");
        sb.Append("    CREATE TABLE dbo." + tableName + " (\n");
        sb.Append("\n");
        sb.Append("         bi_session_id           bigint                  NOT NULL\n");
        sb.Append("\n");
        sb.Append("        ,i_ip_addr               int                     NOT NULL\n");
        sb.Append("        ,i_sg_ip                 int                     NOT NULL\n");
        sb.Append("        ,b_box_id                binary(16)              NOT NULL\n");
        sb.Append("        ,b_host_address          binary(36)              NOT NULL\n");
        sb.Append("        ,b_key_exchange_key      binary(16)              NOT NULL\n");
        sb.Append("        ,i_public_available      int                     NOT NULL\n");
        sb.Append("        ,i_private_available     int                     NOT NULL\n");
        sb.Append("        ,i_public_current        int                     NOT NULL\n");
        sb.Append("        ,i_private_current       int                     NOT NULL\n");
        sb.Append("        ,dt_session_expiration   datetime                NOT NULL\n");
        sb.Append("        ,ti_is_available         tinyint                 NOT NULL\n");
        sb.Append("        ,i_hash                  int                     NOT NULL\n");
        sb.Append("        ,ti_nat_type             tinyint                 NOT NULL\n");
        sb.Append("        ,dt_deletion_time        datetime                \n");
        sb.Append("\n");

        // built in attributes added to all schemas
        sb.Append("        ," + AttributeName(MatchDefs.X_ATTRIBUTE_GAME_TYPE)
            + "          " + IdToSqlType(MatchDefs.X_ATTRIBUTE_GAME_TYPE) + " NOT NULL\n");
        sb.Append("        ," + AttributeName(MatchDefs.X_ATTRIBUTE_GAME_MODE)
            + "          " + IdToSqlType(MatchDefs.X_ATTRIBUTE_GAME_MODE) + " NOT NULL\n");
        sb.Append("        ," + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_ZONE)
            + "          " + IdToSqlType(MatchDefs.X_ATTRIBUTE_GAMER_ZONE) + " NOT NULL\n");
        sb.Append("        ," + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_COUNTRY)
            + "          " + IdToSqlType(MatchDefs.X_ATTRIBUTE_GAMER_COUNTRY) + " NOT NULL\n");
        sb.Append("        ," + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_LANGUAGE)
            + "          " + IdToSqlType(MatchDefs.X_ATTRIBUTE_GAMER_LANGUAGE) + " NOT NULL\n");
        sb.Append("        ," + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_RATING)
            + "          " + IdToSqlType(MatchDefs.X_ATTRIBUTE_GAMER_RATING) + " NOT NULL\n");
        sb.Append("        ," + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_MU)
            + "          " + IdToSqlType(MatchDefs.X_ATTRIBUTE_GAMER_MU) + " NOT NULL\n");
        sb.Append("        ," + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_SIGMA)
            + "          " + IdToSqlType(MatchDefs.X_ATTRIBUTE_GAMER_SIGMA) + " NOT NULL\n");
        sb.Append("        ," + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_PUID)
            + "          " + IdToSqlType(MatchDefs.X_ATTRIBUTE_GAMER_PUID) + " NOT NULL\n");
        sb.Append("        ," + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_HOSTNAME)
            + "          " + IdToSqlType(MatchDefs.X_ATTRIBUTE_GAMER_HOSTNAME) + " NOT NULL\n");
        sb.Append("        ," + AttributeName(MatchDefs.X_ATTRIBUTE_PLATFORM_TYPE)
            + "          " + IdToSqlType(MatchDefs.X_ATTRIBUTE_PLATFORM_TYPE) + " NOT NULL\n");
        sb.Append("        ," + AttributeName(MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK)
            + "          " + IdToSqlType(MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK) + " NOT NULL\n");
        sb.Append("\n");

        // Add title defined schema attributes
        foreach (MatchSchemaAttribute a in matchGameConfig.MatchSchema)
        {
            if (!MatchDefs.IsSystemAttribute(a.Id))
            {
                Log("Adding schema attribute " + AttributeName(a.Id));
                sb.Append("        ,"
                    + AttributeName(a.Id) + "          "
                    + IdToSqlType(a.Id) + "\n");
            }
        }

        // While session id is the primary key, and must be unique, we want to
        // cluster the table on something that will group the rows more usefully
        sb.Append("\n");
        sb.Append("        CONSTRAINT " + tableName + "_pk PRIMARY KEY NONCLUSTERED\n");
        sb.Append("                    (bi_session_id),\n");
        sb.Append("    )\n");
        sb.Append("\n");

        // The goal with this clustered index is to physically organize the table such that
        // rows that are likely to be scanned for most search queries are grouped together.
        sb.Append("    CREATE CLUSTERED INDEX " + tableName+ "_ndx on " + tableName + " (\n");
        sb.Append("         ti_is_available\n");
        sb.Append("        ," + AttributeName(MatchDefs.X_ATTRIBUTE_GAME_MODE) + "\n");
        sb.Append("        ," + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_LANGUAGE) + "\n");
        sb.Append("        ," + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_COUNTRY) + "\n");
        sb.Append("        ," + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_ZONE) + "\n");
        sb.Append("        ,i_hash\n");
        sb.Append("        ,bi_session_id\n");
        sb.Append("    )\n");
        sb.Append("\n");

        // This non-clustered index is to hopefully make dead xbox and dead sg processing
        // more efficient
        sb.Append("    CREATE NONCLUSTERED INDEX " + tableName + "_ndx_boxid_nc on " + tableName + " (\n");
        sb.Append("         b_box_id\n");
        sb.Append("    )\n");

        // This non-clustered index allows us to quickly find sessions session ready to delete
        // we place the session ID into the index page to eliminate a data read.
        sb.Append("    CREATE NONCLUSTERED INDEX " + tableName + "_ndx_deletion_time_nc on " + tableName + " (\n");
        sb.Append("         dt_deletion_time, bi_session_id\n");
        sb.Append("    )\n");
        sb.Append("\n");

        sb.Append("    -- set permissions\n");
        sb.Append("    GRANT SELECT, INSERT, UPDATE, DELETE ON dbo." + tableName + " TO ClientLib\n");
        sb.Append("END\n");

        // make the newlines in the string Windows style
        sb.Replace("\n", "\r\n");

        string[] sqlStatements = new string[1];
        sqlStatements[0] = sb.ToString();

        Log("Generated " + sqlStatements.Length + " sql statements for table " + tableName);

        return sqlStatements;
    }

    private static string StandardTableName(MatchGameConfig matchGameConfig)
    {
        return "t_match_sessions_0x" + matchGameConfig.TitleId.ToString("X8") + "_standard";
    }

    public static string[] RankedTable(
        MatchGameConfig matchGameConfig,
        bool droptable)
    {
        string tableName = RankedTableName(matchGameConfig);

        string msg = "Generating sql statements for table " + tableName;
        Log(msg);

        StringBuilder sb = new StringBuilder();
        sb.Append("IF EXISTS\n");
        sb.Append("    (SELECT * FROM dbo.sysobjects\n");
        sb.Append("        WHERE name = '" + tableName + "'\n");
        sb.Append("        AND type = 'u')\n");
        sb.Append("BEGIN\n");

        if (droptable)
        {
            sb.Append("    PRINT 'Dropping table "+ tableName + "'\n");
            sb.Append("    DROP TABLE [dbo].["+ tableName + "]\n");
            sb.Append("END\n");
        }
        else
        {
            sb.Append("    PRINT '**Note: " + tableName + " table already exists."
                +"  Creation has been skipped.'\n");
            sb.Append("END\n");
            sb.Append("ELSE\n");
        }

        sb.Append("BEGIN\n");
        sb.Append("    PRINT 'Creating " + tableName + " table.'\n");
        sb.Append("    CREATE TABLE dbo." + tableName + " (\n");
        sb.Append("\n");
        sb.Append("         bi_session_id           bigint                  NOT NULL\n");
        sb.Append("\n");
        sb.Append("        ,i_ip_addr               int                     NOT NULL\n");
        sb.Append("        ,i_sg_ip                 int                     NOT NULL\n");
        sb.Append("        ,b_box_id                binary(16)              NOT NULL\n");
        sb.Append("        ,b_host_address          binary(36)              NOT NULL\n");
        sb.Append("        ,b_key_exchange_key      binary(16)              NOT NULL\n");
        sb.Append("        ,i_public_available      int                     NOT NULL\n");
        sb.Append("        ,i_private_available     int                     NOT NULL\n");
        sb.Append("        ,i_public_current        int                     NOT NULL\n");
        sb.Append("        ,i_private_current       int                     NOT NULL\n");
        sb.Append("        ,dt_session_expiration   datetime                NOT NULL\n");
        sb.Append("        ,ti_is_available         tinyint                 NOT NULL\n");
        sb.Append("        ,i_hash                  int                     NOT NULL\n");
        sb.Append("        ,ti_nat_type             tinyint                 NOT NULL\n");
        sb.Append("        ,dt_deletion_time        datetime                \n");
        sb.Append("\n");

        // built in attributes not listed in xlast but added to all schemas
        sb.Append("        ," + AttributeName(MatchDefs.X_ATTRIBUTE_GAME_TYPE)
            + "          " + IdToSqlType(MatchDefs.X_ATTRIBUTE_GAME_TYPE) + " NOT NULL\n");
        sb.Append("        ," + AttributeName(MatchDefs.X_ATTRIBUTE_GAME_MODE)
            + "          " + IdToSqlType(MatchDefs.X_ATTRIBUTE_GAME_MODE) + " NOT NULL\n");
        sb.Append("        ," + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_ZONE)
            + "          " + IdToSqlType(MatchDefs.X_ATTRIBUTE_GAMER_ZONE) + " NOT NULL\n");
        sb.Append("        ," + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_COUNTRY)
            + "          " + IdToSqlType(MatchDefs.X_ATTRIBUTE_GAMER_COUNTRY) + " NOT NULL\n");
        sb.Append("        ," + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_LANGUAGE)
            + "          " + IdToSqlType(MatchDefs.X_ATTRIBUTE_GAMER_LANGUAGE) + " NOT NULL\n");
        sb.Append("        ," + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_RATING)
            + "          " + IdToSqlType(MatchDefs.X_ATTRIBUTE_GAMER_RATING) + " NOT NULL\n");
        sb.Append("        ," + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_MU)
            + "          " + IdToSqlType(MatchDefs.X_ATTRIBUTE_GAMER_MU) + " NOT NULL\n");
        sb.Append("        ," + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_SIGMA)
            + "          " + IdToSqlType(MatchDefs.X_ATTRIBUTE_GAMER_SIGMA) + " NOT NULL\n");
        sb.Append("        ," + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_PUID)
            + "          " + IdToSqlType(MatchDefs.X_ATTRIBUTE_GAMER_PUID) + " NOT NULL\n");
        sb.Append("        ," + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_HOSTNAME)
            + "          " + IdToSqlType(MatchDefs.X_ATTRIBUTE_GAMER_HOSTNAME) + " NOT NULL\n");
        sb.Append("        ," + AttributeName(MatchDefs.X_ATTRIBUTE_PLATFORM_TYPE)
            + "          " + IdToSqlType(MatchDefs.X_ATTRIBUTE_PLATFORM_TYPE) + " NOT NULL\n");
        sb.Append("        ," + AttributeName(MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK)
            + "          " + IdToSqlType(MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK) + " NOT NULL\n");
        sb.Append("\n");

        // Add title defined schema attributes
        foreach (MatchSchemaAttribute a in matchGameConfig.MatchSchema)
        {
            if (!MatchDefs.IsSystemAttribute(a.Id))
            {
                Log("Adding schema attribute " + AttributeName(a.Id));
                sb.Append("        ,"
                    + AttributeName(a.Id) + "          "
                    + IdToSqlType(a.Id) + "\n");
            }
        }

        // While session id is the primary key, and must be unique, we want to
        // cluster the table on something that will group the rows more usefully
        sb.Append("\n");
        sb.Append("        CONSTRAINT " + tableName + "_pk PRIMARY KEY NONCLUSTERED\n");
        sb.Append("                    (bi_session_id),\n");
        sb.Append("    )\n");
        sb.Append("\n");

        // The goal with this clustered index is to physically organize the table such that
        // rows that are likely to be scanned for most search queries are grouped together.
        sb.Append("    CREATE CLUSTERED INDEX " + tableName+ "_ndx on " + tableName + " (\n");
        sb.Append("         ti_is_available\n");
        sb.Append("        ," + AttributeName(MatchDefs.X_ATTRIBUTE_GAME_MODE) + "\n");
        sb.Append("        ," + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_MU) + "\n");
        sb.Append("        ,bi_session_id\n");
        sb.Append("    )\n");
        sb.Append("\n");

        // This non-clustered index is to hopefully make dead xbox and dead sg processing
        // more efficient
        sb.Append("    CREATE NONCLUSTERED INDEX " + tableName + "_ndx_boxid_nc on " + tableName + " (\n");
        sb.Append("         b_box_id\n");
        sb.Append("    )\n");
        sb.Append("\n");

        // This non-clustered index allows us to quickly find sessions session ready to delete
        // we place the session ID into the index page to eliminate a data read.
        sb.Append("    CREATE NONCLUSTERED INDEX " + tableName + "_ndx_deletion_time_nc on " + tableName + " (\n");
        sb.Append("         dt_deletion_time, bi_session_id\n");
        sb.Append("    )\n");
        sb.Append("\n");

        sb.Append("    -- set permissions\n");
        sb.Append("    GRANT SELECT, INSERT, UPDATE, DELETE ON dbo." + tableName + " TO ClientLib\n");
        sb.Append("END\n");

        // make the newlines in the string Windows style
        sb.Replace("\n", "\r\n");

        string[] sqlStatements = new string[1];
        sqlStatements[0] = sb.ToString();

        Log("Generated " + sqlStatements.Length + " sql statements for table " + tableName);

        return sqlStatements;
    }

    private static string RankedTableName(MatchGameConfig matchGameConfig)
    {
        return "t_match_sessions_0x" + matchGameConfig.TitleId.ToString("X8") + "_ranked";
    }

    private static string AttributeName(uint id)
    {
        return "att_0x" + MaskId(id).ToString("X8");
    }

    private static uint MaskId(uint id)
    {
        return id & (MatchDefs.X_ATTRIBUTE_SCOPE_MASK
            | MatchDefs.X_ATTRIBUTE_XENON_DATATYPE_MASK
            | MatchDefs.X_ATTRIBUTE_ID_MASK);
    }

    private static string IdToSqlType(uint id)
    {
         switch (MatchDefs.AttributeXenonDatatype(id))
        {
        case MatchDefs.X_ATTRIBUTE_XENON_DATATYPE_CONTEXT:
            return "bigint";

        case MatchDefs.X_ATTRIBUTE_XENON_DATATYPE_UINT32:
            return "int";

        case MatchDefs.X_ATTRIBUTE_XENON_DATATYPE_UINT64:
            return "bigint";

        case MatchDefs.X_ATTRIBUTE_XENON_DATATYPE_FLOAT64:
            return "float";

        case MatchDefs.X_ATTRIBUTE_XENON_DATATYPE_UNICODE:
            return "nvarchar(400)";

        case MatchDefs.X_ATTRIBUTE_XENON_DATATYPE_FLOAT32:
            return "real";

        case MatchDefs.X_ATTRIBUTE_XENON_DATATYPE_DATETIME:
            // datetimes are stored as FILETIME bigints not
            // sql datatime values so there is no loss of
            // precision and so they are easy to subtract
            // for fuzzy matches
            return "bigint";
        case MatchDefs.X_ATTRIBUTE_XENON_DATATYPE_BINARY:
            return "varbinary(800)";

        default:
            throw new ExceptionWithEventId(XEvent.Id.MATCH_CONFIG_57,
                "Unknown Xenon datatype found in title configuration. "
                + "id: " + id.ToString("X8"));

        }
     }

    public static string[] InsertProc(MatchGameConfig matchGameConfig)
    {
        string rankedTableName = RankedTableName(matchGameConfig);
        string standardTableName = StandardTableName(matchGameConfig);
        string procName = InsertProcName(matchGameConfig);
        string[] sqlStatements = new string[3];

        string msg = "Generating sql statements for proc " + procName;
        Log(msg);

        StringBuilder sb = new StringBuilder();

        sb.Append("IF NOT EXISTS (SELECT name FROM dbo.sysobjects WHERE type = 'p' AND name = '" + procName + "')\n");
        sb.Append("BEGIN\n");
        sb.Append("    EXEC('create procedure dbo." + procName + " as raiserror(''Empty Stored Procedure!!'', 16, 1) with seterror')\n");
        sb.Append("    IF (@@error != 0)\n");
        sb.Append("    BEGIN\n");
        sb.Append("        PRINT 'FAILED to create " + procName + "'\n");
        sb.Append("    END\n");
        sb.Append("END\n");

        // make the newlines in the string Windows style
        sb.Replace("\n", "\r\n");

        sqlStatements[0] = sb.ToString();

        sb = new StringBuilder();

        sb.Append("ALTER PROCEDURE [dbo].[" + procName + "]\n");
        sb.Append("     @bi_session_id                 bigint\n");
        sb.Append("    ,@i_ip_addr                     int\n");
        sb.Append("    ,@i_sg_ip                       int\n");
        sb.Append("    ,@b_box_id                      binary(16)\n");
        sb.Append("    ,@b_host_address                binary(36)\n");
        sb.Append("    ,@b_key_exchange_key            binary(16)\n");
        sb.Append("    ,@i_public_available            int\n");
        sb.Append("    ,@i_private_available           int\n");
        sb.Append("    ,@i_public_current              int\n");
        sb.Append("    ,@i_private_current             int\n");
        sb.Append("    ,@dt_session_expire             datetime\n");
        sb.Append("    ,@ti_nat_type                   tinyint\n");
        sb.Append("    ,@i_sw_bucket             int\n");
        sb.Append("    ,@ti_breadcrumb_state           tinyint = 1 -- default to breadcrumb\n");
        sb.Append("    ,@dt_lock_expire             datetime = NULL -- occasionally a caller will want to insert a row in locked state.\n");
        
        // built in attributes not listed in xlast but added to all schemas
        sb.Append("    ,@" + AttributeName(MatchDefs.X_ATTRIBUTE_GAME_TYPE)
            + "                " + IdToSqlType(MatchDefs.X_ATTRIBUTE_GAME_TYPE) + "\n");
        sb.Append("    ,@" + AttributeName(MatchDefs.X_ATTRIBUTE_GAME_MODE)
            + "                " + IdToSqlType(MatchDefs.X_ATTRIBUTE_GAME_MODE) + "\n");
        sb.Append("    ,@" + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_ZONE)
            + "                " + IdToSqlType(MatchDefs.X_ATTRIBUTE_GAMER_ZONE) + " = "
            + MatchDefs.X_ATTRIBUTE_GAMER_ZONE_DEFAULT.ToString() + "\n");
        sb.Append("    ,@" + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_COUNTRY)
            + "                " + IdToSqlType(MatchDefs.X_ATTRIBUTE_GAMER_COUNTRY) + " = "
            + MatchDefs.X_ATTRIBUTE_GAMER_COUNTRY_DEFAULT.ToString() + "\n");
        sb.Append("    ,@" + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_LANGUAGE)
            + "                " + IdToSqlType(MatchDefs.X_ATTRIBUTE_GAMER_LANGUAGE) + " = "
            + MatchDefs.X_ATTRIBUTE_GAMER_LANGUAGE_DEFAULT.ToString() + "\n");
        sb.Append("    ,@" + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_RATING)
            + "                " + IdToSqlType(MatchDefs.X_ATTRIBUTE_GAMER_RATING) + " = "
            + MatchDefs.X_ATTRIBUTE_GAMER_RATING_DEFAULT.ToString() + "\n");
        sb.Append("    ,@" + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_MU)
            + "                " + IdToSqlType(MatchDefs.X_ATTRIBUTE_GAMER_MU) + " = "
            + MatchDefs.X_ATTRIBUTE_GAMER_MU_DEFAULT.ToString() + "\n");
        sb.Append("    ,@" + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_SIGMA)
            + "                " + IdToSqlType(MatchDefs.X_ATTRIBUTE_GAMER_SIGMA) + " = "
            + MatchDefs.X_ATTRIBUTE_GAMER_SIGMA_DEFAULT.ToString() + "\n");
        sb.Append("    ,@" + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_PUID)
            + "                " + IdToSqlType(MatchDefs.X_ATTRIBUTE_GAMER_PUID) + " = 0\n");
        sb.Append("    ,@" + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_HOSTNAME)
            + "                " + IdToSqlType(MatchDefs.X_ATTRIBUTE_GAMER_HOSTNAME) + " = ''\n");
        sb.Append("    ,@" + AttributeName(MatchDefs.X_ATTRIBUTE_PLATFORM_TYPE)
            + "                " + IdToSqlType(MatchDefs.X_ATTRIBUTE_PLATFORM_TYPE) + " = 0\n");
        sb.Append("    ,@" + AttributeName(MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK)
            + "                " + IdToSqlType(MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK) + " = 0\n");

        // title defined schema attributes
        foreach (MatchSchemaAttribute a in matchGameConfig.MatchSchema)
        {
            if (!MatchDefs.IsSystemAttribute(a.Id))
            {
                sb.Append("    ,@" + AttributeName(a.Id) + "                "
                    + IdToSqlType(a.Id) + " = NULL\n");
            }
        }

        sb.Append("AS\n");
        sb.Append("-- Match Code Generator Version - !!Version=" + VersionString + "\n");
        sb.Append("-- Xlast (XDK) Version = " + matchGameConfig.XlastVersion + "\n");
        sb.Append("-- Xlast Project Version = " + matchGameConfig.ProjectVersion + "\n");
        sb.Append("BEGIN\n");
        sb.Append("    DECLARE\n");
        sb.Append("        -- Generic\n");
        sb.Append("         @i_return_code             int\n");
        sb.Append("        ,@error_var                 int\n");
        sb.Append("        ,@rowcount_var                 int\n");
        sb.Append("        ,@ti_is_available           tinyint\n");
        sb.Append("        ,@ti_current_bc_state           tinyint\n");
        sb.Append("        ,@dt_deletion_time           datetime\n");
        sb.Append("\n");
        sb.Append("    SET nocount on\n");
        sb.Append("\n");
        sb.Append("    --\n");
        sb.Append("    --  Insert the session, GAME_TYPE=0 is ranked, GAME_TYPE=1 is standard\n");
        sb.Append("    --\n");
        sb.Append("    SET @ti_is_available = CASE WHEN @i_public_available > 0 THEN 1 ELSE 0 END\n");
        sb.Append("\n");

        // mu is supposed to be in the range 0 to 6, and the search algorithms
        // rely on that fact. If for some reason a mu out of range
        // has been supplied, peg it to one end of the range.
        sb.Append("    if (@" + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_MU) + " > 6.0)\n");
        sb.Append("        set @" + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_MU) +" = 6.0\n");
        sb.Append("    else if (@" + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_MU) + " < 0.0)\n");
        sb.Append("        set @" + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_MU) +" = 0.0\n");
        sb.Append("\n");

        // sigma is supposed to be in the range 0 to 1, while the search algorithm doesn't
        // strictly rely on this fact, we should enforce it anyway. If for some reason a 
        // sigma out of range has been supplied, peg it to one end of the range.
        sb.Append("    if (@" + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_SIGMA) + " > 1.0)\n");
        sb.Append("        set @" + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_SIGMA) +" = 1.0\n");
        sb.Append("    else if (@" + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_SIGMA) + " < 0.0)\n");
        sb.Append("        set @" + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_SIGMA) +" = 0.0\n");
        sb.Append("\n");

        // rating is supposed to be in the range 0 to 100, and the search algorithms
        // rely on that fact. If for some reason a rating out of range
        // has been supplied, peg it to one end of the range.
        sb.Append("    if (@" + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_RATING) + " > 100.0)\n");
        sb.Append("        set @" + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_RATING) +" = 100.0\n");
        sb.Append("    else if (@" + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_RATING) + " < 0.0)\n");
        sb.Append("        set @" + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_RATING) +" = 0.0\n");
        sb.Append("\n");



        sb.Append("    if (@" + AttributeName(MatchDefs.X_ATTRIBUTE_GAME_TYPE) + " = 0)\n");
        sb.Append("    begin\n");
        
        InsertProcEmitCoreSql(ref sb, rankedTableName, MatchDefs.X_ATTRIBUTE_GAME_TYPE_RANKED, matchGameConfig);

        sb.Append("    end\n");
        sb.Append("    else\n");
        sb.Append("    begin\n");

        InsertProcEmitCoreSql(ref sb, standardTableName, MatchDefs.X_ATTRIBUTE_GAME_TYPE_STANDARD, matchGameConfig);
        
        sb.Append("    end\n");
        sb.Append("\n");
        sb.Append("    SELECT @error_var = @@ERROR\n");
        sb.Append("\n");
        sb.Append("    IF @error_var != 0\n");
        sb.Append("    BEGIN\n");
        sb.Append("        IF @error_var = 2627 -- integrity violation\n");
        sb.Append("        BEGIN\n");
        sb.Append("            -- setting the return code is really pointless since xmatchfd will receive DB_E_INTEGRITYVIOLATION\n");
        sb.Append("            -- but it is important to set error_var to 0 since this occurs in normal operation and we don't want\n");
        sb.Append("            -- event spew on every occurance.\n");
        sb.Append("            SET @i_return_code = 0x80155112  -- XONLINE_E_MATCH_SESSION_ALREADY_EXISTS\n");
        sb.Append("            SET @error_var = 0\n");
        sb.Append("            GOTO exit_label\n");
        sb.Append("        END\n");
        sb.Append("\n");
        sb.Append("        SET @i_return_code = 0x80155115  -- XONLINE_E_MATCH_CRITICAL_DB_ERR\n");
        sb.Append("        GOTO exit_label\n");
        sb.Append("    END\n");
        sb.Append("\n");
        sb.Append("    RETURN 0\n");
        sb.Append("\n");
        sb.Append("exit_label:\n");
        sb.Append("    IF @error_var != 0\n");
        sb.Append("    BEGIN\n");
        sb.Append("        DECLARE @message varchar(255)\n");
        sb.Append("        SELECT @message = 'XMATCH_SESSION_INSERT_FAILED: " + procName + " - ' + CAST(CAST(CAST(@error_var AS binary(4)) AS int) AS varchar(64))\n");
        sb.Append("        EXEC master.dbo.xp_logevent 51709, @message, error\n");
        sb.Append("    END\n");
        sb.Append("    RETURN @i_return_code\n");
        sb.Append("END\n");

        // make the newlines in the string Windows style
        sb.Replace("\n", "\r\n");

        sqlStatements[1] = sb.ToString();

        sqlStatements[2] = "GRANT EXECUTE ON " + procName + " TO ClientLib\r\n";

        Log("Generated " + sqlStatements.Length + " sql statements for proc " + procName);

        return sqlStatements;
    }


    // helper to emit the select statement which returns all columns in the modified row
    private static void InsertProcEmitCoreSql(ref StringBuilder sb, 
                                                    string strTableName,
                                                    uint nGameType, 
                                                    MatchGameConfig matchGameConfig)
    {
        sb.Append("    -- first, grab some info about the existing row, if there is one\n");
        sb.Append("    SELECT @ti_current_bc_state = ti_breadcrumb_state,\n");
        sb.Append("        @dt_deletion_time = dt_deletion_time\n");
        sb.Append("    FROM dbo." + strTableName + "\n");
        sb.Append("    WHERE bi_session_id = @bi_session_id \n");
        sb.Append("    if(@@ROWCOUNT < 1 OR\n"); 
        sb.Append("              @dt_deletion_time IS NOT NULL OR -- otherwise let it fail, to cause PK_violation error on the FD\n");
        sb.Append("              @ti_current_bc_state = 3 OR\n");
        sb.Append("              @ti_current_bc_state = @ti_breadcrumb_state)\n");
        sb.Append("    begin\n");
        sb.Append("        INSERT INTO dbo." + strTableName + " (\n");
        sb.Append("             bi_session_id\n");
        sb.Append("            ,i_ip_addr\n");
        sb.Append("            ,i_sg_ip\n");
        sb.Append("            ,b_box_id\n");
        sb.Append("            ,b_host_address\n");
        sb.Append("            ,b_key_exchange_key\n");
        sb.Append("            ,i_public_available\n");
        sb.Append("            ,i_private_available\n");
        sb.Append("            ,i_public_current\n");
        sb.Append("            ,i_private_current\n");
        sb.Append("            ,dt_session_expiration\n");
        sb.Append("            ,ti_is_available\n");
        sb.Append("            ,i_hash\n");
        sb.Append("            ,ti_nat_type\n");
        sb.Append("            ,ti_breadcrumb_state\n");
        sb.Append("            ,dt_lock_expire\n");
        sb.Append("            ,i_sw_bucket\n");
        sb.Append("            ," + AttributeName(MatchDefs.X_ATTRIBUTE_GAME_TYPE) + "\n");
        sb.Append("            ," + AttributeName(MatchDefs.X_ATTRIBUTE_GAME_MODE) + "\n");
        sb.Append("            ," + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_ZONE) + "\n");
        sb.Append("            ," + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_COUNTRY) + "\n");
        sb.Append("            ," + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_LANGUAGE) + "\n");
        sb.Append("            ," + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_RATING) + "\n");
        sb.Append("            ," + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_MU) + "\n");
        sb.Append("            ," + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_SIGMA) + "\n");
        sb.Append("            ," + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_PUID) + "\n");
        sb.Append("            ," + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_HOSTNAME) + "\n");
        sb.Append("            ," + AttributeName(MatchDefs.X_ATTRIBUTE_PLATFORM_TYPE) + "\n");
        sb.Append("            ," + AttributeName(MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK) + "\n");

        foreach (MatchSchemaAttribute a in matchGameConfig.MatchSchema)
        {
            if(!MatchDefs.IsSystemAttribute(a.Id))
            {
                sb.Append("            ," + AttributeName(a.Id) + "\n");
            }
        }

        sb.Append("        ) VALUES (\n");
        sb.Append("             @bi_session_id\n");
        sb.Append("            ,@i_ip_addr\n");
        sb.Append("            ,@i_sg_ip\n");
        sb.Append("            ,@b_box_id\n");
        sb.Append("            ,@b_host_address\n");
        sb.Append("            ,@b_key_exchange_key\n");
        sb.Append("            ,@i_public_available\n");
        sb.Append("            ,@i_private_available\n");
        sb.Append("            ,@i_public_current\n");
        sb.Append("            ,@i_private_current\n");
        sb.Append("            ,@dt_session_expire\n");
        sb.Append("            ,@ti_is_available\n");
        sb.Append("            ,RAND() * 10000\n");
        sb.Append("            ,@ti_nat_type\n");
        sb.Append("            ,@ti_breadcrumb_state\n");
        sb.Append("            ,@dt_lock_expire\n");
        sb.Append("            ,@i_sw_bucket\n");
        sb.Append("            ,@" + AttributeName(MatchDefs.X_ATTRIBUTE_GAME_TYPE) + "\n");
        sb.Append("            ,@" + AttributeName(MatchDefs.X_ATTRIBUTE_GAME_MODE) + "\n");
        sb.Append("            ,@" + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_ZONE) + "\n");
        sb.Append("            ,@" + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_COUNTRY) + "\n");
        sb.Append("            ,@" + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_LANGUAGE) + "\n");
        sb.Append("            ,@" + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_RATING) + "\n");
        sb.Append("            ,@" + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_MU) + "\n");
        sb.Append("            ,@" + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_SIGMA) + "\n");
        sb.Append("            ,@" + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_PUID) + "\n");
        sb.Append("            ,@" + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_HOSTNAME) + "\n");
        sb.Append("            ,@" + AttributeName(MatchDefs.X_ATTRIBUTE_PLATFORM_TYPE) + "\n");
        sb.Append("            ,@" + AttributeName(MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK) + "\n");

        foreach (MatchSchemaAttribute a in matchGameConfig.MatchSchema)
        {
            if (!MatchDefs.IsSystemAttribute(a.Id))
            {
                sb.Append("            ,@" + AttributeName(a.Id) + "\n");
            }
        }

        sb.Append("        )\n");
        sb.Append("    end\n");
        sb.Append("    else\n");
        sb.Append("    begin\n");
        sb.Append("        if(@ti_breadcrumb_state = 1)\n");
        sb.Append("        begin\n");
        sb.Append("            -- update the breadcrumb_state, and all other cols\n");



        sb.Append("            --\n");
        sb.Append("            SET @ti_is_available = CASE WHEN @i_public_available > 0 THEN 1 ELSE 0 END\n");
        sb.Append("\n");
        sb.Append("            if (@" + AttributeName(MatchDefs.X_ATTRIBUTE_GAME_TYPE) + " IS NOT NULL and @" 
            + AttributeName(MatchDefs.X_ATTRIBUTE_GAME_TYPE) + " != " + nGameType + ")\n");
        sb.Append("            begin\n");
        sb.Append("                set @i_return_code = 0x80155119 -- XONLINE_E_MATCH_INVALID_PARAM\n");
        sb.Append("                goto exit_label\n");
        sb.Append("            end\n");
        sb.Append("            UPDATE dbo." + strTableName + " SET\n");
        sb.Append("                 i_public_available = @i_public_available\n");
        sb.Append("                ,i_private_available = @i_private_available\n");
        sb.Append("                ,i_public_current = @i_public_current\n");
        sb.Append("                ,i_private_current = @i_private_current\n");
        sb.Append("                ,dt_session_expiration = @dt_session_expire\n");
        sb.Append("                ,ti_is_available = @ti_is_available\n");
        sb.Append("                ,dt_lock_expire =  @dt_lock_expire\n"); 
        sb.Append("                ,ti_breadcrumb_state = 3 -- indicates that the bc and sw now share this row\n");
        sb.Append("                ,i_sw_bucket =  @i_sw_bucket\n"); 
        sb.Append("                ," + AttributeName(MatchDefs.X_ATTRIBUTE_GAME_MODE)
            + " = ISNULL(@" + AttributeName(MatchDefs.X_ATTRIBUTE_GAME_MODE)
            + ", " + AttributeName(MatchDefs.X_ATTRIBUTE_GAME_MODE) + ")\n");
        sb.Append("            ," + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_ZONE)
            + " = ISNULL(@" + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_ZONE)
            + ", " + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_ZONE) + ")\n");
        sb.Append("            ," + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_COUNTRY)
            + " = ISNULL(@" + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_COUNTRY)
            + ", " + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_COUNTRY) + ")\n");
        sb.Append("            ," + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_LANGUAGE)
            + " = ISNULL(@" + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_LANGUAGE)
            + ", " + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_LANGUAGE) + ")\n");
        sb.Append("            ," + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_RATING)
            + " = ISNULL(@" + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_RATING)
            + ", " + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_RATING) + ")\n");
        sb.Append("            ," + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_MU)
            + " = ISNULL(@" + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_MU)
            + ", " + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_MU) + ")\n");
        sb.Append("            ," + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_SIGMA)
            + " = ISNULL(@" + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_SIGMA)
            + ", " + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_SIGMA) + ")\n");
        sb.Append("            ," + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_PUID)
            + " = ISNULL(@" + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_PUID)
            + ", " + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_PUID) + ")\n");
        sb.Append("            ," + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_HOSTNAME)
            + " = ISNULL(@" + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_HOSTNAME)
            + ", " + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_HOSTNAME) + ")\n");
        sb.Append("            ," + AttributeName(MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK)
            + " = ISNULL(@" + AttributeName(MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK)
            + ", " + AttributeName(MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK) + ")\n");

        foreach (MatchSchemaAttribute a in matchGameConfig.MatchSchema)
        {
            if (!MatchDefs.IsSystemAttribute(a.Id))
            {
                sb.Append("            ," + AttributeName(a.Id)
                    + " = ISNULL(@" + AttributeName(a.Id) + ", " + AttributeName(a.Id) + ")\n");
            }
        }

        sb.Append("            WHERE bi_session_id = @bi_session_id\n");
        sb.Append("        SELECT @error_var = @@ERROR, @rowcount_var = @@ROWCOUNT\n");
        sb.Append("\n");
        sb.Append("    IF @error_var != 0\n");
        sb.Append("    BEGIN\n");
        sb.Append("        SET @i_return_code = 0x80155115  -- XONLINE_E_MATCH_CRITICAL_DB_ERR\n");
        sb.Append("        GOTO exit_label\n");
        sb.Append("    END\n");
        sb.Append("\n");
        sb.Append("    IF @rowcount_var = 0\n");
        sb.Append("    BEGIN\n");
        sb.Append("        SET @i_return_code = 0x80155100  -- XONLINE_E_MATCH_INVALID_SESSION_ID\n");
        sb.Append("        GOTO exit_label\n");
        sb.Append("    END\n");
        sb.Append("\n");


        
        sb.Append("        end\n");       
        sb.Append("        else\n");
        sb.Append("        if(@ti_breadcrumb_state = 2)\n");
        sb.Append("        begin\n");
        sb.Append("            -- just update the breadcrumb state (no update of data)\n");
        sb.Append("            UPDATE dbo." + strTableName + " SET ti_breadcrumb_state = 3\n");
        sb.Append("                WHERE bi_session_id = @bi_session_id \n"); 
        sb.Append("        end\n");               
        sb.Append("        else\n");
        sb.Append("        begin\n");
        sb.Append("            SET @i_return_code = 0x80155115  -- XONLINE_E_MATCH_CRITICAL_DB_ERR\n");
        sb.Append("            GOTO exit_label\n");
        sb.Append("        end\n");       
        sb.Append("    end\n");       

    }


    private static string InsertProcName(MatchGameConfig matchGameConfig)
    {
        return "p_match_session_v2_0x" + matchGameConfig.TitleId.ToString("X8")
            + "_insert";
    }

    public static string VersionString
    {
        get
        {
            return Assembly.GetExecutingAssembly().GetName().Version.ToString();
        }
    }

    public static string[] UpdateProc(MatchGameConfig matchGameConfig)
    {
        string rankedTableName = RankedTableName(matchGameConfig);
        string standardTableName = StandardTableName(matchGameConfig);
        string procName = UpdateProcName(matchGameConfig);
        string[] sqlStatements = new string[3];

        string msg = "Generating sql statements for proc " + procName;
        Log(msg);

        StringBuilder sb = new StringBuilder();

        sb.Append("IF NOT EXISTS (SELECT name FROM dbo.sysobjects WHERE type = 'p' AND name = '" + procName + "')\n");
        sb.Append("BEGIN\n");
        sb.Append("    EXEC('create procedure dbo." + procName + " as raiserror(''Empty Stored Procedure!!'', 16, 1) with seterror')\n");
        sb.Append("    IF (@@error != 0)\n");
        sb.Append("    BEGIN\n");
        sb.Append("        PRINT 'FAILED to create "+ procName + "'\n");
        sb.Append("    END\n");
        sb.Append("END\n");

        // make the newlines in the string Windows style
        sb.Replace("\n", "\r\n");

        sqlStatements[0] = sb.ToString();

        sb = new StringBuilder();

        sb.Append("ALTER PROCEDURE [dbo].[" + procName + "]\n");
        sb.Append("     @bi_session_id                 bigint\n");
        sb.Append("    ,@i_public_available            int\n");
        sb.Append("    ,@i_private_available           int\n");
        sb.Append("    ,@i_public_current              int\n");
        sb.Append("    ,@i_private_current             int\n");
        sb.Append("    ,@dt_session_expire             datetime\n");
        sb.Append("    ,@ti_target_rowtype             tinyint\n");

        // built in attributes not listed in xlast but added to all schemas
        //
        // Some attributes are accepted as parameters but not updated. The attributes ride along
        // with the request and do not cause issues with the update call and are eventually logged.
        sb.Append("    ,@" + AttributeName(MatchDefs.X_ATTRIBUTE_GAME_TYPE)
            + "                " + IdToSqlType(MatchDefs.X_ATTRIBUTE_GAME_TYPE) + " = NULL\n");
        sb.Append("    ,@" + AttributeName(MatchDefs.X_ATTRIBUTE_GAME_MODE)
            + "                " + IdToSqlType(MatchDefs.X_ATTRIBUTE_GAME_MODE) + " = NULL\n");
        sb.Append("    ,@" + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_ZONE)
            + "                " + IdToSqlType(MatchDefs.X_ATTRIBUTE_GAMER_ZONE) + " = NULL\n");
        sb.Append("    ,@" + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_COUNTRY)
            + "                " + IdToSqlType(MatchDefs.X_ATTRIBUTE_GAMER_COUNTRY) + " = NULL\n");
        sb.Append("    ,@" + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_LANGUAGE)
            + "                " + IdToSqlType(MatchDefs.X_ATTRIBUTE_GAMER_LANGUAGE) + " = NULL\n");
        sb.Append("    ,@" + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_RATING)
            + "                " + IdToSqlType(MatchDefs.X_ATTRIBUTE_GAMER_RATING) + " = NULL\n");
        sb.Append("    ,@" + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_MU)
            + "                " + IdToSqlType(MatchDefs.X_ATTRIBUTE_GAMER_MU) + " = NULL\n");
        sb.Append("    ,@" + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_SIGMA)
            + "                " + IdToSqlType(MatchDefs.X_ATTRIBUTE_GAMER_SIGMA) + " = NULL\n");
        sb.Append("    ,@" + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_PUID)
            + "                " + IdToSqlType(MatchDefs.X_ATTRIBUTE_GAMER_PUID) + " = NULL\n");
        sb.Append("    ,@" + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_HOSTNAME)
            + "                " + IdToSqlType(MatchDefs.X_ATTRIBUTE_GAMER_HOSTNAME) + " = NULL\n");
        sb.Append("    ,@" + AttributeName(MatchDefs.X_ATTRIBUTE_PLATFORM_TYPE)
            + "                " + IdToSqlType(MatchDefs.X_ATTRIBUTE_PLATFORM_TYPE) + " = NULL\n");
        sb.Append("    ,@" + AttributeName(MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK)
            + "                " + IdToSqlType(MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK) + " = NULL\n");

        // title defined schema attributes
        foreach (MatchSchemaAttribute a in matchGameConfig.MatchSchema)
        {
            if (!MatchDefs.IsSystemAttribute(a.Id))
            {
                sb.Append("    ,@" + AttributeName(a.Id) + "                "
                    + IdToSqlType(a.Id) + " = NULL\n");
            }
        }

        sb.Append("AS\n");
        sb.Append("-- Match Code Generator Version - !!Version=" + VersionString + "\n");
        sb.Append("-- Xlast (XDK) Version = " + matchGameConfig.XlastVersion + "\n");
        sb.Append("-- Xlast Project Version = " + matchGameConfig.ProjectVersion + "\n");
        sb.Append("BEGIN\n");
        sb.Append("    DECLARE\n");
        sb.Append("        @error_var                 int\n");
        sb.Append("        ,@rowcount_var              int\n");
        sb.Append("        ,@ti_is_available           tinyint\n");
		sb.Append("        ,@bi_current_type			bigint\n");
		sb.Append("        ,@bi_current_mode			bigint\n");
		sb.Append("        ,@ti_current_bc_state		tinyint\n");
		sb.Append("        ,@dt_lock_expire			datetime\n");
		sb.Append("        ,@i_return_code					int\n");
		sb.Append("        ,@ti_partition_changed		tinyint\n");
		sb.Append("        ,@ti_remote_data			tinyint\n");
        sb.Append("        ,@i_sw_bucket			int\n");
        sb.Append("        ,@dt_deletion_time			datetime\n");
        sb.Append("\n");
        sb.Append("    SET nocount on\n");
        sb.Append("\n");
        sb.Append("SET @i_return_code = 0\n");
        sb.Append("SET @ti_remote_data = 0\n");
        sb.Append("\n");
        sb.Append("-- get some useful info about this session from the appropriate table.\n");
        sb.Append("if ((@bi_session_id & 0x0000000000000300) = 0)\n");
        sb.Append("begin\n");
        sb.Append("    SELECT @dt_lock_expire = dt_lock_expire, \n");
        sb.Append("        @ti_current_bc_state = ti_breadcrumb_state,\n");
        sb.Append("        @bi_current_type = att_0x0000800A,\n");
        sb.Append("        @bi_current_mode = att_0x0000800B,\n");
        sb.Append("        @dt_deletion_time = dt_deletion_time,\n");
        sb.Append("        @i_sw_bucket = i_sw_bucket\n");
        sb.Append("    FROM dbo." + rankedTableName + "\n");
        sb.Append("    WHERE bi_session_id = @bi_session_id \n");
        sb.Append("end\n");
        sb.Append("else\n");
        sb.Append("begin\n");
        sb.Append("    SELECT @dt_lock_expire = dt_lock_expire,\n");
        sb.Append("        @ti_current_bc_state = ti_breadcrumb_state,\n");
        sb.Append("        @bi_current_type = att_0x0000800A,\n");
        sb.Append("        @bi_current_mode = att_0x0000800B,\n");
        sb.Append("        @dt_deletion_time = dt_deletion_time,\n");
        sb.Append("        @i_sw_bucket = i_sw_bucket\n");
        sb.Append("    FROM dbo." + standardTableName + "\n");
        sb.Append("    WHERE bi_session_id = @bi_session_id\n");
        sb.Append("end\n");
        sb.Append("\n");

        sb.Append("-- check if the session has been marked for deletion.  Return failure.\n");
        sb.Append("if(@dt_deletion_time IS NOT NULL)\n");
        sb.Append("begin\n");
        sb.Append("    SET @i_return_code = 0x80155100  -- XONLINE_E_MATCH_INVALID_SESSION_ID\n");
        sb.Append("    goto exit_label\n");
        sb.Append("end\n");
        sb.Append("\n");
        sb.Append("-- check whether the row we're updating is the desired type.\n");
        sb.Append("-- This is intentionally done before the lock check, because the type_mismatch error is more informative.\n");
        sb.Append("if ((@ti_target_rowtype = 1 and @ti_current_bc_state = 2)\n");
        sb.Append("    OR (@ti_target_rowtype = 2 and @ti_current_bc_state = 1))\n");
        sb.Append("begin\n");
        sb.Append("    set @i_return_code = 0x80155128 -- XONLINE_E_MATCH_SESSION_TYPE_MISMATCH\n");
        sb.Append("    goto exit_label\n");
        sb.Append("end\n");
        sb.Append("\n");
        sb.Append("-- check the lock status.  If locked, return failure.\n");
        sb.Append("if (@dt_lock_expire IS NOT NULL and\n");
        sb.Append("    GETUTCDATE() < @dt_lock_expire and\n");
        sb.Append("    @ti_target_rowtype != 2) -- don't check lock when updating sandwich, because breadcrumb is the gatekeeper\n");
        sb.Append("begin\n");
        sb.Append("    set @i_return_code = 0x80155127 -- XONLINE_E_MATCH_CONCURRENT_REQ_CONFLICT\n");
        sb.Append("    goto exit_label\n");
        sb.Append("end\n");
        sb.Append("\n");
        sb.Append("-- if mode changed, give the FD a hint.  Note that type cannot change.\n");
        sb.Append("set @ti_partition_changed = 0\n");
        sb.Append("if (@att_0x0000800B IS NOT NULL AND @att_0x0000800B <> @bi_current_mode)\n");
        sb.Append("begin\n");
        sb.Append("    set @ti_partition_changed = 1\n");
        sb.Append("end\n");
        sb.Append("\n");
        sb.Append("-- only set the lock if we might be modifying the row on some\n");
        sb.Append("-- other server.  At the same time, set the remote data hint\n");
        sb.Append("-- that we'll return\n");
        sb.Append("if ((@ti_current_bc_state = 1 AND @i_sw_bucket IS NOT NULL) OR\n");
        sb.Append("    @ti_partition_changed > 0)\n");
        sb.Append("BEGIN\n");
        sb.Append("    -- TODOTHEOM: const for the lock time\n");
        sb.Append("    set @ti_remote_data = 1\n");
        sb.Append("    set @dt_lock_expire = DATEADD(second, 1, GETUTCDATE())\n");
        sb.Append("END\n");
        sb.Append("\n");

        // mu is supposed to be in the range 0 to 6, and the search algorithms
        // rely on that fact. If for some reason a mu out of range
        // has been supplied, peg it to one end of the range.
        sb.Append("-- make sure params are within acceptable ranges\n");
        sb.Append("    if (@" + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_MU) + " IS NOT NULL and @"
            + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_MU) + " > 6.0)\n");
        sb.Append("        set @" + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_MU) +" = 6.0\n");
        sb.Append("    else if (@" + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_MU) + " IS NOT NULL and @"
            + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_MU) + " < 0.0)\n");
        sb.Append("        set @" + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_MU) +" = 0.0\n");
        sb.Append("\n");

        // sigma is supposed to be in the range 0 to 1, while the search algorithm doesn't
        // strictly rely on this fact, we should enforce it anyway. If for some reason a 
        // sigma out of range has been supplied, peg it to one end of the range.
        sb.Append("    if (@" + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_SIGMA) + " IS NOT NULL and @"
            + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_SIGMA) + " > 1.0)\n");
        sb.Append("        set @" + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_SIGMA) +" = 1.0\n");
        sb.Append("    else if (@" + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_SIGMA) + " IS NOT NULL and @"
            + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_SIGMA) + " < 0.0)\n");
        sb.Append("        set @" + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_SIGMA) +" = 0.0\n");
        sb.Append("\n");

        // rating is supposed to be in the range 0 to 100, and the search algorithms
        // rely on that fact. If for some reason a rating out of range
        // has been supplied, peg it to one end of the range.
        sb.Append("    if (@" + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_RATING) + " IS NOT NULL and @"
            + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_RATING) + " > 100.0)\n");
        sb.Append("        set @" + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_RATING) +" = 100.0\n");
        sb.Append("    else if (@" + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_RATING) + " IS NOT NULL and @"
            + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_RATING) + " < 0.0)\n");
        sb.Append("        set @" + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_RATING) +" = 0.0\n");
        sb.Append("\n");

        sb.Append("    --\n");
        sb.Append("    --  Update the session\n");
        sb.Append("    --\n");
        sb.Append("    SET @ti_is_available = CASE WHEN @i_public_available > 0 THEN 1 ELSE 0 END\n");
        sb.Append("\n");
        sb.Append("    if ((@bi_session_id & 0x0000000000000300) = 0)\n");
        sb.Append("    begin\n");
        sb.Append("        if (@" + AttributeName(MatchDefs.X_ATTRIBUTE_GAME_TYPE) + " IS NOT NULL and @" 
            + AttributeName(MatchDefs.X_ATTRIBUTE_GAME_TYPE) + " != 0)\n");
        sb.Append("        begin\n");
        sb.Append("            set @i_return_code = 0x80155119 -- XONLINE_E_MATCH_INVALID_PARAM\n");
        sb.Append("            goto exit_label\n");
        sb.Append("        end\n");
        sb.Append("        UPDATE dbo." + rankedTableName + " SET\n");
        sb.Append("             i_public_available = @i_public_available\n");
        sb.Append("            ,i_private_available = @i_private_available\n");
        sb.Append("            ,i_public_current = @i_public_current\n");
        sb.Append("            ,i_private_current = @i_private_current\n");
        sb.Append("            ,dt_session_expiration = @dt_session_expire\n");
        sb.Append("            ,ti_is_available = @ti_is_available\n");
        sb.Append("            ,dt_lock_expire =  @dt_lock_expire\n");
        sb.Append("            ," + AttributeName(MatchDefs.X_ATTRIBUTE_GAME_MODE)
            + " = ISNULL(@" + AttributeName(MatchDefs.X_ATTRIBUTE_GAME_MODE)
            + ", " + AttributeName(MatchDefs.X_ATTRIBUTE_GAME_MODE) + ")\n");
        sb.Append("            ," + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_ZONE)
            + " = ISNULL(@" + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_ZONE)
            + ", " + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_ZONE) + ")\n");
        sb.Append("            ," + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_COUNTRY)
            + " = ISNULL(@" + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_COUNTRY)
            + ", " + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_COUNTRY) + ")\n");
        sb.Append("            ," + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_LANGUAGE)
            + " = ISNULL(@" + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_LANGUAGE)
            + ", " + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_LANGUAGE) + ")\n");
        sb.Append("            ," + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_RATING)
            + " = ISNULL(@" + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_RATING)
            + ", " + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_RATING) + ")\n");
        sb.Append("            ," + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_MU)
            + " = ISNULL(@" + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_MU)
            + ", " + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_MU) + ")\n");
        sb.Append("            ," + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_SIGMA)
            + " = ISNULL(@" + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_SIGMA)
            + ", " + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_SIGMA) + ")\n");
        sb.Append("            ," + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_PUID)
            + " = ISNULL(@" + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_PUID)
            + ", " + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_PUID) + ")\n");
        sb.Append("            ," + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_HOSTNAME)
            + " = ISNULL(@" + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_HOSTNAME)
            + ", " + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_HOSTNAME) + ")\n");
        sb.Append("            ," + AttributeName(MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK)
            + " = ISNULL(@" + AttributeName(MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK)
            + ", " + AttributeName(MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK) + ")\n");

        foreach (MatchSchemaAttribute a in matchGameConfig.MatchSchema)
        {
            if (!MatchDefs.IsSystemAttribute(a.Id))
            {
                sb.Append("            ," + AttributeName(a.Id)
                    + " = ISNULL(@" + AttributeName(a.Id) + ", " + AttributeName(a.Id) + ")\n");
            }
        }

        sb.Append("            WHERE bi_session_id = @bi_session_id\n");
        sb.Append("        SELECT @error_var = @@ERROR, @rowcount_var = @@ROWCOUNT\n");
        sb.Append("    end\n");
        sb.Append("    else\n");
        sb.Append("    begin\n");
        sb.Append("        if (@" + AttributeName(MatchDefs.X_ATTRIBUTE_GAME_TYPE) + " IS NOT NULL and @" 
            + AttributeName(MatchDefs.X_ATTRIBUTE_GAME_TYPE) + " != 1)\n");
        sb.Append("        begin\n");
        sb.Append("            set @i_return_code = 0x80155119 -- XONLINE_E_MATCH_INVALID_PARAM\n");
        sb.Append("            goto exit_label\n");
        sb.Append("        end\n");
        sb.Append("        UPDATE dbo." + standardTableName + " SET\n");
        sb.Append("             i_public_available = @i_public_available\n");
        sb.Append("            ,i_private_available = @i_private_available\n");
        sb.Append("            ,i_public_current = @i_public_current\n");
        sb.Append("            ,i_private_current = @i_private_current\n");
        sb.Append("            ,dt_session_expiration = @dt_session_expire\n");
        sb.Append("            ,ti_is_available = @ti_is_available\n");
        sb.Append("            ,dt_lock_expire =  @dt_lock_expire\n");
        sb.Append("            ," + AttributeName(MatchDefs.X_ATTRIBUTE_GAME_MODE)
            + " = ISNULL(@" + AttributeName(MatchDefs.X_ATTRIBUTE_GAME_MODE)
            + ", " + AttributeName(MatchDefs.X_ATTRIBUTE_GAME_MODE) + ")\n");
        sb.Append("            ," + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_ZONE)
            + " = ISNULL(@" + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_ZONE)
            + ", " + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_ZONE) + ")\n");
        sb.Append("            ," + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_COUNTRY)
            + " = ISNULL(@" + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_COUNTRY)
            + ", " + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_COUNTRY) + ")\n");
        sb.Append("            ," + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_LANGUAGE)
            + " = ISNULL(@" + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_LANGUAGE)
            + ", " + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_LANGUAGE) + ")\n");
        sb.Append("            ," + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_RATING)
            + " = ISNULL(@" + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_RATING)
            + ", " + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_RATING) + ")\n");
        sb.Append("            ," + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_MU)
            + " = ISNULL(@" + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_MU)
            + ", " + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_MU) + ")\n");
        sb.Append("            ," + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_SIGMA)
            + " = ISNULL(@" + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_SIGMA)
            + ", " + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_SIGMA) + ")\n");
        sb.Append("            ," + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_HOSTNAME)
            + " = ISNULL(@" + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_HOSTNAME)
            + ", " + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_HOSTNAME) + ")\n");
        sb.Append("            ," + AttributeName(MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK)
            + " = ISNULL(@" + AttributeName(MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK)
            + ", " + AttributeName(MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK) + ")\n");

        foreach (MatchSchemaAttribute a in matchGameConfig.MatchSchema)
        {
            if (!MatchDefs.IsSystemAttribute(a.Id))
            {
                sb.Append("            ," + AttributeName(a.Id)
                    + " = ISNULL(@" + AttributeName(a.Id) + ", " + AttributeName(a.Id) + ")\n");
            }
        }

        sb.Append("            WHERE bi_session_id = @bi_session_id\n");
        sb.Append("        SELECT @error_var = @@ERROR, @rowcount_var = @@ROWCOUNT\n");
        sb.Append("    end\n");
        sb.Append("\n");
        sb.Append("\n");
        sb.Append("    IF @error_var != 0\n");
        sb.Append("    BEGIN\n");
        sb.Append("        SET @i_return_code = 0x80155115  -- XONLINE_E_MATCH_CRITICAL_DB_ERR\n");
        sb.Append("        GOTO exit_label\n");
        sb.Append("    END\n");
        sb.Append("\n");
        sb.Append("    IF @rowcount_var = 0\n");
        sb.Append("    BEGIN\n");
        sb.Append("        SET @i_return_code = 0x80155100  -- XONLINE_E_MATCH_INVALID_SESSION_ID\n");
        sb.Append("        GOTO exit_label\n");
        sb.Append("    END\n");
        sb.Append("\n");

        sb.Append("-- grab the row we just updated, to return to the FD\n");
        sb.Append("if ((@bi_session_id & 0x0000000000000300) = 0)\n");
        sb.Append("begin\n");
        EmitReturnRowSql(ref sb, rankedTableName, matchGameConfig);
        sb.Append("end\n");
        sb.Append("else\n");
        sb.Append("begin\n");
        EmitReturnRowSql(ref sb, standardTableName, matchGameConfig);
        sb.Append("end\n");
        sb.Append("\n");
        sb.Append("    RETURN\n");
        sb.Append("\n");
        sb.Append("exit_label:\n");
        sb.Append("    IF @error_var != 0\n");
        sb.Append("    BEGIN\n");
        sb.Append("        DECLARE @message varchar(255)\n");
        sb.Append("        SELECT @message = 'XMATCH_SESSION_UPDATE_FAILED: " + procName
            + " - ' + CAST(CAST(CAST(@error_var AS binary(4)) AS int) AS varchar(64))\n");
        sb.Append("        EXEC master.dbo.xp_logevent 51710, @message, error\n");
        sb.Append("    END\n");
        sb.Append("    SELECT @i_return_code as i_return_code\n");
        sb.Append("    RETURN\n");
        sb.Append("END\n");

        // make the newlines in the string Windows style
        sb.Replace("\n", "\r\n");

        sqlStatements[1] = sb.ToString();

        sqlStatements[2] = "GRANT EXECUTE ON " + procName + " TO ClientLib\r\n";

        Log("Generated " + sqlStatements.Length + " sql statements for proc " + procName);

        return sqlStatements;
    }

    private static string UpdateProcName(MatchGameConfig matchGameConfig)
    {
        return "p_match_session_v2_0x" + matchGameConfig.TitleId.ToString("X8")
            + "_update";
    }

    // helper to emit the select statement which returns all columns in the modified row
    private static void EmitReturnRowSql(ref StringBuilder sb, 
                                                    string strTableName, 
                                                    MatchGameConfig matchGameConfig)
    {
        sb.Append("    SELECT TOP 1 @i_return_code as i_return_code\n");
        sb.Append("    ,@ti_remote_data as ti_remote_data\n");
        sb.Append("    ,@ti_partition_changed as ti_partition_changed\n");
        sb.Append("    ,bi_session_id\n");
        sb.Append("    ,i_ip_addr\n");
        sb.Append("    ,i_sg_ip\n");
        sb.Append("    ,b_box_id\n");
        sb.Append("    ,b_host_address\n");
        sb.Append("    ,b_key_exchange_key\n");
        sb.Append("    ,i_public_available\n");
        sb.Append("    ,i_private_available\n");
        sb.Append("    ,i_public_current\n");
        sb.Append("    ,i_private_current\n");
        sb.Append("    ,dt_session_expiration\n");
        sb.Append("    ,ti_is_available\n");
        sb.Append("    ,i_hash\n");
        sb.Append("    ,ti_nat_type\n");
        sb.Append("    ,dt_deletion_time\n");
        sb.Append("    ,i_sw_bucket\n");
        sb.Append("    ,ti_breadcrumb_state\n");
        sb.Append("    ,dt_lock_expire\n");
        sb.Append("    ," + AttributeName(MatchDefs.X_ATTRIBUTE_GAME_TYPE) + "\n");
        sb.Append("    ," + AttributeName(MatchDefs.X_ATTRIBUTE_GAME_MODE) + "\n");
        sb.Append("    ," + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_ZONE) + "\n");
        sb.Append("    ," + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_COUNTRY) + "\n");
        sb.Append("    ," + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_LANGUAGE) + "\n");
        sb.Append("    ," + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_RATING) + "\n");
        sb.Append("    ," + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_MU) + "\n");
        sb.Append("    ," + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_SIGMA) + "\n");
        sb.Append("    ," + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_PUID) + "\n");
        sb.Append("    ," + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_HOSTNAME) + "\n");
        sb.Append("    ," + AttributeName(MatchDefs.X_ATTRIBUTE_PLATFORM_TYPE) + "\n");
        sb.Append("    ," + AttributeName(MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK) + "\n");

        foreach (MatchSchemaAttribute a in matchGameConfig.MatchSchema)
        {
            if (!MatchDefs.IsSystemAttribute(a.Id))
            {
                sb.Append("    ," + AttributeName(a.Id) + "\n");
            }
        }
        sb.Append("    from " + strTableName + "\n");
        sb.Append("    WHERE bi_session_id = @bi_session_id\n");
    }

   public static string[] UpdateCompleteProc(MatchGameConfig matchGameConfig)
    {
        string rankedTableName = RankedTableName(matchGameConfig);
        string standardTableName = StandardTableName(matchGameConfig);
        string procName = UpdateCompleteProcName(matchGameConfig);
        string[] sqlStatements = new string[3];

        string msg = "Generating sql statements for proc " + procName;
        Log(msg);

        StringBuilder sb = new StringBuilder();

        sb.Append("IF NOT EXISTS (SELECT name FROM dbo.sysobjects WHERE type = 'p' AND name = '" + procName + "')\n");
        sb.Append("BEGIN\n");
        sb.Append("    EXEC('create procedure dbo." + procName + " as raiserror(''Empty Stored Procedure!!'', 16, 1) with seterror')\n");
        sb.Append("    IF (@@error != 0)\n");
        sb.Append("    BEGIN\n");
        sb.Append("        PRINT 'FAILED to create "+ procName + "'\n");
        sb.Append("    END\n");
        sb.Append("END\n");

        // make the newlines in the string Windows style
        sb.Replace("\n", "\r\n");

        sqlStatements[0] = sb.ToString();

        sb = new StringBuilder();

        sb.Append("ALTER PROCEDURE [dbo].[" + procName + "]\n");
        sb.Append("     @bi_session_id                 bigint\n");
        sb.Append("    ,@i_sw_bucket                   int = NULL -- default to NULL, to indicate there is no sandwich\n");
        sb.Append("    ,@ti_breadcrumb_state           tinyint\n");
        sb.Append("AS\n");
        sb.Append("BEGIN\n");
        sb.Append("\n");
        sb.Append("    SET nocount on\n");
        sb.Append("\n");
        sb.Append("    DECLARE\n");
        sb.Append("         @i_return_code             int\n");
        sb.Append("        ,@error_var                 int\n");
        sb.Append("        ,@rowcount_var              int\n");
        sb.Append("\n");   
        sb.Append("    if ((@bi_session_id & 0x0000000000000300) = 0)\n");
        sb.Append("    begin\n");
        sb.Append("        if(@ti_breadcrumb_state = 0) -- if the FD didn't know what the BC state should be, just use what we've got.\n");
        sb.Append("        begin\n");
        sb.Append("            SELECT @ti_breadcrumb_state = ti_breadcrumb_state from dbo." + rankedTableName + "\n");
        sb.Append("            WHERE bi_session_id = @bi_session_id AND ti_breadcrumb_state != 2\n");
        sb.Append("        end\n");
        sb.Append("        UPDATE dbo." + rankedTableName + " SET\n");
        sb.Append("            i_sw_bucket = @i_sw_bucket\n");
        sb.Append("            ,dt_lock_expire =  NULL\n");
        sb.Append("            ,ti_breadcrumb_state = @ti_breadcrumb_state\n");
        sb.Append("        WHERE bi_session_id = @bi_session_id\n");
        sb.Append("            AND dt_deletion_time IS NULL -- we want to fail if the row's been marked for delete.\n");
        sb.Append("            AND ti_breadcrumb_state != 2 -- we want to fail if the row that's here is not a breadcrumb.\n");
        sb.Append("    end\n");
        sb.Append("    else\n");
        sb.Append("    begin\n");
        sb.Append("        if(@ti_breadcrumb_state = 0) -- if the FD didn't know what the BC state should be, just use what we've got.\n");
        sb.Append("        begin\n");
        sb.Append("            SELECT @ti_breadcrumb_state = ti_breadcrumb_state from dbo." + standardTableName + "\n");
        sb.Append("            WHERE bi_session_id = @bi_session_id AND ti_breadcrumb_state != 2\n");
        sb.Append("        end\n");        
        sb.Append("        UPDATE dbo." + standardTableName + " SET\n");
        sb.Append("            i_sw_bucket = @i_sw_bucket\n");
        sb.Append("            ,dt_lock_expire =  NULL\n");
        sb.Append("            ,ti_breadcrumb_state = @ti_breadcrumb_state\n");
        sb.Append("        WHERE bi_session_id = @bi_session_id\n");
        sb.Append("            AND dt_deletion_time IS NULL -- we want to fail if the row's been marked for delete.\n");
        sb.Append("            AND ti_breadcrumb_state != 2 -- we want to fail if the row that's here is not a breadcrumb.\n");
        sb.Append("    end\n");
        sb.Append("\n");
        sb.Append("    SELECT @error_var = @@ERROR, @rowcount_var = @@ROWCOUNT\n");
        sb.Append("\n");
        sb.Append("    IF @error_var != 0\n");
        sb.Append("    BEGIN\n");
        sb.Append("        SET @i_return_code = 0x80155115  -- XONLINE_E_MATCH_CRITICAL_DB_ERR\n");
        sb.Append("        GOTO exit_label\n");
        sb.Append("    END\n");
        sb.Append("\n");
        sb.Append("    IF @rowcount_var = 0\n");
        sb.Append("    BEGIN\n");
        sb.Append("        SET @i_return_code = 0x80155100  -- XONLINE_E_MATCH_INVALID_SESSION_ID\n");
        sb.Append("        GOTO exit_label\n");
        sb.Append("    END\n");
        sb.Append("\n");
	    sb.Append("    RETURN 0\n");

        sb.Append("exit_label:\n");
        sb.Append("IF @error_var != 0\n");
        sb.Append("BEGIN\n");
        sb.Append("    DECLARE @message varchar(255)\n");
        sb.Append("    SELECT @message = 'XMATCH_SESSION_UPDATECOMPLETE_FAILED: " + procName + " - ' + CAST(CAST(CAST(@error_var AS binary(4)) AS int) AS varchar(64))\n");
        sb.Append("    EXEC master.dbo.xp_logevent 51710, @message, error\n");
        sb.Append("END\n");

	    sb.Append("RETURN @i_return_code\n");
        sb.Append("END\n");

        // make the newlines in the string Windows style
        sb.Replace("\n", "\r\n");

        sqlStatements[1] = sb.ToString();

        sqlStatements[2] = "GRANT EXECUTE ON " + procName + " TO ClientLib\r\n";

        Log("Generated " + sqlStatements.Length + " sql statements for proc " + procName);

        return sqlStatements;
    }


    private static string UpdateCompleteProcName(MatchGameConfig matchGameConfig)
    {
        return "p_match_session_v2_0x" + matchGameConfig.TitleId.ToString("X8")
            + "_updatecomplete";
    }

    public static string[] DeleteProc(MatchGameConfig matchGameConfig)
    {
        string rankedTableName = RankedTableName(matchGameConfig);
        string standardTableName = StandardTableName(matchGameConfig);
        string procName = DeleteProcName(matchGameConfig);
        string[] sqlStatements = new string[3];

        string msg = "Generating sql statements for proc " + procName;
        Log(msg);

        StringBuilder sb = new StringBuilder();

        sb.Append("IF NOT EXISTS (SELECT name FROM dbo.sysobjects WHERE type = 'p' AND name = '" + procName + "')\n");
        sb.Append("BEGIN\n");
        sb.Append("    EXEC('create procedure dbo." + procName + " as raiserror(''Empty Stored Procedure!!'', 16, 1) with seterror')\n");
        sb.Append("    IF (@@error != 0)\n");
        sb.Append("    BEGIN\n");
        sb.Append("        PRINT 'FAILED to create " + procName + "'\n");
        sb.Append("    END\n");
        sb.Append("END\n");

        // make the newlines in the string Windows style
        sb.Replace("\n", "\r\n");

        sqlStatements[0] = sb.ToString();

        sb = new StringBuilder();

        sb.Append("ALTER PROCEDURE [dbo].[" + procName + "]\n");
        sb.Append("     @i_sw_bucket                    int OUTPUT,\n");
        sb.Append("     @bi_session_id                  bigint,\n");
        sb.Append("     @i_delete_delay_seconds         int = 0,\n");
        sb.Append("     @ti_target_rowtype             tinyint\n");        
        sb.Append("AS\n");
        sb.Append("-- Match Code Generator Version - !!Version=" + VersionString + "\n");
        sb.Append("-- Xlast (XDK) Version = " + matchGameConfig.XlastVersion + "\n");
        sb.Append("-- Xlast Project Version = " + matchGameConfig.ProjectVersion + "\n");
        sb.Append("BEGIN\n");
        sb.Append("    DECLARE\n");
        sb.Append("         @i_return_code             int\n");
        sb.Append("        ,@error_var                 int\n");
        sb.Append("        ,@rowcount_var              int\n");
        sb.Append("        ,@ti_breadcrumb_state       tinyint\n");
	sb.Append("        ,@dt_current_time           datetime\n");
	sb.Append("        ,@f_hasSession             bit\n");
        sb.Append("\n");
        sb.Append("    SET nocount on\n");
        sb.Append("\n");
        sb.Append("    --pre-fetch a value for current time, so that we don't have to\n");
        sb.Append("    --do this once for each row in the delete statement.");
        sb.Append("    --TODOTHEOM: later this should become a param passed by the FD.\n");
        sb.Append("    SELECT @dt_current_time = GETUTCDATE()\n");
        sb.Append("\n");
        sb.Append("    --\n");
        sb.Append("    --  Delete the session based on game type\n");
        sb.Append("    --\n");
        sb.Append("    if ((@bi_session_id & 0x0000000000000300) = 0)\n");
        sb.Append("    begin\n");
        sb.Append("        -- find out whether the session is breadcrumbed... if so then return\n");
        sb.Append("        -- i_sw_bucket in @i_sw_bucket\n");
        sb.Append("        SELECT @ti_breadcrumb_state = ti_breadcrumb_state,\n");
        sb.Append("            @i_sw_bucket = i_sw_bucket\n");
        sb.Append("            FROM dbo." + rankedTableName + "\n");
        sb.Append("                WHERE bi_session_id = @bi_session_id\n");
        sb.Append("        \n");
        sb.Append("        -- Delete means different things depending on the breadcrumb state and target_rowtype.\n");
        sb.Append("        -- BUG XONLINE:108894 -- @ti_target_rowtype == 3 is a new one, which we're introducing\n");
        sb.Append("        -- to tell the stored proc 'you can delete both the breadcrumb and sandwich, if they\n");
        sb.Append("        -- are in the same row.'\n");
        sb.Append("        if((@ti_target_rowtype = 3 AND @ti_breadcrumb_state != 2)\n");
        sb.Append("            OR @ti_target_rowtype = @ti_breadcrumb_state)\n");
        sb.Append("        begin\n");
        sb.Append("            -- if we're deleting bc and sw in one fell swoop, don't return the i_sw_bucket\n");
        sb.Append("            if(@ti_target_rowtype = 3 AND @ti_breadcrumb_state = 3)\n");
        sb.Append("            begin\n");
        sb.Append("                set @i_sw_bucket = NULL\n");
        sb.Append("            end\n");
        sb.Append("            -- Only process deferred deletion if delay time is specified\n");
        sb.Append("            if(@i_delete_delay_seconds = 0)\n");
        sb.Append("            begin\n");
        sb.Append("                DELETE dbo." + rankedTableName + " WHERE bi_session_id = @bi_session_id\n");
        sb.Append("            end\n");
        sb.Append("            else\n");
        sb.Append("            begin\n");
	sb.Append("                -- pre-check to see how many sessions we have to delete.  If none, don't even get into the delete.\n");
        sb.Append("                -- also optimize the dt_deletion_time clause for the case where there are no rows, to prevent SQL from\n");
        sb.Append("                -- making bad guesses of row count when building the execution plan\n");
        sb.Append("                SELECT top 1 @f_hasSession=1 FROM dbo." + rankedTableName + " WITH (NOLOCK)\n");
        sb.Append("                    WHERE dt_deletion_time < @dt_current_time\n");
        sb.Append("                    OPTION (OPTIMIZE FOR (@dt_current_time = '1900/1/1 12:00:00'))\n");
        sb.Append("                IF(@f_hasSession > 0)\n");
        sb.Append("                BEGIN\n");
        sb.Append("                    DELETE dbo." + rankedTableName + "\n");
        sb.Append("                        WHERE dt_deletion_time < @dt_current_time\n");
        sb.Append("                        OPTION (OPTIMIZE FOR (@dt_current_time = '1900/1/1 12:00:00'))\n");
        sb.Append("                END\n");
        sb.Append("                UPDATE dbo." + rankedTableName + "\n");
        sb.Append("                    SET  dt_deletion_time = DATEADD(second, @i_delete_delay_seconds, GETUTCDATE())\n");
        sb.Append("                        ,ti_is_available = 0\n");
        sb.Append("                    WHERE bi_session_id = @bi_session_id\n");
        sb.Append("            end\n");
        sb.Append("        end\n");
        sb.Append("        else if(@ti_breadcrumb_state = 3)\n");
        sb.Append("        begin\n");
        sb.Append("            -- change the row's breadcrumb state\n");
        sb.Append("            update dbo." + rankedTableName + " SET ti_breadcrumb_state = (3-@ti_target_rowtype)\n");
        sb.Append("            WHERE bi_session_id = @bi_session_id \n");
        sb.Append("        end\n");
        sb.Append("        else\n");
        sb.Append("        begin\n");
        sb.Append("            -- error... can't delete due to mismatched type.\n");
        sb.Append("            SET @i_return_code = 0x80155128 -- XONLINE_E_MATCH_SESSION_TYPE_MISMATCH\n");
        sb.Append("            GOTO exit_label\n");
        sb.Append("        end\n");
        sb.Append("        \n");
        sb.Append("    end\n");
        sb.Append("    else\n");
        sb.Append("    begin\n");
        sb.Append("        -- find out whether the session is breadcrumbed... if so then return\n");
        sb.Append("        -- i_sw_bucket in @i_sw_bucket\n");
        sb.Append("        SELECT @ti_breadcrumb_state = ti_breadcrumb_state,\n");
        sb.Append("            @i_sw_bucket = i_sw_bucket\n");
        sb.Append("            FROM dbo." + standardTableName + "\n");
        sb.Append("                WHERE bi_session_id = @bi_session_id\n");
        sb.Append("        \n");
        sb.Append("        -- Delete means different things depending on the breadcrumb state and target_rowtype.\n");
        sb.Append("        -- BUG XONLINE:108894 -- @ti_target_rowtype == 3 is a new one, which we're introducing\n");
        sb.Append("        -- to tell the stored proc 'you can delete both the breadcrumb and sandwich, if they\n");
        sb.Append("        -- are in the same row.'\n");
        sb.Append("        if((@ti_target_rowtype = 3 AND @ti_breadcrumb_state != 2)\n");
        sb.Append("            OR @ti_target_rowtype = @ti_breadcrumb_state)\n");
        sb.Append("        begin\n");
        sb.Append("            -- if we're deleting bc and sw in one fell swoop, don't return the i_sw_bucket\n");
        sb.Append("            if(@ti_target_rowtype = 3 AND @ti_breadcrumb_state = 3)\n");
        sb.Append("            begin\n");
        sb.Append("                set @i_sw_bucket = NULL\n");
        sb.Append("            end\n");
        sb.Append("            -- Only process deferred deletion if delay time is specified\n");
        sb.Append("            if(@i_delete_delay_seconds = 0)\n");
        sb.Append("            begin\n");
        sb.Append("                DELETE dbo." + standardTableName + " WHERE bi_session_id = @bi_session_id\n");
        sb.Append("            end\n");
        sb.Append("            else\n");
        sb.Append("            begin\n");
        sb.Append("                SELECT top 1 @f_hasSession=1 FROM dbo." + standardTableName + " WITH (NOLOCK)\n");
        sb.Append("                    WHERE dt_deletion_time < @dt_current_time\n");
        sb.Append("                    OPTION (OPTIMIZE FOR (@dt_current_time = '1900/1/1 12:00:00'))\n");
        sb.Append("                IF(@f_hasSession > 0)\n");
        sb.Append("                BEGIN\n");
        sb.Append("                    DELETE dbo." + standardTableName + "\n");
        sb.Append("                        WHERE dt_deletion_time < @dt_current_time\n");
        sb.Append("                        OPTION (OPTIMIZE FOR (@dt_current_time = '1900/1/1 12:00:00'))\n");
        sb.Append("                END\n");
        sb.Append("                UPDATE dbo." + standardTableName + "\n");
        sb.Append("                    SET  dt_deletion_time = DATEADD(second, @i_delete_delay_seconds, GETUTCDATE())\n");
        sb.Append("                        ,ti_is_available = 0\n");
        sb.Append("                    WHERE bi_session_id = @bi_session_id\n");
        sb.Append("            end\n");
        sb.Append("        end\n");
        sb.Append("        else if(@ti_breadcrumb_state = 3)\n");
        sb.Append("        begin\n");
        sb.Append("            -- change the row's breadcrumb state\n");
        sb.Append("            update dbo." + standardTableName + " SET ti_breadcrumb_state = (3-@ti_target_rowtype)\n");
        sb.Append("            WHERE bi_session_id = @bi_session_id \n");
        sb.Append("        end\n");
        sb.Append("        else\n");
        sb.Append("        begin\n");
        sb.Append("            -- error... can't delete due to mismatched type.\n");
        sb.Append("            SET @i_return_code = 0x80155128 -- XONLINE_E_MATCH_SESSION_TYPE_MISMATCH\n");
        sb.Append("            GOTO exit_label\n");
        sb.Append("        end\n");
        sb.Append("    end\n");
        sb.Append("\n");
        sb.Append("    SELECT @error_var = @@ERROR, @rowcount_var = @@ROWCOUNT\n");
        sb.Append("\n");
        sb.Append("    IF @error_var != 0\n");
        sb.Append("    BEGIN\n");
        sb.Append("        SET @i_return_code = 0x80155115  -- XONLINE_E_MATCH_CRITICAL_DB_ERR\n");
        sb.Append("        GOTO exit_label\n");
        sb.Append("    END\n");
        sb.Append("\n");
        sb.Append("    IF @rowcount_var = 0\n");
        sb.Append("    BEGIN\n");
        sb.Append("        SET @i_return_code = 0x80155100 -- XONLINE_E_MATCH_INVALID_SESSION_ID\n");
        sb.Append("        GOTO exit_label\n");
        sb.Append("    END\n");
        sb.Append("\n");
        sb.Append("    RETURN 0\n");
        sb.Append("\n");
        sb.Append("exit_label:\n");
        sb.Append("    IF @error_var != 0\n");
        sb.Append("    BEGIN\n");
        sb.Append("        DECLARE @message varchar(255)\n");
        sb.Append("        SELECT @message = 'XMATCH_SESSION_DELETE_FAILED: " + procName + " - ' + CAST(CAST(CAST(@error_var AS binary(4)) AS int) AS varchar(64))\n");
        sb.Append("        EXEC master.dbo.xp_logevent 51711, @message, error\n");
        sb.Append("    END\n");
        sb.Append("    RETURN @i_return_code\n");
        sb.Append("END\n");

        // make the newlines in the string Windows style
        sb.Replace("\n", "\r\n");

        sqlStatements[1] = sb.ToString();

        sqlStatements[2] = "GRANT EXECUTE ON " + procName + " TO ClientLib\r\n";

        Log("Generated " + sqlStatements.Length + " sql statements for proc " + procName);

        return sqlStatements;
    }

    private static string DeleteProcName(MatchGameConfig matchGameConfig)
    {
        return "p_match_session_v2_0x" + matchGameConfig.TitleId.ToString("X8")
            + "_delete";
    }

    public static string[] DeadXboxProc(MatchGameConfig matchGameConfig)
    {
        string rankedTableName = RankedTableName(matchGameConfig);
        string standardTableName = StandardTableName(matchGameConfig);
        string procName = DeadXboxProcName(matchGameConfig);
        string[] sqlStatements = new string[3];

        string msg = "Generating sql statements for proc " + procName;
        Log(msg);

        StringBuilder sb = new StringBuilder();

        sb.Append("IF NOT EXISTS (SELECT name FROM dbo.sysobjects WHERE type = 'p' AND name = '" + procName + "')\n");
        sb.Append("BEGIN\n");
        sb.Append("    EXEC('create procedure dbo." + procName + " as raiserror(''Empty Stored Procedure!!'', 16, 1) with seterror')\n");
        sb.Append("    IF (@@error != 0)\n");
        sb.Append("    BEGIN\n");
        sb.Append("        PRINT 'FAILED to create " + procName + "'\n");
        sb.Append("    END\n");
        sb.Append("END\n");

        // make the newlines in the string Windows style
        sb.Replace("\n", "\r\n");

        sqlStatements[0] = sb.ToString();

        sb = new StringBuilder();

        sb.Append("ALTER PROCEDURE [dbo].[" + procName + "]\n");
        sb.Append("     @b_box_id                 binary(16),\n");
        sb.Append("     @i_delete_delay_seconds          int = 0\n");
        sb.Append("AS\n");
        sb.Append("-- Match Code Generator Version - !!Version=" + VersionString + "\n");
        sb.Append("-- Xlast (XDK) Version = " + matchGameConfig.XlastVersion + "\n");
        sb.Append("-- Xlast Project Version = " + matchGameConfig.ProjectVersion + "\n");
        sb.Append("BEGIN\n");
        sb.Append("    DECLARE\n");
        sb.Append("         @i_return_code             int\n");
        sb.Append("        ,@error_var                 int\n");
	sb.Append("        ,@dt_current_time           datetime\n");
	sb.Append("        ,@f_hasSession             bit\n");
        sb.Append("\n");
        sb.Append("    SET nocount on\n");
        sb.Append("\n");
        sb.Append("    --pre-fetch a value for current time, so that we don't have to\n");
        sb.Append("    --do this once for each row in the delete statement.");
        sb.Append("    --TODOTHEOM: later this should become a param passed by the FD.\n");
        sb.Append("    SELECT @dt_current_time = GETUTCDATE()\n");
        sb.Append("\n");
        sb.Append("    --\n");
        sb.Append("    --  Delete all sessions in either the ranked or standard table for this box id\n");
        sb.Append("    --  When delay_seconds is 0 the deletion is done directly\n");
        sb.Append("    --  Otherwise all pending deletions are culled and the current session is marked\n");
        sb.Append("    --\n");
        sb.Append("    IF @i_delete_delay_seconds = 0\n");
        sb.Append("    BEGIN\n");
        sb.Append("        DELETE dbo." + rankedTableName + " WHERE b_box_id = @b_box_id\n");
        sb.Append("    END\n");
        sb.Append("    ELSE\n");
        sb.Append("    BEGIN\n");
	sb.Append("        -- pre-check to see how many sessions we have to delete.  If none, don't even get into the delete.\n");
        sb.Append("        -- also optimize the dt_deletion_time clause for the case where there are no rows, to prevent SQL from\n");
        sb.Append("        -- making bad guesses of row count when building the execution plan\n");
        sb.Append("        SELECT top 1 @f_hasSession=1 FROM dbo." + rankedTableName + " WITH (NOLOCK)\n");
        sb.Append("            WHERE dt_deletion_time < @dt_current_time\n");
        sb.Append("            OPTION (OPTIMIZE FOR (@dt_current_time = '1900/1/1 12:00:00'))\n");
        sb.Append("        IF(@f_hasSession > 0)\n");
        sb.Append("        BEGIN\n");
        sb.Append("            DELETE dbo." + rankedTableName + "\n");
        sb.Append("                WHERE dt_deletion_time < @dt_current_time\n");
        sb.Append("                OPTION (OPTIMIZE FOR (@dt_current_time = '1900/1/1 12:00:00'))\n");
        sb.Append("        END\n");
        sb.Append("        UPDATE dbo." + rankedTableName + "\n");
        sb.Append("            SET   dt_deletion_time = DATEADD(second, @i_delete_delay_seconds, GETUTCDATE())\n");
        sb.Append("                 ,ti_is_available = 0\n");
        sb.Append("            WHERE b_box_id = @b_box_id\n");
        sb.Append("    END\n");
        sb.Append("\n");
        sb.Append("    SELECT @error_var = @@ERROR\n");
        sb.Append("\n");
        sb.Append("    IF @error_var != 0\n");
        sb.Append("    BEGIN\n");
        sb.Append("        SET @i_return_code = 0x80155115  -- XONLINE_E_MATCH_CRITICAL_DB_ERR\n");
        sb.Append("        GOTO exit_label\n");
        sb.Append("    END\n");
        sb.Append("\n");
        sb.Append("    IF @i_delete_delay_seconds = 0\n");
        sb.Append("    BEGIN\n");
        sb.Append("        DELETE dbo." + standardTableName + " WHERE b_box_id = @b_box_id\n");
        sb.Append("    END\n");
        sb.Append("    ELSE\n");
        sb.Append("    BEGIN\n");
        sb.Append("        SELECT top 1 @f_hasSession=1 FROM dbo." + standardTableName + " WITH (NOLOCK)\n");
        sb.Append("            WHERE dt_deletion_time < @dt_current_time\n");
        sb.Append("            OPTION (OPTIMIZE FOR (@dt_current_time = '1900/1/1 12:00:00'))\n");
        sb.Append("        IF(@f_hasSession > 0)\n");
        sb.Append("        BEGIN\n");
        sb.Append("            DELETE dbo." + standardTableName + "\n");
        sb.Append("                WHERE dt_deletion_time < @dt_current_time\n");
        sb.Append("                OPTION (OPTIMIZE FOR (@dt_current_time = '1900/1/1 12:00:00'))\n");
        sb.Append("        END\n");
        sb.Append("        UPDATE dbo." + standardTableName + "\n");
        sb.Append("            SET   dt_deletion_time = DATEADD(second, @i_delete_delay_seconds, GETUTCDATE())\n");
        sb.Append("                 ,ti_is_available = 0\n");
        sb.Append("            WHERE b_box_id = @b_box_id\n");
        sb.Append("    END\n");
        sb.Append("\n");
        sb.Append("    SELECT @error_var = @@ERROR\n");
        sb.Append("\n");
        sb.Append("    IF @error_var != 0\n");
        sb.Append("    BEGIN\n");
        sb.Append("        SET @i_return_code = 0x80155115  -- XONLINE_E_MATCH_CRITICAL_DB_ERR\n");
        sb.Append("        GOTO exit_label\n");
        sb.Append("    END\n");
        sb.Append("\n");
        sb.Append("    RETURN 0\n");
        sb.Append("\n");
        sb.Append("exit_label:\n");
        sb.Append("    IF @error_var != 0\n");
        sb.Append("    BEGIN\n");
        sb.Append("        DECLARE @message varchar(255)\n");
        sb.Append("        SELECT @message = 'XMATCH_SESSION_DELETE_FAILED: " + procName + " - ' + CAST(CAST(CAST(@error_var AS binary(4)) AS int) AS varchar(64))\n");
        sb.Append("        EXEC master.dbo.xp_logevent 51711, @message, error\n");
        sb.Append("    END\n");
        sb.Append("    RETURN @i_return_code\n");
        sb.Append("END\n");

        // make the newlines in the string Windows style
        sb.Replace("\n", "\r\n");

        sqlStatements[1] = sb.ToString();

        sqlStatements[2] = "GRANT EXECUTE ON " + procName + " TO ClientLib\r\n";

        Log("Generated " + sqlStatements.Length + " sql statements for proc " + procName);

        return sqlStatements;
    }

    private static string DeadXboxProcName(MatchGameConfig matchGameConfig)
    {
        return "p_match_session_0x" + matchGameConfig.TitleId.ToString("X8")
            + "_deadxbox";
    }

    public static string[] SystemFindByIdQueryProc(MatchGameConfig matchGameConfig)
    {
        string rankedTableName = RankedTableName(matchGameConfig);
        string standardTableName = StandardTableName(matchGameConfig);
        string procName = SystemFindByIdProcName(matchGameConfig);
        string[] sqlStatements = new string[3];

        string msg = "Generating sql statements for proc " + procName;
        Log(msg);

        StringBuilder sb = new StringBuilder();

        sb.Append("IF NOT EXISTS (SELECT name FROM dbo.sysobjects WHERE type = 'p' AND name = '" + procName + "')\n");
        sb.Append("BEGIN \n");
        sb.Append("    EXEC('create procedure dbo." + procName + " as raiserror(''Empty Stored Procedure!!'', 16, 1) with seterror')\n");
        sb.Append("    IF (@@error != 0)\n");
        sb.Append("    BEGIN\n");
        sb.Append("        PRINT 'FAILED to create stored procedure.'\n");
        sb.Append("    END\n");
        sb.Append("END\n");

        // make the newlines in the string Windows style
        sb.Replace("\n", "\r\n");

        sqlStatements[0] = sb.ToString();

        sb = new StringBuilder();

        sb.Append("ALTER PROCEDURE [dbo].[" + procName + "]\n");
        sb.Append("    @si_required_slots              smallint,\n");
        sb.Append("    @i_client_ip                    int,\n");
        sb.Append("    @ti_nat_type                    tinyint,\n");
        sb.Append("    @ti_server_count                tinyint,\n");

        // only one parameter for the system find by id query - the queryid, and it can't be NULL
        sb.Append("    @" + ParamName(MatchDefs.X_ATTRIBUTE_SESSION_ID)
            + "               " + IdToSqlType(MatchDefs.X_ATTRIBUTE_SESSION_ID) + "\n");
        sb.Append("    ,@" + ParamName(MatchDefs.X_ATTRIBUTE_PLATFORM_TYPE)
            + "               " + IdToSqlType(MatchDefs.X_ATTRIBUTE_PLATFORM_TYPE) + " = 0\n");
        sb.Append("    ,@" + ParamName(MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK)
            + "               " + IdToSqlType(MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK) + " = 0\n");

        sb.Append("\n");
        sb.Append("AS\n");
        sb.Append("-- Match Code Generator Version - !!Version=" + VersionString + "\n");
        sb.Append("-- Xlast (XDK) Version = " + matchGameConfig.XlastVersion + "\n");
        sb.Append("-- Xlast Project Version = " + matchGameConfig.ProjectVersion + "\n");
        sb.Append("BEGIN\n");
        sb.Append("\n");
        sb.Append("    if ((@" + ParamName(MatchDefs.X_ATTRIBUTE_SESSION_ID)
            + " & 0x0000000000000300) = 0)\n");
        sb.Append("    begin\n");
        sb.Append("        SELECT TOP 1\n");
        sb.Append("            s.bi_session_id,\n");
        sb.Append("            s.b_host_address,\n");
        sb.Append("            s.b_key_exchange_key,\n");
        sb.Append("            s.i_public_available,\n");
        sb.Append("            s.i_private_available,\n");
        sb.Append("            s.i_public_current,\n");
        sb.Append("            s.i_private_current\n");
        sb.Append("        FROM dbo." + rankedTableName + " s WITH (NOLOCK)\n");
        sb.Append("        WHERE\n");
        sb.Append("            (s.ti_breadcrumb_state != 2)\n");
        sb.Append("            AND (@" + ParamName(MatchDefs.X_ATTRIBUTE_SESSION_ID) + " = s.bi_session_id)\n");
        sb.Append("            AND (s.dt_deletion_time IS NULL)\n");
        sb.Append("            AND ((0 = s." + AttributeName(MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK)
                + " AND 0 = @" + ParamName(MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK) + ")\n"
                + "               OR (s." + AttributeName(MatchDefs.X_ATTRIBUTE_PLATFORM_TYPE)
                + " = @" + ParamName(MatchDefs.X_ATTRIBUTE_PLATFORM_TYPE)
                + " AND 1 = s." + AttributeName(MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK) + "))\n");
        sb.Append("    end\n");
        sb.Append("    else\n");
        sb.Append("    begin\n");
        sb.Append("        SELECT TOP 1\n");
        sb.Append("            s.bi_session_id,\n");
        sb.Append("            s.b_host_address,\n");
        sb.Append("            s.b_key_exchange_key,\n");
        sb.Append("            s.i_public_available,\n");
        sb.Append("            s.i_private_available,\n");
        sb.Append("            s.i_public_current,\n");
        sb.Append("            s.i_private_current\n");
        sb.Append("        FROM dbo." + standardTableName + " s  WITH (NOLOCK)\n");
        sb.Append("        WHERE\n");
        sb.Append("            (s.ti_breadcrumb_state != 2)\n");
        sb.Append("            AND (@" + ParamName(MatchDefs.X_ATTRIBUTE_SESSION_ID) + " = s.bi_session_id)\n");
        sb.Append("            AND (s.dt_deletion_time IS NULL)\n");
        sb.Append("            AND ((0 = s." + AttributeName(MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK)
                + " AND 0 = @" + ParamName(MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK) + ")\n"
                + "               OR (s." + AttributeName(MatchDefs.X_ATTRIBUTE_PLATFORM_TYPE)
                + " = @" + ParamName(MatchDefs.X_ATTRIBUTE_PLATFORM_TYPE)
                + " AND 1 = s." + AttributeName(MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK) + "))\n");
        sb.Append("    end\n");
        sb.Append("\n");
        sb.Append("    RETURN 0\n");
        sb.Append("\n");
        sb.Append("END\n");

        // make the newlines in the string Windows style
        sb.Replace("\n", "\r\n");

        sqlStatements[1] = sb.ToString();

        sqlStatements[2] = "GRANT EXECUTE ON " + procName + " TO ClientLib\r\n";

        Log("Generated " + sqlStatements.Length + " sql statements for proc " + procName);

        return sqlStatements;
    }

    public static string[] SystemFindByIdGetAttributesQueryProc(MatchGameConfig matchGameConfig)
    {
        string rankedTableName = RankedTableName(matchGameConfig);
        string standardTableName = StandardTableName(matchGameConfig);
        string procName = SystemFindByIdGetAttributesProcName(matchGameConfig);
        string[] sqlStatements = new string[3];

        string msg = "Generating sql statements for proc " + procName;
        Log(msg);

        StringBuilder sb = new StringBuilder();

        sb.Append("IF NOT EXISTS (SELECT name FROM dbo.sysobjects WHERE type = 'p' AND name = '" + procName + "')\n");
        sb.Append("BEGIN \n");
        sb.Append("    EXEC('create procedure dbo." + procName + " as raiserror(''Empty Stored Procedure!!'', 16, 1) with seterror')\n");
        sb.Append("    IF (@@error != 0)\n");
        sb.Append("    BEGIN\n");
        sb.Append("        PRINT 'FAILED to create stored procedure.'\n");
        sb.Append("    END\n");
        sb.Append("END\n");

        // make the newlines in the string Windows style
        sb.Replace("\n", "\r\n");

        sqlStatements[0] = sb.ToString();

        sb = new StringBuilder();

        sb.Append("ALTER PROCEDURE [dbo].[" + procName + "]\n");
        sb.Append("    @si_required_slots              smallint,\n");
        sb.Append("    @i_client_ip                    int,\n");
        sb.Append("    @ti_nat_type                    tinyint,\n");
        sb.Append("    @ti_server_count                tinyint,\n");

        // only one parameter for the system find by id query - the queryid, and it can't be NULL
        sb.Append("    @" + ParamName(MatchDefs.X_ATTRIBUTE_SESSION_ID)
            + "               " + IdToSqlType(MatchDefs.X_ATTRIBUTE_SESSION_ID) + "\n");
        sb.Append("    ,@" + ParamName(MatchDefs.X_ATTRIBUTE_PLATFORM_TYPE)
            + "               " + IdToSqlType(MatchDefs.X_ATTRIBUTE_PLATFORM_TYPE) + " = 0\n");
        sb.Append("    ,@" + ParamName(MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK)
            + "               " + IdToSqlType(MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK) + " = 0\n");

        sb.Append("\n");
        sb.Append("AS\n");
        sb.Append("-- Match Code Generator Version - !!Version=" + VersionString + "\n");
        sb.Append("-- Xlast (XDK) Version = " + matchGameConfig.XlastVersion + "\n");
        sb.Append("-- Xlast Project Version = " + matchGameConfig.ProjectVersion + "\n");
        sb.Append("BEGIN\n");
        sb.Append("\n");
        sb.Append("    if ((@" + ParamName(MatchDefs.X_ATTRIBUTE_SESSION_ID)
            + " & 0x0000000000000300) = 0)\n");
        sb.Append("    begin\n");
        sb.Append("        SELECT TOP 1\n");
        sb.Append("            s.bi_session_id,\n");
        sb.Append("            s.b_host_address,\n");
        sb.Append("            s.b_key_exchange_key,\n");
        sb.Append("            s.i_public_available,\n");
        sb.Append("            s.i_private_available,\n");
        sb.Append("            s.i_public_current,\n");
        sb.Append("            s.i_private_current\n");

        // Append auto-attributes as well as the attributes from the schema
        sb.Append("            ,s." + AttributeName(MatchDefs.X_ATTRIBUTE_GAME_TYPE) + "\n");
        sb.Append("            ,s." + AttributeName(MatchDefs.X_ATTRIBUTE_GAME_MODE) + "\n");
        sb.Append("            ,s." + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_ZONE) + "\n");
        sb.Append("            ,s." + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_COUNTRY) + "\n");
        sb.Append("            ,s." + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_LANGUAGE) + "\n");
        sb.Append("            ,s." + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_RATING) + "\n");
        sb.Append("            ,s." + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_MU) + "\n");
        sb.Append("            ,s." + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_SIGMA) + "\n");
        sb.Append("            ,s." + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_PUID) + "\n");
        sb.Append("            ,s." + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_HOSTNAME) + "\n");
        sb.Append("            ,s." + AttributeName(MatchDefs.X_ATTRIBUTE_PLATFORM_TYPE) + "\n");
        sb.Append("            ,s." + AttributeName(MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK) + "\n");
        foreach (MatchSchemaAttribute attr in matchGameConfig.MatchSchema)
        {
            if (!MatchDefs.IsSystemAttribute(attr.Id))
            {
                sb.Append("            ,s." + AttributeName(attr.Id) + "\n");
            }
        }

        sb.Append("        FROM dbo." + rankedTableName + " s\n");
        sb.Append("        WHERE\n");
        sb.Append("            (s.ti_breadcrumb_state != 2)\n");
        sb.Append("            AND (@" + ParamName(MatchDefs.X_ATTRIBUTE_SESSION_ID) + " = s.bi_session_id)\n");
        sb.Append("            AND ((0 = s." + AttributeName(MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK)
                + " AND 0 = @" + ParamName(MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK) + ")\n"
                + "               OR (s." + AttributeName(MatchDefs.X_ATTRIBUTE_PLATFORM_TYPE)
                + " = @" + ParamName(MatchDefs.X_ATTRIBUTE_PLATFORM_TYPE)
                + " AND 1 = s." + AttributeName(MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK) + "))\n");
        sb.Append("    end\n");
        sb.Append("    else\n");
        sb.Append("    begin\n");
        sb.Append("        SELECT TOP 1\n");
        sb.Append("            s.bi_session_id,\n");
        sb.Append("            s.b_host_address,\n");
        sb.Append("            s.b_key_exchange_key,\n");
        sb.Append("            s.i_public_available,\n");
        sb.Append("            s.i_private_available,\n");
        sb.Append("            s.i_public_current,\n");
        sb.Append("            s.i_private_current\n");

        // Append auto-attributes as well as the attributes from the schema
        sb.Append("            ,s." + AttributeName(MatchDefs.X_ATTRIBUTE_GAME_TYPE) + "\n");
        sb.Append("            ,s." + AttributeName(MatchDefs.X_ATTRIBUTE_GAME_MODE) + "\n");
        sb.Append("            ,s." + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_ZONE) + "\n");
        sb.Append("            ,s." + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_COUNTRY) + "\n");
        sb.Append("            ,s." + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_LANGUAGE) + "\n");
        sb.Append("            ,s." + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_RATING) + "\n");
        sb.Append("            ,s." + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_MU) + "\n");
        sb.Append("            ,s." + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_SIGMA) + "\n");
        sb.Append("            ,s." + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_PUID) + "\n");
        sb.Append("            ,s." + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_HOSTNAME) + "\n");
        sb.Append("            ,s." + AttributeName(MatchDefs.X_ATTRIBUTE_PLATFORM_TYPE) + "\n");
        sb.Append("            ,s." + AttributeName(MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK) + "\n");
        foreach (MatchSchemaAttribute attr in matchGameConfig.MatchSchema)
        {
            if (!MatchDefs.IsSystemAttribute(attr.Id))
            {
                sb.Append("            ,s." + AttributeName(attr.Id) + "\n");
            }
        }

        sb.Append("        FROM dbo." + standardTableName + " s\n");
        sb.Append("        WHERE\n");
        sb.Append("            (s.ti_breadcrumb_state != 2)\n");
        sb.Append("            AND (@" + ParamName(MatchDefs.X_ATTRIBUTE_SESSION_ID) + " = s.bi_session_id)\n");
        sb.Append("            AND ((0 = s." + AttributeName(MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK)
                + " AND 0 = @" + ParamName(MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK) + ")\n"
                + "               OR (s." + AttributeName(MatchDefs.X_ATTRIBUTE_PLATFORM_TYPE)
                + " = @" + ParamName(MatchDefs.X_ATTRIBUTE_PLATFORM_TYPE)
                + " AND 1 = s." + AttributeName(MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK) + "))\n");
        sb.Append("    end\n");
        sb.Append("\n");
        sb.Append("    RETURN 0\n");
        sb.Append("\n");
        sb.Append("END\n");

        // make the newlines in the string Windows style
        sb.Replace("\n", "\r\n");

        sqlStatements[1] = sb.ToString();

        sqlStatements[2] = "GRANT EXECUTE ON " + procName + " TO ClientLib\r\n";

        Log("Generated " + sqlStatements.Length + " sql statements for proc " + procName);

        return sqlStatements;
    }

    public static string[] SystemFindByIdListQueryProc(MatchGameConfig matchGameConfig)
    {
        string rankedTableName = RankedTableName(matchGameConfig);
        string standardTableName = StandardTableName(matchGameConfig);
        string procName = SystemFindByIdListProcName(matchGameConfig);
        string[] sqlStatements = new string[3];

        string msg = "Generating sql statements for proc " + procName;
        Log(msg);

        StringBuilder sb = new StringBuilder();

        sb.Append("IF NOT EXISTS (SELECT name FROM dbo.sysobjects WHERE type = 'p' AND name = '" + procName + "')\n");
        sb.Append("BEGIN \n");
        sb.Append("    EXEC('create procedure dbo." + procName + " as raiserror(''Empty Stored Procedure!!'', 16, 1) with seterror')\n");
        sb.Append("    IF (@@error != 0)\n");
        sb.Append("    BEGIN\n");
        sb.Append("        PRINT 'FAILED to create stored procedure.'\n");
        sb.Append("    END\n");
        sb.Append("END\n");

        // make the newlines in the string Windows style
        sb.Replace("\n", "\r\n");

        sqlStatements[0] = sb.ToString();

        sb = new StringBuilder();

        sb.Append("ALTER PROCEDURE [dbo].[" + procName + "]\n");
        sb.Append("    @si_required_slots              smallint,\n");
        sb.Append("    @i_client_ip                    int,\n");
        sb.Append("    @ti_nat_type                    tinyint,\n");
        sb.Append("    @ti_server_count                tinyint,\n");
        sb.Append("    @i_session_id_count             int,\n");

        // only one parameter for the system find by id query - the queryid, and it can't be NULL
        sb.Append("    @" + ParamName(MatchDefs.X_ATTRIBUTE_SESSION_ID_LIST)
            + "               " + IdToSqlType(MatchDefs.X_ATTRIBUTE_SESSION_ID_LIST) + "\n");
        sb.Append("    ,@" + ParamName(MatchDefs.X_ATTRIBUTE_PLATFORM_TYPE)
            + "               " + IdToSqlType(MatchDefs.X_ATTRIBUTE_PLATFORM_TYPE) + " = 0\n");
        sb.Append("    ,@" + ParamName(MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK)
            + "               " + IdToSqlType(MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK) + " = 0\n");

        sb.Append("\n");
        sb.Append("AS\n");
        sb.Append("-- Match Code Generator Version - !!Version=" + VersionString + "\n");
        sb.Append("-- Xlast (XDK) Version = " + matchGameConfig.XlastVersion + "\n");
        sb.Append("-- Xlast Project Version = " + matchGameConfig.ProjectVersion + "\n");
        sb.Append("BEGIN\n");
        sb.Append("    DECLARE @bi_session_id bigint\n");
        sb.Append("    DECLARE @b_session_id binary(8)\n");
        sb.Append("    DECLARE @i int\n");
        sb.Append("    DECLARE @temp_sessions TABLE (\n");
        sb.Append("         bi_session_id       bigint,\n");
        sb.Append("         b_host_address      binary(36),\n");
        sb.Append("         b_key_exchange_key  binary(16),\n");
        sb.Append("         i_public_available  int,\n");
        sb.Append("         i_private_available int,\n");
        sb.Append("         i_public_current    int,\n");
        sb.Append("         i_private_current   int\n");
        sb.Append("    )\n");
        sb.Append("\n");
        sb.Append("\n");
        sb.Append("    SET @i = 0\n");
        sb.Append("    WHILE(@i < @i_session_id_count)\n");
        sb.Append("    BEGIN\n");
        sb.Append("        set @b_session_id = substring(@" + ParamName(MatchDefs.X_ATTRIBUTE_SESSION_ID_LIST) + ", 1 + (@i * 8), 8)\n");
        sb.Append("        set @bi_session_id = convert(bigint, @b_session_id)\n");
        sb.Append("        if ((@bi_session_id & 0x0000000000000300) = 0)\n");
        sb.Append("        begin\n");
        sb.Append("            INSERT INTO @temp_sessions (\n");
        sb.Append("                bi_session_id,\n");
        sb.Append("                b_host_address,\n");
        sb.Append("                b_key_exchange_key,\n");
        sb.Append("                i_public_available,\n");
        sb.Append("                i_private_available,\n");
        sb.Append("                i_public_current,\n");
        sb.Append("                i_private_current\n");
        sb.Append("            )\n");
        sb.Append("            SELECT TOP 1\n");
        sb.Append("                s.bi_session_id,\n");
        sb.Append("                s.b_host_address,\n");
        sb.Append("                s.b_key_exchange_key,\n");
        sb.Append("                s.i_public_available,\n");
        sb.Append("                s.i_private_available,\n");
        sb.Append("                s.i_public_current,\n");
        sb.Append("                s.i_private_current\n");
        sb.Append("            FROM dbo." + rankedTableName + " s WITH (NOLOCK)\n");
        sb.Append("            WHERE\n");
        sb.Append("                (s.ti_breadcrumb_state != 2)\n");
        sb.Append("                AND (@bi_session_id = s.bi_session_id)\n");
        sb.Append("                AND (s.dt_deletion_time IS NULL)\n");
        sb.Append("                AND ((0 = s." + AttributeName(MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK)
                + " AND 0 = @" + ParamName(MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK) + ")\n"
                + "                   OR (s." + AttributeName(MatchDefs.X_ATTRIBUTE_PLATFORM_TYPE)
                + " = @" + ParamName(MatchDefs.X_ATTRIBUTE_PLATFORM_TYPE)
                + " AND 1 = s." + AttributeName(MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK) + "))\n");
        sb.Append("        end\n");
        sb.Append("        else\n");
        sb.Append("        begin\n");
        sb.Append("            INSERT INTO @temp_sessions (\n");
        sb.Append("                bi_session_id,\n");
        sb.Append("                b_host_address,\n");
        sb.Append("                b_key_exchange_key,\n");
        sb.Append("                i_public_available,\n");
        sb.Append("                i_private_available,\n");
        sb.Append("                i_public_current,\n");
        sb.Append("                i_private_current\n");
        sb.Append("            )\n");
        sb.Append("            SELECT TOP 1\n");
        sb.Append("                s.bi_session_id,\n");
        sb.Append("                s.b_host_address,\n");
        sb.Append("                s.b_key_exchange_key,\n");
        sb.Append("                s.i_public_available,\n");
        sb.Append("                s.i_private_available,\n");
        sb.Append("                s.i_public_current,\n");
        sb.Append("                s.i_private_current\n");
        sb.Append("            FROM dbo." + standardTableName + " s  WITH (NOLOCK)\n");
        sb.Append("            WHERE\n");
        sb.Append("                (s.ti_breadcrumb_state != 2)\n");
        sb.Append("                AND (@bi_session_id = s.bi_session_id)\n");
        sb.Append("                AND (s.dt_deletion_time IS NULL)\n");
        sb.Append("                AND ((0 = s." + AttributeName(MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK)
                + " AND 0 = @" + ParamName(MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK) + ")\n"
                + "                   OR (s." + AttributeName(MatchDefs.X_ATTRIBUTE_PLATFORM_TYPE)
                + " = @" + ParamName(MatchDefs.X_ATTRIBUTE_PLATFORM_TYPE)
                + " AND 1 = s." + AttributeName(MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK) + "))\n");
        sb.Append("        end\n");
        sb.Append("        SET @i = @i + 1\n");
        sb.Append("    END\n");
        sb.Append("\n");
        sb.Append("    SELECT \n");
        sb.Append("        bi_session_id,\n");
        sb.Append("        b_host_address,\n");
        sb.Append("        b_key_exchange_key,\n");
        sb.Append("        i_public_available,\n");
        sb.Append("        i_private_available,\n");
        sb.Append("        i_public_current,\n");
        sb.Append("        i_private_current\n");
        sb.Append("        FROM @temp_sessions\n");
        sb.Append("    RETURN 0\n");
        sb.Append("\n");
        sb.Append("END\n");

        // make the newlines in the string Windows style
        sb.Replace("\n", "\r\n");

        sqlStatements[1] = sb.ToString();

        sqlStatements[2] = "GRANT EXECUTE ON " + procName + " TO ClientLib\r\n";

        Log("Generated " + sqlStatements.Length + " sql statements for proc " + procName);

        return sqlStatements;
    }

    private static string SystemFindByIdProcName(MatchGameConfig matchGameConfig)
    {
        return "p_match_session_v2_0x" + matchGameConfig.TitleId.ToString("X8") + "_search_findbyid";
    }

    private static string SystemFindByIdGetAttributesProcName(MatchGameConfig matchGameConfig)
    {
        return "p_match_session_v2_0x" + matchGameConfig.TitleId.ToString("X8") + "_search_findbyid_get_attributes";
    }

    private static string SystemFindByIdListProcName(MatchGameConfig matchGameConfig)
    {
        return "p_match_session_v2_0x" + matchGameConfig.TitleId.ToString("X8") + "_search_findbyid_list";
    }


    // 
    // Standard query uses multiple passes of increasing breath to find sessions that
    // match the following hard and soft criteria:
    //
    //  Hard criteria: Available, Game mode
    //  Soft criteria (in order of importance): Lang, Country, Zone, Title Attributes
    //
    // The clustered index for the standard table is now organized with this in mind as well as
    // the hash value which provides a quick way to cull out sessions when we have found too many.
    // 
    // We used to use a widening parameter on rating which turns out to be a very poor parititioning
    // scheme as it is not uniformly distributed (instead it resembles an extreme power curve).
    // The table is now partitioned on the data that actually matters and provides a better overal
    // partitioning for the majority of queries.
    //
    // We rely on random hash removal to cull sessions when we have to many, this provides 'equal'
    // priority to all sessions that match the search criteria. 
    //
    // This new structure provides a 3x improvement in performance in search over the old method.
    //
    public static string[] StandardQueryProc(MatchGameConfig matchGameConfig, uint queryId)
    {
        string tableName = StandardTableName(matchGameConfig);
        string procName = StandardQueryProcName(matchGameConfig, queryId);
        MatchQuery matchQuery = (MatchQuery)matchGameConfig.MatchQueries[queryId];
        string[] sqlStatements = new string[3];

        uint primarySortAttributeId = MatchDefs.X_ATTRIBUTE_GAMER_ZONE;
        uint secondarySortAttributeId = MatchDefs.X_ATTRIBUTE_GAMER_LANGUAGE;
        uint tertiarySortAttributeId = MatchDefs.X_ATTRIBUTE_GAMER_COUNTRY;

        // HACK HACK: modern warfare 2 needs different social ordering
        // the long term fix would be to allow the overriding of these sorts in the xlast file
        // but we don't have time for that right now. 
        // (would require xlast + spac changes, and possibly goldengate changes)
        if (matchGameConfig.TitleId == 0x41560817)
        {
            primarySortAttributeId = MatchDefs.X_ATTRIBUTE_GAMER_COUNTRY;
            secondarySortAttributeId = MatchDefs.X_ATTRIBUTE_GAMER_LANGUAGE;
            tertiarySortAttributeId = MatchDefs.X_ATTRIBUTE_GAMER_ZONE;
        }

        string msg = "Generating sql statements for proc " + procName;
        Log(msg);

        StringBuilder sb = new StringBuilder();

        sb.Append("IF NOT EXISTS (SELECT name FROM dbo.sysobjects WHERE type = 'p' AND name = '" + procName + "')\n");
        sb.Append("BEGIN \n");
        sb.Append("    EXEC('create procedure dbo." + procName + " as raiserror(''Empty Stored Procedure!!'', 16, 1) with seterror')\n");
        sb.Append("    IF (@@error != 0)\n");
        sb.Append("    BEGIN\n");
        sb.Append("        PRINT 'FAILED to create stored procedure.'\n");
        sb.Append("    END\n");
        sb.Append("END\n");

        // make the newlines in the string Windows style
        sb.Replace("\n", "\r\n");

        sqlStatements[0] = sb.ToString();

        sb = new StringBuilder();

        sb.Append("ALTER PROCEDURE [dbo].[" + procName + "]\n");

        // the front door does not know the title defined max results, for this 
        // query, but this procedure does, so we return it to the front door
        sb.Append("    @i_max_results                  int OUTPUT\n");

        // This is a count of the number of negative affiliate sessions that the
        // front door is aware of. This value should be added to max results
        // to determine how many records need be returned from this query
        sb.Append("   ,@i_negative_sessions            int\n");

        sb.Append("   ,@si_required_slots              smallint\n");
        sb.Append("   ,@i_client_ip                    int\n");
        sb.Append("   ,@ti_nat_type                    tinyint\n");
        sb.Append("   ,@ti_server_count                tinyint\n");

        // built in params not listed in xlast but added to all queries
        sb.Append("   ,@" + ParamName(MatchDefs.X_ATTRIBUTE_GAME_TYPE) + "               "
            + IdToSqlType(MatchDefs.X_ATTRIBUTE_GAME_TYPE) + "\n");
        sb.Append("   ,@" + ParamName(MatchDefs.X_ATTRIBUTE_GAME_MODE) + "               "
            + IdToSqlType(MatchDefs.X_ATTRIBUTE_GAME_MODE) + "\n");
        sb.Append("   ,@" + ParamName(MatchDefs.X_ATTRIBUTE_GAMER_ZONE) + "               "
            + IdToSqlType(MatchDefs.X_ATTRIBUTE_GAMER_ZONE) + " = "
            + MatchDefs.X_ATTRIBUTE_GAMER_ZONE_DEFAULT.ToString() + "\n");
        sb.Append("   ,@" + ParamName(MatchDefs.X_ATTRIBUTE_GAMER_COUNTRY) + "               "
            + IdToSqlType(MatchDefs.X_ATTRIBUTE_GAMER_COUNTRY) + " = "
            + MatchDefs.X_ATTRIBUTE_GAMER_COUNTRY_DEFAULT.ToString() + "\n");
        sb.Append("   ,@" + ParamName(MatchDefs.X_ATTRIBUTE_GAMER_LANGUAGE) + "               "
            + IdToSqlType(MatchDefs.X_ATTRIBUTE_GAMER_LANGUAGE) + " = "
            + MatchDefs.X_ATTRIBUTE_GAMER_LANGUAGE_DEFAULT.ToString() + "\n");
        sb.Append("   ,@" + ParamName(MatchDefs.X_ATTRIBUTE_GAMER_RATING) + "               "
            + IdToSqlType(MatchDefs.X_ATTRIBUTE_GAMER_RATING) + " = "
            + MatchDefs.X_ATTRIBUTE_GAMER_RATING_DEFAULT.ToString() + "\n");
        sb.Append("   ,@" + ParamName(MatchDefs.X_ATTRIBUTE_GAMER_MU) + "               "
            + IdToSqlType(MatchDefs.X_ATTRIBUTE_GAMER_MU) + " = "
            + MatchDefs.X_ATTRIBUTE_GAMER_MU_DEFAULT.ToString() + "\n");
        sb.Append("   ,@" + ParamName(MatchDefs.X_ATTRIBUTE_GAMER_SIGMA) + "               "
            + IdToSqlType(MatchDefs.X_ATTRIBUTE_GAMER_SIGMA) + " = "
            + MatchDefs.X_ATTRIBUTE_GAMER_SIGMA_DEFAULT.ToString() + "\n");
        sb.Append("   ,@" + ParamName(MatchDefs.X_ATTRIBUTE_GAMER_PUID) + "               "
            + IdToSqlType(MatchDefs.X_ATTRIBUTE_GAMER_PUID) + " = 0\n");
        sb.Append("   ,@" + ParamName(MatchDefs.X_ATTRIBUTE_GAMER_HOSTNAME) + "               "
            + IdToSqlType(MatchDefs.X_ATTRIBUTE_GAMER_HOSTNAME) + " = ''\n");
        sb.Append("   ,@" + ParamName(MatchDefs.X_ATTRIBUTE_PLATFORM_TYPE) + "               "
            + IdToSqlType(MatchDefs.X_ATTRIBUTE_PLATFORM_TYPE) + " = 0\n");
        sb.Append("   ,@" + ParamName(MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK) + "               "
            + IdToSqlType(MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK) + " = 0\n");

        // title defined query params
        foreach (MatchQueryParam param in matchQuery.Parameters)
        {
            if (!MatchDefs.IsSystemAttribute(param.Id))
            {
                sb.Append("   ,@" + ParamName(param.Id) + "               "
                    + IdToSqlType(param.Id) + " = NULL\n");
            }
        }

        sb.Append("\n");
        sb.Append("AS\n");
        sb.Append("-- Match Code Generator Version - !!Version=" + VersionString + "\n");
        sb.Append("-- Xlast (XDK) Version = " + matchGameConfig.XlastVersion + "\n");
        sb.Append("-- Xlast Project Version = " + matchGameConfig.ProjectVersion + "\n");
        sb.Append("BEGIN\n");
        sb.Append("\n");
        sb.Append("    SET @i_max_results = " + matchQuery.MaxResults + "\n");
        sb.Append("\n");
        sb.Append("    declare @i_results_found int\n");
        sb.Append("    declare @i_results_needed int\n");
        sb.Append("    declare @i_rowcount int\n");
        sb.Append("    SET @i_results_needed = @i_max_results + @i_negative_sessions\n");
        sb.Append("\n");

        // This first section is searching for sessions that are in the same
        // zone, same language, and same country
        sb.Append("    set @i_rowcount = (select count(*)\n");
        sb.Append("    FROM " + tableName + " s WITH (NOLOCK)\n");
        sb.Append("    WHERE\n");
        sb.Append("        (s.ti_is_available = 1)\n");
        sb.Append("        AND (s.ti_breadcrumb_state != 1 OR s.i_sw_bucket IS NULL)\n");
        sb.Append("        AND (s." + AttributeName(MatchDefs.X_ATTRIBUTE_GAME_MODE)
            + " = @" + ParamName(MatchDefs.X_ATTRIBUTE_GAME_MODE) + ")\n");
        sb.Append("        AND (s." + AttributeName(primarySortAttributeId)
            + " = @" + ParamName(primarySortAttributeId) + ")\n");
        sb.Append("        AND (s." + AttributeName(secondarySortAttributeId)
            + " = @" + ParamName(secondarySortAttributeId) + ")\n");
        sb.Append("        AND (s." + AttributeName(tertiarySortAttributeId)
            + " = @" + ParamName(tertiarySortAttributeId) + ")\n");
        sb.Append("        AND (s.i_public_available >= @si_required_slots)\n");
        sb.Append("        AND (s.i_ip_addr = @i_client_ip OR s.ti_nat_type + @ti_nat_type < 5)\n");
        sb.Append("        AND ((0 = s." + AttributeName(MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK)
                + " AND 0 = @" + ParamName(MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK) + ")\n"
                + "           OR (s." + AttributeName(MatchDefs.X_ATTRIBUTE_PLATFORM_TYPE)
                + " = @" + ParamName(MatchDefs.X_ATTRIBUTE_PLATFORM_TYPE)
                + " AND 1 = s." + AttributeName(MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK) + "))\n");
        foreach (MatchQueryFilter filter in matchQuery.Filters)
        {
            sb.Append("        AND ");
            sb.Append(FilterToSql(filter, matchGameConfig));
        }
        sb.Append("    )\n");
        sb.Append("\n");

        // we add a random hash filter here, if rowcount is greater than maxresults*4
        // this is not ideal since i_hash is not part of the clustered index,
        // but it will protect the us somewhat against the case where the
        // distribution of ratings was such that a single iteration of the
        // loop above went from too few sessions, to far too many
        sb.Append("    declare @i_upper_hash_bound1 int\n");
        sb.Append("    declare @i_lower_hash_bound1 int\n");
        sb.Append("    declare @i_upper_hash_bound2 int\n");
        sb.Append("    declare @i_lower_hash_bound2 int\n");
        sb.Append("    declare @i_hash_count int\n");
        sb.Append("    set @i_upper_hash_bound1 = 10000\n");
        sb.Append("    set @i_lower_hash_bound1 = 0\n");
        sb.Append("    set @i_upper_hash_bound2 = 0\n");
        sb.Append("    set @i_lower_hash_bound2 = 0\n");
        sb.Append("    set @i_hash_count = 10000\n");
        sb.Append("    if (@i_rowcount > @i_results_needed * 4 )\n");
        sb.Append("    begin\n");
        sb.Append("        set @i_hash_count = (@i_results_needed * 3 * 10000)/@i_rowcount\n");
        sb.Append("        set @i_lower_hash_bound1 = (RAND() * 10000)\n");
        sb.Append("        set @i_upper_hash_bound1 = @i_lower_hash_bound1 + @i_hash_count\n");
        sb.Append("        if (@i_upper_hash_bound1 > 10000)\n");
        sb.Append("        begin\n");
        sb.Append("            set @i_upper_hash_bound2 = @i_upper_hash_bound1 - 10000\n");
        sb.Append("            set @i_upper_hash_bound1 = 10000\n");
        sb.Append("        end\n");
        sb.Append("    end\n");
        sb.Append("\n");

        // we return the parameters we decided on so the front door can log them
        sb.Append("    select\n");
        sb.Append("        " + ((int)matchGameConfig.TitleId).ToString() + " as i_title_id,\n");
        sb.Append("        " + ((int)queryId).ToString() + " as i_query_id,\n");
        sb.Append("        @" + ParamName(MatchDefs.X_ATTRIBUTE_GAME_TYPE) + " as i_game_type,\n");
        sb.Append("        @" + ParamName(MatchDefs.X_ATTRIBUTE_GAME_MODE) + " as i_game_mode,\n");
        sb.Append("        @" + ParamName(MatchDefs.X_ATTRIBUTE_GAMER_RATING) + " as f_gamer_rating,\n");
        sb.Append("        @" + ParamName(MatchDefs.X_ATTRIBUTE_GAMER_ZONE) + " as f_gamer_zone,\n");
        sb.Append("        0 as i_iterations,\n");
        sb.Append("        @i_rowcount as i_rowcount,\n");
        sb.Append("        cast(0.0 as float) as f_rating_range,\n");
        sb.Append("        cast(0.0 as float) as f_rating_upper_bound,\n");
        sb.Append("        cast(0.0 as float) as f_rating_lower_bound,\n");
        sb.Append("        @i_lower_hash_bound1 as i_lower_hash_bound1,\n");
        sb.Append("        @i_upper_hash_bound1 as i_upper_hash_bound1,\n");
        sb.Append("        @i_lower_hash_bound2 as i_lower_hash_bound2,\n");
        sb.Append("        @i_upper_hash_bound2 as i_upper_hash_bound2\n");
        sb.Append("\n");

        // now we do the actual query, using the rating and hash ranges we decided on 
        sb.Append("    set rowcount @i_results_needed\n");
        sb.Append("    select\n");
        sb.Append("        s.bi_session_id\n");
        sb.Append("       ,s.b_host_address\n");
        sb.Append("       ,s.b_key_exchange_key\n");
        sb.Append("       ,s.i_public_available\n");
        sb.Append("       ,s.i_private_available\n");
        sb.Append("       ,s.i_public_current\n");
        sb.Append("       ,s.i_private_current\n");
        foreach (DictionaryEntry de in matchQuery.Returns)
        {
            MatchQueryReturn queryReturn = (MatchQueryReturn)de.Value;
            sb.Append("       ,s." + AttributeName(queryReturn.Id) + "\n");
        }
        sb.Append("       ,s." + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_ZONE) + "\n");
        sb.Append("       ,s." + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_HOSTNAME) + "\n");
        sb.Append("    FROM " + tableName + " s WITH (NOLOCK)\n");
        sb.Append("    WHERE\n");
        sb.Append("        (s.ti_is_available = 1)\n");
        sb.Append("        AND (s.ti_breadcrumb_state != 1 OR s.i_sw_bucket IS NULL)\n");
        sb.Append("        AND (s." + AttributeName(MatchDefs.X_ATTRIBUTE_GAME_MODE)
            + "= @" + ParamName(MatchDefs.X_ATTRIBUTE_GAME_MODE) + ")\n");
        sb.Append("        AND (s." + AttributeName(primarySortAttributeId)
            + " = @" + ParamName(primarySortAttributeId) + ")\n");
        sb.Append("        AND (s." + AttributeName(secondarySortAttributeId)
            + " = @" + ParamName(secondarySortAttributeId) + ")\n");
        sb.Append("        AND (s." + AttributeName(tertiarySortAttributeId)
            + " = @" + ParamName(tertiarySortAttributeId) + ")\n");
        sb.Append("        AND ((s.i_hash >= @i_lower_hash_bound1 AND s.i_hash < @i_upper_hash_bound1)\n");
        sb.Append("            OR (s.i_hash >= @i_lower_hash_bound2 AND s.i_hash < @i_upper_hash_bound2))\n");
        sb.Append("        AND (s.i_public_available >= @si_required_slots)\n");
        sb.Append("        AND (s.i_ip_addr = @i_client_ip OR s.ti_nat_type + @ti_nat_type < 5)\n");
        sb.Append("        AND ((0 = s." + AttributeName(MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK)
                + " AND 0 = @" + ParamName(MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK) + ")\n"
                + "             OR (s." + AttributeName(MatchDefs.X_ATTRIBUTE_PLATFORM_TYPE)
                + " = @" + ParamName(MatchDefs.X_ATTRIBUTE_PLATFORM_TYPE)
                + " AND 1 = s." + AttributeName(MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK) + "))\n");

        foreach (MatchQueryFilter filter in matchQuery.Filters)
        {
            sb.Append("        AND ");
            sb.Append(FilterToSql(filter, matchGameConfig));
        }
        sb.Append("    ORDER BY\n");
        bool firstLine = true;
        if (matchQuery.SortOps.Count > 0)
        {
            foreach (DictionaryEntry de in matchQuery.SortOps)
            {
                if (firstLine)
                {
                    firstLine = false;
                    sb.Append("        ");
                }
                else
                {
                    sb.Append("       ,");
                }
                sb.Append(SortOpToSql((MatchQuerySortOp)de.Value));
                sb.Append("\n");
            }
        }
        if (firstLine)
        {
            sb.Append("        ");
        }
        else
        {
            sb.Append("       ,");
        }
        sb.Append(OrderByDrawProbabilityClause());
        sb.Append("\n");

        // if we have enough sessions to satisfy the front door, then we're done
        sb.Append("    set @i_results_found = @@rowcount\n");
        sb.Append("    set rowcount 0\n");
        sb.Append("\n");
        sb.Append("    if (@i_results_found >= @i_results_needed) RETURN 0\n");
        sb.Append("\n");

        // figure out how many rows we have yet to find
        sb.Append("    set @i_results_needed = @i_results_needed - @i_results_found\n");
        sb.Append("\n");

        // now repeat the entire process, but only match sessions in the same gamer zone
        // where either the language, or the country, or both, do not match.
        sb.Append("    set @i_rowcount = (select count(*)\n");
        sb.Append("        FROM " + tableName + " s WITH (NOLOCK)\n");
        sb.Append("        WHERE\n");
        sb.Append("            (s.ti_is_available = 1)\n");
        sb.Append("            AND (s.ti_breadcrumb_state != 1 OR s.i_sw_bucket IS NULL)\n");
        sb.Append("            AND (s." + AttributeName(MatchDefs.X_ATTRIBUTE_GAME_MODE)
            + " = @" + ParamName(MatchDefs.X_ATTRIBUTE_GAME_MODE) + ")\n");
        sb.Append("            AND (s." + AttributeName(primarySortAttributeId)
            + " = @" + ParamName(primarySortAttributeId) + ")\n");
        sb.Append("            AND (\n");
        sb.Append("                (s." + AttributeName(secondarySortAttributeId)
            + " != @" + ParamName(secondarySortAttributeId) + ")\n");
        sb.Append("                OR (s." + AttributeName(tertiarySortAttributeId)
            + " != @" + ParamName(tertiarySortAttributeId) + ")\n");
        sb.Append("            )\n");
        sb.Append("            AND (s.i_public_available >= @si_required_slots)\n");
        sb.Append("            AND (s.i_ip_addr = @i_client_ip OR s.ti_nat_type + @ti_nat_type < 5)\n");
        sb.Append("            AND ((0 = s." + AttributeName(MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK)
                + " AND 0 = @" + ParamName(MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK) + ")\n"
                + "              OR (s." + AttributeName(MatchDefs.X_ATTRIBUTE_PLATFORM_TYPE)
                + " = @" + ParamName(MatchDefs.X_ATTRIBUTE_PLATFORM_TYPE)
                + " AND 1 = s." + AttributeName(MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK) + "))\n");
        foreach (MatchQueryFilter filter in matchQuery.Filters)
        {
            sb.Append("            AND ");
            sb.Append(FilterToSql(filter, matchGameConfig));
        }
        sb.Append("    )\n");
        sb.Append("\n");

        sb.Append("    set @i_upper_hash_bound1 = 10000\n");
        sb.Append("    set @i_lower_hash_bound1 = 0\n");
        sb.Append("    set @i_upper_hash_bound2 = 0\n");
        sb.Append("    set @i_lower_hash_bound2 = 0\n");
        sb.Append("    set @i_hash_count = 10000\n");
        sb.Append("    if (@i_rowcount > @i_results_needed * 4)\n");
        sb.Append("    begin\n");
        sb.Append("        set @i_hash_count = (@i_results_needed * 3 * 10000)/@i_rowcount\n");
        sb.Append("        set @i_lower_hash_bound1 = (RAND() * 10000)\n");
        sb.Append("        set @i_upper_hash_bound1 = @i_lower_hash_bound1 + @i_hash_count\n");
        sb.Append("        if (@i_upper_hash_bound1 > 10000)\n");
        sb.Append("        begin\n");
        sb.Append("            set @i_upper_hash_bound2 = @i_upper_hash_bound1 - 10000\n");
        sb.Append("            set @i_upper_hash_bound1 = 10000\n");
        sb.Append("        end\n");
        sb.Append("    end\n");
        sb.Append("\n");

        sb.Append("    select\n");
        sb.Append("        " + ((int)matchGameConfig.TitleId).ToString() + " as i_title_id,\n");
        sb.Append("        " + ((int)queryId).ToString() + " as i_query_id,\n");
        sb.Append("        @" + ParamName(MatchDefs.X_ATTRIBUTE_GAME_TYPE) + " as i_game_type,\n");
        sb.Append("        @" + ParamName(MatchDefs.X_ATTRIBUTE_GAME_MODE) + " as i_game_mode,\n");
        sb.Append("        @" + ParamName(MatchDefs.X_ATTRIBUTE_GAMER_RATING) + " as f_gamer_rating,\n");
        sb.Append("        @" + ParamName(MatchDefs.X_ATTRIBUTE_GAMER_ZONE) + " as f_gamer_zone,\n");
        sb.Append("        0 as i_iterations,\n");
        sb.Append("        @i_rowcount as i_rowcount,\n");
        sb.Append("        cast(0.0 as float) as f_rating_range,\n");
        sb.Append("        cast(0.0 as float) as f_rating_upper_bound,\n");
        sb.Append("        cast(0.0 as float) as f_rating_lower_bound,\n");
        sb.Append("        @i_lower_hash_bound1 as i_lower_hash_bound1,\n");
        sb.Append("        @i_upper_hash_bound1 as i_upper_hash_bound1,\n");
        sb.Append("        @i_lower_hash_bound2 as i_lower_hash_bound2,\n");
        sb.Append("        @i_upper_hash_bound2 as i_upper_hash_bound2\n");
        sb.Append("\n");
        sb.Append("    set rowcount @i_results_needed\n");
        sb.Append("    select\n");
        sb.Append("        s.bi_session_id\n");
        sb.Append("       ,s.b_host_address\n");
        sb.Append("       ,s.b_key_exchange_key\n");
        sb.Append("       ,s.i_public_available\n");
        sb.Append("       ,s.i_private_available\n");
        sb.Append("       ,s.i_public_current\n");
        sb.Append("       ,s.i_private_current\n");
        foreach (DictionaryEntry de in matchQuery.Returns)
        {
            MatchQueryReturn queryReturn = (MatchQueryReturn)de.Value;
            sb.Append("       ,s." + AttributeName(queryReturn.Id) + "\n");
        }
        sb.Append("       ,s." + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_ZONE) + "\n");
        sb.Append("       ,s." + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_HOSTNAME) + "\n");
        sb.Append("    FROM " + tableName + " s WITH (NOLOCK)\n");
        sb.Append("    WHERE\n");
        sb.Append("        (s.ti_is_available = 1)\n");
        sb.Append("        AND (s.ti_breadcrumb_state != 1 OR s.i_sw_bucket IS NULL)\n");
        sb.Append("        AND (s." + AttributeName(MatchDefs.X_ATTRIBUTE_GAME_MODE)
            + "= @" + ParamName(MatchDefs.X_ATTRIBUTE_GAME_MODE) + ")\n");
        sb.Append("        AND (s." + AttributeName(primarySortAttributeId)
            + " = @" + ParamName(primarySortAttributeId) + ")\n");
        sb.Append("        AND (\n");
        sb.Append("            (s." + AttributeName(secondarySortAttributeId)
            + " != @" + ParamName(secondarySortAttributeId) + ")\n");
        sb.Append("            OR (s." + AttributeName(tertiarySortAttributeId)
            + " != @" + ParamName(tertiarySortAttributeId) + ")\n");
        sb.Append("        )\n");
        sb.Append("        AND ((s.i_hash >= @i_lower_hash_bound1 AND s.i_hash < @i_upper_hash_bound1)\n");
        sb.Append("            OR (s.i_hash >= @i_lower_hash_bound2 AND s.i_hash < @i_upper_hash_bound2))\n");
        sb.Append("        AND (s.i_public_available >= @si_required_slots)\n");
        sb.Append("        AND (s.i_ip_addr = @i_client_ip OR s.ti_nat_type + @ti_nat_type < 5)\n");
        sb.Append("        AND ((0 = s." + AttributeName(MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK)
                + " AND 0 = @" + ParamName(MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK) + ")\n"
                + "          OR (s." + AttributeName(MatchDefs.X_ATTRIBUTE_PLATFORM_TYPE)
                + " = @" + ParamName(MatchDefs.X_ATTRIBUTE_PLATFORM_TYPE)
                + " AND 1 = s." + AttributeName(MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK) + "))\n");
        foreach (MatchQueryFilter filter in matchQuery.Filters)
        {
            sb.Append("        AND ");
            sb.Append(FilterToSql(filter, matchGameConfig));
        }
        sb.Append("    ORDER BY\n");
        sb.Append("        CASE \n");
        sb.Append("            WHEN (s." + AttributeName(secondarySortAttributeId)
            + " = @" + ParamName(secondarySortAttributeId) + ") THEN 1\n");
        sb.Append("            WHEN (s." + AttributeName(tertiarySortAttributeId)
            + " = @" + ParamName(tertiarySortAttributeId) + ") THEN 2\n");
        sb.Append("            ELSE 3\n");
        sb.Append("        END\n");
        if (matchQuery.SortOps.Count > 0)
        {
            foreach (DictionaryEntry de in matchQuery.SortOps)
            {
                 sb.Append("       ," + SortOpToSql((MatchQuerySortOp)de.Value) + "\n");
            }
        }
        sb.Append("       ," + OrderByDrawProbabilityClause());
        sb.Append("\n");

        // if we have enough sessions to satisfy the front door, then we're done
        sb.Append("    set @i_results_found = @@rowcount\n");
        sb.Append("    set rowcount 0\n");
        sb.Append("\n");
        sb.Append("    if (@i_results_found >= @i_results_needed) RETURN 0\n");
        sb.Append("\n");

        // figure out how many rows we have yet to find
        sb.Append("    set @i_results_needed = @i_results_needed - @i_results_found\n");
        sb.Append("\n");

        // now repeat the entire process one more time, but this time for
        // sessions from different gamer zones
        sb.Append("    set @i_rowcount = (select count(*)\n");
        sb.Append("        FROM " + tableName + " s WITH (NOLOCK)\n");
        sb.Append("        WHERE\n");
        sb.Append("            (s.ti_is_available = 1)\n");
        sb.Append("            AND (s.ti_breadcrumb_state != 1 OR s.i_sw_bucket IS NULL)\n");
        sb.Append("            AND (s." + AttributeName(MatchDefs.X_ATTRIBUTE_GAME_MODE)
            + " = @" + ParamName(MatchDefs.X_ATTRIBUTE_GAME_MODE) + ")\n");
        sb.Append("            AND (s." + AttributeName(primarySortAttributeId)
            + " != @" + ParamName(primarySortAttributeId) + ")\n");
        sb.Append("            AND (s.i_public_available >= @si_required_slots)\n");
        sb.Append("            AND (s.i_ip_addr = @i_client_ip OR s.ti_nat_type + @ti_nat_type < 5)\n");
        sb.Append("            AND ((0 = s." + AttributeName(MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK)
                + " AND 0 = @" + ParamName(MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK) + ")\n"
                + "              OR (s." + AttributeName(MatchDefs.X_ATTRIBUTE_PLATFORM_TYPE)
                + " = @" + ParamName(MatchDefs.X_ATTRIBUTE_PLATFORM_TYPE)
                + " AND 1 = s." + AttributeName(MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK) + "))\n");

        foreach (MatchQueryFilter filter in matchQuery.Filters)
        {
            sb.Append("            AND ");
            sb.Append(FilterToSql(filter, matchGameConfig));
        }
        sb.Append("    )\n");
        sb.Append("\n");

        sb.Append("    set @i_upper_hash_bound1 = 10000\n");
        sb.Append("    set @i_lower_hash_bound1 = 0\n");
        sb.Append("    set @i_upper_hash_bound2 = 0\n");
        sb.Append("    set @i_lower_hash_bound2 = 0\n");
        sb.Append("    set @i_hash_count = 10000\n");
        sb.Append("    if (@i_rowcount > @i_results_needed * 4)\n");
        sb.Append("    begin\n");
        sb.Append("        set @i_hash_count = (@i_results_needed * 3 * 10000)/@i_rowcount\n");
        sb.Append("        set @i_lower_hash_bound1 = (RAND() * 10000)\n");
        sb.Append("        set @i_upper_hash_bound1 = @i_lower_hash_bound1 + @i_hash_count\n");
        sb.Append("        if (@i_upper_hash_bound1 > 10000)\n");
        sb.Append("        begin\n");
        sb.Append("            set @i_upper_hash_bound2 = @i_upper_hash_bound1 - 10000\n");
        sb.Append("            set @i_upper_hash_bound1 = 10000\n");
        sb.Append("        end\n");
        sb.Append("    end\n");
        sb.Append("\n");

        sb.Append("    select\n");
        sb.Append("        " + ((int)matchGameConfig.TitleId).ToString() + " as i_title_id,\n");
        sb.Append("        " + ((int)queryId).ToString() + " as i_query_id,\n");
        sb.Append("        @" + ParamName(MatchDefs.X_ATTRIBUTE_GAME_TYPE) + " as i_game_type,\n");
        sb.Append("        @" + ParamName(MatchDefs.X_ATTRIBUTE_GAME_MODE) + " as i_game_mode,\n");
        sb.Append("        @" + ParamName(MatchDefs.X_ATTRIBUTE_GAMER_RATING) + " as f_gamer_rating,\n");
        sb.Append("        @" + ParamName(MatchDefs.X_ATTRIBUTE_GAMER_ZONE) + " as f_gamer_zone,\n");
        sb.Append("        0 as i_iterations,\n");
        sb.Append("        @i_rowcount as i_rowcount,\n");
        sb.Append("        cast(0.0 as float) as f_rating_range,\n");
        sb.Append("        cast(0.0 as float) as f_rating_upper_bound,\n");
        sb.Append("        cast(0.0 as float) as f_rating_lower_bound,\n");
        sb.Append("        @i_lower_hash_bound1 as i_lower_hash_bound1,\n");
        sb.Append("        @i_upper_hash_bound1 as i_upper_hash_bound1,\n");
        sb.Append("        @i_lower_hash_bound2 as i_lower_hash_bound2,\n");
        sb.Append("        @i_upper_hash_bound2 as i_upper_hash_bound2\n");
        sb.Append("\n");
        sb.Append("    set rowcount @i_results_needed\n");
        sb.Append("    select\n");
        sb.Append("        s.bi_session_id\n");
        sb.Append("       ,s.b_host_address\n");
        sb.Append("       ,s.b_key_exchange_key\n");
        sb.Append("       ,s.i_public_available\n");
        sb.Append("       ,s.i_private_available\n");
        sb.Append("       ,s.i_public_current\n");
        sb.Append("       ,s.i_private_current\n");
        foreach (DictionaryEntry de in matchQuery.Returns)
        {
            MatchQueryReturn queryReturn = (MatchQueryReturn)de.Value;
            sb.Append("       ,s." + AttributeName(queryReturn.Id) + "\n");
        }
        sb.Append("       ,s." + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_ZONE) + "\n");
        sb.Append("       ,s." + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_HOSTNAME) + "\n");
        sb.Append("    FROM " + tableName + " s WITH (NOLOCK)\n");
        sb.Append("    WHERE\n");
        sb.Append("        (s.ti_is_available = 1)\n");
        sb.Append("        AND (s.ti_breadcrumb_state != 1 OR s.i_sw_bucket IS NULL)\n");
        sb.Append("        AND (s." + AttributeName(MatchDefs.X_ATTRIBUTE_GAME_MODE)
            + "= @" + ParamName(MatchDefs.X_ATTRIBUTE_GAME_MODE) + ")\n");
        sb.Append("        AND (s." + AttributeName(primarySortAttributeId)
            + " != @" + ParamName(primarySortAttributeId) + ")\n");
        sb.Append("        AND ((s.i_hash >= @i_lower_hash_bound1 AND s.i_hash < @i_upper_hash_bound1)\n");
        sb.Append("            OR (s.i_hash >= @i_lower_hash_bound2 AND s.i_hash < @i_upper_hash_bound2))\n");
        sb.Append("        AND (s.i_public_available >= @si_required_slots)\n");
        sb.Append("        AND (s.i_ip_addr = @i_client_ip OR s.ti_nat_type + @ti_nat_type < 5)\n");
        sb.Append("        AND ((0 = s." + AttributeName(MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK)
                + " AND 0 = @" + ParamName(MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK) + ")\n"
                + "          OR (s." + AttributeName(MatchDefs.X_ATTRIBUTE_PLATFORM_TYPE)
                + " = @" + ParamName(MatchDefs.X_ATTRIBUTE_PLATFORM_TYPE)
                + " AND 1 = s." + AttributeName(MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK) + "))\n");
        foreach (MatchQueryFilter filter in matchQuery.Filters)
        {
            sb.Append("        AND ");
            sb.Append(FilterToSql(filter, matchGameConfig));
        }
        sb.Append("    ORDER BY\n");
        sb.Append("        CASE \n");
        sb.Append("            WHEN (s." + AttributeName(secondarySortAttributeId)
            + " = @" + ParamName(secondarySortAttributeId)
            + " and s." + AttributeName(tertiarySortAttributeId)
            + " = @" + ParamName(tertiarySortAttributeId) + ") THEN 0\n");
        sb.Append("            WHEN (s." + AttributeName(secondarySortAttributeId)
            + " = @" + ParamName(secondarySortAttributeId) + ") THEN 1\n");
        sb.Append("            WHEN (s." + AttributeName(tertiarySortAttributeId)
            + " = @" + ParamName(tertiarySortAttributeId) + ") THEN 2\n");
        sb.Append("            ELSE 3\n");
        sb.Append("        END\n");
        if (matchQuery.SortOps.Count > 0)
        {
            foreach (DictionaryEntry de in matchQuery.SortOps)
            {
                 sb.Append("       ," + SortOpToSql((MatchQuerySortOp)de.Value) + "\n");
            }
        }
        sb.Append("       ," + OrderByDrawProbabilityClause());
        sb.Append("\n");
        sb.Append("    set rowcount 0\n");
        sb.Append("\n");
        sb.Append("    RETURN 0\n");
        sb.Append("END\n");

        // make the newlines in the string Windows style
        sb.Replace("\n", "\r\n");

        sqlStatements[1] = sb.ToString();

        sqlStatements[2] = "GRANT EXECUTE ON " + procName + " TO ClientLib\r\n";

        Log("Generated " + sqlStatements.Length + " sql statements for proc " + procName);

        return sqlStatements;
    }

    private static string StandardQueryProcName(MatchGameConfig matchGameConfig, uint queryId)
    {
        return "p_match_session_v2_0x" + matchGameConfig.TitleId.ToString("X8")
            + "_0x" + queryId.ToString("X8") + "_search_standard";
    }

    public static string[] RankedQueryProc(MatchGameConfig matchGameConfig, uint queryId)
    {
        string tableName = RankedTableName(matchGameConfig);
        string procName = RankedQueryProcName(matchGameConfig, queryId);
        MatchQuery matchQuery = (MatchQuery)matchGameConfig.MatchQueries[queryId];
        string[] sqlStatements = new string[3];

        string msg = "Generating sql statements for proc " + procName;
        Log(msg);

        StringBuilder sb = new StringBuilder();

        sb.Append("IF NOT EXISTS (SELECT name FROM dbo.sysobjects WHERE type = 'p' AND name = '" + procName + "')\n");
        sb.Append("BEGIN \n");
        sb.Append("    EXEC('create procedure dbo." + procName + " as raiserror(''Empty Stored Procedure!!'', 16, 1) with seterror')\n");
        sb.Append("    IF (@@error != 0)\n");
        sb.Append("    BEGIN\n");
        sb.Append("        PRINT 'FAILED to create stored procedure.'\n");
        sb.Append("    END\n");
        sb.Append("END\n");

        // make the newlines in the string Windows style
        sb.Replace("\n", "\r\n");

        sqlStatements[0] = sb.ToString();

        sb = new StringBuilder();

        sb.Append("ALTER PROCEDURE [dbo].[" + procName + "]\n");

        // the front door does not know the title defined max results, for this 
        // query, but this procedure does, so we return it to the front door
        sb.Append("    -- declared as a BIGINT to prevent SQL from doing a cast when selecting top(max_results)\n");
        sb.Append("    @i_max_results                  BIGINT OUTPUT\n");
        sb.Append("   ,@si_required_slots              smallint\n");
        sb.Append("   ,@i_client_ip                    int\n");
        sb.Append("   ,@ti_nat_type                    tinyint\n");
        sb.Append("   ,@ti_server_count                tinyint\n");

        // built in params not listed in xlast but added to all queries
        sb.Append("   ,@" + ParamName(MatchDefs.X_ATTRIBUTE_GAME_TYPE) + "               "
            + IdToSqlType(MatchDefs.X_ATTRIBUTE_GAME_TYPE) + "\n");
        sb.Append("   ,@" + ParamName(MatchDefs.X_ATTRIBUTE_GAME_MODE) + "               "
            + IdToSqlType(MatchDefs.X_ATTRIBUTE_GAME_MODE) + "\n");
        sb.Append("   ,@" + ParamName(MatchDefs.X_ATTRIBUTE_GAMER_ZONE) + "               "
            + IdToSqlType(MatchDefs.X_ATTRIBUTE_GAMER_ZONE) + " = "
            + MatchDefs.X_ATTRIBUTE_GAMER_ZONE_DEFAULT.ToString() + "\n");
        sb.Append("   ,@" + ParamName(MatchDefs.X_ATTRIBUTE_GAMER_COUNTRY) + "               "
            + IdToSqlType(MatchDefs.X_ATTRIBUTE_GAMER_COUNTRY) + " = "
            + MatchDefs.X_ATTRIBUTE_GAMER_COUNTRY_DEFAULT.ToString() + "\n");
        sb.Append("   ,@" + ParamName(MatchDefs.X_ATTRIBUTE_GAMER_LANGUAGE) + "               "
            + IdToSqlType(MatchDefs.X_ATTRIBUTE_GAMER_LANGUAGE) + " = "
            + MatchDefs.X_ATTRIBUTE_GAMER_LANGUAGE_DEFAULT.ToString() + "\n");
        sb.Append("   ,@" + ParamName(MatchDefs.X_ATTRIBUTE_GAMER_RATING) + "               "
            + IdToSqlType(MatchDefs.X_ATTRIBUTE_GAMER_RATING) + " = "
            + MatchDefs.X_ATTRIBUTE_GAMER_RATING_DEFAULT.ToString() + "\n");
        sb.Append("   ,@" + ParamName(MatchDefs.X_ATTRIBUTE_GAMER_MU) + "               "
            + IdToSqlType(MatchDefs.X_ATTRIBUTE_GAMER_MU) + " = "
            + MatchDefs.X_ATTRIBUTE_GAMER_MU_DEFAULT.ToString() + "\n");
        sb.Append("   ,@" + ParamName(MatchDefs.X_ATTRIBUTE_GAMER_SIGMA) + "               "
            + IdToSqlType(MatchDefs.X_ATTRIBUTE_GAMER_SIGMA) + " = "
            + MatchDefs.X_ATTRIBUTE_GAMER_SIGMA_DEFAULT.ToString() + "\n");
        sb.Append("   ,@" + ParamName(MatchDefs.X_ATTRIBUTE_GAMER_PUID) + "               "
            + IdToSqlType(MatchDefs.X_ATTRIBUTE_GAMER_PUID) + " = 0\n");
        sb.Append("   ,@" + ParamName(MatchDefs.X_ATTRIBUTE_GAMER_HOSTNAME) + "               "
            + IdToSqlType(MatchDefs.X_ATTRIBUTE_GAMER_HOSTNAME) + " = ''\n");
        sb.Append("   ,@" + ParamName(MatchDefs.X_ATTRIBUTE_PLATFORM_TYPE) + "               "
            + IdToSqlType(MatchDefs.X_ATTRIBUTE_PLATFORM_TYPE) + " = 0\n");
        sb.Append("   ,@" + ParamName(MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK) + "               "
            + IdToSqlType(MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK) + " = 0\n");

        // title defined query params
        foreach (MatchQueryParam param in matchQuery.Parameters)
        {
            if (!MatchDefs.IsSystemAttribute(param.Id))
            {
                sb.Append("   ,@" + ParamName(param.Id) + "               "
                    + IdToSqlType(param.Id) + " = NULL\n");
            }
        }

        sb.Append("\n");
        sb.Append("AS\n");
        sb.Append("-- Match Code Generator Version - !!Version=" + VersionString + "\n");
        sb.Append("-- Xlast (XDK) Version = " + matchGameConfig.XlastVersion + "\n");
        sb.Append("-- Xlast Project Version = " + matchGameConfig.ProjectVersion + "\n");
        sb.Append("BEGIN\n");
        sb.Append("\n");
        sb.Append("    SET @i_max_results = " + matchQuery.MaxResults + "\n");
        sb.Append("\n");

        // mu is supposed to be in the range 0 to 6, and this algorithm
        // relies on that fact. If for some reason a mu out of range
        // has been supplied, peg it to one end of the range.
        sb.Append("    if (@" + ParamName(MatchDefs.X_ATTRIBUTE_GAMER_MU) + " > 6.0)\n");
        sb.Append("        set @" + ParamName(MatchDefs.X_ATTRIBUTE_GAMER_MU) +" = 6.0\n");
        sb.Append("    else if (@" + ParamName(MatchDefs.X_ATTRIBUTE_GAMER_MU) + " < 0.0)\n");
        sb.Append("        set @" + ParamName(MatchDefs.X_ATTRIBUTE_GAMER_MU) +" = 0.0\n");
        sb.Append("\n");

        // sigma is supposed to be in the range 0 to 1, while the search algorithm doesn't
        // strictly rely on this fact, we should enforce it anyway. If for some reason a 
        // sigma out of range has been supplied, peg it to one end of the range.
        sb.Append("    if (@" + ParamName(MatchDefs.X_ATTRIBUTE_GAMER_SIGMA) + " > 1.0)\n");
        sb.Append("        set @" + ParamName(MatchDefs.X_ATTRIBUTE_GAMER_SIGMA) +" = 1.0\n");
        sb.Append("    else if (@" + ParamName(MatchDefs.X_ATTRIBUTE_GAMER_SIGMA) + " < 0.0)\n");
        sb.Append("        set @" + ParamName(MatchDefs.X_ATTRIBUTE_GAMER_SIGMA) +" = 0.0\n");
        sb.Append("\n");

        // The really crushing performance hit occurs if we present too many
        // rows to the ORDER BY clause, generating a very expensive SORT
        // operation on the server. Compared to a large sort, filtering is very
        // fast. Filtering that uses the clustered index is extremely fast,
        // and filtering that doesn't use the clustered index is ok.
        // Therefore we perform several filtering operations expanding the
        // range of mu values we are willing to consider, until we've found
        // a range of mu values that returns enough rows to yield good results
        // but not so many rows that we crush the server with a big sort.

        // Our goal with this loop is to find a range of mu that produces
        // between maxresults*2 and maxresults*4 rows. This is a factor of 
        // 2 difference. In order hopefully hit this target, we expand the 
        // range by a factor of 2 with each iteration. I experimented with
        // several different factors, and 2 seemed to give the best perf.

        // We need to start out narrow enough such that we can reasonably expect
        // to reduce 20000 available sessions to 200 or so (hopefully less).
        // So we choose 2e-7 as our starting point.

        sb.Append("    declare @f_mu_range float\n");
        sb.Append("    declare @f_mu_upper_bound float\n");
        sb.Append("    declare @f_mu_lower_bound float\n");
        sb.Append("    declare @f_base float\n");
        sb.Append("    declare @i int\n");
        sb.Append("    declare @i_rowcount int\n");
        sb.Append("    declare @i_iterations int\n");
        sb.Append("    set @f_base = 2.0\n");
        sb.Append("    set @i_rowcount = 0\n");
        sb.Append("    set @i = -7\n");
        sb.Append("    set @i_iterations = 1\n");

        sb.Append("    while (1 = 1)\n");
        sb.Append("    begin\n");
        sb.Append("        set @f_mu_range = 3.0 * power(@f_base, cast(@i as float))\n");
        sb.Append("        set @f_mu_upper_bound = @"
            + ParamName(MatchDefs.X_ATTRIBUTE_GAMER_MU) + " + @f_mu_range\n");
        sb.Append("        set @f_mu_lower_bound = @"
            + ParamName(MatchDefs.X_ATTRIBUTE_GAMER_MU) + " - @f_mu_range\n");
        sb.Append("        if (@f_mu_lower_bound < 0)\n");
        sb.Append("        begin\n");
        sb.Append("            set @f_mu_upper_bound = @f_mu_upper_bound - @f_mu_lower_bound\n");
        sb.Append("            set @f_mu_lower_bound = 0.0\n");
        sb.Append("        end\n");
        sb.Append("        else if (@f_mu_upper_bound > 6.0)\n");
        sb.Append("        begin\n");
        sb.Append("            set @f_mu_lower_bound = @f_mu_lower_bound - (@f_mu_upper_bound - 6.0)\n");
        sb.Append("            set @f_mu_upper_bound = 6.0\n");
        sb.Append("        end\n");
        sb.Append("        set @i_rowcount = (select count(*)\n");
        sb.Append("            FROM " + tableName + " s WITH (NOLOCK)\n");
        sb.Append("            WHERE\n");
        sb.Append("                (s.ti_is_available = 1)\n");
        sb.Append("                AND (s.ti_breadcrumb_state != 1 OR s.i_sw_bucket IS NULL)\n");
        //sb.Append("                AND (s." + AttributeName(MatchDefs.X_ATTRIBUTE_GAME_TYPE)
        //    + " = @" + ParamName(MatchDefs.X_ATTRIBUTE_GAME_TYPE) + ")\n");
        sb.Append("                AND (s." + AttributeName(MatchDefs.X_ATTRIBUTE_GAME_MODE)
            + " = @" + ParamName(MatchDefs.X_ATTRIBUTE_GAME_MODE) + ")\n");
        sb.Append("                AND (s." + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_MU)
            + " <= @f_mu_upper_bound)\n");
        sb.Append("                AND (s." + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_MU)
            + " >= @f_mu_lower_bound)\n");
        sb.Append("                AND (s.i_public_available >= @si_required_slots)\n");
        sb.Append("                AND (s.i_ip_addr = @i_client_ip OR s.ti_nat_type + @ti_nat_type < 5)\n");
        sb.Append("                AND ((0 = s." + AttributeName(MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK)
                + " AND 0 = @" + ParamName(MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK) + ")\n"
                + "                  OR (s." + AttributeName(MatchDefs.X_ATTRIBUTE_PLATFORM_TYPE)
                + " = @" + ParamName(MatchDefs.X_ATTRIBUTE_PLATFORM_TYPE)
                + " AND 1 = s." + AttributeName(MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK) + "))\n");
        foreach (MatchQueryFilter filter in matchQuery.Filters)
        {
            sb.Append("                AND ");
            sb.Append(FilterToSql(filter, matchGameConfig));
        }
        sb.Append("        )\n");
        sb.Append("        if (@i_rowcount >= @i_max_results * 2) break\n");
        sb.Append("        if (@i = 0) break\n");
        sb.Append("        set @i_iterations = @i_iterations + 1\n");

        // We skip an iteration if the current range only returned 0 or 1 rows.
        // This hopefully results in fewer overall iterations, and therefore
        // fewer index scans. I experimented with bigger jumps, but tended
        // to overshoot the goal too often, which hurt perf instead of helping.
        sb.Append("        if (@i_rowcount < 2)\n");
        sb.Append("        begin\n");
        sb.Append("            set @i = @i + 2\n");
        sb.Append("            if (@i > 0) set @i = 0\n");
        sb.Append("        end\n");
        sb.Append("        else set @i = @i + 1\n");
        sb.Append("    end\n");
        sb.Append("\n");

        // we add a random hash filter here, if rowcount is greater than maxresults*4
        // this is not ideal since i_hash is not part of the clustered index,
        // but it will protect the us somewhat against the case where a
        // title doesn't use mu properly and we can't filter the rowset down
        // to a reasonable number with mu alone. If we're going to hash, we
        // hash down to maxresults*3 estimated rows, to ensure we're below
        // the maxresults*4 threshold we don't want to exceed.
        sb.Append("    declare @i_upper_hash_bound1 int\n");
        sb.Append("    declare @i_lower_hash_bound1 int\n");
        sb.Append("    declare @i_upper_hash_bound2 int\n");
        sb.Append("    declare @i_lower_hash_bound2 int\n");
        sb.Append("    declare @i_hash_count int\n");
        sb.Append("    set @i_upper_hash_bound1 = 10000\n");
        sb.Append("    set @i_lower_hash_bound1 = 0\n");
        sb.Append("    set @i_upper_hash_bound2 = 0\n");
        sb.Append("    set @i_lower_hash_bound2 = 0\n");
        sb.Append("    set @i_hash_count = 10000\n");
        sb.Append("    if (@i_rowcount > @i_max_results * 4)\n");
        sb.Append("    begin\n");
        sb.Append("        set @i_hash_count = (@i_max_results * 3 * 10000)/@i_rowcount\n");
        sb.Append("        set @i_lower_hash_bound1 = (RAND() * 10000)\n");
        sb.Append("        set @i_upper_hash_bound1 = @i_lower_hash_bound1 + @i_hash_count\n");
        sb.Append("        if (@i_upper_hash_bound1 > 10000)\n");
        sb.Append("        begin\n");
        sb.Append("            set @i_upper_hash_bound2 = @i_upper_hash_bound1 - 10000\n");
        sb.Append("            set @i_upper_hash_bound1 = 10000\n");
        sb.Append("        end\n");
        sb.Append("    end\n");
        sb.Append("\n");

        // we return the parameters we decided on so the front door can log them
        sb.Append("    select\n");
        sb.Append("        " + ((int)matchGameConfig.TitleId).ToString() + " as i_title_id,\n");
        sb.Append("        " + ((int)queryId).ToString() + " as i_query_id,\n");
        sb.Append("        @" + ParamName(MatchDefs.X_ATTRIBUTE_GAME_TYPE) + " as i_game_type,\n");
        sb.Append("        @" + ParamName(MatchDefs.X_ATTRIBUTE_GAME_MODE) + " as i_game_mode,\n");
        sb.Append("        @" + ParamName(MatchDefs.X_ATTRIBUTE_GAMER_MU) + " as f_gamer_mu,\n");
        sb.Append("        @i_iterations as i_iterations,\n");
        sb.Append("        @i_rowcount as i_rowcount,\n");
        sb.Append("        @f_mu_range as f_mu_range,\n");
        sb.Append("        @f_mu_upper_bound as f_mu_upper_bound,\n");
        sb.Append("        @f_mu_lower_bound as f_mu_lower_bound,\n");
        sb.Append("        @i_lower_hash_bound1 as i_lower_hash_bound1,\n");
        sb.Append("        @i_upper_hash_bound1 as i_upper_hash_bound1,\n");
        sb.Append("        @i_lower_hash_bound2 as i_lower_hash_bound2,\n");
        sb.Append("        @i_upper_hash_bound2 as i_upper_hash_bound2\n");
        sb.Append("\n");

        // now we do the actual query, using the mu and hash ranges we decided on 
        sb.Append("    select top (@i_max_results)\n");
        sb.Append("        s.bi_session_id\n");
        sb.Append("       ,s.b_host_address\n");
        sb.Append("       ,s.b_key_exchange_key\n");
        sb.Append("       ,s.i_public_available\n");
        sb.Append("       ,s.i_private_available\n");
        sb.Append("       ,s.i_public_current\n");
        sb.Append("       ,s.i_private_current\n");
        foreach (DictionaryEntry de in matchQuery.Returns)
        {
            MatchQueryReturn queryReturn = (MatchQueryReturn)de.Value;
            sb.Append("       ,s." + AttributeName(queryReturn.Id) + "\n");
        }
        sb.Append("           ,s." + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_ZONE) + "\n");
        sb.Append("           ,s." + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_HOSTNAME) + "\n");
        sb.Append("    FROM " + tableName + " s WITH (NOLOCK)\n");
        sb.Append("    WHERE\n");
        sb.Append("        (s.ti_is_available = 1)\n");
        sb.Append("        AND (s.ti_breadcrumb_state != 1 OR s.i_sw_bucket IS NULL)\n");
        sb.Append("        AND (s." + AttributeName(MatchDefs.X_ATTRIBUTE_GAME_MODE)
            + "= @" + ParamName(MatchDefs.X_ATTRIBUTE_GAME_MODE) + ")\n");
        sb.Append("        AND (s." + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_MU)
            + " <= @f_mu_upper_bound)\n");
        sb.Append("        AND (s." + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_MU)
            + " >= @f_mu_lower_bound)\n");
        sb.Append("        AND ((s.i_hash >= @i_lower_hash_bound1 AND s.i_hash < @i_upper_hash_bound1)\n");
        sb.Append("            OR (s.i_hash >= @i_lower_hash_bound2 AND s.i_hash < @i_upper_hash_bound2))\n");
        sb.Append("        AND (s.i_public_available >= @si_required_slots)\n");
        sb.Append("        AND (s.i_ip_addr = @i_client_ip OR s.ti_nat_type + @ti_nat_type < 5)\n");
        sb.Append("        AND ((0 = s." + AttributeName(MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK)
                + " AND 0 = @" + ParamName(MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK) + ")\n"
                + "          OR (s." + AttributeName(MatchDefs.X_ATTRIBUTE_PLATFORM_TYPE)
                + " = @" + ParamName(MatchDefs.X_ATTRIBUTE_PLATFORM_TYPE)
                + " AND 1 = s." + AttributeName(MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK) + "))\n");

        foreach (MatchQueryFilter filter in matchQuery.Filters)
        {
            sb.Append("        AND ");
            sb.Append(FilterToSql(filter, matchGameConfig));
        }

        sb.Append("    ORDER BY\n");
        bool firstLine = true;
        if (matchQuery.SortOps.Count > 0)
        {
            foreach (DictionaryEntry de in matchQuery.SortOps)
            {
                if (firstLine)
                {
                    firstLine = false;
                    sb.Append("        ");
                }
                else
                {
                    sb.Append("       ,");
                }
                sb.Append(SortOpToSql((MatchQuerySortOp)de.Value));
                sb.Append("\n");
            }
        }
        if (firstLine)
        {
            sb.Append("        ");
        }
        else
        {
            sb.Append("       ,");
        }
        sb.Append(OrderByDrawProbabilityClause());
        sb.Append("\n");
        sb.Append("    RETURN 0\n");
        sb.Append("END\n");

        // make the newlines in the string Windows style
        sb.Replace("\n", "\r\n");

        sqlStatements[1] = sb.ToString();

        sqlStatements[2] = "GRANT EXECUTE ON " + procName + " TO ClientLib\r\n";

        Log("Generated " + sqlStatements.Length + " sql statements for proc " + procName);

        return sqlStatements;
    }

    private static string RankedQueryProcName(MatchGameConfig matchGameConfig, uint queryId)
    {
        return "p_match_session_v2_0x" + matchGameConfig.TitleId.ToString("X8")
            + "_0x" + queryId.ToString("X8") + "_search_ranked";
    }



    public static string[] WeightedQueryProc(MatchGameConfig matchGameConfig, uint queryId, bool fRanked)
    {
        // We produce 2 separate sprocs for weighted (ranked and standard) because ranked and standard use 2 different tables.
        // it makes the code of each sproc cleaner, and reduces the chance of SQL getting execution plans for a single sproc confused.  
        string tableName = "";
        if(fRanked)
        {
            tableName = RankedTableName(matchGameConfig);
        }
        else
        {
            tableName = StandardTableName(matchGameConfig);
        }
        string procName = WeightedQueryProcName(matchGameConfig, queryId, fRanked);
        MatchQuery matchQuery = (MatchQuery)matchGameConfig.MatchQueries[queryId];
        string[] sqlStatements = new string[3];

        string msg = "Generating sql statements for proc " + procName;
        Log(msg);

        StringBuilder sb = new StringBuilder();

        sb.Append("IF NOT EXISTS (SELECT name FROM dbo.sysobjects WHERE type = 'p' AND name = '" + procName + "')\n");
        sb.Append("BEGIN \n");
        sb.Append("    EXEC('create procedure dbo." + procName + " as raiserror(''Empty Stored Procedure!!'', 16, 1) with seterror')\n");
        sb.Append("    IF (@@error != 0)\n");
        sb.Append("    BEGIN\n");
        sb.Append("        PRINT 'FAILED to create stored procedure.'\n");
        sb.Append("    END\n");
        sb.Append("END\n");

        // make the newlines in the string Windows style
        sb.Replace("\n", "\r\n");

        sqlStatements[0] = sb.ToString();

        sb = new StringBuilder();

        sb.Append("ALTER PROCEDURE [dbo].[" + procName + "]\n");

        // the front door does not know the title defined max results, for this 
        // query, but this procedure does, so we return it to the front door
        sb.Append("    -- declared as a BIGINT to prevent SQL from doing a cast when selecting top(max_results)\n");
        sb.Append("    @i_max_results                  BIGINT OUTPUT\n");
        sb.Append("   ,@si_required_slots              smallint\n");
        sb.Append("   ,@i_client_ip                    int\n");
        sb.Append("   ,@ti_nat_type                    tinyint\n");
        sb.Append("   ,@ti_server_count                tinyint\n");

        // built in params not listed in xlast but added to all queries
        sb.Append("   ,@" + ParamName(MatchDefs.X_ATTRIBUTE_GAME_TYPE) + "               "
            + IdToSqlType(MatchDefs.X_ATTRIBUTE_GAME_TYPE) + "\n");
        sb.Append("   ,@" + ParamName(MatchDefs.X_ATTRIBUTE_GAME_MODE) + "               "
            + IdToSqlType(MatchDefs.X_ATTRIBUTE_GAME_MODE) + "\n");
        sb.Append("   ,@" + ParamName(MatchDefs.X_ATTRIBUTE_GAMER_ZONE) + "               "
            + IdToSqlType(MatchDefs.X_ATTRIBUTE_GAMER_ZONE) + " = "
            + MatchDefs.X_ATTRIBUTE_GAMER_ZONE_DEFAULT.ToString() + "\n");
        sb.Append("   ,@" + ParamName(MatchDefs.X_ATTRIBUTE_GAMER_COUNTRY) + "               "
            + IdToSqlType(MatchDefs.X_ATTRIBUTE_GAMER_COUNTRY) + " = "
            + MatchDefs.X_ATTRIBUTE_GAMER_COUNTRY_DEFAULT.ToString() + "\n");
        sb.Append("   ,@" + ParamName(MatchDefs.X_ATTRIBUTE_GAMER_LANGUAGE) + "               "
            + IdToSqlType(MatchDefs.X_ATTRIBUTE_GAMER_LANGUAGE) + " = "
            + MatchDefs.X_ATTRIBUTE_GAMER_LANGUAGE_DEFAULT.ToString() + "\n");
        sb.Append("   ,@" + ParamName(MatchDefs.X_ATTRIBUTE_GAMER_RATING) + "               "
            + IdToSqlType(MatchDefs.X_ATTRIBUTE_GAMER_RATING) + " = "
            + MatchDefs.X_ATTRIBUTE_GAMER_RATING_DEFAULT.ToString() + "\n");
        sb.Append("   ,@" + ParamName(MatchDefs.X_ATTRIBUTE_GAMER_MU) + "               "
            + IdToSqlType(MatchDefs.X_ATTRIBUTE_GAMER_MU) + " = "
            + MatchDefs.X_ATTRIBUTE_GAMER_MU_DEFAULT.ToString() + "\n");
        sb.Append("   ,@" + ParamName(MatchDefs.X_ATTRIBUTE_GAMER_SIGMA) + "               "
            + IdToSqlType(MatchDefs.X_ATTRIBUTE_GAMER_SIGMA) + " = "
            + MatchDefs.X_ATTRIBUTE_GAMER_SIGMA_DEFAULT.ToString() + "\n");
        sb.Append("   ,@" + ParamName(MatchDefs.X_ATTRIBUTE_GAMER_PUID) + "               "
            + IdToSqlType(MatchDefs.X_ATTRIBUTE_GAMER_PUID) + " = 0\n");
        sb.Append("   ,@" + ParamName(MatchDefs.X_ATTRIBUTE_GAMER_HOSTNAME) + "               "
            + IdToSqlType(MatchDefs.X_ATTRIBUTE_GAMER_HOSTNAME) + " = ''\n");
        sb.Append("   ,@" + ParamName(MatchDefs.X_ATTRIBUTE_PLATFORM_TYPE) + "               "
            + IdToSqlType(MatchDefs.X_ATTRIBUTE_PLATFORM_TYPE) + " = 0\n");
        sb.Append("   ,@" + ParamName(MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK) + "               "
            + IdToSqlType(MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK) + " = 0\n");

        // title defined query params
        foreach (MatchQueryParam param in matchQuery.Parameters)
        {
            if (!MatchDefs.IsSystemAttribute(param.Id))
            {
                sb.Append("   ,@" + ParamName(param.Id) + "               "
                    + IdToSqlType(param.Id) + " = NULL\n");
            }
            // some params can now have weights associated with them.  Those that do
            // get an additional floating point sql parameter to represent the weight.
            // this may include system schema attributes, like mu and sigma.
            // TODOTHEOM: there are some system schema attributes that should not allow weights.  Where to enforce?
            if(param.IsWeighted == true)
            {
                sb.Append("   ,@" + WeightParamName(param.Id) + "        "
                    + "float = 0\n");
            }
        }

        sb.Append("\n");
        sb.Append("AS\n");
        sb.Append("-- Match Code Generator Version - !!Version=" + VersionString + "\n");
        sb.Append("-- Xlast (XDK) Version = " + matchGameConfig.XlastVersion + "\n");
        sb.Append("-- Xlast Project Version = " + matchGameConfig.ProjectVersion + "\n");
        sb.Append("BEGIN\n");
        sb.Append("\n");
        sb.Append("    SET @i_max_results = " + matchQuery.MaxResults + "\n");
        sb.Append("\n");
        sb.Append("\n");

        sb.Append("-- variables used during expansion and hashing\n");
        sb.Append("declare @i_current_exp int\n");
        sb.Append("declare @i_starting_exp int\n");
        sb.Append("declare @i_rowcount int\n");
        sb.Append("declare @f_range_base float\n");
        sb.Append("declare @f_half_range float\n");
        sb.Append("declare @f_range_multiplier float\n");
        sb.Append("declare @i_lower_hash_bound1 int\n");
        sb.Append("declare @i_upper_hash_bound1 int\n");
        sb.Append("declare @i_lower_hash_bound2 int\n");
        sb.Append("declare @i_upper_hash_bound2 int\n");
        sb.Append("declare @i_eligible_rows int\n");

// TODOTHEOM: some of these should really be configurable per-title, or even per game mode.
        sb.Append("set @i_starting_exp = -10\n");
        sb.Append("set @i_current_exp = @i_starting_exp\n");
        sb.Append("set @i_rowcount = 0\n");
        sb.Append("set @f_half_range = .5\n");
        sb.Append("set @f_range_base = 1.4\n");
        sb.Append("set @f_range_multiplier =0\n");
        sb.Append("set @i_lower_hash_bound1 = 0\n");
        sb.Append("set @i_upper_hash_bound1 = 0\n");
        sb.Append("set @i_lower_hash_bound2 = 0\n");
        sb.Append("set @i_upper_hash_bound2 = 0\n");


        sb.Append("-- declare allowed param distances for each weighted param, if there are any\n");
        sb.Append("-- these are calculated in the magic expando query below\n");
        //iterate through the weighted query params, declaring an alloweddistance variable for each.
        foreach (MatchQueryParam param in matchQuery.Parameters)
        {
            if(param.IsWeighted == true)
            {
                sb.Append("declare @" + ParamName(param.Id) + "_alloweddistance float = 0\n");
            }
        }

        // get the number of eligible rows from the table.  These are the rows that pass the hard filters defined in the query.
        sb.Append("select @i_eligible_rows = count(*) from " + tableName + " s with (nolock) \n");
        EmitWeightedQueryProcWhereClause(sb, matchQuery, matchGameConfig, false /*fEmitWeightedBoxFilters*/);

        // if we only have few rows, no reason to do iterations... just blow out the view window and do 1 iteration.
        sb.Append("IF (@i_eligible_rows < (@i_max_results*2))\n");
        sb.Append("BEGIN\n");
        sb.Append("    set @i_current_exp = 1 -- in this case, we want no iterations\n");
        sb.Append("    -- since we're doing no iterations to find the 'right' distances...\n");
        sb.Append("    -- set all the allowed distances to the widest possible distance.\n");
        foreach (MatchQueryParam param in matchQuery.Parameters)
        {
            if (param.IsWeighted == true)
            {
                sb.Append("    if (@" + WeightParamName(param.Id) + " > 0) set @" + ParamName(param.Id) + "_alloweddistance = 1\n");
            }
        }
        sb.Append("END\n");

        sb.Append("while (@i_current_exp < 1 AND @i_rowcount < (@i_max_results*2))\n");
        sb.Append("begin\n");
        sb.Append("    set @f_range_multiplier = @f_half_range * power(@f_range_base, cast(@i_current_exp as float))\n");
        sb.Append("    set @i_current_exp = @i_current_exp+1\n");
        sb.Append("    -- we will scale the box in each dimension by the inverse of the weight for that dimension (alloweddistance), if there are any weighted params\n");

        foreach (MatchQueryParam param in matchQuery.Parameters)
        {
            if(param.IsWeighted == true)
            {
                sb.Append("    if (@" + WeightParamName(param.Id) + " > 0) set @" + ParamName(param.Id) + "_alloweddistance" +  "= @f_range_multiplier * (1/@" + WeightParamName(param.Id) + ")\n");
            }
        }

        sb.Append("    set @i_rowcount = (select count(*)  from " + tableName + " s WITH (NOLOCK) \n");
        EmitWeightedQueryProcWhereClause(sb, matchQuery, matchGameConfig, true /*fEmitWeightedBoxFilters*/);
        sb.Append(")\n"); // closes the "select count" subquery
        sb.Append("end\n");

        // we return the parameters we decided on so the front door can log them
        // TODOTHEOM: return more info here (at least, a couple more of the params from the above widening formula)
        sb.Append("    select\n");
        sb.Append("        " + ((int)matchGameConfig.TitleId).ToString() + " as i_title_id,\n");
        sb.Append("        " + ((int)queryId).ToString() + " as i_query_id,\n");
        sb.Append("        @" + ParamName(MatchDefs.X_ATTRIBUTE_GAME_TYPE) + " as i_game_type,\n");
        sb.Append("        @" + ParamName(MatchDefs.X_ATTRIBUTE_GAME_MODE) + " as i_game_mode,\n");
        sb.Append("        @" + ParamName(MatchDefs.X_ATTRIBUTE_GAMER_MU) + " as f_gamer_mu,\n");
        sb.Append("        (@i_current_exp - @i_starting_exp) as i_iterations,\n");
        sb.Append("        @i_rowcount as i_rowcount,\n");
        sb.Append("        @f_range_base as f_range_base,\n");
        sb.Append("        @i_lower_hash_bound1 as i_lower_hash_bound1,\n");
        sb.Append("        @i_upper_hash_bound1 as i_upper_hash_bound1,\n");
        sb.Append("        @i_lower_hash_bound2 as i_lower_hash_bound2,\n");
        sb.Append("        @i_upper_hash_bound2 as i_upper_hash_bound2\n");
        sb.Append("\n");


        // and now the actual results
        sb.Append("    select top (@i_max_results)\n");
        sb.Append("        s.bi_session_id\n");
        sb.Append("       ,s.b_host_address\n");
        sb.Append("       ,s.b_key_exchange_key\n");
        sb.Append("       ,s.i_public_available\n");
        sb.Append("       ,s.i_private_available\n");
        sb.Append("       ,s.i_public_current\n");
        sb.Append("       ,s.i_private_current\n");
        sb.Append("       -- returns from XLAST\n");
        foreach (DictionaryEntry de in matchQuery.Returns)
        {
            MatchQueryReturn queryReturn = (MatchQueryReturn)de.Value;
            sb.Append("       ,s." + AttributeName(queryReturn.Id) + "\n");
        }
        sb.Append("       -- more hard-coded returns.  These follow the xlast returns because they always have...\n");
        sb.Append("           ,s." + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_ZONE) + "\n");
        sb.Append("           ,s." + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_HOSTNAME) + "\n");
        // TODOTHEOM: somehow spit out the per-attribute distance for each session, when in DEBUG?
        sb.Append("           -- now calculate the score of each session as a column.  This will be used for sorting, and returned to the FD/client.\n");
        bool fFirstParam = true;
        foreach (MatchQueryParam param in matchQuery.Parameters)
        {
            if(param.IsWeighted == true)
            {
                if(fFirstParam == true)
                {
                        sb.Append("           ,cast((\n");
                        fFirstParam = false;
                }
                else
                {
                        sb.Append("           +");
                }
                if(param.IsExactMatch == true)
                {
                    // TODOTHEOM: ISNULL() on the param is ok because when the param is null, the weight will be zero.
                    // but ISNULL on the attribute (column) is not ok, because 0.0 may have special meaning there.  
                    // Need to make sure a null col value effectively results in a zero weight for that param/attr pair.
                    sb.Append("(@" + WeightParamName(param.Id)+ "*square(cast(cast(ISNULL(" + AttributeName(param.Id) + ",0.0) - ISNULL(@" + ParamName(param.Id) + ",0.0) as bit) as real)))\n");
                }
                else
                {
                    sb.Append("(@" + WeightParamName(param.Id) + "*square(ISNULL(" + AttributeName(param.Id) + ",0.0) - ISNULL(@" + ParamName(param.Id) + ",0.0)))\n");
                }
            }
        }
        if(fFirstParam == true)
        {
            // if there are no weighted params, return a score of 0 for each session, just for consistency.
            sb.Append("           ,cast(0 as real) as " + AttributeName(MatchDefs.X_ATTRIBUTE_SESSION_SCORE) + "\n");
        }
        else
        {
            sb.Append("           ) as real) as " + AttributeName(MatchDefs.X_ATTRIBUTE_SESSION_SCORE) + "\n");
        }

        sb.Append("    FROM " + tableName + " s WITH (NOLOCK)\n");
        EmitWeightedQueryProcWhereClause(sb, matchQuery, matchGameConfig, true /*fEmitWeightedBoxFilters*/);
        sb.Append("    ORDER BY\n");
        // now add in the non-weighted sort operations.  These take precedence over the weighted ones, 
        // and should be used sparingly.
        bool firstLine = true;
        if (matchQuery.SortOps.Count > 0)
        {
            foreach (DictionaryEntry de in matchQuery.SortOps)
            {
                if (firstLine)
                {
                    firstLine = false;
                    sb.Append("        ");
                }
                else
                {
                    sb.Append("       ,");
                }
                sb.Append(SortOpToSql((MatchQuerySortOp)de.Value));
                sb.Append("\n");
            }
        }
        // and finally... the weighted sort
        if (firstLine == false)
        {
            sb.Append("        , " + AttributeName(MatchDefs.X_ATTRIBUTE_SESSION_SCORE) + "\n");
        }
        else
        {
            sb.Append("        " + AttributeName(MatchDefs.X_ATTRIBUTE_SESSION_SCORE) + "\n");
        }

        sb.Append("    RETURN 0\n");
        sb.Append("END\n");

        // make the newlines in the string Windows style
        sb.Replace("\n", "\r\n");

        sqlStatements[1] = sb.ToString();

        sqlStatements[2] = "GRANT EXECUTE ON " + procName + " TO ClientLib\r\n";

        Log("Generated " + sqlStatements.Length + " sql statements for proc " + procName);

        return sqlStatements;
    }

    private static string WeightedQueryProcName(MatchGameConfig matchGameConfig, uint queryId, bool fRanked)
    {
        string strName= "p_match_session_v2_0x" + matchGameConfig.TitleId.ToString("X8")
            + "_0x" + queryId.ToString("X8") + "_search_weighted";
        if(fRanked)
        {
            strName += "_ranked";
        }
        else
        {
            strName += "_standard";
        }
        return strName;
    }

    private static void EmitWeightedQueryProcWhereClause(StringBuilder sb, MatchQuery matchQuery, MatchGameConfig matchGameConfig, bool fEmitWeightedBoxFilters)
    {
        //
        // first, emit the "built in" filters
        //

        sb.Append("    WHERE\n");
        sb.Append("        (s.ti_is_available = 1)\n");
        sb.Append("        AND (s.ti_breadcrumb_state != 1 OR s.i_sw_bucket IS NULL)\n");
        sb.Append("        AND (s." + AttributeName(MatchDefs.X_ATTRIBUTE_GAME_MODE)
            + " = @" + ParamName(MatchDefs.X_ATTRIBUTE_GAME_MODE) + ")\n");
        sb.Append("        AND (s.i_public_available >= @si_required_slots)\n");
        sb.Append("        AND (s.ti_nat_type + @ti_nat_type < 5 OR s.i_ip_addr = @i_client_ip)\n");
        sb.Append("        AND ((0 = s." + AttributeName(MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK)
                + " AND 0 = @" + ParamName(MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK) + ")\n"
                + "          OR (s." + AttributeName(MatchDefs.X_ATTRIBUTE_PLATFORM_TYPE)
                + " = @" + ParamName(MatchDefs.X_ATTRIBUTE_PLATFORM_TYPE)
                + " AND 1 = s." + AttributeName(MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK) + "))\n");
        sb.Append("       -- Filters from the xlast file.\n");

        // now write out the actual filters (skipping type and mode) with "AND" in between
        foreach (MatchQueryFilter filter in matchQuery.Filters)
        {
            if (filter.Left != MatchDefs.X_ATTRIBUTE_GAME_MODE && filter.Left != MatchDefs.X_ATTRIBUTE_GAME_TYPE)
            {
                sb.Append("        AND ");
                sb.Append(FilterToSql(filter, matchGameConfig));
            }
        }

        //
        // finally, emit filters for the weighted search bounding box.  (but only if the caller requested them)
        //
        if (fEmitWeightedBoxFilters)
        {
            sb.Append("       -- each attribute of the session must be within the bounds that are currently established \n");
            foreach (MatchQueryParam param in matchQuery.Parameters)
            {
                if (param.IsWeighted == true)
                {
                    sb.Append("        AND ((@" + WeightParamName(param.Id) + " = 0)\n"); // if the param's weight is zero (or less), we won't evaluate anything more
                    if (param.IsExactMatch == true)
                    {
                        sb.Append("            OR ((cast(cast(" + AttributeName(param.Id) + "-@" + ParamName(param.Id) + " as bit) as real)) <= @" + ParamName(param.Id) + "_alloweddistance))\n");
                    }
                    else
                    {
                        sb.Append("            OR (" + AttributeName(param.Id) + " BETWEEN (@" + ParamName(param.Id) + " - " + "@" + ParamName(param.Id) + "_alloweddistance)\n");
                        sb.Append("            AND (@" + ParamName(param.Id) + " + " + "@" + ParamName(param.Id) + "_alloweddistance)))\n");
                    }
                }
            }
        }
    }

    public static string[] AffiliatesQueryProc(MatchGameConfig matchGameConfig, uint queryId)
    {
        string tableName = StandardTableName(matchGameConfig);
        string procName = AffiliatesQueryProcName(matchGameConfig, queryId);
        MatchQuery matchQuery = (MatchQuery)matchGameConfig.MatchQueries[queryId];
        string[] sqlStatements = new string[3];

        string msg = "Generating sql statements for proc " + procName;
        Log(msg);

        StringBuilder sb = new StringBuilder();

        sb.Append("IF NOT EXISTS (SELECT name FROM dbo.sysobjects WHERE type = 'p' AND name = '" + procName + "')\n");
        sb.Append("BEGIN \n");
        sb.Append("    EXEC('create procedure dbo." + procName + " as raiserror(''Empty Stored Procedure!!'', 16, 1) with seterror')\n");
        sb.Append("    IF (@@error != 0)\n");
        sb.Append("    BEGIN\n");
        sb.Append("        PRINT 'FAILED to create stored procedure.'\n");
        sb.Append("    END\n");
        sb.Append("END\n");

        // make the newlines in the string Windows style
        sb.Replace("\n", "\r\n");

        sqlStatements[0] = sb.ToString();

        sb = new StringBuilder();

        sb.Append("ALTER PROCEDURE [dbo].[" + procName + "]\n");

        // the front door does not know the title defined max results, for this 
        // query, but this procedure does, so we return it to the front door
        sb.Append("    @i_max_results                  int OUTPUT\n");
        sb.Append("   ,@si_required_slots              smallint\n");
        sb.Append("   ,@i_client_ip                    int\n");
        sb.Append("   ,@ti_nat_type                    tinyint\n");
        sb.Append("   ,@ti_server_count                tinyint\n");

        // The session ids we are looking for are passed in a varbinary array
        // the number of session ids in the array is passed in i_session_id_count
        // with 8000 bytes, up to 1000 session ids can be passed.
        sb.Append("   ,@i_session_id_count             int\n");
        sb.Append("   ,@vb_session_ids                 varbinary(8000)\n");

        // built in params not listed in xlast but added to all queries
        sb.Append("   ,@" + ParamName(MatchDefs.X_ATTRIBUTE_GAME_TYPE) + "               "
            + IdToSqlType(MatchDefs.X_ATTRIBUTE_GAME_TYPE) + "\n");
        sb.Append("   ,@" + ParamName(MatchDefs.X_ATTRIBUTE_GAME_MODE) + "               "
            + IdToSqlType(MatchDefs.X_ATTRIBUTE_GAME_MODE) + "\n");
        sb.Append("   ,@" + ParamName(MatchDefs.X_ATTRIBUTE_GAMER_ZONE) + "               "
            + IdToSqlType(MatchDefs.X_ATTRIBUTE_GAMER_ZONE) + " = "
            + MatchDefs.X_ATTRIBUTE_GAMER_ZONE_DEFAULT.ToString() + "\n");
        sb.Append("   ,@" + ParamName(MatchDefs.X_ATTRIBUTE_GAMER_COUNTRY) + "               "
            + IdToSqlType(MatchDefs.X_ATTRIBUTE_GAMER_COUNTRY) + " = "
            + MatchDefs.X_ATTRIBUTE_GAMER_COUNTRY_DEFAULT.ToString() + "\n");
        sb.Append("   ,@" + ParamName(MatchDefs.X_ATTRIBUTE_GAMER_LANGUAGE) + "               "
            + IdToSqlType(MatchDefs.X_ATTRIBUTE_GAMER_LANGUAGE) + " = "
            + MatchDefs.X_ATTRIBUTE_GAMER_LANGUAGE_DEFAULT.ToString() + "\n");
        sb.Append("   ,@" + ParamName(MatchDefs.X_ATTRIBUTE_GAMER_RATING) + "               "
            + IdToSqlType(MatchDefs.X_ATTRIBUTE_GAMER_RATING) + " = "
            + MatchDefs.X_ATTRIBUTE_GAMER_RATING_DEFAULT.ToString() + "\n");
        sb.Append("   ,@" + ParamName(MatchDefs.X_ATTRIBUTE_GAMER_MU) + "               "
            + IdToSqlType(MatchDefs.X_ATTRIBUTE_GAMER_MU) + " = "
            + MatchDefs.X_ATTRIBUTE_GAMER_MU_DEFAULT.ToString() + "\n");
        sb.Append("   ,@" + ParamName(MatchDefs.X_ATTRIBUTE_GAMER_SIGMA) + "               "
            + IdToSqlType(MatchDefs.X_ATTRIBUTE_GAMER_SIGMA) + " = "
            + MatchDefs.X_ATTRIBUTE_GAMER_SIGMA_DEFAULT.ToString() + "\n");
        sb.Append("   ,@" + ParamName(MatchDefs.X_ATTRIBUTE_GAMER_PUID) + "               "
            + IdToSqlType(MatchDefs.X_ATTRIBUTE_GAMER_PUID) + " = 0\n");
        sb.Append("   ,@" + ParamName(MatchDefs.X_ATTRIBUTE_GAMER_HOSTNAME) + "               "
            + IdToSqlType(MatchDefs.X_ATTRIBUTE_GAMER_HOSTNAME) + " = ''\n");
        sb.Append("   ,@" + ParamName(MatchDefs.X_ATTRIBUTE_PLATFORM_TYPE) + "               "
            + IdToSqlType(MatchDefs.X_ATTRIBUTE_PLATFORM_TYPE) + " = 0\n");
        sb.Append("   ,@" + ParamName(MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK) + "               "
            + IdToSqlType(MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK) + " = 0\n");

        // title defined query params
        foreach (MatchQueryParam param in matchQuery.Parameters)
        {
            if (!MatchDefs.IsSystemAttribute(param.Id))
            {
                sb.Append("   ,@" + ParamName(param.Id) + "               "
                    + IdToSqlType(param.Id) + " = NULL\n");
            }
        }

        sb.Append("\n");
        sb.Append("AS\n");
        sb.Append("-- Match Code Generator Version - !!Version=" + VersionString + "\n");
        sb.Append("-- Xlast (XDK) Version = " + matchGameConfig.XlastVersion + "\n");
        sb.Append("-- Xlast Project Version = " + matchGameConfig.ProjectVersion + "\n");
        sb.Append("BEGIN\n");

        // let the front door know how many results should be returned to the client
        // for this query
        sb.Append("    SET @i_max_results = " + matchQuery.MaxResults + "\n");
        sb.Append("\n");

        // Loop through the session ids passed, performing one select statement
        // per session id. Each select statement generates a result set,
        // which will have either 0 or 1 rows in it. We loop twice, once
        // to get all affiliate sessions in the same gamer zone, and once
        // to get all affiliate sessions in different gamer zones.

        sb.Append("    DECLARE @bi_session_id bigint\n");
        sb.Append("    DECLARE @b_session_id binary(8)\n");
        sb.Append("    DECLARE @i int\n");
        sb.Append("\n");
        sb.Append("    SET @i = 0\n");
        sb.Append("    WHILE (@i < @i_session_id_count)\n");
        sb.Append("    BEGIN\n");
        // note, sql substring is 1 based, not zero based!
        sb.Append("        set @b_session_id = substring(@vb_session_ids, 1+(@i * 8), 8)\n");
        sb.Append("        set @bi_session_id = convert(bigint, @b_session_id)\n");
        sb.Append("        SELECT\n");
        sb.Append("            s.bi_session_id\n");
        sb.Append("           ,s.b_host_address\n");
        sb.Append("           ,s.b_key_exchange_key\n");
        sb.Append("           ,s.i_public_available\n");
        sb.Append("           ,s.i_private_available\n");
        sb.Append("           ,s.i_public_current\n");
        sb.Append("           ,s.i_private_current\n");
        foreach (DictionaryEntry de in matchQuery.Returns)
        {
            MatchQueryReturn queryReturn = (MatchQueryReturn)de.Value;
            sb.Append("           ,s." + AttributeName(queryReturn.Id) + "\n");
        }
        sb.Append("           ,s." + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_ZONE) + "\n");
        sb.Append("           ,s." + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_HOSTNAME) + "\n");
        sb.Append("        FROM " + tableName + " s WITH (NOLOCK)\n");
        sb.Append("        WHERE\n");
        sb.Append("              (s.bi_session_id = @bi_session_id)\n");
        sb.Append("              AND (s.ti_is_available = 1)\n");
        sb.Append("              AND (s." + AttributeName(MatchDefs.X_ATTRIBUTE_GAME_TYPE)
            + " = @" + ParamName(MatchDefs.X_ATTRIBUTE_GAME_TYPE) + ")\n");
        sb.Append("              AND (s." + AttributeName(MatchDefs.X_ATTRIBUTE_GAME_MODE)
            + " = @" + ParamName(MatchDefs.X_ATTRIBUTE_GAME_MODE) + ")\n");
        sb.Append("              AND (s.i_public_available >= @si_required_slots)\n");
        sb.Append("              AND (s.i_ip_addr = @i_client_ip OR s.ti_nat_type + @ti_nat_type < 5)\n"); // Match if inaOnline matches (behind same NAT) or NATs are compatible
        sb.Append("              AND ((0 = s." + AttributeName(MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK)
                + " AND 0 = @" + ParamName(MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK) + ")\n"
                + "                OR (s." + AttributeName(MatchDefs.X_ATTRIBUTE_PLATFORM_TYPE)
                + " = @" + ParamName(MatchDefs.X_ATTRIBUTE_PLATFORM_TYPE)
                + " AND 1 = s." + AttributeName(MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK) + "))\n");
        foreach (MatchQueryFilter filter in matchQuery.Filters)
        {
            sb.Append("              AND ");
            sb.Append(FilterToSql(filter, matchGameConfig));
        }
        sb.Append("        set @i = @i + 1\n");
        sb.Append("    END\n");
        sb.Append("\n");
        sb.Append("    RETURN 0\n");
        sb.Append("END\n");

        // make the newlines in the string Windows style
        sb.Replace("\n", "\r\n");

        sqlStatements[1] = sb.ToString();

        sqlStatements[2] = "GRANT EXECUTE ON " + procName + " TO ClientLib\r\n";

        Log("Generated " + sqlStatements.Length + " sql statements for proc " + procName);

        return sqlStatements;
    }

    private static string AffiliatesQueryProcName(MatchGameConfig matchGameConfig, uint queryId)
    {
        return "p_match_session_v2_0x" + matchGameConfig.TitleId.ToString("X8")
            + "_0x" + queryId.ToString("X8") + "_search_affiliates";
    }


    public static string[] LockAndReadProc(MatchGameConfig matchGameConfig)
    {
        string rankedTableName = RankedTableName(matchGameConfig);
        string standardTableName = StandardTableName(matchGameConfig);
        string procName = LockAndReadProcName(matchGameConfig);
        string[] sqlStatements = new string[3];

        string msg = "Generating sql statements for proc " + procName;
        Log(msg);

        StringBuilder sb = new StringBuilder();

        sb.Append("IF NOT EXISTS (SELECT name FROM dbo.sysobjects WHERE type = 'p' AND name = '" + procName + "')\n");
        sb.Append("BEGIN \n");
        sb.Append("    EXEC('create procedure dbo." + procName + " as raiserror(''Empty Stored Procedure!!'', 16, 1) with seterror')\n");
        sb.Append("    IF (@@error != 0)\n");
        sb.Append("    BEGIN\n");
        sb.Append("        PRINT 'FAILED to create stored procedure.'\n");
        sb.Append("    END\n");
        sb.Append("END\n");

        // make the newlines in the string Windows style
        sb.Replace("\n", "\r\n");

        sqlStatements[0] = sb.ToString();

        sb = new StringBuilder();

        sb.Append("ALTER PROCEDURE [dbo].[" + procName + "]\n");
        sb.Append("   @bi_session_id              bigint\n");
        sb.Append("\n");
        sb.Append("AS\n");
        sb.Append("-- Match Code Generator Version - !!Version=" + VersionString + "\n");
        sb.Append("-- Xlast (XDK) Version = " + matchGameConfig.XlastVersion + "\n");
        sb.Append("-- Xlast Project Version = " + matchGameConfig.ProjectVersion + "\n");
        sb.Append("BEGIN\n");
        sb.Append("\n");
        sb.Append("declare @dt_lock_expire datetime\n");
        sb.Append("declare @ti_current_bc_state tinyint\n");
        sb.Append("declare @dt_deletion_time datetime\n");
        sb.Append("declare @error_var int\n");      
        sb.Append("declare @i_return_code int\n");       
        sb.Append("declare @rowcount_var int\n");
        sb.Append("declare @ti_remote_data int -- not used, but necessary to make shared code happy\n");
        sb.Append("declare @ti_partition_changed int -- not used, but necessary to make shared code happy\n");
        sb.Append("set @rowcount_var = 0\n");
        sb.Append("set @error_var = 0\n");  
        sb.Append("set @i_return_code = 0\n");             
        sb.Append("-- get some useful info about this session from the appropriate table.\n");
        sb.Append("if ((@bi_session_id & 0x0000000000000300) = 0)\n");
        sb.Append("begin\n");
        sb.Append("    SELECT @dt_lock_expire = dt_lock_expire, \n");
        sb.Append("        @ti_current_bc_state = ti_breadcrumb_state,\n");  // TODOTHEOM: is it worth checking breadcrumb state?
        sb.Append("        @dt_deletion_time = dt_deletion_time\n");
        sb.Append("    FROM dbo." + rankedTableName + "\n");
        sb.Append("    WHERE bi_session_id = @bi_session_id \n");
        sb.Append("end\n");
        sb.Append("else\n");
        sb.Append("begin\n");
        sb.Append("    SELECT @dt_lock_expire = dt_lock_expire,\n");
        sb.Append("        @ti_current_bc_state = ti_breadcrumb_state,\n");
        sb.Append("        @dt_deletion_time = dt_deletion_time\n");
        sb.Append("    FROM dbo." + standardTableName + "\n");
        sb.Append("    WHERE bi_session_id = @bi_session_id\n");
        sb.Append("end\n");
        sb.Append("\n");
        sb.Append("-- check if the session has been marked for deletion.  Return failure.\n");
        sb.Append("if(@dt_deletion_time IS NOT NULL)\n");
        sb.Append("begin\n");
        sb.Append("    SET @i_return_code = 0x80155100  -- XONLINE_E_MATCH_INVALID_SESSION_ID\n");
        sb.Append("    goto exit_label\n");
        sb.Append("end\n");
        sb.Append("\n");
        sb.Append("-- check the lock status.  If locked, return failure.\n");
        sb.Append("if (@dt_lock_expire IS NOT NULL and\n");
        sb.Append("    GETUTCDATE() < @dt_lock_expire )\n");
        sb.Append("begin\n");
        sb.Append("    set @i_return_code = 0x80155127 -- XONLINE_E_MATCH_CONCURRENT_REQ_CONFLICT\n");
        sb.Append("    goto exit_label\n");
        sb.Append("end\n");
        sb.Append("\n");
        sb.Append("    set @dt_lock_expire = DATEADD(second, 10, GETUTCDATE())\n"); // TODOTHEOM: consts for lock expiration, here and above
        sb.Append("if ((@bi_session_id & 0x0000000000000300) = 0)\n");
        sb.Append("begin\n");
        sb.Append("        UPDATE dbo." + rankedTableName + " SET\n");
        sb.Append("            dt_lock_expire =  @dt_lock_expire\n");
        sb.Append("    WHERE bi_session_id = @bi_session_id \n");
        sb.Append("    SELECT @error_var = @@ERROR, @rowcount_var = @@ROWCOUNT\n");
        sb.Append("end\n");
        sb.Append("else\n");
        sb.Append("begin\n");
        sb.Append("        UPDATE dbo." + standardTableName + " SET\n");
        sb.Append("            dt_lock_expire =  @dt_lock_expire\n");
        sb.Append("    WHERE bi_session_id = @bi_session_id\n");
        sb.Append("    SELECT @error_var = @@ERROR, @rowcount_var = @@ROWCOUNT\n");
        sb.Append("end\n");
        sb.Append("\n");
        sb.Append("    IF @error_var != 0\n");
        sb.Append("    BEGIN\n");
        sb.Append("        SET @i_return_code = 0x80155115  -- XONLINE_E_MATCH_CRITICAL_DB_ERR\n");
        sb.Append("        GOTO exit_label\n");
        sb.Append("    END\n");
        sb.Append("\n");
        sb.Append("    IF @rowcount_var = 0\n");
        sb.Append("    BEGIN\n");
        sb.Append("        SET @i_return_code = 0x80155100  -- XONLINE_E_MATCH_INVALID_SESSION_ID\n");
        sb.Append("        GOTO exit_label\n");
        sb.Append("    END\n");
        sb.Append("\n");
        sb.Append("-- grab the row we just locked, to return to the FD\n");
        sb.Append("if ((@bi_session_id & 0x0000000000000300) = 0)\n");
        sb.Append("begin\n");
        EmitReturnRowSql(ref sb, rankedTableName, matchGameConfig);
        sb.Append("    SELECT @error_var = @@ERROR, @rowcount_var = @@ROWCOUNT\n");
        sb.Append("end\n");
        sb.Append("else\n");
        sb.Append("begin\n");
        EmitReturnRowSql(ref sb, standardTableName, matchGameConfig);
        sb.Append("    SELECT @error_var = @@ERROR, @rowcount_var = @@ROWCOUNT\n");
        sb.Append("end\n");
        sb.Append("\n");
        sb.Append("    IF @error_var != 0\n");
        sb.Append("    BEGIN\n");
        sb.Append("        SET @i_return_code = 0x80155115  -- XONLINE_E_MATCH_CRITICAL_DB_ERR\n");
        sb.Append("        GOTO exit_label\n");
        sb.Append("    END\n");
        sb.Append("\n");
        sb.Append("    IF @rowcount_var = 0\n");
        sb.Append("    BEGIN\n");
        sb.Append("        SET @i_return_code = 0x80155100  -- XONLINE_E_MATCH_INVALID_SESSION_ID\n");
        sb.Append("        GOTO exit_label\n");
        sb.Append("    END\n");
        sb.Append("\n");
        sb.Append("    RETURN\n");

        sb.Append("exit_label:\n");
        sb.Append("    IF @error_var != 0\n");
        sb.Append("    BEGIN\n");
        sb.Append("        IF @i_return_code = 0\n");
        sb.Append("        BEGIN\n");
        sb.Append("            SET @i_return_code = 0x80155115  -- XONLINE_E_MATCH_CRITICAL_DB_ERR\n");
        sb.Append("        END\n");
        sb.Append("        DECLARE @message varchar(255)\n");
        sb.Append("        SELECT @message = 'XMATCH_SESSION_UPDATE_FAILED: " + procName
            + " - ' + CAST(CAST(CAST(@error_var AS binary(4)) AS int) AS varchar(64))\n");
        sb.Append("        EXEC master.dbo.xp_logevent 51710, @message, error\n");
        sb.Append("    END\n");
        sb.Append("    SELECT @i_return_code as i_return_code\n");
        sb.Append("    RETURN\n");
        sb.Append("END\n");

        // make the newlines in the string Windows style
        sb.Replace("\n", "\r\n");

        sqlStatements[1] = sb.ToString();

        sqlStatements[2] = "GRANT EXECUTE ON " + procName + " TO ClientLib\r\n";

        Log("Generated " + sqlStatements.Length + " sql statements for proc " + procName);

        return sqlStatements;
    }

    private static string LockAndReadProcName(MatchGameConfig matchGameConfig)
    {
        return "p_match_session_v2_0x" + matchGameConfig.TitleId.ToString("X8") + "_lock_and_read";
    }


    public static string[] ReleaseLockProc(MatchGameConfig matchGameConfig)
    {
        string rankedTableName = RankedTableName(matchGameConfig);
        string standardTableName = StandardTableName(matchGameConfig);
       
        string procName = ReleaseLockProcName(matchGameConfig);
        string[] sqlStatements = new string[3];

        string msg = "Generating sql statements for proc " + procName;
        Log(msg);

        StringBuilder sb = new StringBuilder();

        sb.Append("IF NOT EXISTS (SELECT name FROM dbo.sysobjects WHERE type = 'p' AND name = '" + procName + "')\n");
        sb.Append("BEGIN \n");
        sb.Append("    EXEC('create procedure dbo." + procName + " as raiserror(''Empty Stored Procedure!!'', 16, 1) with seterror')\n");
        sb.Append("    IF (@@error != 0)\n");
        sb.Append("    BEGIN\n");
        sb.Append("        PRINT 'FAILED to create stored procedure.'\n");
        sb.Append("    END\n");
        sb.Append("END\n");

        // make the newlines in the string Windows style
        sb.Replace("\n", "\r\n");

        sqlStatements[0] = sb.ToString();

        sb = new StringBuilder();

        sb.Append("ALTER PROCEDURE [dbo].[" + procName + "]\n");
        sb.Append("   @bi_session_id              bigint\n");
        sb.Append("\n");
        sb.Append("AS\n");
        sb.Append("-- Match Code Generator Version - !!Version=" + VersionString + "\n");
        sb.Append("-- Xlast (XDK) Version = " + matchGameConfig.XlastVersion + "\n");
        sb.Append("-- Xlast Project Version = " + matchGameConfig.ProjectVersion + "\n");
        sb.Append("BEGIN\n");
        sb.Append("\n");


        sb.Append("declare @dt_lock_expire datetime\n");
        sb.Append("declare @ti_current_bc_state tinyint\n");
        sb.Append("declare @dt_deletion_time datetime\n");
        sb.Append("declare @error_var int\n");        
        sb.Append("declare @i_return_code int\n");        
        sb.Append("declare @rowcount_var int\n");        
        sb.Append("set @rowcount_var = 0\n");
        sb.Append("set @error_var = 0\n");
        sb.Append("set @i_return_code = 0\n");
        sb.Append("-- get some useful info about this session from the appropriate table.\n");
        sb.Append("if ((@bi_session_id & 0x0000000000000300) = 0)\n");
        sb.Append("begin\n");
        sb.Append("    SELECT @dt_lock_expire = dt_lock_expire, \n");
        sb.Append("        @ti_current_bc_state = ti_breadcrumb_state,\n");  // TODOTHEOM: is it worth checking breadcrumb state?
        sb.Append("        @dt_deletion_time = dt_deletion_time\n");
        sb.Append("    FROM dbo." + rankedTableName + "\n");
        sb.Append("    WHERE bi_session_id = @bi_session_id \n");
        sb.Append("end\n");
        sb.Append("else\n");
        sb.Append("begin\n");
        sb.Append("    SELECT @dt_lock_expire = dt_lock_expire,\n");
        sb.Append("        @ti_current_bc_state = ti_breadcrumb_state,\n");
        sb.Append("        @dt_deletion_time = dt_deletion_time\n");
        sb.Append("    FROM dbo." + standardTableName + "\n");
        sb.Append("    WHERE bi_session_id = @bi_session_id\n");
        sb.Append("end\n");
        sb.Append("\n");
        sb.Append("-- check if the session has been marked for deletion.  Return failure.\n");
        sb.Append("if(@dt_deletion_time IS NOT NULL)\n");
        sb.Append("begin\n");
        sb.Append("    SET @i_return_code = 0x80155100  -- XONLINE_E_MATCH_INVALID_SESSION_ID\n");
        sb.Append("    goto exit_label\n");
        sb.Append("end\n");
        sb.Append("\n");
        sb.Append("-- check the lock status.  If locked, return failure.\n");
        sb.Append("if (@dt_lock_expire IS NULL OR\n");
        sb.Append("    GETUTCDATE() > @dt_lock_expire )\n");
        sb.Append("begin\n");
        sb.Append("    set @i_return_code = 0x80155129 -- XONLINE_E_MATCH_LOCK_ALREADY_RELEASED - let the caller know the lock was old, but go ahead and clear it.\n"); 
        sb.Append("end\n");
        sb.Append("\n");
        sb.Append("if ((@bi_session_id & 0x0000000000000300) = 0)\n");
        sb.Append("begin\n");
        sb.Append("        UPDATE dbo." + rankedTableName + " SET\n");
        sb.Append("            dt_lock_expire =  NULL\n");
        sb.Append("    WHERE bi_session_id = @bi_session_id \n");
        sb.Append("    SELECT @error_var = @@ERROR, @rowcount_var = @@ROWCOUNT\n");
        sb.Append("end\n");
        sb.Append("else\n");
        sb.Append("begin\n");
        sb.Append("        UPDATE dbo." + standardTableName + " SET\n");
        sb.Append("            dt_lock_expire =  NULL\n");
        sb.Append("    WHERE bi_session_id = @bi_session_id\n");
        sb.Append("    SELECT @error_var = @@ERROR, @rowcount_var = @@ROWCOUNT\n");
        sb.Append("end\n");
        sb.Append("\n");
        sb.Append("    IF @error_var != 0\n");
        sb.Append("    BEGIN\n");
        sb.Append("        SET @i_return_code = 0x80155115  -- XONLINE_E_MATCH_CRITICAL_DB_ERR\n");
        sb.Append("        GOTO exit_label\n");
        sb.Append("    END\n");
        sb.Append("\n");
        sb.Append("    IF @rowcount_var = 0\n");
        sb.Append("    BEGIN\n");
        sb.Append("        SET @i_return_code = 0x80155100  -- XONLINE_E_MATCH_INVALID_SESSION_ID\n");
        sb.Append("        GOTO exit_label\n");
        sb.Append("    END\n");
        sb.Append("\n");

        sb.Append("exit_label:\n");
        sb.Append("    IF @error_var != 0\n");
        sb.Append("    BEGIN\n");
        sb.Append("        IF @i_return_code = 0\n");
        sb.Append("        BEGIN\n");
        sb.Append("            SET @i_return_code = 0x80155115  -- XONLINE_E_MATCH_CRITICAL_DB_ERR\n");
        sb.Append("        END\n");
        sb.Append("        DECLARE @message varchar(255)\n");
        sb.Append("        SELECT @message = 'XMATCH_SESSION_UPDATE_FAILED: " + procName
            + " - ' + CAST(CAST(CAST(@error_var AS binary(4)) AS int) AS varchar(64))\n");
        sb.Append("        EXEC master.dbo.xp_logevent 51710, @message, error\n");
        sb.Append("    END\n");
        sb.Append("    RETURN @i_return_code\n");
        sb.Append("END\n");


        // make the newlines in the string Windows style
        sb.Replace("\n", "\r\n");

        sqlStatements[1] = sb.ToString();

        sqlStatements[2] = "GRANT EXECUTE ON " + procName + " TO ClientLib\r\n";

        Log("Generated " + sqlStatements.Length + " sql statements for proc " + procName);

        return sqlStatements;
    }

    private static string ReleaseLockProcName(MatchGameConfig matchGameConfig)
    {
        return "p_match_session_v2_0x" + matchGameConfig.TitleId.ToString("X8") + "_release_lock";
    }




    public static string[] SessionCleanupProc(MatchGameConfig matchGameConfig, MatchLtcConfig matchLtcConfig)
    {
        string rankedTableName = RankedTableName(matchGameConfig);
        string standardTableName = StandardTableName(matchGameConfig);
        string strTitleId = "0x" + matchGameConfig.TitleId.ToString("X8");
       
        string procName = SessionCleanupProcName(matchGameConfig);
        string[] sqlStatements = new string[2];

        string msg = "Generating sql statements for proc " + procName;
        Log(msg);

        StringBuilder sb = new StringBuilder();

        sb.Append("IF NOT EXISTS (SELECT name FROM dbo.sysobjects WHERE type = 'p' AND name = '" + procName + "')\n");
        sb.Append("BEGIN \n");
        sb.Append("    EXEC('create procedure dbo." + procName + " as raiserror(''Empty Stored Procedure!!'', 16, 1) with seterror')\n");
        sb.Append("    IF (@@error != 0)\n");
        sb.Append("    BEGIN\n");
        sb.Append("        PRINT 'FAILED to create stored procedure.'\n");
        sb.Append("    END\n");
        sb.Append("END\n");

        // make the newlines in the string Windows style
        sb.Replace("\n", "\r\n");

        sqlStatements[0] = sb.ToString();

        sb = new StringBuilder();

        sb.Append("ALTER PROCEDURE [dbo].[" + procName + "]\n");
        // These parameters do not do anything.
        // They are simply here for back-compat with the old version of the job
        // that calls this sproc with parameters.  They are optional so the new job
        // does not need to send parameters.  The default values are never used.
        sb.Append("-- The passed in parameters are from when the job was originally created.\n");
        sb.Append("-- The latest configuration is hardcoded into this sproc further down.\n");
        sb.Append("   @nMaxSessionsAvail int = 0\n");
        sb.Append("   ,@nSessionTruncateLevelAvail int = 0\n");
        sb.Append("   ,@nSessionWarnLevelAvail int = 0\n");
        sb.Append("   ,@nMaxSessionsUnavail int = 0\n");
        sb.Append("   ,@nSessionTruncateLevelUnavail int = 0\n");
        sb.Append("   ,@nSessionWarnLevelUnavail int = 0\n");
        sb.Append("\n");
        sb.Append("AS\n");
        sb.Append("-- Match Code Generator Version - !!Version=" + VersionString + "\n");
        sb.Append("-- Xlast (XDK) Version = " + matchGameConfig.XlastVersion + "\n");
        sb.Append("-- Xlast Project Version = " + matchGameConfig.ProjectVersion + "\n");
        sb.Append("BEGIN\n");
        sb.Append("\n");

        sb.Append("SET NOCOUNT ON\n");
        if (matchLtcConfig.MatchSessionLimitEnabled == true)
        {
            sb.Append("declare @cRankedSessions int\n");
            sb.Append("declare @cStandardSessions int\n");
            sb.Append("declare @fpRankedSessions float -- declared as a float so that it can be divided and result in a float\n");
            sb.Append("declare @fpStandardSessions float -- ditto\n");
            sb.Append("declare @cTotalSessions int\n");
            sb.Append("declare @cSessionsToDelete int\n");
            sb.Append("declare @fpRankedRatio float\n");
            sb.Append("declare @fpStandardRatio float\n");
            sb.Append("declare @strErrMessage nvarchar(200)\n");
            sb.Append("declare @nCurrentChunk int\n");
            sb.Append("declare @nMaxDeleteChunk int\n");

            sb.Append("SELECT @nMaxSessionsAvail = " + matchLtcConfig.MatchSessionMaxAvail.ToString() + "\n");
            sb.Append("SELECT @nSessionTruncateLevelAvail = " + matchLtcConfig.MatchSessionTruncateLevelAvail.ToString() + "\n");
            sb.Append("SELECT @nSessionWarnLevelAvail = " + matchLtcConfig.MatchSessionWarnLevelAvail.ToString() + "\n");
            sb.Append("SELECT @nMaxSessionsUnavail = " + matchLtcConfig.MatchSessionMaxUnavail.ToString() + "\n");
            sb.Append("SELECT @nSessionTruncateLevelUnavail = " + matchLtcConfig.MatchSessionTruncateLevelUnavail.ToString() + "\n");
            sb.Append("SELECT @nSessionWarnLevelUnavail = " + matchLtcConfig.MatchSessionWarnLevelUnavail.ToString() + "\n");

            sb.Append("SELECT @cSessionsToDelete = 0\n");
            sb.Append("SELECT @nMaxDeleteChunk = 100\n");
            sb.Append("CREATE TABLE #ToDelete (bi_session_id BIGINT PRIMARY KEY)\n");
            sb.Append("\n");
            EmitSessionCleanupCode(sb, strTitleId, standardTableName, rankedTableName, 0, "Unavail");
            EmitSessionCleanupCode(sb, strTitleId, standardTableName, rankedTableName, 1, "Avail");
            sb.Append("\n");
            sb.Append("DROP TABLE #ToDelete -- just to be explicit\n");
        }
        else
        {
            sb.Append("-- This job has been disabled.\n");
        }
        sb.Append("END\n");


        // make the newlines in the string Windows style
        sb.Replace("\n", "\r\n");

        sqlStatements[1] = sb.ToString();

        Log("Generated " + sqlStatements.Length + " sql statements for proc " + procName);

        return sqlStatements;
    }

    private static string SessionCleanupProcName(MatchGameConfig matchGameConfig)
    {
        return "p_match_session_cleanup_0x" + matchGameConfig.TitleId.ToString("X8");
    }


private static void EmitSessionCleanupCode(StringBuilder sb, string strTitleId, string standardTableName, string rankedTableName, short tiIsAvail, string strParamSuffix)
{
        sb.Append("-- figure out how many sessions we have in standard and ranked\n");
        sb.Append("SELECT @cStandardSessions = count(*) FROM " + standardTableName + " (nolock) WHERE ti_is_available = " + tiIsAvail.ToString() + "\n");
        sb.Append("SELECT @cRankedSessions = count(*) FROM " + rankedTableName + " (nolock) WHERE ti_is_available = " + tiIsAvail.ToString() + "\n");
        sb.Append("SET @cTotalSessions = @cRankedSessions + @cStandardSessions\n");
        sb.Append("\n");
        sb.Append("-- Log a useful message, which should show up in the SQL Agent job history\n");
        sb.Append("SET @strErrMessage = 'p_match_session_cleanup_" + strTitleId + " cleaning up sessions for avail = " + tiIsAvail.ToString() + " -- MaxSessions: %d, TruncateLevel: %d.'\n");
        sb.Append("SET @strErrMessage = @strErrMessage + ' Found -- Total: %d, Ranked: %d, Std: %d'\n");
        sb.Append("\n");
        sb.Append("-- raiseerror works like printf...\n");
        sb.Append("RAISERROR (@strErrMessage,\n");
        sb.Append("            0, -- Severity,\n");
        sb.Append("            1, -- State, \n");
        sb.Append("            @nMaxSessions" + strParamSuffix + ",\n");
        sb.Append("            @nSessionTruncateLevel" + strParamSuffix + ",\n");
        sb.Append("            @cTotalSessions,\n");
        sb.Append("            @cRankedSessions,\n");
        sb.Append("            @cStandardSessions)\n");
        sb.Append("\n");
        sb.Append("-- but raiseerror doesn''t do floating points, so ranked/standard count vars had to be duped.\n");
        sb.Append("SET @fpRankedSessions = @cRankedSessions\n");
        sb.Append("SET @fpStandardSessions = @cStandardSessions\n");
        sb.Append("\n");
        sb.Append("-- only continue cleanup if there are too many sessions\n");
        sb.Append("IF(@cTotalSessions > 0 AND @cTotalSessions > @nMaxSessions" + strParamSuffix + ")\n");
        sb.Append("BEGIN\n");
        sb.Append("    -- calculate the ratio of standard and ranked to total\n");
        sb.Append("    SET @fpStandardRatio = @fpStandardSessions / @cTotalSessions\n");
        sb.Append("    SET @fpRankedRatio = @fpRankedSessions / @cTotalSessions\n");
        sb.Append("\n");
        sb.Append("    -- let the XOC know that were deleting user sessions\n");
        sb.Append("    SET @strErrMessage = 'p_match_session_cleanup -- Alert! Title " + strTitleId + " has exceeded its max sessions with ti_is_available = " + tiIsAvail.ToString() + ". (' + CAST(@cTotalSessions as varchar(10)) + '/' + CAST(@nMaxSessions" + strParamSuffix + " as varchar(10)) + ').  Deleting old sessions.'\n");
        sb.Append("    EXEC xp_logevent " + (((uint) XEvent.Id.MATCH_CODE_SESSION_LIMIT_EXCEEDED) & 0xFFFF).ToString() + ", @strErrMessage, ERROR\n");
        sb.Append("\n");
        sb.Append("    -- do the deleting, proportionally in standard/ranked based on their portion of the total.\n");
        sb.Append("    -- chunk the deletions so that each operation only deletes @nMaxDeleteChunk at most.\n");
        sb.Append("    -- this is intended to reduce the impact of the locks that session deletion holds.\n");
        sb.Append("\n");
        sb.Append("    SELECT @cSessionsToDelete = (@cTotalSessions - @nSessionTruncateLevel" + strParamSuffix + ") * @fpStandardRatio\n");
        sb.Append("    WHILE(@cSessionsToDelete > 0)\n");
        sb.Append("    BEGIN\n");
        sb.Append("        SET @nCurrentChunk = @cSessionsToDelete\n");
        sb.Append("        IF(@nCurrentChunk > @nMaxDeleteChunk)\n");
        sb.Append("        BEGIN\n");
        sb.Append("            SET @nCurrentChunk = @nMaxDeleteChunk\n");
        sb.Append("        END\n");
        sb.Append("        SET @cSessionsToDelete = @cSessionsToDelete - @nCurrentChunk\n");
/*
        sb.Append("        --exec('SELECT TOP ' + @nCurrentChunk + ' * FROM dbo.t_match_sessions_" + strTitleId + "_standard WHERE ti_is_available = " + tiIsAvail.ToString() + " ORDER BY dt_session_expiration ASC'')\n");
        sb.Append("       exec('DELETE FROM dbo.t_match_sessions_" + strTitleId + "_standard WHERE bi_session_id IN (SELECT TOP ' + @nCurrentChunk + ' bi_session_id FROM dbo.t_match_sessions_" + strTitleId + "_standard WHERE ti_is_available = " + tiIsAvail.ToString() + " ORDER BY dt_session_expiration ASC)')\n");
*/
        sb.Append("        truncate table #ToDelete\n");
        sb.Append("        exec('INSERT INTO #ToDelete SELECT TOP ' + @nCurrentChunk + ' bi_session_id FROM dbo.t_match_sessions_" + strTitleId + "_standard with (nolock) WHERE ti_is_available = " + tiIsAvail.ToString() + " ORDER BY dt_session_expiration ASC')\n");
        sb.Append("        delete mss from dbo.t_match_sessions_" + strTitleId + "_standard as mss\n");
        sb.Append("            inner join #ToDelete as td on td.bi_session_id = mss.bi_session_id\n");
        sb.Append("    END\n");
        sb.Append("\n");
        sb.Append("    SELECT @cSessionsToDelete = (@cTotalSessions - @nSessionTruncateLevel" + strParamSuffix + ") * @fpRankedRatio\n");
        sb.Append("    WHILE(@cSessionsToDelete > 0)\n");
        sb.Append("    BEGIN\n");
        sb.Append("        SET @nCurrentChunk = @cSessionsToDelete\n");
        sb.Append("        IF(@nCurrentChunk > @nMaxDeleteChunk)\n");
        sb.Append("        BEGIN\n");
        sb.Append("            SET @nCurrentChunk = @nMaxDeleteChunk\n");
        sb.Append("        END\n");
        sb.Append("        SET @cSessionsToDelete = @cSessionsToDelete - @nCurrentChunk\n");
/*
        sb.Append("        --exec('SELECT TOP ' + @nCurrentChunk + ' * FROM dbo.t_match_sessions_" + strTitleId + "_ranked WHERE ti_is_available = " + tiIsAvail.ToString() + " ORDER BY dt_session_expiration ASC')\n");
        sb.Append("        exec('DELETE FROM dbo.t_match_sessions_" + strTitleId + "_ranked WHERE bi_session_id IN (SELECT TOP ' + @nCurrentChunk + ' bi_session_id FROM dbo.t_match_sessions_" + strTitleId + "_ranked WHERE ti_is_available = " + tiIsAvail.ToString() + " ORDER BY dt_session_expiration ASC)')\n");
*/
        sb.Append("        truncate table #ToDelete\n");
        sb.Append("        exec('INSERT INTO #ToDelete SELECT TOP ' + @nCurrentChunk + ' bi_session_id FROM dbo.t_match_sessions_" + strTitleId + "_ranked with (nolock) WHERE ti_is_available = " + tiIsAvail.ToString() + " ORDER BY dt_session_expiration ASC')\n");
        sb.Append("        delete mss from dbo.t_match_sessions_" + strTitleId + "_ranked as mss\n");
        sb.Append("            inner join #ToDelete as td on td.bi_session_id = mss.bi_session_id\n");
        sb.Append("    END\n");
        sb.Append("END\n");
        sb.Append("ELSE\n");
        sb.Append("BEGIN\n");
        sb.Append("    -- warn the Xoc if the sessions are getting to a suspicious level (but no cleanup yet)\n");
        sb.Append("    IF(@cTotalSessions > @nSessionWarnLevel" + strParamSuffix + ")\n");
        sb.Append("    BEGIN\n");
        sb.Append("        SET @strErrMessage = 'p_match_session_cleanup -- Alert! Title " + strTitleId + " has exceeded its session warning level for sessions with ti_is_available = " + tiIsAvail.ToString() + ". (' + CAST(@cTotalSessions as varchar(10)) + '/' + CAST(@nSessionWarnLevel" + strParamSuffix + " as varchar(10)) + ').  Sessions will be deleted at ' + CAST(@nMaxSessions" + strParamSuffix + " as varchar(10)) + '.'\n");
        sb.Append("        EXEC xp_logevent " + (((uint) XEvent.Id.MATCH_CODE_SESSION_LIMIT_EXCEEDED) & 0xFFFF).ToString() + ", @strErrMessage, ERROR\n");
        sb.Append("    END\n");
        sb.Append("END\n");
}

    public static string[] SessionCleanupJob(MatchGameConfig matchGameConfig, MatchLtcConfig matchLtcConfig)
    {
        string strJobTitleId = "0x" + matchGameConfig.TitleId.ToString("X8");
        string strJobName = "XMatch_j_remove_expired_sessions_" + strJobTitleId;
        
        string[] sqlStatements = new string[1];

        string strJobEnableValue = "1";

        string msg = "Generating sql statements for sql agent job" + strJobName;
        Log(msg);

        StringBuilder sb = new StringBuilder();

        sb.Append("BEGIN TRANSACTION\n");
        sb.Append("DECLARE @ReturnCode INT\n");
        sb.Append("SELECT @ReturnCode = 0\n");
        sb.Append("DECLARE @jobId BINARY(16)\n");
        sb.Append("DECLARE @scheduleId int\n");
        
        // create the "uncategorized" category, because that's what SQL does when you script out a job
        sb.Append("IF NOT EXISTS (SELECT name FROM msdb.dbo.syscategories WHERE name=N'[Uncategorized (Local)]' AND category_class=1)\n");
        sb.Append("BEGIN\n");
        sb.Append("EXEC @ReturnCode = msdb.dbo.sp_add_category @class=N'JOB', @type=N'LOCAL', @name=N'[Uncategorized (Local)]'\n");
        sb.Append("IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback\n");
        sb.Append("END\n");

        // if the job does not exist, assume that none of its components exist either, and create them all.
        // if the job does exist, assume that all its components exist.
        // This is susceptible to someone messing with the job manually, but getting around that is a giant pain.

        // Since the job cannot be modified by users other than the owner or SA, the job will be created and updated
        // only once.  Once the job exists, only the sproc that it calls will be changed.
        // Originally, this was two transactions, one to create the job, and one to update the job.  Now it is a single transaction.
                
        sb.Append("IF NOT EXISTS (SELECT name FROM msdb.dbo.sysjobs WHERE name=N'XMatch_j_remove_expired_sessions_" + strJobTitleId + "') \n");
        sb.Append("BEGIN\n");
        sb.Append("\n");
        
        // Begin by creating the job and adding the necessary components.

        // create a job
        sb.Append("    EXEC @ReturnCode =  msdb.dbo.sp_add_job @job_name=N'" + strJobName + "', \n");
        sb.Append("            @enabled=0, \n");
        sb.Append("            @job_id = @jobId OUTPUT\n");
        sb.Append("    IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback\n");
        sb.Append("\n");

        // add a new step to the job
        sb.Append("    EXEC @ReturnCode = msdb.dbo.sp_add_jobstep @job_id=@jobId, @step_name=N'Execute Session Cleanup Sproc', \n");
        sb.Append("            @step_id=1, \n");
        sb.Append("            @subsystem=N'TSQL' \n");
        sb.Append("    IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback\n");
        sb.Append("\n");

        // add a schedule
        sb.Append("    EXEC @ReturnCode = msdb.dbo.sp_add_schedule \n");
        sb.Append("            @schedule_name=N'" + strJobTitleId + "Schedule', \n");
        sb.Append("            @enabled=0, \n");
        sb.Append("            @freq_interval=1,\n");
        sb.Append("            @freq_type=4,\n");
        sb.Append("            @schedule_id = @scheduleId OUTPUT\n");
        sb.Append("    IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback\n");
        sb.Append("\n");

        // attach the schedule to the job
        sb.Append("    EXEC @ReturnCode = msdb.dbo.sp_attach_schedule \n");
        sb.Append("            @job_id=@jobId, \n");
        sb.Append("            @schedule_id = @scheduleId\n");
        sb.Append("    IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback\n");
        sb.Append("\n");

        // add a server (always localhost) for the job
        sb.Append("    EXEC @ReturnCode = msdb.dbo.sp_add_jobserver @job_id = @jobId, @server_name = N'(local)'\n");
        sb.Append("    IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback\n");
        sb.Append("\n");

        // End of job creation.

        // The next part was originally the second transaction that would update the job with the new settings.
        // Now that the job is not updated after it is created, these steps will occur immediately after the job
        // has been created.

        sb.Append("DECLARE @nStartTimeOffset int\n");
        // If the title has multiple servers, we want this job to run at different times on different servers. 
        // To get the jobs far apart enough in a simple way, add 25 seconds to the start time of each server, mod 60.
        // This way, the jobs start at :00, :25, :50, :15, :40, :05, :20, :45, :10, :35, :00.
        // Add the cleanup offset minutes *100 (for SQL's HHMMSS format).
        sb.Append("SELECT @nStartTimeOffset = 100 * (" + matchLtcConfig.MatchSessionCleanupOffsetMinutes + ") + ((25 * @adoparam_serverindex)%60)\n");
        sb.Append("\n");

        // update the job
        sb.Append("    EXEC @ReturnCode =  msdb.dbo.sp_update_job @job_name=N'" + strJobName + "', \n");
        sb.Append("            @enabled=" + strJobEnableValue + ", \n");
        sb.Append("            @start_step_id = 1, \n");
        sb.Append("            @notify_level_eventlog=2,  -- log on failure\n");
        sb.Append("            @notify_level_email=0, \n");
        sb.Append("            @notify_level_netsend=0, \n");
        sb.Append("            @notify_level_page=0, \n");
        sb.Append("            @delete_level=0, \n");
        sb.Append("            @description=N'No description available.', \n");
        sb.Append("            @category_name=N'[Uncategorized (Local)]' \n");
        sb.Append("    IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback\n");
        sb.Append("\n");

        // update the step
        sb.Append("    EXEC @ReturnCode = msdb.dbo.sp_update_jobstep @job_name= N'" + strJobName + "', \n");
        sb.Append("            @step_id=1, \n");
        sb.Append("            @cmdexec_success_code=0, \n");
        sb.Append("            @on_success_action=1, -- quit with success \n");
        sb.Append("            @on_success_step_id=0, \n");
        sb.Append("            @on_fail_action=2,  -- quit with failure\n");
        sb.Append("            @on_fail_step_id=0, \n");
        sb.Append("            @retry_attempts=0, \n");
        sb.Append("            @retry_interval=0, \n");
        sb.Append("            @os_run_priority=0, \n");
        sb.Append("            @subsystem=N'TSQL', \n");
        sb.Append("            @command=");

        // Call the sproc for the job command.  The sproc will be changed as needed when the session
        // cleanup configuration changes.
        sb.Append("N'exec [XMatch].dbo.");
        sb.Append(SessionCleanupProcName(matchGameConfig));
        // The sproc has optional parameters that are not actually used.  They are there to support
        // the previous version of this job that always sent parameters.
        // The sproc will have the most updated version of these parameters hardcoded into it.
        sb.Append("',\n");

        sb.Append("            @database_name=N'xmatch', \n");
        sb.Append("            @flags=0\n");
        sb.Append("    IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback\n");
        sb.Append("\n");

        // set that first (and only) step to be the starting step
        sb.Append("    EXEC @ReturnCode = msdb.dbo.sp_update_job @job_name = N'" + strJobName + "', @start_step_id = 1\n");
        sb.Append("    IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback\n");
        sb.Append("\n");

        // update the schedule as per the LTC configuration
        sb.Append("    EXEC @ReturnCode = msdb.dbo.sp_update_schedule \n");
        sb.Append("            @name=N'" + strJobTitleId + "Schedule', \n");
        sb.Append("            @enabled=1, \n");
        sb.Append("            @freq_type=4, -- daily \n");
        sb.Append("            @freq_interval=1,  \n");
        sb.Append("            @freq_subday_type=4, -- run every freq_subday_interval minutes \n");
        sb.Append("            @freq_subday_interval=" + matchLtcConfig.MatchSessionCleanupPeriodMinutes + ", -- this is the interval in minutes\n");
        sb.Append("            @freq_relative_interval=0, -- not used\n");
        sb.Append("            @freq_recurrence_factor=0,  -- not used\n");
        sb.Append("            @active_start_date=20080206, -- start date in the past\n");
        sb.Append("            @active_end_date=99991231,  -- end date way in the future\n");
        sb.Append("            @active_start_time=@nStartTimeOffset,  -- start time offset from midnight by a number of minutes to create different schedules.\n");
        sb.Append("            @active_end_time=235959\n");
        sb.Append("    IF (@@ERROR <> 0 OR @ReturnCode <> 0) GOTO QuitWithRollback\n");
        sb.Append("\n");

        // End of job configuration.

        sb.Append("END\n"); // END of IF job doesn't exist block

        sb.Append("COMMIT TRANSACTION\n");
        sb.Append("GOTO EndSave\n");
        sb.Append("QuitWithRollback:\n");
        sb.Append("IF (@@TRANCOUNT > 0) ROLLBACK TRANSACTION\n");
        sb.Append("EndSave:\n");

        // make the newlines in the string Windows style
        sb.Replace("\n", "\r\n");

        sqlStatements[0] = sb.ToString();

        Log("Generated " + sqlStatements.Length + " sql statements for job " + strJobName);

        return sqlStatements;
    }


    private static string ParamName(uint id)
    {
        return "param_0x" + MaskId(id).ToString("X8");
    }

    private static string WeightParamName(uint id)
    {
        return "param_0x" + MaskId(id).ToString("X8") + "_weight";
    }

    private static string FilterToSql(MatchQueryFilter filter, MatchGameConfig matchGameConfig)
    {
        StringBuilder sb = new StringBuilder();

        switch (filter.LeftType)
        {
        case "Parameter":
            switch (filter.RightType)
            {
            case "Parameter":
                throw new ExceptionWithEventId(XEvent.Id.MATCH_CONFIG_58,
                    "Illegal Match Query Filter detected. "
                    + "Right side cannot be a Parameter when Left side is a Parameter. "
                    + "Titleid: " + matchGameConfig.TitleId.ToString("X8")
                    + " Left Side id: " + filter.Left.ToString("X8")
                    + " Right Side id: " + filter.Right.ToString("X8"));

            case "Attribute":
                sb.Append(FilterParamLeftAttributeRight(filter, matchGameConfig));
                break;

            case "Constant":
                throw new ExceptionWithEventId(XEvent.Id.MATCH_CONFIG_59,
                    "Illegal Match Query Filter detected. "
                    + "Right side cannot be a Constant when Left side is a Parameter. "
                    + "Titleid: " + matchGameConfig.TitleId.ToString("X8")
                    + " Left Side id: " + filter.Left.ToString("X8")
                    + " Right Side id: " + filter.Right.ToString("X8"));

            case "ContextValue":
                throw new ExceptionWithEventId(XEvent.Id.MATCH_CONFIG_60,
                    "Illegal Match Query Filter detected. "
                    + "Right side cannot be a ContextValue when Left side is a Parameter. "
                    + "Titleid: " + matchGameConfig.TitleId.ToString("X8")
                    + " Left Side id: " + filter.Left.ToString("X8")
                    + " Right Side id: " + filter.Right.ToString("X8"));

            default:
                throw new ExceptionWithEventId(XEvent.Id.MATCH_CONFIG_61,
                    "Illegal Match Query Filter detected. "
                    + "Unknown type on Right side "
                    + "Titleid: " + matchGameConfig.TitleId.ToString("X8")
                    + " Left Side id: " + filter.Left.ToString("X8")
                    + " Right Side id: " + filter.Right.ToString("X8"));
            }
            break;

        case "Attribute":
            switch (filter.RightType)
            {
            case "Parameter":
                sb.Append(FilterAttributeLeftParamRight(filter, matchGameConfig));
                break;

            case "Attribute":
                throw new ExceptionWithEventId(XEvent.Id.MATCH_CONFIG_62,
                    "Illegal Match Query Filter detected. "
                    + "Right side cannot be an Attribute when Left side is an Attribute. "
                    + "Titleid: " + matchGameConfig.TitleId.ToString("X8")
                    + " Left Side id: " + filter.Left.ToString("X8")
                    + " Right Side id: " + filter.Right.ToString("X8"));

            case "Constant":
                sb.Append(FilterAttributeLeftConstantRight(filter, matchGameConfig));
                break;

            case "ContextValue":
                sb.Append(FilterAttributeLeftContextValueRight(filter, matchGameConfig));
                break;

            default:
                throw new ExceptionWithEventId(XEvent.Id.MATCH_CONFIG_63,
                    "Illegal Match Query Filter detected. "
                    + "Unknown type on Right side "
                    + "Titleid: " + matchGameConfig.TitleId.ToString("X8")
                    + " Left Side id: " + filter.Left.ToString("X8")
                    + " Right Side id: " + filter.Right.ToString("X8"));
            }
            break;

        case "Constant":
            throw new ExceptionWithEventId(XEvent.Id.MATCH_CONFIG_64,
                "Illegal Match Query Filter detected. "
                + "Left side cannot be a Constant "
                + "Titleid: " + matchGameConfig.TitleId.ToString("X8")
                + " Left Side id: " + filter.Left.ToString("X8")
                + " Right Side id: " + filter.Right.ToString("X8"));

        default:
            throw new ExceptionWithEventId(XEvent.Id.MATCH_CONFIG_65,
                "Illegal Match Query Filter detected. "
                + "Unknown type on Left side "
                + "Titleid: " + matchGameConfig.TitleId.ToString("X8")
                + " Left Side id: " + filter.Left.ToString("X8")
                + " Right Side id: " + filter.Right.ToString("X8"));
        }

        sb.Append("\n");
        return sb.ToString();
    }

    private static string FilterParamLeftAttributeRight(
        MatchQueryFilter filter,
        MatchGameConfig matchGameConfig)
    {
        StringBuilder sb = new StringBuilder();
        sb.Append("(@" + ParamName(filter.Left) + " " + FilterOpToSql(filter.Op)
            + " s." + AttributeName(filter.Right) + " OR ");
        sb.Append("@" + ParamName(filter.Left) + " IS NULL)");
        return sb.ToString();
    }

    private static string FilterAttributeLeftParamRight(
        MatchQueryFilter filter,
        MatchGameConfig matchGameConfig)
    {
        StringBuilder sb = new StringBuilder();
        sb.Append("((@" + ParamName(filter.Right) + " IS NULL) OR ");
        sb.Append("(s." + AttributeName(filter.Left) + " " + FilterOpToSql(filter.Op)
            + " @" + ParamName(filter.Right) + "))");

        return sb.ToString();
    }

    private static string FilterAttributeLeftConstantRight(
        MatchQueryFilter filter,
        MatchGameConfig matchGameConfig)
    {
        return "s." + AttributeName(filter.Left) + " " + FilterOpToSql(filter.Op)
            + " '" + ConstantValue(filter.Right, matchGameConfig) + "'";
    }

    private static string FilterAttributeLeftContextValueRight(
        MatchQueryFilter filter,
        MatchGameConfig matchGameConfig)
    {
        return "s." + AttributeName(filter.Left) + " " + FilterOpToSql(filter.Op)
            + " '" + ContextValue(filter.Right) + "'";
    }

    // SQL wants to use = for equals, but xlast uses ==
    private static string FilterOpToSql(string op)
    {
        if (op == "==")
        {
            return "=";
        }
        return op;
    }

    private static string ConstantValue(uint id, MatchGameConfig matchGameConfig)
    {
        MatchConstant matchConstant = (MatchConstant)matchGameConfig.MatchConstants[id];

        // if we're dealing with a date time constant, we have to convert the
        // string to a filetime value, because that's what we store in the database
        if (MatchDefs.AttributeXenonDatatype(id) == MatchDefs.X_ATTRIBUTE_XENON_DATATYPE_DATETIME)
        {
            DateTime dateTime = DateTime.Parse(matchConstant.Value);
            long fileTime = dateTime.ToFileTimeUtc();
            return fileTime.ToString();
        }
        else
        {
            return matchConstant.Value;
        }
    }

    private static string ContextValue(uint id)
    {
        // for context values, the id is the value.
        return id.ToString();
    }

    private static string SortOpToSql(MatchQuerySortOp sortOp)
    {
        // As of 4/6/2005, xlast masks the MatchDefs.X_ATTRIBUTE_TYPE_PARAM
        // bit into sortOp.DistanceId, even though it doesn't do it anywhere
        // else. Since we've decide to not use this flag on the wire, get
        // rid of that flag here.
        uint distanceid = sortOp.DistanceId & (~MatchDefs.X_ATTRIBUTE_TYPE_MASK);
        switch (sortOp.Type)
        {
        case "Ascending":
            return AttributeName(sortOp.Id) + " ASC";

        case "Descending":
            return AttributeName(sortOp.Id) + " DESC";

        case "Near":
            return "ABS(" + AttributeName(sortOp.Id)
                + " - @" + ParamName(distanceid) + ") ASC";

        case "Far":
            return "ABS(" + AttributeName(sortOp.Id)
                + " - @" + ParamName(distanceid) + ") DESC";

        default:
            throw new ExceptionWithEventId(XEvent.Id.MATCH_CONFIG_66,
                "Illegal Match Query Sort Operation detected. Unknown Type: " + sortOp.Type);
        }
    }

    private static string OrderByDrawProbabilityClause()
    {
        return 
            "exp( "
                + "-( "
                    + "("
                        + "(" 
                            + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_MU)
                            + "-@" + ParamName(MatchDefs.X_ATTRIBUTE_GAMER_MU)
                        + ")"
                        + "*"
                        + "(" 
                            + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_MU)
                            + "-@" + ParamName(MatchDefs.X_ATTRIBUTE_GAMER_MU)
                        + ")"
                    + ")"
                    + " + "
                    + "("
                        + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_SIGMA)
                        + "*"
                        + AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_SIGMA)
                    + ")"
                    + " + "
                    + "(" 
                        + "@" + ParamName(MatchDefs.X_ATTRIBUTE_GAMER_SIGMA)
                        + "*" 
                        + "@" + ParamName(MatchDefs.X_ATTRIBUTE_GAMER_SIGMA)
                    + ")"
                + " )"
            + " )"
            + " DESC\n";
    }
}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\offerutil\offerutil\OfferUtil.cs ===
using System;
using System.IO;
using System.Reflection;
using System.Xml;
using System.Xml.Schema;
using System.Xml.Serialization;
using xonline.common.offerutil;
using System.Text.RegularExpressions;

namespace xonline.common.offerutil
{
    /// <summary>
    /// Command line code for the system check tool
    /// </summary>
    public class OfferUtil
    {
        static bool validationSuccess = true;

        public static LiveOffer LoadOffer(string file)
        {
            XmlSerializer serializer = new XmlSerializer(typeof(LiveOffer));
            XmlReader validatingReader = CreateValidatingReader(file);

            LiveOffer lo = null;
            try
            {
                if (serializer.CanDeserialize(validatingReader))
                    lo = (LiveOffer)serializer.Deserialize(validatingReader);
            }
            catch (XmlException e)
            {
                Console.WriteLine(string.Format(e.Message + file));
                throw new XmlException(string.Format(e.Message + file));
            }

            finally
            {
                validatingReader.Close();
            }

            return lo;
        }

        public static void StoreOffer(LiveOffer lo, string file)
        {
            // Store the LiveOffer, i.e. Serialize it out to file...
            XmlSerializer serializer = new XmlSerializer(typeof(LiveOffer));

            StreamWriter streamWriter = new StreamWriter(file);
            XmlTextWriter writer = new XmlTextWriter(streamWriter.BaseStream, null); // null defaults to UTF8
            writer.Formatting = Formatting.Indented;
            writer.Indentation = 4;
            serializer.Serialize(writer, lo);
            writer.Close();
        }

        public static XmlReader CreateValidatingReader(string file)
        {
            Uri assemblyUri = new Uri(Assembly.GetExecutingAssembly().CodeBase);

            string schemaPath = Path.Combine(
                Path.GetDirectoryName(assemblyUri.LocalPath), 
                "LiveOffer.xsd");
            if (!File.Exists(schemaPath))
                throw new Exception(string.Format("cannot find LiveOffer.xsd at {0}", schemaPath));

            Console.WriteLine("Validating instance against {0}", schemaPath);

            XmlReaderSettings readerSettings = new XmlReaderSettings();
            readerSettings.Schemas.Add(null, new XmlTextReader(schemaPath));
            readerSettings.ValidationType = ValidationType.Schema;
            //readerSettings.ValidationEventHandler += new ValidationEventHandler(readerSettingsValidationEventHandler);

            StreamReader streamReader = new StreamReader(file);
            XmlReader validatingReader = XmlReader.Create(new XmlTextReader(streamReader), readerSettings);

            if (!validationSuccess)
            {
                Console.WriteLine("XML failed to parse");
                validatingReader = null;
            }

            return validatingReader;
        }

        static void readerSettingsValidationEventHandler(object sender, ValidationEventArgs e)
        {
            if (e.Severity == XmlSeverityType.Warning)
            {
                Console.WriteLine("OfferUtil WARNING: " + e.Message);
            }
            else if (e.Severity == XmlSeverityType.Error)
            {
                Console.WriteLine("OfferUtil ERROR: " + e.Message);
                validationSuccess = false;
            }
        }
        /// <summary>
        /// Checks the string value and returns true if the string is a guid
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        public static bool IsGUID(string value)
        {
            if (value != null)
            {
                Regex guidRegEx = new Regex(@"^(([0-9a-fA-F]){8}-([0-9a-fA-F]){4}-([0-9a-fA-F]){4}-([0-9a-fA-F]){4}-([0-9a-fA-F]){12})$");

                return guidRegEx.IsMatch(value);
            }
            return false;
        }

    }
}

namespace xonline.common.xboxofferutil
{
    public class XboxOfferUtil
    {
        static bool validationSuccess = true;

        public static XboxOffers LoadOffer(string file)
        {
            XmlSerializer serializer = new XmlSerializer(typeof(XboxOffers));
            XmlReader validatingReader = CreateValidatingReader(file);

            XboxOffers xo = null;
            if(serializer.CanDeserialize(validatingReader))
                xo = (XboxOffers) serializer.Deserialize(validatingReader);

            validatingReader.Close();

            return xo;
        }

        public static void StoreOffer(XboxOffers xo, string file)
        {
            // Store the LiveOffer, i.e. Serialize it out to file...
            XmlSerializer serializer = new XmlSerializer(typeof(XboxOffers));

            StreamWriter streamWriter = new StreamWriter(file);
            XmlTextWriter writer = new XmlTextWriter(streamWriter.BaseStream, null); // null defaults to UTF8
            writer.Formatting = Formatting.Indented;
            writer.Indentation = 4;
            serializer.Serialize(writer, xo);
            writer.Close();
        }

        public static XmlReader CreateValidatingReader(string file)
        {
            string schemaPath = Path.Combine(
                Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), 
                "Xbox1Offer.xsd");
            if (!File.Exists(schemaPath))
                throw new Exception(string.Format("cannot find Xbox1Offer.xsd at {0}", schemaPath));

            Console.WriteLine("Validating instance against {0}", schemaPath);

            XmlReaderSettings readerSettings = new XmlReaderSettings();
            readerSettings.Schemas.Add(null, new XmlTextReader(schemaPath));
            readerSettings.ValidationType = ValidationType.Schema;
            //readerSettings.ValidationEventHandler += new ValidationEventHandler(readerSettingsValidationEventHandler);

            StreamReader streamReader = new StreamReader(file);
            XmlReader validatingReader = XmlReader.Create(new XmlTextReader(streamReader), readerSettings);

            if (!validationSuccess)
            {
                Console.WriteLine("XML failed to parse");
                validatingReader = null;
            }

            return validatingReader;
        }

        static void readerSettingsValidationEventHandler(object sender, ValidationEventArgs e)
        {
            if (e.Severity == XmlSeverityType.Warning)
            {
                Console.WriteLine("OfferUtil WARNING: " + e.Message);
            }
            else if (e.Severity == XmlSeverityType.Error)
            {
                Console.WriteLine("OfferUtil ERROR: " + e.Message);
                validationSuccess = false;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\offerutil\offerutil\svcoffer.cs ===
//  	 Autogenerated by Spiller from :  pdbfinal.spil
//  	 DateTime: 2/27/2008 10:58:03 PM
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.1433
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace xonline.common.offerutil {
    using System;
    using System.Data;
    using System.Data.SqlClient;
    using System.Data.SqlTypes;
    using System.Collections;
    using Microsoft.Subscriptions.Data;
    using System.Xml;
    
    
    /// <summary>
    /// Class generated by Spil for DataStore access
    /// </summary>
    public class SvcOffer : IDataStore {
        
        private string storeName = "uodb";
        
        private string connectionString = "Persist Security Info=False";
        
        [ThreadStatic()]
        private DataStoreContext dataStoreContext;
        
        /// <summary>
        /// Creates a new instance for the specified class SvcOffer
        /// The storeName may be the logical database name or the logical webstore application name
        /// The connectionString should not have the server name or catalog specified
        /// i.e,
        ///  "data source=ServerName"    and
        ///  "Initial Catalog=storeName"
        /// should not be present
        /// An example for valid connection string is:
        /// Integrated Security=SSPI;persist security info=False
        /// </summary>
        public SvcOffer() {
        }
        
        /// <summary>
        /// The name of the DataStore
        /// </summary>
        public virtual string StoreName {
            get {
                return this.storeName;
            }
            set {
                this.storeName = value;
            }
        }
        
        /// <summary>
        /// The connection string used to connect to the DataStore
        /// </summary>
        public virtual string ConnectionString {
            get {
                return this.connectionString;
            }
            set {
                this.connectionString = value;
            }
        }
        
        /// <summary>
        /// The <see cref="Microsoft.Subscriptions.Data.DataStoreContext"/> for the data store
        /// </summary>
        public virtual DataStoreContext Context {
            get {
                if ((dataStoreContext == null)) {
                    dataStoreContext = new DataStoreContext();
                }
                return this.dataStoreContext;
            }
        }
        
        /// <summary>
        /// Execute stored procedure SvcDeleteRegions on all partitions
        /// </summary>
        /// <param name="scm">Connection Manager</param>
        /// <param name="bi_offer_id">bi_offer_id</param>
        public virtual int[] SvcDeleteRegions(ISpilConnectionManager scm, SqlInt64 bi_offer_id) {
            SqlParameter[] callParameters = new SqlParameter[1];
            // pack all parameters into Sql parameters array
            callParameters[0] = new SqlParameter();
            callParameters[0].ParameterName = "@bi_offer_id";
            callParameters[0].IsNullable = true;
            callParameters[0].SqlDbType = SqlDbType.BigInt;
            callParameters[0].Direction = ParameterDirection.Input;
            callParameters[0].Value = bi_offer_id;
            int[] results;
            try {
                results = DataStoreComponent.ExecuteNonQueryOnAllPartitions(this.Context, scm, this.StoreName, this.ConnectionString, "p_svc_delete_regions", callParameters);
            }
            finally {
                // assign output parameter values
            }
            return results;
        }
        
        /// <summary>
        /// Execute stored procedure SvcInsertBaseOffer on all partitions
        /// </summary>
        /// <param name="scm">Connection Manager</param>
        /// <param name="bi_offer_id">the offer id of the offer</param>
        /// <param name="i_tier_id">the tier membership which the offers confers</param>
        public virtual int[] SvcInsertBaseOffer(ISpilConnectionManager scm, SqlInt64 bi_offer_id, SqlInt32 i_tier_id) {
            SqlParameter[] callParameters = new SqlParameter[2];
            // pack all parameters into Sql parameters array
            callParameters[0] = new SqlParameter();
            callParameters[0].ParameterName = "@bi_offer_id";
            callParameters[0].IsNullable = true;
            callParameters[0].SqlDbType = SqlDbType.BigInt;
            callParameters[0].Direction = ParameterDirection.Input;
            callParameters[0].Value = bi_offer_id;
            callParameters[1] = new SqlParameter();
            callParameters[1].ParameterName = "@i_tier_id";
            callParameters[1].IsNullable = true;
            callParameters[1].SqlDbType = SqlDbType.Int;
            callParameters[1].Direction = ParameterDirection.Input;
            callParameters[1].Value = i_tier_id;
            int[] results;
            try {
                results = DataStoreComponent.ExecuteNonQueryOnAllPartitions(this.Context, scm, this.StoreName, this.ConnectionString, "p_svc_insert_base_offer", callParameters);
            }
            finally {
                // assign output parameter values
            }
            return results;
        }
        
        /// <summary>
        /// Execute stored procedure SvcInsertDmpOfferDetails on all partitions
        /// </summary>
        /// <param name="scm">Connection Manager</param>
        /// <param name="bi_offer_id">the points offer id</param>
        /// <param name="i_revenue_sku_id">the revenue sku associated with this offer</param>
        /// <param name="i_category_id">the category associated with this offer</param>
        /// <param name="i_campaign_id">the campaign associated with this offer</param>
        public virtual int[] SvcInsertDmpOfferDetails(ISpilConnectionManager scm, SqlInt64 bi_offer_id, SqlInt32 i_revenue_sku_id, SqlInt32 i_category_id, SqlInt32 i_campaign_id) {
            SqlParameter[] callParameters = new SqlParameter[4];
            // pack all parameters into Sql parameters array
            callParameters[0] = new SqlParameter();
            callParameters[0].ParameterName = "@bi_offer_id";
            callParameters[0].IsNullable = true;
            callParameters[0].SqlDbType = SqlDbType.BigInt;
            callParameters[0].Direction = ParameterDirection.Input;
            callParameters[0].Value = bi_offer_id;
            callParameters[1] = new SqlParameter();
            callParameters[1].ParameterName = "@i_revenue_sku_id";
            callParameters[1].IsNullable = true;
            callParameters[1].SqlDbType = SqlDbType.Int;
            callParameters[1].Direction = ParameterDirection.Input;
            callParameters[1].Value = i_revenue_sku_id;
            callParameters[2] = new SqlParameter();
            callParameters[2].ParameterName = "@i_category_id";
            callParameters[2].IsNullable = true;
            callParameters[2].SqlDbType = SqlDbType.Int;
            callParameters[2].Direction = ParameterDirection.Input;
            callParameters[2].Value = i_category_id;
            callParameters[3] = new SqlParameter();
            callParameters[3].ParameterName = "@i_campaign_id";
            callParameters[3].IsNullable = true;
            callParameters[3].SqlDbType = SqlDbType.Int;
            callParameters[3].Direction = ParameterDirection.Input;
            callParameters[3].Value = i_campaign_id;
            int[] results;
            try {
                results = DataStoreComponent.ExecuteNonQueryOnAllPartitions(this.Context, scm, this.StoreName, this.ConnectionString, "p_svc_insert_dmp_offer_details", callParameters);
            }
            finally {
                // assign output parameter values
            }
            return results;
        }
        
        /// <summary>
        /// Execute stored procedure SvcInsertDmpReward on all partitions
        /// </summary>
        /// <param name="scm">Connection Manager</param>
        /// <param name="i_reward_id">the reward id</param>
        /// <param name="i_points_rewarded">the number of points rewarded</param>
        /// <param name="i_reward_lifetime">the lifetime in days of the reward points</param>
        /// <param name="i_promo_sku_id">the promo sku for this reward</param>
        /// <param name="i_campaign_id">the campaign associated with this reward</param>
        /// <param name="i_acquisition_type_id">the acquisition type of this reward</param>
        public virtual int[] SvcInsertDmpReward(ISpilConnectionManager scm, SqlInt32 i_reward_id, SqlInt32 i_points_rewarded, SqlInt32 i_reward_lifetime, SqlInt32 i_promo_sku_id, SqlInt32 i_campaign_id, SqlInt32 i_acquisition_type_id) {
            SqlParameter[] callParameters = new SqlParameter[6];
            // pack all parameters into Sql parameters array
            callParameters[0] = new SqlParameter();
            callParameters[0].ParameterName = "@i_reward_id";
            callParameters[0].IsNullable = true;
            callParameters[0].SqlDbType = SqlDbType.Int;
            callParameters[0].Direction = ParameterDirection.Input;
            callParameters[0].Value = i_reward_id;
            callParameters[1] = new SqlParameter();
            callParameters[1].ParameterName = "@i_points_rewarded";
            callParameters[1].IsNullable = true;
            callParameters[1].SqlDbType = SqlDbType.Int;
            callParameters[1].Direction = ParameterDirection.Input;
            callParameters[1].Value = i_points_rewarded;
            callParameters[2] = new SqlParameter();
            callParameters[2].ParameterName = "@i_reward_lifetime";
            callParameters[2].IsNullable = true;
            callParameters[2].SqlDbType = SqlDbType.Int;
            callParameters[2].Direction = ParameterDirection.Input;
            callParameters[2].Value = i_reward_lifetime;
            callParameters[3] = new SqlParameter();
            callParameters[3].ParameterName = "@i_promo_sku_id";
            callParameters[3].IsNullable = true;
            callParameters[3].SqlDbType = SqlDbType.Int;
            callParameters[3].Direction = ParameterDirection.Input;
            callParameters[3].Value = i_promo_sku_id;
            callParameters[4] = new SqlParameter();
            callParameters[4].ParameterName = "@i_campaign_id";
            callParameters[4].IsNullable = true;
            callParameters[4].SqlDbType = SqlDbType.Int;
            callParameters[4].Direction = ParameterDirection.Input;
            callParameters[4].Value = i_campaign_id;
            callParameters[5] = new SqlParameter();
            callParameters[5].ParameterName = "@i_acquisition_type_id";
            callParameters[5].IsNullable = true;
            callParameters[5].SqlDbType = SqlDbType.Int;
            callParameters[5].Direction = ParameterDirection.Input;
            callParameters[5].Value = i_acquisition_type_id;
            int[] results;
            try {
                results = DataStoreComponent.ExecuteNonQueryOnAllPartitions(this.Context, scm, this.StoreName, this.ConnectionString, "p_svc_insert_dmp_reward", callParameters);
            }
            finally {
                // assign output parameter values
            }
            return results;
        }
        
        /// <summary>
        /// Execute stored procedure SvcInsertDmpRewardCultureDetails on all partitions
        /// </summary>
        /// <param name="scm">Connection Manager</param>
        /// <param name="i_reward_id">the reward ID</param>
        /// <param name="i_culture_id">the culture that this reward title is localized into</param>
        /// <param name="vc_acquisition_title">the localized acquisition title of this reward</param>
        public virtual int[] SvcInsertDmpRewardCultureDetails(ISpilConnectionManager scm, SqlInt32 i_reward_id, SqlInt32 i_culture_id, string vc_acquisition_title) {
            SqlParameter[] callParameters = new SqlParameter[3];
            // pack all parameters into Sql parameters array
            callParameters[0] = new SqlParameter();
            callParameters[0].ParameterName = "@i_reward_id";
            callParameters[0].IsNullable = true;
            callParameters[0].SqlDbType = SqlDbType.Int;
            callParameters[0].Direction = ParameterDirection.Input;
            callParameters[0].Value = i_reward_id;
            callParameters[1] = new SqlParameter();
            callParameters[1].ParameterName = "@i_culture_id";
            callParameters[1].IsNullable = true;
            callParameters[1].SqlDbType = SqlDbType.Int;
            callParameters[1].Direction = ParameterDirection.Input;
            callParameters[1].Value = i_culture_id;
            callParameters[2] = new SqlParameter();
            callParameters[2].ParameterName = "@vc_acquisition_title";
            callParameters[2].IsNullable = true;
            callParameters[2].SqlDbType = SqlDbType.NVarChar;
            callParameters[2].Direction = ParameterDirection.Input;
            callParameters[2].Size = 200;
            if ((vc_acquisition_title == null)) {
                callParameters[2].Value = SqlString.Null;
            }
            else {
                callParameters[2].Value = ((System.Data.SqlTypes.SqlString)(vc_acquisition_title));
            }
            int[] results;
            try {
                results = DataStoreComponent.ExecuteNonQueryOnAllPartitions(this.Context, scm, this.StoreName, this.ConnectionString, "p_svc_insert_dmp_reward_culture_details", callParameters);
            }
            finally {
                // assign output parameter values
            }
            return results;
        }
        
        /// <summary>
        /// Execute stored procedure SvcInsertOffers on all partitions
        /// </summary>
        /// <param name="scm">Connection Manager</param>
        /// <param name="i_title_id">i_title_id</param>
        /// <param name="bi_offer_id">bi_offer_id</param>
        /// <param name="i_ESRB_id">i_ESRB_id</param>
        /// <param name="b_cancelable">b_cancelable</param>
        /// <param name="i_package_size">i_package_size</param>
        /// <param name="i_install_size">i_install_size</param>
        /// <param name="vb_sym_key">vb_sym_key</param>
        /// <param name="i_bitfilter">i_bitfilter</param>
        /// <param name="vc_billing_svc_component_id">vc_billing_svc_component_id</param>
        /// <param name="i_offer_type_id">i_offer_type_id</param>
        /// <param name="i_offer_frequency_id">i_offer_frequency_id</param>
        /// <param name="dt_start_date">dt_start_date</param>
        /// <param name="dt_end_date">dt_end_date</param>
        /// <param name="vc_friendly_name">vc_friendly_name</param>
        /// <param name="vb_public_key">vb_public_key</param>
        /// <param name="i_policy_flags">i_policy_flags</param>
        /// <param name="ti_console_type_id">default to an xbox1 offer</param>
        /// <param name="i_license_bits">i_license_bits</param>
        /// <param name="b_content_id">b_content_id</param>
        /// <param name="bi_preview_offer_id">bi_preview_offer_id</param>
        public virtual int[] SvcInsertOffers(
                    ISpilConnectionManager scm, 
                    SqlInt32 i_title_id, 
                    SqlInt64 bi_offer_id, 
                    SqlInt32 i_ESRB_id, 
                    SqlByte b_cancelable, 
                    SqlInt32 i_package_size, 
                    SqlInt32 i_install_size, 
                    SqlBinary vb_sym_key, 
                    SqlInt32 i_bitfilter, 
                    string vc_billing_svc_component_id, 
                    SqlInt32 i_offer_type_id, 
                    SqlInt32 i_offer_frequency_id, 
                    SqlDateTime dt_start_date, 
                    SqlDateTime dt_end_date, 
                    string vc_friendly_name, 
                    SqlBinary vb_public_key, 
                    SqlInt32 i_policy_flags, 
                    SqlByte ti_console_type_id, 
                    SqlInt32 i_license_bits, 
                    SqlBinary b_content_id, 
                    SqlInt64 bi_preview_offer_id) {
            SqlParameter[] callParameters = new SqlParameter[20];
            // pack all parameters into Sql parameters array
            callParameters[0] = new SqlParameter();
            callParameters[0].ParameterName = "@i_title_id";
            callParameters[0].IsNullable = true;
            callParameters[0].SqlDbType = SqlDbType.Int;
            callParameters[0].Direction = ParameterDirection.Input;
            callParameters[0].Value = i_title_id;
            callParameters[1] = new SqlParameter();
            callParameters[1].ParameterName = "@bi_offer_id";
            callParameters[1].IsNullable = true;
            callParameters[1].SqlDbType = SqlDbType.BigInt;
            callParameters[1].Direction = ParameterDirection.Input;
            callParameters[1].Value = bi_offer_id;
            callParameters[2] = new SqlParameter();
            callParameters[2].ParameterName = "@i_ESRB_id";
            callParameters[2].IsNullable = true;
            callParameters[2].SqlDbType = SqlDbType.Int;
            callParameters[2].Direction = ParameterDirection.Input;
            callParameters[2].Value = i_ESRB_id;
            callParameters[3] = new SqlParameter();
            callParameters[3].ParameterName = "@b_cancelable";
            callParameters[3].IsNullable = true;
            callParameters[3].SqlDbType = SqlDbType.TinyInt;
            callParameters[3].Direction = ParameterDirection.Input;
            callParameters[3].Value = b_cancelable;
            callParameters[4] = new SqlParameter();
            callParameters[4].ParameterName = "@i_package_size";
            callParameters[4].IsNullable = true;
            callParameters[4].SqlDbType = SqlDbType.Int;
            callParameters[4].Direction = ParameterDirection.Input;
            callParameters[4].Value = i_package_size;
            callParameters[5] = new SqlParameter();
            callParameters[5].ParameterName = "@i_install_size";
            callParameters[5].IsNullable = true;
            callParameters[5].SqlDbType = SqlDbType.Int;
            callParameters[5].Direction = ParameterDirection.Input;
            callParameters[5].Value = i_install_size;
            callParameters[6] = new SqlParameter();
            callParameters[6].ParameterName = "@vb_sym_key";
            callParameters[6].IsNullable = true;
            callParameters[6].SqlDbType = SqlDbType.VarBinary;
            callParameters[6].Direction = ParameterDirection.Input;
            callParameters[6].Size = 16;
            callParameters[6].Value = vb_sym_key;
            callParameters[7] = new SqlParameter();
            callParameters[7].ParameterName = "@i_bitfilter";
            callParameters[7].IsNullable = true;
            callParameters[7].SqlDbType = SqlDbType.Int;
            callParameters[7].Direction = ParameterDirection.Input;
            callParameters[7].Value = i_bitfilter;
            callParameters[8] = new SqlParameter();
            callParameters[8].ParameterName = "@vc_billing_svc_component_id";
            callParameters[8].IsNullable = true;
            callParameters[8].SqlDbType = SqlDbType.NVarChar;
            callParameters[8].Direction = ParameterDirection.Input;
            callParameters[8].Size = 36;
            if ((vc_billing_svc_component_id == null)) {
                callParameters[8].Value = SqlString.Null;
            }
            else {
                callParameters[8].Value = ((System.Data.SqlTypes.SqlString)(vc_billing_svc_component_id));
            }
            callParameters[9] = new SqlParameter();
            callParameters[9].ParameterName = "@i_offer_type_id";
            callParameters[9].IsNullable = true;
            callParameters[9].SqlDbType = SqlDbType.Int;
            callParameters[9].Direction = ParameterDirection.Input;
            callParameters[9].Value = i_offer_type_id;
            callParameters[10] = new SqlParameter();
            callParameters[10].ParameterName = "@i_offer_frequency_id";
            callParameters[10].IsNullable = true;
            callParameters[10].SqlDbType = SqlDbType.Int;
            callParameters[10].Direction = ParameterDirection.Input;
            callParameters[10].Value = i_offer_frequency_id;
            callParameters[11] = new SqlParameter();
            callParameters[11].ParameterName = "@dt_start_date";
            callParameters[11].IsNullable = true;
            callParameters[11].SqlDbType = SqlDbType.DateTime;
            callParameters[11].Direction = ParameterDirection.Input;
            callParameters[11].Value = dt_start_date;
            callParameters[12] = new SqlParameter();
            callParameters[12].ParameterName = "@dt_end_date";
            callParameters[12].IsNullable = true;
            callParameters[12].SqlDbType = SqlDbType.DateTime;
            callParameters[12].Direction = ParameterDirection.Input;
            callParameters[12].Value = dt_end_date;
            callParameters[13] = new SqlParameter();
            callParameters[13].ParameterName = "@vc_friendly_name";
            callParameters[13].IsNullable = true;
            callParameters[13].SqlDbType = SqlDbType.NVarChar;
            callParameters[13].Direction = ParameterDirection.Input;
            callParameters[13].Size = 150;
            if ((vc_friendly_name == null)) {
                callParameters[13].Value = SqlString.Null;
            }
            else {
                callParameters[13].Value = ((System.Data.SqlTypes.SqlString)(vc_friendly_name));
            }
            callParameters[14] = new SqlParameter();
            callParameters[14].ParameterName = "@vb_public_key";
            callParameters[14].IsNullable = true;
            callParameters[14].SqlDbType = SqlDbType.VarBinary;
            callParameters[14].Direction = ParameterDirection.Input;
            callParameters[14].Size = 284;
            callParameters[14].Value = vb_public_key;
            callParameters[15] = new SqlParameter();
            callParameters[15].ParameterName = "@i_policy_flags";
            callParameters[15].IsNullable = true;
            callParameters[15].SqlDbType = SqlDbType.Int;
            callParameters[15].Direction = ParameterDirection.Input;
            callParameters[15].Value = i_policy_flags;
            callParameters[16] = new SqlParameter();
            callParameters[16].ParameterName = "@ti_console_type_id";
            callParameters[16].IsNullable = true;
            callParameters[16].SqlDbType = SqlDbType.TinyInt;
            callParameters[16].Direction = ParameterDirection.Input;
            callParameters[16].Value = ti_console_type_id;
            callParameters[17] = new SqlParameter();
            callParameters[17].ParameterName = "@i_license_bits";
            callParameters[17].IsNullable = true;
            callParameters[17].SqlDbType = SqlDbType.Int;
            callParameters[17].Direction = ParameterDirection.Input;
            callParameters[17].Value = i_license_bits;
            callParameters[18] = new SqlParameter();
            callParameters[18].ParameterName = "@b_content_id";
            callParameters[18].IsNullable = true;
            callParameters[18].SqlDbType = SqlDbType.Binary;
            callParameters[18].Direction = ParameterDirection.Input;
            callParameters[18].Size = 20;
            callParameters[18].Value = b_content_id;
            callParameters[19] = new SqlParameter();
            callParameters[19].ParameterName = "@bi_preview_offer_id";
            callParameters[19].IsNullable = true;
            callParameters[19].SqlDbType = SqlDbType.BigInt;
            callParameters[19].Direction = ParameterDirection.Input;
            callParameters[19].Value = bi_preview_offer_id;
            int[] results;
            try {
                results = DataStoreComponent.ExecuteNonQueryOnAllPartitions(this.Context, scm, this.StoreName, this.ConnectionString, "p_svc_insert_offers", callParameters);
            }
            finally {
                // assign output parameter values
            }
            return results;
        }
        
        /// <summary>
        /// Execute stored procedure SvcInsertOfferAcquisitionType on all partitions
        /// </summary>
        /// <param name="scm">Connection Manager</param>
        /// <param name="i_acquisition_type_id">the acquisition type ID</param>
        /// <param name="vc_friendly_name">the ops-friendly name of this reward acquisition type</param>
        /// <param name="i_overwrite">flag allow overwritting of existing row</param>
        public virtual int[] SvcInsertOfferAcquisitionType(ISpilConnectionManager scm, SqlInt32 i_acquisition_type_id, string vc_friendly_name, SqlInt32 i_overwrite) {
            SqlParameter[] callParameters = new SqlParameter[3];
            // pack all parameters into Sql parameters array
            callParameters[0] = new SqlParameter();
            callParameters[0].ParameterName = "@i_acquisition_type_id";
            callParameters[0].IsNullable = true;
            callParameters[0].SqlDbType = SqlDbType.Int;
            callParameters[0].Direction = ParameterDirection.Input;
            callParameters[0].Value = i_acquisition_type_id;
            callParameters[1] = new SqlParameter();
            callParameters[1].ParameterName = "@vc_friendly_name";
            callParameters[1].IsNullable = true;
            callParameters[1].SqlDbType = SqlDbType.NVarChar;
            callParameters[1].Direction = ParameterDirection.Input;
            callParameters[1].Size = 200;
            if ((vc_friendly_name == null)) {
                callParameters[1].Value = SqlString.Null;
            }
            else {
                callParameters[1].Value = ((System.Data.SqlTypes.SqlString)(vc_friendly_name));
            }
            callParameters[2] = new SqlParameter();
            callParameters[2].ParameterName = "@i_overwrite";
            callParameters[2].IsNullable = true;
            callParameters[2].SqlDbType = SqlDbType.Int;
            callParameters[2].Direction = ParameterDirection.Input;
            callParameters[2].Value = i_overwrite;
            int[] results;
            try {
                results = DataStoreComponent.ExecuteNonQueryOnAllPartitions(this.Context, scm, this.StoreName, this.ConnectionString, "p_svc_insert_offer_acquisition_type", callParameters);
            }
            finally {
                // assign output parameter values
            }
            return results;
        }
        
        /// <summary>
        /// Execute stored procedure SvcInsertOfferCampaign on all partitions
        /// </summary>
        /// <param name="scm">Connection Manager</param>
        /// <param name="i_campaign_id">the campaign id</param>
        /// <param name="vc_friendly_name">the ops-friendly name of this campaign</param>
        /// <param name="i_overwrite">flag allow overwritting of existing row</param>
        public virtual int[] SvcInsertOfferCampaign(ISpilConnectionManager scm, SqlInt32 i_campaign_id, string vc_friendly_name, SqlInt32 i_overwrite) {
            SqlParameter[] callParameters = new SqlParameter[3];
            // pack all parameters into Sql parameters array
            callParameters[0] = new SqlParameter();
            callParameters[0].ParameterName = "@i_campaign_id";
            callParameters[0].IsNullable = true;
            callParameters[0].SqlDbType = SqlDbType.Int;
            callParameters[0].Direction = ParameterDirection.Input;
            callParameters[0].Value = i_campaign_id;
            callParameters[1] = new SqlParameter();
            callParameters[1].ParameterName = "@vc_friendly_name";
            callParameters[1].IsNullable = true;
            callParameters[1].SqlDbType = SqlDbType.NVarChar;
            callParameters[1].Direction = ParameterDirection.Input;
            callParameters[1].Size = 200;
            if ((vc_friendly_name == null)) {
                callParameters[1].Value = SqlString.Null;
            }
            else {
                callParameters[1].Value = ((System.Data.SqlTypes.SqlString)(vc_friendly_name));
            }
            callParameters[2] = new SqlParameter();
            callParameters[2].ParameterName = "@i_overwrite";
            callParameters[2].IsNullable = true;
            callParameters[2].SqlDbType = SqlDbType.Int;
            callParameters[2].Direction = ParameterDirection.Input;
            callParameters[2].Value = i_overwrite;
            int[] results;
            try {
                results = DataStoreComponent.ExecuteNonQueryOnAllPartitions(this.Context, scm, this.StoreName, this.ConnectionString, "p_svc_insert_offer_campaign", callParameters);
            }
            finally {
                // assign output parameter values
            }
            return results;
        }
        
        /// <summary>
        /// Execute stored procedure SvcInsertOfferCategoryCultureDetails on all partitions
        /// </summary>
        /// <param name="scm">Connection Manager</param>
        /// <param name="i_category_id">the category id</param>
        /// <param name="i_culture_id">the culture that this category is localized into</param>
        /// <param name="vc_category_name">the localized name of this category</param>
        public virtual int[] SvcInsertOfferCategoryCultureDetails(ISpilConnectionManager scm, SqlInt32 i_category_id, SqlInt32 i_culture_id, string vc_category_name) {
            SqlParameter[] callParameters = new SqlParameter[3];
            // pack all parameters into Sql parameters array
            callParameters[0] = new SqlParameter();
            callParameters[0].ParameterName = "@i_category_id";
            callParameters[0].IsNullable = true;
            callParameters[0].SqlDbType = SqlDbType.Int;
            callParameters[0].Direction = ParameterDirection.Input;
            callParameters[0].Value = i_category_id;
            callParameters[1] = new SqlParameter();
            callParameters[1].ParameterName = "@i_culture_id";
            callParameters[1].IsNullable = true;
            callParameters[1].SqlDbType = SqlDbType.Int;
            callParameters[1].Direction = ParameterDirection.Input;
            callParameters[1].Value = i_culture_id;
            callParameters[2] = new SqlParameter();
            callParameters[2].ParameterName = "@vc_category_name";
            callParameters[2].IsNullable = true;
            callParameters[2].SqlDbType = SqlDbType.NVarChar;
            callParameters[2].Direction = ParameterDirection.Input;
            callParameters[2].Size = 200;
            if ((vc_category_name == null)) {
                callParameters[2].Value = SqlString.Null;
            }
            else {
                callParameters[2].Value = ((System.Data.SqlTypes.SqlString)(vc_category_name));
            }
            int[] results;
            try {
                results = DataStoreComponent.ExecuteNonQueryOnAllPartitions(this.Context, scm, this.StoreName, this.ConnectionString, "p_svc_insert_offer_category_culture_details", callParameters);
            }
            finally {
                // assign output parameter values
            }
            return results;
        }
        
        /// <summary>
        /// Execute stored procedure SvcInsertOfferConsumables on all partitions
        /// </summary>
        /// <param name="scm">Connection Manager</param>
        /// <param name="i_title_id">i_title_id</param>
        /// <param name="bi_offer_id">bi_offer_id</param>
        /// <param name="i_asset_id">i_asset_id</param>
        /// <param name="i_quantity">i_quantity</param>
        public virtual int[] SvcInsertOfferConsumables(ISpilConnectionManager scm, SqlInt32 i_title_id, SqlInt64 bi_offer_id, SqlInt32 i_asset_id, SqlInt32 i_quantity) {
            SqlParameter[] callParameters = new SqlParameter[4];
            // pack all parameters into Sql parameters array
            callParameters[0] = new SqlParameter();
            callParameters[0].ParameterName = "@i_title_id";
            callParameters[0].IsNullable = true;
            callParameters[0].SqlDbType = SqlDbType.Int;
            callParameters[0].Direction = ParameterDirection.Input;
            callParameters[0].Value = i_title_id;
            callParameters[1] = new SqlParameter();
            callParameters[1].ParameterName = "@bi_offer_id";
            callParameters[1].IsNullable = true;
            callParameters[1].SqlDbType = SqlDbType.BigInt;
            callParameters[1].Direction = ParameterDirection.Input;
            callParameters[1].Value = bi_offer_id;
            callParameters[2] = new SqlParameter();
            callParameters[2].ParameterName = "@i_asset_id";
            callParameters[2].IsNullable = true;
            callParameters[2].SqlDbType = SqlDbType.Int;
            callParameters[2].Direction = ParameterDirection.Input;
            callParameters[2].Value = i_asset_id;
            callParameters[3] = new SqlParameter();
            callParameters[3].ParameterName = "@i_quantity";
            callParameters[3].IsNullable = true;
            callParameters[3].SqlDbType = SqlDbType.Int;
            callParameters[3].Direction = ParameterDirection.Input;
            callParameters[3].Value = i_quantity;
            int[] results;
            try {
                results = DataStoreComponent.ExecuteNonQueryOnAllPartitions(this.Context, scm, this.StoreName, this.ConnectionString, "p_svc_insert_offer_consumables", callParameters);
            }
            finally {
                // assign output parameter values
            }
            return results;
        }
        
        /// <summary>
        /// Execute stored procedure SvcInsertOfferCultureDetails on all partitions
        /// </summary>
        /// <param name="scm">Connection Manager</param>
        /// <param name="bi_offer_id">the title id</param>
        /// <param name="i_culture_id">the culture id (lcid)</param>
        /// <param name="vc_name">the localized name of the title</param>
        /// <param name="vc_sell_text">the localized sell text of the title</param>
        public virtual int[] SvcInsertOfferCultureDetails(ISpilConnectionManager scm, SqlInt64 bi_offer_id, SqlInt32 i_culture_id, string vc_name, string vc_sell_text) {
            SqlParameter[] callParameters = new SqlParameter[4];
            // pack all parameters into Sql parameters array
            callParameters[0] = new SqlParameter();
            callParameters[0].ParameterName = "@bi_offer_id";
            callParameters[0].IsNullable = true;
            callParameters[0].SqlDbType = SqlDbType.BigInt;
            callParameters[0].Direction = ParameterDirection.Input;
            callParameters[0].Value = bi_offer_id;
            callParameters[1] = new SqlParameter();
            callParameters[1].ParameterName = "@i_culture_id";
            callParameters[1].IsNullable = true;
            callParameters[1].SqlDbType = SqlDbType.Int;
            callParameters[1].Direction = ParameterDirection.Input;
            callParameters[1].Value = i_culture_id;
            callParameters[2] = new SqlParameter();
            callParameters[2].ParameterName = "@vc_name";
            callParameters[2].IsNullable = true;
            callParameters[2].SqlDbType = SqlDbType.NVarChar;
            callParameters[2].Direction = ParameterDirection.Input;
            callParameters[2].Size = 100;
            if ((vc_name == null)) {
                callParameters[2].Value = SqlString.Null;
            }
            else {
                callParameters[2].Value = ((System.Data.SqlTypes.SqlString)(vc_name));
            }
            callParameters[3] = new SqlParameter();
            callParameters[3].ParameterName = "@vc_sell_text";
            callParameters[3].IsNullable = true;
            callParameters[3].SqlDbType = SqlDbType.NVarChar;
            callParameters[3].Direction = ParameterDirection.Input;
            callParameters[3].Size = 1000;
            if ((vc_sell_text == null)) {
                callParameters[3].Value = SqlString.Null;
            }
            else {
                callParameters[3].Value = ((System.Data.SqlTypes.SqlString)(vc_sell_text));
            }
            int[] results;
            try {
                results = DataStoreComponent.ExecuteNonQueryOnAllPartitions(this.Context, scm, this.StoreName, this.ConnectionString, "p_svc_insert_offer_culture_details", callParameters);
            }
            finally {
                // assign output parameter values
            }
            return results;
        }
        
        /// <summary>
        /// Execute stored procedure SvcInsertOfferDescriptions on all partitions
        /// </summary>
        /// <param name="scm">Connection Manager</param>
        /// <param name="bi_offer_id">bi_offer_id</param>
        /// <param name="vb_enum_blob">vb_enum_blob</param>
        /// <param name="i_description_index">i_description_index</param>
        public virtual int[] SvcInsertOfferDescriptions(ISpilConnectionManager scm, SqlInt64 bi_offer_id, SqlBinary vb_enum_blob, SqlInt32 i_description_index) {
            SqlParameter[] callParameters = new SqlParameter[3];
            // pack all parameters into Sql parameters array
            callParameters[0] = new SqlParameter();
            callParameters[0].ParameterName = "@bi_offer_id";
            callParameters[0].IsNullable = true;
            callParameters[0].SqlDbType = SqlDbType.BigInt;
            callParameters[0].Direction = ParameterDirection.Input;
            callParameters[0].Value = bi_offer_id;
            callParameters[1] = new SqlParameter();
            callParameters[1].ParameterName = "@vb_enum_blob";
            callParameters[1].IsNullable = true;
            callParameters[1].SqlDbType = SqlDbType.VarBinary;
            callParameters[1].Direction = ParameterDirection.Input;
            callParameters[1].Size = 8000;
            callParameters[1].Value = vb_enum_blob;
            callParameters[2] = new SqlParameter();
            callParameters[2].ParameterName = "@i_description_index";
            callParameters[2].IsNullable = true;
            callParameters[2].SqlDbType = SqlDbType.Int;
            callParameters[2].Direction = ParameterDirection.Input;
            callParameters[2].Value = i_description_index;
            int[] results;
            try {
                results = DataStoreComponent.ExecuteNonQueryOnAllPartitions(this.Context, scm, this.StoreName, this.ConnectionString, "p_svc_insert_offer_descriptions", callParameters);
            }
            finally {
                // assign output parameter values
            }
            return results;
        }
        
        /// <summary>
        /// Execute stored procedure SvcInsertOfferDescriptionDetails on all partitions
        /// </summary>
        /// <param name="scm">Connection Manager</param>
        /// <param name="bi_offer_id">bi_offer_id</param>
        /// <param name="vb_details_blob">vb_details_blob</param>
        /// <param name="i_description_index">i_description_index</param>
        /// <param name="i_order">i_order</param>
        public virtual int[] SvcInsertOfferDescriptionDetails(ISpilConnectionManager scm, SqlInt64 bi_offer_id, SqlBinary vb_details_blob, SqlInt32 i_description_index, SqlInt32 i_order) {
            SqlParameter[] callParameters = new SqlParameter[4];
            // pack all parameters into Sql parameters array
            callParameters[0] = new SqlParameter();
            callParameters[0].ParameterName = "@bi_offer_id";
            callParameters[0].IsNullable = true;
            callParameters[0].SqlDbType = SqlDbType.BigInt;
            callParameters[0].Direction = ParameterDirection.Input;
            callParameters[0].Value = bi_offer_id;
            callParameters[1] = new SqlParameter();
            callParameters[1].ParameterName = "@vb_details_blob";
            callParameters[1].IsNullable = true;
            callParameters[1].SqlDbType = SqlDbType.VarBinary;
            callParameters[1].Direction = ParameterDirection.Input;
            callParameters[1].Size = 8000;
            callParameters[1].Value = vb_details_blob;
            callParameters[2] = new SqlParameter();
            callParameters[2].ParameterName = "@i_description_index";
            callParameters[2].IsNullable = true;
            callParameters[2].SqlDbType = SqlDbType.Int;
            callParameters[2].Direction = ParameterDirection.Input;
            callParameters[2].Value = i_description_index;
            callParameters[3] = new SqlParameter();
            callParameters[3].ParameterName = "@i_order";
            callParameters[3].IsNullable = true;
            callParameters[3].SqlDbType = SqlDbType.Int;
            callParameters[3].Direction = ParameterDirection.Input;
            callParameters[3].Value = i_order;
            int[] results;
            try {
                results = DataStoreComponent.ExecuteNonQueryOnAllPartitions(this.Context, scm, this.StoreName, this.ConnectionString, "p_svc_insert_offer_description_details", callParameters);
            }
            finally {
                // assign output parameter values
            }
            return results;
        }
        
        /// <summary>
        /// Execute stored procedure SvcInsertOfferDuration on all partitions
        /// </summary>
        /// <param name="scm">Connection Manager</param>
        /// <param name="bi_offer_id">the offer id</param>
        /// <param name="i_duration_seconds">the number of seconds that this offer is valid</param>
        public virtual int[] SvcInsertOfferDuration(ISpilConnectionManager scm, SqlInt64 bi_offer_id, SqlInt32 i_duration_seconds) {
            SqlParameter[] callParameters = new SqlParameter[2];
            // pack all parameters into Sql parameters array
            callParameters[0] = new SqlParameter();
            callParameters[0].ParameterName = "@bi_offer_id";
            callParameters[0].IsNullable = true;
            callParameters[0].SqlDbType = SqlDbType.BigInt;
            callParameters[0].Direction = ParameterDirection.Input;
            callParameters[0].Value = bi_offer_id;
            callParameters[1] = new SqlParameter();
            callParameters[1].ParameterName = "@i_duration_seconds";
            callParameters[1].IsNullable = true;
            callParameters[1].SqlDbType = SqlDbType.Int;
            callParameters[1].Direction = ParameterDirection.Input;
            callParameters[1].Value = i_duration_seconds;
            int[] results;
            try {
                results = DataStoreComponent.ExecuteNonQueryOnAllPartitions(this.Context, scm, this.StoreName, this.ConnectionString, "p_svc_insert_offer_duration", callParameters);
            }
            finally {
                // assign output parameter values
            }
            return results;
        }

        /// <summary>
        /// Execute stored procedure SvcInsertOfferInstanceFamilyMappings on all partitions
        /// </summary>
        /// <param name="scm">Connection Manager</param>
        /// <param name="bi_offer_id">bi_offer_id</param>
        /// <param name="ti_country_id">ti_country_id</param>
        /// <param name="i_payment_type_id">i_payment_type_id</param>
        public virtual int[] SvcInsertOfferInstanceFamilyMappings(ISpilConnectionManager scm, SqlInt64 bi_offer_id, SqlByte ti_country_id, SqlInt32 i_payment_type_id)
        {
            SqlParameter[] callParameters = new SqlParameter[3];
            // pack all parameters into Sql parameters array
            callParameters[0] = new SqlParameter();
            callParameters[0].ParameterName = "@bi_offer_id";
            callParameters[0].IsNullable = true;
            callParameters[0].SqlDbType = SqlDbType.BigInt;
            callParameters[0].Direction = ParameterDirection.Input;
            callParameters[0].Value = bi_offer_id;
            callParameters[1] = new SqlParameter();
            callParameters[1].ParameterName = "@ti_country_id";
            callParameters[1].IsNullable = true;
            callParameters[1].SqlDbType = SqlDbType.TinyInt;
            callParameters[1].Direction = ParameterDirection.Input;
            callParameters[1].Value = ti_country_id;
            callParameters[2] = new SqlParameter();
            callParameters[2].ParameterName = "@i_payment_type_id";
            callParameters[2].IsNullable = true;
            callParameters[2].SqlDbType = SqlDbType.Int;
            callParameters[2].Direction = ParameterDirection.Input;
            callParameters[2].Value = i_payment_type_id;
            int[] results;
            try
            {
                results = DataStoreComponent.ExecuteNonQueryOnAllPartitions(this.Context, scm, this.StoreName, this.ConnectionString, "p_svc_insert_offer_instance_family_mappings", callParameters);
            }
            finally
            {
                // assign output parameter values
            }
            return results;
        }

        /// <summary>
        /// Execute stored procedure SvcInsertOfferLocations on all partitions
        /// </summary>
        /// <param name="scm">Connection Manager</param>
        /// <param name="bi_offer_id">bi_offer_id</param>
        /// <param name="i_location_rank">i_location_rank</param>
        /// <param name="vc_XRL">vc_XRL</param>
        public virtual int[] SvcInsertOfferLocations(ISpilConnectionManager scm, SqlInt64 bi_offer_id, SqlInt32 i_location_rank, string vc_XRL) {
            SqlParameter[] callParameters = new SqlParameter[3];
            // pack all parameters into Sql parameters array
            callParameters[0] = new SqlParameter();
            callParameters[0].ParameterName = "@bi_offer_id";
            callParameters[0].IsNullable = true;
            callParameters[0].SqlDbType = SqlDbType.BigInt;
            callParameters[0].Direction = ParameterDirection.Input;
            callParameters[0].Value = bi_offer_id;
            callParameters[1] = new SqlParameter();
            callParameters[1].ParameterName = "@i_location_rank";
            callParameters[1].IsNullable = true;
            callParameters[1].SqlDbType = SqlDbType.Int;
            callParameters[1].Direction = ParameterDirection.Input;
            callParameters[1].Value = i_location_rank;
            callParameters[2] = new SqlParameter();
            callParameters[2].ParameterName = "@vc_XRL";
            callParameters[2].IsNullable = true;
            callParameters[2].SqlDbType = SqlDbType.NVarChar;
            callParameters[2].Direction = ParameterDirection.Input;
            callParameters[2].Size = 4000;
            if ((vc_XRL == null)) {
                callParameters[2].Value = SqlString.Null;
            }
            else {
                callParameters[2].Value = ((System.Data.SqlTypes.SqlString)(vc_XRL));
            }
            int[] results;
            try {
                results = DataStoreComponent.ExecuteNonQueryOnAllPartitions(this.Context, scm, this.StoreName, this.ConnectionString, "p_svc_insert_offer_locations", callParameters);
            }
            finally {
                // assign output parameter values
            }
            return results;
        }
        
        /// <summary>
        /// Execute stored procedure SvcInsertOfferPrivileges on all partitions
        /// </summary>
        /// <param name="scm">Connection Manager</param>
        /// <param name="bi_offer_id">the offer id</param>
        /// <param name="vc_privileges">the list of privileges that the offer should confer</param>
        public virtual int[] SvcInsertOfferPrivileges(ISpilConnectionManager scm, SqlInt64 bi_offer_id, string vc_privileges) {
            SqlParameter[] callParameters = new SqlParameter[2];
            // pack all parameters into Sql parameters array
            callParameters[0] = new SqlParameter();
            callParameters[0].ParameterName = "@bi_offer_id";
            callParameters[0].IsNullable = true;
            callParameters[0].SqlDbType = SqlDbType.BigInt;
            callParameters[0].Direction = ParameterDirection.Input;
            callParameters[0].Value = bi_offer_id;
            callParameters[1] = new SqlParameter();
            callParameters[1].ParameterName = "@vc_privileges";
            callParameters[1].IsNullable = true;
            callParameters[1].SqlDbType = SqlDbType.NVarChar;
            callParameters[1].Direction = ParameterDirection.Input;
            callParameters[1].Size = 256;
            if ((vc_privileges == null)) {
                callParameters[1].Value = SqlString.Null;
            }
            else {
                callParameters[1].Value = ((System.Data.SqlTypes.SqlString)(vc_privileges));
            }
            int[] results;
            try {
                results = DataStoreComponent.ExecuteNonQueryOnAllPartitions(this.Context, scm, this.StoreName, this.ConnectionString, "p_svc_insert_offer_privileges", callParameters);
            }
            finally {
                // assign output parameter values
            }
            return results;
        }
        
        /// <summary>
        /// Execute stored procedure SvcInsertOfferRegions on all partitions
        /// </summary>
        /// <param name="scm">Connection Manager</param>
        /// <param name="bi_offer_id">bi_offer_id</param>
        /// <param name="ti_country_id">ti_country_id</param>
        /// <param name="vc_billing_offer_id">vc_billing_offer_id</param>
        /// <param name="i_price_whole">i_price_whole</param>
        /// <param name="i_price_fractional">i_price_fractional</param>
        /// <param name="si_specific_offer_details">si_specific_offer_details</param>
        public virtual int[] SvcInsertOfferRegions(ISpilConnectionManager scm, SqlInt64 bi_offer_id, SqlByte ti_country_id, string vc_billing_offer_id, SqlInt32 i_price_whole, SqlInt32 i_price_fractional, SqlInt16 si_specific_offer_details) {
            SqlParameter[] callParameters = new SqlParameter[6];
            // pack all parameters into Sql parameters array
            callParameters[0] = new SqlParameter();
            callParameters[0].ParameterName = "@bi_offer_id";
            callParameters[0].IsNullable = true;
            callParameters[0].SqlDbType = SqlDbType.BigInt;
            callParameters[0].Direction = ParameterDirection.Input;
            callParameters[0].Value = bi_offer_id;
            callParameters[1] = new SqlParameter();
            callParameters[1].ParameterName = "@ti_country_id";
            callParameters[1].IsNullable = true;
            callParameters[1].SqlDbType = SqlDbType.TinyInt;
            callParameters[1].Direction = ParameterDirection.Input;
            callParameters[1].Value = ti_country_id;
            callParameters[2] = new SqlParameter();
            callParameters[2].ParameterName = "@vc_billing_offer_id";
            callParameters[2].IsNullable = true;
            callParameters[2].SqlDbType = SqlDbType.NVarChar;
            callParameters[2].Direction = ParameterDirection.Input;
            callParameters[2].Size = 36;
            if ((vc_billing_offer_id == null)) {
                callParameters[2].Value = SqlString.Null;
            }
            else {
                callParameters[2].Value = ((System.Data.SqlTypes.SqlString)(vc_billing_offer_id));
            }
            callParameters[3] = new SqlParameter();
            callParameters[3].ParameterName = "@i_price_whole";
            callParameters[3].IsNullable = true;
            callParameters[3].SqlDbType = SqlDbType.Int;
            callParameters[3].Direction = ParameterDirection.Input;
            callParameters[3].Value = i_price_whole;
            callParameters[4] = new SqlParameter();
            callParameters[4].ParameterName = "@i_price_fractional";
            callParameters[4].IsNullable = true;
            callParameters[4].SqlDbType = SqlDbType.Int;
            callParameters[4].Direction = ParameterDirection.Input;
            callParameters[4].Value = i_price_fractional;
            callParameters[5] = new SqlParameter();
            callParameters[5].ParameterName = "@si_specific_offer_details";
            callParameters[5].IsNullable = true;
            callParameters[5].SqlDbType = SqlDbType.SmallInt;
            callParameters[5].Direction = ParameterDirection.Input;
            callParameters[5].Value = si_specific_offer_details;
            int[] results;
            try {
                results = DataStoreComponent.ExecuteNonQueryOnAllPartitions(this.Context, scm, this.StoreName, this.ConnectionString, "p_svc_insert_offer_regions", callParameters);
            }
            finally {
                // assign output parameter values
            }
            return results;
        }
        
        /// <summary>
        /// Execute stored procedure SvcInsertOfferRegionsXenon on all partitions
        /// </summary>
        /// <param name="scm">Connection Manager</param>
        /// <param name="bi_offer_id">bi_offer_id</param>
        /// <param name="ti_country_id">ti_country_id</param>
        /// <param name="i_tier_required">i_tier_required</param>
        /// <param name="i_payment_type_id">i_payment_type_id</param>
        /// <param name="dt_start_date">dt_start_date</param>
        /// <param name="dt_end_date">dt_end_date</param>
        /// <param name="vc_billing_offer_id">vc_billing_offer_id</param>
        /// <param name="i_price_whole">i_price_whole</param>
        /// <param name="i_price_fractional">i_price_fractional</param>
        /// <param name="si_specific_offer_details">si_specific_offer_details</param>
        public virtual int[] SvcInsertOfferRegionsXenon(ISpilConnectionManager scm, SqlInt64 bi_offer_id, SqlByte ti_country_id, SqlInt32 i_tier_required, SqlInt32 i_payment_type_id, SqlDateTime dt_start_date, SqlDateTime dt_end_date, string vc_billing_offer_id, SqlInt32 i_price_whole, SqlInt32 i_price_fractional, SqlInt16 si_specific_offer_details) {
            SqlParameter[] callParameters = new SqlParameter[10];
            // pack all parameters into Sql parameters array
            callParameters[0] = new SqlParameter();
            callParameters[0].ParameterName = "@bi_offer_id";
            callParameters[0].IsNullable = true;
            callParameters[0].SqlDbType = SqlDbType.BigInt;
            callParameters[0].Direction = ParameterDirection.Input;
            callParameters[0].Value = bi_offer_id;
            callParameters[1] = new SqlParameter();
            callParameters[1].ParameterName = "@ti_country_id";
            callParameters[1].IsNullable = true;
            callParameters[1].SqlDbType = SqlDbType.TinyInt;
            callParameters[1].Direction = ParameterDirection.Input;
            callParameters[1].Value = ti_country_id;
            callParameters[2] = new SqlParameter();
            callParameters[2].ParameterName = "@i_tier_required";
            callParameters[2].IsNullable = true;
            callParameters[2].SqlDbType = SqlDbType.Int;
            callParameters[2].Direction = ParameterDirection.Input;
            callParameters[2].Value = i_tier_required;
            callParameters[3] = new SqlParameter();
            callParameters[3].ParameterName = "@i_payment_type_id";
            callParameters[3].IsNullable = true;
            callParameters[3].SqlDbType = SqlDbType.Int;
            callParameters[3].Direction = ParameterDirection.Input;
            callParameters[3].Value = i_payment_type_id;
            callParameters[4] = new SqlParameter();
            callParameters[4].ParameterName = "@dt_start_date";
            callParameters[4].IsNullable = true;
            callParameters[4].SqlDbType = SqlDbType.DateTime;
            callParameters[4].Direction = ParameterDirection.Input;
            callParameters[4].Value = dt_start_date;
            callParameters[5] = new SqlParameter();
            callParameters[5].ParameterName = "@dt_end_date";
            callParameters[5].IsNullable = true;
            callParameters[5].SqlDbType = SqlDbType.DateTime;
            callParameters[5].Direction = ParameterDirection.Input;
            callParameters[5].Value = dt_end_date;
            callParameters[6] = new SqlParameter();
            callParameters[6].ParameterName = "@vc_billing_offer_id";
            callParameters[6].IsNullable = true;
            callParameters[6].SqlDbType = SqlDbType.NVarChar;
            callParameters[6].Direction = ParameterDirection.Input;
            callParameters[6].Size = 36;
            if ((vc_billing_offer_id == null)) {
                callParameters[6].Value = SqlString.Null;
            }
            else {
                callParameters[6].Value = ((System.Data.SqlTypes.SqlString)(vc_billing_offer_id));
            }
            callParameters[7] = new SqlParameter();
            callParameters[7].ParameterName = "@i_price_whole";
            callParameters[7].IsNullable = true;
            callParameters[7].SqlDbType = SqlDbType.Int;
            callParameters[7].Direction = ParameterDirection.Input;
            callParameters[7].Value = i_price_whole;
            callParameters[8] = new SqlParameter();
            callParameters[8].ParameterName = "@i_price_fractional";
            callParameters[8].IsNullable = true;
            callParameters[8].SqlDbType = SqlDbType.Int;
            callParameters[8].Direction = ParameterDirection.Input;
            callParameters[8].Value = i_price_fractional;
            callParameters[9] = new SqlParameter();
            callParameters[9].ParameterName = "@si_specific_offer_details";
            callParameters[9].IsNullable = true;
            callParameters[9].SqlDbType = SqlDbType.SmallInt;
            callParameters[9].Direction = ParameterDirection.Input;
            callParameters[9].Value = si_specific_offer_details;
            int[] results;
            try {
                results = DataStoreComponent.ExecuteNonQueryOnAllPartitions(this.Context, scm, this.StoreName, this.ConnectionString, "p_svc_insert_offer_regions_xenon", callParameters);
            }
            finally {
                // assign output parameter values
            }
            return results;
        }
        
        /// <summary>
        /// Execute stored procedure SvcInsertOfferRelations on all partitions
        /// </summary>
        /// <param name="scm">Connection Manager</param>
        /// <param name="bi_offer_id">bi_offer_id</param>
        /// <param name="bi_related_offer_id">bi_related_offer_id</param>
        /// <param name="i_relation_type_id">i_relation_type_id</param>
        /// <param name="i_convert_mode">i_convert_mode</param>
        public virtual int[] SvcInsertOfferRelations(ISpilConnectionManager scm, SqlInt64 bi_offer_id, SqlInt64 bi_related_offer_id, SqlInt32 i_relation_type_id, SqlInt32 i_convert_mode) {
            SqlParameter[] callParameters = new SqlParameter[4];
            // pack all parameters into Sql parameters array
            callParameters[0] = new SqlParameter();
            callParameters[0].ParameterName = "@bi_offer_id";
            callParameters[0].IsNullable = true;
            callParameters[0].SqlDbType = SqlDbType.BigInt;
            callParameters[0].Direction = ParameterDirection.Input;
            callParameters[0].Value = bi_offer_id;
            callParameters[1] = new SqlParameter();
            callParameters[1].ParameterName = "@bi_related_offer_id";
            callParameters[1].IsNullable = true;
            callParameters[1].SqlDbType = SqlDbType.BigInt;
            callParameters[1].Direction = ParameterDirection.Input;
            callParameters[1].Value = bi_related_offer_id;
            callParameters[2] = new SqlParameter();
            callParameters[2].ParameterName = "@i_relation_type_id";
            callParameters[2].IsNullable = true;
            callParameters[2].SqlDbType = SqlDbType.Int;
            callParameters[2].Direction = ParameterDirection.Input;
            callParameters[2].Value = i_relation_type_id;
            callParameters[3] = new SqlParameter();
            callParameters[3].ParameterName = "@i_convert_mode";
            callParameters[3].IsNullable = true;
            callParameters[3].SqlDbType = SqlDbType.Int;
            callParameters[3].Direction = ParameterDirection.Input;
            callParameters[3].Value = i_convert_mode;
            int[] results;
            try {
                results = DataStoreComponent.ExecuteNonQueryOnAllPartitions(this.Context, scm, this.StoreName, this.ConnectionString, "p_svc_insert_offer_relations", callParameters);
            }
            finally {
                // assign output parameter values
            }
            return results;
        }
        
        /// <summary>
        /// Execute stored procedure SvcInsertOfferRewardDetails on all partitions
        /// </summary>
        /// <param name="scm">Connection Manager</param>
        /// <param name="bi_offer_id">the subscription offer id</param>
        /// <param name="i_reward_id">the ID of the reward associated with this subscription</param>
        public virtual int[] SvcInsertOfferRewardDetails(ISpilConnectionManager scm, SqlInt64 bi_offer_id, SqlInt32 i_reward_id) {
            SqlParameter[] callParameters = new SqlParameter[2];
            // pack all parameters into Sql parameters array
            callParameters[0] = new SqlParameter();
            callParameters[0].ParameterName = "@bi_offer_id";
            callParameters[0].IsNullable = true;
            callParameters[0].SqlDbType = SqlDbType.BigInt;
            callParameters[0].Direction = ParameterDirection.Input;
            callParameters[0].Value = bi_offer_id;
            callParameters[1] = new SqlParameter();
            callParameters[1].ParameterName = "@i_reward_id";
            callParameters[1].IsNullable = true;
            callParameters[1].SqlDbType = SqlDbType.Int;
            callParameters[1].Direction = ParameterDirection.Input;
            callParameters[1].Value = i_reward_id;
            int[] results;
            try {
                results = DataStoreComponent.ExecuteNonQueryOnAllPartitions(this.Context, scm, this.StoreName, this.ConnectionString, "p_svc_insert_offer_reward_details", callParameters);
            }
            finally {
                // assign output parameter values
            }
            return results;
        }
        
        /// <summary>
        /// Execute stored procedure SvcInsertOfferScsItemDetails on all partitions
        /// </summary>
        /// <param name="scm">Connection Manager</param>
        /// <param name="bi_offer_id">the points offer id</param>
        /// <param name="i_campaign_id">the campaign associated with this offer</param>
        public virtual int[] SvcInsertOfferScsItemDetails(ISpilConnectionManager scm, SqlInt64 bi_offer_id, SqlInt32 i_campaign_id) {
            SqlParameter[] callParameters = new SqlParameter[2];
            // pack all parameters into Sql parameters array
            callParameters[0] = new SqlParameter();
            callParameters[0].ParameterName = "@bi_offer_id";
            callParameters[0].IsNullable = true;
            callParameters[0].SqlDbType = SqlDbType.BigInt;
            callParameters[0].Direction = ParameterDirection.Input;
            callParameters[0].Value = bi_offer_id;
            callParameters[1] = new SqlParameter();
            callParameters[1].ParameterName = "@i_campaign_id";
            callParameters[1].IsNullable = true;
            callParameters[1].SqlDbType = SqlDbType.Int;
            callParameters[1].Direction = ParameterDirection.Input;
            callParameters[1].Value = i_campaign_id;
            int[] results;
            try {
                results = DataStoreComponent.ExecuteNonQueryOnAllPartitions(this.Context, scm, this.StoreName, this.ConnectionString, "p_svc_insert_offer_scs_item_details", callParameters);
            }
            finally {
                // assign output parameter values
            }
            return results;
        }
        
        /// <summary>
        /// Execute stored procedure SvcInsertOfferServices on all partitions
        /// </summary>
        /// <param name="scm">Connection Manager</param>
        /// <param name="bi_offer_id">bi_offer_id</param>
        /// <param name="i_site_id">i_site_id</param>
        public virtual int[] SvcInsertOfferServices(ISpilConnectionManager scm, SqlInt64 bi_offer_id, SqlInt32 i_site_id) {
            SqlParameter[] callParameters = new SqlParameter[2];
            // pack all parameters into Sql parameters array
            callParameters[0] = new SqlParameter();
            callParameters[0].ParameterName = "@bi_offer_id";
            callParameters[0].IsNullable = true;
            callParameters[0].SqlDbType = SqlDbType.BigInt;
            callParameters[0].Direction = ParameterDirection.Input;
            callParameters[0].Value = bi_offer_id;
            callParameters[1] = new SqlParameter();
            callParameters[1].ParameterName = "@i_site_id";
            callParameters[1].IsNullable = true;
            callParameters[1].SqlDbType = SqlDbType.Int;
            callParameters[1].Direction = ParameterDirection.Input;
            callParameters[1].Value = i_site_id;
            int[] results;
            try {
                results = DataStoreComponent.ExecuteNonQueryOnAllPartitions(this.Context, scm, this.StoreName, this.ConnectionString, "p_svc_insert_offer_services", callParameters);
            }
            finally {
                // assign output parameter values
            }
            return results;
        }
        
        /// <summary>
        /// Execute stored procedure SvcInsertOfferSku on all partitions
        /// </summary>
        /// <param name="scm">Connection Manager</param>
        /// <param name="i_sku_id">the SKU id</param>
        /// <param name="i_sku_type_id">the SKU type id (lcid)</param>
        /// <param name="vc_sku">the actual SKU value</param>
        /// <param name="vc_friendly_name">an ops-friendly name for this SKU</param>
        /// <param name="i_overwrite">flag allow overwritting of existing row</param>
        public virtual int[] SvcInsertOfferSku(ISpilConnectionManager scm, SqlInt32 i_sku_id, SqlInt32 i_sku_type_id, string vc_sku, string vc_friendly_name, SqlInt32 i_overwrite) {
            SqlParameter[] callParameters = new SqlParameter[5];
            // pack all parameters into Sql parameters array
            callParameters[0] = new SqlParameter();
            callParameters[0].ParameterName = "@i_sku_id";
            callParameters[0].IsNullable = true;
            callParameters[0].SqlDbType = SqlDbType.Int;
            callParameters[0].Direction = ParameterDirection.Input;
            callParameters[0].Value = i_sku_id;
            callParameters[1] = new SqlParameter();
            callParameters[1].ParameterName = "@i_sku_type_id";
            callParameters[1].IsNullable = true;
            callParameters[1].SqlDbType = SqlDbType.Int;
            callParameters[1].Direction = ParameterDirection.Input;
            callParameters[1].Value = i_sku_type_id;
            callParameters[2] = new SqlParameter();
            callParameters[2].ParameterName = "@vc_sku";
            callParameters[2].IsNullable = true;
            callParameters[2].SqlDbType = SqlDbType.NVarChar;
            callParameters[2].Direction = ParameterDirection.Input;
            callParameters[2].Size = 200;
            if ((vc_sku == null)) {
                callParameters[2].Value = SqlString.Null;
            }
            else {
                callParameters[2].Value = ((System.Data.SqlTypes.SqlString)(vc_sku));
            }
            callParameters[3] = new SqlParameter();
            callParameters[3].ParameterName = "@vc_friendly_name";
            callParameters[3].IsNullable = true;
            callParameters[3].SqlDbType = SqlDbType.NVarChar;
            callParameters[3].Direction = ParameterDirection.Input;
            callParameters[3].Size = 200;
            if ((vc_friendly_name == null)) {
                callParameters[3].Value = SqlString.Null;
            }
            else {
                callParameters[3].Value = ((System.Data.SqlTypes.SqlString)(vc_friendly_name));
            }
            callParameters[4] = new SqlParameter();
            callParameters[4].ParameterName = "@i_overwrite";
            callParameters[4].IsNullable = true;
            callParameters[4].SqlDbType = SqlDbType.Int;
            callParameters[4].Direction = ParameterDirection.Input;
            callParameters[4].Value = i_overwrite;
            int[] results;
            try {
                results = DataStoreComponent.ExecuteNonQueryOnAllPartitions(this.Context, scm, this.StoreName, this.ConnectionString, "p_svc_insert_offer_sku", callParameters);
            }
            finally {
                // assign output parameter values
            }
            return results;
        }
        
        /// <summary>
        /// Execute stored procedure SvcInsertOfferSubscriptionReward on all partitions
        /// </summary>
        /// <param name="scm">Connection Manager</param>
        /// <param name="bi_offer_id">the subscription offer id</param>
        /// <param name="ti_country_id">the country associated with the subscription</param>
        /// <param name="i_subscription_tier_id">the tier associated with the subscription</param>
        /// <param name="dt_start_date">the date on which this subscription reward goes into effect</param>
        /// <param name="dt_end_date">the date on which this subscription reward is no longer in effect</param>
        /// <param name="i_reward_id">the ID of the reward associated with this subscription</param>
        public virtual int[] SvcInsertOfferSubscriptionReward(ISpilConnectionManager scm, SqlInt64 bi_offer_id, SqlInt32 ti_country_id, SqlInt32 i_subscription_tier_id, SqlDateTime dt_start_date, SqlDateTime dt_end_date, SqlInt32 i_reward_id) {
            SqlParameter[] callParameters = new SqlParameter[6];
            // pack all parameters into Sql parameters array
            callParameters[0] = new SqlParameter();
            callParameters[0].ParameterName = "@bi_offer_id";
            callParameters[0].IsNullable = true;
            callParameters[0].SqlDbType = SqlDbType.BigInt;
            callParameters[0].Direction = ParameterDirection.Input;
            callParameters[0].Value = bi_offer_id;
            callParameters[1] = new SqlParameter();
            callParameters[1].ParameterName = "@ti_country_id";
            callParameters[1].IsNullable = true;
            callParameters[1].SqlDbType = SqlDbType.Int;
            callParameters[1].Direction = ParameterDirection.Input;
            callParameters[1].Value = ti_country_id;
            callParameters[2] = new SqlParameter();
            callParameters[2].ParameterName = "@i_subscription_tier_id";
            callParameters[2].IsNullable = true;
            callParameters[2].SqlDbType = SqlDbType.Int;
            callParameters[2].Direction = ParameterDirection.Input;
            callParameters[2].Value = i_subscription_tier_id;
            callParameters[3] = new SqlParameter();
            callParameters[3].ParameterName = "@dt_start_date";
            callParameters[3].IsNullable = true;
            callParameters[3].SqlDbType = SqlDbType.DateTime;
            callParameters[3].Direction = ParameterDirection.Input;
            callParameters[3].Value = dt_start_date;
            callParameters[4] = new SqlParameter();
            callParameters[4].ParameterName = "@dt_end_date";
            callParameters[4].IsNullable = true;
            callParameters[4].SqlDbType = SqlDbType.DateTime;
            callParameters[4].Direction = ParameterDirection.Input;
            callParameters[4].Value = dt_end_date;
            callParameters[5] = new SqlParameter();
            callParameters[5].ParameterName = "@i_reward_id";
            callParameters[5].IsNullable = true;
            callParameters[5].SqlDbType = SqlDbType.Int;
            callParameters[5].Direction = ParameterDirection.Input;
            callParameters[5].Value = i_reward_id;
            int[] results;
            try {
                results = DataStoreComponent.ExecuteNonQueryOnAllPartitions(this.Context, scm, this.StoreName, this.ConnectionString, "p_svc_insert_offer_subscription_reward", callParameters);
            }
            finally {
                // assign output parameter values
            }
            return results;
        }
        
        /// <summary>
        /// Execute stored procedure SvcInsertSubscriptions on all partitions
        /// </summary>
        /// <param name="scm">Connection Manager</param>
        /// <param name="i_title_id">i_title_id</param>
        /// <param name="bi_offer_id">bi_offer_id</param>
        /// <param name="i_ESRB_id">i_ESRB_id</param>
        /// <param name="b_cancelable">b_cancelable</param>
        /// <param name="i_package_size">i_package_size</param>
        /// <param name="i_install_size">i_install_size</param>
        /// <param name="vb_sym_key">vb_sym_key</param>
        /// <param name="i_bitfilter">i_bitfilter</param>
        /// <param name="vc_billing_svc_component_id">vc_billing_svc_component_id</param>
        /// <param name="i_offer_type_id">i_offer_type_id</param>
        /// <param name="i_offer_frequency_id">i_offer_frequency_id</param>
        /// <param name="dt_start_date">dt_start_date</param>
        /// <param name="dt_end_date">dt_end_date</param>
        /// <param name="vc_friendly_name">vc_friendly_name</param>
        /// <param name="vb_public_key">vb_public_key</param>
        /// <param name="i_policy_flags">i_policy_flags</param>
        /// <param name="si_global_offer_details">si_global_offer_details</param>
        /// <param name="ti_console_type_id">default to an xbox1 offer</param>
        public virtual int[] SvcInsertSubscriptions(
                    ISpilConnectionManager scm, 
                    SqlInt32 i_title_id, 
                    SqlInt64 bi_offer_id, 
                    SqlInt32 i_ESRB_id, 
                    SqlByte b_cancelable, 
                    SqlInt32 i_package_size, 
                    SqlInt32 i_install_size, 
                    SqlBinary vb_sym_key, 
                    SqlInt32 i_bitfilter, 
                    string vc_billing_svc_component_id, 
                    SqlInt32 i_offer_type_id, 
                    SqlInt32 i_offer_frequency_id, 
                    SqlDateTime dt_start_date, 
                    SqlDateTime dt_end_date, 
                    string vc_friendly_name, 
                    SqlBinary vb_public_key, 
                    SqlInt32 i_policy_flags, 
                    SqlInt16 si_global_offer_details, 
                    SqlByte ti_console_type_id) {
            SqlParameter[] callParameters = new SqlParameter[18];
            // pack all parameters into Sql parameters array
            callParameters[0] = new SqlParameter();
            callParameters[0].ParameterName = "@i_title_id";
            callParameters[0].IsNullable = true;
            callParameters[0].SqlDbType = SqlDbType.Int;
            callParameters[0].Direction = ParameterDirection.Input;
            callParameters[0].Value = i_title_id;
            callParameters[1] = new SqlParameter();
            callParameters[1].ParameterName = "@bi_offer_id";
            callParameters[1].IsNullable = true;
            callParameters[1].SqlDbType = SqlDbType.BigInt;
            callParameters[1].Direction = ParameterDirection.Input;
            callParameters[1].Value = bi_offer_id;
            callParameters[2] = new SqlParameter();
            callParameters[2].ParameterName = "@i_ESRB_id";
            callParameters[2].IsNullable = true;
            callParameters[2].SqlDbType = SqlDbType.Int;
            callParameters[2].Direction = ParameterDirection.Input;
            callParameters[2].Value = i_ESRB_id;
            callParameters[3] = new SqlParameter();
            callParameters[3].ParameterName = "@b_cancelable";
            callParameters[3].IsNullable = true;
            callParameters[3].SqlDbType = SqlDbType.TinyInt;
            callParameters[3].Direction = ParameterDirection.Input;
            callParameters[3].Value = b_cancelable;
            callParameters[4] = new SqlParameter();
            callParameters[4].ParameterName = "@i_package_size";
            callParameters[4].IsNullable = true;
            callParameters[4].SqlDbType = SqlDbType.Int;
            callParameters[4].Direction = ParameterDirection.Input;
            callParameters[4].Value = i_package_size;
            callParameters[5] = new SqlParameter();
            callParameters[5].ParameterName = "@i_install_size";
            callParameters[5].IsNullable = true;
            callParameters[5].SqlDbType = SqlDbType.Int;
            callParameters[5].Direction = ParameterDirection.Input;
            callParameters[5].Value = i_install_size;
            callParameters[6] = new SqlParameter();
            callParameters[6].ParameterName = "@vb_sym_key";
            callParameters[6].IsNullable = true;
            callParameters[6].SqlDbType = SqlDbType.VarBinary;
            callParameters[6].Direction = ParameterDirection.Input;
            callParameters[6].Size = 16;
            callParameters[6].Value = vb_sym_key;
            callParameters[7] = new SqlParameter();
            callParameters[7].ParameterName = "@i_bitfilter";
            callParameters[7].IsNullable = true;
            callParameters[7].SqlDbType = SqlDbType.Int;
            callParameters[7].Direction = ParameterDirection.Input;
            callParameters[7].Value = i_bitfilter;
            callParameters[8] = new SqlParameter();
            callParameters[8].ParameterName = "@vc_billing_svc_component_id";
            callParameters[8].IsNullable = true;
            callParameters[8].SqlDbType = SqlDbType.NVarChar;
            callParameters[8].Direction = ParameterDirection.Input;
            callParameters[8].Size = 36;
            if ((vc_billing_svc_component_id == null)) {
                callParameters[8].Value = SqlString.Null;
            }
            else {
                callParameters[8].Value = ((System.Data.SqlTypes.SqlString)(vc_billing_svc_component_id));
            }
            callParameters[9] = new SqlParameter();
            callParameters[9].ParameterName = "@i_offer_type_id";
            callParameters[9].IsNullable = true;
            callParameters[9].SqlDbType = SqlDbType.Int;
            callParameters[9].Direction = ParameterDirection.Input;
            callParameters[9].Value = i_offer_type_id;
            callParameters[10] = new SqlParameter();
            callParameters[10].ParameterName = "@i_offer_frequency_id";
            callParameters[10].IsNullable = true;
            callParameters[10].SqlDbType = SqlDbType.Int;
            callParameters[10].Direction = ParameterDirection.Input;
            callParameters[10].Value = i_offer_frequency_id;
            callParameters[11] = new SqlParameter();
            callParameters[11].ParameterName = "@dt_start_date";
            callParameters[11].IsNullable = true;
            callParameters[11].SqlDbType = SqlDbType.DateTime;
            callParameters[11].Direction = ParameterDirection.Input;
            callParameters[11].Value = dt_start_date;
            callParameters[12] = new SqlParameter();
            callParameters[12].ParameterName = "@dt_end_date";
            callParameters[12].IsNullable = true;
            callParameters[12].SqlDbType = SqlDbType.DateTime;
            callParameters[12].Direction = ParameterDirection.Input;
            callParameters[12].Value = dt_end_date;
            callParameters[13] = new SqlParameter();
            callParameters[13].ParameterName = "@vc_friendly_name";
            callParameters[13].IsNullable = true;
            callParameters[13].SqlDbType = SqlDbType.NVarChar;
            callParameters[13].Direction = ParameterDirection.Input;
            callParameters[13].Size = 150;
            if ((vc_friendly_name == null)) {
                callParameters[13].Value = SqlString.Null;
            }
            else {
                callParameters[13].Value = ((System.Data.SqlTypes.SqlString)(vc_friendly_name));
            }
            callParameters[14] = new SqlParameter();
            callParameters[14].ParameterName = "@vb_public_key";
            callParameters[14].IsNullable = true;
            callParameters[14].SqlDbType = SqlDbType.VarBinary;
            callParameters[14].Direction = ParameterDirection.Input;
            callParameters[14].Size = 284;
            callParameters[14].Value = vb_public_key;
            callParameters[15] = new SqlParameter();
            callParameters[15].ParameterName = "@i_policy_flags";
            callParameters[15].IsNullable = true;
            callParameters[15].SqlDbType = SqlDbType.Int;
            callParameters[15].Direction = ParameterDirection.Input;
            callParameters[15].Value = i_policy_flags;
            callParameters[16] = new SqlParameter();
            callParameters[16].ParameterName = "@si_global_offer_details";
            callParameters[16].IsNullable = true;
            callParameters[16].SqlDbType = SqlDbType.SmallInt;
            callParameters[16].Direction = ParameterDirection.Input;
            callParameters[16].Value = si_global_offer_details;
            callParameters[17] = new SqlParameter();
            callParameters[17].ParameterName = "@ti_console_type_id";
            callParameters[17].IsNullable = true;
            callParameters[17].SqlDbType = SqlDbType.TinyInt;
            callParameters[17].Direction = ParameterDirection.Input;
            callParameters[17].Value = ti_console_type_id;
            int[] results;
            try {
                results = DataStoreComponent.ExecuteNonQueryOnAllPartitions(this.Context, scm, this.StoreName, this.ConnectionString, "p_svc_insert_subscriptions", callParameters);
            }
            finally {
                // assign output parameter values
            }
            return results;
        }
        
        /// <summary>
        /// Execute stored procedure SvcInsertSubscriptionsMultiTitle on all partitions
        /// </summary>
        /// <param name="scm">Connection Manager</param>
        /// <param name="xml_title_ids">xml_title_ids</param>
        /// <param name="bi_offer_id">bi_offer_id</param>
        /// <param name="i_ESRB_id">i_ESRB_id</param>
        /// <param name="b_cancelable">b_cancelable</param>
        /// <param name="i_package_size">i_package_size</param>
        /// <param name="i_install_size">i_install_size</param>
        /// <param name="vb_sym_key">vb_sym_key</param>
        /// <param name="i_bitfilter">i_bitfilter</param>
        /// <param name="vc_billing_svc_component_id">vc_billing_svc_component_id</param>
        /// <param name="i_offer_type_id">i_offer_type_id</param>
        /// <param name="i_offer_frequency_id">i_offer_frequency_id</param>
        /// <param name="dt_start_date">dt_start_date</param>
        /// <param name="dt_end_date">dt_end_date</param>
        /// <param name="vc_friendly_name">vc_friendly_name</param>
        /// <param name="vb_public_key">vb_public_key</param>
        /// <param name="i_policy_flags">i_policy_flags</param>
        /// <param name="si_global_offer_details">si_global_offer_details</param>
        /// <param name="ti_console_type_id">default to an xbox1 offer</param>
        public virtual int[] SvcInsertSubscriptionsMultiTitle(
                    ISpilConnectionManager scm,
                    SqlXml xml_title_ids,
                    SqlInt64 bi_offer_id,
                    SqlInt32 i_ESRB_id,
                    SqlByte b_cancelable,
                    SqlInt32 i_package_size,
                    SqlInt32 i_install_size,
                    SqlBinary vb_sym_key,
                    SqlInt32 i_bitfilter,
                    string vc_billing_svc_component_id,
                    SqlInt32 i_offer_type_id,
                    SqlInt32 i_offer_frequency_id,
                    SqlDateTime dt_start_date,
                    SqlDateTime dt_end_date,
                    string vc_friendly_name,
                    SqlBinary vb_public_key,
                    SqlInt32 i_policy_flags,
                    SqlInt16 si_global_offer_details,
                    SqlByte ti_console_type_id )
        {
            SqlParameter[] callParameters = new SqlParameter[18];
            // pack all parameters into Sql parameters array
            callParameters[0] = new SqlParameter();
            callParameters[0].ParameterName = "@xml_title_ids";
            callParameters[0].IsNullable = true;
            callParameters[0].SqlDbType = SqlDbType.Xml;
            callParameters[0].Direction = ParameterDirection.Input;
            callParameters[0].Value = xml_title_ids;
            callParameters[1] = new SqlParameter();
            callParameters[1].ParameterName = "@bi_offer_id";
            callParameters[1].IsNullable = true;
            callParameters[1].SqlDbType = SqlDbType.BigInt;
            callParameters[1].Direction = ParameterDirection.Input;
            callParameters[1].Value = bi_offer_id;
            callParameters[2] = new SqlParameter();
            callParameters[2].ParameterName = "@i_ESRB_id";
            callParameters[2].IsNullable = true;
            callParameters[2].SqlDbType = SqlDbType.Int;
            callParameters[2].Direction = ParameterDirection.Input;
            callParameters[2].Value = i_ESRB_id;
            callParameters[3] = new SqlParameter();
            callParameters[3].ParameterName = "@b_cancelable";
            callParameters[3].IsNullable = true;
            callParameters[3].SqlDbType = SqlDbType.TinyInt;
            callParameters[3].Direction = ParameterDirection.Input;
            callParameters[3].Value = b_cancelable;
            callParameters[4] = new SqlParameter();
            callParameters[4].ParameterName = "@i_package_size";
            callParameters[4].IsNullable = true;
            callParameters[4].SqlDbType = SqlDbType.Int;
            callParameters[4].Direction = ParameterDirection.Input;
            callParameters[4].Value = i_package_size;
            callParameters[5] = new SqlParameter();
            callParameters[5].ParameterName = "@i_install_size";
            callParameters[5].IsNullable = true;
            callParameters[5].SqlDbType = SqlDbType.Int;
            callParameters[5].Direction = ParameterDirection.Input;
            callParameters[5].Value = i_install_size;
            callParameters[6] = new SqlParameter();
            callParameters[6].ParameterName = "@vb_sym_key";
            callParameters[6].IsNullable = true;
            callParameters[6].SqlDbType = SqlDbType.VarBinary;
            callParameters[6].Direction = ParameterDirection.Input;
            callParameters[6].Size = 16;
            callParameters[6].Value = vb_sym_key;
            callParameters[7] = new SqlParameter();
            callParameters[7].ParameterName = "@i_bitfilter";
            callParameters[7].IsNullable = true;
            callParameters[7].SqlDbType = SqlDbType.Int;
            callParameters[7].Direction = ParameterDirection.Input;
            callParameters[7].Value = i_bitfilter;
            callParameters[8] = new SqlParameter();
            callParameters[8].ParameterName = "@vc_billing_svc_component_id";
            callParameters[8].IsNullable = true;
            callParameters[8].SqlDbType = SqlDbType.NVarChar;
            callParameters[8].Direction = ParameterDirection.Input;
            callParameters[8].Size = 36;
            if ( ( vc_billing_svc_component_id == null ) )
            {
                callParameters[8].Value = SqlString.Null;
            }
            else
            {
                callParameters[8].Value = ( (System.Data.SqlTypes.SqlString)( vc_billing_svc_component_id ) );
            }
            callParameters[9] = new SqlParameter();
            callParameters[9].ParameterName = "@i_offer_type_id";
            callParameters[9].IsNullable = true;
            callParameters[9].SqlDbType = SqlDbType.Int;
            callParameters[9].Direction = ParameterDirection.Input;
            callParameters[9].Value = i_offer_type_id;
            callParameters[10] = new SqlParameter();
            callParameters[10].ParameterName = "@i_offer_frequency_id";
            callParameters[10].IsNullable = true;
            callParameters[10].SqlDbType = SqlDbType.Int;
            callParameters[10].Direction = ParameterDirection.Input;
            callParameters[10].Value = i_offer_frequency_id;
            callParameters[11] = new SqlParameter();
            callParameters[11].ParameterName = "@dt_start_date";
            callParameters[11].IsNullable = true;
            callParameters[11].SqlDbType = SqlDbType.DateTime;
            callParameters[11].Direction = ParameterDirection.Input;
            callParameters[11].Value = dt_start_date;
            callParameters[12] = new SqlParameter();
            callParameters[12].ParameterName = "@dt_end_date";
            callParameters[12].IsNullable = true;
            callParameters[12].SqlDbType = SqlDbType.DateTime;
            callParameters[12].Direction = ParameterDirection.Input;
            callParameters[12].Value = dt_end_date;
            callParameters[13] = new SqlParameter();
            callParameters[13].ParameterName = "@vc_friendly_name";
            callParameters[13].IsNullable = true;
            callParameters[13].SqlDbType = SqlDbType.NVarChar;
            callParameters[13].Direction = ParameterDirection.Input;
            callParameters[13].Size = 150;
            if ( ( vc_friendly_name == null ) )
            {
                callParameters[13].Value = SqlString.Null;
            }
            else
            {
                callParameters[13].Value = ( (System.Data.SqlTypes.SqlString)( vc_friendly_name ) );
            }
            callParameters[14] = new SqlParameter();
            callParameters[14].ParameterName = "@vb_public_key";
            callParameters[14].IsNullable = true;
            callParameters[14].SqlDbType = SqlDbType.VarBinary;
            callParameters[14].Direction = ParameterDirection.Input;
            callParameters[14].Size = 284;
            callParameters[14].Value = vb_public_key;
            callParameters[15] = new SqlParameter();
            callParameters[15].ParameterName = "@i_policy_flags";
            callParameters[15].IsNullable = true;
            callParameters[15].SqlDbType = SqlDbType.Int;
            callParameters[15].Direction = ParameterDirection.Input;
            callParameters[15].Value = i_policy_flags;
            callParameters[16] = new SqlParameter();
            callParameters[16].ParameterName = "@si_global_offer_details";
            callParameters[16].IsNullable = true;
            callParameters[16].SqlDbType = SqlDbType.SmallInt;
            callParameters[16].Direction = ParameterDirection.Input;
            callParameters[16].Value = si_global_offer_details;
            callParameters[17] = new SqlParameter();
            callParameters[17].ParameterName = "@ti_console_type_id";
            callParameters[17].IsNullable = true;
            callParameters[17].SqlDbType = SqlDbType.TinyInt;
            callParameters[17].Direction = ParameterDirection.Input;
            callParameters[17].Value = ti_console_type_id;
            int[] results;
            try
            {
                results = DataStoreComponent.ExecuteNonQueryOnAllPartitions( this.Context, scm, this.StoreName, this.ConnectionString, "p_svc_insert_subscriptions_multi_title", callParameters );
            }
            finally
            {
                // assign output parameter values
            }
            return results;
        }

        /// <summary>
        /// Execute stored procedure SvcInsertSubscriptionInfo on all partitions
        /// </summary>
        /// <param name="scm">Connection Manager</param>
        /// <param name="bi_offer_id">the offer id of the offer</param>
        /// <param name="si_subscription_type">the subscription type</param>
        /// <param name="i_tier_id">the tier membership which the offers confers</param>
        /// <param name="ti_is_base">is this a base offer</param>
        public virtual int[] SvcInsertSubscriptionInfo(ISpilConnectionManager scm, SqlInt64 bi_offer_id, SqlInt16 si_subscription_type, SqlInt32 i_tier_id, SqlByte ti_is_base) {
            SqlParameter[] callParameters = new SqlParameter[4];
            // pack all parameters into Sql parameters array
            callParameters[0] = new SqlParameter();
            callParameters[0].ParameterName = "@bi_offer_id";
            callParameters[0].IsNullable = true;
            callParameters[0].SqlDbType = SqlDbType.BigInt;
            callParameters[0].Direction = ParameterDirection.Input;
            callParameters[0].Value = bi_offer_id;
            callParameters[1] = new SqlParameter();
            callParameters[1].ParameterName = "@si_subscription_type";
            callParameters[1].IsNullable = true;
            callParameters[1].SqlDbType = SqlDbType.SmallInt;
            callParameters[1].Direction = ParameterDirection.Input;
            callParameters[1].Value = si_subscription_type;
            callParameters[2] = new SqlParameter();
            callParameters[2].ParameterName = "@i_tier_id";
            callParameters[2].IsNullable = true;
            callParameters[2].SqlDbType = SqlDbType.Int;
            callParameters[2].Direction = ParameterDirection.Input;
            callParameters[2].Value = i_tier_id;
            callParameters[3] = new SqlParameter();
            callParameters[3].ParameterName = "@ti_is_base";
            callParameters[3].IsNullable = true;
            callParameters[3].SqlDbType = SqlDbType.TinyInt;
            callParameters[3].Direction = ParameterDirection.Input;
            callParameters[3].Value = ti_is_base;
            int[] results;
            try {
                results = DataStoreComponent.ExecuteNonQueryOnAllPartitions(this.Context, scm, this.StoreName, this.ConnectionString, "p_svc_insert_subscription_info", callParameters);
            }
            finally {
                // assign output parameter values
            }
            return results;
        }
                
        /// <summary>
        /// Execute stored procedure SvcInsertTitleAssociatedOffer on all partitions
        /// </summary>
        /// <param name="scm">Connection Manager</param>
        /// <param name="i_title_id">the title id that is associated with this offer (but is not the primary title)</param>
        /// <param name="bi_offer_id">the offer id</param>
        public virtual int[] SvcInsertTitleAssociatedOffer(ISpilConnectionManager scm, SqlInt32 i_title_id, SqlInt64 bi_offer_id) {
            SqlParameter[] callParameters = new SqlParameter[2];
            // pack all parameters into Sql parameters array
            callParameters[0] = new SqlParameter();
            callParameters[0].ParameterName = "@i_title_id";
            callParameters[0].IsNullable = true;
            callParameters[0].SqlDbType = SqlDbType.Int;
            callParameters[0].Direction = ParameterDirection.Input;
            callParameters[0].Value = i_title_id;
            callParameters[1] = new SqlParameter();
            callParameters[1].ParameterName = "@bi_offer_id";
            callParameters[1].IsNullable = true;
            callParameters[1].SqlDbType = SqlDbType.BigInt;
            callParameters[1].Direction = ParameterDirection.Input;
            callParameters[1].Value = bi_offer_id;
            int[] results;
            try {
                results = DataStoreComponent.ExecuteNonQueryOnAllPartitions(this.Context, scm, this.StoreName, this.ConnectionString, "p_svc_insert_title_associated_offer", callParameters);
            }
            finally {
                // assign output parameter values
            }
            return results;
        }
        
        /// <summary>
        /// Execute stored procedure SvcInsertTitleCultureDetails on all partitions
        /// </summary>
        /// <param name="scm">Connection Manager</param>
        /// <param name="i_title_id">the title id</param>
        /// <param name="i_culture_id">the culture id (lcid)</param>
        /// <param name="vc_name">the localized name of the title</param>
        /// <param name="vc_sell_text">the localized sell text of the title</param>
        /// <param name="vc_publisher">the localized name of the pubisher</param>
        /// <param name="vc_developer">the localized name of the developer</param>
        /// <param name="vc_genre">the localized name of the genre</param>
        public virtual int[] SvcInsertTitleCultureDetails(ISpilConnectionManager scm, SqlInt32 i_title_id, SqlInt32 i_culture_id, string vc_name, string vc_sell_text, string vc_publisher, string vc_developer, string vc_genre) {
            SqlParameter[] callParameters = new SqlParameter[7];
            // pack all parameters into Sql parameters array
            callParameters[0] = new SqlParameter();
            callParameters[0].ParameterName = "@i_title_id";
            callParameters[0].IsNullable = true;
            callParameters[0].SqlDbType = SqlDbType.Int;
            callParameters[0].Direction = ParameterDirection.Input;
            callParameters[0].Value = i_title_id;
            callParameters[1] = new SqlParameter();
            callParameters[1].ParameterName = "@i_culture_id";
            callParameters[1].IsNullable = true;
            callParameters[1].SqlDbType = SqlDbType.Int;
            callParameters[1].Direction = ParameterDirection.Input;
            callParameters[1].Value = i_culture_id;
            callParameters[2] = new SqlParameter();
            callParameters[2].ParameterName = "@vc_name";
            callParameters[2].IsNullable = true;
            callParameters[2].SqlDbType = SqlDbType.NVarChar;
            callParameters[2].Direction = ParameterDirection.Input;
            callParameters[2].Size = 100;
            if ((vc_name == null)) {
                callParameters[2].Value = SqlString.Null;
            }
            else {
                callParameters[2].Value = ((System.Data.SqlTypes.SqlString)(vc_name));
            }
            callParameters[3] = new SqlParameter();
            callParameters[3].ParameterName = "@vc_sell_text";
            callParameters[3].IsNullable = true;
            callParameters[3].SqlDbType = SqlDbType.NVarChar;
            callParameters[3].Direction = ParameterDirection.Input;
            callParameters[3].Size = 1000;
            if ((vc_sell_text == null)) {
                callParameters[3].Value = SqlString.Null;
            }
            else {
                callParameters[3].Value = ((System.Data.SqlTypes.SqlString)(vc_sell_text));
            }
            callParameters[4] = new SqlParameter();
            callParameters[4].ParameterName = "@vc_publisher";
            callParameters[4].IsNullable = true;
            callParameters[4].SqlDbType = SqlDbType.NVarChar;
            callParameters[4].Direction = ParameterDirection.Input;
            callParameters[4].Size = 60;
            if ((vc_publisher == null)) {
                callParameters[4].Value = SqlString.Null;
            }
            else {
                callParameters[4].Value = ((System.Data.SqlTypes.SqlString)(vc_publisher));
            }
            callParameters[5] = new SqlParameter();
            callParameters[5].ParameterName = "@vc_developer";
            callParameters[5].IsNullable = true;
            callParameters[5].SqlDbType = SqlDbType.NVarChar;
            callParameters[5].Direction = ParameterDirection.Input;
            callParameters[5].Size = 60;
            if ((vc_developer == null)) {
                callParameters[5].Value = SqlString.Null;
            }
            else {
                callParameters[5].Value = ((System.Data.SqlTypes.SqlString)(vc_developer));
            }
            callParameters[6] = new SqlParameter();
            callParameters[6].ParameterName = "@vc_genre";
            callParameters[6].IsNullable = true;
            callParameters[6].SqlDbType = SqlDbType.NVarChar;
            callParameters[6].Direction = ParameterDirection.Input;
            callParameters[6].Size = 60;
            if ((vc_genre == null)) {
                callParameters[6].Value = SqlString.Null;
            }
            else {
                callParameters[6].Value = ((System.Data.SqlTypes.SqlString)(vc_genre));
            }
            int[] results;
            try {
                results = DataStoreComponent.ExecuteNonQueryOnAllPartitions(this.Context, scm, this.StoreName, this.ConnectionString, "p_svc_insert_title_culture_details", callParameters);
            }
            finally {
                // assign output parameter values
            }
            return results;
        }
                
        /// <summary>
        /// Execute stored procedure SvcInsertTitleUpdatePackages on all partitions
        /// </summary>
        /// <param name="scm">Connection Manager</param>
        /// <param name="i_title_id">i_title_id</param>
        /// <param name="i_title_base_version">i_title_base_version</param>
        /// <param name="i_title_update_version">i_title_update_version</param>
        /// <param name="i_package_size">i_package_size</param>
        /// <param name="i_install_size">i_install_size</param>
        /// <param name="vb_update_sym_key">vb_update_sym_key</param>
        /// <param name="vb_public_key">vb_public_key</param>
        /// <param name="b_content_id">b_content_id</param>
        /// <param name="ti_console_type_id">ti_console_type_id</param>
        public virtual int[] SvcInsertTitleUpdatePackages(ISpilConnectionManager scm, SqlInt32 i_title_id, SqlInt32 i_title_base_version, SqlInt32 i_title_update_version, SqlInt32 i_package_size, SqlInt32 i_install_size, SqlBinary vb_update_sym_key, SqlBinary vb_public_key, SqlBinary b_content_id, SqlByte ti_console_type_id) {
            SqlParameter[] callParameters = new SqlParameter[9];
            // pack all parameters into Sql parameters array
            callParameters[0] = new SqlParameter();
            callParameters[0].ParameterName = "@i_title_id";
            callParameters[0].IsNullable = true;
            callParameters[0].SqlDbType = SqlDbType.Int;
            callParameters[0].Direction = ParameterDirection.Input;
            callParameters[0].Value = i_title_id;
            callParameters[1] = new SqlParameter();
            callParameters[1].ParameterName = "@i_title_base_version";
            callParameters[1].IsNullable = true;
            callParameters[1].SqlDbType = SqlDbType.Int;
            callParameters[1].Direction = ParameterDirection.Input;
            callParameters[1].Value = i_title_base_version;
            callParameters[2] = new SqlParameter();
            callParameters[2].ParameterName = "@i_title_update_version";
            callParameters[2].IsNullable = true;
            callParameters[2].SqlDbType = SqlDbType.Int;
            callParameters[2].Direction = ParameterDirection.Input;
            callParameters[2].Value = i_title_update_version;
            callParameters[3] = new SqlParameter();
            callParameters[3].ParameterName = "@i_package_size";
            callParameters[3].IsNullable = true;
            callParameters[3].SqlDbType = SqlDbType.Int;
            callParameters[3].Direction = ParameterDirection.Input;
            callParameters[3].Value = i_package_size;
            callParameters[4] = new SqlParameter();
            callParameters[4].ParameterName = "@i_install_size";
            callParameters[4].IsNullable = true;
            callParameters[4].SqlDbType = SqlDbType.Int;
            callParameters[4].Direction = ParameterDirection.Input;
            callParameters[4].Value = i_install_size;
            callParameters[5] = new SqlParameter();
            callParameters[5].ParameterName = "@vb_update_sym_key";
            callParameters[5].IsNullable = true;
            callParameters[5].SqlDbType = SqlDbType.VarBinary;
            callParameters[5].Direction = ParameterDirection.Input;
            callParameters[5].Size = 16;
            callParameters[5].Value = vb_update_sym_key;
            callParameters[6] = new SqlParameter();
            callParameters[6].ParameterName = "@vb_public_key";
            callParameters[6].IsNullable = true;
            callParameters[6].SqlDbType = SqlDbType.VarBinary;
            callParameters[6].Direction = ParameterDirection.Input;
            callParameters[6].Size = 284;
            callParameters[6].Value = vb_public_key;
            callParameters[7] = new SqlParameter();
            callParameters[7].ParameterName = "@b_content_id";
            callParameters[7].IsNullable = true;
            callParameters[7].SqlDbType = SqlDbType.Binary;
            callParameters[7].Direction = ParameterDirection.Input;
            callParameters[7].Size = 20;
            callParameters[7].Value = b_content_id;
            callParameters[8] = new SqlParameter();
            callParameters[8].ParameterName = "@ti_console_type_id";
            callParameters[8].IsNullable = true;
            callParameters[8].SqlDbType = SqlDbType.TinyInt;
            callParameters[8].Direction = ParameterDirection.Input;
            callParameters[8].Value = ti_console_type_id;
            int[] results;
            try {
                results = DataStoreComponent.ExecuteNonQueryOnAllPartitions(this.Context, scm, this.StoreName, this.ConnectionString, "p_svc_insert_title_update_packages", callParameters);
            }
            finally {
                // assign output parameter values
            }
            return results;
        }
        
        /// <summary>
        /// Execute stored procedure SvcInsertTitleVersions on all partitions
        /// </summary>
        /// <param name="scm">Connection Manager</param>
        /// <param name="i_title_id">i_title_id</param>
        /// <param name="i_base_version">i_base_version</param>
        /// <param name="i_new_version">i_new_version</param>
        /// <param name="i_version_flag">i_version_flag</param>
        /// <param name="ti_console_type_id">ti_console_type_id</param>
        public virtual int[] SvcInsertTitleVersions(ISpilConnectionManager scm, SqlInt32 i_title_id, SqlInt32 i_base_version, SqlInt32 i_new_version, SqlInt32 i_version_flag, SqlByte ti_console_type_id) {
            SqlParameter[] callParameters = new SqlParameter[5];
            // pack all parameters into Sql parameters array
            callParameters[0] = new SqlParameter();
            callParameters[0].ParameterName = "@i_title_id";
            callParameters[0].IsNullable = true;
            callParameters[0].SqlDbType = SqlDbType.Int;
            callParameters[0].Direction = ParameterDirection.Input;
            callParameters[0].Value = i_title_id;
            callParameters[1] = new SqlParameter();
            callParameters[1].ParameterName = "@i_base_version";
            callParameters[1].IsNullable = true;
            callParameters[1].SqlDbType = SqlDbType.Int;
            callParameters[1].Direction = ParameterDirection.Input;
            callParameters[1].Value = i_base_version;
            callParameters[2] = new SqlParameter();
            callParameters[2].ParameterName = "@i_new_version";
            callParameters[2].IsNullable = true;
            callParameters[2].SqlDbType = SqlDbType.Int;
            callParameters[2].Direction = ParameterDirection.Input;
            callParameters[2].Value = i_new_version;
            callParameters[3] = new SqlParameter();
            callParameters[3].ParameterName = "@i_version_flag";
            callParameters[3].IsNullable = true;
            callParameters[3].SqlDbType = SqlDbType.Int;
            callParameters[3].Direction = ParameterDirection.Input;
            callParameters[3].Value = i_version_flag;
            callParameters[4] = new SqlParameter();
            callParameters[4].ParameterName = "@ti_console_type_id";
            callParameters[4].IsNullable = true;
            callParameters[4].SqlDbType = SqlDbType.TinyInt;
            callParameters[4].Direction = ParameterDirection.Input;
            callParameters[4].Value = ti_console_type_id;
            int[] results;
            try {
                results = DataStoreComponent.ExecuteNonQueryOnAllPartitions(this.Context, scm, this.StoreName, this.ConnectionString, "p_svc_insert_title_versions", callParameters);
            }
            finally {
                // assign output parameter values
            }
            return results;
        }
        
        /// <summary>
        /// Execute stored procedure SvcServiceCreateOffer on all partitions
        /// </summary>
        /// <param name="scm">Connection Manager</param>
        /// <param name="i_service_id">i_service_id</param>
        /// <param name="bi_offer_id">bi_offer_id</param>
        public virtual int[] SvcServiceCreateOffer(ISpilConnectionManager scm, SqlInt32 i_service_id, SqlInt64 bi_offer_id) {
            SqlParameter[] callParameters = new SqlParameter[2];
            // pack all parameters into Sql parameters array
            callParameters[0] = new SqlParameter();
            callParameters[0].ParameterName = "@i_service_id";
            callParameters[0].IsNullable = true;
            callParameters[0].SqlDbType = SqlDbType.Int;
            callParameters[0].Direction = ParameterDirection.Input;
            callParameters[0].Value = i_service_id;
            callParameters[1] = new SqlParameter();
            callParameters[1].ParameterName = "@bi_offer_id";
            callParameters[1].IsNullable = true;
            callParameters[1].SqlDbType = SqlDbType.BigInt;
            callParameters[1].Direction = ParameterDirection.Input;
            callParameters[1].Value = bi_offer_id;
            int[] results;
            try {
                results = DataStoreComponent.ExecuteNonQueryOnAllPartitions(this.Context, scm, this.StoreName, this.ConnectionString, "p_svc_service_create_offer", callParameters);
            }
            finally {
                // assign output parameter values
            }
            return results;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\offerutil\offerutil\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__offerutil_4_none_12.4.56.0_none_ee3defb5a3a86d86
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__offerutil_4_no-public-key_12.4.56.0_x-ww_d3468d4a
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_offerutil_4
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__offerutil_4_no-public-key_12.4.56.0_x-ww_d3468d4a
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__offerutil_4_no-public-key_12.4.56.0_x-ww_d3468d4a.manifest
XP_MANIFEST_PATH=manifests\x86__offerutil_4_no-public-key_12.4.56.0_x-ww_d3468d4a.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__offerutil_4_no-public-key_12.4.56.0_x-ww_d3468d4a.cat
XP_CATALOG_PATH=manifests\x86__offerutil_4_no-public-key_12.4.56.0_x-ww_d3468d4a.cat
XP_PAYLOAD_PATH=x86__offerutil_4_no-public-key_12.4.56.0_x-ww_d3468d4a
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_offerutil_4,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\offerutil\offerutil\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__offerutil_4_none_12.4.56.0_none_ee3defb5a3a86d86
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__offerutil_4_no-public-key_12.4.56.0_x-ww_d3468d4a
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_offerutil_4
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__offerutil_4_no-public-key_12.4.56.0_x-ww_d3468d4a
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__offerutil_4_no-public-key_12.4.56.0_x-ww_d3468d4a.manifest
XP_MANIFEST_PATH=manifests\x86__offerutil_4_no-public-key_12.4.56.0_x-ww_d3468d4a.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__offerutil_4_no-public-key_12.4.56.0_x-ww_d3468d4a.cat
XP_CATALOG_PATH=manifests\x86__offerutil_4_no-public-key_12.4.56.0_x-ww_d3468d4a.cat
XP_PAYLOAD_PATH=x86__offerutil_4_no-public-key_12.4.56.0_x-ww_d3468d4a
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_offerutil_4,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\offerutil\offerutil\OfferManager.cs ===
//------------------------------------------------------------
// Copyright (c) Microsoft Corporation. All rights reserved.
//------------------------------------------------------------ 

using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Data.SqlTypes;
using System.Diagnostics;
using System.Drawing;
using System.Globalization;
using System.IO;
using System.Net;
using System.Runtime.InteropServices;
using System.Security.Cryptography.X509Certificates;
using System.ServiceProcess;
using System.Text;
using System.Threading;
using System.Web;
using System.Web.Services.Protocols;
using System.Xml;
using System.Xml.Serialization;
using Microsoft.Webstore.WstClient;
using Microsoft.Subscriptions.Data;
using xonline.common.billing;
using xonline.common.config;
using xonline.common.offer;
using xonline.common.offerutil;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.sql.webstore;
using xonline.common.xboxofferutil;


namespace xonline.common.offerutil
{
    public static class OfferManager
    {
        // this is a static utility class
        static OfferManager()
        {
            #region TargetHelperCodeInit
            // Init ServerName/ConnectString Helper Arrays
            TargetStrings[0] = "";
            TargetStrings[1] = ConfigUtil.UodbWebstoreApp;

            // Init Database TargetType Helper Arrays
            TargetTypes[0] = TargetType.unknown;
            TargetTypes[1] = TargetType.webstore;

            // Init Database Target names Helper Arrays
            TargetDBs[0] = TargetDB.unknown;
            TargetDBs[1] = TargetDB.uodb;
            #endregion

            imageFilePaths = new ArrayList();
            imageServerPaths = new Hashtable();
        }

        /// <summary>
        /// Target Databases to Prop.
        /// </summary>
        public enum TargetDB
        {
            unknown = 0x00,
            uodb = 0x01,
            all = 0xff   // important, bitwise!!!
        }

        #region TargetHelperCode
        public enum TargetType
        {
            unknown = 0x00,
            webstore = 0x01,
            sql = 0x02
        }

        const int maxTypes = 3;

        static string[] TargetStrings = new string[maxTypes];

        static TargetType[] TargetTypes = new TargetType[maxTypes];

        static TargetDB[] TargetDBs = new TargetDB[maxTypes];

        static ISpilConnectionManager GetConnectionManager(int tdbsindex)
        {
            ISpilConnectionManager spm = null;

            // Get which connection type we require, from our list, and create one
            switch (TargetTypes[tdbsindex])
            {
                case TargetType.webstore:
                    spm = new WebStoreConnectionManager();
                    break;
                case TargetType.sql:
                    spm = new SimpleConnectionManager((string)null);
                    break;
                default: // default to webstore, with default settings in the generated code
                    spm = new WebStoreConnectionManager();
                    break;
            }
            return spm;
        }

        static void ConfigureSvcOffer(SvcOffer so, int tdbsindex)
        {
            if (so != null)
            {
                // Get which string param we need to se, and do so
                switch (TargetTypes[tdbsindex])
                {
                    case TargetType.webstore:
                        so.StoreName = TargetStrings[tdbsindex];
                        break;
                    case TargetType.sql:
                        so.ConnectionString = TargetStrings[tdbsindex];
                        break;
                    default: // leave default settings in the generated code as is
                        break;
                }
            }
            return;
        }

        static String ContextToString(DataStoreContext ctx)
        {
            return ContextToString(ctx, "");
        }

        static String ContextToString(DataStoreContext ctx, string targetname)
        {
            if (ctx.Command == null)
                return (string)"No DataStoreContext.Command available for SqlParameter dump.";

            SqlParameter param = new SqlParameter();

            StringBuilder str = new StringBuilder();
            str.AppendFormat("dbo.{0} /*({1})*/", ctx.Command.CommandText, targetname);

            for (int j = 0; j < ctx.Command.Parameters.Count; j++)
            {
                param = (SqlParameter)ctx.Command.Parameters[j];

                if (param.Direction != ParameterDirection.ReturnValue)
                {
                    if (j > 0) // skip first one
                        str.Append(",");

                    if (((INullable)param.Value).IsNull)
                    {
                        str.AppendFormat(" {0}={1}", param.ParameterName, "null");
                    }
                    else
                    {
                        switch (param.SqlDbType)
                        {
                            case SqlDbType.Binary:
                            case SqlDbType.VarBinary:
                            case SqlDbType.Image:
                                str.AppendFormat(" {0}=0x{1}", param.ParameterName, ByteConvert.ToString((byte[])(SqlBinary)param.Value));
                                break;
                            case SqlDbType.Char:
                            case SqlDbType.DateTime:
                            case SqlDbType.NChar:
                            case SqlDbType.NText:
                            case SqlDbType.NVarChar:
                            case SqlDbType.SmallDateTime:
                            case SqlDbType.Text:
                            case SqlDbType.VarChar:
                                str.AppendFormat(" {0}='{1}'", param.ParameterName, param.Value);
                                break;
                            default:
                                str.AppendFormat(" {0}={1}", param.ParameterName, param.Value);
                                break;

                        }
                    }
                }
            }

            return str.ToString();
        }

        static void ErrorCheck(DataStoreContext ctx, string targetname, bool bAlreadyThrown)
        {
            // check for errors (only last execution of the SP has its retval easily exposed, unless we move away from the NonQuery version)
            uint hr = (uint)DataStoreComponent.GetReturnValue(ctx);
            if (HResult.Failed(hr) && !bAlreadyThrown)
            {
                string msg = ContextToString(ctx, targetname) + " failed with hr = 0x" + hr.ToString("x");
                throw new XRLException(hr, XEvent.Id.COMMON_CODE_144, msg);
            }

            Console.WriteLine();
            Console.WriteLine(ContextToString(ctx, targetname));
        }

        #endregion

        static TargetDB target = TargetDB.all; // not really thread-safe. but this class is only used in single-threaded LiveOffer utility

        /// <summary>
        /// The Target DataStore
        /// </summary>
        public static TargetDB Target
        {
            get
            {
                return target;
            }
            set
            {
                target = value;
            }
        }

        static bool overwriteDMPSettings = false; // not really thread-safe. but this class is only used in single-threaded LiveOffer utility

        /// <summary>
        /// The Target DataStore
        /// </summary>
        public static bool OverwriteDMPSettings
        {
            get
            {
                return overwriteDMPSettings;
            }
            set
            {
                overwriteDMPSettings = value;
            }
        }

        static bool useTransaction = true;

        /// <summary>
        /// The Target DataStore
        /// </summary>
        public static bool UseTransaction
        {
            get
            {
                return useTransaction;
            }
            set
            {
                useTransaction = value;
            }
        }


        // this arrayList stores the local names of images that were propped to Live
        static ArrayList imageFilePaths = null;

        public static string[] ImageFilePaths
        {
            get
            {
                string[] iFPs = new string[imageFilePaths.Count];
                imageFilePaths.CopyTo(iFPs);
                return iFPs;
            }
        }

        // this Hashtable stores what server paths images have been written to
        static Hashtable imageServerPaths = null;

        public static byte[] HexStringToByteArray(string s)
        {
            s = s.Trim().ToUpper();

            if (s[0] == '0' && s[1] == 'X')
                s = s.Substring(2);

            int numBytes = s.Length / 2;
            byte[] bytes = new byte[numBytes];

            for (int j = 0; j < numBytes; j++)
            {
                bytes[j] = Byte.Parse(s.Substring(j * 2, 2), NumberStyles.HexNumber);
            }

            return bytes;
        }

        public static string ByteArrayToHexString(byte[] bytes)
        {
            StringBuilder sb = new StringBuilder(bytes.Length * 2 + 1);

            for (int i = 0; i < bytes.Length; i++)
            {
                sb.Append(bytes[i].ToString("x2"));
            }

            return sb.ToString();
        }

        public static ulong ParseUlong(string s)
        {
            s = s.Trim().ToUpper();

            ulong u;

            if (s[0] == '0' && s[1] == 'X')
                u = UInt64.Parse(s.Substring(2), NumberStyles.HexNumber);
            else
            {
                try
                {
                    u = (ulong)Int64.Parse(s);
                }
                catch (FormatException)
                {
                    u = UInt64.Parse(s, NumberStyles.HexNumber);
                }
            }

            return u;
        }

        public static uint ParseUint(string s)
        {
            s = s.Trim().ToUpper();

            uint i;

            if (s[0] == '0' && s[1] == 'X')
                i = UInt32.Parse(s.Substring(2), NumberStyles.HexNumber);
            else
            {
                try
                {
                    i = (uint)Int32.Parse(s);
                }
                catch (FormatException)
                {
                    i = UInt32.Parse(s, NumberStyles.HexNumber);
                }
            }

            return i;
        }

        static uint[] ParseUints(ArrayList value)
        {
            var result = new uint[value.Count];
            for (int i = 0; i < value.Count; i++)
            {
                result[i] = ParseUint((string)value[i]);
            }
            return result;
        }

        public static int MapConsoleType(ConsoleType consoleType)
        {
            switch (consoleType)
            {
                case ConsoleType.Xbox360:
                    return (int)ConsoleTypeEnum.Xenon;
                case ConsoleType.PC:
                    return (int)ConsoleTypeEnum.PC;
            }

            throw new Exception("invalid content offerType: " + consoleType);
        }

        public static int MapRelationType(OfferRelationType relationType)
        {
            switch (relationType)
            {
                case OfferRelationType.Renewal:
                    return (int)OfferingRelationTypeEnum.Renewal;

                case OfferRelationType.Trial:
                    return (int)OfferingRelationTypeEnum.Trial;

                case OfferRelationType.Xbox1XenonSubstitution:
                    return (int)OfferingRelationTypeEnum.Xbox1ToXenon;
            }

            throw new Exception("invalid relation type: " + relationType);
        }

        public static int MapConvertMode(OfferConvertMode convertMode)
        {
            switch (convertMode)
            {
                case OfferConvertMode.Convert:
                    return (int)OfferingConvertMode.Convert;

                case OfferConvertMode.Renew:
                    return (int)OfferingConvertMode.Renew;
            }

            throw new Exception("invalid convert mode: " + convertMode);
        }

        public static int MapLiveTier(LiveTier liveTier)
        {
            switch (liveTier)
            {
                case LiveTier.NewUser:
                    return (int)TierEnum.NewUser;

                case LiveTier.Silver:
                    return (int)TierEnum.Silver;

                case LiveTier.Gold:
                    return (int)TierEnum.Gold;

                case LiveTier.FamilyGold:
                    return (int)TierEnum.FamilyGold;
            }

            throw new Exception("invalid live tier: " + liveTier);
        }

        public static int MapGenre(Genre genre)
        {
            switch (genre)
            {
                case Genre.Action:
                    return 102000000;

                case Genre.Adventure:
                    return 103000000;

                case Genre.Compilations:
                    return 104000000;

                case Genre.Family:
                    return 105000000;

                case Genre.Fighting:
                    return 106000000;

                case Genre.Music:
                    return 108000000;

                case Genre.Platform:
                    return 109000000;

                case Genre.Racing:
                    return 110000000;

                case Genre.RolePlaying:
                    return 111000000;

                case Genre.Shooter:
                    return 112000000;

                case Genre.Simulation:
                    return 113000000;

                case Genre.Sports:
                    return 114000000;

                case Genre.Strategy:
                    return 115000000;

                case Genre.XArcadeAction:
                    return 116010000;

                case Genre.XArcadeCardAndBoard:
                    return 116020000;

                case Genre.XArcadeCoinOpClassics:
                    return 116030000;

                case Genre.XArcadePuzzleAndWord:
                    return 116040000;

                case Genre.XArcadeSocialSports:
                    return 116050000;

                case Genre.XArcadeStrategyAndSims:
                    return 116060000;

                case Genre.XArcadeConsoleClassics:
                    return 116070000;

                case Genre.XArcadeGameShows:
                    return 116080000;

                case Genre.XArcadeFamilyGames:
                    return 116090000;

                case Genre.XArcadeTrivia:
                    return 116100000;
            }

            throw new Exception("invalid genre: " + genre);
        }

        public static byte MapSubscriptionFrequency(SubscriptionFrequency frequency)
        {
            switch (frequency)
            {
                case SubscriptionFrequency.OneTimeCharge:
                    return (byte)OfferingFrequencyEnum.OneTimeCharge;

                case SubscriptionFrequency.Monthly:
                    return (byte)OfferingFrequencyEnum.Monthly;

                case SubscriptionFrequency.Quarterly:
                    return (byte)OfferingFrequencyEnum.Quarterly;

                case SubscriptionFrequency.BiAnnually:
                    return (byte)OfferingFrequencyEnum.BiAnnually;

                case SubscriptionFrequency.Annually:
                    return (byte)OfferingFrequencyEnum.Annually;
            }

            throw new Exception("invalid subscriptionFrequency: " + frequency);
        }

        public static byte MapTaxType(TaxType taxType)
        {
            switch (taxType)
            {
                case TaxType.NoTax:
                    return (byte)TaxTypeEnum.NoTax;

                case TaxType.DefaultTax:
                    return (byte)TaxTypeEnum.Default;

                case TaxType.GST:
                    return (byte)TaxTypeEnum.GST;

                case TaxType.VAT:
                    return (byte)TaxTypeEnum.VAT;

                case TaxType.TaxNotApplicable:
                    return (byte)TaxTypeEnum.TaxNotApplicable;
            }

            throw new Exception("invalid taxType: " + taxType);
        }

        public static bool VetOfferRegionCultures(ulong offerID, OfferRegionInfoCollection oric, OfferCultureDetailsCollection ocdc)
        {
            bool bFound = false, bRet = true;

            // Ensure that we have all Cultures for each Region's Country
            foreach (OfferRegionInfo info in oric)
            {
                ArrayList regionCultures = Culture.GetRegionCultures(info.countryID);

                // Make sure we have all needed OfferCultureDetailsCollection objects
                foreach (CultureData c in regionCultures)
                {
                    bFound = false;
                    foreach (OfferCultureDetails detail in ocdc)
                    {
                        if ((int)detail.culture == c.CultureID)
                        {
                            bFound = true;
                        }
                    }

                    if (!bFound)
                    {
                        bRet = false;
                        throw new Exception("invalid Culture Collection in OfferID: " + offerID.ToString("X") + " - missing CultureID: " + c.CultureID + " for CountryID: " + c.CountryID);
                    }
                }
            }

            return bRet;
        }

        static void PropOfferCultureDetailsCollection(OfferCultureDetailsCollection c, ulong offerID, uint[] titleIDs)
        {
            foreach (OfferCultureDetails details in c)
            {
                int culture = (int)details.culture;
                string name = details.name;
                string sellText = details.sellText;

                p_svc_insert_offer_culture_details(offerID, culture, name, sellText);

                string localFileName = details.imageFilePath;
                if (localFileName != null && localFileName != string.Empty)
                {
                    foreach (uint titleID in titleIDs)
                    {
                        string storageFileName = string.Format("//global/t:{0}/marketplace/{1}/{2}",
                            titleID.ToString("x"), 0, offerID.ToString("x"));

                        WriteFileToStorage(localFileName, storageFileName, titleID);
                    }
                }
            }
        }


        public static void PropOfferRegionInfoCollection(OfferRegionInfoCollection c, ulong offerID,
            bool autoXboxToken)
        {
            bool hasSCSPaymentTypes = false; // PS# 117737 - LiveOffer must support propping SCS data (campaignID) for content offers

            PropOfferRegionInfoCollection(c, offerID, autoXboxToken, true, out hasSCSPaymentTypes);
        }
        public static void PropOfferRegionInfoCollection(OfferRegionInfoCollection c, ulong offerID,
            bool autoXboxToken, bool allowWholesalePaymentTypes, out bool hasSCSPaymentTypes)
        {
            hasSCSPaymentTypes = false; // reset

            foreach (OfferRegionInfo region in c)
            {
                byte countryID = region.countryID;
                int tierRequired = MapLiveTier(region.liveTier);
                DateTime startDate = region.startDate;
                DateTime endDate = region.endDate;

                int paymentType;
                string boid;
                int priceWhole;
                int priceFractional;
                uint specificOfferDetails;

                if (region.__paymentTypePoints != null)
                {
                    paymentType = (int)PaymentTypeEnum.Points;
                    boid = (region.paymentTypePoints.boid == null) ? string.Empty : region.paymentTypePoints.boid;
                    priceWhole = (int)region.paymentTypePoints.priceInPoints;
                    priceFractional = 0;
                    specificOfferDetails = 0;

                    p_svc_insert_offer_regions_xenon(offerID, countryID, tierRequired, paymentType, startDate,
                        endDate, boid, priceWhole, priceFractional, specificOfferDetails);
                }

                // Fix for Bug 39226 - Offergap/LiveOffer must always set tokens to be allowed for offers
                if (region.paymentTypeXboxToken || autoXboxToken)
                {
                    paymentType = (int)PaymentTypeEnum.Token;
                    boid = string.Empty;
                    priceWhole = 0;
                    priceFractional = 0;
                    specificOfferDetails = 0;

                    p_svc_insert_offer_regions_xenon(offerID, countryID, tierRequired, paymentType, startDate,
                        endDate, boid, priceWhole, priceFractional, specificOfferDetails);
                }

                if (region.__paymentTypeSCG != null)
                {
                    ValidateBoidValue(region.paymentTypeSCG.boid, "paymentTypeSCG");
                    hasSCSPaymentTypes = true;
                    paymentType = (int)PaymentTypeEnum.CreditCard;
                    boid = (region.paymentTypeSCG.boid == null) ? string.Empty : region.paymentTypeSCG.boid;
                    priceWhole = (int)region.paymentTypeSCG.priceWhole;
                    priceFractional = (int)region.paymentTypeSCG.priceFractional;

                    byte taxType = MapTaxType(region.paymentTypeSCG.taxType);
                    specificOfferDetails = Details.BuildSpecificOfferDetails(taxType, false);

                    p_svc_insert_offer_regions_xenon(offerID, countryID, tierRequired, paymentType, startDate,
                        endDate, boid, priceWhole, priceFractional, specificOfferDetails);
                }

                if (region.__paymentTypeSCGToken != null)
                {
                    ValidateBoidValue(region.paymentTypeSCGToken.boid, "paymentTypeSCGToken");
                    hasSCSPaymentTypes = true;
                    paymentType = (int)PaymentTypeEnum.Token;
                    boid = (region.paymentTypeSCGToken.boid == null) ? string.Empty : region.paymentTypeSCGToken.boid;
                    priceWhole = 0;
                    priceFractional = 0;
                    specificOfferDetails = 0;

                    p_svc_insert_offer_regions_xenon(offerID, countryID, tierRequired, paymentType, startDate,
                        endDate, boid, priceWhole, priceFractional, specificOfferDetails);
                }

                if (region.__paymentTypeWholesaleCollection != null &&
                    region.__paymentTypeWholesaleCollection.Count > 0)
                {
                    if (!allowWholesalePaymentTypes)
                    {
                        throw new ArgumentException("Wholesale PaymentType not allowed for this Offer-Type.");
                    }

                    Dictionary<string, bool> _wholesalePaymentProvider = new Dictionary<string, bool>();
                    foreach (PaymentTypeWholesale paymentTypeWholesale in region.__paymentTypeWholesaleCollection)
                    {
                        string partnerName = paymentTypeWholesale.wholesalePartner;
                        if (_wholesalePaymentProvider.ContainsKey(partnerName.ToLower()))
                        {
                            throw new Exception("A duplicate wholesale payment type was found for wholesale provider " + partnerName + ".");
                        }
                        _wholesalePaymentProvider.Add(partnerName.ToLower(), true);


                        // Force that only CHINATELCOM Wireline is supported.  Later, when more providers 
                        // are added, this line will most likely turn into a database query.
                        if (partnerName.ToLower() != "CHINATELCOM Wireline".ToLower())
                        {
                            throw new Exception("Ignoring unknown wholesale payment type partner \"" + paymentTypeWholesale.wholesalePartner + "\".");
                        }
                        ValidateBoidValue(paymentTypeWholesale.boid, "paymentTypeWholesale");
                        paymentType = (int)PaymentTypeEnum.Wholesale;
                        boid = (paymentTypeWholesale.boid == null) ? string.Empty : paymentTypeWholesale.boid;
                        priceWhole = (int)paymentTypeWholesale.priceWhole;
                        priceFractional = (int)paymentTypeWholesale.priceFractional;
                        specificOfferDetails = 0;

                        p_svc_insert_offer_regions_xenon(offerID, countryID, tierRequired, paymentType, startDate,
                            endDate, boid, priceWhole, priceFractional, specificOfferDetails);
                    }
                }
            }
        }
        /// <summary>
        /// Validates boid value and throws an exception if it is not a guid.
        /// </summary>
        /// <param name="value">value of the string to validate</param>
        /// <param name="section">section name</param>
        /// <exception cref="ArgumentException"></exception>
        static void ValidateBoidValue(string value, string section)
        {
            if (!string.IsNullOrEmpty(value))
            {
                if (!OfferUtil.IsGUID(value))
                {
                    throw new ArgumentException(string.Format("Billing Offer Id {0} within {1} must either be an emptystring/Guid", value, section));
                }
            }
        }
        public static void PropOfferPrivilegeInfo(OfferPrivilegeInfo opi, ulong offerID)
        {
            if (opi.offerPrivilegeGrantCollection.Count > 0)
            {
                OfferPrivilegeGrants grants = new OfferPrivilegeGrants();
                foreach (uint p in opi.offerPrivilegeGrantCollection) grants[(int)p] = true;
                grants.Save(offerID);
            }

            if (opi.offerPrivilegeRestrictionCollection.Count > 0)
            {
                OfferPrivilegeRestrictions restrictions = new OfferPrivilegeRestrictions();
                foreach (uint p in opi.offerPrivilegeRestrictionCollection) restrictions[(int)p] = true;
                restrictions.Save(offerID);
            }
        }

        public static void PropOfferBasicInfo(OfferBasicInfo info, int offerType, uint policyFlags,
            uint licenseBits, byte[] contentID, ulong previewOfferID, bool autoXboxToken)
        {
            bool hasSCSPaymentTypes = false; // PS# 117737 - LiveOffer must support propping SCS data (campaignID) for content offers

            PropOfferBasicInfo(info, offerType, policyFlags, licenseBits, contentID, previewOfferID,
                                autoXboxToken, true, out hasSCSPaymentTypes);
        }

        public static void PropOfferBasicInfo(OfferBasicInfo info, int offerType, uint policyFlags,
            uint licenseBits, byte[] contentID, ulong previewOfferID, bool autoXboxToken,
            bool allowWholesalePaymentTypes, out bool hasSCSPaymentTypes)
        {
            uint titleID = ParseUint(info.primaryTitleID);
            ulong offerID = ParseUlong(info.offerID);
            uint bitFilter = ParseUint(info.bitFilter);

            string friendlyName = info.friendlyName;
            ConsoleTypeEnum consoleType = (ConsoleTypeEnum)MapConsoleType(info.consoleType);

            if (consoleType == ConsoleTypeEnum.PC &&
               info.offerEnumerationType != OfferEnumerationType.NeverEnumerate
              )
            {
                // PC Arcade offers must have their offerEnumerationType set to NeverEnumerate for UODB
                policyFlags |= Offer.DO_NOT_ENUMERATE;
            }
            else
            {
                switch (info.offerEnumerationType)
                {
                    case OfferEnumerationType.AlwaysEnumerateExceptInPartnerNetDash:
                        policyFlags |= Offer.HIDE_FROM_PARTNERNET_DASH;
                        break;

                    case OfferEnumerationType.NeverEnumerate:
                        policyFlags |= Offer.DO_NOT_ENUMERATE;
                        break;

                    case OfferEnumerationType.AlwaysEnumerate:
                        // no flags are set
                        break;
                }
            }

            if (info.__requiresGeofencingSpecified == true && info.requiresGeofencing == true)
                policyFlags |= Offer.REQUIRES_GEOFENCING;

            p_svc_insert_offers(titleID, offerID, bitFilter, offerType, friendlyName, consoleType, policyFlags,
                licenseBits, contentID, previewOfferID);

            foreach (string s in info.associatedTitleIDCollection)
            {
                uint associatedTitleID = ParseUint(s);
                p_svc_insert_title_associated_offer(associatedTitleID, offerID);
            }

            VetOfferRegionCultures(offerID, info.offerRegionInfoCollection, info.offerCultureDetailsCollection);

            PropOfferCultureDetailsCollection(info.offerCultureDetailsCollection, offerID, new[] { titleID });

            // Since regions contain billing info, clean out existing before insert new...
            p_svc_delete_offer_regions_xbox((long)offerID);

            PropOfferRegionInfoCollection(info.offerRegionInfoCollection, offerID, autoXboxToken, allowWholesalePaymentTypes, out hasSCSPaymentTypes);
        }

        public static void ExpireOfferBasicInfo(OfferBasicInfo info, DateTime expirationDateTime)
        {
            if (info == null)
                throw new ArgumentException("Null OfferBasicInfo passed into ExpireOfferBasicInfo!", "info");

            ulong offerID = ParseUlong(info.offerID);

            foreach (OfferRegionInfo offerRegionInfo in info.offerRegionInfoCollection)
            {
                offerRegionInfo.endDate = expirationDateTime;
            }

            // Since regions contain billing info, clean out existing before insert new...
            p_svc_delete_offer_regions_xbox((long)offerID);

            PropOfferRegionInfoCollection(info.offerRegionInfoCollection, offerID, false);
        }

        public static void ExpireOfferFromCatalogDB(Dictionary<string, Content> contentDictionary, ContentOffer contentOffer, DateTime expirationDateTime)
        {
            Content content = null;
            contentDictionary.TryGetValue(contentOffer.offerContentInfo.contentID, out content);

            if (content == null)
            {
                Console.WriteLine("Error expiring offers to CatalogDB. Cannot find Content with contentId = '{0}' as referenced by offer with offerId = '{1}'.",
                    contentOffer.offerContentInfo.contentID,
                    contentOffer.offerBasicInfo.offerID);
            }

            //Resetting the OfferInfo EndDateTimes to a new expired EndDateTime
            foreach (OfferRegionInfo offerRegionInfo in contentOffer.offerBasicInfo.offerRegionInfoCollection)
            {
                offerRegionInfo.endDate = expirationDateTime;
            }

        }

        public static void PropSKUDetails(SKUDetails details)
        {
            // TODO: add checks here to make sure we're not overwriting anything previously configured
            int skuType;
            if (details.skuType == SKUType.Promo)
                skuType = (int)OfferingSKUType.PromotionalSKU;
            else if (details.skuType == SKUType.Revenue)
                skuType = (int)OfferingSKUType.RevenueSKU;
            else
                throw new Exception("invalid sku type: " + details.skuType);

            p_svc_insert_offer_sku(details.skuID, skuType, details.sku, details.friendlyName);
        }

        public static void PropCampaignDetails(CampaignDetails details)
        {
            // TODO: add checks here to make sure we're not overwriting anything previously configured

            p_svc_insert_offer_campaign(details.campaignID, details.friendlyName);
        }

        public static void PropAcquisitionType(AcquisitionType type)
        {
            // TODO: add checks here to make sure we're not overwriting anything previously configured

            p_svc_insert_offer_acquisition_type((int)type.acquisitionTypeID, type.friendlyName);
        }

        public static void PropDMPInfo(OfferDMPInfo info, ulong offerID, int offerType)
        {
            PropSKUDetails(info.sku);
            int revenueSkuID = (int)info.sku.skuID;

            int categoryID = offerType;

            PropCampaignDetails(info.campaign);
            int campaignID = (int)info.campaign.campaignID;

            p_svc_insert_dmp_offer_details(offerID, revenueSkuID, categoryID, campaignID);
        }

        public static void PropPointsBundleOffer(PointsBundleOffer o)
        {
            int offerType = (int)OfferingTypeEnum.PointsBundle;

            uint policyFlags = 0;
            uint licenseBits = 0;
            byte[] contentID = null;

            PropOfferBasicInfo(o.offerBasicInfo, offerType, policyFlags, licenseBits, contentID, 0, false);

            PropCampaignDetails(o.campaign);
            int campaignID = (int)o.campaign.campaignID;

            ulong offerID = ParseUlong(o.offerBasicInfo.offerID);
            p_svc_insert_offer_scs_item_details(offerID, campaignID);
        }

        public static void PropGamertagChangeOffer(GamertagChangeOffer o)
        {
            int offerType = (int)OfferingTypeEnum.GamertagChange;

            uint policyFlags = 0;
            uint licenseBits = 0;
            byte[] contentID = null;

            PropOfferBasicInfo(o.offerBasicInfo, offerType, policyFlags, licenseBits, contentID, 0, true);

            ulong offerID = ParseUlong(o.offerBasicInfo.offerID);
            PropDMPInfo(o.offerDMPInfo, offerID, offerType);
        }

        public static void PropGameplayOffer(GameplayOffer o)
        {
            int offerType = (int)OfferingTypeEnum.Gameplay;
            ulong offerID = ParseUlong(o.offerBasicInfo.offerID);

            uint policyFlags = 0;
            uint licenseBits = 0;
            byte[] contentID = null;

            PropOfferBasicInfo(o.offerBasicInfo, offerType, policyFlags, licenseBits, contentID, 0, true);

            // Instead of simply granting multiplayer privileges, we now require privileges to
            // be explicitly declared in the xml for gameplay offers.
            PropOfferPrivilegeInfo(o.offerPrivilegeInfo, offerID);

            p_svc_insert_offer_duration(offerID, (int)o.durationInSeconds);

            // Ensure that Fusion and Xbox1 can take advantage of 48-hour offers
            p_svc_insert_offer_services_xbox(offerID, 1);
            p_svc_insert_offer_services_xbox(offerID, 2);
            p_svc_insert_offer_services_xbox(offerID, 9999);

            SubscriptionTypeInfo subscriptionTypeInfo = new SubscriptionTypeInfo();
            subscriptionTypeInfo.subscriptionType = 1; // xbox-live
            subscriptionTypeInfo.tierProvided = 0;
            subscriptionTypeInfo.isBase = false;

            p_svc_insert_subscription_info(subscriptionTypeInfo, offerID);
        }

        public static void PropReward(Reward r)
        {
            int rewardID = (int)r.rewardID;
            int pointsRewarded = (int)r.pointsRewarded;
            int rewardLifetime = 0; // reward lifetime comes from the dmp promo sku

            PropSKUDetails(r.sku);
            int promoSKU = (int)r.sku.skuID;

            PropCampaignDetails(r.campaign);
            int campaignID = (int)r.campaign.campaignID;

            PropAcquisitionType(r.acquisitionType);
            int acquisitionType = (int)r.acquisitionType.acquisitionTypeID;

            p_svc_insert_dmp_reward(rewardID, pointsRewarded, rewardLifetime, promoSKU,
                campaignID, acquisitionType);

            foreach (RewardCultureDetails details in r.rewardCultureDetailsCollection)
            {
                int cultureID = (int)details.culture;
                string acquisitionTitle = details.acquisitionTitle;

                p_svc_insert_dmp_reward_culture_details(rewardID, cultureID, acquisitionTitle);
            }
        }

        public static void PropPromotionalPointsOffer(PromotionalPointsOffer o)
        {
            int offerType = (int)OfferingTypeEnum.PromoPoints;

            uint policyFlags = 0;
            uint licenseBits = 0;
            byte[] contentID = null;

            PropOfferBasicInfo(o.offerBasicInfo, offerType, policyFlags, licenseBits, contentID, 0, true);

            ulong offerID = ParseUlong(o.offerBasicInfo.offerID);

            p_svc_insert_offer_reward_details(offerID, (int)o.rewardID);
        }

        static void PropSubscriptionBasicInfo(SubscriptionBasicInfo info, int offerType)
        {
            uint[] titleIDs = ParseUints(info.titleIDCollection);
            ulong offerID = ParseUlong(info.offerID);
            uint bitFilter = ParseUint(info.bitFilter);

            string friendlyName = info.friendlyName;
            ConsoleTypeEnum consoleType = (ConsoleTypeEnum)MapConsoleType(info.consoleType);

            string billingComponentID = info.billingComponentID;

            uint policyFlags = Offer.PER_USER_RIGHTS;
            switch (info.offerEnumerationType)
            {
                case OfferEnumerationType.AlwaysEnumerateExceptInPartnerNetDash:
                    policyFlags |= Offer.HIDE_FROM_PARTNERNET_DASH;
                    break;

                case OfferEnumerationType.NeverEnumerate:
                    policyFlags |= Offer.DO_NOT_ENUMERATE;
                    break;

                case OfferEnumerationType.AlwaysEnumerate:
                    // no flags are set
                    break;
            }

            byte frequency = MapSubscriptionFrequency(info.subscriptionFrequency);
            byte duration = info.duration;
            byte freeCycles = 0; // legacy

            bool cancelable = false; // default
            if (info.__cancelableSpecified)
            {
                cancelable = info.cancelable;
            }

            uint globalOfferDetails = Details.BuildGlobalOfferDetails(frequency, duration, freeCycles);

            p_svc_insert_subscriptions_multi_title(titleIDs, offerID, bitFilter, cancelable, offerType, friendlyName, billingComponentID,
                policyFlags, globalOfferDetails, consoleType);

            PropOfferPrivilegeInfo(info.offerPrivilegeInfo, offerID);

            //Note the we do not call VetOfferRegionCultures before commiting the offers in UODB.  
            //That's because the MIX API's call this class when they create a new subscription, and 
            // the MIX API's use locales instead of the cultures.  In most cases the locale id and the 
            // culture id are the same, but they differ for en-IN, en-HK and en-SG. 
            //The UODB sproc p_svc_insert_offer_culture_details will set these locales to the corresponding 
            // UODB cultured id's.  
            PropOfferCultureDetailsCollection(info.offerCultureDetailsCollection, offerID, titleIDs);

            PropOfferRegionInfoCollection(info.offerRegionInfoCollection, offerID, false);
        }

        public static void ExpireSubscriptionBasicInfo(SubscriptionBasicInfo info, DateTime expirationDateTime)
        {
            if (info == null)
                throw new ArgumentException("Null SubscriptionBasicInfo structure passed into ExpireSubscriptionBasicInfo.", "info");

            ulong offerID = ParseUlong(info.offerID);

            foreach (OfferRegionInfo offerRegionInfo in info.offerRegionInfoCollection)
            {
                offerRegionInfo.endDate = expirationDateTime;
            }

            PropOfferRegionInfoCollection(info.offerRegionInfoCollection, offerID, false);
        }

        public static void PropLiveSubscription(LiveSubscription s)
        {
            int offerType = s.isTrial ? (int)OfferingTypeEnum.Trial : (int)OfferingTypeEnum.Subscription;
            ulong offerID = ParseUlong(s.subscriptionBasicInfo.offerID);

            SubscriptionTypeInfo subscriptionTypeInfo;

            // if they provided subscriptionTypeInfo,  then we use it
            // if they provided a liveTier then make sure it  matches

            if (s.__subscriptionTypeInfo != null)
            {
                subscriptionTypeInfo = s.__subscriptionTypeInfo;

                if (s.__liveTierProvidedSpecified)
                {
                    if (subscriptionTypeInfo.tierProvided != s.liveTierProvided)
                    {
                        Console.WriteLine("OfferManger.PropLiveSubscription() error: value of <liveTierProvided> does not match value in <SubscriptionTypeInfo>");
                        throw new Exception("live tier mismatch");
                    }
                }
            }

            // if they didn't provide subscriptionTypeInfo,  then  we
            // create one and fill it in  with  some  default  values

            else
            {
                Console.WriteLine("OfferManger.PropLiveSubscription() warning: no subscription type info provided, using defaults");

                subscriptionTypeInfo = new SubscriptionTypeInfo();
                subscriptionTypeInfo.subscriptionType = 1;
                subscriptionTypeInfo.isBase = true;

                if (s.__liveTierProvidedSpecified)
                    subscriptionTypeInfo.tierProvided = s.liveTierProvided;
                else
                {
                    subscriptionTypeInfo.tierProvided = LiveTier.Gold;
                }
            }

            p_svc_insert_subscription_info(subscriptionTypeInfo, offerID);
            PropSubscriptionBasicInfo(s.subscriptionBasicInfo, offerType);

            // TODO - remove this once we no longer use base offer
            uint tierID = (uint)MapLiveTier(subscriptionTypeInfo.tierProvided);
            p_svc_insert_base_offer(offerID, tierID);

            foreach (OfferSubscriptionRewardInfo info in s.offerSubscriptionRewardInfoCollection)
            {
                ushort countryID = info.countryID;
                int subscriptionTier = MapLiveTier(info.userTier);
                int rewardID = (int)info.rewardID;
                DateTime startDate = info.startDate;
                DateTime endDate = info.endDate;

                p_svc_insert_offer_subscription_reward(offerID, countryID, subscriptionTier, rewardID,
                    startDate, endDate);
            }

            foreach (LiveSubscriptionRelation relation in s.offerRelationInfoCollection)
            {
                ulong offerIDFrom = ParseUlong(relation.offerIDFrom);
                ulong OfferIDTo = offerID;
                int relationType = MapRelationType(relation.relationType);
                int convertMode = MapConvertMode(relation.convertMode);

                p_svc_insert_offer_relations(offerIDFrom, OfferIDTo, relationType, convertMode);
            }

            // if this subscription should allow xbox1play, we need to populate t_offer_services
            // for the offer with all of the xbox1 services.  if this subscription should *not*
            // allow xbox1 play, nothing more needs to be done--services/privileges for xenon
            // will come from the subscription tier
            if (s.allowsXbox1Play)
            {
                p_svc_insert_offer_services_xbox(offerID, 1);
                p_svc_insert_offer_services_xbox(offerID, 2);
                p_svc_insert_offer_services_xbox(offerID, 9999);
            }
        }

        public static void PropGameSubscription(GameSubscription s)
        {
            ulong offerID = ParseUlong(s.subscriptionBasicInfo.offerID);
            int offerType = (int)OfferingTypeEnum.Subscription;

            SubscriptionTypeInfo subscriptionTypeInfo;

            if (s.__subscriptionTypeInfo != null)
                subscriptionTypeInfo = s.__subscriptionTypeInfo;
            else
            {
                Console.WriteLine("OfferManger.PropLiveSubscription() warning: no subscription type info provided, using defaults");

                subscriptionTypeInfo = new SubscriptionTypeInfo();
                subscriptionTypeInfo.subscriptionType = 1;
                subscriptionTypeInfo.tierProvided = LiveTier.Gold;
            }

            p_svc_insert_subscription_info(subscriptionTypeInfo, offerID);
            PropSubscriptionBasicInfo(s.subscriptionBasicInfo, offerType);

            if (s.__liveServiceProvidedSpecified)
            {
                uint serviceID = s.liveServiceProvided;
                p_svc_service_create_offer(offerID, serviceID);
            }

            foreach (LiveSubscriptionRelation relation in s.offerRelationInfoCollection)
            {
                ulong offerIDFrom = ParseUlong(relation.offerIDFrom);
                ulong OfferIDTo = offerID;
                int relationType = MapRelationType(relation.relationType);
                int convertMode = MapConvertMode(relation.convertMode);

                p_svc_insert_offer_relations(offerIDFrom, OfferIDTo, relationType, convertMode);
            }
        }

        public static void PropPcAccountCreationOffer(PcAccountCreationOffer s)
        {
            ulong offerID = ParseUlong(s.offerID);
            uint titleID = ParseUint(s.titleID);

            p_svc_insert_offers(
                titleID, offerID, 0 /* bitFilter */, (int)OfferingTypeEnum.PcAccountCreation,
                s.friendlyName, ConsoleTypeEnum.PC, 0 /* policyFlags */, 0 /* licenseBits */,
                null /* contentID */, 0 /* previewOfferID */);
        }

        public static int PropLiveOffer(LiveOffer lo)
        {
            int count = 0;

            TransactionScope ts = (useTransaction ? TransactionScope.DTC : TransactionScope.None);
            IsolationLevel il = IsolationLevel.ReadCommitted;

            #region Prop to UODB
            foreach (Reward r in lo.rewardCollection)
            {
                using (TransactionWrapper myTrans = new TransactionWrapper(ts, il))
                {
                    PropReward(r);
                    if (useTransaction)
                        myTrans.SetComplete();
                }
            }

            foreach (PromotionalPointsOffer o in lo.promotionalPointsOfferCollection)
            {
                using (TransactionWrapper myTrans = new TransactionWrapper(ts, il))
                {
                    PropPromotionalPointsOffer(o);
                    count++;
                    if (useTransaction)
                        myTrans.SetComplete();
                }
            }

            foreach (PointsBundleOffer o in lo.pointsBundleOfferCollection)
            {
                using (TransactionWrapper myTrans = new TransactionWrapper(ts, il))
                {
                    PropPointsBundleOffer(o);
                    count++;
                    if (useTransaction)
                        myTrans.SetComplete();
                }
            }

            foreach (GamertagChangeOffer o in lo.gamertagChangeOfferCollection)
            {
                using (TransactionWrapper myTrans = new TransactionWrapper(ts, il))
                {
                    PropGamertagChangeOffer(o);
                    count++;
                    if (useTransaction)
                        myTrans.SetComplete();
                }
            }

            foreach (GameplayOffer o in lo.gameplayOfferCollection)
            {
                using (TransactionWrapper myTrans = new TransactionWrapper(ts, il))
                {
                    PropGameplayOffer(o);
                    count++;
                    if (useTransaction)
                        myTrans.SetComplete();
                }
            }

            foreach (LiveSubscription s in lo.liveSubscriptionCollection)
            {
                using (TransactionWrapper myTrans = new TransactionWrapper(ts, il))
                {
                    PropLiveSubscription(s);
                    count++;
                    if (useTransaction)
                        myTrans.SetComplete();
                }
            }

            foreach (GameSubscription s in lo.gameSubscriptionCollection)
            {
                using (TransactionWrapper myTrans = new TransactionWrapper(ts, il))
                {
                    PropGameSubscription(s);
                    count++;
                    if (useTransaction)
                        myTrans.SetComplete();
                }
            }

            foreach (PcAccountCreationOffer s in lo.pcAccountCreationOfferCollection)
            {
                using (TransactionWrapper myTrans = new TransactionWrapper(ts, il))
                {
                    PropPcAccountCreationOffer(s);
                    count++;
                    if (useTransaction)
                        myTrans.SetComplete();
                }
            }
            #endregion

            return count;
        }
        public static bool ValidateImageSizes(LiveOffer lo)
        {
            foreach (Title t in lo.titleCollection)
            {
                foreach (TitleCultureDetails details in t.titleCultureDetailsCollection)
                {
                    if (false == ValidateImage(details.imageFilePath)) return false;
                }
            }
            foreach (PromotionalPointsOffer o in lo.promotionalPointsOfferCollection)
            {
                foreach (OfferCultureDetails details in o.offerBasicInfo.offerCultureDetailsCollection)
                {
                    if (false == ValidateImage(details.imageFilePath)) return false;
                }
            }
            foreach (ContentOffer o in lo.contentOfferCollection)
            {
                foreach (OfferCultureDetails details in o.offerBasicInfo.offerCultureDetailsCollection)
                {
                    if (false == ValidateImage(details.imageFilePath)) return false;
                }
            }
            foreach (PointsBundleOffer o in lo.pointsBundleOfferCollection)
            {
                foreach (OfferCultureDetails details in o.offerBasicInfo.offerCultureDetailsCollection)
                {
                    if (false == ValidateImage(details.imageFilePath)) return false;
                }
            }
            foreach (GamertagChangeOffer o in lo.gamertagChangeOfferCollection)
            {
                foreach (OfferCultureDetails details in o.offerBasicInfo.offerCultureDetailsCollection)
                {
                    if (false == ValidateImage(details.imageFilePath)) return false;
                }
            }
            foreach (GameplayOffer o in lo.gameplayOfferCollection)
            {
                foreach (OfferCultureDetails details in o.offerBasicInfo.offerCultureDetailsCollection)
                {
                    if (false == ValidateImage(details.imageFilePath)) return false;
                }
            }
            foreach (LiveSubscription s in lo.liveSubscriptionCollection)
            {
                foreach (OfferCultureDetails details in s.subscriptionBasicInfo.offerCultureDetailsCollection)
                {
                    if (false == ValidateImage(details.imageFilePath)) return false;
                }
            }
            foreach (GameSubscription s in lo.gameSubscriptionCollection)
            {
                foreach (OfferCultureDetails details in s.subscriptionBasicInfo.offerCultureDetailsCollection)
                {
                    if (false == ValidateImage(details.imageFilePath)) return false;
                }
            }
            return true;
        }

        static bool ValidateImage(string localFileName)
        {
            try
            {
                if (Path.GetExtension(localFileName).ToLower().EndsWith("png"))
                {
                    if (!File.Exists(localFileName))
                    {
                        Console.WriteLine("OfferManager.ValidateImage() error: " + localFileName + " does not exist. Please check the filename and location.");
                        return false;
                    }

                    Bitmap b = new Bitmap(localFileName);
                    if (b.Width != 420 || b.Height != 95)
                    {
                        Console.WriteLine("OfferManager.ValidateImage() error: '" + localFileName + "' is not the required size.  420x95 required; " + b.Width + "x" + b.Height + " found.");
                        return false;
                    }
                }
                else
                {
                    Console.WriteLine("OfferManager.ValidateImage() error: " + localFileName + " is not a PNG file");
                    return false;
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine("OfferManager.ValidateImage() error: file '" + localFileName + "' threw exception '" + ex.Message + "'");
                return false;
            }

            return true;
        }

        static void p_svc_insert_offers(uint titleID, ulong offerID, uint bitFilter,
            int offerType, string friendlyName, ConsoleTypeEnum consoleType, uint policyFlags,
            uint licenseBits, byte[] contentID, ulong previewOfferID)
        {
            byte[] symKey = new byte[16];
            byte[] publicKey = new byte[284];

            p_svc_insert_offers_EX(titleID, offerID, 0, false, 0, 0, symKey, bitFilter,
                "", offerType, 0,
                new DateTime(2001, 11, 15), new DateTime(3001, 11, 15), friendlyName, publicKey,
                policyFlags, consoleType, licenseBits, contentID, previewOfferID);
        }


        static void p_svc_insert_dmp_offer_details(ulong offerID, int revenueSkuID, int categoryID,
            int campaignID)
        {
            // Iterate through all db targets
            for (int i = 0; i < maxTypes; i++)
            {
                // check if we are being asked to prop this particular db type
                if (0 != ((int)target & (int)TargetDBs[i]))
                {
                    using (ISpilConnectionManager scm = GetConnectionManager(i))
                    {
                        SvcOffer so = new SvcOffer(); bool bThrown = false;

                        ConfigureSvcOffer(so, i);

                        // NOTE: on the NonQuery calls, the results[] array contains the rowcount affected for each time the SP is exec'd,
                        //       and _not_ the return value from executing the SP
                        //
                        // Reference
                        // public virtual int[] SvcInsertDmpOfferDetails(
                        //  ISpilConnectionManager scm,
                        //  SqlInt64 bi_offer_id,
                        //  SqlInt32 i_revenue_sku_id,
                        //  SqlInt32 i_category_id,
                        //  SqlInt32 i_campaign_id)
                        //
                        try
                        {
                            int[] results = so.SvcInsertDmpOfferDetails(scm
                                      , (long)offerID
                                      , revenueSkuID
                                      , categoryID
                                      , campaignID
                                      );

                        }
                        catch { bThrown = true; throw; }
                        finally { ErrorCheck(so.Context, Convert.ToString(TargetDBs[i]), bThrown); }
                    }
                }
            }
        }

        public static void p_svc_insert_title_associated_offer(uint titleID, ulong offerID)
        {
            // Iterate through all db targets
            for (int i = 0; i < maxTypes; i++)
            {
                // check if we are being asked to prop this particular db type
                if (0 != ((int)target & (int)TargetDBs[i]))
                {
                    using (ISpilConnectionManager scm = GetConnectionManager(i))
                    {
                        SvcOffer so = new SvcOffer(); bool bThrown = false;

                        ConfigureSvcOffer(so, i);

                        // NOTE: on the NonQuery calls, the results[] array contains the rowcount affected for each time the SP is exec'd,
                        //       and _not_ the return value from executing the SP
                        //
                        // Reference
                        // public virtual int[] SvcInsertTitleAssociatedOffer(
                        //  ISpilConnectionManager scm,
                        //  SqlInt32 i_title_id,
                        //  SqlInt64 bi_offer_id)
                        //
                        try
                        {
                            int[] results = so.SvcInsertTitleAssociatedOffer(scm
                                , (int)titleID
                                , (long)offerID
                                );

                        }
                        catch { bThrown = true; throw; }
                        finally { ErrorCheck(so.Context, Convert.ToString(TargetDBs[i]), bThrown); }
                    }
                }
            }
        }

        public static void p_svc_insert_offer_culture_details(ulong offerID, int culture, string name,
            string sellText)
        {
            // Iterate through all db targets
            for (int i = 0; i < maxTypes; i++)
            {
                // check if we are being asked to prop this particular db type
                if (0 != ((int)target & (int)TargetDBs[i]))
                {
                    using (ISpilConnectionManager scm = GetConnectionManager(i))
                    {
                        SvcOffer so = new SvcOffer(); bool bThrown = false;

                        ConfigureSvcOffer(so, i);

                        // NOTE: on the NonQuery calls, the results[] array contains the rowcount affected for each time the SP is exec'd,
                        //       and _not_ the return value from executing the SP
                        //
                        // Reference
                        // public virtual int[] SvcInsertOfferCultureDetails(
                        //  ISpilConnectionManager scm,
                        //  SqlInt64 bi_offer_id,
                        //  SqlInt32 i_culture_id,
                        //  string vc_name,
                        //  string vc_sell_text) {
                        //
                        try
                        {
                            int[] results = so.SvcInsertOfferCultureDetails(scm
                                , (long)offerID
                                , culture
                                , name
                                , sellText
                                );

                        }
                        catch { bThrown = true; throw; }
                        finally { ErrorCheck(so.Context, Convert.ToString(TargetDBs[i]), bThrown); }
                    }
                }
            }
        }

        public static void p_svc_insert_offer_regions_xenon(ulong offerID, byte countryID,
            int tierRequired, int paymentType, DateTime startDate, DateTime endDate, string boid,
            int priceWhole, int priceFractional, uint specificOfferDetails)
        {
            // Iterate through all db targets
            for (int i = 0; i < maxTypes; i++)
            {
                // check if we are being asked to prop this particular db type
                if (0 != ((int)target & (int)TargetDBs[i]))
                {
                    using (ISpilConnectionManager scm = GetConnectionManager(i))
                    {
                        SvcOffer so = new SvcOffer(); bool bThrown = false;

                        ConfigureSvcOffer(so, i);

                        // NOTE: on the NonQuery calls, the results[] array contains the rowcount affected for each time the SP is exec'd,
                        //       and _not_ the return value from executing the SP
                        //
                        // Reference
                        // public virtual int[] SvcInsertOfferRegionsXenon(
                        //  ISpilConnectionManager scm,
                        //  SqlInt64 bi_offer_id,
                        //  SqlByte ti_country_id,
                        //  SqlInt32 i_tier_required,
                        //  SqlInt32 i_payment_type_id,
                        //  SqlDateTime dt_start_date,
                        //  SqlDateTime dt_end_date,
                        //  string vc_billing_offer_id,
                        //  SqlInt32 i_price_whole,
                        //  SqlInt32 i_price_fractional,
                        //  SqlInt16 si_specific_offer_details)
                        //
                        try
                        {
                            int[] results = so.SvcInsertOfferRegionsXenon(scm
                                , (long)offerID
                                , countryID
                                , tierRequired
                                , paymentType
                                , startDate
                                , endDate
                                , boid
                                , priceWhole
                                , priceFractional
                                , (short)specificOfferDetails
                                );

                        }
                        catch { bThrown = true; throw; }
                        finally { ErrorCheck(so.Context, Convert.ToString(TargetDBs[i]), bThrown); }
                    }
                }
            }
        }

        static void RemoveFileFromStorage(string storageFileName, ulong titleID)
        {
            string arguments = string.Format("-a:remove -p:{0} -t:0x{1:x8}", storageFileName, titleID);

            Process stutil = new Process();
            stutil.StartInfo.FileName = "stutil.exe";
            stutil.StartInfo.Arguments = arguments;
            stutil.StartInfo.UseShellExecute = false;
            stutil.StartInfo.RedirectStandardOutput = true;

            stutil.Start();

            Console.WriteLine();
            Console.WriteLine("{0} {1}", stutil.StartInfo.FileName, stutil.StartInfo.Arguments);
            Console.WriteLine(stutil.StandardOutput.ReadToEnd());

            stutil.WaitForExit();
        }

        static void WriteFileToStorage(string localFileName, string storageFileName, ulong titleID)
        {
            if (Environment.GetEnvironmentVariable("LIVEOFFER_NOPIX") != null)
                return;

            // check to see if we've already written an image to this location, and if so move on
            if (imageServerPaths.Contains(storageFileName))
                return;

            // check to see if the local file exists; if not, abort and return
            if (!File.Exists(localFileName))
            {
                Console.WriteLine("OfferManager.WriteFileToStorage(): ERROR: could not find source file " + localFileName + " using current path " + Environment.CurrentDirectory);
                return;
            }

            string arguments = string.Format("-a:write -f:{0} -p:{1} -t:0x{2:x8} -y", localFileName, storageFileName, titleID);

            Process stutil = new Process();
            stutil.StartInfo.FileName = "stutil.exe";
            stutil.StartInfo.Arguments = arguments;
            stutil.StartInfo.UseShellExecute = false;
            stutil.StartInfo.RedirectStandardOutput = true;

            stutil.Start();

            Console.WriteLine();
            Console.WriteLine("{0} {1}", stutil.StartInfo.FileName, stutil.StartInfo.Arguments);
            Console.WriteLine(stutil.StandardOutput.ReadToEnd());

            stutil.WaitForExit();

            if (stutil.ExitCode == 0) // success
            {
                if (imageFilePaths.IndexOf(localFileName) < 0) // a distinct list
                    imageFilePaths.Add(localFileName);

                imageServerPaths[storageFileName] = 1;
            }

        }

        static void p_svc_insert_offer_scs_item_details(ulong offerID, int campaignID)
        {
            // Iterate through all db targets
            for (int i = 0; i < maxTypes; i++)
            {
                // check if we are being asked to prop this particular db type
                if (0 != ((int)target & (int)TargetDBs[i]))
                {
                    using (ISpilConnectionManager scm = GetConnectionManager(i))
                    {
                        SvcOffer so = new SvcOffer(); bool bThrown = false;

                        ConfigureSvcOffer(so, i);

                        // NOTE: on the NonQuery calls, the results[] array contains the rowcount affected for each time the SP is exec'd,
                        //       and _not_ the return value from executing the SP
                        //
                        // Reference
                        // public virtual int[] SvcInsertOfferScsItemDetails(
                        //  ISpilConnectionManager scm,
                        //  SqlInt64 bi_offer_id,
                        //  SqlInt32 i_campaign_id)
                        //
                        try
                        {
                            int[] results = so.SvcInsertOfferScsItemDetails(scm
                                , (long)offerID
                                , campaignID
                                );

                        }
                        catch { bThrown = true; throw; }
                        finally { ErrorCheck(so.Context, Convert.ToString(TargetDBs[i]), bThrown); }
                    }
                }
            }
        }

        public static void p_svc_insert_offer_campaign(uint campaignID, string friendlyName)
        {
            // Iterate through all db targets
            for (int i = 0; i < maxTypes; i++)
            {
                // check if we are being asked to prop this particular db type
                if (0 != ((int)target & (int)TargetDBs[i]))
                {
                    using (ISpilConnectionManager scm = GetConnectionManager(i))
                    {
                        SvcOffer so = new SvcOffer(); bool bThrown = false;

                        ConfigureSvcOffer(so, i);

                        // NOTE: on the NonQuery calls, the results[] array contains the rowcount affected for each time the SP is exec'd,
                        //       and _not_ the return value from executing the SP
                        //
                        // Reference
                        // public virtual int[] SvcInsertOfferCampaign(
                        //  ISpilConnectionManager scm,
                        //  SqlInt32 i_campaign_id,
                        //  string vc_friendly_name)
                        //
                        try
                        {
                            int[] results = so.SvcInsertOfferCampaign(scm
                                , (int)campaignID
                                , friendlyName
                                , (overwriteDMPSettings ? 1 : 0)
                                );

                        }
                        catch { bThrown = true; throw; }
                        finally { ErrorCheck(so.Context, Convert.ToString(TargetDBs[i]), bThrown); }
                    }
                }
            }
        }

        public static void p_svc_insert_offer_sku(uint skuID, int skuType, string SKU, string friendlyName)
        {
            for (int i = 0; i < maxTypes; i++)
            {
                // check if we are being asked to prop this particular db type
                if (0 != ((int)target & (int)TargetDBs[i]))
                {
                    using (ISpilConnectionManager scm = GetConnectionManager(i))
                    {
                        SvcOffer so = new SvcOffer(); bool bThrown = false;

                        ConfigureSvcOffer(so, i);

                        // NOTE: on the NonQuery calls, the results[] array contains the rowcount affected for each time the SP is exec'd,
                        //       and _not_ the return value from executing the SP
                        //
                        // Reference
                        // public virtual int[] SvcInsertOfferSku(
                        //  ISpilConnectionManager scm,
                        //  SqlInt32 i_sku_id,
                        //  SqlInt32 i_sku_type_id,
                        //  string vc_sku,
                        //  string vc_friendly_name) {
                        //
                        try
                        {
                            int[] results = so.SvcInsertOfferSku(scm
                                , (int)skuID
                                , skuType
                                , SKU
                                , friendlyName
                                , (overwriteDMPSettings ? 1 : 0)
                                );

                        }
                        catch { bThrown = true; throw; }
                        finally { ErrorCheck(so.Context, Convert.ToString(TargetDBs[i]), bThrown); }
                    }
                }
            }
        }

        public static void p_svc_insert_offer_duration(ulong offerID, int durationSeconds)
        {
            for (int i = 0; i < maxTypes; i++)
            {
                // check if we are being asked to prop this particular db type
                if (0 != ((int)target & (int)TargetDBs[i]))
                {
                    using (ISpilConnectionManager scm = GetConnectionManager(i))
                    {
                        SvcOffer so = new SvcOffer(); bool bThrown = false;

                        ConfigureSvcOffer(so, i);

                        // NOTE: on the NonQuery calls, the results[] array contains the rowcount affected for each time the SP is exec'd,
                        //       and _not_ the return value from executing the SP
                        //
                        // Reference
                        // public virtual int[] SvcInsertOfferDuration(
                        //  ISpilConnectionManager scm,
                        //  SqlInt64 bi_offer_id,
                        //  SqlInt32 i_duration_seconds)
                        //
                        try
                        {
                            int[] results = so.SvcInsertOfferDuration(scm
                                , (long)offerID
                                , durationSeconds
                                );

                        }
                        catch { bThrown = true; throw; }
                        finally { ErrorCheck(so.Context, Convert.ToString(TargetDBs[i]), bThrown); }
                    }
                }
            }
        }

        public static void p_svc_insert_dmp_reward_culture_details(int rewardID, int cultureID,
            string acquisitionTitle)
        {
            for (int i = 0; i < maxTypes; i++)
            {
                // check if we are being asked to prop this particular db type
                if (0 != ((int)target & (int)TargetDBs[i]))
                {
                    using (ISpilConnectionManager scm = GetConnectionManager(i))
                    {
                        SvcOffer so = new SvcOffer(); bool bThrown = false;

                        ConfigureSvcOffer(so, i);

                        // NOTE: on the NonQuery calls, the results[] array contains the rowcount affected for each time the SP is exec'd,
                        //       and _not_ the return value from executing the SP
                        //
                        // Reference
                        // public virtual int[] SvcInsertDmpRewardCultureDetails(
                        //  ISpilConnectionManager scm,
                        //  SqlInt32 i_reward_id,
                        //  SqlInt32 i_culture_id,
                        //  string vc_acquisition_title)
                        //
                        try
                        {
                            int[] results = so.SvcInsertDmpRewardCultureDetails(scm
                                , rewardID
                                , cultureID
                                , acquisitionTitle
                                );

                        }
                        catch { bThrown = true; throw; }
                        finally { ErrorCheck(so.Context, Convert.ToString(TargetDBs[i]), bThrown); }
                    }
                }
            }
        }

        public static void p_svc_insert_dmp_reward(int rewardID, int pointsRewarded, int rewardLifetime,
            int promoSKU, int campaignID, int acquisitionType)
        {
            for (int i = 0; i < maxTypes; i++)
            {
                // check if we are being asked to prop this particular db type
                if (0 != ((int)target & (int)TargetDBs[i]))
                {
                    using (ISpilConnectionManager scm = GetConnectionManager(i))
                    {
                        SvcOffer so = new SvcOffer(); bool bThrown = false;

                        ConfigureSvcOffer(so, i);

                        // NOTE: on the NonQuery calls, the results[] array contains the rowcount affected for each time the SP is exec'd,
                        //       and _not_ the return value from executing the SP
                        //
                        // Reference
                        // public virtual int[] SvcInsertDmpReward(
                        //  ISpilConnectionManager scm,
                        //  SqlInt32 i_reward_id,
                        //  SqlInt32 i_points_rewarded,
                        //  SqlInt32 i_reward_lifetime,
                        //  SqlInt32 i_promo_sku_id,
                        //  SqlInt32 i_campaign_id,
                        //  SqlInt32 i_acquisition_type_id)
                        //
                        try
                        {
                            int[] results = so.SvcInsertDmpReward(scm
                                , rewardID
                                , pointsRewarded
                                , rewardLifetime
                                , promoSKU
                                , campaignID
                                , acquisitionType
                                );

                        }
                        catch { bThrown = true; throw; }
                        finally { ErrorCheck(so.Context, Convert.ToString(TargetDBs[i]), bThrown); }
                    }
                }
            }
        }

        public static void p_svc_insert_offer_acquisition_type(int acquisitionType, string friendlyName)
        {
            for (int i = 0; i < maxTypes; i++)
            {
                // check if we are being asked to prop this particular db type
                if (0 != ((int)target & (int)TargetDBs[i]))
                {
                    using (ISpilConnectionManager scm = GetConnectionManager(i))
                    {
                        SvcOffer so = new SvcOffer(); bool bThrown = false;

                        ConfigureSvcOffer(so, i);

                        // NOTE: on the NonQuery calls, the results[] array contains the rowcount affected for each time the SP is exec'd,
                        //       and _not_ the return value from executing the SP
                        //
                        // Reference
                        // public virtual int[] SvcInsertOfferAcquisitionType(
                        //  ISpilConnectionManager scm,
                        //  SqlInt32 i_acquisition_type_id,
                        //  string vc_friendly_name)
                        //
                        try
                        {
                            int[] results = so.SvcInsertOfferAcquisitionType(scm
                                , acquisitionType
                                , friendlyName
                                , (overwriteDMPSettings ? 1 : 0)
                                );

                        }
                        catch { bThrown = true; throw; }
                        finally { ErrorCheck(so.Context, Convert.ToString(TargetDBs[i]), bThrown); }
                    }
                }
            }
        }

        public static void p_svc_insert_offer_reward_details(ulong offerID, int rewardID)
        {
            for (int i = 0; i < maxTypes; i++)
            {
                // check if we are being asked to prop this particular db type
                if (0 != ((int)target & (int)TargetDBs[i]))
                {
                    using (ISpilConnectionManager scm = GetConnectionManager(i))
                    {
                        SvcOffer so = new SvcOffer(); bool bThrown = false;

                        ConfigureSvcOffer(so, i);

                        // NOTE: on the NonQuery calls, the results[] array contains the rowcount affected for each time the SP is exec'd,
                        //       and _not_ the return value from executing the SP
                        //
                        // Reference
                        // public virtual int[] SvcInsertOfferRewardDetails(
                        //  ISpilConnectionManager scm,
                        //  SqlInt64 bi_offer_id,
                        //  SqlInt32 i_reward_id)
                        //
                        try
                        {
                            int[] results = so.SvcInsertOfferRewardDetails(scm
                                , (long)offerID
                                , rewardID
                                );

                        }
                        catch { bThrown = true; throw; }
                        finally { ErrorCheck(so.Context, Convert.ToString(TargetDBs[i]), bThrown); }
                    }
                }
            }
        }

        static void p_svc_insert_subscriptions_multi_title(uint[] titleIDs, ulong offerID, uint bitFilter,
            bool cancelable, int offerType, string friendlyName, string billingComponentID, uint policyFlags,
            uint globalOfferDetails, ConsoleTypeEnum consoleType)
        {
            p_svc_insert_subscriptions_EX(titleIDs, offerID, 0,
                cancelable, 0, 0, null, (int)bitFilter, billingComponentID, offerType, 0,
                new DateTime(2001, 11, 15), new DateTime(3001, 11, 15), friendlyName, null, policyFlags,
                globalOfferDetails, consoleType);
        }

        public static void p_svc_service_create_offer(ulong offerID, uint serviceID)
        {
            for (int i = 0; i < maxTypes; i++)
            {
                // check if we are being asked to prop this particular db type
                if (0 != ((int)target & (int)TargetDBs[i]))
                {
                    using (ISpilConnectionManager scm = GetConnectionManager(i))
                    {
                        SvcOffer so = new SvcOffer(); bool bThrown = false;

                        ConfigureSvcOffer(so, i);

                        // NOTE: on the NonQuery calls, the results[] array contains the rowcount affected for each time the SP is exec'd,
                        //       and _not_ the return value from executing the SP
                        //
                        // Reference
                        // public virtual int[] SvcServiceCreateOffer(
                        //  ISpilConnectionManager scm,
                        //  SqlInt32 i_service_id,
                        //  SqlInt64 bi_offer_id)
                        //
                        try
                        {
                            if (serviceID != 0)
                            {
                                int[] results = so.SvcServiceCreateOffer(scm
                                    , (int)serviceID
                                    , (long)offerID
                                    );
                            }
                            else
                            {
                                return;
                            }

                        }
                        catch { bThrown = true; throw; }
                        finally
                        {
                            if (so.Context.Command != null)
                            {
                                ErrorCheck(so.Context, Convert.ToString(TargetDBs[i]), bThrown);
                            }
                        }
                    }
                }
            }
        }

        public static void p_svc_insert_base_offer(ulong offerID, uint tierID)
        {
            for (int i = 0; i < maxTypes; i++)
            {
                // check if we are being asked to prop this particular db type
                if (0 != ((int)target & (int)TargetDBs[i]))
                {
                    using (ISpilConnectionManager scm = GetConnectionManager(i))
                    {
                        SvcOffer so = new SvcOffer(); bool bThrown = false;

                        ConfigureSvcOffer(so, i);

                        // NOTE: on the NonQuery calls, the results[] array contains the rowcount affected for each time the SP is exec'd,
                        //       and _not_ the return value from executing the SP
                        //
                        // Reference
                        // public virtual int[] SvcInsertBaseOffer(
                        //  ISpilConnectionManager scm,
                        //  SqlInt64 bi_offer_id,
                        //  SqlInt32 i_tier_id)
                        //
                        try
                        {
                            int[] results = so.SvcInsertBaseOffer(scm
                                , (long)offerID
                                , (int)tierID
                                );

                        }
                        catch { bThrown = true; throw; }
                        finally { ErrorCheck(so.Context, Convert.ToString(TargetDBs[i]), bThrown); }
                    }
                }
            }
        }

        public static void p_svc_insert_subscription_info(SubscriptionTypeInfo typeInfo, ulong offerID)
        {
            for (int i = 0; i < maxTypes; i++)
            {
                // check if we are being asked to prop this particular db type
                if (0 != ((int)target & (int)TargetDBs[i]))
                {
                    using (ISpilConnectionManager scm = GetConnectionManager(i))
                    {
                        SvcOffer so = new SvcOffer(); bool bThrown = false;

                        ConfigureSvcOffer(so, i);

                        // NOTE: on the NonQuery calls, the results[] array contains the rowcount affected for each time the SP is exec'd,
                        //       and _not_ the return value from executing the SP
                        //
                        // Reference
                        // public virtual int[] SvcInsertSubscriptionInfo(
                        //  ISpilConnectionManager scm,
                        //  SqlInt64 bi_offer_id,
                        //  SqlInt16 si_subscription_type
                        //  SqlInt32 i_tier_id
                        //  SqlByte  ti_is_base
                        // ) 
                        //
                        try
                        {
                            int[] results = so.SvcInsertSubscriptionInfo(
                                scm, (long)offerID,
                                typeInfo.subscriptionType,
                                MapLiveTier(typeInfo.tierProvided),
                                typeInfo.isBase ? (byte)1 : (byte)0
                            );
                        }
                        catch
                        {
                            bThrown = true; throw;
                        }
                        finally
                        {
                            ErrorCheck(so.Context, Convert.ToString(TargetDBs[i]), bThrown);
                        }
                    }
                }
            }
        }

        public static void p_svc_insert_offer_subscription_reward(ulong offerID, ushort countryID, int subscriptionTier,
            int rewardID, DateTime startDate, DateTime endDate)
        {
            for (int i = 0; i < maxTypes; i++)
            {
                // check if we are being asked to prop this particular db type
                if (0 != ((int)target & (int)TargetDBs[i]))
                {
                    using (ISpilConnectionManager scm = GetConnectionManager(i))
                    {
                        SvcOffer so = new SvcOffer(); bool bThrown = false;

                        ConfigureSvcOffer(so, i);

                        // NOTE: on the NonQuery calls, the results[] array contains the rowcount affected for each time the SP is exec'd,
                        //       and _not_ the return value from executing the SP
                        //
                        // Reference
                        // public virtual int[] SvcInsertOfferSubscriptionReward(
                        //  ISpilConnectionManager scm,
                        //  SqlInt64 bi_offer_id,
                        //  SqlInt32 ti_country_id,
                        //  SqlInt32 i_subscription_tier_id,
                        //  SqlDateTime dt_start_date,
                        //  SqlDateTime dt_end_date,
                        //  SqlInt32 i_reward_id)
                        //
                        try
                        {
                            int[] results = so.SvcInsertOfferSubscriptionReward(scm
                                , (long)offerID
                                , (int)countryID
                                , subscriptionTier
                                , startDate
                                , endDate
                                , rewardID
                                );

                        }
                        catch { bThrown = true; throw; }
                        finally { ErrorCheck(so.Context, Convert.ToString(TargetDBs[i]), bThrown); }
                    }
                }
            }
        }

        public static void p_svc_insert_offer_relations(ulong offerIDFrom, ulong OfferIDTo, int relationType, int convertMode)
        {
            //        public virtual int[] SvcInsertOfferRelations(ISpilConnectionManager scm, SqlInt64 bi_offer_id, SqlInt64 bi_related_offer_id, SqlInt32 i_relation_type_id, SqlInt32 i_convert_mode) {
            for (int i = 0; i < maxTypes; i++)
            {
                // check if we are being asked to prop this particular db type
                if (0 != ((int)target & (int)TargetDBs[i]))
                {
                    using (ISpilConnectionManager scm = GetConnectionManager(i))
                    {
                        SvcOffer so = new SvcOffer(); bool bThrown = false;

                        ConfigureSvcOffer(so, i);

                        // NOTE: on the NonQuery calls, the results[] array contains the rowcount affected for each time the SP is exec'd,
                        //       and _not_ the return value from executing the SP
                        //
                        // Reference
                        // public virtual int[] SvcInsertOfferRelations(
                        //  ISpilConnectionManager scm,
                        //  SqlInt64 bi_offer_id,
                        //  SqlInt64 bi_related_offer_id,
                        //  SqlInt32 i_relation_type_id,
                        //  SqlInt32 i_convert_mode) {
                        //
                        try
                        {
                            int[] results = so.SvcInsertOfferRelations(scm
                                , (long)OfferIDTo
                                , (long)offerIDFrom
                                , relationType
                                , convertMode
                                );

                        }
                        catch { bThrown = true; throw; }
                        finally { ErrorCheck(so.Context, Convert.ToString(TargetDBs[i]), bThrown); }
                    }
                }
            }
        }


        #region Xbox XML Shredding...

        public static int PropXboxOffers(XboxOffers xos)
        {
            int count = 0;

            TransactionScope ts = (useTransaction ? TransactionScope.DTC : TransactionScope.None);
            IsolationLevel il = IsolationLevel.ReadCommitted;

            //task: HOW SHOULD WE DEPLOY SERVICES AND SERVICE INSTANCES?? 
            //task: for services and service instances


            //for subscription offers
            foreach (XboxSubscription xs in xos.XboxSubscriptionCollection)
            {
                //Note: TransactionScope.DTC currently has issue when over 100 commands are issued in the same Transaction -- WebstoreProduct bug 5812 is being researched
                //      Current Workaround is to update HKLM\Software\Microsoft\WebStore\<WebStore AppName>\MaxPoolSize (DWORD) to be over 100
                using (TransactionWrapper myTrans = new TransactionWrapper(ts, il))
                {
                    DeployXboxSubscription(xs);
                    count++;
                    // From SPIL 3.0 documentation:
                    // This method should be called just before the end of the "using" block. 
                    // It lets the TransactionWrapper know that the block completed without throwing an exception. 
                    // If SetComplete was not called before Dispose was called, then we automatically abort the transaction. 
                    if (useTransaction)
                        myTrans.SetComplete();
                }
            }

            //for each content offer (there is only 1 possible)
            if (xos.__XboxContentOffer != null)
            {
                using (TransactionWrapper myTrans = new TransactionWrapper(ts, il))
                {
                    DeployXboxContentOffer(xos.XboxContentOffer);
                    count++;
                    if (useTransaction)
                        myTrans.SetComplete();
                }
            }

            //task: for each update ???
            // This should be handled by LiveTitle or LiveContent

            return count;
        }


        //note: the schema for Xbox contains many "long" types where "ulong" would have been more appropriate
        //      but it seemed easier to convert these here 
        public static void DeployXboxContentOffer(XboxContentOffer xo)
        {

            XboxOfferBasicInfo xobi = xo.xboxOfferBasicInfo;

            // basic validation
            if (String.IsNullOrEmpty(xobi.symKey) || String.IsNullOrEmpty(xobi.publicKey))
            {
                Console.WriteLine("OfferManager error: either symKey or publicKey are empty or null.  Aborting deployment of offer...");
                return;
            }

            byte[] symKey = HexStringToByteArray(xobi.symKey);
            byte[] pubKey = HexStringToByteArray(xobi.publicKey);

            p_svc_insert_offers_xbox(
                (uint)xobi.titleID, (ulong)xobi.offerID, (ushort)xobi.ESRB,
                (int)xobi.packageSize, (int)xobi.installSize, symKey, (uint)xobi.bitFilter,
                xobi.billingSvcComponentID, (int)xobi.offerTypeID, xobi.startDate,
                xobi.endDate, xobi.friendlyName, pubKey, xobi.policyFlags);

            foreach (XboxOfferDescription xod in xo.xboxOfferDescriptionCollection)
            {
                byte[] blob = null;
                if (xod.blobBase64 == true)
                    blob = Convert.FromBase64String(xod.detailsBlob);
                else
                    blob = HexStringToByteArray(xod.detailsBlob);
                p_svc_insert_offer_descriptions_xbox((ulong)xod.liveOfferID, (int)xod.descriptionIndex, blob);
            }

            foreach (XboxOfferDescriptionDetails xods in xo.xboxOfferDescriptionDetailsCollection)
            {
                byte[] blob = null;
                if (xods.blobBase64 == true)
                    blob = Convert.FromBase64String(xods.detailsBlob);
                else
                    blob = HexStringToByteArray(xods.detailsBlob);
                p_svc_insert_offer_description_details_xbox((ulong)xods.liveOfferID, blob, (int)xods.descriptionIndex, (int)xods.order);
            }

            foreach (XboxOfferLocations xol in xo.xboxOfferLocationsCollection)
            {
                p_svc_insert_offer_locations_xbox((ulong)xol.offerID, (int)xol.locationRank, xol.XRL);
            }

            //titlemgr did it this way... so we'll do it too.
            p_svc_delete_offer_regions_xbox(xobi.offerID);

            foreach (XboxOfferRegions xor in xo.xboxOfferRegionsCollection)
            {
                p_svc_insert_offer_regions_xbox((ulong)xor.liveOfferID, xor.countryID, xor.billingOfferID,
                    (int)xor.priceWhole, (int)xor.priceFractional, (short)xor.specificOfferDetails);
            }
        }

        //note: the schema for Xbox contains many "long" types where "ulong" would have been more appropriate
        //      but it seemed easier to convert these here 
        public static void DeployXboxSubscription(XboxSubscription xs)
        {

            XboxSubscriptionBasicInfo xsbi = xs.xboxSubscriptionBasicInfo;
            byte[] symKey = null;
            byte[] pubKey = null;
            // backwards compat with old subscription offers files that 
            // always used base64. Not perfect, but works in all cases encountered in test
            if (String.Compare(xsbi.symKey.Substring(0, 2), ("0x"), true) != 0)
            {
                symKey = Convert.FromBase64String(xsbi.symKey);
                pubKey = Convert.FromBase64String(xsbi.publicKey);
            }
            else
            {   // New / expected format for these values
                symKey = HexStringToByteArray(xsbi.symKey);
                pubKey = HexStringToByteArray(xsbi.publicKey);
            }


            p_svc_insert_subscriptions_xbox(
                (uint)xsbi.titleID, (ulong)xsbi.offerID, (ushort)xsbi.ESRB, xsbi.cancellable,
                (int)xsbi.packageSize, (int)xsbi.installSize, symKey,
                xsbi.bitFilter, xsbi.billingSvcComponentID, (int)xsbi.offerTypeID,
                (int)xsbi.offerFrequency, xsbi.startDate, xsbi.endDate, xsbi.friendlyName,
                pubKey, xsbi.policyFlags, xsbi.globalOfferDetails);

            //task: if BASE OFFER do anything else ???
            //    : eventually, make sure that site 1 is specified in offerchecker
            if (xs.baseOffer)
            {
                //add it to base_offers
                p_svc_insert_base_offer((ulong)xs.xboxSubscriptionBasicInfo.offerID, 6);  // LiveTier.Gold

                SubscriptionTypeInfo subscriptionTypeInfo = new SubscriptionTypeInfo();
                subscriptionTypeInfo.subscriptionType = 1;
                subscriptionTypeInfo.isBase = true;
                subscriptionTypeInfo.tierProvided = LiveTier.Gold;

                p_svc_insert_subscription_info(subscriptionTypeInfo, (ulong)xs.xboxSubscriptionBasicInfo.offerID);
            }

            foreach (XboxOfferDescription xod in xs.xboxOfferDescriptionCollection)
            {
                byte[] blob = null;
                if (xod.blobBase64 == true
                    // backwards compat with old subscription offers files that 
                    // always used base64. Not perfect, but works in all cases encountered in test
                        || String.Compare(xod.detailsBlob.Substring(0, 2), ("0x"), true) != 0)
                    blob = Convert.FromBase64String(xod.detailsBlob);
                else
                    blob = HexStringToByteArray(xod.detailsBlob);
                p_svc_insert_offer_descriptions_xbox((ulong)xod.liveOfferID, (int)xod.descriptionIndex, blob);
            }

            foreach (XboxOfferDescriptionDetails xods in xs.xboxOfferDescriptionDetailsCollection)
            {
                byte[] blob = null;
                if (xods.blobBase64 == true
                    // backwards compat with old subscription offers files that 
                    // always used base64. Not perfect, but works in all cases encountered in test
                        || String.Compare(xods.detailsBlob.Substring(0, 2), ("0x"), true) != 0)
                    blob = Convert.FromBase64String(xods.detailsBlob);
                else
                    blob = HexStringToByteArray(xods.detailsBlob);
                p_svc_insert_offer_description_details_xbox((ulong)xods.liveOfferID, blob, (int)xods.descriptionIndex, (int)xods.order);
            }

            //titlemgr did it this way... so we'll do it too.
            p_svc_delete_offer_regions_xbox(xsbi.offerID);

            foreach (XboxOfferRegions xor in xs.xboxOfferRegionsCollection)
            {
                p_svc_insert_offer_regions_xbox((ulong)xor.liveOfferID, xor.countryID, xor.billingOfferID,
                    (int)xor.priceWhole, (int)xor.priceFractional, (short)xor.specificOfferDetails);
            }

            foreach (XboxOfferRelations xorl in xs.xboxOfferRelationsCollection)
            {
                p_svc_insert_offer_relations_xbox((ulong)xorl.offerID, (ulong)xorl.relatedOfferID, (int)xorl.relationTypeID,
                    (int)xorl.convertMode);
            }

            foreach (XboxOfferServices xsvc in xs.xboxOfferServicesCollection)
            {
                p_svc_insert_offer_services_xbox((ulong)xsvc.offerID, (int)xsvc.siteID);
            }

        }

        #endregion


        #region Xbox Stored Procedure Code


        //REVIEW: several methods here duplicate methods above... we should 
        //        refactor so that the Xenon calls just put defaults for legacy params
        //        and call these Xbox procedures.  
        //        It doesn't seem good at this late hour to be refactoring working code
        //        that doesn't (yet) have unit tests.

        //p_svc_delete_offer_regions
        static void p_svc_delete_offer_regions_xbox(long offerID)
        {
            // Iterate through all db targets
            for (int i = 0; i < maxTypes; i++)
            {
                // check if we are being asked to prop this particular db type
                if (0 != ((int)target & (int)TargetDBs[i]))
                {
                    using (ISpilConnectionManager scm = GetConnectionManager(i))
                    {
                        SvcOffer so = new SvcOffer(); bool bThrown = false;

                        ConfigureSvcOffer(so, i);

                        // NOTE: on the NonQuery calls, the results[] array contains the rowcount affected for each time the SP is exec'd,
                        //       and _not_ the return value from executing the SP
                        //
                        // Reference
                        //         public virtual int[] SvcDeleteRegions(ISpilConnectionManager scm, SqlInt64 bi_offer_id)
                        //
                        try
                        {
                            int[] results = so.SvcDeleteRegions(scm, offerID);

                        }
                        catch { bThrown = true; throw; }
                        finally { ErrorCheck(so.Context, Convert.ToString(TargetDBs[i]), bThrown); }
                    }
                }
            }
        }


        public static void p_svc_insert_offers_xbox(uint titleID, ulong offerID, int esrb,
            int packageSize, int installSize, byte[] symKey, uint bitFilter,
            string billingSvcComponentID, int offerType, DateTime startDate, DateTime endDate,
            string friendlyName, byte[] publicKey, uint policyFlags)
        {
            p_svc_insert_offers_EX(titleID, offerID, esrb, false, packageSize, installSize, symKey, bitFilter,
            billingSvcComponentID, offerType, 0,
            startDate, endDate, friendlyName, publicKey,
            policyFlags, ConsoleTypeEnum.Xbox1, 0, null, 0);
        }

        // function that both consoleTypes can use
        public static void p_svc_insert_offers_EX(uint titleID, ulong offerID, int esrb,
            bool cancelable, int packageSize, int installSize, byte[] symKey, uint bitFilter,
            string billingSvcComponentID, int offerType, int offerFrequency,
            DateTime startDate, DateTime endDate, string friendlyName, byte[] publicKey,
            uint policyFlags, ConsoleTypeEnum consoleType, uint licenseBits, byte[] contentID, ulong previewOfferID)
        {

            // Iterate through all db targets
            for (int i = 0; i < maxTypes; i++)
            {
                // check if we are being asked to prop this particular db type
                if (0 != ((int)target & (int)TargetDBs[i]))
                {
                    using (ISpilConnectionManager scm = GetConnectionManager(i))
                    {
                        SvcOffer so = new SvcOffer(); bool bThrown = false;

                        ConfigureSvcOffer(so, i);

                        // NOTE: on the NonQuery calls, the results[] array contains the rowcount affected for each time the SP is exec'd,
                        //       and _not_ the return value from executing the SP
                        //
                        // Reference
                        //  public virtual int[] SvcInsertOffers(
                        //  ISpilConnectionManager scm,
                        //  SqlInt32 i_title_id,
                        //  SqlInt64 bi_offer_id,
                        //  SqlInt32 i_ESRB_id,
                        //  SqlByte b_cancelable,
                        //  SqlInt32 i_package_size,
                        //  SqlInt32 i_install_size,
                        //  SqlBinary vb_sym_key,
                        //  SqlInt32 i_bitfilter,
                        //  string vc_billing_svc_component_id,
                        //  SqlInt32 i_offer_type_id,
                        //  SqlInt32 i_offer_frequency_id,
                        //  SqlDateTime dt_start_date,
                        //  SqlDateTime dt_end_date,
                        //  string vc_friendly_name,
                        //  SqlBinary vb_public_key,
                        //  SqlInt32 i_policy_flags,
                        //  SqlByte ti_console_type_id,
                        //  SqlInt32 i_license_bits,
                        //  SqlBinary b_content_id,
                        //  SqlInt64 bi_preview_offer_id)
                        //
                        try
                        {
                            int[] results = so.SvcInsertOffers(scm
                                , (int)titleID
                                , (long)offerID
                                , (int)esrb // i_ESRB_id : legacy
                                , (byte)(cancelable ? 1 : 0) // b_cancelable : legacy
                                , packageSize // i_package_size : legacy
                                , installSize // i_install_size : legacy
                                , symKey
                                , (int)bitFilter
                                , billingSvcComponentID // vc_billing_svc_component_id : not applicable to content offers
                                , offerType
                                , 0 // i_offer_frequency_id : legacy
                                , startDate // dt_start_date : legacy
                                , endDate // dt_end_date : legacy
                                , friendlyName
                                , publicKey // legacy
                                , (int)policyFlags
                                , (byte)consoleType // xbox consoletype
                                , (int)licenseBits
                                , (contentID != null ? contentID : SqlBinary.Null)
                                , (long)previewOfferID
                                );

                        }
                        catch { bThrown = true; throw; }
                        finally { ErrorCheck(so.Context, Convert.ToString(TargetDBs[i]), bThrown); }
                    }
                }
            }
        }

        //insert offer descriptions
        public static void p_svc_insert_offer_descriptions_xbox(ulong offerID,
            int descriptionIndex, byte[] detailsBlob)
        {
            // Iterate through all db targets
            for (int i = 0; i < maxTypes; i++)
            {
                // check if we are being asked to prop this particular db type
                if (0 != ((int)target & (int)TargetDBs[i]))
                {
                    using (ISpilConnectionManager scm = GetConnectionManager(i))
                    {
                        SvcOffer so = new SvcOffer(); bool bThrown = false;

                        ConfigureSvcOffer(so, i);

                        // NOTE: on the NonQuery calls, the results[] array contains the rowcount affected for each time the SP is exec'd,
                        //       and _not_ the return value from executing the SP
                        //
                        // Reference
                        // public virtual int[] SvcInsertOfferDescriptions(
                        //   ISpilConnectionManager scm,
                        //   SqlInt64 bi_offer_id,
                        //   SqlBinary vb_enum_blob,
                        //   SqlInt32 i_description_index)
                        //
                        try
                        {
                            int[] results = so.SvcInsertOfferDescriptions(scm
                                , (long)offerID
                                , detailsBlob
                                , descriptionIndex
                                );

                        }
                        catch { bThrown = true; throw; }
                        finally { ErrorCheck(so.Context, Convert.ToString(TargetDBs[i]), bThrown); }
                    }
                }
            }
        }

        //insert offer description details
        public static void p_svc_insert_offer_description_details_xbox(ulong offerID,
            byte[] detailsBlob, int descriptionIndex, int order)
        {
            // Iterate through all db targets
            for (int i = 0; i < maxTypes; i++)
            {
                // check if we are being asked to prop this particular db type
                if (0 != ((int)target & (int)TargetDBs[i]))
                {
                    using (ISpilConnectionManager scm = GetConnectionManager(i))
                    {
                        SvcOffer so = new SvcOffer(); bool bThrown = false;

                        ConfigureSvcOffer(so, i);

                        // NOTE: on the NonQuery calls, the results[] array contains the rowcount affected for each time the SP is exec'd,
                        //       and _not_ the return value from executing the SP
                        //
                        // Reference
                        // public virtual int[] SvcInsertOfferDescriptionDetails(
                        //   ISpilConnectionManager scm,
                        //   SqlInt64 bi_offer_id,
                        //   SqlBinary vb_details_blob,
                        //   SqlInt32 i_description_index,
                        //   SqlInt32 i_order)
                        //
                        try
                        {
                            int[] results = so.SvcInsertOfferDescriptionDetails(scm
                                , (long)offerID
                                , detailsBlob
                                , descriptionIndex
                                , order
                                );

                        }
                        catch { bThrown = true; throw; }
                        finally { ErrorCheck(so.Context, Convert.ToString(TargetDBs[i]), bThrown); }
                    }
                }
            }
        }

        //p_svc_insert_offer_locations
        public static void p_svc_insert_offer_locations_xbox(ulong offerID, int locationRank, string xrl)
        {
            // Iterate through all db targets
            for (int i = 0; i < maxTypes; i++)
            {
                // check if we are being asked to prop this particular db type
                if (0 != ((int)target & (int)TargetDBs[i]))
                {
                    using (ISpilConnectionManager scm = GetConnectionManager(i))
                    {
                        SvcOffer so = new SvcOffer(); bool bThrown = false;

                        ConfigureSvcOffer(so, i);

                        // NOTE: on the NonQuery calls, the results[] array contains the rowcount affected for each time the SP is exec'd,
                        //       and _not_ the return value from executing the SP
                        //
                        // Reference
                        // public virtual int[] SvcInsertOfferLocations(
                        // ISpilConnectionManager scm,
                        //  SqlInt64 bi_offer_id,
                        //  SqlInt32 i_location_rank,
                        //  string vc_XRL)
                        //
                        try
                        {
                            int[] results = so.SvcInsertOfferLocations(scm
                                , (long)offerID
                                , locationRank
                                , xrl
                                );

                        }
                        catch { bThrown = true; throw; }
                        finally { ErrorCheck(so.Context, Convert.ToString(TargetDBs[i]), bThrown); }
                    }
                }
            }
        }


        //p_svc_insert_offer_relations
        static void p_svc_insert_offer_relations_xbox(ulong offerID, ulong relatedOfferID,
            int relationTypeID, int convertMode)
        {
            for (int i = 0; i < maxTypes; i++)
            {
                // check if we are being asked to prop this particular db type
                if (0 != ((int)target & (int)TargetDBs[i]))
                {
                    using (ISpilConnectionManager scm = GetConnectionManager(i))
                    {
                        SvcOffer so = new SvcOffer(); bool bThrown = false;

                        ConfigureSvcOffer(so, i);

                        // NOTE: on the NonQuery calls, the results[] array contains the rowcount affected for each time the SP is exec'd,
                        //       and _not_ the return value from executing the SP
                        //
                        // Reference
                        // public virtual int[] SvcInsertOfferRelations(
                        //  ISpilConnectionManager scm,
                        //  SqlInt64 bi_offer_id,
                        //  SqlInt64 bi_related_offer_id,
                        //  SqlInt32 i_relation_type_id,
                        //  SqlInt32 i_convert_mode)
                        //
                        try
                        {
                            int[] results = so.SvcInsertOfferRelations(scm
                                , (long)offerID
                                , (long)relatedOfferID
                                , relationTypeID
                                , convertMode
                                );

                        }
                        catch { bThrown = true; throw; }
                        finally { ErrorCheck(so.Context, Convert.ToString(TargetDBs[i]), bThrown); }
                    }
                }
            }
        }


        //p_svc_insert_offer_regions
        static void p_svc_insert_offer_regions_xbox(ulong offerID, byte countryID,
            string billingOfferID, int priceWhole, int priceFractional, short specificOfferDetails)
        {
            for (int i = 0; i < maxTypes; i++)
            {
                // check if we are being asked to prop this particular db type
                if (0 != ((int)target & (int)TargetDBs[i]))
                {
                    using (ISpilConnectionManager scm = GetConnectionManager(i))
                    {
                        SvcOffer so = new SvcOffer(); bool bThrown = false;

                        ConfigureSvcOffer(so, i);

                        // NOTE: on the NonQuery calls, the results[] array contains the rowcount affected for each time the SP is exec'd,
                        //       and _not_ the return value from executing the SP
                        //
                        // Reference
                        // public virtual int[] SvcInsertOfferRegions(
                        //  ISpilConnectionManager scm,
                        //  SqlInt64 bi_offer_id,
                        //  SqlByte ti_country_id,
                        //  string vc_billing_offer_id,
                        //  SqlInt32 i_price_whole,
                        //  SqlInt32 i_price_fractional,
                        //  SqlInt16 si_specific_offer_details)
                        //
                        try
                        {
                            int[] results = so.SvcInsertOfferRegions(scm
                                , (long)offerID
                                , countryID
                                , billingOfferID
                                , priceWhole
                                , priceFractional
                                , specificOfferDetails
                                );

                        }
                        catch { bThrown = true; throw; }
                        finally { ErrorCheck(so.Context, Convert.ToString(TargetDBs[i]), bThrown); }
                    }
                }
            }
        }

        //p_svc_insert_offer_services
        static void p_svc_insert_offer_services_xbox(ulong offerID, int siteID)
        {
            for (int i = 0; i < maxTypes; i++)
            {
                // check if we are being asked to prop this particular db type
                if (0 != ((int)target & (int)TargetDBs[i]))
                {
                    using (ISpilConnectionManager scm = GetConnectionManager(i))
                    {
                        SvcOffer so = new SvcOffer(); bool bThrown = false;

                        ConfigureSvcOffer(so, i);

                        // NOTE: on the NonQuery calls, the results[] array contains the rowcount affected for each time the SP is exec'd,
                        //       and _not_ the return value from executing the SP
                        //
                        // Reference
                        // public virtual int[] SvcInsertOfferServices(
                        //  ISpilConnectionManager scm,
                        //  SqlInt64 bi_offer_id,
                        //  SqlInt32 i_site_id)
                        //
                        try
                        {
                            int[] results = so.SvcInsertOfferServices(scm
                                , (long)offerID
                                , siteID
                                );

                        }
                        catch { bThrown = true; throw; }
                        finally { ErrorCheck(so.Context, Convert.ToString(TargetDBs[i]), bThrown); }
                    }
                }
            }
        }

        //p_svc_insert_title_update_packages 
        static void p_svc_insert_title_update_packages_xbox(uint titleID,
            int titleBaseVersion, int titleUpdateVersion, int packageSize, int installSize,
            byte[] symKey, byte[] publicKey)
        {
            for (int i = 0; i < maxTypes; i++)
            {
                // check if we are being asked to prop this particular db type
                if (0 != ((int)target & (int)TargetDBs[i]))
                {
                    using (ISpilConnectionManager scm = GetConnectionManager(i))
                    {
                        SvcOffer so = new SvcOffer(); bool bThrown = false;

                        ConfigureSvcOffer(so, i);

                        // NOTE: on the NonQuery calls, the results[] array contains the rowcount affected for each time the SP is exec'd,
                        //       and _not_ the return value from executing the SP
                        //
                        // Reference
                        // public virtual int[] SvcInsertTitleUpdatePackages(
                        //  ISpilConnectionManager scm,
                        //  SqlInt32 i_title_id,
                        //  SqlInt32 i_title_base_version,
                        //  SqlInt32 i_title_update_version,
                        //  SqlInt32 i_package_size,
                        //  SqlInt32 i_install_size,
                        //  SqlBinary vb_update_sym_key,
                        //  SqlBinary vb_public_key,
                        //  SqlBinary b_content_id) {
                        //
                        try
                        {
                            int[] results = so.SvcInsertTitleUpdatePackages(scm
                                , (int)titleID
                                , titleBaseVersion
                                , titleUpdateVersion
                                , packageSize
                                , installSize
                                , symKey
                                , publicKey
                                , SqlBinary.Null
                                , SqlByte.Null
                                );

                        }
                        catch { bThrown = true; throw; }
                        finally { ErrorCheck(so.Context, Convert.ToString(TargetDBs[i]), bThrown); }
                    }
                }
            }
        }

        //p_svc_insert_title_versions  
        static void p_svc_insert_title_versions(uint titleID,
            int titleBaseVersion, int titleNewVersion, int versionFlag)
        {
            //        public virtual int[] SvcInsertTitleVersions(ISpilConnectionManager scm, SqlInt32 i_title_id, SqlInt32 i_base_version, SqlInt32 i_new_version, SqlInt32 i_version_flag) {
            for (int i = 0; i < maxTypes; i++)
            {
                // check if we are being asked to prop this particular db type
                if (0 != ((int)target & (int)TargetDBs[i]))
                {
                    using (ISpilConnectionManager scm = GetConnectionManager(i))
                    {
                        SvcOffer so = new SvcOffer(); bool bThrown = false;

                        ConfigureSvcOffer(so, i);

                        // NOTE: on the NonQuery calls, the results[] array contains the rowcount affected for each time the SP is exec'd,
                        //       and _not_ the return value from executing the SP
                        //
                        // Reference
                        // public virtual int[] SvcInsertTitleVersions(
                        //  ISpilConnectionManager scm,
                        //  SqlInt32 i_title_id,
                        //  SqlInt32 i_base_version,
                        //  SqlInt32 i_new_version,
                        //  SqlInt32 i_version_flag) {
                        //
                        try
                        {
                            int[] results = so.SvcInsertTitleVersions(scm
                                , (int)titleID
                                , titleBaseVersion
                                , titleNewVersion
                                , versionFlag
                                , SqlByte.Null
                                );

                        }
                        catch { bThrown = true; throw; }
                        finally { ErrorCheck(so.Context, Convert.ToString(TargetDBs[i]), bThrown); }
                    }
                }
            }
        }

        //p_svc_insert_subscriptions, in the same order as the procedure..  ONLY USE IT FOR XBOX
        static void p_svc_insert_subscriptions_xbox(uint titleID, ulong offerID, ushort esrb,
            bool cancelable, int packageSize, int installSize, byte[] symKey,
            int bitFilter, string billingSvcComponentID, int offerType, int offerFrequency,
            DateTime startDate, DateTime endDate, string friendlyName, byte[] pubKey, uint policyFlags,
            uint globalOfferDetails)
        {
            p_svc_insert_subscriptions_EX(new[] { titleID }, offerID, esrb,
            cancelable, packageSize, installSize, symKey,
            bitFilter, billingSvcComponentID, offerType, offerFrequency,
            startDate, endDate, friendlyName, pubKey, policyFlags,
            globalOfferDetails, ConsoleTypeEnum.Xbox1);
        }

        //p_svc_insert_subscriptions, in the same order as the procedure..  ONLY USE IT FOR XBOX
        static void p_svc_insert_subscriptions_EX(uint[] titleIDs, ulong offerID, ushort esrb,
            bool cancelable, int packageSize, int installSize, byte[] symKeyIn,
            int bitFilter, string billingComponentID, int offerType, int offerFrequency,
            DateTime startDate, DateTime endDate, string friendlyName, byte[] pubKeyIn, uint policyFlags,
            uint globalOfferDetails, ConsoleTypeEnum consoleType)
        {
            byte[] symKey = (symKeyIn == null ? new byte[16] : symKeyIn);
            byte[] publicKey = (pubKeyIn == null ? new byte[284] : pubKeyIn);

            for (int i = 0; i < maxTypes; i++)
            {
                // check if we are being asked to prop this particular db type
                if (0 != ((int)target & (int)TargetDBs[i]))
                {
                    using (ISpilConnectionManager scm = GetConnectionManager(i))
                    {
                        SvcOffer so = new SvcOffer(); bool bThrown = false;

                        ConfigureSvcOffer(so, i);

                        // NOTE: on the NonQuery calls, the results[] array contains the rowcount affected for each time the SP is exec'd,
                        //       and _not_ the return value from executing the SP
                        //
                        // Reference
                        //  public virtual int[] SvcInsertSubscriptionsMultiTitle(
                        //      ISpilConnectionManager scm,
                        //      SqlXml xml_title_ids,
                        //      SqlInt64 bi_offer_id,
                        //      SqlInt32 i_ESRB_id,
                        //      SqlByte b_cancelable,
                        //      SqlInt32 i_package_size,
                        //      SqlInt32 i_install_size,
                        //      SqlBinary vb_sym_key,
                        //      SqlInt32 i_bitfilter,
                        //      string vc_billing_svc_component_id,
                        //      SqlInt32 i_offer_type_id,
                        //      SqlInt32 i_offer_frequency_id,
                        //      SqlDateTime dt_start_date,
                        //      SqlDateTime dt_end_date,
                        //      string vc_friendly_name,
                        //      SqlBinary vb_public_key,
                        //      SqlInt32 i_policy_flags,
                        //      SqlInt16 si_global_offer_details,
                        //      SqlByte ti_console_type_id)
                        //
                        try
                        {
                            int[] results = so.SvcInsertSubscriptionsMultiTitle(scm
                                , MarshalToXml(titleIDs)
                                , (long)offerID
                                , (short)esrb // i_ESRB_id : legacy
                                , (byte)(cancelable ? 1 : 0) // b_cancelable : legacy
                                , packageSize // i_package_size : not applicable to subscription offers
                                , installSize // i_install_size : not applicable to subscription offers
                                , symKey // not applicable to subscription offers
                                , (int)bitFilter
                                , billingComponentID
                                , offerType
                                , offerFrequency // i_offer_frequency_id : legacy
                                , startDate // dt_start_date : legacy
                                , endDate // dt_end_date : legacy
                                , friendlyName
                                , publicKey // not applicable to subscription offers
                                , (int)policyFlags
                                , (short)globalOfferDetails
                                , (byte)consoleType
                                );

                        }
                        catch { bThrown = true; throw; }
                        finally { ErrorCheck(so.Context, Convert.ToString(TargetDBs[i]), bThrown); }
                    }
                }
            }
        }

        static SqlXml MarshalToXml(uint[] values)
        {
            var builder = new StringBuilder();

            // N.B. conversion to int before serialization
            foreach (int value in values)
            {
                builder.AppendFormat("<item value='{0}'/>", value);
            }

            return new SqlXml(new MemoryStream(Encoding.ASCII.GetBytes(builder.ToString())));
        }

        //p_svc_insert_content
        //p_svc_insert_content_locations

        #endregion

    }


    public class OfferPrivilegeGrants : OfferPrivileges
    {
        public OfferPrivilegeGrants()
            : base()
        {
        }

        public OfferPrivilegeGrants(uint[] privileges)
            : base(privileges)
        {
        }

        override public string StoredProcedure
        {
            get { return "dbo.p_svc_insert_offer_privileges"; }
        }
    }

    public class OfferPrivilegeRestrictions : OfferPrivileges
    {
        public OfferPrivilegeRestrictions()
            : base()
        {
        }

        public OfferPrivilegeRestrictions(uint[] privileges)
            : base(privileges)
        {
        }

        override public string StoredProcedure
        {
            get { return "dbo.p_svc_insert_offer_privilege_restrictions"; }
        }
    }

    public abstract class OfferPrivileges
    {
        /*

        Privileges are stored as single bits in a field of 256 bits.  Bits are stored
        with the high bits being stored in the first of the 32 bytes in the array,
        and so on.

        */

        public const int NUM_PRIVILEGE_BITS = 256;
        public const int NUM_PRIVILEGE_DWORDS = NUM_PRIVILEGE_BITS / 32;

        public OfferPrivileges()
        {
            m_privileges = new uint[NUM_PRIVILEGE_DWORDS];

            for (int i = 0; i < NUM_PRIVILEGE_DWORDS; i++)
                m_privileges[i] = 0;
        }

        public OfferPrivileges(uint[] privileges)
        {
            if (privileges.Length != NUM_PRIVILEGE_DWORDS)
                throw new Exception("Expecting exactly " + NUM_PRIVILEGE_DWORDS + " privilege bytes");

            m_privileges = privileges;
        }

        public override string ToString()
        {
            // generates a string of 0's and 1's which represent the 256 privileges
            // the first 1 or 0 corresponds to privilege #0, and so on...

            StringBuilder privileges = new StringBuilder(NUM_PRIVILEGE_BITS);

            for (int i = 0; i < NUM_PRIVILEGE_BITS; i++)
            {
                if (this[i] == true)
                    privileges.Append('1');
                else
                    privileges.Append('0');
            }

            return privileges.ToString();
        }

        public void Save(ulong offerID)
        {
            using (WstConnection c = new WstConnection(ConfigUtil.UodbWebstoreApp))
            {
                c.Open();

                for (int partition = 0; partition < c.SqlPartitions.Count; partition++)
                {
                    using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
                    {
                        ws.PhysicalPartition = partition;
                        ws.StoredProc = this.StoredProcedure;

                        ws.AddParameter(ParamType.RETVAL, "@ret", 0);
                        ws.AddParameter(ParamType.INPUT, "@bi_offer_id", offerID);
                        ws.AddParameter(ParamType.INPUT, "@vc_privileges", this.ToString(), NUM_PRIVILEGE_BITS);

                        ws.ExecuteNonQuery();

                        uint hr = (uint)ws.GetIntParameter("@ret");
                        if (HResult.Failed(hr))
                        {
                            string msg = ws.GetCallSignature() + " failed with hr = 0x" + hr.ToString("x");

                            throw new XRLException(hr, XEvent.Id.COMMON_CODE_145, msg);
                        }

                        Console.WriteLine();
                        Console.WriteLine(ws.GetCallSignature());
                    }
                }
            }
        }

        public bool this[int index]
        {
            // get or set individual bits within the privilege set

            get
            {
                uint ul = m_privileges[index / 32];
                uint mask = (uint)1 << (index % 32);

                return (ul & mask) == mask;
            }

            set
            {
                uint ul = m_privileges[index / 32];
                uint mask = (uint)1 << (index % 32);

                if (value == true)
                    ul = ul | mask;
                else
                    ul = ul & ~mask;

                m_privileges[index / 32] = ul;
            }
        }

        public uint[] ToArray()
        {
            return m_privileges;
        }

        uint[] m_privileges;

        public abstract string StoredProcedure
        {
            get;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\offerutil\offerutil\Xbox1Offer.cs ===
// Copyright 2004, Microsoft Corporation
// Sample Code - Use restricted to terms of use defined in the accompanying license agreement (EULA.doc)

//--------------------------------------------------------------
// Autogenerated by XSDObjectGen version 1.4.2.0
// Schema file: Xbox1Offer.xsd
// Creation Date: 9/12/2005 1:48:39 AM
//--------------------------------------------------------------

using System;
using System.Xml.Serialization;
using System.Collections;
using System.Xml.Schema;
using System.ComponentModel;

namespace xonline.common.xboxofferutil
{

	public struct Declarations
	{
		public const string SchemaVersion = "http://www.xboxlive.com/xboxoffer";
	}

	[Serializable]
	public enum XboxESRB
	{
		[XmlEnum(Name="All")] All,
		[XmlEnum(Name="Adult")] Adult,
		[XmlEnum(Name="Mature")] Mature,
		[XmlEnum(Name="Teen")] Teen,
		[XmlEnum(Name="Everyone")] Everyone,
		[XmlEnum(Name="Kids to Adults")] Kids_to_Adults,
		[XmlEnum(Name="Early Childhood")] Early_Childhood
	}

	[Serializable]
	public enum XboxOfferFrequency
	{
		[XmlEnum(Name="OneTimeCharge")] OneTimeCharge,
		[XmlEnum(Name="Monthly")] Monthly,
		[XmlEnum(Name="Quarterly")] Quarterly,
		[XmlEnum(Name="BiAnnually")] BiAnnually,
		[XmlEnum(Name="Annually")] Annually
	}


	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class XboxOfferDescriptionCollection : ArrayList
	{
		public xonline.common.xboxofferutil.XboxOfferDescription Add(xonline.common.xboxofferutil.XboxOfferDescription obj)
		{
			base.Add(obj);
			return obj;
		}

		public xonline.common.xboxofferutil.XboxOfferDescription Add()
		{
			return Add(new xonline.common.xboxofferutil.XboxOfferDescription());
		}

		public void Insert(int index, xonline.common.xboxofferutil.XboxOfferDescription obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(xonline.common.xboxofferutil.XboxOfferDescription obj)
		{
			base.Remove(obj);
		}

		new public xonline.common.xboxofferutil.XboxOfferDescription this[int index]
		{
			get { return (xonline.common.xboxofferutil.XboxOfferDescription) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class XboxSubscriptionCollection : ArrayList
	{
		public XboxSubscription Add(XboxSubscription obj)
		{
			base.Add(obj);
			return obj;
		}

		public XboxSubscription Add()
		{
			return Add(new XboxSubscription());
		}

		public void Insert(int index, XboxSubscription obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(XboxSubscription obj)
		{
			base.Remove(obj);
		}

		new public XboxSubscription this[int index]
		{
			get { return (XboxSubscription) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class XboxOfferRelationsCollection : ArrayList
	{
		public xonline.common.xboxofferutil.XboxOfferRelations Add(xonline.common.xboxofferutil.XboxOfferRelations obj)
		{
			base.Add(obj);
			return obj;
		}

		public xonline.common.xboxofferutil.XboxOfferRelations Add()
		{
			return Add(new xonline.common.xboxofferutil.XboxOfferRelations());
		}

		public void Insert(int index, xonline.common.xboxofferutil.XboxOfferRelations obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(xonline.common.xboxofferutil.XboxOfferRelations obj)
		{
			base.Remove(obj);
		}

		new public xonline.common.xboxofferutil.XboxOfferRelations this[int index]
		{
			get { return (xonline.common.xboxofferutil.XboxOfferRelations) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class XboxOfferLocationsCollection : ArrayList
	{
		public xonline.common.xboxofferutil.XboxOfferLocations Add(xonline.common.xboxofferutil.XboxOfferLocations obj)
		{
			base.Add(obj);
			return obj;
		}

		public xonline.common.xboxofferutil.XboxOfferLocations Add()
		{
			return Add(new xonline.common.xboxofferutil.XboxOfferLocations());
		}

		public void Insert(int index, xonline.common.xboxofferutil.XboxOfferLocations obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(xonline.common.xboxofferutil.XboxOfferLocations obj)
		{
			base.Remove(obj);
		}

		new public xonline.common.xboxofferutil.XboxOfferLocations this[int index]
		{
			get { return (xonline.common.xboxofferutil.XboxOfferLocations) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class XboxUpdateCollection : ArrayList
	{
		public XboxUpdate Add(XboxUpdate obj)
		{
			base.Add(obj);
			return obj;
		}

		public XboxUpdate Add()
		{
			return Add(new XboxUpdate());
		}

		public void Insert(int index, XboxUpdate obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(XboxUpdate obj)
		{
			base.Remove(obj);
		}

		new public XboxUpdate this[int index]
		{
			get { return (XboxUpdate) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class XboxOfferRegionsCollection : ArrayList
	{
		public xonline.common.xboxofferutil.XboxOfferRegions Add(xonline.common.xboxofferutil.XboxOfferRegions obj)
		{
			base.Add(obj);
			return obj;
		}

		public xonline.common.xboxofferutil.XboxOfferRegions Add()
		{
			return Add(new xonline.common.xboxofferutil.XboxOfferRegions());
		}

		public void Insert(int index, xonline.common.xboxofferutil.XboxOfferRegions obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(xonline.common.xboxofferutil.XboxOfferRegions obj)
		{
			base.Remove(obj);
		}

		new public xonline.common.xboxofferutil.XboxOfferRegions this[int index]
		{
			get { return (xonline.common.xboxofferutil.XboxOfferRegions) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class XboxOfferDescriptionDetailsCollection : ArrayList
	{
		public xonline.common.xboxofferutil.XboxOfferDescriptionDetails Add(xonline.common.xboxofferutil.XboxOfferDescriptionDetails obj)
		{
			base.Add(obj);
			return obj;
		}

		public xonline.common.xboxofferutil.XboxOfferDescriptionDetails Add()
		{
			return Add(new xonline.common.xboxofferutil.XboxOfferDescriptionDetails());
		}

		public void Insert(int index, xonline.common.xboxofferutil.XboxOfferDescriptionDetails obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(xonline.common.xboxofferutil.XboxOfferDescriptionDetails obj)
		{
			base.Remove(obj);
		}

		new public xonline.common.xboxofferutil.XboxOfferDescriptionDetails this[int index]
		{
			get { return (xonline.common.xboxofferutil.XboxOfferDescriptionDetails) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class XboxOfferServicesCollection : ArrayList
	{
		public xonline.common.xboxofferutil.XboxOfferServices Add(xonline.common.xboxofferutil.XboxOfferServices obj)
		{
			base.Add(obj);
			return obj;
		}

		public xonline.common.xboxofferutil.XboxOfferServices Add()
		{
			return Add(new xonline.common.xboxofferutil.XboxOfferServices());
		}

		public void Insert(int index, xonline.common.xboxofferutil.XboxOfferServices obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(xonline.common.xboxofferutil.XboxOfferServices obj)
		{
			base.Remove(obj);
		}

		new public xonline.common.xboxofferutil.XboxOfferServices this[int index]
		{
			get { return (xonline.common.xboxofferutil.XboxOfferServices) base[index]; }
			set { base[index] = value; }
		}
	}



	[XmlType(TypeName="XboxOfferDescription",Namespace=Declarations.SchemaVersion),Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class XboxOfferDescription
	{

		[XmlAttribute(AttributeName="liveOfferID",DataType="long")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public long __liveOfferID;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __liveOfferIDSpecified;
		
		[XmlIgnore]
		public long liveOfferID
		{ 
			get { return __liveOfferID; }
			set { __liveOfferID = value; __liveOfferIDSpecified = true; }
		}

		[XmlAttribute(AttributeName="detailsBlob",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __detailsBlob;
		
		[XmlIgnore]
		public string detailsBlob
		{ 
			get { return __detailsBlob; }
			set { __detailsBlob = value; }
		}

		[XmlAttribute(AttributeName="descriptionIndex",DataType="unsignedInt")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __descriptionIndex;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __descriptionIndexSpecified;
		
		[XmlIgnore]
		public uint descriptionIndex
		{ 
			get { return __descriptionIndex; }
			set { __descriptionIndex = value; __descriptionIndexSpecified = true; }
		}

		[XmlAttribute(AttributeName="blobBase64",DataType="boolean")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __blobBase64;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __blobBase64Specified;
		
		[XmlIgnore]
		public bool blobBase64
		{ 
			get { return __blobBase64; }
			set { __blobBase64 = value; __blobBase64Specified = true; }
		}

		public XboxOfferDescription()
		{
		}
	}


	[XmlType(TypeName="XboxOfferRelations",Namespace=Declarations.SchemaVersion),Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class XboxOfferRelations
	{

		[XmlAttribute(AttributeName="offerID",DataType="long")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public long __offerID;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __offerIDSpecified;
		
		[XmlIgnore]
		public long offerID
		{ 
			get { return __offerID; }
			set { __offerID = value; __offerIDSpecified = true; }
		}

		[XmlAttribute(AttributeName="relatedOfferID",DataType="long")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public long __relatedOfferID;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __relatedOfferIDSpecified;
		
		[XmlIgnore]
		public long relatedOfferID
		{ 
			get { return __relatedOfferID; }
			set { __relatedOfferID = value; __relatedOfferIDSpecified = true; }
		}

		[XmlAttribute(AttributeName="relationTypeID",DataType="unsignedInt")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __relationTypeID;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __relationTypeIDSpecified;
		
		[XmlIgnore]
		public uint relationTypeID
		{ 
			get { return __relationTypeID; }
			set { __relationTypeID = value; __relationTypeIDSpecified = true; }
		}

		[XmlAttribute(AttributeName="convertMode",DataType="int")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public int __convertMode;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __convertModeSpecified;
		
		[XmlIgnore]
		public int convertMode
		{ 
			get { return __convertMode; }
			set { __convertMode = value; __convertModeSpecified = true; }
		}

		public XboxOfferRelations()
		{
		}
	}


	[XmlType(TypeName="XboxSubscriptionBasicInfo",Namespace=Declarations.SchemaVersion),Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class XboxSubscriptionBasicInfo
	{

		[XmlAttribute(AttributeName="titleID",DataType="long")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public long __titleID;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __titleIDSpecified;
		
		[XmlIgnore]
		public long titleID
		{ 
			get { return __titleID; }
			set { __titleID = value; __titleIDSpecified = true; }
		}

		[XmlAttribute(AttributeName="offerID",DataType="long")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public long __offerID;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __offerIDSpecified;
		
		[XmlIgnore]
		public long offerID
		{ 
			get { return __offerID; }
			set { __offerID = value; __offerIDSpecified = true; }
		}

		[XmlAttribute(AttributeName="ESRB",DataType="unsignedByte")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public byte __ESRB;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __ESRBSpecified;
		
		[XmlIgnore]
		public byte ESRB
		{ 
			get { return __ESRB; }
			set { __ESRB = value; __ESRBSpecified = true; }
		}

		[XmlAttribute(AttributeName="cancellable",DataType="boolean")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __cancellable;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __cancellableSpecified;
		
		[XmlIgnore]
		public bool cancellable
		{ 
			get { return __cancellable; }
			set { __cancellable = value; __cancellableSpecified = true; }
		}

		[XmlAttribute(AttributeName="packageSize",DataType="unsignedInt")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __packageSize;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __packageSizeSpecified;
		
		[XmlIgnore]
		public uint packageSize
		{ 
			get { return __packageSize; }
			set { __packageSize = value; __packageSizeSpecified = true; }
		}

		[XmlAttribute(AttributeName="installSize",DataType="unsignedInt")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __installSize;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __installSizeSpecified;
		
		[XmlIgnore]
		public uint installSize
		{ 
			get { return __installSize; }
			set { __installSize = value; __installSizeSpecified = true; }
		}

		[XmlAttribute(AttributeName="symKey",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __symKey;
		
		[XmlIgnore]
		public string symKey
		{ 
			get { return __symKey; }
			set { __symKey = value; }
		}

		[XmlAttribute(AttributeName="bitFilter",DataType="int")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public int __bitFilter;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __bitFilterSpecified;
		
		[XmlIgnore]
		public int bitFilter
		{ 
			get { return __bitFilter; }
			set { __bitFilter = value; __bitFilterSpecified = true; }
		}

		[XmlAttribute(AttributeName="billingSvcComponentID",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __billingSvcComponentID;
		
		[XmlIgnore]
		public string billingSvcComponentID
		{ 
			get { return __billingSvcComponentID; }
			set { __billingSvcComponentID = value; }
		}

		[XmlAttribute(AttributeName="offerTypeID",DataType="unsignedInt")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __offerTypeID;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __offerTypeIDSpecified;
		
		[XmlIgnore]
		public uint offerTypeID
		{ 
			get { return __offerTypeID; }
			set { __offerTypeID = value; __offerTypeIDSpecified = true; }
		}

		[XmlAttribute(AttributeName="offerFrequency",DataType="unsignedByte")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public byte __offerFrequency;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __offerFrequencySpecified;
		
		[XmlIgnore]
		public byte offerFrequency
		{ 
			get { return __offerFrequency; }
			set { __offerFrequency = value; __offerFrequencySpecified = true; }
		}

		[XmlAttribute(AttributeName="startDate",DataType="dateTime")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public DateTime __startDate;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __startDateSpecified;
		
		[XmlIgnore]
		public DateTime startDate
		{ 
			get { return __startDate; }
			set { __startDate = value; __startDateSpecified = true; }
		}
		
		[XmlIgnore]
		public DateTime startDateUtc
		{ 
			get { return __startDate.ToUniversalTime(); }
			set { __startDate = value.ToLocalTime(); __startDateSpecified = true; }
		}

		[XmlAttribute(AttributeName="endDate",DataType="dateTime")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public DateTime __endDate;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __endDateSpecified;
		
		[XmlIgnore]
		public DateTime endDate
		{ 
			get { return __endDate; }
			set { __endDate = value; __endDateSpecified = true; }
		}
		
		[XmlIgnore]
		public DateTime endDateUtc
		{ 
			get { return __endDate.ToUniversalTime(); }
			set { __endDate = value.ToLocalTime(); __endDateSpecified = true; }
		}

		[XmlAttribute(AttributeName="friendlyName",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __friendlyName;
		
		[XmlIgnore]
		public string friendlyName
		{ 
			get { return __friendlyName; }
			set { __friendlyName = value; }
		}

		[XmlAttribute(AttributeName="publicKey",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __publicKey;
		
		[XmlIgnore]
		public string publicKey
		{ 
			get { return __publicKey; }
			set { __publicKey = value; }
		}

		[XmlAttribute(AttributeName="policyFlags",DataType="unsignedInt")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __policyFlags;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __policyFlagsSpecified;
		
		[XmlIgnore]
		public uint policyFlags
		{ 
			get { return __policyFlags; }
			set { __policyFlags = value; __policyFlagsSpecified = true; }
		}

		[XmlAttribute(AttributeName="globalOfferDetails",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __globalOfferDetails;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __globalOfferDetailsSpecified;
		
		[XmlIgnore]
		public ushort globalOfferDetails
		{ 
			get { return __globalOfferDetails; }
			set { __globalOfferDetails = value; __globalOfferDetailsSpecified = true; }
		}

		public XboxSubscriptionBasicInfo()
		{
			__startDate = DateTime.Now;
			__endDate = DateTime.Now;
		}
	}


	[XmlType(TypeName="XboxOfferLocations",Namespace=Declarations.SchemaVersion),Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class XboxOfferLocations
	{

		[XmlAttribute(AttributeName="offerID",DataType="long")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public long __offerID;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __offerIDSpecified;
		
		[XmlIgnore]
		public long offerID
		{ 
			get { return __offerID; }
			set { __offerID = value; __offerIDSpecified = true; }
		}

		[XmlAttribute(AttributeName="locationRank",DataType="unsignedInt")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __locationRank;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __locationRankSpecified;
		
		[XmlIgnore]
		public uint locationRank
		{ 
			get { return __locationRank; }
			set { __locationRank = value; __locationRankSpecified = true; }
		}

		[XmlAttribute(AttributeName="XRL",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __XRL;
		
		[XmlIgnore]
		public string XRL
		{ 
			get { return __XRL; }
			set { __XRL = value; }
		}

		public XboxOfferLocations()
		{
		}
	}


	[XmlType(TypeName="XboxTitleUpdatePackage",Namespace=Declarations.SchemaVersion),Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class XboxTitleUpdatePackage
	{

		[XmlAttribute(AttributeName="titleID",DataType="long")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public long __titleID;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __titleIDSpecified;
		
		[XmlIgnore]
		public long titleID
		{ 
			get { return __titleID; }
			set { __titleID = value; __titleIDSpecified = true; }
		}

		[XmlAttribute(AttributeName="titleBaseVersion",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __titleBaseVersion;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __titleBaseVersionSpecified;
		
		[XmlIgnore]
		public ushort titleBaseVersion
		{ 
			get { return __titleBaseVersion; }
			set { __titleBaseVersion = value; __titleBaseVersionSpecified = true; }
		}

		[XmlAttribute(AttributeName="titleUpdateVersion",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __titleUpdateVersion;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __titleUpdateVersionSpecified;
		
		[XmlIgnore]
		public ushort titleUpdateVersion
		{ 
			get { return __titleUpdateVersion; }
			set { __titleUpdateVersion = value; __titleUpdateVersionSpecified = true; }
		}

		[XmlAttribute(AttributeName="packageSize",DataType="unsignedInt")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __packageSize;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __packageSizeSpecified;
		
		[XmlIgnore]
		public uint packageSize
		{ 
			get { return __packageSize; }
			set { __packageSize = value; __packageSizeSpecified = true; }
		}

		[XmlAttribute(AttributeName="installSize",DataType="unsignedInt")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __installSize;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __installSizeSpecified;
		
		[XmlIgnore]
		public uint installSize
		{ 
			get { return __installSize; }
			set { __installSize = value; __installSizeSpecified = true; }
		}

		[XmlAttribute(AttributeName="symKey",DataType="hexBinary")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public byte[] __symKey;
		
		[XmlIgnore]
		public byte[] symKey
		{ 
			get { return __symKey; }
			set { __symKey = value; }
		}

		[XmlAttribute(AttributeName="publicKey",DataType="hexBinary")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public byte[] __publicKey;
		
		[XmlIgnore]
		public byte[] publicKey
		{ 
			get { return __publicKey; }
			set { __publicKey = value; }
		}

		public XboxTitleUpdatePackage()
		{
		}
	}


	[XmlType(TypeName="XboxOfferRegions",Namespace=Declarations.SchemaVersion),Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class XboxOfferRegions
	{

		[XmlAttribute(AttributeName="liveOfferID",DataType="long")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public long __liveOfferID;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __liveOfferIDSpecified;
		
		[XmlIgnore]
		public long liveOfferID
		{ 
			get { return __liveOfferID; }
			set { __liveOfferID = value; __liveOfferIDSpecified = true; }
		}

		[XmlAttribute(AttributeName="countryID",DataType="unsignedByte")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public byte __countryID;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __countryIDSpecified;
		
		[XmlIgnore]
		public byte countryID
		{ 
			get { return __countryID; }
			set { __countryID = value; __countryIDSpecified = true; }
		}

		[XmlAttribute(AttributeName="billingOfferID",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __billingOfferID;
		
		[XmlIgnore]
		public string billingOfferID
		{ 
			get { return __billingOfferID; }
			set { __billingOfferID = value; }
		}

		[XmlAttribute(AttributeName="priceWhole",DataType="unsignedInt")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __priceWhole;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __priceWholeSpecified;
		
		[XmlIgnore]
		public uint priceWhole
		{ 
			get { return __priceWhole; }
			set { __priceWhole = value; __priceWholeSpecified = true; }
		}

		[XmlAttribute(AttributeName="priceFractional",DataType="unsignedInt")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __priceFractional;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __priceFractionalSpecified;
		
		[XmlIgnore]
		public uint priceFractional
		{ 
			get { return __priceFractional; }
			set { __priceFractional = value; __priceFractionalSpecified = true; }
		}

		[XmlAttribute(AttributeName="specificOfferDetails",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __specificOfferDetails;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __specificOfferDetailsSpecified;
		
		[XmlIgnore]
		public ushort specificOfferDetails
		{ 
			get { return __specificOfferDetails; }
			set { __specificOfferDetails = value; __specificOfferDetailsSpecified = true; }
		}

		public XboxOfferRegions()
		{
		}
	}


	[XmlType(TypeName="XboxTitleVersion",Namespace=Declarations.SchemaVersion),Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class XboxTitleVersion
	{

		[XmlAttribute(AttributeName="titleID",DataType="long")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public long __titleID;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __titleIDSpecified;
		
		[XmlIgnore]
		public long titleID
		{ 
			get { return __titleID; }
			set { __titleID = value; __titleIDSpecified = true; }
		}

		[XmlAttribute(AttributeName="titleBaseVersion",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __titleBaseVersion;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __titleBaseVersionSpecified;
		
		[XmlIgnore]
		public ushort titleBaseVersion
		{ 
			get { return __titleBaseVersion; }
			set { __titleBaseVersion = value; __titleBaseVersionSpecified = true; }
		}

		[XmlAttribute(AttributeName="titleNewVersion",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __titleNewVersion;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __titleNewVersionSpecified;
		
		[XmlIgnore]
		public ushort titleNewVersion
		{ 
			get { return __titleNewVersion; }
			set { __titleNewVersion = value; __titleNewVersionSpecified = true; }
		}

		[XmlAttribute(AttributeName="versionFlag",DataType="unsignedByte")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public byte __versionFlag;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __versionFlagSpecified;
		
		[XmlIgnore]
		public byte versionFlag
		{ 
			get { return __versionFlag; }
			set { __versionFlag = value; __versionFlagSpecified = true; }
		}

		public XboxTitleVersion()
		{
		}
	}


	[XmlType(TypeName="LiveServiceInstance",Namespace=Declarations.SchemaVersion),Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class LiveServiceInstance
	{

		[XmlAttribute(AttributeName="serviceID",DataType="int")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public int __serviceID;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __serviceIDSpecified;
		
		[XmlIgnore]
		public int serviceID
		{ 
			get { return __serviceID; }
			set { __serviceID = value; __serviceIDSpecified = true; }
		}

		[XmlAttribute(AttributeName="siteID",DataType="int")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public int __siteID;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __siteIDSpecified;
		
		[XmlIgnore]
		public int siteID
		{ 
			get { return __siteID; }
			set { __siteID = value; __siteIDSpecified = true; }
		}

		[XmlAttribute(AttributeName="titleID",DataType="int")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public int __titleID;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __titleIDSpecified;
		
		[XmlIgnore]
		public int titleID
		{ 
			get { return __titleID; }
			set { __titleID = value; __titleIDSpecified = true; }
		}

		[XmlAttribute(AttributeName="titleVersion",DataType="int")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public int __titleVersion;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __titleVersionSpecified;
		
		[XmlIgnore]
		public int titleVersion
		{ 
			get { return __titleVersion; }
			set { __titleVersion = value; __titleVersionSpecified = true; }
		}

		[XmlAttribute(AttributeName="titleRegion",DataType="int")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public int __titleRegion;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __titleRegionSpecified;
		
		[XmlIgnore]
		public int titleRegion
		{ 
			get { return __titleRegion; }
			set { __titleRegion = value; __titleRegionSpecified = true; }
		}

		[XmlAttribute(AttributeName="port",DataType="int")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public int __port;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __portSpecified;
		
		[XmlIgnore]
		public int port
		{ 
			get { return __port; }
			set { __port = value; __portSpecified = true; }
		}

		[XmlAttribute(AttributeName="serviceAvailable",DataType="int")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public int __serviceAvailable;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __serviceAvailableSpecified;
		
		[XmlIgnore]
		public int serviceAvailable
		{ 
			get { return __serviceAvailable; }
			set { __serviceAvailable = value; __serviceAvailableSpecified = true; }
		}

		public LiveServiceInstance()
		{
		}
	}


	[XmlType(TypeName="LiveService",Namespace=Declarations.SchemaVersion),Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class LiveService
	{

		[XmlAttribute(AttributeName="serviceID",DataType="int")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public int __serviceID;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __serviceIDSpecified;
		
		[XmlIgnore]
		public int serviceID
		{ 
			get { return __serviceID; }
			set { __serviceID = value; __serviceIDSpecified = true; }
		}

		[XmlAttribute(AttributeName="kerbServiceName",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __kerbServiceName;
		
		[XmlIgnore]
		public string kerbServiceName
		{ 
			get { return __kerbServiceName; }
			set { __kerbServiceName = value; }
		}

		[XmlAttribute(AttributeName="kerbDomainName",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __kerbDomainName;
		
		[XmlIgnore]
		public string kerbDomainName
		{ 
			get { return __kerbDomainName; }
			set { __kerbDomainName = value; }
		}

		[XmlAttribute(AttributeName="machineOnly",DataType="int")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public int __machineOnly;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __machineOnlySpecified;
		
		[XmlIgnore]
		public int machineOnly
		{ 
			get { return __machineOnly; }
			set { __machineOnly = value; __machineOnlySpecified = true; }
		}

		public LiveService()
		{
		}
	}


	[XmlType(TypeName="XboxOfferBasicInfo",Namespace=Declarations.SchemaVersion),Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class XboxOfferBasicInfo
	{

		[XmlAttribute(AttributeName="titleID",DataType="long")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public long __titleID;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __titleIDSpecified;
		
		[XmlIgnore]
		public long titleID
		{ 
			get { return __titleID; }
			set { __titleID = value; __titleIDSpecified = true; }
		}

		[XmlAttribute(AttributeName="offerID",DataType="long")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public long __offerID;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __offerIDSpecified;
		
		[XmlIgnore]
		public long offerID
		{ 
			get { return __offerID; }
			set { __offerID = value; __offerIDSpecified = true; }
		}

		[XmlAttribute(AttributeName="ESRB",DataType="unsignedByte")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public byte __ESRB;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __ESRBSpecified;
		
		[XmlIgnore]
		public byte ESRB
		{ 
			get { return __ESRB; }
			set { __ESRB = value; __ESRBSpecified = true; }
		}

		[XmlAttribute(AttributeName="packageSize",DataType="unsignedInt")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __packageSize;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __packageSizeSpecified;
		
		[XmlIgnore]
		public uint packageSize
		{ 
			get { return __packageSize; }
			set { __packageSize = value; __packageSizeSpecified = true; }
		}

		[XmlAttribute(AttributeName="installSize",DataType="unsignedInt")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __installSize;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __installSizeSpecified;
		
		[XmlIgnore]
		public uint installSize
		{ 
			get { return __installSize; }
			set { __installSize = value; __installSizeSpecified = true; }
		}

		[XmlAttribute(AttributeName="symKey",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __symKey;
		
		[XmlIgnore]
		public string symKey
		{ 
			get { return __symKey; }
			set { __symKey = value; }
		}

		[XmlAttribute(AttributeName="bitFilter",DataType="int")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public int __bitFilter;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __bitFilterSpecified;
		
		[XmlIgnore]
		public int bitFilter
		{ 
			get { return __bitFilter; }
			set { __bitFilter = value; __bitFilterSpecified = true; }
		}

		[XmlAttribute(AttributeName="billingSvcComponentID",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __billingSvcComponentID;
		
		[XmlIgnore]
		public string billingSvcComponentID
		{ 
			get { return __billingSvcComponentID; }
			set { __billingSvcComponentID = value; }
		}

		[XmlAttribute(AttributeName="offerTypeID",DataType="unsignedInt")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __offerTypeID;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __offerTypeIDSpecified;
		
		[XmlIgnore]
		public uint offerTypeID
		{ 
			get { return __offerTypeID; }
			set { __offerTypeID = value; __offerTypeIDSpecified = true; }
		}

		[XmlAttribute(AttributeName="startDate",DataType="dateTime")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public DateTime __startDate;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __startDateSpecified;
		
		[XmlIgnore]
		public DateTime startDate
		{ 
			get { return __startDate; }
			set { __startDate = value; __startDateSpecified = true; }
		}
		
		[XmlIgnore]
		public DateTime startDateUtc
		{ 
			get { return __startDate.ToUniversalTime(); }
			set { __startDate = value.ToLocalTime(); __startDateSpecified = true; }
		}

		[XmlAttribute(AttributeName="endDate",DataType="dateTime")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public DateTime __endDate;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __endDateSpecified;
		
		[XmlIgnore]
		public DateTime endDate
		{ 
			get { return __endDate; }
			set { __endDate = value; __endDateSpecified = true; }
		}
		
		[XmlIgnore]
		public DateTime endDateUtc
		{ 
			get { return __endDate.ToUniversalTime(); }
			set { __endDate = value.ToLocalTime(); __endDateSpecified = true; }
		}

		[XmlAttribute(AttributeName="friendlyName",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __friendlyName;
		
		[XmlIgnore]
		public string friendlyName
		{ 
			get { return __friendlyName; }
			set { __friendlyName = value; }
		}

		[XmlAttribute(AttributeName="publicKey",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __publicKey;
		
		[XmlIgnore]
		public string publicKey
		{ 
			get { return __publicKey; }
			set { __publicKey = value; }
		}

		[XmlAttribute(AttributeName="policyFlags",DataType="unsignedInt")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __policyFlags;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __policyFlagsSpecified;
		
		[XmlIgnore]
		public uint policyFlags
		{ 
			get { return __policyFlags; }
			set { __policyFlags = value; __policyFlagsSpecified = true; }
		}

		[XmlAttribute(AttributeName="consoleTypeID",DataType="unsignedInt")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __consoleTypeID;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __consoleTypeIDSpecified;
		
		[XmlIgnore]
		public uint consoleTypeID
		{ 
			get { return __consoleTypeID; }
			set { __consoleTypeID = value; __consoleTypeIDSpecified = true; }
		}

		public XboxOfferBasicInfo()
		{
			__startDate = DateTime.Now;
			__endDate = DateTime.Now;
		}
	}


	[XmlType(TypeName="XboxOfferDescriptionDetails",Namespace=Declarations.SchemaVersion),Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class XboxOfferDescriptionDetails
	{

		[XmlAttribute(AttributeName="liveOfferID",DataType="long")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public long __liveOfferID;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __liveOfferIDSpecified;
		
		[XmlIgnore]
		public long liveOfferID
		{ 
			get { return __liveOfferID; }
			set { __liveOfferID = value; __liveOfferIDSpecified = true; }
		}

		[XmlAttribute(AttributeName="detailsBlob",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __detailsBlob;
		
		[XmlIgnore]
		public string detailsBlob
		{ 
			get { return __detailsBlob; }
			set { __detailsBlob = value; }
		}

		[XmlAttribute(AttributeName="descriptionIndex",DataType="unsignedInt")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __descriptionIndex;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __descriptionIndexSpecified;
		
		[XmlIgnore]
		public uint descriptionIndex
		{ 
			get { return __descriptionIndex; }
			set { __descriptionIndex = value; __descriptionIndexSpecified = true; }
		}

		[XmlAttribute(AttributeName="order",DataType="unsignedInt")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __order;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __orderSpecified;
		
		[XmlIgnore]
		public uint order
		{ 
			get { return __order; }
			set { __order = value; __orderSpecified = true; }
		}

		[XmlAttribute(AttributeName="blobBase64",DataType="boolean")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __blobBase64;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __blobBase64Specified;
		
		[XmlIgnore]
		public bool blobBase64
		{ 
			get { return __blobBase64; }
			set { __blobBase64 = value; __blobBase64Specified = true; }
		}

		public XboxOfferDescriptionDetails()
		{
		}
	}


	[XmlType(TypeName="XboxOfferServices",Namespace=Declarations.SchemaVersion),Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class XboxOfferServices
	{

		[XmlAttribute(AttributeName="offerID",DataType="long")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public long __offerID;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __offerIDSpecified;
		
		[XmlIgnore]
		public long offerID
		{ 
			get { return __offerID; }
			set { __offerID = value; __offerIDSpecified = true; }
		}

		[XmlAttribute(AttributeName="siteID",DataType="int")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public int __siteID;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __siteIDSpecified;
		
		[XmlIgnore]
		public int siteID
		{ 
			get { return __siteID; }
			set { __siteID = value; __siteIDSpecified = true; }
		}

		public XboxOfferServices()
		{
		}
	}


	[XmlRoot(ElementName="XboxOffers",Namespace=Declarations.SchemaVersion,IsNullable=false),Serializable]
	public class XboxOffers
	{

		[XmlAttribute(AttributeName="version",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __version;
		
		[XmlIgnore]
		public string version
		{ 
			get { return __version; }
			set { __version = value; }
		}

		[XmlElement(Type=typeof(XboxContentOffer),ElementName="XboxContentOffer",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public XboxContentOffer __XboxContentOffer;
		
		[XmlIgnore]
		public XboxContentOffer XboxContentOffer
		{
			get
			{
				if (__XboxContentOffer == null) __XboxContentOffer = new XboxContentOffer();		
				return __XboxContentOffer;
			}
			set {__XboxContentOffer = value;}
		}

		[XmlElement(Type=typeof(XboxSubscription),ElementName="XboxSubscription",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public XboxSubscriptionCollection __XboxSubscriptionCollection;
		
		[XmlIgnore]
		public XboxSubscriptionCollection XboxSubscriptionCollection
		{
			get
			{
				if (__XboxSubscriptionCollection == null) __XboxSubscriptionCollection = new XboxSubscriptionCollection();
				return __XboxSubscriptionCollection;
			}
			set {__XboxSubscriptionCollection = value;}
		}

		[XmlElement(Type=typeof(XboxUpdate),ElementName="XboxUpdate",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public XboxUpdateCollection __XboxUpdateCollection;
		
		[XmlIgnore]
		public XboxUpdateCollection XboxUpdateCollection
		{
			get
			{
				if (__XboxUpdateCollection == null) __XboxUpdateCollection = new XboxUpdateCollection();
				return __XboxUpdateCollection;
			}
			set {__XboxUpdateCollection = value;}
		}

		public XboxOffers()
		{
		}
	}


	[XmlType(TypeName="XboxContentOffer",Namespace=Declarations.SchemaVersion),Serializable]
	public class XboxContentOffer
	{

		[XmlElement(Type=typeof(xonline.common.xboxofferutil.XboxOfferBasicInfo),ElementName="xboxOfferBasicInfo",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public xonline.common.xboxofferutil.XboxOfferBasicInfo __xboxOfferBasicInfo;
		
		[XmlIgnore]
		public xonline.common.xboxofferutil.XboxOfferBasicInfo xboxOfferBasicInfo
		{
			get
			{
				if (__xboxOfferBasicInfo == null) __xboxOfferBasicInfo = new xonline.common.xboxofferutil.XboxOfferBasicInfo();		
				return __xboxOfferBasicInfo;
			}
			set {__xboxOfferBasicInfo = value;}
		}

		[XmlElement(Type=typeof(xonline.common.xboxofferutil.XboxOfferDescription),ElementName="xboxOfferDescription",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public XboxOfferDescriptionCollection __xboxOfferDescriptionCollection;
		
		[XmlIgnore]
		public XboxOfferDescriptionCollection xboxOfferDescriptionCollection
		{
			get
			{
				if (__xboxOfferDescriptionCollection == null) __xboxOfferDescriptionCollection = new XboxOfferDescriptionCollection();
				return __xboxOfferDescriptionCollection;
			}
			set {__xboxOfferDescriptionCollection = value;}
		}

		[XmlElement(Type=typeof(xonline.common.xboxofferutil.XboxOfferDescriptionDetails),ElementName="xboxOfferDescriptionDetails",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public XboxOfferDescriptionDetailsCollection __xboxOfferDescriptionDetailsCollection;
		
		[XmlIgnore]
		public XboxOfferDescriptionDetailsCollection xboxOfferDescriptionDetailsCollection
		{
			get
			{
				if (__xboxOfferDescriptionDetailsCollection == null) __xboxOfferDescriptionDetailsCollection = new XboxOfferDescriptionDetailsCollection();
				return __xboxOfferDescriptionDetailsCollection;
			}
			set {__xboxOfferDescriptionDetailsCollection = value;}
		}

		[XmlElement(Type=typeof(xonline.common.xboxofferutil.XboxOfferLocations),ElementName="xboxOfferLocations",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public XboxOfferLocationsCollection __xboxOfferLocationsCollection;
		
		[XmlIgnore]
		public XboxOfferLocationsCollection xboxOfferLocationsCollection
		{
			get
			{
				if (__xboxOfferLocationsCollection == null) __xboxOfferLocationsCollection = new XboxOfferLocationsCollection();
				return __xboxOfferLocationsCollection;
			}
			set {__xboxOfferLocationsCollection = value;}
		}

		[XmlElement(Type=typeof(xonline.common.xboxofferutil.XboxOfferRegions),ElementName="xboxOfferRegions",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public XboxOfferRegionsCollection __xboxOfferRegionsCollection;
		
		[XmlIgnore]
		public XboxOfferRegionsCollection xboxOfferRegionsCollection
		{
			get
			{
				if (__xboxOfferRegionsCollection == null) __xboxOfferRegionsCollection = new XboxOfferRegionsCollection();
				return __xboxOfferRegionsCollection;
			}
			set {__xboxOfferRegionsCollection = value;}
		}

		public XboxContentOffer()
		{
		}
	}


	[XmlType(TypeName="XboxSubscription",Namespace=Declarations.SchemaVersion),Serializable]
	public class XboxSubscription
	{

		[XmlAttribute(AttributeName="baseOffer",DataType="boolean")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __baseOffer;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __baseOfferSpecified;
		
		[XmlIgnore]
		public bool baseOffer
		{ 
			get { return __baseOffer; }
			set { __baseOffer = value; __baseOfferSpecified = true; }
		}

		[XmlElement(Type=typeof(xonline.common.xboxofferutil.XboxSubscriptionBasicInfo),ElementName="xboxSubscriptionBasicInfo",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public xonline.common.xboxofferutil.XboxSubscriptionBasicInfo __xboxSubscriptionBasicInfo;
		
		[XmlIgnore]
		public xonline.common.xboxofferutil.XboxSubscriptionBasicInfo xboxSubscriptionBasicInfo
		{
			get
			{
				if (__xboxSubscriptionBasicInfo == null) __xboxSubscriptionBasicInfo = new xonline.common.xboxofferutil.XboxSubscriptionBasicInfo();		
				return __xboxSubscriptionBasicInfo;
			}
			set {__xboxSubscriptionBasicInfo = value;}
		}

		[XmlElement(Type=typeof(xonline.common.xboxofferutil.XboxOfferDescription),ElementName="xboxOfferDescription",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public XboxOfferDescriptionCollection __xboxOfferDescriptionCollection;
		
		[XmlIgnore]
		public XboxOfferDescriptionCollection xboxOfferDescriptionCollection
		{
			get
			{
				if (__xboxOfferDescriptionCollection == null) __xboxOfferDescriptionCollection = new XboxOfferDescriptionCollection();
				return __xboxOfferDescriptionCollection;
			}
			set {__xboxOfferDescriptionCollection = value;}
		}

		[XmlElement(Type=typeof(xonline.common.xboxofferutil.XboxOfferDescriptionDetails),ElementName="xboxOfferDescriptionDetails",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public XboxOfferDescriptionDetailsCollection __xboxOfferDescriptionDetailsCollection;
		
		[XmlIgnore]
		public XboxOfferDescriptionDetailsCollection xboxOfferDescriptionDetailsCollection
		{
			get
			{
				if (__xboxOfferDescriptionDetailsCollection == null) __xboxOfferDescriptionDetailsCollection = new XboxOfferDescriptionDetailsCollection();
				return __xboxOfferDescriptionDetailsCollection;
			}
			set {__xboxOfferDescriptionDetailsCollection = value;}
		}

		[XmlElement(Type=typeof(xonline.common.xboxofferutil.XboxOfferRegions),ElementName="xboxOfferRegions",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public XboxOfferRegionsCollection __xboxOfferRegionsCollection;
		
		[XmlIgnore]
		public XboxOfferRegionsCollection xboxOfferRegionsCollection
		{
			get
			{
				if (__xboxOfferRegionsCollection == null) __xboxOfferRegionsCollection = new XboxOfferRegionsCollection();
				return __xboxOfferRegionsCollection;
			}
			set {__xboxOfferRegionsCollection = value;}
		}

		[XmlElement(Type=typeof(xonline.common.xboxofferutil.XboxOfferRelations),ElementName="xboxOfferRelations",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public XboxOfferRelationsCollection __xboxOfferRelationsCollection;
		
		[XmlIgnore]
		public XboxOfferRelationsCollection xboxOfferRelationsCollection
		{
			get
			{
				if (__xboxOfferRelationsCollection == null) __xboxOfferRelationsCollection = new XboxOfferRelationsCollection();
				return __xboxOfferRelationsCollection;
			}
			set {__xboxOfferRelationsCollection = value;}
		}

		[XmlElement(Type=typeof(xonline.common.xboxofferutil.XboxOfferServices),ElementName="xboxOfferServices",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public XboxOfferServicesCollection __xboxOfferServicesCollection;
		
		[XmlIgnore]
		public XboxOfferServicesCollection xboxOfferServicesCollection
		{
			get
			{
				if (__xboxOfferServicesCollection == null) __xboxOfferServicesCollection = new XboxOfferServicesCollection();
				return __xboxOfferServicesCollection;
			}
			set {__xboxOfferServicesCollection = value;}
		}

		public XboxSubscription()
		{
		}
	}


	[XmlType(TypeName="XboxUpdate",Namespace=Declarations.SchemaVersion),Serializable]
	public class XboxUpdate
	{

		[XmlElement(Type=typeof(xonline.common.xboxofferutil.XboxTitleUpdatePackage),ElementName="xboxTitleUpdatePackage",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public xonline.common.xboxofferutil.XboxTitleUpdatePackage __xboxTitleUpdatePackage;
		
		[XmlIgnore]
		public xonline.common.xboxofferutil.XboxTitleUpdatePackage xboxTitleUpdatePackage
		{
			get
			{
				if (__xboxTitleUpdatePackage == null) __xboxTitleUpdatePackage = new xonline.common.xboxofferutil.XboxTitleUpdatePackage();		
				return __xboxTitleUpdatePackage;
			}
			set {__xboxTitleUpdatePackage = value;}
		}

		[XmlElement(Type=typeof(xonline.common.xboxofferutil.XboxTitleVersion),ElementName="xboxTitleVersion",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public xonline.common.xboxofferutil.XboxTitleVersion __xboxTitleVersion;
		
		[XmlIgnore]
		public xonline.common.xboxofferutil.XboxTitleVersion xboxTitleVersion
		{
			get
			{
				if (__xboxTitleVersion == null) __xboxTitleVersion = new xonline.common.xboxofferutil.XboxTitleVersion();		
				return __xboxTitleVersion;
			}
			set {__xboxTitleVersion = value;}
		}

		public XboxUpdate()
		{
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\querylib\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\querylib\base.cs ===
// 
// Base.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Query Plugin base classes
// Xbox Online Service
// 
// Author: slamb
//

using System;
using System.Collections;
using xonline.common.service;
using xonline.common.protocol;

namespace xonline.server.querylib 
{
    public interface IQueryAdd
    {
        HResult BeforeAdd(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, QueryAttribute[] attribs, Hashtable ctx);
        HResult AfterAdd(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, QueryAttribute[] attribs, ulong entityId, Hashtable ctx);
    }
    
    public interface IQueryUpdate
    {
        HResult BeforeUpdate(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, uint procIndex, QueryAttribute[] attribs, Hashtable ctx);
        void AfterUpdate(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, uint procIndex, QueryAttribute[] attribs, Hashtable ctx);
    }

    public interface IQueryUpdateId
    {
        HResult BeforeUpdateId(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, uint procIndex, QueryAttribute[] attribs, ulong entityId, Hashtable ctx);
        void AfterUpdateId(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, uint procIndex, QueryAttribute[] attribs, ulong entityId, Hashtable ctx);
    }

    public interface IQueryRemove
    {
        HResult BeforeRemove(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, uint procIndex, QueryAttribute[] attribs, Hashtable ctx);
        void AfterRemove(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, uint procIndex, QueryAttribute[] attribs, Hashtable ctx);
    }
    
    public interface IQueryRemoveId
    {
        HResult BeforeRemoveId(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId, Hashtable ctx);
        void AfterRemoveId(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId, Hashtable ctx);
    }
    
    public interface IQuerySelect
    {
        HResult Select(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId, uint actionId, QueryAttribute[] attribs, Hashtable ctx);
    }
    
    public interface IQuerySearch
    {
        HResult BeforeSearch(Source source, uint titleId, uint datasetId, uint procIndex, QueryAttribute[] attribs, Hashtable ctx);
    }
    
    public interface IQueryFindFromIds
    {
        HResult BeforeFind(Source source, uint titleId, uint datasetId, uint procIndex, ulong [] entityIds, Hashtable ctx);
    }
    
    public interface IQueryCustom
    {
        HResult BeforeCustom(Source source, uint titleId, uint datasetId, uint procIndex, QueryAttribute[] attribs, Hashtable ctx);
    }


    [Flags]
    public enum Source
    {
        Xbox = 0x1,
        Server = 0x2,
        Plugin = 0x4,
        Web = 0x8
    }    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\offerutil\offerutil\LiveOfferSchema.cs ===
// Copyright 2004, Microsoft Corporation
// Sample Code - Use restricted to terms of use defined in the accompanying license agreement (EULA.doc)

//--------------------------------------------------------------
// Autogenerated by XSDObjectGen version 1.4.4.1
// Schema file: LiveOffer.xsd
// Creation Date: 6/28/2011 11:28:47 AM
//--------------------------------------------------------------

using System;
using System.Xml.Serialization;
using System.Collections;
using System.Xml.Schema;
using System.ComponentModel;

namespace xonline.common.offerutil
{

	public struct Declarations
	{
		public const string SchemaVersion = "http://www.xboxlive.com/offer";
	}

	[Serializable]
	public enum OfferRelationType
	{
		[XmlEnum(Name="Renewal")] Renewal,
		[XmlEnum(Name="Trial")] Trial,
		[XmlEnum(Name="Xbox1XenonSubstitution")] Xbox1XenonSubstitution
	}

	[Serializable]
	public enum OfferService
	{
		[XmlEnum(Name="OneTimeCharge")] OneTimeCharge,
		[XmlEnum(Name="Monthly")] Monthly,
		[XmlEnum(Name="Quarterly")] Quarterly,
		[XmlEnum(Name="BiAnnually")] BiAnnually,
		[XmlEnum(Name="Annually")] Annually
	}

	[Serializable]
	public enum LicenseLevel
	{
		[XmlEnum(Name="Unrestricted")] Unrestricted,
		[XmlEnum(Name="RestrictedToUserAndMachine")] RestrictedToUserAndMachine,
		[XmlEnum(Name="RestrictedToMachine")] RestrictedToMachine
	}

	[Serializable]
	public enum TaxType
	{
		[XmlEnum(Name="NoTax")] NoTax,
		[XmlEnum(Name="DefaultTax")] DefaultTax,
		[XmlEnum(Name="GST")] GST,
		[XmlEnum(Name="VAT")] VAT,
		[XmlEnum(Name="TaxNotApplicable")] TaxNotApplicable
	}

	[Serializable]
	public enum Genre
	{
		[XmlEnum(Name="Action")] Action,
		[XmlEnum(Name="Adventure")] Adventure,
		[XmlEnum(Name="Compilations")] Compilations,
		[XmlEnum(Name="Family")] Family,
		[XmlEnum(Name="Fighting")] Fighting,
		[XmlEnum(Name="Music")] Music,
		[XmlEnum(Name="Platform")] Platform,
		[XmlEnum(Name="Racing")] Racing,
		[XmlEnum(Name="RolePlaying")] RolePlaying,
		[XmlEnum(Name="Shooter")] Shooter,
		[XmlEnum(Name="Simulation")] Simulation,
		[XmlEnum(Name="Sports")] Sports,
		[XmlEnum(Name="Strategy")] Strategy,
		[XmlEnum(Name="XArcadeAction")] XArcadeAction,
		[XmlEnum(Name="XArcadeCardAndBoard")] XArcadeCardAndBoard,
		[XmlEnum(Name="XArcadeCoinOpClassics")] XArcadeCoinOpClassics,
		[XmlEnum(Name="XArcadePuzzleAndWord")] XArcadePuzzleAndWord,
		[XmlEnum(Name="XArcadeSocialSports")] XArcadeSocialSports,
		[XmlEnum(Name="XArcadeStrategyAndSims")] XArcadeStrategyAndSims,
		[XmlEnum(Name="XArcadeConsoleClassics")] XArcadeConsoleClassics,
		[XmlEnum(Name="XArcadeGameShows")] XArcadeGameShows,
		[XmlEnum(Name="XArcadeFamilyGames")] XArcadeFamilyGames,
		[XmlEnum(Name="XArcadeTrivia")] XArcadeTrivia
	}

	[Serializable]
	public enum ConsoleType
	{
		[XmlEnum(Name="Xbox360")] Xbox360,
		[XmlEnum(Name="PC")] PC
	}

	[Serializable]
	public enum SKUType
	{
		[XmlEnum(Name="Promo")] Promo,
		[XmlEnum(Name="Revenue")] Revenue
	}

	[Serializable]
	public enum ContentPackageType
	{
		[XmlEnum(Name="Undefined")] Undefined,
		[XmlEnum(Name="Cab")] Cab,
		[XmlEnum(Name="SvodUncompressed")] SvodUncompressed,
		[XmlEnum(Name="SvodCompressed")] SvodCompressed
	}

	[Serializable]
	public enum OfferEnumerationType
	{
		[XmlEnum(Name="AlwaysEnumerateExceptInPartnerNetDash")] AlwaysEnumerateExceptInPartnerNetDash,
		[XmlEnum(Name="NeverEnumerate")] NeverEnumerate,
		[XmlEnum(Name="AlwaysEnumerate")] AlwaysEnumerate
	}

	[Serializable]
	public enum OfferConvertMode
	{
		[XmlEnum(Name="Convert")] Convert,
		[XmlEnum(Name="Renew")] Renew
	}

	[Serializable]
	public enum LiveTier
	{
		[XmlEnum(Name="NewUser")] NewUser,
		[XmlEnum(Name="Silver")] Silver,
		[XmlEnum(Name="Gold")] Gold,
		[XmlEnum(Name="FamilyGold")] FamilyGold
	}

	[Serializable]
	public enum ContentOfferType
	{
		[XmlEnum(Name="GameContent")] GameContent,
		[XmlEnum(Name="GameDemo")] GameDemo,
		[XmlEnum(Name="GameTrailer")] GameTrailer,
		[XmlEnum(Name="Theme")] Theme,
		[XmlEnum(Name="FullGame")] FullGame,
		[XmlEnum(Name="Tile")] Tile,
		[XmlEnum(Name="Arcade")] Arcade,
		[XmlEnum(Name="Video")] Video,
		[XmlEnum(Name="AvatarItem")] AvatarItem
	}

	[Serializable]
	public enum SubscriptionFrequency
	{
		[XmlEnum(Name="OneTimeCharge")] OneTimeCharge,
		[XmlEnum(Name="Monthly")] Monthly,
		[XmlEnum(Name="Quarterly")] Quarterly,
		[XmlEnum(Name="BiAnnually")] BiAnnually,
		[XmlEnum(Name="Annually")] Annually
	}


	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class RatingCollection : ArrayList
	{
		public xonline.common.offerutil.Rating Add(xonline.common.offerutil.Rating obj)
		{
			base.Add(obj);
			return obj;
		}

		public xonline.common.offerutil.Rating Add()
		{
			return Add(new xonline.common.offerutil.Rating());
		}

		public void Insert(int index, xonline.common.offerutil.Rating obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(xonline.common.offerutil.Rating obj)
		{
			base.Remove(obj);
		}

		new public xonline.common.offerutil.Rating this[int index]
		{
			get { return (xonline.common.offerutil.Rating) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class OfferRegionInfoCollection : ArrayList
	{
		public xonline.common.offerutil.OfferRegionInfo Add(xonline.common.offerutil.OfferRegionInfo obj)
		{
			base.Add(obj);
			return obj;
		}

		public xonline.common.offerutil.OfferRegionInfo Add()
		{
			return Add(new xonline.common.offerutil.OfferRegionInfo());
		}

		public void Insert(int index, xonline.common.offerutil.OfferRegionInfo obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(xonline.common.offerutil.OfferRegionInfo obj)
		{
			base.Remove(obj);
		}

		new public xonline.common.offerutil.OfferRegionInfo this[int index]
		{
			get { return (xonline.common.offerutil.OfferRegionInfo) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class LiveSubscriptionRelationCollection : ArrayList
	{
		public xonline.common.offerutil.LiveSubscriptionRelation Add(xonline.common.offerutil.LiveSubscriptionRelation obj)
		{
			base.Add(obj);
			return obj;
		}

		public xonline.common.offerutil.LiveSubscriptionRelation Add()
		{
			return Add(new xonline.common.offerutil.LiveSubscriptionRelation());
		}

		public void Insert(int index, xonline.common.offerutil.LiveSubscriptionRelation obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(xonline.common.offerutil.LiveSubscriptionRelation obj)
		{
			base.Remove(obj);
		}

		new public xonline.common.offerutil.LiveSubscriptionRelation this[int index]
		{
			get { return (xonline.common.offerutil.LiveSubscriptionRelation) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class LiveSubscriptionCollection : ArrayList
	{
		public xonline.common.offerutil.LiveSubscription Add(xonline.common.offerutil.LiveSubscription obj)
		{
			base.Add(obj);
			return obj;
		}

		public xonline.common.offerutil.LiveSubscription Add()
		{
			return Add(new xonline.common.offerutil.LiveSubscription());
		}

		public void Insert(int index, xonline.common.offerutil.LiveSubscription obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(xonline.common.offerutil.LiveSubscription obj)
		{
			base.Remove(obj);
		}

		new public xonline.common.offerutil.LiveSubscription this[int index]
		{
			get { return (xonline.common.offerutil.LiveSubscription) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class RewardCultureDetailsCollection : ArrayList
	{
		public xonline.common.offerutil.RewardCultureDetails Add(xonline.common.offerutil.RewardCultureDetails obj)
		{
			base.Add(obj);
			return obj;
		}

		public xonline.common.offerutil.RewardCultureDetails Add()
		{
			return Add(new xonline.common.offerutil.RewardCultureDetails());
		}

		public void Insert(int index, xonline.common.offerutil.RewardCultureDetails obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(xonline.common.offerutil.RewardCultureDetails obj)
		{
			base.Remove(obj);
		}

		new public xonline.common.offerutil.RewardCultureDetails this[int index]
		{
			get { return (xonline.common.offerutil.RewardCultureDetails) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class PromotionalPointsOfferCollection : ArrayList
	{
		public xonline.common.offerutil.PromotionalPointsOffer Add(xonline.common.offerutil.PromotionalPointsOffer obj)
		{
			base.Add(obj);
			return obj;
		}

		public xonline.common.offerutil.PromotionalPointsOffer Add()
		{
			return Add(new xonline.common.offerutil.PromotionalPointsOffer());
		}

		public void Insert(int index, xonline.common.offerutil.PromotionalPointsOffer obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(xonline.common.offerutil.PromotionalPointsOffer obj)
		{
			base.Remove(obj);
		}

		new public xonline.common.offerutil.PromotionalPointsOffer this[int index]
		{
			get { return (xonline.common.offerutil.PromotionalPointsOffer) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class RewardCollection : ArrayList
	{
		public xonline.common.offerutil.Reward Add(xonline.common.offerutil.Reward obj)
		{
			base.Add(obj);
			return obj;
		}

		public xonline.common.offerutil.Reward Add()
		{
			return Add(new xonline.common.offerutil.Reward());
		}

		public void Insert(int index, xonline.common.offerutil.Reward obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(xonline.common.offerutil.Reward obj)
		{
			base.Remove(obj);
		}

		new public xonline.common.offerutil.Reward this[int index]
		{
			get { return (xonline.common.offerutil.Reward) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class offerPrivilegeRestrictionCollection : ArrayList
	{
		public uint Add(uint obj)
		{
			base.Add(obj);
			return obj;
		}

		public uint Add()
		{
			return Add(new uint());
		}

		public void Insert(int index, uint obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(uint obj)
		{
			base.Remove(obj);
		}

		new public uint this[int index]
		{
			get { return (uint) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class ContentLocationCollection : ArrayList
	{
		public xonline.common.offerutil.ContentLocation Add(xonline.common.offerutil.ContentLocation obj)
		{
			base.Add(obj);
			return obj;
		}

		public xonline.common.offerutil.ContentLocation Add()
		{
			return Add(new xonline.common.offerutil.ContentLocation());
		}

		public void Insert(int index, xonline.common.offerutil.ContentLocation obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(xonline.common.offerutil.ContentLocation obj)
		{
			base.Remove(obj);
		}

		new public xonline.common.offerutil.ContentLocation this[int index]
		{
			get { return (xonline.common.offerutil.ContentLocation) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class ContentOfferCollection : ArrayList
	{
		public xonline.common.offerutil.ContentOffer Add(xonline.common.offerutil.ContentOffer obj)
		{
			base.Add(obj);
			return obj;
		}

		public xonline.common.offerutil.ContentOffer Add()
		{
			return Add(new xonline.common.offerutil.ContentOffer());
		}

		public void Insert(int index, xonline.common.offerutil.ContentOffer obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(xonline.common.offerutil.ContentOffer obj)
		{
			base.Remove(obj);
		}

		new public xonline.common.offerutil.ContentOffer this[int index]
		{
			get { return (xonline.common.offerutil.ContentOffer) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class CategoryCollection : ArrayList
	{
		public xonline.common.offerutil.Category Add(xonline.common.offerutil.Category obj)
		{
			base.Add(obj);
			return obj;
		}

		public xonline.common.offerutil.Category Add()
		{
			return Add(new xonline.common.offerutil.Category());
		}

		public void Insert(int index, xonline.common.offerutil.Category obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(xonline.common.offerutil.Category obj)
		{
			base.Remove(obj);
		}

		new public xonline.common.offerutil.Category this[int index]
		{
			get { return (xonline.common.offerutil.Category) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class PcAccountCreationOfferCollection : ArrayList
	{
		public xonline.common.offerutil.PcAccountCreationOffer Add(xonline.common.offerutil.PcAccountCreationOffer obj)
		{
			base.Add(obj);
			return obj;
		}

		public xonline.common.offerutil.PcAccountCreationOffer Add()
		{
			return Add(new xonline.common.offerutil.PcAccountCreationOffer());
		}

		public void Insert(int index, xonline.common.offerutil.PcAccountCreationOffer obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(xonline.common.offerutil.PcAccountCreationOffer obj)
		{
			base.Remove(obj);
		}

		new public xonline.common.offerutil.PcAccountCreationOffer this[int index]
		{
			get { return (xonline.common.offerutil.PcAccountCreationOffer) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class TitleCultureDetailsCollection : ArrayList
	{
		public xonline.common.offerutil.TitleCultureDetails Add(xonline.common.offerutil.TitleCultureDetails obj)
		{
			base.Add(obj);
			return obj;
		}

		public xonline.common.offerutil.TitleCultureDetails Add()
		{
			return Add(new xonline.common.offerutil.TitleCultureDetails());
		}

		public void Insert(int index, xonline.common.offerutil.TitleCultureDetails obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(xonline.common.offerutil.TitleCultureDetails obj)
		{
			base.Remove(obj);
		}

		new public xonline.common.offerutil.TitleCultureDetails this[int index]
		{
			get { return (xonline.common.offerutil.TitleCultureDetails) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class associatedTitleIDCollection : ArrayList
	{
		public string Add(string obj)
		{
			base.Add(obj);
			return obj;
		}

		public void Insert(int index, string obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(string obj)
		{
			base.Remove(obj);
		}

		new public string this[int index]
		{
			get { return (string) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class PaymentTypeWholesaleCollection : ArrayList
	{
		public xonline.common.offerutil.PaymentTypeWholesale Add(xonline.common.offerutil.PaymentTypeWholesale obj)
		{
			base.Add(obj);
			return obj;
		}

		public xonline.common.offerutil.PaymentTypeWholesale Add()
		{
			return Add(new xonline.common.offerutil.PaymentTypeWholesale());
		}

		public void Insert(int index, xonline.common.offerutil.PaymentTypeWholesale obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(xonline.common.offerutil.PaymentTypeWholesale obj)
		{
			base.Remove(obj);
		}

		new public xonline.common.offerutil.PaymentTypeWholesale this[int index]
		{
			get { return (xonline.common.offerutil.PaymentTypeWholesale) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class ratingCollection : ArrayList
	{
		public uint Add(uint obj)
		{
			base.Add(obj);
			return obj;
		}

		public uint Add()
		{
			return Add(new uint());
		}

		public void Insert(int index, uint obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(uint obj)
		{
			base.Remove(obj);
		}

		new public uint this[int index]
		{
			get { return (uint) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class GamertagChangeOfferCollection : ArrayList
	{
		public xonline.common.offerutil.GamertagChangeOffer Add(xonline.common.offerutil.GamertagChangeOffer obj)
		{
			base.Add(obj);
			return obj;
		}

		public xonline.common.offerutil.GamertagChangeOffer Add()
		{
			return Add(new xonline.common.offerutil.GamertagChangeOffer());
		}

		public void Insert(int index, xonline.common.offerutil.GamertagChangeOffer obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(xonline.common.offerutil.GamertagChangeOffer obj)
		{
			base.Remove(obj);
		}

		new public xonline.common.offerutil.GamertagChangeOffer this[int index]
		{
			get { return (xonline.common.offerutil.GamertagChangeOffer) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class OfferSubscriptionRewardInfoCollection : ArrayList
	{
		public xonline.common.offerutil.OfferSubscriptionRewardInfo Add(xonline.common.offerutil.OfferSubscriptionRewardInfo obj)
		{
			base.Add(obj);
			return obj;
		}

		public xonline.common.offerutil.OfferSubscriptionRewardInfo Add()
		{
			return Add(new xonline.common.offerutil.OfferSubscriptionRewardInfo());
		}

		public void Insert(int index, xonline.common.offerutil.OfferSubscriptionRewardInfo obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(xonline.common.offerutil.OfferSubscriptionRewardInfo obj)
		{
			base.Remove(obj);
		}

		new public xonline.common.offerutil.OfferSubscriptionRewardInfo this[int index]
		{
			get { return (xonline.common.offerutil.OfferSubscriptionRewardInfo) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class OfferCultureDetailsCollection : ArrayList
	{
		public xonline.common.offerutil.OfferCultureDetails Add(xonline.common.offerutil.OfferCultureDetails obj)
		{
			base.Add(obj);
			return obj;
		}

		public xonline.common.offerutil.OfferCultureDetails Add()
		{
			return Add(new xonline.common.offerutil.OfferCultureDetails());
		}

		public void Insert(int index, xonline.common.offerutil.OfferCultureDetails obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(xonline.common.offerutil.OfferCultureDetails obj)
		{
			base.Remove(obj);
		}

		new public xonline.common.offerutil.OfferCultureDetails this[int index]
		{
			get { return (xonline.common.offerutil.OfferCultureDetails) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class offerPrivilegeGrantCollection : ArrayList
	{
		public uint Add(uint obj)
		{
			base.Add(obj);
			return obj;
		}

		public uint Add()
		{
			return Add(new uint());
		}

		public void Insert(int index, uint obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(uint obj)
		{
			base.Remove(obj);
		}

		new public uint this[int index]
		{
			get { return (uint) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class TitleCollection : ArrayList
	{
		public xonline.common.offerutil.Title Add(xonline.common.offerutil.Title obj)
		{
			base.Add(obj);
			return obj;
		}

		public xonline.common.offerutil.Title Add()
		{
			return Add(new xonline.common.offerutil.Title());
		}

		public void Insert(int index, xonline.common.offerutil.Title obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(xonline.common.offerutil.Title obj)
		{
			base.Remove(obj);
		}

		new public xonline.common.offerutil.Title this[int index]
		{
			get { return (xonline.common.offerutil.Title) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class titleIDCollection : ArrayList
	{
		public string Add(string obj)
		{
			base.Add(obj);
			return obj;
		}

		public void Insert(int index, string obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(string obj)
		{
			base.Remove(obj);
		}

		new public string this[int index]
		{
			get { return (string) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class GameplayOfferCollection : ArrayList
	{
		public xonline.common.offerutil.GameplayOffer Add(xonline.common.offerutil.GameplayOffer obj)
		{
			base.Add(obj);
			return obj;
		}

		public xonline.common.offerutil.GameplayOffer Add()
		{
			return Add(new xonline.common.offerutil.GameplayOffer());
		}

		public void Insert(int index, xonline.common.offerutil.GameplayOffer obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(xonline.common.offerutil.GameplayOffer obj)
		{
			base.Remove(obj);
		}

		new public xonline.common.offerutil.GameplayOffer this[int index]
		{
			get { return (xonline.common.offerutil.GameplayOffer) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class GameSubscriptionCollection : ArrayList
	{
		public xonline.common.offerutil.GameSubscription Add(xonline.common.offerutil.GameSubscription obj)
		{
			base.Add(obj);
			return obj;
		}

		public xonline.common.offerutil.GameSubscription Add()
		{
			return Add(new xonline.common.offerutil.GameSubscription());
		}

		public void Insert(int index, xonline.common.offerutil.GameSubscription obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(xonline.common.offerutil.GameSubscription obj)
		{
			base.Remove(obj);
		}

		new public xonline.common.offerutil.GameSubscription this[int index]
		{
			get { return (xonline.common.offerutil.GameSubscription) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class ContentCollection : ArrayList
	{
		public xonline.common.offerutil.Content Add(xonline.common.offerutil.Content obj)
		{
			base.Add(obj);
			return obj;
		}

		public xonline.common.offerutil.Content Add()
		{
			return Add(new xonline.common.offerutil.Content());
		}

		public void Insert(int index, xonline.common.offerutil.Content obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(xonline.common.offerutil.Content obj)
		{
			base.Remove(obj);
		}

		new public xonline.common.offerutil.Content this[int index]
		{
			get { return (xonline.common.offerutil.Content) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class PointsBundleOfferCollection : ArrayList
	{
		public xonline.common.offerutil.PointsBundleOffer Add(xonline.common.offerutil.PointsBundleOffer obj)
		{
			base.Add(obj);
			return obj;
		}

		public xonline.common.offerutil.PointsBundleOffer Add()
		{
			return Add(new xonline.common.offerutil.PointsBundleOffer());
		}

		public void Insert(int index, xonline.common.offerutil.PointsBundleOffer obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(xonline.common.offerutil.PointsBundleOffer obj)
		{
			base.Remove(obj);
		}

		new public xonline.common.offerutil.PointsBundleOffer this[int index]
		{
			get { return (xonline.common.offerutil.PointsBundleOffer) base[index]; }
			set { base[index] = value; }
		}
	}



	[XmlType(TypeName="ContentLocation",Namespace=Declarations.SchemaVersion),Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class ContentLocation
	{

		[XmlElement(ElementName="rank",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="unsignedInt",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __rank;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __rankSpecified;
		
		[XmlIgnore]
		public uint rank
		{ 
			get { return __rank; }
			set { __rank = value; __rankSpecified = true; }
		}

		[XmlElement(ElementName="xrl",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="string",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __xrl;
		
		[XmlIgnore]
		public string xrl
		{ 
			get { return __xrl; }
			set { __xrl = value; }
		}

		public ContentLocation()
		{
		}
	}


	[XmlType(TypeName="Content",Namespace=Declarations.SchemaVersion),Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class Content
	{

		[XmlElement(ElementName="contentID",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="string",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __contentID;
		
		[XmlIgnore]
		public string contentID
		{ 
			get { return __contentID; }
			set { __contentID = value; }
		}

		[XmlElement(ElementName="packageSize",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="unsignedLong",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ulong __packageSize;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __packageSizeSpecified;
		
		[XmlIgnore]
		public ulong packageSize
		{ 
			get { return __packageSize; }
			set { __packageSize = value; __packageSizeSpecified = true; }
		}

		[XmlElement(ElementName="installSize",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="unsignedLong",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ulong __installSize;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __installSizeSpecified;
		
		[XmlIgnore]
		public ulong installSize
		{ 
			get { return __installSize; }
			set { __installSize = value; __installSizeSpecified = true; }
		}

		[XmlElement(ElementName="symKey",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="string",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __symKey;
		
		[XmlIgnore]
		public string symKey
		{ 
			get { return __symKey; }
			set { __symKey = value; }
		}

		[XmlElement(ElementName="publicKey",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="string",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __publicKey;
		
		[XmlIgnore]
		public string publicKey
		{ 
			get { return __publicKey; }
			set { __publicKey = value; }
		}

		[XmlElement(ElementName="friendlyName",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="string",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __friendlyName;
		
		[XmlIgnore]
		public string friendlyName
		{ 
			get { return __friendlyName; }
			set { __friendlyName = value; }
		}

		[XmlElement(Type=typeof(xonline.common.offerutil.ContentLocation),ElementName="contentLocation",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ContentLocationCollection __contentLocationCollection;
		
		[XmlIgnore]
		public ContentLocationCollection contentLocationCollection
		{
			get
			{
				if (__contentLocationCollection == null) __contentLocationCollection = new ContentLocationCollection();
				return __contentLocationCollection;
			}
			set {__contentLocationCollection = value;}
		}

		[XmlElement(ElementName="packageType",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public xonline.common.offerutil.ContentPackageType __packageType;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __packageTypeSpecified;
		
		[XmlIgnore]
		public xonline.common.offerutil.ContentPackageType packageType
		{ 
			get { return __packageType; }
			set { __packageType = value; __packageTypeSpecified = true; }
		}

		[XmlElement(ElementName="gameRegion",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="unsignedInt",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __gameRegion;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __gameRegionSpecified;
		
		[XmlIgnore]
		public uint gameRegion
		{ 
			get { return __gameRegion; }
			set { __gameRegion = value; __gameRegionSpecified = true; }
		}

		public Content()
		{
		}
	}


	[XmlType(TypeName="Rating",Namespace=Declarations.SchemaVersion),Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class Rating
	{

		[XmlAttribute(AttributeName="ratingSystemId",DataType="unsignedInt")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __ratingSystemId;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __ratingSystemIdSpecified;
		
		[XmlIgnore]
		public uint ratingSystemId
		{ 
			get { return __ratingSystemId; }
			set { __ratingSystemId = value; __ratingSystemIdSpecified = true; }
		}

		[XmlAttribute(AttributeName="ratingId",DataType="unsignedInt")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __ratingId;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __ratingIdSpecified;
		
		[XmlIgnore]
		public uint ratingId
		{ 
			get { return __ratingId; }
			set { __ratingId = value; __ratingIdSpecified = true; }
		}

		public Rating()
		{
		}
	}


	[XmlType(TypeName="Category",Namespace=Declarations.SchemaVersion),Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class Category
	{

		[XmlAttribute(AttributeName="categoryId",DataType="unsignedInt")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __categoryId;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __categoryIdSpecified;
		
		[XmlIgnore]
		public uint categoryId
		{ 
			get { return __categoryId; }
			set { __categoryId = value; __categoryIdSpecified = true; }
		}

		[XmlAttribute(AttributeName="externalType",DataType="unsignedInt")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __externalType;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __externalTypeSpecified;
		
		[XmlIgnore]
		public uint externalType
		{ 
			get { return __externalType; }
			set { __externalType = value; __externalTypeSpecified = true; }
		}

		public Category()
		{
		}
	}


	[XmlType(TypeName="OfferContentInfo",Namespace=Declarations.SchemaVersion),Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class OfferContentInfo
	{

		[XmlElement(ElementName="contentID",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="string",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __contentID;
		
		[XmlIgnore]
		public string contentID
		{ 
			get { return __contentID; }
			set { __contentID = value; }
		}

		[XmlElement(ElementName="licenseLevel",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public xonline.common.offerutil.LicenseLevel __licenseLevel;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __licenseLevelSpecified;
		
		[XmlIgnore]
		public xonline.common.offerutil.LicenseLevel licenseLevel
		{ 
			get { return __licenseLevel; }
			set { __licenseLevel = value; __licenseLevelSpecified = true; }
		}

		[XmlElement(ElementName="licenseExtensionBits",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="unsignedInt",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __licenseExtensionBits;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __licenseExtensionBitsSpecified;
		
		[XmlIgnore]
		public uint licenseExtensionBits
		{ 
			get { return __licenseExtensionBits; }
			set { __licenseExtensionBits = value; __licenseExtensionBitsSpecified = true; }
		}

		[XmlElement(ElementName="previewOfferID",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="string",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __previewOfferID;
		
		[XmlIgnore]
		public string previewOfferID
		{ 
			get { return __previewOfferID; }
			set { __previewOfferID = value; }
		}

		public OfferContentInfo()
		{
		}
	}


	[XmlType(TypeName="CampaignDetails",Namespace=Declarations.SchemaVersion),Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class CampaignDetails
	{

		[XmlElement(ElementName="campaignID",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="unsignedInt",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __campaignID;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __campaignIDSpecified;
		
		[XmlIgnore]
		public uint campaignID
		{ 
			get { return __campaignID; }
			set { __campaignID = value; __campaignIDSpecified = true; }
		}

		[XmlElement(ElementName="friendlyName",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="string",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __friendlyName;
		
		[XmlIgnore]
		public string friendlyName
		{ 
			get { return __friendlyName; }
			set { __friendlyName = value; }
		}

		public CampaignDetails()
		{
		}
	}


	[XmlType(TypeName="AcquisitionType",Namespace=Declarations.SchemaVersion),Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class AcquisitionType
	{

		[XmlElement(ElementName="acquisitionTypeID",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="unsignedInt",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __acquisitionTypeID;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __acquisitionTypeIDSpecified;
		
		[XmlIgnore]
		public uint acquisitionTypeID
		{ 
			get { return __acquisitionTypeID; }
			set { __acquisitionTypeID = value; __acquisitionTypeIDSpecified = true; }
		}

		[XmlElement(ElementName="friendlyName",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="string",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __friendlyName;
		
		[XmlIgnore]
		public string friendlyName
		{ 
			get { return __friendlyName; }
			set { __friendlyName = value; }
		}

		public AcquisitionType()
		{
		}
	}


	[XmlType(TypeName="SKUDetails",Namespace=Declarations.SchemaVersion),Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class SKUDetails
	{

		[XmlElement(ElementName="skuID",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="unsignedInt",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __skuID;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __skuIDSpecified;
		
		[XmlIgnore]
		public uint skuID
		{ 
			get { return __skuID; }
			set { __skuID = value; __skuIDSpecified = true; }
		}

		[XmlElement(ElementName="skuType",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public xonline.common.offerutil.SKUType __skuType;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __skuTypeSpecified;
		
		[XmlIgnore]
		public xonline.common.offerutil.SKUType skuType
		{ 
			get { return __skuType; }
			set { __skuType = value; __skuTypeSpecified = true; }
		}

		[XmlElement(ElementName="sku",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="string",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __sku;
		
		[XmlIgnore]
		public string sku
		{ 
			get { return __sku; }
			set { __sku = value; }
		}

		[XmlElement(ElementName="friendlyName",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="string",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __friendlyName;
		
		[XmlIgnore]
		public string friendlyName
		{ 
			get { return __friendlyName; }
			set { __friendlyName = value; }
		}

		public SKUDetails()
		{
		}
	}


	[XmlType(TypeName="OfferDMPInfo",Namespace=Declarations.SchemaVersion),Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class OfferDMPInfo
	{

		[XmlElement(Type=typeof(xonline.common.offerutil.SKUDetails),ElementName="sku",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public xonline.common.offerutil.SKUDetails __sku;
		
		[XmlIgnore]
		public xonline.common.offerutil.SKUDetails sku
		{
			get
			{
				if (__sku == null) __sku = new xonline.common.offerutil.SKUDetails();		
				return __sku;
			}
			set {__sku = value;}
		}

		[XmlElement(Type=typeof(xonline.common.offerutil.CampaignDetails),ElementName="campaign",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public xonline.common.offerutil.CampaignDetails __campaign;
		
		[XmlIgnore]
		public xonline.common.offerutil.CampaignDetails campaign
		{
			get
			{
				if (__campaign == null) __campaign = new xonline.common.offerutil.CampaignDetails();		
				return __campaign;
			}
			set {__campaign = value;}
		}

		public OfferDMPInfo()
		{
		}
	}


	[XmlType(TypeName="OfferConsumableInfo",Namespace=Declarations.SchemaVersion),Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class OfferConsumableInfo
	{

		[XmlElement(ElementName="assetID",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="unsignedInt",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __assetID;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __assetIDSpecified;
		
		[XmlIgnore]
		public uint assetID
		{ 
			get { return __assetID; }
			set { __assetID = value; __assetIDSpecified = true; }
		}

		[XmlElement(ElementName="quantity",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="unsignedInt",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __quantity;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __quantitySpecified;
		
		[XmlIgnore]
		public uint quantity
		{ 
			get { return __quantity; }
			set { __quantity = value; __quantitySpecified = true; }
		}

		public OfferConsumableInfo()
		{
		}
	}


	[XmlType(TypeName="PaymentTypePoints",Namespace=Declarations.SchemaVersion),Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class PaymentTypePoints
	{

		[XmlElement(ElementName="boid",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="string",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __boid;
		
		[XmlIgnore]
		public string boid
		{ 
			get { return __boid; }
			set { __boid = value; }
		}

		[XmlElement(ElementName="priceInPoints",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="unsignedInt",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __priceInPoints;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __priceInPointsSpecified;
		
		[XmlIgnore]
		public uint priceInPoints
		{ 
			get { return __priceInPoints; }
			set { __priceInPoints = value; __priceInPointsSpecified = true; }
		}

		public PaymentTypePoints()
		{
		}
	}


	[XmlType(TypeName="PaymentTypeCreditCard",Namespace=Declarations.SchemaVersion),Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class PaymentTypeCreditCard
	{

		[XmlElement(ElementName="priceWhole",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="unsignedInt",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __priceWhole;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __priceWholeSpecified;
		
		[XmlIgnore]
		public uint priceWhole
		{ 
			get { return __priceWhole; }
			set { __priceWhole = value; __priceWholeSpecified = true; }
		}

		[XmlElement(ElementName="priceFractional",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="unsignedInt",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __priceFractional;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __priceFractionalSpecified;
		
		[XmlIgnore]
		public uint priceFractional
		{ 
			get { return __priceFractional; }
			set { __priceFractional = value; __priceFractionalSpecified = true; }
		}

		[XmlElement(ElementName="taxType",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public xonline.common.offerutil.TaxType __taxType;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __taxTypeSpecified;
		
		[XmlIgnore]
		public xonline.common.offerutil.TaxType taxType
		{ 
			get { return __taxType; }
			set { __taxType = value; __taxTypeSpecified = true; }
		}

		public PaymentTypeCreditCard()
		{
		}
	}


	[XmlType(TypeName="PaymentTypeSCG",Namespace=Declarations.SchemaVersion),Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class PaymentTypeSCG
	{

		[XmlElement(ElementName="boid",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="string",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __boid;
		
		[XmlIgnore]
		public string boid
		{ 
			get { return __boid; }
			set { __boid = value; }
		}

		[XmlElement(ElementName="priceWhole",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="unsignedInt",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __priceWhole;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __priceWholeSpecified;
		
		[XmlIgnore]
		public uint priceWhole
		{ 
			get { return __priceWhole; }
			set { __priceWhole = value; __priceWholeSpecified = true; }
		}

		[XmlElement(ElementName="priceFractional",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="unsignedInt",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __priceFractional;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __priceFractionalSpecified;
		
		[XmlIgnore]
		public uint priceFractional
		{ 
			get { return __priceFractional; }
			set { __priceFractional = value; __priceFractionalSpecified = true; }
		}

		[XmlElement(ElementName="taxType",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public xonline.common.offerutil.TaxType __taxType;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __taxTypeSpecified;
		
		[XmlIgnore]
		public xonline.common.offerutil.TaxType taxType
		{ 
			get { return __taxType; }
			set { __taxType = value; __taxTypeSpecified = true; }
		}

		public PaymentTypeSCG()
		{
		}
	}


	[XmlType(TypeName="PaymentTypeSCGToken",Namespace=Declarations.SchemaVersion),Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class PaymentTypeSCGToken
	{

		[XmlElement(ElementName="boid",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="string",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __boid;
		
		[XmlIgnore]
		public string boid
		{ 
			get { return __boid; }
			set { __boid = value; }
		}

		public PaymentTypeSCGToken()
		{
		}
	}


	[XmlType(TypeName="PaymentTypeWholesale",Namespace=Declarations.SchemaVersion),Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class PaymentTypeWholesale
	{

		[XmlElement(ElementName="wholesalePartner",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="string",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __wholesalePartner;
		
		[XmlIgnore]
		public string wholesalePartner
		{ 
			get { return __wholesalePartner; }
			set { __wholesalePartner = value; }
		}

		[XmlElement(ElementName="boid",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="string",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __boid;
		
		[XmlIgnore]
		public string boid
		{ 
			get { return __boid; }
			set { __boid = value; }
		}

		[XmlElement(ElementName="priceWhole",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="unsignedInt",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __priceWhole;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __priceWholeSpecified;
		
		[XmlIgnore]
		public uint priceWhole
		{ 
			get { return __priceWhole; }
			set { __priceWhole = value; __priceWholeSpecified = true; }
		}

		[XmlElement(ElementName="priceFractional",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="unsignedInt",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __priceFractional;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __priceFractionalSpecified;
		
		[XmlIgnore]
		public uint priceFractional
		{ 
			get { return __priceFractional; }
			set { __priceFractional = value; __priceFractionalSpecified = true; }
		}

		[XmlElement(ElementName="taxType",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public xonline.common.offerutil.TaxType __taxType;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __taxTypeSpecified;
		
		[XmlIgnore]
		public xonline.common.offerutil.TaxType taxType
		{ 
			get { return __taxType; }
			set { __taxType = value; __taxTypeSpecified = true; }
		}

		public PaymentTypeWholesale()
		{
		}
	}


	[XmlType(TypeName="OfferCultureDetails",Namespace=Declarations.SchemaVersion),Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class OfferCultureDetails
	{

		[XmlElement(ElementName="culture",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="unsignedInt",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __culture;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __cultureSpecified;
		
		[XmlIgnore]
		public uint culture
		{ 
			get { return __culture; }
			set { __culture = value; __cultureSpecified = true; }
		}

		[XmlElement(ElementName="name",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="string",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __name;
		
		[XmlIgnore]
		public string name
		{ 
			get { return __name; }
			set { __name = value; }
		}

		[XmlElement(ElementName="sellText",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="string",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __sellText;
		
		[XmlIgnore]
		public string sellText
		{ 
			get { return __sellText; }
			set { __sellText = value; }
		}

		[XmlElement(ElementName="imageFilePath",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="string",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __imageFilePath;
		
		[XmlIgnore]
		public string imageFilePath
		{ 
			get { return __imageFilePath; }
			set { __imageFilePath = value; }
		}

		public OfferCultureDetails()
		{
		}
	}


	[XmlType(TypeName="OfferRegionInfo",Namespace=Declarations.SchemaVersion),Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class OfferRegionInfo
	{

		[XmlElement(ElementName="countryID",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="unsignedByte",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public byte __countryID;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __countryIDSpecified;
		
		[XmlIgnore]
		public byte countryID
		{ 
			get { return __countryID; }
			set { __countryID = value; __countryIDSpecified = true; }
		}

		[XmlElement(ElementName="liveTier",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public xonline.common.offerutil.LiveTier __liveTier;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __liveTierSpecified;
		
		[XmlIgnore]
		public xonline.common.offerutil.LiveTier liveTier
		{ 
			get { return __liveTier; }
			set { __liveTier = value; __liveTierSpecified = true; }
		}

		[XmlElement(ElementName="startDate",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="dateTime",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public DateTime __startDate;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __startDateSpecified;
		
		[XmlIgnore]
		public DateTime startDate
		{ 
			get { return __startDate; }
			set { __startDate = value; __startDateSpecified = true; }
		}
		
		[XmlIgnore]
		public DateTime startDateUtc
		{ 
			get { return __startDate.ToUniversalTime(); }
			set { __startDate = value.ToLocalTime(); __startDateSpecified = true; }
		}

		[XmlElement(ElementName="endDate",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="dateTime",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public DateTime __endDate;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __endDateSpecified;
		
		[XmlIgnore]
		public DateTime endDate
		{ 
			get { return __endDate; }
			set { __endDate = value; __endDateSpecified = true; }
		}
		
		[XmlIgnore]
		public DateTime endDateUtc
		{ 
			get { return __endDate.ToUniversalTime(); }
			set { __endDate = value.ToLocalTime(); __endDateSpecified = true; }
		}

		[XmlElement(Type=typeof(xonline.common.offerutil.PaymentTypePoints),ElementName="paymentTypePoints",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public xonline.common.offerutil.PaymentTypePoints __paymentTypePoints;
		
		[XmlIgnore]
		public xonline.common.offerutil.PaymentTypePoints paymentTypePoints
		{
			get
			{
				if (__paymentTypePoints == null) __paymentTypePoints = new xonline.common.offerutil.PaymentTypePoints();		
				return __paymentTypePoints;
			}
			set {__paymentTypePoints = value;}
		}

		[XmlElement(Type=typeof(xonline.common.offerutil.PaymentTypeSCG),ElementName="paymentTypeSCG",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public xonline.common.offerutil.PaymentTypeSCG __paymentTypeSCG;
		
		[XmlIgnore]
		public xonline.common.offerutil.PaymentTypeSCG paymentTypeSCG
		{
			get
			{
				if (__paymentTypeSCG == null) __paymentTypeSCG = new xonline.common.offerutil.PaymentTypeSCG();		
				return __paymentTypeSCG;
			}
			set {__paymentTypeSCG = value;}
		}

		[XmlElement(Type=typeof(xonline.common.offerutil.PaymentTypeSCGToken),ElementName="paymentTypeSCGToken",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public xonline.common.offerutil.PaymentTypeSCGToken __paymentTypeSCGToken;
		
		[XmlIgnore]
		public xonline.common.offerutil.PaymentTypeSCGToken paymentTypeSCGToken
		{
			get
			{
				if (__paymentTypeSCGToken == null) __paymentTypeSCGToken = new xonline.common.offerutil.PaymentTypeSCGToken();		
				return __paymentTypeSCGToken;
			}
			set {__paymentTypeSCGToken = value;}
		}

		[XmlElement(ElementName="paymentTypeXboxToken",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="boolean",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __paymentTypeXboxToken;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __paymentTypeXboxTokenSpecified;
		
		[XmlIgnore]
		public bool paymentTypeXboxToken
		{ 
			get { return __paymentTypeXboxToken; }
			set { __paymentTypeXboxToken = value; __paymentTypeXboxTokenSpecified = true; }
		}

		[XmlElement(Type=typeof(xonline.common.offerutil.PaymentTypeWholesale),ElementName="paymentTypeWholesale",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public PaymentTypeWholesaleCollection __paymentTypeWholesaleCollection;
		
		[XmlIgnore]
		public PaymentTypeWholesaleCollection paymentTypeWholesaleCollection
		{
			get
			{
				if (__paymentTypeWholesaleCollection == null) __paymentTypeWholesaleCollection = new PaymentTypeWholesaleCollection();
				return __paymentTypeWholesaleCollection;
			}
			set {__paymentTypeWholesaleCollection = value;}
		}

		[XmlElement(Type=typeof(xonline.common.offerutil.PaymentTypeCreditCard),ElementName="paymentTypeCreditCard",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public xonline.common.offerutil.PaymentTypeCreditCard __paymentTypeCreditCard;
		
		[XmlIgnore]
		public xonline.common.offerutil.PaymentTypeCreditCard paymentTypeCreditCard
		{
			get
			{
				if (__paymentTypeCreditCard == null) __paymentTypeCreditCard = new xonline.common.offerutil.PaymentTypeCreditCard();		
				return __paymentTypeCreditCard;
			}
			set {__paymentTypeCreditCard = value;}
		}

		[XmlElement(ElementName="providerId",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="unsignedInt",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __providerId;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __providerIdSpecified;
		
		[XmlIgnore]
		public uint providerId
		{ 
			get { return __providerId; }
			set { __providerId = value; __providerIdSpecified = true; }
		}

		public OfferRegionInfo()
		{
			__startDate = DateTime.Now;
			__endDate = DateTime.Now;
		}
	}


	[XmlType(TypeName="OfferBasicInfo",Namespace=Declarations.SchemaVersion),Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class OfferBasicInfo
	{

		[XmlElement(ElementName="offerID",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="string",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __offerID;
		
		[XmlIgnore]
		public string offerID
		{ 
			get { return __offerID; }
			set { __offerID = value; }
		}

		[XmlElement(ElementName="consoleType",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public xonline.common.offerutil.ConsoleType __consoleType;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __consoleTypeSpecified;
		
		[XmlIgnore]
		public xonline.common.offerutil.ConsoleType consoleType
		{ 
			get { return __consoleType; }
			set { __consoleType = value; __consoleTypeSpecified = true; }
		}

		[XmlElement(ElementName="friendlyName",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="string",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __friendlyName;
		
		[XmlIgnore]
		public string friendlyName
		{ 
			get { return __friendlyName; }
			set { __friendlyName = value; }
		}

		[XmlElement(ElementName="primaryTitleID",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="string",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __primaryTitleID;
		
		[XmlIgnore]
		public string primaryTitleID
		{ 
			get { return __primaryTitleID; }
			set { __primaryTitleID = value; }
		}

		[XmlElement(Type=typeof(string),ElementName="associatedTitleID",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="string",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public associatedTitleIDCollection __associatedTitleIDCollection;
		
		[XmlIgnore]
		public associatedTitleIDCollection associatedTitleIDCollection
		{
			get
			{
				if (__associatedTitleIDCollection == null) __associatedTitleIDCollection = new associatedTitleIDCollection();
				return __associatedTitleIDCollection;
			}
			set {__associatedTitleIDCollection = value;}
		}

		[XmlElement(ElementName="bitFilter",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="string",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __bitFilter;
		
		[XmlIgnore]
		public string bitFilter
		{ 
			get { return __bitFilter; }
			set { __bitFilter = value; }
		}

		[XmlElement(ElementName="offerEnumerationType",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public xonline.common.offerutil.OfferEnumerationType __offerEnumerationType;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __offerEnumerationTypeSpecified;
		
		[XmlIgnore]
		public xonline.common.offerutil.OfferEnumerationType offerEnumerationType
		{ 
			get { return __offerEnumerationType; }
			set { __offerEnumerationType = value; __offerEnumerationTypeSpecified = true; }
		}

		[XmlElement(Type=typeof(xonline.common.offerutil.OfferCultureDetails),ElementName="offerCultureDetails",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public OfferCultureDetailsCollection __offerCultureDetailsCollection;
		
		[XmlIgnore]
		public OfferCultureDetailsCollection offerCultureDetailsCollection
		{
			get
			{
				if (__offerCultureDetailsCollection == null) __offerCultureDetailsCollection = new OfferCultureDetailsCollection();
				return __offerCultureDetailsCollection;
			}
			set {__offerCultureDetailsCollection = value;}
		}

		[XmlElement(Type=typeof(xonline.common.offerutil.OfferRegionInfo),ElementName="offerRegionInfo",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public OfferRegionInfoCollection __offerRegionInfoCollection;
		
		[XmlIgnore]
		public OfferRegionInfoCollection offerRegionInfoCollection
		{
			get
			{
				if (__offerRegionInfoCollection == null) __offerRegionInfoCollection = new OfferRegionInfoCollection();
				return __offerRegionInfoCollection;
			}
			set {__offerRegionInfoCollection = value;}
		}

		[XmlElement(ElementName="requiresGeofencing",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="boolean",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __requiresGeofencing;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __requiresGeofencingSpecified;
		
		[XmlIgnore]
		public bool requiresGeofencing
		{ 
			get { return __requiresGeofencing; }
			set { __requiresGeofencing = value; __requiresGeofencingSpecified = true; }
		}

		public OfferBasicInfo()
		{
		}
	}


	[XmlType(TypeName="OfferPrivilegeInfo",Namespace=Declarations.SchemaVersion),Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class OfferPrivilegeInfo
	{

		[XmlElement(Type=typeof(uint),ElementName="offerPrivilegeGrant",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="unsignedInt",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public offerPrivilegeGrantCollection __offerPrivilegeGrantCollection;
		
		[XmlIgnore]
		public offerPrivilegeGrantCollection offerPrivilegeGrantCollection
		{
			get
			{
				if (__offerPrivilegeGrantCollection == null) __offerPrivilegeGrantCollection = new offerPrivilegeGrantCollection();
				return __offerPrivilegeGrantCollection;
			}
			set {__offerPrivilegeGrantCollection = value;}
		}

		[XmlElement(Type=typeof(uint),ElementName="offerPrivilegeRestriction",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="unsignedInt",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public offerPrivilegeRestrictionCollection __offerPrivilegeRestrictionCollection;
		
		[XmlIgnore]
		public offerPrivilegeRestrictionCollection offerPrivilegeRestrictionCollection
		{
			get
			{
				if (__offerPrivilegeRestrictionCollection == null) __offerPrivilegeRestrictionCollection = new offerPrivilegeRestrictionCollection();
				return __offerPrivilegeRestrictionCollection;
			}
			set {__offerPrivilegeRestrictionCollection = value;}
		}

		public OfferPrivilegeInfo()
		{
		}
	}


	[XmlType(TypeName="SubscriptionTypeInfo",Namespace=Declarations.SchemaVersion),Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class SubscriptionTypeInfo
	{

		[XmlElement(ElementName="subscriptionType",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="short",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public short __subscriptionType;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __subscriptionTypeSpecified;
		
		[XmlIgnore]
		public short subscriptionType
		{ 
			get { return __subscriptionType; }
			set { __subscriptionType = value; __subscriptionTypeSpecified = true; }
		}

		[XmlElement(ElementName="tierProvided",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public xonline.common.offerutil.LiveTier __tierProvided;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __tierProvidedSpecified;
		
		[XmlIgnore]
		public xonline.common.offerutil.LiveTier tierProvided
		{ 
			get { return __tierProvided; }
			set { __tierProvided = value; __tierProvidedSpecified = true; }
		}

		[XmlElement(ElementName="isBase",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="boolean",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __isBase;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __isBaseSpecified;
		
		[XmlIgnore]
		public bool isBase
		{ 
			get { return __isBase; }
			set { __isBase = value; __isBaseSpecified = true; }
		}

		public SubscriptionTypeInfo()
		{
		}
	}


	[XmlType(TypeName="SubscriptionBasicInfo",Namespace=Declarations.SchemaVersion),Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class SubscriptionBasicInfo
	{

		[XmlElement(ElementName="offerID",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="string",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __offerID;
		
		[XmlIgnore]
		public string offerID
		{ 
			get { return __offerID; }
			set { __offerID = value; }
		}

		[XmlElement(ElementName="consoleType",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public xonline.common.offerutil.ConsoleType __consoleType;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __consoleTypeSpecified;
		
		[XmlIgnore]
		public xonline.common.offerutil.ConsoleType consoleType
		{ 
			get { return __consoleType; }
			set { __consoleType = value; __consoleTypeSpecified = true; }
		}

		[XmlElement(ElementName="friendlyName",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="string",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __friendlyName;
		
		[XmlIgnore]
		public string friendlyName
		{ 
			get { return __friendlyName; }
			set { __friendlyName = value; }
		}

		[XmlElement(Type=typeof(string),ElementName="titleID",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="string",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public titleIDCollection __titleIDCollection;
		
		[XmlIgnore]
		public titleIDCollection titleIDCollection
		{
			get
			{
				if (__titleIDCollection == null) __titleIDCollection = new titleIDCollection();
				return __titleIDCollection;
			}
			set {__titleIDCollection = value;}
		}

		[XmlElement(ElementName="bitFilter",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="string",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __bitFilter;
		
		[XmlIgnore]
		public string bitFilter
		{ 
			get { return __bitFilter; }
			set { __bitFilter = value; }
		}

		[XmlElement(ElementName="offerEnumerationType",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public xonline.common.offerutil.OfferEnumerationType __offerEnumerationType;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __offerEnumerationTypeSpecified;
		
		[XmlIgnore]
		public xonline.common.offerutil.OfferEnumerationType offerEnumerationType
		{ 
			get { return __offerEnumerationType; }
			set { __offerEnumerationType = value; __offerEnumerationTypeSpecified = true; }
		}

		[XmlElement(ElementName="billingComponentID",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="string",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __billingComponentID;
		
		[XmlIgnore]
		public string billingComponentID
		{ 
			get { return __billingComponentID; }
			set { __billingComponentID = value; }
		}

		[XmlElement(ElementName="subscriptionFrequency",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public xonline.common.offerutil.SubscriptionFrequency __subscriptionFrequency;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __subscriptionFrequencySpecified;
		
		[XmlIgnore]
		public xonline.common.offerutil.SubscriptionFrequency subscriptionFrequency
		{ 
			get { return __subscriptionFrequency; }
			set { __subscriptionFrequency = value; __subscriptionFrequencySpecified = true; }
		}

		[XmlElement(ElementName="duration",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="unsignedByte",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public byte __duration;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __durationSpecified;
		
		[XmlIgnore]
		public byte duration
		{ 
			get { return __duration; }
			set { __duration = value; __durationSpecified = true; }
		}

		[XmlElement(ElementName="cancelable",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="boolean",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __cancelable;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __cancelableSpecified;
		
		[XmlIgnore]
		public bool cancelable
		{ 
			get { return __cancelable; }
			set { __cancelable = value; __cancelableSpecified = true; }
		}

		[XmlElement(Type=typeof(xonline.common.offerutil.OfferPrivilegeInfo),ElementName="offerPrivilegeInfo",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public xonline.common.offerutil.OfferPrivilegeInfo __offerPrivilegeInfo;
		
		[XmlIgnore]
		public xonline.common.offerutil.OfferPrivilegeInfo offerPrivilegeInfo
		{
			get
			{
				if (__offerPrivilegeInfo == null) __offerPrivilegeInfo = new xonline.common.offerutil.OfferPrivilegeInfo();		
				return __offerPrivilegeInfo;
			}
			set {__offerPrivilegeInfo = value;}
		}

		[XmlElement(Type=typeof(xonline.common.offerutil.OfferCultureDetails),ElementName="offerCultureDetails",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public OfferCultureDetailsCollection __offerCultureDetailsCollection;
		
		[XmlIgnore]
		public OfferCultureDetailsCollection offerCultureDetailsCollection
		{
			get
			{
				if (__offerCultureDetailsCollection == null) __offerCultureDetailsCollection = new OfferCultureDetailsCollection();
				return __offerCultureDetailsCollection;
			}
			set {__offerCultureDetailsCollection = value;}
		}

		[XmlElement(Type=typeof(xonline.common.offerutil.OfferRegionInfo),ElementName="offerRegionInfo",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public OfferRegionInfoCollection __offerRegionInfoCollection;
		
		[XmlIgnore]
		public OfferRegionInfoCollection offerRegionInfoCollection
		{
			get
			{
				if (__offerRegionInfoCollection == null) __offerRegionInfoCollection = new OfferRegionInfoCollection();
				return __offerRegionInfoCollection;
			}
			set {__offerRegionInfoCollection = value;}
		}

		public SubscriptionBasicInfo()
		{
		}
	}


	[XmlType(TypeName="OfferSubscriptionRewardInfo",Namespace=Declarations.SchemaVersion),Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class OfferSubscriptionRewardInfo
	{

		[XmlElement(ElementName="countryID",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="unsignedByte",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public byte __countryID;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __countryIDSpecified;
		
		[XmlIgnore]
		public byte countryID
		{ 
			get { return __countryID; }
			set { __countryID = value; __countryIDSpecified = true; }
		}

		[XmlElement(ElementName="userTier",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public xonline.common.offerutil.LiveTier __userTier;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __userTierSpecified;
		
		[XmlIgnore]
		public xonline.common.offerutil.LiveTier userTier
		{ 
			get { return __userTier; }
			set { __userTier = value; __userTierSpecified = true; }
		}

		[XmlElement(ElementName="startDate",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="dateTime",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public DateTime __startDate;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __startDateSpecified;
		
		[XmlIgnore]
		public DateTime startDate
		{ 
			get { return __startDate; }
			set { __startDate = value; __startDateSpecified = true; }
		}
		
		[XmlIgnore]
		public DateTime startDateUtc
		{ 
			get { return __startDate.ToUniversalTime(); }
			set { __startDate = value.ToLocalTime(); __startDateSpecified = true; }
		}

		[XmlElement(ElementName="endDate",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="dateTime",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public DateTime __endDate;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __endDateSpecified;
		
		[XmlIgnore]
		public DateTime endDate
		{ 
			get { return __endDate; }
			set { __endDate = value; __endDateSpecified = true; }
		}
		
		[XmlIgnore]
		public DateTime endDateUtc
		{ 
			get { return __endDate.ToUniversalTime(); }
			set { __endDate = value.ToLocalTime(); __endDateSpecified = true; }
		}

		[XmlElement(ElementName="rewardID",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="unsignedInt",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __rewardID;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __rewardIDSpecified;
		
		[XmlIgnore]
		public uint rewardID
		{ 
			get { return __rewardID; }
			set { __rewardID = value; __rewardIDSpecified = true; }
		}

		public OfferSubscriptionRewardInfo()
		{
			__startDate = DateTime.Now;
			__endDate = DateTime.Now;
		}
	}


	[XmlType(TypeName="LiveSubscriptionRelation",Namespace=Declarations.SchemaVersion),Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class LiveSubscriptionRelation
	{

		[XmlElement(ElementName="offerIDFrom",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="string",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __offerIDFrom;
		
		[XmlIgnore]
		public string offerIDFrom
		{ 
			get { return __offerIDFrom; }
			set { __offerIDFrom = value; }
		}

		[XmlElement(ElementName="relationType",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public xonline.common.offerutil.OfferRelationType __relationType;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __relationTypeSpecified;
		
		[XmlIgnore]
		public xonline.common.offerutil.OfferRelationType relationType
		{ 
			get { return __relationType; }
			set { __relationType = value; __relationTypeSpecified = true; }
		}

		[XmlElement(ElementName="convertMode",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public xonline.common.offerutil.OfferConvertMode __convertMode;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __convertModeSpecified;
		
		[XmlIgnore]
		public xonline.common.offerutil.OfferConvertMode convertMode
		{ 
			get { return __convertMode; }
			set { __convertMode = value; __convertModeSpecified = true; }
		}

		public LiveSubscriptionRelation()
		{
		}
	}


	[XmlType(TypeName="LiveSubscription",Namespace=Declarations.SchemaVersion),Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class LiveSubscription
	{

		[XmlElement(ElementName="liveTierProvided",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public xonline.common.offerutil.LiveTier __liveTierProvided;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __liveTierProvidedSpecified;
		
		[XmlIgnore]
		public xonline.common.offerutil.LiveTier liveTierProvided
		{ 
			get { return __liveTierProvided; }
			set { __liveTierProvided = value; __liveTierProvidedSpecified = true; }
		}

		[XmlElement(ElementName="allowsXbox1Play",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="boolean",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __allowsXbox1Play;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __allowsXbox1PlaySpecified;
		
		[XmlIgnore]
		public bool allowsXbox1Play
		{ 
			get { return __allowsXbox1Play; }
			set { __allowsXbox1Play = value; __allowsXbox1PlaySpecified = true; }
		}

		[XmlElement(ElementName="isTrial",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="boolean",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __isTrial;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __isTrialSpecified;
		
		[XmlIgnore]
		public bool isTrial
		{ 
			get { return __isTrial; }
			set { __isTrial = value; __isTrialSpecified = true; }
		}

		[XmlElement(Type=typeof(xonline.common.offerutil.SubscriptionTypeInfo),ElementName="subscriptionTypeInfo",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public xonline.common.offerutil.SubscriptionTypeInfo __subscriptionTypeInfo;
		
		[XmlIgnore]
		public xonline.common.offerutil.SubscriptionTypeInfo subscriptionTypeInfo
		{
			get
			{
				if (__subscriptionTypeInfo == null) __subscriptionTypeInfo = new xonline.common.offerutil.SubscriptionTypeInfo();		
				return __subscriptionTypeInfo;
			}
			set {__subscriptionTypeInfo = value;}
		}

		[XmlElement(Type=typeof(xonline.common.offerutil.SubscriptionBasicInfo),ElementName="subscriptionBasicInfo",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public xonline.common.offerutil.SubscriptionBasicInfo __subscriptionBasicInfo;
		
		[XmlIgnore]
		public xonline.common.offerutil.SubscriptionBasicInfo subscriptionBasicInfo
		{
			get
			{
				if (__subscriptionBasicInfo == null) __subscriptionBasicInfo = new xonline.common.offerutil.SubscriptionBasicInfo();		
				return __subscriptionBasicInfo;
			}
			set {__subscriptionBasicInfo = value;}
		}

		[XmlElement(Type=typeof(xonline.common.offerutil.OfferSubscriptionRewardInfo),ElementName="offerSubscriptionRewardInfo",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public OfferSubscriptionRewardInfoCollection __offerSubscriptionRewardInfoCollection;
		
		[XmlIgnore]
		public OfferSubscriptionRewardInfoCollection offerSubscriptionRewardInfoCollection
		{
			get
			{
				if (__offerSubscriptionRewardInfoCollection == null) __offerSubscriptionRewardInfoCollection = new OfferSubscriptionRewardInfoCollection();
				return __offerSubscriptionRewardInfoCollection;
			}
			set {__offerSubscriptionRewardInfoCollection = value;}
		}

		[XmlElement(Type=typeof(xonline.common.offerutil.LiveSubscriptionRelation),ElementName="offerRelationInfo",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public LiveSubscriptionRelationCollection __offerRelationInfoCollection;
		
		[XmlIgnore]
		public LiveSubscriptionRelationCollection offerRelationInfoCollection
		{
			get
			{
				if (__offerRelationInfoCollection == null) __offerRelationInfoCollection = new LiveSubscriptionRelationCollection();
				return __offerRelationInfoCollection;
			}
			set {__offerRelationInfoCollection = value;}
		}

		public LiveSubscription()
		{
		}
	}


	[XmlType(TypeName="GameSubscription",Namespace=Declarations.SchemaVersion),Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class GameSubscription
	{

		[XmlElement(ElementName="liveServiceProvided",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="unsignedInt",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __liveServiceProvided;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __liveServiceProvidedSpecified;
		
		[XmlIgnore]
		public uint liveServiceProvided
		{ 
			get { return __liveServiceProvided; }
			set { __liveServiceProvided = value; __liveServiceProvidedSpecified = true; }
		}

		[XmlElement(Type=typeof(xonline.common.offerutil.SubscriptionTypeInfo),ElementName="subscriptionTypeInfo",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public xonline.common.offerutil.SubscriptionTypeInfo __subscriptionTypeInfo;
		
		[XmlIgnore]
		public xonline.common.offerutil.SubscriptionTypeInfo subscriptionTypeInfo
		{
			get
			{
				if (__subscriptionTypeInfo == null) __subscriptionTypeInfo = new xonline.common.offerutil.SubscriptionTypeInfo();		
				return __subscriptionTypeInfo;
			}
			set {__subscriptionTypeInfo = value;}
		}

		[XmlElement(Type=typeof(xonline.common.offerutil.SubscriptionBasicInfo),ElementName="subscriptionBasicInfo",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public xonline.common.offerutil.SubscriptionBasicInfo __subscriptionBasicInfo;
		
		[XmlIgnore]
		public xonline.common.offerutil.SubscriptionBasicInfo subscriptionBasicInfo
		{
			get
			{
				if (__subscriptionBasicInfo == null) __subscriptionBasicInfo = new xonline.common.offerutil.SubscriptionBasicInfo();		
				return __subscriptionBasicInfo;
			}
			set {__subscriptionBasicInfo = value;}
		}

		[XmlElement(Type=typeof(xonline.common.offerutil.LiveSubscriptionRelation),ElementName="offerRelationInfo",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public LiveSubscriptionRelationCollection __offerRelationInfoCollection;
		
		[XmlIgnore]
		public LiveSubscriptionRelationCollection offerRelationInfoCollection
		{
			get
			{
				if (__offerRelationInfoCollection == null) __offerRelationInfoCollection = new LiveSubscriptionRelationCollection();
				return __offerRelationInfoCollection;
			}
			set {__offerRelationInfoCollection = value;}
		}

		public GameSubscription()
		{
		}
	}


	[XmlType(TypeName="TitleCultureDetails",Namespace=Declarations.SchemaVersion),Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class TitleCultureDetails
	{

		[XmlElement(ElementName="culture",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="unsignedInt",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __culture;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __cultureSpecified;
		
		[XmlIgnore]
		public uint culture
		{ 
			get { return __culture; }
			set { __culture = value; __cultureSpecified = true; }
		}

		[XmlElement(ElementName="name",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="string",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __name;
		
		[XmlIgnore]
		public string name
		{ 
			get { return __name; }
			set { __name = value; }
		}

		[XmlElement(ElementName="sellText",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="string",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __sellText;
		
		[XmlIgnore]
		public string sellText
		{ 
			get { return __sellText; }
			set { __sellText = value; }
		}

		[XmlElement(ElementName="publisher",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="string",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __publisher;
		
		[XmlIgnore]
		public string publisher
		{ 
			get { return __publisher; }
			set { __publisher = value; }
		}

		[XmlElement(ElementName="developer",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="string",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __developer;
		
		[XmlIgnore]
		public string developer
		{ 
			get { return __developer; }
			set { __developer = value; }
		}

		[XmlElement(ElementName="customGenre",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="string",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __customGenre;
		
		[XmlIgnore]
		public string customGenre
		{ 
			get { return __customGenre; }
			set { __customGenre = value; }
		}

		[XmlElement(ElementName="imageFilePath",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="string",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __imageFilePath;
		
		[XmlIgnore]
		public string imageFilePath
		{ 
			get { return __imageFilePath; }
			set { __imageFilePath = value; }
		}

		public TitleCultureDetails()
		{
		}
	}


	[XmlType(TypeName="RewardCultureDetails",Namespace=Declarations.SchemaVersion),Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class RewardCultureDetails
	{

		[XmlElement(ElementName="culture",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="unsignedInt",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __culture;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __cultureSpecified;
		
		[XmlIgnore]
		public uint culture
		{ 
			get { return __culture; }
			set { __culture = value; __cultureSpecified = true; }
		}

		[XmlElement(ElementName="acquisitionTitle",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="string",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __acquisitionTitle;
		
		[XmlIgnore]
		public string acquisitionTitle
		{ 
			get { return __acquisitionTitle; }
			set { __acquisitionTitle = value; }
		}

		public RewardCultureDetails()
		{
		}
	}


	[XmlType(TypeName="Reward",Namespace=Declarations.SchemaVersion),Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class Reward
	{

		[XmlElement(ElementName="rewardID",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="unsignedInt",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __rewardID;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __rewardIDSpecified;
		
		[XmlIgnore]
		public uint rewardID
		{ 
			get { return __rewardID; }
			set { __rewardID = value; __rewardIDSpecified = true; }
		}

		[XmlElement(ElementName="pointsRewarded",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="unsignedInt",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __pointsRewarded;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __pointsRewardedSpecified;
		
		[XmlIgnore]
		public uint pointsRewarded
		{ 
			get { return __pointsRewarded; }
			set { __pointsRewarded = value; __pointsRewardedSpecified = true; }
		}

		[XmlElement(Type=typeof(xonline.common.offerutil.SKUDetails),ElementName="sku",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public xonline.common.offerutil.SKUDetails __sku;
		
		[XmlIgnore]
		public xonline.common.offerutil.SKUDetails sku
		{
			get
			{
				if (__sku == null) __sku = new xonline.common.offerutil.SKUDetails();		
				return __sku;
			}
			set {__sku = value;}
		}

		[XmlElement(Type=typeof(xonline.common.offerutil.CampaignDetails),ElementName="campaign",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public xonline.common.offerutil.CampaignDetails __campaign;
		
		[XmlIgnore]
		public xonline.common.offerutil.CampaignDetails campaign
		{
			get
			{
				if (__campaign == null) __campaign = new xonline.common.offerutil.CampaignDetails();		
				return __campaign;
			}
			set {__campaign = value;}
		}

		[XmlElement(Type=typeof(xonline.common.offerutil.AcquisitionType),ElementName="acquisitionType",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public xonline.common.offerutil.AcquisitionType __acquisitionType;
		
		[XmlIgnore]
		public xonline.common.offerutil.AcquisitionType acquisitionType
		{
			get
			{
				if (__acquisitionType == null) __acquisitionType = new xonline.common.offerutil.AcquisitionType();		
				return __acquisitionType;
			}
			set {__acquisitionType = value;}
		}

		[XmlElement(Type=typeof(xonline.common.offerutil.RewardCultureDetails),ElementName="rewardCultureDetails",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public RewardCultureDetailsCollection __rewardCultureDetailsCollection;
		
		[XmlIgnore]
		public RewardCultureDetailsCollection rewardCultureDetailsCollection
		{
			get
			{
				if (__rewardCultureDetailsCollection == null) __rewardCultureDetailsCollection = new RewardCultureDetailsCollection();
				return __rewardCultureDetailsCollection;
			}
			set {__rewardCultureDetailsCollection = value;}
		}

		public Reward()
		{
		}
	}


	[XmlType(TypeName="Title",Namespace=Declarations.SchemaVersion),Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class Title
	{

		[XmlElement(ElementName="titleID",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="string",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __titleID;
		
		[XmlIgnore]
		public string titleID
		{ 
			get { return __titleID; }
			set { __titleID = value; }
		}

		[XmlElement(ElementName="consoleType",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public xonline.common.offerutil.ConsoleType __consoleType;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __consoleTypeSpecified;
		
		[XmlIgnore]
		public xonline.common.offerutil.ConsoleType consoleType
		{ 
			get { return __consoleType; }
			set { __consoleType = value; __consoleTypeSpecified = true; }
		}

		[XmlElement(Type=typeof(uint),ElementName="rating",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="unsignedInt",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ratingCollection __ratingCollection;
		
		[XmlIgnore]
		public ratingCollection ratingCollection
		{
			get
			{
				if (__ratingCollection == null) __ratingCollection = new ratingCollection();
				return __ratingCollection;
			}
			set {__ratingCollection = value;}
		}

		[XmlElement(ElementName="genre",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public xonline.common.offerutil.Genre __genre;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __genreSpecified;
		
		[XmlIgnore]
		public xonline.common.offerutil.Genre genre
		{ 
			get { return __genre; }
			set { __genre = value; __genreSpecified = true; }
		}

		[XmlElement(Type=typeof(xonline.common.offerutil.TitleCultureDetails),ElementName="titleCultureDetails",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public TitleCultureDetailsCollection __titleCultureDetailsCollection;
		
		[XmlIgnore]
		public TitleCultureDetailsCollection titleCultureDetailsCollection
		{
			get
			{
				if (__titleCultureDetailsCollection == null) __titleCultureDetailsCollection = new TitleCultureDetailsCollection();
				return __titleCultureDetailsCollection;
			}
			set {__titleCultureDetailsCollection = value;}
		}

		public Title()
		{
		}
	}


	[XmlType(TypeName="ContentOffer",Namespace=Declarations.SchemaVersion),Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class ContentOffer
	{

		[XmlElement(ElementName="contentOfferType",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public xonline.common.offerutil.ContentOfferType __contentOfferType;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __contentOfferTypeSpecified;
		
		[XmlIgnore]
		public xonline.common.offerutil.ContentOfferType contentOfferType
		{ 
			get { return __contentOfferType; }
			set { __contentOfferType = value; __contentOfferTypeSpecified = true; }
		}

		[XmlElement(ElementName="gameContentMediaId",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="string",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __gameContentMediaId;
		
		[XmlIgnore]
		public string gameContentMediaId
		{ 
			get { return __gameContentMediaId; }
			set { __gameContentMediaId = value; }
		}

		[XmlElement(Type=typeof(xonline.common.offerutil.OfferBasicInfo),ElementName="offerBasicInfo",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public xonline.common.offerutil.OfferBasicInfo __offerBasicInfo;
		
		[XmlIgnore]
		public xonline.common.offerutil.OfferBasicInfo offerBasicInfo
		{
			get
			{
				if (__offerBasicInfo == null) __offerBasicInfo = new xonline.common.offerutil.OfferBasicInfo();		
				return __offerBasicInfo;
			}
			set {__offerBasicInfo = value;}
		}

		[XmlElement(Type=typeof(xonline.common.offerutil.OfferContentInfo),ElementName="offerContentInfo",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public xonline.common.offerutil.OfferContentInfo __offerContentInfo;
		
		[XmlIgnore]
		public xonline.common.offerutil.OfferContentInfo offerContentInfo
		{
			get
			{
				if (__offerContentInfo == null) __offerContentInfo = new xonline.common.offerutil.OfferContentInfo();		
				return __offerContentInfo;
			}
			set {__offerContentInfo = value;}
		}

		[XmlElement(Type=typeof(xonline.common.offerutil.OfferDMPInfo),ElementName="offerDMPInfo",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public xonline.common.offerutil.OfferDMPInfo __offerDMPInfo;
		
		[XmlIgnore]
		public xonline.common.offerutil.OfferDMPInfo offerDMPInfo
		{
			get
			{
				if (__offerDMPInfo == null) __offerDMPInfo = new xonline.common.offerutil.OfferDMPInfo();		
				return __offerDMPInfo;
			}
			set {__offerDMPInfo = value;}
		}

		[XmlElement(ElementName="contentCAB",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="string",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __contentCAB;
		
		[XmlIgnore]
		public string contentCAB
		{ 
			get { return __contentCAB; }
			set { __contentCAB = value; }
		}

		[XmlElement(Type=typeof(xonline.common.offerutil.OfferConsumableInfo),ElementName="offerConsumableInfo",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public xonline.common.offerutil.OfferConsumableInfo __offerConsumableInfo;
		
		[XmlIgnore]
		public xonline.common.offerutil.OfferConsumableInfo offerConsumableInfo
		{
			get
			{
				if (__offerConsumableInfo == null) __offerConsumableInfo = new xonline.common.offerutil.OfferConsumableInfo();		
				return __offerConsumableInfo;
			}
			set {__offerConsumableInfo = value;}
		}

		[XmlElement(Type=typeof(xonline.common.offerutil.Rating),ElementName="rating",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public RatingCollection __ratingCollection;
		
		[XmlIgnore]
		public RatingCollection ratingCollection
		{
			get
			{
				if (__ratingCollection == null) __ratingCollection = new RatingCollection();
				return __ratingCollection;
			}
			set {__ratingCollection = value;}
		}

		[XmlElement(ElementName="inheritRating",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="boolean",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __inheritRating;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __inheritRatingSpecified;
		
		[XmlIgnore]
		public bool inheritRating
		{ 
			get { return __inheritRating; }
			set { __inheritRating = value; __inheritRatingSpecified = true; }
		}

		[XmlElement(Type=typeof(xonline.common.offerutil.Category),ElementName="category",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public CategoryCollection __categoryCollection;
		
		[XmlIgnore]
		public CategoryCollection categoryCollection
		{
			get
			{
				if (__categoryCollection == null) __categoryCollection = new CategoryCollection();
				return __categoryCollection;
			}
			set {__categoryCollection = value;}
		}

		[XmlElement(ElementName="creatorContributorId",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="string",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __creatorContributorId;
		
		[XmlIgnore]
		public string creatorContributorId
		{ 
			get { return __creatorContributorId; }
			set { __creatorContributorId = value; }
		}

		public ContentOffer()
		{
		}
	}


	[XmlType(TypeName="PointsBundleOffer",Namespace=Declarations.SchemaVersion),Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class PointsBundleOffer
	{

		[XmlElement(Type=typeof(xonline.common.offerutil.CampaignDetails),ElementName="campaign",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public xonline.common.offerutil.CampaignDetails __campaign;
		
		[XmlIgnore]
		public xonline.common.offerutil.CampaignDetails campaign
		{
			get
			{
				if (__campaign == null) __campaign = new xonline.common.offerutil.CampaignDetails();		
				return __campaign;
			}
			set {__campaign = value;}
		}

		[XmlElement(Type=typeof(xonline.common.offerutil.OfferBasicInfo),ElementName="offerBasicInfo",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public xonline.common.offerutil.OfferBasicInfo __offerBasicInfo;
		
		[XmlIgnore]
		public xonline.common.offerutil.OfferBasicInfo offerBasicInfo
		{
			get
			{
				if (__offerBasicInfo == null) __offerBasicInfo = new xonline.common.offerutil.OfferBasicInfo();		
				return __offerBasicInfo;
			}
			set {__offerBasicInfo = value;}
		}

		public PointsBundleOffer()
		{
		}
	}


	[XmlType(TypeName="GamertagChangeOffer",Namespace=Declarations.SchemaVersion),Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class GamertagChangeOffer
	{

		[XmlElement(Type=typeof(xonline.common.offerutil.OfferBasicInfo),ElementName="offerBasicInfo",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public xonline.common.offerutil.OfferBasicInfo __offerBasicInfo;
		
		[XmlIgnore]
		public xonline.common.offerutil.OfferBasicInfo offerBasicInfo
		{
			get
			{
				if (__offerBasicInfo == null) __offerBasicInfo = new xonline.common.offerutil.OfferBasicInfo();		
				return __offerBasicInfo;
			}
			set {__offerBasicInfo = value;}
		}

		[XmlElement(Type=typeof(xonline.common.offerutil.OfferDMPInfo),ElementName="offerDMPInfo",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public xonline.common.offerutil.OfferDMPInfo __offerDMPInfo;
		
		[XmlIgnore]
		public xonline.common.offerutil.OfferDMPInfo offerDMPInfo
		{
			get
			{
				if (__offerDMPInfo == null) __offerDMPInfo = new xonline.common.offerutil.OfferDMPInfo();		
				return __offerDMPInfo;
			}
			set {__offerDMPInfo = value;}
		}

		public GamertagChangeOffer()
		{
		}
	}


	[XmlType(TypeName="GameplayOffer",Namespace=Declarations.SchemaVersion),Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class GameplayOffer
	{

		[XmlElement(ElementName="durationInSeconds",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="unsignedInt",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __durationInSeconds;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __durationInSecondsSpecified;
		
		[XmlIgnore]
		public uint durationInSeconds
		{ 
			get { return __durationInSeconds; }
			set { __durationInSeconds = value; __durationInSecondsSpecified = true; }
		}

		[XmlElement(Type=typeof(xonline.common.offerutil.OfferBasicInfo),ElementName="offerBasicInfo",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public xonline.common.offerutil.OfferBasicInfo __offerBasicInfo;
		
		[XmlIgnore]
		public xonline.common.offerutil.OfferBasicInfo offerBasicInfo
		{
			get
			{
				if (__offerBasicInfo == null) __offerBasicInfo = new xonline.common.offerutil.OfferBasicInfo();		
				return __offerBasicInfo;
			}
			set {__offerBasicInfo = value;}
		}

		[XmlElement(Type=typeof(xonline.common.offerutil.OfferPrivilegeInfo),ElementName="offerPrivilegeInfo",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public xonline.common.offerutil.OfferPrivilegeInfo __offerPrivilegeInfo;
		
		[XmlIgnore]
		public xonline.common.offerutil.OfferPrivilegeInfo offerPrivilegeInfo
		{
			get
			{
				if (__offerPrivilegeInfo == null) __offerPrivilegeInfo = new xonline.common.offerutil.OfferPrivilegeInfo();		
				return __offerPrivilegeInfo;
			}
			set {__offerPrivilegeInfo = value;}
		}

		public GameplayOffer()
		{
		}
	}


	[XmlType(TypeName="PromotionalPointsOffer",Namespace=Declarations.SchemaVersion),Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class PromotionalPointsOffer
	{

		[XmlElement(ElementName="rewardID",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="unsignedInt",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __rewardID;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __rewardIDSpecified;
		
		[XmlIgnore]
		public uint rewardID
		{ 
			get { return __rewardID; }
			set { __rewardID = value; __rewardIDSpecified = true; }
		}

		[XmlElement(Type=typeof(xonline.common.offerutil.OfferBasicInfo),ElementName="offerBasicInfo",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public xonline.common.offerutil.OfferBasicInfo __offerBasicInfo;
		
		[XmlIgnore]
		public xonline.common.offerutil.OfferBasicInfo offerBasicInfo
		{
			get
			{
				if (__offerBasicInfo == null) __offerBasicInfo = new xonline.common.offerutil.OfferBasicInfo();		
				return __offerBasicInfo;
			}
			set {__offerBasicInfo = value;}
		}

		public PromotionalPointsOffer()
		{
		}
	}


	[XmlType(TypeName="PcAccountCreationOffer",Namespace=Declarations.SchemaVersion),Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class PcAccountCreationOffer
	{

		[XmlElement(ElementName="offerID",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="string",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __offerID;
		
		[XmlIgnore]
		public string offerID
		{ 
			get { return __offerID; }
			set { __offerID = value; }
		}

		[XmlElement(ElementName="friendlyName",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="string",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __friendlyName;
		
		[XmlIgnore]
		public string friendlyName
		{ 
			get { return __friendlyName; }
			set { __friendlyName = value; }
		}

		[XmlElement(ElementName="titleID",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="string",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __titleID;
		
		[XmlIgnore]
		public string titleID
		{ 
			get { return __titleID; }
			set { __titleID = value; }
		}

		public PcAccountCreationOffer()
		{
		}
	}


	[XmlRoot(ElementName="LiveOffer",Namespace=Declarations.SchemaVersion,IsNullable=false),Serializable]
	public class LiveOffer
	{

		[XmlElement(Type=typeof(xonline.common.offerutil.Title),ElementName="title",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public TitleCollection __titleCollection;
		
		[XmlIgnore]
		public TitleCollection titleCollection
		{
			get
			{
				if (__titleCollection == null) __titleCollection = new TitleCollection();
				return __titleCollection;
			}
			set {__titleCollection = value;}
		}

		[XmlElement(Type=typeof(xonline.common.offerutil.Reward),ElementName="reward",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public RewardCollection __rewardCollection;
		
		[XmlIgnore]
		public RewardCollection rewardCollection
		{
			get
			{
				if (__rewardCollection == null) __rewardCollection = new RewardCollection();
				return __rewardCollection;
			}
			set {__rewardCollection = value;}
		}

		[XmlElement(Type=typeof(xonline.common.offerutil.Content),ElementName="content",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ContentCollection __contentCollection;
		
		[XmlIgnore]
		public ContentCollection contentCollection
		{
			get
			{
				if (__contentCollection == null) __contentCollection = new ContentCollection();
				return __contentCollection;
			}
			set {__contentCollection = value;}
		}

		[XmlElement(Type=typeof(xonline.common.offerutil.PromotionalPointsOffer),ElementName="promotionalPointsOffer",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public PromotionalPointsOfferCollection __promotionalPointsOfferCollection;
		
		[XmlIgnore]
		public PromotionalPointsOfferCollection promotionalPointsOfferCollection
		{
			get
			{
				if (__promotionalPointsOfferCollection == null) __promotionalPointsOfferCollection = new PromotionalPointsOfferCollection();
				return __promotionalPointsOfferCollection;
			}
			set {__promotionalPointsOfferCollection = value;}
		}

		[XmlElement(Type=typeof(xonline.common.offerutil.ContentOffer),ElementName="contentOffer",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ContentOfferCollection __contentOfferCollection;
		
		[XmlIgnore]
		public ContentOfferCollection contentOfferCollection
		{
			get
			{
				if (__contentOfferCollection == null) __contentOfferCollection = new ContentOfferCollection();
				return __contentOfferCollection;
			}
			set {__contentOfferCollection = value;}
		}

		[XmlElement(Type=typeof(xonline.common.offerutil.PointsBundleOffer),ElementName="pointsBundleOffer",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public PointsBundleOfferCollection __pointsBundleOfferCollection;
		
		[XmlIgnore]
		public PointsBundleOfferCollection pointsBundleOfferCollection
		{
			get
			{
				if (__pointsBundleOfferCollection == null) __pointsBundleOfferCollection = new PointsBundleOfferCollection();
				return __pointsBundleOfferCollection;
			}
			set {__pointsBundleOfferCollection = value;}
		}

		[XmlElement(Type=typeof(xonline.common.offerutil.GamertagChangeOffer),ElementName="gamertagChangeOffer",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public GamertagChangeOfferCollection __gamertagChangeOfferCollection;
		
		[XmlIgnore]
		public GamertagChangeOfferCollection gamertagChangeOfferCollection
		{
			get
			{
				if (__gamertagChangeOfferCollection == null) __gamertagChangeOfferCollection = new GamertagChangeOfferCollection();
				return __gamertagChangeOfferCollection;
			}
			set {__gamertagChangeOfferCollection = value;}
		}

		[XmlElement(Type=typeof(xonline.common.offerutil.GameplayOffer),ElementName="gameplayOffer",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public GameplayOfferCollection __gameplayOfferCollection;
		
		[XmlIgnore]
		public GameplayOfferCollection gameplayOfferCollection
		{
			get
			{
				if (__gameplayOfferCollection == null) __gameplayOfferCollection = new GameplayOfferCollection();
				return __gameplayOfferCollection;
			}
			set {__gameplayOfferCollection = value;}
		}

		[XmlElement(Type=typeof(xonline.common.offerutil.LiveSubscription),ElementName="liveSubscription",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public LiveSubscriptionCollection __liveSubscriptionCollection;
		
		[XmlIgnore]
		public LiveSubscriptionCollection liveSubscriptionCollection
		{
			get
			{
				if (__liveSubscriptionCollection == null) __liveSubscriptionCollection = new LiveSubscriptionCollection();
				return __liveSubscriptionCollection;
			}
			set {__liveSubscriptionCollection = value;}
		}

		[XmlElement(Type=typeof(xonline.common.offerutil.GameSubscription),ElementName="gameSubscription",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public GameSubscriptionCollection __gameSubscriptionCollection;
		
		[XmlIgnore]
		public GameSubscriptionCollection gameSubscriptionCollection
		{
			get
			{
				if (__gameSubscriptionCollection == null) __gameSubscriptionCollection = new GameSubscriptionCollection();
				return __gameSubscriptionCollection;
			}
			set {__gameSubscriptionCollection = value;}
		}

		[XmlElement(Type=typeof(xonline.common.offerutil.PcAccountCreationOffer),ElementName="pcAccountCreationOffer",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public PcAccountCreationOfferCollection __pcAccountCreationOfferCollection;
		
		[XmlIgnore]
		public PcAccountCreationOfferCollection pcAccountCreationOfferCollection
		{
			get
			{
				if (__pcAccountCreationOfferCollection == null) __pcAccountCreationOfferCollection = new PcAccountCreationOfferCollection();
				return __pcAccountCreationOfferCollection;
			}
			set {__pcAccountCreationOfferCollection = value;}
		}

		public LiveOffer()
		{
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\activeauth\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\querylib\CronUtil.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.IO;
using xonline.common.plugins;
using xonline.common.protocol;
using xonline.common.service;

namespace xonline.server.querylib 
{
    public class CronUtil
    {
        public static HResult AddJob(string name, uint titleId, string assembly, string className, uint execCount, uint timeoutSecs, DateTime nextExec, uint intervalSecs, Hashtable ctx, out int jobId)
        {
            return AddJob(name, titleId, assembly, className, execCount, timeoutSecs, nextExec, intervalSecs, PluginUtil.HashtableToXml(ctx), out jobId);
        }            
        
        public static HResult AddJob(string name, uint titleId, string assembly, string className, uint execCount, uint timeoutSecs, DateTime nextExec, uint intervalSecs, string ctxXml, out int jobId)
        {
            AddJobRequest  addCronJobReq  = new AddJobRequest();
            AddJobResponse addCronJobResp = new AddJobResponse();
            XRLObject2     xrlo           = (XRLObject2)addCronJobResp;
            HResult        hr;

            jobId = 0;            
            
            addCronJobReq.name         = name;
            addCronJobReq.titleId      = titleId;
            addCronJobReq.assembly     = assembly;
            addCronJobReq.className    = className;
            addCronJobReq.argsXml      = ctxXml;
            addCronJobReq.execCount    = execCount;
            addCronJobReq.timeoutSecs  = timeoutSecs;
            addCronJobReq.nextExec     = nextExec;
            addCronJobReq.intervalSecs = intervalSecs;
            
    
            hr = XRLUtil.PostXrlRequest(XOService.Cron, addCronJobReq.GetXRL(), addCronJobReq, ref xrlo);
            if (HResult.Succeeded(hr))
            {
                jobId = addCronJobResp.jobId;
            }
            
            return hr;
        }
        
        public static HResult RemoveJob(int jobId, uint titleId)
        {
            RemoveJobRequest req = new RemoveJobRequest();
            HResult hr;
            
            req.jobId = jobId;
            req.titleId = titleId;
            
            hr = XRLUtil.PostXrlRequest(XOService.Cron, req.GetXRL(), req);
            return hr;
        }
        
        public static HResult FindJobs(string search, out CronJobWire[] jobs)
        {
            FindJobsRequest req = new FindJobsRequest();
            FindJobsResponse resp = new FindJobsResponse();
            XRLObject2 xrlo = (XRLObject2)resp;
            HResult hr;
            
            req.search = search;
            jobs = new CronJobWire[0];
            
            hr = XRLUtil.PostXrlRequest(XOService.Cron, req.GetXRL(), req, ref xrlo);
            if (HResult.Succeeded(hr))
            {
                jobs = resp.jobs;
            }
            
            return hr;    
        }
            
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\activeauth\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__security_1_none_12.4.56.0_none_240f4c6c500e5723
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__security_1_no-public-key_12.4.56.0_x-ww_c10a2227
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_security_1
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__security_1_no-public-key_12.4.56.0_x-ww_c10a2227
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__security_1_no-public-key_12.4.56.0_x-ww_c10a2227.manifest
XP_MANIFEST_PATH=manifests\x86__security_1_no-public-key_12.4.56.0_x-ww_c10a2227.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__security_1_no-public-key_12.4.56.0_x-ww_c10a2227.cat
XP_CATALOG_PATH=manifests\x86__security_1_no-public-key_12.4.56.0_x-ww_c10a2227.cat
XP_PAYLOAD_PATH=x86__security_1_no-public-key_12.4.56.0_x-ww_c10a2227
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_security_1,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\querylib\DatasetInfo.cs ===
using System;
using System.Data;
using System.Data.SqlClient;
using System.Web;
using System.Diagnostics;
using System.Collections;
using System.Reflection;
using xonline.common.mgmt;
using xonline.common.config;
using xonline.common.service;
using xonline.common.plugins;
using xonline.common.protocol;
using xonline.common.sql.sqlclient;

[assembly: XomAreaDefinition(XomAreaName.log)]
[assembly: XomAreaDefinition(XomAreaName.xqry)]


namespace xonline.server.querylib
{
    public class DatasetInfo
    {
        private static Assembly _fdAsm = Assembly.GetExecutingAssembly();

        public static Assembly FrontDoorAssembly
        {
            get { return _fdAsm; }
            set { _fdAsm = value; }
        }

        public static void EnsureDSInfoIsLoaded()
        {
        }

        public static DatasetInfo GetDSInfo(uint titleId, uint datasetId)
        {
            string key = titleId.ToString("x8") + "|" + datasetId.ToString("x");
            
            DatasetInfo info = (DatasetInfo)_dsInfo[key];
            
            if(info == null)
            {
                IBucketServer bucket;
                try
                {
                     bucket = Config.GetTitleBucketServer(Interface.querydb, titleId, datasetId);
                }
                catch(Exception bucketE)
                {
                    throw new XRLException(HResult.XONLINE_E_QUERY_DATASET_NOT_FOUND, XEvent.Id.QUERY_DATASET_CONFIG_ERROR, 
                                "Couldn't find querydb server for titleid " + titleId.ToString("x8") + ", dataset " + datasetId.ToString("x8") + "!" + 
                                "   Was titlemgr run for this title and dataset?", bucketE);
                }   
                
                int quota = 0;         
                
                try
                {
                    quota = Convert.ToInt32(bucket.Info1);
                }
                catch(Exception ex)
                {
                    throw new XRLException(HResult.XONLINE_E_QUERY_ERROR, XEvent.Id.QUERY_DATASET_CONFIG_ERROR_1, 
                                            "Invalid value for Owner Quota (t_interface_buckets.vc_info_1): " + bucket.Info1 + "\r\n"+ 
                                            "TitleId: " + titleId.ToString("x8") + "\r\n" + 
                                            "DatasetId: " + datasetId.ToString("x8"), ex);
                }

                info = new DatasetInfo();
                                
                info.TitleId = titleId;
                info.DatasetId = datasetId;
                info.Partition = (int)datasetId;
                info.OwnerQuota = quota;
                
                // load plugin info
                SqlClient cmd = new SqlClient(Interface.npdb);
                cmd.StoredProc = "p_query_get_plugin_info";
                cmd.AddParameter("@i_title_id", titleId);
                cmd.AddParameter("@i_dataset_id", datasetId);
                
                SqlDataReader reader = cmd.Execute();
                while(reader.Read())
                {
                    string assemblyName = (string)reader["vc_assembly"];
                    string className = (string)reader["vc_class"];
                    Hashtable ctx = null;
                    object ob;

                    // strip .dll off the name
                    if (assemblyName.EndsWith(".dll"))
                    {
                        assemblyName = assemblyName.Substring(0, assemblyName.Length - 4);
                    }

                    // replace the old namespace convention with the new, for legacy applications
                    // created with XLAST
                    //
                    className = className.Replace("XBOX.Online.Competitions.Elimination", "xonline.server.comps.query");

                    try
                    {
                        // create the plugin class
                        Assembly asm = Assembly.Load(assemblyName);
                        ob = asm.CreateInstance(className, false);
                        if (ob == null)
                        {
                            throw new Exception("Type " + className + " not found in assembly " + assemblyName + "!");
                        }

                        try
                        {
                            // Change 268493 changed the behavior of RegisterAssembly. It 
                            // used to swallow exceptions, and now it throws them. I don't 
                            // fully understand the code here in Query, nor why this 
                            // function may throw an exception, so 100% 
                            // backwards-compatibility it is. But let's at least log an 
                            // event, k?
                            XomLoggingControl.RegisterAssembly(asm);
                        }
                        catch (Exception e)
                        {
                            Xom.NtEvent( XEvent.Id.QUERY_PLUGIN_CREATION_ERROR_2, e, "An error occurred while " + 
                                "registering the assembly " + asm.ToString() + " for " + key + 
                                " (titleId|datasetId) with XMGMT. This is likely not " + 
                                "fatal but should still be investigated."
                            );
                        }
                        XomPerformanceCounterCategory.InitInstPerfCtrs(asm, titleId.ToString("x8"));

                        // create the context, if specified
                        string xmlctx = null;
                        if (reader["txt_context"] != DBNull.Value)
                        {
                            xmlctx = (string)reader["txt_context"];
                        }
                        ctx = PluginUtil.XmlToHashtable(xmlctx);


                    }
                    catch(Exception e)
                    {
                        Xom.NtEvent( XEvent.Id.QUERY_PLUGIN_CREATION_ERROR_1, e, "An error occured attempting to create the plugin for " + key + " (titleId|datasetId).");
                        continue;
                    }

                    DatasetPlugin pi = new DatasetPlugin();
                    pi.ob = ob;
                    pi.ctx = ctx;

                    info.PluginList.Add(pi);
                }    
                
                _dsInfo[key] = info;
            }

            return (DatasetInfo)_dsInfo[key];
        }

        static DatasetInfo()
        {
            XomControl.ControlRequestEvent += new XomControl.ControlRequestEventHandler(DatasetInfo.OnControlRequest);
        }

        public static void OnControlRequest(object sender, ControlRequestEventArgs args)
        {
            try
            {
                switch (args.Command)
                {
                // note: no help, as this simply uses the same command provided by feapp.
                // we can't use the feapp flushcache event, because it may not be compliled into
                // this assembly!

                case "cacheflush":
                    OnFlushCache(args);
                    args.Handled = true;
                    break;
                }
            }
            catch(Exception e)
            {
                XomControlConnection.SendMessage("Error: " + e.ToString() + "\r\n\r\n", args.RequestId);
            }
        }

        public static void OnFlushCache(EventArgs e)
        {
            _dsInfo = new Hashtable();
        }


        private static Hashtable _dsInfo = new Hashtable();

        public uint TitleId;
        public uint DatasetId;
        public int Partition;
        public int OwnerQuota;
        public int DatasetTypeId;

        public ArrayList PluginList = new ArrayList();


        public DatasetPlugin[] GetContextPluginList(uint datasetId)
        {
            DatasetPlugin[] plugins;

            // decorate key with assembly name, since calling from a different
            // assembly will result in a casting error
            string key = "dsPlugins|" + datasetId.ToString("x") + "|" + Assembly.GetExecutingAssembly().FullName;

            if (PluginList.Count == 0)
            {
                return null;
            }

            // if it dosen't already exist, copy list of dataset plugins to httpcontext
            // with a *cloned* copy of the context hashtable.
            plugins = (DatasetPlugin[])HttpContext.Current.Items[key];
            if (plugins == null)
            {
                plugins = new DatasetPlugin[PluginList.Count];
                for (int i = 0; i < plugins.Length; i++)
                {
                    DatasetPlugin dspi = (DatasetPlugin)PluginList[i];
                    plugins[i] = new DatasetPlugin();
                    plugins[i].ob = dspi.ob;
                    plugins[i].ctx = (Hashtable)dspi.ctx.Clone();
                }

                HttpContext.Current.Items[key] = plugins;
            }

            return plugins;
        }

        public HResult BeforeAdd(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, QueryAttribute[] attribs)
        {
            uint hr = HResult.S_OK;
            DatasetPlugin[] plugins = GetContextPluginList(datasetId);

            if (plugins != null)
            {
                for (int i = 0; i < plugins.Length; i++)
                {
                    if (plugins[i].ob is IQueryAdd)
                    {
                        IQueryAdd pi = (IQueryAdd)plugins[i].ob;

                        hr = pi.BeforeAdd(source, titleId, userId, teamId, datasetId, attribs, plugins[i].ctx);
                        if (HResult.Failed(hr))
                            break;
                    }

                }
            }


            return hr;
        }

        public HResult AfterAdd(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, QueryAttribute[] attribs, ulong entityId)
        {
            DatasetPlugin[] plugins = GetContextPluginList(datasetId);
            uint hr = HResult.S_OK;

            if (plugins != null)
            {
                for (int i = 0; i < plugins.Length; i++)
                {
                    if (plugins[i].ob is IQueryAdd)
                    {
                        IQueryAdd pi = (IQueryAdd)plugins[i].ob;
                        hr = pi.AfterAdd(source, titleId, userId, teamId, datasetId, attribs, entityId, plugins[i].ctx);
                        if (HResult.Failed(hr))
                            break;
                    }
                }
            }

            return hr;
        }

        public HResult BeforeUpdate(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, uint procIndex, QueryAttribute[] attribs)
        {
            uint hr = HResult.S_OK;
            DatasetPlugin[] plugins = GetContextPluginList(datasetId);

            if (plugins != null)
            {
                for (int i = 0; i < plugins.Length; i++)
                {
                    if (plugins[i].ob is IQueryUpdate)
                    {
                        IQueryUpdate pi = (IQueryUpdate)plugins[i].ob;
                        hr = pi.BeforeUpdate(source, titleId, userId, teamId, datasetId, procIndex, attribs, plugins[i].ctx);
                        if (HResult.Failed(hr))
                            break;
                    }
                }
            }

            return hr;
        }

        public void AfterUpdate(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, uint procIndex, QueryAttribute[] attribs)
        {
            DatasetPlugin[] plugins = GetContextPluginList(datasetId);

            if (plugins != null)
            {
                for (int i = 0; i < plugins.Length; i++)
                {
                    if (plugins[i].ob is IQueryUpdate)
                    {
                        IQueryUpdate pi = (IQueryUpdate)plugins[i].ob;
                        pi.AfterUpdate(source, titleId, userId, teamId, datasetId, procIndex, attribs, plugins[i].ctx);
                    }
                }
            }
            return;
        }

        public HResult BeforeUpdateId(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, uint procIndex, ulong entityId, QueryAttribute[] attribs)
        {
            uint hr = HResult.S_OK;
            DatasetPlugin[] plugins = GetContextPluginList(datasetId);

            if (plugins != null)
            {
                for (int i = 0; i < plugins.Length; i++)
                {
                    if (plugins[i].ob is IQueryUpdateId)
                    {
                        IQueryUpdateId pi = (IQueryUpdateId)plugins[i].ob;
                        hr = pi.BeforeUpdateId(source, titleId, userId, teamId, datasetId, procIndex, attribs, entityId, plugins[i].ctx);
                        if (HResult.Failed(hr))
                            break;
                    }
                }
            }

            return hr;
        }

        public void AfterUpdateId(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, uint procIndex, ulong entityId, QueryAttribute[] attribs)
        {
            DatasetPlugin[] plugins = GetContextPluginList(datasetId);

            if (plugins != null)
            {
                for (int i = 0; i < plugins.Length; i++)
                {
                    if (plugins[i].ob is IQueryUpdateId)
                    {
                        IQueryUpdateId pi = (IQueryUpdateId)plugins[i].ob;
                        pi.AfterUpdateId(source, titleId, userId, teamId, datasetId, procIndex, attribs, entityId, plugins[i].ctx);
                    }
                }
            }
            return;
        }

        public HResult BeforeRemove(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, uint procIndex, QueryAttribute[] attribs)
        {
            uint hr = HResult.S_OK;
            DatasetPlugin[] plugins = GetContextPluginList(datasetId);

            if (plugins != null)
            {
                for (int i = 0; i < plugins.Length; i++)
                {
                    if (plugins[i].ob is IQueryRemove)
                    {
                        IQueryRemove pi = (IQueryRemove)plugins[i].ob;
                        hr = pi.BeforeRemove(source, titleId, userId, teamId, datasetId, procIndex, attribs, plugins[i].ctx);
                        if (HResult.Failed(hr))
                            break;
                    }
                }
            }

            return hr;
        }

        public void AfterRemove(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, uint procIndex, QueryAttribute[] attribs)
        {
            DatasetPlugin[] plugins = GetContextPluginList(datasetId);

            if (plugins != null)
            {
                for (int i = 0; i < plugins.Length; i++)
                {
                    if (plugins[i].ob is IQueryRemove)
                    {
                        IQueryRemove pi = (IQueryRemove)plugins[i].ob;
                        pi.AfterRemove(source, titleId, userId, teamId, datasetId, procIndex, attribs, plugins[i].ctx);
                    }
                }
            }

            return;
        }


        public HResult BeforeRemoveId(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId)
        {
            uint hr = HResult.S_OK;
            DatasetPlugin[] plugins = GetContextPluginList(datasetId);

            if (plugins != null)
            {
                for (int i = 0; i < plugins.Length; i++)
                {
                    if (plugins[i].ob is IQueryRemoveId)
                    {
                        IQueryRemoveId pi = (IQueryRemoveId)plugins[i].ob;
                        hr = pi.BeforeRemoveId(source, titleId, userId, teamId, datasetId, entityId, plugins[i].ctx);
                        if (HResult.Failed(hr))
                            break;
                    }
                }
            }

            return hr;
        }

        public void AfterRemoveId(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId)
        {
            DatasetPlugin[] plugins = GetContextPluginList(datasetId);

            if (plugins != null)
            {
                for (int i = 0; i < plugins.Length; i++)
                {
                    if (plugins[i].ob is IQueryRemoveId)
                    {
                        IQueryRemoveId pi = (IQueryRemoveId)plugins[i].ob;
                        pi.AfterRemoveId(source, titleId, userId, teamId, datasetId, entityId, plugins[i].ctx);
                    }
                }
            }
            return;
        }

        public HResult Select(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId, uint actionId, QueryAttribute[] attribs, BundledAuthData bundledAuth, TeamTickets bundledTickets)
        {
            uint hr = HResult.XONLINE_E_QUERY_INVALID_ACTION;
            DatasetPlugin[] plugins = GetContextPluginList(datasetId);

            if (plugins != null)
            {
                for (int i = 0; i < plugins.Length; i++)
                {
                    if (plugins[i].ob is IQuerySelect)
                    {
                        IQuerySelect pi = (IQuerySelect)plugins[i].ob;

                        // Add auth data if any
                        if (null != bundledAuth)
                        {
                            plugins[i].ctx.Add("bundledAuth", bundledAuth);
                        }

                        // Add team tickets data if any
                        if (null != bundledTickets)
                        {
                            plugins[i].ctx.Add("bundledTickets", bundledTickets);
                        }

                        hr = pi.Select(source, titleId, userId, teamId, datasetId, entityId, actionId, attribs, plugins[i].ctx);
                        if (HResult.Failed(hr))
                            break;
                    }
                }

            }

            return hr;
        }



        public HResult BeforeSearch(Source source, uint titleId, uint datasetId, uint procIndex, QueryAttribute[] attribs)
        {
            uint hr = HResult.S_OK;
            DatasetPlugin[] plugins = GetContextPluginList(datasetId);

            if (plugins != null)
            {
                for (int i = 0; i < plugins.Length; i++)
                {
                    if (plugins[i].ob is IQuerySearch)
                    {
                        IQuerySearch pi = (IQuerySearch)plugins[i].ob;
                        hr = pi.BeforeSearch(source, titleId, datasetId, procIndex, attribs, plugins[i].ctx);
                        if (HResult.Failed(hr))
                            break;
                    }
                }

            }

            return hr;
        }



        public HResult BeforeFindFromIds(Source source, uint titleId, uint datasetId, uint procIndex, ulong [] entityIds)
        {
            uint hr = HResult.S_OK;
            DatasetPlugin[] plugins = GetContextPluginList(datasetId);

            if (plugins != null)
            {
                for (int i = 0; i < plugins.Length; i++)
                {
                    if (plugins[i].ob is IQueryFindFromIds)
                    {
                        IQueryFindFromIds pi = (IQueryFindFromIds)plugins[i].ob;

                        hr = pi.BeforeFind(source, titleId, datasetId, procIndex, entityIds, plugins[i].ctx);
                        if (HResult.Failed(hr))
                            break;
                    }
                }

            }

            return hr;
        }


        public HResult BeforeCustom(Source source, uint titleId, uint datasetId, uint procIndex, QueryAttribute[] attribs)
        {
            uint hr = HResult.S_OK;
            DatasetPlugin[] plugins = GetContextPluginList(datasetId);

            if (plugins != null)
            {
                for (int i = 0; i < plugins.Length; i++)
                {
                    if (plugins[i].ob is IQueryCustom)
                    {
                        IQueryCustom pi = (IQueryCustom)plugins[i].ob;

                        hr = pi.BeforeCustom(source, titleId, datasetId, procIndex, attribs, plugins[i].ctx);
                        if (HResult.Failed(hr))
                            break;
                    }
                }

            }

            return hr;
        }
    }

    public struct DatasetPlugin
    {
        public object ob;
        public Hashtable ctx;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\activeauth\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__security_1_none_12.4.56.0_none_240f4c6c500e5723
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__security_1_no-public-key_12.4.56.0_x-ww_c10a2227
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_security_1
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__security_1_no-public-key_12.4.56.0_x-ww_c10a2227
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__security_1_no-public-key_12.4.56.0_x-ww_c10a2227.manifest
XP_MANIFEST_PATH=manifests\x86__security_1_no-public-key_12.4.56.0_x-ww_c10a2227.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__security_1_no-public-key_12.4.56.0_x-ww_c10a2227.cat
XP_CATALOG_PATH=manifests\x86__security_1_no-public-key_12.4.56.0_x-ww_c10a2227.cat
XP_PAYLOAD_PATH=x86__security_1_no-public-key_12.4.56.0_x-ww_c10a2227
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_security_1,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\activeauth\AAInfoInternetTier.cs ===
//
// AAInfoInternetTier.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// This class extends the AAInfoBase class in \private\common\service\ and adds the 
// ability to populate it with data. This class should only be used by components that 
// live in the internet tier, i.e. ones that do not have direct access to the UODB, 
// Webstore, xcache, etc. We have to use the ActiveAuthInfo front door to retrieve our 
// information.
//
// See additional usage notes in \private\common\service\AAInfoBase.cs.
//
// Author: kgoodier 7/2007
//

using System;
using System.Web;
using System.IO;
using System.Net;
using System.Collections;
using System.Collections.Specialized;
using System.Text;
using System.Diagnostics;

using xonline.common.service;
using xonline.common.config;
using xonline.common.mgmt;

namespace xonline.common.service
{

public class AAInfoInternetTier : AAInfo
{

    // -------------------------------------------------------------------------
    // Current - this is how a consumer, like a front-door, should retrieve the 
    // ActiveAuthInfo for a request.
    // -------------------------------------------------------------------------
    public static new AAInfo Current
    {
        get
        {
            AAInfo aa;
            string ContextKey = c_CtxKey_AAInfoCacheITier;

            // If HttpContext.Current is null, we can't really do much. I guess we can 
            // return a blank object.. or throw an exception? or return null?
            if (HttpContext.Current == null)
            {
                return null;
            }

            // Location 1/3: If this object has already been created, let's just pull it 
            // out of the cache.
            aa = (AAInfo)HttpContext.Current.Items[ContextKey];
            if (aa != null)
            {
                return aa;
            }

            // Super important security check
            if (!AAInfo.IsInternetTier)
            {
                return null;
            }

            aa = new AAInfoInternetTier();

            // Location 2/3: in the local context, which would have come from the 
            // ActiveAuthModule?
            if (!TryMarshallFromContext(HttpContext.Current, ref aa))
            {
                // Location 3/3: in the http headers, which would have come from the 
                // ActiveAuthGateway?
                //
                // This is an invalid location for the InternetTier. Skip.

                return null;
            }

            // Stick in cache
            if (aa != null)
            {
                HttpContext.Current.Items[ContextKey] = aa;
            }

            return aa;
        }
    }


    // -------------------------------------------------------------------------
    // Base constructor
    // -------------------------------------------------------------------------
    protected AAInfoInternetTier()
        : base()
    {
    }


    // -------------------------------------------------------------------------
    // PopulateLiveXuid - lookup xuid from passport puid. XCache has already been tried, 
    // and it failed.
    //
    // Inputs  : _passportPuid
    // Outputs : _liveXuid
    // -------------------------------------------------------------------------
    protected override void PopulateLiveXuid()
    {
        // Not in xcache. We have no xuid, so can't use xbanc. Try getaainfo?
        PopulateAllUserInfo();
    }

    // -------------------------------------------------------------------------
    // PopulateUserInfo - lookup user info from xuid
    //
    // Inputs  : _liveXuid (or _passportPuid)
    // Outputs : _countryId (more in future?)
    // -------------------------------------------------------------------------
    protected override void PopulateUserInfo()
    {
        PopulateAllUserInfo();
    }

    // -------------------------------------------------------------------------
    // PopulateUserPrivileges - lookup privileges for user from xuid
    //
    // Inputs  : _liveXuid (or _passportPuid)
    // Outputs : _userPrivileges
    // -------------------------------------------------------------------------
    protected override void PopulateUserPrivileges()
    {
        // For now, privileges are lumped in with everything else. If it turns out to be 
        // too expensive, we should break them out.
        PopulateAllUserInfo();
    }


    // -------------------------------------------------------------------------
    // PopulateAllUserInfo - make call to GetAAInfo front door api to populate all of our 
    // info. It will optionally populate the livexuid for us if needed, otherwise we 
    // should provide it for optimization.
    // -------------------------------------------------------------------------
    protected void PopulateAllUserInfo()
    {
        // Zero everything out so we don't keep trying over and over
        _countryId = 0;
        _userPrivileges = new BitArray(XOn.XONLINE_MAX_PRIVILEGE_ID);

        if (PassportPuid == 0)
        {
            Xom.Trace(XomAreaName.aainfo, LogLevel.L_WARNING, "PopulateAllUserInfo: passportpuid is 0, can't look up user info");
            return;
        }

        // _liveXuid may or may not be set, and that's ok.  If it is valid, then we should 
        // try XBanc first, then GetAAInfo if that fails.  If it is not valid, go straight 
        // to GetAAInfo.
        
        if (TryGetFromXBanc())
        {
            return;
        }

        // Not in xbanc. May or may not have valid xuid. Send it all to GetAAInfo and let 
        // it populate everything.

        GetAAInfoRequest request = new GetAAInfoRequest();
        GetAAInfoResponse response = new GetAAInfoResponse();

        request.SchemaVersion     = ProtocolVersion;  // we use our own version numbering
        request.PassportPuid      = PassportPuid;
        request.LiveXuid          = LiveXuid;
        request.IpAddressInternet = IpAddressInternet;

        // PostXrlRequest will set X-Schema-Ver for us based on request.SchemaVersion

        XRLObject2 xrlo = response;
        HResult hr = XRLUtil.PostXrlRequest(
            VirtualInterface.xsig_int,
            request.Xrl,
            null,                       // no authdata
            request,
            ref xrlo);

        if (HResult.Failed(hr))
        {
            // @@@ better error?
            throw new Exception("Call to GetAAInfo failed. hr = " + hr);
        }

        _liveXuid = response.LiveXuid;
        _countryId = response.CountryId;
        _userPrivileges = new BitArray(response.UserPrivileges);

        //
        // Put in xbanc
        //
        
        PutToXBanc();
    }


    // -------------------------------------------------------------------------
    // NewLocalInstance - constructs a new AAInfo object for local use. Only the GetAAInfo 
    // front door and tests should use this function.
    // -------------------------------------------------------------------------
    internal static AAInfo NewLocalInstance(
        ulong passportPuid,
        ulong? liveXuid,
        string ipAddressInternet)
    {
        AAInfoInternetTier aa = new AAInfoInternetTier();
        aa._passportPuid = passportPuid;
        aa._liveXuid = liveXuid;
        aa._ipAddressInternet = ipAddressInternet;
        aa.UseXBanc = false;
        return aa;
    }

}


// -------------------------------------------------------------------------
// Protocol definitions for talking to the AAFD (GetAAInfo xrl). They live here so that 
// the xonline.common.service namespace doesn't have to take a dependency on 
// xonline.common.protocol, which has a lot of bloat.
// -------------------------------------------------------------------------


public class GetAAInfoRequest : XRLObject2
{
    [WireInfo(HexString=true)]
    public ulong    PassportPuid;
   
    [WireInfo(HexString=true)]
    public ulong    LiveXuid;  // ok to be 0
   
    [WireInfo(Min=0, Max=32)]
    public uint     IpAddressInternetLength;

    [WireInfo(SizeParam="IpAddressInternetLength")]
    public string   IpAddressInternet;

    public override string Xrl 
    { 
        get 
        { 
            return "/xsig/GetAAInfo.ashx"; 
        } 
    }
}


public class GetAAInfoResponse : XRLObject2
{
    [WireInfo(HexString=true)]
    public ulong    LiveXuid;

    public byte     CountryId;

    [WireInfo(Min=0, Max=XOn.XONLINE_NUM_PRIVILEGE_DWORDS)]
    public uint     UserPrivilegesLength;

    // Has to be int, not uint, for BitArray
    [WireInfo(HexString=true, SizeParam="UserPrivilegesLength")]
    public int[]    UserPrivileges;

}


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\blacklist\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\querylib\queryutil.cs ===
// 
// QueryUtil.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Query Plugin base classes
// Xbox Online Service
// 
// Author: slamb
//

using System;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using System.Text;

using xonline.common.config;
using xonline.common.protocol;
using xonline.common.plugins;
using xonline.common.service;
using xonline.common.sql.sqlclient;
using xonline.common.mgmt;


namespace xonline.server.querylib 
{
    public class QueryUtil
    {
        //
        // Static method to init logging within our assembly
        //
        public static void InitLogging()
        {
            PluginUtil.InitLogging();
        }

    
        //
        // Small helper to find a value of an attribute in an a array of attributes.
        //
        public static long GetAttributeValueInt64(QueryAttribute[] attribs, uint id)
        {
            for (int i = 0; i < attribs.Length; i++)
            {
                if (attribs[i].Id == id)
                    return attribs[i].lValue;
            }
            
            // not found   
            return 0;
        }            

        public static string GetAttributeValueString(QueryAttribute[] attribs, uint id)
        {
            for (int i = 0; i < attribs.Length; i++)
            {
                if (attribs[i].Id == id)
                    return attribs[i].strValue;
            }
            
            // not found   
            return null;
        }          
        
        public static byte[] GetAttributeValueBytes(QueryAttribute[] attribs, uint id)
        {
            for (int i = 0; i < attribs.Length; i++)
            {
                if (attribs[i].Id == id)
                    return attribs[i].binValue;
            }
            
            // not found   
            return null;
        }            




        
        public static string DumpAttribs(QueryAttribute[] attribs)
        {
            StringBuilder b = new StringBuilder();
            
            b.Append("QueryAttributes:\r\n");
            b.Append("----------------\r\n");
            
            foreach (QueryAttribute attrib in attribs)
            {
                b.Append("0x" + attrib.Id.ToString("x") + " = ");
                switch(attrib.Id & XOn.X_ATTRIBUTE_DATATYPE_MASK)
                {
                case XOn.X_ATTRIBUTE_DATATYPE_INTEGER:
                    b.Append(attrib.lValue);
                    break;
                    
                case XOn.X_ATTRIBUTE_DATATYPE_STRING:
                    b.Append(attrib.strValue);
                    break;
                    
                case XOn.X_ATTRIBUTE_DATATYPE_BLOB:
                    b.Append(ByteConvert.ToString(attrib.binValue));
                    break;
                }    
                
                b.Append("\r\n");
            }
            
            return b.ToString();
        }
        

        //
        // Private data
        //
        private static long _timeWarp = 0;


        //
        // Public accessors
        //        
        public static DateTime UtcNow
        {
            get 
            {
                return DateTime.UtcNow.AddSeconds(_timeWarp);
            }
        }
        
        public static long TimeWarpAdjustment
        {
            get { return _timeWarp; }
            set { _timeWarp = value; }
        }
    }        
                    

    public class QueryHealth
    {
        //
        // Private data
        //
        const int  c_checkInterval = 5 * 60;    // 5 minutes between checks
        

        private static DateTime _start = DateTime.MinValue;
        private static DateTime _end = DateTime.MinValue;

        private static ArrayList _startTimes = new ArrayList();
        private static ArrayList _endTimes = new ArrayList();

        
        public static bool ServiceDown
        {
            get 
            { 
                return WasServiceDown(DateTime.UtcNow, DateTime.UtcNow);
            }
        }

        public static bool WasServiceDown(DateTime start, DateTime end)
        {
            bool wasDown = false;
            
            RefreshDowntime(start, end);
            
            for (int i = 0; i < _startTimes.Count; i++)
            {
                DateTime outageStart = (DateTime)_startTimes[i];
                DateTime outageEnd = (DateTime)_endTimes[i];
                
                
                if (start <= outageStart && end <= outageStart)
                    continue;
                    
                if (start >= outageEnd && end >= outageEnd)
                {
                    // looking at past outages now, no need to continue
                    wasDown = false;
                    break;
                }
                    
                    
                // found an outage period!
                Xom.Trace(XomAreaName.xqry, LogLevel.L_WARNING, "Service was down between " + outageStart + " and " + outageEnd);            
                Xom.Trace(XomAreaName.xqry, LogLevel.L_WARNING, "Range of " + start + " to " + end + " includes downtime.");            
                wasDown = true;
                break;                
            }
            
            return wasDown;
        }
        
        public static void RefreshDowntime(DateTime start, DateTime end)
        {
            SqlClient cmd = null;
            SqlDataReader results = null;
            
            ArrayList startTimes;
            ArrayList endTimes;
            
            
            // Quick out without locks
            if (_start <= start && _end >= end)
            {
                return;
            }

            // Do the real check
            lock(typeof(QueryHealth))
            {
                if (_start <= start && _end >= end)
                {
                    return;
                }
                                 
                startTimes = new ArrayList();
                endTimes = new ArrayList();
                                 
                // make sure we use a reasonable range
                if (DateTime.UtcNow.AddDays(-1) > start)
                {
                    start = DateTime.UtcNow.AddDays(-1);
                }
                
                if (DateTime.UtcNow.AddSeconds(c_checkInterval) < end)
                {
                    end = DateTime.UtcNow.AddDays(c_checkInterval);
                }    
                
                try
                {
                    cmd = new SqlClient(Interface.npdb);
                    
                    cmd.StoredProc = "p_svc_get_downtime";
                    
                    cmd.AddParameter("@dt_start", start);
                    cmd.AddParameter("@dt_end", end);
                    
                    results = cmd.Execute();
                
                    while (results.Read())
                    {
                        startTimes.Add(results.GetDateTime(0));
                        endTimes.Add(results.GetDateTime(1));
                    }
                    
                    _startTimes = startTimes;
                    _endTimes = endTimes;
                    
                    _start = start;
                    _end = end;
                }    
                catch (Exception e)
                {
                    // Problem occurred! Log an event. 
                    Xom.NtEvent(XEvent.Id.QUERY_SERVER_HEALTH_ERROR, e, "Error contacting NPDB to detect service downtime. Service is marked DOWN."); 
                    
                    // all checks should return was/is DOWN                    
                    startTimes = new ArrayList();
                    endTimes = new ArrayList();
                    startTimes.Add(DateTime.MinValue);
                    endTimes.Add(DateTime.MaxValue);
                    
                    _startTimes = startTimes;
                    _endTimes = endTimes;
                   
                    // check again, next time someone asks.
                    _start = DateTime.MinValue;
                    _end = DateTime.MinValue;
                    
                }
                finally
                {
                    if (cmd != null)    
                        cmd.Close();
                }
            }
        }    
           
           
           
        // control stuff
        // 
        static QueryHealth()
        {
            XomControl.ControlRequestEvent += new XomControl.ControlRequestEventHandler(QueryHealth.OnControlRequest);
        }
        
        public static void OnControlRequest(object sender, ControlRequestEventArgs args)
        {
            try
            {
                switch (args.Command)
                {
                // note: no help, as this simply uses the same command provided by feapp. 
                // we can't use the feapp flushcache event, because feapp may not be compliled into
                // this assembly!
                
                case "cacheflush":
                    OnFlushCache(args);
                    args.Handled = true;
                    break;
                }
            }
            catch(Exception e)
            {
                XomControlConnection.SendMessage("Error: " + e.ToString() + "\r\n\r\n", args.RequestId);
            }
        }

        
        public static void OnFlushCache(EventArgs e)
        {
            Xom.Trace(XomAreaName.xqry, LogLevel.L_LOW, "Flushing service downtime cache..");
            
            lock(typeof(QueryHealth))
            {
                _start = DateTime.MinValue;
                _end = DateTime.MinValue;
            }
            
            Xom.Trace(XomAreaName.xqry, LogLevel.L_LOW, "Done, it'll be reloaded on the next relevant request.");
            
    
        }            

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\querylib\queryerror.cs ===
// 
// Add.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// xqry Front Door
// Xbox Online Service
// 
// Author: slamb
//

using System;
using System.Web;
using System.Text;
using System.Diagnostics;
using System.Data.SqlClient;
using xonline.common.plugins;
using xonline.common.mgmt;
using xonline.common.service;


namespace xonline.server.querylib 
{
    public class QueryError
    {
        //-----------------------------------------------------
        // GetBetterHrAndEvent
        //      
        //      translates some exceptions into friendly HResults
        //
        public static void GetBetterHrAndEvent(Exception e, out HResult hr, out XEvent.Id eventId)
        {
            Exception       baseE;
            SqlException    sqlE;
            XRLException    xrlE = null;

            hr = HResult.XONLINE_E_QUERY_ERROR;
            eventId = XEvent.Id.QUERYLIB_CODE_0;
            
            if (e is XRLException)
            {
                xrlE = (XRLException)e;
            }
            
            baseE = e.GetBaseException();

            if (null != baseE && baseE is XRLException)
            {
                xrlE = (XRLException)baseE;
            }

            if (null != xrlE)
            {
                hr = xrlE.HResult;
                eventId = xrlE.EventId;
            }    

            if (null != baseE && baseE is SqlException)
            {
                sqlE = (SqlException)baseE;
                Xom.Trace(XomAreaName.xqry, LogLevel.L_LOW, "SQL Exception error #: " + sqlE.Number);
            
                switch (sqlE.Number)
                {
                case 8152:  // truncation
                    hr = HResult.XONLINE_E_QUERY_ATTRIBUTE_TOO_LONG;
                    eventId = XEvent.Id.QUERYLIB_CONFIG_13;
                    break;
                    
                case 8145:  // bad parameter
                case 8144:  // too many arguments
                case 8143:  // duplicate parameters
                case 201:   // too few or wrong attributes
                    hr = HResult.XONLINE_E_QUERY_UNEXPECTED_ATTRIBUTE;
                    eventId = XEvent.Id.QUERYLIB_CONFIG_14;
                    break;
                    
                case 2812:   // couldn't find procedure
                    hr = HResult.XONLINE_E_QUERY_PROCEDURE_NOT_FOUND;
                    eventId = XEvent.Id.QUERYLIB_CONFIG_15;
                    break;

                case 2601:   // duplicate key violation
                    hr = HResult.XONLINE_E_QUERY_DUPLICATE_ENTRY;
                    eventId = XEvent.Id.QUERYLIB_CONFIG_16;
                    break;
                
                case 601:   // data moved - retry if possible
                    hr = HResult.XONLINE_E_QUERY_RETRY;
                    break;
                    
                default:
                    // unexpected or unhandled SQL Error
                    break;
                }    
            }           
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\activeauth\AAInfoMiddleTier.cs ===
//
// AAInfoMiddleTier.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// This class extends the AAInfoBase class in \private\common\service\ and adds the 
// ability to populate it with data. This class should only be used by components that 
// live in the middle tier, i.e. ones that have direct access to the UODB, Webstore, 
// xcache, etc.
//
// See additional usage notes in \private\common\service\AAInfoBase.cs.
//
// Author: kgoodier 7/2007
//

using System;
using System.Web;
using System.IO;
using System.Net;
using System.Collections;
using System.Collections.Specialized;
using System.Text;
using System.Diagnostics;

using xonline.common.service;
using xonline.common.protocol;
using xonline.common.config;
using xonline.common.sql.webstore;
using Microsoft.Webstore.WstClient;
using xonline.common.mgmt;

namespace xonline.common.service
{

public class AAInfoMiddleTier : AAInfo
{

    // -------------------------------------------------------------------------
    // Current - this is how a consumer, like a front-door, should retrieve the 
    // ActiveAuthInfo for a request.
    // -------------------------------------------------------------------------
    public static new AAInfo Current
    {
        get
        {
            AAInfo aa;
            string ContextKey = c_CtxKey_AAInfoCacheMTier;

            // If HttpContext.Current is null, we can't really do much. I guess we can 
            // return a blank object.. or throw an exception? or return null?
            if (HttpContext.Current == null)
            {
                return null;
            }

            // Location 1/3: If this object has already been created, let's just pull it 
            // out of the cache.
            aa = (AAInfo)HttpContext.Current.Items[ContextKey];
            if (aa != null)
            {
                return aa;
            }

            // Super important security check, will block those hackers
            if (!AAInfo.IsMiddleTier)
            {
                return null;
            }

            aa = new AAInfoMiddleTier();

            // Location 2/3: in the local context, which would have come from the 
            // ActiveAuthModule?
            //
            // This is an invalid location for the MiddleTier. Next.

            // Location 3/3: in the http headers, which would have come from the 
            // ActiveAuthGateway?
            if (!TryMarshallFromHeaders(HttpContext.Current.Request.Headers, ref aa))
            {
                // Can't find the AAInfo anywhere. Return null;
                return null;
            }

            // Stick in cache
            if (aa != null)
            {
                HttpContext.Current.Items[ContextKey] = aa;
            }

            return aa;
        }
    }

    // -------------------------------------------------------------------------
    // Base constructor
    // -------------------------------------------------------------------------
    protected AAInfoMiddleTier() 
        : base()
    {
    }


    // -------------------------------------------------------------------------
    // PopulateLiveXuid - lookup xuid from passport puid. XCache has already been tried, 
    // and it failed.
    //
    // Inputs  : _passportPuid
    // Outputs : _liveXuid
    // -------------------------------------------------------------------------
    protected override void PopulateLiveXuid()
    {
        _liveXuid = 0;
        HResult hr = 0x0;

        if (PassportPuid == 0)
        {
            Xom.Trace(XomAreaName.aainfo, LogLevel.L_WARNING, "PopulateLiveXuid: passportpuid is 0, can't look up user info");
            return;
        }

        // No dice with XCache. Go straight to UODB, do not pass go.
        // Code stolen from \private\common\user\User.cs
        using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
        {
            ws.StoredProc = "dbo.p_xuacs_get_user_by_passport";
            ws.SetHashVal(PassportPuid);

            ws.AddParameter(ParamType.RETVAL, "@RETVAL", 0);
            ws.AddParameter(ParamType.INPUT,  "@bi_user_passport_puid", PassportPuid);
            ws.AddParameter(ParamType.OUTPUT, "@bi_user_puid", (ulong)_liveXuid);

            ws.ExecuteNonQuery();

            hr = (uint)ws.GetIntParameter("@RETVAL");
            if (hr == HResult.XONLINE_E_ACCOUNTS_INVALID_USER)
            {
                // Can't find user
                _liveXuid = 0;
                return;
            }
            else if (HResult.Failed(hr))
            {
                throw new Exception("p_xuacs_get_user_by_passport call failed with HR " + hr);
            }

            _liveXuid = (ulong?)ws.GetLongParameter("@bi_user_puid");
        }

    }

    // -------------------------------------------------------------------------
    // PopulateUserInfo - lookup user info from xuid
    //
    // Inputs  : _liveXuid (or _passportPuid)
    // Outputs : _countryId (more in future?)
    // -------------------------------------------------------------------------
    protected override void PopulateUserInfo()
    {
        PopulateAllUserInfo();
    }

    // -------------------------------------------------------------------------
    // PopulateUserPrivileges - lookup privileges for user from xuid
    //
    // Inputs  : _liveXuid (or _passportPuid)
    // Outputs : _userPrivileges
    // -------------------------------------------------------------------------
    protected override void PopulateUserPrivileges()
    {
        // For now, privileges are lumped in with everything else. If it turns out to be 
        // too expensive, we should break them out.
        PopulateAllUserInfo();
    }


    // -------------------------------------------------------------------------
    // PopulateAllUserInfo - populates all fields except LiveXuid
    // -------------------------------------------------------------------------
    protected void PopulateAllUserInfo()
    {
        HResult hr = 0x0;

        _countryId = 0;
        _userPrivileges = new BitArray(XOn.XONLINE_MAX_PRIVILEGE_ID);

        if (!IsUserValid)
            return;

        // 
        // Try xbanc first
        //

        if (TryGetFromXBanc())
        {
            return;
        }

        //
        // CountryId, etc
        //

        // Code stolen from \private\common\user\User.cs
        using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
        {
            ws.StoredProc = "dbo.p_xuacs_get_user_account_info";
            ws.SetHashVal(LiveXuid);

            ws.AddParameter(ParamType.RETVAL, "@hr", 0);
            ws.AddParameter(ParamType.INPUT, "@bi_user_puid", LiveXuid);

            // call the procedure
            using (WstDataReader rdr = ws.Execute())
            {
                // rdr.Read() returns false when the user is invalid (not found). If that 
                // happens, we want to skip the privileges lookup as well, since it will 
                // likely fail. May as well save some cycles.
                if ( !rdr.Read() )
                {
                    return;
                    //throw new Exception("p_xuacs_get_user_account_info call failed.  
                    //Invalid user? LiveXuid=0x" + LiveXuid.ToString("x"));
                }

                // We could add more user info fields, as this stored proc returns quite a 
                // few. 
                //
                // @@@ Tier? Gamertag? 
                //
                // The full list is:
                //
                // _ownerPuid = WSClient.GetUInt64(rdr, "bi_owner_puid");
                // _offlineXuid = WSClient.GetUInt64(rdr, "bi_offline_xuid");
                // _passportPuid = WSClient.GetUInt64(rdr, "bi_user_passport_puid");
                // _ownerPassportPuid = WSClient.GetUInt64(rdr, "bi_owner_passport_puid");
                // _accountType = WSClient.GetByte(rdr, "ti_account_type");
                // _createdAccountType = WSClient.GetByte(rdr, "ti_created_account_type");
                // _allowXbox1Logon = WSClient.GetByte(rdr, "f_allow_xbox1_logon" );
                // _machinePuid = WSClient.GetUInt64(rdr, "bi_machine_puid");
                // _countryId = WSClient.GetByte(rdr, "ti_country_id");
                // _languageId = WSClient.GetInt32(rdr, "i_language_id");
                // _cultureId = WSClient.GetInt32(rdr, "i_culture_id");
                // _accountId = WSClient.GetString(rdr, "vc_billing_account_id");
                // _paymentInfoId = WSClient.GetString(rdr, "vc_billing_payinfo_id");
                // _gamerTag  = WSClient.GetString(rdr, "vc_gamertag");
                // _birthdate = WSClient.GetDateTime(rdr, "dt_birthdate");
                // _ticketFlags = WSClient.GetInt16(rdr, "si_ticket_flags");
                // _accountResumeDate = WSClient.GetDateTime(rdr, "dt_acct_resume_date");
                // _suspensionLength  = WSClient.GetInt32(rdr, "i_suspension_length");
                // _voiceResumeDate   = WSClient.GetDateTime(rdr, "dt_voice_resume_date");
                // _voiceBanLength = WSClient.GetInt32(rdr, "i_voice_ban_length");
                // _nameChangeRequired = WSClient.GetByte(rdr, "ti_name_change_required");
                // _acceptedTOSDate = WSClient.GetDateTime(rdr, "dt_accepted_tos");
                // _resetDate = WSClient.GetDateTime(rdr, "dt_reset_date");
                // _billingAccountStatus = WSClient.GetUInt32(rdr, "i_billing_account_status");
                // _billingPIN = WSClient.GetBytes(rdr, "bin_acct_pin");
                // _parentalControlGroupId = WSClient.GetInt32(rdr, "i_parental_control_group_id");
                // _lastChangeDate = WSClient.GetDateTime(rdr, "dt_change_datetime");
                // _downgraded = WSClient.GetByte(rdr, "f_downgraded");
                // _lastActivityDate = WSClient.GetDateTime(rdr, "dt_last_activity");
                // _lastWebActivityDate = WSClient.GetDateTime(rdr, "dt_last_web_activity");
                // _acceptMsSpam = WSClient.GetByte(rdr, "f_ms_opt_in");
                // _acceptPartnerSpam = WSClient.GetByte(rdr, "f_partner_opt_in");
                // _hasMusicnetAccount = (byte) WSClient.GetInt32(rdr, "i_has_musicnet_account");
                // _hasGamerProfile = (byte) WSClient.GetInt32(rdr, "i_has_gamer_profile");
                // _isGeoFenceExempt = WSClient.GetByte(rdr, "f_geofence_exempt");
                // _wholesalePartnerId = WSClient.GetUInt32(rdr, "i_wholesale_partner_id");
                // _tier = WSClient.GetInt32(rdr, "i_tier_id");

                _countryId = WSClient.GetByte(rdr, "ti_country_id");

                rdr.Close();

                hr = (uint)ws.GetIntParameter("@hr");
                if (HResult.Failed(hr))
                {
                    throw new Exception(ws.GetCallSignature() + " failed with hr = " + hr);
                }
            }
        }

        //
        // Privileges
        //

        // Code stolen from \private\common\user\User.cs
        using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
        {
            ws.StoredProc = "dbo.p_signin_get_user_privileges";
            ws.SetHashVal(LiveXuid);

            ws.AddParameter(ParamType.RETVAL, "@RETVAL", 0);
            ws.AddParameter(ParamType.INPUT, "@bi_user_puid", LiveXuid);

            using (WstDataReader r = ws.Execute())
            {
                // initially the privilege set is all set to false, so cycle through
                // the privileges that are returned and set them to true
                while (r.Read())
                {
                    int privilege = r.GetByte(0);
                    _userPrivileges[privilege] = true;
                }

                hr = (uint)ws.GetIntParameter("@RETVAL");
                if (HResult.Failed(hr))
                    throw new Exception("p_xuacs_get_user_privileges call failed with HR " + hr);
            }
        }

        //
        // Put everything in xbanc now
        //

        PutToXBanc();

    }



    // -------------------------------------------------------------------------
    // NewLocalInstance - constructs a new AAInfo object for local use. Only the GetAAInfo 
    // front door and tests should use this function.
    // -------------------------------------------------------------------------
    public static AAInfo NewLocalInstance(
        ulong passportPuid,
        ulong? liveXuid,
        string ipAddressInternet)
    {
        AAInfoMiddleTier aa = new AAInfoMiddleTier();
        aa._passportPuid = passportPuid;
        aa._liveXuid = liveXuid;
        aa._ipAddressInternet = ipAddressInternet;
        aa.UseXBanc = false;
        return aa;
    }


}


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\querylib\Dataset.cs ===
using Microsoft.Webstore.WstClient;
using System;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.Reflection;
using System.Web;
using xonline.common.plugins;
using xonline.common.protocol;
using xonline.common.sql.webstore;
using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;

using xonline.common.sql.sqlclient;


namespace xonline.server.querylib 
{
    public class Dataset
    {
        public const ulong C_TEAM_PREFIX = 0xFEFE000000000000;
        

        public static bool IsTeamPuid(ulong puid)
        {
            return ((puid & C_TEAM_PREFIX) == C_TEAM_PREFIX);
        }

        
        // ******************************************************
        //
        //  Public methods
        //
        // ******************************************************
        public BundledAuthData bundledAuth;
        
        
        //-----------------------------------------------------
        // SourceFromRequest
        //
        //      Set the request source based on callsourceinfo from SGInfo and the http context. 
        //
        public static Source SourceFromRequest(string viface, HttpContext ctx)
        {
            Source      source = (viface == VirtualInterface.xqry ? Source.Xbox : 0) | (viface == VirtualInterface.xqry_int ? Source.Server : 0);            

            if (viface == VirtualInterface.xqry_int)
            {
                // Check to see if we have a header from the webcache boxes
                string sourceHint = ctx.Request.Headers[XHttpHdr.WEBCACHEREQUEST];

                if(sourceHint != null) 
                {
                    sourceHint = sourceHint.ToUpper();                    
                    if( sourceHint == "TRUE" || sourceHint == "ON" || sourceHint == "YES" || sourceHint == "1" ) 
                    {
                        // This treats web calls the same as xbox client calls. 
                        source = Source.Web;
                    }
                }
            }

            return source;
        }

        
        //-----------------------------------------------------
        // Add
        //
        //      Add a new entry to a dataset.  
        //
        public static HResult Add(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, QueryAttribute[] attribs, out ulong entityId)
        {
            return InternalAdd(Source.Plugin | source, titleId, userId, teamId, datasetId, attribs, out entityId);
        }
        
        //-----------------------------------------------------
        // Update
        //
        //      Update a set of existing entries in a dataset.  
        //
        public static HResult Update(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, uint procIndex, QueryAttribute[] attribs)
        {
            return InternalUpdate(Source.Plugin | source, titleId, userId, teamId, datasetId, procIndex, attribs);
        }
        
        //-----------------------------------------------------
        // UpdateId
        //
        //      Update an existing entry in a dataset.  
        //
        public static HResult UpdateId(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, uint procIndex, ulong entityId, QueryAttribute[] attribs)
        {
            return InternalUpdateId(Source.Plugin | source, titleId, userId, teamId, datasetId, procIndex, entityId, attribs);
        }
        
        //-----------------------------------------------------
        // Remove
        //
        //      Remove one or more entires based on provided
        //      attributes.  
        //
        public static HResult Remove(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, uint procIndex, QueryAttribute[] attribs)
        {
            return InternalRemove(Source.Plugin | source, titleId, userId, teamId, datasetId, procIndex, attribs);
        }
        
        //-----------------------------------------------------
        // RemoveId
        //
        //      Remove a specific entry in a dataset.
        //
        public static HResult RemoveId(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId)
        {
            return InternalRemoveId(Source.Plugin | source, titleId, userId, teamId, datasetId, entityId);
        }    
        
        //-----------------------------------------------------
        // Select
        //
        //      Execute a plugin-defined action on a dataset.  
        //
        public static HResult Select(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId, uint actionId, QueryAttribute[] attribs)
        {
            return InternalSelect(Source.Plugin | source, titleId, userId, teamId, datasetId, entityId, actionId, attribs, null, null);
        }
        
        
        //-----------------------------------------------------
        // Search
        //
        //      Query for a list of entries according to the 
        //      provided attributes
        //
        public static HResult Search(Source source, uint titleId, 
                                  uint datasetId, 
                                  uint procIndex, 
                                  uint page, 
                                  uint resultsPerPage, 
                                  QueryAttribute[] attribs, 
                                  QueryAttributeSpec[] resultSpecs,
                                  out uint totalResults, 
                                  out QueryAttribute[,] results)
        {
            uint returnedResults;
            HResult hr;
            SqlDataReader reader = null;
            SqlClient cmd = null;

            try
            {
                hr = InternalSearch(Source.Plugin | source, titleId, datasetId, procIndex, page, resultsPerPage, attribs, resultSpecs, out totalResults, out returnedResults, out reader, out cmd);
                
                results = null;
                if ((returnedResults > 0) || (reader.HasRows))
                {
                    results = Get2DAttributesFromResults(titleId, reader, resultSpecs, returnedResults);

                    returnedResults = (uint)results.GetLength(0);
                }    
            }
            finally
            {
                if (null != cmd)
                {
                    cmd.Close();                    
                }
                
                if (null != reader)
                {
                    reader.Close();
                }
            }
            

            return hr;
        }

        //-----------------------------------------------------
        // FindFromIds
        //
        //      Get one or more specific entities.
        //
        public static HResult FindFromIds(Source source, uint titleId, 
                                       uint datasetId, 
                                       uint procIndex,
                                       ulong[] entityIds, 
                                       QueryAttributeSpec[] resultSpecs,
                                       out QueryAttribute[,] results
                                       )
        {
            HResult hr;
            SqlDataReader reader = null;
            SqlClient cmd = null;

            try
            {
                hr = InternalFindFromIds(Source.Plugin | source, titleId, datasetId, procIndex, entityIds, resultSpecs, out reader, out cmd);
                
                if (HResult.Failed(hr))
                {
                    results = null;
                    return hr;
                }    
                
                results = Get2DAttributesFromResults(titleId, reader, resultSpecs, (uint)entityIds.Length);
            }
            finally
            {
                if (null != cmd)
                {
                    cmd.Close();                    
                }
                
                if (null != reader)
                {
                    reader.Close();
                }
            }
            
            return hr;

        }
        
        //-----------------------------------------------------
        // ExecCustom
        //
        //      Execute a custom stored proc on a dataset.  
        //
        public static HResult ExecCustom(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, uint procIndex, ulong entityId, QueryAttribute[] attribs)
        {
            return InternalExecCustom(Source.Plugin | source, titleId, userId, teamId, datasetId, procIndex, entityId, attribs);
        }
        


        // ******************************************************
        //
        //  Internal methods
        //
        // ******************************************************
        
        
        public static HResult InternalAdd(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, QueryAttribute[] attribs, out ulong entityId)
        {
            DatasetInfo dsi;
            int i;
            SqlClient cmd = null;
            HResult hr;
            uint id;
            
            entityId = 0;
            
            
            dsi = DatasetInfo.GetDSInfo(titleId, datasetId);

            
            try
            {
                // call beforeadd on plugins
                //
                hr = dsi.BeforeAdd(source, titleId, userId, teamId, datasetId, attribs);
                if (HResult.Failed(hr))
                {
                    goto end;
                }
                
                // do database work
                //
                cmd = new SqlClient(Interface.querydb, titleId, (uint)dsi.Partition);
                cmd.StoredProc = "p_query_add_" + titleId.ToString("x8") + "_" + datasetId.ToString("x");
                
                cmd.AddParameter(ParameterDirection.ReturnValue, "@ret", 0);
                cmd.AddParameter("@bi_owner_id", teamId == 0 ? userId : teamId);                
                cmd.AddParameter("@i_owner_quota", titleId == userId ? -1 : dsi.OwnerQuota);
                
                
                for (i = 0; i < attribs.Length; i++)
                {
                    id = attribs[i].Id | XOn.X_ATTRIBUTE_DATAFLAG_PARAM;
                    switch(attribs[i].Id & XOn.X_ATTRIBUTE_DATATYPE_MASK)
                    {
                    case XOn.X_ATTRIBUTE_DATATYPE_INTEGER: 
                        cmd.AddParameter("@att_" + id.ToString("x8"), attribs[i].lValue);
                        break;
    
                    case XOn.X_ATTRIBUTE_DATATYPE_STRING: 
                        cmd.AddParameter("@att_" + id.ToString("x8"), attribs[i].strValue);
                        break;
                        
                    case XOn.X_ATTRIBUTE_DATATYPE_BLOB: 
                        cmd.AddParameter("@att_" + id.ToString("x8"), attribs[i].binValue);
                        break;
                    }
                }
                
                cmd.AddParameter(ParameterDirection.Output, "@bi_entity_id", (long)0);
                
                cmd.ExecuteNonQuery();
                
                entityId = (ulong)cmd.GetLongParameter("@bi_entity_id");
                hr = (uint)cmd.GetIntParameter("@ret");            
                if (HResult.Failed(hr))
                {
                    goto end;
                }
                
                // call afteradd on plugins
                //
                // REVIEW: indeed, this error handling sucks.  Unfortunately much of the plugin work can only be done
                // once an entityId exists.     A better way might be to allocate the entityId before calling
                // beforeAdd. 
                //
                hr = dsi.AfterAdd(source, titleId, userId, teamId, datasetId, attribs, entityId);
                if (HResult.Failed(hr))
                {
                    // attempt to remove the just-added entity
                    Xom.Trace(XomAreaName.xqry, LogLevel.L_LOW, "AfterAdd call failed attempting to remove entity! hr = " + hr);
                    
                    try
                    {
                        // Calling RemoveId rather than InternalRemoveId to ensure permissions are set correctly
                        RemoveId(source, titleId, userId, teamId, datasetId, entityId);
                        Xom.Trace(XomAreaName.xqry, LogLevel.L_LOW, "entity removed successfully.");
                    }
                    catch
                    {
                        // make sure it's not removed again
                        entityId = 0;
                        throw;
                    }    
                    
                    goto end;
                }
            }
            catch (Exception e)
            {
                XEvent.Id eventId;
                QueryError.GetBetterHrAndEvent(e, out hr, out eventId);
                
                try
                {
                    
                    if (entityId != 0)
                    {
                        Xom.Trace(XomAreaName.xqry, LogLevel.L_LOW, "AfterAdd call threw an exception, attempting to remove entity!");

                        // Calling RemoveId rather than InternalRemoveId to ensure permissions are set correctly
                        RemoveId(source, titleId, userId, teamId, datasetId, entityId);
                        Xom.Trace(XomAreaName.xqry, LogLevel.L_LOW, "entity removed.");
                    }
                    
                }
                catch(Exception e2)
                {
                    throw new XRLException(hr, eventId, "ANOTHER error occrued trying to roll-back from Add error (see inner exception): " + e2.ToString(), e);
                }
                    
                throw new XRLException(hr, eventId, "Add failed, rollback successful.", e);
            }        
            finally
            {
                if (null != cmd)
                {
                    cmd.Close();                    
                }
            }
            
end:
            return hr;
        }
        
        public static HResult InternalUpdate(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, uint procIndex, QueryAttribute[] attribs)
        {
            DatasetInfo dsi;
            int i;
            SqlClient cmd = null;
            HResult hr = HResult.S_OK;
            uint id;
            
            try
            {
                dsi = DatasetInfo.GetDSInfo(titleId, datasetId);
                
                hr = dsi.BeforeUpdate(source, titleId, userId, teamId, datasetId, procIndex, attribs);
                if (HResult.Failed(hr))
                {
                    goto end;
                }
                
                cmd = new SqlClient(Interface.querydb, titleId, (uint)dsi.Partition);
                cmd.StoredProc = "p_query_update_" + titleId.ToString("x8") + "_" + datasetId.ToString("x") + "_" + procIndex.ToString("x");
                
                cmd.AddParameter(ParameterDirection.ReturnValue, "@ret", 0);
                cmd.AddParameter("@bi_owner_id", teamId == 0 ? userId : teamId);
                
                for (i = 0; i < attribs.Length; i++)
                {
                    id = attribs[i].Id | XOn.X_ATTRIBUTE_DATAFLAG_PARAM;
                    switch(id & XOn.X_ATTRIBUTE_DATATYPE_MASK)
                    {
                    case XOn.X_ATTRIBUTE_DATATYPE_INTEGER: 
                        cmd.AddParameter("@att_" + id.ToString("x8"), attribs[i].lValue);
                        break;
    
                    case XOn.X_ATTRIBUTE_DATATYPE_STRING: 
                        cmd.AddParameter("@att_" + id.ToString("x8"), attribs[i].strValue);
                        break;
                        
                    case XOn.X_ATTRIBUTE_DATATYPE_BLOB: 
                        cmd.AddParameter("@att_" + id.ToString("x8"), attribs[i].binValue);
                        break;
                    }
                
                
                }
                
                cmd.ExecuteNonQuery();
                
                hr = (uint)cmd.GetIntParameter("@ret");
                
                
                dsi.AfterUpdate(source, titleId, userId, teamId, datasetId, procIndex, attribs);
            }
            catch (Exception e)
            {
                XEvent.Id eventId;
                QueryError.GetBetterHrAndEvent(e, out hr, out eventId);
                
                throw new XRLException(hr, eventId, "Update failed!", e);
            }
            finally
            {
                if (null != cmd)
                {
                    cmd.Close();                    
                }
            }
            
            
end:            
            return hr;
        
        }
        
        public static HResult InternalUpdateId(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, uint procIndex, ulong entityId, QueryAttribute[] attribs)
        {
            DatasetInfo dsi;
            int i;
            SqlClient cmd = null;
            HResult hr = HResult.S_OK;
            uint id;
            
            try
            {
                dsi = DatasetInfo.GetDSInfo(titleId, datasetId);
                
                hr = dsi.BeforeUpdateId(source, titleId, userId, teamId, datasetId, procIndex, entityId, attribs);
                if (HResult.Failed(hr))
                {
                    goto end;
                }
                
                cmd = new SqlClient(Interface.querydb, titleId, (uint)dsi.Partition);
                
                
                cmd.StoredProc = "p_query_updateid_" + titleId.ToString("x8") + "_" + datasetId.ToString("x") + "_" + procIndex.ToString("x");
                
                cmd.AddParameter(ParameterDirection.ReturnValue, "@ret", 0);
                cmd.AddParameter("@bi_entity_id", entityId);
                cmd.AddParameter("@bi_owner_id", teamId == 0 ? userId : teamId);
                
                for (i = 0; i < attribs.Length; i++)
                {
                    id = attribs[i].Id | XOn.X_ATTRIBUTE_DATAFLAG_PARAM;
                    switch(id & XOn.X_ATTRIBUTE_DATATYPE_MASK)
                    {
                    case XOn.X_ATTRIBUTE_DATATYPE_INTEGER: 
                        cmd.AddParameter("@att_" + id.ToString("x8"), attribs[i].lValue);
                        break;
    
                    case XOn.X_ATTRIBUTE_DATATYPE_STRING: 
                        cmd.AddParameter("@att_" + id.ToString("x8"), attribs[i].strValue);
                        break;
                        
                    case XOn.X_ATTRIBUTE_DATATYPE_BLOB: 
                        cmd.AddParameter("@att_" + id.ToString("x8"), attribs[i].binValue);
                        break;
                    }
                
                
                }
                
                cmd.ExecuteNonQuery();
                
                hr = (uint)cmd.GetIntParameter("@ret");
                
                
                dsi.AfterUpdateId(source, titleId, userId, teamId, datasetId, procIndex, entityId, attribs);
            }
            catch (Exception e)
            {
                XEvent.Id eventId;
                QueryError.GetBetterHrAndEvent(e, out hr, out eventId);
                
                throw new XRLException(hr, eventId, "UpdateId failed!", e);
            }
            finally
            {
                if (null != cmd)
                {
                    cmd.Close();                    
                }
            }
                
            
end:            
            return hr;
        
        }
        
        public static HResult InternalRemove(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, uint procIndex, QueryAttribute[] attribs)
        {
            DatasetInfo dsi;
            int i;
            SqlClient cmd = null;
            HResult hr;
            uint id;
            
            try
            {
                dsi = DatasetInfo.GetDSInfo(titleId, datasetId);
                
                // call BeforeRemove on plugin(s)
                //
                hr = dsi.BeforeRemove(source, titleId, userId, teamId, datasetId, procIndex, attribs);
                if (HResult.Failed(hr))
                {
                    goto end;
                }
    
                            
                // do database work
                //
                cmd = new SqlClient(Interface.querydb, titleId, (uint)dsi.Partition);
                
                
                cmd.StoredProc = "p_query_remove_" + titleId.ToString("x8") + "_" + datasetId.ToString("x") + "_" + procIndex.ToString("x");
                cmd.AddParameter(ParameterDirection.ReturnValue, "@ret", 0);
                cmd.AddParameter("@bi_owner_id", teamId == 0 ? userId : teamId);
               
                for (i = 0; i < attribs.Length; i++)
                {
                    id = attribs[i].Id | XOn.X_ATTRIBUTE_DATAFLAG_PARAM;
                    switch(id & XOn.X_ATTRIBUTE_DATATYPE_MASK)
                    {
                    case XOn.X_ATTRIBUTE_DATATYPE_INTEGER: 
                        cmd.AddParameter("@att_" + id.ToString("x8"), attribs[i].lValue);
                        break;
    
                    case XOn.X_ATTRIBUTE_DATATYPE_STRING: 
                        cmd.AddParameter("@att_" + id.ToString("x8"), attribs[i].strValue);
                        break;
                        
                    case XOn.X_ATTRIBUTE_DATATYPE_BLOB: 
                        cmd.AddParameter("@att_" + id.ToString("x8"), attribs[i].binValue);
                        break;
                    }
                
                
                }
                
                cmd.ExecuteNonQuery();
                
                hr = (uint)cmd.GetIntParameter("@ret");
                
                // call AfterRemove on plugin(s)
                //
                dsi.AfterRemove(source, titleId, userId, teamId, datasetId, procIndex, attribs);
            }    
            catch (Exception e)
            {
                XEvent.Id eventId;
                QueryError.GetBetterHrAndEvent(e, out hr, out eventId);
                
                throw new XRLException(hr, eventId, "Remove failed!", e);
            }
            finally
            {
                if (null != cmd)
                {
                    cmd.Close();                    
                }
            }
            
end:
            return hr;        
        }
        
        public static HResult InternalRemoveId(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId)
        {
            DatasetInfo dsi;
            SqlClient cmd = null;
            HResult hr;
            
            try
            {
                dsi = DatasetInfo.GetDSInfo(titleId, datasetId);
                
                hr = dsi.BeforeRemoveId(source, titleId, userId, teamId, datasetId, entityId);
                if (HResult.Failed(hr))
                {
                    goto end;
                }
                
                cmd = new SqlClient(Interface.querydb, titleId, (uint)dsi.Partition);
                
                
                cmd.StoredProc = "p_query_removeId_" + titleId.ToString("x8") + "_" + datasetId.ToString("x");
                cmd.AddParameter("@bi_owner_id", teamId == 0 ? userId : teamId);
                cmd.AddParameter("@bi_entity_id", entityId);
                cmd.AddParameter(ParameterDirection.ReturnValue, "@ret", hr);
                
                cmd.ExecuteNonQuery();
                
                hr = (uint)cmd.GetIntParameter("@ret");
                
                if (HResult.Failed(hr))
                {
                    goto end;
                }
                
                dsi.AfterRemoveId(source, titleId, userId, teamId, datasetId, entityId);
            }
            catch (Exception e)
            {
                XEvent.Id eventId;
                QueryError.GetBetterHrAndEvent(e, out hr, out eventId);
                
                throw new XRLException(hr, eventId, "RemoveId failed!", e);
            }
            finally
            {
                if (null != cmd)
                {
                    cmd.Close();                    
                }
            }
            
end:
            return hr;
        }   
        
        public static HResult InternalSelect(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, ulong entityId, uint actionId, QueryAttribute[] attribs, BundledAuthData bundledAuth, TeamTickets bundledTickets)
        {
            DatasetInfo dsi;
            HResult hr;
            
            dsi = DatasetInfo.GetDSInfo(titleId, datasetId);
            hr = dsi.Select(source, titleId, userId, teamId, datasetId, entityId, actionId, attribs, bundledAuth, bundledTickets);
            
            return hr;
        }
        
        

        
        public static HResult InternalSearch(Source source, uint titleId, 
                                          uint datasetId, 
                                          uint procIndex, 
                                          uint page, 
                                          uint resultsPerPage, 
                                          QueryAttribute[] attribs, 
                                          QueryAttributeSpec[] resultSpecs,
                                          out uint totalResults, 
                                          out uint returnedResults,
                                          out SqlDataReader reader,
                                          out SqlClient cmd
                                          )
        {
            DatasetInfo dsi;
            HResult    hr;
            int i;
            uint id;

            try
            {
                totalResults = 0;
                returnedResults = 0;
                
                reader = null;
                cmd = null;
                
                // run the search
                //
                dsi = DatasetInfo.GetDSInfo(titleId, datasetId);
    
                // call BeforeSearch on plugin(s)
                //
                hr = dsi.BeforeSearch(source, titleId, datasetId, procIndex, attribs);
                if (HResult.Failed(hr))
                {
                    goto end;
                }
                
                cmd = new SqlClient(Interface.querydb, titleId, (uint)dsi.Partition);
                
                
                cmd.StoredProc = "p_query_search_" + titleId.ToString("x8") + "_" + datasetId.ToString("x") + "_" + procIndex.ToString("x");
    
                // REVIEW:  This asks for all rows up to the requested page,
                // would it be more performant to skip in the sp and have it only 
                // return the desired rows?
                // doing so would require first dumping this resultset into a 
                // temp table, then grabbing the correct page from it...
                //
                cmd.AddParameter("@i_max_results", (page+1) * resultsPerPage);
                
                for (i = 0; i < attribs.Length; i++)
                {
                    id = attribs[i].Id | XOn.X_ATTRIBUTE_DATAFLAG_PARAM;
                    switch(id & XOn.X_ATTRIBUTE_DATATYPE_MASK)
                    {
                    case XOn.X_ATTRIBUTE_DATATYPE_INTEGER: 
                        cmd.AddParameter("@att_" + id.ToString("x8"), attribs[i].lValue);
                        break;
    
                    case XOn.X_ATTRIBUTE_DATATYPE_STRING: 
                        cmd.AddParameter("@att_" + id.ToString("x8"), attribs[i].strValue);
                        break;
                        
                    case XOn.X_ATTRIBUTE_DATATYPE_BLOB: 
                        cmd.AddParameter("@att_" + id.ToString("x8"), attribs[i].binValue);
                        break;
                    
                    case XOn.X_ATTRIBUTE_DATATYPE_NULL: 
                        // skip it, let the param default handle it
                        break;
                    }
                }
                
                reader = cmd.Execute();
                reader.Read();
                
                totalResults = (uint)reader.GetInt32(0);
                returnedResults = (uint)Math.Max(0, Math.Min((int)resultsPerPage, (int)(totalResults - (page * resultsPerPage))));
                
                reader.NextResult();
                
                if (reader.FieldCount != resultSpecs.Length && reader.FieldCount != -1)
                {
                    hr = HResult.XONLINE_E_QUERY_SPEC_COUNT_MISMATCH;
                }
                
                for (i = 0; i < page * resultsPerPage; i++)
                {
                    if (!reader.Read())
                        break;
                }
            }                    
            catch (Exception e)
            {
                XEvent.Id eventId;
                QueryError.GetBetterHrAndEvent(e, out hr, out eventId);
                
                throw new XRLException(hr, eventId, "Search failed!", e);
            }
            
end:            
            return hr;            
        }
            
        
        public static HResult InternalFindFromIds(Source source, uint titleId, 
                                               uint datasetId, 
                                               uint procIndex,
                                               ulong[] entityIds, 
                                               QueryAttributeSpec[] resultSpecs,
                                               out SqlDataReader reader,
                                               out SqlClient cmd
                                               )
        {
            DatasetInfo dsi;
            HResult hr;
            int i;

            cmd = null;
            reader = null;

            try
            {
                // run the search
                //
                dsi = DatasetInfo.GetDSInfo(titleId, datasetId);
    
    
                // call BeforeSearch on plugin(s)
                //
                hr = dsi.BeforeFindFromIds(source, titleId, datasetId, procIndex, entityIds);
                if (HResult.Failed(hr))
                {
                    goto end;
                }
                
    
                cmd = new SqlClient(Interface.querydb, titleId, (uint)dsi.Partition);
                
                
                cmd.StoredProc = "p_query_find_ids_" + titleId.ToString("x8") + "_" + datasetId.ToString("x") + "_" + procIndex.ToString("x");
    
                cmd.AddParameter("@i_num_ids", entityIds.Length);
                
                
                for (i = 0; i < entityIds.Length; i++)
                {
                    cmd.AddParameter("@id" + i, (long)entityIds[i]);
                }
                
                reader = cmd.Execute();
                if (!reader.Read())
                {
                    throw new XRLException(HResult.XONLINE_E_QUERY_ERROR, XEvent.Id.QUERY_BAD_DATA_10, "1st resultset from FindIds has no rows!");
                }
                
                hr = (uint)reader.GetInt32(0);
                if (HResult.Failed(hr))
                {
                    goto end;
                }
                    
                reader.NextResult();
                
                if (reader.FieldCount != resultSpecs.Length && reader.FieldCount != -1)
                {
                    Xom.Trace(XomAreaName.xqry, LogLevel.L_WARNING, "FindFromIDs attempted with wrong list of specs!  reader.FieldCount: " + reader.FieldCount + " spec count: " + resultSpecs.Length);
                    hr = HResult.XONLINE_E_QUERY_SPEC_COUNT_MISMATCH;
                }
                
                
            }
            catch (Exception e)
            {
                XEvent.Id eventId;
                QueryError.GetBetterHrAndEvent(e, out hr, out eventId);
                
                throw new XRLException(hr, eventId, "FindFromIds failed!", e);
            }
                
end:            
            return hr;            
        }
            
        internal static HResult InternalExecCustom(Source source, uint titleId, ulong userId, ulong teamId, uint datasetId, uint procIndex, ulong entityId, QueryAttribute[] attribs)
        {
            DatasetInfo dsi;
            int i;
            SqlClient cmd = null;
            HResult hr;
            uint id;
            
            dsi = DatasetInfo.GetDSInfo(titleId, datasetId);
            

            try
            {
                // call BeforeSearch on plugin(s)
                //
                hr = dsi.BeforeCustom(source, titleId, datasetId, procIndex, attribs);
                if (HResult.Failed(hr))
                {
                    goto end;
                }
                
                
                cmd = new SqlClient(Interface.querydb, titleId, (uint)dsi.Partition);
                
                
                cmd.StoredProc = "p_query_custom_" + titleId.ToString("x8") + "_" + datasetId.ToString("x") + "_" + procIndex.ToString("x");
                
                cmd.AddParameter(ParameterDirection.ReturnValue, "@ret", 0);
                cmd.AddParameter("@bi_owner_id", teamId == 0 ? userId : teamId);
                cmd.AddParameter("@bi_entity_id", entityId);
                
                for (i = 0; i < attribs.Length; i++)
                {
                    id = attribs[i].Id | XOn.X_ATTRIBUTE_DATAFLAG_PARAM;
                    switch(id & XOn.X_ATTRIBUTE_DATATYPE_MASK)
                    {
                    case XOn.X_ATTRIBUTE_DATATYPE_INTEGER: 
                        cmd.AddParameter("@att_" + id.ToString("x8"), attribs[i].lValue);
                        break;
    
                    case XOn.X_ATTRIBUTE_DATATYPE_STRING: 
                        cmd.AddParameter("@att_" + id.ToString("x8"), attribs[i].strValue);
                        break;
                        
                    case XOn.X_ATTRIBUTE_DATATYPE_BLOB: 
                        cmd.AddParameter("@att_" + id.ToString("x8"), attribs[i].binValue);
                        break;
                    }
                
                
                }
                
                cmd.ExecuteNonQuery();
                
                hr = (uint)cmd.GetIntParameter("@ret");
            }
            catch (Exception e)
            {
                XEvent.Id eventId;
                QueryError.GetBetterHrAndEvent(e, out hr, out eventId);
                
                throw new XRLException(hr, eventId, "ExecCustom failed!", e);
            }
            finally
            {
                if (null != cmd)
                {
                    cmd.Close();                    
                }
            }
                
end:            
            return hr;
        }
        

        //
        // Map a user puid or team puid to the corresponding name. 
        //
        public static string MapPUIDToName(uint titleId, ulong puid)
        {
            string  name = "";

            if (0 != puid)
            {
                if (IsTeamPuid(puid))
                {
                    name = XCache.LookupTeamName(titleId, puid);
                }
                else
                {
                    name = XCache.LookupGamerTag(puid);
                }
            }
            return name;
        }

        
        //
        // Take a webstore resultset and return a flattened array of attributes that represents the results
        //
        public static QueryAttribute[] GetAttributesFromResults(uint titleId, SqlDataReader reader, QueryAttributeSpec[] resultSpecs, uint expectedCount)
        {
            QueryAttribute[] results;
            int r, j;
            int index;
            int len;
            byte[] buf;
            bool fNeedMapping = false;
            
            results = new QueryAttribute[expectedCount * resultSpecs.Length];
            
            // copy search results to results array 
            //            
            j = 0;
            r = 0;
            while(reader.Read())
            {
                // Check to ensure our hint is accurate
                if (r >= expectedCount)
                {
                    // There is more data than we expected!
                    // create a new results array with the actual count
                    QueryAttribute[] newResults = new QueryAttribute[(uint)(r + 1) * (resultSpecs.Length)];
                    Array.Copy(results, 0, newResults, 0, r * (resultSpecs.Length));
                    
                    results = newResults;
                    expectedCount = (uint)r + 1;
                }
                
                // read the list of attributes
                //
                for (j = 0; j < resultSpecs.Length; j++)
                {
                    index = r * resultSpecs.Length + j;
                    
                    results[index] = new QueryAttribute();
                    results[index].Id = resultSpecs[j].type;
                    
                    switch(resultSpecs[j].type & XOn.X_ATTRIBUTE_DATATYPE_MASK)
                    {
                    case XOn.X_ATTRIBUTE_DATATYPE_INTEGER:
                        if (reader.GetFieldType(j) != typeof(long))
                        {
                            throw new XRLException(HResult.XONLINE_E_QUERY_UNEXPECTED_ATTRIBUTE, XEvent.Id.QUERY_BAD_DATA_11,
                                "Mismatched attribute types!\r\n" +
                                "column: " + j + "\r\n" + 
                                "spec: 0x" + resultSpecs[j].type.ToString("x8") + "\r\n" + 
                                "actual column name: " + reader.GetName(j) + "\r\n" +
                                "actual type: " + reader.GetFieldType(j).ToString());
                        }                                
                                
                        results[index].lValue = reader.GetInt64(j);
                        break;
                        
                    case XOn.X_ATTRIBUTE_DATATYPE_STRING:
                        if (0 != (resultSpecs[j].type & XOn.X_ATTRIBUTE_DATAFLAG_MAPPED))
                        {
                            // Mapped PUID or TEAM value. The actual data from SQL is an integer
                            //  value, but we need to convert it to the value that the client expects. 
                            // For now, just read out the int value. We'll convert it later. 
                            results[index].lValue = reader.GetInt64(j);     

                            fNeedMapping = true;
                        }
                        else
                        {
                            if (reader.GetFieldType(j) != typeof(string))
                            {
                                throw new XRLException(HResult.XONLINE_E_QUERY_UNEXPECTED_ATTRIBUTE, XEvent.Id.QUERY_BAD_DATA_12,
                                    "Mismatched attribute types!\r\n" +
                                    "column: " + j + "\r\n" + 
                                    "spec: 0x" + resultSpecs[j].type.ToString("x8") + "\r\n" + 
                                    "actual column name: " + reader.GetName(j) + "\r\n" +
                                    "actual type: " + reader.GetFieldType(j).ToString());
                            }                                
                                                        
                            results[index].strValue = reader.GetString(j);

                            len = (results[index].strValue).Length;
                            
                            if (len > resultSpecs[j].len)
                            {
                                // should we be logging this as an NT event?
                                // ops can't exactly do anything about it..
                                //
                                Xom.Trace(XomAreaName.xqry, LogLevel.L_WARNING, "string value returned from db is longer than spec-allowed length!! Truncating.. (" + 
                                                len + " vs. " + resultSpecs[j].len + ") " + 
                                                "spec: " + j + "  entityId: 0x" + reader.GetInt64(0).ToString("x8"));
                            
                                results[index].strValue = (results[index].strValue).Substring(0, (int)resultSpecs[j].len);
                            }                        
                        }
                        
                        break;
                        
                    case XOn.X_ATTRIBUTE_DATATYPE_BLOB:
                        if (reader.GetFieldType(j) != typeof(byte[]))
                        {
                            throw new XRLException(HResult.XONLINE_E_QUERY_UNEXPECTED_ATTRIBUTE, XEvent.Id.QUERY_BAD_DATA_13,
                                "Mismatched attribute types!\r\n" +
                                "column: " + j + "\r\n" + 
                                "spec: 0x" + resultSpecs[j].type.ToString("x8") + "\r\n" + 
                                "actual column name: " + reader.GetName(j) + "\r\n" +
                                "actual type: " + reader.GetFieldType(j).ToString());
                        }                                
                        
                        results[index].binValue = reader.GetSqlBinary(j).Value;
                        len = (int)reader.GetSqlBinary(j).Length;
                        
                        if (len > resultSpecs[j].len)
                        {
                            // should we be logging this as an NT event?
                            // ops can't exactly do anything about it..
                            //
                            Xom.Trace(XomAreaName.xqry, LogLevel.L_WARNING, "blob value returned from db is longer than spec-allowed length!! Truncating.. (" + 
                                            len + " vs. " + resultSpecs[j].len + ") " + 
                                            "spec: " + j + "  entityId: 0x" + reader.GetInt64(0).ToString("x8"));
                        
                            len = (int)resultSpecs[j].len;
                            buf = new byte[len];
                            Array.Copy(results[index].binValue, buf, len);
                            results[index].binValue = buf;
                        }                        
                        break;
                    
                    default:
                        throw new XRLException(HResult.XONLINE_E_QUERY_ERROR, XEvent.Id.QUERY_BAD_DATA_14,
                                    "Unexpected attribute type! id: 0x" + resultSpecs[j].type.ToString("x8"));                  
                    }
                }   
                
                r++;
            }                   

            // Done with the reader. Dispose of it before we do attribute mapping, etc.
            reader.Close();

            // Do any attribute mapping required
            if (fNeedMapping)
            {
                for (int i=0; i<r; i++)
                {
                    for (j=0; j < resultSpecs.Length; j++)
                    {
                        if (0 != (resultSpecs[j].type & XOn.X_ATTRIBUTE_DATAFLAG_MAPPED))
                        {
                            index = i * resultSpecs.Length + j;
                            // data should be an int - convert it to the proper string representation
                            results[index].strValue = MapPUIDToName(titleId, (ulong)results[index].lValue);

                            len = (results[index].strValue).Length;
                            
                            if (len > resultSpecs[j].len)
                            {
                                // should we be logging this as an NT event?
                                // ops can't exactly do anything about it..
                                //
                                Xom.Trace(XomAreaName.xqry, LogLevel.L_WARNING, "string value returned from db is longer than spec-allowed length!! Truncating.. (" + 
                                                len + " vs. " + resultSpecs[j].len + ") " + 
                                                "spec: " + j + "  entityId: 0x" + reader.GetInt64(0).ToString("x8"));
                            
                                results[index].strValue = (results[index].strValue).Substring(0, (int)resultSpecs[j].len);
                            }                        
                        }
                    }
                }
            }
            
            if (r < expectedCount)
            {
                // create a new results array with the actual count
                QueryAttribute[] newResults = new QueryAttribute[r * (resultSpecs.Length)];
                Array.Copy(results, 0, newResults, 0, r * (resultSpecs.Length));
                
                results = newResults;
            }    
            
            return results;
        }

        
        //
        // Same as above, but return a 2 dimensional array
        //
        private static QueryAttribute[,] Get2DAttributesFromResults(uint titleId, SqlDataReader reader, QueryAttributeSpec[] resultSpecs, uint expectedCount)
        {
            QueryAttribute[,] results;
            int r, j;
            int len;
            byte[] buf;
            bool fNeedMapping = false;
            
            results = new QueryAttribute[expectedCount, resultSpecs.Length];
            
            // copy search results to results array 
            //            
            j = 0;
            r = 0;
            while(reader.Read())
            {
                // Check to ensure our hint is accurate
                if (r >= expectedCount)
                {
                    // There is more data than we expected!
                    // create a new results array with the actual count
                    QueryAttribute[,] newResults = new QueryAttribute[(uint)(r + 1),resultSpecs.Length];

                    Array.Copy(results, 0, newResults, 0, r * (resultSpecs.Length));
                    
                    results = newResults;
                    expectedCount = (uint)r + 1;
                }                
            
                // read the list of attributes
                //
                for (j = 0; j < resultSpecs.Length; j++)
                {
                    results[r,j] = new QueryAttribute();
                    results[r,j].Id = resultSpecs[j].type;
                    
                    switch(resultSpecs[j].type & XOn.X_ATTRIBUTE_DATATYPE_MASK)
                    {
                    case XOn.X_ATTRIBUTE_DATATYPE_INTEGER:
                        if (reader.GetFieldType(j) != typeof(long))
                        {
                            throw new XRLException(HResult.XONLINE_E_QUERY_UNEXPECTED_ATTRIBUTE, XEvent.Id.QUERY_BAD_DATA_15,
                                "Mismatched attribute types!\r\n" +
                                "column: " + j + "\r\n" + 
                                "spec: 0x" + resultSpecs[j].type.ToString("x8") + "\r\n" + 
                                "actual column name: " + reader.GetName(j) + "\r\n" +
                                "actual type: " + reader.GetFieldType(j).ToString());
                        }                                
                                
                        results[r,j].lValue = reader.GetInt64(j);
                        break;
                        
                    case XOn.X_ATTRIBUTE_DATATYPE_STRING:
                        if (0 != (resultSpecs[j].type & XOn.X_ATTRIBUTE_DATAFLAG_MAPPED))
                        {
                            // Mapped PUID or TEAM value. The actual data from SQL is an integer
                            //  value, but we need to convert it to the value that the client expects. 
                            // For now, just read out the int value. We'll convert it later. 
                            results[r,j].lValue = reader.GetInt64(j);
                            
                            fNeedMapping = true;                            
                        }
                        else
                        {
                            if (reader.GetFieldType(j) != typeof(string))
                            {
                                throw new XRLException(HResult.XONLINE_E_QUERY_UNEXPECTED_ATTRIBUTE, XEvent.Id.QUERY_BAD_DATA_16,
                                    "Mismatched attribute types!\r\n" +
                                    "column: " + j + "\r\n" + 
                                    "spec: 0x" + resultSpecs[j].type.ToString("x8") + "\r\n" + 
                                    "actual column name: " + reader.GetName(j) + "\r\n" +
                                    "actual type: " + reader.GetFieldType(j).ToString());
                            }                                
                                    
                            results[r,j].strValue = reader.GetString(j);
                            len = (results[r,j].strValue).Length;
                            
                            if (len > resultSpecs[j].len)
                            {
                                // should we be logging this as an NT event?
                                // ops can't exactly do anything about it..
                                //
                                Xom.Trace(XomAreaName.xqry, LogLevel.L_WARNING, "string value returned from db is longer than spec-allowed length!! Truncating.. (" + 
                                                len + " vs. " + resultSpecs[j].len + ") " + 
                                                "spec: " + j + "  entityId: 0x" + reader.GetInt64(0).ToString("x8"));
                            
                                results[r,j].strValue = (results[r,j].strValue).Substring(0, (int)resultSpecs[j].len);
                            }                        
                        }
                        
                        break;
                        
                    case XOn.X_ATTRIBUTE_DATATYPE_BLOB:
                        if (reader.GetFieldType(j) != typeof(byte[]))
                        {
                            throw new XRLException(HResult.XONLINE_E_QUERY_UNEXPECTED_ATTRIBUTE, XEvent.Id.QUERY_BAD_DATA_17,
                                "Mismatched attribute types!\r\n" +
                                "column: " + j + "\r\n" + 
                                "spec: 0x" + resultSpecs[j].type.ToString("x8") + "\r\n" + 
                                "actual column name: " + reader.GetName(j) + "\r\n" +
                                "actual type: " + reader.GetFieldType(j).ToString());
                        }                                
                                
                        results[r,j].binValue = reader.GetSqlBinary(j).Value;
                        len = (int)reader.GetSqlBinary(j).Length;
                        
                        if (len > resultSpecs[j].len)
                        {
                            // should we be logging this as an NT event?
                            // ops can't exactly do anything about it..
                            //
                            Xom.Trace(XomAreaName.xqry, LogLevel.L_WARNING, "blob value returned from db is longer than spec-allowed length!! Truncating.. (" + 
                                            len + " vs. " + resultSpecs[j].len + ") " + 
                                            "spec: " + j + "  entityId: 0x" + reader.GetInt64(0).ToString("x8"));
                        
                            len = (int)resultSpecs[j].len;
                            buf = new byte[len];
                            Array.Copy(results[r,j].binValue, buf, len);
                            results[r,j].binValue = buf;
                        }                        
                        break;
                    
                    default:
                        throw new XRLException(HResult.XONLINE_E_QUERY_ERROR, XEvent.Id.QUERY_BAD_DATA_18,
                                    "Unexpected attribute type! id: 0x" + resultSpecs[j].type.ToString("x8"));                    }
                }   
                
                r++;
            }                   
            
            // Done with the reader. Dispose of it before we do attribute mapping, etc.
            reader.Close();

            // Do any attribute mapping required
            if (fNeedMapping)
            {
                for (int i=0; i<r; i++)
                {
                    for (j=0; j < resultSpecs.Length; j++)
                    {
                        if (0 != (resultSpecs[j].type & XOn.X_ATTRIBUTE_DATAFLAG_MAPPED))
                        {
                            // data should be an int - convert it to the proper string representation
                            results[i, j].strValue = MapPUIDToName(titleId, (ulong)results[i, j].lValue);

                            len = (results[r,j].strValue).Length;
                            
                            if (len > resultSpecs[j].len)
                            {
                                // should we be logging this as an NT event?
                                // ops can't exactly do anything about it..
                                //
                                Xom.Trace(XomAreaName.xqry, LogLevel.L_WARNING, "string value returned from db is longer than spec-allowed length!! Truncating.. (" + 
                                                len + " vs. " + resultSpecs[j].len + ") " + 
                                                "spec: " + j + "  entityId: 0x" + reader.GetInt64(0).ToString("x8"));
                            
                                results[r,j].strValue = (results[r,j].strValue).Substring(0, (int)resultSpecs[j].len);
                            }                        
                        }
                    }
                }
            }
            
            if (r < expectedCount)
            {
                // create a new results array with the actual count
                QueryAttribute[,] newResults = new QueryAttribute[r,resultSpecs.Length];

                Array.Copy(results, 0, newResults, 0, r * (resultSpecs.Length));
                
                results = newResults;
            }    
            
            return results;
        }
        

        public static HResult UpdateQueryTrust(uint titleId, ulong userId, int addCompMatches, int addCompNoShows)
        {
            if ( (TrustToggle.Off) || (IsTeamPuid(userId)) )
            {
                return HResult.S_OK;
            }
            
            WSClient ws = null;
            HResult hr;
            
            // do database work
            //
            using(ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                
                // Data is partitioned by user puid
                ws.PartitionType   = WstPartitionType.Logical;
                ws.Partition       = ws.CalcPartition(userId);
    
                ws.StoredProc = "dbo.p_xqry_update_user_trust";
                
                ws.AddParameter(ParamType.RETVAL, "@ret", 0);
                ws.AddParameter("@user_puid", userId);
                ws.AddParameter("@title_id", titleId);
                ws.AddParameter("@C12_change", (int)addCompMatches);   // Played a non-arbitrated competition match
                ws.AddParameter("@C13_change", (int)addCompNoShows);   // Did not show up for a competition match
                ws.AddParameter("@Hash_Bucket", (short) ws.Partition);
                
                ws.ExecuteNonQuery();
                
                hr = (uint)ws.GetIntParameter("@ret");            
            }            
            return hr;    
        }        
    }

    //
    //  TrustToggle: Wraps the guts of turning on/off SG auth checking by config file.
    // 
    public class TrustToggle
    {
        private static bool m_GotSetting = false;

        // static toggle saying whether to ignore auth data from SG
        // default to TRUE
        //     
        private static bool m_QueryTrustUpdates = true;

        // static constructor to get config settings for XBOS.
        private static void GetTrustToggle()
        {
            string r = Config.GetSetting(Setting.querylib_trustUpdates);            
            if(r != null) 
            {
                r = r.ToUpper();
                if( r == "FALSE" || r == "NO" || r == "OFF" ) 
                {
                  Xom.NtEvent( XEvent.Id.MC_QUERY_TRUST_IS_OFF,
                        "QUERY SERVICE TRUST INTEGRATION HAS BEEN TURNED OFF. This should NEVER happen in production." );

                    m_QueryTrustUpdates = false;
                } 
            }
            m_GotSetting = true;
        }

        public static bool On 
        {
            get 
            { 
                if(m_GotSetting == false) 
                {
                    GetTrustToggle(); 
                }
                return (m_QueryTrustUpdates == true);
            }
        }

        public static bool Off 
        {
            get 
            { 
                if(m_GotSetting == false) 
                {
                    GetTrustToggle(); 
                }
                return (m_QueryTrustUpdates == false);
            }
        }
    
    }
    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\blacklist\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_common_blacklist_none_12.4.56.0_none_26c70f8b71a8a509
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_common_blacklist_no-public-key_12.4.56.0_x-ww_ace2ec9f
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=common_blacklist
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_common_blacklist_no-public-key_12.4.56.0_x-ww_ace2ec9f
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_common_blacklist_no-public-key_12.4.56.0_x-ww_ace2ec9f.manifest
XP_MANIFEST_PATH=manifests\x86_common_blacklist_no-public-key_12.4.56.0_x-ww_ace2ec9f.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_common_blacklist_no-public-key_12.4.56.0_x-ww_ace2ec9f.cat
XP_CATALOG_PATH=manifests\x86_common_blacklist_no-public-key_12.4.56.0_x-ww_ace2ec9f.cat
XP_PAYLOAD_PATH=x86_common_blacklist_no-public-key_12.4.56.0_x-ww_ace2ec9f
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=common_blacklist,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\blacklist\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_common_blacklist_none_12.4.56.0_none_26c70f8b71a8a509
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_common_blacklist_no-public-key_12.4.56.0_x-ww_ace2ec9f
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=common_blacklist
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_common_blacklist_no-public-key_12.4.56.0_x-ww_ace2ec9f
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_common_blacklist_no-public-key_12.4.56.0_x-ww_ace2ec9f.manifest
XP_MANIFEST_PATH=manifests\x86_common_blacklist_no-public-key_12.4.56.0_x-ww_ace2ec9f.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_common_blacklist_no-public-key_12.4.56.0_x-ww_ace2ec9f.cat
XP_CATALOG_PATH=manifests\x86_common_blacklist_no-public-key_12.4.56.0_x-ww_ace2ec9f.cat
XP_PAYLOAD_PATH=x86_common_blacklist_no-public-key_12.4.56.0_x-ww_ace2ec9f
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=common_blacklist,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\crypto\calclankey\CalcLanKey.cpp ===
//---------------------------------------------------------------------------------
//
//    Copyright (C) Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------------

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include "winsockx.h"
#include "xonlinep.h"
#include "xcrypt.h"
#include "cryptohelper.h"

#define XBEIMAGE_CERTIFICATE_KEY_LENGTH 16  // from xbox\private\inc\xbeimage.h
#define XBOX_KEY_LENGTH                 16  // from xbox\private\ntos\net\xn.h

BOOL ParseKey( LPCSTR pszKey, BYTE *pbKey )
{
    if( ( NULL == pszKey ) || ( NULL == pbKey ) || ( 32 != strlen( pszKey ) ) )
    {
        return( FALSE );
    }

    for( int i = 0; i < 4; i++ )
    {
        char szTemp[ 9 ] = { 0 };
        memcpy( szTemp, pszKey + ( i * 8 ), 8 );

        LPSTR pszNext;
        DWORD dwVal = strtoul( szTemp, &pszNext, 16 );
        DWORD dwVal2 = ( ( dwVal & 0x000000ff ) << 24 ) |
                       ( ( dwVal & 0x0000ff00 ) <<  8 ) |
                       ( ( dwVal & 0x00ff0000 ) >> 8 ) |
                       ( ( dwVal & 0xff000000 ) >> 24 );

        memcpy( pbKey + ( i * 4 ), &dwVal2, sizeof(DWORD) );
    }

    return( TRUE );
}

int __cdecl main(int argc, char* argv[])
{
    BYTE abXboxLANKey[ XBOX_KEY_LENGTH ];
    BYTE abCertLANKey[ XBOX_KEY_LENGTH ];

    if( ( 3 != argc ) ||
        !ParseKey( argv[1], abXboxLANKey ) ||
        !ParseKey( argv[2], abCertLANKey ) )
    {
        printf( "Usage: CalcLANKey <Xbox LAN key as 32 hex chars> <Title cert LAN key as 32 hex chars>\n" );
        // devkit = 2b69b13755a7062a975af75453113840 00000000000000000000000000000000
        return( 1 );
    }

    BYTE abCert[1 + XBEIMAGE_CERTIFICATE_KEY_LENGTH];
    BYTE abHash[XC_SERVICE_DIGEST_SIZE * 2];

    memcpy( &abCert[1], abCertLANKey, XBEIMAGE_CERTIFICATE_KEY_LENGTH );

    abCert[0] = 0;
    XcHMAC( abXboxLANKey, XBOX_KEY_LENGTH, abCert, sizeof(abCert), NULL, 0, &abHash[0] );

    BYTE abKeyShaLan[ 16 ];
    memcpy( abKeyShaLan, &abHash[0], sizeof(abKeyShaLan) );

    printf( "BYTE abKeyShaLan[ 16 ] =\n{\n    " );

    for( int i = 0; i < 16; i++ )
    {
        printf( "0x%02X%s", abKeyShaLan[ i ], ( i < 15 ) ? ", " : "" );

        if( i == 7 )
        {
            printf( "\n    " );
        }
    }

    printf( "\n};\n" );
    return( 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\crypto\helperlib\stdafx.h ===
#pragma once


#include "winsock2.h"
#include <wincrypt.h>
#include <userenv.h>
#include <stdio.h>
#include <assert.h>
#include <crypto/modes.h>
#include "wsockntp.h"
#include "xonlinep.h"
#include "cryptoHelper.h"
#include "xmgmt.h"

// Define test-keys in BSAFE format
#define XETESTKEYS_BSAFE
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\crypto\helperlib\CryptoHelper.cpp ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved
//
#include "stdafx.h"
#include "xetestkeys.h"

#define RSA_PUB_MAGIC  0x31415352
#define RSA_PRIV_MAGIC 0x32415352
#define RSA_2048_BITS  0x800

struct KEY_HEADER
{
    BLOBHEADER blob;
    RSAPUBKEY  rsa;
};

#ifndef QWORD
#define QWORD ULONGLONG
#endif

#define BYTESWAP32(x) \
    ((((x)&0x000000FF)<<24)| \
     (((x)&0x0000FF00)<<8) | \
     (((x)&0x00FF0000)>>8) | \
     (((x)&0xFF000000)>>24))

#define BYTESWAP64(x) \
    (((QWORD)BYTESWAP32(x >> 32)) | \
     ((QWORD)BYTESWAP32(x & 0x00000000FFFFFFFF) << 32))

#ifndef ARRAY_SIZE
#define ARRAY_SIZE(x) (sizeof(x)/sizeof(x[0]))
#endif


//////////////////////////////////////////////////////////////////////////////
//
// Yet another copy of our SHA1-HMAC implementation
//
void
XcHMAC(
    IN PBYTE pbKeyMaterial,
    IN ULONG cbKeyMaterial,
    IN PBYTE pbData,
    IN ULONG cbData,
    IN PBYTE pbData2,
    IN ULONG cbData2,
    OUT PBYTE HmacData // length must be A_SHA_DIGEST_LEN
    )
{
#define HMAC_K_PADSIZE              64
#define HMAC_KI_XOR_FACTOR            ((DWORD)0x36363636)
#define HMAC_KO_XOR_FACTOR            ((DWORD)0x5C5C5C5C)
    BYTE Kipad[HMAC_K_PADSIZE];
    BYTE Kopad[HMAC_K_PADSIZE];
    BYTE HMACTmp[HMAC_K_PADSIZE+A_SHA_DIGEST_LEN];
    ULONG dwBlock;
    A_SHA_CTX shaHash;

    // truncate
    if (cbKeyMaterial > HMAC_K_PADSIZE)
        cbKeyMaterial = HMAC_K_PADSIZE;

    RtlZeroMemory(Kipad, HMAC_K_PADSIZE);
    RtlCopyMemory(Kipad, pbKeyMaterial, cbKeyMaterial);

    RtlZeroMemory(Kopad, HMAC_K_PADSIZE);
    RtlCopyMemory(Kopad, pbKeyMaterial, cbKeyMaterial);

    //
    // Kipad, Kopad are padded sMacKey. Now XOR across...
    //
    for(dwBlock=0; dwBlock<HMAC_K_PADSIZE/sizeof(DWORD); dwBlock++)
    {
        ((DWORD*)Kipad)[dwBlock] ^= HMAC_KI_XOR_FACTOR;
        ((DWORD*)Kopad)[dwBlock] ^= HMAC_KO_XOR_FACTOR;
    }

    //
    // prepend Kipad to data, Hash to get H1
    //

    A_SHAInit(&shaHash);
    A_SHAUpdate(&shaHash, Kipad, HMAC_K_PADSIZE);
    if (cbData != 0)
    {
        A_SHAUpdate(&shaHash, pbData, cbData);
    }
    if (cbData2 != 0)
    {
        A_SHAUpdate(&shaHash, pbData2, cbData2);
    }

    // Finish off the hash
    A_SHAFinal(&shaHash,HMACTmp+HMAC_K_PADSIZE);

    // prepend Kopad to H1, hash to get HMAC
    RtlCopyMemory(HMACTmp, Kopad, HMAC_K_PADSIZE);

    // final hash: output value into passed-in buffer
    A_SHAInit(&shaHash);
    A_SHAUpdate(&shaHash,HMACTmp, sizeof(HMACTmp));
    A_SHAFinal(&shaHash,HmacData);
}


//////////////////////////////////////////////////////////////////////////////
BOOL GenPPAforDB(
    IN LPCSTR pszName,
    IN const XOCryptoKeyStruct *pKey,
    OUT XOCryptoSPPAStruct *pSPPA1,
    OUT XOCryptoPPAStruct *pPPA2
    )
{
    if( ( NULL == pszName ) || ( NULL == pKey ) || ( NULL == pSPPA1 ) || ( NULL == pPPA2 ) )
    {
        return( FALSE );
    }

    assert( sizeof(XOCryptoSPPAStruct) == XONLINE_PPA_HASH_SIZE );
    assert( sizeof(XOCryptoPPAStruct) == XONLINE_PPA2_STORAGE_LENGTH );

    //
    // Convert to standard (15-char max) upper case name
    //
    char szName[ XONLINE_GAMERTAG_SIZE ];
    memset( szName, 0, sizeof( szName ) );
    for( int i = 0; i < sizeof( szName ); i++ )
    {
        if (pszName[ i ] == '\0')
        {
            break;
        }
        szName[ i ] = (CHAR)toupper( pszName[ i ] );
    }

    //
    // Calculate and return SHA( HMAC key( Name ) ) as pSPPA
    //
    BYTE abPPA1[ A_SHA_DIGEST_LEN ];

    XcHMAC(
        (BYTE *) pKey->abKey,
        sizeof( pKey->abKey ),
        (BYTE *) szName,
        sizeof( szName ),
        NULL,
        0,
        abPPA1 );

    A_SHA_CTX shaCtx;

    A_SHAInit( &shaCtx );
    A_SHAUpdate( &shaCtx, abPPA1, sizeof( abPPA1 ) );
    A_SHAFinal( &shaCtx, pSPPA1->abSPPA );

    //
    // Calculate and return first 8 bytes of HMAC key( Name,Name ) as pPPA2
    //
    BYTE abPPA2[ A_SHA_DIGEST_LEN ];

    XcHMAC(
        (BYTE *) pKey->abKey,
        sizeof( pKey->abKey ),
        (BYTE *) szName,
        sizeof( szName ),
        (BYTE *) szName,
        sizeof( szName ),
        abPPA2 );

    memcpy( pPPA2->abPPA, abPPA2, sizeof( pPPA2->abPPA ) );

    return( TRUE );
}


static volatile HCRYPTPROV g_hRandCryptProv = NULL;

BOOL XOCryptGenRandom( BYTE* pbData, DWORD cbData )
{
    if (g_hRandCryptProv == NULL)
    {
        HCRYPTPROV hCrypt = NULL;
        if(!CryptAcquireContext(
            &hCrypt,
            NULL,
            NULL,
            PROV_RSA_FULL,
            CRYPT_VERIFYCONTEXT))
        {
            if(!CryptAcquireContext(
                &hCrypt,
                NULL,
                NULL,
                PROV_RSA_FULL,
                CRYPT_VERIFYCONTEXT  | CRYPT_NEWKEYSET))
            {
                return FALSE;
            }
        }

        // Set global one if no one else did, otherwise release our local copy.
        if (NULL != InterlockedCompareExchangePointer ((PVOID*)&g_hRandCryptProv, (PVOID)hCrypt, NULL))
        {
            CryptReleaseContext(hCrypt, 0);
        }
    }

    return CryptGenRandom( g_hRandCryptProv, cbData, pbData);
}

HRESULT EncryptWithMasterKey(
    IN DWORD dwMasterKeyVersion,
    IN LPBYTE pKey,
    IN DWORD cbKey,
    IN OUT XOCryptoMasterKeyEncryptedStruct* pRawKey
    )
{
    HRESULT hr;
    HCRYPTPROV hProv = NULL;
    HCRYPTKEY hKey = NULL;
    WCHAR awszContainer[256];
    BOOL bDidCreateKeyset = FALSE;

    _snwprintf( awszContainer, sizeof(awszContainer)/sizeof(WCHAR), MASTER_KEY_CONTAINER_NAME, dwMasterKeyVersion );
    awszContainer[ (sizeof(awszContainer)/sizeof(awszContainer[0])) - 1 ] = L'\0';

    if (!CryptAcquireContext(
          &hProv,
          awszContainer,
          MS_ENHANCED_PROV,
          PROV_RSA_FULL,
          CRYPT_ACQUIRE_CONTEXT_FLAGS))
    {
        hr = GetLastError();
        if(hr == NTE_BAD_KEYSET)
        {
            if(!CryptAcquireContext(
                        &hProv,
                        awszContainer,
                        MS_ENHANCED_PROV,
                        PROV_RSA_FULL,
                        CRYPT_ACQUIRE_CONTEXT_FLAGS | CRYPT_NEWKEYSET))
                hr = GetLastError();
            else
            {
                hr = S_OK;
                bDidCreateKeyset = TRUE;
            }
        }

        if(hr != S_OK)
            goto Ret;
    }

    assert( hProv != NULL );

    if(!CryptImportKey(
       hProv,
       pKey,
       cbKey,
       NULL,
       0,
       &hKey))
    {
        hr = GetLastError();
        goto Ret;
    }

    assert( hKey != NULL );

    // create a copy of the key we are encrypting,  so we don't
    // overwrite they key as we encrypt it one block at a  time

    BYTE srcBuffer[SERVICE_KEY_SIZE];
    assert(pRawKey != NULL && pRawKey->dwKeyLen <= sizeof(srcBuffer));
    memcpy(srcBuffer, pRawKey->abKey, pRawKey->dwKeyLen);

    // spin through the copy of the key and encrypt  back  into
    // the user's original buffer.  do it  one  block at a time.

    DWORD srcRemaining = pRawKey->dwKeyLen;
    DWORD srcOffset = 0, destOffset = 0;

    while (srcRemaining > 0)
    {
        BOOL  bFinal = srcRemaining <= MASTER_KEY_ENCRYPT_SIZE;
        DWORD dwBlockSize = bFinal ? srcRemaining : MASTER_KEY_ENCRYPT_SIZE;

        // copy the next block of bytes from the key  into  the
        // users buffer, and then encrypt that block  in  place

        memcpy(&pRawKey->abKey[destOffset], &srcBuffer[srcOffset], dwBlockSize);
        
        if (! CryptEncrypt(hKey, NULL, bFinal, 0, &pRawKey->abKey[destOffset], &dwBlockSize, sizeof(pRawKey->abKey) - destOffset))
        {
            hr = GetLastError();
            goto Ret;
        }

        // move our "pointers" so we can encrypt the next block

        srcRemaining  -= srcRemaining > MASTER_KEY_ENCRYPT_SIZE ? MASTER_KEY_ENCRYPT_SIZE : srcRemaining;
        srcOffset     += MASTER_KEY_ENCRYPT_SIZE;
        destOffset    += dwBlockSize;
    }

    pRawKey->dwKeyLen = destOffset;
    hr = S_OK;

Ret:
    if (hKey)
        CryptDestroyKey(hKey);

    if (hProv)
        CryptReleaseContext(hProv, 0);

    //  if we created a new keyset above, delete it now...it serves no purpose
    if (bDidCreateKeyset)
    {
        CryptAcquireContext(
                &hProv,
                awszContainer,
                MS_ENHANCED_PROV,
                PROV_RSA_FULL,
                CRYPT_ACQUIRE_CONTEXT_FLAGS | CRYPT_DELETEKEYSET);
    }

    return hr;
}

HRESULT DecryptWithMasterKey(
    IN DWORD dwMasterKeyVersion,
    IN OUT XOCryptoMasterKeyEncryptedStruct* pRawKey
    )
{
    HRESULT hr;
    HCRYPTPROV hProv = NULL;
    HCRYPTKEY hKey = NULL;
    WCHAR awszContainer[256];
#if DBG
    WCHAR wszDebug[256];
#endif

    _snwprintf( awszContainer, sizeof(awszContainer)/sizeof(WCHAR), MASTER_KEY_CONTAINER_NAME, dwMasterKeyVersion );
    awszContainer[ (sizeof(awszContainer)/sizeof(awszContainer[0])) - 1 ] = L'\0';

#ifdef LOAD_USER_PROFILE
    HANDLE hToken = NULL;
    PROFILEINFO ProfileInfo;
    WCHAR wszUserName[256];
    DWORD dwSize;

    dwSize = 256;
    if (!GetUserName(wszUserName, &dwSize))
    {
        hr = GetLastError();
#if DBG
        swprintf(wszDebug, L"DecryptWithMasterKey: GetUserName failed with %X\n", hr);
        OutputDebugString( wszDebug );
#endif
        hr = HRESULT_FROM_WIN32(hr);
        goto Ret;
    }
#if DBG
    swprintf(wszDebug, L"DecryptWithMasterKey: GetUserName got %s\n", wszUserName);
    OutputDebugString( wszDebug );
#endif

    memset( &ProfileInfo, 0, sizeof(ProfileInfo) );
    ProfileInfo.dwSize = sizeof(PROFILEINFO);
    ProfileInfo.dwFlags = PI_NOUI;
    ProfileInfo.lpUserName = wszUserName;

    if (!OpenThreadToken(GetCurrentThread(), TOKEN_ALL_ACCESS, TRUE, &hToken))
    {
        hr = GetLastError();
        if (hr == ERROR_NO_TOKEN)
        {
#if DBG
            swprintf(wszDebug, L"DecryptWithMasterKey: Using OpenProcessToken instead of OpenThreadToken\n");
            OutputDebugString( wszDebug );
#endif
            if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ALL_ACCESS, &hToken))
            {
                hr = GetLastError();
#if DBG
                swprintf(wszDebug, L"DecryptWithMasterKey: OpenProcessToken failed with %X\n", hr);
                OutputDebugString( wszDebug );
#endif
                hr = HRESULT_FROM_WIN32(hr);
                goto Ret;
            }
        }
        else
        {
#if DBG
            swprintf(wszDebug, L"DecryptWithMasterKey: OpenThreadToken failed with %X\n", hr);
            OutputDebugString( wszDebug );
#endif
            hr = HRESULT_FROM_WIN32(hr);
            goto Ret;
        }
    }
    else
    {
#if DBG
        swprintf(wszDebug, L"DecryptWithMasterKey: Using OpenThreadToken\n");
        OutputDebugString( wszDebug );
#endif
    }

    if (!LoadUserProfile( hToken, &ProfileInfo ))
    {
        hr = GetLastError();
#if DBG
        swprintf(wszDebug, L"DecryptWithMasterKey: LoadUserProfile failed with %X\n", hr);
        OutputDebugString( wszDebug );
#endif
        hr = HRESULT_FROM_WIN32(hr);
        goto Ret;
    }
#endif

    if (!CryptAcquireContext(
          &hProv,
          awszContainer,
          MS_ENHANCED_PROV,
          PROV_RSA_FULL,
          CRYPT_ACQUIRE_CONTEXT_FLAGS))
    {
        hr = GetLastError();
#if DBG
        swprintf(wszDebug, L"DecryptWithMasterKey: CryptAcquireContext failed with %X\n", hr);
        OutputDebugString( wszDebug );
#endif
        hr = HRESULT_FROM_WIN32(hr);
        goto Ret;
    }

    assert( hProv != NULL );

    if(!CryptGetUserKey(
       hProv,
       AT_KEYEXCHANGE,
       &hKey))
    {
        hr = GetLastError();
#if DBG
        swprintf(wszDebug, L"DecryptWithMasterKey: CryptGetUserKey failed with %X\n", hr);
        OutputDebugString( wszDebug );
#endif
        hr = HRESULT_FROM_WIN32(hr);
        goto Ret;
    }

    assert( hKey != NULL );
    assert( pRawKey->dwKeyLen != 0 );


    // create a copy of the data we are decrypting, so we don't
    // overwrite they key as we decrypt it one block at a  time

    BYTE srcBuffer[SERVICE_KEY_SIZE];
    assert(pRawKey != NULL && pRawKey->dwKeyLen <= sizeof(srcBuffer));
    memcpy(srcBuffer, pRawKey->abKey, pRawKey->dwKeyLen);

    // spin through the copy of the key and decrypt  back  into
    // the user's original buffer.  do it  one  block at a time.

    DWORD srcRemaining = pRawKey->dwKeyLen;
    DWORD srcOffset = 0, destOffset = 0;

    while (srcRemaining > 0)
    {
        BOOL  bFinal = srcRemaining <= MASTER_KEY_DECRYPT_SIZE;
        DWORD dwBlockSize = MASTER_KEY_DECRYPT_SIZE;

        // copy the next block of bytes from the key  into  the
        // users buffer, and then encrypt that block  in  place

        memcpy(&pRawKey->abKey[destOffset], &srcBuffer[srcOffset], dwBlockSize);
        
        if (! CryptDecrypt(hKey, NULL, bFinal, 0, &pRawKey->abKey[destOffset], &dwBlockSize))
        {
            hr = GetLastError();
#if DBG
            swprintf(wszDebug, L"DecryptWithMasterKey: CryptDecrypt failed with %X\n", hr);
            OutputDebugString( wszDebug );
#endif
            hr = HRESULT_FROM_WIN32(hr);
            goto Ret;
        }

        // move our "pointers" so we can decrypt the next block

        srcRemaining  -= srcRemaining > MASTER_KEY_DECRYPT_SIZE ? MASTER_KEY_DECRYPT_SIZE : srcRemaining;
        srcOffset     += MASTER_KEY_DECRYPT_SIZE;
        destOffset    += dwBlockSize;
    }

    pRawKey->dwKeyLen = destOffset;
    OutputDebugString( L"DecryptWithMasterKey finished successfully\n" );

    hr = S_OK;

Ret:
    if (hKey)
    {
        CryptDestroyKey(hKey);
    }

    if (hProv)
    {
        CryptReleaseContext(hProv, 0);
    }

#ifdef LOAD_USER_PROFILE
    if (ProfileInfo.hProfile)
    {
        UnloadUserProfile( hToken, ProfileInfo.hProfile );
    }

    if (hToken)
    {
        CloseHandle( hToken );
    }
#endif

    return hr;
}

XOCryptoKeyEncryptionHelper::XOCryptoKeyEncryptionHelper( XOCryptoKeyEncryptionKey* pKey )
{
    aeskey( &m_keyTable, pKey->abKey, AES_ROUNDS_256 );
    RtlZeroMemory( pKey->abKey, sizeof(pKey->abKey) );
}

BOOL XOCryptoKeyEncryptionHelper::GenerateNewKey(
    OUT XOCryptoIVStruct* pIV,
    OUT XOCryptoKeyStruct* pEncryptedKey,
    OUT XOCryptoKeyStruct* pRawKey
    )
{
    DWORD i;

    assert( ONLINE_KEY_LEN == AES_BLOCKLEN );

    if (!XOCryptGenRandom( pIV->abIV, sizeof(pIV->abIV) ) )
    {
        return FALSE;
    }

    if (!XOCryptGenRandom( pRawKey->abKey, sizeof(pRawKey->abKey) ) )
    {
        return FALSE;
    }

    for (i=0; i<sizeof(XOCryptoKeyStruct); ++i)
    {
        pEncryptedKey->abKey[i] = pRawKey->abKey[i] ^ pIV->abIV[i];
    }

    aes( pEncryptedKey->abKey, pEncryptedKey->abKey, &m_keyTable, ENCRYPT );

    //XOCryptoIVStruct fb;
    //RtlCopyMemory( fb.abIV, pIV->abIV, sizeof(fb.abIV));
    //CBC(aes, AES_BLOCKLEN, pEncryptedKey->abKey, pRawKey->abKey, &m_keyTable, ENCRYPT, fb.abIV);

    return TRUE;
}

void XOCryptoKeyEncryptionHelper::DecryptKey(
    IN XOCryptoIVStruct* pIV,
    IN XOCryptoKeyStruct* pEncryptedKey,
    OUT XOCryptoKeyStruct* pRawKey
    )
{
    DWORD i;

    assert( ONLINE_KEY_LEN == AES_BLOCKLEN );

    RtlCopyMemory( pRawKey->abKey, pEncryptedKey->abKey, sizeof(XOCryptoKeyStruct) );

    aes( pRawKey->abKey, pRawKey->abKey, &m_keyTable, DECRYPT );

    for (i=0; i<sizeof(XOCryptoKeyStruct); ++i)
    {
        pRawKey->abKey[i] ^= pIV->abIV[i];
    }

    //XOCryptoIVStruct fb;
    //RtlCopyMemory( fb.abIV, pIV->abIV, sizeof(fb.abIV));
    //CBC(aes, AES_BLOCKLEN, pRawKey->abKey, pEncryptedKey->abKey, &m_keyTable, DECRYPT, fb.abIV);
}

void XOCryptoKeyEncryptionHelper::Decrypt(
    IN  XOCryptoIVStruct*   pIV,
    IN  LPBYTE              pEncrypted,
    IN  ULONG               ulLen,
    OUT LPBYTE              pRaw
    )
{
    XOCryptoIVStruct fb;

    assert( (ulLen % AES_BLOCKLEN) == 0 );

    RtlCopyMemory( fb.abIV, pIV->abIV, sizeof(fb.abIV));

    for(ULONG ul = 0; ul < ulLen; ul += AES_BLOCKLEN)
    {
        CBC(aes, AES_BLOCKLEN, pRaw + ul, pEncrypted + ul, &m_keyTable, DECRYPT, fb.abIV);
    }
}

BOOL XOCryptoKeyEncryptionHelper::EncryptKey(
    IN  XOCryptoKeyStruct* pRawKey,
    OUT XOCryptoIVStruct* pIV,
    OUT XOCryptoKeyStruct* pEncryptedKey
    )
{
    DWORD i;

    assert( ONLINE_KEY_LEN == AES_BLOCKLEN );

    if (!XOCryptGenRandom( pIV->abIV, sizeof(pIV->abIV) ) )
    {
        return FALSE;
    }

    for (i=0; i<sizeof(XOCryptoKeyStruct); ++i)
    {
        pEncryptedKey->abKey[i] = pRawKey->abKey[i] ^ pIV->abIV[i];
    }

    aes( pEncryptedKey->abKey, pEncryptedKey->abKey, &m_keyTable, ENCRYPT );

    //XOCryptoIVStruct fb;
    //RtlCopyMemory( fb.abIV, pIV->abIV, sizeof(fb.abIV));
    //CBC(aes, AES_BLOCKLEN, pEncryptedKey->abKey, pRawKey->abKey, &m_keyTable, ENCRYPT, fb.abIV);

    return TRUE;
}

BOOL XOCryptoKeyEncryptionHelper::Encrypt(
    IN  LPBYTE pRaw,
    IN  ULONG  ulLen,
    OUT XOCryptoIVStruct* pIV,
    OUT LPBYTE pEncrypted
    )
{
    assert(pIV);

    // Generate a random IV
    if (!XOCryptGenRandom( pIV->abIV, sizeof(pIV->abIV) ) )
    {
        return FALSE;
    }
    
    EncryptWithIv(pRaw, ulLen, pIV, pEncrypted);

    return TRUE;
}

void XOCryptoKeyEncryptionHelper::EncryptWithIv(
    IN  LPBYTE pRaw,
    IN  ULONG  ulLen,
    IN  XOCryptoIVStruct* pIV,
    OUT LPBYTE pEncrypted
    )
{
    XOCryptoIVStruct fb;

    assert(pIV);
    assert( (ulLen % AES_BLOCKLEN) == 0 );

    RtlCopyMemory( fb.abIV, pIV->abIV, sizeof(fb.abIV));

    for(ULONG ul = 0; ul < ulLen; ul += AES_BLOCKLEN)
    {
        CBC(aes, AES_BLOCKLEN, pEncrypted + ul, pRaw + ul, &m_keyTable, ENCRYPT, fb.abIV);
    }
}

bool CXoCryptoCspPk::InstallKeyFromBsafeFormat(
    LPCWSTR pszContainer,
    LPCWSTR pszProvider,
    bool fUseMachineStore,
    KeyPurpose keyPurpose,
    const BYTE* pbBsafeKey,
    DWORD cbBsafeKey,
    bool fReplace
)
{
    bool fRet = false;
    HCRYPTPROV hProv = NULL;
    HCRYPTKEY hKey = NULL;
    BYTE abCspImport[2048];
    DWORD cbCspImport;

    cbCspImport = sizeof(abCspImport);
    if(!ConvertKeyBsafeToCspImport(pbBsafeKey, keyPurpose, abCspImport, &cbCspImport))
        goto lDone;
    
    if(!CreateNewContainer(pszContainer,pszProvider,fUseMachineStore,fReplace,&hProv))
        goto lDone;

    if(!CryptImportKey(hProv, abCspImport, cbCspImport, NULL, 0, &hKey))
        goto lDone;
    
    fRet = true;

lDone:

    if(hKey != NULL)
        ::CryptDestroyKey(hKey);

    if(hProv != NULL)
        ::CryptReleaseContext(hProv, 0);
    
    return fRet;
}

bool CXoCryptoCspPk::InstallTestKeys(bool fUseMachineStore)
{
    if(!CXoCryptoCspPk::InstallKeyFromBsafeFormat(TEST_KEY_CONTAINER_XMACS_ENCRYPT,
        MS_ENHANCED_PROV,fUseMachineStore,KeyPurposeEncrypt,g_XenonXmacsBsafePrv2048,
        sizeof(g_XenonXmacsBsafePrv2048), true))
    {
        return false;
    }

    return true;
}

bool CXoCryptoCspPk::CreateNewContainer(
    LPCWSTR pszContainer,
    LPCWSTR pszProvider,
    bool fUseMachineStore,
    bool fReplace,
    HCRYPTPROV* phProv
)
{
    DWORD dwStore = fUseMachineStore ? CRYPT_MACHINE_KEYSET : 0;
    
    if(::CryptAcquireContextW(phProv, pszContainer, pszProvider, PROV_RSA_FULL, dwStore | CRYPT_SILENT | CRYPT_NEWKEYSET))
        return true;

    if(GetLastError() != NTE_EXISTS)
        return false;

    if(!fReplace)
        return false;

    if(!::CryptAcquireContextW(phProv, pszContainer, pszProvider, PROV_RSA_FULL, dwStore | CRYPT_SILENT | CRYPT_DELETEKEYSET))
        return false;

    if(!::CryptAcquireContextW(phProv, pszContainer, pszProvider, PROV_RSA_FULL, dwStore | CRYPT_SILENT | CRYPT_NEWKEYSET))
        return false;

    return true;
}

CXoCryptoCspPk::CXoCryptoCspPk()
{
    _hProv = NULL;
    _hKey  = NULL;
}

CXoCryptoCspPk::~CXoCryptoCspPk()
{
    Reset();
}

void CXoCryptoCspPk::Reset()
{
    if(_hKey != NULL)
    {
        ::CryptDestroyKey(_hKey);
        _hKey = NULL;
    }
    
    if(_hProv != NULL)
    {
        ::CryptReleaseContext(_hProv, 0);
        _hProv = NULL;
    }
}

CXoCryptoCspPk::OpenContainerStatus CXoCryptoCspPk::OpenContainer(
    LPCWSTR pszContainer,
    LPCWSTR pszProvider,
    bool fUseMachineStore
)
{
    DWORD dwStore = fUseMachineStore ? CRYPT_MACHINE_KEYSET : 0;

    Reset();
    
    if(!::CryptAcquireContextW(&_hProv, pszContainer, pszProvider, PROV_RSA_FULL, dwStore | CRYPT_SILENT))
    {
        DWORD err = ::GetLastError();
        
        if(err == NTE_BAD_KEYSET)
            return OpenContainerNotFound;
        else
            return OpenContainerOtherError;
    }

    if(!::CryptGetUserKey(_hProv, AT_SIGNATURE, &_hKey) &&
       !::CryptGetUserKey(_hProv, AT_KEYEXCHANGE, &_hKey))
    {
        return OpenContainerOtherError;
    }

    return OpenContainerSuccess;
}

bool CXoCryptoCspPk::OpenPublicKey(
    BYTE* pbCspImport,
    DWORD cbCspImport
)
{
    Reset();
    
    if(!::CryptAcquireContextW(&_hProv,NULL,MS_ENHANCED_PROV,PROV_RSA_FULL,CRYPT_SILENT | CRYPT_VERIFYCONTEXT))
        return false;

    if(!CryptImportKey(_hProv, pbCspImport, cbCspImport, NULL, 0, &_hKey))
        return false;

    return true;
}

bool CXoCryptoCspPk::OpenBsafePublicKey(
    IN const BYTE* pBsafeKey,
    IN KeyPurpose keyPurpose
)
{
    BYTE abCspImport[4000];
    DWORD cbCspImport = sizeof(abCspImport);

    Reset();

    if(!ConvertKeyPubBsafeToCspImport(pBsafeKey, keyPurpose, abCspImport, &cbCspImport))
        return false;

    if(!OpenPublicKey(abCspImport, cbCspImport))
        return false;

    return true;
}

bool CXoCryptoCspPk::OpenConsolePublicKey(
    BYTE* pbKey,
    DWORD cbKey,
    KeyPurpose keyPurpose
)
{
    BYTE abCspImport[2048];
    DWORD cbCspImport;
    
    Reset();
    
    if(!ConvertConsoleKeyToCspImport(pbKey, cbKey, keyPurpose, abCspImport, &cbCspImport))
        return false;

    if(!::CryptAcquireContextW(&_hProv,NULL,MS_ENHANCED_PROV,PROV_RSA_FULL,CRYPT_SILENT | CRYPT_VERIFYCONTEXT))
        return false;

    if(!CryptImportKey(_hProv, abCspImport, cbCspImport, NULL, 0, &_hKey))
        return false;

    return true;
}

// @@@ dcaiafa: remove once it's unreferenced
bool CXoCryptoCspPk::OpenConsolePublicKeyOld(
    BYTE* pbKey,
    DWORD cbKey,
    KeyPurpose keyPurpose
)
{
    BYTE abCspImport[2048];
    DWORD cbCspImport;
    
    Reset();
    
    if(!ConvertConsoleKeyToCspImportOld(pbKey, cbKey, keyPurpose, abCspImport, &cbCspImport))
        return false;

    if(!::CryptAcquireContextW(&_hProv,NULL,MS_ENHANCED_PROV,PROV_RSA_FULL,CRYPT_SILENT | CRYPT_VERIFYCONTEXT))
        return false;

    if(!CryptImportKey(_hProv, abCspImport, cbCspImport, NULL, 0, &_hKey))
        return false;

    return true;
}


bool CXoCryptoCspPk::ExportKey(
    BYTE* pbCspExport,
    IN OUT DWORD* pdwCspExport
)
{
    bool fRet = false;
    HCRYPTKEY hKey = 0;

    if(!_hProv)
        return false;
    
    if(!CryptGetUserKey(_hProv, AT_SIGNATURE, &hKey))
    {
        if(!CryptGetUserKey(_hProv, AT_KEYEXCHANGE, &hKey))
        {
            goto lDone;
        }
    }
    
    if(!CryptExportKey(hKey, NULL, PUBLICKEYBLOB, 0, pbCspExport, pdwCspExport))
        goto lDone;

    fRet = true;

lDone:

    if(hKey != 0)
        ::CryptDestroyKey(hKey);

    return fRet;
}

bool CXoCryptoCspPk::Encrypt(
    IN OUT BYTE* pbMsg,
    IN OUT DWORD* pcbMsg,
    IN DWORD cbBuffer
)
{
    if(!_hKey)
        return false;
    
    if(!::CryptEncrypt(_hKey, NULL, TRUE, CRYPT_OAEP, pbMsg, pcbMsg, cbBuffer))
        return false;

    return true;
}

bool CXoCryptoCspPk::Decrypt(
    IN BYTE* pbMsg,
    IN OUT DWORD* pcbMsg
)
{
    if(!_hKey)
        return false;
    
    if(!::CryptDecrypt(_hKey, NULL, TRUE, CRYPT_OAEP, pbMsg, pcbMsg))
        return false;

    return true;
}

bool CXoCryptoCspPk::Sign(
    IN const BYTE* pbSha1,
    DWORD cbSha1,
    OUT BYTE* pbSignature,
    IN OUT DWORD* pcbSignature
)
{
    bool fRet = false;
    HCRYPTHASH hHash = 0;

    if(!_hProv)
        return false;
    
    if(cbSha1 != A_SHA_DIGEST_LEN)
        goto lDone;

    if(!CryptCreateHash(_hProv, CALG_SHA1, NULL, 0, &hHash))
        goto lDone;

    if(!CryptSetHashParam(hHash, HP_HASHVAL, pbSha1, 0))
        goto lDone;

    if(!CryptSignHashA(hHash, AT_SIGNATURE, NULL, 0, pbSignature, pcbSignature))
    {
        printf("Error = %u\n", GetLastError());
        goto lDone;
    }

    fRet = true;

lDone:

    if(hHash != 0)
        CryptDestroyHash(hHash);

    return fRet;
}

bool CXoCryptoCspPk::VerifySignature(
    IN const BYTE* pbSha1,
    IN DWORD cbSha1,
    IN BYTE* pbSignature,
    IN DWORD cbSignature,
    IN BOOL  fNoHashOid
)
{
    bool fRet = false;
    HCRYPTHASH hHash = 0;
    
    if(!_hProv || !_hKey)
        return false;
    
    if(cbSha1 != A_SHA_DIGEST_LEN)
        goto lDone;

    if(!CryptCreateHash(_hProv, CALG_SHA1, NULL, 0, &hHash))
        goto lDone;

    if(!CryptSetHashParam(hHash, HP_HASHVAL, pbSha1, 0))
        goto lDone;
    
    if(!CryptVerifySignatureA(hHash, pbSignature, cbSignature, _hKey, NULL, fNoHashOid ? CRYPT_NOHASHOID : 0))
        goto lDone;

    fRet = true;

lDone:

    if(hHash != 0)
        CryptDestroyHash(hHash);

    return fRet;
}

bool CXoCryptoCspPk::ConvertKeyBsafeToCspImport(
    IN const BYTE* pBsafeKey,
    KeyPurpose keyPurpose,
    OUT BYTE* pCspImport,
    IN OUT DWORD* pcbCspImport
)
{
    bool fRet = false;

    DWORD dwKeyType = *(UNALIGNED DWORD*)pBsafeKey;

    if(dwKeyType == RSA1)
    {
        return ConvertKeyPubBsafeToCspImport(pBsafeKey, keyPurpose, pCspImport,
            pcbCspImport);
    }
    else if(dwKeyType == RSA2)
    {
        return ConvertKeyPrvBsafeToCspImport(pBsafeKey, keyPurpose, pCspImport,
            pcbCspImport);
    }
    else
    {
        return false;
    }
}

bool CXoCryptoCspPk::ConvertKeyPubBsafeToCspImport(
    IN const BYTE* pBsafeKey,
    KeyPurpose keyPurpose,
    OUT BYTE* pCspImport,
    IN OUT DWORD* pcbCspImport
)
{
    LPBSAFE_PUB_KEY pPubKey = (LPBSAFE_PUB_KEY) pBsafeKey;
    DWORD cbMod = pPubKey->keylen - 8;
    DWORD cbHalfMod = cbMod / 2;
    UNALIGNED KEY_HEADER* pKeyHdr;
    BYTE* pb;

    //
    //  48758
    //  Overflow check - If keylen + headerlen > 0xffffffff then
    //  we can't possibly copy the entire key.  Fail.
    //

    if(cbMod > (cbMod + sizeof(KEY_HEADER)))
        return false;

    //
    //  If the buffer passed in is too small, fail.
    //

    if(*pcbCspImport < cbMod + sizeof(KEY_HEADER))
        return false;

    pKeyHdr = (UNALIGNED KEY_HEADER*) pCspImport;
    pKeyHdr->blob.bType = PUBLICKEYBLOB;   
    pKeyHdr->blob.bVersion = CUR_BLOB_VERSION;
    pKeyHdr->blob.reserved = 0;
    pKeyHdr->blob.aiKeyAlg = (keyPurpose == KeyPurposeSign ? CALG_RSA_SIGN 
                              : CALG_RSA_KEYX);
    
    pKeyHdr->rsa.magic = RSA_PUB_MAGIC; 
    pKeyHdr->rsa.bitlen = cbMod*8;
    pKeyHdr->rsa.pubexp = pPubKey->pubexp;
    
    pb = pCspImport + sizeof(KEY_HEADER);
    
    memcpy(pb, pPubKey + 1, cbMod);
    pb += cbMod;

    *pcbCspImport = (DWORD) (pb - pCspImport);
    
    return true;
}

bool CXoCryptoCspPk::ConvertKeyPrvBsafeToCspImport(
    IN const BYTE* pBsafeKey,
    KeyPurpose keyPurpose,
    OUT BYTE* pCspImport,
    IN OUT DWORD* pcbCspImport
)
{
    
    LPBSAFE_PRV_KEY pPrvKey = (LPBSAFE_PRV_KEY) pBsafeKey;
    BSAFE_KEY_PARTS keyparts;
    DWORD cbMod = pPrvKey->keylen - 8;
    DWORD cbHalfMod = cbMod / 2;
    UNALIGNED KEY_HEADER* pKeyHdr;
    BYTE* pb;

    if(!BSafeGetPrvKeyParts(pPrvKey, &keyparts))
        return false;
    
    //
    //  48759
    //  Check for integer overflow.  If keysize is too
    //  big, then a large enough buffer can't be supplied.  Fail.
    //

    if(cbMod > (0xffffffff - sizeof(KEY_HEADER))/5)
        return false;

    if(*pcbCspImport < cbMod * 5 + sizeof(KEY_HEADER))
        return false;

    pKeyHdr = (UNALIGNED KEY_HEADER*) pCspImport;
    pKeyHdr->blob.bType = PRIVATEKEYBLOB;   
    pKeyHdr->blob.bVersion = CUR_BLOB_VERSION;
    pKeyHdr->blob.reserved = 0;
    pKeyHdr->blob.aiKeyAlg = (keyPurpose == KeyPurposeSign ? CALG_RSA_SIGN 
                              : CALG_RSA_KEYX);
    
    pKeyHdr->rsa.magic = RSA_PRIV_MAGIC; 
    pKeyHdr->rsa.bitlen = cbMod*8;
    pKeyHdr->rsa.pubexp = pPrvKey->pubexp;
    
    pb = pCspImport + sizeof(KEY_HEADER);
    
    memcpy(pb, keyparts.modulus, cbMod);
    pb += cbMod;

    memcpy(pb, keyparts.prime1, cbHalfMod);
    pb += cbHalfMod;

    memcpy(pb, keyparts.prime2, cbHalfMod);
    pb += cbHalfMod;

    memcpy(pb, keyparts.exp1, cbHalfMod);
    pb += cbHalfMod;
    
    memcpy(pb, keyparts.exp2, cbHalfMod);
    pb += cbHalfMod;

    memcpy(pb, keyparts.coef, cbHalfMod);
    pb += cbHalfMod;

    memcpy(pb, keyparts.prvexp, cbMod);
    pb += cbMod;

    *pcbCspImport = (DWORD) (pb - pCspImport);

    return true;
}

// Copy a sequence of bytes between buffers and at the same time swap the bytes
// of the QWORDs 
void CXoCryptoCspPk::CopyAndByteSwap64(
    OUT BYTE*       pDest,
    IN const BYTE*  pSrc,
    IN DWORD        cb
    )
{
    UNALIGNED QWORD*        pqwd = (UNALIGNED QWORD*)pDest;
    const UNALIGNED QWORD*  pqws = (const UNALIGNED QWORD*)pSrc;
    DWORD                   cqw = cb / sizeof(QWORD);

    for(DWORD i=0; i < cqw; i++)
    {
        pqwd[i] = BYTESWAP64(pqws[i]);
    }
}

bool CXoCryptoCspPk::ConvertConsoleKeyToCspImport(
    IN const BYTE* pbConsoleKey,
    DWORD cbConsoleKey,
    KeyPurpose keyPurpose,
    OUT BYTE* pbCspImport,
    IN OUT DWORD* pcbCspImport
)
{
    CONSOLE_PUBLIC_KEY* pPubKey = (CONSOLE_PUBLIC_KEY*) pbConsoleKey;
    DWORD cbMod = 128;
    DWORD cbHalfMod = cbMod / 2;
    UNALIGNED KEY_HEADER* pKeyHdr;
    BYTE* pb;
    
    if(cbConsoleKey != sizeof(CONSOLE_PUBLIC_KEY))
        return false;

    pKeyHdr = (UNALIGNED KEY_HEADER*) pbCspImport;
    pKeyHdr->blob.bType = PUBLICKEYBLOB;   
    pKeyHdr->blob.bVersion = CUR_BLOB_VERSION;
    pKeyHdr->blob.reserved = 0;
    pKeyHdr->blob.aiKeyAlg = (keyPurpose == KeyPurposeSign ? CALG_RSA_SIGN 
                              : CALG_RSA_KEYX);
    
    pKeyHdr->rsa.magic = RSA_PUB_MAGIC; 
    pKeyHdr->rsa.bitlen = cbMod*8;
    pKeyHdr->rsa.pubexp = BYTESWAP32(*((UNALIGNED DWORD*)pPubKey->abPublicExp));
    
    pb = pbCspImport + sizeof(KEY_HEADER);
    
    CopyAndByteSwap64(pb, pPubKey->abModulus, cbMod);
    pb += cbMod;

    *pcbCspImport = (DWORD) (pb - pbCspImport);

    return true;
}

///////////////////////////////////////////////////////
// Function ConvertConsoleRSA2048KeyToCspImport
//
// Description
//    Converts a console's public RSA2048 bit to 
//    a format that can be consumed by windows native
//    crypto subsystem
//
bool CXoCryptoCspPk::ConvertConsoleRSA2048KeyToCspImport(
    IN const BYTE* pbConsoleKey,
    DWORD cbConsoleKey,
    KeyPurpose keyPurpose,
    OUT BYTE* pbCspImport,
    IN OUT DWORD* pcbCspImport
)
{

    //
    // Key structures from client base code
    // 
    struct XECRYPT_RSA{
        DWORD           cqw;                // Number of QWORD digits in modulus
        DWORD           dwPubExp;           // Public exponent
        QWORD           qwReserved;         // Reserved (was qwMI)
    };

    struct XECRYPT_RSAPUB_2048{
        struct XECRYPT_RSA     Rsa;         // Common header
        QWORD           aqwM[32];           // [BnQwNe] Modulus
    };


    //
    // Local params
    //
    XECRYPT_RSAPUB_2048* pPubKey = (XECRYPT_RSAPUB_2048*) pbConsoleKey;
    UNALIGNED KEY_HEADER* pKeyHdr= NULL;
    BYTE* pb                     = NULL;
    DWORD cbMod                  = 0;
    // Output buffer len requirement
    const DWORD cMinCspLen = 32*sizeof(QWORD) + sizeof(KEY_HEADER);
    
    //
    // Param validation
    // 
    if(!pbCspImport                                || 
       !pcbCspImport                               || 
       cbConsoleKey != sizeof(XECRYPT_RSAPUB_2048) ||
       *pcbCspImport < cMinCspLen)
    {
        return false;
    }

    //
    // Create RSA 2048 bit public key header
    // 
    pKeyHdr = (UNALIGNED KEY_HEADER*) pbCspImport;
    pKeyHdr->blob.bType = PUBLICKEYBLOB;   
    pKeyHdr->blob.bVersion = CUR_BLOB_VERSION;
    pKeyHdr->blob.reserved = 0;
    pKeyHdr->blob.aiKeyAlg = (keyPurpose == KeyPurposeSign ? CALG_RSA_SIGN 
                              : CALG_RSA_KEYX);
    
    pKeyHdr->rsa.magic = RSA_PUB_MAGIC; 
    pKeyHdr->rsa.bitlen = RSA_2048_BITS;
    pKeyHdr->rsa.pubexp = BYTESWAP32(pPubKey->Rsa.dwPubExp);
    
    // copy key content beyond header
    pb = pbCspImport + sizeof(KEY_HEADER);
    
    cbMod = BYTESWAP32(pPubKey->Rsa.cqw);
    if (cbMod > 32)
    {
        // bad calculation. Cannot be larger then aqwM length
        return false;
    }
    cbMod *=  sizeof(QWORD);
    CopyAndByteSwap64(pb, (PBYTE)(pPubKey->aqwM), cbMod);

    // calc output size
    pb += cbMod;
    *pcbCspImport = (DWORD) (pb - pbCspImport);

    return true;
}

// @@@ dcaiafa: remove once it's unreferenced
bool CXoCryptoCspPk::ConvertConsoleKeyToCspImportOld(
    IN const BYTE* pbConsoleKey,
    DWORD cbConsoleKey,
    KeyPurpose keyPurpose,
    OUT BYTE* pbCspImport,
    IN OUT DWORD* pcbCspImport
)
{
    CONSOLE_PUBLIC_KEY* pPubKey = (CONSOLE_PUBLIC_KEY*) pbConsoleKey;
    DWORD cbMod = 128;
    DWORD cbHalfMod = cbMod / 2;
    UNALIGNED KEY_HEADER* pKeyHdr;
    BYTE* pb;
    
    if(cbConsoleKey != sizeof(CONSOLE_PUBLIC_KEY))
        return false;

    pKeyHdr = (UNALIGNED KEY_HEADER*) pbCspImport;
    pKeyHdr->blob.bType = PUBLICKEYBLOB;   
    pKeyHdr->blob.bVersion = CUR_BLOB_VERSION;
    pKeyHdr->blob.reserved = 0;
    pKeyHdr->blob.aiKeyAlg = (keyPurpose == KeyPurposeSign ? CALG_RSA_SIGN 
                              : CALG_RSA_KEYX);
    
    pKeyHdr->rsa.magic = RSA_PUB_MAGIC; 
    pKeyHdr->rsa.bitlen = cbMod*8;
    pKeyHdr->rsa.pubexp = *((UNALIGNED DWORD*)pPubKey->abPublicExp);
    
    pb = pbCspImport + sizeof(KEY_HEADER);
    
    memcpy(pb, pPubKey->abModulus, cbMod);
    pb += cbMod;

    *pcbCspImport = (DWORD) (pb - pbCspImport);

    return true;
}


// bool CXoCrypto::RsaOaepEncrypt(
//     IN RsaKeyType keyType,
//     IN DWORD cbPacket,
//     IN BYTE* pRsa,
//     IN const BYTE* pbMsg,
//     IN DWORD cbMsg,
//     OUT BYTE* pbEncMsg
// )
// {
//     const DWORD BufferSize = 300; // Maximum modulus size supported (256) + extra room required by some crypto primitives
//     BYTE abPacketSeed[EMEOAEP_HASH_SIZE];
//     BYTE abPacket[BufferSize];
//     BYTE abEnPacket[BufferSize];
//     EMEOAEP_ERROR error;
//
//     // Generate a random seed for the encoding
//     if(!XOCryptGenRandom(abPacketSeed, sizeof(abPacketSeed)))
//         return false;
//
//     // Encode
//     error = EmeoaepPack(cbPacket, NULL, abPacketSeed, pbMsg, cbMsg, abPacket);
//     if(error != EmeoaepErrorNoError)
//         return false;
//
//     // Arrange byte order according to crypto primitive used
//     RevertBinary(abPacket, cbPacket);
//     memset(abPacket + cbPacket, 0, BufferSize - cbPacket);
//
//     // Encrypt
//     if(keyType == RsaKeyPublic)
//     {
//         if(!BSafeEncPublic((LPBSAFE_PUB_KEY)pRsa, abPacket, abEnPacket))
//             return false;
//     }
//     else if(keyType == RsaKeyPrivate)
//     {
//         if(!BSafeDecPrivate((LPBSAFE_PRV_KEY)pRsa, abPacket, abEnPacket))
//             return false;
//     }
//     else
//     {
//         return false; // Where is the Assert macro?
//     }
//
//     // Copy ciphertext to caller's buffer with the correct byte order
//     for(DWORD i=0; i < cbPacket; i++)
//     {
//         pbEncMsg[i] = abEnPacket[cbPacket-i-1];
//     }
//
//     return true;
// }
//
// bool CXoCrypto::RsaOaepDecrypt(
//     IN RsaKeyType keyType,
//     IN DWORD cbPacket,
//     IN const BYTE* pRsa,
//     IN const BYTE* pbEncMsg,
//     OUT BYTE* pbMsg,
//     IN OUT DWORD* pcbMsg
// )
// {
//     const BufferSize = 300; // Maximum modulus size supported (256) + extra room required by some crypto primitives
//     BYTE abPacket[BufferSize];
//     BYTE abEnPacket[BufferSize];
//     BYTE* pbPacketMsg;
//     DWORD cbPacketMsg;
//     EMEOAEP_ERROR error;
//
//     // Copy message with the right byte order according to crypto primitive
//     // used
//     for(DWORD i=0; i < cbPacket; i++)
//         abEnPacket[i] = pbEncMsg[cbPacket-i-1];
//
//     memset(abEnPacket + cbPacket, 0, BufferSize - cbPacket);
//
//     // Descrypt
//     if(keyType == RsaKeyPublic)
//     {
//         if(!BSafeEncPublic((LPBSAFE_PUB_KEY)pRsa, abEnPacket, abPacket))
//             return false;
//     }
//     else if(keyType == RsaKeyPrivate)
//     {
//         if(!BSafeDecPrivate((LPBSAFE_PRV_KEY)pRsa, abEnPacket, abPacket))
//             return false;
//     }
//     else
//     {
//         return false; // Where is the Assert macro?
//     }
//
//     // Readjust byte-order
//     RevertBinary(abPacket, cbPacket);
//
//     // Decode
//     error = EmeOaepUnpack(cbPacket, NULL, abPacket, &pbPacketMsg, &cbPacketMsg);
//     if(error != EmeoaepErrorNoError)
//         return false;
//
//     // Copy message to caller's buffer
//     if(*pcbMsg < cbPacketMsg)
//         return false;
//
//     memcpy(pbMsg, pbPacketMsg, cbPacketMsg);
//     *pcbMsg = cbPacketMsg;
//
//     return true;
// }
//
// void CXoCrypto::RevertBinary(BYTE* pb, DWORD cb)
// {
//     for(DWORD i=0; i < cb/2; i++)
//     {
//         BYTE t = pb[i];
//         pb[i] = pb[cb - i - 1];
//         pb[cb - i - 1] = t;
//     }
// }


///////////////////////////////////////////////////////
// Function FindCertificate
//
// Description
//    Finds the certificate of given (subject) name in the
//    specified store.
//
// Parameters
//   szCertName - the DN name to look for (CN=...)
//   szStore - the store in which to look for (e.g. "MY")
//   dwFlags - flags for crypto store
//   KeyID - returned KeyID for usage for signing
//
//
// Returns:
//  A handle to the certificate or NULL if error.
//
// Memory Side Effect:
//   Allocates Issuer KeyID ; Issuer Cert Context ; Issuer provider.
//   Free with:
//      CertFreeCertificateContext(pCertContext);
//      delete [] KeyID;
//
PCCERT_CONTEXT
FindCertificate(
    IN      wchar_t const * const      szCertName,
    IN      wchar_t const * const      szStore,
    IN      DWORD const                dwFlags,
    IN      DWORD const                dwEncodingType)
{
   PCCERT_CONTEXT pCertContext = NULL;
   PCERT_EXTENSION pExtension = NULL;
   HCERTSTORE hStore = 0;
   BOOL fErr, fSuccess = FALSE;
   DWORD dwSize=0;
   DWORD dwErr;

   // Open Certificate store
   hStore = CertOpenStore(
                CERT_STORE_PROV_SYSTEM,
                dwEncodingType, 0, dwFlags,
                (LPVOID)szStore);

   if (!hStore)
   {
       dwErr = GetLastError();
       printf("Error <0x%x>: Failed to open store %ls\n", dwErr, szStore);
       goto Cleanup;
   }

   // Find Certificate with Subject name
   pCertContext = CertFindCertificateInStore(hStore,
                                             dwEncodingType,
                                             0,
                                             CERT_FIND_SUBJECT_STR,
                                             (LPVOID)szCertName,
                                             NULL);
   if (!pCertContext)
   {
       dwErr = GetLastError();
       printf("Error <0x%x>: Failed to find certificate (%ls)\n", dwErr, szCertName);
       goto Cleanup;
   }

   fSuccess = TRUE;

Cleanup:

    // Clean up
    if (hStore)
    {
        CertCloseStore(hStore, 0);
    }


    if (!fSuccess)
    {
        if (pCertContext)
        {
            CertFreeCertificateContext(pCertContext);
            pCertContext = NULL;
        }
    }

   return pCertContext;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\crypto\helperlib\xetestkeys.cpp ===
//-----------------------------------------------------------------------------
// MasterSigning key
//-----------------------------------------------------------------------------

#include "stdafx.h"
#include "xetestkeys.h"

//@@@ dcaiafa: rename to g_XenonMasterSigningBsafePub2048
const BYTE g_XenonMasterSigningProdBsafePub2048[284] =
{
    0x52,0x53,0x41,0x31,0x08,0x01,0x00,0x00,0x00,0x08,0x00,0x00,0xFF,0x00,
    0x00,0x00,0x03,0x00,0x00,0x00,0xBB,0x37,0x4D,0x99,0x6F,0x49,0x5F,0xDD,
    0x43,0xB8,0xA6,0x5D,0xF2,0x98,0x5B,0xE4,0xAC,0xD4,0xA4,0x3C,0xFD,0x10,
    0xD3,0xBE,0xAF,0x63,0x3B,0xDB,0x79,0x3A,0x92,0xE6,0xF9,0x01,0x72,0x85,
    0xE5,0xA0,0xCD,0x38,0xE2,0xAD,0x4B,0x08,0x5B,0x5A,0x5F,0x0E,0x83,0x53,
    0x34,0x85,0x33,0x42,0x2A,0xA0,0x63,0x8E,0x35,0xBF,0x8F,0x5B,0xE5,0x1E,
    0x35,0xC4,0xDC,0x03,0xFF,0x8C,0x28,0xD8,0xBB,0x9F,0x36,0xC1,0x1A,0x0D,
    0xE4,0x02,0x3F,0x10,0x86,0xEC,0x4E,0xDE,0xED,0x90,0x25,0x78,0x3A,0xD9,
    0x96,0xFD,0x1F,0xE4,0x84,0xBD,0x96,0x1F,0x8B,0xD3,0xE1,0x38,0x24,0xA8,
    0xD0,0xBA,0x56,0x2A,0x5E,0xF6,0x93,0xEB,0x9A,0xA1,0x3C,0x8F,0x02,0xE5,
    0x7B,0xDF,0xC4,0xDA,0x99,0x1B,0xD7,0x59,0xBF,0x17,0x3A,0xCC,0x12,0x9A,
    0xC1,0xD0,0x6B,0x7F,0x2A,0xD4,0x87,0x78,0x4D,0x6E,0xC2,0xCE,0xF5,0x4E,
    0x8D,0xCD,0x2F,0x9E,0x12,0xFE,0xAD,0x9F,0x0F,0xA3,0x5A,0xA0,0xE4,0x52,
    0x5C,0xF2,0x6F,0x20,0x74,0x65,0x82,0xD1,0xAE,0x0D,0x25,0x3C,0xC1,0xB0,
    0xEA,0x8B,0xCD,0xE5,0x44,0xD7,0x60,0x7C,0xCE,0x02,0x0C,0x7A,0x1B,0xB5,
    0x80,0x6C,0x3F,0x4A,0x36,0x39,0x3D,0x51,0x24,0x0C,0x00,0x56,0x81,0x8D,
    0x83,0xCF,0x12,0xD3,0xDE,0xB6,0xEC,0xEA,0x86,0x79,0x64,0xB4,0x87,0xBB,
    0x4E,0x35,0xAB,0x7B,0x35,0x8A,0x13,0x90,0xF3,0xE1,0x8C,0x47,0x1D,0xEA,
    0xAA,0xF3,0xF2,0x07,0x82,0x55,0x97,0x27,0x7B,0x8E,0xA3,0x74,0x8F,0x47,
    0x53,0xF9,0x8A,0xAB,0xFB,0xCB,0x77,0xFC,0xB8,0xAE,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00 
};

//@@@ dcaiafa: rename to g_XenonMasterSigningTestBsafePub2048
const BYTE g_XenonMasterSigningBsafePub2048[284] =
{
    0x52,0x53,0x41,0x31,0x08,0x01,0x00,0x00,0x00,0x08,0x00,0x00,0xFF,0x00,0x00,0x00,
    0x03,0x00,0x00,0x00,0xA5,0x29,0xF1,0x27,0x87,0xCD,0x12,0x92,0x3F,0xA8,0x59,0x2F,
    0xDD,0xD1,0xBA,0xB3,0x7E,0x2D,0xB4,0xD1,0xB2,0x62,0x30,0x65,0x94,0xA9,0x89,0x63,
    0x7F,0x2F,0x5B,0x2F,0xAC,0x43,0x54,0x66,0x16,0x46,0x0A,0xC1,0x18,0x64,0xEB,0xF9,
    0xB2,0x38,0x07,0x78,0xE5,0xEC,0x3C,0x61,0x39,0xC8,0x26,0xC4,0x3E,0xE9,0x6D,0x42,
    0x59,0x92,0xDD,0x62,0x04,0xF0,0x29,0x19,0x04,0x81,0xAE,0xCA,0x19,0xF9,0x4C,0x48,
    0xAE,0x86,0xC5,0x6D,0x88,0x52,0xCC,0x32,0x54,0x31,0x8A,0xFB,0x63,0xB2,0x3C,0x43,
    0x42,0x98,0x9E,0x25,0x8D,0xD3,0x3E,0x97,0xA3,0x71,0xCA,0x07,0x40,0xFD,0xD2,0xA3,
    0x56,0xA9,0x44,0x4E,0xB4,0x7D,0x92,0x23,0xEE,0x5E,0x1A,0xB8,0x95,0xF3,0xF9,0x02,
    0xC7,0x04,0xF7,0xA8,0xCE,0x24,0x90,0x30,0x5C,0xE2,0x82,0x77,0x77,0x99,0x39,0xBE,
    0x4F,0x19,0x05,0x7D,0x5D,0x55,0xB0,0x68,0x74,0x91,0xEF,0x82,0xA9,0xF5,0x11,0x91,
    0x7B,0xFA,0x4D,0xA7,0xB1,0xB0,0x76,0x21,0x87,0x3F,0xA1,0xDD,0x56,0xD1,0xDC,0xBD,
    0x90,0x9D,0xD6,0x7D,0x33,0x78,0xDA,0x80,0x6F,0xEE,0xA7,0x5C,0xB4,0xDD,0xBA,0x31,
    0x5B,0x61,0xD2,0x63,0x00,0xE8,0xC5,0x97,0x2A,0x76,0xFC,0x8E,0xFE,0xAA,0xB3,0x18,
    0xFF,0x7A,0x3C,0x6E,0x6E,0x63,0xA8,0xEF,0xA8,0x98,0xE8,0x78,0xF7,0xBC,0x49,0xCC,
    0x82,0xF7,0x02,0x96,0xC6,0x88,0x58,0x4E,0x84,0xD6,0x58,0x77,0xC0,0x4A,0xA1,0x30,
    0xD5,0x35,0x3F,0x1F,0x84,0x1C,0x8E,0x06,0xE6,0xF6,0xA0,0xDD,0x3D,0xC3,0x7B,0xEC,
    0xEB,0x62,0xFF,0xB5,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
};

const BYTE g_XenonMasterSigningBsafePrv2048[1340] =
{
    0x52,0x53,0x41,0x32,0x08,0x01,0x00,0x00,0x00,0x08,0x00,0x00,0xFF,0x00,0x00,0x00,
    0x03,0x00,0x00,0x00,0xA5,0x29,0xF1,0x27,0x87,0xCD,0x12,0x92,0x3F,0xA8,0x59,0x2F,
    0xDD,0xD1,0xBA,0xB3,0x7E,0x2D,0xB4,0xD1,0xB2,0x62,0x30,0x65,0x94,0xA9,0x89,0x63,
    0x7F,0x2F,0x5B,0x2F,0xAC,0x43,0x54,0x66,0x16,0x46,0x0A,0xC1,0x18,0x64,0xEB,0xF9,
    0xB2,0x38,0x07,0x78,0xE5,0xEC,0x3C,0x61,0x39,0xC8,0x26,0xC4,0x3E,0xE9,0x6D,0x42,
    0x59,0x92,0xDD,0x62,0x04,0xF0,0x29,0x19,0x04,0x81,0xAE,0xCA,0x19,0xF9,0x4C,0x48,
    0xAE,0x86,0xC5,0x6D,0x88,0x52,0xCC,0x32,0x54,0x31,0x8A,0xFB,0x63,0xB2,0x3C,0x43,
    0x42,0x98,0x9E,0x25,0x8D,0xD3,0x3E,0x97,0xA3,0x71,0xCA,0x07,0x40,0xFD,0xD2,0xA3,
    0x56,0xA9,0x44,0x4E,0xB4,0x7D,0x92,0x23,0xEE,0x5E,0x1A,0xB8,0x95,0xF3,0xF9,0x02,
    0xC7,0x04,0xF7,0xA8,0xCE,0x24,0x90,0x30,0x5C,0xE2,0x82,0x77,0x77,0x99,0x39,0xBE,
    0x4F,0x19,0x05,0x7D,0x5D,0x55,0xB0,0x68,0x74,0x91,0xEF,0x82,0xA9,0xF5,0x11,0x91,
    0x7B,0xFA,0x4D,0xA7,0xB1,0xB0,0x76,0x21,0x87,0x3F,0xA1,0xDD,0x56,0xD1,0xDC,0xBD,
    0x90,0x9D,0xD6,0x7D,0x33,0x78,0xDA,0x80,0x6F,0xEE,0xA7,0x5C,0xB4,0xDD,0xBA,0x31,
    0x5B,0x61,0xD2,0x63,0x00,0xE8,0xC5,0x97,0x2A,0x76,0xFC,0x8E,0xFE,0xAA,0xB3,0x18,
    0xFF,0x7A,0x3C,0x6E,0x6E,0x63,0xA8,0xEF,0xA8,0x98,0xE8,0x78,0xF7,0xBC,0x49,0xCC,
    0x82,0xF7,0x02,0x96,0xC6,0x88,0x58,0x4E,0x84,0xD6,0x58,0x77,0xC0,0x4A,0xA1,0x30,
    0xD5,0x35,0x3F,0x1F,0x84,0x1C,0x8E,0x06,0xE6,0xF6,0xA0,0xDD,0x3D,0xC3,0x7B,0xEC,
    0xEB,0x62,0xFF,0xB5,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7B,0xED,0x1B,0x19,
    0xDF,0x3F,0x0E,0x5B,0xE2,0xBA,0x0B,0x5A,0x9B,0x04,0x7E,0xAE,0xE7,0x4F,0x8E,0xDB,
    0x20,0x6E,0xAC,0x03,0x49,0x83,0x54,0x23,0x18,0xDD,0xEC,0xBC,0x3B,0x2F,0x39,0x7D,
    0xA7,0x1E,0xDF,0x47,0xCA,0x84,0xBF,0x2B,0x6A,0x11,0x51,0xA6,0x2D,0xF4,0xCA,0x2B,
    0x1E,0xF6,0x0C,0xCD,0x6C,0xA8,0x5C,0x84,0x45,0x0E,0x53,0x26,0xB0,0x85,0x01,0xB9,
    0x9B,0x67,0x2F,0x4F,0x83,0x9D,0x1E,0xEA,0xCC,0xFF,0x66,0x77,0x27,0x9F,0x22,0x07,
    0x1A,0xA8,0xFF,0x0E,0x3D,0x3A,0x06,0x33,0xD2,0x81,0x91,0x9E,0x09,0x0F,0xE0,0x0D,
    0xD3,0x1B,0x9A,0x76,0x17,0x04,0x6C,0x7C,0x5F,0x54,0xFC,0x4A,0x9C,0xA1,0x38,0x4E,
    0x79,0xBB,0x9C,0xA9,0xD6,0xD7,0x20,0x35,0x6D,0x17,0xB7,0xEA,0x00,0x00,0x00,0x00,
    0x5F,0x4B,0xB3,0x61,0xED,0x8D,0xEB,0x8B,0xCF,0xF7,0x4F,0xB6,0xA5,0xC7,0x05,0x50,
    0xAD,0x00,0x6D,0xB7,0xF0,0xEA,0xA6,0x9E,0xC5,0xA8,0xF2,0xAE,0x19,0x3F,0xFD,0xBC,
    0xA9,0xF1,0x2F,0x8D,0x18,0x3A,0xCF,0xFA,0x25,0xE0,0x04,0x47,0xF2,0xAB,0xFD,0xB4,
    0x9B,0x0D,0x9B,0xA6,0xB0,0x65,0x0D,0x4A,0xC0,0x2D,0xAA,0x29,0xCE,0xE6,0x17,0xFD,
    0xDF,0xCC,0x87,0x38,0xE9,0xD7,0xC7,0xF8,0x4B,0xBE,0xCB,0xE6,0x8E,0xC8,0xEC,0x39,
    0xF1,0x4C,0x03,0xB2,0xB6,0x06,0xD9,0x38,0x47,0xEE,0x0D,0xAC,0x51,0x5E,0xFE,0xC8,
    0xE7,0x5E,0xD2,0xB0,0xCD,0x26,0x89,0xFB,0xD2,0x23,0xAE,0xCB,0xFD,0xEC,0x9A,0x16,
    0x4C,0x04,0xFE,0x8E,0x7B,0xE1,0x50,0xF3,0x8E,0x4B,0xC5,0xB5,0xFB,0x74,0x80,0xC6,
    0x00,0x00,0x00,0x00,0xA7,0xF3,0x67,0xBB,0x94,0x2A,0xB4,0x3C,0xEC,0xD1,0x07,0x3C,
    0x12,0x03,0x54,0x74,0x9A,0x8A,0x09,0x3D,0x6B,0x49,0xC8,0x57,0xDB,0xAC,0x8D,0x17,
    0x10,0x3E,0xF3,0x7D,0xD2,0x74,0x7B,0x53,0x1A,0xBF,0x94,0xDA,0x86,0x58,0x2A,0x1D,
    0x9C,0x0B,0x36,0xC4,0x73,0x4D,0x87,0x72,0x69,0xF9,0x5D,0x33,0xF3,0x1A,0x93,0xAD,
    0x83,0x09,0xE2,0x6E,0x75,0xAE,0xAB,0xD0,0x67,0x9A,0x1F,0x8A,0x57,0xBE,0x69,0xF1,
    0xDD,0xFF,0x99,0x4F,0x1A,0x6A,0x6C,0xAF,0x66,0xC5,0xFF,0x09,0x7E,0xD1,0xAE,0xCC,
    0x36,0x01,0x61,0x14,0xB1,0xB4,0xEA,0xB3,0x8C,0x12,0xBC,0xF9,0x64,0xAD,0xF2,0x52,
    0xEA,0xE2,0x52,0x87,0xBD,0x6B,0xD0,0xDE,0x50,0xD2,0xBD,0x1B,0x8F,0x3A,0x6B,0x23,
    0x9E,0x0F,0x7A,0x9C,0x00,0x00,0x00,0x00,0x3F,0x32,0x22,0x41,0x9E,0x5E,0xF2,0x07,
    0x35,0xA5,0x8A,0x79,0x6E,0xDA,0x03,0xE0,0xC8,0x55,0xF3,0x24,0x4B,0x47,0x6F,0x14,
    0xD9,0xC5,0xA1,0x74,0x66,0x7F,0x53,0xD3,0x1B,0xA1,0xCA,0x08,0xBB,0x26,0x8A,0xFC,
    0xC3,0xEA,0xAD,0x84,0xA1,0x72,0xFE,0xCD,0x67,0x5E,0x67,0xC4,0x75,0xEE,0x08,0xDC,
    0x2A,0xC9,0xC6,0x1B,0x34,0xEF,0x0F,0xFE,0x3F,0x33,0x05,0x7B,0x9B,0x3A,0x85,0x50,
    0xDD,0x7E,0x32,0xEF,0x09,0xDB,0x9D,0x26,0xF6,0xDD,0xAC,0x76,0x24,0xAF,0x90,0xD0,
    0x84,0x49,0x09,0xC8,0x8B,0xE9,0xFE,0x85,0x9A,0x94,0xE1,0x75,0xDE,0x19,0x06,0xFD,
    0xE1,0x17,0x74,0x32,0xA9,0x48,0x67,0x64,0xDD,0x02,0x54,0x5F,0x52,0x96,0xE0,0x4C,
    0x5F,0x32,0x2E,0x79,0x52,0xA3,0x55,0x84,0x00,0x00,0x00,0x00,0x8D,0xD8,0xD0,0x92,
    0x37,0xC7,0xA5,0xA5,0x24,0x47,0x8F,0x27,0x4E,0x3C,0xD0,0x2B,0x9E,0xFD,0xD8,0x4C,
    0xFE,0x2C,0x31,0x6E,0x8E,0x33,0xD2,0x41,0xC4,0xE4,0xED,0xA3,0x35,0x09,0xFF,0xB5,
    0x47,0xAD,0x83,0x5E,0x15,0x4E,0xD3,0x33,0xDC,0xB8,0x61,0x58,0x66,0xA8,0x10,0x21,
    0x1C,0x66,0x8E,0x7A,0xF8,0xFB,0xA5,0x0B,0x82,0xDA,0xC2,0x61,0xA8,0xA9,0x33,0xF5,
    0xF8,0x1B,0x28,0x3B,0xEF,0xD5,0xD9,0x04,0x86,0xE1,0xA7,0xE0,0x92,0xC7,0x78,0x1A,
    0xC9,0x13,0xCB,0xEA,0x15,0xE8,0xCC,0xB4,0xBB,0x2B,0xD5,0x3D,0x3D,0x54,0xBC,0x4C,
    0xCA,0x63,0xA3,0x72,0x49,0x7F,0x0C,0x05,0xB5,0xDD,0x12,0x2B,0x0A,0x83,0x5C,0x78,
    0xC4,0x1A,0x96,0x0A,0x7F,0xA9,0x29,0x19,0xF4,0x79,0xFE,0x5B,0x00,0x00,0x00,0x00,
    0x33,0x4B,0xC1,0xC8,0xD1,0xFF,0x65,0xC7,0xB3,0xA3,0xFE,0x69,0xBD,0x03,0x7A,0x23,
    0xF1,0x3D,0x7B,0xD4,0xC0,0x5B,0x93,0x2C,0x59,0xFE,0xD6,0x60,0xDE,0x0C,0xF6,0x78,
    0x84,0x6C,0x47,0x3D,0xE4,0x48,0x3D,0x54,0x70,0xFF,0x19,0x5A,0xE4,0xFC,0x7A,0x68,
    0xBD,0x9C,0xE4,0x09,0x47,0x48,0x08,0x1E,0x61,0xB7,0x44,0xB8,0x83,0x13,0xF7,0xD4,
    0xA2,0x13,0x6B,0x1A,0xAA,0x2B,0x7A,0xAC,0x31,0xBE,0x41,0xFA,0x36,0xD4,0x4B,0x28,
    0xF5,0xEE,0x6E,0xA6,0x57,0xAC,0xCB,0x77,0xEA,0x5B,0x70,0xED,0xBE,0x7A,0xB4,0x7E,
    0x12,0x99,0x5D,0x90,0xAC,0x74,0x6F,0x0E,0x39,0x8E,0xD0,0xE7,0x50,0x45,0x1E,0xF3,
    0x87,0x3A,0x3D,0x84,0xFB,0x2B,0x73,0x67,0x75,0x35,0x0D,0x10,0x94,0xA5,0x7F,0xFA,
    0xDD,0x6D,0xB5,0x75,0x3D,0xEC,0x01,0xA5,0x4F,0x66,0x26,0xD4,0xDF,0x10,0xAE,0xA8,
    0x93,0xE3,0xCA,0x45,0xF8,0x60,0x4A,0x57,0xC6,0xA3,0xB6,0x60,0x52,0xFC,0x33,0x1A,
    0x21,0xCB,0xF9,0xC0,0x04,0xD5,0xC0,0x93,0xE4,0xE0,0x3D,0x29,0x0B,0x69,0xE4,0x53,
    0x22,0x50,0x3C,0xAB,0x9F,0x49,0xC5,0x3D,0x78,0x3E,0x27,0x21,0x92,0xEB,0x36,0xED,
    0xAA,0x9A,0x2E,0x65,0x1C,0xA4,0xFD,0x09,0xFF,0x71,0x22,0xBB,0x54,0xA7,0x7D,0x49,
    0xF4,0xEC,0x1A,0xF5,0xC5,0x65,0xF0,0xA5,0x4F,0xD3,0xDB,0x32,0x57,0xFA,0x01,0x64,
    0x84,0xB0,0xE5,0xDE,0x02,0x8F,0x90,0x4F,0x80,0xDC,0xC0,0x75,0xE3,0x23,0x2A,0x6A,
    0xAD,0xBD,0x5E,0x04,0x44,0x4F,0x6B,0x3E,0x29,0x82,0x52,0x48,0x9D,0xEC,0x54,0x79,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
};


//-----------------------------------------------------------------------------
// Xenon Console key
//-----------------------------------------------------------------------------

const BYTE g_XenonConsoleRsaBsafePub1024[156] =
{
    0x52,0x53,0x41,0x31,0x88,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x7F,0x00,0x00,0x00,
    0x03,0x00,0x00,0x00,0x39,0x3C,0xFD,0x6A,0xE4,0x76,0x73,0x96,0xB5,0x96,0x2B,0xC3,
    0xE6,0x2D,0xAD,0x58,0xC8,0xE2,0x7E,0x83,0x49,0xDC,0x05,0x97,0x2A,0x2D,0x91,0xD2,
    0x0D,0xD7,0x45,0xCC,0x19,0xA4,0xC3,0x5C,0x4E,0xEE,0x6C,0xDD,0x4C,0xE9,0xF6,0x0A,
    0xA4,0xE0,0xC8,0xA7,0x60,0x71,0x0D,0xBB,0x1D,0xA7,0xBC,0xCE,0x5B,0x77,0x96,0xA5,
    0x26,0x96,0xA5,0x5E,0x66,0xDE,0xEF,0x93,0x1F,0x3C,0x12,0x1F,0x93,0xCB,0xB3,0xBD,
    0x6C,0x38,0x6C,0xF0,0x84,0xE9,0x90,0xFB,0x78,0x76,0xAB,0xAC,0xA2,0x37,0xCE,0x10,
    0x8B,0x7A,0x50,0x16,0x86,0xAA,0x31,0xDE,0x06,0x22,0xA6,0x21,0x77,0x3E,0x1C,0x50,
    0x56,0x54,0x45,0xD0,0x51,0x45,0xD8,0x7B,0xC8,0xA7,0xDF,0xF1,0xF9,0x8F,0x39,0x9D,
    0x8A,0x32,0x00,0xCA,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
};

const BYTE g_XenonConsoleRsaBsafePrv1024[700] =
{
    0x52,0x53,0x41,0x32,0x88,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x7F,0x00,0x00,0x00,
    0x03,0x00,0x00,0x00,0x39,0x3C,0xFD,0x6A,0xE4,0x76,0x73,0x96,0xB5,0x96,0x2B,0xC3,
    0xE6,0x2D,0xAD,0x58,0xC8,0xE2,0x7E,0x83,0x49,0xDC,0x05,0x97,0x2A,0x2D,0x91,0xD2,
    0x0D,0xD7,0x45,0xCC,0x19,0xA4,0xC3,0x5C,0x4E,0xEE,0x6C,0xDD,0x4C,0xE9,0xF6,0x0A,
    0xA4,0xE0,0xC8,0xA7,0x60,0x71,0x0D,0xBB,0x1D,0xA7,0xBC,0xCE,0x5B,0x77,0x96,0xA5,
    0x26,0x96,0xA5,0x5E,0x66,0xDE,0xEF,0x93,0x1F,0x3C,0x12,0x1F,0x93,0xCB,0xB3,0xBD,
    0x6C,0x38,0x6C,0xF0,0x84,0xE9,0x90,0xFB,0x78,0x76,0xAB,0xAC,0xA2,0x37,0xCE,0x10,
    0x8B,0x7A,0x50,0x16,0x86,0xAA,0x31,0xDE,0x06,0x22,0xA6,0x21,0x77,0x3E,0x1C,0x50,
    0x56,0x54,0x45,0xD0,0x51,0x45,0xD8,0x7B,0xC8,0xA7,0xDF,0xF1,0xF9,0x8F,0x39,0x9D,
    0x8A,0x32,0x00,0xCA,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xC3,0x3B,0xCC,0x97,
    0x28,0xD4,0x4D,0x74,0x8C,0xAD,0x40,0xBF,0xE4,0x76,0x0E,0xED,0x10,0x5F,0xE9,0xD6,
    0x12,0xE2,0x47,0xC6,0x1A,0x19,0x50,0xA3,0x25,0xF1,0x5D,0xA6,0xEF,0x71,0x06,0x6D,
    0xFC,0x60,0x46,0x1D,0x44,0xB3,0xCA,0xF0,0xE4,0xE9,0x82,0x61,0xB0,0xC6,0x70,0x40,
    0xBC,0x9B,0x46,0x63,0xBC,0x34,0x43,0x96,0xB3,0xFD,0x44,0xE8,0x00,0x00,0x00,0x00,
    0x53,0xF4,0xF0,0x2C,0x85,0xED,0x0F,0xF6,0xA0,0x94,0x87,0x4C,0xDD,0xDA,0x9F,0x1E,
    0x90,0x4D,0xAD,0xAA,0xC1,0xBD,0xD6,0x79,0xBD,0xF5,0xE6,0x3F,0x3D,0xCC,0x92,0x51,
    0x84,0xBD,0x12,0xFD,0xE9,0xA4,0xD8,0xD5,0x1D,0x2F,0x13,0x1B,0xF2,0x17,0xC9,0xB6,
    0x90,0x5E,0x89,0xFF,0x52,0x21,0xCD,0x1B,0x82,0xD0,0x8B,0x1F,0x22,0x87,0xA3,0xDE,
    0x00,0x00,0x00,0x00,0xD7,0x27,0x88,0xBA,0xC5,0xE2,0x33,0xF8,0xB2,0x73,0x80,0x7F,
    0x98,0xA4,0x09,0x9E,0x60,0x3F,0x46,0x8F,0x0C,0xEC,0x2F,0x84,0xBC,0x10,0xE0,0x6C,
    0x6E,0x4B,0xE9,0x6E,0x4A,0xA1,0x59,0xF3,0x52,0xEB,0x2E,0xBE,0x82,0x77,0xDC,0xF5,
    0xED,0x9B,0xAC,0xEB,0xCA,0xD9,0xF5,0x2A,0x28,0xBD,0xD9,0xEC,0xD2,0xCD,0x2C,0x64,
    0x22,0xA9,0xD8,0x9A,0x00,0x00,0x00,0x00,0x37,0xF8,0xF5,0x1D,0xAE,0xF3,0x5F,0xF9,
    0x15,0x63,0x5A,0x88,0x93,0x3C,0x15,0xBF,0x0A,0x89,0x73,0x1C,0x81,0x7E,0xE4,0xFB,
    0x28,0xF9,0x99,0x2A,0x7E,0xDD,0x61,0x36,0x58,0x7E,0x0C,0xFE,0x9B,0x18,0x3B,0x39,
    0x69,0x1F,0x62,0x67,0xA1,0xBA,0x30,0xCF,0xB5,0xE9,0xB0,0xFF,0xE1,0xC0,0x88,0x12,
    0xAC,0x35,0x5D,0x6A,0xC1,0x04,0x6D,0x94,0x00,0x00,0x00,0x00,0x77,0x86,0x15,0x5B,
    0x7A,0x54,0x4D,0x67,0xC4,0x78,0xA3,0x59,0xEF,0xEE,0xA3,0x71,0x16,0x97,0x06,0x88,
    0x50,0x30,0x1A,0x3A,0xF7,0x03,0xC3,0x78,0x1A,0x2F,0xFC,0x6F,0xC3,0x2A,0x0B,0xC5,
    0xB1,0x7E,0xC2,0x0C,0xE1,0x4B,0x3E,0x13,0x73,0x25,0xBC,0x11,0xF0,0x68,0x42,0x69,
    0xC4,0x5A,0x51,0x33,0xD7,0x06,0x9A,0xCF,0x61,0x35,0x6A,0x84,0x00,0x00,0x00,0x00,
    0xC3,0xB2,0x2A,0xC4,0x79,0x23,0xB9,0x72,0x05,0xE3,0xEC,0x24,0xC3,0x92,0x54,0x33,
    0x1A,0x24,0xF0,0xAB,0xF8,0xD2,0x44,0x8F,0xE1,0xBE,0xE6,0xF4,0x71,0x66,0xE3,0xE2,
    0xC3,0x4D,0x1C,0xF7,0xEF,0x9A,0xDE,0x46,0x47,0xAF,0x10,0xAA,0x88,0x94,0xA8,0x5F,
    0x6A,0xDD,0x0C,0x52,0xB4,0x46,0x1B,0x35,0xBE,0xF6,0x84,0x4A,0x8B,0x0B,0x7E,0xBA,
    0xED,0x3E,0xF5,0xB7,0xBF,0xD2,0xB6,0x14,0x62,0x32,0xCD,0xD3,0x9D,0x25,0x48,0xA0,
    0x58,0x46,0x0B,0xFD,0xA5,0xF9,0x1C,0x73,0x6C,0x7A,0x89,0x60,0x07,0xA7,0x35,0x64,
    0x59,0x1C,0x21,0x94,0x04,0x6C,0x19,0xC1,0xA4,0x29,0x68,0x35,0xE4,0xE2,0xD8,0x8A,
    0x36,0x2E,0x90,0x52,0x30,0xC5,0x3F,0xA1,0xA6,0x0A,0xD1,0x68,0x5C,0xCC,0xAA,0x86,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
};

const BYTE g_XenonXmacsBsafePub2048[284] =
{
    0x52,0x53,0x41,0x31,0x08,0x01,0x00,0x00,0x00,0x08,0x00,0x00,0xFF,0x00,0x00,0x00,
    0x03,0x00,0x00,0x00,0xFB,0x37,0x45,0x77,0xFB,0xDF,0xC9,0xD8,0x74,0x53,0xA4,0x98,
    0x0F,0x45,0x0D,0x14,0xD3,0x09,0x29,0x2C,0xF6,0x2F,0x71,0xBD,0xDE,0x10,0xCA,0xF6,
    0xF8,0x7A,0x9B,0xCE,0x6F,0x39,0xA7,0xBF,0x2B,0x37,0x73,0x1A,0x8D,0x45,0x36,0x4C,
    0xA3,0xC2,0x1A,0xC7,0x92,0x60,0xE1,0xDE,0xC0,0xEC,0x69,0xF1,0x02,0xFD,0x23,0xA4,
    0x9E,0xF5,0xDE,0xED,0x4F,0x35,0xEF,0xD8,0x11,0x0C,0x52,0x2F,0x1E,0x1A,0xC3,0x86,
    0x0E,0xC8,0x8F,0x80,0x91,0xFA,0xBE,0x7A,0x85,0x3D,0x58,0xF7,0x2A,0x6F,0x24,0x92,
    0x1F,0xEC,0xA5,0xB5,0xC9,0x1D,0x5F,0x3C,0x2F,0x02,0x0F,0xF3,0xF9,0x36,0x85,0xF9,
    0x1F,0x5F,0xFA,0x83,0x26,0xA3,0xCD,0x05,0x8C,0x31,0x94,0xF0,0xC5,0x89,0x1A,0x24,
    0x23,0x8A,0x2E,0x57,0x23,0xDC,0x1C,0x65,0x81,0x1D,0x2A,0xCD,0xF1,0xA2,0xC3,0xFC,
    0xC5,0x36,0x53,0x7B,0xC8,0x69,0xF9,0x54,0x89,0xE1,0x6A,0xB5,0xA4,0x75,0x19,0xAF,
    0x89,0xA9,0x27,0x4F,0x47,0xF0,0xCD,0xD6,0x72,0x88,0xAF,0x68,0xB5,0xCC,0xB4,0x85,
    0xC3,0x16,0xBA,0x4B,0xF8,0x49,0xBF,0x9A,0x85,0xC3,0x11,0xE1,0x84,0xFE,0x53,0x03,
    0x55,0x18,0xDC,0x74,0xBB,0x16,0xEB,0x0F,0x97,0xC5,0xE1,0xAF,0xFE,0x34,0x76,0x90,
    0xF3,0xD6,0x06,0xF4,0x90,0xA9,0x15,0xB2,0xF5,0xE8,0x91,0x81,0xE5,0x8E,0xA2,0x68,
    0xEB,0x93,0x07,0x12,0x0E,0x48,0x63,0x0E,0x6F,0xA5,0xF8,0x52,0x62,0xB1,0x1B,0x02,
    0xE4,0x8F,0x08,0x05,0x22,0x41,0x77,0x08,0x14,0xEF,0x05,0xD7,0x38,0x23,0x5B,0x5A,
    0x89,0x83,0xA3,0xA3,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
};

const BYTE g_XenonXmacsBsafePrv2048[1340] =
{
    0x52,0x53,0x41,0x32,0x08,0x01,0x00,0x00,0x00,0x08,0x00,0x00,0xFF,0x00,0x00,0x00,
    0x03,0x00,0x00,0x00,0xFB,0x37,0x45,0x77,0xFB,0xDF,0xC9,0xD8,0x74,0x53,0xA4,0x98,
    0x0F,0x45,0x0D,0x14,0xD3,0x09,0x29,0x2C,0xF6,0x2F,0x71,0xBD,0xDE,0x10,0xCA,0xF6,
    0xF8,0x7A,0x9B,0xCE,0x6F,0x39,0xA7,0xBF,0x2B,0x37,0x73,0x1A,0x8D,0x45,0x36,0x4C,
    0xA3,0xC2,0x1A,0xC7,0x92,0x60,0xE1,0xDE,0xC0,0xEC,0x69,0xF1,0x02,0xFD,0x23,0xA4,
    0x9E,0xF5,0xDE,0xED,0x4F,0x35,0xEF,0xD8,0x11,0x0C,0x52,0x2F,0x1E,0x1A,0xC3,0x86,
    0x0E,0xC8,0x8F,0x80,0x91,0xFA,0xBE,0x7A,0x85,0x3D,0x58,0xF7,0x2A,0x6F,0x24,0x92,
    0x1F,0xEC,0xA5,0xB5,0xC9,0x1D,0x5F,0x3C,0x2F,0x02,0x0F,0xF3,0xF9,0x36,0x85,0xF9,
    0x1F,0x5F,0xFA,0x83,0x26,0xA3,0xCD,0x05,0x8C,0x31,0x94,0xF0,0xC5,0x89,0x1A,0x24,
    0x23,0x8A,0x2E,0x57,0x23,0xDC,0x1C,0x65,0x81,0x1D,0x2A,0xCD,0xF1,0xA2,0xC3,0xFC,
    0xC5,0x36,0x53,0x7B,0xC8,0x69,0xF9,0x54,0x89,0xE1,0x6A,0xB5,0xA4,0x75,0x19,0xAF,
    0x89,0xA9,0x27,0x4F,0x47,0xF0,0xCD,0xD6,0x72,0x88,0xAF,0x68,0xB5,0xCC,0xB4,0x85,
    0xC3,0x16,0xBA,0x4B,0xF8,0x49,0xBF,0x9A,0x85,0xC3,0x11,0xE1,0x84,0xFE,0x53,0x03,
    0x55,0x18,0xDC,0x74,0xBB,0x16,0xEB,0x0F,0x97,0xC5,0xE1,0xAF,0xFE,0x34,0x76,0x90,
    0xF3,0xD6,0x06,0xF4,0x90,0xA9,0x15,0xB2,0xF5,0xE8,0x91,0x81,0xE5,0x8E,0xA2,0x68,
    0xEB,0x93,0x07,0x12,0x0E,0x48,0x63,0x0E,0x6F,0xA5,0xF8,0x52,0x62,0xB1,0x1B,0x02,
    0xE4,0x8F,0x08,0x05,0x22,0x41,0x77,0x08,0x14,0xEF,0x05,0xD7,0x38,0x23,0x5B,0x5A,
    0x89,0x83,0xA3,0xA3,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1D,0x1E,0x0E,0x52,
    0xD1,0x94,0xB9,0x2F,0xD9,0x10,0x77,0x82,0x0E,0xBC,0x16,0xB3,0x59,0x79,0xCC,0xE9,
    0x6B,0x71,0x95,0xF6,0x36,0xEC,0x68,0xF9,0xC1,0x13,0xB4,0xE4,0x09,0xAE,0x0F,0x62,
    0xE0,0x5D,0xC3,0x69,0x42,0x92,0x35,0xE5,0xC7,0xD2,0x34,0x70,0x2F,0x8B,0x91,0x27,
    0x2C,0x9D,0xF9,0xE8,0x32,0x2E,0x20,0x7D,0x54,0x85,0xC6,0x8D,0xCD,0xE8,0xE6,0x82,
    0x64,0xDE,0xC1,0x90,0x26,0x1C,0xDB,0x04,0xF1,0xF2,0xA8,0x88,0x4E,0x0B,0x15,0x09,
    0xE9,0xE1,0x02,0x6E,0xF3,0xCE,0x47,0x88,0x03,0xF4,0x5B,0x99,0xCD,0x1F,0x9B,0xAC,
    0x4F,0x2E,0xB0,0x56,0x8D,0x58,0xA8,0xDB,0x99,0xBF,0x4E,0x34,0x3C,0x0F,0x45,0x8A,
    0xF5,0xEB,0xD6,0x79,0xC9,0x71,0xEC,0x28,0x47,0xD1,0x24,0xD5,0x00,0x00,0x00,0x00,
    0xF7,0xB2,0xAE,0x9F,0x67,0xC3,0x53,0xEF,0x56,0x3F,0x3F,0xD3,0x5B,0xA0,0xA6,0xC1,
    0xAB,0x50,0x1B,0xE9,0xE9,0x85,0x65,0x6E,0xC4,0xF1,0xDD,0xE8,0xC8,0x6B,0xAE,0xE5,
    0xE0,0x97,0x37,0x86,0x94,0x08,0x19,0xF9,0xE1,0x71,0xB2,0x80,0x70,0xEF,0xF4,0x6D,
    0x7F,0x54,0xBF,0xAA,0xAB,0x16,0xD9,0x3F,0x3A,0x23,0xA3,0x98,0xA8,0x1A,0x5E,0xA2,
    0x2D,0x18,0xB1,0xC2,0xBF,0x6D,0x67,0x78,0x2D,0x17,0xE0,0x40,0xBB,0x43,0xC1,0xB1,
    0x00,0xFD,0x48,0xFD,0x9D,0x8C,0x94,0x32,0x8A,0xC6,0x75,0x8F,0xC6,0xCA,0xF6,0xDC,
    0x72,0x63,0xAB,0x50,0xD3,0x1D,0x73,0x00,0xDB,0x4F,0x13,0x84,0x14,0xB5,0x0A,0x5B,
    0x24,0x39,0x66,0xCB,0xBA,0x81,0x56,0x62,0x8F,0xA2,0x0F,0x5E,0x78,0x83,0x8A,0xC4,
    0x00,0x00,0x00,0x00,0x13,0x14,0xB4,0x36,0x36,0x63,0x26,0x75,0x3B,0x0B,0xFA,0x56,
    0xB4,0xD2,0xB9,0xCC,0x3B,0xA6,0xDD,0x9B,0xF2,0xA0,0x63,0xA4,0x24,0x48,0x9B,0xFB,
    0x2B,0x0D,0x78,0x98,0x06,0x74,0x0A,0xEC,0xEA,0x93,0xD7,0x9B,0x81,0x61,0xCE,0x98,
    0xDA,0xE1,0xCD,0x4A,0xCA,0x5C,0xB6,0x6F,0x1D,0xBE,0xFB,0x45,0x77,0xC9,0x6A,0x53,
    0x38,0xAE,0xD9,0xB3,0x33,0x9B,0x44,0x57,0x98,0xE9,0x2B,0x0B,0x6F,0xBD,0x3C,0x03,
    0xF6,0xA1,0x70,0xB0,0x89,0x07,0x0E,0x06,0x46,0x41,0x57,0x49,0xA2,0x34,0x85,0x05,
    0xAD,0xA2,0x92,0xBB,0x33,0x15,0x12,0x73,0x8A,0xC9,0xCA,0x39,0x5E,0x90,0xC5,0xE7,
    0xBB,0x7F,0x34,0x78,0x7D,0x5F,0x83,0xB1,0xA3,0xF2,0x39,0x51,0x86,0xF6,0xF2,0xC5,
    0x84,0x8B,0x18,0x8E,0x00,0x00,0x00,0x00,0x4F,0x77,0x74,0x6A,0x9A,0xD7,0x37,0x4A,
    0x8F,0x7F,0x7F,0x37,0x3D,0xC0,0x19,0x81,0x72,0xE0,0xBC,0xF0,0x9B,0xAE,0x43,0xF4,
    0x82,0xF6,0x93,0xF0,0x85,0xF2,0x1E,0x99,0x40,0x65,0x7A,0x59,0xB8,0x05,0x66,0xFB,
    0xEB,0x4B,0xCC,0x55,0xA0,0x9F,0xF8,0xF3,0x54,0x38,0x2A,0xC7,0xC7,0xB9,0x90,0x2A,
    0x7C,0x17,0xC2,0x65,0x70,0xBC,0x3E,0x6C,0x1E,0x10,0x76,0x2C,0xD5,0xF3,0x44,0x50,
    0x1E,0xBA,0xEA,0xD5,0x7C,0x82,0x2B,0x21,0xAB,0xA8,0x30,0xFE,0x13,0xB3,0x0D,0x77,
    0xB1,0xD9,0xA3,0x5F,0x84,0xDC,0xF9,0x3D,0xF7,0xEC,0x1C,0x8B,0x37,0x69,0xF7,0xAA,
    0x3C,0x35,0x62,0xAD,0x0D,0xCE,0xB1,0x3C,0x18,0x26,0x44,0x32,0x27,0x01,0x8F,0x41,
    0x0A,0x17,0xB5,0x3E,0x50,0x02,0x07,0x83,0x00,0x00,0x00,0x00,0xAB,0x5E,0x1A,0xAE,
    0x1A,0x59,0x5C,0x6C,0xAB,0xC6,0xE8,0x44,0xE0,0xB2,0x86,0xF2,0xF1,0x64,0x69,0x47,
    0x6E,0x35,0xE1,0xD0,0x93,0x21,0x35,0x79,0x30,0x69,0x16,0x87,0x0E,0x50,0xE6,0x73,
    0x19,0x16,0x4F,0x3D,0x68,0x48,0xE4,0xF2,0x36,0x9D,0x06,0x36,0x14,0xB2,0x26,0x94,
    0xCE,0x38,0x2E,0x66,0x39,0xE6,0xE5,0x8A,0x4C,0x6D,0x65,0xE8,0xDA,0x29,0x33,0xFC,
    0xFF,0x96,0xCB,0xC7,0x3B,0x1E,0x30,0xBB,0x7F,0x21,0x92,0xE7,0x0C,0xAC,0xA4,0x00,
    0x8A,0x58,0x74,0xC8,0xBA,0xDF,0x9C,0x1A,0x04,0xC6,0x83,0xF6,0xAE,0x3D,0x59,0x5F,
    0xF9,0x7D,0x0E,0x13,0xDE,0x09,0xC1,0x0F,0xD7,0x71,0x18,0x20,0xA7,0x1E,0xEE,0x12,
    0xAA,0x2F,0xF3,0xF4,0xE7,0x79,0xAD,0xB2,0x83,0x00,0x7D,0xBC,0x00,0x00,0x00,0x00,
    0x9B,0x44,0xB0,0x03,0xD7,0xAF,0x7D,0x26,0x83,0x57,0x49,0xD7,0x18,0x9B,0x8A,0xBF,
    0x33,0xD5,0x80,0x3B,0xC0,0x25,0xA4,0xE5,0xEC,0x21,0x02,0x63,0x49,0x52,0x7B,0xAD,
    0x58,0xA2,0xEA,0xE4,0x79,0xE0,0xB9,0xCF,0x45,0xD6,0xDE,0xEE,0xF1,0xAA,0xA0,0xF0,
    0x97,0x00,0x0B,0xB3,0xF0,0x25,0xBA,0x85,0x0E,0x1D,0xEB,0x5E,0x16,0x39,0x7C,0x7E,
    0x38,0x78,0x8F,0xB7,0xF3,0x7F,0x70,0x19,0xDC,0x99,0x5A,0x2B,0xEC,0x60,0x6E,0xD9,
    0xD6,0xF6,0x95,0x4D,0x54,0xDF,0xD5,0x39,0x1E,0x91,0x44,0xFC,0x38,0x1E,0xE2,0xD4,
    0xB0,0x11,0xBB,0xD4,0xB2,0xCE,0x47,0xBD,0x0B,0x5F,0x86,0x66,0xF6,0x46,0x6B,0xF8,
    0x83,0x3C,0x6C,0x75,0x92,0x82,0x44,0xB8,0x48,0x4E,0x14,0xBE,0x97,0x23,0xAA,0xD3,
    0x6B,0x3D,0x13,0xEE,0x00,0x69,0x71,0x33,0xA1,0x6C,0x82,0xA8,0x2E,0xCF,0x8C,0xA7,
    0x85,0x46,0xA6,0x38,0x06,0x41,0x47,0xCE,0x6D,0x4E,0x66,0x1F,0xB1,0x1B,0xC5,0x34,
    0xDA,0x4A,0x89,0xE4,0xA1,0x05,0x75,0xF0,0x78,0x88,0x78,0xAE,0xD7,0xB9,0x26,0xDD,
    0xFA,0xDB,0xD4,0x11,0x59,0x82,0xB6,0x40,0x03,0xFF,0x37,0x02,0x8E,0x65,0x3D,0xA3,
    0x27,0x0F,0xF2,0x5F,0x0F,0xD9,0xEB,0x1F,0xFF,0xCD,0x4E,0x60,0xA2,0xE4,0x59,0x4D,
    0x0B,0x71,0x0E,0xCC,0xA3,0xF0,0x0B,0x01,0x99,0xB4,0xC1,0x45,0xF2,0xB7,0xAF,0xB6,
    0x5E,0x85,0x97,0x09,0x4A,0x6E,0x50,0x37,0xEC,0x20,0xBD,0x56,0xED,0x5F,0xB0,0x58,
    0xC1,0x80,0x4F,0xB0,0x62,0x9F,0xAE,0xE4,0x25,0xC2,0x3C,0x3C,0x06,0xAD,0x17,0x6D,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\crypto\helperlib\DosBlackBox.cpp ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved
//
#include "stdafx.h"

#import "CommonConfig.tlb" raw_interfaces_only, no_smart_pointers
using namespace XblConfig;


XomDefineArea( blackbox );

extern
void
XcHMAC(
    IN PBYTE pbKeyMaterial,
    IN ULONG cbKeyMaterial,
    IN PBYTE pbData,
    IN ULONG cbData,
    IN PBYTE pbData2,
    IN ULONG cbData2,
    OUT PBYTE HmacData // length must be A_SHA_DIGEST_LEN
    );

BYTE g_abNameSHAKey[16];

DWORD g_dwSPPAPick[sizeof(DWORD)];

//////////////////////////////////////////////////////////////////////////////
XOCryptoDoSBlackBox::XOCryptoDoSBlackBox() :
    m_dwNumEntries( 0 ),
    m_dwMaxEntries( 0 ),
    m_dwMaxTimeSkewInSecs( 0 ),
    m_msClientRetryInterval( 0 )
{
    for (DWORD idx = 0; idx < ARRAYSIZE(m_pEntries); idx++)
    {
        m_pEntries[idx] = NULL;
    }
}


//////////////////////////////////////////////////////////////////////////////
XOCryptoDoSBlackBox::~XOCryptoDoSBlackBox()
{
    for (DWORD idx = 0; idx < ARRAYSIZE(m_pEntries); idx++)
    {
        if( NULL != m_pEntries[idx] )
        {
            VirtualFree( m_pEntries[idx], 0, MEM_RELEASE );
            m_pEntries[idx] = NULL;
        }
    }
}


//////////////////////////////////////////////////////////////////////////////
BOOL XOCryptoDoSBlackBox::Init(
    IN DWORD dwMaxEntries,
    IN DWORD dwMaxTimeSkewInSecs,
    IN DWORD msClientRetryInterval )
{
    BOOL fResult = TRUE;
    int i,j;
    BYTE abTempPermuteTable[A_SHA_DIGEST_LEN];
    
    //
    // Validate parameters
    //
    if( ( 0 == dwMaxEntries ) || ( 0 == dwMaxTimeSkewInSecs ) || ( 0 == msClientRetryInterval ) )
    {
        XomTrace( blackbox, L_ERROR, "Error: bad Init param (%d, %d, %d)",
                   dwMaxEntries, dwMaxTimeSkewInSecs, msClientRetryInterval );
        fResult = FALSE;
        goto Exit;
    }

    m_dwMaxTimeSkewInSecs = dwMaxTimeSkewInSecs;
    m_msClientRetryInterval = msClientRetryInterval;

    //
    // Round up max entries to next higher prime from a list, and calculate the hash stride mask
    //
    DWORD dwSelectedPrimes[] =
    {
        5009, 10007, 25031, 50021, 75011, 100151, 150089, 200381, 250049, 500111, 750119,
        1000037, 1500041, 2000081, 2500049, 3000131, 4000037, 5000111, 7500221, 10000139,
        15000521, 20000003, 25000009, 30000001, 40000003, 50000017, 60000011, 70000027,
        80000023, 90000049, 100000007, 110000017, 120000007, 130000007, 140000041, 
        150000001, 160000003, 170000009, 180000017, 190000003, 200000033, 210000017, 
        220000013, 230000003, 240000011, 250000013, 260000011, 270000023, 280000027, 
        290000033, 300000007, 310000037, 320000077, 330000001, 340000019, 350000041,
        360000019, 370000003, 380000009, 390000041, 400000009,
        0xffffffff
    };

    for( i = 0; ; i++ )
    {
        if( dwMaxEntries <= dwSelectedPrimes[ i ] )
        {
            m_dwMaxEntries = dwSelectedPrimes[ i ];
            break;
        }
    }

    if( 0xffffffff == m_dwMaxEntries )
    {
        XomTrace( blackbox, L_ERROR, "Error: Init w/ max entries too large (%d)", dwMaxEntries );
        fResult = FALSE;
        goto Exit;
    }

    m_dwStrideMask = 1;

    while( m_dwStrideMask < m_dwMaxEntries / 2 )
    {
        m_dwStrideMask <<= 1;
    }

    m_dwStrideMask = ( m_dwStrideMask >> 1  ) - 1;

    //
    // Allocate the hash table memory
    //
    // Example where m_dwMaxEntries = 23, m_dwNumEntriesPerBank = 5, and # blocks = 4:
    //     Block 0 : 6 entries (6 total)
    //     Block 1 : 6 entries (12 total)
    //     Block 2 : 6 entries (18 total)
    //     Block 3 : 5 entries (23 total)
    //
    // We're going to allocate room for 6 entries, so we may overallocate by a few extra entries (# of buckets minus 
    // 1).
    //
    m_dwNumEntriesPerBank = m_dwMaxEntries / ARRAYSIZE(m_pEntries);
    if ((m_dwMaxEntries % ARRAYSIZE(m_pEntries)) != 0)
    {
        // Round up when total entries isn't a multiple of 4 
        m_dwNumEntriesPerBank++;
    }
    DWORD allocSize = m_dwNumEntriesPerBank * sizeof(HashEntry);
    XomTrace( blackbox, L_LOW, "Allocating %d blocks of size %d each", ARRAYSIZE(m_pEntries), allocSize);

    for (DWORD idx = 0; idx < ARRAYSIZE(m_pEntries); idx++)
    {
        m_pEntries[idx] = (HashEntry *) VirtualAlloc(
            NULL,
            allocSize,
            MEM_COMMIT,
            PAGE_READWRITE );

        if( NULL == m_pEntries[idx] )
        {
            XomTrace( blackbox, L_ERROR, 
                       "Error: Init failed on VirtualAlloc call %d of %d ( %d bytes ). GetLastError returned %d",
                       idx + 1,
                       ARRAYSIZE(m_pEntries),
                       allocSize,
                       GetLastError() );
            fResult = FALSE;
            goto Exit;
        }
    }


    XomTrace( blackbox, L_INFO, "Successfully allocated %d bytes",
               m_dwMaxEntries * sizeof( HashEntry ) );

    XOCryptGenRandom( g_abNameSHAKey, sizeof(g_abNameSHAKey) );
    XOCryptGenRandom( (BYTE*)g_dwSPPAPick, sizeof(g_dwSPPAPick) );

    for (i=0; i<sizeof(abTempPermuteTable); ++i)
    {
        abTempPermuteTable[i] = (BYTE)i;
    }
    for (i=0; i<sizeof(DWORD); ++i)
    {
        j = g_dwSPPAPick[i] % (A_SHA_DIGEST_LEN - i);
        g_dwSPPAPick[i] = abTempPermuteTable[j];
        while( j < (sizeof(abTempPermuteTable) - 1) )
        {
            abTempPermuteTable[j] = abTempPermuteTable[j+1];
            ++j;
        }
    }

Exit:

    return( fResult );
}


//////////////////////////////////////////////////////////////////////////////
DWORD CalculateNameSHA( LPCSTR pszName )
{
    //
    // Convert to standard (15-char max) upper case name
    //
    char szName[ XONLINE_GAMERTAG_SIZE ];
    BYTE abDigest[A_SHA_DIGEST_LEN];
    
    memset( szName, 0, sizeof( szName ) );

    for( int i = 0; i < sizeof( szName ); i++ )
    {
        if( pszName[ i ] == '\0' )
        {
            break;
        }

        szName[ i ] = (char) toupper( pszName[ i ] );
    }

    XcHMAC(g_abNameSHAKey, sizeof(g_abNameSHAKey), (BYTE*)szName, sizeof( szName ), NULL, 0, abDigest);

    return( *(DWORD *) abDigest );
}


//////////////////////////////////////////////////////////////////////////////
DWORD SPPA2DWORD( const BYTE* SPPA )
{
    BYTE abResult[sizeof(DWORD)];
    int i;
    
    for( i = 0; i < sizeof( DWORD ); i++ )
    {
        abResult[i] = SPPA[g_dwSPPAPick[i]];
    }

    return( *(DWORD *) abResult );
}


//////////////////////////////////////////////////////////////////////////////
BOOL XOCryptoDoSBlackBox::AddEntry(
    IN LPCSTR pszName,
    IN const XOCryptoSPPAStruct *pSPPA1,
    IN const XOCryptoPPAStruct *pPPA2 )
{
    BOOL fResult = TRUE;
    do
    {
        DWORD dwNameSHA;
        DWORD dwSPPA;
        DWORD dwPercentageFull = 0;
        
        if ( ! GetStats( &dwPercentageFull ) || dwPercentageFull > 98 )
        {
            fResult = FALSE;
            break;
        }

        if (pSPPA1 == NULL)
        {
            fResult = FALSE;
            break;
        }
        dwNameSHA = CalculateNameSHA( pszName );
        dwSPPA = SPPA2DWORD( pSPPA1->abSPPA );

        HashEntry *pEntry = FindEntry( dwNameSHA, dwSPPA );

        if( NULL == pEntry )
        {
            fResult = FALSE;
            break;
        }

        BOOL fEntryInUse = ( pEntry->dwNameSHA != 0 ) || ( pEntry->dwSPPA != 0 );

#if DOSBLACKBOX_USEPPA2 
        if (pPPA2 == NULL)
        {
            fResult = FALSE;
            break;
        }
        if( fEntryInUse && ( 0 != memcmp( pEntry->abPPA2, pPPA2->abPPA, PPA_DATA_LEN ) ) )
        {
            XomTrace( blackbox, L_ERROR, "AddEntry: FindEntry returned slot already in use!" );
            fResult = FALSE;
            break;
        }

        memcpy( pEntry->abPPA2, pPPA2->abPPA, PPA_DATA_LEN );
#endif

        pEntry->dwSPPA = dwSPPA;
        pEntry->dwNameSHA = dwNameSHA;

        if( !fEntryInUse )
        {
            m_dwNumEntries++;
        }
    }
    while( FALSE );

    return( fResult );
}


//////////////////////////////////////////////////////////////////////////////
BOOL TimeOutOfSkew( FILETIME ftTest, DWORD dwSkewSecs )
{
    FILETIME ftNow;
    GetSystemTimeAsFileTime( &ftNow );

    //
    // Convert time skew to 100ns units
    //
    ULONGLONG qwSkew = (ULONGLONG) dwSkewSecs * 10000000;

    return( ( *(ULONGLONG *) &ftTest < *(ULONGLONG *) &ftNow - qwSkew ) ||
            ( *(ULONGLONG *) &ftTest > *(ULONGLONG *) &ftNow + qwSkew ) );
}


//////////////////////////////////////////////////////////////////////////////
XOCryptoDoSBlackBox::BB_RESULT XOCryptoDoSBlackBox::ProcessRequest(
    IN LPCSTR pszName,
    IN const XKERB_PA_XBOX_PPA *pXboxPPA )
{
    XOCryptoDoSBlackBox::BB_RESULT res = BB_CONTINUE_PROCESSING;

    do
    {
        //
        // First check for out of range time value
        //
        if( TimeOutOfSkew( pXboxPPA->currentTime, m_dwMaxTimeSkewInSecs ) )
        {
            res = BB_BAD_TIME_RESPOND;

#if DBG
            FILETIME ftNow;
            GetSystemTimeAsFileTime( &ftNow );

            XomTrace(
                blackbox,
                L_NORMAL,
                "ProcessRequest:  time out of skew ( %I64d, %d, now=%I64d )",
                pXboxPPA->currentTime, m_dwMaxTimeSkewInSecs, ftNow );
#endif
            break;
        }

        DWORD dwNameSHA = CalculateNameSHA( pszName );

        //
        // Calculate SHA( PPA1 ) so we can find dwSPPA
        //
        A_SHA_CTX shaCtx;
        BYTE abSHA[ A_SHA_DIGEST_LEN ];

        A_SHAInit( &shaCtx );
        A_SHAUpdate( &shaCtx, (BYTE *) pXboxPPA->ppa1, sizeof( pXboxPPA->ppa1 ) );
        A_SHAFinal( &shaCtx, abSHA );

        DWORD dwSPPA = SPPA2DWORD( abSHA );

        HashEntry *pEntry = FindEntry( dwNameSHA, dwSPPA );

        if( NULL == pEntry )
        {
            XomTrace(
                blackbox,
                L_ERROR,
                "ProcessRequest: FindEntry returned NULL!!! Letting the request through!" );
            break;
        }

        //
        // First check for a complete lookup miss
        //
        if( ( 0 == pEntry->dwNameSHA ) && ( 0 == pEntry->dwSPPA ) )
        {
            res = BB_ENTRY_NOT_FOUND;

            XomTrace(
                blackbox,
                L_NORMAL,
                "ProcessRequest:  no match for Find( %x, %x ), possible hack attempt",
                dwNameSHA, dwSPPA );
            break;
        }

        assert( ( dwNameSHA == pEntry->dwNameSHA ) && ( dwSPPA == pEntry->dwSPPA ) );

#if DOSBLACKBOX_USEPPA2
        //
        // Calculate SHA( PPA2[0-8] | T )
        //
        A_SHAInit( &shaCtx );
        A_SHAUpdate( &shaCtx, (BYTE *) pEntry->abPPA2, sizeof( pEntry->abPPA2 ) );
        A_SHAUpdate( &shaCtx, (BYTE *) &pXboxPPA->currentTime, sizeof( pXboxPPA->currentTime ) );
        A_SHAFinal( &shaCtx, abSHA );

        //
        // See if the caller computed the same value
        //
        assert( sizeof( abSHA ) == sizeof( pXboxPPA->sppa2 ) );

        if( 0 != memcmp( abSHA, pXboxPPA->sppa2, sizeof( abSHA ) ) )
        {
            res = BB_SPPA2T_MISMATCH;

            XomTrace(
                blackbox,
                L_NORMAL,
                "ProcessRequest:  SPPA2T for ( %x, %x ) didn't match, possible hack attempt",
                dwNameSHA, dwSPPA );
            break;
        }
#endif

    }
    while( FALSE );

    return( res );
}


//////////////////////////////////////////////////////////////////////////////
BOOL XOCryptoDoSBlackBox::GetStats(
    OUT DWORD *pdwPercentFull /* 0 - 100 */ )
{
    if( NULL == pdwPercentFull )
    {
        return( FALSE );
    }

    *pdwPercentFull = 0;

    if( m_dwMaxEntries != 0 )
    {
        *pdwPercentFull = (DWORD)( (__int64) m_dwNumEntries * 100 / (__int64) m_dwMaxEntries );
    }

    return( TRUE );
}


//////////////////////////////////////////////////////////////////////////////
BOOL XOCryptoDoSBlackBox::GetStats(
    OUT DWORD *pdwPercentFull,
    OUT DWORD *pdwNumEntries )
{
    if( NULL == pdwPercentFull )
    {
        return( FALSE );
    }
    if( NULL == pdwNumEntries )
    {
        return( FALSE );
    }

    *pdwPercentFull = 0;

    if( m_dwMaxEntries != 0 )
    {
        *pdwPercentFull = (DWORD)( (__int64) m_dwNumEntries * 100 / (__int64) m_dwMaxEntries );
    }

    // set the number of entries.
    *pdwNumEntries = m_dwNumEntries;
    
    return( TRUE );
}

//////////////////////////////////////////////////////////////////////////////
XOCryptoDoSBlackBox::HashEntry *XOCryptoDoSBlackBox::FindEntry( DWORD dwNameSHA, DWORD dwSPPA )
{
    DWORD dwSlotNum = ( dwNameSHA ^ dwSPPA ) % m_dwMaxEntries;

    assert( ( m_dwStrideMask != 0 ) && ( m_dwStrideMask < m_dwMaxEntries ) );
    DWORD dwStride = ( ( dwNameSHA ^ dwSPPA ) & m_dwStrideMask ) + 1;

    do
    {
        DWORD dwBankNum = dwSlotNum % ARRAYSIZE(m_pEntries);
        DWORD dwIdxNum = dwSlotNum / ARRAYSIZE(m_pEntries);
        HashEntry *pEntry = m_pEntries[dwBankNum] + dwIdxNum;

        if( ( ( dwNameSHA == pEntry->dwNameSHA ) && ( dwSPPA == pEntry->dwSPPA ) ) ||
            ( ( 0 == pEntry->dwNameSHA ) && ( 0 == pEntry->dwSPPA ) ) )
        {
            return( pEntry );
        }

        dwSlotNum += dwStride;

        if( dwSlotNum >= m_dwMaxEntries )
        {
            dwSlotNum -= m_dwMaxEntries;
        }
    }
    while( TRUE );

    return( NULL );
}


//////////////////////////////////////////////////////////////////////////////
BOOL XOCryptoDoSBlackBox::QueryByName(
    IN LPCSTR pszName,
    OUT HashEntry *ppEntryArray,
    OUT DWORD *pcEntryArray )
{
    BOOL bRes = FALSE;
    DWORD dwEntries = 0;

    if ( NULL == pszName || NULL == ppEntryArray || NULL == pcEntryArray || *pcEntryArray < 1 )
    {
        bRes = FALSE;
        goto Exit;
    }

    DWORD dwNameSHA = CalculateNameSHA( pszName );
    DWORD i;
        
    for ( i=0; i < m_dwMaxEntries; i++ )
    {
        // check the the SHA match.
        DWORD dwBankNum = i % ARRAYSIZE(m_pEntries);
        DWORD dwIdxNum = i / ARRAYSIZE(m_pEntries);
        HashEntry *pEntry = m_pEntries[dwBankNum] + dwIdxNum;
        if ( pEntry->dwNameSHA == dwNameSHA )
        {
            // copy the rest of the struct into the entry array.
            memcpy( &(ppEntryArray[dwEntries]), pEntry, sizeof(HashEntry) );

            dwEntries++;
            if ( dwEntries == *pcEntryArray )
            {
                goto Exit;
            }
        }
    }

    // set the number of entries we've found.
    *pcEntryArray = dwEntries;
    bRes = ( 0 != *pcEntryArray );
    
Exit:    
    return( bRes );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\blacklist\XListMgr.cs ===
using System;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Security.Principal;
using System.Threading;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;

#if !NOCSPP
[assembly: XomAreaDefinition(XomAreaName.xlisttrace)]
#endif

namespace xonline.common.blacklist
{
    /// <summary>
    /// XList provides a generic base implementation of a class for storing 
    /// the state of a set of blacklisted items. 
    /// </summary>
    public abstract class XList<TKey>
    {
        public string           _storedProc;
        public DateTime         _lastLoadTime;
        public bool             _bEndThread;
        public string           _identifier;
        public XboxLiveThread   _loaderThread;

        private WindowsIdentity _threadIdentity;
        private AutoResetEvent  _loadcomplete;
        private AutoResetEvent  _wakeup;
        private string         _waitTimeSetting;

        protected XList(string procName, string waitTimeSetting, string identifier)
            : this(procName, waitTimeSetting, identifier, true) { }

        protected XList(string procName, string waitTimeSetting, string identifier, bool startThread)
        {
            // create the hash table.
            _list = new HashSet<TKey>();

            _bEndThread = false;
            _lastLoadTime = new DateTime(1753, 1, 1);
            _wakeup = new AutoResetEvent( false );
            _loadcomplete = new AutoResetEvent( false );
            _storedProc = procName;
            _waitTimeSetting = waitTimeSetting;
            _identifier = identifier;

            _threadIdentity = WindowsIdentity.GetCurrent();
            Xom.Trace(XomAreaName.xlisttrace, LogLevel.L_LOW, "XList:  " + _identifier + " Constructor.  Running As: " + _threadIdentity.Name );
            _loaderThread = new XboxLiveThread( new System.Threading.ThreadStart( HandleThread ));

            if (startThread)
            {
                StartThreadAndWait();
            }
        }

        protected void StartThreadAndWait()
        {
            _loaderThread.Start();

            // wait for the initial load to finish.
            _loadcomplete.WaitOne();
        }

        public int _waitTimeInMilliSecs
        {
            get
            {
                return Int32.Parse(Config.GetSetting(_waitTimeSetting));
            }
        }

        /// <summary>
        /// Main thread to read database tables for blacklist information.
        /// </summary>
        public void HandleThread()
        {
            WindowsImpersonationContext ctx = _threadIdentity.Impersonate();

            // loop until this is over.
            while ( !_bEndThread )
            {
                try
                {
                    Xom.Trace(XomAreaName.xlisttrace, LogLevel.L_LOW, "XList:  " + _identifier + " thread is alive.  Running As: " + WindowsIdentity.GetCurrent().Name );

                    using (SqlConnection conn = new SqlConnection(ConfigUtil.NpdbConnectionString))
                    {
                        conn.Open();

                        using (SqlCommand cmd = conn.CreateCommand())
                        {
                            cmd.CommandText = _storedProc;
                            cmd.CommandType = CommandType.StoredProcedure;

                            // NOTE: _lastLoadTime is never updated.  This causes the entire list to be
                            // loaded each time which is what we're expecting to happen.  
                            cmd.Parameters.Add("@dt_last", SqlDbType.DateTime).Value = _lastLoadTime;

                            AddExtraParams(cmd);

                            SqlDataReader r = cmd.ExecuteReader();
                            HashSet<TKey> list = new HashSet<TKey>();
                            
                            // Read all the entries into the new hashTable
                            while (r.Read())
                            {
                                ReadEntryFromDB(list, r);
                            }

                            // All consumers of this list assume that it can change 
                            // without warning and handle it appropriately.  Only a 
                            // single thread performs this update so there is no 
                            // concern for contention here.
                            _list = list;

                            Xom.Trace(XomAreaName.xlisttrace, LogLevel.L_LOW, "XList: " + _identifier + " thread:  Load Complete." );
                        }
                    }
                }
                catch ( Exception e )
                {
                    Xom.NtEvent(XEvent.Id.COMMON_COMM_6, e, "XList: " + _identifier + " thread error.");
                    Xom.Trace(XomAreaName.xlisttrace, LogLevel.L_ERROR, "XList: " + _identifier + " thread error:  " + e.ToString() );
                }

                // tell everyone listening that I am complete!!!
                _loadcomplete.Set();

                // wait for the time to expire
                _wakeup.WaitOne( _waitTimeInMilliSecs, false );

            }
            Xom.Trace(XomAreaName.xlisttrace, LogLevel.L_LOW, "XList:  " + _identifier + " thread exiting." );

            //  release the thread identity.
            ctx.Undo();
        }

        /// <summary>
        /// Forces the list to reload all it's data from the database.
        /// </summary>
        public void ForceLoad()
        {
            if ( _wakeup.Set() )
            {
                _loadcomplete.WaitOne();

            }
            else
            {
                Xom.NtEvent(XEvent.Id.COMMON_CODE_20, "XList: " + _identifier + " thread error:  Failed to wake up loader thread." );
                Xom.Trace(XomAreaName.xlisttrace, LogLevel.L_ERROR, "XList: " + _identifier + " thread error:  Failed to wake up loader thread." );
            }
        }

        /// <summary>
        /// Determines if a given item is blacklisted
        /// </summary>
        /// <param name="key">The item to check</param>
        /// <returns>True if the item is blacklisted, false otherwise</returns>
        public Boolean IsBlackListed(TKey key)
        {
            return _list.Contains(key);
        }

        /// <summary>
        /// The list of all the blacklisted values and their blacklist state
        /// </summary>
        protected volatile HashSet<TKey> _list;

        /// <summary>
        /// When overridden in a derived class, reads an entry from the database
        /// and stores it in the provided list
        /// </summary>
        /// <param name="list">The list to add the entry to</param>
        /// <param name="rs">The data reader to read the entry from</param>
        protected abstract void ReadEntryFromDB(HashSet<TKey> list, SqlDataReader rs);

        /// <summary>
        /// When overridden in a derived class, adds any additional parameters to
        /// the SQL command that is used to retrieved the blacklist data from the
        /// database
        /// </summary>
        /// <param name="cmd">The SQL command to add the parameters to</param>
        protected virtual void AddExtraParams(SqlCommand cmd) { }
    }

    /// <summary>
    /// Blacklist class to handle machine banning
    /// </summary>
    public class XSigMachineBlackList: XList<UInt64>
    {
        public XSigMachineBlackList(string waitTimeSetting) : base("p_xsig_get_blacklisted_machines", waitTimeSetting, "Machine") { }

        public bool IsBlackListed( byte[] machineID )
        {
            Byte[] reversed = (Byte[])machineID.Clone();

            Array.Reverse(reversed);            
            if (reversed.Length < 8)
            {
                Array.Resize(ref reversed, 8);
            }
            
            ulong machinePuid = BitConverter.ToUInt64(reversed, 0);

            return IsBlackListed(machinePuid);
        }

        /// <summary>
        /// Reads a machine blacklist entry from the database and stores it
        /// </summary>
        /// <param name="list">The list to add the entry to</param>
        /// <param name="rs">The data reader to read the entry from</param>
        protected override void ReadEntryFromDB(HashSet<UInt64> list, SqlDataReader rs)
        {
            ulong machinePuid = 0;
            byte isBanned = 0;

            // read the machine PUID and the banning flag.
            machinePuid = (ulong)rs.GetInt64( 0 );
            isBanned = rs.GetByte( 1 );

            if (isBanned != 0)
            {
                list.Add(machinePuid);
            }

            Xom.Trace(XomAreaName.xlisttrace, LogLevel.L_LOW, "XSigMachineBlackList:  Machine: 0x{0:X16} loaded.", machinePuid);
        }
    }

    public struct XSigDigest
    {
        public byte[] digestBytes;
    }

    public enum DigestRevocationDeliveryType : byte
    {
        None = 0,
        RevocationList = 1,
        ServerSideCheck = 2,
    }

    public enum DigestRevocationStatus : byte
    {
        NotBlacklisted = 0,
        Blacklisted = 1,
    }

    /// <summary>
    /// Blacklist class to handle digest banning
    /// </summary>
    public class XSigDigestBlackList: XList<ByteArray>
    {
        public XSigDigestBlackList(string waitTimeSetting, DigestRevocationDeliveryType deliveryType)
            : base("p_xsig_get_blacklisted_digests", waitTimeSetting, "Digest", false)
        {
            _deliveryType = deliveryType;
            StartThreadAndWait();
        }

        public bool IsBlackListed(byte[] digest)
        {
            return IsBlackListed(new ByteArray(digest));
        }

        /// <summary>
        /// Retrieves all of the banned digests in the blacklist
        /// </summary>
        /// <returns>An array containing all of the banned digests in the digest blacklist table</returns>
        public XSigDigest[] GetDigestList()
        {
            HashSet<ByteArray> list = _list;
            List<XSigDigest> results = new List<XSigDigest>(list.Count);
            
            foreach(var entry in list)
            {
                XSigDigest digest;
                digest.digestBytes = entry.Bytes;

                if(digest.digestBytes.Length == XOn.REVOCATION_LIST_ENTRY_DIGEST_SIZE)
                {
                    results.Add(digest);
                }
            }

            return results.ToArray();
        }

        /// <summary>
        /// Reads a digest blacklist entry from the database and stores it
        /// </summary>
        /// <param name="list">The list to add the entry to</param>
        /// <param name="rs">The data reader to read the entry from</param>
        protected override void ReadEntryFromDB(HashSet<ByteArray> list, SqlDataReader rs)
        {
            byte[] digest = null;
            byte isBanned = 0;
            ByteArray key = null;

            // read the digest and the banning flag.
            int digestLen = (int)rs.GetBytes(0, 0, null, 0, 0);
            digest = new byte[digestLen];
            rs.GetBytes(0, 0, digest, 0, digestLen);
            isBanned = rs.GetByte(1);
            key = new ByteArray(digest);

            if (isBanned != 0)
            {
                list.Add(key);
            }

            Xom.Trace(XomAreaName.xlisttrace, LogLevel.L_LOW, "XSigDigestBlackList:  Digest:  {0} loaded.  Length = {1}", key, key.Bytes.Length);
        }

        protected override void AddExtraParams(SqlCommand cmd)
        {
            cmd.Parameters.Add("@ti_revocation_delivery_type", SqlDbType.TinyInt).Value = _deliveryType;
        }
        
        private readonly DigestRevocationDeliveryType _deliveryType;
    }

    /// <summary>
    /// Blacklist class to handle user banning
    /// </summary>
    public class XSigUserBlackList: XList<UInt64>
    {
        public XSigUserBlackList(string waitTimeSetting) : base("p_xsig_get_blacklisted_users", waitTimeSetting, "User") { }

        /// <summary>
        /// Reads a user blacklist entry from the database and stores it
        /// </summary>
        /// <param name="list">The list to add the entry to</param>
        /// <param name="rs">The data reader to read the entry from</param>
        protected override void ReadEntryFromDB(HashSet<UInt64> list, SqlDataReader rs)
        {
            ulong userPuid = 0;
            byte isBanned = 0;

            // read the user puid and the banning flag.
            userPuid = (ulong)rs.GetInt64( 0 );
            isBanned = rs.GetByte( 1 );

            if (isBanned != 0)
            {
                list.Add(userPuid);
            }

            Xom.Trace(XomAreaName.xlisttrace, LogLevel.L_LOW, "XSigUserBlackList:  User: 0x{0:X16} loaded.", userPuid);
        }
    }
    
    /// <summary>
    /// Blacklist class to handle title banning
    /// </summary>
    public class XSigTitleBlackList: XList<String>
    {
        public XSigTitleBlackList(string waitTimeSetting) : base("p_xsig_get_blacklisted_titles", waitTimeSetting, "Title") { }

        /// <summary>
        /// Determines if a given title id/version pair is blacklisted. Constructs
        /// a string key to check against the underlying list
        /// </summary>
        /// <param name="titleid">The title id to check</param>
        /// <param name="titleversion">The title version to check</param>
        /// <returns>True if the title is banned, false otherwise</returns>
        public bool IsBlackListed(uint titleid, uint titleversion)
        {
            string key = titleid.ToString("X") + "|" + titleversion.ToString("X");
            return IsBlackListed(key);
        }

        /// <summary>
        /// Reads a title blacklist entry from the database and stores it
        /// </summary>
        /// <param name="list">The list to add the entry to</param>
        /// <param name="rs">The data reader to read the entry from</param>
        protected override void ReadEntryFromDB(HashSet<String> list, SqlDataReader rs)
        {
            uint titleid = 0;
            uint titleversion = 0;
            byte isBanned = 0;
            string key = "";

            // get the result from the database for title id and version
            titleid = (uint)rs.GetInt32( 0 );
            titleversion = (uint)rs.GetInt32( 1 );
            isBanned = rs.GetByte( 2 );

            // set the key.
            key = titleid.ToString("X") + "|" + titleversion.ToString("X");

            if (isBanned != 0)
            {
                list.Add(key);
            }

            Xom.Trace(XomAreaName.xlisttrace, LogLevel.L_LOW, "XSigTitleBlackList:  Title: 0x{0:X8} Title Version: 0x{1:X8} loaded.", titleid, titleversion);
        }
    }

    public class XSigListMgr
    {
        public const string c_defaultReloadInterval = "300000";  // 5 minutes

        protected static int _isInit = 0;

        private static XSigTitleBlackList    _titleBlackList     = null;
        private static XSigUserBlackList     _userBlackList      = null;
        private static XSigDigestBlackList   _digestBlackList    = null;
        private static XSigMachineBlackList  _machineBlackList   = null;

        public XSigListMgr(){}

        static public void Init()
        {
            if ( _isInit == 0 )
            {
                if ( Interlocked.CompareExchange( ref _isInit, 1, 0 ) == 1 )
                {
                    return;
                }
            }
            else
            {
                return;
            }

            // create the lists with the config settings.
            //   default all to 1 minute if the value is invalid.

            try
            {
                // set up title list.
                _titleBlackList = new XSigTitleBlackList( Setting.signature_titleReloadInterval );

                // set up user list
                _userBlackList = new XSigUserBlackList( Setting.signature_userReloadInterval );

                // set up digest list.
                _digestBlackList = new XSigDigestBlackList( Setting.signature_digestReloadInterval, DigestRevocationDeliveryType.ServerSideCheck);

                // set up machine list.
                _machineBlackList = new XSigMachineBlackList( Setting.signature_machineReloadInterval );

            }
            catch ( Exception e )
            {
                Xom.Trace(XomAreaName.xlisttrace, LogLevel.L_ERROR, "XSigListMgr:  Invalid config setting.  Please ensure all values are integers. \r\nMessage:\r\n" + e.ToString() );
                throw new XRLException( HResult.XONLINE_E_SERVER_CONFIG_ERROR, XEvent.Id.COMMON_CODE_117, "XSigListMgr:  Invalid config setting.  Please ensure all values are integers. \r\n", e );
            }

        }

        static public XSigTitleBlackList TitleBlackList
        {
            get { return _titleBlackList; }
        }

        static public XSigUserBlackList UserBlackList
        {
            get { return _userBlackList; }
        }

        static public XSigDigestBlackList DigestBlackList
        {
            get { return _digestBlackList; }
        }

        static public XSigMachineBlackList MachineBlackList
        {
            get { return _machineBlackList; }
        }

    }

    public class XbosListMgr
    {
        public const string c_defaultReloadInterval = "300000";  // 5 minutes

        protected static int _isInit = 0;

        private static XSigDigestBlackList   _digestBlackList    = null;

        public XbosListMgr(){}

        static public void Init()
        {
            if ( _isInit == 0 )
            {
                if ( Interlocked.CompareExchange( ref _isInit, 1, 0 ) == 1 )
                {
                    return;
                }
            }
            else
            {
                return;
            }

            // create the lists with the config settings.
            //   default all to 1 minute if the value is invalid.

            try
            {
                // set up digest list.
                _digestBlackList = new XSigDigestBlackList( Setting.signature_digestReloadInterval, DigestRevocationDeliveryType.RevocationList);
            }
            catch ( Exception e )
            {
                Xom.Trace(XomAreaName.xlisttrace, LogLevel.L_ERROR, "XbosListMgr:  Invalid config setting.  Please ensure all values are integers. \r\nMessage:\r\n" + e.ToString() );
                throw new XRLException( HResult.XONLINE_E_SERVER_CONFIG_ERROR, XEvent.Id.COMMON_CODE_118, "XbosListMgr:  Invalid config setting.  Please ensure all values are integers. \r\n", e );
            }

        }

        static public XSigDigestBlackList DigestBlackList
        {
            get { return _digestBlackList; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\crypto\helperlib\dvt\stdafx.h ===
// stdafx.h : include file for standard system include files,
// or project specific include files that are used frequently, but
// are changed infrequently
//

#include <windows.h>
#include <wincrypt.h>
#include <stdio.h>
#include <atlbase.h>
#include <atlcoll.h>
#include <atlstr.h>
#include <atlconv.h>
#include <assert.h>

#include "wsockntp.h"
#include "xonlinep.h"
#include "xalloc.h"
#include "cryptohelper.h"

#include "cpl.h"

// TODO: reference additional headers your program requires here
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\crypto\helperlib\dvt\dvt.cpp ===
// This is the main project file for VC++ application project 
// generated using an Application Wizard.

#include "stdafx.h"

//  Duplicated from cryptohelper.cpp, not to be found in any header file.

struct KEY_HEADER
{
    BLOBHEADER blob;
    RSAPUBKEY  rsa;
};


void TC_ConvertKeyPubBsafeToCspImport_Pos()
{
    CXoCryptoCspPk csp;
    BYTE* pCspImport;
    DWORD dwCspImport;

    DWORD dwPubKeySize;
    DWORD dwPrvKeySize;
    DWORD dwModBits = 1024;
    BSafeComputeKeySizes(&dwPubKeySize, &dwPrvKeySize, &dwModBits);

    BYTE* pPubKey = new BYTE[dwPubKeySize];
    BYTE* pPrvKey = new BYTE[dwPrvKeySize];
    BSafeMakeKeyPair((BSAFE_PUB_KEY*)pPubKey, (BSAFE_PRV_KEY*)pPrvKey, 1024);

    pCspImport = new BYTE[sizeof(KEY_HEADER) + dwPubKeySize];
    memset(pCspImport, 0, sizeof(KEY_HEADER) + dwPubKeySize);
    dwCspImport = sizeof(KEY_HEADER) + dwPubKeySize;

    bool bReturn = csp.ConvertKeyPubBsafeToCspImport(
        pPubKey,
        CXoCryptoCspPk::KeyPurposeEncrypt,
        pCspImport,
        &dwCspImport);

    printf("Test case TC_ConvertKeyPubBsafeToCspImport_Pos %s.\r\n", bReturn ? "succeeded" : "failed");

    delete [] pPubKey;
    delete [] pPrvKey;
    delete [] pCspImport;
}

void TC_ConvertKeyPubBsafeToCspImport_Overflow_48758()
{
    CXoCryptoCspPk csp;
    BYTE* pCspImport;
    DWORD dwCspImport;

    DWORD dwPubKeySize;
    DWORD dwPrvKeySize;
    DWORD dwModBits = 1024;
    BSafeComputeKeySizes(&dwPubKeySize, &dwPrvKeySize, &dwModBits);

    BYTE* pPubKey = new BYTE[dwPubKeySize];
    BYTE* pPrvKey = new BYTE[dwPrvKeySize];
    BSafeMakeKeyPair((BSAFE_PUB_KEY*)pPubKey, (BSAFE_PRV_KEY*)pPrvKey, 1024);

    ((BSAFE_PUB_KEY*)pPubKey)->keylen = 0xFFFFFFFF;

    pCspImport = new BYTE[sizeof(KEY_HEADER) + dwPubKeySize];
    memset(pCspImport, 0, sizeof(KEY_HEADER) + dwPubKeySize);
    dwCspImport = sizeof(KEY_HEADER) + dwPubKeySize;

    bool bReturn = csp.ConvertKeyPubBsafeToCspImport(
        pPubKey,
        CXoCryptoCspPk::KeyPurposeEncrypt,
        pCspImport,
        &dwCspImport);

    printf("Test case TC_ConvertKeyPubBsafeToCspImport_Pos %s.\r\n", bReturn ? "failed" : "succeeded");

    delete [] pPubKey;
    delete [] pPrvKey;
    delete [] pCspImport;
}

void TC_ConvertKeyPrvBsafeToCspImport_Pos()
{
    CXoCryptoCspPk csp;
    BYTE* pCspImport;
    DWORD dwCspImport;

    DWORD dwPubKeySize;
    DWORD dwPrvKeySize;
    DWORD dwModBits = 1024;
    BSafeComputeKeySizes(&dwPubKeySize, &dwPrvKeySize, &dwModBits);

    BYTE* pPubKey = new BYTE[dwPubKeySize];
    BYTE* pPrvKey = new BYTE[dwPrvKeySize];
    BSafeMakeKeyPair((BSAFE_PUB_KEY*)pPubKey, (BSAFE_PRV_KEY*)pPrvKey, 1024);

    pCspImport = new BYTE[sizeof(KEY_HEADER) + dwPrvKeySize];
    memset(pCspImport, 0, sizeof(KEY_HEADER) + dwPrvKeySize);
    dwCspImport = sizeof(KEY_HEADER) + dwPrvKeySize;

    bool bReturn = csp.ConvertKeyPrvBsafeToCspImport(
        pPrvKey,
        CXoCryptoCspPk::KeyPurposeEncrypt,
        pCspImport,
        &dwCspImport);

    printf("Test case TC_ConvertKeyPrvBsafeToCspImport_Pos %s.\r\n", bReturn ? "succeeded" : "failed");

    delete [] pPubKey;
    delete [] pPrvKey;
    delete [] pCspImport;
}

void TC_ConvertKeyPrvBsafeToCspImport_Overflow_48759()
{
    CXoCryptoCspPk csp;
    BYTE* pCspImport;
    DWORD dwCspImport;

    DWORD dwPubKeySize;
    DWORD dwPrvKeySize;
    DWORD dwModBits = 1024;
    BSafeComputeKeySizes(&dwPubKeySize, &dwPrvKeySize, &dwModBits);

    BYTE* pPubKey = new BYTE[dwPubKeySize];
    BYTE* pPrvKey = new BYTE[dwPrvKeySize];
    BSafeMakeKeyPair((BSAFE_PUB_KEY*)pPubKey, (BSAFE_PRV_KEY*)pPrvKey, 1024);

    ((BSAFE_PRV_KEY*)pPrvKey)->keylen = 0xFFFFFFFF;

    pCspImport = new BYTE[sizeof(KEY_HEADER) + dwPrvKeySize];
    memset(pCspImport, 0, sizeof(KEY_HEADER) + dwPrvKeySize);
    dwCspImport = sizeof(KEY_HEADER) + dwPrvKeySize;

    bool bReturn = csp.ConvertKeyPrvBsafeToCspImport(
        pPrvKey,
        CXoCryptoCspPk::KeyPurposeEncrypt,
        pCspImport,
        &dwCspImport);

    printf("Test case TC_ConvertKeyPrvBsafeToCspImport_Pos %s.\r\n", bReturn ? "failed" : "succeeded");

    delete [] pPubKey;
    delete [] pPrvKey;
    delete [] pCspImport;
}

void ShowBBStats(XOCryptoDoSBlackBox *pbb)
{
    DWORD pctFull = 0;
    DWORD numEntries = 0;
    pbb->GetStats(&pctFull, &numEntries);
    printf("BlackBox stats: %d%% full, %d entries\n", pctFull, numEntries);
}

void CalcBBInfoFromIndex(DWORD idx, LPSTR pszName, BYTE * ppa1)
{
    sprintf(pszName, "x%d", idx);
    *((DWORD*)ppa1) = idx;
}

void CalcBBInfoFromIndex(DWORD idx, LPSTR pszName, BYTE * ppa1, BYTE * sppa1)
{
    CalcBBInfoFromIndex(idx, pszName, ppa1);
    
    A_SHA_CTX shaCtx;
    A_SHAInit( &shaCtx );
    A_SHAUpdate( &shaCtx, (BYTE *)ppa1, XONLINE_PPA_HASH_SIZE );
    A_SHAFinal( &shaCtx, sppa1);
}

void TC_BlackBox_Pos(DWORD dwMaxEntries)
{
    printf("Running TC_BlackBox_Pos for %d entries\n", dwMaxEntries);
    
    BOOL bReturn = FALSE;
    XOCryptoDoSBlackBox bb;
    
    CHECK_BOOL(bReturn = bb.Init(
        dwMaxEntries,
        60,     // timeskew in sec
        1000));  // retry interval in ms

    cpl_TimerStart(FALSE);

    // Populate 1 entry, then find a different entry, and repeat.

    char                name[16];
    XOCryptoSPPAStruct  sppa1;
    XKERB_PA_XBOX_PPA   xboxppa;
    XOCryptoDoSBlackBox::BB_RESULT bbRes;

    DWORD               lastPct = 0;
    DWORD               idxAdd = 0;
    DWORD               idxProcess = 0;
    for (idxAdd = 0; idxAdd < dwMaxEntries; idxAdd++)
    {
        CalcBBInfoFromIndex(idxAdd, name, xboxppa.ppa1, sppa1.abSPPA);
        
        DWORD pctFull = 0;
        DWORD numEntries = 0;
        bb.GetStats(&pctFull, &numEntries);

        if (pctFull > 98)
        {
            // Expect to fail the add
            CHECK_BOOL(!(bReturn = bb.AddEntry(
                        name,
                        &sppa1,
                        NULL)));
        }
        else
        {
            // Add entry idxAdd
            CalcBBInfoFromIndex(idxAdd, name, xboxppa.ppa1, sppa1.abSPPA);
            CHECK_BOOL(bReturn = bb.AddEntry(
                    name,
                    &sppa1,
                    NULL));
        }
        
        if (pctFull > lastPct)
        {
            double elapsedSec = cpl_TimerEnd(FALSE);
            printf("%.6f seconds, ", elapsedSec); 
            ShowBBStats(&bb);
            cpl_TimerStart(FALSE);
        }
        lastPct = pctFull;

        // Process entry idxProcess (positive)
        idxProcess = (idxProcess + 3) % (idxAdd + 1);
        CalcBBInfoFromIndex(idxProcess, name, xboxppa.ppa1);
        GetSystemTimeAsFileTime(&xboxppa.currentTime);

        bbRes = bb.ProcessRequest(
            name,
            &xboxppa);

        // Should have found it
        CHECK_BOOL(bbRes == XOCryptoDoSBlackBox::BB_CONTINUE_PROCESSING);
        
        // Process entry idxProcess (negative)
        idxProcess = (idxProcess + 3) % (idxAdd + 1);
        name[0] = 'z';
        bbRes = bb.ProcessRequest(
            name,
            &xboxppa);

        // Should not have found it
        CHECK_BOOL(bbRes == XOCryptoDoSBlackBox::BB_ENTRY_NOT_FOUND);
    }
    
    bReturn = TRUE;

Exit:

    if (!bReturn)
    {
        ShowBBStats(&bb);
    }

    printf("Test case TC_BlackBox_Pos %s.\r\n", bReturn ? "succeeded" : "failed");
}



int __cdecl _tmain()
{
    cpl_Init();

    TC_BlackBox_Pos(5009);  // 5009 is smallest defined prime

    // 80 MB
    TC_BlackBox_Pos(10000000);

    // 1.6 GB 
    //TC_BlackBox_Pos(200000000);

    TC_ConvertKeyPubBsafeToCspImport_Pos();
    TC_ConvertKeyPubBsafeToCspImport_Overflow_48758();

    TC_ConvertKeyPrvBsafeToCspImport_Pos();
    TC_ConvertKeyPrvBsafeToCspImport_Overflow_48759();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\crypto\helperwrapper\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\crypto\helperlibtest\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by XStorageSmoke.rc
// Copyright (c) Microsoft Corporation.  All rights reserved

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\crypto\helperlib\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_cryptohelper_none_12.4.56.0_none_5e2e2d0461d96a69
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_cryptohelper_no-public-key_12.4.56.0_x-ww_6b885985
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=cryptohelper
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_cryptohelper_no-public-key_12.4.56.0_x-ww_6b885985
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_cryptohelper_no-public-key_12.4.56.0_x-ww_6b885985.manifest
XP_MANIFEST_PATH=manifests\x86_cryptohelper_no-public-key_12.4.56.0_x-ww_6b885985.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_cryptohelper_no-public-key_12.4.56.0_x-ww_6b885985.cat
XP_CATALOG_PATH=manifests\x86_cryptohelper_no-public-key_12.4.56.0_x-ww_6b885985.cat
XP_PAYLOAD_PATH=x86_cryptohelper_no-public-key_12.4.56.0_x-ww_6b885985
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=cryptohelper,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\crypto\helperlib\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_cryptohelper_none_12.4.56.0_none_5e2e2d0461d96a69
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_cryptohelper_no-public-key_12.4.56.0_x-ww_6b885985
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=cryptohelper
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_cryptohelper_no-public-key_12.4.56.0_x-ww_6b885985
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_cryptohelper_no-public-key_12.4.56.0_x-ww_6b885985.manifest
XP_MANIFEST_PATH=manifests\x86_cryptohelper_no-public-key_12.4.56.0_x-ww_6b885985.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_cryptohelper_no-public-key_12.4.56.0_x-ww_6b885985.cat
XP_CATALOG_PATH=manifests\x86_cryptohelper_no-public-key_12.4.56.0_x-ww_6b885985.cat
XP_PAYLOAD_PATH=x86_cryptohelper_no-public-key_12.4.56.0_x-ww_6b885985
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=cryptohelper,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\crypto\helperwrapper\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\crypto\helperlibtest\CryptoHelperTest.cpp ===
//---------------------------------------------------------------------------------
//
//    Copyright (C) Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------------


//------------------------------------------------------------------
//  INCLUDES
//------------------------------------------------------------------
#include <windows.h>
#include <wincrypt.h>
#include <stdio.h>
#include <atlbase.h>
#include <atlcoll.h>
#include <atlstr.h>
#include <atlconv.h>
#include <assert.h>

#include "wsockntp.h"
#include "xonlinep.h"
#include "xalloc.h"
#include "cryptohelper.h"

//------------------------------------------------------------------
//  main()  : program main exe path.
//------------------------------------------------------------------
int __cdecl main(int argc, char* argv[])
{
    HRESULT hr;
    
    XOCryptoKeyEncryptionKey keyEncKey;

    XOCryptoKeyStruct rawKey, encKey, rawKey2;

    XOCryptoMasterKeyEncryptedStruct freqKey1, freqKey2;
    
    XOCryptoIVStruct iv;

    BOOL fOK;
    
    fOK = XOCryptGenRandom( (BYTE*)&keyEncKey, sizeof(keyEncKey) );
    assert(fOK);

    XOCryptoKeyEncryptionHelper* pKey = new XOCryptoKeyEncryptionHelper( &keyEncKey );

    fOK = pKey->GenerateNewKey( &iv, &encKey, &rawKey );
    assert(fOK);

    pKey->DecryptKey( &iv, &encKey, &rawKey2 );

    assert( memcmp( &rawKey2, &rawKey, sizeof(rawKey)) == 0 );

    freqKey1.dwKeyLen = 40;
    fOK = XOCryptGenRandom( freqKey1.abKey, freqKey1.dwKeyLen );
    assert(fOK);

    memcpy( &freqKey2, &freqKey1, sizeof(freqKey2) );
    
#if 0
    hr = EncryptWithMasterKey( 1, &freqKey1 );
    assert( SUCCEEDED(hr) );

    printf( "Encrypted size if %d\n", freqKey1.dwKeyLen );
    
    hr = DecryptWithMasterKey( 1, &freqKey1 );
    assert( SUCCEEDED(hr) );
#endif

    assert( freqKey1.dwKeyLen == freqKey2.dwKeyLen );
    assert( memcmp( freqKey1.abKey, freqKey2.abKey, freqKey1.dwKeyLen ) == 0 );
    
    //
    // Test out XOCryptoDosBlackBox functionality
    //
    do
    {
        XOCryptoDoSBlackBox bbox;

        if( !bbox.Init( 123456, 5, 5000 ) )
        {
            break;
        }

        BOOL fOk;
        XOCryptoDoSBlackBox::BB_RESULT res;

        XOCryptoSPPAStruct sppa1;
        
        XOCryptoPPAStruct ppa2;
        memcpy( ppa2.abPPA, "abcd1234", sizeof( ppa2.abPPA ) );

        XKERB_PA_XBOX_PPA xp;
        GetSystemTimeAsFileTime( &xp.currentTime );

        memcpy( xp.ppa1, "123456789a123456789a", sizeof( xp.ppa1 ) );

        A_SHA_CTX shaCtx;
        BYTE abSHA[ A_SHA_DIGEST_LEN ];

        A_SHAInit( &shaCtx );
        A_SHAUpdate( &shaCtx, xp.ppa1, sizeof( xp.ppa1 ) );
        A_SHAFinal( &shaCtx, sppa1.abSPPA );

        A_SHAInit( &shaCtx );
        A_SHAUpdate( &shaCtx, ppa2.abPPA, sizeof( ppa2.abPPA ) );
        A_SHAUpdate( &shaCtx, (BYTE *) &xp.currentTime, sizeof( xp.currentTime ) );
        A_SHAFinal( &shaCtx, xp.sppa2 );

        //
        // First do an add and an immediate lookup
        //
        fOk = bbox.AddEntry( "AbcDef", &sppa1, &ppa2 );
        res = bbox.ProcessRequest( "AbcDef", &xp );

        assert( fOk && ( XOCryptoDoSBlackBox::BB_CONTINUE_PROCESSING == res ) );

        //
        // Double-check case sensitivity
        //
        res = bbox.ProcessRequest( "ABcDeF", &xp );

        assert( XOCryptoDoSBlackBox::BB_CONTINUE_PROCESSING == res );

        //
        // Double-check name-based failures
        //
        res = bbox.ProcessRequest( "AceF", &xp );

        assert( XOCryptoDoSBlackBox::BB_ENTRY_NOT_FOUND == res );

        //
        // Double-check time validation
        //
        xp.currentTime.dwLowDateTime += 300000000;

        A_SHAInit( &shaCtx );
        A_SHAUpdate( &shaCtx, ppa2.abPPA, sizeof( ppa2.abPPA ) );
        A_SHAUpdate( &shaCtx, (BYTE *) &xp.currentTime, sizeof( xp.currentTime ) );
        A_SHAFinal( &shaCtx, xp.sppa2 );

        res = bbox.ProcessRequest( "ABcDeF", &xp );

        assert( XOCryptoDoSBlackBox::BB_BAD_TIME_RESPOND == res );

        xp.currentTime.dwLowDateTime -= 600000000;

        A_SHAInit( &shaCtx );
        A_SHAUpdate( &shaCtx, ppa2.abPPA, sizeof( ppa2.abPPA ) );
        A_SHAUpdate( &shaCtx, (BYTE *) &xp.currentTime, sizeof( xp.currentTime ) );
        A_SHAFinal( &shaCtx, xp.sppa2 );

        res = bbox.ProcessRequest( "ABcDeF", &xp );

        assert( XOCryptoDoSBlackBox::BB_BAD_TIME_RESPOND == res );

        xp.currentTime.dwLowDateTime += 300000000;

        A_SHAInit( &shaCtx );
        A_SHAUpdate( &shaCtx, ppa2.abPPA, sizeof( ppa2.abPPA ) );
        A_SHAUpdate( &shaCtx, (BYTE *) &xp.currentTime, sizeof( xp.currentTime ) );
        A_SHAFinal( &shaCtx, xp.sppa2 );

        res = bbox.ProcessRequest( "ABcDeF", &xp );

        assert( XOCryptoDoSBlackBox::BB_CONTINUE_PROCESSING == res );

        Sleep( 6000 );
        res = bbox.ProcessRequest( "ABcDeF", &xp );

        assert( XOCryptoDoSBlackBox::BB_BAD_TIME_RESPOND == res );

        //
        // Double-check the ppa validation
        //
        GetSystemTimeAsFileTime( &xp.currentTime );

        A_SHAInit( &shaCtx );
        A_SHAUpdate( &shaCtx, ppa2.abPPA, sizeof( ppa2.abPPA ) );
        A_SHAUpdate( &shaCtx, (BYTE *) &xp.currentTime, sizeof( xp.currentTime ) );
        A_SHAFinal( &shaCtx, xp.sppa2 );

        res = bbox.ProcessRequest( "AbcdeF", &xp );

        assert( XOCryptoDoSBlackBox::BB_CONTINUE_PROCESSING == res );

        memcpy( xp.ppa1, "12345#$ACB6789a123456789a", sizeof( xp.ppa1 ) );
        res = bbox.ProcessRequest( "AbcdeF", &xp );

        assert( XOCryptoDoSBlackBox::BB_ENTRY_NOT_FOUND == res );
    }
    while( FALSE );

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\crypto\helperwrapper\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by helperwrapper.rc
//
#define IDS_PROJNAME                    100
#define IDS_XOCRYPTOWRAPPER_DESC        101
#define IDR_XoCryptoWrapper             102
#define IDS_XOKEYENCRYPTIONHELPERWRP_DESC 103
#define IDS_XOKEYENCRYPTIONHELPERWRP_DESC1 105
#define IDR_XoKeyEncryptionHelperWrp    106

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           107
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\crypto\helperwrapper\helperwrapper.cpp ===
// helperwrapper.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f helperwrapperps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "helperwrapper.h"

#include "helperwrapper_i.c"
#include "XoCryptoWrapper.h"
#include "XoKeyEncryptionHelperWrp.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_XoCryptoWrapper, CXoCryptoWrapper)
OBJECT_ENTRY(CLSID_XoKeyEncryptionHelperWrp, CXoKeyEncryptionHelperWrp)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_HELPERWRAPPERLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\crypto\helperwrapper\StdAfx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__2BF28AE2_6478_4FA2_BAE5_84D97C174A5A__INCLUDED_)
#define AFX_STDAFX_H__2BF28AE2_6478_4FA2_BAE5_84D97C174A5A__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_FREE_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlsafe.h>
#include <stdio.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__2BF28AE2_6478_4FA2_BAE5_84D97C174A5A__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\crypto\helperwrapper\XoCryptoWrapper.h ===
//------------------------------------------------------------------------------
// XoCryptoWrapper.h: Definition of the CXoCryptoWrapper class
//
// Copyright (c) Microsoft Corporation.  All rights reserved
//
//------------------------------------------------------------------------------

#if !defined(AFX_XOCRYPTOWRAPPER_H__2EDCAD1F_B2F8_4B4B_B970_AEDA5DF24569__INCLUDED_)
#define AFX_XOCRYPTOWRAPPER_H__2EDCAD1F_B2F8_4B4B_B970_AEDA5DF24569__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "resource.h"       // main symbols

//------------------------------------------------------------------------------
// CXoCryptoWrapper

class CXoCryptoWrapper : 
    public IDispatchImpl<IXoCryptoWrapper, &IID_IXoCryptoWrapper, &LIBID_HELPERWRAPPERLib>, 
    public ISupportErrorInfo,
    public CComObjectRoot,
    public CComCoClass<CXoCryptoWrapper,&CLSID_XoCryptoWrapper>
{
public:
    CXoCryptoWrapper() {}
BEGIN_COM_MAP(CXoCryptoWrapper)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IXoCryptoWrapper)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CXoCryptoWrapper) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation. 

DECLARE_REGISTRY_RESOURCEID(IDR_XoCryptoWrapper)
// ISupportsErrorInfo
    STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IXoCryptoWrapper
public:
    STDMETHOD(DecryptWithMasterKeyWrp)(/*[in]*/ unsigned long ulMasterKeyVersion, /*[in]*/ unsigned long ulDataSize, /*[in]*/ SAFEARRAY* psaEncData, /*[out,retval]*/ SAFEARRAY** psaDecData);
    STDMETHOD(XOCryptGenRandomWrp)(/*[in]*/ unsigned long ulDataSize, /*[out, retval]*/ SAFEARRAY** ppsaData);
    STDMETHOD(GenPPAforDBWrp)(/*[in]*/ BSTR bstrName, /*[in]*/SAFEARRAY * psaKey, /*[out]*/ SAFEARRAY ** ppsaSPPA, /*[out]*/SAFEARRAY ** ppsaPPA);
    STDMETHOD(EncryptWithMasterKeyWrp)(/*[in]*/ unsigned long ulMasterKeyVersion, /*[in]*/ unsigned long cbPublicKey, /*[in]*/ SAFEARRAY* psaPublicKey, /*[in]*/ unsigned long ulDataSize, /*[in]*/ SAFEARRAY* psaDecData, /*[out,retval]*/ SAFEARRAY** psaEncData);
};

#endif // !defined(AFX_XOCRYPTOWRAPPER_H__2EDCAD1F_B2F8_4B4B_B970_AEDA5DF24569__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\crypto\helperwrapper\obj\i386\dlldata.c ===
/*********************************************************
   DllData file -- generated by MIDL compiler 

        DO NOT ALTER THIS FILE

   This file is regenerated by MIDL on every IDL file compile.

   To completely reconstruct this file, delete it and rerun MIDL
   on all the IDL files in this DLL, specifying this file for the
   /dlldata command line option

*********************************************************/

#define PROXY_DELEGATION

#include <rpcproxy.h>

#ifdef __cplusplus
extern "C"   {
#endif

EXTERN_PROXY_FILE( helperwrapper )


PROXYFILE_LIST_START
/* Start of list */
  REFERENCE_PROXY_FILE( helperwrapper ),
/* End of list */
PROXYFILE_LIST_END


DLLDATA_ROUTINES( aProxyFileList, GET_DLL_CLSID )

#ifdef __cplusplus
}  /*extern "C" */
#endif

/* end of generated dlldata file */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\crypto\helperwrapper\XoCryptoWrapper.cpp ===
//------------------------------------------------------------------------------
// XoCryptoWrapper.cpp : Implementation of CHelperwrapperApp and DLL registration.
//
// Copyright (c) Microsoft Corporation.  All rights reserved
//
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// Includes
//------------------------------------------------------------------------------

#include "stdafx.h"
#include "helperwrapper.h"
#include "XoCryptoWrapper.h"

#include <crtdbg.h>

#include "winsock2.h"
#include "wsockntp.h"
#include "xonlinep.h"

#include "cryptohelper.h"

//------------------------------------------------------------------------------
// Constants 
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// Definitions
//------------------------------------------------------------------------------
#define ERROR_STRING_SIZE       256

//------------------------------------------------------------------------------
// CXoCryptoWrapper

STDMETHODIMP CXoCryptoWrapper::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IXoCryptoWrapper,
	};

	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

//------------------------------------------------------------------------------
// CXoCryptoWrapper::XOCryptGenRandom
//  Calls cryptohelper's XOCryptGenRandom to generate random data.
//------------------------------------------------------------------------------
STDMETHODIMP CXoCryptoWrapper::XOCryptGenRandomWrp( unsigned long ulDataSize, 
												    SAFEARRAY** ppsaRetData)
{
    HRESULT hr = S_OK;
	CComSafeArray<BYTE> *pcsaRetVal ;

    pcsaRetVal = new CComSafeArray<BYTE>(ulDataSize);

    //  ensure the params are valid.
    if ( ppsaRetData == NULL )
	{
		OutputDebugStringA("ERROR:(CXoCryptoWrapper::XOCryptGenRandomWrp)  Invalid pointer given for return data.");
        hr = E_POINTER;
        goto Exit;
	}
    *ppsaRetData = NULL;

	// ensure teh data size is valid.
	if ( ulDataSize == 0 )
    {
		OutputDebugStringA("ERROR:(CXoCryptoWrapper::XOCryptGenRandomWrp)  Return data size must be bigger than 0.");
        hr = E_INVALIDARG;
        goto Exit;
    }

    // attempt to generate random information.
    if (! XOCryptGenRandom( (BYTE*)(pcsaRetVal->m_psa->pvData), (DWORD)ulDataSize ) )
    {
		// failed to attain random byte information.
		OutputDebugStringA("ERROR:(CXoCryptoWrapper::XOCryptGenRandomWrp)  Attempt to attain random data failed.");
		*ppsaRetData = NULL;
        hr = E_FAIL;
        goto Exit;
    }

	// turn over the safe array to the result.
	*ppsaRetData = pcsaRetVal->Detach();


Exit:
    delete pcsaRetVal;

    return hr;
}


//------------------------------------------------------------------------------
// CXoCryptoWrapper::DecryptWithMasterKey
//  Calls cryptohelper's DecryptWithMasterKey to generate random data.
//------------------------------------------------------------------------------
STDMETHODIMP CXoCryptoWrapper::DecryptWithMasterKeyWrp( unsigned long ulMasterKeyVersion, 
													    unsigned long ulDataSize, 
													    SAFEARRAY* psaEncData, 
                                                        SAFEARRAY** psaDecData)
{
    HRESULT hr = S_OK;
    XOCryptoMasterKeyEncryptedStruct objMKEncrypt;
	CComSafeArray<BYTE> *pcsaData ;

    pcsaData = new CComSafeArray<BYTE>(ulDataSize);

    //  ensure the pointers are valid.
    if ( psaEncData == NULL || psaDecData == NULL )
	{
        char szErr[ERROR_STRING_SIZE];
        _snprintf( szErr, 
                    ERROR_STRING_SIZE, 
                    "ERROR:(CXoCryptoWrapper::DecryptWithMasterKeyWrp) The given pointers are invalid. pulDataSize=0x%I64X",                     
                    ulDataSize); 
        szErr[ ERROR_STRING_SIZE - 1 ] = '\0';

        OutputDebugStringA( szErr );

        hr = E_POINTER;
        goto Exit;
	}
		
	// ensure the params are valid.
	if ( ulDataSize == 0 || ulDataSize > sizeof( objMKEncrypt.abKey ) || (psaEncData)->rgsabound[0].cElements < ulDataSize )
    {
        char szErr[ERROR_STRING_SIZE];
        _snprintf( szErr, 
                    ERROR_STRING_SIZE, 
                    "ERROR:(CXoCryptoWrapper::DecryptWithMasterKeyWrp) The given parameters are invalid.  Ensure the safe array size is equal to the given size.  ulDataSize=%d, psaData->rgsabound[0].cElements=%d", 
                    ulDataSize, (psaEncData)->rgsabound[0].cElements); 

        OutputDebugStringA( szErr );

        hr = E_INVALIDARG;
        goto Exit;
    }

    // set up the encryption node for decrypting
    objMKEncrypt.dwKeyLen = (DWORD)(ulDataSize);
    memcpy( objMKEncrypt.abKey, (BYTE*)((psaEncData)->pvData), ulDataSize );

    // decrypt with the master key.
    hr = DecryptWithMasterKey( (DWORD)ulMasterKeyVersion, &objMKEncrypt );

	// copy over the information.
	pcsaData->Resize( objMKEncrypt.dwKeyLen );

	// after the resize... ensure we still have the same pointer!!!
    memcpy( (BYTE*)(pcsaData->m_psa->pvData), objMKEncrypt.abKey, objMKEncrypt.dwKeyLen );
    *psaDecData = pcsaData->Detach();

Exit:
    delete pcsaData;
    return hr;

}

//------------------------------------------------------------------------------
// CXoCryptoWrapper::GenPPAforDB
//  generates PPA data for the database.
//------------------------------------------------------------------------------
STDMETHODIMP CXoCryptoWrapper::GenPPAforDBWrp(BSTR bstrName, SAFEARRAY * psaKey, SAFEARRAY ** ppsaSPPA, SAFEARRAY ** ppsaPPA)
{
    USES_CONVERSION;
    HRESULT hr = S_OK;
    XOCryptoKeyStruct  objKey;
	CComSafeArray<BYTE> *pcsaSPPA;
	CComSafeArray<BYTE> *pcsaPPA;

    // attach to the com help wrappers.
    pcsaSPPA = new CComSafeArray<BYTE>(A_SHA_DIGEST_LEN);
    pcsaPPA = new CComSafeArray<BYTE>(PPA_DATA_LEN);

    *ppsaSPPA = NULL;
    *ppsaPPA = NULL;

    //  ensure the pointers are valid.
    if ( ppsaSPPA == NULL || ppsaPPA == NULL || psaKey == NULL )
	{
        char szErr[ERROR_STRING_SIZE];
        _snprintf( szErr, 
                    ERROR_STRING_SIZE, 
                    "ERROR:(CXoCryptoWrapper::GenPPAforDB) The given pointers are invalid."); 
        szErr[ ERROR_STRING_SIZE - 1 ] = '\0';

        OutputDebugStringA( szErr );

        hr = E_POINTER;
        goto Exit;
	}
		
	// ensure the params are valid.
	if ( (psaKey)->rgsabound[0].cElements != ONLINE_KEY_LEN || SysStringLen(bstrName) < 1  )
    {
        char szErr[ERROR_STRING_SIZE];
        _snprintf( szErr, 
                    ERROR_STRING_SIZE, 
                    "ERROR:(CXoCryptoWrapper::GenPPAforDB) The given parameters are invalid.  Ensure the safe array size is equal to the given size.  *ppsaKey->rgsabound[0].cElements=%d, bstrName=%S", 
                    (psaKey)->rgsabound[0].cElements, bstrName); 

        OutputDebugStringA( szErr );

        hr = E_INVALIDARG;
        goto Exit;
    }

    // copy the key into a key structure.
    memcpy( (void*)(objKey.abKey), (psaKey)->pvData, ONLINE_KEY_LEN );

    // generate the PPA data for the DB.
    if ( !GenPPAforDB( (W2A(bstrName)), &objKey, (XOCryptoSPPAStruct*)(pcsaSPPA->m_psa->pvData), (XOCryptoPPAStruct*)(pcsaPPA->m_psa->pvData) ) )
    {
        hr = E_FAIL;
        OutputDebugStringA( "ERROR:(CXoCryptoWrapper::GenPPAforDB) Call to function returned false.  Please review params and try again." );
        goto Exit;
    }

    // detach the pointers with the correct information.
    *ppsaSPPA = pcsaSPPA->Detach();
    *ppsaPPA = pcsaPPA->Detach();


Exit:
    delete pcsaSPPA;
    delete pcsaPPA;

    return hr;
}


//------------------------------------------------------------------------------
// CXoCryptoWrapper::EncryptWithMasterKeyWrp
//------------------------------------------------------------------------------
STDMETHODIMP CXoCryptoWrapper::EncryptWithMasterKeyWrp( unsigned long ulMasterKeyVersion,
                                                        unsigned long cbPublicKey,
                                                        SAFEARRAY* psaPublicKey,
                                                        unsigned long ulDataSize,
                                                        SAFEARRAY* psaDecData,
                                                        SAFEARRAY** psaEncData)
{
    HRESULT hr = S_OK;
    XOCryptoMasterKeyEncryptedStruct objMKEncrypt;

    CComSafeArray<BYTE> *pcsaData ;
    pcsaData = new CComSafeArray<BYTE>(ulDataSize);

    //  ensure the pointers are valid.
    if ( psaEncData == NULL || psaDecData == NULL )
    {
        char szErr[ERROR_STRING_SIZE];
        _snprintf( szErr, 
                    ERROR_STRING_SIZE, 
                    "ERROR:(CXoCryptoWrapper::EncryptWithMasterKeyWrp) The given pointers are invalid. ulDataSize=0x%I64X",                     
                    ulDataSize); 
        szErr[ ERROR_STRING_SIZE - 1 ] = '\0';

        OutputDebugStringA( szErr );

        hr = E_POINTER;
        goto Exit;
    }

    // ensure the params are valid.
    if ( ulDataSize == 0 || ulDataSize > sizeof( objMKEncrypt.abKey ) || (psaDecData)->rgsabound[0].cElements < ulDataSize )
    {
        char szErr[ERROR_STRING_SIZE];
        _snprintf( szErr, 
                    ERROR_STRING_SIZE, 
                    "ERROR:(CXoCryptoWrapper::EncryptWithMasterKeyWrp) The given parameters are invalid.  Ensure the safe array size is equal to the given size.  ulDataSize=%d, psaData->rgsabound[0].cElements=%d", 
                    ulDataSize, (psaDecData)->rgsabound[0].cElements); 

        OutputDebugStringA( szErr );

        hr = E_INVALIDARG;
        goto Exit;
    }

    // set up the encryption node for decrypting
    objMKEncrypt.dwKeyLen = (DWORD)(ulDataSize);
    memcpy( objMKEncrypt.abKey, (BYTE*)((psaDecData)->pvData), ulDataSize );

    // encrypt with the master key.
    hr = EncryptWithMasterKey((DWORD)ulMasterKeyVersion, (LPBYTE)psaPublicKey->pvData, cbPublicKey, &objMKEncrypt);

    // copy over the information.
    pcsaData->Resize( objMKEncrypt.dwKeyLen );

    // after the resize... ensure we still have the same pointer!!!
    memcpy( (BYTE*)(pcsaData->m_psa->pvData), objMKEncrypt.abKey, objMKEncrypt.dwKeyLen );
    *psaEncData = pcsaData->Detach();

Exit:
    delete pcsaData;
    return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\crypto\helperwrapper\XoKeyEncryptionHelperWrp.cpp ===
//------------------------------------------------------------------------------
// XoKeyEncryptionHelperWrp.cpp : Implementation of CHelperwrapperApp and DLL registration.
//
// Copyright (c) Microsoft Corporation.  All rights reserved
//
//------------------------------------------------------------------------------


//------------------------------------------------------------------------------
// Includes
//------------------------------------------------------------------------------

#include "stdafx.h"
#include "helperwrapper.h"
#include "XoKeyEncryptionHelperWrp.h"

#include <crtdbg.h>

#include "winsock2.h"
#include "wsockntp.h"
#include "xonlinep.h"

#include "cryptohelper.h"

//------------------------------------------------------------------------------
// Constants 
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// Definitions
//------------------------------------------------------------------------------
#define ERROR_STRING_SIZE       256


//------------------------------------------------------------------------------
// CXoKeyEncryptionHelperWrp


STDMETHODIMP CXoKeyEncryptionHelperWrp::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IXoKeyEncryptionHelperWrp,
	};

	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}



//------------------------------------------------------------------------------
//  Init:  Initializes the atl object with a new helper class if the 
//      attribute is NULL.
//------------------------------------------------------------------------------
STDMETHODIMP CXoKeyEncryptionHelperWrp::Init(SAFEARRAY * saKEK)
{
    HRESULT hr = S_OK;

    if ( m_pKEKHelper )
    {
        // object already exists.  
        OutputDebugStringA( "ERROR:(CXoKeyEncryptionHelperWrp::Init)  Object has already been initialized, please Release this object before re-Init.");
        _ASSERT( !"Invalid Initialization." );
        hr = E_ABORT;        
        goto Exit;
    }

    // ensure the params
    if ( saKEK == NULL )
    {
        //  params are messed up... warn and return
        OutputDebugStringA( "ERROR:(CXoKeyEncryptionHelperWrp::Init)  Given params are invalid.  The SAFEARRAY is an invalid pointer.");
        _ASSERT( !"Invalid Pointer." );
        hr = E_POINTER;
        goto Exit;
    }

    // ensure the params
    if ( ( saKEK->rgsabound[0].cElements < KEY_ENCRYPTION_KEY_SIZE ) )
    {
        //  params are messed up... warn and return
        OutputDebugStringA( "ERROR:(CXoKeyEncryptionHelperWrp::Init)  Given params are invalid.  The size of the given SAFEARRAY buffer must be the same as the key encryption key size.  Please see cryptohelper.h for this size.");
        _ASSERT( !"Invalid Params." );
        hr = E_INVALIDARG;
        goto Exit;
    }

    // create the new object.
    m_pKEKHelper = new XOCryptoKeyEncryptionHelper( (XOCryptoKeyEncryptionKey*)(saKEK->pvData) );

    // check to ensure this pointer is valid.
    if ( m_pKEKHelper == NULL )
    {
        //  params are messed up... warn and return
        OutputDebugStringA( "ERROR:(CXoKeyEncryptionHelperWrp::Init)  Failed to initialize.  Out of memory.");
        _ASSERT( !"Out of Memory." );
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

Exit:
    return hr;
}

//------------------------------------------------------------------------------
//  Release:  Releases the memory held by this structure.
//------------------------------------------------------------------------------
STDMETHODIMP CXoKeyEncryptionHelperWrp::Terminate(void)
{
    OutputDebugStringA( "ERROR:(CXoKeyEncryptionHelperWrp::Terminate)  Releasing object.");

    // check if it exists.
    if ( m_pKEKHelper )
    {
        // if so ... delete it.
        delete m_pKEKHelper;
        m_pKEKHelper = NULL;
    }

    return S_OK;
}

//------------------------------------------------------------------------------
// GenerateNewKey:  generate a new key.
//------------------------------------------------------------------------------
STDMETHODIMP CXoKeyEncryptionHelperWrp::GenerateNewKey(SAFEARRAY ** ppsaIV, SAFEARRAY ** ppsaEncryptedKey, SAFEARRAY ** ppsaRawKey)
{
    HRESULT hr = S_OK;
    XOCryptoIVStruct IV;
    XOCryptoKeyStruct EncryptedKey;
    XOCryptoKeyStruct RawKey;
    CComSafeArray<BYTE> *pcsaIV = new CComSafeArray<BYTE>(AES_BLOCKLEN);
    CComSafeArray<BYTE> *pcsaEncryptKey = new CComSafeArray<BYTE>(ONLINE_KEY_LEN);
    CComSafeArray<BYTE> *pcsaRawKey = new CComSafeArray<BYTE>(ONLINE_KEY_LEN);
                                        
    // ensure we have the helper.
    if ( !m_pKEKHelper )
    {
        //  params are messed up... warn and return
        OutputDebugStringA( "ERROR:(CXoKeyEncryptionHelperWrp::GenerateNewKey)  Object has not been initialized.");
        _ASSERT( !"Not Initalized" );
        hr = E_ABORT;
        goto Exit;
    }

    // ensure the given are valid pointers.        
    if ( ppsaIV == NULL || ppsaEncryptedKey == NULL || ppsaRawKey == NULL )
    {
        //  params are messed up... warn and return
        OutputDebugStringA( "ERROR:(CXoKeyEncryptionHelperWrp::GenerateNewKey)  Given params are invalid.  No param can be NULL.");
        _ASSERT( !"Invalid Pointer." );
        hr = E_POINTER;
        goto Exit;
    }

    // zero the given stack memory.
    ZeroMemory( &IV, sizeof(XOCryptoIVStruct) );
    ZeroMemory( &EncryptedKey, sizeof(XOCryptoKeyStruct) );
    ZeroMemory( &RawKey, sizeof(XOCryptoKeyStruct) );

    // generate the new key.
    m_pKEKHelper->GenerateNewKey( &IV, &EncryptedKey, &RawKey );

    // set the values.
    CopyMemory( pcsaIV->m_psa->pvData, (void *)&(IV.abIV), AES_BLOCKLEN );
    CopyMemory( pcsaEncryptKey->m_psa->pvData, (void *)&(EncryptedKey.abKey), ONLINE_KEY_LEN );
    CopyMemory( pcsaRawKey->m_psa->pvData, (void *)&(RawKey.abKey), ONLINE_KEY_LEN );

    // detach and continue.
    *ppsaIV = pcsaIV->Detach();
    *ppsaEncryptedKey = pcsaEncryptKey->Detach();
    *ppsaRawKey = pcsaRawKey->Detach();

Exit:
    delete pcsaIV;
    delete pcsaEncryptKey;
    delete pcsaRawKey;

    return hr;
}

//------------------------------------------------------------------------------
// DecryptKey:  Decrypts a given encrypted key.
//------------------------------------------------------------------------------
STDMETHODIMP CXoKeyEncryptionHelperWrp::DecryptKey(SAFEARRAY * psaIV, SAFEARRAY * psaEncryptedKey, SAFEARRAY ** ppsaRawKey)
{
    HRESULT hr = S_OK;
    XOCryptoKeyStruct RawKey;
    CComSafeArray<BYTE> *pcsaRawKey = new CComSafeArray<BYTE>(ONLINE_KEY_LEN);

    // ensure we have the helper.
    if ( !m_pKEKHelper )
    {
        //  params are messed up... warn and return
        OutputDebugStringA( "ERROR:(CXoKeyEncryptionHelperWrp::GenerateNewKey)  Object has not been initialized.");
        _ASSERT( !"Not Initalized" );
        hr = E_ABORT;
        goto Exit;
    }

    // ensure the given are valid pointers.        
    if ( psaIV == NULL || psaEncryptedKey == NULL || ppsaRawKey == NULL )
    {
        //  params are messed up... warn and return
        OutputDebugStringA( "ERROR:(CXoKeyEncryptionHelperWrp::DecryptKey)  Given params are invalid.  No param can be NULL.");
        _ASSERT( !"Invalid Pointer." );
        hr = E_POINTER;
        goto Exit;
    }

    // ensure the given are valid pointers.        
    if ( psaIV->rgsabound[0].cElements < AES_BLOCKLEN || psaEncryptedKey->rgsabound[0].cElements != ONLINE_KEY_LEN )
    {
        //  params are messed up... warn and return
        OutputDebugStringA( "ERROR:(CXoKeyEncryptionHelperWrp::DecryptKey)  Given params are invalid.  No param can be NULL.");
        _ASSERT( !"Invalid Params." );
        hr = E_INVALIDARG;
        goto Exit;
    }

    // TODO:(lohab) Copy the memory (if the struct change then the current version won't work.
    // call the function.
    m_pKEKHelper->DecryptKey( (XOCryptoIVStruct*)(psaIV->pvData), (XOCryptoKeyStruct*)(psaEncryptedKey->pvData), &RawKey );

    // copy the data
    CopyMemory( pcsaRawKey->m_psa->pvData, (void*)(RawKey.abKey), ONLINE_KEY_LEN );

    // set the return value.
    *ppsaRawKey = pcsaRawKey->Detach();

Exit:    
    delete pcsaRawKey;
    return hr;
}


//------------------------------------------------------------------------------
// EncryptKey:  Encrypts given raw data returning the IV and encrypted data.
//------------------------------------------------------------------------------
STDMETHODIMP CXoKeyEncryptionHelperWrp::EncryptKey(SAFEARRAY * saRawKey, SAFEARRAY ** ppsaIV, SAFEARRAY ** ppsaEncryptedKey)
{
    HRESULT hr = S_OK;
    XOCryptoIVStruct IV;
    XOCryptoKeyStruct EncryptedData;
    CComSafeArray<BYTE> *pcsaIV = new CComSafeArray<BYTE>(AES_BLOCKLEN);
    CComSafeArray<BYTE> *pcsaEncryptedData = new CComSafeArray<BYTE>(ONLINE_KEY_LEN);

    // ensure we have the helper.
    if ( !m_pKEKHelper )
    {
        //  params are messed up... warn and return
        OutputDebugStringA( "ERROR:(CXoKeyEncryptionHelperWrp::GenerateNewKey)  Object has not been initialized.");
        _ASSERT( !"Not Initalized" );
        hr = E_ABORT;
        goto Exit;
    }

    // ensure the given are valid pointers.        
    if ( saRawKey == NULL || ppsaIV == NULL || ppsaEncryptedKey == NULL )
    {
        //  params are messed up... warn and return
        OutputDebugStringA( "ERROR:(CXoKeyEncryptionHelperWrp::DecryptKey)  Given params are invalid.  No param can be NULL.");
        _ASSERT( !"Invalid Pointer." );
        hr = E_POINTER;
        goto Exit;
    }

    // ensure the given are valid pointers.        
    if ( saRawKey->rgsabound[0].cElements < ONLINE_KEY_LEN )
    {
        //  params are messed up... warn and return
        OutputDebugStringA( "ERROR:(CXoKeyEncryptionHelperWrp::DecryptKey)  Given params are invalid.  The size of the raw data is too small.");
        _ASSERT( !"Invalid Params." );
        hr = E_INVALIDARG;
        goto Exit;
    }

    // TODO:(lohab) Copy the memory (if the struct change then the current version won't work.
    // call the function.
    if (! m_pKEKHelper->EncryptKey( (XOCryptoKeyStruct*)(saRawKey->pvData), &IV, &EncryptedData ) )
	{
        //  params are messed up... warn and return
        OutputDebugStringA( "ERROR:(CXoKeyEncryptionHelperWrp::EncryptKey)  EncryptKey failed.");
        hr = E_FAIL;
        goto Exit;
	}
    
    // copy the data
    CopyMemory( pcsaIV->m_psa->pvData, (void*)(IV.abIV), AES_BLOCKLEN );
    CopyMemory( pcsaEncryptedData->m_psa->pvData, (void*)(EncryptedData.abKey), ONLINE_KEY_LEN );

    // set the return value.
    *ppsaIV = pcsaIV->Detach();
    *ppsaEncryptedKey = pcsaEncryptedData->Detach();


Exit:    
    delete pcsaIV;
    delete pcsaEncryptedData;
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\crypto\helperwrapper\XoKeyEncryptionHelperWrp.h ===
// XoKeyEncryptionHelperWrp.h: Definition of the XoKeyEncryptionHelperWrp class
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_XOKEYENCRYPTIONHELPERWRP_H__A330426C_A021_4549_B7BD_FB834BA7AF50__INCLUDED_)
#define AFX_XOKEYENCRYPTIONHELPERWRP_H__A330426C_A021_4549_B7BD_FB834BA7AF50__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "resource.h"       // main symbols

// just a temp marker.
class XOCryptoKeyEncryptionHelper;

/////////////////////////////////////////////////////////////////////////////
// XoKeyEncryptionHelperWrp

class CXoKeyEncryptionHelperWrp : 
	public IDispatchImpl<IXoKeyEncryptionHelperWrp, &IID_IXoKeyEncryptionHelperWrp, &LIBID_HELPERWRAPPERLib>, 
	public ISupportErrorInfo,
	public CComObjectRoot,
	public CComCoClass<CXoKeyEncryptionHelperWrp,&CLSID_XoKeyEncryptionHelperWrp>
{
public:
    CXoKeyEncryptionHelperWrp(): m_pKEKHelper(NULL) {}
BEGIN_COM_MAP(CXoKeyEncryptionHelperWrp)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IXoKeyEncryptionHelperWrp)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CXoKeyEncryptionHelperWrp) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation. 

DECLARE_REGISTRY_RESOURCEID(IDR_XoKeyEncryptionHelperWrp)
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IXoKeyEncryptionHelperWrp
public:

    STDMETHOD(Init)(SAFEARRAY * saKEK);
    STDMETHOD(Terminate)(void);
    STDMETHOD(GenerateNewKey)(/*[out]*/SAFEARRAY**  ppsaIV, /*[out]*/SAFEARRAY** ppsaEncryptedData, /*[out]*/SAFEARRAY** ppsaRawData);
    STDMETHOD(DecryptKey)(/*[in]*/SAFEARRAY * saIV, /*[in]*/SAFEARRAY * saEncryptedData, /*[out,retval]*/SAFEARRAY **  ppsaRawData);
    STDMETHOD(EncryptKey)(/*[in]*/SAFEARRAY * saRawData, /*[out]*/SAFEARRAY ** ppsaIV, /*[out]*/SAFEARRAY ** ppsaEncryptedData);


protected:
    // The key encryption key helper class that is being wrapped.
    XOCryptoKeyEncryptionHelper *m_pKEKHelper;
};

#endif // !defined(AFX_XOKEYENCRYPTIONHELPERWRP_H__A330426C_A021_4549_B7BD_FB834BA7AF50__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\crypto\helperwrapper\objd\i386\dlldata.c ===
/*********************************************************
   DllData file -- generated by MIDL compiler 

        DO NOT ALTER THIS FILE

   This file is regenerated by MIDL on every IDL file compile.

   To completely reconstruct this file, delete it and rerun MIDL
   on all the IDL files in this DLL, specifying this file for the
   /dlldata command line option

*********************************************************/

#define PROXY_DELEGATION

#include <rpcproxy.h>

#ifdef __cplusplus
extern "C"   {
#endif

EXTERN_PROXY_FILE( helperwrapper )


PROXYFILE_LIST_START
/* Start of list */
  REFERENCE_PROXY_FILE( helperwrapper ),
/* End of list */
PROXYFILE_LIST_END


DLLDATA_ROUTINES( aProxyFileList, GET_DLL_CLSID )

#ifdef __cplusplus
}  /*extern "C" */
#endif

/* end of generated dlldata file */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\crypto\helperwrapper\obj\i386\helperwrapper_i.c ===
/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 7.00.0500 */
/* Compiler settings for helperwrapper.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, oldnames, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IXoCryptoWrapper,0x4CC1CC3B,0x38A6,0x4AF2,0xB7,0x5F,0xE4,0x57,0xA4,0x50,0x72,0x52);


MIDL_DEFINE_GUID(IID, IID_IXoKeyEncryptionHelperWrp,0x86BA703A,0xDEDA,0x42DC,0x8A,0x27,0x62,0x2F,0x39,0xB1,0x3D,0x9F);


MIDL_DEFINE_GUID(IID, LIBID_HELPERWRAPPERLib,0x9339844B,0x3E09,0x4502,0x8F,0x9B,0xDC,0xF1,0xFD,0x6D,0x16,0x6C);


MIDL_DEFINE_GUID(CLSID, CLSID_XoCryptoWrapper,0x007CDE6D,0x353E,0x4F97,0x98,0xE2,0xB3,0x51,0xD0,0x09,0xBD,0x1B);


MIDL_DEFINE_GUID(CLSID, CLSID_XoKeyEncryptionHelperWrp,0x50C34C88,0x45C4,0x483F,0x94,0xA5,0xFE,0xB3,0x2E,0x6E,0x2A,0x71);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\crypto\helperwrapper\obj\i386\helperwrapper.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0500 */
/* Compiler settings for helperwrapper.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, oldnames, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __helperwrapper_h__
#define __helperwrapper_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IXoCryptoWrapper_FWD_DEFINED__
#define __IXoCryptoWrapper_FWD_DEFINED__
typedef interface IXoCryptoWrapper IXoCryptoWrapper;
#endif 	/* __IXoCryptoWrapper_FWD_DEFINED__ */


#ifndef __IXoKeyEncryptionHelperWrp_FWD_DEFINED__
#define __IXoKeyEncryptionHelperWrp_FWD_DEFINED__
typedef interface IXoKeyEncryptionHelperWrp IXoKeyEncryptionHelperWrp;
#endif 	/* __IXoKeyEncryptionHelperWrp_FWD_DEFINED__ */


#ifndef __XoCryptoWrapper_FWD_DEFINED__
#define __XoCryptoWrapper_FWD_DEFINED__

#ifdef __cplusplus
typedef class XoCryptoWrapper XoCryptoWrapper;
#else
typedef struct XoCryptoWrapper XoCryptoWrapper;
#endif /* __cplusplus */

#endif 	/* __XoCryptoWrapper_FWD_DEFINED__ */


#ifndef __XoKeyEncryptionHelperWrp_FWD_DEFINED__
#define __XoKeyEncryptionHelperWrp_FWD_DEFINED__

#ifdef __cplusplus
typedef class XoKeyEncryptionHelperWrp XoKeyEncryptionHelperWrp;
#else
typedef struct XoKeyEncryptionHelperWrp XoKeyEncryptionHelperWrp;
#endif /* __cplusplus */

#endif 	/* __XoKeyEncryptionHelperWrp_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IXoCryptoWrapper_INTERFACE_DEFINED__
#define __IXoCryptoWrapper_INTERFACE_DEFINED__

/* interface IXoCryptoWrapper */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IXoCryptoWrapper;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4CC1CC3B-38A6-4AF2-B75F-E457A4507252")
    IXoCryptoWrapper : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE XOCryptGenRandomWrp( 
            /* [in] */ unsigned long ulDataSize,
            /* [retval][out] */ SAFEARRAY * *ppsaData) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE DecryptWithMasterKeyWrp( 
            /* [in] */ unsigned long ulMasterKeyVersion,
            /* [in] */ unsigned long pulDataSize,
            /* [in] */ SAFEARRAY * psaEncData,
            /* [retval][out] */ SAFEARRAY * *psaDecData) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GenPPAforDBWrp( 
            /* [in] */ BSTR bstrName,
            /* [in] */ SAFEARRAY * ppsaKey,
            /* [out] */ SAFEARRAY * *ppsaSPPA,
            /* [out] */ SAFEARRAY * *ppsaPPA) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE EncryptWithMasterKeyWrp( 
            /* [in] */ unsigned long ulMasterKeyVersion,
            /* [in] */ unsigned long cbPublicKey,
            /* [in] */ SAFEARRAY * psaPublicKey,
            /* [in] */ unsigned long ulDataSize,
            /* [in] */ SAFEARRAY * psaDecData,
            /* [retval][out] */ SAFEARRAY * *psaEncData) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXoCryptoWrapperVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXoCryptoWrapper * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXoCryptoWrapper * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXoCryptoWrapper * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IXoCryptoWrapper * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IXoCryptoWrapper * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IXoCryptoWrapper * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IXoCryptoWrapper * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *XOCryptGenRandomWrp )( 
            IXoCryptoWrapper * This,
            /* [in] */ unsigned long ulDataSize,
            /* [retval][out] */ SAFEARRAY * *ppsaData);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *DecryptWithMasterKeyWrp )( 
            IXoCryptoWrapper * This,
            /* [in] */ unsigned long ulMasterKeyVersion,
            /* [in] */ unsigned long pulDataSize,
            /* [in] */ SAFEARRAY * psaEncData,
            /* [retval][out] */ SAFEARRAY * *psaDecData);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GenPPAforDBWrp )( 
            IXoCryptoWrapper * This,
            /* [in] */ BSTR bstrName,
            /* [in] */ SAFEARRAY * ppsaKey,
            /* [out] */ SAFEARRAY * *ppsaSPPA,
            /* [out] */ SAFEARRAY * *ppsaPPA);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *EncryptWithMasterKeyWrp )( 
            IXoCryptoWrapper * This,
            /* [in] */ unsigned long ulMasterKeyVersion,
            /* [in] */ unsigned long cbPublicKey,
            /* [in] */ SAFEARRAY * psaPublicKey,
            /* [in] */ unsigned long ulDataSize,
            /* [in] */ SAFEARRAY * psaDecData,
            /* [retval][out] */ SAFEARRAY * *psaEncData);
        
        END_INTERFACE
    } IXoCryptoWrapperVtbl;

    interface IXoCryptoWrapper
    {
        CONST_VTBL struct IXoCryptoWrapperVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXoCryptoWrapper_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXoCryptoWrapper_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXoCryptoWrapper_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXoCryptoWrapper_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IXoCryptoWrapper_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IXoCryptoWrapper_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IXoCryptoWrapper_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IXoCryptoWrapper_XOCryptGenRandomWrp(This,ulDataSize,ppsaData)	\
    ( (This)->lpVtbl -> XOCryptGenRandomWrp(This,ulDataSize,ppsaData) ) 

#define IXoCryptoWrapper_DecryptWithMasterKeyWrp(This,ulMasterKeyVersion,pulDataSize,psaEncData,psaDecData)	\
    ( (This)->lpVtbl -> DecryptWithMasterKeyWrp(This,ulMasterKeyVersion,pulDataSize,psaEncData,psaDecData) ) 

#define IXoCryptoWrapper_GenPPAforDBWrp(This,bstrName,ppsaKey,ppsaSPPA,ppsaPPA)	\
    ( (This)->lpVtbl -> GenPPAforDBWrp(This,bstrName,ppsaKey,ppsaSPPA,ppsaPPA) ) 

#define IXoCryptoWrapper_EncryptWithMasterKeyWrp(This,ulMasterKeyVersion,cbPublicKey,psaPublicKey,ulDataSize,psaDecData,psaEncData)	\
    ( (This)->lpVtbl -> EncryptWithMasterKeyWrp(This,ulMasterKeyVersion,cbPublicKey,psaPublicKey,ulDataSize,psaDecData,psaEncData) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXoCryptoWrapper_INTERFACE_DEFINED__ */


#ifndef __IXoKeyEncryptionHelperWrp_INTERFACE_DEFINED__
#define __IXoKeyEncryptionHelperWrp_INTERFACE_DEFINED__

/* interface IXoKeyEncryptionHelperWrp */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IXoKeyEncryptionHelperWrp;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("86BA703A-DEDA-42DC-8A27-622F39B13D9F")
    IXoKeyEncryptionHelperWrp : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Init( 
            /* [in] */ SAFEARRAY * saKEK) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Terminate( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GenerateNewKey( 
            /* [out] */ SAFEARRAY * *psaIV,
            /* [out] */ SAFEARRAY * *psaEncryptedData,
            /* [out] */ SAFEARRAY * *psaRawData) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE DecryptKey( 
            /* [in] */ SAFEARRAY * psaIV,
            /* [in] */ SAFEARRAY * psaEncryptedData,
            /* [retval][out] */ SAFEARRAY * *psaRawData) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE EncryptKey( 
            /* [in] */ SAFEARRAY * psaRawData,
            /* [out] */ SAFEARRAY * *psaIV,
            /* [out] */ SAFEARRAY * *psaEncryptedData) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXoKeyEncryptionHelperWrpVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXoKeyEncryptionHelperWrp * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXoKeyEncryptionHelperWrp * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXoKeyEncryptionHelperWrp * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IXoKeyEncryptionHelperWrp * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IXoKeyEncryptionHelperWrp * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IXoKeyEncryptionHelperWrp * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IXoKeyEncryptionHelperWrp * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Init )( 
            IXoKeyEncryptionHelperWrp * This,
            /* [in] */ SAFEARRAY * saKEK);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Terminate )( 
            IXoKeyEncryptionHelperWrp * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GenerateNewKey )( 
            IXoKeyEncryptionHelperWrp * This,
            /* [out] */ SAFEARRAY * *psaIV,
            /* [out] */ SAFEARRAY * *psaEncryptedData,
            /* [out] */ SAFEARRAY * *psaRawData);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *DecryptKey )( 
            IXoKeyEncryptionHelperWrp * This,
            /* [in] */ SAFEARRAY * psaIV,
            /* [in] */ SAFEARRAY * psaEncryptedData,
            /* [retval][out] */ SAFEARRAY * *psaRawData);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *EncryptKey )( 
            IXoKeyEncryptionHelperWrp * This,
            /* [in] */ SAFEARRAY * psaRawData,
            /* [out] */ SAFEARRAY * *psaIV,
            /* [out] */ SAFEARRAY * *psaEncryptedData);
        
        END_INTERFACE
    } IXoKeyEncryptionHelperWrpVtbl;

    interface IXoKeyEncryptionHelperWrp
    {
        CONST_VTBL struct IXoKeyEncryptionHelperWrpVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXoKeyEncryptionHelperWrp_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXoKeyEncryptionHelperWrp_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXoKeyEncryptionHelperWrp_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXoKeyEncryptionHelperWrp_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IXoKeyEncryptionHelperWrp_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IXoKeyEncryptionHelperWrp_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IXoKeyEncryptionHelperWrp_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IXoKeyEncryptionHelperWrp_Init(This,saKEK)	\
    ( (This)->lpVtbl -> Init(This,saKEK) ) 

#define IXoKeyEncryptionHelperWrp_Terminate(This)	\
    ( (This)->lpVtbl -> Terminate(This) ) 

#define IXoKeyEncryptionHelperWrp_GenerateNewKey(This,psaIV,psaEncryptedData,psaRawData)	\
    ( (This)->lpVtbl -> GenerateNewKey(This,psaIV,psaEncryptedData,psaRawData) ) 

#define IXoKeyEncryptionHelperWrp_DecryptKey(This,psaIV,psaEncryptedData,psaRawData)	\
    ( (This)->lpVtbl -> DecryptKey(This,psaIV,psaEncryptedData,psaRawData) ) 

#define IXoKeyEncryptionHelperWrp_EncryptKey(This,psaRawData,psaIV,psaEncryptedData)	\
    ( (This)->lpVtbl -> EncryptKey(This,psaRawData,psaIV,psaEncryptedData) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXoKeyEncryptionHelperWrp_INTERFACE_DEFINED__ */



#ifndef __HELPERWRAPPERLib_LIBRARY_DEFINED__
#define __HELPERWRAPPERLib_LIBRARY_DEFINED__

/* library HELPERWRAPPERLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_HELPERWRAPPERLib;

EXTERN_C const CLSID CLSID_XoCryptoWrapper;

#ifdef __cplusplus

class DECLSPEC_UUID("007CDE6D-353E-4F97-98E2-B351D009BD1B")
XoCryptoWrapper;
#endif

EXTERN_C const CLSID CLSID_XoKeyEncryptionHelperWrp;

#ifdef __cplusplus

class DECLSPEC_UUID("50C34C88-45C4-483F-94A5-FEB32E6E2A71")
XoKeyEncryptionHelperWrp;
#endif
#endif /* __HELPERWRAPPERLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  LPSAFEARRAY_UserSize(     unsigned long *, unsigned long            , LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserMarshal(  unsigned long *, unsigned char *, LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserUnmarshal(unsigned long *, unsigned char *, LPSAFEARRAY * ); 
void                      __RPC_USER  LPSAFEARRAY_UserFree(     unsigned long *, LPSAFEARRAY * ); 

unsigned long             __RPC_USER  BSTR_UserSize64(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal64(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal64(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree64(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  LPSAFEARRAY_UserSize64(     unsigned long *, unsigned long            , LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserMarshal64(  unsigned long *, unsigned char *, LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserUnmarshal64(unsigned long *, unsigned char *, LPSAFEARRAY * ); 
void                      __RPC_USER  LPSAFEARRAY_UserFree64(     unsigned long *, LPSAFEARRAY * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\crypto\helperwrapper\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_cryptowrapper_none_12.4.56.0_none_9c4eeb047e805db4
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_cryptowrapper_no-public-key_12.4.56.0_x-ww_82434988
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=cryptowrapper
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_cryptowrapper_no-public-key_12.4.56.0_x-ww_82434988
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_cryptowrapper_no-public-key_12.4.56.0_x-ww_82434988.manifest
XP_MANIFEST_PATH=manifests\x86_cryptowrapper_no-public-key_12.4.56.0_x-ww_82434988.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_cryptowrapper_no-public-key_12.4.56.0_x-ww_82434988.cat
XP_CATALOG_PATH=manifests\x86_cryptowrapper_no-public-key_12.4.56.0_x-ww_82434988.cat
XP_PAYLOAD_PATH=x86_cryptowrapper_no-public-key_12.4.56.0_x-ww_82434988
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=cryptowrapper,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\crypto\helperwrapper\obj\i386\helperwrapper_p.c ===
/* this ALWAYS GENERATED file contains the proxy stub code */


 /* File created by MIDL compiler version 7.00.0500 */
/* Compiler settings for helperwrapper.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, oldnames, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)


#pragma warning( disable: 4049 )  /* more than 64k source lines */
#if _MSC_VER >= 1200
#pragma warning(push)
#endif

#pragma warning( disable: 4211 )  /* redefine extern to static */
#pragma warning( disable: 4232 )  /* dllimport identity*/
#pragma warning( disable: 4024 )  /* array to pointer mapping*/
#pragma warning( disable: 4152 )  /* function/data pointer conversion in expression */
#pragma warning( disable: 4100 ) /* unreferenced arguments in x86 call */

#pragma optimize("", off ) 

#define USE_STUBLESS_PROXY


/* verify that the <rpcproxy.h> version is high enough to compile this file*/
#ifndef __REDQ_RPCPROXY_H_VERSION__
#define __REQUIRED_RPCPROXY_H_VERSION__ 475
#endif


#include "rpcproxy.h"
#ifndef __RPCPROXY_H_VERSION__
#error this stub requires an updated version of <rpcproxy.h>
#endif // __RPCPROXY_H_VERSION__


#include "helperwrapper.h"

#define TYPE_FORMAT_STRING_SIZE   1233                              
#define PROC_FORMAT_STRING_SIZE   427                               
#define EXPR_FORMAT_STRING_SIZE   1                                 
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   2            

typedef struct _helperwrapper_MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } helperwrapper_MIDL_TYPE_FORMAT_STRING;

typedef struct _helperwrapper_MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } helperwrapper_MIDL_PROC_FORMAT_STRING;

typedef struct _helperwrapper_MIDL_EXPR_FORMAT_STRING
    {
    long          Pad;
    unsigned char  Format[ EXPR_FORMAT_STRING_SIZE ];
    } helperwrapper_MIDL_EXPR_FORMAT_STRING;


static RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};


extern const helperwrapper_MIDL_TYPE_FORMAT_STRING helperwrapper__MIDL_TypeFormatString;
extern const helperwrapper_MIDL_PROC_FORMAT_STRING helperwrapper__MIDL_ProcFormatString;
extern const helperwrapper_MIDL_EXPR_FORMAT_STRING helperwrapper__MIDL_ExprFormatString;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IXoCryptoWrapper_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IXoCryptoWrapper_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IXoKeyEncryptionHelperWrp_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IXoKeyEncryptionHelperWrp_ProxyInfo;


extern const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ];

#if !defined(__RPC_WIN32__)
#error  Invalid build platform for this stub.
#endif
#if !(TARGET_IS_NT51_OR_LATER)
#error You need a Windows XP or later to run this stub because it uses these features:
#error   #error However, your C/C++ compilation flags indicate you intend to run this app on earlier systems.
#error This app will fail with the RPC_X_WRONG_STUB_VERSION error.
#endif


static const helperwrapper_MIDL_PROC_FORMAT_STRING helperwrapper__MIDL_ProcFormatString =
    {
        0,
        {

	/* Procedure XOCryptGenRandomWrp */

			0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
/*  6 */	NdrFcShort( 0x7 ),	/* 7 */
/*  8 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 10 */	NdrFcShort( 0x8 ),	/* 8 */
/* 12 */	NdrFcShort( 0x8 ),	/* 8 */
/* 14 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x3,		/* 3 */
/* 16 */	0x8,		/* 8 */
			0x43,		/* Ext Flags:  new corr desc, clt corr check, has range on conformance */
/* 18 */	NdrFcShort( 0x1d ),	/* 29 */
/* 20 */	NdrFcShort( 0x0 ),	/* 0 */
/* 22 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ulDataSize */

/* 24 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 26 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 28 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppsaData */

/* 30 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 32 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 34 */	NdrFcShort( 0x4a6 ),	/* Type Offset=1190 */

	/* Return value */

/* 36 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 38 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 40 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure DecryptWithMasterKeyWrp */

/* 42 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 44 */	NdrFcLong( 0x0 ),	/* 0 */
/* 48 */	NdrFcShort( 0x8 ),	/* 8 */
/* 50 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 52 */	NdrFcShort( 0x10 ),	/* 16 */
/* 54 */	NdrFcShort( 0x8 ),	/* 8 */
/* 56 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 58 */	0x8,		/* 8 */
			0x47,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, has range on conformance */
/* 60 */	NdrFcShort( 0x23 ),	/* 35 */
/* 62 */	NdrFcShort( 0x20 ),	/* 32 */
/* 64 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ulMasterKeyVersion */

/* 66 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 68 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 70 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pulDataSize */

/* 72 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 74 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 76 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter psaEncData */

/* 78 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 80 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 82 */	NdrFcShort( 0x4b8 ),	/* Type Offset=1208 */

	/* Parameter psaDecData */

/* 84 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 86 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 88 */	NdrFcShort( 0x4a6 ),	/* Type Offset=1190 */

	/* Return value */

/* 90 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 92 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 94 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GenPPAforDBWrp */

/* 96 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 98 */	NdrFcLong( 0x0 ),	/* 0 */
/* 102 */	NdrFcShort( 0x9 ),	/* 9 */
/* 104 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 106 */	NdrFcShort( 0x0 ),	/* 0 */
/* 108 */	NdrFcShort( 0x8 ),	/* 8 */
/* 110 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 112 */	0x8,		/* 8 */
			0x47,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, has range on conformance */
/* 114 */	NdrFcShort( 0x14f ),	/* 335 */
/* 116 */	NdrFcShort( 0x29 ),	/* 41 */
/* 118 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter bstrName */

/* 120 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 122 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 124 */	NdrFcShort( 0x4c6 ),	/* Type Offset=1222 */

	/* Parameter ppsaKey */

/* 126 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 128 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 130 */	NdrFcShort( 0x4b8 ),	/* Type Offset=1208 */

	/* Parameter ppsaSPPA */

/* 132 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 134 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 136 */	NdrFcShort( 0x4a6 ),	/* Type Offset=1190 */

	/* Parameter ppsaPPA */

/* 138 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 140 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 142 */	NdrFcShort( 0x4a6 ),	/* Type Offset=1190 */

	/* Return value */

/* 144 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 146 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 148 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure EncryptWithMasterKeyWrp */

/* 150 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 152 */	NdrFcLong( 0x0 ),	/* 0 */
/* 156 */	NdrFcShort( 0xa ),	/* 10 */
/* 158 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
/* 160 */	NdrFcShort( 0x18 ),	/* 24 */
/* 162 */	NdrFcShort( 0x8 ),	/* 8 */
/* 164 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x7,		/* 7 */
/* 166 */	0x8,		/* 8 */
			0x47,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, has range on conformance */
/* 168 */	NdrFcShort( 0x31 ),	/* 49 */
/* 170 */	NdrFcShort( 0x180 ),	/* 384 */
/* 172 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ulMasterKeyVersion */

/* 174 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 176 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 178 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter cbPublicKey */

/* 180 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 182 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 184 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter psaPublicKey */

/* 186 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 188 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 190 */	NdrFcShort( 0x4b8 ),	/* Type Offset=1208 */

	/* Parameter ulDataSize */

/* 192 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 194 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 196 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter psaDecData */

/* 198 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 200 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 202 */	NdrFcShort( 0x4b8 ),	/* Type Offset=1208 */

	/* Parameter psaEncData */

/* 204 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 206 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 208 */	NdrFcShort( 0x4a6 ),	/* Type Offset=1190 */

	/* Return value */

/* 210 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 212 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 214 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Init */

/* 216 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 218 */	NdrFcLong( 0x0 ),	/* 0 */
/* 222 */	NdrFcShort( 0x7 ),	/* 7 */
/* 224 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 226 */	NdrFcShort( 0x0 ),	/* 0 */
/* 228 */	NdrFcShort( 0x8 ),	/* 8 */
/* 230 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x2,		/* 2 */
/* 232 */	0x8,		/* 8 */
			0x45,		/* Ext Flags:  new corr desc, srv corr check, has range on conformance */
/* 234 */	NdrFcShort( 0x0 ),	/* 0 */
/* 236 */	NdrFcShort( 0x34 ),	/* 52 */
/* 238 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter saKEK */

/* 240 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 242 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 244 */	NdrFcShort( 0x4b8 ),	/* Type Offset=1208 */

	/* Return value */

/* 246 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 248 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 250 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Terminate */

/* 252 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 254 */	NdrFcLong( 0x0 ),	/* 0 */
/* 258 */	NdrFcShort( 0x8 ),	/* 8 */
/* 260 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 262 */	NdrFcShort( 0x0 ),	/* 0 */
/* 264 */	NdrFcShort( 0x8 ),	/* 8 */
/* 266 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x1,		/* 1 */
/* 268 */	0x8,		/* 8 */
			0x41,		/* Ext Flags:  new corr desc, has range on conformance */
/* 270 */	NdrFcShort( 0x0 ),	/* 0 */
/* 272 */	NdrFcShort( 0x0 ),	/* 0 */
/* 274 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Return value */

/* 276 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 278 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 280 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GenerateNewKey */

/* 282 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 284 */	NdrFcLong( 0x0 ),	/* 0 */
/* 288 */	NdrFcShort( 0x9 ),	/* 9 */
/* 290 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 292 */	NdrFcShort( 0x0 ),	/* 0 */
/* 294 */	NdrFcShort( 0x8 ),	/* 8 */
/* 296 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x4,		/* 4 */
/* 298 */	0x8,		/* 8 */
			0x43,		/* Ext Flags:  new corr desc, clt corr check, has range on conformance */
/* 300 */	NdrFcShort( 0x413 ),	/* 1043 */
/* 302 */	NdrFcShort( 0x0 ),	/* 0 */
/* 304 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter psaIV */

/* 306 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 308 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 310 */	NdrFcShort( 0x4a6 ),	/* Type Offset=1190 */

	/* Parameter psaEncryptedData */

/* 312 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 314 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 316 */	NdrFcShort( 0x4a6 ),	/* Type Offset=1190 */

	/* Parameter psaRawData */

/* 318 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 320 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 322 */	NdrFcShort( 0x4a6 ),	/* Type Offset=1190 */

	/* Return value */

/* 324 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 326 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 328 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure DecryptKey */

/* 330 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 332 */	NdrFcLong( 0x0 ),	/* 0 */
/* 336 */	NdrFcShort( 0xa ),	/* 10 */
/* 338 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 340 */	NdrFcShort( 0x0 ),	/* 0 */
/* 342 */	NdrFcShort( 0x8 ),	/* 8 */
/* 344 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 346 */	0x8,		/* 8 */
			0x47,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, has range on conformance */
/* 348 */	NdrFcShort( 0x3d ),	/* 61 */
/* 350 */	NdrFcShort( 0x262 ),	/* 610 */
/* 352 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter psaIV */

/* 354 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 356 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 358 */	NdrFcShort( 0x4b8 ),	/* Type Offset=1208 */

	/* Parameter psaEncryptedData */

/* 360 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 362 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 364 */	NdrFcShort( 0x4b8 ),	/* Type Offset=1208 */

	/* Parameter psaRawData */

/* 366 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 368 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 370 */	NdrFcShort( 0x4a6 ),	/* Type Offset=1190 */

	/* Return value */

/* 372 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 374 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 376 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure EncryptKey */

/* 378 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 380 */	NdrFcLong( 0x0 ),	/* 0 */
/* 384 */	NdrFcShort( 0xb ),	/* 11 */
/* 386 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 388 */	NdrFcShort( 0x0 ),	/* 0 */
/* 390 */	NdrFcShort( 0x8 ),	/* 8 */
/* 392 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 394 */	0x8,		/* 8 */
			0x47,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, has range on conformance */
/* 396 */	NdrFcShort( 0x32b ),	/* 811 */
/* 398 */	NdrFcShort( 0x40 ),	/* 64 */
/* 400 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter psaRawData */

/* 402 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 404 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 406 */	NdrFcShort( 0x4b8 ),	/* Type Offset=1208 */

	/* Parameter psaIV */

/* 408 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 410 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 412 */	NdrFcShort( 0x4a6 ),	/* Type Offset=1190 */

	/* Parameter psaEncryptedData */

/* 414 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 416 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 418 */	NdrFcShort( 0x4a6 ),	/* Type Offset=1190 */

	/* Return value */

/* 420 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 422 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 424 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

			0x0
        }
    };

static const helperwrapper_MIDL_TYPE_FORMAT_STRING helperwrapper__MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/*  4 */	NdrFcShort( 0x4a2 ),	/* Offset= 1186 (1190) */
/*  6 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/*  8 */	NdrFcShort( 0x2 ),	/* Offset= 2 (10) */
/* 10 */	
			0x13, 0x0,	/* FC_OP */
/* 12 */	NdrFcShort( 0x488 ),	/* Offset= 1160 (1172) */
/* 14 */	
			0x2a,		/* FC_ENCAPSULATED_UNION */
			0x49,		/* 73 */
/* 16 */	NdrFcShort( 0x18 ),	/* 24 */
/* 18 */	NdrFcShort( 0xa ),	/* 10 */
/* 20 */	NdrFcLong( 0x8 ),	/* 8 */
/* 24 */	NdrFcShort( 0x84 ),	/* Offset= 132 (156) */
/* 26 */	NdrFcLong( 0xd ),	/* 13 */
/* 30 */	NdrFcShort( 0xce ),	/* Offset= 206 (236) */
/* 32 */	NdrFcLong( 0x9 ),	/* 9 */
/* 36 */	NdrFcShort( 0x114 ),	/* Offset= 276 (312) */
/* 38 */	NdrFcLong( 0xc ),	/* 12 */
/* 42 */	NdrFcShort( 0x330 ),	/* Offset= 816 (858) */
/* 44 */	NdrFcLong( 0x24 ),	/* 36 */
/* 48 */	NdrFcShort( 0x364 ),	/* Offset= 868 (916) */
/* 50 */	NdrFcLong( 0x800d ),	/* 32781 */
/* 54 */	NdrFcShort( 0x380 ),	/* Offset= 896 (950) */
/* 56 */	NdrFcLong( 0x10 ),	/* 16 */
/* 60 */	NdrFcShort( 0x3a4 ),	/* Offset= 932 (992) */
/* 62 */	NdrFcLong( 0x2 ),	/* 2 */
/* 66 */	NdrFcShort( 0x3c8 ),	/* Offset= 968 (1034) */
/* 68 */	NdrFcLong( 0x3 ),	/* 3 */
/* 72 */	NdrFcShort( 0x3ec ),	/* Offset= 1004 (1076) */
/* 74 */	NdrFcLong( 0x14 ),	/* 20 */
/* 78 */	NdrFcShort( 0x410 ),	/* Offset= 1040 (1118) */
/* 80 */	NdrFcShort( 0xffff ),	/* Offset= -1 (79) */
/* 82 */	
			0x1b,		/* FC_CARRAY */
			0x1,		/* 1 */
/* 84 */	NdrFcShort( 0x2 ),	/* 2 */
/* 86 */	0x9,		/* Corr desc: FC_ULONG */
			0x0,		/*  */
/* 88 */	NdrFcShort( 0xfffc ),	/* -4 */
/* 90 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 92 */	0x0 , 
			0x0,		/* 0 */
/* 94 */	NdrFcLong( 0x0 ),	/* 0 */
/* 98 */	NdrFcLong( 0x0 ),	/* 0 */
/* 102 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 104 */	
			0x17,		/* FC_CSTRUCT */
			0x3,		/* 3 */
/* 106 */	NdrFcShort( 0x8 ),	/* 8 */
/* 108 */	NdrFcShort( 0xffe6 ),	/* Offset= -26 (82) */
/* 110 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 112 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 114 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 116 */	NdrFcShort( 0x4 ),	/* 4 */
/* 118 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 120 */	NdrFcShort( 0x0 ),	/* 0 */
/* 122 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 124 */	0x0 , 
			0x0,		/* 0 */
/* 126 */	NdrFcLong( 0x0 ),	/* 0 */
/* 130 */	NdrFcLong( 0x0 ),	/* 0 */
/* 134 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 136 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 138 */	NdrFcShort( 0x4 ),	/* 4 */
/* 140 */	NdrFcShort( 0x0 ),	/* 0 */
/* 142 */	NdrFcShort( 0x1 ),	/* 1 */
/* 144 */	NdrFcShort( 0x0 ),	/* 0 */
/* 146 */	NdrFcShort( 0x0 ),	/* 0 */
/* 148 */	0x13, 0x0,	/* FC_OP */
/* 150 */	NdrFcShort( 0xffd2 ),	/* Offset= -46 (104) */
/* 152 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 154 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 156 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 158 */	NdrFcShort( 0x8 ),	/* 8 */
/* 160 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 162 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 164 */	NdrFcShort( 0x4 ),	/* 4 */
/* 166 */	NdrFcShort( 0x4 ),	/* 4 */
/* 168 */	0x11, 0x0,	/* FC_RP */
/* 170 */	NdrFcShort( 0xffc8 ),	/* Offset= -56 (114) */
/* 172 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 174 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 176 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 178 */	NdrFcLong( 0x0 ),	/* 0 */
/* 182 */	NdrFcShort( 0x0 ),	/* 0 */
/* 184 */	NdrFcShort( 0x0 ),	/* 0 */
/* 186 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 188 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 190 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 192 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 194 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 196 */	NdrFcShort( 0x0 ),	/* 0 */
/* 198 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 200 */	NdrFcShort( 0x0 ),	/* 0 */
/* 202 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 204 */	0x0 , 
			0x0,		/* 0 */
/* 206 */	NdrFcLong( 0x0 ),	/* 0 */
/* 210 */	NdrFcLong( 0x0 ),	/* 0 */
/* 214 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 218 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 220 */	0x0 , 
			0x0,		/* 0 */
/* 222 */	NdrFcLong( 0x0 ),	/* 0 */
/* 226 */	NdrFcLong( 0x0 ),	/* 0 */
/* 230 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 232 */	NdrFcShort( 0xffc8 ),	/* Offset= -56 (176) */
/* 234 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 236 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 238 */	NdrFcShort( 0x8 ),	/* 8 */
/* 240 */	NdrFcShort( 0x0 ),	/* 0 */
/* 242 */	NdrFcShort( 0x6 ),	/* Offset= 6 (248) */
/* 244 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 246 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 248 */	
			0x11, 0x0,	/* FC_RP */
/* 250 */	NdrFcShort( 0xffc8 ),	/* Offset= -56 (194) */
/* 252 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 254 */	NdrFcLong( 0x20400 ),	/* 132096 */
/* 258 */	NdrFcShort( 0x0 ),	/* 0 */
/* 260 */	NdrFcShort( 0x0 ),	/* 0 */
/* 262 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 264 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 266 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 268 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 270 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 272 */	NdrFcShort( 0x0 ),	/* 0 */
/* 274 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 276 */	NdrFcShort( 0x0 ),	/* 0 */
/* 278 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 280 */	0x0 , 
			0x0,		/* 0 */
/* 282 */	NdrFcLong( 0x0 ),	/* 0 */
/* 286 */	NdrFcLong( 0x0 ),	/* 0 */
/* 290 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 294 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 296 */	0x0 , 
			0x0,		/* 0 */
/* 298 */	NdrFcLong( 0x0 ),	/* 0 */
/* 302 */	NdrFcLong( 0x0 ),	/* 0 */
/* 306 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 308 */	NdrFcShort( 0xffc8 ),	/* Offset= -56 (252) */
/* 310 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 312 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 314 */	NdrFcShort( 0x8 ),	/* 8 */
/* 316 */	NdrFcShort( 0x0 ),	/* 0 */
/* 318 */	NdrFcShort( 0x6 ),	/* Offset= 6 (324) */
/* 320 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 322 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 324 */	
			0x11, 0x0,	/* FC_RP */
/* 326 */	NdrFcShort( 0xffc8 ),	/* Offset= -56 (270) */
/* 328 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0x9,		/* FC_ULONG */
/* 330 */	0x7,		/* Corr desc: FC_USHORT */
			0x0,		/*  */
/* 332 */	NdrFcShort( 0xfff8 ),	/* -8 */
/* 334 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 336 */	0x0 , 
			0x0,		/* 0 */
/* 338 */	NdrFcLong( 0x0 ),	/* 0 */
/* 342 */	NdrFcLong( 0x0 ),	/* 0 */
/* 346 */	NdrFcShort( 0x2 ),	/* Offset= 2 (348) */
/* 348 */	NdrFcShort( 0x10 ),	/* 16 */
/* 350 */	NdrFcShort( 0x2f ),	/* 47 */
/* 352 */	NdrFcLong( 0x14 ),	/* 20 */
/* 356 */	NdrFcShort( 0x800b ),	/* Simple arm type: FC_HYPER */
/* 358 */	NdrFcLong( 0x3 ),	/* 3 */
/* 362 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 364 */	NdrFcLong( 0x11 ),	/* 17 */
/* 368 */	NdrFcShort( 0x8001 ),	/* Simple arm type: FC_BYTE */
/* 370 */	NdrFcLong( 0x2 ),	/* 2 */
/* 374 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 376 */	NdrFcLong( 0x4 ),	/* 4 */
/* 380 */	NdrFcShort( 0x800a ),	/* Simple arm type: FC_FLOAT */
/* 382 */	NdrFcLong( 0x5 ),	/* 5 */
/* 386 */	NdrFcShort( 0x800c ),	/* Simple arm type: FC_DOUBLE */
/* 388 */	NdrFcLong( 0xb ),	/* 11 */
/* 392 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 394 */	NdrFcLong( 0xa ),	/* 10 */
/* 398 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 400 */	NdrFcLong( 0x6 ),	/* 6 */
/* 404 */	NdrFcShort( 0xe8 ),	/* Offset= 232 (636) */
/* 406 */	NdrFcLong( 0x7 ),	/* 7 */
/* 410 */	NdrFcShort( 0x800c ),	/* Simple arm type: FC_DOUBLE */
/* 412 */	NdrFcLong( 0x8 ),	/* 8 */
/* 416 */	NdrFcShort( 0xe2 ),	/* Offset= 226 (642) */
/* 418 */	NdrFcLong( 0xd ),	/* 13 */
/* 422 */	NdrFcShort( 0xff0a ),	/* Offset= -246 (176) */
/* 424 */	NdrFcLong( 0x9 ),	/* 9 */
/* 428 */	NdrFcShort( 0xff50 ),	/* Offset= -176 (252) */
/* 430 */	NdrFcLong( 0x2000 ),	/* 8192 */
/* 434 */	NdrFcShort( 0xd4 ),	/* Offset= 212 (646) */
/* 436 */	NdrFcLong( 0x24 ),	/* 36 */
/* 440 */	NdrFcShort( 0xd6 ),	/* Offset= 214 (654) */
/* 442 */	NdrFcLong( 0x4024 ),	/* 16420 */
/* 446 */	NdrFcShort( 0xd0 ),	/* Offset= 208 (654) */
/* 448 */	NdrFcLong( 0x4011 ),	/* 16401 */
/* 452 */	NdrFcShort( 0x10a ),	/* Offset= 266 (718) */
/* 454 */	NdrFcLong( 0x4002 ),	/* 16386 */
/* 458 */	NdrFcShort( 0x108 ),	/* Offset= 264 (722) */
/* 460 */	NdrFcLong( 0x4003 ),	/* 16387 */
/* 464 */	NdrFcShort( 0x106 ),	/* Offset= 262 (726) */
/* 466 */	NdrFcLong( 0x4014 ),	/* 16404 */
/* 470 */	NdrFcShort( 0x104 ),	/* Offset= 260 (730) */
/* 472 */	NdrFcLong( 0x4004 ),	/* 16388 */
/* 476 */	NdrFcShort( 0x102 ),	/* Offset= 258 (734) */
/* 478 */	NdrFcLong( 0x4005 ),	/* 16389 */
/* 482 */	NdrFcShort( 0x100 ),	/* Offset= 256 (738) */
/* 484 */	NdrFcLong( 0x400b ),	/* 16395 */
/* 488 */	NdrFcShort( 0xea ),	/* Offset= 234 (722) */
/* 490 */	NdrFcLong( 0x400a ),	/* 16394 */
/* 494 */	NdrFcShort( 0xe8 ),	/* Offset= 232 (726) */
/* 496 */	NdrFcLong( 0x4006 ),	/* 16390 */
/* 500 */	NdrFcShort( 0xf2 ),	/* Offset= 242 (742) */
/* 502 */	NdrFcLong( 0x4007 ),	/* 16391 */
/* 506 */	NdrFcShort( 0xe8 ),	/* Offset= 232 (738) */
/* 508 */	NdrFcLong( 0x4008 ),	/* 16392 */
/* 512 */	NdrFcShort( 0xea ),	/* Offset= 234 (746) */
/* 514 */	NdrFcLong( 0x400d ),	/* 16397 */
/* 518 */	NdrFcShort( 0xe8 ),	/* Offset= 232 (750) */
/* 520 */	NdrFcLong( 0x4009 ),	/* 16393 */
/* 524 */	NdrFcShort( 0xe6 ),	/* Offset= 230 (754) */
/* 526 */	NdrFcLong( 0x6000 ),	/* 24576 */
/* 530 */	NdrFcShort( 0xe4 ),	/* Offset= 228 (758) */
/* 532 */	NdrFcLong( 0x400c ),	/* 16396 */
/* 536 */	NdrFcShort( 0xea ),	/* Offset= 234 (770) */
/* 538 */	NdrFcLong( 0x10 ),	/* 16 */
/* 542 */	NdrFcShort( 0x8002 ),	/* Simple arm type: FC_CHAR */
/* 544 */	NdrFcLong( 0x12 ),	/* 18 */
/* 548 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 550 */	NdrFcLong( 0x13 ),	/* 19 */
/* 554 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 556 */	NdrFcLong( 0x15 ),	/* 21 */
/* 560 */	NdrFcShort( 0x800b ),	/* Simple arm type: FC_HYPER */
/* 562 */	NdrFcLong( 0x16 ),	/* 22 */
/* 566 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 568 */	NdrFcLong( 0x17 ),	/* 23 */
/* 572 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 574 */	NdrFcLong( 0xe ),	/* 14 */
/* 578 */	NdrFcShort( 0xc8 ),	/* Offset= 200 (778) */
/* 580 */	NdrFcLong( 0x400e ),	/* 16398 */
/* 584 */	NdrFcShort( 0xcc ),	/* Offset= 204 (788) */
/* 586 */	NdrFcLong( 0x4010 ),	/* 16400 */
/* 590 */	NdrFcShort( 0xca ),	/* Offset= 202 (792) */
/* 592 */	NdrFcLong( 0x4012 ),	/* 16402 */
/* 596 */	NdrFcShort( 0x7e ),	/* Offset= 126 (722) */
/* 598 */	NdrFcLong( 0x4013 ),	/* 16403 */
/* 602 */	NdrFcShort( 0x7c ),	/* Offset= 124 (726) */
/* 604 */	NdrFcLong( 0x4015 ),	/* 16405 */
/* 608 */	NdrFcShort( 0x7a ),	/* Offset= 122 (730) */
/* 610 */	NdrFcLong( 0x4016 ),	/* 16406 */
/* 614 */	NdrFcShort( 0x70 ),	/* Offset= 112 (726) */
/* 616 */	NdrFcLong( 0x4017 ),	/* 16407 */
/* 620 */	NdrFcShort( 0x6a ),	/* Offset= 106 (726) */
/* 622 */	NdrFcLong( 0x0 ),	/* 0 */
/* 626 */	NdrFcShort( 0x0 ),	/* Offset= 0 (626) */
/* 628 */	NdrFcLong( 0x1 ),	/* 1 */
/* 632 */	NdrFcShort( 0x0 ),	/* Offset= 0 (632) */
/* 634 */	NdrFcShort( 0xffff ),	/* Offset= -1 (633) */
/* 636 */	
			0x15,		/* FC_STRUCT */
			0x7,		/* 7 */
/* 638 */	NdrFcShort( 0x8 ),	/* 8 */
/* 640 */	0xb,		/* FC_HYPER */
			0x5b,		/* FC_END */
/* 642 */	
			0x13, 0x0,	/* FC_OP */
/* 644 */	NdrFcShort( 0xfde4 ),	/* Offset= -540 (104) */
/* 646 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 648 */	NdrFcShort( 0x2 ),	/* Offset= 2 (650) */
/* 650 */	
			0x13, 0x0,	/* FC_OP */
/* 652 */	NdrFcShort( 0x208 ),	/* Offset= 520 (1172) */
/* 654 */	
			0x13, 0x0,	/* FC_OP */
/* 656 */	NdrFcShort( 0x2a ),	/* Offset= 42 (698) */
/* 658 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 660 */	NdrFcLong( 0x2f ),	/* 47 */
/* 664 */	NdrFcShort( 0x0 ),	/* 0 */
/* 666 */	NdrFcShort( 0x0 ),	/* 0 */
/* 668 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 670 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 672 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 674 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 676 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 678 */	NdrFcShort( 0x1 ),	/* 1 */
/* 680 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 682 */	NdrFcShort( 0x4 ),	/* 4 */
/* 684 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 686 */	0x0 , 
			0x0,		/* 0 */
/* 688 */	NdrFcLong( 0x0 ),	/* 0 */
/* 692 */	NdrFcLong( 0x0 ),	/* 0 */
/* 696 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 698 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 700 */	NdrFcShort( 0x10 ),	/* 16 */
/* 702 */	NdrFcShort( 0x0 ),	/* 0 */
/* 704 */	NdrFcShort( 0xa ),	/* Offset= 10 (714) */
/* 706 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 708 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 710 */	NdrFcShort( 0xffcc ),	/* Offset= -52 (658) */
/* 712 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 714 */	
			0x13, 0x20,	/* FC_OP [maybenull_sizeis] */
/* 716 */	NdrFcShort( 0xffd8 ),	/* Offset= -40 (676) */
/* 718 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 720 */	0x1,		/* FC_BYTE */
			0x5c,		/* FC_PAD */
/* 722 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 724 */	0x6,		/* FC_SHORT */
			0x5c,		/* FC_PAD */
/* 726 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 728 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 730 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 732 */	0xb,		/* FC_HYPER */
			0x5c,		/* FC_PAD */
/* 734 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 736 */	0xa,		/* FC_FLOAT */
			0x5c,		/* FC_PAD */
/* 738 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 740 */	0xc,		/* FC_DOUBLE */
			0x5c,		/* FC_PAD */
/* 742 */	
			0x13, 0x0,	/* FC_OP */
/* 744 */	NdrFcShort( 0xff94 ),	/* Offset= -108 (636) */
/* 746 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 748 */	NdrFcShort( 0xff96 ),	/* Offset= -106 (642) */
/* 750 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 752 */	NdrFcShort( 0xfdc0 ),	/* Offset= -576 (176) */
/* 754 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 756 */	NdrFcShort( 0xfe08 ),	/* Offset= -504 (252) */
/* 758 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 760 */	NdrFcShort( 0x2 ),	/* Offset= 2 (762) */
/* 762 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 764 */	NdrFcShort( 0x2 ),	/* Offset= 2 (766) */
/* 766 */	
			0x13, 0x0,	/* FC_OP */
/* 768 */	NdrFcShort( 0x194 ),	/* Offset= 404 (1172) */
/* 770 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 772 */	NdrFcShort( 0x2 ),	/* Offset= 2 (774) */
/* 774 */	
			0x13, 0x0,	/* FC_OP */
/* 776 */	NdrFcShort( 0x14 ),	/* Offset= 20 (796) */
/* 778 */	
			0x15,		/* FC_STRUCT */
			0x7,		/* 7 */
/* 780 */	NdrFcShort( 0x10 ),	/* 16 */
/* 782 */	0x6,		/* FC_SHORT */
			0x1,		/* FC_BYTE */
/* 784 */	0x1,		/* FC_BYTE */
			0x8,		/* FC_LONG */
/* 786 */	0xb,		/* FC_HYPER */
			0x5b,		/* FC_END */
/* 788 */	
			0x13, 0x0,	/* FC_OP */
/* 790 */	NdrFcShort( 0xfff4 ),	/* Offset= -12 (778) */
/* 792 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 794 */	0x2,		/* FC_CHAR */
			0x5c,		/* FC_PAD */
/* 796 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x7,		/* 7 */
/* 798 */	NdrFcShort( 0x20 ),	/* 32 */
/* 800 */	NdrFcShort( 0x0 ),	/* 0 */
/* 802 */	NdrFcShort( 0x0 ),	/* Offset= 0 (802) */
/* 804 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 806 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 808 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 810 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 812 */	NdrFcShort( 0xfe1c ),	/* Offset= -484 (328) */
/* 814 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 816 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 818 */	NdrFcShort( 0x4 ),	/* 4 */
/* 820 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 822 */	NdrFcShort( 0x0 ),	/* 0 */
/* 824 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 826 */	0x0 , 
			0x0,		/* 0 */
/* 828 */	NdrFcLong( 0x0 ),	/* 0 */
/* 832 */	NdrFcLong( 0x0 ),	/* 0 */
/* 836 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 838 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 840 */	NdrFcShort( 0x4 ),	/* 4 */
/* 842 */	NdrFcShort( 0x0 ),	/* 0 */
/* 844 */	NdrFcShort( 0x1 ),	/* 1 */
/* 846 */	NdrFcShort( 0x0 ),	/* 0 */
/* 848 */	NdrFcShort( 0x0 ),	/* 0 */
/* 850 */	0x13, 0x0,	/* FC_OP */
/* 852 */	NdrFcShort( 0xffc8 ),	/* Offset= -56 (796) */
/* 854 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 856 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 858 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 860 */	NdrFcShort( 0x8 ),	/* 8 */
/* 862 */	NdrFcShort( 0x0 ),	/* 0 */
/* 864 */	NdrFcShort( 0x6 ),	/* Offset= 6 (870) */
/* 866 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 868 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 870 */	
			0x11, 0x0,	/* FC_RP */
/* 872 */	NdrFcShort( 0xffc8 ),	/* Offset= -56 (816) */
/* 874 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 876 */	NdrFcShort( 0x4 ),	/* 4 */
/* 878 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 880 */	NdrFcShort( 0x0 ),	/* 0 */
/* 882 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 884 */	0x0 , 
			0x0,		/* 0 */
/* 886 */	NdrFcLong( 0x0 ),	/* 0 */
/* 890 */	NdrFcLong( 0x0 ),	/* 0 */
/* 894 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 896 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 898 */	NdrFcShort( 0x4 ),	/* 4 */
/* 900 */	NdrFcShort( 0x0 ),	/* 0 */
/* 902 */	NdrFcShort( 0x1 ),	/* 1 */
/* 904 */	NdrFcShort( 0x0 ),	/* 0 */
/* 906 */	NdrFcShort( 0x0 ),	/* 0 */
/* 908 */	0x13, 0x0,	/* FC_OP */
/* 910 */	NdrFcShort( 0xff2c ),	/* Offset= -212 (698) */
/* 912 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 914 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 916 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 918 */	NdrFcShort( 0x8 ),	/* 8 */
/* 920 */	NdrFcShort( 0x0 ),	/* 0 */
/* 922 */	NdrFcShort( 0x6 ),	/* Offset= 6 (928) */
/* 924 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 926 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 928 */	
			0x11, 0x0,	/* FC_RP */
/* 930 */	NdrFcShort( 0xffc8 ),	/* Offset= -56 (874) */
/* 932 */	
			0x1d,		/* FC_SMFARRAY */
			0x0,		/* 0 */
/* 934 */	NdrFcShort( 0x8 ),	/* 8 */
/* 936 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 938 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 940 */	NdrFcShort( 0x10 ),	/* 16 */
/* 942 */	0x8,		/* FC_LONG */
			0x6,		/* FC_SHORT */
/* 944 */	0x6,		/* FC_SHORT */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 946 */	0x0,		/* 0 */
			NdrFcShort( 0xfff1 ),	/* Offset= -15 (932) */
			0x5b,		/* FC_END */
/* 950 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 952 */	NdrFcShort( 0x18 ),	/* 24 */
/* 954 */	NdrFcShort( 0x0 ),	/* 0 */
/* 956 */	NdrFcShort( 0xa ),	/* Offset= 10 (966) */
/* 958 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 960 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 962 */	NdrFcShort( 0xffe8 ),	/* Offset= -24 (938) */
/* 964 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 966 */	
			0x11, 0x0,	/* FC_RP */
/* 968 */	NdrFcShort( 0xfcfa ),	/* Offset= -774 (194) */
/* 970 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 972 */	NdrFcShort( 0x1 ),	/* 1 */
/* 974 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 976 */	NdrFcShort( 0x0 ),	/* 0 */
/* 978 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 980 */	0x0 , 
			0x0,		/* 0 */
/* 982 */	NdrFcLong( 0x0 ),	/* 0 */
/* 986 */	NdrFcLong( 0x0 ),	/* 0 */
/* 990 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 992 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 994 */	NdrFcShort( 0x8 ),	/* 8 */
/* 996 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 998 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1000 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1002 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1004 */	0x13, 0x20,	/* FC_OP [maybenull_sizeis] */
/* 1006 */	NdrFcShort( 0xffdc ),	/* Offset= -36 (970) */
/* 1008 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1010 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1012 */	
			0x1b,		/* FC_CARRAY */
			0x1,		/* 1 */
/* 1014 */	NdrFcShort( 0x2 ),	/* 2 */
/* 1016 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1018 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1020 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1022 */	0x0 , 
			0x0,		/* 0 */
/* 1024 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1028 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1032 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 1034 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 1036 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1038 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1040 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1042 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1044 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1046 */	0x13, 0x20,	/* FC_OP [maybenull_sizeis] */
/* 1048 */	NdrFcShort( 0xffdc ),	/* Offset= -36 (1012) */
/* 1050 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1052 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1054 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 1056 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1058 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1060 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1062 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1064 */	0x0 , 
			0x0,		/* 0 */
/* 1066 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1070 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1074 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1076 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 1078 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1080 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1082 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1084 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1086 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1088 */	0x13, 0x20,	/* FC_OP [maybenull_sizeis] */
/* 1090 */	NdrFcShort( 0xffdc ),	/* Offset= -36 (1054) */
/* 1092 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1094 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1096 */	
			0x1b,		/* FC_CARRAY */
			0x7,		/* 7 */
/* 1098 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1100 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1102 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1104 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1106 */	0x0 , 
			0x0,		/* 0 */
/* 1108 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1112 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1116 */	0xb,		/* FC_HYPER */
			0x5b,		/* FC_END */
/* 1118 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 1120 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1122 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1124 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1126 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1128 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1130 */	0x13, 0x20,	/* FC_OP [maybenull_sizeis] */
/* 1132 */	NdrFcShort( 0xffdc ),	/* Offset= -36 (1096) */
/* 1134 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1136 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1138 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 1140 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1142 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1144 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1146 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 1148 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1150 */	0x7,		/* Corr desc: FC_USHORT */
			0x0,		/*  */
/* 1152 */	NdrFcShort( 0xffd8 ),	/* -40 */
/* 1154 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1156 */	0x0 , 
			0x0,		/* 0 */
/* 1158 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1162 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1166 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1168 */	NdrFcShort( 0xffe2 ),	/* Offset= -30 (1138) */
/* 1170 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1172 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1174 */	NdrFcShort( 0x28 ),	/* 40 */
/* 1176 */	NdrFcShort( 0xffe2 ),	/* Offset= -30 (1146) */
/* 1178 */	NdrFcShort( 0x0 ),	/* Offset= 0 (1178) */
/* 1180 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 1182 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1184 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1186 */	NdrFcShort( 0xfb6c ),	/* Offset= -1172 (14) */
/* 1188 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1190 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 1192 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1194 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1196 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1198 */	NdrFcShort( 0xfb58 ),	/* Offset= -1192 (6) */
/* 1200 */	
			0x12, 0x10,	/* FC_UP [pointer_deref] */
/* 1202 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1204) */
/* 1204 */	
			0x12, 0x0,	/* FC_UP */
/* 1206 */	NdrFcShort( 0xffde ),	/* Offset= -34 (1172) */
/* 1208 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 1210 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1212 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1214 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1216 */	NdrFcShort( 0xfff0 ),	/* Offset= -16 (1200) */
/* 1218 */	
			0x12, 0x0,	/* FC_UP */
/* 1220 */	NdrFcShort( 0xfba4 ),	/* Offset= -1116 (104) */
/* 1222 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 1224 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1226 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1228 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1230 */	NdrFcShort( 0xfff4 ),	/* Offset= -12 (1218) */

			0x0
        }
    };

static const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ] = 
        {
            
            {
            LPSAFEARRAY_UserSize
            ,LPSAFEARRAY_UserMarshal
            ,LPSAFEARRAY_UserUnmarshal
            ,LPSAFEARRAY_UserFree
            },
            {
            BSTR_UserSize
            ,BSTR_UserMarshal
            ,BSTR_UserUnmarshal
            ,BSTR_UserFree
            }

        };



/* Object interface: IUnknown, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: IDispatch, ver. 0.0,
   GUID={0x00020400,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: IXoCryptoWrapper, ver. 0.0,
   GUID={0x4CC1CC3B,0x38A6,0x4AF2,{0xB7,0x5F,0xE4,0x57,0xA4,0x50,0x72,0x52}} */

#pragma code_seg(".orpc")
static const unsigned short IXoCryptoWrapper_FormatStringOffsetTable[] =
    {
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    0,
    42,
    96,
    150
    };

static const MIDL_STUBLESS_PROXY_INFO IXoCryptoWrapper_ProxyInfo =
    {
    &Object_StubDesc,
    helperwrapper__MIDL_ProcFormatString.Format,
    &IXoCryptoWrapper_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IXoCryptoWrapper_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    helperwrapper__MIDL_ProcFormatString.Format,
    &IXoCryptoWrapper_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(11) _IXoCryptoWrapperProxyVtbl = 
{
    &IXoCryptoWrapper_ProxyInfo,
    &IID_IXoCryptoWrapper,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    0 /* (void *) (INT_PTR) -1 /* IDispatch::GetTypeInfoCount */ ,
    0 /* (void *) (INT_PTR) -1 /* IDispatch::GetTypeInfo */ ,
    0 /* (void *) (INT_PTR) -1 /* IDispatch::GetIDsOfNames */ ,
    0 /* IDispatch_Invoke_Proxy */ ,
    (void *) (INT_PTR) -1 /* IXoCryptoWrapper::XOCryptGenRandomWrp */ ,
    (void *) (INT_PTR) -1 /* IXoCryptoWrapper::DecryptWithMasterKeyWrp */ ,
    (void *) (INT_PTR) -1 /* IXoCryptoWrapper::GenPPAforDBWrp */ ,
    (void *) (INT_PTR) -1 /* IXoCryptoWrapper::EncryptWithMasterKeyWrp */
};


static const PRPC_STUB_FUNCTION IXoCryptoWrapper_table[] =
{
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2
};

CInterfaceStubVtbl _IXoCryptoWrapperStubVtbl =
{
    &IID_IXoCryptoWrapper,
    &IXoCryptoWrapper_ServerInfo,
    11,
    &IXoCryptoWrapper_table[-3],
    CStdStubBuffer_DELEGATING_METHODS
};


/* Object interface: IXoKeyEncryptionHelperWrp, ver. 0.0,
   GUID={0x86BA703A,0xDEDA,0x42DC,{0x8A,0x27,0x62,0x2F,0x39,0xB1,0x3D,0x9F}} */

#pragma code_seg(".orpc")
static const unsigned short IXoKeyEncryptionHelperWrp_FormatStringOffsetTable[] =
    {
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    216,
    252,
    282,
    330,
    378
    };

static const MIDL_STUBLESS_PROXY_INFO IXoKeyEncryptionHelperWrp_ProxyInfo =
    {
    &Object_StubDesc,
    helperwrapper__MIDL_ProcFormatString.Format,
    &IXoKeyEncryptionHelperWrp_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IXoKeyEncryptionHelperWrp_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    helperwrapper__MIDL_ProcFormatString.Format,
    &IXoKeyEncryptionHelperWrp_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(12) _IXoKeyEncryptionHelperWrpProxyVtbl = 
{
    &IXoKeyEncryptionHelperWrp_ProxyInfo,
    &IID_IXoKeyEncryptionHelperWrp,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    0 /* (void *) (INT_PTR) -1 /* IDispatch::GetTypeInfoCount */ ,
    0 /* (void *) (INT_PTR) -1 /* IDispatch::GetTypeInfo */ ,
    0 /* (void *) (INT_PTR) -1 /* IDispatch::GetIDsOfNames */ ,
    0 /* IDispatch_Invoke_Proxy */ ,
    (void *) (INT_PTR) -1 /* IXoKeyEncryptionHelperWrp::Init */ ,
    (void *) (INT_PTR) -1 /* IXoKeyEncryptionHelperWrp::Terminate */ ,
    (void *) (INT_PTR) -1 /* IXoKeyEncryptionHelperWrp::GenerateNewKey */ ,
    (void *) (INT_PTR) -1 /* IXoKeyEncryptionHelperWrp::DecryptKey */ ,
    (void *) (INT_PTR) -1 /* IXoKeyEncryptionHelperWrp::EncryptKey */
};


static const PRPC_STUB_FUNCTION IXoKeyEncryptionHelperWrp_table[] =
{
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2
};

CInterfaceStubVtbl _IXoKeyEncryptionHelperWrpStubVtbl =
{
    &IID_IXoKeyEncryptionHelperWrp,
    &IXoKeyEncryptionHelperWrp_ServerInfo,
    12,
    &IXoKeyEncryptionHelperWrp_table[-3],
    CStdStubBuffer_DELEGATING_METHODS
};

static const MIDL_STUB_DESC Object_StubDesc = 
    {
    0,
    NdrOleAllocate,
    NdrOleFree,
    0,
    0,
    0,
    0,
    0,
    helperwrapper__MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x60001, /* Ndr library version */
    0,
    0x70001f4, /* MIDL Version 7.0.500 */
    0,
    UserMarshalRoutines,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0, /* cs routines */
    0,   /* proxy/server info */
    0
    };

const CInterfaceProxyVtbl * _helperwrapper_ProxyVtblList[] = 
{
    ( CInterfaceProxyVtbl *) &_IXoKeyEncryptionHelperWrpProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IXoCryptoWrapperProxyVtbl,
    0
};

const CInterfaceStubVtbl * _helperwrapper_StubVtblList[] = 
{
    ( CInterfaceStubVtbl *) &_IXoKeyEncryptionHelperWrpStubVtbl,
    ( CInterfaceStubVtbl *) &_IXoCryptoWrapperStubVtbl,
    0
};

PCInterfaceName const _helperwrapper_InterfaceNamesList[] = 
{
    "IXoKeyEncryptionHelperWrp",
    "IXoCryptoWrapper",
    0
};

const IID *  _helperwrapper_BaseIIDList[] = 
{
    &IID_IDispatch,
    &IID_IDispatch,
    0
};


#define _helperwrapper_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _helperwrapper, pIID, n)

int __stdcall _helperwrapper_IID_Lookup( const IID * pIID, int * pIndex )
{
    IID_BS_LOOKUP_SETUP

    IID_BS_LOOKUP_INITIAL_TEST( _helperwrapper, 2, 1 )
    IID_BS_LOOKUP_RETURN_RESULT( _helperwrapper, 2, *pIndex )
    
}

const ExtendedProxyFileInfo helperwrapper_ProxyFileInfo = 
{
    (PCInterfaceProxyVtblList *) & _helperwrapper_ProxyVtblList,
    (PCInterfaceStubVtblList *) & _helperwrapper_StubVtblList,
    (const PCInterfaceName * ) & _helperwrapper_InterfaceNamesList,
    (const IID ** ) & _helperwrapper_BaseIIDList,
    & _helperwrapper_IID_Lookup, 
    2,
    2,
    0, /* table of [async_uuid] interfaces */
    0, /* Filler1 */
    0, /* Filler2 */
    0  /* Filler3 */
};
#pragma optimize("", on )
#if _MSC_VER >= 1200
#pragma warning(pop)
#endif


#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\crypto\helperwrappermanaged\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\crypto\helperwrapper\objd\i386\helperwrapper_i.c ===
/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 7.00.0500 */
/* Compiler settings for helperwrapper.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, oldnames, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IXoCryptoWrapper,0x4CC1CC3B,0x38A6,0x4AF2,0xB7,0x5F,0xE4,0x57,0xA4,0x50,0x72,0x52);


MIDL_DEFINE_GUID(IID, IID_IXoKeyEncryptionHelperWrp,0x86BA703A,0xDEDA,0x42DC,0x8A,0x27,0x62,0x2F,0x39,0xB1,0x3D,0x9F);


MIDL_DEFINE_GUID(IID, LIBID_HELPERWRAPPERLib,0x9339844B,0x3E09,0x4502,0x8F,0x9B,0xDC,0xF1,0xFD,0x6D,0x16,0x6C);


MIDL_DEFINE_GUID(CLSID, CLSID_XoCryptoWrapper,0x007CDE6D,0x353E,0x4F97,0x98,0xE2,0xB3,0x51,0xD0,0x09,0xBD,0x1B);


MIDL_DEFINE_GUID(CLSID, CLSID_XoKeyEncryptionHelperWrp,0x50C34C88,0x45C4,0x483F,0x94,0xA5,0xFE,0xB3,0x2E,0x6E,0x2A,0x71);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\crypto\helperwrapper\objd\i386\helperwrapper.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0500 */
/* Compiler settings for helperwrapper.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, oldnames, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __helperwrapper_h__
#define __helperwrapper_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IXoCryptoWrapper_FWD_DEFINED__
#define __IXoCryptoWrapper_FWD_DEFINED__
typedef interface IXoCryptoWrapper IXoCryptoWrapper;
#endif 	/* __IXoCryptoWrapper_FWD_DEFINED__ */


#ifndef __IXoKeyEncryptionHelperWrp_FWD_DEFINED__
#define __IXoKeyEncryptionHelperWrp_FWD_DEFINED__
typedef interface IXoKeyEncryptionHelperWrp IXoKeyEncryptionHelperWrp;
#endif 	/* __IXoKeyEncryptionHelperWrp_FWD_DEFINED__ */


#ifndef __XoCryptoWrapper_FWD_DEFINED__
#define __XoCryptoWrapper_FWD_DEFINED__

#ifdef __cplusplus
typedef class XoCryptoWrapper XoCryptoWrapper;
#else
typedef struct XoCryptoWrapper XoCryptoWrapper;
#endif /* __cplusplus */

#endif 	/* __XoCryptoWrapper_FWD_DEFINED__ */


#ifndef __XoKeyEncryptionHelperWrp_FWD_DEFINED__
#define __XoKeyEncryptionHelperWrp_FWD_DEFINED__

#ifdef __cplusplus
typedef class XoKeyEncryptionHelperWrp XoKeyEncryptionHelperWrp;
#else
typedef struct XoKeyEncryptionHelperWrp XoKeyEncryptionHelperWrp;
#endif /* __cplusplus */

#endif 	/* __XoKeyEncryptionHelperWrp_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IXoCryptoWrapper_INTERFACE_DEFINED__
#define __IXoCryptoWrapper_INTERFACE_DEFINED__

/* interface IXoCryptoWrapper */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IXoCryptoWrapper;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4CC1CC3B-38A6-4AF2-B75F-E457A4507252")
    IXoCryptoWrapper : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE XOCryptGenRandomWrp( 
            /* [in] */ unsigned long ulDataSize,
            /* [retval][out] */ SAFEARRAY * *ppsaData) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE DecryptWithMasterKeyWrp( 
            /* [in] */ unsigned long ulMasterKeyVersion,
            /* [in] */ unsigned long pulDataSize,
            /* [in] */ SAFEARRAY * psaEncData,
            /* [retval][out] */ SAFEARRAY * *psaDecData) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GenPPAforDBWrp( 
            /* [in] */ BSTR bstrName,
            /* [in] */ SAFEARRAY * ppsaKey,
            /* [out] */ SAFEARRAY * *ppsaSPPA,
            /* [out] */ SAFEARRAY * *ppsaPPA) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE EncryptWithMasterKeyWrp( 
            /* [in] */ unsigned long ulMasterKeyVersion,
            /* [in] */ unsigned long cbPublicKey,
            /* [in] */ SAFEARRAY * psaPublicKey,
            /* [in] */ unsigned long ulDataSize,
            /* [in] */ SAFEARRAY * psaDecData,
            /* [retval][out] */ SAFEARRAY * *psaEncData) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXoCryptoWrapperVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXoCryptoWrapper * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXoCryptoWrapper * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXoCryptoWrapper * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IXoCryptoWrapper * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IXoCryptoWrapper * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IXoCryptoWrapper * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IXoCryptoWrapper * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *XOCryptGenRandomWrp )( 
            IXoCryptoWrapper * This,
            /* [in] */ unsigned long ulDataSize,
            /* [retval][out] */ SAFEARRAY * *ppsaData);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *DecryptWithMasterKeyWrp )( 
            IXoCryptoWrapper * This,
            /* [in] */ unsigned long ulMasterKeyVersion,
            /* [in] */ unsigned long pulDataSize,
            /* [in] */ SAFEARRAY * psaEncData,
            /* [retval][out] */ SAFEARRAY * *psaDecData);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GenPPAforDBWrp )( 
            IXoCryptoWrapper * This,
            /* [in] */ BSTR bstrName,
            /* [in] */ SAFEARRAY * ppsaKey,
            /* [out] */ SAFEARRAY * *ppsaSPPA,
            /* [out] */ SAFEARRAY * *ppsaPPA);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *EncryptWithMasterKeyWrp )( 
            IXoCryptoWrapper * This,
            /* [in] */ unsigned long ulMasterKeyVersion,
            /* [in] */ unsigned long cbPublicKey,
            /* [in] */ SAFEARRAY * psaPublicKey,
            /* [in] */ unsigned long ulDataSize,
            /* [in] */ SAFEARRAY * psaDecData,
            /* [retval][out] */ SAFEARRAY * *psaEncData);
        
        END_INTERFACE
    } IXoCryptoWrapperVtbl;

    interface IXoCryptoWrapper
    {
        CONST_VTBL struct IXoCryptoWrapperVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXoCryptoWrapper_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXoCryptoWrapper_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXoCryptoWrapper_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXoCryptoWrapper_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IXoCryptoWrapper_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IXoCryptoWrapper_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IXoCryptoWrapper_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IXoCryptoWrapper_XOCryptGenRandomWrp(This,ulDataSize,ppsaData)	\
    ( (This)->lpVtbl -> XOCryptGenRandomWrp(This,ulDataSize,ppsaData) ) 

#define IXoCryptoWrapper_DecryptWithMasterKeyWrp(This,ulMasterKeyVersion,pulDataSize,psaEncData,psaDecData)	\
    ( (This)->lpVtbl -> DecryptWithMasterKeyWrp(This,ulMasterKeyVersion,pulDataSize,psaEncData,psaDecData) ) 

#define IXoCryptoWrapper_GenPPAforDBWrp(This,bstrName,ppsaKey,ppsaSPPA,ppsaPPA)	\
    ( (This)->lpVtbl -> GenPPAforDBWrp(This,bstrName,ppsaKey,ppsaSPPA,ppsaPPA) ) 

#define IXoCryptoWrapper_EncryptWithMasterKeyWrp(This,ulMasterKeyVersion,cbPublicKey,psaPublicKey,ulDataSize,psaDecData,psaEncData)	\
    ( (This)->lpVtbl -> EncryptWithMasterKeyWrp(This,ulMasterKeyVersion,cbPublicKey,psaPublicKey,ulDataSize,psaDecData,psaEncData) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXoCryptoWrapper_INTERFACE_DEFINED__ */


#ifndef __IXoKeyEncryptionHelperWrp_INTERFACE_DEFINED__
#define __IXoKeyEncryptionHelperWrp_INTERFACE_DEFINED__

/* interface IXoKeyEncryptionHelperWrp */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IXoKeyEncryptionHelperWrp;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("86BA703A-DEDA-42DC-8A27-622F39B13D9F")
    IXoKeyEncryptionHelperWrp : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Init( 
            /* [in] */ SAFEARRAY * saKEK) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Terminate( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GenerateNewKey( 
            /* [out] */ SAFEARRAY * *psaIV,
            /* [out] */ SAFEARRAY * *psaEncryptedData,
            /* [out] */ SAFEARRAY * *psaRawData) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE DecryptKey( 
            /* [in] */ SAFEARRAY * psaIV,
            /* [in] */ SAFEARRAY * psaEncryptedData,
            /* [retval][out] */ SAFEARRAY * *psaRawData) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE EncryptKey( 
            /* [in] */ SAFEARRAY * psaRawData,
            /* [out] */ SAFEARRAY * *psaIV,
            /* [out] */ SAFEARRAY * *psaEncryptedData) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXoKeyEncryptionHelperWrpVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IXoKeyEncryptionHelperWrp * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IXoKeyEncryptionHelperWrp * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IXoKeyEncryptionHelperWrp * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IXoKeyEncryptionHelperWrp * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IXoKeyEncryptionHelperWrp * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IXoKeyEncryptionHelperWrp * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IXoKeyEncryptionHelperWrp * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Init )( 
            IXoKeyEncryptionHelperWrp * This,
            /* [in] */ SAFEARRAY * saKEK);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Terminate )( 
            IXoKeyEncryptionHelperWrp * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GenerateNewKey )( 
            IXoKeyEncryptionHelperWrp * This,
            /* [out] */ SAFEARRAY * *psaIV,
            /* [out] */ SAFEARRAY * *psaEncryptedData,
            /* [out] */ SAFEARRAY * *psaRawData);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *DecryptKey )( 
            IXoKeyEncryptionHelperWrp * This,
            /* [in] */ SAFEARRAY * psaIV,
            /* [in] */ SAFEARRAY * psaEncryptedData,
            /* [retval][out] */ SAFEARRAY * *psaRawData);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *EncryptKey )( 
            IXoKeyEncryptionHelperWrp * This,
            /* [in] */ SAFEARRAY * psaRawData,
            /* [out] */ SAFEARRAY * *psaIV,
            /* [out] */ SAFEARRAY * *psaEncryptedData);
        
        END_INTERFACE
    } IXoKeyEncryptionHelperWrpVtbl;

    interface IXoKeyEncryptionHelperWrp
    {
        CONST_VTBL struct IXoKeyEncryptionHelperWrpVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXoKeyEncryptionHelperWrp_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IXoKeyEncryptionHelperWrp_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IXoKeyEncryptionHelperWrp_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IXoKeyEncryptionHelperWrp_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IXoKeyEncryptionHelperWrp_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IXoKeyEncryptionHelperWrp_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IXoKeyEncryptionHelperWrp_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IXoKeyEncryptionHelperWrp_Init(This,saKEK)	\
    ( (This)->lpVtbl -> Init(This,saKEK) ) 

#define IXoKeyEncryptionHelperWrp_Terminate(This)	\
    ( (This)->lpVtbl -> Terminate(This) ) 

#define IXoKeyEncryptionHelperWrp_GenerateNewKey(This,psaIV,psaEncryptedData,psaRawData)	\
    ( (This)->lpVtbl -> GenerateNewKey(This,psaIV,psaEncryptedData,psaRawData) ) 

#define IXoKeyEncryptionHelperWrp_DecryptKey(This,psaIV,psaEncryptedData,psaRawData)	\
    ( (This)->lpVtbl -> DecryptKey(This,psaIV,psaEncryptedData,psaRawData) ) 

#define IXoKeyEncryptionHelperWrp_EncryptKey(This,psaRawData,psaIV,psaEncryptedData)	\
    ( (This)->lpVtbl -> EncryptKey(This,psaRawData,psaIV,psaEncryptedData) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXoKeyEncryptionHelperWrp_INTERFACE_DEFINED__ */



#ifndef __HELPERWRAPPERLib_LIBRARY_DEFINED__
#define __HELPERWRAPPERLib_LIBRARY_DEFINED__

/* library HELPERWRAPPERLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_HELPERWRAPPERLib;

EXTERN_C const CLSID CLSID_XoCryptoWrapper;

#ifdef __cplusplus

class DECLSPEC_UUID("007CDE6D-353E-4F97-98E2-B351D009BD1B")
XoCryptoWrapper;
#endif

EXTERN_C const CLSID CLSID_XoKeyEncryptionHelperWrp;

#ifdef __cplusplus

class DECLSPEC_UUID("50C34C88-45C4-483F-94A5-FEB32E6E2A71")
XoKeyEncryptionHelperWrp;
#endif
#endif /* __HELPERWRAPPERLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  LPSAFEARRAY_UserSize(     unsigned long *, unsigned long            , LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserMarshal(  unsigned long *, unsigned char *, LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserUnmarshal(unsigned long *, unsigned char *, LPSAFEARRAY * ); 
void                      __RPC_USER  LPSAFEARRAY_UserFree(     unsigned long *, LPSAFEARRAY * ); 

unsigned long             __RPC_USER  BSTR_UserSize64(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal64(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal64(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree64(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  LPSAFEARRAY_UserSize64(     unsigned long *, unsigned long            , LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserMarshal64(  unsigned long *, unsigned char *, LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserUnmarshal64(unsigned long *, unsigned char *, LPSAFEARRAY * ); 
void                      __RPC_USER  LPSAFEARRAY_UserFree64(     unsigned long *, LPSAFEARRAY * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\crypto\helperwrapper\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_cryptowrapper_none_12.4.56.0_none_9c4eeb047e805db4
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_cryptowrapper_no-public-key_12.4.56.0_x-ww_82434988
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=cryptowrapper
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_cryptowrapper_no-public-key_12.4.56.0_x-ww_82434988
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_cryptowrapper_no-public-key_12.4.56.0_x-ww_82434988.manifest
XP_MANIFEST_PATH=manifests\x86_cryptowrapper_no-public-key_12.4.56.0_x-ww_82434988.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_cryptowrapper_no-public-key_12.4.56.0_x-ww_82434988.cat
XP_CATALOG_PATH=manifests\x86_cryptowrapper_no-public-key_12.4.56.0_x-ww_82434988.cat
XP_PAYLOAD_PATH=x86_cryptowrapper_no-public-key_12.4.56.0_x-ww_82434988
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=cryptowrapper,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\crypto\helperwrapper\objd\i386\helperwrapper_p.c ===
/* this ALWAYS GENERATED file contains the proxy stub code */


 /* File created by MIDL compiler version 7.00.0500 */
/* Compiler settings for helperwrapper.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, oldnames, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)


#pragma warning( disable: 4049 )  /* more than 64k source lines */
#if _MSC_VER >= 1200
#pragma warning(push)
#endif

#pragma warning( disable: 4211 )  /* redefine extern to static */
#pragma warning( disable: 4232 )  /* dllimport identity*/
#pragma warning( disable: 4024 )  /* array to pointer mapping*/
#pragma warning( disable: 4152 )  /* function/data pointer conversion in expression */
#pragma warning( disable: 4100 ) /* unreferenced arguments in x86 call */

#pragma optimize("", off ) 

#define USE_STUBLESS_PROXY


/* verify that the <rpcproxy.h> version is high enough to compile this file*/
#ifndef __REDQ_RPCPROXY_H_VERSION__
#define __REQUIRED_RPCPROXY_H_VERSION__ 475
#endif


#include "rpcproxy.h"
#ifndef __RPCPROXY_H_VERSION__
#error this stub requires an updated version of <rpcproxy.h>
#endif // __RPCPROXY_H_VERSION__


#include "helperwrapper.h"

#define TYPE_FORMAT_STRING_SIZE   1233                              
#define PROC_FORMAT_STRING_SIZE   427                               
#define EXPR_FORMAT_STRING_SIZE   1                                 
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   2            

typedef struct _helperwrapper_MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } helperwrapper_MIDL_TYPE_FORMAT_STRING;

typedef struct _helperwrapper_MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } helperwrapper_MIDL_PROC_FORMAT_STRING;

typedef struct _helperwrapper_MIDL_EXPR_FORMAT_STRING
    {
    long          Pad;
    unsigned char  Format[ EXPR_FORMAT_STRING_SIZE ];
    } helperwrapper_MIDL_EXPR_FORMAT_STRING;


static RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};


extern const helperwrapper_MIDL_TYPE_FORMAT_STRING helperwrapper__MIDL_TypeFormatString;
extern const helperwrapper_MIDL_PROC_FORMAT_STRING helperwrapper__MIDL_ProcFormatString;
extern const helperwrapper_MIDL_EXPR_FORMAT_STRING helperwrapper__MIDL_ExprFormatString;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IXoCryptoWrapper_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IXoCryptoWrapper_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IXoKeyEncryptionHelperWrp_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IXoKeyEncryptionHelperWrp_ProxyInfo;


extern const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ];

#if !defined(__RPC_WIN32__)
#error  Invalid build platform for this stub.
#endif
#if !(TARGET_IS_NT51_OR_LATER)
#error You need a Windows XP or later to run this stub because it uses these features:
#error   #error However, your C/C++ compilation flags indicate you intend to run this app on earlier systems.
#error This app will fail with the RPC_X_WRONG_STUB_VERSION error.
#endif


static const helperwrapper_MIDL_PROC_FORMAT_STRING helperwrapper__MIDL_ProcFormatString =
    {
        0,
        {

	/* Procedure XOCryptGenRandomWrp */

			0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
/*  6 */	NdrFcShort( 0x7 ),	/* 7 */
/*  8 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 10 */	NdrFcShort( 0x8 ),	/* 8 */
/* 12 */	NdrFcShort( 0x8 ),	/* 8 */
/* 14 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x3,		/* 3 */
/* 16 */	0x8,		/* 8 */
			0x43,		/* Ext Flags:  new corr desc, clt corr check, has range on conformance */
/* 18 */	NdrFcShort( 0x1d ),	/* 29 */
/* 20 */	NdrFcShort( 0x0 ),	/* 0 */
/* 22 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ulDataSize */

/* 24 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 26 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 28 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppsaData */

/* 30 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 32 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 34 */	NdrFcShort( 0x4a6 ),	/* Type Offset=1190 */

	/* Return value */

/* 36 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 38 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 40 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure DecryptWithMasterKeyWrp */

/* 42 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 44 */	NdrFcLong( 0x0 ),	/* 0 */
/* 48 */	NdrFcShort( 0x8 ),	/* 8 */
/* 50 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 52 */	NdrFcShort( 0x10 ),	/* 16 */
/* 54 */	NdrFcShort( 0x8 ),	/* 8 */
/* 56 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 58 */	0x8,		/* 8 */
			0x47,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, has range on conformance */
/* 60 */	NdrFcShort( 0x23 ),	/* 35 */
/* 62 */	NdrFcShort( 0x20 ),	/* 32 */
/* 64 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ulMasterKeyVersion */

/* 66 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 68 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 70 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pulDataSize */

/* 72 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 74 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 76 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter psaEncData */

/* 78 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 80 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 82 */	NdrFcShort( 0x4b8 ),	/* Type Offset=1208 */

	/* Parameter psaDecData */

/* 84 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 86 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 88 */	NdrFcShort( 0x4a6 ),	/* Type Offset=1190 */

	/* Return value */

/* 90 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 92 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 94 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GenPPAforDBWrp */

/* 96 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 98 */	NdrFcLong( 0x0 ),	/* 0 */
/* 102 */	NdrFcShort( 0x9 ),	/* 9 */
/* 104 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 106 */	NdrFcShort( 0x0 ),	/* 0 */
/* 108 */	NdrFcShort( 0x8 ),	/* 8 */
/* 110 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 112 */	0x8,		/* 8 */
			0x47,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, has range on conformance */
/* 114 */	NdrFcShort( 0x14f ),	/* 335 */
/* 116 */	NdrFcShort( 0x29 ),	/* 41 */
/* 118 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter bstrName */

/* 120 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 122 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 124 */	NdrFcShort( 0x4c6 ),	/* Type Offset=1222 */

	/* Parameter ppsaKey */

/* 126 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 128 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 130 */	NdrFcShort( 0x4b8 ),	/* Type Offset=1208 */

	/* Parameter ppsaSPPA */

/* 132 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 134 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 136 */	NdrFcShort( 0x4a6 ),	/* Type Offset=1190 */

	/* Parameter ppsaPPA */

/* 138 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 140 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 142 */	NdrFcShort( 0x4a6 ),	/* Type Offset=1190 */

	/* Return value */

/* 144 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 146 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 148 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure EncryptWithMasterKeyWrp */

/* 150 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 152 */	NdrFcLong( 0x0 ),	/* 0 */
/* 156 */	NdrFcShort( 0xa ),	/* 10 */
/* 158 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
/* 160 */	NdrFcShort( 0x18 ),	/* 24 */
/* 162 */	NdrFcShort( 0x8 ),	/* 8 */
/* 164 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x7,		/* 7 */
/* 166 */	0x8,		/* 8 */
			0x47,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, has range on conformance */
/* 168 */	NdrFcShort( 0x31 ),	/* 49 */
/* 170 */	NdrFcShort( 0x180 ),	/* 384 */
/* 172 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ulMasterKeyVersion */

/* 174 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 176 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 178 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter cbPublicKey */

/* 180 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 182 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 184 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter psaPublicKey */

/* 186 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 188 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 190 */	NdrFcShort( 0x4b8 ),	/* Type Offset=1208 */

	/* Parameter ulDataSize */

/* 192 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 194 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 196 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter psaDecData */

/* 198 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 200 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 202 */	NdrFcShort( 0x4b8 ),	/* Type Offset=1208 */

	/* Parameter psaEncData */

/* 204 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 206 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 208 */	NdrFcShort( 0x4a6 ),	/* Type Offset=1190 */

	/* Return value */

/* 210 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 212 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 214 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Init */

/* 216 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 218 */	NdrFcLong( 0x0 ),	/* 0 */
/* 222 */	NdrFcShort( 0x7 ),	/* 7 */
/* 224 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 226 */	NdrFcShort( 0x0 ),	/* 0 */
/* 228 */	NdrFcShort( 0x8 ),	/* 8 */
/* 230 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x2,		/* 2 */
/* 232 */	0x8,		/* 8 */
			0x45,		/* Ext Flags:  new corr desc, srv corr check, has range on conformance */
/* 234 */	NdrFcShort( 0x0 ),	/* 0 */
/* 236 */	NdrFcShort( 0x34 ),	/* 52 */
/* 238 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter saKEK */

/* 240 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 242 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 244 */	NdrFcShort( 0x4b8 ),	/* Type Offset=1208 */

	/* Return value */

/* 246 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 248 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 250 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Terminate */

/* 252 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 254 */	NdrFcLong( 0x0 ),	/* 0 */
/* 258 */	NdrFcShort( 0x8 ),	/* 8 */
/* 260 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 262 */	NdrFcShort( 0x0 ),	/* 0 */
/* 264 */	NdrFcShort( 0x8 ),	/* 8 */
/* 266 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x1,		/* 1 */
/* 268 */	0x8,		/* 8 */
			0x41,		/* Ext Flags:  new corr desc, has range on conformance */
/* 270 */	NdrFcShort( 0x0 ),	/* 0 */
/* 272 */	NdrFcShort( 0x0 ),	/* 0 */
/* 274 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Return value */

/* 276 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 278 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 280 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GenerateNewKey */

/* 282 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 284 */	NdrFcLong( 0x0 ),	/* 0 */
/* 288 */	NdrFcShort( 0x9 ),	/* 9 */
/* 290 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 292 */	NdrFcShort( 0x0 ),	/* 0 */
/* 294 */	NdrFcShort( 0x8 ),	/* 8 */
/* 296 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x4,		/* 4 */
/* 298 */	0x8,		/* 8 */
			0x43,		/* Ext Flags:  new corr desc, clt corr check, has range on conformance */
/* 300 */	NdrFcShort( 0x413 ),	/* 1043 */
/* 302 */	NdrFcShort( 0x0 ),	/* 0 */
/* 304 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter psaIV */

/* 306 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 308 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 310 */	NdrFcShort( 0x4a6 ),	/* Type Offset=1190 */

	/* Parameter psaEncryptedData */

/* 312 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 314 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 316 */	NdrFcShort( 0x4a6 ),	/* Type Offset=1190 */

	/* Parameter psaRawData */

/* 318 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 320 */	Nd