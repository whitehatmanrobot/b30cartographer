  :  STATUS_BUFFER_TOO_SMALL                                         \
    )

#define DfsRtlGetUlong(MarshalBuffer, pValue) (                         \
    ((MarshalBuffer)->Current + 4 <= (MarshalBuffer)->Last) ?           \
        *(pValue) = (ULONG) ((MarshalBuffer)->Current[0]      ) |       \
                            ((MarshalBuffer)->Current[1] <<  8) |       \
                            ((MarshalBuffer)->Current[2] << 16) |       \
                            ((MarshalBuffer)->Current[3] << 24),        \
        (MarshalBuffer)->Current += 4,                                  \
        STATUS_SUCCESS                                                  \
     :  STATUS_DATA_ERROR                                               \
    )

#define DfsRtlPutUlong(MarshalBuffer, pValue) (                         \
    ((MarshalBuffer)->Current + 4 <= (MarshalBuffer)->Last) ?           \
        (MarshalBuffer)->Current[0] = BYTE_0(*pValue),                  \
        (MarshalBuffer)->Current[1] = BYTE_1(*pValue),                  \
        (MarshalBuffer)->Current[2] = BYTE_2(*pValue),                  \
        (MarshalBuffer)->Current[3] = BYTE_3(*pValue),                  \
        (MarshalBuffer)->Current += 4,                                  \
        STATUS_SUCCESS                                                  \
     :  STATUS_BUFFER_TOO_SMALL                                         \
    )

#define DfsRtlGetGuid(MarshalBuffer, pValue) (                          \
    ((MarshalBuffer)->Current + 16 <= (MarshalBuffer)->Last) ?          \
        (pValue)->Data1 = (ULONG) ((MarshalBuffer)->Current[0]      ) | \
                                  ((MarshalBuffer)->Current[1] <<  8) | \
                                  ((MarshalBuffer)->Current[2] << 16) | \
                                  ((MarshalBuffer)->Current[3] << 24) , \
        (pValue)->Data2 = (USHORT)((MarshalBuffer)->Current[4]      ) | \
                                  ((MarshalBuffer)->Current[5] <<  8) , \
        (pValue)->Data3 = (USHORT)((MarshalBuffer)->Current[6]      ) | \
                                  ((MarshalBuffer)->Current[7] <<  8) , \
        memcpy((pValue)->Data4, &(MarshalBuffer)->Current[8], 8),       \
        (MarshalBuffer)->Current += 16,                                 \
        STATUS_SUCCESS                                                  \
     :  STATUS_DATA_ERROR                                               \
    )

#define DfsRtlPutGuid(MarshalBuffer, pValue) (                          \
    ((MarshalBuffer)->Current + 16 <= (MarshalBuffer)->Last) ?          \
        (MarshalBuffer)->Current[0] = BYTE_0((pValue)->Data1),          \
        (MarshalBuffer)->Current[1] = BYTE_1((pValue)->Data1),          \
        (MarshalBuffer)->Current[2] = BYTE_2((pValue)->Data1),          \
        (MarshalBuffer)->Current[3] = BYTE_3((pValue)->Data1),          \
        (MarshalBuffer)->Current[4] = BYTE_0((pValue)->Data2),          \
        (MarshalBuffer)->Current[5] = BYTE_1((pValue)->Data2),          \
        (MarshalBuffer)->Current[6] = BYTE_0((pValue)->Data3),          \
        (MarshalBuffer)->Current[7] = BYTE_1((pValue)->Data3),          \
        memcpy(&(MarshalBuffer)->Current[8], (pValue)->Data4, 8),       \
        (MarshalBuffer)->Current += 16,                                 \
        STATUS_SUCCESS                                                  \
     :  STATUS_BUFFER_TOO_SMALL                                         \
    )



#define DfsRtlSizeString(pString, pSize) (                              \
    ((pString)->Length > 0) ? (                                         \
        ((pString)->Buffer != NULL) ?                                   \
            (*(pSize)) += (2 + (pString)->Length),                      \
            STATUS_SUCCESS                                              \
        :   STATUS_DATA_ERROR                                           \
        )                                                               \
    :   ((*(pSize)) += 2,                                               \
        STATUS_SUCCESS)                                                 \
    )

#define DfsRtlSizepwString(pString, pSize) (                            \
        (*pString != NULL) ?                                            \
            (*(pSize)) += ((1 + wcslen(*pString))*sizeof(WCHAR)),       \
            STATUS_SUCCESS                                              \
    :   ((*(pSize)) += 2,                                               \
        STATUS_SUCCESS)                                                 \
    )

#define DfsRtlSizeUnicodeString(pUnicodeString, pSize)                  \
    DfsRtlSizeString(pUnicodeString, pSize)

#define DfsRtlUnwindStringGet(s) {                                      \
    if((s)->Length != 0 && (s)->Buffer != NULL) {                       \
        MarshalBufferFree((s)->Buffer);                                 \
        (s)->Buffer = NULL;                                             \
        (s)->Length = 0;                                                \
    }                                                                   \
}

#define DfsRtlUnwindUnicodeStringGet(s)                                 \
    DfsRtlUnwindStringGet(s)


NTSTATUS
DfsRtlGetArrayUchar(
    IN OUT PMARSHAL_BUFFER      MarshalBuffer,
    IN ULONG                    cbArray,
    OUT PUCHAR                  pArray)
{
    NTSTATUS    status = STATUS_SUCCESS;

    DfsDbgTrace(+1, Dbg, "DfsRtlGetArrayUchar: Entered\n", 0);

    ASSERT(ARGUMENT_PRESENT(MarshalBuffer));
    ASSERT(ARGUMENT_PRESENT(pArray));

    try {
        UNREFERENCED_LABEL(try_exit);
        if (MarshalBuffer->Current + cbArray <= MarshalBuffer->Last) {
            memcpy(pArray, MarshalBuffer->Current, cbArray);
            MarshalBuffer->Current += cbArray;
        } else {
            status = STATUS_DATA_ERROR;
        }
    try_exit: NOTHING;
    } finally {
        if (AbnormalTermination()) {
            DfsDbgTrace(0, Dbg,
                "DfsRtlGetArrayUchar - Abnormal termination!\n", 0);
            status = STATUS_DATA_ERROR;
        }

    }

    DfsDbgTrace(-1, Dbg, "DfsRtlGetArrayUchar: Exited %08lx\n", ULongToPtr(status));
    return(status);
}

NTSTATUS
DfsRtlPutArrayUchar(
    IN OUT PMARSHAL_BUFFER      MarshalBuffer,
    IN ULONG                    cbArray,
    OUT PUCHAR                  pArray)
{
    NTSTATUS    status = STATUS_SUCCESS;

    DfsDbgTrace(+1, Dbg, "DfsRtlGetArrayUchar: Entered\n", 0);

    ASSERT(ARGUMENT_PRESENT(MarshalBuffer));
    ASSERT(ARGUMENT_PRESENT(pArray));

    try {
        UNREFERENCED_LABEL(try_exit);
        if (MarshalBuffer->Current + cbArray <= MarshalBuffer->Last) {
            if (cbArray) {
                memcpy(MarshalBuffer->Current, pArray, cbArray);
                MarshalBuffer->Current += cbArray;
            }
        } else {
            status = STATUS_BUFFER_TOO_SMALL;
        }
    try_exit: NOTHING;
    } finally {
        if (AbnormalTermination()) {
            DfsDbgTrace(0, Dbg,
                "DfsRtlPutArrayUchar - Abnormal termination!\n", 0);
            status = STATUS_DATA_ERROR;
        }

    }

    DfsDbgTrace(-1, Dbg, "DfsRtlPutArrayUchar: Exited %08lx\n", ULongToPtr(status));
    return(status);
}


NTSTATUS
DfsRtlGetpwString(
    IN OUT PMARSHAL_BUFFER      MarshalBuffer,
    OUT    PWSTR                *ppwszString
)
{
    USHORT size;
    PCHAR cp = NULL;
    NTSTATUS status = STATUS_SUCCESS;

    DfsDbgTrace(+1, Dbg, "DfsRtlGetpwString:  Entered\n", 0);

    ASSERT(ARGUMENT_PRESENT(MarshalBuffer));
    ASSERT(ARGUMENT_PRESENT(ppwszString));

    try {
        UNREFERENCED_LABEL(try_exit);
        *ppwszString = NULL;
        if(NT_SUCCESS(status = DfsRtlGetUshort(MarshalBuffer, &size))) {
            if(size > 0) {
                if(
                    MarshalBuffer->Current + size <= MarshalBuffer->Last &&
                    ((ULONG)size + sizeof(WCHAR)) <= MAXUSHORT &&
                    (size & 0x1) == 0
                ) {
                    if((cp = MarshalBufferAllocate(size+sizeof(WCHAR))) != NULL) {
                        memcpy(cp, MarshalBuffer->Current, size);
                        *((WCHAR *) (cp + size)) = UNICODE_NULL;
                        *ppwszString = (PWCHAR) cp;
                        MarshalBuffer->Current += size;
                    } else
                        status = STATUS_INSUFFICIENT_RESOURCES;
                } else
                    status = STATUS_DATA_ERROR;
            }
        }
    try_exit: NOTHING;
    } finally {
        if(AbnormalTermination()) {
            DfsDbgTrace(0, Dbg,
                "DfsRtlGetpwString:  Abnormal Termination!\n", 0);
            status = STATUS_DATA_ERROR;
        }

        if(!NT_SUCCESS(status) && cp)
                MarshalBufferFree(cp);
    }
    DfsDbgTrace(-1, Dbg, "DfsRtlGetpwString:  Exit -> %08lx\n", ULongToPtr(status));
    return status;
}


NTSTATUS
DfsRtlPutpwString(
    IN OUT  PMARSHAL_BUFFER MarshalBuffer,
    OUT     PWSTR       *ppwszString
)
{
    USHORT size;
    NTSTATUS status = STATUS_SUCCESS;

    DfsDbgTrace(+1, Dbg, "DfsRtlPutpwString:  Entered\n", 0);

    ASSERT(ARGUMENT_PRESENT(MarshalBuffer));
    ASSERT(ARGUMENT_PRESENT(ppwszString));


    try {
        UNREFERENCED_LABEL(try_exit);
        if (*ppwszString != NULL)
            size = wcslen(*ppwszString)*sizeof(WCHAR);
        else
            size = 0;
        if(NT_SUCCESS(status = DfsRtlPutUshort(MarshalBuffer, &size))) {
            if(size > 0) {
                if(MarshalBuffer->Current + size <= MarshalBuffer->Last) {
                    memcpy(MarshalBuffer->Current, *ppwszString, size);
                    MarshalBuffer->Current += size;
                } else
                    status = STATUS_BUFFER_TOO_SMALL;
            }
        }
    try_exit: NOTHING;
    } finally {
        if(AbnormalTermination()) {
            DfsDbgTrace(0, Dbg,
                "DfsRtlPutString:  Abnormal Termination!\n", 0);
            status = STATUS_DATA_ERROR;
        }
    }
    DfsDbgTrace(-1, Dbg, "DfsRtlPutString:  Exit -> %08lx\n", ULongToPtr(status));
    return status;
}



NTSTATUS
DfsRtlGetString(
    IN OUT  PMARSHAL_BUFFER MarshalBuffer,
    OUT     PSTRING String
)
{
    USHORT size;
    PCHAR cp = NULL;
    NTSTATUS status = STATUS_SUCCESS;

    DfsDbgTrace(+1, Dbg, "DfsRtlGetString:  Entered\n", 0);

    ASSERT(ARGUMENT_PRESENT(MarshalBuffer));
    ASSERT(ARGUMENT_PRESENT(String));

    try {
        UNREFERENCED_LABEL(try_exit);
        String->Length = String->MaximumLength = 0;
        String->Buffer = NULL;
        if(NT_SUCCESS(status = DfsRtlGetUshort(MarshalBuffer, &size))) {
            if(size > 0) {
                if(MarshalBuffer->Current + size <= MarshalBuffer->Last &&
                    ((ULONG)size + sizeof(WCHAR)) <= MAXUSHORT &&
                    (size & 0x1) == 0
                ) {
                    if((cp = MarshalBufferAllocate(size+sizeof(WCHAR))) != NULL) {
                        RtlZeroMemory(cp, size+sizeof(WCHAR));
                        memcpy(cp, MarshalBuffer->Current, size);
                        String->Length = size;
                        String->MaximumLength = size + sizeof(WCHAR);
                        String->Buffer = cp;
                        MarshalBuffer->Current += size;
                    } else
                        status = STATUS_INSUFFICIENT_RESOURCES;
                } else
                    status = STATUS_DATA_ERROR;
            }
        }
    try_exit: NOTHING;
    } finally {
        if(AbnormalTermination()) {
            DfsDbgTrace(0, Dbg,
                "DfsRtlGetString:  Abnormal Termination!\n", 0);
            status = STATUS_DATA_ERROR;
        }

        if(!NT_SUCCESS(status) && cp)
                MarshalBufferFree(cp);
    }
    DfsDbgTrace(-1, Dbg, "DfsRtlGetString:  Exit -> %08lx\n", ULongToPtr(status));
    return status;
}



NTSTATUS
DfsRtlPutString(
    IN OUT  PMARSHAL_BUFFER MarshalBuffer,
    OUT     PSTRING String
)
{
    USHORT size;
    NTSTATUS status = STATUS_SUCCESS;

    DfsDbgTrace(+1, Dbg, "DfsRtlPutString:  Entered\n", 0);

    ASSERT(ARGUMENT_PRESENT(MarshalBuffer));
    ASSERT(ARGUMENT_PRESENT(String));


    try {
        UNREFERENCED_LABEL(try_exit);
        size = String->Length;
        if(NT_SUCCESS(status = DfsRtlPutUshort(MarshalBuffer, &size))) {
            if(size > 0) {
                if(MarshalBuffer->Current + size <= MarshalBuffer->Last) {
                    if(String->Buffer != NULL) {
                        memcpy(MarshalBuffer->Current, String->Buffer, size);
                        MarshalBuffer->Current += size;
                    } else
                        status = STATUS_DATA_ERROR;
                } else
                    status = STATUS_BUFFER_TOO_SMALL;
            }
        }
    try_exit: NOTHING;
    } finally {
        if(AbnormalTermination()) {
            DfsDbgTrace(0, Dbg,
                "DfsRtlPutString:  Abnormal Termination!\n", 0);
            status = STATUS_DATA_ERROR;
        }
    }
    DfsDbgTrace(-1, Dbg, "DfsRtlPutString:  Exit -> %08lx\n", ULongToPtr(status));
    return status;
}



#ifdef  NOT_NEEDED

NTSTATUS
DfsRtlGetUnicodeString(
    IN OUT  PMARSHAL_BUFFER MarshalBuffer,
    OUT     PUNICODE_STRING UnicodeString
)
{
    USHORT size;
    PWCHAR wcp = NULL;
    NTSTATUS status = STATUS_SUCCESS;

    DfsDbgTrace(+1, Dbg, "DfsRtlGetUnicodeString:  Entered\n", 0);

    ASSERT(ARGUMENT_PRESENT(MarshalBuffer));
    ASSERT(ARGUMENT_PRESENT(UnicodeString));

    try {
        UnicodeString->Length = UnicodeString->MaximumLength = 0;
        UnicodeString->Buffer = NULL;
        if(NT_SUCCESS(status = DfsRtlGetUshort(MarshalBuffer, &size))) {
            if(size > 0) {
                if(
                    MarshalBuffer->Current + size <= MarshalBuffer->Last &&
                    ((ULONG)size + sizeof(WCHAR)) <= MAXUSHORT &&
                    (size & 0x1) == 0
                ) {
                    if((wcp = (MarshalBufferAllocate)(size+sizeof(WCHAR))) != NULL) {
                        memcpy(wcp, MarshalBuffer->Current, size);
                        wcp[size/sizeof(WCHAR)] = UNICODE_NULL;
                        UnicodeString->Length = size;
                        UnicodeString->MaximumLength = size + sizeof(WCHAR);
                        UnicodeString->Buffer = wcp;
                        MarshalBuffer->Current += size;
                    } else
                        status = STATUS_INSUFFICIENT_RESOURCES;
                } else
                    status = STATUS_DATA_ERROR;
            }
        }
    try_exit: NOTHING;
    } finally {
        if(AbnormalTermination()) {
            DfsDbgTrace(0, Dbg,
                "DfsRtlGetUnicodeString:  Abnormal Termination!\n", 0);
            status = STATUS_DATA_ERROR;
        }

        if(!NT_SUCCESS(status) && wcp)
                MarshalBufferFree(wcp);
    }
    DfsDbgTrace(-1, Dbg, "DfsRtlGetUnicodeString:  Exit -> %08lx\n",
                status);
    return status;
}



NTSTATUS
DfsRtlPutUnicodeString(
    IN OUT  PMARSHAL_BUFFER MarshalBuffer,
    OUT     PUNICODE_STRING UnicodeString
)
{
    USHORT size;
    NTSTATUS status = STATUS_SUCCESS;

    DfsDbgTrace(+1, Dbg, "DfsRtlPutUnicodeString:  Entered\n", 0);

    ASSERT(ARGUMENT_PRESENT(MarshalBuffer));
    ASSERT(ARGUMENT_PRESENT(UnicodeString));

    try {
        size = UnicodeString->Length;
        if(NT_SUCCESS(status = DfsRtlPutUshort(MarshalBuffer, &size))) {
            if(size > 0) {
                if(MarshalBuffer->Current + size <= MarshalBuffer->Last) {
                    if(UnicodeString->Buffer != NULL) {
                        memcpy(
                            MarshalBuffer->Current,
                            UnicodeString->Buffer,
                            size
                        );
                        MarshalBuffer->Current += size;
                    } else
                        status = STATUS_DATA_ERROR;
                } else
                    status = STATUS_BUFFER_TOO_SMALL;
            }
        }
    try_exit: NOTHING;
    } finally {
        if(AbnormalTermination()) {
            DfsDbgTrace(0, Dbg,
                "DfsRtlPutUnicodeString:  Abnormal Termination!\n", 0);
            status = STATUS_DATA_ERROR;
        }
    }
    DfsDbgTrace(-1, Dbg, "DfsRtlPutUnicodeString:  Exit -> %08lx\n",
                status);
    return status;
}

#else   // NOT_NEEDED

#define DfsRtlGetUnicodeString(b, s)\
    DfsRtlGetString(b, (PSTRING)(s))

#define DfsRtlPutUnicodeString(b, s)\
    DfsRtlPutString(b, (PSTRING)(s))

#endif  // NOT_NEEDED





NTSTATUS
DfsRtlGet(
    IN OUT  PMARSHAL_BUFFER MarshalBuffer,
    IN  PMARSHAL_INFO MarshalInfo,
    OUT PVOID Item
)
{
    PMARSHAL_TYPE_INFO typeInfo;
    PVOID subItem;
    PVOID subItemElem;
    ULONG cnt;
    ULONG unwindcnt;
    PUCHAR cntptr;
    ULONG itemSize;
    PMARSHAL_INFO subInfo;
    NTSTATUS status = STATUS_SUCCESS;

    DfsDbgTrace(+1, Dbg, "DfsRtlGet:  Entered\n", 0);

    ASSERT(ARGUMENT_PRESENT(MarshalBuffer));
    ASSERT(ARGUMENT_PRESENT(MarshalInfo));
    ASSERT(ARGUMENT_PRESENT(Item));

    try {

        RtlZeroMemory(Item, MarshalInfo->_size);

        for(typeInfo = &MarshalInfo->_typeInfo[0];
            typeInfo < &MarshalInfo->_typeInfo[MarshalInfo->_typecnt];
            typeInfo++) {

            switch(typeInfo->_type & MTYPE_BASE_TYPE) {
            case MTYPE_COMPOUND:
                subInfo = typeInfo->_subinfo;
                itemSize = subInfo->_size;
                //
                // If this compound type is a conformant structure, then
                // we need to adjust the size field here.
                //
                if (subInfo->_typecnt > 0 &&
                      subInfo->_typeInfo[0]._type == MTYPE_CONFORMANT_CNT) {
                   MARSHAL_BUFFER tempMarshalBuffer = *MarshalBuffer;
                   ULONG extraSize = 0;

                   status = DfsRtlGetUlong(&tempMarshalBuffer, &extraSize);
                   if (!NT_SUCCESS(status) || (itemSize + extraSize) < itemSize) {
                      try_return(status = STATUS_DATA_ERROR);
                   }
                   itemSize += extraSize;
                }
                break;
            case MTYPE_CONFORMANT_CNT:
                itemSize = 0;
                break;
            case MTYPE_GUID:
                itemSize = sizeof(GUID);
                break;
            case MTYPE_STRING:
                itemSize = sizeof(STRING);
                break;
            case MTYPE_UNICODE_STRING:
                itemSize = sizeof(UNICODE_STRING);
                break;
            case MTYPE_PWSTR:
                itemSize = sizeof(PWSTR);
                break;
            case MTYPE_ULONG:
                itemSize = sizeof(ULONG);
                break;
            case MTYPE_USHORT:
                itemSize = sizeof(USHORT);
                break;
            case MTYPE_UCHAR:
                itemSize = sizeof(UCHAR);
                break;
            default:
                try_return(status = STATUS_DATA_ERROR);
            }

            if(typeInfo->_type & MTYPE_COUNTED_ARRAY) {
                cntptr = ((PUCHAR)Item + typeInfo->_cntoff);
                switch(typeInfo->_cntsize) {
                case sizeof(UCHAR):
                    cnt = *(PUCHAR)cntptr;
                    break;
                case sizeof(USHORT):
                    cnt = *(PUSHORT)cntptr;
                    break;
                case sizeof(ULONG):
                    cnt = *(PULONG)cntptr;
                    break;
                default:
                    try_return(status = STATUS_DATA_ERROR);
                }
            } else if (typeInfo->_type & MTYPE_STATIC_ARRAY) {
                cnt = typeInfo->_cntoff;
            } else {
                cnt = 1;
            }

            if(typeInfo->_type & MTYPE_INDIRECT) {
                if((typeInfo->_type & MTYPE_COUNTED_ARRAY) && cnt == 0)
                    subItem = NULL;
                else {
                    subItem = NULL;
                    if ((cnt != 0) && ((itemSize * cnt) / cnt) == itemSize)
                        subItem = MarshalBufferAllocate(itemSize * cnt);
                    if(subItem == NULL)
                        try_return(status = STATUS_INSUFFICIENT_RESOURCES);
                }
                *(PVOID *)((PUCHAR)Item + typeInfo->_off) = subItem;
            }
            else
                subItem = ((PUCHAR)Item + typeInfo->_off);

            switch(typeInfo->_type & ~MTYPE_INDIRECT) {

            case MTYPE_COMPOUND:
                    status = DfsRtlGet(
                        MarshalBuffer,
                        subInfo,
                        subItem
                    );
                    break;
            case MTYPE_CONFORMANT_CNT:
                    //
                    // this field is used only when sizing a conformant
                    // structure. As such, there is no place to unmarshal
                    // it into. So, simply eat the ulong.
                    //
                    status = DfsRtlGetUlong(MarshalBuffer, &itemSize);
                    break;
            case (MTYPE_COMPOUND|MTYPE_COUNTED_ARRAY):
            case (MTYPE_COMPOUND|MTYPE_STATIC_ARRAY):
                    subItemElem = (PUCHAR)subItem;
                    unwindcnt = cnt;
                    while(cnt--) {
                        status = DfsRtlGet(
                            MarshalBuffer,
                            subInfo,
                            subItemElem
                        );
                        if(!NT_SUCCESS(status)) {
                            while((++cnt) < unwindcnt) {
                                ((PUCHAR)subItemElem) -= itemSize;
                                DfsRtlUnwindGet(
                                    subInfo,
                                    &subInfo->_typeInfo[subInfo->_typecnt],
                                    subItemElem
                                );
                            }
                            if(typeInfo->_type & MTYPE_INDIRECT)
                                MarshalBufferFree(subItem);
                            break;
                        }
                        ((PUCHAR)subItemElem) += itemSize;
                    }
                    break;
            case MTYPE_GUID:
                    status = DfsRtlGetGuid(
                        MarshalBuffer,
                        (GUID *)subItem
                    );
                    break;
            case MTYPE_STRING:
                    status = DfsRtlGetString(
                        MarshalBuffer,
                        (PSTRING)subItem
                    );
                    break;
            case MTYPE_UNICODE_STRING:
                    status = DfsRtlGetUnicodeString(
                        MarshalBuffer,
                        (PUNICODE_STRING)subItem
                    );
                    break;

            case MTYPE_PWSTR:
                    status = DfsRtlGetpwString(
                        MarshalBuffer,
                        (PWSTR *)subItem
                    );
                    break;

            case (MTYPE_PWSTR|MTYPE_COUNTED_ARRAY):
            case (MTYPE_PWSTR|MTYPE_STATIC_ARRAY):
                    subItemElem = (PUCHAR)subItem;
                    unwindcnt = cnt;
                    while (cnt--) {
                        status = DfsRtlGetpwString(
                            MarshalBuffer,
                            (PWSTR *)subItemElem);
                        if (!NT_SUCCESS(status)) {
                            while ((++cnt) < unwindcnt) {
                                ((PUCHAR)subItemElem) -= itemSize;
                                MarshalBufferFree((PVOID)*(PWSTR *)subItemElem);
                            }
                            if (typeInfo->_type & MTYPE_INDIRECT) {
                                MarshalBufferFree(subItem);
                            }
                            break;
                        }
                        ((PUCHAR)subItemElem) += itemSize;
                    }
                    break;
            case (MTYPE_UNICODE_STRING|MTYPE_COUNTED_ARRAY):
            case (MTYPE_UNICODE_STRING|MTYPE_STATIC_ARRAY):
                    subItemElem = (PUCHAR)subItem;
                    unwindcnt = cnt;
                    while(cnt--) {
                        status = DfsRtlGetUnicodeString(
                            MarshalBuffer,
                            (PUNICODE_STRING)subItemElem
                        );
                        if(!NT_SUCCESS(status)) {
                            while((++cnt) < unwindcnt) {
                                ((PUCHAR)subItemElem) -= itemSize;
                                DfsRtlUnwindUnicodeStringGet(
                                    (PUNICODE_STRING)subItemElem
                                );
                            }
                            if(typeInfo->_type & MTYPE_INDIRECT)
                                MarshalBufferFree(subItem);
                            break;
                        }
                        ((PUCHAR)subItemElem) += itemSize;
                    }
                    break;
            case MTYPE_ULONG:
                    status = DfsRtlGetUlong(
                        MarshalBuffer,
                        (PULONG)subItem
                    );
                    break;
            case MTYPE_USHORT:
                    status = DfsRtlGetUshort(
                        MarshalBuffer,
                        (PUSHORT)subItem);
                    break;
            case MTYPE_UCHAR:
                    status = DfsRtlGetUchar(
                        MarshalBuffer,
                        (PUCHAR)subItem);
                    break;
            case MTYPE_UCHAR|MTYPE_COUNTED_ARRAY:
            case MTYPE_UCHAR|MTYPE_STATIC_ARRAY:
                    status = DfsRtlGetArrayUchar(
                        MarshalBuffer,
                        cnt,
                        (PUCHAR)subItem);
                    break;
            default:
                    status = STATUS_DATA_ERROR;
                    break;
            };
            if(!NT_SUCCESS(status))
                break;
        }

    try_exit: NOTHING;
    } finally {
        if(AbnormalTermination()) {
            DfsDbgTrace(0, Dbg, "DfsRtlGet:  Abnormal Termination!\n", 0);
            status = STATUS_DATA_ERROR;
        }

        if(!NT_SUCCESS(status))
            DfsRtlUnwindGet(MarshalInfo, typeInfo, Item);
    }

    DfsDbgTrace(-1, Dbg, "DfsRtlGet:  Exit -> %08lx\n", ULongToPtr(status));
    return status;
}



NTSTATUS
DfsRtlPut(
    IN OUT  PMARSHAL_BUFFER MarshalBuffer,
    IN  PMARSHAL_INFO MarshalInfo,
    OUT PVOID Item
)
{
    PMARSHAL_TYPE_INFO typeInfo;
    PVOID subItem;
    PVOID subItemElem;
    ULONG cnt;
    PUCHAR cntptr;
    ULONG itemSize;
    PMARSHAL_INFO subInfo;
    NTSTATUS status = STATUS_SUCCESS;

    DfsDbgTrace(+1, Dbg, "DfsRtlPut:  Entered\n", 0);

    ASSERT(ARGUMENT_PRESENT(MarshalBuffer));
    ASSERT(ARGUMENT_PRESENT(MarshalInfo));
    ASSERT(ARGUMENT_PRESENT(Item));

    try {
        for(typeInfo = &MarshalInfo->_typeInfo[0];
            typeInfo < &MarshalInfo->_typeInfo[MarshalInfo->_typecnt];
            typeInfo++) {

            switch(typeInfo->_type & MTYPE_BASE_TYPE) {
            case MTYPE_COMPOUND:
                subInfo = typeInfo->_subinfo;
                itemSize = subInfo->_size;
                break;
            case MTYPE_CONFORMANT_CNT:
                itemSize = typeInfo->_off;
                break;
            case MTYPE_GUID:
                itemSize = sizeof(GUID);
                break;
            case MTYPE_STRING:
                itemSize = sizeof(STRING);
                break;
            case MTYPE_UNICODE_STRING:
                itemSize = sizeof(UNICODE_STRING);
                break;
            case MTYPE_PWSTR:
                itemSize = sizeof(PWSTR);
                break;
            case MTYPE_ULONG:
                itemSize = sizeof(ULONG);
                break;
            case MTYPE_USHORT:
                itemSize = sizeof(USHORT);
                break;
            case MTYPE_UCHAR:
                itemSize = sizeof(UCHAR);
                break;
            default:
                try_return(status = STATUS_DATA_ERROR);
            }

            if(typeInfo->_type & MTYPE_COUNTED_ARRAY ||
               typeInfo->_type == MTYPE_CONFORMANT_CNT) {
                cntptr = ((PUCHAR)Item + typeInfo->_cntoff);
                switch(typeInfo->_cntsize) {
                case sizeof(UCHAR):
                    cnt = *(PUCHAR)cntptr;
                    break;
                case sizeof(USHORT):
                    cnt = *(PUSHORT)cntptr;
                    break;
                case sizeof(ULONG):
                    cnt = *(PULONG)cntptr;
                    break;
                default:
                    try_return(status = STATUS_DATA_ERROR);
                }
            } else
                cnt = typeInfo->_cntoff;

            if(typeInfo->_type & MTYPE_INDIRECT) {
                subItem = *(PUCHAR *)((PUCHAR)Item + typeInfo->_off);
                if(subItem == NULL &&
                   !((typeInfo->_type & MTYPE_COUNTED_ARRAY) && cnt == 0))
                    try_return(status = STATUS_DATA_ERROR);
            } else
                subItem = ((PUCHAR)Item + typeInfo->_off);

            switch(typeInfo->_type & ~MTYPE_INDIRECT) {

            case MTYPE_COMPOUND:
                    status = DfsRtlPut(
                        MarshalBuffer,
                        subInfo,
                        subItem
                    );
                    break;
            case MTYPE_CONFORMANT_CNT:
                    cnt *= itemSize;
                    status = DfsRtlPutUlong(
                                MarshalBuffer,
                                &cnt);
                    break;
            case (MTYPE_COMPOUND|MTYPE_COUNTED_ARRAY):
            case (MTYPE_COMPOUND|MTYPE_STATIC_ARRAY):
                    //
                    // No sense in having an array of conformant structures
                    // ASSERT this fact
                    //

                    ASSERT(subInfo->_typecnt == 0
                                    ||
                           subInfo->_typeInfo[0]._type != MTYPE_CONFORMANT_CNT
                          );

                    subItemElem = (PUCHAR)subItem;
                    while(cnt--) {
                        status = DfsRtlPut(
                            MarshalBuffer,
                            subInfo,
                            subItemElem
                        );
                        if(!NT_SUCCESS(status))
                            break;
                        ((PUCHAR)subItemElem) += itemSize;
                    }
                    break;
            case MTYPE_GUID:
                    status = DfsRtlPutGuid(
                        MarshalBuffer,
                        (GUID *)subItem
                    );
                    break;
            case MTYPE_STRING:
                    status = DfsRtlPutString(
                        MarshalBuffer,
                        (PSTRING)subItem
                    );
                    break;
            case MTYPE_UNICODE_STRING:
                    status = DfsRtlPutUnicodeString(
                        MarshalBuffer,
                        (PUNICODE_STRING)subItem
                    );
                    break;
            case MTYPE_PWSTR:
                    status = DfsRtlPutpwString(
                        MarshalBuffer,
                        (PWSTR *)subItem
                    );
                    break;

            case (MTYPE_PWSTR|MTYPE_COUNTED_ARRAY):
            case (MTYPE_PWSTR|MTYPE_STATIC_ARRAY):
                    subItemElem = (PWSTR *)subItem;
                    while(cnt--) {
                        status = DfsRtlPutpwString(
                            MarshalBuffer,
                            (PWSTR *)subItemElem);
                        if (!NT_SUCCESS(status))
                            break;
                        ((PUCHAR)subItemElem) += itemSize;
                    }
                    break;
            case (MTYPE_UNICODE_STRING|MTYPE_COUNTED_ARRAY):
            case (MTYPE_UNICODE_STRING|MTYPE_STATIC_ARRAY):
                    subItemElem = (PUCHAR)subItem;
                    while(cnt--) {
                        status = DfsRtlPutUnicodeString(
                            MarshalBuffer,
                            (PUNICODE_STRING)subItemElem
                        );
                        if(!NT_SUCCESS(status))
                            break;
                        ((PUCHAR)subItemElem) += itemSize;
                    }
                    break;
            case MTYPE_ULONG:
                    status = DfsRtlPutUlong(
                        MarshalBuffer,
                        (PULONG)subItem
                    );
                    break;
            case MTYPE_USHORT:
                    status = DfsRtlPutUshort(
                        MarshalBuffer,
                        (PUSHORT)subItem);
                    break;
            case MTYPE_UCHAR:
                    status = DfsRtlPutUchar(
                        MarshalBuffer,
                        (PUCHAR)subItem);
                    break;
            case (MTYPE_UCHAR|MTYPE_COUNTED_ARRAY):
            case (MTYPE_UCHAR|MTYPE_STATIC_ARRAY):
                    status = DfsRtlPutArrayUchar(
                        MarshalBuffer,
                        cnt,
                        (PUCHAR)subItem);
                    break;
            default:
                    status = STATUS_DATA_ERROR;
                break;
            }

            if(!NT_SUCCESS(status))
                break;
        }

    try_exit: NOTHING;
    } finally {
        if(AbnormalTermination()) {
            DfsDbgTrace(0, Dbg, "DfsRtlPut:  Abnormal Termination!\n", 0);
            status = STATUS_DATA_ERROR;
        }
    }

    DfsDbgTrace(-1, Dbg, "DfsRtlPut:  Exit -> %08lx\n", ULongToPtr(status));
    return status;
}




NTSTATUS
DfsRtlSize(
    IN  PMARSHAL_INFO MarshalInfo,
    IN  PVOID Item,
    OUT PULONG Size
)
{
    PMARSHAL_TYPE_INFO typeInfo;
    PVOID subItem;
    PVOID subItemElem;
    ULONG cnt;
    PUCHAR cntptr;
    ULONG itemSize;
    PMARSHAL_INFO subInfo;
    NTSTATUS status = STATUS_SUCCESS;

    DfsDbgTrace(+1, Dbg, "DfsRtlSize:  Entered\n", 0);

    ASSERT(ARGUMENT_PRESENT(MarshalInfo));
    ASSERT(ARGUMENT_PRESENT(Item));
    ASSERT(ARGUMENT_PRESENT(Size));

    try {
        for(typeInfo = &MarshalInfo->_typeInfo[0];
            typeInfo < &MarshalInfo->_typeInfo[MarshalInfo->_typecnt];
            typeInfo++) {

            switch(typeInfo->_type & MTYPE_BASE_TYPE) {
            case MTYPE_COMPOUND:
                subInfo = typeInfo->_subinfo;
                itemSize = subInfo->_size;
                break;
            case MTYPE_CONFORMANT_CNT:
                //
                // For conformant structures, _offset is sizeof each
                // element, _cntsize is sizeof cnt field, and _cntoff is
                // offset of cnt field.
                //
                itemSize = typeInfo->_off;
                break;
            case MTYPE_GUID:
                itemSize = sizeof(GUID);
                break;
            case MTYPE_STRING:
                itemSize = sizeof(STRING);
                break;
            case MTYPE_UNICODE_STRING:
                itemSize = sizeof(UNICODE_STRING);
                break;
            case MTYPE_PWSTR:
                itemSize = sizeof(PWCHAR);
                break;
            case MTYPE_ULONG:
                itemSize = sizeof(ULONG);
                break;
            case MTYPE_USHORT:
                itemSize = sizeof(USHORT);
                break;
            case MTYPE_UCHAR:
                itemSize = sizeof(UCHAR);
                break;
            default:
                try_return(status = STATUS_DATA_ERROR);
            }

            if(typeInfo->_type & MTYPE_COUNTED_ARRAY ||
               typeInfo->_type == MTYPE_CONFORMANT_CNT) {
                cntptr = ((PUCHAR)Item + typeInfo->_cntoff);
                switch(typeInfo->_cntsize) {
                case sizeof(UCHAR):
                    cnt = *(PUCHAR)cntptr;
                    break;
                case sizeof(USHORT):
                    cnt = *(PUSHORT)cntptr;
                    break;
                case sizeof(ULONG):
                    cnt = *(PULONG)cntptr;
                    break;
                default:
                    try_return(status = STATUS_DATA_ERROR);
                }
            } else
                cnt = typeInfo->_cntoff;

            if(typeInfo->_type & MTYPE_INDIRECT) {
                subItem = *(PUCHAR *)((PUCHAR)Item + typeInfo->_off);
                if(subItem == NULL &&
                   !((typeInfo->_type & MTYPE_COUNTED_ARRAY) && cnt == 0))
                    try_return(status = STATUS_DATA_ERROR);
            } else
                subItem = ((PUCHAR)Item + typeInfo->_off);

            switch(typeInfo->_type & ~MTYPE_INDIRECT) {

            case MTYPE_COMPOUND:
                    status = DfsRtlSize(
                        subInfo,
                        subItem,
                        Size
                    );
                    break;
            case MTYPE_CONFORMANT_CNT:
                    (*Size) += sizeof(ULONG);
                    break;
            case (MTYPE_COMPOUND|MTYPE_COUNTED_ARRAY):
            case (MTYPE_COMPOUND|MTYPE_STATIC_ARRAY):
                    //
                    // No sense in having an array of conformant structures
                    // ASSERT this fact
                    //

                    ASSERT(subInfo->_typecnt == 0
                                    ||
                           subInfo->_typeInfo[0]._type != MTYPE_CONFORMANT_CNT
                          );

                    subItemElem = (PUCHAR)subItem;
                    while(cnt--) {
                        status = DfsRtlSize(
                            subInfo,
                            subItemElem,
                            Size
                        );
                        if(!NT_SUCCESS(status))
                            break;
                        ((PUCHAR)subItemElem) += itemSize;
                    }
                    break;
            case MTYPE_GUID:
                    (*Size) += 16;
                    break;
            case MTYPE_STRING:
                    status = DfsRtlSizeString(
                        (PSTRING)subItem,
                        Size
                    );
                    break;
            case MTYPE_UNICODE_STRING:
                    status = DfsRtlSizeUnicodeString(
                        (PUNICODE_STRING)subItem,
                        Size
                    );
                    break;

            case MTYPE_PWSTR:
                    status = DfsRtlSizepwString(
                        (PWSTR *)subItem,
                        Size
                    );
                    break;
            case (MTYPE_PWSTR|MTYPE_COUNTED_ARRAY):
            case (MTYPE_PWSTR|MTYPE_STATIC_ARRAY):
                    subItemElem = (PUCHAR)subItem;
                    while (cnt--) {
                        status = DfsRtlSizepwString(
                            (PWSTR *)subItemElem,
                            Size);
                        if (!NT_SUCCESS(status)) {
                            break;
                        }
                        ((PUCHAR)subItemElem) += itemSize;
                    }
                    break;
            case (MTYPE_UNICODE_STRING|MTYPE_COUNTED_ARRAY):
            case (MTYPE_UNICODE_STRING|MTYPE_STATIC_ARRAY):
                    subItemElem = (PUCHAR)subItem;
                    while(cnt--) {
                        status = DfsRtlSizeUnicodeString(
                            (PUNICODE_STRING)subItemElem,
                            Size
                        );
                        if(!NT_SUCCESS(status))
                            break;
                        ((PUCHAR)subItemElem) += itemSize;
                    }
                    break;
            case MTYPE_ULONG:
                    (*Size) += 4;
                    break;
            case MTYPE_USHORT:
                    (*Size) += 2;
                    break;
            case MTYPE_UCHAR:
                    (*Size) += 1;
                    break;
            case MTYPE_UCHAR|MTYPE_COUNTED_ARRAY:
            case MTYPE_UCHAR|MTYPE_STATIC_ARRAY:
                    (*Size) += (cnt * sizeof(UCHAR));
                    break;
            default:
                    status = STATUS_DATA_ERROR;
                    break;
            };
            if(!NT_SUCCESS(status))
                break;
        }

    try_exit: NOTHING;
    } finally {
        if(AbnormalTermination()) {
            DfsDbgTrace(0, Dbg, "DfsRtlSize:  Abnormal Termination!\n", 0);
            status = STATUS_DATA_ERROR;
        }
    }

    DfsDbgTrace(0, Dbg, "DfsRtlSize:  (*Size) = %ld\n", ULongToPtr(*Size));
    DfsDbgTrace(-1, Dbg, "DfsRtlSize:  Exit -> %08lx\n", ULongToPtr(status));
    return status;
}




VOID
DfsRtlUnwindGet(
    IN  PMARSHAL_INFO MarshalInfo,
    IN  PMARSHAL_TYPE_INFO LastTypeInfo,
    IN  PVOID Item
)
{
    PMARSHAL_TYPE_INFO typeInfo;
    PVOID subItem;
    PVOID subItemElem;
    ULONG cnt;
    PUCHAR cntptr;
    ULONG itemSize;
    PMARSHAL_INFO subInfo;
    NTSTATUS status = STATUS_SUCCESS;

    DfsDbgTrace(+1, Dbg, "DfsRtlUnwindGet:  Entered\n", 0);

    for(typeInfo = &MarshalInfo->_typeInfo[0];
        typeInfo < LastTypeInfo;
        typeInfo++) {

        switch(typeInfo->_type & MTYPE_BASE_TYPE) {
        case MTYPE_COMPOUND:
            subInfo = typeInfo->_subinfo;
            itemSize = subInfo->_size;
            break;
        case MTYPE_GUID:
            itemSize = sizeof(GUID);
            break;
        case MTYPE_STRING:
            itemSize = sizeof(STRING);
            break;
        case MTYPE_UNICODE_STRING:
            itemSize = sizeof(UNICODE_STRING);
            break;
        case MTYPE_ULONG:
            itemSize = sizeof(ULONG);
            break;
        case MTYPE_USHORT:
            itemSize = sizeof(USHORT);
            break;
        case MTYPE_UCHAR:
            itemSize = sizeof(UCHAR);
            break;
        default:
            ExRaiseStatus(STATUS_DATA_ERROR);
        }

        if(typeInfo->_type & MTYPE_COUNTED_ARRAY) {
            cntptr = ((PUCHAR)Item + typeInfo->_cntoff);
            switch(typeInfo->_cntsize) {
            case sizeof(UCHAR):
                cnt = *(PUCHAR)cntptr;
                break;
            case sizeof(USHORT):
                cnt = *(PUSHORT)cntptr;
                break;
            case sizeof(ULONG):
                cnt = *(PULONG)cntptr;
                break;
            default:
                ExRaiseStatus(STATUS_DATA_ERROR);
            }
        } else
            cnt = typeInfo->_cntoff;

        if(typeInfo->_type & MTYPE_INDIRECT) {
            subItem = *(PUCHAR *)((PUCHAR)Item + typeInfo->_off);
            if(subItem == NULL &&
               !((typeInfo->_type & MTYPE_COUNTED_ARRAY) && cnt == 0))
                ExRaiseStatus(STATUS_DATA_ERROR);
        } else
            subItem = ((PUCHAR)Item + typeInfo->_off);

        switch(typeInfo->_type & ~MTYPE_INDIRECT) {

        case MTYPE_COMPOUND:
                DfsRtlUnwindGet(
                    subInfo,
                    &subInfo->_typeInfo[subInfo->_typecnt],
                    subItem
                );
                break;
        case (MTYPE_COMPOUND|MTYPE_COUNTED_ARRAY):
        case (MTYPE_COMPOUND|MTYPE_STATIC_ARRAY):
                subItemElem = (PUCHAR)subItem;
                while(cnt--) {
                    DfsRtlUnwindGet(
                        subInfo,
                        &subInfo->_typeInfo[subInfo->_typecnt],
                        subItemElem
                    );
                    ((PUCHAR)subItemElem) += itemSize;
                }
                break;
        case MTYPE_STRING:
                DfsRtlUnwindStringGet((PSTRING)subItem);
                break;
        case MTYPE_UNICODE_STRING:
                DfsRtlUnwindUnicodeStringGet((PUNICODE_STRING)subItem);
                break;
        case (MTYPE_UNICODE_STRING|MTYPE_COUNTED_ARRAY):
        case (MTYPE_UNICODE_STRING|MTYPE_STATIC_ARRAY):
                subItemElem = (PUCHAR)subItem;
                while(cnt--) {
                    DfsRtlUnwindUnicodeStringGet((PUNICODE_STRING)subItemElem);
                    ((PUCHAR)subItemElem) += itemSize;
                }
                break;
        case MTYPE_GUID:
        case MTYPE_ULONG:
        case MTYPE_USHORT:
        case MTYPE_UCHAR:
                break;
        default:
                ExRaiseStatus(STATUS_DATA_ERROR);
        };

        if(typeInfo->_type & MTYPE_INDIRECT) {
            MarshalBufferFree(subItem);
            *(PUCHAR *)((PUCHAR)Item + typeInfo->_off) = NULL;
        }
    }
    DfsDbgTrace(-1, Dbg, "DfsRtlUnwindGet:  Exit -> VOID\n", 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mup\dfsstruc.h ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:       dfsstruc.h
//
//  Contents:
//      This module defines the data structures that make up the major internal
//      part of the DFS file system.
//
//  Functions:
//
//  History:    12 Nov 1991     AlanW   Created from CDFS souce.
//               8 May 1992     PeterCo Removed all EP related stuff
//                                      Added stuff to support PKT
//              11 May 1992     PeterCo Added support for attached devices
//              24 April 1993   SudK    Added support for KernelToUserMode calls
//                                      Added support for timer functionality.
//-----------------------------------------------------------------------------


#ifndef _DFSSTRUC_
#define _DFSSTRUC_

typedef enum {
    DFS_UNKNOWN = 0,
    DFS_CLIENT = 1,
    DFS_SERVER = 2,
    DFS_ROOT_SERVER = 3,
} DFS_MACHINE_STATE;

typedef enum {
    LV_UNINITIALIZED = 0,
    LV_INITSCHEDULED,
    LV_INITINPROGRESS,
    LV_INITIALIZED,
    LV_VALIDATED
} DFS_LV_STATE;

//
//  The DFS_DATA record is the top record in the DFS file system in-memory
//  data structure.  This structure must be allocated from non-paged pool.
//

typedef struct _DFS_DATA {

    //
    //  The type and size of this record (must be DSFS_NTC_DATA_HEADER)
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  A queue of all the logical roots that are known by the file system.
    //

    LIST_ENTRY  VcbQueue;

    //
    //  A list of all the deleted logical roots that still have files open
    //  on them.
    //

    LIST_ENTRY  DeletedVcbQueue;

    //
    //  A queue of all the DRT (Deviceless roots) that are known.
    //

    LIST_ENTRY  DrtQueue;

    //
    //  A list of all the user-defined credentials
    //

    LIST_ENTRY  Credentials;

    //
    //  A list of all the deleted credentials. They will be destroyed once
    //  their ref count goes to 0
    //

    LIST_ENTRY  DeletedCredentials;

    //
    //  A list of all the offline roots
    //

    LIST_ENTRY  OfflineRoots;

    //
    //  A pointer to the Driver object we were initialized with
    //

    PDRIVER_OBJECT DriverObject;

    //
    //  A pointer to the \Dfs device object
    //

    PDEVICE_OBJECT FileSysDeviceObject;

    //
    //  A pointer to an array of provider records
    //

    struct _PROVIDER_DEF *pProvider;
    int cProvider, maxProvider;

    //
    //  A resource variable to control access to the global data record
    //

    ERESOURCE Resource;

    //
    //  A spin lock to control access to the global data record; handy for
    //  Interlocked operations.
    //

    KSPIN_LOCK DfsLock;

    //
    //  A pointer to our EPROCESS struct, which is a required input to the
    //  Cache Management subsystem.  This field is simply set each time an
    //  FSP thread is started, since it is easiest to do while running in the
    //  Fsp.
    //

    PEPROCESS OurProcess;

    //
    // Lookaside list for IRP contexts
    //

    NPAGED_LOOKASIDE_LIST IrpContextLookaside;

    //
    //  Device name prefix for the logical root devices.
    //  E.g.,  `\Device\WinDfs\'.
    //

    UNICODE_STRING LogRootDevName;

    //
    //  The state of the machine - DC, Server, Client etc.
    //

    DFS_MACHINE_STATE MachineState;

    //
    // The system wide Partition Knowledge Table (PKT)
    //

    DFS_PKT Pkt;

    //
    // DNR has been designed so that resources (like the Pkt above) are not
    // locked across network calls. This is critical to prevent inter-machine
    // deadlocks and for other functionality. To regulate access to these
    // resources, we use the following two events.
    //
    // This notify event is used to indicate that some thread is waiting to
    // write into the Pkt. If this event is !RESET!, it means that a thread
    // is waiting to write, and other threads trying to enter DNR should
    // hold off.
    //

    KEVENT PktWritePending;

    //
    // This semaphone is used to indicate that some thread(s) have currently
    // gone to get a referral. Another thread that wants to get a referral
    // should wait till this semaphone is SIGNALLED before attempting to go
    // get its own referral.
    //

    KSEMAPHORE PktReferralRequests;

    //
    //  A hash table for associating DFS_FCBs with file objects
    //

    struct _FCB_HASH_TABLE *FcbHashTable;

    //
    // EA buffer used to diffrentiate CSC opens from others
    //

    PFILE_FULL_EA_INFORMATION  CSCEaBuffer;
    ULONG                      CSCEaBufferLength;

} DFS_DATA, *PDFS_DATA;




#define MAX_PROVIDERS   5       // number of pre-allocated provider records

//
//  A PROVIDER_DEF is a structure that abstracts an underlying redirector.
//

typedef struct _PROVIDER_DEF {

    //
    //  The type and size of this record (must be DSFS_NTC_PROVIDER)
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  Provider ID and Capabilities, same as in the DS_REFERRAL structure.
    //

    USHORT      eProviderId;
    USHORT      fProvCapability;

    //
    //  The following field gives the name of the device for the provider.
    //

    UNICODE_STRING      DeviceName;

    //
    //  Referenced pointers to the associated file and device objects
    //

    PDEVICE_OBJECT      DeviceObject;
    PFILE_OBJECT        FileObject;

} PROVIDER_DEF, *PPROVIDER_DEF;


//
//  The Vcb (Volume Control Block) record corresponds to every volume
//  (ie, a net use) mounted by the file system.  They are ordered in a
//  queue off of DfsData.VcbQueue.
//
//  For the DFS file system, `volumes' correspond to DFS logical roots.
//  These records are an extension of a corresponding device object.
//

typedef struct _DFS_VCB {

    //
    //  The type and size of this record (must be DSFS_NTC_VCB)
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  The links for the device queue off of DfsData.VcbQueue
    //

    LIST_ENTRY  VcbLinks;

    //
    //  The internal state of the device.  This is a collection of FSD device
    //  state flags.
    //

    USHORT VcbState;

    //
    //  The logical root corresponding to this volume.  Forms part of the
    //  path name in the NT object name space. This string will be something
    //  like L"org", or L"dom" etc.
    //

    UNICODE_STRING LogicalRoot;

    //
    //  The LogRootPrefix has a prefix that needs to be prepended to file
    //  names being opened via this logical root before their name can
    //  be resolved.
    //

    UNICODE_STRING LogRootPrefix;

    //
    //  The credentials associated with this logical root
    //

    struct _DFS_CREDENTIALS *Credentials;

    //
    //  A count of the number of file objects that have opened the volume
    //  for direct access, and their share access state.
    //

    CLONG DirectAccessOpenCount;
    SHARE_ACCESS ShareAccess;

    //
    //  A count of the number of file objects that have any file/directory
    //  opened on this volume, not including direct access.
    //

    CLONG OpenFileCount;
    PFILE_OBJECT FileObjectWithVcbLocked;

#ifdef TERMSRV

    ULONG SessionID;

#endif // TERMSRV
    
    LUID  LogonID;
    PDFS_PKT_ENTRY pktEntry;
} DFS_VCB;
typedef DFS_VCB *PDFS_VCB;

#define VCB_STATE_FLAG_LOCKED           (0x0001)
#define VCB_STATE_FLAG_ALLOC_FCB        (0x0002)
#define VCB_STATE_CSCAGENT_VOLUME       (0x0004)
//#define VCB_STATE_FLAG_DEVICE_ONLY    (0x0008)

#ifdef TERMSRV

//
// This SessionId indicates that the device name should not be suffixed
// with :SessionID, and that no matching on SessionID should be done.
//

#define INVALID_SESSIONID               0xffffffff

#endif


//
//  A CREDENTIAL_RECORD is a user-supplied set of credentials that should
//  be used when accessing a particular Dfs. They are ordered in a queue
//  off of DfsData.Credentials;
//

typedef struct _DFS_CREDENTIALS {

    //
    //  The links for the credentials queue off of DfsData.Credentials
    //

    LIST_ENTRY Link;

    //
    //  A flags field to keep state about this credential record.
    //

    ULONG       Flags;

    //
    //  A ref count to keep this credential record from going away while
    //  it is being used.
    //

    ULONG       RefCount;

    //
    //  A count of the number of net uses that refer to these credentials
    //

    ULONG       NetUseCount;

    //
    //  The root of the Dfs for which these credentials apply.
    //

    UNICODE_STRING ServerName;
    UNICODE_STRING ShareName;

    //
    //  The domain name, user name and password to use when accessing the
    //  Dfs rooted at ServerName\ShareName
    //

    UNICODE_STRING DomainName;
    UNICODE_STRING UserName;
    UNICODE_STRING Password;

#ifdef TERMSRV

    ULONG SessionID;

#endif // TERMSRV

    LUID  LogonID;
    //
    //  When setting up a Tree connect using these credentials, we'll need
    //  to form an EA Buffer to pass in with the ZwCreateFile call. So, we
    //  form one here.
    //

    ULONG  EaLength;
    PUCHAR EaBuffer[1];

} DFS_CREDENTIALS;
typedef DFS_CREDENTIALS *PDFS_CREDENTIALS;

#define CRED_HAS_DEVICE         0x1
#define CRED_IS_DEVICELESS      0x2


//
//  The DFS_FCB record corresponds to every open file and directory.
//

typedef struct _DFS_FCB {

    //
    //  Type and size of this record (must be DSFS_NTC_FCB or DSFS_NTC_DCB)
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  A list entry for the hash table chain.
    //

    LIST_ENTRY HashChain;

    //
    //  A pointer to the Logical root device, through which this DFS_FCB
    //  was opened.
    //

    PDFS_VCB Vcb;

    //
    //  The following field is the fully qualified file name for this DFS_FCB/DCB
    //  starting from the logical root.
    //

    union {
       UNICODE_STRING FullFileName;
       DFS_NAME_CONTEXT DfsNameContext;
    };

    UNICODE_STRING AlternateFileName;

    //
    //  The following fields give the file and devices on which this DFS_FCB
    //  have been opened.  The DFS driver will pass through requests for
    //  the file object to the target device below.
    //

    PFILE_OBJECT FileObject;

    //
    //  The destinatation FSD device object through which I/O will be done.
    //

    PDEVICE_OBJECT TargetDevice;

    //
    //  The provider def that opened this file
    //

    USHORT ProviderId;

    //
    //  The DFS_MACHINE_ENTRY through which this file was opened. We need
    //  to maintain a reference for each file on a DFS_MACHINE_ENTRY in
    //  case we have authenticated connections to the server; we don't want
    //  to tear down the authenticated connection if files are open.
    //

    PDFS_MACHINE_ENTRY DfsMachineEntry;

    WORK_QUEUE_ITEM WorkQueueItem;

} DFS_FCB, *PDFS_FCB;



//
//  The Logical Root Device Object is an I/O system device object
//  created as a result of creating a DFS logical root.
//  Logical roots are in many ways analogous to volumes
//  for a local file system.
//
//  There is a DFS_VCB record appended to the end.
//

typedef struct _LOGICAL_ROOT_DEVICE_OBJECT {

    DEVICE_OBJECT DeviceObject;

    //
    //  This is the file system specific volume control block.
    //

    DFS_VCB Vcb;

} LOGICAL_ROOT_DEVICE_OBJECT, *PLOGICAL_ROOT_DEVICE_OBJECT;



//
//  The Irp Context record is allocated for every orginating Irp.  It
//  is created by the Fsd dispatch routines, and deallocated by the
//  DfsCompleteRequest routine
//

typedef struct _IRP_CONTEXT {

    //
    //  Type and size of this record (must be DSFS_NTC_IRP_CONTEXT)
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  This structure is used for posting to the Ex worker threads.
    //

    WORK_QUEUE_ITEM WorkQueueItem;

    //
    //  A pointer to the originating Irp.
    //

    PIRP OriginatingIrp;

    //
    //  A pointer to function dependent context.
    //

    PVOID Context;

    //
    //  Major and minor function codes copied from the Irp
    //

    UCHAR MajorFunction;
    UCHAR MinorFunction;

    //
    //  The following flags field indicates if we can wait/block for a resource
    //  or I/O, if we are to do everything write through, and if this
    //  entry into the Fsd is a recursive call
    //

    USHORT Flags;

    //
    //  The following field contains the NTSTATUS value used when we are
    //  unwinding due to an exception
    //

    NTSTATUS ExceptionStatus;

} IRP_CONTEXT;
typedef IRP_CONTEXT *PIRP_CONTEXT;

//
//  Values for the Irp context Flags field.
//

//#define IRP_CONTEXT_FLAG_FROM_POOL       (0x00000001) // replaced by lookaside list
#define IRP_CONTEXT_FLAG_WAIT            (0x00000002)
#define IRP_CONTEXT_FLAG_IN_FSD          (0x00000004)


//
// This context is used by the DfsIoTimer routine. We can expand on this
// whenever new functionality needs to be added to the Timer function.
//
typedef struct  _DFS_TIMER_CONTEXT {

    //
    //  TickCount. To keep track of how many times the timer routine was
    //  called.  The timer uses this to do things at a coarser granularity.
    //
    ULONG       TickCount;

    //
    //  InUse. This field is used to denote that this CONTEXT is in use
    //  by some function to which the Timer routine has passed it off.  This
    //  is used in a simple way to control access to this context.
    //
    BOOLEAN     InUse;

    //
    //  ValidateLocalPartitions. This field is used to denote that the
    //  local volumes should be validated at this time.
    //

    BOOLEAN     ValidateLocalPartitions;

    //
    //  This is used to schedule DfsAgePktEntries.
    //

    WORK_QUEUE_ITEM     WorkQueueItem;

    //
    //  This is used to schedule DfsDeleteDevices.
    //

    WORK_QUEUE_ITEM     DeleteQueueItem;

} DFS_TIMER_CONTEXT, *PDFS_TIMER_CONTEXT;

//
//  The following constant is the number of seconds between any two scans
//  through the PKT to get rid of old PKT entries.
//
#define DFS_MAX_TICKS                   240

//
//  The following constant is the number of seconds that a referral will
//  remain in cache (PKT).
//

#define MAX_REFERRAL_LIFE_TIME          300

//
// The followin constants are the starting timeout (in seconds) between
// special referrals.  The start value is doubled after every retry until it
// reaches the max.
//

#define SPECIAL_TIMEOUT_START           (5*60)          // 5 min
#define SPECIAL_TIMEOUT_MAX             (60*60)         // 60 min


//
//  The Drt (Devless Root) record corresponds to every net use.
//  They are ordered in a queue off of DfsData.VcbQueue.
//
//

typedef struct _DFS_DEVLESS_ROOT {

    //
    //  The type and size of this record (must be DSFS_NTC_DRT)
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  The links for the device queue off of DfsData.DrtQueue
    //

    LIST_ENTRY  DrtLinks;

    //
    //  The pathname corresponding to this entry.
    //

    UNICODE_STRING DevlessPath;

    //
    //  The credentials associated with this logical root
    //

    struct _DFS_CREDENTIALS *Credentials;

#ifdef TERMSRV

    ULONG SessionID;

#endif // TERMSRV
    
    LUID  LogonID;
    PDFS_PKT_ENTRY pktEntry;
} DFS_DEVLESS_ROOT;

typedef DFS_DEVLESS_ROOT *PDFS_DEVLESS_ROOT;

#endif // _DFSSTRUC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mup\dfsmrshl.h ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation
//
//  File:       DfsMrshl.h
//
//  Contents:   Defines for Dfs marshalling routines
//
//  Classes:
//
//  Functions:
//
//  History:    March 29, 1994          Milans Created from Peterco's dfsrtl.h
//
//-----------------------------------------------------------------------------

#ifndef _DFSMRSHL_
#define _DFSMRSHL_

#ifdef __cplusplus
extern "C" {
#endif

#include <stddef.h>
#include <guiddef.h>
//
// MARSHALLING AND UNMARSHALLING SUPPORT
//

#ifdef  KERNEL_MODE
#define MarshalBufferAllocate(x)   ExAllocatePoolWithTag(PagedPool, x, ' puM')
#define MarshalBufferFree(x)       ExFreePool(x)
#else
#include <stdlib.h>
#define MarshalBufferAllocate(x)   malloc(x)
#define MarshalBufferFree(x)       free(x)
#endif // KERNEL_MODE

#define DfsAllocate                MarshalBufferAllocate
#define DfsFree                    MarshalBufferFree

//
// Structure used when marshalling and unmarhalling
//
typedef struct _MARSHAL_BUFFER {

    PUCHAR  First;
    PUCHAR  Current;
    PUCHAR  Last;

} MARSHAL_BUFFER, *PMARSHAL_BUFFER;


typedef struct _MARSHAL_TYPE_INFO {

    ULONG _type;                    // the type of item to be marshalled
    ULONG _off;                     // offset of item (in the struct)
    ULONG _cntsize;                 // size of counter for counted array
    ULONG _cntoff;                  // else, offset count item (in the struct)
    struct _MARSHAL_INFO * _subinfo;// if compound type, need info

} MARSHAL_TYPE_INFO, *PMARSHAL_TYPE_INFO;


typedef struct _MARSHAL_INFO {

    ULONG _size;                    // size of item
    ULONG _typecnt;                 // number of type infos
    PMARSHAL_TYPE_INFO _typeInfo;   // type infos

} MARSHAL_INFO, *PMARSHAL_INFO;

#define _mkMarshalInfo(s, i)\
    {(ULONG)sizeof(s),(ULONG)(sizeof(i)/sizeof(MARSHAL_TYPE_INFO)),i}


#define MTYPE_BASE_TYPE             (0x0000ffffL)

#define MTYPE_COMPOUND              (0x00000001L)
#define MTYPE_GUID                  (0x00000002L)
#define MTYPE_STRING                (0x00000003L)
#define MTYPE_UNICODE_STRING        (0x00000004L)
#define MTYPE_ULONG                 (0x00000005L)
#define MTYPE_USHORT                (0x00000006L)
#define MTYPE_PWSTR                 (0x00000007L)
#define MTYPE_UCHAR                 (0x00000008L)
#define MTYPE_CONFORMANT_CNT        (0x00000009L)

#define MTYPE_INDIRECT      (0x80000000L)

#define MTYPE_COMPLEX_TYPE          (0x7fff0000L)

#define MTYPE_STATIC_ARRAY  (0x00010000L)
#define MTYPE_COUNTED_ARRAY (0x00020000L)


#define _MCode_conformant(s,m,c)\
    {MTYPE_CONFORMANT_CNT, sizeof(((s *) 0)->m[0]), sizeof(((s *) 0)->c), offsetof(s,c), 0L}

#define _MCode_Base(t,s,m,i)\
    {t,offsetof(s,m),0L,0L,i}

#define _MCode_struct(s,m,i)\
    _MCode_Base(MTYPE_COMPOUND,s,m,i)
#define _MCode_guid(s,m)\
    _MCode_Base(MTYPE_GUID,s,m,NULL)
#define _MCode_str(s,m)\
    _MCode_Base(MTYPE_STRING,s,m,NULL)
#define _MCode_ustr(s,m)\
    _MCode_Base(MTYPE_UNICODE_STRING,s,m,NULL)
#define _MCode_pwstr(s,m)\
    _MCode_Base(MTYPE_PWSTR,s,m,NULL)
#define _MCode_ul(s,m)\
    _MCode_Base(MTYPE_ULONG,s,m,NULL)
#define _MCode_ush(s,m)\
    _MCode_Base(MTYPE_USHORT,s,m,NULL)
#define _MCode_uch(s,m)\
    _MCode_Base(MTYPE_UCHAR,s,m,NULL)

#define _MCode_pstruct(s,m,i)\
    _MCode_Base(MTYPE_COMPOUND|MTYPE_INDIRECT,s,m,i)
#define _MCode_pguid(s,m)\
    _MCode_Base(MTYPE_GUID|MTYPE_INDIRECT,s,m,NULL)
#define _MCode_pstr(s,m)\
    _MCode_Base(MTYPE_STRING|MTYPE_INDIRECT,s,m,NULL)
#define _MCode_pustr(s,m)\
    _MCode_Base(MTYPE_UNICODE_STRING|MTYPE_INDIRECT,s,m,NULL)
#define _MCode_pul(s,m)\
    _MCode_Base(MTYPE_ULONG|MTYPE_INDIRECT,s,m,NULL)
#define _MCode_push(s,m)\
    _MCode_Base(MTYPE_USHORT|MTYPE_INDIRECT,s,m,NULL)
#define _MCode_puch(s,m)\
    _MCode_Base(MTYPE_UCHAR|MTYPE_INDIRECT,s,m,NULL)

#define _MCode_aStatic(t,s,m,c,i)\
    {t|MTYPE_STATIC_ARRAY,offsetof(s,m),0L,c,i}

#define _MCode_astruct(s,m,c,i)\
    _MCode_aStatic(MTYPE_COMPOUND,s,m,c,i)
#define _MCode_aguid(s,m,c)\
    _MCode_aStatic(MTYPE_GUID,s,m,c,NULL)
#define _MCode_astr(s,m,c)\
    _MCode_aStatic(MTYPE_STRING,s,m,c,NULL)
#define _MCode_austr(s,m,c)\
    _MCode_aStatic(MTYPE_UNICODE_STRING,s,m,c,NULL)
#define _MCode_aul(s,m,c)\
    _MCode_aStatic(MTYPE_ULONG,s,m,c,NULL)
#define _MCode_aush(s,m,c)\
    _MCode_aStatic(MTYPE_USHORT,s,m,c,NULL)
#define _MCode_auch(s,m,c)\
    _MCode_aStatic(MTYPE_UCHAR,s,m,c,NULL)

#define _MCode_pastruct(s,m,c,i)\
    _MCode_aStatic(MTYPE_COMPOUND|MTYPE_INDIRECT,s,m,c,i)
#define _MCode_paguid(s,m,c)\
    _MCode_aStatic(MTYPE_GUID|MTYPE_INDIRECT,s,m,c,NULL)
#define _MCode_pastr(s,m,c)\
    _MCode_aStatic(MTYPE_STRING|MTYPE_INDIRECT,s,m,c,NULL)
#define _MCode_paustr(s,m,c)\
    _MCode_aStatic(MTYPE_UNICODE_STRING|MTYPE_INDIRECT,s,m,c,NULL)
#define _MCode_paul(s,m,c)\
    _MCode_aStatic(MTYPE_ULONG|MTYPE_INDIRECT,s,m,c,NULL)
#define _MCode_paush(s,m,c)\
    _MCode_aStatic(MTYPE_USHORT|MTYPE_INDIRECT,s,m,c,NULL)
#define _MCode_pauch(s,m,c)\
    _MCode_aStatic(MTYPE_UCHAR|MTYPE_INDIRECT,s,m,c,NULL)

#define _MCode_aCounted(t,s,m,c,i) {\
    t|MTYPE_COUNTED_ARRAY,\
    offsetof(s,m),\
    sizeof(((s *)0)->c),\
    offsetof(s,c),\
    i\
    }

#define _MCode_castruct(s,m,c,i)\
    _MCode_aCounted(MTYPE_COMPOUND,s,m,c,i)
#define _MCode_caguid(s,m,c)\
    _MCode_aCounted(MTYPE_GUID,s,m,c,NULL)
#define _MCode_capwstr(s,m,c)\
    _MCode_aCounted(MTYPE_PWSTR,s,m,c,NULL)
#define _MCode_castr(s,m,c)\
    _MCode_aCounted(MTYPE_STRING,s,m,c,NULL)
#define _MCode_caustr(s,m,c)\
    _MCode_aCounted(MTYPE_UNICODE_STRING,s,m,c,NULL)
#define _MCode_caul(s,m,c)\
    _MCode_aCounted(MTYPE_ULONG,s,m,c,NULL)
#define _MCode_caush(s,m,c)\
    _MCode_aCounted(MTYPE_USHORT,s,m,c,NULL)
#define _MCode_cauch(s,m,c)\
    _MCode_aCounted(MTYPE_UCHAR,s,m,c,NULL)

#define _MCode_pcastruct(s,m,c,i)\
    _MCode_aCounted(MTYPE_COMPOUND|MTYPE_INDIRECT,s,m,c,i)
#define _MCode_pcaguid(s,m,c)\
    _MCode_aCounted(MTYPE_GUID|MTYPE_INDIRECT,s,m,c,NULL)
#define _MCode_pcapwstr(s,m,c)\
    _MCode_aCounted(MTYPE_PWSTR|MTYPE_INDIRECT,s,m,c,NULL)
#define _MCode_pcastr(s,m,c)\
    _MCode_aCounted(MTYPE_STRING|MTYPE_INDIRECT,s,m,c,NULL)
#define _MCode_pcaustr(s,m,c)\
    _MCode_aCounted(MTYPE_UNICODE_STRING|MTYPE_INDIRECT,s,m,c,NULL)
#define _MCode_pcaul(s,m,c)\
    _MCode_aCounted(MTYPE_ULONG|MTYPE_INDIRECT,s,m,c,NULL)
#define _MCode_pcaush(s,m,c)\
    _MCode_aCounted(MTYPE_USHORT|MTYPE_INDIRECT,s,m,c,NULL)



#define MarshalBufferInitialize( MarshalBuffer, BufferLength, Buffer ) {\
    (MarshalBuffer)->First = (PUCHAR)(Buffer);                          \
    (MarshalBuffer)->Current = (PUCHAR)(Buffer);                        \
    (MarshalBuffer)->Last = &(MarshalBuffer)->Current[(BufferLength)];  \
    }


//
// Defines and functions for unmarshalling base types.
// The BYTE masks are perfectly fine and they dont care if
// we are on working on LITTLE_ENDIAN or BIG_ENDIAN etc.
//

#define BYTE_0_MASK 0xFF

#define BYTE_0(Value) (UCHAR)(  (Value)        & BYTE_0_MASK)
#define BYTE_1(Value) (UCHAR)( ((Value) >>  8) & BYTE_0_MASK)
#define BYTE_2(Value) (UCHAR)( ((Value) >> 16) & BYTE_0_MASK)
#define BYTE_3(Value) (UCHAR)( ((Value) >> 24) & BYTE_0_MASK)


#define DfsRtlGetUshort(MarshalBuffer, pValue) (                        \
    ((MarshalBuffer)->Current + 2 <= (MarshalBuffer)->Last) ?           \
        *(pValue) = (USHORT)((MarshalBuffer)->Current[0]     ) |        \
                            ((MarshalBuffer)->Current[1] << 8),         \
        (MarshalBuffer)->Current += 2,                                  \
        STATUS_SUCCESS                                                  \
     :  STATUS_DATA_ERROR                                               \
    )

#define DfsRtlPutUshort(MarshalBuffer, pValue) (                        \
    ((MarshalBuffer)->Current + 2 <= (MarshalBuffer)->Last) ?           \
        (MarshalBuffer)->Current[0] = BYTE_0(*pValue),                  \
        (MarshalBuffer)->Current[1] = BYTE_1(*pValue),                  \
        (MarshalBuffer)->Current += 2,                                  \
        STATUS_SUCCESS                                                  \
     :  STATUS_BUFFER_TOO_SMALL                                         \
    )

#define DfsRtlGetUlong(MarshalBuffer, pValue) (                         \
    ((MarshalBuffer)->Current + 4 <= (MarshalBuffer)->Last) ?           \
        *(pValue) = (ULONG) ((MarshalBuffer)->Current[0]      ) |       \
                            ((MarshalBuffer)->Current[1] <<  8) |       \
                            ((MarshalBuffer)->Current[2] << 16) |       \
                            ((MarshalBuffer)->Current[3] << 24),        \
        (MarshalBuffer)->Current += 4,                                  \
        STATUS_SUCCESS                                                  \
     :  STATUS_DATA_ERROR                                               \
    )

#define DfsRtlPutUlong(MarshalBuffer, pValue) (                         \
    ((MarshalBuffer)->Current + 4 <= (MarshalBuffer)->Last) ?           \
        (MarshalBuffer)->Current[0] = BYTE_0(*pValue),                  \
        (MarshalBuffer)->Current[1] = BYTE_1(*pValue),                  \
        (MarshalBuffer)->Current[2] = BYTE_2(*pValue),                  \
        (MarshalBuffer)->Current[3] = BYTE_3(*pValue),                  \
        (MarshalBuffer)->Current += 4,                                  \
        STATUS_SUCCESS                                                  \
     :  STATUS_BUFFER_TOO_SMALL                                         \
    )

#define DfsRtlGetGuid(MarshalBuffer, pValue) (                          \
    ((MarshalBuffer)->Current + 16 <= (MarshalBuffer)->Last) ?          \
        (pValue)->Data1 = (ULONG) ((MarshalBuffer)->Current[0]      ) | \
                                  ((MarshalBuffer)->Current[1] <<  8) | \
                                  ((MarshalBuffer)->Current[2] << 16) | \
                                  ((MarshalBuffer)->Current[3] << 24) , \
        (pValue)->Data2 = (USHORT)((MarshalBuffer)->Current[4]      ) | \
                                  ((MarshalBuffer)->Current[5] <<  8) , \
        (pValue)->Data3 = (USHORT)((MarshalBuffer)->Current[6]      ) | \
                                  ((MarshalBuffer)->Current[7] <<  8) , \
        memcpy((pValue)->Data4, &(MarshalBuffer)->Current[8], 8),       \
        (MarshalBuffer)->Current += 16,                                 \
        STATUS_SUCCESS                                                  \
     :  STATUS_DATA_ERROR                                               \
    )


//
// This routine is being used for DFS_UPD_REFERRAL_BUFFER. These
// routines will continue to be used in the future as well since
// we want to keep the structure of DFS_UPD_REFERRAL_BUFFER well
// defined rather than using the Marshalling routines provided here.
//
#define _PutGuid(cp, pguid)                      \
        cp[0] = BYTE_0((pguid)->Data1),          \
        cp[1] = BYTE_1((pguid)->Data1),          \
        cp[2] = BYTE_2((pguid)->Data1),          \
        cp[3] = BYTE_3((pguid)->Data1),          \
        cp[4] = BYTE_0((pguid)->Data2),          \
        cp[5] = BYTE_1((pguid)->Data2),          \
        cp[6] = BYTE_0((pguid)->Data3),          \
        cp[7] = BYTE_1((pguid)->Data3),          \
        memcpy(&cp[8], (pguid)->Data4, 8)


#define _PutULong(cp, ularg)                    \
        cp[0] = BYTE_0(ularg),                  \
        cp[1] = BYTE_1(ularg),                  \
        cp[2] = BYTE_2(ularg),                  \
        cp[3] = BYTE_3(ularg)


#define _GetULong(cp, ularg)                    \
        ularg = (ULONG) (cp[0])         |       \
                        (cp[1] << 8)    |       \
                        (cp[2] << 16)   |       \
                        (cp[3] << 24)


#define DfsRtlPutGuid(MarshalBuffer, pValue) (                          \
    ((MarshalBuffer)->Current + 16 <= (MarshalBuffer)->Last) ?          \
        (MarshalBuffer)->Current[0] = BYTE_0((pValue)->Data1),          \
        (MarshalBuffer)->Current[1] = BYTE_1((pValue)->Data1),          \
        (MarshalBuffer)->Current[2] = BYTE_2((pValue)->Data1),          \
        (MarshalBuffer)->Current[3] = BYTE_3((pValue)->Data1),          \
        (MarshalBuffer)->Current[4] = BYTE_0((pValue)->Data2),          \
        (MarshalBuffer)->Current[5] = BYTE_1((pValue)->Data2),          \
        (MarshalBuffer)->Current[6] = BYTE_0((pValue)->Data3),          \
        (MarshalBuffer)->Current[7] = BYTE_1((pValue)->Data3),          \
        memcpy(&(MarshalBuffer)->Current[8], (pValue)->Data4, 8),       \
        (MarshalBuffer)->Current += 16,                                 \
        STATUS_SUCCESS                                                  \
     :  STATUS_BUFFER_TOO_SMALL                                         \
    )



#define DfsRtlSizeString(pString, pSize) (                              \
    ((pString)->Length > 0) ? (                                         \
        ((pString)->Buffer != NULL) ?                                   \
            (*(pSize)) += (2 + (pString)->Length),                      \
            STATUS_SUCCESS                                              \
        :   STATUS_DATA_ERROR                                           \
        )                                                               \
    :   ((*(pSize)) += 2,                                               \
        STATUS_SUCCESS)                                                 \
    )

#define DfsRtlSizepwString(pString, pSize) (                            \
        (*pString != NULL) ?                                            \
            (*(pSize)) += ((1 + wcslen(*pString))*sizeof(WCHAR)),       \
            STATUS_SUCCESS                                              \
    :   ((*(pSize)) += 2,                                               \
        STATUS_SUCCESS)                                                 \
    )

#define DfsRtlSizeUnicodeString(pUnicodeString, pSize)                  \
    DfsRtlSizeString(pUnicodeString, pSize)


NTSTATUS
DfsRtlGet(
    IN OUT  PMARSHAL_BUFFER MarshalBuffer,
    IN  PMARSHAL_INFO MarshalInfo,
    OUT PVOID Item
);


NTSTATUS
DfsRtlPut(
    IN OUT  PMARSHAL_BUFFER MarshalBuffer,
    IN  PMARSHAL_INFO MarshalInfo,
    OUT PVOID Item
);


NTSTATUS
DfsRtlSize(
    IN  PMARSHAL_INFO MarshalInfo,
    IN  PVOID Item,
    OUT PULONG Size
);

VOID
DfsRtlUnwindGet(
    IN  PMARSHAL_INFO MarshalInfo,
    IN  PMARSHAL_TYPE_INFO LastTypeInfo,
    IN  PVOID Item
);

#ifdef __cplusplus
}
#endif

#endif // _DFSMRSHL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mup\dfsprocs.h ===
//+----------------------------------------------------------------------------
//
//  File:   DFSPROCS.H
//
//  Contents:
//  This module defines all of the globally used procedures in the Dsfs
//  file system.
//
//  Functions:
//
//  History:    12 Nov 1991 AlanW   Created from CDFS souce.
//              8  May 1992 PeterCo Removed References to EPs
//                                  Added stuff to support PKT (M000)
//-----------------------------------------------------------------------------


#ifndef _DFSPROCS_
#define _DFSPROCS_

//
// "System" include files
//
#if defined (MUPKD)
#include <ntos.h>
#include <string.h>
#include <fsrtl.h>

#else
#include <ntifs.h>
#include <ntddser.h>

#endif

#include <windef.h>
#include <tdi.h>
#include <wincred.h>

#include <ntddnfs.h>                             // For communicating with
                                                 // the SMB Rdr
#include <ntddmup.h>                             // For UNC registration


#include <winnetwk.h>                            // For NETRESOURCE def'n

#include <dfsfsctl.h>                            // Dfs FsControl Codes.

#include <lmdfs.h>                               // DFS_INFO_X

#include "dfserr.h"
#include "dfsstr.h"
#include "nodetype.h"
#include "dfsmrshl.h"
#include "dfsrtl.h"
#include "pkt.h"
#include "dfsstruc.h"
#include "dfsdata.h"
#include "log.h"

#ifndef i386

#define DFS_UNALIGNED   UNALIGNED

#else

#define DFS_UNALIGNED

#endif // MIPS

NTSYSAPI
NTSTATUS
NTAPI
ZwQueryInformationProcess(
    IN HANDLE ProcessHandle,
    IN PROCESSINFOCLASS ProcessInformationClass,
    OUT PVOID ProcessInformation,
    IN ULONG ProcessInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwCreateSymbolicLinkObject(
    OUT PHANDLE LinkHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN PUNICODE_STRING LinkTarget
    );

//
//  The driver entry routine
//

NTSTATUS
DfsDriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
);

VOID
DfsUnload(
    IN PDRIVER_OBJECT DriverObject
    );


//
//  The following routine is used to create and initialIze logical root
//  device objects, implemented in dsinit.c
//

#ifdef TERMSRV

NTSTATUS
DfsInitializeLogicalRoot (
    IN LPCWSTR Name,
    IN PUNICODE_STRING Prefix OPTIONAL,
    IN PDFS_CREDENTIALS Credentials OPTIONAL,
    IN USHORT VcbFlags OPTIONAL,
    IN ULONG SessionID,
    IN PLUID LogonID
    );

NTSTATUS
DfsDeleteLogicalRoot (
    IN PWSTR Name,
    IN BOOLEAN fForce,
    IN ULONG SessionID,
    IN PLUID LogonID
    );

BOOLEAN
DfsLogicalRootExists(
    IN PWSTR pwszName,
    IN ULONG SessionID,
    IN PLUID LogonID
    );

NTSTATUS
DfsInitializeDevlessRoot (
    IN PUNICODE_STRING NAME,
    IN PDFS_CREDENTIALS Credentials OPTIONAL,
    IN ULONG SessionID,
    IN PLUID LogonID
);

NTSTATUS
DfsDeleteDevlessRoot (
    IN PUNICODE_STRING NAME,
    IN ULONG SessionID,
    IN PLUID LogonID
);

NTSTATUS
DfsFindDevlessRoot(
    IN PUNICODE_STRING Name,
    IN ULONG SessionID,
    IN PLUID LogonID,
    OUT PDFS_DEVLESS_ROOT *Drt
    );

#else // TERMSRV

NTSTATUS
DfsInitializeLogicalRoot (
    IN LPCWSTR Name,
    IN PUNICODE_STRING Prefix OPTIONAL,
    IN PDFS_CREDENTIALS Credentials OPTIONAL,
    IN USHORT VcbFlags OPTIONAL,
    IN PLUID LogonID
);

NTSTATUS
DfsDeleteLogicalRoot (
    IN PWSTR Name,
    IN BOOLEAN fForce,
    IN PLUID LogonID
);

BOOLEAN
DfsLogicalRootExists(
    PWSTR       pwszName,
    IN PLUID LogonID
);

NTSTATUS
DfsInitializeDevlessRoot (
    IN PUNICODE_STRING NAME,
    IN PDFS_CREDENTIALS Credentials OPTIONAL,
    IN PLUID LogonID
);

NTSTATUS
DfsDeleteDevlessRoot (
    IN PUNICODE_STRING NAME,
    IN PLUID LogonID
);

NTSTATUS
DfsFindDevlessRoot(
    IN PUNICODE_STRING Name,
    IN PLUID LogonID,
    OUT PDFS_DEVLESS_ROOT *Drt
    );

#endif // TERMSRV


NTSTATUS
DfspLogRootNameToPath(
    LPCWSTR         Name,
    PUNICODE_STRING RootName
);


NTSTATUS
DfsGetResourceFromVcb(
    PIRP                pIrp,
    PDFS_VCB            Vcb,
    PUNICODE_STRING     ProviderName,
    PUCHAR              BufBegin,
    PUCHAR              Buf,
    PULONG              BufSize,
    PULONG              pResourceSize
);

NTSTATUS
DfsGetResourceFromDevlessRoot(
    PIRP                pIrp,
    PDFS_DEVLESS_ROOT   Drt,
    PUNICODE_STRING     ProviderName,
    PUCHAR              BufBegin,
    PUCHAR              Buf,
    PULONG              BufSize,
    PULONG              pResourceSize
);

//
//  The following routines are used to manipulate the fcb associated with
//  each opened file object, implemented in FilObSup.c
//

typedef enum _TYPE_OF_OPEN {
    UnopenedFileObject = 1,
    FilesystemDeviceOpen,
    LogicalRootDeviceOpen,
    RedirectedFileOpen,
    UserVolumeOpen,
    UnknownOpen,
} TYPE_OF_OPEN;

VOID
DfsSetFileObject (
    IN PFILE_OBJECT FileObject OPTIONAL,
    IN TYPE_OF_OPEN TypeOfOpen,
    IN PVOID VcbOrFcb
);

TYPE_OF_OPEN
DfsDecodeFileObject (
    IN PFILE_OBJECT FileObject,
    OUT PDFS_VCB *Vcb,
    OUT PDFS_FCB *Fcb
);



//
//  In-memory structure support routines, implemented in StrucSup.c
//

PIRP_CONTEXT
DfsCreateIrpContext (
    IN PIRP Irp,
    IN BOOLEAN Wait
    );

VOID
DfsDeleteIrpContext_Real (
    IN PIRP_CONTEXT IrpContext
    );

#if DBG
#define DfsDeleteIrpContext(IRPCONTEXT) {   \
    DfsDeleteIrpContext_Real((IRPCONTEXT)); \
    (IRPCONTEXT) = NULL;            \
}
#else
#define DfsDeleteIrpContext(IRPCONTEXT) {   \
    DfsDeleteIrpContext_Real((IRPCONTEXT)); \
}
#endif

VOID
DfsInitializeVcb (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PDFS_VCB Vcb,
    IN PUNICODE_STRING LogRootPrefix,
    IN PDFS_CREDENTIALS Credentials OPTIONAL,
    IN PDEVICE_OBJECT TargetDeviceObject
);

VOID
DfsInitializeDrt (
    IN OUT PDFS_DEVLESS_ROOT Drt,
    IN PUNICODE_STRING Name,
    IN PDFS_CREDENTIALS Credentials OPTIONAL
);


VOID
DfsDeleteVcb_Real (
    IN PIRP_CONTEXT IrpContext,
    IN PDFS_VCB Vcb
);

#if DBG
#define DfsDeleteVcb(IRPCONTEXT,VCB) {    \
    DfsDeleteVcb_Real((IRPCONTEXT),(VCB)); \
    (VCB) = NULL;              \
}
#else
#define DfsDeleteVcb(IRPCONTEXT,VCB) {    \
    DfsDeleteVcb_Real((IRPCONTEXT),(VCB)); \
}
#endif


PDFS_FCB
DfsCreateFcb (
    IN PIRP_CONTEXT IrpContext,
    IN PDFS_VCB Vcb,
    IN PUNICODE_STRING FullName OPTIONAL
    );

VOID
DfsDeleteFcb_Real (
    IN PIRP_CONTEXT IrpContext,
    IN PDFS_FCB Fcb
    );

#if DBG
#define DfsDeleteFcb(IRPCONTEXT,FCB) {    \
    DfsDeleteFcb_Real((IRPCONTEXT),(FCB)); \
    (FCB) = NULL;              \
}
#else
#define DfsDeleteFcb(IRPCONTEXT,FCB) {    \
    DfsDeleteFcb_Real((IRPCONTEXT),(FCB)); \
}
#endif


//
//  Miscellaneous routines
//

VOID GuidToString(
    IN GUID   *pGuid,
    OUT PWSTR pwszGuid);

VOID StringToGuid(
    IN PWSTR pwszGuid,
    OUT GUID *pGuid);


#ifdef TERMSRV

NTSTATUS
DfsFindLogicalRoot(                 //  implemented in FsCtrl.c
    IN PUNICODE_STRING PrefixPath,
    IN ULONG SessionID,
    IN PLUID LogonID,
    OUT PDFS_VCB *Vcb,
    OUT PUNICODE_STRING RemainingPath
    );

#else // TERMSRV

NTSTATUS
DfsFindLogicalRoot(                 //  implemented in FsCtrl.c
    IN PUNICODE_STRING PrefixPath,
    IN PLUID LogonID,
    OUT PDFS_VCB *Vcb,
    OUT PUNICODE_STRING RemainingPath
    );

#endif // TERMSRV

NTSTATUS
DfsInsertProvider(                  //  implemented in FsCtrl.c
    IN PUNICODE_STRING pustrProviderName,
    IN ULONG           fProvCapability,
    IN ULONG           eProviderId);

NTSTATUS                            //  implemented in provider.c
DfsGetProviderForDevice(
    IN PUNICODE_STRING DeviceName,
    PPROVIDER_DEF *Provider);

VOID
DfsAgePktEntries(
    IN PVOID DfsTimerContext
    );

NTSTATUS
DfsFsctrlIsThisADfsPath(
    IN PUNICODE_STRING filePath,
    IN BOOLEAN          CSCAgentCreate,
    OUT PUNICODE_STRING pathName);

NTSTATUS
PktFsctrlFlushCache(
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength
);

NTSTATUS
PktFsctrlFlushSpcCache(
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength
);

NTSTATUS
DfsFsctrlSetDCName(
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength);

NTSTATUS
DfsFsctrlSetDomainNameFlat(
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength);

NTSTATUS
DfsFsctrlSetDomainNameDns(
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength);

NTSTATUS
PktpSetActiveSpcService(
    PUNICODE_STRING DomainName,
    PUNICODE_STRING DcName,
    BOOLEAN ResetTimeout);

NTSTATUS
PktpUpdateSpecialTable(
    PUNICODE_STRING DomainName,
    PUNICODE_STRING DCName);


//
// Pass-through functions
//
NTSTATUS
DfsVolumePassThrough(
    IN  PDEVICE_OBJECT DeviceObject,
    IN  PIRP Irp
);

NTSTATUS
DfsCompleteVolumePassThrough(
    IN  PDEVICE_OBJECT pDevice,
    IN  PIRP Irp,
    IN  PVOID Context
);

NTSTATUS
DfsFilePassThrough(
    IN  PDFS_FCB pFcb,
    IN  PIRP Irp
);


//
//  The FSD Level dispatch routines.   These routines are called by the
//  I/O system via the dispatch table in the Driver Object.
//
//  They each accept as input a pointer to a device object (actually most
//  expect a logical root device object; some will also work with a file
//  system device object), and a pointer to the IRP.  They either perform
//  the function at the FSD level or post the request to the FSP work
//  queue for FSP level processing.
//

NTSTATUS
DfsFsdCleanup (                 //  implemented in Close.c
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
DfsFsdClose (                   //  implemented in Close.c
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
DfsFsdCreate (                  //  implemented in Create.c
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
DfsFsdDeviceIoControl (         //  implemented in FsCtrl.c
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
DfsFsdDirectoryControl (            //  implemented in DirCtrl.c
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
DfsFsdQueryInformation (            //  implemented in FileInfo.c
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
DfsFsdQueryInformation (            //  implemented in FileInfo.c
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
DfsFsdSetInformation (              //  implemented in FileInfo.c
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
DfsFsdFileSystemControl (           //  implemented in FsCtrl.c
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
DfsFsdQueryVolumeInformation (          //  implemented in VolInfo.c
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
DfsFsdSetVolumeInformation (            //  implemented in VolInfo.c
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

//
//  The following macro is used to determine if an FSD thread can block
//  for I/O or wait for a resource.  It returns TRUE if the thread can
//  block and FALSE otherwise.  This attribute can then be used to call
//  the FSD & FSP common work routine with the proper wait value.
//

#define CanFsdWait(IRP) ((BOOLEAN)(          \
    IoIsOperationSynchronous(IRP) ||             \
    DfsData.OurProcess == PsGetCurrentProcess())         \
)


//
//  Routine for posting an Irp to the FSP, implemented in fspdisp.c
//

NTSTATUS
DfsFsdPostRequest(
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

//
//  The FSP level dispatch/main routine.  This is the routine that takes
//  IRPs from the work queue and calls the appropriate FSP level work routine.
//

VOID
DfsFspDispatch (                   //  implemented in FspDisp.c
    IN PVOID Context
    );

//
//  The following routines are the FSP work routines that are called
//  by the preceding DfsFsdDispath routine.  Each takes as input a pointer
//  to the IRP, performs the function, and returns.
//
//  Each of the following routines is also responsible for completing the IRP.
//  We moved this responsibility from the main loop to the individual routines
//  to allow them the ability to complete the IRP and continue post processing
//  actions.
//

VOID
DfsFspClose (                   //  implemented in Close.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

VOID
DfsFspQueryInformation (            //  implemented in FileInfo.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

VOID
DfsFspSetInformation (              //  implemented in FileInfo.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

VOID
DfsFspFileSystemControl (           //  implemented in FsCtrl.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

VOID
DfsFspQueryVolumeInformation (          //  implemented in VolInfo.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

VOID
DfsFspSetVolumeInformation (            //  implemented in VolInfo.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );


//
//  The following macro is used by the FSP and FSD routines to complete
//  an IRP.
//
//  Note that this macro allows either the Irp or the IrpContext to be
//  null, however the only legal order to do this in is:
//
//  DfsCompleteRequest( NULL, Irp, Status );     // completes Irp & preserves context
//  ...
//  DfsCompleteRequest( IrpContext, NULL, DontCare ); // deallocates context
//
//  This would typically be done in order to pass a "naked" IrpContext off to the
//  Fsp for post processing, such as read ahead.
//

VOID
DfsCompleteRequest_Real (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN NTSTATUS Status
    );

#define DfsCompleteRequest(IRPCONTEXT,IRP,STATUS) { \
    DfsCompleteRequest_Real(IRPCONTEXT,IRP,STATUS); \
}



//
//  The following two macros are used by the Fsd/Fsp exception handlers to
//  process an exception.  The first macro is the exception filter used in
//  the Fsd/Fsp to decide if an exception should be handled at this level.
//  The second macro decides if the exception is to be finished off by
//  completing the IRP, and cleaning up the Irp Context, or if we should
//  bugcheck.  Exception values such as STATUS_FILE_INVALID (raised by
//  VerfySup.c) cause us to complete the Irp and cleanup, while exceptions
//  such as accvio cause us to bugcheck.
//
//  The basic structure for fsd/fsp exception handling is as follows:
//
//  DfsFsdXxx(...)
//  {
//  try {
//
//      ...
//
//  } except(DfsExceptionFilter("Xxx\n")) {
//
//      DfsProcessException( IrpContext, Irp, &Status );
//  }
//
//  Return Status;
//  }
//
//  LONG
//  DfsExceptionFilter (
//  IN PSZ String
//  );
//
//  VOID
//  DfsProcessException (
//  IN PIRP_CONTEXT IrpContext,
//  IN PIRP Irp,
//  IN PNTSTATUS ExceptionCode
//  );
//

LONG
DfsExceptionFilter (
    IN PIRP_CONTEXT IrpContext,
    IN NTSTATUS ExceptionCode,
    IN PEXCEPTION_POINTERS ExceptionPointer
    );

NTSTATUS
DfsProcessException (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN NTSTATUS ExceptionCode
    );

NTSTATUS
DfsGetLogonId (
    IN PLUID Id
    );

//
//  VOID
//  DfsRaiseStatus (
//  IN PRIP_CONTEXT IrpContext,
//  IN NT_STATUS Status
//  );
//
//

#define DfsRaiseStatus(IRPCONTEXT,STATUS) {    \
    (IRPCONTEXT)->ExceptionStatus = (STATUS); \
    ExRaiseStatus( (STATUS) );            \
    BugCheck( "DfsRaiseStatus "  #STATUS );       \
}


//
//  The following macros are used to establish the semantics needed
//  to do a return from within a try-finally clause.  As a rule every
//  try clause must end with a label call try_exit.  For example,
//
//  try {
//      :
//      :
//
//  try_exit: NOTHING;
//  } finally {
//
//      :
//      :
//  }
//
//  Every return statement executed inside of a try clause should use the
//  try_return macro.  If the compiler fully supports the try-finally construct
//  then the macro should be
//
//  #define try_return(S)  { return(S); }
//
//  If the compiler does not support the try-finally construct then the macro
//  should be
//
//  #define try_return(S)  { S; goto try_exit; }
//

#define try_return(S) { S; goto try_exit; }


#ifdef TERMSRV

NTSTATUS
TSGetRequestorSessionId(
    IN PIRP pIrp,
    OUT PULONG pulSessionId
    );

#endif // TERMSRV

#endif // _DFSPROCS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mup\dnr.c ===
//+-------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:       dnr.c
//
//  Contents:   Distributed name resolution process and control
//
//  Functions:  DnrStartNameResolution -- Start a name resolution
//              DnrNameResolve -- Main loop for DNR
//              DnrComposeFileName -- Canonicalize file name
//              DnrCaptureCredentials -- Capture user-defined creds for Dnr
//              DnrReleaseCredentials -- Dual of DnrCaptureCredentials
//              DnrRedirectFileOpen -- Redirect a create IRP to some provider
//              DnrPostProcessFileOpen -- Resume after return from redirect
//              DnrGetAuthenticatedConnection -- Using Dnr credentials
//              DnrReleaseAuthenticatedConnection -- returned by above func
//              DfsBuildConnectionRequest -- Builds name of server IPC$ share
//              DfsFreeConnectionRequest -- Free resources allocated above
//              DfsCreateConnection -- Create a connection to a server IPC$
//              DfsCloseConnection -- Close connection opened above
//              DnrBuildReferralRequest -- Build Irp for referral request
//              DnrInsertReferralAndResume -- Resume DNR after referral
//              DnrCompleteReferral -- DPC to process a referral response
//              DnrCompleteFileOpen -- DPC to process a file open completion
//              DnrBuildFsControlRequest -- Create an IRP for an Fsctrl
//              AllocateDnrContext -- Allocate a context record for DNR
//              DeallocateDnrContext -- Free context record
//              DnrConcatenateFilePath -- Construct path with backslashes etc
//              DnrLocateDC -- Locate the server for a Dfs root
//
//--------------------------------------------------------------------------


#include "dfsprocs.h"
#include <smbtypes.h>
#include <smbtrans.h>
#include "fsctrl.h"
#include "fcbsup.h"
#include "dnr.h"
#include "creds.h"
#include "know.h"
#include "mupwml.h"

#include <netevent.h>

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_DNR)

//
//  Local function prototypes
//


#define DNR_SET_TARGET_INFO(_DnrC, _Entry)   \
   if (((_DnrC)->pDfsTargetInfo == NULL) && (_Entry != NULL)) {\
      (_DnrC)->pDfsTargetInfo = (_Entry)->pDfsTargetInfo; \
      if ((_DnrC)->pDfsTargetInfo != NULL) {                        \
           PktAcquireTargetInfo( (_DnrC)->pDfsTargetInfo);          \
      }                                                             \
   }                                                             


PDNR_CONTEXT
AllocateDnrContext(
    IN ULONG    cbExtra
);

#define DeallocateDnrContext(pNRC)      ExFreePool(pNRC);

VOID
DnrRebuildDnrContext(
    IN PDNR_CONTEXT DnrContext,
    IN PUNICODE_STRING NewDfsPrefix,
    IN PUNICODE_STRING RemainingPath);

VOID
DnrCaptureCredentials(
    IN PDNR_CONTEXT DnrContext);

VOID
DnrReleaseCredentials(
    IN PDNR_CONTEXT DnrContext);

NTSTATUS
DnrGetAuthenticatedConnection(
    IN OUT PDNR_CONTEXT DnrContext);

VOID
DnrReleaseAuthenticatedConnection(
    IN OUT PDNR_CONTEXT DnrContext);

NTSTATUS
DfsBuildConnectionRequest(
    IN PDFS_SERVICE pService,
    IN PPROVIDER_DEF pProvider,
    OUT PUNICODE_STRING pShareName);

VOID
DfsFreeConnectionRequest(
    IN OUT PUNICODE_STRING pShareName);

NTSTATUS
DnrRedirectFileOpen (
    IN    PDNR_CONTEXT DnrContext
);

NTSTATUS
DnrPostProcessFileOpen(
    IN    PDNR_CONTEXT DnrContext
);

VOID
DnrInsertReferralAndResume(
    IN    PVOID Context);

VOID
DnrLocateDC(
    IN PUNICODE_STRING FileName);

NTSTATUS
DnrCompleteReferral(
    IN PDEVICE_OBJECT pDevice,
    IN PIRP Irp,
    IN PVOID Context
);

NTSTATUS
DnrCompleteFileOpen(
    IN PDEVICE_OBJECT pDevice,
    IN PIRP Irp,
    IN PVOID Context
);

PIRP
DnrBuildReferralRequest(
    IN PDNR_CONTEXT pDnrContext
);

VOID
PktFlushChildren(
    PDFS_PKT_ENTRY pEntry
);


VOID
MupInvalidatePrefixTable(
   VOID			 
);
NTSTATUS
DnrGetTargetInfo( 
    PDNR_CONTEXT pDnrContext);

#define DFS_REFERENCE_OBJECT(d) \
    ObReferenceObjectByPointer(d,0,NULL,KernelMode);

#define DFS_DEREFERENCE_OBJECT(d) \
    ObDereferenceObject((PVOID)(d));

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, DnrStartNameResolution )
#pragma alloc_text( PAGE, DnrNameResolve )
#pragma alloc_text( PAGE, DnrComposeFileName )
#pragma alloc_text( PAGE, DnrCaptureCredentials )
#pragma alloc_text( PAGE, DnrReleaseCredentials )
#pragma alloc_text( PAGE, DnrGetAuthenticatedConnection )
#pragma alloc_text( PAGE, DnrReleaseAuthenticatedConnection )
#pragma alloc_text( PAGE, DnrRedirectFileOpen )
#pragma alloc_text( PAGE, DnrPostProcessFileOpen )
#pragma alloc_text( PAGE, DfsBuildConnectionRequest )
#pragma alloc_text( PAGE, DfsFreeConnectionRequest )
#pragma alloc_text( PAGE, DnrBuildReferralRequest )
#pragma alloc_text( PAGE, DfsCreateConnection )
#pragma alloc_text( PAGE, DfsCloseConnection )
#pragma alloc_text( PAGE, DnrBuildFsControlRequest )
#pragma alloc_text( PAGE, DnrInsertReferralAndResume )
#pragma alloc_text( PAGE, DnrLocateDC )
#pragma alloc_text( PAGE, AllocateDnrContext )
#pragma alloc_text( PAGE, DnrRebuildDnrContext )
#pragma alloc_text( PAGE, DnrConcatenateFilePath )
#pragma alloc_text( PAGE, DfspGetOfflineEntry)
#pragma alloc_text( PAGE, DfspMarkServerOnline)
#pragma alloc_text( PAGE, DfspMarkServerOffline)
#pragma alloc_text( PAGE, DfspIsRootOnline)

//
// The following are not pageable since they can be called at DPC level
//
// DnrCompleteReferral
// DnrCompleteFileOpen
//

#endif

//+-------------------------------------------------------------------
//
//  Function:   DfsIsShareNull
//
//  Synopsis:   Is this name of the form "\server\"?
//
//  Arguments:  [FileName] - pointer to the UNICODE_STRING we are checking
//
//  Returns:    TRUE if FileName is "\server\", FALSE otherwise
//
//--------------------------------------------------------------------

BOOLEAN
DfsIsShareNull(PUNICODE_STRING FileName)
{
    USHORT RootEnd = 0;
    USHORT ShareEnd = 0;
    BOOLEAN result = FALSE;
    USHORT Length = 0;
    

    // find the first '\' 
    // we start at 1 because the first character is also '\'
    for (RootEnd = 1;
	    RootEnd < FileName->Length/sizeof(WCHAR) &&
		FileName->Buffer[RootEnd] != UNICODE_PATH_SEP;
		    RootEnd++) {

	NOTHING;

    }

    // now FileName->Buffer[RootEnd] == '\' and we are beyond the root part of the name
    // find the end of the share part.
    for (ShareEnd = RootEnd+1;
	    ShareEnd < FileName->Length/sizeof(WCHAR) &&
		FileName->Buffer[ShareEnd] != UNICODE_PATH_SEP;
			ShareEnd++) {

	 NOTHING;

    }

    // the length of the share name is ShareEnd - RootEnd - 1
    // the -1 is becasue we have actually stepped one char beyond the 
    // share name's end
    // For example: 	\root\share\link	RootEnd=5, ShareEnd=11
    //			\root\share             RootEnd=5, ShareEnd=11
    //			\root\			RootEnd=5, ShareEnd=6
    Length = (USHORT) (ShareEnd - RootEnd - 1) * sizeof(WCHAR);

    if(Length == 0) {
	result = TRUE;
    } else {
	result = FALSE;
    }

    return result;
}



NTSTATUS
DfsRerouteOpenToMup(
    IN PFILE_OBJECT FileObject,
    IN PUNICODE_STRING FileName)
{

    UNICODE_STRING NewName;
    ULONG nameLength;
    NTSTATUS status;

    nameLength = sizeof(DD_MUP_DEVICE_NAME ) + FileName->Length + sizeof(WCHAR);
    if (nameLength > MAXUSHORT) {
        status = STATUS_NAME_TOO_LONG;
        MUP_TRACE_HIGH(ERROR, DfsRerouteOpenToMup_Error_NameTooLong, 
                       LOGSTATUS(status)
                       LOGPTR(FileObject));
        return status;
    }

    NewName.Buffer = ExAllocatePoolWithTag(
                         PagedPool,
                         nameLength,			  
                         ' puM');

    if ( NewName.Buffer ==  NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    NewName.MaximumLength = (USHORT)nameLength;
    NewName.Length = 0;

    RtlAppendUnicodeToString(&NewName, DD_MUP_DEVICE_NAME);
    RtlAppendUnicodeStringToString(&NewName, FileName);

    if (MupVerbose) {
      DbgPrint("Newname %wZ\n", &NewName);
    }

    ExFreePool(FileObject->FileName.Buffer);
    FileObject->FileName = NewName;

    return STATUS_REPARSE;
}
    




//  The name resolution process operates as a state machine in
//  which the current step in the process is indicated by a state
//  variable, and responses to requests from the network will
//  transition the process to other states, from which actions
//  are taken.
//
//  When a user request needs further processing, an IRP is
//  dispatched with a Completion Routine that will
//  pick up processing when the sub-request is completed.  The
//  completion routine will adjust the name resolution state and restart the
//  main loop of the state machine.
//
//  The following state/action table describes the actions of
//  the procedures which implement the state machine:
//
//      Current         Condition/                      Next
//       State            Action                        State
//      -------         ----------                      -----
//
//      Enter           Acquire Pkt, canonicalize file  LocalCompletion
//                      name, optimistic allocation of
//                      FCB fails/
//                      No action
//
//      Enter           Acquire Pkt, canonicalize file  Start
//                      name, allocated FCB/
//                      Capture Credentials to use
//
//      Start           Got a referral, new pkt entry   GetFirstReplica
//                      is already in DnrContext and
//                      pkt entry is not inter-dfs/
//                      Capture USN of pkt entry
//
//      Start           lookup in PKT returns match     GetFirstReplica
//                      and pkt entry is not inter-dfs/
//                      Capture USN of pkt entry
//
//      Start           pkt entry from referral or      Start
//                      lookup is inter-dfs/
//                      Change file name in DnrContext
//                      to name in new Dfs, rebuild
//                      DnrContext
//
//      Start           lookup in PKT, no match/        GetFirstDC
//                      No action
//
//      GetFirstReplica Find First replica fails and    Done
//                      we have already got a referral/
//                      Set final status to
//                      NO_SUCH_DEVICE (must be
//                      because we don't have an
//                      appropriate redirector)
//
//      GetFirstReplica Find First replica fails and    GetFirstDC
//                      we haven't yet got a referral/
//                      locate first DC to send
//                      referral request to.
//
//      GetFirstReplica Replica found has no address,   GetFirstDC
//                      means a domain-based Dfs with
//                      no DCs/
//                      No action
//
//      GetFirstReplica Replica found with valid        SendRequest
//                      address/
//                      Capture provider info under
//                      lock protection, Reference
//                      provider's device object,
//
//      SendRequest     Supplied credentials, and tree  Done
//                      connect using creds fails/
//                      Set final status, dereference
//                      provider's device object
//
//      SendRequest     Allocate pool for new name/     PostProcessOpen
//                      Change file name into one that
//                      the provider can parse, pass
//                      the Create request to the
//                      provider, Derefence provider's
//                      device object when provider
//                      completes the request.
//
//      SendRequest     Pool Allocation fails/          Done
//                      Set final status, dereference
//                      provider's device object
//
//      PostProcessOpen Underlying FS returned REPARSE, SendRequest
//                      successfully created or found a
//                      provider for the target redir/
//                      Capture provider information
//                      under lock protection,
//                      Reference providers Device obj.
//
//      PostProcessOpen Underlying FS returned SUCCESS/ Done
//                      Insert optimistically allocated
//                      FCB into Fcb table, set final
//                      status
//
//      PostProcessOpen Open failed with                GetFirstDC
//                      PATH_NOT_COVERED or
//                      DFS_EXIT_POINT_FOUND, and
//                      we haven't yet gotten a
//                      referral/
//                      No action
//
//      PostProcessOpen Open failed with                Start
//                      OBJECT_TYPE_MISMATCH (ie,
//                      downlevel open found an
//                      interdfs link)/Change
//                      name in DnrContext to name
//                      in new Dfs, rebuild DnrContext
//
//      PostProcessOpen Open failed with                GetFirstReplica
//                      PATH_NOT_COVERED or
//                      DFS_EXIT_POINT_FOUND, and we
//                      already got a referral, and
//                      we have never reported an
//                      inconsistency/
//                      Report inconsistency
//
//      PostProcessOpen Same as above, but we already   GetNextReplica
//                      reported the inconsistency/
//                      Report the inconsistency
//
//      PostProcessOpen Open failed with network error/ GetNextReplica
//                      No action
//
//      PostProcessOpen Open failed with non-network    Done
//                      error/
//                      Set final status
//
//      GetNextReplica  No more replicas and haven't    GetFirstDC
//                      gotten a referral yet/
//                      no action
//
//      GetNextReplica  No more replicas and got a      Done
//                      referral/
//                      no action
//
//      GetNextReplica  Replica found/                  SendRequest
//                      Capture provider information
//                      under lock protection,
//                      Reference provider Device obj
//
//      GetFirstDC      Lookup referral entry not       Done
//                      found or has no services, and
//                      we have already called DC
//                      Locator once/
//                      Set final status to
//                      CANT_ACCESS_DOMAIN_INFO
//
//      GetFirstDC      Lookup referral entry returned  Done
//                      valid entry, but can't find a
//                      provider for it/
//                      Set final status to
//                      CANT_ACCESS_DOMAIN_INFO
//
//      GetFirstDC      Lookup referral entry returned  GetReferrals
//                      valid entry, and found
//                      provider/
//                      Set DnrContext->pPktEntry to
//                      DC's entry, Capture provider
//                      info under lock protection,
//                      Reference provider's Device obj
//
//      GetReferrals    Unable to open DC's IPC$ share/ GetNextDC
//                      Dereference provider's device
//                      object
//
//      GetReferrals    Opened DC's IPC$ share, but     Done
//                      unable to build referral
//                      request Irp/
//                      Dereference provider's device,
//                      Set final status to
//                      INSUFFICIENT_RESOURCES
//
//      GetReferrals    Opened DC's IPC$ share and      CompleteReferral
//                      built referral request/
//                      Release Pkt, Send referral
//                      request
//
//      GetNextDC       Successfully found another      GetReferrals
//                      DC/
//                      Capture provider info under
//                      lock protection, Reference
//                      provider's Device object
//
//      GetNextDC       Can't find another DC/          Done
//                      Set final status to
//                      CANT_ACCESS_DOMAIN_INFO
//
//      Done            Complete create Irp with
//                      DnrContext->FinalStatus
//
//      LocalCompletion Complete create Irp with
//                      local status.
//
//      CompleteReferral Referral returned with         GetReferrals
//                      BUFFER_OVERFLOW/
//                      Set referral size to
//                      indicated amount
//
//      CompleteReferral Referral returned, but         Done
//                      error in creating entry/
//                      Dereference provider's
//                      device, set final status to
//                      result of creating entry
//
//      CompleteReferral Referral returned and          GetFirstDC
//                      successfully created entry,
//                      entry is inter-dfs/
//                      Dereference provider's device,
//                      Reset ReferralSize
//
//      CompleteReferral Same as above, but entry       Start
//                      is storage entry/
//                      Dereference provider's device,
//                      Adjust DnrContext->
//                      RemainingPart to correspond
//                      to the new entry
//
//      CompleteReferral Referral request failed with   GetNextDC
//                      some network error/
//                      Dereference Provider's device
//
//      CompleteReferral Referral request failed with   Done
//                      some non-network error/
//                      Dereference provider's Device,
//                      Set final status to this error
//


//+-------------------------------------------------------------------------
//
//  Function:   DnrStartNameResolution - Start a distributed name resolution
//
//  Synopsis:   DnrStartNameResolution starts the name resolution process
//              for a request (typically an NtCreateFile).
//
//  Effects:    Could change the state of the PKT or individual
//              PKT entries.
//
//  Arguments:  [IrpContext] - pointer to a IRP_CONTEXT structure for the
//                      current request.
//              [Irp] - IRP being processed.
//              [Vcb] - Vcb of logical root.
//
//  Returns:    NTSTATUS - Status to be returned to the I/O subsystem.
//
//  Notes:
//
//--------------------------------------------------------------------------


NTSTATUS
DnrStartNameResolution(
    IN    PIRP_CONTEXT IrpContext,
    IN    PIRP  Irp,
    IN    PDFS_VCB  Vcb
) {
    PDNR_CONTEXT        DnrContext;
    NTSTATUS            Status;
    PIO_STACK_LOCATION  IrpSp = IoGetCurrentIrpStackLocation(Irp);
    PFILE_OBJECT        FileObject = IrpSp->FileObject;
    PUNICODE_STRING     LogRootPrefix = &Vcb->LogRootPrefix;
    ULONG               CreateOptions;
    USHORT              cbFileName;
    SECURITY_QUALITY_OF_SERVICE sqos;
    ULONG               cbFileNameLong;

    MUP_TRACE_NORM(TRACE_IRP, DnrStartNameResolution_Entry,
		   LOGPTR(Irp)
		   LOGPTR(Vcb)
		   LOGPTR(FileObject)
		   LOGUSTR(FileObject->FileName)
		   LOGUSTR(*LogRootPrefix));

    cbFileNameLong =    FileObject->FileName.Length +
                         sizeof(UNICODE_PATH_SEP) +
                        LogRootPrefix->Length +
                         sizeof(UNICODE_NULL);

    cbFileName = (USHORT)cbFileNameLong;

    if( cbFileName != cbFileNameLong ) {
        //
        // The resulting name is too long -- we cannot deal with it
        //
        Status = STATUS_OBJECT_NAME_INVALID;
        DfsCompleteRequest(IrpContext, Irp, Status);
        DfsDbgTrace(0, Dbg, "DnrStartNameResolution:  Exit ->%x\n", ULongToPtr(Status));
        MUP_TRACE_HIGH(ERROR, DnrStartNameResolution_Error_NameTooLong,
                       LOGSTATUS(Status)
                       LOGPTR(FileObject)
                       LOGPTR(Irp));
        return Status;
    }

    //
    // Allocate the DnrContext used to resolve the name. We optimize
    // allocation by allocating room for the FileName at the end of the
    // DnrContext.
    //

    DnrContext = AllocateDnrContext(cbFileName);

    if (DnrContext == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        DfsCompleteRequest(IrpContext, Irp, Status);
        DfsDbgTrace(0, Dbg, "DnrStartNameResolution:  Exit ->%x\n", ULongToPtr(Status));
        MUP_TRACE_HIGH(ERROR, DnrStartNameResolution_Error2,
                       LOGSTATUS(Status)
                       LOGPTR(FileObject)
                       LOGPTR(Irp));
        return Status;
    }

    DnrContext->FileName.Length = 0;
    DnrContext->FileName.MaximumLength = cbFileName;
    DnrContext->FileName.Buffer = (PWCHAR) ( (PBYTE) DnrContext + sizeof(DNR_CONTEXT) );

    //
    // Since FileName.Buffer has not been separately allocated, we set this
    // to FALSE.
    //

    DnrContext->NameAllocated = FALSE;

    //
    // Capture the user's security token so we can later impersonate if
    // needed.
    //

    sqos.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    sqos.ImpersonationLevel = SecurityImpersonation;
    sqos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    sqos.EffectiveOnly = FALSE;

    Status = SeCreateClientSecurity(
                Irp->Tail.Overlay.Thread,
                &sqos,
                FALSE,                           // Remote Session
                &DnrContext->SecurityContext);   // Return context.

    MUP_TRACE_ERROR_HIGH(Status, ALL_ERROR, DnrStartNameResolution_Error_SeCreateClientSecurity,
                         LOGSTATUS(Status)
                         LOGPTR(FileObject)
                         LOGPTR(Irp)
			 LOGUSTR(FileObject->FileName));
    if (!NT_SUCCESS(Status)) {
        DeallocateDnrContext( DnrContext );
        DfsCompleteRequest(IrpContext, Irp, Status);
        DfsDbgTrace(0, Dbg, "DnrStartNameResolution:  Exit ->%x\n", ULongToPtr(Status));
        return( Status );
    }

    DnrContext->Impersonate = FALSE;

    ASSERT(NT_SUCCESS(Status));

    //
    // Initialize the rest of the DnrContext
    //

    DnrContext->AuthConn = NULL;
    DnrContext->OriginalIrp = Irp;
    DnrContext->pIrpContext = IrpContext;
    DnrContext->Credentials = NULL;
    DnrContext->FinalStatus = STATUS_SUCCESS;
    DnrContext->FcbToUse = NULL;
    DnrContext->Vcb = Vcb;
    DnrContext->State = DnrStateEnter;
    DnrContext->Attempts = 0;
    DnrContext->DnrActive = FALSE;
    DnrContext->ReleasePkt = FALSE;
    DnrContext->GotReferral = FALSE;
    DnrContext->FoundInconsistency = FALSE;
    DnrContext->CalledDCLocator = FALSE;
    DnrContext->CachedConnFile = FALSE;
    DnrContext->ReferralSize = MAX_REFERRAL_LENGTH;
    KeQuerySystemTime(&DnrContext->StartTime);


    CreateOptions = IrpSp->Parameters.Create.Options;

    //
    // ... and resolve the name
    //

    return DnrNameResolve(DnrContext);
}

//+-------------------------------------------------------------------------
//
//  Function:   DnrNameResolve - Main loop for DNR
//
//  Synopsis:   DnrNameResolve drives the name resolution process
//              for a request (typically an NtCreateFile).
//
//  Effects:    Could change the state of the PKT or individual
//              PKT entries.
//
//  Arguments:  [DnrContext] - pointer to a DNR_CONTEXT structure which
//                      records the state of the DNR.
//
//  Returns:    NTSTATUS - Status to be returned to the I/O subsystem.
//
//  Notes:
//
//--------------------------------------------------------------------------


NTSTATUS
DnrNameResolve(
    IN    PDNR_CONTEXT DnrContext
) {
    PIO_STACK_LOCATION IrpSp;
    NTSTATUS Status = STATUS_SUCCESS;
    PDFS_VCB Vcb;
    PIRP Irp;
    BOOLEAN LastEntry;
    PDFS_PKT_ENTRY shortPfxMatch;
    UNICODE_STRING shortRemainingPart;
    LARGE_INTEGER EndTime;
    PFILE_OBJECT FileObject;


    DfsDbgTrace(+1, Dbg, "DnrNameResolve: Entered\n", 0);

    ASSERT( !DnrContext->DnrActive && "Recursive call to Dnr!\n");


    DnrContext->DnrActive = TRUE;

    //
    // If we need to impersonate the original caller, do so before doing
    // anything else.
    //


    Irp = DnrContext->OriginalIrp;
    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    FileObject = IrpSp->FileObject;
    Vcb = DnrContext->Vcb;

    if (DnrContext->Impersonate) {

        Status = SeImpersonateClientEx(
                    &DnrContext->SecurityContext,
                    (PETHREAD) NULL);
        MUP_TRACE_ERROR_HIGH(Status, ALL_ERROR, DnrNameResolve_Error_SeImpersonateClientEx,
                             LOGSTATUS(Status)
                             LOGPTR(FileObject));

        if (!NT_SUCCESS(Status)) {

            DnrContext->DnrActive = FALSE;
            DnrContext->State = DnrStateLocalCompletion;
            DfsDbgTrace(0, Dbg,
                "DnrNameResolve quitting due to SeImpersonateClientEx returning 0x%x\n", ULongToPtr(Status));

        }

    }


    //
    //  Drive the name resolution process as far as possible before
    //  it is necessary to wait for an I/O completion.
    //

    while (1) {
        PDFS_PKT_ENTRY pktEntry = NULL;
        PFILE_OBJECT FileObject = IrpSp->FileObject;

        if (DnrContext->State == DnrStateGetFirstReplica ||
            DnrContext->State == DnrStateGetFirstDC) {
            if (++DnrContext->Attempts > MAX_DNR_ATTEMPTS) {
                Status = STATUS_BAD_NETWORK_PATH;
                DnrContext->State = DnrStateLocalCompletion;
                DfsDbgTrace(0, 0,
                    "DFS: DnrNameResolve quitting due to MAX_DNR_ATTEMPTS %d\n",
                    UIntToPtr(DnrContext->Attempts));
            }
        }

        if (DnrContext->State == DnrStateStart)
        {
            if (DnrContext->Attempts > MAX_DNR_ATTEMPTS)
            {
                Status = STATUS_BAD_NETWORK_PATH;
                DnrContext->State = DnrStateLocalCompletion;
            }
        }

	MUP_TRACE_LOW(DNR, DnrNameResolve_TopOfLoop, 
		      LOGUSTR(FileObject->FileName)
		      LOGULONG(DnrContext->State)
		      );
        switch (DnrContext->State) {

        case DnrStateEnter:
#if DBG
            if (MupVerbose) {
                KeQuerySystemTime(&EndTime);
                DbgPrint("[%d] FSM state DnrStateEnter\n",
                    (ULONG)((EndTime.QuadPart - DnrContext->StartTime.QuadPart)/(10 * 1000)));
            }
#endif

            ASSERT(DnrContext->ReleasePkt == FALSE);

            PktAcquireShared( TRUE, &DnrContext->ReleasePkt );

            //
            // We need to construct the fully qualified file name given the
            // logical root and the input file name relative to that root.
            // DnrComposeFileName will allocate memory to hold a string that
            // is the concatenation of the name of the logical root wrt org
            // and the file name.
            //
            //

            ASSERT((FileObject->FileName.Length & 0x1) == 0);

            DnrComposeFileName(
                &DnrContext->FileName,
                DnrContext->Vcb,
                FileObject->RelatedFileObject,
                &FileObject->FileName);

	    DnrContext->ContextFileName = DnrContext->FileName;

            DfsDbgTrace(0, Dbg,
                "DnrComposeFileName -> %wZ\n", &FileObject->FileName);


	    if(DfsIsShareNull(&DnrContext->FileName)) {
		//
		// It doesn't make sense for us to have a name in the form
		// "\server\" or "\domain\" so we reject it. If we didn't reject these
		// names we would wind up bugchecking when processing the 
		// referral with a NULL sharename.
		//
		Status = STATUS_INVALID_PARAMETER;
		DnrContext->State = DnrStateLocalCompletion;
                break;
	    }

	    Status = DfspIsRootOnline(&DnrContext->FileName,
                            (BOOLEAN)
                                ((DnrContext->Vcb->VcbState & VCB_STATE_CSCAGENT_VOLUME) != 0));
            if (!NT_SUCCESS(Status)) {
     	        DnrContext->State = DnrStateLocalCompletion;
                break;
	    }
#if DBG
            if (MupVerbose)
                DbgPrint("  DnrContext->FileName=(%wZ)\n", &DnrContext->FileName);
#endif

            //
            // Allocate an FCB now for use if the DNR succeeds. We must, do
            // this, or we won't know how what to do if the underlying FS
            // opens the file and then we are unable to allocate the FCB.
            //

            ASSERT(DnrContext->FcbToUse == NULL);

            DnrContext->FcbToUse =  DfsCreateFcb(
                                        NULL,
                                        DnrContext->Vcb,
                                        &DnrContext->ContextFileName);

            if (DnrContext->FcbToUse == NULL) {
                DfsDbgTrace(0, Dbg, "Could not create FCB!\n", 0);
                Status = STATUS_INSUFFICIENT_RESOURCES;
                DnrContext->State = DnrStateLocalCompletion;
                break;
            }

	    DnrContext->FcbToUse->FileObject = FileObject;
	    
	    DfsSetFileObject(FileObject, 
			     RedirectedFileOpen, 
			     DnrContext->FcbToUse);


            DnrCaptureCredentials(DnrContext);

            DnrContext->State = DnrStateStart;

            //
            // Fall through
            //

        case DnrStateStart:
            DfsDbgTrace(0, Dbg, "FSM state Start\n", 0);
#if DBG
            if (MupVerbose) {
                KeQuerySystemTime(&EndTime);
                DbgPrint("[%d] FSM state DnrStateStart\n",
                    (ULONG)((EndTime.QuadPart - DnrContext->StartTime.QuadPart)/(10 * 1000)));
                DbgPrint("  DnrContext->FileName=(%wZ)\n", &DnrContext->FileName);
            }
#endif

            ASSERT( PKT_LOCKED_FOR_SHARED_ACCESS() );

            //
            // Try to match the filename with the best
            // PktEntry we have.
            //

            //
            // Do the match in the full prefix table
            //

            pktEntry = PktLookupEntryByPrefix(&DfsData.Pkt,
                                            &DnrContext->FileName,
                                            &DnrContext->RemainingPart);


            //
            // Then do a match in the short prefix table
            //

            shortPfxMatch = PktLookupEntryByShortPrefix(
                                &DfsData.Pkt,
                                &DnrContext->FileName,
                                &shortRemainingPart);

            if (shortPfxMatch != NULL) {

                if (pktEntry == NULL) {

                    pktEntry = shortPfxMatch;

                    DnrContext->RemainingPart = shortRemainingPart;

                } else if (shortPfxMatch->Id.Prefix.Length >
                            pktEntry->Id.Prefix.Length) {

                    pktEntry = shortPfxMatch;

                    DnrContext->RemainingPart = shortRemainingPart;

                }

            }

            //
            // If the entry found is stale and this is our first attempt at dnr,
            // force another referral request.
            //

            if (DnrContext->Attempts == 0 && pktEntry != NULL && pktEntry->ExpireTime <= 0) {
#if DBG
                if (MupVerbose)
                    DbgPrint("  pktEntry [%wZ] is stale - force getting another\n",
                                    &pktEntry->Id.Prefix);
#endif
                DnrContext->pPktEntry = pktEntry;

                DnrContext->State = DnrStateGetFirstDC;
                //
                // Now break out so we restart Dnr and get a referral
                //
                break;

            }


            if (pktEntry == NULL) {

                PUNICODE_STRING filePath = &DnrContext->FileName;
                UNICODE_STRING dfsRootName;
                UNICODE_STRING shareName;
                NTSTATUS status;
                PDFS_SPECIAL_ENTRY pSpecialEntry;
                ULONG i, j;

                for (i = 1;
                        i < filePath->Length/sizeof(WCHAR) &&
                            filePath->Buffer[i] != UNICODE_PATH_SEP;
                                i++) {

                    NOTHING;

                }

                dfsRootName.Length = (USHORT) ((i-1) * sizeof(WCHAR));
                dfsRootName.MaximumLength = dfsRootName.Length;
                dfsRootName.Buffer = &filePath->Buffer[1];

                for (j = i+1;
                        j < filePath->Length/sizeof(WCHAR) &&
                            filePath->Buffer[j] != UNICODE_PATH_SEP;
                                    j++) {

                     NOTHING;

                }

                shareName.Length = (USHORT) (j - i - 1) * sizeof(WCHAR);
                shareName.MaximumLength = shareName.Length;
                shareName.Buffer = &filePath->Buffer[i+1];

                PktRelease();
                DnrContext->ReleasePkt = FALSE;

                status = PktExpandSpecialName(
                                    &dfsRootName,
                                    &pSpecialEntry);

                PktAcquireShared( TRUE, &DnrContext->ReleasePkt );

                if (NT_SUCCESS(status)) {

                    ULONG Len;

                    if ((j+1) < filePath->Length/sizeof(WCHAR)) {

                        Len = filePath->Length - ((j+1) * sizeof(WCHAR));

                        DnrContext->RemainingPart.Buffer = &filePath->Buffer[j+1];
                        DnrContext->RemainingPart.Length = (USHORT) Len;
                        DnrContext->RemainingPart.MaximumLength = (USHORT) Len;

                    } else {

                        DnrContext->RemainingPart.Buffer = NULL;
                        DnrContext->RemainingPart.Length = 0;
                        DnrContext->RemainingPart.MaximumLength = 0;

                    }

                    status = PktEntryFromSpecialEntry(
                                    pSpecialEntry,
                                    &shareName,
                                    &pktEntry);

                    InterlockedDecrement(&pSpecialEntry->UseCount);

                }

            }



#if 0

            if (pktEntry != NULL) {

                pktEntry->ExpireTime = pktEntry->TimeToLive;

            }

#endif

            DfsDbgTrace(0, Dbg, "DnrNameResolve: found pktEntry %08lx\n",
                                        pktEntry);

            DNR_SET_TARGET_INFO( DnrContext, pktEntry );

            if (pktEntry == NULL) {

                //
                // We didn't find any entry. We set pPktEntry to NULL so that
                // in GetFirstDC, the call to PktLookupReferralEntry will
                // return the right thing (ie, will give use the highest DC we
                // know about).
                //

                DnrContext->pPktEntry = NULL;
                DnrContext->State = DnrStateGetFirstDC;

            } else if (pktEntry->Type & PKT_ENTRY_TYPE_OUTSIDE_MY_DOM) {

                DnrRebuildDnrContext(
                    DnrContext,
                    &pktEntry->Info.ServiceList[0].Address,
                    &DnrContext->RemainingPart);


                //
                // The DnrContext has been rebuilt and programmed to
                // "restart" DNR. So, we'll just break out of the state
                // machine and reenter it with the reconstructed context
                //

            } else {

                ASSERT(pktEntry != NULL);

                DnrContext->pPktEntry = pktEntry;
                DnrContext->USN = pktEntry->USN;
                DnrContext->State = DnrStateGetFirstReplica;

            }
            break;

        case DnrStateGetFirstReplica:
            DfsDbgTrace(0, Dbg, "FSM state GetFirstReplica\n", 0);
#if DBG
            if (MupVerbose) {
                KeQuerySystemTime(&EndTime);
                DbgPrint("[%d] FSM state DnrStateGetFirstReplica\n",
                    (EndTime.QuadPart - DnrContext->StartTime.QuadPart)/(10 * 1000));
            }
#endif

            ASSERT(DnrContext->ReleasePkt == TRUE);

            ExAcquireResourceExclusiveLite(&DfsData.Resource, TRUE);

            Status = ReplFindFirstProvider(DnrContext->pPktEntry,
                                           NULL,
                                           NULL,
                                           &DnrContext->pService,
                                           &DnrContext->RSelectContext,
                                           &LastEntry);

            if (! NT_SUCCESS(Status)) {

                ULONG PktType = DnrContext->pPktEntry->Type;

                ExReleaseResourceLite(&DfsData.Resource);

                DfsDbgTrace(0, Dbg, "No provider found %08lx\n", ULongToPtr(Status));

                if (DnrContext->GotReferral ||
                    (PktType & PKT_ENTRY_TYPE_SYSVOL) != 0 ||
                    DnrContext->GotReparse == TRUE
                ) {
                    DnrContext->FinalStatus = STATUS_NO_SUCH_DEVICE;
                    DnrContext->State = DnrStateDone;
                    break;
                } else {
                    DnrContext->State = DnrStateGetFirstDC;
                    break;
                }

            } else if (DnrContext->pService->Address.Length == 0) {

                ExReleaseResourceLite(&DfsData.Resource);

                DfsDbgTrace(0, Dbg, "Service with no address, going for referral\n", 0);

                DnrContext->State = DnrStateGetFirstDC;
                break;

            } else {

                ASSERT(DnrContext->pService != NULL);
                ASSERT(DnrContext->pService->pProvider != NULL);

#if DBG
                if (MupVerbose)
                    DbgPrint("  Alternate Name=[%wZ] Address=[%wZ]\n",
                        &DnrContext->pService->Name,
                        &DnrContext->pService->Address);
#endif

                DnrContext->pProvider = DnrContext->pService->pProvider;
                DnrContext->ProviderId = DnrContext->pProvider->eProviderId;
                DnrContext->TargetDevice = DnrContext->pProvider->DeviceObject;
                DFS_REFERENCE_OBJECT(DnrContext->TargetDevice);

                if (LastEntry == TRUE) {
                    DnrContext->DfsNameContext.Flags |= DFS_FLAG_LAST_ALTERNATE;
                } else {
                    DnrContext->DfsNameContext.Flags &= ~DFS_FLAG_LAST_ALTERNATE;
                }

                ExReleaseResourceLite(&DfsData.Resource);

                DnrContext->State = DnrStateSendRequest;
            }
            // FALL THROUGH ...

        case DnrStateSendRequest:
#if DBG
            if (MupVerbose) {
                KeQuerySystemTime(&EndTime);
                DbgPrint("[%d] FSM state DnrStateSendRequest\n",
                    (ULONG)((EndTime.QuadPart - DnrContext->StartTime.QuadPart)/(10 * 1000)));
            }
#endif

            DfsDbgTrace(0, Dbg, "FSM state SendRequest\n", 0);

            ASSERT(DnrContext->ReleasePkt == TRUE);

            ASSERT(DnrContext->pService != NULL);
            ASSERT(DnrContext->pProvider != NULL);
            ASSERT(DnrContext->TargetDevice != NULL);

            //
            // First of all, check to see if the volume is offline
            //

            if (DnrContext->pService->Type & DFS_SERVICE_TYPE_OFFLINE) {

                DFS_DEREFERENCE_OBJECT(DnrContext->TargetDevice);
                DnrContext->FinalStatus = STATUS_DEVICE_OFF_LINE;
                DnrContext->State = DnrStateDone;
                DfsDbgTrace(-1, Dbg, "DnrNameResolve: Device Offline\n",0);
                Status = STATUS_DEVICE_OFF_LINE;
                MUP_TRACE_HIGH(ERROR, DnrNameResolve_Error3,
                               LOGSTATUS(Status)
                               LOGPTR(FileObject));
                break;
            }

            //
            // Next, try to make an authenticated connection to the server, if needed
            //
            // The pkt lock may be dropped in this call, so keep the pkt entry from going
            // away.
            //

            InterlockedIncrement(&DnrContext->pPktEntry->UseCount);


            PktRelease();
            DnrContext->ReleasePkt = FALSE;

            Status = DnrGetAuthenticatedConnection( DnrContext );

            PktAcquireShared( TRUE, &DnrContext->ReleasePkt );

            InterlockedDecrement(&DnrContext->pPktEntry->UseCount);

            if (!NT_SUCCESS(Status)) {

                DFS_DEREFERENCE_OBJECT(DnrContext->TargetDevice);
                DnrContext->FinalStatus = Status;

                //
                // If the error is such that we need to try another replica,
                // do so here.
                //

                if (ReplIsRecoverableError(Status)) {
                     DnrContext->State = DnrStateGetNextReplica;
                }
                else {
                     DnrContext->State = DnrStateDone;
                }

                DfsDbgTrace(-1, Dbg,
                  "DnrNameResolve: Unable to get connection %08lx\n", ULongToPtr(Status));

                break;
            }

            if (DnrContext->USN != DnrContext->pPktEntry->USN) {

                //
                // Dang, Pkt Entry changed when we made the
                // connection. We'll have to retry.
                //
                DFS_DEREFERENCE_OBJECT(DnrContext->TargetDevice);
                DnrReleaseAuthenticatedConnection(DnrContext);
                DnrContext->State = DnrStateStart;
                DfsDbgTrace(-1, Dbg, "DnrNameResolve: USN delta - restarting DNR\n", 0);
                break;

            }

            Status = DnrRedirectFileOpen(DnrContext);

            if (Status == STATUS_PENDING) {
                return(Status);
            }
            break;

        case DnrStatePostProcessOpen:
            DfsDbgTrace(0, Dbg, "FSM state PostProcessOpen\n", 0);
#if DBG
            if (MupVerbose) {
                KeQuerySystemTime(&EndTime);
                DbgPrint("[%d] FSM state DnrStatePostProcessOpen\n",
                    (ULONG)((EndTime.QuadPart - DnrContext->StartTime.QuadPart)/(10 * 1000)));
            }
#endif

            //
            // We come to this state only after sending an open request over
            // the net. We should never hold the Pkt while going over the net.
            // Hence the sense of the assert below.
            //

            ASSERT(DnrContext->ReleasePkt == FALSE);

            Status = DnrPostProcessFileOpen(DnrContext);
            pktEntry = DnrContext->pPktEntry;
            break;

        case DnrStateGetNextReplica:
            DfsDbgTrace(0, Dbg, "FSM state GetNextReplica\n", 0);
#if DBG
            if (MupVerbose) {
                KeQuerySystemTime(&EndTime);
                DbgPrint("[%d] FSM state DnrGetNextReplica\n",
                    (ULONG)((EndTime.QuadPart - DnrContext->StartTime.QuadPart)/(10 * 1000)));
            }
#endif

            ASSERT(DnrContext->ReleasePkt == TRUE);

            {
                NTSTATUS ReplStatus;

                ExAcquireResourceExclusiveLite( &DfsData.Resource, TRUE );

                ReplStatus = ReplFindNextProvider(DnrContext->pPktEntry,
                                                  &DnrContext->pService,
                                                  &DnrContext->RSelectContext,
                                                  &LastEntry);

                if (ReplStatus == STATUS_NO_MORE_ENTRIES) {

                    ULONG PktType = DnrContext->pPktEntry->Type;

#if DBG
                    if (MupVerbose)
                        DbgPrint("  No more alternates...\n");
#endif

                    //
                    // If all failed and we are about to give up due to one
                    // of two reasons :
                    // 1. None of the Services for the PkEntry being used
                    //    responded (either they are down or network down!).
                    // 2. Some or all of the Services have inconsistencies
                    //    which we detected and informed the DC about along
                    //    the way.
                    // If we did land up with case 2 then we really have to
                    // try and get a new referral and use that - just in
                    // case things have changed since then at the DC. So let
                    // us get into a GetReferral State and try once again.
                    //

                    ExReleaseResourceLite( &DfsData.Resource );

                    if (DnrContext->GotReferral ||
                        (PktType & PKT_ENTRY_TYPE_SYSVOL) != 0 ||
                        DnrContext->GotReparse == TRUE
                    ) {
                        DnrContext->State = DnrStateDone;
                    } else {
                        DnrContext->State = DnrStateGetFirstDC;
                    }

                } else if (NT_SUCCESS( ReplStatus )) {

                    //
                    // Found another replica, go back and retry.
                    //

                    ASSERT(DnrContext->pService != NULL);
                    ASSERT(DnrContext->pService->pProvider != NULL);

                    DnrContext->pProvider = DnrContext->pService->pProvider;
                    DnrContext->ProviderId = DnrContext->pProvider->eProviderId;
                    DnrContext->TargetDevice = DnrContext->pProvider->DeviceObject;
                    DFS_REFERENCE_OBJECT(DnrContext->TargetDevice);

                    ExReleaseResourceLite(&DfsData.Resource);

                    DnrContext->State = DnrStateSendRequest;

#if DBG
                    if (MupVerbose)
                        DbgPrint("  Alternate Name=[%wZ] Address=[%wZ]\n",
                            &DnrContext->pService->Name,
                            &DnrContext->pService->Address);
#endif

                    if (LastEntry == TRUE) {
                        DnrContext->DfsNameContext.Flags |= DFS_FLAG_LAST_ALTERNATE;
                    } else {
                        DnrContext->DfsNameContext.Flags &= ~DFS_FLAG_LAST_ALTERNATE;
                    }

                    break;
                } else  {

                    ExReleaseResourceLite(&DfsData.Resource);

                    ASSERT(ReplStatus == STATUS_NO_MORE_ENTRIES);
                }
            }
            break;

        case DnrStateGetFirstDC:
            DfsDbgTrace(0, Dbg, "FSM state GetFirstDC\n", 0);
#if DBG
            if (MupVerbose) {
                KeQuerySystemTime(&EndTime);
                DbgPrint("[%d] FSM state DnrStateGetFirstDC\n",
                    (ULONG)((EndTime.QuadPart - DnrContext->StartTime.QuadPart)/(10 * 1000)));
            }
#endif

            ASSERT(DnrContext->ReleasePkt == TRUE);

            {
                NTSTATUS ReplStatus;
                PDFS_PKT_ENTRY pPktEntryDC = NULL;

                pPktEntryDC = PktLookupReferralEntry(&DfsData.Pkt, DnrContext->pPktEntry);

                //
                // If there is no root entry, or it is stale, or it has no
                // services, then try for a new referral entry for the root
                //

                if (
                    pPktEntryDC == NULL
                        ||
                    pPktEntryDC->ExpireTime <= 0
                        ||
                    pPktEntryDC->Info.ServiceCount == 0
                ) {

                    if (DnrContext->CalledDCLocator) {
                        DnrContext->FinalStatus = STATUS_CANT_ACCESS_DOMAIN_INFO;
                        DnrContext->State = DnrStateDone;
                        break;
                    }

                    //
                    // We are unable to find a DC to go to for referrals.
                    // This can only happen if we don't have the pkt entry
                    // for the root of the Dfs. Try to get the root entry.
                    //

                    DfsDbgTrace(0, Dbg, "No DC info - will try locator\n", 0);
#if DBG
                    if (MupVerbose) {
                        if (pPktEntryDC != NULL && pPktEntryDC <= 0)
                            DbgPrint("  Entry is stale.\n");
                        DbgPrint("  No Root/DC info - will try locator\n");
                    }
#endif

                    PktRelease();
                    DnrContext->ReleasePkt = FALSE;

                    DnrLocateDC(&DnrContext->FileName);

                    PktAcquireShared( TRUE, &DnrContext->ReleasePkt );

                    DnrContext->CalledDCLocator = TRUE;
                    DnrContext->State = DnrStateStart;

                    break;

                }

#if DBG
                if (MupVerbose) {
                    if (DnrContext->pPktEntry != NULL)
                        DbgPrint("  DnrContext->pPktEntry=[%wZ]\n",
                            &DnrContext->pPktEntry->Id.Prefix);
                    else
                        DbgPrint("  DnrContext->pPktEntry=NULL\n");
                    DbgPrint("  pPktEntryDC=[%wZ]\n", &pPktEntryDC->Id.Prefix);
                }
#endif

                DnrContext->pPktEntry = pPktEntryDC;

                DNR_SET_TARGET_INFO( DnrContext, DnrContext->pPktEntry );
                DnrContext->USN = pPktEntryDC->USN;

                ExAcquireResourceExclusiveLite(&DfsData.Resource, TRUE);

                ReplStatus = ReplFindFirstProvider(pPktEntryDC,
                                            NULL,
                                            NULL,
                                            &DnrContext->pService,
                                            &DnrContext->RDCSelectContext,
                                            &LastEntry);

                if (!NT_SUCCESS(ReplStatus)) {
                    ExReleaseResourceLite(&DfsData.Resource);
                    DnrContext->FinalStatus = STATUS_CANT_ACCESS_DOMAIN_INFO;
                    DnrContext->State = DnrStateDone;
                    break;
                } else {
                    ASSERT(DnrContext->pService != NULL);
                    ASSERT(DnrContext->pService->pProvider != NULL);

                    InterlockedIncrement(&DnrContext->pPktEntry->UseCount);

                    DnrContext->pProvider = DnrContext->pService->pProvider;
                    DnrContext->ProviderId = DnrContext->pProvider->eProviderId;
                    DnrContext->TargetDevice = DnrContext->pProvider->DeviceObject;
                    DFS_REFERENCE_OBJECT(DnrContext->TargetDevice);

                    ExReleaseResourceLite(&DfsData.Resource);

                }
            }
            DnrContext->State = DnrStateGetReferrals;
            /* FALL THROUGH */


        case DnrStateGetReferrals:
            DfsDbgTrace(0, Dbg, "FSM state GetReferrals\n", 0);
#if DBG
            if (MupVerbose) {
                KeQuerySystemTime(&EndTime);
                DbgPrint("[%d] FSM state DnrStateGetReferrals\n",
                    (ULONG)((EndTime.QuadPart - DnrContext->StartTime.QuadPart)/(10 * 1000)));
            }
#endif

            ASSERT(DnrContext->ReleasePkt == TRUE);

            ExAcquireResourceExclusiveLite(&DfsData.Resource, TRUE);

            //
            // Attempt to open the Dfs Root's IPC$ share if we haven't already done
            // so.
            //

            if (DnrContext->pService->ConnFile == NULL) {
                HANDLE hDC;
                SE_IMPERSONATION_STATE DisabledImpersonationState;
                BOOLEAN RestoreImpersonationState = FALSE;

                ExReleaseResourceLite(&DfsData.Resource);
                KeQuerySystemTime(&EndTime);

#if DBG
                if (MupVerbose)
                    DbgPrint("  [%d] Opening connection to [\\%wZ\\IPC$] using [%wZ]\n",
                        (ULONG)((EndTime.QuadPart - DnrContext->StartTime.QuadPart)/(10 * 1000)),
                        &DnrContext->pService->Name,
                        &DnrContext->pProvider->DeviceName);
#endif


		if (MupUseNullSessionForDfs) {
		    RestoreImpersonationState = PsDisableImpersonation(
                                                   PsGetCurrentThread(),
                                                   &DisabledImpersonationState);
		}
		  
                Status = DfsCreateConnection(
                            DnrContext->pService,
                            DnrContext->pProvider,
                            (BOOLEAN)
                                ((DnrContext->Vcb->VcbState & VCB_STATE_CSCAGENT_VOLUME) != 0),
                                                                        &hDC);

                if (RestoreImpersonationState) {
                        PsRestoreImpersonation(
                            PsGetCurrentThread(),
                            &DisabledImpersonationState);
                }


#if DBG
                if (MupVerbose)
                    DbgPrint("  Open of connection Status=0x%x\n", Status);
#endif

                if (NT_SUCCESS( Status )) {

                    if (DnrContext->USN != DnrContext->pPktEntry->USN) {

                        //
                        // Dang, Pkt Entry changed when we made the
                        // connection. We'll have to retry.
                        //
                        InterlockedDecrement(&DnrContext->pPktEntry->UseCount);

                        ZwClose( hDC );

                        DnrContext->State = DnrStateGetFirstDC;
#if DBG
                        if (MupVerbose)
                            DbgPrint("  USN changed.\n");
#endif
                        break;

                    }

                }

                if ( NT_SUCCESS( Status ) ) {

                    PFILE_OBJECT FileObject; // Need stack based variable
                                             // because ObRef... expects
                                             // this parameter to be in
                                             // non-paged memory.

                    ExAcquireResourceExclusiveLite(&DfsData.Resource, TRUE);

                    if (DnrContext->pService->ConnFile == NULL) {

                        //
                        // 426184, need to check return code for errors.
                        //
                        Status = ObReferenceObjectByHandle(
                                    hDC,
                                    0,
                                    NULL,
                                    KernelMode,
                                    (PVOID *)&FileObject,
                                    NULL);
                        MUP_TRACE_ERROR_HIGH(Status, ALL_ERROR,  DnrNameResolve_Error_ObReferenceObjectByHandle,
                                             LOGSTATUS(Status)
                                             LOGPTR(FileObject));
#if DBG
                        if (MupVerbose)
                            DbgPrint("  ObReferenceObjectByHandle returned 0x%x\n", Status);
#endif
                        if ( NT_SUCCESS( Status ) ) {
                            DnrContext->pService->ConnFile = FileObject;
                        }
                        ZwClose( hDC );
                    }
                }

                if ( NT_SUCCESS( Status ) ) {
                    DnrContext->DCConnFile = DnrContext->pService->ConnFile;
                    DnrContext->CachedConnFile = FALSE;
                    DFS_REFERENCE_OBJECT( DnrContext->DCConnFile );

                    ExReleaseResourceLite( &DfsData.Resource );

                } else if (DfsEventLog > 0) {

                    LogWriteMessage(
                        DFS_CONNECTION_FAILURE,
                        Status,
                        1,
                        &DnrContext->pService->Name);

                }

            } else {

                //
                // DnrContext->pService is protected by the Pkt lock. Since we
                // will be using pService->ConnFile to send the referral request,
                // we better reference and cache it.
                //
                DnrContext->DCConnFile = DnrContext->pService->ConnFile;
                DFS_REFERENCE_OBJECT( DnrContext->DCConnFile );
                DnrContext->CachedConnFile = TRUE;
                ExReleaseResourceLite(&DfsData.Resource);
                Status = STATUS_SUCCESS;

            }

            //
            // Unable to get IPC$ share, try the next Dfs root
            //

            if (!NT_SUCCESS(Status)) {
                DnrContext->State = DnrStateGetNextDC;
                DFS_DEREFERENCE_OBJECT(DnrContext->TargetDevice);
                break;
            }

            //
            // Opened Dfs Root's IPC$ share - remember this DC is a good one.
            //

            ReplSetActiveService(
                DnrContext->pPktEntry,
                DnrContext->RDCSelectContext);

            //
            // Build the Referral request...
            //

            Irp = DnrBuildReferralRequest(DnrContext);

            if (Irp == NULL) {
                InterlockedDecrement(&DnrContext->pPktEntry->UseCount);
                Irp = DnrContext->OriginalIrp;
                DnrContext->FinalStatus = STATUS_INSUFFICIENT_RESOURCES;
                DFS_DEREFERENCE_OBJECT(DnrContext->TargetDevice);
                DFS_DEREFERENCE_OBJECT(DnrContext->DCConnFile);
                DnrContext->State = DnrStateDone;
#if DBG
                if (MupVerbose)
                    DbgPrint("  DnrBuildReferralRequest returned NULL irp\n");
#endif
                break;
            }

            DnrContext->State = DnrStateCompleteReferral;

            PktRelease();
            DnrContext->ReleasePkt = FALSE;

            //
            // The PktReferralRequests semaphore is used to control how
            // many threads can simultaneously be going for referrals. The
            // following Wait will decrement the PktReferralRequests
            // semaphore by 1 if it is not already 0. If it is 0, then
            // this thread will suspend until someone else bumps up the
            // semaphore by 1. We will bump up the semaphore count in
            // DnrCompleteReferral.
            //

            Status = KeWaitForSingleObject(
                            &DfsData.PktReferralRequests,
                            UserRequest,     // WaitReason - don't care
                            KernelMode,
                            FALSE,           // Alertable
                            NULL);           // Timeout

            ASSERT(Status == STATUS_SUCCESS);

            KeQuerySystemTime(&EndTime);
#if DBG
            if (MupVerbose)
                DbgPrint("  [%d] asking for referral (IoCallDriver)\n",
                    (ULONG)((EndTime.QuadPart - DnrContext->StartTime.QuadPart)/(10 * 1000)));
#endif

            IoMarkIrpPending( DnrContext->OriginalIrp );

            Status = IoCallDriver( DnrContext->TargetDevice, Irp );

            MUP_TRACE_ERROR_HIGH(Status, ALL_ERROR, DnrNameResolve_Error_IoCallDriver,
                                 LOGSTATUS(Status)
                                 LOGPTR(FileObject));
            //
            // We now return STATUS_PENDING. DnrCompleteReferral will
            // resume the Dnr.
            //

            DfsDbgTrace(-1, Dbg, "DnrNameResolve: returning %08lx\n", ULongToPtr(STATUS_PENDING));

            return(STATUS_PENDING);

        case DnrStateGetNextDC:
            DfsDbgTrace(0, Dbg, "FSM State GetNextDC\n", 0);
#if DBG
            if (MupVerbose) {
                KeQuerySystemTime(&EndTime);
                DbgPrint("[%d] FSM state DnrStateGetNextDC\n",
                    (ULONG)((EndTime.QuadPart - DnrContext->StartTime.QuadPart)/(10 * 1000)));
            }
#endif
            {
               NTSTATUS ReplStatus;
               PDFS_PKT_ENTRY pPktEntry = NULL;
               UNICODE_STRING RemPath;

               pPktEntry = PktLookupEntryByPrefix(&DfsData.Pkt,
                                           &DnrContext->FileName,
                                           &RemPath);

               ExAcquireResourceExclusiveLite(&DfsData.Resource, TRUE);

               ReplStatus = ReplFindNextProvider(DnrContext->pPktEntry,
                                                 &DnrContext->pService,
                                                 &DnrContext->RDCSelectContext,
                                                 &LastEntry);
               if (NT_SUCCESS(ReplStatus)) {
                   ASSERT(DnrContext->pService != NULL);
                   ASSERT(DnrContext->pService->pProvider != NULL);

                   DnrContext->pProvider = DnrContext->pService->pProvider;
                   DnrContext->ProviderId = DnrContext->pProvider->eProviderId;
                   DnrContext->TargetDevice = DnrContext->pProvider->DeviceObject;
                   DFS_REFERENCE_OBJECT(DnrContext->TargetDevice);

                   DnrContext->State = DnrStateGetReferrals;
               } else if (pPktEntry != NULL && pPktEntry->ExpireTime <= 0) {
                           //
                           // Extend the timeout on the stale entry we have
                           //
                           ASSERT( PKT_LOCKED_FOR_SHARED_ACCESS() );
#if DBG
                           if (MupVerbose) {
                               DbgPrint("  Out of roots to try for referral for [%wZ]\n",
                                                &DnrContext->FileName);
                               DbgPrint("  Found stale referral [%wZ], adding 60 sec to it\n",
                                                &pPktEntry->Id.Prefix);
                           }
#endif
                   InterlockedDecrement(&DnrContext->pPktEntry->UseCount);
                   DnrContext->State = DnrStateStart;
               } else {
#if DBG
                   if (MupVerbose)
                       DbgPrint("  Out of roots to try for referral for [%wZ], no stale found\n",
                                        &DnrContext->FileName);
#endif
                   InterlockedDecrement(&DnrContext->pPktEntry->UseCount);
                   DnrContext->FinalStatus = STATUS_CANT_ACCESS_DOMAIN_INFO;
                   DnrContext->State = DnrStateDone;
               }

               ExReleaseResourceLite(&DfsData.Resource);

            }
            break;

        case DnrStateDone:
#if DBG
            if (MupVerbose) {
                KeQuerySystemTime(&EndTime);
                DbgPrint("[%d] FSM state DnrStateDone\n",
                    (ULONG)((EndTime.QuadPart - DnrContext->StartTime.QuadPart)/(10 * 1000)));
            }
#endif
            Status = DnrContext->FinalStatus;
            // FALL THROUGH ...

        case DnrStateLocalCompletion:
            DfsDbgTrace(0, Dbg, "FSM state Done\n", 0);
#if DBG
            if (MupVerbose) {
                KeQuerySystemTime(&EndTime);
                DbgPrint("[%d] FSM state DnrStateLocalCompletion\n",
                    (ULONG)((EndTime.QuadPart - DnrContext->StartTime.QuadPart)/(10 * 1000)));
            }
#endif

            if (Status != STATUS_LOGON_FAILURE && !ReplIsRecoverableError(Status)) {

                if (DnrContext->pPktEntry != NULL &&
                    (DnrContext->pPktEntry->Type & PKT_ENTRY_TYPE_SYSVOL) &&
	            (DnrContext->pPktEntry->Link.Flink == &(DnrContext->pPktEntry->Link))) {

                    PDFS_PKT Pkt = _GetPkt();
                    PDFS_PKT_ENTRY Entry = DnrContext->pPktEntry;
                    PDFS_PKT_ENTRY pMatchEntry;

                    InterlockedIncrement(&Entry->UseCount);

                    if (DnrContext->ReleasePkt)
                        PktRelease();

                    PktAcquireExclusive(TRUE, &DnrContext->ReleasePkt);

                    InterlockedDecrement(&Entry->UseCount);

#if DBG
		    if ((MupVerbose) && (pktEntry != NULL)) {
			//
		        // Temporary debug stuff.
			//
			if ((pktEntry->NodeTypeCode != DSFS_NTC_PKT_ENTRY) ||
			    (pktEntry->NodeByteSize != sizeof(*pktEntry))) {
			    DbgPrint("DnrNameResolve: Updating bogus Pkt entry avoided: Pkt Entry 0x%x\n", pktEntry);
			}
		    }
#endif
                    pMatchEntry = PktFindEntryByPrefix(
                                           Pkt,
                                           &Entry->Id.Prefix);

                    if ((Entry->Type & PKT_ENTRY_TYPE_DELETE_PENDING) == 0) {
                        if (pMatchEntry == NULL) {
                             if (DfsInsertUnicodePrefix(&Pkt->PrefixTable,
                                                        &Entry->Id.Prefix,
                                                        &Entry->PrefixTableEntry)) {

                              //
                               // We successfully created the prefix entry, so now we link
                               // this entry into the PKT.
                               //
                               PktLinkEntry(Pkt, Entry);
			     }
	                } else {
                             //
                             // Destroy this entry if it isn't in the table, as we are
                             // about to orphan it.
                             //
                            if (pMatchEntry != NULL && pMatchEntry != Entry) {

                                Entry->ActiveService = NULL;
                                PktEntryIdDestroy(&Entry->Id, FALSE);
                                PktEntryInfoDestroy(&Entry->Info, FALSE);
                                ExFreePool(Entry);
                            }
                        }
                    }
                    PktRelease();
                    DnrContext->ReleasePkt = FALSE;

                }

            }

            if (DnrContext->ReleasePkt)
                PktRelease();

	    if ((Status == STATUS_DEVICE_OFF_LINE) &&
		(IrpSp->FileObject->RelatedFileObject == NULL)) {
	        Status = DfsRerouteOpenToMup(IrpSp->FileObject, &DnrContext->FileName);
	    }

            if (DnrContext->FcbToUse != NULL) {
	        DfsDetachFcb(DnrContext->FcbToUse->FileObject, DnrContext->FcbToUse);
                ExFreePool( DnrContext->FcbToUse );
	    }

            DfsCompleteRequest(DnrContext->pIrpContext, Irp, Status);


            DnrReleaseCredentials(DnrContext);

            SeDeleteClientSecurity( &DnrContext->SecurityContext );

            if (DnrContext->NameAllocated)
                ExFreePool( DnrContext->FileName.Buffer );

            if (DnrContext->pDfsTargetInfo != NULL)
            {
                PktReleaseTargetInfo(DnrContext->pDfsTargetInfo);
                DnrContext->pDfsTargetInfo = NULL;
            }
            KeQuerySystemTime(&EndTime);
#if DBG
            if (MupVerbose)
                DbgPrint("[%d] DnrNameResolve exit 0x%x\n",
                        (ULONG)((EndTime.QuadPart - DnrContext->StartTime.QuadPart)/(10 * 1000)),
                        Status);
#endif
            DeallocateDnrContext(DnrContext);

            DfsDbgTrace(-1, Dbg, "DnrNameResolve: Exit ->%x\n", ULongToPtr(Status));
            return Status;

        default:
            BugCheck("DnrNameResolve: unexpected DNR state");
        }
    }

    BugCheck("DnrNameResolve: unexpected exit from loop");
}



//+----------------------------------------------------------------------------
//
//  Function:   DnrComposeFileName
//
//  Synopsis:   Given a DFS_VCB (implicitly a Device Object), and a file name
//              relative to that device, this routine will compose a fully
//              qualified name (ie, a name relative to the highest (org) root).
//
//  Arguments:  [FullName] --   Fully qualified name destination.
//              [Vcb] --        Pointer to Vcb of Device Object.
//              [RelatedFile] -- Related file object.
//              [FileName] -- The file being "name resolved"
//
//  Returns:
//
//  Note:       This function assumes that file names are composed precisely
//              of two parts - the name relative to org of the file object's
//              device, followed by the name of the file relative to the device
//              This may not be true if we have a related file object! In that
//              case, the full name is three part - device name relative to
//              org, related file name relative to device, and file name
//              relative to related file. However, in create.c,
//              DfsCommonCreate, we manipulate file objects so all opens look
//              like "non-relative" opens. If one changes that code, then
//              this function must be changed to correspond.
//
//-----------------------------------------------------------------------------

VOID
DnrComposeFileName(
    OUT PUNICODE_STRING FullName,
    IN  PDFS_VCB            Vcb,
    IN  PFILE_OBJECT RelatedFile,
    IN  PUNICODE_STRING FileName
)
{
    PUNICODE_STRING   LogRootPrefix = &(Vcb->LogRootPrefix);

    ASSERT(FullName->MaximumLength >= FileName->Length + LogRootPrefix->Length);
    ASSERT(FullName->Length == 0);
    ASSERT(FullName->Buffer != NULL);

    if ((LogRootPrefix->Length > 0) && (RelatedFile == NULL)) {
        RtlMoveMemory(FullName->Buffer, LogRootPrefix->Buffer,
                      LogRootPrefix->Length);
        FullName->Length = LogRootPrefix->Length;
    } else {
        FullName->Buffer[0] = UNICODE_PATH_SEP;
        FullName->Length = sizeof(UNICODE_PATH_SEP);
    }

    DnrConcatenateFilePath(
        FullName,
        FileName->Buffer,
        FileName->Length);

}


//+----------------------------------------------------------------------------
//
//  Function:   DnrCaptureCredentials
//
//  Synopsis:   Captures the credentials to use for Dnr.
//
//  Arguments:  [DnrContext] -- The DNR_CONTEXT record describing the Dnr.
//
//  Returns:    Nothing -- The DnrContext is simply updated.
//
//-----------------------------------------------------------------------------

VOID
DnrCaptureCredentials(
    IN OUT PDNR_CONTEXT DnrContext)
{

#ifdef TERMSRV
    NTSTATUS Status;
    ULONG SessionID;
#endif // TERMSRV

    LUID LogonID;

    DfsDbgTrace(+1, Dbg, "DnrCaptureCredentials: Enter [%wZ] \n", &DnrContext->FileName);
    ExAcquireResourceExclusiveLite( &DfsData.Resource, TRUE );

    DfsGetLogonId( &LogonID );

#ifdef TERMSRV

    Status = TSGetRequestorSessionId( DnrContext->OriginalIrp, & SessionID );

    ASSERT( NT_SUCCESS( Status ) ) ;

    if( NT_SUCCESS( Status ) ) {
        DnrContext->Credentials = DfsLookupCredentials( &DnrContext->FileName, SessionID, &LogonID  );
    }
    else {
        DnrContext->Credentials = NULL;
    }

#else // TERMSRV

    DnrContext->Credentials = DfsLookupCredentials( &DnrContext->FileName, &LogonID );

#endif // TERMSRV


    if (DnrContext->Credentials != NULL)
        DnrContext->Credentials->RefCount++;

    ExReleaseResourceLite( &DfsData.Resource );
    DfsDbgTrace(-1, Dbg, "DnrCaptureCredentials: Exit. Creds %x\n", DnrContext->Credentials);

}


//+----------------------------------------------------------------------------
//
//  Function:   DnrReleaseCredentials
//
//  Synopsis:   Releases the credentials captured by DnrCaptureCredentials
//
//  Arguments:  [DnrContext] -- The DNR_CONTEXT into which credentials were
//                      captured.
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

VOID
DnrReleaseCredentials(
    IN PDNR_CONTEXT DnrContext)
{
    ExAcquireResourceExclusiveLite( &DfsData.Resource, TRUE );

    if (DnrContext->Credentials != NULL)
        DnrContext->Credentials->RefCount--;

    ExReleaseResourceLite( &DfsData.Resource );

}


//+-------------------------------------------------------------------
//
//  Function:   DnrRedirectFileOpen, local
//
//  Synopsis:   This routine redirects a create IRP request to the specified
//              provider by doing an IoCallDriver to the device object for
//              which the file open is destined. This routine takes care of
//              converting the FileObject's name from the Dfs namespace to
//              the underlying file system's namespace.
//
//  Arguments:  [DnrContext] -- The context block for the DNR.  All
//                      parameters for the operation will be taken from
//                      here.
//
//  Returns:    [STATUS_DEVICE_OFF_LINE] -- The service for the volume
//                      is currently off line.
//
//              [STATUS_DEVICE_NOT_CONNECTED] -- The storage for the volume
//                      is not available at this time. Might have been blown
//                      off by a format etc.
//
//              [STATUS_INSUFFICIENT_RESOURCES] -- Unable to allocate room
//                      for the file name that the provider for this volume
//                      understands.
//
//              [STATUS_PENDING] -- If the underlying file system returned
//                      STATUS_PENDING.
//
//              Any other NTSTATUS that the underlying file system returned.
//
//  Notes:
//
//--------------------------------------------------------------------

NTSTATUS
DnrRedirectFileOpen (
    IN PDNR_CONTEXT DnrContext
) {
    PIRP Irp = DnrContext->OriginalIrp;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation(Irp);
    PIO_STACK_LOCATION NextIrpSp = NULL;
    PFILE_OBJECT FileObject = IrpSp->FileObject;
    PDFS_VCB Vcb = DnrContext->Vcb;
    NTSTATUS Status;
    UNICODE_STRING fileName;
    ULONG CreateOptions;
    PPROVIDER_DEF pProvider;
    UNICODE_STRING ProviderDeviceName;

    DfsDbgTrace(+1, Dbg, "DnrRedirectFileOpen: Entered\n", 0);

    MUP_TRACE_NORM(DNR, DnrRedirectFileOpen_Entry,
		   LOGPTR(DnrContext->OriginalIrp)
		   LOGUSTR(DnrContext->FileName));
    //
    // If this is a csc agent open, force the open to the LanManRedirector,
    // as this is the only redirector that works with csc.
    //


    DNR_SET_TARGET_INFO( DnrContext, DnrContext->pPktEntry );

    DnrContext->DfsNameContext.pLMRTargetInfo =  NULL;
    DnrContext->DfsNameContext.pDfsTargetInfo = NULL;

    if (DnrContext->pDfsTargetInfo != NULL) {
        if (DnrContext->pDfsTargetInfo->DfsHeader.Flags & TARGET_INFO_DFS)
        {
            DnrContext->DfsNameContext.pDfsTargetInfo = 
                (PVOID)&DnrContext->pDfsTargetInfo->TargetInfo;
        }
        else {
            DnrContext->DfsNameContext.pLMRTargetInfo = 
                (PVOID)&DnrContext->pDfsTargetInfo->LMRTargetInfo;
        }
    }


    if (
        (DnrContext->Vcb->VcbState & VCB_STATE_CSCAGENT_VOLUME)
            &&
        (DnrContext->pService->Type & DFS_SERVICE_TYPE_DOWN_LEVEL)
    ) {
        RtlInitUnicodeString(&ProviderDeviceName, DD_NFS_DEVICE_NAME_U);
        ExAcquireResourceExclusiveLite( &DfsData.Resource, TRUE );
        Status = DfsGetProviderForDevice(
                    &ProviderDeviceName,
                    &DnrContext->pProvider);
        if (NT_SUCCESS( Status )) {
            DFS_DEREFERENCE_OBJECT(DnrContext->TargetDevice);
            if (MupVerbose)
                DbgPrint("  CSCAGENT:Provider Device [%wZ] -> [%wZ]\n",
                     &DnrContext->TargetDevice->DriverObject->DriverName,
                     &DnrContext->pProvider->DeviceObject->DriverObject->DriverName);
            DnrContext->ProviderId = DnrContext->pProvider->eProviderId;
            DnrContext->TargetDevice = DnrContext->pProvider->DeviceObject;
            DFS_REFERENCE_OBJECT(DnrContext->TargetDevice);
        } else {
            DFS_DEREFERENCE_OBJECT(DnrContext->TargetDevice);
            ExReleaseResourceLite( &DfsData.Resource );
            DnrReleaseAuthenticatedConnection(DnrContext);
            DnrContext->FinalStatus = STATUS_BAD_NETWORK_PATH;
            DnrContext->State = DnrStateDone;
            return(STATUS_BAD_NETWORK_PATH);
        }
        ExReleaseResourceLite( &DfsData.Resource );
    }

    //
    // Prepare to hand of the open request to the next driver. We
    // must give it a name that it will understand; so, we save the original
    // file name in the DnrContext in case we need to restore it in the
    // event of a failure.
    //

    DnrContext->SavedFileName = FileObject->FileName;
    DnrContext->SavedRelatedFileObject = FileObject->RelatedFileObject;

    ASSERT( DnrContext->SavedFileName.Buffer != NULL );

    //
    //  Create the full path name to be opened from the target device
    //  object.
    //

    fileName.MaximumLength =
                    DnrContext->pService->Address.Length +
                    DnrContext->pPktEntry->Id.Prefix.Length +
                    sizeof (WCHAR) +
                    DnrContext->RemainingPart.Length;

    fileName.Buffer = ExAllocatePoolWithTag(PagedPool, fileName.MaximumLength, ' puM');

    if (fileName.Buffer == NULL) {
        DFS_DEREFERENCE_OBJECT(DnrContext->TargetDevice);
        DnrReleaseAuthenticatedConnection(DnrContext);
        DnrContext->FinalStatus = STATUS_INSUFFICIENT_RESOURCES;
        DnrContext->State = DnrStateDone;
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    if (DnrContext->pService->Address.Buffer)   {

        RtlMoveMemory( fileName.Buffer,
                   DnrContext->pService->Address.Buffer,
                   DnrContext->pService->Address.Length
                   );
        fileName.Length = DnrContext->pService->Address.Length;

    } else {

        fileName.Buffer[0] = UNICODE_PATH_SEP;
        fileName.Length = sizeof(WCHAR);

    }

    //
    //  If we are supposed to strip the prefix, do it now.
    //

    if (!(DnrContext->pService->Capability & PROV_STRIP_PREFIX)) {

        DnrConcatenateFilePath(
            &fileName,
            DnrContext->pPktEntry->Id.Prefix.Buffer,
            DnrContext->pPktEntry->Id.Prefix.Length);

    }

    if (DnrContext->RemainingPart.Length > 0) {

        DnrConcatenateFilePath(
            &fileName,
            DnrContext->RemainingPart.Buffer,
            DnrContext->RemainingPart.Length);

    }

    DnrContext->NewNameLen = fileName.Length;

    //
    //  Attempt to open the file.  Copy all of the information
    //  from the create IRP we received.
    //

    DfsDbgTrace( 0, Dbg, "Attempt to open %wZ\n", &fileName );

    //
    // Copy the stack from one to the next...
    //

    NextIrpSp = IoGetNextIrpStackLocation(Irp);
    (*NextIrpSp) = (*IrpSp);

    CreateOptions = IrpSp->Parameters.Create.Options;

    // Update the type of open in the DfsNameContext

    if (DnrContext->Vcb->VcbState & VCB_STATE_CSCAGENT_VOLUME) {
#if DBG
        if (MupVerbose)
            DbgPrint("  FsContext = DFS_CSCAGENT_NAME_CONTEXT\n");
#endif
        DnrContext->DfsNameContext.NameContextType = DFS_CSCAGENT_NAME_CONTEXT;
    } else {
#if DBG
        if (MupVerbose)
            DbgPrint("  FsContext = DFS_USER_NAME_CONTEXT\n");
#endif
        DnrContext->DfsNameContext.NameContextType = DFS_USER_NAME_CONTEXT;
    }


    FileObject->FsContext = &(DnrContext->DfsNameContext);

    if (DnrContext->pProvider->fProvCapability & PROV_DFS_RDR) {

        //
        // We are connecting to a dfs-aware server. Indicate this to the
        // redirector.
        //

        FileObject->FsContext2 = UIntToPtr(DFS_OPEN_CONTEXT);

    } else {

        //
        // We are connecting to a downlevel server. Indicate to the redirector
        // that Dfs is trying a downlevel access.
        //

        FileObject->FsContext2 = UIntToPtr(DFS_DOWNLEVEL_OPEN_CONTEXT);

    }


    NextIrpSp->Parameters.Create.Options = CreateOptions;

    FileObject->RelatedFileObject = NULL;
    FileObject->FileName = fileName;

    IoSetCompletionRoutine(
        Irp,
        DnrCompleteFileOpen,
        DnrContext,
        TRUE,
        TRUE,
        TRUE);

    //
    // Now, we are going to pass the buck to the provider for this volume.
    // This can potentially go over the net. To avoid needless contentions,
    // we release the Pkt.
    //

    ASSERT( PKT_LOCKED_FOR_SHARED_ACCESS() );

    InterlockedIncrement(&DnrContext->pPktEntry->UseCount);

#if defined (USECOUNT_DBG)
    {
        LONG Count;
        Count = InterlockedIncrement(&DnrContext->pService->pMachEntry->UseCount);
        if (Count < DnrContext->pService->pMachEntry->SvcUseCount)
        {
            DbgPrint("DnrContext %x, 1\n", DnrContext);
            DfsDbgBreakPoint;
        }
    }

#else
    InterlockedIncrement(&DnrContext->pService->pMachEntry->UseCount);
#endif

    DnrContext->FcbToUse->DfsMachineEntry = DnrContext->pService->pMachEntry;
    DnrContext->FcbToUse->TargetDevice =    DnrContext->TargetDevice;
    DnrContext->FcbToUse->ProviderId   =    DnrContext->ProviderId;


    PktRelease();
    DnrContext->ReleasePkt = FALSE;

#if DBG
    if (MupVerbose)
        DbgPrint("  DnrRedirectFileOpen of [%wZ(%wZ):0x%x] to [%wZ]\n",
                    &fileName,
                    &DnrContext->DfsNameContext.UNCFileName,
                    DnrContext->DfsNameContext.Flags,
                    &DnrContext->TargetDevice->DriverObject->DriverName);
#endif

    MUP_TRACE_NORM(DNR, DnrRedirectFileOpen_BeforeIoCallDriver,
		   LOGPTR(Irp)
		   LOGUSTR(DnrContext->FileName)
		   LOGUSTR(DnrContext->TargetDevice->DriverObject->DriverName));

    Status = IoCallDriver(DnrContext->TargetDevice, Irp);
    MUP_TRACE_ERROR_HIGH(Status, ALL_ERROR, DnrRedirectFileOpen_Error_IoCallDriver,
                         LOGSTATUS(Status)
			 LOGPTR(Irp)
                         LOGPTR(FileObject)
			 LOGPTR(DnrContext));
			 
    
    if (Status != STATUS_PENDING) {

        DnrContext->State = DnrStatePostProcessOpen;

    }

    DfsDbgTrace( 0, Dbg, "IoCallDriver Status = %8lx\n", ULongToPtr(Status));

    DfsDbgTrace(-1, Dbg, "DnrRedirectFileOpen: Exit -> %x\n", ULongToPtr(Status));

    return(Status);

}


//+-------------------------------------------------------------------
//
//  Function:   DnrPostProcessFileOpen, local
//
//  Synopsis:   This routine picks up where DnrRedirectFileOpen left off.
//              It figures out what the underlying file system returned
//              in response to our IoCallDriver, and resumes DNR from there.
//
//  Arguments:  [DnrContext] -- The context block for the DNR.  All
//                      parameters for the operation will be taken from
//                      here.
//
//  Returns:    NTSTATUS - The status of the operation.
//
//--------------------------------------------------------------------

ULONG StopOnError = 0;

NTSTATUS
DnrPostProcessFileOpen(
    IN PDNR_CONTEXT DnrContext)
{
    NTSTATUS Status;
    PDFS_VCB Vcb = DnrContext->Vcb;
    PIRP Irp = DnrContext->OriginalIrp;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation(Irp);
    PFILE_OBJECT FileObject = IrpSp->FileObject;
    LARGE_INTEGER EndTime;


    DfsDbgTrace( +1, Dbg, "DnrPostProcessFileOpen Entered: DnrContext = %08lx\n",
                DnrContext );


    Status = DnrContext->FinalStatus;

    if ((Status == STATUS_LOGON_FAILURE) || (Status == STATUS_ACCESS_DENIED))
    {
        if (MupVerbose)
        {
            DbgPrint("File %wZ, (%wZ), Status %x\n",
                     &DnrContext->ContextFileName, &FileObject->FileName, Status);
            DbgPrint("Context used was %x, %x\n", DnrContext->DfsNameContext.pDfsTargetInfo,
                     DnrContext->DfsNameContext.pLMRTargetInfo );
            DbgPrint("Driver is %wZ\n", &DnrContext->TargetDevice->DriverObject->DriverName);
        }
    }
             
#if DBG
    if (MupVerbose) {
        KeQuerySystemTime(&EndTime);
        DbgPrint("  [%d] DnrPostProcessFileOpen entered [%wZ] Status = 0x%x\n",
                    (ULONG)((EndTime.QuadPart - DnrContext->StartTime.QuadPart)/(10 * 1000)),
                    &FileObject->FileName,
                    Status);
    }
#endif

    if ( Status == STATUS_REPARSE ) {

        //
        // This may have been an open sent to the MUP, who is now returning a status
        // reparse. Figure out the name of the device that this is being
        // reparsed to, create (if needed) a PROVIDER_DEF for this new device,
        // and retry DnrRedirectFileOpen. Also, update the service
        // structure to point to this new provider.
        //

        //
        // If the device is not mup, clean out any child entries for the pkt
        // entry that represents the root of the dfs, then stop dnr with
        // STATUS_REPARSE
        //

        PDFS_PKT_ENTRY pEntry;
        UNICODE_STRING ProviderDevice;
        UNICODE_STRING MupDeviceName;
        UNICODE_STRING FileName;
        UNICODE_STRING RemPath;
        USHORT i, j;

        DfsDbgTrace(0, Dbg, "Processing STATUS_REPARSE...\n", 0);

        ProviderDevice = FileObject->FileName;

        RtlInitUnicodeString(&MupDeviceName, L"\\FileSystem\\Mup");

#if DBG
        if (MupVerbose)
            DbgPrint("  Comparing [%wZ] to [%wZ]\n", 
                    &DnrContext->TargetDevice->DriverObject->DriverName,
                    &MupDeviceName);
#endif

        if ( RtlCompareUnicodeString(
                &DnrContext->TargetDevice->DriverObject->DriverName,
                &MupDeviceName,
                TRUE) != 0
        ) {

            //
            // This is *not* the mup returning REPARSE
            //

            FileName = DnrContext->FileName;

            //
            // We want to work with the \Server\Share part of the FileName only,
            // so count up to 3 backslashes, then stop.
            //

            for (i = j = 0; i < FileName.Length/sizeof(WCHAR) && j < 3; i++) {

                if (FileName.Buffer[i] == UNICODE_PATH_SEP) {

                    j++;

                }

            }

            FileName.Length = (j >= 3) ? (i-1) * sizeof(WCHAR) : i * sizeof(WCHAR);

#if DBG
            if (MupVerbose)
                DbgPrint("  Will remove all children of [%wZ]\n", &FileName);
#endif

            PktAcquireExclusive( TRUE, &DnrContext->ReleasePkt );

            //
            // Now find the pkt entry
            //

            pEntry = PktLookupEntryByPrefix(
                        &DfsData.Pkt,
                        &FileName,
                        &RemPath);

            //
            // And remove all children
            //

            if (pEntry != NULL) {

                PktFlushChildren(pEntry);

            }

            PktRelease();
            DnrContext->ReleasePkt = FALSE;

            DnrContext->GotReparse = TRUE;
            DnrContext->State = DnrStateDone;
            Status = STATUS_REPARSE;

        } else {

            //
            //  This is the mup returning REPARSE
            //

            //
            // We want to work with the \Device\Driver part of the ProviderDevice only,
            // so count up to 3 backslashes, then stop.
            //

            for (i = j = 0; i < ProviderDevice.Length/sizeof(WCHAR) && j < 3; i++) {

                if (ProviderDevice.Buffer[i] == UNICODE_PATH_SEP) {

                    j++;

                }

            }

            ProviderDevice.Length = (j >= 3) ? (i-1) * sizeof(WCHAR) : i * sizeof(WCHAR);

            DfsDbgTrace(0, Dbg, "Provider Device is [%wZ]\n", &ProviderDevice);

            ExAcquireResourceExclusiveLite( &DfsData.Resource, TRUE );

            Status = DfsGetProviderForDevice(
                        &ProviderDevice,
                        &DnrContext->pProvider);

            if (NT_SUCCESS( Status )) {

                DnrContext->ProviderId = DnrContext->pProvider->eProviderId;
                DnrContext->TargetDevice = DnrContext->pProvider->DeviceObject;
                DFS_REFERENCE_OBJECT(DnrContext->TargetDevice);
                DnrContext->State = DnrStateSendRequest;

            } else {

                if (DnrContext->FinalStatus != STATUS_REPARSE) {
                    DnrContext->FinalStatus = Status;
                }
                DnrContext->State = DnrStateDone;

            }

            ExReleaseResourceLite( &DfsData.Resource );

        }

        ASSERT(DnrContext->ReleasePkt == FALSE);

        //
        // Set active service only if we're going to
        // continue DNR, and the USN hasn't changed.
        //
        // The exit code (see comment at end) will restart DNR if the USN
        // has changed.
        //

        if (NT_SUCCESS( Status )) {

            PktAcquireExclusive( TRUE, &DnrContext->ReleasePkt );

            if (DnrContext->USN == DnrContext->pPktEntry->USN) {

                ReplSetActiveService(DnrContext->pPktEntry,
                                    DnrContext->RSelectContext);

                DnrContext->pService->ProviderId =
                    DnrContext->pProvider->eProviderId;

                DnrContext->pService->pProvider = DnrContext->pProvider;
            }

            PktConvertExclusiveToShared();

        } else {
            if (Status == STATUS_FS_DRIVER_REQUIRED) {
                Status = STATUS_REPARSE;
            }

            DnrContext->FinalStatus = Status;
            PktAcquireShared( TRUE, &DnrContext->ReleasePkt );

        }

        InterlockedDecrement(&DnrContext->pPktEntry->UseCount);

#if defined (USECOUNT_DBG)
        {
            LONG Count;
            Count = InterlockedDecrement(&DnrContext->FcbToUse->DfsMachineEntry->UseCount);
            if (Count < DnrContext->FcbToUse->DfsMachineEntry->SvcUseCount)
            {
                DbgPrint("DnrContext %x, 2\n", DnrContext);
                DfsDbgBreakPoint;
            }
        }
#else

        InterlockedDecrement(&DnrContext->FcbToUse->DfsMachineEntry->UseCount);
#endif

        DfsDbgTrace(0, Dbg, "State after Reparse is %d\n", DnrContext->State);

    }
    else if (( Status == STATUS_LOGON_FAILURE ) || (Status == STATUS_ACCESS_DENIED))
    {
        UNICODE_STRING ProviderDeviceName;
        UNICODE_STRING MupDeviceName;
        UNICODE_STRING ProviderDevice;
        BOOLEAN ReturnError = FALSE;

        NTSTATUS SavedStatus = Status;

        ProviderDevice = FileObject->FileName;
        RtlInitUnicodeString(&MupDeviceName, L"\\FileSystem\\Mup");

        if ( RtlCompareUnicodeString(
                &DnrContext->TargetDevice->DriverObject->DriverName,
                &MupDeviceName,
                TRUE) == 0 )
        {

            RtlInitUnicodeString(&ProviderDeviceName, DD_NFS_DEVICE_NAME_U);
            ExAcquireResourceExclusiveLite( &DfsData.Resource, TRUE );

            Status = DfsGetProviderForDevice( &ProviderDeviceName,
                                              &DnrContext->pProvider);

            if (Status == STATUS_SUCCESS) {
                DnrContext->ProviderId = DnrContext->pProvider->eProviderId;
                DnrContext->TargetDevice = DnrContext->pProvider->DeviceObject;
                DFS_REFERENCE_OBJECT(DnrContext->TargetDevice);
                DnrContext->State = DnrStateSendRequest;
            }
            ExReleaseResourceLite( &DfsData.Resource );
            if (Status == STATUS_SUCCESS)
            {
                PktAcquireExclusive( TRUE, &DnrContext->ReleasePkt );

                if (DnrContext->USN == DnrContext->pPktEntry->USN) {

                    ReplSetActiveService(DnrContext->pPktEntry,
                                         DnrContext->RSelectContext);

                    DnrContext->pService->ProviderId =
                        DnrContext->pProvider->eProviderId;

                    DnrContext->pService->pProvider = DnrContext->pProvider;
                }

                PktConvertExclusiveToShared();

            }
        }

        InterlockedDecrement(&DnrContext->pPktEntry->UseCount);

        InterlockedDecrement(&DnrContext->FcbToUse->DfsMachineEntry->UseCount);

        if (Status != STATUS_SUCCESS)
        {
            DnrContext->FinalStatus = SavedStatus;
            DnrContext->State = DnrStateDone;

            ExFreePool( FileObject->FileName.Buffer );
            FileObject->FileName = DnrContext->SavedFileName;
            FileObject->RelatedFileObject = DnrContext->SavedRelatedFileObject;
        }
    }
     else if ( Status == STATUS_OBJECT_TYPE_MISMATCH ) {

        //
        // This was an open sent to a downlevel server\share that failed
        // because the server happens to be in a Dfs itself. If so, we
        // simply change the name on which we are doing DNR and restart DNR.
        //

        DfsDbgTrace(0, Dbg, "Downlevel access found inter-dfs link!\n", 0);

        DfsDbgTrace(
            0, Dbg, "Current File name is [%wZ]\n", &FileObject->FileName);

        ASSERT(DnrContext->ReleasePkt == FALSE);
        PktAcquireShared( TRUE, &DnrContext->ReleasePkt );

        //
        // Bug: 332061. do not mark it as outside my dom.
        //
        // DnrContext->pPktEntry->Type |= PKT_ENTRY_TYPE_OUTSIDE_MY_DOM;

        InterlockedDecrement(&DnrContext->pPktEntry->UseCount);

#if defined (USECOUNT_DBG)
        {
            LONG Count;
            Count = InterlockedDecrement(&DnrContext->FcbToUse->DfsMachineEntry->UseCount);
            if (Count < DnrContext->FcbToUse->DfsMachineEntry->SvcUseCount)
            {
                DbgPrint("DnrContext %x, 3\n", DnrContext);
            DfsDbgBreakPoint;
            }
        }
#else

        InterlockedDecrement(&DnrContext->FcbToUse->DfsMachineEntry->UseCount);

#endif
        DnrContext->RemainingPart.Length = 0;
        DnrContext->RemainingPart.MaximumLength = 0;
        DnrContext->RemainingPart.Buffer = 0;

        DnrRebuildDnrContext(
            DnrContext,
            &FileObject->FileName,
            &DnrContext->RemainingPart);

        ExFreePool(FileObject->FileName.Buffer);
        FileObject->FileName = DnrContext->SavedFileName;
        FileObject->RelatedFileObject = DnrContext->SavedRelatedFileObject;


    } else if ( NT_SUCCESS( Status ) ) {

        PDFS_FCB Fcb;
        DfsDbgTrace( 0, Dbg, "Open attempt succeeded\n", 0 );

        ASSERT( (DnrContext->FileName.Length & 0x1) == 0 );

        Fcb = DnrContext->FcbToUse;
        DnrContext->FcbToUse = NULL;

        DfsDbgTrace(0, Dbg, "Fcb = %08lx\n", Fcb);

        Fcb->TargetDevice = DnrContext->TargetDevice;
        Fcb->ProviderId = DnrContext->ProviderId;

        //
        // If we file (dir) happens to be a junction point, we capture its
        // alternate name from the Pkt Entry, so we can field requests for
        // FileAlternateNameInformation.
        //

        if (DnrContext->RemainingPart.Length == 0) {

            UNICODE_STRING allButLast;

            RemoveLastComponent(
                &DnrContext->pPktEntry->Id.ShortPrefix,
                &allButLast);

            Fcb->AlternateFileName.Length =
                DnrContext->pPktEntry->Id.ShortPrefix.Length -
                    allButLast.Length;

            RtlCopyMemory(
                Fcb->AlternateFileName.Buffer,
                &DnrContext->pPktEntry->Id.ShortPrefix.Buffer[
                    allButLast.Length/sizeof(WCHAR)],
                Fcb->AlternateFileName.Length);

            DfsDbgTrace(
                0, Dbg, "Captured alternate name [%wZ]\n",
                &Fcb->AlternateFileName);

        }

        InterlockedIncrement(&Fcb->Vcb->OpenFileCount);

        PktAcquireExclusive( TRUE, &DnrContext->ReleasePkt );

        if (DnrContext->USN == DnrContext->pPktEntry->USN) {
            ReplSetActiveService(DnrContext->pPktEntry,
                                DnrContext->RSelectContext);
        }

        //
        // Reset the life time since we just used this PKT entry successfully.
        //

        DnrContext->pPktEntry->ExpireTime = DnrContext->pPktEntry->TimeToLive;

        InterlockedDecrement(&DnrContext->pPktEntry->UseCount);

        PktConvertExclusiveToShared();

        DnrContext->FinalStatus = Status;
        DnrContext->State = DnrStateDone;

        ExFreePool( DnrContext->SavedFileName.Buffer );

    } else {    // ! NT_SUCCESS( Status ) on IoCallDriver

        DfsDbgTrace( 0, Dbg, "Open attempt failed %8lx\n", ULongToPtr(Status) );

        if (Status == STATUS_PATH_NOT_COVERED || Status == STATUS_DFS_EXIT_PATH_FOUND) {

            if (DnrContext->GotReferral) {

                //
                // We just got a referral, and the server is saying
                // path_not_covered. Means DC and server are out
                // of sync.  Inform the DC
                //

                DfsDbgTrace(0, Dbg, "Dnr: Knowledge inconsistency discovered %wZ\n",
                                        &FileObject->FileName);
                (VOID) DfsTriggerKnowledgeVerification( DnrContext );

                //
                // If we never found an inconsistency let us now
                // go back and try to see if we got this fixed.
                // We won't be in an endless loop since we will
                // not do this more than once.
                //
                if (DnrContext->FoundInconsistency == FALSE)  {
                    DnrContext->State = DnrStateGetFirstReplica;
                    DnrContext->FoundInconsistency = TRUE;
                } else
                    DnrContext->State = DnrStateGetNextReplica;
            } else {
                DnrContext->State = DnrStateGetFirstDC;
            }

        } else if (ReplIsRecoverableError( Status )) {

            //
            // Check to see if the error returned was something worth
            // trying a replica for.
            //
            DnrContext->State = DnrStateGetNextReplica;
#if DBG
            if (MupVerbose)
                DbgPrint("  Recoverable error 0x%x State = DnrStateGetNextReplica\n", Status);
#endif
        }
        else if ((Status == STATUS_OBJECT_PATH_NOT_FOUND) && 
                 (DnrContext->RemainingPart.Length == 0)) {
            //
            // if we hit a PATH_NOT_FOUND at the root, it usually means
            // that we have hit a machine that is no longer the root.
            // If there is only one target, mark it as expired.
            // otherwise, move on to the other targets.
            //

            if (DnrContext->pPktEntry->Info.ServiceCount > 1)
            {
                DnrContext->State = DnrStateGetNextReplica;
            }
            else
            {
                DnrContext->pPktEntry->ExpireTime = 0;
                DnrContext->FinalStatus = Status;
                DnrContext->State = DnrStateDone;
            }
        } else {

            DnrContext->FinalStatus = Status;
            DnrContext->State = DnrStateDone;

#if DBG
            if (MupVerbose)
                DbgPrint("  NON-Recoverable error 0x%x State = DnrStateDone\n", Status);
#endif

        }

        if (DfsEventLog > 0) {
            UNICODE_STRING puStr[2];

            if (!DnrContext->ReleasePkt)
                PktAcquireShared( TRUE, &DnrContext->ReleasePkt );
            if (DnrContext->USN == DnrContext->pPktEntry->USN) {
                puStr[0] = FileObject->FileName;
                puStr[1] = DnrContext->pService->Name;
                LogWriteMessage(DFS_OPEN_FAILURE, Status, 2, puStr);
            }
        }

        //
        // In either case, we are going back into DNR.  Let's acquire shared
        // access to Pkt.  We had released the Pkt just before doing the
        // IoCallDriver.
        //

        if (!DnrContext->ReleasePkt)
            PktAcquireShared( TRUE, &DnrContext->ReleasePkt );

        InterlockedDecrement(&DnrContext->pPktEntry->UseCount);

#if defined (USECOUNT_DBG)
        {
            LONG Count;
            Count = InterlockedDecrement(&DnrContext->FcbToUse->DfsMachineEntry->UseCount);
            if (Count < DnrContext->FcbToUse->DfsMachineEntry->SvcUseCount)
            {
                DbgPrint("DnrContext %x, 4\n", DnrContext);
                DfsDbgBreakPoint;
            }
        }
#else

        InterlockedDecrement(&DnrContext->FcbToUse->DfsMachineEntry->UseCount);

#endif

        ExFreePool( FileObject->FileName.Buffer );
        FileObject->FileName = DnrContext->SavedFileName;
        FileObject->RelatedFileObject = DnrContext->SavedRelatedFileObject;
    }

    //
    // One last thing. If we are going back into DNR for whatever reason,
    // check to see if the PktEntry we captured in the DNR_CONTEXT has
    // changed. If so, we'll simply have to restart.
    //

    if (DnrContext->State != DnrStateDone &&
            DnrContext->pPktEntry != NULL &&
                DnrContext->pPktEntry->USN != DnrContext->USN) {

        DnrContext->State = DnrStateStart;

    }

#if DBG
    if (MupVerbose) {
        KeQuerySystemTime(&EndTime);
        DbgPrint("  [%d] DnrPostProcessFileOpen Exited: Status = %08lx State = %d\n",
                        (ULONG)((EndTime.QuadPart - DnrContext->StartTime.QuadPart)/(10 * 1000)),
                        Status,
                        DnrContext->State);
    }
#endif

    DfsDbgTrace( -1, Dbg, "DnrPostProcessFileOpen Exited: Status = %08lx\n",
                ULongToPtr(Status) );
    return Status;
}


//+----------------------------------------------------------------------------
//
//  Function:   DnrGetAuthenticatedConnection
//
//  Synopsis:   If this Dnr is using user-supplied credentials, this routine
//              will setup a tree connection using the user-supplied
//              credentials.
//
//  Notes:      This routine might free and reacquire the Pkt lock. This
//              means that the Pkt entry referenced in DnrContext might
//              become invalid after this call. The caller is assumed to
//              have cached and referenced everything she will need to
//              use in DnrContext before making this call.
//
//  Arguments:  [DnrContext] -- The DNR_CONTEXT record for this Dnr
//
//  Returns:    [STATUS_SUCCESS] -- Operation completed successfully
//
//              NT Status from the attempt to create the tree connection
//
//-----------------------------------------------------------------------------


NTSTATUS
DnrGetAuthenticatedConnection(
    IN OUT PDNR_CONTEXT DnrContext)
{
    NTSTATUS Status;
    PDFS_SERVICE pService = DnrContext->pService;
    BOOLEAN fDoConnection = TRUE;
    LARGE_INTEGER EndTime;

    PFILE_OBJECT TreeConnFileObj = NULL;

    DfsDbgTrace(+1, Dbg, "DnrGetAuthenticatedConnection: Entered\n", 0);

#if DBG
    if (MupVerbose) {
        KeQuerySystemTime(&EndTime);
        DbgPrint("  [%d] DnrGetAuthenticatedConnection(\\%wZ)\n",
                        (ULONG)((EndTime.QuadPart - DnrContext->StartTime.QuadPart)/(10 * 1000)),
                        &pService->Address);
    }
#endif

    ASSERT(DnrContext->pService != NULL);
    ASSERT(DnrContext->pProvider != NULL);

    ExAcquireResourceExclusiveLite( &DfsData.Resource, TRUE );

    //
    // See if we are using supplied credentials
    //

    if (DnrContext->Credentials == NULL) {

        DfsDbgTrace(-1, Dbg,
            "DnrGetAuthenticatedConnection: Dnr with no creds\n", 0);
#if DBG
        if (MupVerbose) {
            KeQuerySystemTime(&EndTime);
            DbgPrint("  [%d] DnrGetAuthenticatedConnection: No creds exit STATUS_SUCCESS\n",
                    (ULONG)((EndTime.QuadPart - DnrContext->StartTime.QuadPart)/(10 * 1000)));
        }
#endif
	ExReleaseResourceLite( &DfsData.Resource );
        return( STATUS_SUCCESS );
    }

    //
    // See if this is a credential record describing the use of default
    // credentials
    //

    if (DnrContext->Credentials->EaLength == 0) {

        DfsDbgTrace(-1, Dbg,
            "DnrGetAuthenticatedConnection: Dnr with default creds\n", 0);
#if DBG
        if (MupVerbose) {
            KeQuerySystemTime(&EndTime);
            DbgPrint("  [%d] DnrGetAuthenticatedConnection: Default creds exit STATUS_SUCCESS\n",
                    (ULONG)((EndTime.QuadPart - DnrContext->StartTime.QuadPart)/(10 * 1000)));
        }
#endif
	ExReleaseResourceLite( &DfsData.Resource );
        return( STATUS_SUCCESS );

    }

    //
    // See if we already have a authenticated connection to the server, and
    // the authenticated connection was established using the credentials
    // we want to use.
    //

    if (pService->pMachEntry->AuthConn != NULL) {

        if (
            (DnrContext->Vcb->VcbState & VCB_STATE_CSCAGENT_VOLUME) != 0
                &&
            pService->pMachEntry->Credentials == DnrContext->Credentials
         ) {

            DnrContext->AuthConn = pService->pMachEntry->AuthConn;
            DFS_REFERENCE_OBJECT( DnrContext->AuthConn );
            fDoConnection = FALSE;
            DfsDbgTrace(0, Dbg,
                "Using existing tree connect %08lx\n", DnrContext->AuthConn);
#if DBG
            if (MupVerbose) {
                KeQuerySystemTime(&EndTime);
                DbgPrint("  [%d] Using existing tree connect\n",
                        (ULONG)((EndTime.QuadPart - DnrContext->StartTime.QuadPart)/(10 * 1000)));
            }
#endif
            Status = STATUS_SUCCESS;

        } else {

            DfsDbgTrace(0, Dbg,
                "Deleting connect %08lx\n", pService->pMachEntry->AuthConn);
#if DBG
            if (MupVerbose) {
                KeQuerySystemTime(&EndTime);
                DbgPrint("  [%d] Deleting tree connect connect\n",
                        (ULONG)((EndTime.QuadPart - DnrContext->StartTime.QuadPart)/(10 * 1000)));
            }
#endif
            TreeConnFileObj = pService->pMachEntry->AuthConn;

            pService->pMachEntry->AuthConn = NULL;
            pService->pMachEntry->Credentials->RefCount--;
            pService->pMachEntry->Credentials = NULL;
            if (pService->ConnFile != NULL)
                DfsCloseConnection( pService );

        }

    }

    ExReleaseResourceLite( &DfsData.Resource );

    //
    // We delete the tree connection after releasing the resource, since
    // the delete involve a call to a lower level driver and we want to 
    // avoid resource lock conflicts.
    //
    if (TreeConnFileObj) {
	    DfsDeleteTreeConnection( TreeConnFileObj, USE_FORCE );
    }

    //
    // If we need to establish a new authenticated connection, do it now.
    // We need a new connection because either we had none, or the one we
    // had was using a different set of credentials.
    //

    if (fDoConnection) {

        UNICODE_STRING shareName;
        HANDLE treeHandle;
        OBJECT_ATTRIBUTES objectAttributes;
        IO_STATUS_BLOCK ioStatusBlock;
        USHORT i, k;

        //
        // Compute the share name...
        //

        shareName.MaximumLength =
            sizeof(DD_NFS_DEVICE_NAME_U) +
                    pService->Address.Length;

        shareName.Buffer = ExAllocatePoolWithTag(PagedPool, shareName.MaximumLength, ' puM');

        if (shareName.Buffer != NULL) {

            shareName.Length = 0;

            RtlAppendUnicodeToString(
                &shareName,
                DD_NFS_DEVICE_NAME_U);

            RtlAppendUnicodeStringToString(&shareName, &pService->Address);

            //
            // One can only do tree connects to server\share. So, in case
            // pService->Address refers to something deeper than the share,
            // make sure we setup a tree-conn only to server\share. Note that
            // by now, shareName is of the form
            // \Device\LanmanRedirector\server\share<\path>. So, count up to
            // 4 slashes and terminate the share name there.
            //

            for (i = 0, k = 0;
                    i < shareName.Length/sizeof(WCHAR) && k < 5;
                        i++) {

                if (shareName.Buffer[i] == UNICODE_PATH_SEP)
                    k++;
            }

            shareName.Length = i * sizeof(WCHAR);
            if (k == 5)
                shareName.Length -= sizeof(WCHAR);

            InitializeObjectAttributes(
                &objectAttributes,
                &shareName,
                OBJ_CASE_INSENSITIVE,
                NULL,
                NULL);

            DfsDbgTrace(0, Dbg, "Tree connecting to %wZ\n", &shareName);
            DfsDbgTrace(0, Dbg,
                "Credentials @%08lx\n", DnrContext->Credentials);

            Status = ZwCreateFile(
                        &treeHandle,
                        SYNCHRONIZE,
                        &objectAttributes,
                        &ioStatusBlock,
                        NULL,
                        FILE_ATTRIBUTE_NORMAL,
                        FILE_SHARE_READ |
                            FILE_SHARE_WRITE |
                            FILE_SHARE_DELETE,
                        FILE_OPEN_IF,
                        FILE_CREATE_TREE_CONNECTION |
                            FILE_SYNCHRONOUS_IO_NONALERT,
                        (PVOID) DnrContext->Credentials->EaBuffer,
                        DnrContext->Credentials->EaLength);

            MUP_TRACE_ERROR_HIGH(Status, ALL_ERROR, DnrGetAuthenticatedConnection_Error_ZwCreateFile,
                                 LOGSTATUS(Status));

#if DBG
            if (MupVerbose) {
                KeQuerySystemTime(&EndTime);
                DbgPrint("  [%d] Tree connect to [%wZ] returned 0x%x\n",
                        (ULONG)((EndTime.QuadPart - DnrContext->StartTime.QuadPart)/(10 * 1000)),
                        &shareName,
                        Status);
            }
#endif

            if (NT_SUCCESS(Status)) {

                PFILE_OBJECT fileObject;

                DfsDbgTrace(0, Dbg, "Tree connect succeeded\n", 0);

                //
                // 426184, need to check return code for errors.
                //
                Status = ObReferenceObjectByHandle(
                            treeHandle,
                            0,
                            NULL,
                            KernelMode,
                           (PVOID *)&fileObject,
                            NULL);
                MUP_TRACE_ERROR_HIGH(Status, ALL_ERROR, DnrGetAuthenticatedConnection_Error_ObReferenceObjectByHandle,
                                     LOGSTATUS(Status));

                ZwClose( treeHandle );

                if (NT_SUCCESS(Status)) {
                    DnrContext->AuthConn = fileObject;
                }
            }

            if (NT_SUCCESS(Status)) {

                //
                // We have a new tree connect. Lets try to cache it for later
                // use. Note that the Pkt could have changed when we went out
                // over the net to establish the tree connect, so we cache
                // the tree connect only if the Pkt hasn't changed.
                //

                PktAcquireExclusive( TRUE, &DnrContext->ReleasePkt );
                ExAcquireResourceExclusiveLite( &DfsData.Resource, TRUE );

                if (DnrContext->USN == DnrContext->pPktEntry->USN) {

                    if (pService->pMachEntry->AuthConn == NULL) {

                        pService->pMachEntry->AuthConn = DnrContext->AuthConn;

                        DFS_REFERENCE_OBJECT( pService->pMachEntry->AuthConn );

                        pService->pMachEntry->Credentials =
                            DnrContext->Credentials;

                        pService->pMachEntry->Credentials->RefCount++;

                    }

                }

                ExReleaseResourceLite( &DfsData.Resource );

                DnrContext->ReleasePkt = FALSE;
                PktRelease();
            }

            ExFreePool( shareName.Buffer );

        } else {

            Status = STATUS_INSUFFICIENT_RESOURCES;

        }

    }

    DfsDbgTrace(-1, Dbg,
        "DnrGetAuthenticatedConnection: Exit %08lx\n", ULongToPtr(Status) );

#if DBG
    if (MupVerbose) {
        KeQuerySystemTime(&EndTime);
        DbgPrint("  [%d] DnrGetAuthenticatedConnection exit 0x%x\n",
                (ULONG)((EndTime.QuadPart - DnrContext->StartTime.QuadPart)/(10 * 1000)),
                Status);
    }
#endif

    return( Status );

}


//+----------------------------------------------------------------------------
//
//  Function:   DnrReleaseAuthenticatedConnection
//
//  Synopsis:   Dereferences the authenticated connection we used during
//              Dnr.
//
//  Arguments:  [DnrContext] -- The DNR_CONTEXT record for this Dnr
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

VOID
DnrReleaseAuthenticatedConnection(
    IN PDNR_CONTEXT DnrContext)
{
    if (DnrContext->AuthConn != NULL) {

        DFS_DEREFERENCE_OBJECT( DnrContext->AuthConn );

        DnrContext->AuthConn = NULL;

    }
}


//+----------------------------------------------------------------------------
//
//  Function:   DfsBuildConnectionRequest
//
//  Synopsis:   Builds the file names necessary to setup an
//              authenticated connection to a server's IPC$ share.
//
//  Arguments:  [pService] -- Pointer to DFS_SERVICE describing server
//              [pProvider] -- Pointer to PROVIDER_DEF describing the
//                            provider to use to establish the connection.
//              [pShareName] -- Share name to open.
//
//  Returns:    STATUS_SUCCESS or STATUS_INSUFFICIENT_RESOURCES
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsBuildConnectionRequest(
    IN PDFS_SERVICE pService,
    IN PPROVIDER_DEF pProvider,
    OUT PUNICODE_STRING pShareName)
{
    ASSERT(pService != NULL);
    ASSERT(pProvider != NULL);

    RtlInitUnicodeString(pShareName, NULL);

    pShareName->Length = 0;

    pShareName->MaximumLength = pProvider->DeviceName.Length +
                                    sizeof(UNICODE_PATH_SEP_STR) +
                                        pService->Name.Length +
                                            sizeof(ROOT_SHARE_NAME);

    pShareName->Buffer = ExAllocatePoolWithTag(PagedPool, pShareName->MaximumLength, ' puM');

    if (pShareName->Buffer == NULL) {

        DfsDbgTrace(0, Dbg, "Unable to allocate pool for share name!\n", 0);

        pShareName->Length = pShareName->MaximumLength = 0;

        return( STATUS_INSUFFICIENT_RESOURCES );
    }

    RtlAppendUnicodeStringToString( pShareName, &pProvider->DeviceName );

    RtlAppendUnicodeToString( pShareName, UNICODE_PATH_SEP_STR );

    RtlAppendUnicodeStringToString( pShareName, &pService->Name );

    RtlAppendUnicodeToString( pShareName, ROOT_SHARE_NAME );

    return( STATUS_SUCCESS );

}

//+----------------------------------------------------------------------------
//
//  Function:   DfsFreeConnectionRequest
//
//  Synopsis:   Frees up the stuff allocated on a successful call to
//              DfsBuildConnectionRequest
//
//  Arguments:  [pShareName] -- Unicode string holding share name.
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

VOID
DfsFreeConnectionRequest(
    IN OUT PUNICODE_STRING pShareName)
{

    if (pShareName->Buffer != NULL) {
        ExFreePool ( pShareName->Buffer );
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   DfsCreateConnection -- Create a connection to a server
//
//  Synopsis:   DfsCreateConnection will attempt to create a connection
//              to some server's IPC$ share.
//
//  Arguments:  [pService] -- the Service entry, giving the server principal
//                            name
//              [pProvider] --
//
//              [CSCAgentCreate] -- TRUE if this is on behalf of CSC agent
//
//              [remoteHandle] -- This is where the handle is returned.
//
//  Returns:    NTSTATUS - the status of the operation
//
//  Notes:      The Pkt must be acquired shared before calling this! It will
//              be released and reacquired in this routine.
//
//--------------------------------------------------------------------------

NTSTATUS
DfsCreateConnection(
    IN PDFS_SERVICE     pService,
    IN PPROVIDER_DEF    pProvider,
    IN BOOLEAN          CSCAgentCreate,
    OUT PHANDLE         remoteHandle
) {
    PFILE_FULL_EA_INFORMATION  EaBuffer;
    ULONG                      EaBufferLength;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatusBlock;
    UNICODE_STRING ShareName;
    NTSTATUS Status;
    BOOLEAN pktLocked;

    ASSERT( PKT_LOCKED_FOR_SHARED_ACCESS() );
    ASSERT(pService != NULL);
    ASSERT(pProvider != NULL);

    Status = DfsBuildConnectionRequest(
                pService,
                pProvider,
                &ShareName);

    if (!NT_SUCCESS(Status)) {
        return( Status );
    }

    InitializeObjectAttributes(
        &ObjectAttributes,
        &ShareName,                             // File Name
        0,                                      // Attributes
        NULL,                                   // Root Directory
        NULL                                    // Security
        );

    //
    // Create or open a connection to the server.
    //

    PktRelease();

    if (CSCAgentCreate) {
        EaBuffer = DfsData.CSCEaBuffer;
        EaBufferLength = DfsData.CSCEaBufferLength;
    } else {
        EaBuffer = NULL;
        EaBufferLength = 0;
    }

    Status = ZwCreateFile(
                    remoteHandle,
                    SYNCHRONIZE,
                    &ObjectAttributes,
                    &IoStatusBlock,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                    FILE_OPEN_IF,
                    FILE_SYNCHRONOUS_IO_NONALERT,
                    EaBuffer,
                    EaBufferLength);

    MUP_TRACE_ERROR_HIGH(Status, ALL_ERROR, DfsCreateConnection_Error_ZwCreateFile,
                         LOGSTATUS(Status));
    PktAcquireShared( TRUE, &pktLocked );

    if ( NT_SUCCESS( Status ) ) {
        DfsDbgTrace(0, Dbg, "Created Connection Successfully\n", 0);
        Status = IoStatusBlock.Status;
    }

    DfsFreeConnectionRequest( &ShareName );

    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   DfsCloseConnection -- Close a connection to a server
//
//  Synopsis:   DfsCloseConnection will attempt to Close a connection
//              to some server.
//
//  Effects:    The file object referring to the the connection will be
//              closed.
//
//  Arguments:  [pService] - the Service entry, giving the server connection
//                      handle
//
//  Returns:    NTSTATUS - the status of the operation
//
//  History:    28 May 1992     Alanw   Created
//
//--------------------------------------------------------------------------


NTSTATUS
DfsCloseConnection(
    IN PDFS_SERVICE pService
)
{
    ASSERT( pService->ConnFile != NULL );

    ObDereferenceObject(pService->ConnFile);
    pService->ConnFile = NULL;
    InterlockedDecrement(&pService->pMachEntry->ConnectionCount);
    return STATUS_SUCCESS;
}



//+----------------------------------------------------------------------------
//
//  Function:   DnrBuildReferralRequest
//
//  Synopsis:   This routine builds all the necessary things to send
//              a referral request to a DC.
//
//  Arguments:  [pDnrContext] -- The context for building the referral.
//
//  Returns:    Pointer to an IRP that can be used to get a referral.
//
//-----------------------------------------------------------------------------

PIRP
DnrBuildReferralRequest(
    IN PDNR_CONTEXT DnrContext)
{
    PUCHAR pNameResBuf = NULL;
    PREQ_GET_DFS_REFERRAL pRef;
    PWCHAR ReferralPath;
    PPROVIDER_DEF  pProvider;
    PIRP pIrp = NULL;
    ULONG cbBuffer = 0;
    NTSTATUS Status;

    DfsDbgTrace(+1,Dbg, "DnrBuildReferralRequest Entered - DnrContext %08lx\n", DnrContext);

    cbBuffer = DnrContext->FileName.Length + sizeof(UNICODE_NULL) + sizeof(PREQ_GET_DFS_REFERRAL);

    if (DnrContext->ReferralSize > cbBuffer) {
        cbBuffer = DnrContext->ReferralSize;
    }
    else {
        DnrContext->ReferralSize = cbBuffer;
    }
    DfsDbgTrace(0, Dbg, "Referral Size = %d bytes\n", ULongToPtr(cbBuffer));

    pNameResBuf = ExAllocatePoolWithTag(NonPagedPool, cbBuffer, ' puM');

    if (pNameResBuf == NULL) {
        DfsDbgTrace(-1, Dbg, "Unable to allocate %d bytes\n", ULongToPtr(cbBuffer));
        return( NULL );

    }

    pRef = (PREQ_GET_DFS_REFERRAL) pNameResBuf;

    pRef->MaxReferralLevel = 3;

    ReferralPath = (PWCHAR) &pRef->RequestFileName[0];

    RtlMoveMemory(
        ReferralPath,
        DnrContext->FileName.Buffer,
        DnrContext->FileName.Length);

    ReferralPath[ DnrContext->FileName.Length/sizeof(WCHAR) ] = UNICODE_NULL;

    ASSERT( DnrContext->DCConnFile != NULL);

#if DBG
    if (MupVerbose)
        DbgPrint("  DnrBuildReferrlRequest:ReferralPath=[%ws]\n", ReferralPath);
#endif




    Status = DnrGetTargetInfo( DnrContext );

    if (Status == STATUS_SUCCESS)
    {
        pIrp = DnrBuildFsControlRequest( DnrContext->DCConnFile,
                                         DnrContext,
                                         FSCTL_DFS_GET_REFERRALS,
                                         pNameResBuf,
                                         FIELD_OFFSET(REQ_GET_DFS_REFERRAL, RequestFileName) +
                                         (wcslen(ReferralPath) + 1) * sizeof(WCHAR),
                                         pNameResBuf,
                                         cbBuffer,
                                         DnrCompleteReferral );
        if (pIrp == NULL) {

            DfsDbgTrace(-1, Dbg, "DnrBuildReferralRequest: Unable to allocate Irp!\n", 0);
            ExFreePool(pNameResBuf);

        } else {
            DfsDbgTrace(-1, Dbg, "DnrBuildReferralRequest: returning %08lx\n", pIrp);
        }
    }
    return( pIrp );

}


//+----------------------------------------------------------------------------
//
//  Function:   DnrInsertReferralAndResume
//
//  Synopsis:   This routine is queued as a work item from DnrComplete
//              referral and does the work of actually inserting the
//              referral and resuming DNR. We must not do this work
//              directly in DnrCompleteReferral because it operates at
//              raised IRQL.
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

VOID
DnrInsertReferralAndResume(
    IN PVOID Context)
{
    PIRP_CONTEXT  pIrpContext = (PIRP_CONTEXT) Context;
    PDNR_CONTEXT  DnrContext = (PDNR_CONTEXT) pIrpContext->Context;
    PIRP          Irp = pIrpContext->OriginatingIrp;
    PRESP_GET_DFS_REFERRAL pRefResponse;
    ULONG length, matchingLength;
    NTSTATUS status;
    LARGE_INTEGER EndTime;
    ULONG referralType = 0;

    DfsDbgTrace(+1, Dbg, "DnrInsertReferralAndResume: Entered\n", 0);
    DfsDbgTrace(0, Dbg, "Irp          = %x\n", Irp    );
    DfsDbgTrace(0, Dbg, "Context      = %x\n", Context);

    ASSERT(DnrContext->State == DnrStateCompleteReferral);

    status = Irp->IoStatus.Status;
    length = (ULONG)Irp->IoStatus.Information;

    DfsDbgTrace(0, Dbg, "Irp->Status  = %x\n", ULongToPtr(status) );
    DfsDbgTrace(0, Dbg, "Irp->Length  = %x\n", ULongToPtr(length) );

    KeQuerySystemTime(&EndTime);

#if DBG
    if (MupVerbose)
        DbgPrint("  [%d] DnrInsertReferralAndResume entered for [%wZ] status = 0x%x\n",
                (ULONG)((EndTime.QuadPart - DnrContext->StartTime.QuadPart)/(10 * 1000)),
                &DnrContext->FileName,
                status);
#endif

    //
    // If the DC returned STATUS_BUFFER_OVERFLOW, the referral didn't fit in
    // the buffer we sent. Increase the buffer and retry the referral request
    // Since we are going to retry the request, we won't dereference the
    // provider's device object yet.
    //

    if (status == STATUS_BUFFER_OVERFLOW) {
        PULONG pcbSize;

	if (DnrContext->ReferralSize < MAX_REFERRAL_MAX) {
           DfsDbgTrace(0, Dbg, "Referral buffer was too small; retrying...\n", 0);
           DnrContext->ReferralSize = MAX_REFERRAL_MAX;
           DnrContext->State = DnrStateGetReferrals;

           //
           // Going back into Dnr. Reacquire the Pkt shared, and release the
           // PktReferralRequests semaphore, so we can go out again to get a
           // referral.
           //

           goto Cleanup;
       }
    }

    //
    // If we got an error and we were using a cached IPC$ connection,
    // close the cached IPC$ and retry the referral request.
    //

    if ( (DnrContext->CachedConnFile == TRUE) &&
         (status != STATUS_SUCCESS) ) 
    {
        PktAcquireExclusive( TRUE, &DnrContext->ReleasePkt );
        ExAcquireResourceExclusiveLite(&DfsData.Resource, TRUE);
        DnrContext->CachedConnFile = FALSE;
	if (DnrContext->pService->ConnFile != NULL) {
	  DfsCloseConnection(DnrContext->pService);
	}
        DnrContext->State = DnrStateGetReferrals;
        ExReleaseResourceLite( &DfsData.Resource );
        PktConvertExclusiveToShared();
        //
        // Going back into Dnr. Reacquire the Pkt shared, and release the
        // PktReferralRequests semaphore, so we can go out again to get a
        // referral.
        //
        goto Cleanup;
    }

    //
    // The referral request has terminated. Since we are done with the
    // provider, dereference its device object now.
    //

    DFS_DEREFERENCE_OBJECT(DnrContext->TargetDevice);

    //
    // Next, handle the result of the Referral request. If we successfully
    // got a referral, then try to insert it into our Pkt.
    //

    if (NT_SUCCESS(status) && length != 0) {

        pRefResponse = (PRESP_GET_DFS_REFERRAL) Irp->AssociatedIrp.SystemBuffer;
        DfsDbgTrace(0, Dbg, "Irp->Buffer  = %x\n", pRefResponse );

        PktAcquireExclusive( TRUE, &DnrContext->ReleasePkt );

        InterlockedDecrement(&DnrContext->pPktEntry->UseCount);

        status = PktCreateEntryFromReferral(
                        &DfsData.Pkt,
                        &DnrContext->FileName,
                        length,
                        pRefResponse,
                        PKT_ENTRY_SUPERSEDE,
                        DnrContext->pNewTargetInfo,
                        &matchingLength,
                        &referralType,
                        &DnrContext->pPktEntry);

        DNR_SET_TARGET_INFO( DnrContext, DnrContext->pPktEntry );

	if (status == STATUS_INVALID_USER_BUFFER) {
	  status = STATUS_BAD_NETWORK_NAME;
	}

        if (NT_SUCCESS(status) && DfsEventLog > 1) {
            UNICODE_STRING puStr[2];

            puStr[0] = DnrContext->FileName;
            puStr[1] = DnrContext->pService->Name;
            LogWriteMessage(DFS_REFERRAL_SUCCESS, status, 2, puStr);
        }

        if (NT_SUCCESS(status)) {

            UNICODE_STRING fileName;
            UNICODE_STRING RemPath;
            PDFS_PKT_ENTRY pEntry = NULL;
            PDFS_PKT_ENTRY pShortPfxEntry = NULL;
            PDFS_PKT Pkt;

            //
            // See if we have to remove an entry
            //

            pEntry = PktLookupEntryByPrefix(
                        &DfsData.Pkt,
                        &DnrContext->FileName,
                        &RemPath);

            pShortPfxEntry = PktLookupEntryByShortPrefix(
                                &DfsData.Pkt,
				&DnrContext->FileName,
				&RemPath);

            if (pShortPfxEntry != NULL) {
                if ((pEntry == NULL) ||
		    (pShortPfxEntry->Id.Prefix.Length > pEntry->Id.Prefix.Length)) {
		  pEntry = pShortPfxEntry;
		}
	    }

            if (pEntry != NULL && pEntry != DnrContext->pPktEntry) {
	      

#if DBG
                if (MupVerbose)
                    DbgPrint("  DnrInsertReferralAndResume: Need to remove pEntry [%wZ]\n",
                            &pEntry->Id.Prefix);
#endif
                Pkt = _GetPkt();
                if ((pEntry->Type & PKT_ENTRY_TYPE_PERMANENT) == 0) {
                    PktFlushChildren(pEntry);
                    if (pEntry->UseCount == 0) {
                        PktEntryDestroy(pEntry, Pkt, (BOOLEAN) TRUE);
                    } else {
                        pEntry->Type |= PKT_ENTRY_TYPE_DELETE_PENDING;
                        pEntry->ExpireTime = 0;
                        DfsRemoveUnicodePrefix(&Pkt->PrefixTable, &(pEntry->Id.Prefix));
                        DfsRemoveUnicodePrefix(&Pkt->ShortPrefixTable, &(pEntry->Id.ShortPrefix));
                    }
                }

            }

            //
            // At this point, we are essentially in the same state as we were
            // when we started DNR, except that we have one more Pkt entry to
            // match against. Continue with name resolution, after fixing up
            // DnrContext->RemainingPart to reflect the match with the new
            // PktEntry.
            //

            fileName = DnrContext->FileName;

            DnrContext->RemainingPart.Length =
                (USHORT) (fileName.Length - matchingLength);

            DnrContext->RemainingPart.MaximumLength =
                (USHORT) (fileName.MaximumLength - matchingLength);

            DnrContext->RemainingPart.Buffer =
                    &fileName.Buffer[ matchingLength/sizeof(WCHAR) ];

            DnrContext->GotReferral = TRUE;

            DnrContext->State = DnrStateStart;

        } else {

            DnrContext->FinalStatus = status;
            DnrContext->State = DnrStateDone;
        }

        PktConvertExclusiveToShared();

    } else if (status == STATUS_NO_SUCH_DEVICE) {

        UNICODE_STRING RemPath;
        PDFS_PKT_ENTRY pEntry = NULL;
        PDFS_PKT Pkt;
        BOOLEAN pktLocked;

        //
        // Check if there is a pkt entry (probably stale) that needs to be removed
        //
#if DBG
        if (MupVerbose) 
            DbgPrint("  DnrInsertReferralAndResume: remove PKT entry for \\%wZ\n",
                            &DnrContext->FileName);
#endif

        PktAcquireExclusive( TRUE, &DnrContext->ReleasePkt );

        Pkt = _GetPkt();
#if DBG
        if (MupVerbose)
            DbgPrint("  Looking up %wZ\n", &DnrContext->FileName);
#endif
        pEntry = PktLookupEntryByPrefix(
                        &DfsData.Pkt,
                        &DnrContext->FileName,
                        &RemPath);
#if DBG
        if (MupVerbose)
            DbgPrint("  pEntry=0x%x\n", pEntry);
#endif
        if (pEntry != NULL && (pEntry->Type & PKT_ENTRY_TYPE_PERMANENT) == 0) {
            PktFlushChildren(pEntry);
            if (pEntry->UseCount == 0) {
                PktEntryDestroy(pEntry, Pkt, (BOOLEAN) TRUE);
            } else {
                pEntry->Type |= PKT_ENTRY_TYPE_DELETE_PENDING;
                pEntry->ExpireTime = 0;
                DfsRemoveUnicodePrefix(&Pkt->PrefixTable, &(pEntry->Id.Prefix));
                DfsRemoveUnicodePrefix(&Pkt->ShortPrefixTable, &(pEntry->Id.ShortPrefix));
            }
        }

        InterlockedDecrement(&DnrContext->pPktEntry->UseCount);

        DnrContext->FinalStatus = status;
        DnrContext->State = DnrStateDone;

        PktConvertExclusiveToShared();

    } else if (ReplIsRecoverableError(status)) {

        DnrContext->State = DnrStateGetNextDC;

    } else if (status == STATUS_BUFFER_OVERFLOW) {

        InterlockedDecrement(&DnrContext->pPktEntry->UseCount);

        DnrContext->FinalStatus = status;

        DnrContext->State = DnrStateDone;

    }  else if (DnrContext->Attempts > 0) {

#if DBG
        if (MupVerbose)
            DbgPrint("  DnrInsertReferralAndResume restarting Attempts = %d\n",
                        DnrContext->Attempts);
#endif
        DnrContext->State = DnrStateStart;

    } else {

        InterlockedDecrement(&DnrContext->pPktEntry->UseCount);

        DnrContext->FinalStatus = status;

        DnrContext->State = DnrStateDone;

    }

    if ( !NT_SUCCESS(status) && DfsEventLog > 0) {
        UNICODE_STRING puStr[2];

        if (!DnrContext->ReleasePkt)
            PktAcquireShared( TRUE, &DnrContext->ReleasePkt );
        if (DnrContext->USN == DnrContext->pPktEntry->USN) {
            puStr[0] = DnrContext->FileName;
            puStr[1] = DnrContext->pService->Name;
            LogWriteMessage(DFS_REFERRAL_FAILURE, status, 2, puStr);
        }
    }

Cleanup:

    //
    // Cleanup referral stuff.
    //

    if (Irp->UserBuffer && Irp->UserBuffer != Irp->AssociatedIrp.SystemBuffer)
        ExFreePool( Irp->UserBuffer );
    if (Irp->AssociatedIrp.SystemBuffer) {
        ExFreePool( Irp->AssociatedIrp.SystemBuffer );
    }

    IoFreeIrp(Irp);
    PktReleaseTargetInfo( DnrContext->pNewTargetInfo );
    DnrContext->pNewTargetInfo = NULL;
    DfsDeleteIrpContext(pIrpContext);

    //
    // We are going back into Dnr, so prepare for that:
    //
    //  - Reacquire PKT shared
    //  - Release the semaphore for referral requests, so that the next
    //    thread can get its referral.
    //  - Restart Dnr
    //

    if (!DnrContext->ReleasePkt)
        PktAcquireShared( TRUE, &DnrContext->ReleasePkt );

    ASSERT(DnrContext->ReleasePkt == TRUE);

#if DBG
    if (MupVerbose)
        DbgPrint("  DnrInsertReferralAndResume next State=%d\n", DnrContext->State);
#endif

    DnrContext->Impersonate = TRUE;
    DnrContext->DnrActive = FALSE;
    DnrNameResolve(DnrContext);
    PsAssignImpersonationToken(PsGetCurrentThread(),NULL);

    DfsDbgTrace(-1, Dbg, "DnrInsertReferralAndResume: Exit -> %x\n", ULongToPtr(status) );

}



//
//  The following two functions are DPC functions which participate
//  in the Distributed Name Resolution process.  Each takes a
//  PDNR_CONTEXT as input, transitions the state of the
//  name resolution and any associated data structures, and
//  invokes the next step of the process.
//


//+-------------------------------------------------------------------
//
//  Function:   DnrCompleteReferral, local
//
//  Synopsis:   This is the completion routine for processing a referral
//              response.  Cleanup the IRP and continue processing the name
//              resolution request.
//
//  Arguments:  [pDevice] -- Pointer to target device object for
//                      the request.
//              [Irp] -- Pointer to I/O request packet
//              [Context] -- Caller-specified context parameter associated
//                      with IRP.  This is actually a pointer to a DNR
//                      Context block.
//
//  Returns:    [STATUS_MORE_PROCESSING_REQUIRED] -- The referral Irp was
//                      constructed by Dnr and will be freed by us. So, we
//                      don't want the IO Subsystem to touch the Irp anymore.
//
//  Notes:      This routine executes at DPC level. We should do an absolutely
//              minimum amount of work here.
//
//--------------------------------------------------------------------

NTSTATUS
DnrCompleteReferral(
    IN PDEVICE_OBJECT pDevice,
    IN PIRP Irp,
    IN PVOID Context
) {
    PIRP_CONTEXT pIrpContext = NULL;
    PDNR_CONTEXT DnrContext = (PDNR_CONTEXT) Context;

    DfsDbgTrace(+1, Dbg, "DnrCompleteReferral: Entered\n", 0);

    DfsDbgTrace(0, Dbg, "Irp = %x\n", Irp);
    DfsDbgTrace(0, Dbg, "Context = %x\n", Context);

    //
    // Derefernce the file object over which we sent the referral request
    //

    DFS_DEREFERENCE_OBJECT( DnrContext->DCConnFile );

    DnrContext->DCConnFile = NULL;

    //
    // Release the semaphore controlling number of referral requests
    //

    KeReleaseSemaphore(
        &DfsData.PktReferralRequests,
        0,                                       // Priority boost
        1,                                       // Increment semaphore amount
        FALSE);                                  // Won't call wait immediately

    try {

        pIrpContext = DfsCreateIrpContext(Irp, TRUE);
        if (pIrpContext == NULL)
            ExRaiseStatus(STATUS_INSUFFICIENT_RESOURCES);
        pIrpContext->Context = DnrContext;

        ExInitializeWorkItem(
                &pIrpContext->WorkQueueItem,
                DnrInsertReferralAndResume,
                pIrpContext);

        ExQueueWorkItem( &pIrpContext->WorkQueueItem, CriticalWorkQueue );

    } except(DfsExceptionFilter(pIrpContext, GetExceptionCode(), GetExceptionInformation())) {

        //
        // Ok, we can't queue the work item and complete Dnr. So, we have
        // to do two things. First of all, clean up the current Irp (ie,
        // the Referral Irp), then complete the original Dnr Irp
        //

        //
        // Cleanup referral stuff.
        //

        if (Irp->UserBuffer && Irp->UserBuffer != Irp->AssociatedIrp.SystemBuffer)
            ExFreePool( Irp->UserBuffer );
        if (Irp->AssociatedIrp.SystemBuffer) {
            ExFreePool( Irp->AssociatedIrp.SystemBuffer );
        }

        IoFreeIrp(Irp);
        PktReleaseTargetInfo( DnrContext->pNewTargetInfo );
        DnrContext->pNewTargetInfo = NULL;

        if (pIrpContext) {

            //
            // Maybe this should be an assert that pIrpContext == NULL. If
            // it is not NULL, then the Irp context was allocated, so who
            // threw an exception anyway?
            //

            DfsDeleteIrpContext(pIrpContext);
        }

        //
        // Now, call Dnr to complete the original Irp
        //

        InterlockedDecrement(&DnrContext->pPktEntry->UseCount);

        DnrContext->DnrActive = FALSE;
        DnrContext->FinalStatus = STATUS_INSUFFICIENT_RESOURCES;
        DnrContext->State = DnrStateDone;
        DnrNameResolve(DnrContext);
	PsAssignImpersonationToken(PsGetCurrentThread(),NULL);
    }

    //
    // Return more processing required to the IO system so that it
    // doesn't attempt further processing on the IRP. The IRP will be
    // freed by DnrInsertReferralAndResume, or has already been freed
    // if we couldn't queue up DnrInsertReferralAndResume
    //

    DfsDbgTrace(-1, Dbg, "DnrCompleteReferral: Exit -> %x\n",
                ULongToPtr(STATUS_MORE_PROCESSING_REQUIRED) );

    UNREFERENCED_PARAMETER(pDevice);

    return STATUS_MORE_PROCESSING_REQUIRED;
}


//+-------------------------------------------------------------------
//
//  Function:   DnrCompleteFileOpen, local
//
//  Synopsis:   This is the completion routine for processing a file open
//              request.  Cleanup the IRP and continue processing the name
//              resolution request.
//
//  Arguments:  [pDevice] -- Pointer to target device object for
//                      the request.
//              [Irp] -- Pointer to I/O request packet
//              [Context] -- Caller-specified context parameter associated
//                      with IRP.  This is actually a pointer to a DNR
//                      Context block.
//
//  Returns:    [STATUS_MORE_PROCESSING_REQUIRED] -- We still have to finish
//                      the DNR, so we halt further completion of this Irp
//                      by returning STATUS_MORE_PROCESSING_REQUIRED.
//
//--------------------------------------------------------------------

NTSTATUS
DnrCompleteFileOpen(
    IN PDEVICE_OBJECT pDevice,
    IN PIRP Irp,
    IN PVOID Context
) {
    PDNR_CONTEXT DnrContext;
    NTSTATUS status;
    PFILE_OBJECT                FileObject;
    PIO_STACK_LOCATION IrpSp;

    DfsDbgTrace(+1, Dbg, "DnrCompleteFileOpen: Entered\n", 0);
    DfsDbgTrace(0, Dbg, "Irp          = %x\n", Irp    );
    DfsDbgTrace(0, Dbg, "Context      = %x\n", Context);

    DnrContext = Context;

    status = Irp->IoStatus.Status;

    DfsDbgTrace(0, Dbg, "Irp->Status  = %x\n", ULongToPtr(status) );

    DnrContext->FinalStatus = status;

    DnrReleaseAuthenticatedConnection( DnrContext );

    DFS_DEREFERENCE_OBJECT( DnrContext->TargetDevice );

    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    FileObject = IrpSp->FileObject;

    //
    // If STATUS_PENDING was initially returned for the IRP, then we need
    // to restart DNR. So, we post a workitem into the FSP, giving it the
    // DnrContext to resume the DNR.
    //
    // If STATUS_PENDING was not returned, then we simply stop the
    // unwinding of the IRP stack by returning STATUS_MORE_PROCESSING_REQUIRED
    // IoCallDriver will eventually return to DnrRedirectFileOpen, which
    // will continue with the DNR.
    //

    if (Irp->PendingReturned) {

        //
        // Schedule a work item to resume DNR
        //

        DnrContext->Impersonate = TRUE;
        DnrContext->DnrActive = FALSE;
        DnrContext->State = DnrStatePostProcessOpen;
        ASSERT(DnrContext->pIrpContext->MajorFunction == IRP_MJ_CREATE);
        DnrContext->pIrpContext->Context = (PVOID) DnrContext;

        //
        // We need to call IpMarkIrpPending so the IoSubsystem will realize
        // that our FSD routine returned STATUS_PENDING. We can't call this
        // from the FSD routine itself because the FSD routine doesn't have
        // access to the stack location when the underlying guy returns
        // STATUS_PENDING
        //

        IoMarkIrpPending( Irp );

        DfsFsdPostRequest(DnrContext->pIrpContext, DnrContext->OriginalIrp);
    }

    //
    // Return more processing required to the IO system so that it
    // stops unwinding the completion routine stack. The DNR that will
    // be resumed will call IoCompleteRequest when appropriate
    // and resume the unwinding of the completion routine stack.
    //

    status = STATUS_MORE_PROCESSING_REQUIRED;
    DfsDbgTrace(-1, Dbg, "DnrCompleteFileOpen: Exit -> %x\n", ULongToPtr(status) );

    UNREFERENCED_PARAMETER(pDevice);

    return status;
}



//+-------------------------------------------------------------------
//
//  Function:   DnrBuildFsControlRequest, local
//
//  Synopsis:   This function builds an I/O request packet for a device or
//              file system I/O control request.
//
//  Arguments:  [FileObject] -- Supplies a pointer the file object to which this
//                      request is directed.  This pointer is copied into the
//                      IRP, so that the called driver can find its file-based
//                      context.  NOTE THAT THIS IS NOT A REFERENCED POINTER.
//                      The caller must ensure that the file object is not
//                      deleted while the I/O operation is in progress.  The
//                      server accomplishes this by incrementing a reference
//                      count in a local block to account for the I/O; the
//                      local block in turn references the file object.
//              [Context] -- Supplies a PVOID value that is passed to the
//                      completion routine.
//              [FsControlCode] -- Supplies the control code for the operation.
//              [MainBuffer] -- Supplies the address of the main buffer.  This
//                      must be a system virtual address, and the buffer must
//                      be locked in memory.  If ControlCode specifies a method
//                      0 request, the actual length of the buffer must be the
//                      greater of InputBufferLength and OutputBufferLength.
//              [InputBufferLength] -- Supplies the length of the input buffer.
//              [AuxiliaryBuffer] -- Supplies the address of the auxiliary
//                      buffer.  If the control code method is 0, this is a
//                      buffered I/O buffer, but the data returned by the
//                      called driver in the system buffer is not
//                      automatically copied into the auxiliary buffer.
//                      Instead, the auxiliary data ends up in MainBuffer.
//                      If the caller wishes the data to be in AuxiliaryBuffer,
//                      it must copy the data at some point after the
//                      completion routine runs.
//              [CompletionRoutine] -- The IO completion routine.
//
//  Returns:    PIRP -- Returns a pointer to the constructed IRP.  If the Irp
//              parameter was not NULL on input, the function return value will
//              be the same value (so it is safe to discard the return value in
//              this case).  It is the responsibility of the calling program to
//              deallocate the IRP after the I/O request is complete.
//
//  Notes:      should we use IoBuildIoControlRequest instead?
//
//--------------------------------------------------------------------


PIRP
DnrBuildFsControlRequest (
    IN PFILE_OBJECT FileObject OPTIONAL,
    IN PVOID Context,
    IN ULONG IoControlCode,
    IN PVOID MainBuffer,
    IN ULONG InputBufferLength,
    IN PVOID AuxiliaryBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN PIO_COMPLETION_ROUTINE CompletionRoutine
) {
    CLONG method;
    PDEVICE_OBJECT deviceObject;
    PIRP Irp;
    PIO_STACK_LOCATION irpSp;
    const UCHAR MajorFunction = IRP_MJ_FILE_SYSTEM_CONTROL;

    ASSERT( MajorFunction == IRP_MJ_FILE_SYSTEM_CONTROL );

    //
    // Get the method with which the buffers are being passed.
    //

    method = IoControlCode & 3;
    ASSERT( method == METHOD_BUFFERED );

    //
    // Allocate an IRP.  The stack size is one higher
    // than that of the target device, to allow for the caller's
    // completion routine.
    //

    deviceObject = IoGetRelatedDeviceObject( FileObject );

    //
    // Get the address of the target device object.
    //

    Irp = IoAllocateIrp( (CCHAR)(deviceObject->StackSize + 1), FALSE );
    if ( Irp == NULL ) {

        //
        // Unable to allocate an IRP.  Inform the caller.
        //

        return NULL;
    }

    Irp->RequestorMode = KernelMode;

    Irp->Tail.Overlay.OriginalFileObject = FileObject;
    Irp->Tail.Overlay.Thread = PsGetCurrentThread();

    //
    // Get a pointer to the current stack location and fill in the
    // device object pointer.
    //

    IoSetNextIrpStackLocation( Irp );

    irpSp = IoGetCurrentIrpStackLocation( Irp );
    irpSp->DeviceObject = deviceObject;

    //
    // Set up the completion routine.
    //

    IoSetCompletionRoutine(
        Irp,
        CompletionRoutine,
        Context,
        TRUE,
        TRUE,
        TRUE
        );

    //
    // Get a pointer to the next stack location.  This one is used to
    // hold the parameters for the device I/O control request.
    //

    irpSp = IoGetNextIrpStackLocation( Irp );

    irpSp->MajorFunction = MajorFunction;
    irpSp->MinorFunction = 0;
    irpSp->FileObject = FileObject;
    irpSp->DeviceObject = deviceObject;

    //
    // Copy the caller's parameters to the service-specific portion of the
    // IRP for those parameters that are the same for all three methods.
    //

    irpSp->Parameters.DeviceIoControl.OutputBufferLength = OutputBufferLength;
    irpSp->Parameters.DeviceIoControl.InputBufferLength = InputBufferLength;
    irpSp->Parameters.DeviceIoControl.IoControlCode = IoControlCode;

    Irp->MdlAddress = NULL;
    Irp->AssociatedIrp.SystemBuffer = MainBuffer;
    Irp->UserBuffer = AuxiliaryBuffer;

    Irp->Flags = (ULONG)IRP_BUFFERED_IO;
    if ( ARGUMENT_PRESENT(AuxiliaryBuffer) ) {
        Irp->Flags |= IRP_INPUT_OPERATION;
    }

    return Irp;

}


//+-------------------------------------------------------------------------
//
//  Function:   AllocateDnrContext, public
//
//  Synopsis:   AllocateDnrContext will allocate a DNR_CONTEXT
//              record.
//
//  Arguments:  -none-
//
//  Returns:    PDNR_CONTEXT - a pointer to the allocated DNR_CONTEXT;
//                      NULL if not enough memory.
//
//  Notes:      We should investigate allocating this out of the
//              IrpContext Zone if they are similar enough in size.
//
//--------------------------------------------------------------------------

PDNR_CONTEXT
AllocateDnrContext(
    IN ULONG    cbExtra
) {
    PDNR_CONTEXT pNRC;

    pNRC = ExAllocatePoolWithTag( NonPagedPool, sizeof (DNR_CONTEXT) + cbExtra, ' puM');
    if (pNRC == NULL) {
        return NULL;
    }
    RtlZeroMemory(pNRC, sizeof (DNR_CONTEXT));
    pNRC->NodeTypeCode = DSFS_NTC_DNR_CONTEXT;
    pNRC->NodeByteSize = sizeof (DNR_CONTEXT);

    return pNRC;
}


//+-------------------------------------------------------------------------
//
//  Function:   DnrConcatenateFilePath, public
//
//  Synopsis:   DnrConcatenateFilePath will concatenate two strings
//              representing file path names, assuring that they are
//              separated by a single '\' character.
//
//  Arguments:  [Dest] - a pointer to the destination string
//              [RemainingPath] - the final part of the path name
//              [Length] - the length (in bytes) of RemainingPath
//
//  Returns:    BOOLEAN - TRUE unless Dest is too small to
//                      hold the result (assert).
//
//--------------------------------------------------------------------------

BOOLEAN
DnrConcatenateFilePath (
    IN PUNICODE_STRING Dest,
    IN PWSTR RemainingPath,
    IN USHORT Length
) {
    PWSTR  OutBuf = (PWSTR)&(((PCHAR)Dest->Buffer)[Dest->Length]);
    ULONG NewLen;

    if (Dest->Length > 0) {
        ASSERT(OutBuf[-1] != UNICODE_NULL);
    }

    if (Length == 0)
    {
        return TRUE;
    }

    if (Dest->Length > 0 && OutBuf[-1] != UNICODE_PATH_SEP) {
        *OutBuf++ = UNICODE_PATH_SEP;
        Dest->Length += sizeof (WCHAR);
    }

    if (Length > 0 && *RemainingPath == UNICODE_PATH_SEP) {
        RemainingPath++;
        Length -= sizeof (WCHAR);
    }

    NewLen = (ULONG)Dest->Length + (ULONG)Length;

    if (NewLen > MAXUSHORT || NewLen > (ULONG)Dest->MaximumLength) {

        return FALSE;

    }

    if (Length > 0) {
        RtlMoveMemory(OutBuf, RemainingPath, Length);
        Dest->Length += Length;
    }
    return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Function:   DnrLocateDC, private
//
//  Synopsis:   Tries to create an entry for the Dfs root which will match
//              FileName.
//
//  Arguments:  [FileName] -- File name for which DC/Root is being located.
//
//  Returns:    Nothing. 
//
//-----------------------------------------------------------------------------

VOID
DnrLocateDC(
    IN PUNICODE_STRING FileName)
{
    BOOLEAN pktLocked;
    NTSTATUS status;
    UNICODE_STRING dfsRoot, dfsShare, remPath;
    UNICODE_STRING RootShareName;
    PDFS_PKT_ENTRY pktEntry;
    PDFS_PKT pkt;
    USHORT i, j;

    ASSERT( FileName->Buffer[0] == UNICODE_PATH_SEP );

#if DBG
    if (MupVerbose)
        DbgPrint("  DnrLocateDC(%wZ)\n", FileName);
#endif

    dfsRoot.Length = dfsRoot.MaximumLength = 0;
    dfsRoot.Buffer = &FileName->Buffer[1];

    for (i = 1;
            i < FileName->Length/sizeof(WCHAR) &&
                FileName->Buffer[i] != UNICODE_PATH_SEP;
                    i++) {

         NOTHING;

    }

    for (j = i + 1;
            j < FileName->Length/sizeof(WCHAR) &&
                FileName->Buffer[j] != UNICODE_PATH_SEP;
                    j++) {

         NOTHING;

    }

    if ((FileName->Buffer[i] == UNICODE_PATH_SEP) && (j > i)) {

        dfsRoot.MaximumLength = dfsRoot.Length = (i - 1) * sizeof(WCHAR);
        dfsShare.MaximumLength = dfsShare.Length = (j - i - 1) * sizeof(WCHAR);
        dfsShare.Buffer = &FileName->Buffer[i+1];
#if DBG
        if (MupVerbose)
            DbgPrint("  DnrLocateDC dfsRoot=[%wZ] dfsShare=[%wZ]\n",
                    &dfsRoot,
                    &dfsShare);
#endif
        status = PktCreateDomainEntry( &dfsRoot, &dfsShare, FALSE );

        if (!NT_SUCCESS(status)) {

#if DBG
            if (MupVerbose)
                DbgPrint("  DnrLocateDC:PktCreateDomainEntry() returned 0x%x\n", status);
#endif
            RootShareName.Buffer = FileName->Buffer;
            RootShareName.Length = j * sizeof(WCHAR);
            RootShareName.MaximumLength = FileName->MaximumLength;
#if DBG
            if (MupVerbose)
                DbgPrint("  DnrLocateDC:RootShareName=[%wZ]\n", &RootShareName);
#endif

            //
            // Failed getting referral - see if we have a stale one.
            //

            pkt = _GetPkt();

            PktAcquireShared( TRUE, &pktLocked );

            pktEntry = PktLookupEntryByPrefix( pkt, &RootShareName, &remPath );

            if (pktEntry != NULL) {

#if DBG
                if (MupVerbose)
                    DbgPrint("  DnrLocateDC:Found stale pkt entry %08lx - adding 60 sec to it\n",
                                        pktEntry);
#endif
                if (pktEntry->ExpireTime <= 0) {
                    pktEntry->ExpireTime = 60;
                    pktEntry->TimeToLive = 60;
                }

                status = STATUS_SUCCESS;

            }

            PktRelease();

        }

    } else {

        status = STATUS_BAD_NETWORK_PATH;

    }

#if DBG
    if (MupVerbose)
        DbgPrint("  DnrLocateDC exit 0x%x\n", status);
#endif

}

//+----------------------------------------------------------------------------
//
//  Function:   DnrRebuildDnrContext
//
//  Synopsis:   To handle inter-dfs links, we simply want to change the name
//              of the file we are opening to the name in the new Dfs, and
//              restart DNR afresh.
//
//              This is most easily done by simply terminating this DNR with
//              STATUS_REPARSE. However, if we do that, we would loose track
//              of the credentials (if any) we originally came in with.
//
//              Hence, this routine simply rebuilds the DnrContext. After
//              calling this, Dnr starts all over again, just as if
//              DnrNameResolve had been called by DnrStartNameResolution
//
//
//  Arguments:  [DnrContext] -- The context to rebuild.
//              [NewDfsPrefix] -- The prefix of the Dfs in which the DNR
//                      should continue.
//              [RemainingPath] -- Path relative to the NewDfsPrefix.
//
//  Returns:    Nothing.
//
//-----------------------------------------------------------------------------

VOID
DnrRebuildDnrContext(
    IN PDNR_CONTEXT DnrContext,
    IN PUNICODE_STRING NewDfsPrefix,
    IN PUNICODE_STRING RemainingPath)
{
    UNICODE_STRING newFileName;
    ULONG newNameLen = 0;

    PIRP Irp = DnrContext->OriginalIrp;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation(Irp);
    PFILE_OBJECT FileObject = IrpSp->FileObject;

    //
    // Build the new file name
    //

    newFileName.Length = 0;

    newNameLen = NewDfsPrefix->Length +
                    sizeof(UNICODE_PATH_SEP) +
                        RemainingPath->Length +
                            sizeof(UNICODE_NULL);

    if (newNameLen >= MAXUSHORT) {

        DnrContext->FinalStatus = STATUS_NAME_TOO_LONG;
        DnrContext->State = DnrStateDone;
        return;

    }

    newFileName.MaximumLength = (USHORT)newNameLen;

    newFileName.Buffer = (PWCHAR) ExAllocatePoolWithTag(
                                        NonPagedPool,
                                        newFileName.MaximumLength,
                                        ' puM');

    if (newFileName.Buffer != NULL) {

        newFileName.Length = NewDfsPrefix->Length;

        RtlMoveMemory(
            newFileName.Buffer,
            NewDfsPrefix->Buffer,
            newFileName.Length);

        DnrConcatenateFilePath(
            &newFileName,
            RemainingPath->Buffer,
            RemainingPath->Length);

        if (DnrContext->NameAllocated)
            ExFreePool(DnrContext->FileName.Buffer);

        DnrContext->NameAllocated = TRUE;

        DnrContext->FileName = newFileName;

    } else {

        DnrContext->FinalStatus = STATUS_INSUFFICIENT_RESOURCES;

        DnrContext->State = DnrStateDone;

        return;
    }

    //
    // Rebuild the FcbToUse because the Fcb has room for the full file name
    // and it might have changed its size.
    //

    ASSERT(DnrContext->FcbToUse != NULL);

    DfsDetachFcb(DnrContext->FcbToUse->FileObject, DnrContext->FcbToUse);
    ExFreePool(DnrContext->FcbToUse);

    DnrContext->FcbToUse = DfsCreateFcb(
                                DnrContext->pIrpContext,
                                DnrContext->Vcb,
                                &DnrContext->ContextFileName);

    if (DnrContext->FcbToUse == NULL) {

        DnrContext->FinalStatus = STATUS_INSUFFICIENT_RESOURCES;

        DnrContext->State = DnrStateDone;

        return;

    }
    DnrContext->FcbToUse->FileObject = FileObject;
    DfsSetFileObject(FileObject, 
		     RedirectedFileOpen, 
		     DnrContext->FcbToUse);

    //
    // Now, whack the rest of the DnrContext. Clean it up so it is essentially
    // zeroed out..
    //

    DnrContext->State = DnrStateStart;

    DnrContext->pPktEntry = NULL;
    DnrContext->USN = 0;
    DnrContext->pService = NULL;
    DnrContext->pProvider = NULL;
    DnrContext->ProviderId = 0;
    DnrContext->TargetDevice = NULL;
    DnrContext->AuthConn = NULL;
    DnrContext->DCConnFile = NULL;

    DnrContext->ReferralSize = MAX_REFERRAL_LENGTH;
    DnrContext->Attempts++;
    DnrContext->GotReferral = FALSE;
    DnrContext->FoundInconsistency = FALSE;
    DnrContext->CalledDCLocator = FALSE;
    DnrContext->CachedConnFile = FALSE;
    DnrContext->DfsNameContext.Flags = 0;
    DnrContext->GotReparse = FALSE;

}

//+-------------------------------------------------------------------------
//
//  Function:   DfspGetOfflineEntry -- Checks for a server marked offline.
//
//  Synopsis:   DfspGetOfflineEntry returns an offline entry for the given
//              server, if it exists in our offline database.
//
//  Arguments:  [servername] - Name of the server of interest.
//              DfsData.Resource assumed held on entry.
//
//  Returns:   PLIST_ENTRY: plist_entry of the offline structure.
//
//--------------------------------------------------------------------------

PLIST_ENTRY 
DfspGetOfflineEntry(
    PUNICODE_STRING ServerName)
{
    PLIST_ENTRY listEntry;
    PDFS_OFFLINE_SERVER server;

    listEntry = DfsData.OfflineRoots.Flink;

    while ( listEntry != &DfsData.OfflineRoots ) {
	server = CONTAINING_RECORD(
		     listEntry,
		     DFS_OFFLINE_SERVER,
		     ListEntry);
	if (RtlCompareUnicodeString(
		     &server->LogicalServerName, ServerName, TRUE) == 0) {
	    break;
	}
	listEntry = listEntry->Flink;
    }
    if (listEntry == &DfsData.OfflineRoots) {
	listEntry = NULL;
    }
    return listEntry;
}

//+-------------------------------------------------------------------------
//
//  Function:   DfspMarkServerOnline -- Marks a server online
//
//  Synopsis:   DfspMarkServerOnline removes the server entry from its offline
//              database, if it was marked as offline earlier.
//
//  Arguments:  [servername] - Name of the server of interest.
//
//  Returns:   NTSTATUS.
//
//--------------------------------------------------------------------------

NTSTATUS
DfspMarkServerOnline(
    PUNICODE_STRING ServerName)
{
    PLIST_ENTRY listEntry;
    PDFS_OFFLINE_SERVER server;
    NTSTATUS status;
    UNICODE_STRING dfsRootName;
    ULONG i;

    DfsDbgTrace(+1, Dbg, "DfspMarkServerOnline: %wZ\n", ServerName);

    //
    // Extract server name when there is \server\share
    //

    dfsRootName = *ServerName;
    if (dfsRootName.Buffer[0] == UNICODE_PATH_SEP) {
        for (i = 1;
             i < dfsRootName.Length/sizeof(WCHAR) &&
                  dfsRootName.Buffer[i] != UNICODE_PATH_SEP;
                     i++) {
            NOTHING;
        }
        dfsRootName.Length = (USHORT) ((i-1) * sizeof(WCHAR));
        dfsRootName.MaximumLength = dfsRootName.Length;
        dfsRootName.Buffer = &ServerName->Buffer[1];
    }

    ExAcquireResourceExclusiveLite( &DfsData.Resource, TRUE );

    listEntry = DfspGetOfflineEntry(&dfsRootName);

    if (listEntry != NULL) {
	RemoveEntryList(listEntry);
    }
    ExReleaseResourceLite( &DfsData.Resource );

    if (listEntry != NULL) {
	server = CONTAINING_RECORD(
		     listEntry,
		     DFS_OFFLINE_SERVER,
		     ListEntry);
	ExFreePool(server->LogicalServerName.Buffer);
	ExFreePool(server);
    }

    MupInvalidatePrefixTable();
    status = STATUS_SUCCESS;
    DfsDbgTrace(-1, Dbg, "DfspMarkServerOnline: status %x\n", ULongToPtr(status));
    return status;
}

//+-------------------------------------------------------------------------
//
//  Function:   DfspMarkServerOffline -- Marks a server offline
//
//  Synopsis:   DfspMarkServerOffline adds the server entry to its offline
//              database.
//
//  Arguments:  [servername] - Name of the server of interest.
//
//  Returns:   NTSTATUS.
//
//--------------------------------------------------------------------------

NTSTATUS
DfspMarkServerOffline(
   PUNICODE_STRING ServerName)
{
    UNICODE_STRING NewName;
    PLIST_ENTRY listEntry;
    PDFS_OFFLINE_SERVER server;
    UNICODE_STRING dfsRootName;
    ULONG i;

    DfsDbgTrace(+1, Dbg, "DfspMarkServerOffline: %wZ \n", ServerName);

    server = ExAllocatePoolWithTag( PagedPool, sizeof(DFS_OFFLINE_SERVER), ' puM' );
    if (server == NULL) {
	return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Extract server name when there is \server\share
    //

    dfsRootName = *ServerName;
    if (dfsRootName.Buffer[0] == UNICODE_PATH_SEP) {
        for (i = 1;
             i < dfsRootName.Length/sizeof(WCHAR) &&
                  dfsRootName.Buffer[i] != UNICODE_PATH_SEP;
                     i++) {
            NOTHING;
        }
        dfsRootName.Length = (USHORT) ((i-1) * sizeof(WCHAR));
        dfsRootName.MaximumLength = dfsRootName.Length;
        dfsRootName.Buffer = &ServerName->Buffer[1];
    }

    NewName.Buffer = ExAllocatePoolWithTag(
                          PagedPool, 
                          dfsRootName.Length + sizeof(WCHAR),
                          ' puM' );

    if (NewName.Buffer == NULL) {
	ExFreePool(server);
	return STATUS_INSUFFICIENT_RESOURCES;
    }

    NewName.MaximumLength = dfsRootName.Length + sizeof(WCHAR);
    NewName.Length = 0;

    RtlCopyUnicodeString(&NewName, &dfsRootName);

    server->LogicalServerName = NewName;

    ExAcquireResourceExclusiveLite( &DfsData.Resource, TRUE );

    listEntry = DfspGetOfflineEntry(&dfsRootName);

    if (listEntry == NULL) {
	InsertTailList( &DfsData.OfflineRoots, &server->ListEntry);	
    }
    ExReleaseResourceLite( &DfsData.Resource );

    if (listEntry != NULL) {
	ExFreePool(NewName.Buffer);
	ExFreePool(server);
    }
    DfsDbgTrace(-1, Dbg, "DfspMarkServerOffline exit STATUS_SUCCESS\n", 0);
    return STATUS_SUCCESS;
}



//+-------------------------------------------------------------------------
//
//  Function:   DfspIsRootOnline -- Checks if a server is online
//
//  Synopsis:   DfspIsRootOnline checks if the server is marked in its offline
//              database. If not, the server is online.
//
//  Arguments:  [servername] - Name of the server of interest.
//
//  Returns:   NTSTATUS. (Success or STATUS_DEVICE_OFFLINE)
//
//--------------------------------------------------------------------------


NTSTATUS
DfspIsRootOnline(
    PUNICODE_STRING FileName,
    BOOLEAN CSCAgentCreate)
{
    NTSTATUS status;
    PLIST_ENTRY listEntry;
    UNICODE_STRING dfsRootName;
    ULONG i;

    DfsDbgTrace(+1, Dbg, "DfspIsRootOnline: %wZ\n", FileName);

    if (CSCAgentCreate == TRUE) {
        DfsDbgTrace(-1, Dbg, "CSCAgent, returning success!\n", 0);
	status = STATUS_SUCCESS;
    }
    else {
	dfsRootName = *FileName;
	if (dfsRootName.Buffer[0] == UNICODE_PATH_SEP) {
	    for (i = 1;
		 i < dfsRootName.Length/sizeof(WCHAR) &&
		      dfsRootName.Buffer[i] != UNICODE_PATH_SEP;
		         i++) {
		NOTHING;
	    }
	    dfsRootName.Length = (USHORT) ((i-1) * sizeof(WCHAR));
	    dfsRootName.MaximumLength = dfsRootName.Length;
	    dfsRootName.Buffer = &FileName->Buffer[1];
	}

	ExAcquireResourceSharedLite( &DfsData.Resource, TRUE );
	listEntry = DfspGetOfflineEntry(&dfsRootName);
	ExReleaseResourceLite( &DfsData.Resource );

	if (listEntry != NULL) {
	    status = STATUS_DEVICE_OFF_LINE;
	}
	else {
	    status = STATUS_SUCCESS;
	}
    }

    DfsDbgTrace(-1, Dbg, "DfspIsRootOnline: ret 0x%x\n", ULongToPtr(status) );

    return status;
}

#if 0
NTSTATUS
DnrGetTargetInfo( 
    PDNR_CONTEXT pDnrContext)
{
    UNICODE_STRING dfsRoot, dfsShare;
    PUNICODE_STRING pFileName = &pDnrContext->FileName;
    USHORT i, j;
    NTSTATUS Status;

    dfsRoot.Length = dfsRoot.MaximumLength = 0;
    dfsRoot.Buffer = &pFileName->Buffer[1];

    for (i = 1;
            i < pFileName->Length/sizeof(WCHAR) &&
                pFileName->Buffer[i] != UNICODE_PATH_SEP;
                    i++) {

         NOTHING;

    }

    for (j = i + 1;
            j < pFileName->Length/sizeof(WCHAR) &&
                pFileName->Buffer[j] != UNICODE_PATH_SEP;
                    j++) {

         NOTHING;

    }

    if ((pFileName->Buffer[i] == UNICODE_PATH_SEP) && (j > i)) {

        dfsRoot.MaximumLength = dfsRoot.Length = (i - 1) * sizeof(WCHAR);
        dfsShare.MaximumLength = dfsShare.Length = (j - i - 1) * sizeof(WCHAR);
        dfsShare.Buffer = &pFileName->Buffer[i+1];

        Status = PktGetTargetInfo( pDnrContext->DCConnFile,
                                   &dfsRoot,
                                   &dfsShare,
                                   &pDnrContext->pNewTargetInfo );
    }
    else {
        Status = STATUS_BAD_NETWORK_PATH;
    }

    return Status;
}

#endif
NTSTATUS
DnrGetTargetInfo( 
    PDNR_CONTEXT pDnrContext)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PDFS_PKT_ENTRY pEntry;

    pEntry = pDnrContext->pPktEntry;
    if (pEntry != NULL)
    {
        pDnrContext->pNewTargetInfo = pEntry->pDfsTargetInfo;
        if (pDnrContext->pNewTargetInfo != NULL)
        {
            PktAcquireTargetInfo(pDnrContext->pNewTargetInfo);
        }
    }

    if (pDnrContext->pNewTargetInfo == NULL)
    {
        if (pDnrContext->pDfsTargetInfo != NULL)
        {
            pDnrContext->pNewTargetInfo = pDnrContext->pDfsTargetInfo;
            if (pDnrContext->pNewTargetInfo != NULL)
            {
                PktAcquireTargetInfo(pDnrContext->pNewTargetInfo);
            }
        }
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mup\fastio.h ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation
//
//  File:       fastio.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    8/11/93		Milans created
//
//-----------------------------------------------------------------------------

#ifndef _FASTIO_
#define _FASTIO_

extern FAST_IO_DISPATCH FastIoDispatch;
extern FS_FILTER_CALLBACKS FsFilterCallbacks;

#endif // _FASTIO_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mup\fastio.c ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation
//
//  File:       fastio.c
//
//  Contents:   Routines to implement Fast IO
//
//  Classes:
//
//  Functions:
//
//  History:    8/11/93         Milans created
//
//-----------------------------------------------------------------------------

#include "dfsprocs.h"
#include "fsctrl.h"
#include "fastio.h"
#include "fcbsup.h"

#define Dbg              (DEBUG_TRACE_FASTIO)

BOOLEAN
DfsFastIoCheckIfPossible (
    FILE_OBJECT *pFileObject,
    LARGE_INTEGER *pOffset,
    ULONG Length,
    BOOLEAN fWait,
    ULONG LockKey,
    BOOLEAN fCheckForRead,
    IO_STATUS_BLOCK *pIoStatusBlock,
    DEVICE_OBJECT *DeviceObject
    );

BOOLEAN
DfsFastIoRead(
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    DEVICE_OBJECT *DeviceObject
    );

BOOLEAN
DfsFastIoWrite(
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    DEVICE_OBJECT *DeviceObject
    );

BOOLEAN
DfsFastIoQueryBasicInfo(
    IN struct _FILE_OBJECT *FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_BASIC_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    DEVICE_OBJECT *DeviceObject
    );

BOOLEAN
DfsFastIoQueryStandardInfo(
    IN struct _FILE_OBJECT *FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_STANDARD_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    DEVICE_OBJECT *DeviceObject
    );

BOOLEAN
DfsFastIoLock(
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    PEPROCESS ProcessId,
    ULONG Key,
    BOOLEAN FailImmediately,
    BOOLEAN ExclusiveLock,
    OUT PIO_STATUS_BLOCK IoStatus,
    DEVICE_OBJECT *DeviceObject
    );

BOOLEAN
DfsFastIoUnlockSingle(
    IN struct _FILE_OBJECT *FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    PEPROCESS ProcessId,
    ULONG Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    DEVICE_OBJECT *DeviceObject
    );


BOOLEAN
DfsFastIoUnlockAll(
    IN struct _FILE_OBJECT *FileObject,
    PEPROCESS ProcessId,
    OUT PIO_STATUS_BLOCK IoStatus,
    DEVICE_OBJECT *DeviceObject
    );

BOOLEAN
DfsFastIoUnlockAllByKey(
    IN struct _FILE_OBJECT *FileObject,
    PVOID ProcessId,
    ULONG Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    DEVICE_OBJECT *DeviceObject
    );

BOOLEAN
DfsFastIoDeviceControl(
    IN struct _FILE_OBJECT *FileObject,
    IN BOOLEAN Wait,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN ULONG IoControlCode,
    OUT PIO_STATUS_BLOCK IoStatus,
    DEVICE_OBJECT *DeviceObject);

VOID
DfsFastIoDetachDevice(
    IN PDEVICE_OBJECT SourceDevice,
    IN PDEVICE_OBJECT TargetDevice);

BOOLEAN
DfsFastIoQueryNetworkOpenInfo(
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_NETWORK_OPEN_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject);

BOOLEAN
DfsFastIoMdlRead(
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject);

BOOLEAN
DfsFastIoMdlReadComplete(
    IN PFILE_OBJECT FileObject,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
DfsFastIoPrepareMdlWrite(
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
DfsFastIoMdlWriteComplete(
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
DfsFastIoReadCompressed(
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    OUT struct _COMPRESSED_DATA_INFO *CompressedDataInfo,
    IN ULONG CompressedDataInfoLength,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
DfsFastIoWriteCompressed(
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _COMPRESSED_DATA_INFO *CompressedDataInfo,
    IN ULONG CompressedDataInfoLength,
    IN PDEVICE_OBJECT DeviceObject);

BOOLEAN
DfsFastIoMdlReadCompleteCompressed(
    IN PFILE_OBJECT FileObject,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject);

BOOLEAN
DfsFastIoMdlWriteCompleteCompressed(
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject);

PFAST_IO_DISPATCH
DfsFastIoLookup(
    IN FILE_OBJECT *pFileObject,
    IN DEVICE_OBJECT *DeviceObject,
    IN PDEVICE_OBJECT *targetVdo);

NTSTATUS
DfsPreAcquireForSectionSynchronization(
    IN PFS_FILTER_CALLBACK_DATA Data,
    OUT PVOID *CompletionContext);

NTSTATUS
DfsPreReleaseForSectionSynchronization(
    IN PFS_FILTER_CALLBACK_DATA Data,
    OUT PVOID *CompletionContext);

NTSTATUS
DfsPreAcquireForModWrite(
    IN PFS_FILTER_CALLBACK_DATA Data,
    OUT PVOID *CompletionContext);

NTSTATUS
DfsPreReleaseForModWrite(
    IN PFS_FILTER_CALLBACK_DATA Data,
    OUT PVOID *CompletionContext);

NTSTATUS
DfsPreAcquireForCcFlush(
    IN PFS_FILTER_CALLBACK_DATA Data,
    OUT PVOID *CompletionContext);

NTSTATUS
DfsPreReleaseForCcFlush(
    IN PFS_FILTER_CALLBACK_DATA Data,
    OUT PVOID *CompletionContext);

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, DfsFastIoCheckIfPossible )
#pragma alloc_text( PAGE, DfsFastIoRead )
#pragma alloc_text( PAGE, DfsFastIoWrite )
#pragma alloc_text( PAGE, DfsFastIoQueryBasicInfo )
#pragma alloc_text( PAGE, DfsFastIoQueryStandardInfo )
#pragma alloc_text( PAGE, DfsFastIoLock )
#pragma alloc_text( PAGE, DfsFastIoUnlockSingle )
#pragma alloc_text( PAGE, DfsFastIoUnlockAll )
#pragma alloc_text( PAGE, DfsFastIoUnlockAllByKey )
#pragma alloc_text( PAGE, DfsFastIoDeviceControl )
#pragma alloc_text( PAGE, DfsFastIoDetachDevice )
#pragma alloc_text( PAGE, DfsFastIoQueryNetworkOpenInfo )
#pragma alloc_text( PAGE, DfsFastIoMdlRead )
#pragma alloc_text( PAGE, DfsFastIoMdlReadComplete )
#pragma alloc_text( PAGE, DfsFastIoPrepareMdlWrite )
#pragma alloc_text( PAGE, DfsFastIoMdlWriteComplete )
#pragma alloc_text( PAGE, DfsFastIoReadCompressed )
#pragma alloc_text( PAGE, DfsFastIoWriteCompressed )
#pragma alloc_text( PAGE, DfsFastIoMdlReadCompleteCompressed )
#pragma alloc_text( PAGE, DfsFastIoMdlWriteCompleteCompressed )
#pragma alloc_text( PAGE, DfsFastIoLookup )
#pragma alloc_text( PAGE, DfsPreAcquireForSectionSynchronization )
#pragma alloc_text( PAGE, DfsPreReleaseForSectionSynchronization )
#pragma alloc_text( PAGE, DfsPreAcquireForModWrite )
#pragma alloc_text( PAGE, DfsPreReleaseForModWrite )
#pragma alloc_text( PAGE, DfsPreAcquireForCcFlush )
#pragma alloc_text( PAGE, DfsPreReleaseForCcFlush )

#endif // ALLOC_PRAGMA

//
//  Note: We don't register the 6 Acquire/Release FastIo Dispatches here
//  because we filter this operations through the FsFilterCallback interface
//  which allows DFS to interop better with file system filters.
//

FAST_IO_DISPATCH FastIoDispatch =
{
    sizeof(FAST_IO_DISPATCH),
    DfsFastIoCheckIfPossible,           //  CheckForFastIo
    DfsFastIoRead,                      //  FastIoRead
    DfsFastIoWrite,                     //  FastIoWrite
    DfsFastIoQueryBasicInfo,            //  FastIoQueryBasicInfo
    DfsFastIoQueryStandardInfo,         //  FastIoQueryStandardInfo
    DfsFastIoLock,                      //  FastIoLock
    DfsFastIoUnlockSingle,              //  FastIoUnlockSingle
    DfsFastIoUnlockAll,                 //  FastIoUnlockAll
    DfsFastIoUnlockAllByKey,            //  FastIoUnlockAllByKey
    NULL,                               //  FastIoDeviceControl
    NULL,                               //  AcquireFileForNtCreateSection
    NULL,                               //  ReleaseFileForNtCreateSection
    DfsFastIoDetachDevice,              //  FastIoDetachDevice
    DfsFastIoQueryNetworkOpenInfo,      //  FastIoQueryNetworkOpenInfo
    NULL,                               //  AcquireForModWrite
    DfsFastIoMdlRead,                   //  MdlRead
    DfsFastIoMdlReadComplete,           //  MdlReadComplete
    DfsFastIoPrepareMdlWrite,           //  PrepareMdlWrite
    DfsFastIoMdlWriteComplete,          //  MdlWriteComplete
    DfsFastIoReadCompressed,            //  FastIoReadCompressed
    DfsFastIoWriteCompressed,           //  FastIoWriteCompressed
    DfsFastIoMdlReadCompleteCompressed, //  MdlReadCompleteCompressed
    DfsFastIoMdlWriteCompleteCompressed,//  MdlWriteCompleteCompressed
    NULL,                               //  FastIoQueryOpen
    NULL,                               //  ReleaseForModWrite
    NULL,                               //  AcquireForCcFlush
    NULL,                               //  ReleaseForCcFlush
};

//
//  NOTE: Dfs has been changed to use the FsFilter interfaces to intercept the
//        Acquire/Release calls traditionally supported via the FastIo path
//        to provide better file system filter driver support.
//
//        By hooking these operations via the FsFilter interfaces, Dfs is able 
//        to propogate the additional information provided through these 
//        interfaces to file system filters as it redirects the operation to
//        a different driver stack (such as the device stack for 
//        LanmanRedirector or WebDavRedirector).
//        
//        This also provides a more consistent interface for these 
//        Acquire/Release operations for file system filter drivers.  With Dfs
//        supporting this interface, filters will only get called through the
//        FsFilter interfaces for these operations on both local and remote
//        file systems.
//

FS_FILTER_CALLBACKS FsFilterCallbacks =
{
    sizeof( FS_FILTER_CALLBACKS ),
    0,
    DfsPreAcquireForSectionSynchronization,     //  PreAcquireForSectionSynchronization
    NULL,                                       //  PostAcquireForSectionSynchronization
    DfsPreReleaseForSectionSynchronization,     //  PreReleaseForSectionSynchronization
    NULL,                                       //  PostReleaseForSectionSynchronization
    DfsPreAcquireForCcFlush,                    //  PreAcquireForCcFlush
    NULL,                                       //  PostAcquireForCcFlush
    DfsPreReleaseForCcFlush,                    //  PreReleaseForCcFlush
    NULL,                                       //  PostReleaseForCcFlush
    DfsPreAcquireForModWrite,                   //  PreAcquireForModWrite
    NULL,                                       //  PostAcquireForModWrite
    DfsPreReleaseForModWrite,                   //  PreReleaseForModWrite
    NULL                                        //  PostReleaseForModWrite
};
    

//
// Macro to see if a PFAST_IO_DISPATCH has a particular field
//

#define IS_VALID_INDEX(pfio, e)                                 \
    ((pfio != NULL)                                       &&    \
     (pfio->SizeOfFastIoDispatch >=                             \
        (offsetof(FAST_IO_DISPATCH, e) + sizeof(PVOID)))  &&    \
     (pfio->e != NULL)                                          \
    )


//+----------------------------------------------------------------------------
//
//  Function:   DfsFastIoLookup
//
//  Synopsis:   Given a file object, this routine will locate the fast IO
//              dispatch table for the underlying provider
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

PFAST_IO_DISPATCH
DfsFastIoLookup(
    IN FILE_OBJECT *pFileObject,
    IN DEVICE_OBJECT *DeviceObject,
    OUT PDEVICE_OBJECT *targetVdo)
{
    PFAST_IO_DISPATCH   pFastIoTable;

    *targetVdo = NULL;

    DfsDbgTrace(+1, Dbg, "DfsFastIoLookup: Entered\n", 0);

    if (DeviceObject->DeviceType == FILE_DEVICE_DFS) {

        //
        // In this case we now need to do an DFS_FCB Lookup to figure out where to
        // go from here.
        //

        TYPE_OF_OPEN    TypeOfOpen;
        PDFS_VCB            Vcb;
        PDFS_FCB            Fcb;

        TypeOfOpen = DfsDecodeFileObject( pFileObject, &Vcb, &Fcb);

        DfsDbgTrace(0, Dbg, "Fcb = %08lx\n", Fcb);

        if (TypeOfOpen == RedirectedFileOpen) {

            //
            // In this case the target device is in the Fcb itself.
            //

            *targetVdo = Fcb->TargetDevice;

            pFastIoTable = (*targetVdo)->DriverObject->FastIoDispatch;

            DfsDbgTrace(0,Dbg, "DfsFastIoLookup: DvObj: %08lx",DeviceObject);
            DfsDbgTrace(0, Dbg, "TargetVdo %08lx\n", *targetVdo);
            DfsDbgTrace(-1,Dbg, "DfsFastIoLookup: Exit-> %08lx\n",pFastIoTable );

            return(pFastIoTable);

        } else {

            //
            // This can happen for opens against mup device, so its legal
            // to return NULL here. Dont assert (bug 422334)
            //

            DfsDbgTrace( 0, Dbg, "DfsFastIoLookup: TypeOfOpen      = %s\n",
                ( (TypeOfOpen == UnopenedFileObject) ? "UnopenedFileObject":
                (TypeOfOpen == LogicalRootDeviceOpen) ? "LogicalRootDeviceOpen":
                                                        "???") );

            DfsDbgTrace(-1,Dbg, "DfsFastIoLookup: Exit -> %08lx\n", NULL );

            return(NULL);

        }

    } else if (DeviceObject->DeviceType == FILE_DEVICE_DFS_FILE_SYSTEM) {

        DfsDbgTrace(0, Dbg, "DfsFastIoLookup: Dfs File System\n", 0);

        return( NULL );

    } else {

        //
        // This is an unknown device object type and we dont know what to do
        //

        DfsDbgTrace(-1,Dbg, "DfsFastIoLookup: Exit -> %08lx\n", NULL );

        return(NULL);

    }

}


//+----------------------------------------------------------------------------
//
//  Function:   DfsFastIoCheckIfPossible
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

BOOLEAN
DfsFastIoCheckIfPossible (
    FILE_OBJECT *pFileObject,
    LARGE_INTEGER *pOffset,
    ULONG Length,
    BOOLEAN fWait,
    ULONG LockKey,
    BOOLEAN fCheckForRead,
    IO_STATUS_BLOCK *pIoStatusBlock,
    PDEVICE_OBJECT DeviceObject)
{
    PFAST_IO_DISPATCH   pFastIoTable;
    PDEVICE_OBJECT      targetVdo;
    BOOLEAN             fPossible;

    DfsDbgTrace(+1, Dbg, "DfsFastIoCheckIfPossible Enter \n", 0);
    pFastIoTable = DfsFastIoLookup(pFileObject, DeviceObject, &targetVdo);


    if ( IS_VALID_INDEX(pFastIoTable, FastIoCheckIfPossible) ) {

        fPossible = pFastIoTable->FastIoCheckIfPossible(
                        pFileObject,
                        pOffset,
                        Length,
                        fWait,
                        LockKey,
                        fCheckForRead,
                        pIoStatusBlock,
                        targetVdo);

    } else {

        fPossible = FALSE;

    }

    DfsDbgTrace(-1, Dbg, "DfsFastIoCheckIfPossible Exit \n", 0);

    return(fPossible);
}

//+----------------------------------------------------------------------------
//
//  Function:   DfsFastIoRead
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

BOOLEAN
DfsFastIoRead(
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    PDEVICE_OBJECT DeviceObject
    )
{
    PFAST_IO_DISPATCH pFastIoTable;
    PDEVICE_OBJECT      targetVdo;
    BOOLEAN             fPossible;

    DfsDbgTrace(+1, Dbg, "DfsFastIoRead Enter \n", 0);
    pFastIoTable = DfsFastIoLookup(FileObject, DeviceObject, &targetVdo);

    if ( IS_VALID_INDEX(pFastIoTable, FastIoRead) ) {

        fPossible =  pFastIoTable->FastIoRead(
                        FileObject,
                        FileOffset,
                        Length,
                        Wait,
                        LockKey,
                        Buffer,
                        IoStatus,
                        targetVdo);

    } else {

        fPossible = FALSE;

    }

    DfsDbgTrace(-1, Dbg, "DfsFastIoRead Exit \n", 0);

    return(fPossible);

}

//+----------------------------------------------------------------------------
//
//  Function:   DfsFastIoWrite
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

BOOLEAN
DfsFastIoWrite(
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    PDEVICE_OBJECT DeviceObject
    )
{
    PFAST_IO_DISPATCH pFastIoTable;
    PDEVICE_OBJECT      targetVdo;
    BOOLEAN             fPossible;

    DfsDbgTrace(+1, Dbg, "DfsFastIoWrite Enter \n", 0);

    pFastIoTable = DfsFastIoLookup(FileObject, DeviceObject, &targetVdo);


    if ( IS_VALID_INDEX(pFastIoTable, FastIoWrite) ) {

        fPossible = pFastIoTable->FastIoWrite(
                        FileObject,
                        FileOffset,
                        Length,
                        Wait,
                        LockKey,
                        Buffer,
                        IoStatus,
                        targetVdo);

    } else {

        fPossible = FALSE;

    }

    DfsDbgTrace(-1, Dbg, "DfsFastIoWrite Exit \n", 0);

    return(fPossible);

}

//+----------------------------------------------------------------------------
//
//  Function:   DfsFastIoQueryBasicInfo
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

BOOLEAN
DfsFastIoQueryBasicInfo(
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_BASIC_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    PDEVICE_OBJECT DeviceObject)
{
    PFAST_IO_DISPATCH pFastIoTable;
    PDEVICE_OBJECT      targetVdo;
    BOOLEAN             fPossible;

    DfsDbgTrace(+1, Dbg, "DfsFastIoQueryBasicInfo Enter \n", 0);

    pFastIoTable = DfsFastIoLookup(FileObject, DeviceObject, &targetVdo);

    if ( IS_VALID_INDEX(pFastIoTable, FastIoQueryBasicInfo) ) {

        fPossible = pFastIoTable->FastIoQueryBasicInfo(
                        FileObject,
                        Wait,
                        Buffer,
                        IoStatus,
                        targetVdo);

    } else {

        fPossible = FALSE;

    }

    DfsDbgTrace(-1, Dbg, "DfsFastIoQueryBasicInfo Exit \n", 0);

    return(fPossible);

}

//+----------------------------------------------------------------------------
//
//  Function:   DfsFastIoQueryStandardInfo
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

BOOLEAN
DfsFastIoQueryStandardInfo(
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_STANDARD_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    PDEVICE_OBJECT DeviceObject)
{
    PFAST_IO_DISPATCH pFastIoTable;
    PDEVICE_OBJECT      targetVdo;
    BOOLEAN             fPossible;

    DfsDbgTrace(+1, Dbg, "DfsFastIoQueryStandardInfo Enter \n", 0);

    pFastIoTable = DfsFastIoLookup(FileObject, DeviceObject, &targetVdo);

    if ( IS_VALID_INDEX(pFastIoTable, FastIoQueryStandardInfo) ) {

        fPossible = pFastIoTable->FastIoQueryStandardInfo(
                        FileObject,
                        Wait,
                        Buffer,
                        IoStatus,
                        targetVdo);

    } else {

        fPossible = FALSE;

    }

    DfsDbgTrace(-1, Dbg, "DfsFastIoQueryStandardInfo Exit \n", 0);

    return(fPossible);

}

//+----------------------------------------------------------------------------
//
//  Function:   DfsFastIoLock
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

BOOLEAN
DfsFastIoLock(
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    PEPROCESS ProcessId,
    ULONG Key,
    BOOLEAN FailImmediately,
    BOOLEAN ExclusiveLock,
    OUT PIO_STATUS_BLOCK IoStatus,
    PDEVICE_OBJECT DeviceObject
    )
{
    PFAST_IO_DISPATCH pFastIoTable;
    PDEVICE_OBJECT      targetVdo;
    BOOLEAN             fPossible;

    DfsDbgTrace(+1, Dbg, "DfsFastIoLock Enter \n", 0);

    pFastIoTable = DfsFastIoLookup(FileObject, DeviceObject, &targetVdo);

    if ( IS_VALID_INDEX(pFastIoTable, FastIoLock) ) {

        fPossible = pFastIoTable->FastIoLock(
                        FileObject,
                        FileOffset,
                        Length,
                        ProcessId,
                        Key,
                        FailImmediately,
                        ExclusiveLock,
                        IoStatus,
                        targetVdo);

    } else {

        fPossible = FALSE;

    }

    DfsDbgTrace(-1, Dbg, "DfsFastIoLock Exit \n", 0);

    return(fPossible);

}

//+----------------------------------------------------------------------------
//
//  Function:   DfsFastIoUnlockSingle
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

BOOLEAN
DfsFastIoUnlockSingle(
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    PEPROCESS ProcessId,
    ULONG Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    PDEVICE_OBJECT DeviceObject)
{
    PFAST_IO_DISPATCH pFastIoTable;
    PDEVICE_OBJECT      targetVdo;
    BOOLEAN             fPossible;

    DfsDbgTrace(+1, Dbg, "DfsFastIoUnlockSingle Enter \n", 0);

    pFastIoTable = DfsFastIoLookup(FileObject, DeviceObject, &targetVdo);

    if ( IS_VALID_INDEX(pFastIoTable, FastIoUnlockSingle) ) {

        fPossible = pFastIoTable->FastIoUnlockSingle(
                        FileObject,
                        FileOffset,
                        Length,
                        ProcessId,
                        Key,
                        IoStatus,
                        targetVdo);

    } else {

        fPossible = FALSE;

    }

    DfsDbgTrace(-1, Dbg, "DfsFastIoUnlockSingle Exit \n", 0);

    return(fPossible);

}

//+----------------------------------------------------------------------------
//
//  Function:   DfsFastIoUnlockAll
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

BOOLEAN
DfsFastIoUnlockAll(
    IN PFILE_OBJECT FileObject,
    PEPROCESS ProcessId,
    OUT PIO_STATUS_BLOCK IoStatus,
    PDEVICE_OBJECT DeviceObject
    )
{
    PFAST_IO_DISPATCH pFastIoTable;
    PDEVICE_OBJECT      targetVdo;
    BOOLEAN             fPossible;

    DfsDbgTrace(+1, Dbg, "DfsFastIoUnlockAll Enter \n", 0);

    pFastIoTable = DfsFastIoLookup(FileObject, DeviceObject, &targetVdo);

    if ( IS_VALID_INDEX(pFastIoTable, FastIoUnlockAll) ) {

        fPossible = pFastIoTable->FastIoUnlockAll(
                        FileObject,
                        ProcessId,
                        IoStatus,
                        targetVdo);

    } else {

        fPossible = FALSE;

    }

    DfsDbgTrace(-1, Dbg, "DfsFastIoUnlockAll Exit \n", 0);

    return(fPossible);

}

//+----------------------------------------------------------------------------
//
//  Function:   FastIoUnlockAllByKey
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

BOOLEAN
DfsFastIoUnlockAllByKey(
    IN PFILE_OBJECT FileObject,
    PVOID ProcessId,
    ULONG Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    PDEVICE_OBJECT DeviceObject
    )
{
    PFAST_IO_DISPATCH pFastIoTable;
    PDEVICE_OBJECT      targetVdo;
    BOOLEAN             fPossible;

    DfsDbgTrace(+1, Dbg, "DfsFastIoUnlockAllByKey Enter \n", 0);

    pFastIoTable = DfsFastIoLookup(FileObject, DeviceObject, &targetVdo);

    if ( IS_VALID_INDEX(pFastIoTable, FastIoUnlockAllByKey) ) {

        fPossible = pFastIoTable->FastIoUnlockAllByKey(
                        FileObject,
                        ProcessId,
                        Key,
                        IoStatus,
                        targetVdo);

    } else {

        fPossible = FALSE;

    }

    DfsDbgTrace(-1, Dbg, "DfsFastIoUnlockAllByKey Exit \n", 0);

    return(fPossible);

}

//+----------------------------------------------------------------------------
//
//  Function:   DfsFastIoDeviceControl
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

BOOLEAN
DfsFastIoDeviceControl(
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN ULONG IoControlCode,
    OUT PIO_STATUS_BLOCK IoStatus,
    PDEVICE_OBJECT DeviceObject
    )
{
    PFAST_IO_DISPATCH pFastIoTable;
    PDEVICE_OBJECT      targetVdo;
    BOOLEAN             fPossible;
    TYPE_OF_OPEN        TypeOfOpen;
    PDFS_VCB                Vcb;
    PDFS_FCB                Fcb;

    DfsDbgTrace(+1, Dbg, "DfsFastIoDeviceControl Enter \n", 0);

    pFastIoTable = DfsFastIoLookup(FileObject, DeviceObject, &targetVdo);

    if ( IS_VALID_INDEX(pFastIoTable, FastIoDeviceControl) ) {

        fPossible = pFastIoTable->FastIoDeviceControl(
                        FileObject,
                        Wait,
                        InputBuffer,
                        InputBufferLength,
                        OutputBuffer,
                        OutputBufferLength,
                        IoControlCode,
                        IoStatus,
                        targetVdo);

    } else {

        fPossible = FALSE;

    }

    DfsDbgTrace(-1, Dbg, "DfsFastIoDeviceControl Exit \n", 0);

    return(fPossible);

}

//+----------------------------------------------------------------------------
//
//  Function:   DfsFastIoDetachDevice, public
//
//  Synopsis:   This routine is a different from the rest of the fast io
//              routines. It is called when a device object is being deleted,
//              and that device object has an attached device. The semantics
//              of this routine are "You attached to a device object that now
//              needs to be deleted; please detach from the said device
//              object."
//
//  Arguments:  [SourceDevice] -- Our device, the one that we created to
//                      attach ourselves to the target device.
//              [TargetDevice] -- Their device, the one that we are attached
//                      to.
//
//  Returns:    Nothing - we must succeed.
//
//-----------------------------------------------------------------------------

VOID
DfsFastIoDetachDevice(
    IN PDEVICE_OBJECT SourceDevice,
    IN PDEVICE_OBJECT TargetDevice)
{
    NOTHING;
}

BOOLEAN
DfsFastIoQueryNetworkOpenInfo(
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_NETWORK_OPEN_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject)
{
    PFAST_IO_DISPATCH pFastIoTable;
    PDEVICE_OBJECT      targetVdo;
    BOOLEAN             fPossible;

    DfsDbgTrace(+1, Dbg, "DfsFastIoQueryNetworkOpenInfo Enter \n", 0);

    pFastIoTable = DfsFastIoLookup(FileObject, DeviceObject, &targetVdo);

    if ( IS_VALID_INDEX(pFastIoTable, FastIoQueryNetworkOpenInfo) ) {

        fPossible = pFastIoTable->FastIoQueryNetworkOpenInfo(
                        FileObject,
                        Wait,
                        Buffer,
                        IoStatus,
                        targetVdo);

    } else {

        fPossible = FALSE;

        IoStatus->Status = STATUS_NOT_SUPPORTED;

    }

    DfsDbgTrace(-1, Dbg, "DfsFastIoQueryNetworkOpenInfo Exit \n", 0);

    return( fPossible );

}

BOOLEAN
DfsFastIoMdlRead(
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject)
{
    PFAST_IO_DISPATCH pFastIoTable;
    PDEVICE_OBJECT      targetVdo;
    BOOLEAN             fPossible;

    DfsDbgTrace(+1, Dbg, "DfsFastIoMdlRead Enter \n", 0);

    pFastIoTable = DfsFastIoLookup(FileObject, DeviceObject, &targetVdo);

    if ( IS_VALID_INDEX(pFastIoTable, MdlRead) ) {

        fPossible = pFastIoTable->MdlRead(
                        FileObject,
                        FileOffset,
                        Length,
                        LockKey,
                        MdlChain,
                        IoStatus,
                        targetVdo);

    } else {

        fPossible = FsRtlMdlReadDev(
                        FileObject,
                        FileOffset,
                        Length,
                        LockKey,
                        MdlChain,
                        IoStatus,
                        targetVdo);

    }

    DfsDbgTrace(-1, Dbg, "DfsFastIoMdlRead Exit \n", 0);

    return( fPossible );
}

BOOLEAN
DfsFastIoMdlReadComplete(
    IN PFILE_OBJECT FileObject,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject
    )
{
    PFAST_IO_DISPATCH pFastIoTable;
    PDEVICE_OBJECT      targetVdo;
    BOOLEAN             fResult;

    DfsDbgTrace(+1, Dbg, "DfsFastIoMdlReadComplete Enter \n", 0);

    pFastIoTable = DfsFastIoLookup(FileObject, DeviceObject, &targetVdo);


    if ( IS_VALID_INDEX(pFastIoTable, MdlReadComplete) ) {

        fResult = pFastIoTable->MdlReadComplete(
                        FileObject,
                        MdlChain,
                        targetVdo);

    } else {

        fResult = FsRtlMdlReadCompleteDev(
                        FileObject,
                        MdlChain,
                        targetVdo);

    }

    DfsDbgTrace(-1, Dbg, "DfsFastIoMdlReadComplete Exit \n", 0);

    return( fResult );

}

BOOLEAN
DfsFastIoPrepareMdlWrite(
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject)
{
    PFAST_IO_DISPATCH pFastIoTable;
    PDEVICE_OBJECT      targetVdo;
    BOOLEAN             fPossible;

    DfsDbgTrace(+1, Dbg, "DfsFastIoPrepareMdlWrite Enter \n", 0);

    pFastIoTable = DfsFastIoLookup(FileObject, DeviceObject, &targetVdo);


    if ( IS_VALID_INDEX(pFastIoTable, PrepareMdlWrite) ) {

        fPossible = pFastIoTable->PrepareMdlWrite(
                        FileObject,
                        FileOffset,
                        Length,
                        LockKey,
                        MdlChain,
                        IoStatus,
                        targetVdo);

    } else {

        fPossible = FsRtlPrepareMdlWriteDev(
                        FileObject,
                        FileOffset,
                        Length,
                        LockKey,
                        MdlChain,
                        IoStatus,
                        targetVdo);

    }

    DfsDbgTrace(-1, Dbg, "DfsFastIoPrepareMdlWrite Exit \n", 0);

    return( fPossible );
}

BOOLEAN
DfsFastIoMdlWriteComplete(
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject
    )
{
    PFAST_IO_DISPATCH pFastIoTable;
    PDEVICE_OBJECT      targetVdo;
    BOOLEAN             fResult;

    DfsDbgTrace(+1, Dbg, "DfsFastIoMdlWriteComplete Enter \n", 0);

    pFastIoTable = DfsFastIoLookup(FileObject, DeviceObject, &targetVdo);


    if ( IS_VALID_INDEX(pFastIoTable, MdlWriteComplete) ) {

        fResult = pFastIoTable->MdlWriteComplete(
                        FileObject,
                        FileOffset,
                        MdlChain,
                        targetVdo);

    } else {

        fResult = FsRtlMdlWriteCompleteDev(
                        FileObject,
                        FileOffset,
                        MdlChain,
                        targetVdo);

    }

    DfsDbgTrace(-1, Dbg, "DfsFastIoMdlWriteComplete Exit \n", 0);

    return( fResult );
}

BOOLEAN
DfsFastIoReadCompressed(
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    OUT struct _COMPRESSED_DATA_INFO *CompressedDataInfo,
    IN ULONG CompressedDataInfoLength,
    IN PDEVICE_OBJECT DeviceObject)
{
    PFAST_IO_DISPATCH pFastIoTable;
    PDEVICE_OBJECT      targetVdo;
    BOOLEAN             fPossible;

    DfsDbgTrace(+1, Dbg, "DfsFastIoReadCompressed Enter \n", 0);

    pFastIoTable = DfsFastIoLookup(FileObject, DeviceObject, &targetVdo);


    if ( IS_VALID_INDEX(pFastIoTable, FastIoReadCompressed) ) {

        fPossible = pFastIoTable->FastIoReadCompressed(
                        FileObject,
                        FileOffset,
                        Length,
                        LockKey,
                        Buffer,
                        MdlChain,
                        IoStatus,
                        CompressedDataInfo,
                        CompressedDataInfoLength,
                        targetVdo);

    } else {

        fPossible = FALSE;

        IoStatus->Status = STATUS_NOT_SUPPORTED;

    }

    DfsDbgTrace(-1, Dbg, "DfsFastIoReadCompressed Exit \n", 0);

    return( fPossible );

}


BOOLEAN
DfsFastIoWriteCompressed(
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _COMPRESSED_DATA_INFO *CompressedDataInfo,
    IN ULONG CompressedDataInfoLength,
    IN PDEVICE_OBJECT DeviceObject)
{
    PFAST_IO_DISPATCH pFastIoTable;
    PDEVICE_OBJECT      targetVdo;
    BOOLEAN             fPossible;

    DfsDbgTrace(+1, Dbg, "DfsFastIoWriteCompressed Enter \n", 0);

    pFastIoTable = DfsFastIoLookup(FileObject, DeviceObject, &targetVdo);


    if ( IS_VALID_INDEX(pFastIoTable, FastIoWriteCompressed) ) {

        fPossible = pFastIoTable->FastIoWriteCompressed(
                        FileObject,
                        FileOffset,
                        Length,
                        LockKey,
                        Buffer,
                        MdlChain,
                        IoStatus,
                        CompressedDataInfo,
                        CompressedDataInfoLength,
                        targetVdo);

    } else {

        fPossible = FALSE;

        IoStatus->Status = STATUS_NOT_SUPPORTED;

    }

    DfsDbgTrace(-1, Dbg, "DfsFastIoWriteCompressed Exit \n", 0);

    return( fPossible );

}

BOOLEAN
DfsFastIoMdlReadCompleteCompressed(
    IN PFILE_OBJECT FileObject,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject)
{
    PFAST_IO_DISPATCH pFastIoTable;
    PDEVICE_OBJECT      targetVdo;
    BOOLEAN             fResult;

    DfsDbgTrace(+1, Dbg, "DfsFastIoMdlReadCompleteCompressed Enter \n", 0);

    pFastIoTable = DfsFastIoLookup(FileObject, DeviceObject, &targetVdo);

    if ( IS_VALID_INDEX(pFastIoTable, MdlReadCompleteCompressed) ) {

        fResult = pFastIoTable->MdlReadCompleteCompressed(
                        FileObject,
                        MdlChain,
                        targetVdo);

    } else {

        fResult = FALSE;

    }

    DfsDbgTrace(-1, Dbg, "DfsFastIoMdlReadCompleteCompressed Exit \n", 0);

    return( fResult );
}

BOOLEAN
DfsFastIoMdlWriteCompleteCompressed(
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject)
{
    PFAST_IO_DISPATCH pFastIoTable;
    PDEVICE_OBJECT      targetVdo;
    BOOLEAN             fResult;

    DfsDbgTrace(+1, Dbg, "DfsFastIoMdlWriteCompleteCompressed Enter \n", 0);

    pFastIoTable = DfsFastIoLookup(FileObject, DeviceObject, &targetVdo);

    if ( IS_VALID_INDEX(pFastIoTable, MdlWriteCompleteCompressed) ) {

        fResult = pFastIoTable->MdlWriteCompleteCompressed(
                        FileObject,
                        FileOffset,
                        MdlChain,
                        targetVdo);

    } else {

        fResult = FALSE;

    }

    DfsDbgTrace(-1, Dbg, "DfsFastIoMdlWriteCompleteCompressed Exit \n", 0);

    return( fResult );

}

//+----------------------------------------------------------------------------
//
//  Function:   DfsPreAcquireForSectionSynchronization
//
//  Synopsis:   This is the equivalent to FastIoAcquireFileForNtCreateSection. 
//              Dfs receives this callback through the FsFilter interfaces
//              of the FsRtl package in the kernel. 
//
//              This is the time to do the work necessary to synchronize
//              for memory-mapped section creation.  If this operation
//              should be redirected to an underlying FS, the parameters will
//              be changed accordingly so that the operation is redirect when 
//              this callback returns.
//
//  Arguments:  [Data] -- The structure that contains the relevent parameters
//                        to this operation, like the FileObject and DeviceObject.
//              [CompletionContext] - Provides a pointer for a context to be
//                        past from the pre to post operation.  Since Dfs
//                        does not need a post operation, this parameter is not
//                        used.
//
//  Returns:    STATUS_SUCCESS
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsPreAcquireForSectionSynchronization(
    IN PFS_FILTER_CALLBACK_DATA Data,
    OUT PVOID *CompletionContext)
{
    PDEVICE_OBJECT targetVdo;
    PFSRTL_COMMON_FCB_HEADER header;
    PDFS_FCB pFcb;

    UNREFERENCED_PARAMETER( CompletionContext );

    DfsFastIoLookup( Data->FileObject, Data->DeviceObject, &targetVdo );

    pFcb = DfsLookupFcb(Data->FileObject);

    //
    //  If we've got a valid pFcb and pFcb->FileObject, we need to switch
    //  this operation to the other device stack and file object.
    //
    
    if (targetVdo != NULL &&
            pFcb != NULL && 
                pFcb->FileObject != NULL) {

        IoSetTopLevelIrp( (PIRP) FSRTL_FSP_TOP_LEVEL_IRP );
        
        Data->FileObject = pFcb->FileObject;
        Data->DeviceObject = targetVdo;

    } else if ((header = Data->FileObject->FsContext) && header->Resource) {

        IoSetTopLevelIrp( (PIRP) FSRTL_FSP_TOP_LEVEL_IRP );

        ExAcquireResourceExclusiveLite( header->Resource, TRUE );
        
    } else {

        NOTHING;
    }
    
    return STATUS_SUCCESS;
}

//+----------------------------------------------------------------------------
//
//  Function:   DfsPreReleaseForSectionSynchronization
//
//  Synopsis:   This is the equivalent to FastIoReleaseFileForNtCreateSection. 
//              Dfs receives this callback through the FsFilter interfaces
//              of the FsRtl package in the kernel. 
//
//              This is the time to do the work necessary to end the
//              synchronization operations taken to create a memory-mapped
//              section.  If this operation should be redirected to an 
//              underlying FS, the parameters will be changed accordingly so 
//              that the operation is redirect when this callback returns.
//
//  Arguments:  [Data] -- The structure that contains the relevent parameters
//                        to this operation, like the FileObject and DeviceObject.
//              [CompletionContext] - Provides a pointer for a context to be
//                        past from the pre to post operation.  Since Dfs
//                        does not need a post operation, this parameter is not
//                        used.
//
//  Returns:    STATUS_SUCCESS
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsPreReleaseForSectionSynchronization(
    IN PFS_FILTER_CALLBACK_DATA Data,
    OUT PVOID *CompletionContext)
{
    PDEVICE_OBJECT targetVdo;
    PFSRTL_COMMON_FCB_HEADER header;
    PDFS_FCB pFcb;

    UNREFERENCED_PARAMETER( CompletionContext );

    DfsFastIoLookup( Data->FileObject, Data->DeviceObject, &targetVdo );

    pFcb = DfsLookupFcb(Data->FileObject);

    if (targetVdo != NULL &&
            pFcb != NULL && 
                pFcb->FileObject != NULL) {
        
        IoSetTopLevelIrp( (PIRP) NULL );
        Data->DeviceObject = targetVdo;

    } else if ((header = Data->FileObject->FsContext) && header->Resource) {
    
        IoSetTopLevelIrp( (PIRP) NULL );

        ExReleaseResourceLite( header->Resource );

    } else {

        NOTHING;
    }

    return STATUS_SUCCESS;
}

//+----------------------------------------------------------------------------
//
//  Function:   DfsPreAcquireForModWrite
//
//  Synopsis:   This is the equivalent to FastIoAcquireForModWrite. 
//              Dfs receives this callback through the FsFilter interfaces
//              of the FsRtl package in the kernel. 
//
//              This is the time to do the work necessary to synchronize
//              for modified page writer operations.  If this operation
//              should be redirected to an underlying FS, the parameters will
//              be changed accordingly so that the operation is redirect when 
//              this callback returns.
//
//  Arguments:  [Data] -- The structure that contains the relevent parameters
//                        to this operation, like the FileObject and DeviceObject.
//              [CompletionContext] - Provides a pointer for a context to be
//                        past from the pre to post operation.  Since Dfs
//                        does not need a post operation, this parameter is not
//                        used.
//
//  Returns:    STATUS_SUCCESS or STATUS_INVALID_DEVICE_REQUEST for default
//              behavior.
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsPreAcquireForModWrite(
    IN PFS_FILTER_CALLBACK_DATA Data,
    OUT PVOID *CompletionContext)
{
    PDEVICE_OBJECT      targetVdo;
    NTSTATUS            status;

    UNREFERENCED_PARAMETER( CompletionContext );

    DfsDbgTrace(+1, Dbg, "DfsPreAcquireForModWrite Enter \n", 0);

    DfsFastIoLookup(Data->FileObject, Data->DeviceObject, &targetVdo);

    if (targetVdo != NULL) {

        Data->DeviceObject = targetVdo;
        status = STATUS_SUCCESS;

    } else {

        //
        // The lazy write called us because we had the dispatch routine for
        // AcquireFileForModWrite, but the underlying FS did not. So, we
        // return this particular error so that the lazy write knows exactly
        // what happened, and can take the default action.
        //

        status = STATUS_INVALID_DEVICE_REQUEST;
    }

    DfsDbgTrace(-1, Dbg, "DfsPreAcquireForModWrite Exit \n", 0);

    return( status );

}

//+----------------------------------------------------------------------------
//
//  Function:   DfsPreReleaseForModWrite
//
//  Synopsis:   This is the equivalent to FastIoReleaseForModWrite. 
//              Dfs receives this callback through the FsFilter interfaces
//              of the FsRtl package in the kernel. 
//
//              This is the time to do the work necessary to end the
//              synchronization operations taken to prepare for the modified
//              page writer to do its work.  If this operation should be 
//              redirected to an underlying FS, the parameters will be changed 
//              accordingly so that the operation is redirect when this callback 
//              returns.
//
//  Arguments:  [Data] -- The structure that contains the relevent parameters
//                        to this operation, like the FileObject and DeviceObject.
//              [CompletionContext] - Provides a pointer for a context to be
//                        past from the pre to post operation.  Since Dfs
//                        does not need a post operation, this parameter is not
//                        used.
//
//  Returns:    STATUS_SUCCESS or STATUS_INVALID_DEVICE_REQUEST for default
//              actions.
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsPreReleaseForModWrite(
    IN PFS_FILTER_CALLBACK_DATA Data,
    OUT PVOID *CompletionContext)
{
    PDEVICE_OBJECT      targetVdo;
    NTSTATUS            status;

    UNREFERENCED_PARAMETER( CompletionContext );

    DfsDbgTrace(+1, Dbg, "DfsPreReleaseForModWrite Enter \n", 0);

    DfsFastIoLookup(Data->FileObject, Data->DeviceObject, &targetVdo);

    if (targetVdo != NULL) {
        
        Data->DeviceObject = targetVdo;
        status = STATUS_SUCCESS;

    } else {

    
        //
        // The lazy write called us because we had the dispatch routine for
        // AcquireFileForModWrite, but the underlying FS did not. So, we
        // return this particular error so that the lazy write knows exactly
        // what happened, and can take the default action.
        //

        status = STATUS_INVALID_DEVICE_REQUEST;
    }

    DfsDbgTrace(-1, Dbg, "DfsPreReleaseForModWrite Exit \n", 0);

    return( status );
}

//+----------------------------------------------------------------------------
//
//  Function:   DfsPreAcquireForCcFlush
//
//  Synopsis:   This is the equivalent to FastIoAcquireForCcFlush. 
//              Dfs receives this callback through the FsFilter interfaces
//              of the FsRtl package in the kernel. 
//
//              This is the time to do the work necessary to synchronize
//              for a CC flush of the given file.  If this operation
//              should be redirected to an underlying FS, the parameters will
//              be changed accordingly so that the operation is redirect when 
//              this callback returns.
//
//  Arguments:  [Data] -- The structure that contains the relevent parameters
//                        to this operation, like the FileObject and DeviceObject.
//              [CompletionContext] - Provides a pointer for a context to be
//                        past from the pre to post operation.  Since Dfs
//                        does not need a post operation, this parameter is not
//                        used.
//
//  Returns:    STATUS_SUCCESS or STATUS_INVALID_DEVICE_REQUEST for default
//              actions.
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsPreAcquireForCcFlush(
    IN PFS_FILTER_CALLBACK_DATA Data,
    OUT PVOID *CompletionContext)
{
    PDEVICE_OBJECT      targetVdo;
    NTSTATUS            status;

    UNREFERENCED_PARAMETER( CompletionContext );

    DfsDbgTrace(+1, Dbg, "DfsPreAcquireForCcFlush Enter \n", 0);

    DfsFastIoLookup(Data->FileObject, Data->DeviceObject, &targetVdo);

    if (targetVdo != NULL) {
        
        Data->DeviceObject = targetVdo;
        status = STATUS_SUCCESS;
        
    } else {

        status = STATUS_INVALID_DEVICE_REQUEST;
    }

    DfsDbgTrace(-1, Dbg, "DfsPreAcquireForCcFlush Exit \n", 0);

    return( status );
}

//+----------------------------------------------------------------------------
//
//  Function:   DfsPreReleaseForCcFlush
//
//  Synopsis:   This is the equivalent to FastIoReleaseForCcFlush. 
//              Dfs receives this callback through the FsFilter interfaces
//              of the FsRtl package in the kernel. 
//
//              This is the time to do the work necessary to end the
//              synchronization operations taken to prepare for a CC flush
//              of this file.  If this operation should be redirected to an 
//              underlying FS, the parameters will be changed accordingly so 
//              that the operation is redirect when this callback returns.
//
//  Arguments:  [Data] -- The structure that contains the relevent parameters
//                        to this operation, like the FileObject and DeviceObject.
//              [CompletionContext] - Provides a pointer for a context to be
//                        past from the pre to post operation.  Since Dfs
//                        does not need a post operation, this parameter is not
//                        used.
//
//  Returns:    STATUS_SUCCESS or STATUS_INVALID_DEVICE_REQUEST for default
//              actions.
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsPreReleaseForCcFlush(
    IN PFS_FILTER_CALLBACK_DATA Data,
    OUT PVOID *CompletionContext)
{
    PDEVICE_OBJECT      targetVdo;
    NTSTATUS            status;

    UNREFERENCED_PARAMETER( CompletionContext );
    
    DfsDbgTrace(+1, Dbg, "DfsPreReleaseForCcFlush Enter \n", 0);

    DfsFastIoLookup(Data->FileObject, Data->DeviceObject, &targetVdo);

    if (targetVdo != NULL) {

        Data->DeviceObject = targetVdo;
        status = STATUS_SUCCESS;

    } else {

        status = STATUS_INVALID_DEVICE_REQUEST;
    }
    
    DfsDbgTrace(-1, Dbg, "DfsPreReleaseForCcFlush Exit \n", 0);

    return( status );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mup\dnr.h ===
//+-------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:       dnr.h
//
//  Contents:   Definitions for distributed name resolution context
//
//  History:    26 May 1992     Alanw   Created
//              04 Sep 1992     Milans  Added support for replica selection
//
//--------------------------------------------------------------------------


#include "rpselect.h"

//
// Maximum number of times we'll go around the main loop in DnrResolveName.
//

#define MAX_DNR_ATTEMPTS    16

//  The following define a Name resolution context which describes the
//  state of an ongoing name resolution.  A pointer to this context is
//  used as the argument to a DPC which will initiate the next step of
//  name resolution.


typedef enum    {
    DnrStateEnter = 0,
    DnrStateStart,              // Start or restart nameres process
    DnrStateGetFirstDC,         // contact a dc, so that we can...
    DnrStateGetReferrals,       // ask knowledge server for referral
    DnrStateGetNextDC,
    DnrStateCompleteReferral,   // waiting for I/O completion of referral req.
    DnrStateSendRequest,        // requesting Open, ResolveName, etc.
    DnrStatePostProcessOpen,    // resume Dnr after call to provider
    DnrStateGetFirstReplica,    // select the first server.
    DnrStateGetNextReplica,     // a server failed, select another
    DnrStateSvcListCheck,       // exhausted svc list, see if svc list changed
    DnrStateDone,               // done, complete the IRP
    DnrStateLocalCompletion = 101       // like done, small optimization
} DNR_STATE;



typedef struct _DNR_CONTEXT {

    //
    //  The type and size of this record (must be DSFS_NTC_DNR_CONTEXT)
    //
    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    DNR_STATE           State;          // State of name resolution
    SECURITY_CLIENT_CONTEXT SecurityContext;  // Security context of caller.
    PDFS_PKT_ENTRY      pPktEntry;      // pointer to locked PKT entry
    ULONG               USN;            // USN of pPktEntry when we cached it
    PDFS_SERVICE        pService;       // pointer to file service being used
    PPROVIDER_DEF       pProvider;      // Same as pService->pProvider

    //
    // The Provider Defs are protected by DfsData.Resource. We don't want
    // to hold this (or any other) resource when going over the net. So, we
    // cache that part of the provider def that we need to use upon returning
    // from the network call.
    //

    USHORT              ProviderId;
    PDEVICE_OBJECT      TargetDevice;

    //
    // Since we don't want to hold any locks while going over the net,
    // we need to reference the authenticated tree connection to the server
    // we will send the open request to.
    //

    PFILE_OBJECT        AuthConn;

    // The pService field is protected by Pkt.Resource. Again, we don't want
    // to hold this resource when going over the net. However, we need to
    // use pService->ConnFile to send a referral request. So, we reference
    // and cache the pService->ConnFile in the DnrContext, release the Pkt,
    // then send the referral request over the cached DCConnFile.
    //

    PFILE_OBJECT        DCConnFile;

    PDFS_CREDENTIALS    Credentials;    // Credentials to use during Dnr
    PIRP_CONTEXT        pIrpContext;    // associated IRP context
    PIRP                OriginalIrp;    // original IRP we started with
    NTSTATUS            FinalStatus;    // status to complete IRP with
    PDFS_FCB            FcbToUse;       // If DNR succeeds, FCB to use.
    PDFS_VCB            Vcb;            // associated DFS_VCB

    // The DFS_NAME_CONTEXT instance is required to be passed down to all
    // the underlying providers. The FileName is the first field in the
    // DFS_NAME_CONTEXT as well.
    // This overlaying facilitates the manipulation of DFS_NAME_CONTEXT


    UNICODE_STRING      FileName;       // file name being processed
    union {
      UNICODE_STRING      ContextFileName;       // file name being processed
      DFS_NAME_CONTEXT    DfsNameContext; // the Dfs name context to be passed down
    };
    UNICODE_STRING      RemainingPart;  // remaining part of file name
    UNICODE_STRING      SavedFileName;  // The one that came with the file
    PFILE_OBJECT        SavedRelatedFileObject; // object.
    USHORT              NewNameLen;     // Length of translated name.

    REPL_SELECT_CONTEXT RSelectContext; // Context for replica selection
    REPL_SELECT_CONTEXT RDCSelectContext; // Context for DC replica selection
    ULONG               ReferralSize;   // size of buffer needed for referral
    unsigned int        Attempts;       // number of name resolution attempts
    BOOLEAN             ReleasePkt;     // if TRUE, Pkt resource must be freed
    BOOLEAN             DnrActive;      // if TRUE, DnrNameResolve active on this context
    BOOLEAN             GotReferral;    // if TRUE, last action was a referral
    BOOLEAN             FoundInconsistency; // if TRUE, last referral involved
                                        // inconsistencies in it.
    BOOLEAN             CalledDCLocator;// if TRUE, we have already called locator
    BOOLEAN             Impersonate;    // if TRUE, we need to impersonate using SecurityToken
    BOOLEAN             NameAllocated;  // if TRUE, FileName.Buffer was allocated separately
    BOOLEAN             GotReparse;     // if TRUE, the a non-mup redir returned STATUS_REPARSE
    BOOLEAN             CachedConnFile; // if TRUE, the connfile connection was a cached one
    PDEVICE_OBJECT      DeviceObject;
    LARGE_INTEGER       StartTime;
    PDFS_TARGET_INFO    pDfsTargetInfo;
    PDFS_TARGET_INFO    pNewTargetInfo;
} DNR_CONTEXT, *PDNR_CONTEXT;


//
//  The initial length of a referral requested over the network.
//

#define MAX_REFERRAL_LENGTH     PAGE_SIZE

//
//  The max length we'll go for a referral
//

#define MAX_REFERRAL_MAX        (0xe000)

typedef struct DFS_OFFLINE_SERVER {
    UNICODE_STRING LogicalServerName;
    LIST_ENTRY     ListEntry;
} DFS_OFFLINE_SERVER, *PDFS_OFFLINE_SERVER;

extern BOOLEAN MupUseNullSessionForDfs;

//
//  Prototypes for functions in dnr.c
//

NTSTATUS
DnrStartNameResolution(
    IN    PIRP_CONTEXT IrpContext,
    IN    PIRP  Irp,
    IN    PDFS_VCB  Vcb
);

NTSTATUS
DnrNameResolve(
    IN    PDNR_CONTEXT DnrContext
);

VOID
DnrComposeFileName(
    OUT PUNICODE_STRING FullName,
    IN  PDFS_VCB            Vcb,
    IN  PFILE_OBJECT    RelatedFile,
    IN  PUNICODE_STRING FileName
);

NTSTATUS
DfsCreateConnection(
    IN PDFS_SERVICE pService,
    IN PPROVIDER_DEF pProvider,
    IN BOOLEAN       CSCAgentCreate,
    OUT PHANDLE     handle
);

NTSTATUS
DfsCloseConnection(
        IN PDFS_SERVICE pService
);

BOOLEAN
DnrConcatenateFilePath (
    IN PUNICODE_STRING Dest,
    IN PWSTR RemainingPath,
    IN USHORT Length
);

PIRP
DnrBuildFsControlRequest (
    IN PFILE_OBJECT FileObject OPTIONAL,
    IN PVOID Context,
    IN ULONG IoControlCode,
    IN PVOID MainBuffer,
    IN ULONG InputBufferLength,
    IN PVOID AuxiliaryBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN PIO_COMPLETION_ROUTINE CompletionRoutine
);

NTSTATUS
DfspIsRootOnline(
    PUNICODE_STRING Name,
    BOOLEAN CSCAgentCreate
);


NTSTATUS
DfspMarkServerOffline(
   PUNICODE_STRING ServerName
);

NTSTATUS
DfspMarkServerOnline(
   PUNICODE_STRING ServerName
);

PLIST_ENTRY 
DfspGetOfflineEntry(
    PUNICODE_STRING ServerName
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mup\fcbsup.h ===
//+-------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:       fcbsup.h
//
//  Contents:   Declarations for DFS_FCB lookup support functions.
//
//  History:    20 Feb 1993     Alanw   Created
//
//--------------------------------------------------------------------------

#ifndef __FCBSUP_H__
#define __FCBSUP_H__

//
//      In order to avoid modifying file objects which are passed
//      through the DFS and used by other file systems, DFS_FCB records
//      used by DFS are not directly attached to the file object
//      through one of the fscontext fields, they are instead
//      associated with the file object, and looked up as needed.
//
//      A hashing mechanism is used for the lookup.  Since the
//      file object being looked up is just a pointer, the hash
//      function is just a simple combination of a few of the low-
//      order bits of the pointer's address.
//

//
//  Declaration of the hash table.  The hash table can be variably
//  sized, with the hash table size being a parameter of the hash
//  function.
//

typedef struct _FCB_HASH_TABLE {

    //
    //  The type and size of this record (must be DSFS_NTC_FCB_HASH)
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  Mask value for the hash function.  The hash table size is
    //  assumed to be a power of two; the mask is the size - 1.
    //

    ULONG HashMask;

    //
    //  A spinlock to protect access to the hash bucket lists.
    //

    KSPIN_LOCK HashListSpinLock;

    //
    //  An array of list heads for the hash table chains.  There
    //  are actually N of these where N is the hash table size.
    //

    LIST_ENTRY  HashBuckets[1];
} FCB_HASH_TABLE, *PFCB_HASH_TABLE;



NTSTATUS
DfsInitFcbs(
  IN    ULONG n
);

VOID
DfsUninitFcbs(
  VOID);

PDFS_FCB
DfsLookupFcb(
  IN    PFILE_OBJECT pFile
);

VOID
DfsAttachFcb(
  IN    PFILE_OBJECT pFileObj,
  IN    PDFS_FCB pFCB
);

VOID
DfsDetachFcb(
  IN    PFILE_OBJECT pFileObj,
  IN    PDFS_FCB pFCB
);

#endif  // __FCBSUP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mup\filobsup.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    filobsup.c

Abstract:

    This module implements the mup file object support routines.

Author:

    Manny Weiser (mannyw)    20-Dec-1991

Revision History:

--*/

#include "mup.h"

//
// The debug trace level
//

#define Dbg                              (DEBUG_TRACE_FILOBSUP)

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, MupDecodeFileObject )
#pragma alloc_text( PAGE, MupSetFileObject )
#endif

VOID
MupSetFileObject (
    IN PFILE_OBJECT FileObject OPTIONAL,
    IN PVOID FsContext,
    IN PVOID FsContext2
    )

/*++

Routine Description:

    This routine sets the file system pointers within the file object.
    This routine MUST be called with the Global Lock held.

Arguments:

    FileObject - Supplies a pointer to the file object being modified, and
        can optionally be null.

    FsContext - Supplies a pointer to the vcb.
        structure.

    FsContext2 - NULL

Return Value:

    None.

--*/

{
    PAGED_CODE();
    DebugTrace(+1, Dbg, "MupSetFileObject, FileObject = %08lx\n", (ULONG)FileObject );

    //
    // Set the fscontext fields of the file object.
    //

    FileObject->FsContext  = FsContext;
    FileObject->FsContext2 = FsContext2;

    DebugTrace(-1, Dbg, "MupSetFileObject -> VOID\n", 0);

    return;
}


BLOCK_TYPE
MupDecodeFileObject (
    IN PFILE_OBJECT FileObject,
    OUT PVOID *FsContext,
    OUT PVOID *FsContext2
    )

/*++

Routine Description:

    This procedure takes a pointer to a file object, that has already been
    opened by the MUP and figures out what it really is opened.

Arguments:

    FileObject - Supplies the file object pointer being interrogated

    FsContext - Receive the file object FsContext pointer

    FsContext2 - Receive the file object FsContext2 pointer


Return Value:

    BlockType - Returns the node type code for a Vcb or Fcb.

        Vcb - indicates that file object opens the mup driver.

        Ccb - indicates that the file object is for a broadcast mailslot file.

        Zero - indicates that the file object has been closed.

--*/

{
    BLOCK_TYPE blockType;
    PBLOCK_HEADER pBlockHead;

    PAGED_CODE();
    DebugTrace(+1, Dbg, "MupDecodeFileObject, FileObject = %08lx\n", (ULONG)FileObject);

    //
    // Acquire the global lock to protect the block reference counts.
    //

    MupAcquireGlobalLock();

    //
    // Read the fs FsContext fields of the file object, then reference
    // the block pointed at by the file object
    //

    *FsContext = FileObject->FsContext;
    *FsContext2 = FileObject->FsContext2;

    ASSERT( (*FsContext) != NULL );

    if ((*FsContext) == NULL) {

        blockType = BlockTypeUndefined;
    }
    else {
      pBlockHead = (PBLOCK_HEADER)(*FsContext);
      if ( ((pBlockHead->BlockType != BlockTypeVcb) &&
	    (pBlockHead->BlockType != BlockTypeFcb)) ||
	   ((pBlockHead->BlockState != BlockStateActive) &&
	    (pBlockHead->BlockState != BlockStateClosing)) ) {
	*FsContext = NULL;
        blockType = BlockTypeUndefined;
      } else {

        //
        // The node is active.  Supply a referenced pointer to the node.
        //

        blockType = BlockType( pBlockHead );
        MupReferenceBlock( pBlockHead );

      }
    }

    //
    // Release the global lock and return to the caller.
    //

    MupReleaseGlobalLock();

    DebugTrace(0,
               DEBUG_TRACE_REFCOUNT,
               "Referencing block %08lx\n",
               (ULONG)*FsContext);
    DebugTrace(0,
               DEBUG_TRACE_REFCOUNT,
               "    Reference count = %lx\n",
               ((PBLOCK_HEADER)(*FsContext))->ReferenceCount );

    DebugTrace(-1, Dbg, "MupDecodeFileObject -> %08lx\n", blockType);

    return blockType;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mup\forward.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    fscontrl.c

Abstract:

    This module implements the forwarding of all broadcast requests
    to UNC providers.

Author:

    Manny Weiser (mannyw)    6-Jan-1992

Revision History:

--*/

#include "mup.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_FORWARD)

//
//  local procedure prototypes
//

NTSTATUS
BuildAndSubmitIrp (
    IN PIRP OriginalIrp,
    IN PCCB Ccb,
    IN PMASTER_FORWARDED_IO_CONTEXT MasterContext
    );

NTSTATUS
ForwardedIoCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

VOID
DeferredForwardedIoCompletionRoutine(
    PVOID Context);

NTSTATUS
CommonForwardedIoCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context);

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, BuildAndSubmitIrp )
#pragma alloc_text( PAGE, MupForwardIoRequest )
#endif


NTSTATUS
MupForwardIoRequest (
    IN PMUP_DEVICE_OBJECT MupDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine forwards an I/O Request Packet to all redirectors for
    a broadcast request.

Arguments:

    MupDeviceObject - Supplies the device object to use.

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The status for the IRP

--*/

{
    NTSTATUS status;
    PIO_STACK_LOCATION irpSp;
    PFCB fcb;
    PVOID fscontext2;
    PLIST_ENTRY listEntry;
    PCCB ccb;
    PMASTER_FORWARDED_IO_CONTEXT masterContext;
    BOOLEAN ownLock = FALSE;

    MupDeviceObject;

    PAGED_CODE();
    DebugTrace(+1, Dbg, "MupForwardIrp\n", 0);


    if (MupEnableDfs &&
            MupDeviceObject->DeviceObject.DeviceType == FILE_DEVICE_DFS) {
        status = DfsVolumePassThrough((PDEVICE_OBJECT)MupDeviceObject, Irp);
        return( status );
    }

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    // Find the FCB for this file object
    //

    FsRtlEnterFileSystem();

    MupDecodeFileObject(
        irpSp->FileObject,
        (PVOID *)&fcb,
        &fscontext2
        );

    if ( fcb == NULL || BlockType( fcb ) != BlockTypeFcb ) {

        //
        // This is not an FCB.
        //

        DebugTrace(0, Dbg, "The fail is closing\n", 0);

        FsRtlExitFileSystem();

        MupCompleteRequest( Irp, STATUS_INVALID_DEVICE_REQUEST );
        status = STATUS_INVALID_DEVICE_REQUEST;

        DebugTrace(-1, Dbg, "MupForwardRequest -> %08lx\n", status );
        return status;
    }

    //
    // Allocate a context structure
    //

    masterContext = MupAllocateMasterIoContext();

    if (masterContext == NULL) {

        //
        // We ran out of resources.  Clean up and return the error.
        //

        DebugTrace(0, Dbg, "Couldn't allc masterContect\n", 0);

        FsRtlExitFileSystem();

        MupCompleteRequest( Irp, STATUS_INSUFFICIENT_RESOURCES );
        status = STATUS_INSUFFICIENT_RESOURCES;

        DebugTrace(-1, Dbg, "MupForwardRequest -> %08lx\n", status );
        return status;
    }

    DebugTrace( 0, Dbg, "Allocated MasterContext 0x%08lx\n", masterContext );

    IoMarkIrpPending(Irp);

    //
    // At this point, we're committed to returning STATUS_PENDING
    //

    masterContext->OriginalIrp = Irp;

    //
    // set status for MupDereferenceMasterIoContext. If this is still
    // an error when the context is freed then masterContext->ErrorStatus
    // will be used to complete the request.
    //

    masterContext->SuccessStatus = STATUS_UNSUCCESSFUL;
    masterContext->ErrorStatus = STATUS_BAD_NETWORK_PATH;

    //
    // Copy the referenced pointer to the FCB.
    //

    masterContext->Fcb = fcb;

    try {

        //
        // Submit the forwarded IRPs.  Note that we can not hold the lock
        // across calls to BuildAndSubmitIrp as it calls IoCallDriver().
        //

        ACQUIRE_LOCK( &MupCcbListLock );
        ownLock = TRUE;

        listEntry = fcb->CcbList.Flink;

        while ( listEntry != &fcb->CcbList ) {

            RELEASE_LOCK( &MupCcbListLock );
            ownLock = FALSE;

            ccb = CONTAINING_RECORD( listEntry, CCB, ListEntry );

            MupAcquireGlobalLock();
            MupReferenceBlock( ccb );
            MupReleaseGlobalLock();

            BuildAndSubmitIrp( Irp, ccb, masterContext );

            ACQUIRE_LOCK( &MupCcbListLock );
            ownLock = TRUE;

            listEntry = listEntry->Flink;

        }

        RELEASE_LOCK( &MupCcbListLock );
        ownLock = FALSE;

    } except ( EXCEPTION_EXECUTE_HANDLER ) {

        masterContext->ErrorStatus = GetExceptionCode();

    }

    //
    // If BuildAndSubmitIrp threw an exception, the lock might still be
    // held.  Drop it if so.
    //

    if (ownLock == TRUE) {

        RELEASE_LOCK( &MupCcbListLock );

    }

    //
    // Release our reference to the master IO context block.
    //

    MupDereferenceMasterIoContext( masterContext, NULL );

    //
    // Return to the caller.
    //

    FsRtlExitFileSystem();

    DebugTrace(-1, Dbg, "MupForwardIrp -> %08lx\n", status);
    return STATUS_PENDING;
}


NTSTATUS
BuildAndSubmitIrp (
    IN PIRP OriginalIrp,
    IN PCCB Ccb,
    IN PMASTER_FORWARDED_IO_CONTEXT MasterContext
    )

/*++

Routine Description:

    This routine takes the original IRP and forwards it to the
    the UNC provider described by the CCB.

Arguments:

    OriginalIrp - Supplies the Irp being processed

    Ccb - A pointer the the ccb.

    MasterContext - A pointer to the master context block for this
        forwarded request.

Return Value:

    NTSTATUS - The status for the Irp

--*/

{
    PIRP irp = NULL;
    PIO_STACK_LOCATION irpSp;
    PFORWARDED_IO_CONTEXT forwardedIoContext = NULL;
    NTSTATUS status = STATUS_SUCCESS;
    PDEVICE_OBJECT deviceObject;
    ULONG bufferLength;
    KPROCESSOR_MODE requestorMode;
    PMDL mdl = NULL;

    PAGED_CODE();
    DebugTrace(+1, Dbg, "BuildAndSubmitIrp\n", 0);

    try {
        
        // make this NonPagedPool, since we could free this up in the
        // io completion routine.
         
        forwardedIoContext = ExAllocatePoolWithTag(
                                NonPagedPool,
                                sizeof( FORWARDED_IO_CONTEXT ),
                                ' puM');

        if (forwardedIoContext == NULL) {

            try_return(status = STATUS_INSUFFICIENT_RESOURCES);

        }

        forwardedIoContext->pIrp = NULL;
        forwardedIoContext->DeviceObject = NULL;

        DebugTrace( 0, Dbg, "Allocated work context 0x%08lx\n", forwardedIoContext );

        //
        // Get the address of the target device object.  Note that this was
        // already done for the no intermediate buffering case, but is done
        // here again to speed up the turbo write path.
        //

        deviceObject = IoGetRelatedDeviceObject( Ccb->FileObject );

        //
        // Allocate and initialize the I/O Request Packet (IRP) for this
        // operation.  The allocation is performed with an exception handler
        // in case the caller does not have enough quota to allocate the
        // packet.
        //

        irp = IoAllocateIrp( deviceObject->StackSize, TRUE );

        if (irp == NULL) {

            //
            // An IRP could not be allocated.  Return an appropriate
            // error status code.
            //
            try_return(status = STATUS_INSUFFICIENT_RESOURCES);
        }

        irp->Tail.Overlay.OriginalFileObject = Ccb->FileObject;
        irp->Tail.Overlay.Thread = OriginalIrp->Tail.Overlay.Thread;
        irp->RequestorMode = KernelMode;

        //
        // Get a pointer to the stack location for the first driver.  This will be
        // used to pass the original function codes and parameters.
        //

        irpSp = IoGetNextIrpStackLocation( irp );

        //
        // Copy the parameters from the original request.
        //

        RtlMoveMemory(
            irpSp,
            IoGetCurrentIrpStackLocation( OriginalIrp ),
            sizeof( *irpSp )
            );

        bufferLength = irpSp->Parameters.Write.Length;

        irpSp->FileObject = Ccb->FileObject;

        //
        // Even though this is probably meaningless to a remote mailslot
        // write, pass it though obediently.
        //

        if (Ccb->FileObject->Flags & FO_WRITE_THROUGH) {
            irpSp->Flags = SL_WRITE_THROUGH;
        }

        requestorMode = OriginalIrp->RequestorMode;

        //
        // Now determine whether this device expects to have data buffered
        // to it or whether it performs direct I/O.  This is based on the
        // DO_BUFFERED_IO flag in the device object.  If the flag is set,
        // then a system buffer is allocated and the caller's data is copied
        // into it.  Otherwise, a Memory Descriptor List (MDL) is allocated
        // and the caller's buffer is locked down using it.
        //

        if (deviceObject->Flags & DO_BUFFERED_IO) {

            //
            // The device does not support direct I/O.  Allocate a system
            // buffer, and copy the caller's data into it.  This is done
            // using an exception handler that will perform cleanup if the
            // operation fails.  Note that this is only done if the operation
            // has a non-zero length.
            //

            irp->AssociatedIrp.SystemBuffer = (PVOID) NULL;

            if ( bufferLength != 0 ) {

                //
                // If the request was made from a mode other than kernel,
                // presumably user, probe the entire buffer to determine
                // whether or not the caller has write access to it.
                //

                if (requestorMode != KernelMode) {
                    ProbeForRead(
                        OriginalIrp->UserBuffer,
                        bufferLength,
                        sizeof( UCHAR )
                        );
                }

                //
                // Allocate the intermediary system buffer from paged
                // pool and charge quota for it.
                //

                irp->AssociatedIrp.SystemBuffer = ExAllocatePoolWithQuotaTag(
                                                    PagedPoolCacheAligned,
                                                    bufferLength,
                                                    ' puM');

                if (irp->AssociatedIrp.SystemBuffer == NULL) {
                    try_return(status = STATUS_INSUFFICIENT_RESOURCES);
                }

                RtlMoveMemory(
                    irp->AssociatedIrp.SystemBuffer,
                    OriginalIrp->UserBuffer,
                    bufferLength);

                //
                // Set the IRP_BUFFERED_IO flag in the IRP so that I/O
                // completion will know that this is not a direct I/O
                // operation.  Also set the IRP_DEALLOCATE_BUFFER flag
                // so it will deallocate the buffer.
                //

                irp->Flags = IRP_BUFFERED_IO | IRP_DEALLOCATE_BUFFER;

            } else {

                //
                // This is a zero-length write.  Simply indicate that this is
                // buffered I/O, and pass along the request.  The buffer will
                // not be set to deallocate so the completion path does not
                // have to special-case the length.
                //

                irp->Flags = IRP_BUFFERED_IO;
            }

        } else if (deviceObject->Flags & DO_DIRECT_IO) {

            //
            // This is a direct I/O operation.  Allocate an MDL and invoke the
            // memory management routine to lock the buffer into memory.
            // Note that no MDL is allocated, nor is any memory probed or
            // locked if the length of the request was zero.
            //

            if ( bufferLength != 0 ) {

                //
                // Allocate an MDL, charging quota for it, and hang it
                // off of the IRP.  Probe and lock the pages associated
                // with the caller's buffer for read access and fill in
                // the MDL with the PFNs of those pages.
                //

                mdl = IoAllocateMdl(
                          OriginalIrp->UserBuffer,
                          bufferLength,
                          FALSE,
                          TRUE,
                          irp
                          );

                if (mdl == NULL) {
                    try_return(status = STATUS_INSUFFICIENT_RESOURCES);
                }

                MmProbeAndLockPages( mdl, requestorMode, IoReadAccess );

            }

        } else {

            //
            // Pass the address of the caller's buffer to the device driver.
            // It is now up to the driver to do everything.
            //

            irp->UserBuffer = OriginalIrp->UserBuffer;

        }

        //
        // If this write operation is to be performed without any caching,
        // set the appropriate flag in the IRP so no caching is performed.
        //

        if (Ccb->FileObject->Flags & FO_NO_INTERMEDIATE_BUFFERING) {
            irp->Flags |= IRP_NOCACHE | IRP_WRITE_OPERATION;
        } else {
            irp->Flags |= IRP_WRITE_OPERATION;
        }

        //
        // Setup the context block
        //

        forwardedIoContext->Ccb = Ccb;
        forwardedIoContext->MasterContext = MasterContext;

        MupAcquireGlobalLock();
        MupReferenceBlock( MasterContext );
        MupReleaseGlobalLock();

        //
        // Set up the completion routine.
        //

        IoSetCompletionRoutine(
            irp,
            (PIO_COMPLETION_ROUTINE)ForwardedIoCompletionRoutine,
            forwardedIoContext,
            TRUE,
            TRUE,
            TRUE
            );

        //
        // Pass the request to the provider.
        //

        IoCallDriver( Ccb->DeviceObject, irp );

        //
        // At this point it is up to the completion routine to free things
        //

        irp = NULL;
        forwardedIoContext = NULL;
        mdl = NULL;

try_exit:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        status = GetExceptionCode();
    }

    //
    // Clean up everything if we are returning an error
    //

    if (!NT_SUCCESS(status)) {
        if ( forwardedIoContext != NULL )
            ExFreePool( forwardedIoContext );
        if (  irp != NULL ) {
            if (irp->AssociatedIrp.SystemBuffer != NULL)
                ExFreePool(irp->AssociatedIrp.SystemBuffer);
            IoFreeIrp( irp );
        }
        if ( mdl != NULL )
            IoFreeMdl( mdl );
    }

    DebugTrace(-1, Dbg, "BuildAndSubmitIrp -> 0x%08lx\n", status);

    return status;

}



NTSTATUS
ForwardedIoCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    This routines cleans up after a forwarded IRP has completed.

Arguments:

    DeviceObject - A pointer to the MUP device object.

    IRP - A pointer to the IRP being processed.

    Context - A pointer to a block containing the context of a forward IRP.

Return Value:

    None.

--*/

{
    PFORWARDED_IO_CONTEXT ioContext = Context;

    NTSTATUS status = Irp->IoStatus.Status;

    DebugTrace( +1, Dbg, "ForwardedIoCompletionRoutine\n", 0 );
    DebugTrace( 0, Dbg, "Irp     = 0x%08lx\n", Irp );
    DebugTrace( 0, Dbg, "Context = 0x%08lx\n", Context );
    DebugTrace( 0, Dbg, "status  = 0x%08lx\n", status );

    //
    // Give this to a worker thread if we are at too high an Irq level
    //

    if (KeGetCurrentIrql() >= DISPATCH_LEVEL) {
        ioContext->DeviceObject = DeviceObject;
        ioContext->pIrp = Irp;
        ExInitializeWorkItem(
                &ioContext->WorkQueueItem,
                DeferredForwardedIoCompletionRoutine,
                Context);
        ExQueueWorkItem(&ioContext->WorkQueueItem, CriticalWorkQueue);
    } else {
        CommonForwardedIoCompletionRoutine(
                    DeviceObject,
                    Irp,
                    Context);
    }

    //
    // Return STATUS_MORE_PROCESSING_REQUIRED so that IoCompleteRequest
    // will stop working on the IRP.
    //

    DebugTrace( -1, Dbg, "ForwardedIoCompletionRoutine exit\n", 0 );

    return STATUS_MORE_PROCESSING_REQUIRED;
}

VOID
DeferredForwardedIoCompletionRoutine(
    PVOID Context)
{
    PFORWARDED_IO_CONTEXT ioContext = Context;

    CommonForwardedIoCompletionRoutine(
        ioContext->DeviceObject,
        ioContext->pIrp,
        Context);
}

NTSTATUS
CommonForwardedIoCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context)
{

    PFORWARDED_IO_CONTEXT ioContext = Context;

    NTSTATUS status = Irp->IoStatus.Status;

    DeviceObject;

    //
    // Free the Irp, and any additional structures we may have allocated.
    //

    if ( Irp->MdlAddress ) {
        MmUnlockPages( Irp->MdlAddress );
        IoFreeMdl( Irp->MdlAddress );
    }

    if ( Irp->Flags & IRP_DEALLOCATE_BUFFER ) {
        ExFreePool( Irp->AssociatedIrp.SystemBuffer );
    }

    IoFreeIrp( Irp );

    //
    // Release the our referenced blocks.
    //

    MupDereferenceCcb( ioContext->Ccb );
    MupDereferenceMasterIoContext( ioContext->MasterContext, &status );

    //
    // Free the slave forwarded IO context block
    //

    ExFreePool( ioContext );

    return STATUS_MORE_PROCESSING_REQUIRED;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mup\fcbsup.c ===
//+-------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:       fcbsup.c
//
//  Contents:   Support routines for associating DFS_FCB records with
//              file objects, and looking them up again.
//
//  Functions:  DfsInitFcbs - Initialize the hash table for DFS_FCB lookup
//              DfsLookupFcb - Lookup an DFS_FCB associated with a file object
//              DfsAttachFcb - Associate an DFS_FCB with a file object
//              DfsDetachFcb - Remove the Association between an DFS_FCB and
//                              a file object
//
//  History:    20 Feb 1993     Alanw   Created
//
//      TODO:   the FcbHashTable and Fcbs are currently allocated
//              out of non-paged pool; these should probably be
//              paged.  This would require using some other
//              synchronization method on the hash bucket chains
//
//--------------------------------------------------------------------------


#include "dfsprocs.h"
#include "fcbsup.h"

#define Dbg     0x1000

#define HASH(k,m)       (((ULONG)((ULONG_PTR)(k))>>12^(ULONG)((ULONG_PTR)(k))>>2) & m)

#define DEFAULT_HASH_SIZE       16      // default size of hash table

NTSTATUS
DfsInitFcbHashTable(
    IN  ULONG cHash,
    OUT PFCB_HASH_TABLE *ppHashTable);

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(INIT, DfsInitFcbs)
#pragma alloc_text(INIT, DfsInitFcbHashTable)
#pragma alloc_text(PAGE, DfsUninitFcbs)

//
// The following routines are not pageable because they acquire spinlocks.
//
// DfsLookupFcb
// DfsAttachFcb
// DfsDetachFcb
//

#endif

//+-------------------------------------------------------------------------
//
//  Function:   DfsInitFcbs - Initialize the DFS_FCB lookup hash table
//
//  Synopsis:   This function initializes data structures which are
//              used for looking up an DFS_FCB associated with some open
//              file object.
//
//  Arguments:  [cHash] -- Size of the hash table to be allocated.  Must be
//                         a power of two.  If zero, a default size is used.
//
//  Returns:    NTSTATUS -- STATUS_SUCCESS, unless memory allocation
//                          fails.
//
//  Note:       The hash buckets are initialized to zero, then later
//              initialized to a list head when used.  This is a debugging
//              aid to determine if some hash buckets are never used.
//
//--------------------------------------------------------------------------

NTSTATUS
DfsInitFcbHashTable(
    IN  ULONG cHash,
    OUT PFCB_HASH_TABLE *ppHashTable)
{
    PFCB_HASH_TABLE pHashTable;
    ULONG cbHashTable;

    if (cHash == 0) {
        cHash = DEFAULT_HASH_SIZE;
    }
    ASSERT ((cHash & (cHash-1)) == 0);  // Assure cHash is a power of two

    cbHashTable = sizeof (FCB_HASH_TABLE) + (cHash-1)*sizeof (LIST_ENTRY);
    pHashTable = ExAllocatePoolWithTag(NonPagedPool, cbHashTable, ' puM');
    if (pHashTable == NULL) {
        return STATUS_NO_MEMORY;
    }
    pHashTable->NodeTypeCode = DSFS_NTC_FCB_HASH;
    pHashTable->NodeByteSize = (NODE_BYTE_SIZE) cbHashTable;

    pHashTable->HashMask = (cHash-1);
    KeInitializeSpinLock( &pHashTable->HashListSpinLock );
    RtlZeroMemory(&pHashTable->HashBuckets[0], cHash * sizeof (LIST_ENTRY));

    *ppHashTable = pHashTable;

    return(STATUS_SUCCESS);
}

NTSTATUS
DfsInitFcbs(
  IN    ULONG cHash
) {
    NTSTATUS status;

    status = DfsInitFcbHashTable( cHash, &DfsData.FcbHashTable );

    return status;
}

VOID
DfsUninitFcbs(
    VOID)
{
    ExFreePool (DfsData.FcbHashTable);
}

//+-------------------------------------------------------------------------
//
//  Function:   DfsLookupFcb - Lookup an DFS_FCB in the hash table
//
//  Synopsis:   This function will lookup the DFS_FCB associated with
//              a particular file object.
//
//  Arguments:  [pFile] -- Pointer to file object for which the DFS_FCB is
//                         being looked up.
//
//  Returns:    PVOID -- pointer to the DFS_FCB found, or NULL if none
//
//  Algorithm:  Knuth would call it hashing with conflict resoulution
//              by chaining.
//
//  History:    20 Feb 1993     Alanw   Created
//
//--------------------------------------------------------------------------


PDFS_FCB
DfsLookupFcb(
  IN    PFILE_OBJECT pFile
) {
    PLIST_ENTRY pListHead, pLink;
    PDFS_FCB pFCB;
    KIRQL SavedIrql;
    PFCB_HASH_TABLE pHashTable = DfsData.FcbHashTable;

    KeAcquireSpinLock( &pHashTable->HashListSpinLock, &SavedIrql );
    pListHead = &pHashTable->HashBuckets[ HASH(pFile, pHashTable->HashMask) ];

    if ((pListHead->Flink == NULL) ||           // list not initialized
        (pListHead->Flink == pListHead)) {      // list empty
        KeReleaseSpinLock( &pHashTable->HashListSpinLock, SavedIrql );
        return NULL;
    }

    for (pLink = pListHead->Flink; pLink != pListHead; pLink = pLink->Flink) {
        pFCB = CONTAINING_RECORD(pLink, DFS_FCB, HashChain);
        if (pFCB->FileObject == pFile) {
            KeReleaseSpinLock( &pHashTable->HashListSpinLock, SavedIrql );
            return pFCB;
        }
    }
    KeReleaseSpinLock( &pHashTable->HashListSpinLock, SavedIrql );
    return NULL;
}


//+-------------------------------------------------------------------------
//
//  Function:   DfsAttachFcb - Inserts an DFS_FCB into the hash table
//
//  Synopsis:   This function associates an DFS_FCB to a file object.  This
//              involves inserting it into the hash table.
//
//  Arguments:  [pFCB] -- Pointer to the DFS_FCB to be inserted.
//              [pFileObj] -- Pointer to the corresponding file object, used
//                            as the hash key.
//
//  Returns:    -nothing-
//
//--------------------------------------------------------------------------

VOID
DfsAttachFcb(
  IN    PFILE_OBJECT pFileObj,
  IN    PDFS_FCB pFCB
) {
    PFCB_HASH_TABLE pHashTable = (PFCB_HASH_TABLE) DfsData.FcbHashTable;
    PLIST_ENTRY pListHead;
    KIRQL SavedIrql;

    KeAcquireSpinLock( &pHashTable->HashListSpinLock, &SavedIrql );

    pListHead = &pHashTable->HashBuckets[ HASH(pFileObj, pHashTable->HashMask) ];

    if (pListHead->Flink == NULL) {
        InitializeListHead(pListHead);
    }
    InsertHeadList(pListHead, &pFCB->HashChain);
    KeReleaseSpinLock( &pHashTable->HashListSpinLock, SavedIrql );

    DfsDbgTrace(0, Dbg, "Attached Fcb %08lx ", pFCB);
    DfsDbgTrace(0, Dbg, "For Fileobject %08lx ", pFileObj);

}



//+-------------------------------------------------------------------------
//
//  Function:   DfsDetachFcb - Detach an DFS_FCB from the lookup hash table
//
//  Synopsis:   This function detaches an DFS_FCB from the hash table.  This
//              involves just deleting it from the hash bucket chain.
//
//  Arguments:  [pFCB] -- Pointer to the DFS_FCB to be detached.
//              [pFileObj] -- Pointer to the corresponding file object, used
//                            for debugging only.
//
//  Returns:    -nothing-
//
//--------------------------------------------------------------------------


VOID
DfsDetachFcb(
  IN    PFILE_OBJECT pFileObj,
  IN    PDFS_FCB pFCB
) {
    PFCB_HASH_TABLE pHashTable = (PFCB_HASH_TABLE) DfsData.FcbHashTable;
    KIRQL SavedIrql;

    ASSERT(pFCB->FileObject == pFileObj);
    ASSERT(DfsLookupFcb(pFCB->FileObject) == pFCB);

    KeAcquireSpinLock( &pHashTable->HashListSpinLock, &SavedIrql );
    RemoveEntryList(&pFCB->HashChain);
    pFCB->FileObject = NULL;
    KeReleaseSpinLock( &pHashTable->HashListSpinLock, SavedIrql );

    DfsDbgTrace(0, Dbg, "Detached Fcb %08lx ", pFCB);
    DfsDbgTrace(0, Dbg, "For Fileobject %08lx ", pFileObj);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mup\fileinfo.c ===
//+-------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:       FILEINFO.C
//
//  Contents:   This module implements the File Information routines for
//              Dfs called by the dispatch driver.
//
//  Functions:  DfsFsdSetInformation - FSD entry point for NtSetInformationFile
//              DfsFspSetInformation - FSP entry point for NtSetInformationFile
//              DfsCommonSetInformation - Implement SetInformationFile for DFS
//              DfsSetRenameInfo - Takes care of rename restrictions.
//              DfsSetDispositionInfo - Enforces Deletion of StgId restrictions.
//
//  Notes:      No query information routines are presently used.
//              These requests are passed directly through to a redirected
//              file (if one exists).
//
//  History:    30 Jun 1992     AlanW   Created from FastFAT source.
//              09 Feb 1994     SudK    Added Rename/Delete restrictions.
//
//--------------------------------------------------------------------------


#include "dfsprocs.h"
#include "dnr.h"
#include "mupwml.h"

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_FILEINFO)

//
//  Local procedure prototypes
//

NTSTATUS
DfsCommonSetInformation (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
DfsSetDispositionInfo (
    IN PIRP Irp
    );

NTSTATUS
DfsSetRenameInfo (
    IN PIRP Irp,
    IN PDFS_VCB Vcb,
    IN PDFS_FCB Fcb
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text ( PAGE, DfsFsdQueryInformation )
#pragma alloc_text ( PAGE, DfsFsdSetInformation )
#pragma alloc_text ( PAGE, DfsFspSetInformation )
#pragma alloc_text ( PAGE, DfsCommonSetInformation )
#pragma alloc_text ( PAGE, DfsSetDispositionInfo )
#pragma alloc_text ( PAGE, DfsSetRenameInfo )
#endif // ALLOC_PRAGMA


//+----------------------------------------------------------------------------
//
//  Function:   DfsFsdQueryInformation, public
//
//  Synopsis:   This routine implements the FSD part of the
//              NtQueryInformationFile API call
//
//  Arguments:  [DeviceObject] -- Supplies the volume device object where
//                      the file being queried exists.
//              [Irp] -- Supplies the Irp being processed
//
//  Returns:    NTSTATUS - The FSD status for the Irp.
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsFsdQueryInformation (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PIO_STACK_LOCATION IrpSp;
    FILE_INFORMATION_CLASS FileInformationClass;
    PFILE_NAME_INFORMATION FileNameInfo;
    UNICODE_STRING FileNameToUse;
    ULONG BufferLength, BytesToCopy;
    PFILE_OBJECT FileObject;
    TYPE_OF_OPEN TypeOfOpen;
    PDFS_VCB Vcb;
    PDFS_FCB Fcb;
    BOOLEAN completeIrp;


    ASSERT(ARGUMENT_PRESENT(DeviceObject));
    ASSERT(ARGUMENT_PRESENT(Irp));

    DfsDbgTrace(+1, Dbg, "DfsFsdQueryInformation - Entered\n", 0);

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    FileInformationClass = IrpSp->Parameters.QueryFile.FileInformationClass;

    DfsDbgTrace(0, Dbg, "InfoLevel = %d\n", FileInformationClass);

    if (DeviceObject->DeviceType == FILE_DEVICE_MULTI_UNC_PROVIDER ||
            DeviceObject->DeviceType == FILE_DEVICE_DFS_FILE_SYSTEM) {

        DfsCompleteRequest( NULL, Irp, STATUS_INVALID_DEVICE_REQUEST );

        DfsDbgTrace(-1, Dbg, "DfsFsdQueryInformation - Mup/File System\n", 0);

        return( STATUS_INVALID_DEVICE_REQUEST );

    }

    ASSERT( DeviceObject->DeviceType == FILE_DEVICE_DFS );

    if (FileInformationClass != FileNameInformation &&
            FileInformationClass != FileAlternateNameInformation) {

        Status = DfsVolumePassThrough(DeviceObject, Irp);

        DfsDbgTrace(-1, Dbg,
            "DfsFsdQueryInformation: Exit -> %08lx\n", ULongToPtr(Status) );

        return Status;

    }

    FileObject = IrpSp->FileObject;

    //
    //  Decode the file object. Remember that there need not be an Fcb always.
    //

    TypeOfOpen = DfsDecodeFileObject( FileObject, &Vcb, &Fcb);

    if (Fcb != NULL) {

        completeIrp = TRUE;

        switch (TypeOfOpen) {

        default:
            //
            //  We cannot get info on a device open
            //

            Status = STATUS_INVALID_PARAMETER;

            break;

        case RedirectedFileOpen:
        case UnknownOpen:

            FileNameInfo = (PFILE_NAME_INFORMATION) Irp->AssociatedIrp.SystemBuffer;

            BufferLength = IrpSp->Parameters.QueryFile.Length;

            if (FileInformationClass == FileAlternateNameInformation)
                FileNameToUse = Fcb->AlternateFileName;
            else
                FileNameToUse = Fcb->FullFileName;


            if (BufferLength < sizeof(FILE_NAME_INFORMATION)) {

                Status = STATUS_INVALID_PARAMETER;

            }

            if (FileNameToUse.Length == 0) {

                ASSERT(FileInformationClass == FileAlternateNameInformation);

                Status = DfsVolumePassThrough(DeviceObject, Irp);

                completeIrp = FALSE;

            } else {
                 BufferLength -= FIELD_OFFSET(FILE_NAME_INFORMATION, FileName[0]);

		 if (BufferLength < FileNameToUse.Length) {
		   BytesToCopy = BufferLength;
                   Status = STATUS_BUFFER_OVERFLOW;
		   BufferLength = 0;
		 }
		 else {
		   BytesToCopy = FileNameToUse.Length;
		   BufferLength -= BytesToCopy;
		 }
		 FileNameInfo->FileNameLength = FileNameToUse.Length;

		 if (BytesToCopy > 0) {
	             RtlCopyMemory(
                        (PVOID) &FileNameInfo->FileName,
                        (PVOID) FileNameToUse.Buffer,
                        BytesToCopy);
		 }

                Irp->IoStatus.Information = 
                    IrpSp->Parameters.QueryFile.Length - BufferLength;
            }

            break;
        }

        if (completeIrp)
            DfsCompleteRequest( NULL, Irp, Status );

    } else {

        Status = STATUS_INVALID_PARAMETER;
        DfsCompleteRequest( NULL, Irp, Status );

    }

    //
    //  And return to our caller
    //

    DfsDbgTrace(-1, Dbg, "DfsFsdQueryInformation -> %08lx\n", ULongToPtr(Status) );

    return Status;

}


//+-------------------------------------------------------------------
//
//  Function:   DfsFsdSetInformation, public
//
//  Synopsis:   This routine implements the FSD part of the
//              NtSetInformationFile API call.
//
//  Arguments:  [DeviceObject] -- Supplies the volume device object where
//                      the file being set exists.
//              [Irp] -- Supplies the Irp being processed.
//
//  Returns:    NTSTATUS - The FSD status for the Irp.
//
//--------------------------------------------------------------------

NTSTATUS
DfsFsdSetInformation (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
) {
    NTSTATUS Status;
    PIRP_CONTEXT IrpContext = NULL;
    ASSERT(ARGUMENT_PRESENT(DeviceObject));
    ASSERT(ARGUMENT_PRESENT(Irp));

    DfsDbgTrace(+1, Dbg, "DfsFsdSetInformation\n", 0);

    //
    //  Call the common set routine, with blocking allowed if synchronous
    //

    FsRtlEnterFileSystem();

    try {

        IrpContext = DfsCreateIrpContext( Irp, CanFsdWait( Irp ) );
        if (IrpContext == NULL)
            ExRaiseStatus(STATUS_INSUFFICIENT_RESOURCES);
        Status = DfsCommonSetInformation( IrpContext, Irp );

    } except(DfsExceptionFilter( IrpContext, GetExceptionCode(), GetExceptionInformation() )) {

        //
        //  We had some trouble trying to perform the requested
        //  operation, so we'll abort the I/O request with
        //  the error status that we get back from the
        //  execption code
        //

        Status = DfsProcessException( IrpContext, Irp, GetExceptionCode() );
    }

    FsRtlExitFileSystem();

    //
    //  And return to our caller
    //

    DfsDbgTrace(-1, Dbg, "DfsFsdSetInformation -> %08lx\n", ULongToPtr(Status) );

    UNREFERENCED_PARAMETER( DeviceObject );

    return Status;
}


//+-------------------------------------------------------------------
//
//  Function:   DfsFspSetInformation, public
//
//  Synopsis:   This routine implements the FSP part of the
//              NtSetInformationFile API call.
//
//  Arguments:  [IrpContext] -- The IRP_CONTEXT record for the operation
//              [Irp] -- Supplies the Irp being processed.
//
//  Returns:    Nothing
//
//--------------------------------------------------------------------

VOID
DfsFspSetInformation (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
) {
    DfsDbgTrace(+1, Dbg, "DfsFspSetInformation\n", 0);

    //
    //  Call the common set routine.  The Fsp is always allowed to block
    //

    (VOID)DfsCommonSetInformation( IrpContext, Irp );

    //
    //  And return to our caller
    //

    DfsDbgTrace(-1, Dbg, "DfsFspSetInformation -> VOID\n", 0);

    return;
}


//+-------------------------------------------------------------------
//
//  Function:   DfsCommonSetInformation, private
//
//  Synopsis:   This is the common routine for setting file information called
//              by both the FSD and FSP threads.
//
//  Arguments:  [Irp] -- Supplies the Irp being processed
//
//  Returns:    NTSTATUS - The return status for the operation
//
//--------------------------------------------------------------------
//

NTSTATUS
DfsCommonSetInformation (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
) {
    NTSTATUS Status = STATUS_SUCCESS;

    PIO_STACK_LOCATION IrpSp;
    PIO_STACK_LOCATION NextIrpSp;

    PFILE_OBJECT FileObject;
    FILE_INFORMATION_CLASS FileInformationClass;
    PDEVICE_OBJECT      Vdo, DeviceObject;

    TYPE_OF_OPEN TypeOfOpen;
    PDFS_VCB Vcb;
    PDFS_FCB Fcb;

    //
    //  Get the current stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DfsDbgTrace(+1, Dbg, "DfsCommonSetInformation...\n", 0);
    DfsDbgTrace( 0, Dbg, "Irp                    = %08lx\n", Irp);
    DfsDbgTrace( 0, Dbg, "->Length               = %08lx\n", ULongToPtr(IrpSp->Parameters.SetFile.Length) );
    DfsDbgTrace( 0, Dbg, "->FileInformationClass = %08lx\n", IrpSp->Parameters.SetFile.FileInformationClass);
    DfsDbgTrace( 0, Dbg, "->ReplaceFileObject    = %08lx\n", IrpSp->Parameters.SetFile.FileObject);
    DfsDbgTrace( 0, Dbg, "->ReplaceIfExists      = %08lx\n", IrpSp->Parameters.SetFile.ReplaceIfExists);
    DfsDbgTrace( 0, Dbg, "->Buffer               = %08lx\n", Irp->AssociatedIrp.SystemBuffer);

    //
    //  Reference our input parameters to make things easier
    //

    FileInformationClass = IrpSp->Parameters.SetFile.FileInformationClass;
    FileObject = IrpSp->FileObject;
    DeviceObject = IrpSp->DeviceObject;

    if (DeviceObject->DeviceType == FILE_DEVICE_MULTI_UNC_PROVIDER) {
        DfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_DEVICE_REQUEST );
        DfsDbgTrace(-1, Dbg, "DfsCommonSetInformation - Mup file\n", 0);
        return( STATUS_INVALID_DEVICE_REQUEST );
    }

    //
    //  Decode the file object. Remember that there need not be an Fcb always.
    //

    TypeOfOpen = DfsDecodeFileObject( FileObject, &Vcb, &Fcb);

    //
    //  Set this handle as having modified the file
    //

    FileObject->Flags |= FO_FILE_MODIFIED;

    try {

        //
        //  Case on the type of open we're dealing with
        //

        switch (TypeOfOpen) {

        default:

            //
            //  We cannot set info on a device open
            //

            try_return( Status = STATUS_INVALID_PARAMETER );

        case RedirectedFileOpen:
        case UnknownOpen:

            break;

        }

        if (Fcb == NULL)
            try_return( Status = STATUS_INVALID_PARAMETER );

        //
        // Copy the stack from one to the next...
        //
        NextIrpSp = IoGetNextIrpStackLocation(Irp);
        (*NextIrpSp) = (*IrpSp);

        IoSetCompletionRoutine( Irp,
                                NULL,
                                NULL,
                                FALSE,
                                FALSE,
                                FALSE);

        //
        //  Call the next device in the chain.
        //

        Status = IoCallDriver( Fcb->TargetDevice, Irp );
        MUP_TRACE_ERROR_HIGH(Status, ALL_ERROR, DfsCommonSetInformation_Error_IoCallDriver,
                             LOGSTATUS(Status)
                             LOGPTR(Irp)
                             LOGPTR(FileObject));

        //
        //  The IRP will be completed by the called driver.  We have
        //  no need for the IrpContext in the completion routine.
        //

        DfsDeleteIrpContext(IrpContext);

        IrpContext = NULL;

        Irp = NULL;

    try_exit: NOTHING;

    } finally {

        DebugUnwind( DfsCommonSetInformation );

        if (!AbnormalTermination()) {

            DfsCompleteRequest( IrpContext, Irp, Status );

        }

        DfsDbgTrace(-1, Dbg, "DfsCommonSetInformation -> %08lx\n", ULongToPtr(Status) );
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mup\fsctrl.h ===
//+-------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:       dsfsctl.h
//
//  Contents:   This module contains the definitions of internally used file
//              system controls for the Dfs file system.  It also contains
//              definitions of macros used in the implementation of Fsctrls.
//
//              Public control code and structure declarations are in the
//              private header file dfsfsctl.h.
//
//  Classes:    -none-
//
//  Functions:  -none-
//
//  History:    02 Jan 1992     Alan Whitney (alanw)    Created
//
//--------------------------------------------------------------------------



#ifndef _DSFSCTL_
#define _DSFSCTL_


#ifndef IOCTL_DFS_BASE
# include <dfsfsctl.h>
#endif  //IOCTL_DFS_BASE

//+----------------------------------------------------------------------------
//
//  Macro:      IS_DFS_CTL_CODE
//
//  Synopsis:   Determines whether a fsctrl code is a Dfs fsctrl code.
//
//  Arguments:  [c] -- The control code to test
//
//  Returns:    TRUE if c is a Dfs fsctrl code, FALSE if its not.
//
//-----------------------------------------------------------------------------

#define IS_DFS_CTL_CODE(c)                                              \
    (((c) & CTL_CODE(0xFF, 0,0,0)) == CTL_CODE(FSCTL_DFS_BASE, 0,0,0))


//+----------------------------------------------------------------------------
//
//  Macro:      OFFSET_TO_POINTER
//
//  Synopsis:   Certain fsctls (mainly those issued by the srvsvc) communicate
//              via buffers that contain "pointers" which are really offsets
//              from the beginning of the buffer. This macro fixes up the
//              offsets to real pointers
//
//  Arguments:  [field] -- The field to fix up.
//              [buffer] -- The beginning of the buffer.
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

#define OFFSET_TO_POINTER(field, buffer)  \
    ( ((PCHAR)field) += ((ULONG_PTR)buffer) )

//+----------------------------------------------------------------------------
//
//  Macro:      POINTER_TO_OFFSET
//
//  Synopsis:   Reverse of OFFSET_TO_POINTER.  Turns a pointer into a
//              buffer-relative address
//
//  Arguments:  [field] -- The field to fix up.
//              [buffer] -- The beginning of the buffer.
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

#define POINTER_TO_OFFSET(field, buffer)  \
    ( ((PCHAR)field) -= ((ULONG_PTR)buffer) )

//+----------------------------------------------------------------------------
//
//  Macro:      UNICODESTRING_IS_VALID
//
//  Synopsis:   Determines whether a passed-in UNICODE_STRING is good
//
//  Returns:    TRUE if is good, FALSE if not
//
//-----------------------------------------------------------------------------

#define UNICODESTRING_IS_VALID(ustr,start,len)                              \
    (                                                                       \
    ((ustr).Length <= (len)) &&                                             \
    ((PCHAR)(ustr).Buffer >= (PCHAR)(start)) &&                             \
    ((PCHAR)(ustr).Buffer <= (PCHAR)(start) + ((len) - (ustr).Length))      \
    )

//+----------------------------------------------------------------------------
//
//  Macro:      POINTER_IN_BUFFER
//
//  Synopsis:   Determines whether a pointer lies within a buffer
//
//  Returns:    TRUE if is good, FALSE if not
//
//-----------------------------------------------------------------------------

#define POINTER_IN_BUFFER(ptr,size,buf,len)                           \
  (((PCHAR)(ptr) >= (PCHAR)(buf)) && (((PCHAR)(ptr) + (size)) <= ((PCHAR)(buf) + len)))


//+----------------------------------------------------------------------------
//
//  Function:   DFS_DUPLICATE_STRING
//
//  Synopsis:   Macro to create a UNICODE_STRING from an LPWSTR. The buffer
//              for the UNICODE_STRING is allocated using ExAllocatePoolWithTag.
//
//              Useful for duplicating strings received in fsctls from the
//              server.
//
//  Arguments:  [ustr] -- Destination UNICODE_STRING
//              [pwsz] -- Source LPWSTR
//              [status] -- If pool allocation fails, this will be set to
//                      STATUS_INSUFFICIENT_RESOURCES
//
//  Returns:    Nothing. Check the status parameter to see if the operation
//              succeeded.
//
//-----------------------------------------------------------------------------

#define DFS_DUPLICATE_STRING(ustr,pwsz,status)                               \
ustr.Length = wcslen(pwsz) * sizeof(WCHAR);                                  \
ustr.MaximumLength = ustr.Length + sizeof(WCHAR);                            \
ustr.Buffer = ExAllocatePoolWithTag(PagedPool,ustr.MaximumLength,' puM');    \
if (ustr.Buffer != NULL) {                                                   \
    RtlCopyMemory( ustr.Buffer, pwsz, ustr.MaximumLength );                  \
    status = STATUS_SUCCESS;                                                 \
} else {                                                                     \
    status = STATUS_INSUFFICIENT_RESOURCES;                                  \
}


//+---------------------------------------------------------------------------
//
// Macro:       STD_FSCTRL_PROLOGUE, public
//
// Synopsis:    Do the standard stuff associated with any fsctrl implementation
//              which needs to run in the FSP.  This assumes a standard set
//              of parameters for the calling function, as below:
//
//                      DfsMyownFsctrl(
//                              IN PIRP_CONTEXT IrpContext,
//                              IN PIRP Irp,
//                      [maybe] IN PVOID InputBuffer,
//                              IN ULONG InputBufferLength,
//                      [maybe] IN PVOID OutputBuffer,
//                              IN ULONG OutputBufferLength
//                      );
//
// Arguments:   [szName] -- Name of the function for debug trace messages
//              [fExpInp] -- TRUE if it takes an input buffer
//              [fExpOutp] -- TRUE if it takes an output buffer
//              [fInFsp] -- TRUE if the request must be processed from the
//                          FSP.
//
// Returns:     None
//
//  Notes:      The macros CHECK_BUFFER_TRUE and CHECK_BUFFER_FALSE are
//              necessary for the generation of STD_FSCTRL_PROLOGUE and
//              are not intended to be used directly.
//
//
//----------------------------------------------------------------------------

#define CHK_BUFFER_FALSE(szName, inout) ;
#define CHK_BUFFER_TRUE(szName, inout)                          \
    if (!ARGUMENT_PRESENT(inout##Buffer) || (inout##BufferLength == 0)) {\
        DfsDbgTrace(0, Dbg, #szName ": Bad buffer\n", 0);                \
        DfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );\
        return STATUS_INVALID_PARAMETER;                                \
    }

#define CHK_INFSP_FALSE(szName)
#define CHK_INFSP_TRUE(szName)                                          \
    if ((IrpContext->Flags & IRP_CONTEXT_FLAG_IN_FSD) != 0) {           \
        DfsDbgTrace(0, Dbg, #szName ": Posting to FSP\n",0);             \
        status = DfsFsdPostRequest( IrpContext, Irp );                  \
        return status;                                                  \
    }

#define STD_FSCTRL_PROLOGUE(szName, fExpInp, fExpOutp, fInFsp) {        \
    ASSERT(ARGUMENT_PRESENT(IrpContext) && (ARGUMENT_PRESENT(Irp)));    \
    CHK_BUFFER_##fExpInp(szName, Input)                                 \
    CHK_BUFFER_##fExpOutp(szName, Output)                               \
    CHK_INFSP_##fInFsp(szName)                                          \
    DfsDbgTrace(+1, Dbg, #szName ": Entered\n", 0);                      \
}


//+---------------------------------------------------------------------------
//
//  Macro:      RETURN_BUFFER_SIZE, public
//
//  Synopsis:   Return conventional errors when the output of an fsctrl
//              function is larger than the user buffer. This assumes a
//              standard set of parameters for the calling function, as
//              below:
//
//                      DfsMyownFsctrl(
//                              IN PIRP_CONTEXT IrpContext,
//                              IN PIRP Irp,
//                      [maybe] IN PVOID InputBuffer,
//                      [maybe] IN ULONG InputBufferLength,
//                              IN PVOID OutputBuffer,
//                              IN ULONG OutputBufferLength
//                      );
//
//  Arguments:  [x] -- The required size of the output buffer
//              [Status] -- The status to be returned from the fsctrl.
//
//  Returns:    Sets Status to STATUS_BUFFER_TOO_SMALL or
//              STATUS_BUFFER_OVERFLOW.  The convention we use is that if
//              the OutputBuffer is at least sizeof(ULONG) big, then we stuff
//              the needed size in OutputBuffer and return
//              STATUS_BUFFER_OVERFLOW, which is a warning code.  If the
//              OutputBuffer isn't big enough for that, we return
//              STATUS_BUFFER_TOO_SMALL.
//
//  Notes:      Requires that the function declare "OutputBufferLength",
//              "OutputBuffer", and "Irp". Irp->IoStatus.Information will
//              be set to the return size.
//
//----------------------------------------------------------------------------

#define RETURN_BUFFER_SIZE(x, Status)                                   \
    if ((OutputBufferLength) < sizeof(ULONG)) {                         \
        Status = STATUS_BUFFER_TOO_SMALL;                               \
    } else {                                                            \
        Status = STATUS_BUFFER_OVERFLOW;                                \
        *((PULONG) OutputBuffer) = x;                                   \
        Irp->IoStatus.Information = sizeof(ULONG);                      \
    }


//
//  Internal Distributed file system control operations (private, checked versions only)
//

#define FSCTL_DFS_DBG_BREAK             CTL_CODE(FSCTL_DFS_BASE, 2045, METHOD_BUFFERED, FILE_WRITE_DATA)

#define FSCTL_DFS_DBG_FLAGS             CTL_CODE(FSCTL_DFS_BASE, 2046, METHOD_BUFFERED, FILE_WRITE_DATA)

#define FSCTL_DFS_INTERNAL_READ_MEM     CTL_CODE(FSCTL_DFS_BASE, 2047, METHOD_BUFFERED, FILE_READ_DATA)

#define FSCTL_DFS_SET_PKT_ENTRY_TIMEOUT CTL_CODE(FSCTL_DFS_BASE, 2048, METHOD_BUFFERED, FILE_WRITE_DATA)

#define FSCTL_DFS_VERBOSE_FLAGS         CTL_CODE(FSCTL_DFS_BASE, 2049, METHOD_BUFFERED, FILE_WRITE_DATA)

#define FSCTL_DFS_EVENTLOG_FLAGS        CTL_CODE(FSCTL_DFS_BASE, 2050, METHOD_BUFFERED, FILE_WRITE_DATA)
//
//  Control structure for FSCTL_DFS_INTERNAL_READ_MEM (input)
//

typedef struct _FILE_DFS_READ_MEM {
    DWORD_PTR Address;
    ULONG     Length;
} FILE_DFS_READ_MEM, *PFILE_DFS_READ_MEM;

#endif // _DSFSCTL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mup\fsctrl.c ===
//-----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:       FSCTRL.C
//
//  Contents:
//      This module implements the File System Control routines for Dfs.
//
//  Functions:
//              DfsFsdFileSystemControl
//              DfsFspFileSystemControl
//              DfsCommonFileSystemControl, local
//              DfsUserFsctl, local
//              DfsOplockRequest, local
//              DfsFsctrlDefineLogicalRoot - Define a new logical root
//              DfsFsctrlUndefineLogicalRoot - Undefine an existing root
//              DfsFsctrlGetLogicalRootPrefix - Retrieve prefix that logical
//                      root maps to.
//              DfsFsctrlGetConnectedResources -
//              DfsFsctrlDefineProvider - Define a file service provider
//              DfsFsctrlGetServerName - Get name of server given prefix
//              DfsFsctrlReadMem - return an internal data struct (debug)
//              DfsCompleteMountRequest - Completion routine for mount IRP
//              DfsCompleteLoadFsRequest - Completion routine for Load FS IRP
//              DfsFsctrlGetPkt
//              DfsFsctrlGetPktEntryState
//              DfsGetEntryStateSize - local
//              DfsGetEntryStateMarshall - local
//              DfsFsctrlSetPktEntryState
//              DfsSetPktEntryActive
//              DfsSetPktEntryTimeout
//
//-----------------------------------------------------------------------------

#include "dfsprocs.h"
#include "creds.h"
#include "dnr.h"
#include "know.h"
#include "fsctrl.h"
#include "mupwml.h"

#ifdef TERMSRV
NTKERNELAPI
NTSTATUS
IoGetRequestorSessionId(
    IN PIRP Irp,
    OUT PULONG pSessionId
    );
#endif

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_FSCTRL)


//
//  Local procedure prototypes
//

NTSTATUS
DfsCommonFileSystemControl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
DfsUserFsctl (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
DfsOplockRequest (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
DfsFsctrlDefineLogicalRoot (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PFILE_DFS_DEF_ROOT_BUFFER pDlrParam,
    IN ULONG InputBufferLength
    );

NTSTATUS
DfsFsctrlDefineRootCredentials(
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PUCHAR InputBuffer,
    IN ULONG InputBufferLength);

NTSTATUS
DfsFsctrlUndefineLogicalRoot (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PFILE_DFS_DEF_ROOT_BUFFER pDlrParam,
    IN ULONG InputBufferLength
    );

NTSTATUS
DfsFsctrlGetLogicalRootPrefix (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PFILE_DFS_DEF_ROOT_BUFFER pDlrParam,
    IN ULONG InputBufferLength,
    IN OUT PUCHAR OutputBuffer,
    IN ULONG OutputBufferLength);

NTSTATUS
DfsFsctrlGetConnectedResources(
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PUCHAR  InputBuffer,
    IN ULONG cbInput,
    IN PUCHAR  OutputBuffer,
    IN ULONG OutputBufferLength);

NTSTATUS
DfsFsctrlGetServerName(
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PUCHAR  InputBuffer,
    IN ULONG   InputBufferLength,
    IN PUCHAR  OutputBuffer,
    IN ULONG OutputBufferLength);

NTSTATUS
DfsFsctrlReadMem (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PFILE_DFS_READ_MEM Request,
    IN ULONG InputBufferLength,
    IN OUT PUCHAR OutputBuffer,
    IN ULONG OutputBufferLength
    );

NTSTATUS
DfsFsctrlGetPktEntryState(
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PUCHAR  InputBuffer,
    IN ULONG cbInput,
    IN PUCHAR  OutputBuffer,
    IN ULONG OutputBufferLength);

NTSTATUS
DfsFsctrlGetPkt(
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PUCHAR  OutputBuffer,
    IN ULONG OutputBufferLength);

NTSTATUS
DfsGetEntryStateSize(
    IN ULONG Level,
    IN PUNICODE_STRING ServerName,
    IN PUNICODE_STRING ShareName,
    IN PDFS_PKT_ENTRY pktEntry,
    IN PULONG pcbOutBuffer);

NTSTATUS
DfsGetEntryStateMarshall(
    IN ULONG Level,
    IN PUNICODE_STRING ServerName,
    IN PUNICODE_STRING ShareName,
    IN PDFS_PKT_ENTRY pktEntry,
    IN PBYTE OutputBuffer,
    IN ULONG cbOutBuffer);

NTSTATUS
DfsFsctrlSetPktEntryState(
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PUCHAR  InputBuffer,
    IN ULONG cbInput);

NTSTATUS
DfsFsctrlGetSpcTable(
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PUCHAR  InputBuffer,
    IN ULONG InputBufferLength,
    IN PUCHAR  OutputBuffer,
    IN ULONG OutputBufferLength);

NTSTATUS
DfsSetPktEntryActive(
    IN PUNICODE_STRING ServerName,
    IN PUNICODE_STRING ShareName,
    IN PDFS_PKT_ENTRY pktEntry,
    IN DWORD State);

NTSTATUS
DfsSetPktEntryTimeout(
    IN PDFS_PKT_ENTRY pktEntry,
    IN ULONG Timeout);

NTSTATUS
DfsGetPktSize(
    OUT PULONG pSize);

NTSTATUS
DfsGetPktMarshall(
    IN PBYTE Buffer,
    IN ULONG Size);

NTSTATUS
DfsGetSpcTableNames(
    PIRP   Irp,
    PUCHAR OutputBuffer,
    ULONG  OutputBufferLength);

NTSTATUS
DfsExpSpcTableName(
    LPWSTR SpcName,
    PIRP   Irp,
    PUCHAR OutputBuffer,
    ULONG  OutputBufferLength);

NTSTATUS
DfsGetSpcDcInfo(
    PIRP   Irp,
    PUCHAR OutputBuffer,
    ULONG  OutputBufferLength);

NTSTATUS
DfsFsctrlSpcSetDc(
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PUCHAR  InputBuffer,
    IN ULONG cbInput);


NTSTATUS
DfsTreeConnectGetConnectionInfo(
    IN PDFS_SERVICE Service, 
    IN PDFS_CREDENTIALS Creds,
    IN OUT PUCHAR OutputBuffer,
    IN ULONG OutputBufferLength,
    OUT PULONG InfoLen);

NTSTATUS
DfsFsctrlGetConnectionPerfInfo(
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PUCHAR InputBuffer,
    IN ULONG InputBufferLength,
    IN OUT PUCHAR OutputBuffer,
    IN ULONG OutputBufferLength);

NTSTATUS
DfsFsctrlCscServerOffline(
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PUCHAR InputBuffer,
    IN ULONG InputBufferLength,
    IN OUT PUCHAR OutputBuffer,
    IN ULONG OutputBufferLength);

NTSTATUS
DfsFsctrlCscServerOnline(
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PUCHAR InputBuffer,
    IN ULONG InputBufferLength,
    IN OUT PUCHAR OutputBuffer,
    IN ULONG OutputBufferLength);

NTSTATUS
DfsFsctrlSpcRefresh (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PUCHAR  InputBuffer,
    IN ULONG InputBufferLength);

VOID
MupGetDebugFlags(VOID);

VOID
DfsGetEventLogValue(VOID);

VOID
DfsStopDfs();

void
DfsDumpBuf(
    PCHAR cp,
    ULONG len
);

BOOLEAN
DfspIsSpecialShare(
    PUNICODE_STRING ShareName);

BOOLEAN
DfspIsSysVolShare(
    PUNICODE_STRING ShareName);

extern
BOOLEAN DfsIsSpecialName( PUNICODE_STRING pName);

#define UNICODE_STRING_STRUCT(s) \
        {sizeof(s) - sizeof(WCHAR), sizeof(s) - sizeof(WCHAR), (s)}

static UNICODE_STRING SpecialShares[] = {
    UNICODE_STRING_STRUCT(L"PIPE"),
    UNICODE_STRING_STRUCT(L"IPC$"),
    UNICODE_STRING_STRUCT(L"ADMIN$"),
    UNICODE_STRING_STRUCT(L"MAILSLOT")
};

static UNICODE_STRING SysVolShares[] = {
    UNICODE_STRING_STRUCT(L"SYSVOL"),
    UNICODE_STRING_STRUCT(L"NETLOGON")
};


#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, DfsFsdFileSystemControl )
#pragma alloc_text( PAGE, DfsFspFileSystemControl )
#pragma alloc_text( PAGE, DfsCommonFileSystemControl )
#pragma alloc_text( PAGE, DfsUserFsctl )
#pragma alloc_text( PAGE, DfsFsctrlIsThisADfsPath )
#pragma alloc_text( PAGE, DfsOplockRequest )
#pragma alloc_text( PAGE, DfsFsctrlDefineLogicalRoot )
#pragma alloc_text( PAGE, DfsFsctrlDefineRootCredentials )
#pragma alloc_text( PAGE, DfsFsctrlUndefineLogicalRoot )
#pragma alloc_text( PAGE, DfsFsctrlGetLogicalRootPrefix )
#pragma alloc_text( PAGE, DfsFsctrlGetConnectedResources )
#pragma alloc_text( PAGE, DfsFsctrlGetServerName )
#pragma alloc_text( PAGE, DfsFsctrlReadMem )
#pragma alloc_text( PAGE, DfsStopDfs )
#pragma alloc_text( PAGE, DfspIsSpecialShare )
#pragma alloc_text( PAGE, DfspIsSysVolShare )
#pragma alloc_text( PAGE, DfsFsctrlGetPkt )
#pragma alloc_text( PAGE, DfsFsctrlGetPktEntryState )
#pragma alloc_text( PAGE, DfsGetEntryStateSize )
#pragma alloc_text( PAGE, DfsGetEntryStateMarshall )
#pragma alloc_text( PAGE, DfsFsctrlSetPktEntryState )
#pragma alloc_text( PAGE, DfsSetPktEntryActive )
#pragma alloc_text( PAGE, DfsSetPktEntryTimeout )
#pragma alloc_text( PAGE, DfsGetPktSize )
#pragma alloc_text( PAGE, DfsGetPktMarshall )
#pragma alloc_text( PAGE, DfsFsctrlGetSpcTable )
#pragma alloc_text( PAGE, DfsGetSpcTableNames )
#pragma alloc_text( PAGE, DfsExpSpcTableName )
#pragma alloc_text( PAGE, DfsGetSpcDcInfo )
#pragma alloc_text( PAGE, DfsFsctrlSpcSetDc )
#pragma alloc_text( PAGE, DfsTreeConnectGetConnectionInfo)
#pragma alloc_text( PAGE, DfsFsctrlGetConnectionPerfInfo)

#pragma alloc_text( PAGE, DfsFsctrlCscServerOffline)
#pragma alloc_text( PAGE, DfsFsctrlCscServerOnline)
#pragma alloc_text( PAGE, DfsFsctrlSpcRefresh)

#endif // ALLOC_PRAGMA



//+-------------------------------------------------------------------
//
//  Function:   DfsFsdFileSystemControl, public
//
//  Synopsis:   This routine implements the FSD part of FileSystem
//              control operations
//
//  Arguments:  [DeviceObject] -- Supplies the volume device object
//                      where the file exists
//              [Irp] -- Supplies the Irp being processed
//
//  Returns:    [NTSTATUS] -- The FSD status for the IRP
//
//--------------------------------------------------------------------

NTSTATUS
DfsFsdFileSystemControl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
) {
    BOOLEAN Wait;
    NTSTATUS Status;
    PIRP_CONTEXT IrpContext = NULL;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );
    ULONG FsControlCode = IrpSp->Parameters.FileSystemControl.FsControlCode;

    DfsDbgTrace(+1, Dbg, "DfsFsdFileSystemControl\n", 0);

    //
    //  Call the common FileSystem Control routine, with blocking allowed
    //  if synchronous.  This opeation needs to special case the mount
    //  and verify suboperations because we know they are allowed to block.
    //  We identify these suboperations by looking at the file object field
    //  and seeing if it's null.
    //

    if (IoGetCurrentIrpStackLocation(Irp)->FileObject == NULL) {

        Wait = TRUE;

    } else {

        Wait = CanFsdWait( Irp );

    }

    FsRtlEnterFileSystem();

    try {

        IrpContext = DfsCreateIrpContext( Irp, Wait );
        if (IrpContext == NULL)
            ExRaiseStatus(STATUS_INSUFFICIENT_RESOURCES);
        Status = DfsCommonFileSystemControl( DeviceObject, IrpContext, Irp );

    } except( DfsExceptionFilter( IrpContext, GetExceptionCode(), GetExceptionInformation() )) {

        //
        //  We had some trouble trying to perform the requested
        //  operation, so we'll abort the I/O request with
        //  the error status that we get back from the
        //  execption code
        //

        Status = DfsProcessException( IrpContext, Irp, GetExceptionCode() );
    }

    FsRtlExitFileSystem();

    //
    //  And return to our caller
    //

    DfsDbgTrace(-1, Dbg, "DfsFsdFileSystemControl -> %08lx\n", ULongToPtr(Status));

    return Status;
}


//+-------------------------------------------------------------------
//
//  Function:   DfsFspFileSystemControl, public
//
//  Synopsis:   This routine implements the FSP part of the file system
//              control operations
//
//  Arguments:  [Irp] -- Supplies the Irp being processed
//
//  Returns:    Nothing.
//
//--------------------------------------------------------------------

VOID
DfsFspFileSystemControl (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
) {
    DfsDbgTrace(+1, Dbg, "DfsFspFileSystemControl\n", 0);

    //
    //  Call the common FileSystem Control routine.
    //

    DfsCommonFileSystemControl( NULL, IrpContext, Irp );

    //
    //  And return to our caller
    //

    DfsDbgTrace(-1, Dbg, "DfsFspFileSystemControl -> VOID\n", 0 );

    return;
}


//+-------------------------------------------------------------------
//
//  Function:   DfsCommonFileSystemControl, local
//
//  Synopsis:   This is the common routine for doing FileSystem control
//              operations called by both the FSD and FSP threads
//
//  Arguments:  [DeviceObject] -- The one used to enter our FSD Routine
//              [IrpContext] -- Context associated with the Irp
//              [Irp] -- Supplies the Irp to process
//
//  Returns:    NTSTATUS - The return status for the operation
//--------------------------------------------------------------------

NTSTATUS
DfsCommonFileSystemControl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
) {
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp, NextIrpSp;
    ULONG FsControlCode;
    PFILE_OBJECT FileObject;
    //
    //  Get a pointer to the current Irp stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );
    FileObject = IrpSp->FileObject;

    DfsDbgTrace(+1, Dbg, "DfsCommonFileSystemControl\n", 0);
    DfsDbgTrace( 0, Dbg, "Irp                = %08lx\n", Irp);
    DfsDbgTrace( 0, Dbg, "MinorFunction      = %08lx\n", IrpSp->MinorFunction);

    //
    //  We know this is a file system control so we'll case on the
    //  minor function, and call a internal worker routine to complete
    //  the irp.
    //

    switch (IrpSp->MinorFunction) {

    case IRP_MN_USER_FS_REQUEST:

        FsControlCode = IrpSp->Parameters.FileSystemControl.FsControlCode;

        //
        // If the DFS FSCTL is issued via a device that is not the DFS 
        // file system device object, then reject the request.
        //
        if ((IS_DFS_CTL_CODE(FsControlCode) == 0) ||
            (DeviceObject == DfsData.FileSysDeviceObject)) {
            Status = DfsUserFsctl( IrpContext, Irp );
        }
        else {
            DfsDbgTrace(0, Dbg, "Invalid Device object for FS control %08lx\n",
	         	     DeviceObject);

            DfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_DEVICE_REQUEST );

            Status = STATUS_INVALID_DEVICE_REQUEST;
        }
        break;

    case IRP_MN_MOUNT_VOLUME:
    case IRP_MN_VERIFY_VOLUME:

        //
        // We are processing a MOUNT/VERIFY request being directed to our
        // our File System Device Object. We don't directly support
        // disk volumes, so we simply reject.
        //

        ASSERT(DeviceObject->DeviceType == FILE_DEVICE_DFS_FILE_SYSTEM);

        Status = STATUS_NOT_SUPPORTED;

        DfsCompleteRequest( IrpContext, Irp, Status );

        break;

    default:
      {
	PDFS_FCB Fcb;
	PDFS_VCB Vcb;

       if (DfsDecodeFileObject(IrpSp->FileObject, &Vcb, &Fcb) != RedirectedFileOpen) {

          DfsDbgTrace(0, Dbg, "Invalid FS Control Minor Function %08lx\n",
               IrpSp->MinorFunction);

          DfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_DEVICE_REQUEST );

          Status = STATUS_INVALID_DEVICE_REQUEST;

       }
       else {

          //
          // Copy the stack from one to the next...
          //
          NextIrpSp = IoGetNextIrpStackLocation(Irp);
          (*NextIrpSp) = (*IrpSp);

          IoSetCompletionRoutine(     Irp,
                                      NULL,
                                      NULL,
                                      FALSE,
                                      FALSE,
                                      FALSE);
  
          //
          //  Call to the real device for the file object.
          //

          Status = IoCallDriver( Fcb->TargetDevice, Irp );
          MUP_TRACE_ERROR_HIGH(Status, ALL_ERROR, DfsCommonFileSystemControl_Error_IoCallDriver,
                               LOGSTATUS(Status)
                               LOGPTR(Irp)
                               LOGPTR(FileObject)
                               LOGPTR(DeviceObject));
          //
          //  The IRP will be completed by the called driver.  We have
          //      no need for the IrpContext in the completion routine.
          //

          DfsDeleteIrpContext(IrpContext);
          IrpContext = NULL;
          Irp = NULL;
       }
        break;
      }
    }
    DfsDbgTrace(-1, Dbg, "DfsCommonFileSystemControl -> %08lx\n", ULongToPtr(Status) );

    return Status;
}


//+-------------------------------------------------------------------
//
//  Function:   DfsUserFsctl, local
//
//  Synopsis:   This is the common routine for implementing the user's
//              requests made through NtFsControlFile.
//
//  Arguments:  [Irp] -- Supplies the Irp being processed
//
//  Returns:    NTSTATUS - The return status for the operation
//
//--------------------------------------------------------------------

NTSTATUS
DfsUserFsctl (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
) {
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );
    PFILE_OBJECT FileObject = IrpSp->FileObject;
    PIO_STACK_LOCATION NextIrpSp;
    NTSTATUS Status;
    ULONG FsControlCode;

    ULONG cbOutput;
    ULONG cbInput;

    PUCHAR InputBuffer;
    PUCHAR OutputBuffer;

    PDFS_FCB Fcb;
    PDFS_VCB Vcb;

#ifdef TERMSRV
    ULONG SessionID;
#endif

    //
    // Just in case some-one (cough) forgets about it...
    // ...zero information status now!
    //

    Irp->IoStatus.Information = 0L;

    FsControlCode = IrpSp->Parameters.FileSystemControl.FsControlCode;

    cbInput = IrpSp->Parameters.FileSystemControl.InputBufferLength;

    cbOutput = IrpSp->Parameters.FileSystemControl.OutputBufferLength;

    DfsDbgTrace(+1, Dbg, "DfsUserFsctl:  Entered\n", 0);
    DfsDbgTrace( 0, Dbg, "DfsUserFsctl:  Cntrl Code  -> %08lx\n", ULongToPtr(FsControlCode) );
    DfsDbgTrace( 0, Dbg, "DfsUserFsctl:  cbInput   -> %08lx\n", ULongToPtr(cbInput) );
    DfsDbgTrace( 0, Dbg, "DfsUserFsctl:  cbOutput   -> %08lx\n", ULongToPtr(cbOutput) );

    //
    //  All DFS FsControlCodes use METHOD_BUFFERED, so the SystemBuffer
    //  is used for both the input and output.
    //

    InputBuffer = OutputBuffer = Irp->AssociatedIrp.SystemBuffer;

    DfsDbgTrace( 0, Dbg, "DfsUserFsctl:  InputBuffer -> %08lx\n", InputBuffer);
    DfsDbgTrace( 0, Dbg, "DfsUserFsctl:  UserBuffer  -> %08lx\n", Irp->UserBuffer);

    //
    //  Case on the control code.
    //

    switch ( FsControlCode ) {

    case FSCTL_REQUEST_OPLOCK_LEVEL_1:
    case FSCTL_REQUEST_OPLOCK_LEVEL_2:
    case FSCTL_REQUEST_BATCH_OPLOCK:
    case FSCTL_OPLOCK_BREAK_ACKNOWLEDGE:
    case FSCTL_OPBATCH_ACK_CLOSE_PENDING:
    case FSCTL_OPLOCK_BREAK_NOTIFY:

        Status = DfsOplockRequest( IrpContext, Irp );
        break;

    case FSCTL_DISMOUNT_VOLUME:
        Status = STATUS_NOT_SUPPORTED;
        DfsCompleteRequest(IrpContext, Irp, Status);
        break;

    case  FSCTL_DFS_GET_VERSION:
        if (OutputBuffer != NULL &&
                cbOutput >= sizeof(DFS_GET_VERSION_ARG)) {
            PDFS_GET_VERSION_ARG parg =
                (PDFS_GET_VERSION_ARG) OutputBuffer;
            parg->Version = 1;
            Status = STATUS_SUCCESS;
            Irp->IoStatus.Information = sizeof(DFS_GET_VERSION_ARG);
        } else {
            Status = STATUS_INVALID_PARAMETER;
        }
        DfsCompleteRequest(IrpContext, Irp, Status);
        break;

    case  FSCTL_DFS_STOP_DFS:
        DfsStopDfs();
        Status = STATUS_SUCCESS;
        DfsCompleteRequest(IrpContext, Irp, Status);
        break;


    case  FSCTL_DFS_IS_ROOT:
        Status = STATUS_INVALID_DOMAIN_ROLE;
        DfsCompleteRequest(IrpContext, Irp, Status);
        break;

    case  FSCTL_DFS_IS_VALID_PREFIX: {
            PDFS_IS_VALID_PREFIX_ARG PrefixArg;

            UNICODE_STRING fileName, pathName;

            PrefixArg = (PDFS_IS_VALID_PREFIX_ARG)InputBuffer;

            if (cbInput < sizeof(DFS_IS_VALID_PREFIX_ARG)
                    ||
                (ULONG)(FIELD_OFFSET(DFS_IS_VALID_PREFIX_ARG,RemoteName) +
                    PrefixArg->RemoteNameLen) > cbInput
            ) {
                Status = STATUS_INVALID_PARAMETER;
                DfsCompleteRequest(IrpContext, Irp, Status);
                break;
            }

            //
            // Reject negative and odd RemoteNameLen's
            //
            if (PrefixArg->RemoteNameLen < 0
                    ||
                (PrefixArg->RemoteNameLen & 0x1) != 0
            ) {
                Status = STATUS_INVALID_PARAMETER;
                DfsCompleteRequest(IrpContext, Irp, Status);
                break;
            }

            fileName.Length = PrefixArg->RemoteNameLen;
            fileName.MaximumLength = (USHORT) PrefixArg->RemoteNameLen;
            fileName.Buffer = (PWCHAR) PrefixArg->RemoteName;

            try {

                Status = DfsFsctrlIsThisADfsPath(
                             &fileName,
                             PrefixArg->CSCAgentCreate,
                             &pathName );

            } except (EXCEPTION_EXECUTE_HANDLER) {

                Status = STATUS_INVALID_PARAMETER;

            }

            DfsCompleteRequest(IrpContext, Irp, Status);

        }
        break;

    case  FSCTL_DFS_IS_VALID_LOGICAL_ROOT:
        if (cbInput == sizeof(WCHAR)) {

            UNICODE_STRING logRootName, Remaining;
            WCHAR buffer[3];
            PDFS_VCB Vcb;
	    LUID LogonID;

            buffer[0] = *((PWCHAR) InputBuffer);
            buffer[1] = UNICODE_DRIVE_SEP;
            buffer[2] = UNICODE_PATH_SEP;

            logRootName.Length = sizeof(buffer);
            logRootName.MaximumLength = sizeof(buffer);
            logRootName.Buffer = buffer;

	    DfsGetLogonId(&LogonID);

#ifdef TERMSRV
            Status = IoGetRequestorSessionId(Irp, &SessionID);

            if (NT_SUCCESS(Status)) {
                Status = DfsFindLogicalRoot(&logRootName, SessionID, &LogonID, &Vcb, &Remaining);
            }
#else
            Status = DfsFindLogicalRoot(&logRootName, &LogonID, &Vcb, &Remaining);
#endif

            if (!NT_SUCCESS(Status)) {
                DfsDbgTrace(0, Dbg, "Logical root not found!\n", 0);

                Status = STATUS_NO_SUCH_DEVICE;
            }

        } else {

            Status = STATUS_INVALID_PARAMETER;

        }
        DfsCompleteRequest(IrpContext, Irp, Status);
        break;

    case  FSCTL_DFS_PKT_SET_DC_NAME:
        Status = DfsFsctrlSetDCName(IrpContext,
                                    Irp,
                                    InputBuffer,
                                    cbInput);
        break;

    case  FSCTL_DFS_PKT_SET_DOMAINNAMEFLAT:
        Status = DfsFsctrlSetDomainNameFlat(IrpContext,
                                    Irp,
                                    InputBuffer,
                                    cbInput);
        break;

    case  FSCTL_DFS_PKT_SET_DOMAINNAMEDNS:
        Status = DfsFsctrlSetDomainNameDns(IrpContext,
                                    Irp,
                                    InputBuffer,
                                    cbInput);
        break;


    case  FSCTL_DFS_DEFINE_LOGICAL_ROOT:
        Status = DfsFsctrlDefineLogicalRoot( IrpContext, Irp,
                    (PFILE_DFS_DEF_ROOT_BUFFER)InputBuffer, cbInput);
        break;

    case  FSCTL_DFS_DELETE_LOGICAL_ROOT:
        Status = DfsFsctrlUndefineLogicalRoot( IrpContext, Irp,
                    (PFILE_DFS_DEF_ROOT_BUFFER)InputBuffer, cbInput);
        break;

    case  FSCTL_DFS_GET_LOGICAL_ROOT_PREFIX:
        Status = DfsFsctrlGetLogicalRootPrefix( IrpContext, Irp,
                    (PFILE_DFS_DEF_ROOT_BUFFER)InputBuffer, cbInput,
                    (PUCHAR)OutputBuffer, cbOutput);
        break;

    case  FSCTL_DFS_GET_CONNECTED_RESOURCES:
        Status = DfsFsctrlGetConnectedResources(IrpContext,
                                                Irp,
                                                InputBuffer,
                                                cbInput,
                                                OutputBuffer,
                                                cbOutput);
        break;

    case  FSCTL_DFS_DEFINE_ROOT_CREDENTIALS:
        Status = DfsFsctrlDefineRootCredentials(
                    IrpContext,
                    Irp,
                    InputBuffer,
                    cbInput);
        break;

    case  FSCTL_DFS_GET_SERVER_NAME:
        Status = DfsFsctrlGetServerName(IrpContext,
                                        Irp,
                                        InputBuffer,
                                        cbInput,
                                        OutputBuffer,
                                        cbOutput);
        break;

    case  FSCTL_DFS_SET_PKT_ENTRY_TIMEOUT:
        if (cbInput == sizeof(ULONG)) {
            DfsData.Pkt.EntryTimeToLive = *(PULONG) InputBuffer;
            Status = STATUS_SUCCESS;
        } else {
            Status = STATUS_INVALID_PARAMETER;
        }
        DfsCompleteRequest(IrpContext, Irp, Status);
        break;


    case  FSCTL_DFS_PKT_FLUSH_CACHE:
        Status = PktFsctrlFlushCache(IrpContext, Irp,
                                     InputBuffer, cbInput
                                );
        break;

    case  FSCTL_DFS_PKT_FLUSH_SPC_CACHE:
        Status = PktFsctrlFlushSpcCache(IrpContext, Irp,
                                        InputBuffer, cbInput
                                );
        break;

    case  FSCTL_DFS_GET_PKT_ENTRY_STATE:
        Status = DfsFsctrlGetPktEntryState(IrpContext,
                                           Irp,
                                           InputBuffer,
                                           cbInput,
                                           OutputBuffer,
                                           cbOutput);
        break;

    case  FSCTL_DFS_SET_PKT_ENTRY_STATE:
        Status = DfsFsctrlSetPktEntryState(IrpContext,
                                           Irp,
                                           InputBuffer,
                                           cbInput);
        break;

    case  FSCTL_DFS_GET_PKT:
        Status = DfsFsctrlGetPkt(IrpContext,
                                   Irp,
                                   OutputBuffer,
                                   cbOutput);
        break;


    case  FSCTL_DFS_GET_SPC_TABLE:
        Status = DfsFsctrlGetSpcTable(IrpContext,
                                           Irp,
                                           InputBuffer,
                                           cbInput,
                                           OutputBuffer,
                                           cbOutput);
        break;

    case FSCTL_DFS_SPECIAL_SET_DC:
        Status = DfsFsctrlSpcSetDc(IrpContext,
                                           Irp,
                                           InputBuffer,
                                           cbInput);
        break;

    case FSCTL_DFS_REREAD_REGISTRY:
        DfsGetEventLogValue();
#if DBG
        MupGetDebugFlags();
        DbgPrint("DfsDebugTraceLevel=0x%x\n", DfsDebugTraceLevel);
        DbgPrint("MupVerbose=0x%x\n", MupVerbose);
        DbgPrint("DfsEventLog=0x%x\n", DfsEventLog);
#endif  // DBG
        Status = STATUS_SUCCESS;
        DfsCompleteRequest(IrpContext, Irp, Status);
        break;

#if DBG

    case  FSCTL_DFS_INTERNAL_READ_MEM:
        Status = DfsFsctrlReadMem( IrpContext, Irp,
                    (PFILE_DFS_READ_MEM)InputBuffer, cbInput,
                                OutputBuffer, cbOutput );
        break;

    case  FSCTL_DFS_DBG_BREAK:
        DbgBreakPoint();
        Status = STATUS_SUCCESS;
        DfsCompleteRequest(IrpContext, Irp, Status);
        break;

    case  FSCTL_DFS_DBG_FLAGS:
        if (cbInput >= sizeof(ULONG))
            DfsDebugTraceLevel = * ((PULONG) InputBuffer);
        DbgPrint("DfsDebugTraceLevel=0x%x\n", DfsDebugTraceLevel);
        DbgPrint("MupVerbose=0x%x\n", MupVerbose);
        DbgPrint("DfsEventLog=0x%x\n", DfsEventLog);
        Status = STATUS_SUCCESS;
        DfsCompleteRequest(IrpContext, Irp, Status);
        break;

    case  FSCTL_DFS_VERBOSE_FLAGS:
        if (cbInput >= sizeof(ULONG))
            MupVerbose = * ((PULONG) InputBuffer);
        DbgPrint("DfsDebugTraceLevel=0x%x\n", DfsDebugTraceLevel);
        DbgPrint("MupVerbose=0x%x\n", MupVerbose);
        DbgPrint("DfsEventLog=0x%x\n", DfsEventLog);
        Status = STATUS_SUCCESS;
        DfsCompleteRequest(IrpContext, Irp, Status);
        break;

    case  FSCTL_DFS_EVENTLOG_FLAGS:
        if (cbInput >= sizeof(ULONG))
            DfsEventLog = * ((PULONG) InputBuffer);
        DbgPrint("DfsDebugTraceLevel=0x%x\n", DfsDebugTraceLevel);
        DbgPrint("MupVerbose=0x%x\n", MupVerbose);
        DbgPrint("DfsEventLog=0x%x\n", DfsEventLog);
        Status = STATUS_SUCCESS;
        DfsCompleteRequest(IrpContext, Irp, Status);
        break;

#endif  // DBG

    case FSCTL_DFS_GET_CONNECTION_PERF_INFO:
        Status = DfsFsctrlGetConnectionPerfInfo(IrpContext,
						Irp,
						InputBuffer,
						cbInput,
						OutputBuffer,
						cbOutput);
        break;
	

    case FSCTL_DFS_CSC_SERVER_OFFLINE:
        Status = DfsFsctrlCscServerOffline(IrpContext,
						Irp,
						InputBuffer,
						cbInput,
						OutputBuffer,
						cbOutput);
        break;
	

    case FSCTL_DFS_CSC_SERVER_ONLINE:
        Status = DfsFsctrlCscServerOnline(IrpContext,
						Irp,
						InputBuffer,
						cbInput,
						OutputBuffer,
						cbOutput);
        break;
	

    case FSCTL_DFS_SPC_REFRESH:
        Status = DfsFsctrlSpcRefresh(IrpContext,
						Irp,
						InputBuffer,
						cbInput);
        break;
	

    default:

        //
        //  It is not a recognized DFS fsctrl.  If it is for a redirected
        //  file, just pass it along to the underlying file system.
        //

        if (
            (IS_DFS_CTL_CODE(FsControlCode))
                ||
            (DfsDecodeFileObject( IrpSp->FileObject, &Vcb, &Fcb) != RedirectedFileOpen)
        ) {
            DfsDbgTrace(0, Dbg, "Dfs: Invalid FS control code -> %08lx\n", ULongToPtr(FsControlCode) );
            DfsCompleteRequest( IrpContext, Irp, STATUS_NOT_SUPPORTED);
            Status = STATUS_NOT_SUPPORTED;
            break;
        }

        //
        // Copy the stack from one to the next...
        //
        NextIrpSp = IoGetNextIrpStackLocation(Irp);
        (*NextIrpSp) = (*IrpSp);

        IoSetCompletionRoutine(     Irp,
                                    NULL,
                                    NULL,
                                    FALSE,
                                    FALSE,
                                    FALSE);

        //
        //  Call to the real device for the file object.
        //

        Status = IoCallDriver( Fcb->TargetDevice, Irp );
        MUP_TRACE_ERROR_HIGH(Status, ALL_ERROR, DfsUserFsctl_Error_IoCallDriver,
                             LOGSTATUS(Status)
                             LOGPTR(Irp)
                             LOGPTR(FileObject));
        //
        //  The IRP will be completed by the called driver.  We have
        //      no need for the IrpContext in the completion routine.
        //

        DfsDeleteIrpContext(IrpContext);
        IrpContext = NULL;
        Irp = NULL;
        break;

    }

    DfsDbgTrace(-1, Dbg, "DfsUserFsctl:  Exit -> %08lx\n", ULongToPtr(Status) );
    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   DfsOplockRequest, local
//
//  Synopsis:   DfsOplockRequest will process an oplock request.
//
//  Arguments:  [IrpContext] -
//              [Irp] -
//
//  Returns:    NTSTATUS - STATUS_SUCCESS if no error.
//                         STATUS_OPLOCK_NOT_GRANTED if the oplock is refuesed
//
//
//--------------------------------------------------------------------------

NTSTATUS
DfsOplockRequest (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
) {
    NTSTATUS Status;
    ULONG FsControlCode;
    PDFS_FCB Fcb;
    PDFS_VCB Vcb;
    TYPE_OF_OPEN TypeOfOpen;

    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );
    PFILE_OBJECT FileObject = IrpSp->FileObject;
    PIO_STACK_LOCATION NextIrpSp;


    BOOLEAN AcquiredVcb = FALSE;

    //
    //  Save some references to make our life a little easier
    //

    FsControlCode = IrpSp->Parameters.FileSystemControl.FsControlCode;

    DfsDbgTrace(+1, Dbg, "DfsOplockRequest...\n", 0);
    DfsDbgTrace( 0, Dbg, "FsControlCode = %08lx\n", ULongToPtr(FsControlCode) );

    //
    //  We only permit oplock requests on files.
    //

    if ((TypeOfOpen = DfsDecodeFileObject(IrpSp->FileObject, &Vcb, &Fcb))
                      != RedirectedFileOpen) {

        //
        // A bit bizarre that someone wants to oplock a device object, but
        // hey, if it makes them happy...
        //


        DfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        DfsDbgTrace(-1, Dbg, "DfsOplockRequest -> STATUS_INVALID_PARAMETER\n", 0);
        return STATUS_INVALID_PARAMETER;

    } else {

        //
        // RedirectedFileOpen - we pass the buck to the underlying FS.
        //


        NextIrpSp = IoGetNextIrpStackLocation(Irp);
        (*NextIrpSp) = (*IrpSp);
        IoSetCompletionRoutine(Irp, NULL, NULL, FALSE, FALSE, FALSE);

        //
        //      ...and call the next device
        //

        Status = IoCallDriver( Fcb->TargetDevice, Irp );
        MUP_TRACE_ERROR_HIGH(Status, ALL_ERROR, DfsOplockRequest_Error_IoCallDriver,
                             LOGSTATUS(Status)
                             LOGPTR(Irp)
                             LOGPTR(FileObject));
        DfsDeleteIrpContext( IrpContext );

        return(Status);

    }

}


//+----------------------------------------------------------------------------
//
//  Function:   DfsStopDfs, local
//
//  Synopsis:   "Stops" the Dfs client - causes Dfs to release all references
//              to provider device objects.
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

VOID
DfsStopDfs()
{
    ULONG i;
    PDFS_PKT_ENTRY pktEntry;
    PDFS_VCB Vcb;

    ExAcquireResourceExclusiveLite( &DfsData.Pkt.Resource, TRUE );

    ExAcquireResourceExclusiveLite( &DfsData.Resource, TRUE );

    //
    // Lets go through and release any opens to server IPC$ shares and
    // provider device objects.
    //

    for (pktEntry = PktFirstEntry(&DfsData.Pkt);
            pktEntry != NULL;
                pktEntry = PktNextEntry(&DfsData.Pkt, pktEntry)) {

        for (i = 0; i < pktEntry->Info.ServiceCount; i++) {

            if (pktEntry->Info.ServiceList[i].ConnFile != NULL) {

                ObDereferenceObject(
                    pktEntry->Info.ServiceList[i].ConnFile);

                pktEntry->Info.ServiceList[i].ConnFile = NULL;

            }

            if (pktEntry->Info.ServiceList[i].pMachEntry->AuthConn != NULL) {

                ObDereferenceObject(
                    pktEntry->Info.ServiceList[i].pMachEntry->AuthConn);

                pktEntry->Info.ServiceList[i].pMachEntry->AuthConn = NULL;

                pktEntry->Info.ServiceList[i].pMachEntry->Credentials->RefCount--;

                pktEntry->Info.ServiceList[i].pMachEntry->Credentials = NULL;

            }

            //
            // We are going to be closing all references to provider device
            // objects. So, clear the service's pointer to its provider.
            //

            pktEntry->Info.ServiceList[i].pProvider = NULL;

        }

    }

    for (i = 0; i < (ULONG) DfsData.cProvider; i++) {

        if (DfsData.pProvider[i].FileObject != NULL) {

            ObDereferenceObject( DfsData.pProvider[i].FileObject );
            DfsData.pProvider[i].FileObject = NULL;

            ASSERT( DfsData.pProvider[i].DeviceObject != NULL );

            ObDereferenceObject( DfsData.pProvider[i].DeviceObject );
            DfsData.pProvider[i].DeviceObject = NULL;

        }

    }

    ExReleaseResourceLite( &DfsData.Resource );

    ExReleaseResourceLite( &DfsData.Pkt.Resource );

}


//+----------------------------------------------------------------------------
//
//  Function:   DfsFsctrlIsThisADfsPath, local
//
//  Synopsis:   Determines whether a given path is a Dfs path or not.
//              The general algorithm is:
//
//                - Do a prefix lookup in the Pkt. If an entry is found, it's
//                  a Dfs path.
//                - Ask the Dfs service whether this is a domain based Dfs
//                  path. If so, it's a Dfs path.
//                - Finally, do an ZwCreateFile on the path name (assuming
//                  it's a Dfs path). If it succeeds, it's a Dfs path.
//
//  Arguments:  [filePath] - Name of entire file
//              [pathName] - If this is a Dfs path, this will return the
//                  component of filePath that was a Dfs path name (ie, the
//                  entry path of the Dfs volume that holds the file). The
//                  buffer will point to the same buffer as filePath, so
//                  nothing is allocated.
//
//  Returns:    [STATUS_SUCCESS] -- filePath is a Dfs path.
//
//              [STATUS_BAD_NETWORK_PATH] -- filePath is not a Dfs path.
//
//-----------------------------------------------------------------------------


NTSTATUS
DfsFsctrlIsThisADfsPath(
    IN PUNICODE_STRING  filePath,
    IN BOOLEAN          CSCAgentCreate,
    OUT PUNICODE_STRING pathName)
{
    NTSTATUS status;
    PDFS_PKT pkt;
    PDFS_PKT_ENTRY pktEntry;
    UNICODE_STRING dfsRootName, shareName, remPath;
    UNICODE_STRING RootShareName;
    USHORT i, j;
    BOOLEAN pktLocked;
    PDFS_SPECIAL_ENTRY pSpecialEntry;
    LARGE_INTEGER StartTime;
    LARGE_INTEGER EndTime;

    KeQuerySystemTime(&StartTime);
    DfsDbgTrace(+1, Dbg, "DfsFsctrlIsThisADfsPath: Entered %wZ\n", filePath);
#if DBG
    if (MupVerbose) {
        KeQuerySystemTime(&EndTime);
        DbgPrint("[%d] DfsFsctrlIsThisADfsPath: Entered %wZ\n",
            (ULONG)((EndTime.QuadPart - StartTime.QuadPart)/(10 * 1000)),
            filePath);
    }
#endif

    //
    // Only proceed if the first character is a backslash.
    //

    if (filePath->Buffer[0] != UNICODE_PATH_SEP) {
        status = STATUS_BAD_NETWORK_PATH;
        DfsDbgTrace(-1, Dbg, "filePath does not begin with backslash\n", 0);
        MUP_TRACE_HIGH(ERROR, DfsFsctrlIsThisADfsPath_Error_PathDoesNotBeginWithBackSlash,
                       LOGSTATUS(status));
        return( status );

    }

    //
    // Find the second component in the name.
    //

    for (i = 1;
            i < filePath->Length/sizeof(WCHAR) &&
                filePath->Buffer[i] != UNICODE_PATH_SEP;
                    i++) {

        NOTHING;

    }

    if (i >= filePath->Length/sizeof(WCHAR)) {
        status = STATUS_BAD_NETWORK_PATH;
        DfsDbgTrace(-1, Dbg, "Did not find second backslash\n", 0);

        MUP_TRACE_HIGH(ERROR, DfsFsctrlIsThisADfsPath_Error_DidNotFindSecondBackSlash,
                       LOGSTATUS(status));
        return( status );

    }

    status = DfspIsRootOnline(filePath, CSCAgentCreate);
    if (!NT_SUCCESS(status)) {
        return STATUS_BAD_NETWORK_PATH;
    }

    dfsRootName.Length = (i-1) * sizeof(WCHAR);
    dfsRootName.MaximumLength = dfsRootName.Length;
    dfsRootName.Buffer = &filePath->Buffer[1];

    if (dfsRootName.Length == 0) {
        status = STATUS_BAD_NETWORK_PATH;
        MUP_TRACE_HIGH(ERROR, DfsFsctrlIsThisADfsPath_Error_DfsRootNameHasZeroLength,
                       LOGSTATUS(status));

        return( status );

    }

    //
    // Figure out the share name
    //

    for (j = i+1;
            j < filePath->Length/sizeof(WCHAR) &&
                filePath->Buffer[j] != UNICODE_PATH_SEP;
                        j++) {

         NOTHING;

    }

    shareName.Length = (j - i - 1) * sizeof(WCHAR);
    shareName.MaximumLength = shareName.Length;
    shareName.Buffer = &filePath->Buffer[i+1];

    if (shareName.Length == 0) {
        status = STATUS_BAD_NETWORK_PATH;
        MUP_TRACE_HIGH(ERROR, DfsFsctrlIsThisADfsPath_Error_ShareNameHasZeroLength,
                       LOGSTATUS(status));

        return( status );

    }

    if (DfspIsSpecialShare(&shareName)) {
        status = STATUS_BAD_NETWORK_PATH;
        MUP_TRACE_HIGH(ERROR, DfsFsctrlIsThisADfsPath_Error_DfspIsSpecialShare_FALSE,
                       LOGUSTR(shareName)
                       LOGSTATUS(status));

        return( status );

    }


    //
    // For our purposes we only need to check the \\server\share part of the
    // filePath presented.  Any longer matches will be handled in the dnr loop -
    // we don't care about junction points below the root at this stage.
    //
    RootShareName.Buffer = filePath->Buffer;
    RootShareName.Length = j * sizeof(WCHAR);
    RootShareName.MaximumLength = filePath->MaximumLength;
#if DBG
    if (MupVerbose)
        DbgPrint("  RootShareName=[%wZ]\n", &RootShareName);
#endif

    //
    // First, do a prefix lookup. If we find an entry, it's a Dfs path
    //

    pkt = _GetPkt();

    PktAcquireShared( TRUE, &pktLocked );

    pktEntry = PktLookupEntryByPrefix( pkt, &RootShareName, &remPath );

    if (pktEntry != NULL && pktEntry->ExpireTime > 0) {

        DfsDbgTrace(-1, Dbg, "Found pkt entry %08lx\n", pktEntry);

        pathName->Length = RootShareName.Length - remPath.Length;
        pathName->MaximumLength = pathName->Length;
        pathName->Buffer = RootShareName.Buffer;

        PktRelease();
#if DBG
        if (MupVerbose) {
            KeQuerySystemTime(&EndTime);
            DbgPrint("[%d] DfsFsctrlIsThisADfsPath(1): exit STATUS_SUCCESS\n",
                (ULONG)((EndTime.QuadPart - StartTime.QuadPart)/(10 * 1000)));
        }
#endif
        return( STATUS_SUCCESS );

    }

#if DBG
    if (MupVerbose)  {
        if (pktEntry == NULL)
            DbgPrint("  No pkt entry found.\n");
        else
            DbgPrint("  Stale pkt entry 0x%x ExpireTime=%d\n", pktEntry, pktEntry->ExpireTime);
    }
#endif

    PktRelease();

    //
    // Nothing in the Pkt, check (by getting a referral) is this is a dfs
    //

    status = PktCreateDomainEntry( &dfsRootName, &shareName, CSCAgentCreate );

    if (NT_SUCCESS(status)) {

        pathName->Length = sizeof(UNICODE_PATH_SEP) + dfsRootName.Length;
        pathName->MaximumLength = pathName->Length;
        pathName->Buffer = RootShareName.Buffer;

        DfsDbgTrace(-1, Dbg, "Domain/Machine Dfs name %wZ\n", pathName );
#if DBG
        if (MupVerbose) {
            KeQuerySystemTime(&EndTime);
            DbgPrint("[%d] DfsFsctrlIsThisADfsPath(2): exit STATUS_SUCCESS\n",
                (ULONG)((EndTime.QuadPart - StartTime.QuadPart)/(10 * 1000)));
        }
#endif
        return( STATUS_SUCCESS );

    }

#if DBG
    if (MupVerbose) {
        KeQuerySystemTime(&EndTime);
        DbgPrint("  [%d] PktCreateDomainEntry() returned 0x%x\n",
            (ULONG)((EndTime.QuadPart - StartTime.QuadPart)/(10 * 1000)),
            status);
     }
#endif

    //
    // Failed getting referral - see if we have a stale one.
    //

    PktAcquireShared( TRUE, &pktLocked );

    pktEntry = PktLookupEntryByPrefix( pkt, &RootShareName, &remPath );

    if (pktEntry != NULL) {

#if DBG
        if (MupVerbose)
            DbgPrint("  Found stale pkt entry %08lx - adding 15 sec to it\n", pktEntry);
#endif
        DfsDbgTrace(-1, Dbg, "Found pkt entry %08lx\n", pktEntry);

        pathName->Length = RootShareName.Length - remPath.Length;
        pathName->MaximumLength = pathName->Length;
        pathName->Buffer = RootShareName.Buffer;

        if (pktEntry->ExpireTime <= 0) {
            pktEntry->ExpireTime = 15;
            pktEntry->TimeToLive = 15;
        }

        PktRelease();
#if DBG
        if (MupVerbose) {
            KeQuerySystemTime(&EndTime);
            DbgPrint("[%d] DfsFsctrlIsThisADfsPath(3): exit STATUS_SUCCESS\n",
                (ULONG)((EndTime.QuadPart - StartTime.QuadPart)/(10 * 1000)));
        }
#endif
        return( STATUS_SUCCESS );

    }

    PktRelease();

    if (DfspIsSysVolShare(&shareName)) {

#if DBG
        if (MupVerbose)
            DbgPrint("  Trying as sysvol\n");
#endif

        status = PktExpandSpecialName(&dfsRootName, &pSpecialEntry);

        if (NT_SUCCESS(status)) {

            InterlockedDecrement(&pSpecialEntry->UseCount);

#if DBG

            if (MupVerbose) {
                KeQuerySystemTime(&EndTime);
                DbgPrint("[%d] DfsFsctrlIsThisADfsPath(SYSVOL): exit STATUS_SUCCESS\n",
                    (ULONG)((EndTime.QuadPart - StartTime.QuadPart)/(10 * 1000)));
            }
#endif
            return STATUS_SUCCESS;

        }

    }

    if (DfsIsSpecialName(&dfsRootName)) {
        status = STATUS_SUCCESS;
        return status;
    }

    DfsDbgTrace(-1, Dbg, "Not A Dfs path\n", 0);
#if DBG
    if (MupVerbose) {
        KeQuerySystemTime(&EndTime);
        DbgPrint("[%d] DfsFsctrlIsThisADfsPath: exit STATUS_BAD_NETWORK_PATH\n",
            (ULONG)((EndTime.QuadPart - StartTime.QuadPart)/(10 * 1000)));
    }
#endif
    status = STATUS_BAD_NETWORK_PATH;
    MUP_TRACE_HIGH(ERROR, DfsFsctrlIsThisADfsPath_Exit_NotADfsPath,
               LOGSTATUS(status));

    return( STATUS_BAD_NETWORK_PATH );

}




//+----------------------------------------------------------------------------
//
//  Function:   DfspIsSpecialShare, local
//
//  Synopsis:   Sees if a share name is a special share.
//
//  Arguments:  [ShareName] -- Name of share to test.
//
//  Returns:    TRUE if special, FALSE otherwise.
//
//-----------------------------------------------------------------------------

BOOLEAN
DfspIsSpecialShare(
    PUNICODE_STRING ShareName)
{
    ULONG i;
    BOOLEAN fSpecial = FALSE;

    for (i = 0;
            (i < (sizeof(SpecialShares) / sizeof(SpecialShares[0]))) &&
                !fSpecial;
                    i++) {

        if (SpecialShares[i].Length == ShareName->Length) {

            if (_wcsnicmp(
                    SpecialShares[i].Buffer,
                        ShareName->Buffer,
                            ShareName->Length/sizeof(WCHAR)) == 0) {

                fSpecial = TRUE;

            }

        }

    }

    return( fSpecial );

}

//+----------------------------------------------------------------------------
//
//  Function:   DfspIsSysVolShare, local
//
//  Synopsis:   Sees if a share name is a sysvol share.
//
//  Arguments:  [ShareName] -- Name of share to test.
//
//  Returns:    TRUE if special, FALSE otherwise.
//
//-----------------------------------------------------------------------------

BOOLEAN
DfspIsSysVolShare(
    PUNICODE_STRING ShareName)
{
    ULONG i;
    BOOLEAN fSpecial = FALSE;

    for (i = 0;
            (i < (sizeof(SysVolShares) / sizeof(SysVolShares[0]))) &&
                !fSpecial;
                    i++) {

        if (SysVolShares[i].Length == ShareName->Length) {

            if (_wcsnicmp(
                    SysVolShares[i].Buffer,
                        ShareName->Buffer,
                            ShareName->Length/sizeof(WCHAR)) == 0) {

                fSpecial = TRUE;

            }

        }

    }

    return( fSpecial );

}


//+-------------------------------------------------------------------------
//
//  Function:   DfsFsctrlDefineLogicalRoot, local
//
//  Synopsis:   DfsFsctrlDefineLogicalRoot will create a new logical root structure.
//
//  Arguments:  [IrpContext] -
//              [Irp] -
//              [pDlrParam] -- Pointer to a FILE_DFS_DEF_ROOT_BUFFER,
//                      giving the name of the logical root to be created.
//              [InputBufferLength] -- Size of InputBuffer
//
//  Returns:    NTSTATUS - STATUS_SUCCESS if no error.
//
//  Notes:      This routine needs to be called from the FSP thread,
//              since IoCreateDevice (called from DfsInitializeLogicalRoot)
//              will fail if PreviousMode != KernelMode.
//
//--------------------------------------------------------------------------


NTSTATUS
DfsFsctrlDefineLogicalRoot (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PFILE_DFS_DEF_ROOT_BUFFER pDlrParam,
    IN ULONG InputBufferLength
) {
    NTSTATUS Status;
    UNICODE_STRING ustrPrefix;
    BOOLEAN pktLocked;
    PWCHAR wCp;
    PCHAR InputBufferEnd = (PCHAR)pDlrParam + InputBufferLength;
    ULONG i;
    LUID LogonID;

#ifdef TERMSRV
    ULONG SessionID;
#endif

    DfsDbgTrace(+1, Dbg, "DfsFsctrlDefineLogicalRoot...\n", 0);

    //
    //  Reference the input buffer and make sure it's large enough
    //

    if (InputBufferLength < sizeof (FILE_DFS_DEF_ROOT_BUFFER)) {
        DfsDbgTrace(0, Dbg, "Input buffer is too small\n", 0);
        DfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        Status = STATUS_INVALID_PARAMETER;
        DfsDbgTrace(-1, Dbg, "DfsFsctrlDefineLogicalRoot -> %08lx\n", ULongToPtr(Status) );
        return Status;
    }

    //
    // Verify there's a null someplace in the LogicalRoot buffer
    //

    for (i = 0; i < MAX_LOGICAL_ROOT_NAME && pDlrParam->LogicalRoot[i]; i++)
        NOTHING;

    if (i >= MAX_LOGICAL_ROOT_NAME) {
        Status = STATUS_INVALID_PARAMETER;
        DfsCompleteRequest( IrpContext, Irp, Status );
        DfsDbgTrace(-1, Dbg, "DfsFsctrlDefineLogicalRoot -> %08lx\n", ULongToPtr(Status) );
        return Status;
    }
    
    //
    // Verify there's a null someplace in the RootPrefix buffer
    //

    for (wCp = &pDlrParam->RootPrefix[0]; wCp < (PWCHAR)InputBufferEnd && *wCp; wCp++) {
        NOTHING;
    }

    if (wCp >= (PWCHAR)InputBufferEnd) {
        Status = STATUS_INVALID_PARAMETER;
        DfsCompleteRequest( IrpContext, Irp, Status );
        DfsDbgTrace(-1, Dbg, "DfsFsctrlDefineLogicalRoot -> %08lx\n", ULongToPtr(Status) );
        return Status;
    }

    //
    //  We can insert logical roots only from the FSP, because IoCreateDevice
    //  will fail if previous mode != Kernel mode.
    //

    if ((IrpContext->Flags & IRP_CONTEXT_FLAG_IN_FSD) != 0) {
        DfsDbgTrace(0, Dbg, "DfsFsctrlDefineLogicalRoot: Posting to FSP\n", 0);

        Status = DfsFsdPostRequest( IrpContext, Irp );

        DfsDbgTrace(-1, Dbg, "DfsFsctrlDefineLogicalRoot: Exit -> %08lx\n", ULongToPtr(Status) );

        return(Status);
    }

    //
    // Since we are going to muck with DfsData's VcbQueue, we acquire it
    // exclusively.
    //

    RtlInitUnicodeString(&ustrPrefix, pDlrParam->RootPrefix);

    PktAcquireExclusive( TRUE, &pktLocked );

    ExAcquireResourceExclusiveLite(&DfsData.Resource, TRUE);


    Status = DfsGetLogonId(&LogonID);

#ifdef TERMSRV

    Status = IoGetRequestorSessionId(Irp, &SessionID);

    if( NT_SUCCESS( Status ) ) {
        Status =
            DfsInitializeLogicalRoot(
                (PWSTR) pDlrParam->LogicalRoot,
                &ustrPrefix,
                NULL,
                0,
                SessionID,
		&LogonID );
    }

#else // TERMSRV

    Status = DfsInitializeLogicalRoot(
                        (PWSTR) pDlrParam->LogicalRoot,
                        &ustrPrefix,
                        NULL,
                        0,
			&LogonID );

#endif // TERMSRV

    ExReleaseResourceLite(&DfsData.Resource);

    PktRelease();

    DfsCompleteRequest(IrpContext, Irp, Status);

    DfsDbgTrace(-1, Dbg, "DfsFsctrlDefineLogicalRoot -> %08lx\n", ULongToPtr(Status) );

    return Status;
}


//+----------------------------------------------------------------------------
//
//  Function:   DfsFsctrlUndefineLogicalRoot
//
//  Synopsis:   Deletes an existing logical root structure.
//
//  Arguments:  [IrpContext] --
//              [Irp] --
//              [pDlrParam] -- The LogicalRoot field of this structure will
//                      contain the name of the logical root to be deleted.
//              [InputBufferLength] -- Length of pDlrParam
//
//  Returns:    Yes ;-)
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsFsctrlUndefineLogicalRoot (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PFILE_DFS_DEF_ROOT_BUFFER pDlrParam,
    IN ULONG InputBufferLength)
{
    NTSTATUS Status;
    BOOLEAN pktLocked;
    ULONG i;
    PWCHAR wCp;
    PCHAR InputBufferEnd = (PCHAR)pDlrParam + InputBufferLength;
    LUID LogonID ;
#ifdef TERMSRV
    ULONG SessionID;
#endif

    DfsDbgTrace(+1, Dbg, "DfsFsctrlUndefineLogicalRoot...\n", 0);

    //
    //  Reference the input buffer and make sure it's large enough
    //

    if (InputBufferLength < sizeof (FILE_DFS_DEF_ROOT_BUFFER)) {
        DfsDbgTrace(0, Dbg, "Input buffer is too small\n", 0);

        DfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        Status = STATUS_INVALID_PARAMETER;

        DfsDbgTrace(-1, Dbg, "DfsFsctrlUndefineLogicalRoot -> %08lx\n", ULongToPtr(Status) );
        return Status;
    }

    DfsGetLogonId( &LogonID );
    //
    // Verify there's a null someplace in the LogicalRoot buffer
    //

    for (i = 0; i < MAX_LOGICAL_ROOT_NAME && pDlrParam->LogicalRoot[i]; i++)
        NOTHING;

    if (i >= MAX_LOGICAL_ROOT_NAME) {
        Status = STATUS_INVALID_PARAMETER;
        DfsCompleteRequest( IrpContext, Irp, Status );
        DfsDbgTrace(-1, Dbg, "DfsFsctrlUndefineLogicalRoot -> %08lx\n", ULongToPtr(Status) );
        return Status;
    }

    if (pDlrParam->LogicalRoot[0] == UNICODE_NULL) {

        //
        // Verify there's a null someplace in the RootPrefix buffer
        //

        for (wCp = &pDlrParam->RootPrefix[0]; wCp < (PWCHAR)InputBufferEnd && *wCp; wCp++) {
            NOTHING;
        }

        if (wCp >= (PWCHAR)InputBufferEnd) {
            Status = STATUS_INVALID_PARAMETER;
            DfsCompleteRequest( IrpContext, Irp, Status );
            DfsDbgTrace(-1, Dbg, "DfsFsctrlUnDefineLogicalRoot -> %08lx\n", ULongToPtr(Status) );
            return Status;
        }

    }

#ifdef TERMSRV

    if ( !NT_SUCCESS(IoGetRequestorSessionId(Irp, &SessionID)) ) {
        Status = STATUS_INVALID_PARAMETER;
        DfsCompleteRequest( IrpContext, Irp, Status );
        DfsDbgTrace(-1, Dbg, "DfsFsctrlUndefineLogicalRoot -> %08lx\n", ULongToPtr(Status) );
        return Status;
    }

#endif

    //
    //  We can remove logical roots only from the FSP
    //

    if (pDlrParam->LogicalRoot[0] != UNICODE_NULL) {

        DfsDbgTrace(0, Dbg, "Deleting root [%ws]\n", pDlrParam->LogicalRoot);

#ifdef TERMSRV

        Status =
            DfsDeleteLogicalRoot(
                (PWSTR) pDlrParam->LogicalRoot,
                pDlrParam->fForce,
                SessionID,
                &LogonID );
#else // TERMSRV

        Status = DfsDeleteLogicalRoot(
                    (PWSTR) pDlrParam->LogicalRoot,
                    pDlrParam->fForce,
                    &LogonID);

#endif // TERMSRV

        DfsDbgTrace(0, Dbg, "DfsDeleteLogicalRoot returned %08lx\n", ULongToPtr(Status) );

    } else {
        UNICODE_STRING name;
        RtlInitUnicodeString(&name, pDlrParam->RootPrefix);

        DfsDbgTrace(0, Dbg, "Deleting connection to [%wZ]\n", &name);

#ifdef TERMSRV

        Status = DfsDeleteDevlessRoot(
		    &name,		
		    SessionID,
		    &LogonID );
#else // TERMSRV

        Status = DfsDeleteDevlessRoot(
                    &name,
                    &LogonID);

#endif // TERMSRV
    }

    DfsCompleteRequest(IrpContext, Irp, Status);

    DfsDbgTrace(-1, Dbg, "DfsFsctrlUndefineLogicalRoot -> %08lx\n", ULongToPtr(Status) );

    return Status;

}


//+----------------------------------------------------------------------------
//
//  Function:   DfsFsctrlGetLogicalRootPrefix
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsFsctrlGetLogicalRootPrefix (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PFILE_DFS_DEF_ROOT_BUFFER pDlrParam,
    IN ULONG InputBufferLength,
    IN OUT PUCHAR OutputBuffer,
    IN ULONG OutputBufferLength)
{
    NTSTATUS Status;
    UNICODE_STRING RootPath, Remaining;
    PDFS_VCB           Vcb;
    WCHAR          RootBuffer[MAX_LOGICAL_ROOT_NAME + 2];
    BOOLEAN        bAcquired = FALSE;
    ULONG          i;
    USHORT         PrefixLength;
    LUID LogonID;


#ifdef TERMSRV
    ULONG SessionID;
#endif

    DfsDbgTrace(+1, Dbg, "DfsFsctrlGetLogicalRootPrefix...\n", 0);

    //
    //  Reference the input buffer and make sure it's large enough
    //

    if (InputBufferLength < sizeof (FILE_DFS_DEF_ROOT_BUFFER)) {
        DfsDbgTrace(0, Dbg, "Input buffer is too small\n", 0);
        Status = STATUS_INVALID_PARAMETER;
        DfsDbgTrace(-1, Dbg, "DfsFsctrlGetLogicalRootPrefix -> %08lx\n", ULongToPtr(Status) );
        goto Cleanup;
    }

    //
    // Verify there's a null someplace in the buffer
    //

    for (i = 0; i < MAX_LOGICAL_ROOT_NAME && pDlrParam->LogicalRoot[i]; i++)
        NOTHING;

    if (i >= MAX_LOGICAL_ROOT_NAME) {
        Status = STATUS_INVALID_PARAMETER;
        DfsDbgTrace(-1, Dbg, "DfsFsctrlGetLogicalRootPrefix -> %08lx\n", ULongToPtr(Status) );
        goto Cleanup;
    }

    RootPath.Buffer = RootBuffer;
    RootPath.Length = 0;
    RootPath.MaximumLength = sizeof RootBuffer;

    Status = DfspLogRootNameToPath(pDlrParam->LogicalRoot, &RootPath);
    if (!NT_SUCCESS(Status)) {
        DfsDbgTrace(0, Dbg, "Input name is too big\n", 0);
        Status = STATUS_INVALID_PARAMETER;

        DfsDbgTrace(-1, Dbg, "DfsFsctrlGetLogicalRootPrefix -> %08lx\n", ULongToPtr(Status) );
        goto Cleanup;
    }

    bAcquired = ExAcquireResourceSharedLite(&DfsData.Resource, TRUE);

    DfsGetLogonId(&LogonID);

#ifdef TERMSRV

    Status = IoGetRequestorSessionId(Irp, &SessionID);

    if( NT_SUCCESS( Status ) ) {

        Status = DfsFindLogicalRoot( &RootPath, SessionID, &LogonID, &Vcb, &Remaining);
    }

#else // TERMSRV

    Status = DfsFindLogicalRoot(&RootPath, &LogonID, &Vcb, &Remaining);

#endif // TERMSRV

    if (!NT_SUCCESS(Status)) {
        DfsDbgTrace(0, Dbg, "Logical root not found!\n", 0);

        Status = STATUS_NO_SUCH_DEVICE;

        DfsDbgTrace(-1, Dbg, "DfsFsctrlGetLogicalRootPrefix -> %08lx\n", ULongToPtr(Status) );
        goto Cleanup;
    }

    PrefixLength = Vcb->LogRootPrefix.Length;

    if ((PrefixLength + sizeof(UNICODE_NULL)) > OutputBufferLength) {

        //
        // Return required length in IoStatus.Information.
        //

        RETURN_BUFFER_SIZE( PrefixLength + sizeof(UNICODE_NULL), Status );

        DfsDbgTrace(0, Dbg, "Output buffer too small\n", 0);
        DfsDbgTrace(-1, Dbg, "DfsFsctrlGetLogicalRootPrefix -> %08lx\n", ULongToPtr(Status) );
        goto Cleanup;
    }

    //
    // All ok, copy prefix and get out.
    //

    if (PrefixLength > 0) {
        RtlMoveMemory(
            OutputBuffer,
            Vcb->LogRootPrefix.Buffer,
            PrefixLength);
    }
    ((PWCHAR) OutputBuffer)[PrefixLength/sizeof(WCHAR)] = UNICODE_NULL;
    Irp->IoStatus.Information = Vcb->LogRootPrefix.Length + sizeof(UNICODE_NULL);
    Status = STATUS_SUCCESS;

Cleanup:
    if (bAcquired) {
        ExReleaseResourceLite(&DfsData.Resource);
    }
    DfsCompleteRequest(IrpContext, Irp, Status);

    return(Status);
}


//+----------------------------------------------------------------------------
//
//  Function:   DfsFsctrlGetConnectedResources
//
//  Synopsis:   Returns LPNETRESOURCE structures for each Logical Root,
//              starting from the logical root indicated in the InputBuffer
//              and including as many as will fit in OutputBuffer.
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------
NTSTATUS
DfsFsctrlGetConnectedResources(
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PUCHAR  InputBuffer,
    IN ULONG InputBufferLength,
    IN PUCHAR  OutputBuffer,
    IN ULONG OutputBufferLength)
{

    NTSTATUS    Status = STATUS_SUCCESS;
    PLIST_ENTRY Link;
    PDFS_DEVLESS_ROOT pDrt;
    PDFS_VCB    pVcb;
    ULONG       count = 0;
    ULONG       remLen;
    ULONG       skipNum;
    ULONG       DFS_UNALIGNED *retCnt;
    UNICODE_STRING      providerName;
    PUCHAR      buf = OutputBuffer;
    BOOLEAN     providerNameAllocated;
    LUID        LogonID;
    ULONG       ResourceSize;

#ifdef TERMSRV
    ULONG SessionID;
#endif

    STD_FSCTRL_PROLOGUE(DfsFsctrlGetConnectedResources, TRUE, TRUE, FALSE);

#ifdef TERMSRV

    //
    // Get SessionID of this request first.
    //

    Status = IoGetRequestorSessionId(Irp, &SessionID);

    if( !NT_SUCCESS(Status) ) {

        Status = STATUS_INVALID_PARAMETER;

        DfsCompleteRequest( IrpContext, Irp, Status );

        DfsDbgTrace(-1,Dbg,
            "DfsFsctrlGetConnectedResources: Exit->%08lx\n", ULongToPtr(Status) );

        return Status;
    }

#endif

    if (OutputBufferLength < sizeof(ULONG)) {

        Status = STATUS_BUFFER_TOO_SMALL;

        DfsCompleteRequest( IrpContext, Irp, Status );

        DfsDbgTrace(-1,Dbg,
            "DfsFsctrlGetConnectedResources: Exit->%08lx\n", ULongToPtr(Status) );

        return( Status );
    }

    if (InputBufferLength < sizeof(DWORD))     {

        Status = STATUS_INVALID_PARAMETER;

        DfsCompleteRequest( IrpContext, Irp, Status );

        DfsDbgTrace(-1,Dbg,
            "DfsFsctrlGetConnectedResources: Exit->%08lx\n", ULongToPtr(Status) );

        return Status;

    }

    if (InputBufferLength == sizeof(DWORD)) {

        skipNum = *((ULONG *) InputBuffer);

        providerName.Length = sizeof(DFS_PROVIDER_NAME) - sizeof(UNICODE_NULL);
        providerName.MaximumLength = sizeof(DFS_PROVIDER_NAME);
        providerName.Buffer = DFS_PROVIDER_NAME;

        providerNameAllocated = FALSE;

    } else {

        skipNum = 0;

        providerName.Length =
            (USHORT) (InputBufferLength - sizeof(UNICODE_NULL));
        providerName.MaximumLength = (USHORT) InputBufferLength;
        providerName.Buffer = ExAllocatePoolWithTag(PagedPool, InputBufferLength, ' puM');

        if (providerName.Buffer != NULL) {

            providerNameAllocated = TRUE;

            RtlCopyMemory(
                providerName.Buffer,
                InputBuffer,
                InputBufferLength);

        } else {

            Status = STATUS_INSUFFICIENT_RESOURCES;

            DfsCompleteRequest( IrpContext, Irp, Status );

            DfsDbgTrace(-1,Dbg,
                "DfsFsctrlGetConnectedResources: Exit->%08lx\n", ULongToPtr(Status) );

            return Status;

        }

    }

    RtlZeroMemory(OutputBuffer, OutputBufferLength);

    remLen = OutputBufferLength-sizeof(ULONG);

    retCnt =  (ULONG *) (OutputBuffer + remLen);

    DfsGetLogonId(&LogonID);

    ExAcquireResourceSharedLite(&DfsData.Resource, TRUE);

    //
    // First get the device-less connections
    //

    for (Link = DfsData.DrtQueue.Flink;
            Link != &DfsData.DrtQueue;
                Link = Link->Flink ) {

	pDrt =  CONTAINING_RECORD( Link, DFS_DEVLESS_ROOT, DrtLinks );

#ifdef TERMSRV
	if( (SessionID != INVALID_SESSIONID) &&
	        (SessionID == pDrt->SessionID) &&
	             RtlEqualLuid(&pDrt->LogonID, &LogonID) ) {
#else // TERMSRV
        if ( RtlEqualLuid(&pDrt->LogonID, &LogonID) ) {
#endif

            if (skipNum > 0) {
                skipNum--;
            } else {
                //
                // Report devices for this session only
                //
                Status = DfsGetResourceFromDevlessRoot(
                            Irp,
                            pDrt,
                            &providerName,
                            OutputBuffer,
                            buf,
                            &remLen,
                            &ResourceSize);

                if (!NT_SUCCESS(Status))
                    break;

                buf = buf + ResourceSize;

                count++;
            }
        }
    }

    //
    // Next, get the Device connections
    //

    if (NT_SUCCESS(Status)) {

        for (Link = DfsData.VcbQueue.Flink;
                Link != &DfsData.VcbQueue;
                    Link = Link->Flink ) {

            pVcb = CONTAINING_RECORD( Link, DFS_VCB, VcbLinks );

#ifdef TERMSRV
            if( (pVcb->LogicalRoot.Length == sizeof(WCHAR)) &&
                    (SessionID != INVALID_SESSIONID) &&
                        (SessionID == pVcb->SessionID) &&
	                      RtlEqualLuid(&pVcb->LogonID, &LogonID) ) {
#else // TERMSRV
            if ((pVcb->LogicalRoot.Length == sizeof(WCHAR)) &&
	                RtlEqualLuid(&pVcb->LogonID, &LogonID) ) {
#endif

                if (skipNum > 0) {

                    skipNum--;

                } else {

                    Status = DfsGetResourceFromVcb(
                                Irp,
                                pVcb,
                                &providerName,
                                OutputBuffer,
                                buf,
                                &remLen,
                                &ResourceSize);

                    if (!NT_SUCCESS(Status))
                        break;

                    buf = buf + ResourceSize;

                    count++;
                }
            }
        }
    }

    if (!NT_SUCCESS(Status)) {
        //
        // Now if we did not get atleast one in, then we need to return
        // required size which is in remLen.
        //
        if (count == 0) {

            // the + sizeof(ULONG) is for cnt size

            RETURN_BUFFER_SIZE( remLen + sizeof(ULONG), Status );

            DfsDbgTrace(0, Dbg, "Output buffer too small\n", 0);

        } else if (Status == STATUS_BUFFER_OVERFLOW) {

            *retCnt = count;

            Irp->IoStatus.Information = OutputBufferLength;

            DfsDbgTrace(0, Dbg, "Could not fill in all RESOURCE structs \n", 0);

        } else {

            //
            // Dont know why we should get any other error code.
            //

            ASSERT(Status == STATUS_BUFFER_OVERFLOW);
        }
    } else {

        //
        // Everything went smoothly.
        //

        DfsDbgTrace(0, Dbg, "Succeeded in getting all Resources \n", 0);

        *retCnt = count;

        Irp->IoStatus.Information = OutputBufferLength;
    }

    if (providerNameAllocated == TRUE) {

        ExFreePool(providerName.Buffer);

    }

    ExReleaseResourceLite(&DfsData.Resource);

    DfsCompleteRequest( IrpContext, Irp, Status );

    DfsDbgTrace(-1,Dbg,"DfsFsctrlGetConnectedResources: Exit->%08lx\n", ULongToPtr(Status) );

    return Status;
}

	


//+----------------------------------------------------------------------------
//
//  Function:   DfsFsctrlDefineRootCredentials
//
//  Synopsis:   Creates a new logical root, a new user credential record, or
//              both.
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsFsctrlDefineRootCredentials(
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PUCHAR InputBuffer,
    IN ULONG InputBufferLength)
{
    NTSTATUS status = STATUS_SUCCESS;
    PFILE_DFS_DEF_ROOT_CREDENTIALS def;
    PDFS_CREDENTIALS creds = NULL;
    ULONG prefixIndex;
    UNICODE_STRING prefix;
    BOOLEAN deviceless = FALSE;
    LUID  LogonID;

#ifdef TERMSRV
    ULONG SessionID;
#endif

    //
    // We must do this from the FSP because IoCreateDevice will fail if
    // PreviousMode != KernelMode
    //

    STD_FSCTRL_PROLOGUE(DfsFsctrlDefineRootCredentials, TRUE, FALSE, FALSE);

    //
    // Validate our parameters, best we can.
    //

    if (InputBufferLength < sizeof(FILE_DFS_DEF_ROOT_CREDENTIALS)) {

        status = STATUS_INVALID_PARAMETER;
        DfsCompleteRequest( IrpContext, Irp, status );
        DfsDbgTrace(-1,Dbg,"DfsFsctrlDefineRootCredentials: Exit->%08lx\n", ULongToPtr(status) );
        return status;

    }

    def = (PFILE_DFS_DEF_ROOT_CREDENTIALS) InputBuffer;

    prefixIndex = (def->DomainNameLen +
                        def->UserNameLen +
                            def->PasswordLen +
                                def->ServerNameLen +
                                    def->ShareNameLen) / sizeof(WCHAR);

    prefix.MaximumLength = prefix.Length = def->RootPrefixLen;
    prefix.Buffer = &def->Buffer[ prefixIndex ];

    if (
        !UNICODESTRING_IS_VALID(prefix, InputBuffer, InputBufferLength)
            ||
        (prefix.Length < (4 * sizeof(WCHAR)))
            ||
        (prefix.Buffer[0] != UNICODE_PATH_SEP)
        ) {

            status = STATUS_INVALID_PARAMETER;
            DfsCompleteRequest( IrpContext, Irp, status );
            DfsDbgTrace(-1,Dbg,"DfsFsctrlDefineRootCredentials: Exit->%08lx\n", ULongToPtr(status) );
            return status;

        }

    deviceless = (BOOLEAN) (def->LogicalRoot[0] == UNICODE_NULL);

#ifdef TERMSRV

    if (NT_SUCCESS(status)) {

        status = IoGetRequestorSessionId(Irp, &SessionID);

        if (!NT_SUCCESS(status) ) {
            status = STATUS_INVALID_PARAMETER;
        }
    }

#endif
    //
    // Now get the LogonID.
    //
    if (NT_SUCCESS(status)) {
	status = DfsGetLogonId(&LogonID);

    }

    //
    // First, create the credentials.
    //

    if (NT_SUCCESS(status)) {

#ifdef TERMSRV

        status = DfsCreateCredentials(def, 
				      InputBufferLength, 
				      SessionID, 
				      &LogonID,
				      &creds );


#else // TERMSRV

        status = DfsCreateCredentials(def, 
				      InputBufferLength, 
				      &LogonID,
				      &creds );


#endif // TERMSRV

        if (NT_SUCCESS(status)) {

            //
            // Verify the credentials if the username, domainname, or
            // password are not null
            //

            if ((def->DomainNameLen > 0) ||
                    (def->UserNameLen > 0) ||
                        (def->PasswordLen > 0)) {

                status = DfsVerifyCredentials( &prefix, creds );

            }

            if (NT_SUCCESS(status)) {

                PDFS_CREDENTIALS existingCreds;

                status = DfsInsertCredentials( &creds, deviceless );

                if (status == STATUS_OBJECT_NAME_COLLISION) {

                    status = STATUS_SUCCESS;

                }

            }

            if (!NT_SUCCESS(status))
                DfsFreeCredentials( creds );

        }
    }

    //
    // Next, try and create the logical root, if specified
    //

    if (NT_SUCCESS(status)) { 
        BOOLEAN pktLocked;

        PktAcquireExclusive( TRUE, &pktLocked );

        ExAcquireResourceExclusiveLite(&DfsData.Resource, TRUE);

	if (!deviceless) {
	    USHORT  VcbStateFlags = 0;

	    if (def->CSCAgentCreate) {
		VcbStateFlags |= VCB_STATE_CSCAGENT_VOLUME;
	    }

#ifdef TERMSRV

	    status = DfsInitializeLogicalRoot(
				(PWSTR) def->LogicalRoot,
				&prefix,
				creds,
				VcbStateFlags,
				SessionID,
				&LogonID );

#else // TERMSRV

	    status = DfsInitializeLogicalRoot(
				(PWSTR) def->LogicalRoot,
				&prefix,
				creds,
				VcbStateFlags,
				&LogonID );

#endif // TERMSRV
	}
	else {
#ifdef TERMSRV
	    status = DfsInitializeDevlessRoot(
				&prefix,
				creds,
				SessionID,
				&LogonID );
#else // TERMSRV
	    status = DfsInitializeDevlessRoot(
				&prefix,
				creds,
				&LogonID );
#endif // TERMSRV					     

	}

	if (status != STATUS_SUCCESS) {
	    DfsDeleteCredentials( creds );
        }

        ExReleaseResourceLite(&DfsData.Resource);

        PktRelease();

    }

    DfsCompleteRequest( IrpContext, Irp, status );
    DfsDbgTrace(-1,Dbg,"DfsFsctrlDefineRootCredentials: Exit->%08lx\n", ULongToPtr(status) );
    return status;
}


//+----------------------------------------------------------------------------
//
//  Function:   DfsFsctrlGetServerName
//
//  Synopsis:   Given a Prefix in Dfs namespace it gets a server name for
//              it.
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------
NTSTATUS
DfsFsctrlGetServerName(
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PUCHAR  InputBuffer,
    IN ULONG   InputBufferLength,
    IN PUCHAR  OutputBuffer,
    IN ULONG OutputBufferLength)
{
    NTSTATUS            status = STATUS_SUCCESS;
    PDFS_PKT            pkt;
    PDFS_PKT_ENTRY      pEntry;
    UNICODE_STRING      ustrPrefix, RemainingPath;
    PWCHAR              pwch;
    PDFS_SERVICE        pService;
    ULONG               cbSizeRequired = 0;
    BOOLEAN             pktLocked;
    PWCHAR              wCp = (PWCHAR) InputBuffer;
    ULONG               i;

    STD_FSCTRL_PROLOGUE(DfsFsctrlGetServerName, TRUE, TRUE, FALSE);

    if (InputBufferLength < 2 * sizeof(WCHAR)
            ||
        wCp[0] != UNICODE_PATH_SEP
    ) {

        status = STATUS_INVALID_PARAMETER;
        DfsCompleteRequest( IrpContext, Irp, status );
        return status;

    }

    ustrPrefix.Length = (USHORT) InputBufferLength;
    ustrPrefix.MaximumLength = (USHORT) InputBufferLength;
    ustrPrefix.Buffer = (PWCHAR) InputBuffer;

    if (ustrPrefix.Buffer[0] == UNICODE_PATH_SEP &&
            ustrPrefix.Buffer[1] == UNICODE_PATH_SEP) {
        ustrPrefix.Buffer++;
        ustrPrefix.Length -= sizeof(WCHAR);
    }

    if (ustrPrefix.Buffer[ ustrPrefix.Length/sizeof(WCHAR) - 1]
            == UNICODE_NULL) {
        ustrPrefix.Length -= sizeof(WCHAR);
    }

    pkt = _GetPkt();

    PktAcquireExclusive(TRUE, &pktLocked);

    pEntry = PktLookupEntryByPrefix(pkt,
                                    &ustrPrefix,
                                    &RemainingPath);

    if (pEntry == NULL) {

        status = STATUS_OBJECT_NAME_NOT_FOUND;

    } else {

        if (pEntry->ActiveService != NULL) {

            pService = pEntry->ActiveService;

        } else if (pEntry->Info.ServiceCount == 0) {

            pService = NULL;

        } else {

            pService = pEntry->Info.ServiceList;
        }

        if (pService != NULL) {

            cbSizeRequired = sizeof(UNICODE_PATH_SEP) +
                                pService->Address.Length +
                                    sizeof(UNICODE_PATH_SEP) +
                                        RemainingPath.Length +
                                            sizeof(UNICODE_NULL);

            if (OutputBufferLength < cbSizeRequired) {

                RETURN_BUFFER_SIZE(cbSizeRequired, status);

            } else {

                PWCHAR pwszPath, pwszAddr, pwszRemainingPath;
                ULONG cwAddr;

                //
                // The code below is simply constructing a string of the form
                // \<pService->Address>\RemainingPath. However, due to the
                // fact that InputBuffer and OutputBuffer actually point to
                // the same piece of memory, RemainingPath.Buffer points into
                // a spot in the *OUTPUT* buffer. Hence, we first have to
                // move the RemainingPath to its proper place in the
                // OutputBuffer, and then stuff in the pService->Address,
                // instead of the much more natural method of constructing the
                // string left to right.
                //

                pwszPath = (PWCHAR) OutputBuffer;

                pwszAddr = pService->Address.Buffer;

                cwAddr = pService->Address.Length / sizeof(WCHAR);

                if (cwAddr > 0 && pwszAddr[cwAddr-1] == UNICODE_PATH_SEP)
                    cwAddr--;

                pwszRemainingPath = &pwszPath[ 1 + cwAddr ];

                if (RemainingPath.Length > 0) {

                    if (RemainingPath.Buffer[0] != UNICODE_PATH_SEP) {

                        pwszRemainingPath++;

                    }

                    RtlMoveMemory(
                        pwszRemainingPath,
                        RemainingPath.Buffer,
                        RemainingPath.Length);

                    pwszRemainingPath[-1] = UNICODE_PATH_SEP;

                }

                pwszRemainingPath[RemainingPath.Length/sizeof(WCHAR)] = UNICODE_NULL;

                RtlCopyMemory(
                    &pwszPath[1],
                    pwszAddr,
                    cwAddr * sizeof(WCHAR));

                pwszPath[0] = UNICODE_PATH_SEP;

                Irp->IoStatus.Information = cbSizeRequired;
            }

        } else {

            status = STATUS_OBJECT_NAME_NOT_FOUND;

        }

    }

    PktRelease();

    DfsCompleteRequest( IrpContext, Irp, status );

    DfsDbgTrace(-1,Dbg,"DfsFsctrlGetServerName: Exit->%08lx\n", ULongToPtr(status) );
    return status;
}


//+----------------------------------------------------------------------------
//
//  Function:   DfsFsctrlGetPktEntryState
//
//  Synopsis:   Given a Prefix in Dfs namespace it gets a list of servers
//              for it.  (DFS_INFO_X calls).
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsFsctrlGetPktEntryState(
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PUCHAR  InputBuffer,
    IN ULONG InputBufferLength,
    IN PUCHAR  OutputBuffer,
    IN ULONG OutputBufferLength)
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PDFS_GET_PKT_ENTRY_STATE_ARG arg;
    PDFS_SERVICE pService;
    UNICODE_STRING DfsEntryPath;
    UNICODE_STRING ServerName;
    UNICODE_STRING ShareName;
    UNICODE_STRING remPath;
    PDFS_PKT pkt;
    PDFS_PKT_ENTRY pktEntry;
    BOOLEAN pktLocked = FALSE;
    ULONG cbOutBuffer;
    ULONG Level;
    PCHAR cp;
    PUCHAR InBuffer = NULL;


    DfsDbgTrace(+1, Dbg, "DfsFsctrlGetPktEntryState\n", 0);

    STD_FSCTRL_PROLOGUE(DfsFsctrlGetPktEntryState, TRUE, TRUE, FALSE);

    if (InputBufferLength < sizeof(DFS_GET_PKT_ENTRY_STATE_ARG)) {

        DfsDbgTrace( 0, Dbg, "Input buffer too small\n", 0);

        NtStatus =  STATUS_INVALID_PARAMETER;
        Irp->IoStatus.Information = 0;
        DfsCompleteRequest( IrpContext, Irp, NtStatus );

        DfsDbgTrace(-1, Dbg, "DfsFsctrlGetPktEntryState -> %08lx\n", ULongToPtr(NtStatus) );

        return( NtStatus );

    }

    //
    // Dup the buffer - we're going to construct UNICODE strings that point into
    // the buffer, and the buffer is also the output buffer, so we don't want to
    // overwrite those strings as we build the output buffer.
    //
    InBuffer = ExAllocatePoolWithTag(PagedPool, InputBufferLength, ' puM');

    if (InBuffer) {

        try {

            RtlCopyMemory(InBuffer, InputBuffer, InputBufferLength);

        } except (EXCEPTION_EXECUTE_HANDLER) {

            NtStatus = GetExceptionCode();

        }

    } else {

        NtStatus = STATUS_INSUFFICIENT_RESOURCES;

    }

    //
    // Check args that don't need to be unmarshalled.
    //

    if (NT_SUCCESS(NtStatus)) {

        arg = (PDFS_GET_PKT_ENTRY_STATE_ARG) InBuffer;

        if (!(arg->Level >= 1 && arg->Level <= 4) ||

            (arg->ServerNameLen == 0 && arg->ShareNameLen != 0)) {

            NtStatus = STATUS_INVALID_PARAMETER;

        }

    }

    //
    // Unmarshall the strings
    //

    if (NT_SUCCESS(NtStatus)) {

        try {

            Level = arg->Level;

            DfsEntryPath.Length = DfsEntryPath.MaximumLength = arg->DfsEntryPathLen;
            DfsEntryPath.Buffer = arg->Buffer;

            DfsDbgTrace( 0, Dbg, "\tDfsName=%wZ\n", &DfsEntryPath);

            RtlInitUnicodeString(&ServerName, NULL);
            RtlInitUnicodeString(&ShareName, NULL);

            if (arg->ServerNameLen) {

                cp = (PCHAR)arg->Buffer + arg->DfsEntryPathLen;
                ServerName.Buffer = (WCHAR *)cp;
                ServerName.Length = ServerName.MaximumLength = arg->ServerNameLen;
                cp += arg->ServerNameLen;

            }

            if (arg->ShareNameLen) {

                ShareName.Buffer = (WCHAR *)cp;
                ShareName.Length = ShareName.MaximumLength = arg->ShareNameLen;

                DfsDbgTrace( 0, Dbg, "\tServerName=%wZ\n", &ServerName);
                DfsDbgTrace( 0, Dbg, "\tShareName=%wZ\n", &ShareName);

            }

            DfsDbgTrace( 0, Dbg, "\tLevel=%d\n", ULongToPtr(arg->Level) );
            DfsDbgTrace( 0, Dbg, "\tOutputBufferLength=0x%x\n", ULongToPtr(OutputBufferLength) );

        } except (EXCEPTION_EXECUTE_HANDLER) {

            NtStatus = GetExceptionCode();

        }

    }

    if (NT_SUCCESS(NtStatus)) {

        //
        // Do a prefix lookup. If we find an entry, it's a Dfs path
        //

        pkt = _GetPkt();

        PktAcquireShared( TRUE, &pktLocked );

        pktEntry = PktLookupEntryByPrefix( pkt, &DfsEntryPath, &remPath );

        if (pktEntry != NULL) {

            DfsDbgTrace( 0, Dbg, "\tFound pkt entry %08lx\n", pktEntry);

            //
            // Calculate the needed output buffer size
            //
            NtStatus = DfsGetEntryStateSize(Level,
                                            &ServerName,
                                            &ShareName,
                                            pktEntry,
                                            &cbOutBuffer);
            //
            // Let user know if it's too small
            //

            if (OutputBufferLength < cbOutBuffer) {

                RETURN_BUFFER_SIZE(cbOutBuffer, NtStatus);

            }

        } else {

            NtStatus = STATUS_OBJECT_NAME_NOT_FOUND;

        }

    }

    if (NtStatus == STATUS_SUCCESS) {

        //
        // Args are ok, and it fits - marshall the data
        //

        NtStatus = DfsGetEntryStateMarshall(Level,
                                            &ServerName,
                                            &ShareName,
                                            pktEntry,
                                            OutputBuffer,
                                            cbOutBuffer);

        Irp->IoStatus.Information = cbOutBuffer;

    }

    //
    // Release any locks taken, and free any memory allocated.
    //

    if (pktLocked) {

        PktRelease();

    }

    if (InBuffer) {

        ExFreePool(InBuffer);

    }

    DfsCompleteRequest( IrpContext, Irp, NtStatus );

    DfsDbgTrace(-1, Dbg, "DfsFsctrlGetPktEntryState -> %08lx\n", ULongToPtr(NtStatus) );

    return( NtStatus );
}

//+----------------------------------------------------------------------------
//
//  Function:   DfsGetEntryStateSize
//
//  Synopsis:   Helper routine for DfsFsctrlGetPktEntryState
//              Calculates output buffer size.
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsGetEntryStateSize(
    ULONG Level,
    PUNICODE_STRING ServerName,
    PUNICODE_STRING ShareName,
    PDFS_PKT_ENTRY pktEntry,
    PULONG pcbOutBuffer)
{

    UNICODE_STRING Server;
    UNICODE_STRING Share;
    PDFS_SERVICE pService;
    ULONG Size;
    ULONG NumServices;
    ULONG i;

    DfsDbgTrace(+1, Dbg, "DfsGetEntryStateSize\n", 0);

    //
    // Calculate the needed output buffer size
    //
    Size = pktEntry->Id.Prefix.Length +   // Len of EntryPath
              sizeof(WCHAR);              // ... with null

    switch (Level) {

    case 4:
        Size += sizeof(DFS_INFO_4);
        break;
    case 3:
        Size += sizeof(DFS_INFO_3);
        break;
    case 2:
        Size += sizeof(DFS_INFO_2);
        break;
    case 1:
        Size += sizeof(DFS_INFO_1);
        break;
    }

    //
    // For Level 3 & 4, add the size of any storages that
    // match the ServerName/ShareName passed in.
    //

    NumServices = pktEntry->Info.ServiceCount;

    if (Level == 3 || Level == 4) {

        for (i = 0; i < NumServices; i++) {

            pService = &pktEntry->Info.ServiceList[i];

            DfsDbgTrace( 0, Dbg, "Examining %wZ\n", &pService->Address);

            //
            // Tease apart the address (of form \Server\Share into Server and Share
            //
            RemoveLastComponent(&pService->Address, &Server);

            //
            // Remove leading & trailing '\'
            //
            Server.Length -= 2* sizeof(WCHAR);
            Server.MaximumLength -= 2* sizeof(WCHAR);
            Server.Buffer++;

            //
            // And figure out Share
            //
            Share.Buffer = Server.Buffer + (Server.Length / sizeof(WCHAR)) + 1;
            Share.Length = pService->Address.Length - (Server.Length + 2 * sizeof(WCHAR));
            Share.MaximumLength = Share.Length;

            DfsDbgTrace( 0, Dbg, "DfsGetEntryStateSize: Server=%wZ\n", &Server);
            DfsDbgTrace( 0, Dbg, "                      Share=%wZ\n", &Share);

            if ((ServerName->Length && RtlCompareUnicodeString(ServerName, &Server, TRUE))

                        ||

                (ShareName->Length && RtlCompareUnicodeString(ShareName, &Share, TRUE))) {

                continue;

            }

            Size += sizeof(DFS_STORAGE_INFO) +
                      pService->Address.Length +
                         sizeof(WCHAR);

        }

    }

    DfsDbgTrace( 0, Dbg, "Size=0x%x\n", ULongToPtr(Size) );

    *pcbOutBuffer = Size;

    DfsDbgTrace(-1, Dbg, "DfsGetEntryStateSize -> %08lx\n", STATUS_SUCCESS );

    return (STATUS_SUCCESS);

}

//+----------------------------------------------------------------------------
//
//  Function:   DfsGetEntryStateMarshall
//
//  Synopsis:   Helper routine for DfsFsctrlGetPktEntryState
//              Marshalls the output buffer
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsGetEntryStateMarshall(
    ULONG Level,
    PUNICODE_STRING ServerName,
    PUNICODE_STRING ShareName,
    PDFS_PKT_ENTRY pktEntry,
    PBYTE OutputBuffer,
    ULONG cbOutBuffer)
{

    NTSTATUS NtStatus = STATUS_SUCCESS;
    ULONG iStr;
    ULONG i;
    PDFS_INFO_4 pDfsInfo4;
    PDFS_INFO_3 pDfsInfo3;
    PDFS_STORAGE_INFO pDfsStorageInfo;
    PDFS_SERVICE pService;
    ULONG NumStorageInfo;
    UNICODE_STRING Server;
    UNICODE_STRING Share;

    DfsDbgTrace(+1, Dbg, "DfsGetEntryStateMarshall\n", 0);

    try {

        RtlZeroMemory(OutputBuffer, cbOutBuffer);

        pDfsInfo4 = (PDFS_INFO_4) OutputBuffer;
        pDfsInfo3 = (PDFS_INFO_3) OutputBuffer;

        //
        // iStr will be used to place unicode strings into the buffer
        // starting at the end, working backwards
        //

        iStr = cbOutBuffer;

        //
        // LPWSTR's are stored as offsets into the buffer - the NetDfsXXX calls
        // fix them up.
        //
        iStr -= pktEntry->Id.Prefix.Length + sizeof(WCHAR);
        RtlCopyMemory(&OutputBuffer[iStr],
                      pktEntry->Id.Prefix.Buffer,
                      pktEntry->Id.Prefix.Length);

        //
        // This could could be much more clever, as the DFS_INFO_X structs
        // are similar, but I've gone for clarity over cleverness. (jharper)
        //

        switch (Level) {

        case 4:
            pDfsInfo4->EntryPath = (WCHAR*) ULongToPtr(iStr);
            pDfsInfo4->Comment = NULL;
            pDfsInfo4->State = DFS_VOLUME_STATE_OK;
            pDfsInfo4->Timeout = pktEntry->TimeToLive;
            pDfsInfo4->Guid = pktEntry->Id.Uid;
            pDfsInfo4->NumberOfStorages = pktEntry->Info.ServiceCount;
            pDfsStorageInfo = (PDFS_STORAGE_INFO)(pDfsInfo4 + 1);
            pDfsInfo4->Storage = (PDFS_STORAGE_INFO)((PCHAR)pDfsStorageInfo - OutputBuffer);
            break;
        case 3:
            pDfsInfo3->EntryPath = (WCHAR*) ULongToPtr(iStr);
            pDfsInfo3->Comment = NULL;
            pDfsInfo3->State = DFS_VOLUME_STATE_OK;
            pDfsInfo3->NumberOfStorages = pktEntry->Info.ServiceCount;
            pDfsStorageInfo = (PDFS_STORAGE_INFO)(pDfsInfo3 + 1);
            pDfsInfo3->Storage = (PDFS_STORAGE_INFO)((PCHAR)pDfsStorageInfo - OutputBuffer);
            break;
        case 2:
            pDfsInfo3->EntryPath = (WCHAR*) ULongToPtr(iStr);
            pDfsInfo3->Comment = NULL;
            pDfsInfo3->State = DFS_VOLUME_STATE_OK;
            pDfsInfo3->NumberOfStorages = pktEntry->Info.ServiceCount;
            break;
        case 1:
            pDfsInfo3->EntryPath = (WCHAR*) ULongToPtr(iStr);
            break;

        }

        //
        // For Level 3 & 4 we now walk the services and load State,
        // ServerName and ShareName.  With the complication that if the user
        // specified ServerName and/or ShareName, we must match on those, too.
        //

        if (Level == 3 || Level == 4) {

            NumStorageInfo = 0;

            for (i = 0; i < pktEntry->Info.ServiceCount; i++) {

                LPWSTR wp;
                UNICODE_STRING uStr;
                USHORT m, n;

                pService = &pktEntry->Info.ServiceList[i];

                DfsDbgTrace( 0, Dbg, "Examining %wZ\n", &pService->Address);

                //
                // We want to work with the \Server\Share part of the address only,
                // so count up to 3 backslashes, then stop.
                //
                uStr = pService->Address;
                for (m = n = 0; m < uStr.Length/sizeof(WCHAR) && n < 3; m++) {
                    if (uStr.Buffer[m] == UNICODE_PATH_SEP) {
                        n++;
                    }
                }

                uStr.Length = (n >= 3) ? (m-1) * sizeof(WCHAR) : m * sizeof(WCHAR);

                //
                // Tease apart the address (of form \Server\Share) into Server
                // (Handles a dfs-link like \server\share\dir1\dir2)
                //
                RemoveLastComponent(&uStr, &Server);

                //
                // Remove leading & trailing '\'s
                //
                Server.Length -= 2* sizeof(WCHAR);
                Server.MaximumLength = Server.Length;
                Server.Buffer++;

                //
                // And figure out Share (which will be everything after the server)
                //
                Share.Buffer = Server.Buffer + (Server.Length / sizeof(WCHAR)) + 1;
                Share.Length = pService->Address.Length - (Server.Length + 2 * sizeof(WCHAR));
                Share.MaximumLength = Share.Length;

                DfsDbgTrace( 0, Dbg, "DfsGetEntryStateSize: Server=%wZ\n", &Server);
                DfsDbgTrace( 0, Dbg, "                      Share=%wZ\n", &Share);

                //
                // If ServerName or ShareName are specified, then they must match
                //
                if (
                    (ServerName->Length && RtlCompareUnicodeString(ServerName, &Server, TRUE))

                            ||

                    (ShareName->Length && RtlCompareUnicodeString(ShareName, &Share, TRUE))
                ) {

                    continue;

                }

                //
                // Online or Offline?
                //
                if (pService->Type & DFS_SERVICE_TYPE_OFFLINE) {

                    pDfsStorageInfo->State = DFS_STORAGE_STATE_OFFLINE;

                } else {

                    pDfsStorageInfo->State = DFS_STORAGE_STATE_ONLINE;

                }

                //
                // Active?
                //
                if (pService == pktEntry->ActiveService) {

                    pDfsStorageInfo->State |= DFS_STORAGE_STATE_ACTIVE;

                }

                //
                // Sever name
                //
                iStr -= Server.Length + sizeof(WCHAR);

                RtlCopyMemory(&OutputBuffer[iStr],
                              Server.Buffer,
                              Server.Length);

                pDfsStorageInfo->ServerName = (WCHAR*) ULongToPtr(iStr);

                //
                // Share name
                //
                iStr -= Share.Length + sizeof(WCHAR);

                RtlCopyMemory(&OutputBuffer[iStr],
                              Share.Buffer,
                              Share.Length);

                pDfsStorageInfo->ShareName = (WCHAR*) ULongToPtr(iStr);

                pDfsStorageInfo++;

                NumStorageInfo++;

            }

            //
            // Finally, adjust the # entries we loaded into the buffer
            //
            switch (Level) {

            case 4:
                pDfsInfo4->NumberOfStorages = NumStorageInfo;
                break;
            case 3:
                pDfsInfo3->NumberOfStorages = NumStorageInfo;
                break;

            }

        }

    } except (EXCEPTION_EXECUTE_HANDLER) {

        NtStatus = STATUS_SUCCESS;  // Per Arg Validation Spec

    }

    DfsDbgTrace(-1, Dbg, "DfsGetEntryStateMarshall -> %08lx\n", ULongToPtr(NtStatus) );

    return (NtStatus);

}


//+----------------------------------------------------------------------------
//
//  Function:   DfsFsctrlSetPktEntryState
//
//  Synopsis:   Given a Prefix in Dfs namespace it sets the Timeout or the State
//              of an alternate. (DFS_INFO_X calls).
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsFsctrlSetPktEntryState(
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PUCHAR  InputBuffer,
    IN ULONG InputBufferLength)
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PDFS_SET_PKT_ENTRY_STATE_ARG arg;
    PDFS_SERVICE pService;
    UNICODE_STRING DfsEntryPath;
    UNICODE_STRING ServerName;
    UNICODE_STRING ShareName;
    UNICODE_STRING remPath;
    PDFS_PKT pkt;
    PDFS_PKT_ENTRY pktEntry;
    BOOLEAN pktLocked = FALSE;
    ULONG cbOutBuffer;
    ULONG Level;
    ULONG State;
    ULONG Timeout;
    PCHAR cp;


    DfsDbgTrace(+1, Dbg, "DfsFsctrlSetPktEntryState\n", 0);

    STD_FSCTRL_PROLOGUE(DfsFsctrlSetPktEntryState, TRUE, FALSE, FALSE);

    if (InputBufferLength < sizeof(DFS_SET_PKT_ENTRY_STATE_ARG)) {

        DfsDbgTrace( 0, Dbg, "Input buffer too small\n", 0);

        NtStatus =  STATUS_INVALID_PARAMETER;
        Irp->IoStatus.Information = 0;
        DfsCompleteRequest( IrpContext, Irp, NtStatus );

        DfsDbgTrace(-1, Dbg, "DfsFsctrlSetPktEntryState exit 0x%x\n", ULongToPtr(NtStatus) );

        return( NtStatus );

    }

    //
    // Check args that don't need to be unmarshalled.
    //

    if (NT_SUCCESS(NtStatus)) {

        arg = (PDFS_SET_PKT_ENTRY_STATE_ARG) InputBuffer;

        Level = arg->Level;

        //
        // Check for valid Level
        //
        // Level 101 requires that both be present
        // Level 102 ignores ServerName and ShareName
        //
        switch (Level) {

        case 101:
            State = arg->State;
            if (State != DFS_STORAGE_STATE_ACTIVE ||
                    arg->ServerNameLen == 0 ||
                        arg->ShareNameLen == 0) {
                NtStatus = STATUS_INVALID_PARAMETER;
            }
            break;

        case 102:
            Timeout = arg->Timeout;
            break;

        default:
            NtStatus = STATUS_INVALID_PARAMETER;

        }

    }

    //
    // Unmarshall the strings
    //
    if (NT_SUCCESS(NtStatus)) {

        try {

            DfsEntryPath.Length = DfsEntryPath.MaximumLength = arg->DfsEntryPathLen;
            DfsEntryPath.Buffer = arg->Buffer;

            DfsDbgTrace( 0, Dbg, "\tDfsName=%wZ\n", &DfsEntryPath);

            RtlInitUnicodeString(&ServerName, NULL);
            RtlInitUnicodeString(&ShareName, NULL);

            if (arg->ServerNameLen) {

                cp = (PCHAR)arg->Buffer + arg->DfsEntryPathLen;
                ServerName.Buffer = (WCHAR *)cp;
                ServerName.Length = ServerName.MaximumLength = arg->ServerNameLen;

                DfsDbgTrace( 0, Dbg, "\tServerName=%wZ\n", &ServerName);

            }

            if (arg->ShareNameLen) {

                cp = (PCHAR)arg->Buffer + arg->DfsEntryPathLen + arg->ServerNameLen;
                ShareName.Buffer = (WCHAR *)cp;
                ShareName.Length = ShareName.MaximumLength = arg->ShareNameLen;

                DfsDbgTrace( 0, Dbg, "\tShareName=%wZ\n", &ShareName);

            }

            DfsDbgTrace( 0, Dbg, "\tLevel=%d\n", ULongToPtr(arg->Level) );

        } except (EXCEPTION_EXECUTE_HANDLER) {

            NtStatus = GetExceptionCode();

        }

    }

    //
    // Do a prefix lookup. If we find an entry, it's a Dfs path
    //
    if (NT_SUCCESS(NtStatus)) {

        pkt = _GetPkt();

        PktAcquireExclusive( TRUE, &pktLocked );

        pktEntry = PktLookupEntryByPrefix( pkt, &DfsEntryPath, &remPath );

        if (pktEntry != NULL) {

            DfsDbgTrace( 0, Dbg, "\tFound pkt entry %08lx\n", pktEntry);

        } else {

            NtStatus = STATUS_OBJECT_NAME_NOT_FOUND;

        }

    }

    if (NT_SUCCESS(NtStatus)) {

        //
        // Args are ok - do the work
        //
        switch (Level) {

        case 101:
            NtStatus = DfsSetPktEntryActive(
                                        &ServerName,
                                        &ShareName,
                                        pktEntry,
                                        State);
            break;
        case 102:
            NtStatus = DfsSetPktEntryTimeout(pktEntry,
                                             Timeout);
            break;

        }

        Irp->IoStatus.Information = 0;

    }

    //
    // Release any locks taken, and free any memory allocated.
    //
    if (pktLocked) {

        PktRelease();

    }

    DfsCompleteRequest( IrpContext, Irp, NtStatus );

    DfsDbgTrace(-1, Dbg, "DfsFsctrlSetPktEntryState exit 0x%x\n", ULongToPtr(NtStatus) );

    return( NtStatus );
}
//+-------------------------------------------------------------------------
//
//  Function:   RemoveFirstComponent, public
//
//  Synopsis:   Removes the first component of the string passed.
//
//  Arguments:  [Prefix] -- The prefix whose first component is to be returned.
//              [newPrefix] -- The first component.
//
//  Returns:    NTSTATUS - STATUS_SUCCESS if no error.
//
//  Notes:      On return, the newPrefix points to the same memory buffer
//              as Prefix.
//
//--------------------------------------------------------------------------

void
RemoveFirstComponent(
    PUNICODE_STRING     Prefix,
    PUNICODE_STRING     newPrefix
)
{
    PWCHAR      pwch;
    USHORT      i=sizeof(WCHAR);

    *newPrefix = *Prefix;

    pwch = newPrefix->Buffer;
    pwch ++; //skip the first slash

    while ((*pwch != UNICODE_PATH_SEP) && ((pwch - newPrefix->Buffer) != Prefix->Length))  {
        i += sizeof(WCHAR);
        pwch++;
    }

    newPrefix->Length = i + sizeof(WCHAR);
}

//+----------------------------------------------------------------------------
//
//  Function:   DfsSetPktEntryActive
//
//  Synopsis:   Helper for DfsFsctrlSetPktEntryState
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------
NTSTATUS
DfsSetPktEntryActive(
    PUNICODE_STRING ServerName,
    PUNICODE_STRING ShareName,
    PDFS_PKT_ENTRY pktEntry,
    DWORD State)
{
    UNICODE_STRING Server;
    UNICODE_STRING Share;
    PDFS_SERVICE pService;
    NTSTATUS NtStatus = STATUS_OBJECT_NAME_NOT_FOUND;
    ULONG i;

    DfsDbgTrace(+1, Dbg, "DfsSetPktEntryActive\n", 0);

    for (i = 0; i < pktEntry->Info.ServiceCount && NtStatus != STATUS_SUCCESS; i++) {

        LPWSTR wp;

        pService = &pktEntry->Info.ServiceList[i];

        DfsDbgTrace( 0, Dbg, "Examining %wZ\n", &pService->Address);

        //
        // Tease apart the address (of form \Server\Share) into Server and Share
        //
        RemoveFirstComponent(&pService->Address, &Server);

        //
        // Remove leading & trailing '\'s
        //
        Server.Length -= 2* sizeof(WCHAR);
        Server.MaximumLength = Server.Length;
        Server.Buffer++;

        //
        // And figure out Share
        //
        Share.Buffer = Server.Buffer + (Server.Length / sizeof(WCHAR)) + 1;
        Share.Length = pService->Address.Length - (Server.Length + 2 * sizeof(WCHAR));
        Share.MaximumLength = Share.Length;

        //
        // If ServerName or ShareName don't match, then move on to the next service
        //
        if (
            RtlCompareUnicodeString(ServerName, &Server, TRUE)

                    ||

            RtlCompareUnicodeString(ShareName, &Share, TRUE)
        ) {

            continue;

        }

        DfsDbgTrace( 0, Dbg, "DfsSetPktEntryActive: Server=%wZ\n", &Server);
        DfsDbgTrace( 0, Dbg, "                      Share=%wZ\n", &Share);

        //
        // Make this the active share
        //

        pktEntry->ActiveService = pService;

        NtStatus = STATUS_SUCCESS;

    }

    DfsDbgTrace(-1, Dbg, "DfsSetPktEntryActive -> %08lx\n", ULongToPtr(NtStatus) );

    return NtStatus;
}

//+----------------------------------------------------------------------------
//
//  Function:   DfsSetPktEntryTimeout
//
//  Synopsis:   Helper for DfsFsctrlSetPktEntryState
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------
NTSTATUS
DfsSetPktEntryTimeout(
    PDFS_PKT_ENTRY pktEntry,
    ULONG Timeout)
{
    DfsDbgTrace(+1, Dbg, "DfsSetPktEntryTimeout\n", 0);

    pktEntry->ExpireTime = pktEntry->TimeToLive = Timeout;

    DfsDbgTrace(-1, Dbg, "DfsSetPktEntryTimeout -> %08lx\n", STATUS_SUCCESS );

    return STATUS_SUCCESS;
}


//+----------------------------------------------------------------------------
//
//  Function:   DfsFsctrlGetPkt
//
//  Synopsis:   Returns the current (cached Pkt)
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsFsctrlGetPkt(
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PUCHAR  OutputBuffer,
    IN ULONG OutputBufferLength)
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PDFS_PKT pkt;
    BOOLEAN pktLocked = FALSE;
    ULONG cbOutBuffer;


    DfsDbgTrace(+1, Dbg, "DfsFsctrlGetPktEntryState\n", 0);

    STD_FSCTRL_PROLOGUE(DfsFsctrlGetPkt, FALSE, TRUE, FALSE);

    pkt = _GetPkt();

    PktAcquireShared( TRUE, &pktLocked );

    //
    // Calculate the needed output buffer size
    //
    NtStatus = DfsGetPktSize(&cbOutBuffer);

    //
    // Let user know if it's too small
    //
    if (OutputBufferLength < cbOutBuffer) {

        RETURN_BUFFER_SIZE(cbOutBuffer, NtStatus);

    }

    if (NtStatus == STATUS_SUCCESS) {

        //
        // Args are ok, and it fits - marshall the data
        //
        NtStatus = DfsGetPktMarshall(OutputBuffer, cbOutBuffer);

        Irp->IoStatus.Information = cbOutBuffer;

    }

    //
    // Release any locks taken, and free any memory allocated.
    //
    if (pktLocked) {

        PktRelease();

    }

    DfsCompleteRequest( IrpContext, Irp, NtStatus );

    DfsDbgTrace(-1, Dbg, "DfsFsctrlGetPkt -> %08lx\n", ULongToPtr(NtStatus) );

    return( NtStatus );
}

//+----------------------------------------------------------------------------
//
//  Function:   DfsGetPktSize, private
//
//  Synopsis:   Calculates the size needed to return the Pkt.  Helper for
//              DfsFsctrlGetPkt().
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsGetPktSize(
    PULONG pSize)
{
    ULONG EntryCount = 0;
    ULONG i;
    ULONG Size = 0;
    PDFS_PKT_ENTRY pPktEntry;
    PDFS_PKT pkt = _GetPkt();

    //
    // Walk the linked list of Pkt entries
    //

    for ( pPktEntry = PktFirstEntry(pkt);
            pPktEntry != NULL;
                pPktEntry = PktNextEntry(pkt, pPktEntry)) {

        //
        // Space for the Prefix and ShortPrefix, including a UNICODE_NULL
        //
        Size += pPktEntry->Id.Prefix.Length + sizeof(WCHAR);
        Size += pPktEntry->Id.ShortPrefix.Length + sizeof(WCHAR);

        //
        // Space for an array of pointers to DFS_PKT_ADDRESS_OBJECTS
        //
        Size += sizeof(PDFS_PKT_ADDRESS_OBJECT) * pPktEntry->Info.ServiceCount;

        //
        // Space for the ServerShare address, plus a UNICODE_NULL, plus the state
        //
        for (i = 0; i < pPktEntry->Info.ServiceCount; i++) {

            Size += sizeof(USHORT) + pPktEntry->Info.ServiceList[i].Address.Length + sizeof(WCHAR);

        }

        EntryCount++;

    }

    //
    // Space for the DFS_PKT_ARG, which will have EntryCount objects on the end
    //
    Size += FIELD_OFFSET(DFS_GET_PKT_ARG, EntryObject[EntryCount]);

    //
    // Make sure the size is a multiple of the size of a PDFS_PKT_ADDRESS_OBJECT, as that is what
    // will be at the end of the buffer
    //

    while ((Size & (sizeof(PDFS_PKT_ADDRESS_OBJECT)-1)) != 0) {
        Size++;
    }

    *pSize = Size;

    return STATUS_SUCCESS;
}

//+----------------------------------------------------------------------------
//
//  Function:   DfsGetPktMarshall, private
//
//  Synopsis:   Marshalls the Pkt.  Helper for DfsFsctrlGetPkt().
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsGetPktMarshall(
    PBYTE Buffer,
    ULONG Size)
{
    ULONG EntryCount = 0;
    ULONG i;
    ULONG j;
    ULONG Type;
    PCHAR pCh;
    PDFS_PKT_ENTRY pPktEntry;
    PDFS_GET_PKT_ARG pPktArg;
    PDFS_PKT pkt = _GetPkt();

    //
    // This will be a two-pass operation, the first pass will calculate how
    // much room for the LPWSTR arrays at the end of the buffer, then the
    // second pass will put the strings into place, too.
    //

    RtlZeroMemory(Buffer,Size);

    //
    // Point to the end of the buffer
    //
    pCh = (PCHAR)(Buffer + Size);

    pPktArg = (PDFS_GET_PKT_ARG)Buffer;

    for ( pPktEntry = PktFirstEntry(pkt);
            pPktEntry != NULL;
                pPktEntry = PktNextEntry(pkt, pPktEntry)) {

        //
        // Space for an array of pointers to DFS_PKT_ADDRESS_OBJECTS
        //
        pCh -= sizeof(PDFS_PKT_ADDRESS_OBJECT) * pPktEntry->Info.ServiceCount;
        pPktArg->EntryObject[EntryCount].Address = (PDFS_PKT_ADDRESS_OBJECT *)pCh;

        EntryCount++;

    }

    //
    // Now marshall
    //

    EntryCount = 0;
    for ( pPktEntry = PktFirstEntry(pkt);
            pPktEntry != NULL;
                pPktEntry = PktNextEntry(pkt, pPktEntry)) {

        pCh -= pPktEntry->Id.Prefix.Length + sizeof(WCHAR);
        pPktArg->EntryObject[EntryCount].Prefix = (LPWSTR)pCh;
        RtlCopyMemory(
            pPktArg->EntryObject[EntryCount].Prefix,
            pPktEntry->Id.Prefix.Buffer,
            pPktEntry->Id.Prefix.Length);

        pCh -= pPktEntry->Id.ShortPrefix.Length + sizeof(WCHAR);
        pPktArg->EntryObject[EntryCount].ShortPrefix = (LPWSTR)pCh;
        RtlCopyMemory(
            pPktArg->EntryObject[EntryCount].ShortPrefix,
            pPktEntry->Id.ShortPrefix.Buffer,
            pPktEntry->Id.ShortPrefix.Length);

        pPktArg->EntryObject[EntryCount].Type = pPktEntry->Type;
        pPktArg->EntryObject[EntryCount].USN = pPktEntry->USN;
        pPktArg->EntryObject[EntryCount].ExpireTime = pPktEntry->ExpireTime;
        pPktArg->EntryObject[EntryCount].UseCount = pPktEntry->UseCount;
        pPktArg->EntryObject[EntryCount].Uid = pPktEntry->Id.Uid;
        pPktArg->EntryObject[EntryCount].ServiceCount = pPktEntry->Info.ServiceCount;

        for (i = 0; i < pPktEntry->Info.ServiceCount; i++) {

            Type = pPktEntry->Info.ServiceList[i].Type;
            pCh -= sizeof(USHORT) + pPktEntry->Info.ServiceList[i].Address.Length + sizeof(WCHAR);
            pPktArg->EntryObject[EntryCount].Address[i] = (PDFS_PKT_ADDRESS_OBJECT)pCh;
            pPktArg->EntryObject[EntryCount].Address[i]->State = (USHORT)Type;
            if (pPktEntry->ActiveService == &pPktEntry->Info.ServiceList[i]) {
                pPktArg->EntryObject[EntryCount].Address[i]->State |= DFS_SERVICE_TYPE_ACTIVE;
            }

            RtlCopyMemory(
                &pPktArg->EntryObject[EntryCount].Address[i]->ServerShare[0],
                pPktEntry->Info.ServiceList[i].Address.Buffer,
                pPktEntry->Info.ServiceList[i].Address.Length);

        }

        EntryCount++;

    }

    pPktArg->EntryCount = EntryCount;

    //
    // Convert all the pointers to relative offsets
    //

    for (i = 0; i < pPktArg->EntryCount; i++) {

        for (j = 0; j < pPktArg->EntryObject[i].ServiceCount; j++) {

            POINTER_TO_OFFSET(pPktArg->EntryObject[i].Address[j], Buffer);

        }

        POINTER_TO_OFFSET(pPktArg->EntryObject[i].Prefix, Buffer);
        POINTER_TO_OFFSET(pPktArg->EntryObject[i].ShortPrefix, Buffer);
        POINTER_TO_OFFSET(pPktArg->EntryObject[i].Address, Buffer);

    }

    return STATUS_SUCCESS;
}

//+----------------------------------------------------------------------------
//
//  Function:   DfsFsctrlGetSpcTable
//
//  Synopsis:   Given a NULL string, it returns a list of all the domains
//              Given a non-NULL string, it returns a list of DC's in that domain
//              (if the name is a domain name).  Similar to a special referral request.
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsFsctrlGetSpcTable(
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PUCHAR  InputBuffer,
    IN ULONG InputBufferLength,
    IN PUCHAR  OutputBuffer,
    IN ULONG OutputBufferLength)
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    LPWSTR SpcName;
    ULONG i;

    DfsDbgTrace(+1, Dbg, "DfsFsctrlGetSpcTable\n", 0);

    STD_FSCTRL_PROLOGUE(DfsFsctrlGetSpcTable, TRUE, TRUE, FALSE);

    SpcName = (WCHAR *)InputBuffer;

    //
    // Verify there's a null someplace in the buffer
    //

    for (i = 0; i < InputBufferLength/sizeof(WCHAR) && SpcName[i]; i++)
        NOTHING;

    if (i >= InputBufferLength/sizeof(WCHAR)) {
        NtStatus = STATUS_INVALID_PARAMETER;
        DfsCompleteRequest( IrpContext, Irp, NtStatus );
        DfsDbgTrace(-1, Dbg, "DfsFsctrlGetSpcTable -> %08lx\n", ULongToPtr(NtStatus) );
        return NtStatus;
    }

    DfsDbgTrace(0, Dbg, "SpcName=[%ws]\n", SpcName);

    if (wcslen(SpcName) == 0) {

        //
        // return all the domain names
        //

        NtStatus = DfsGetSpcTableNames(
                        Irp,
                        OutputBuffer,
                        OutputBufferLength);

    } else if (wcslen(SpcName) == 1 && *SpcName == L'*') {

        //
        // Return DC Info
        //

        NtStatus = DfsGetSpcDcInfo(
                        Irp,
                        OutputBuffer,
                        OutputBufferLength);

    } else {

        //
        // Expand the one name
        //

        NtStatus = DfsExpSpcTableName(
                        SpcName,
                        Irp,
                        OutputBuffer,
                        OutputBufferLength);

    }

    DfsCompleteRequest( IrpContext, Irp, NtStatus );

    DfsDbgTrace(-1, Dbg, "DfsFsctrlGetSpcTable -> %08lx\n", ULongToPtr(NtStatus) );

    return( NtStatus );
}

//+----------------------------------------------------------------------------
//
//  Function:   DfsGetspcTableNames, private
//
//  Synopsis:   Marshalls the spc table (Names).  Helper for DfsFsctrlGetSpcTable().
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsGetSpcTableNames(
    PIRP Irp,
    PUCHAR  OutputBuffer,
    ULONG OutputBufferLength)
{
    PDFS_SPECIAL_ENTRY pSpecialEntry;
    PDFS_SPECIAL_TABLE pSpecialTable;
    PDFS_PKT Pkt;
    WCHAR *wCp;
    ULONG Size;
    ULONG i;
    BOOLEAN pktLocked;
    NTSTATUS Status;

    RtlZeroMemory(OutputBuffer, OutputBufferLength);

    Pkt = _GetPkt();

    pSpecialTable = &Pkt->SpecialTable;

    PktAcquireShared(TRUE, &pktLocked);

    Size = sizeof(UNICODE_NULL);

    pSpecialEntry = CONTAINING_RECORD(
                        pSpecialTable->SpecialEntryList.Flink,
                        DFS_SPECIAL_ENTRY,
                        Link);

    for (i = 0; i < pSpecialTable->SpecialEntryCount; i++) {

        Size += pSpecialEntry->SpecialName.Length +
                    sizeof(UNICODE_NULL) +
                        sizeof(WCHAR);

        pSpecialEntry = CONTAINING_RECORD(
                            pSpecialEntry->Link.Flink,
                            DFS_SPECIAL_ENTRY,
                            Link);
    }

    if (Size > OutputBufferLength) {

        RETURN_BUFFER_SIZE(Size, Status)

        PktRelease();

        return Status;

    }

    wCp = (WCHAR *)OutputBuffer;
    pSpecialEntry = CONTAINING_RECORD(
                        pSpecialTable->SpecialEntryList.Flink,
                        DFS_SPECIAL_ENTRY,
                        Link);

    for (i = 0; i < pSpecialTable->SpecialEntryCount; i++) {

        *wCp++ = pSpecialEntry->NeedsExpansion == TRUE ? L'-' : '+';
        RtlCopyMemory(
            wCp,
            pSpecialEntry->SpecialName.Buffer,
            pSpecialEntry->SpecialName.Length);
        wCp += pSpecialEntry->SpecialName.Length/sizeof(WCHAR);
        *wCp++ = UNICODE_NULL;

        pSpecialEntry = CONTAINING_RECORD(
                            pSpecialEntry->Link.Flink,
                            DFS_SPECIAL_ENTRY,
                            Link);
    }

    *wCp++ = UNICODE_NULL;

    PktRelease();

    Irp->IoStatus.Information = Size;

    return STATUS_SUCCESS;

}

//+----------------------------------------------------------------------------
//
//  Function:   DfsGetSpcDcInfo, private
//
//  Synopsis:   Marshalls DC Info w.r.t. the special name table
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsGetSpcDcInfo(
    PIRP Irp,
    PUCHAR  OutputBuffer,
    ULONG OutputBufferLength)
{
    NTSTATUS Status = STATUS_SUCCESS;
    BOOLEAN pktLocked;
    PDFS_PKT Pkt;
    WCHAR *wCp;
    ULONG Size;

    Pkt = _GetPkt();
    PktAcquireShared(TRUE, &pktLocked);

    RtlZeroMemory(OutputBuffer, OutputBufferLength);

    Size = sizeof(UNICODE_NULL);

    Size += Pkt->DCName.Length +
                sizeof(UNICODE_NULL) +
                    sizeof(WCHAR);

    Size += Pkt->DomainNameFlat.Length +
                sizeof(UNICODE_NULL) +
                    sizeof(WCHAR);

    Size += Pkt->DomainNameDns.Length +
                sizeof(UNICODE_NULL) +
                    sizeof(WCHAR);

    if (Size > OutputBufferLength) {

        RETURN_BUFFER_SIZE(Size, Status)
        PktRelease();

        return Status;

    }

    wCp = (WCHAR *)OutputBuffer;

    *wCp++ = L'*';
    RtlCopyMemory(
                wCp,
                Pkt->DCName.Buffer,
                Pkt->DCName.Length);
    wCp += Pkt->DCName.Length/sizeof(WCHAR);
    *wCp++ = UNICODE_NULL;

    *wCp++ = L'*';
    RtlCopyMemory(
                wCp,
                Pkt->DomainNameFlat.Buffer,
                Pkt->DomainNameFlat.Length);
    wCp += Pkt->DomainNameFlat.Length/sizeof(WCHAR);
    *wCp++ = UNICODE_NULL;

    *wCp++ = L'*';
    RtlCopyMemory(
                wCp,
                Pkt->DomainNameDns.Buffer,
                Pkt->DomainNameDns.Length);
    wCp += Pkt->DomainNameDns.Length/sizeof(WCHAR);
    *wCp++ = UNICODE_NULL;

    *wCp++ = UNICODE_NULL;

    PktRelease();

    Irp->IoStatus.Information = Size;

    return STATUS_SUCCESS;
}

//+----------------------------------------------------------------------------
//
//  Function:   DfsExpSpcTableName, private
//
//  Synopsis:   Marshalls the spc table (1 expansion).  Helper for DfsFsctrlGetSpcTable().
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsExpSpcTableName(
    LPWSTR SpcName,
    PIRP Irp,
    PUCHAR  OutputBuffer,
    ULONG OutputBufferLength)
{
    PDFS_SPECIAL_ENTRY pSpcEntry = NULL;
    UNICODE_STRING Name;
    NTSTATUS Status = STATUS_SUCCESS;
    WCHAR *wCp;
    ULONG Size;
    ULONG i;

    RtlInitUnicodeString(&Name, SpcName);

    Status = PktExpandSpecialName(&Name, &pSpcEntry);

    if (!NT_SUCCESS(Status)) {

        return Status;

    }

    RtlZeroMemory(OutputBuffer, OutputBufferLength);

    Size = sizeof(UNICODE_NULL);

    for (i = 0; i < pSpcEntry->ExpandedCount; i++) {

        Size += pSpcEntry->ExpandedNames[i].ExpandedName.Length +
                    sizeof(UNICODE_NULL) +
                        sizeof(WCHAR);

    }

    if (Size > OutputBufferLength) {

        RETURN_BUFFER_SIZE(Size, Status)

        InterlockedDecrement(&pSpcEntry->UseCount);

        return Status;

    }

    wCp = (WCHAR *)OutputBuffer;

    for (i = 0; i < pSpcEntry->ExpandedCount; i++) {

        *wCp++ = i == pSpcEntry->Active ? L'+' : L'-';
        RtlCopyMemory(
                    wCp,
                    pSpcEntry->ExpandedNames[i].ExpandedName.Buffer,
                    pSpcEntry->ExpandedNames[i].ExpandedName.Length);
        wCp += pSpcEntry->ExpandedNames[i].ExpandedName.Length/sizeof(WCHAR);
        *wCp++ = UNICODE_NULL;

    }

    *wCp++ = UNICODE_NULL;

    InterlockedDecrement(&pSpcEntry->UseCount);

    Irp->IoStatus.Information = Size;

    return STATUS_SUCCESS;
}

//+----------------------------------------------------------------------------
//
//  Function:   DfsFsctrlSpcSetDc
//
//  Synopsis:   Given a special name and a dc name, it makes the DC in that special
//              list the 'active' DC.
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsFsctrlSpcSetDc(
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PUCHAR  InputBuffer,
    IN ULONG InputBufferLength)
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PDFS_SPECIAL_SET_DC_INPUT_ARG arg = (PDFS_SPECIAL_SET_DC_INPUT_ARG) InputBuffer;

    DfsDbgTrace(+1, Dbg, "DfsFsctrlSpcSetDc\n", 0);

    STD_FSCTRL_PROLOGUE(DfsFsctrlSpcSetDc, TRUE, FALSE, FALSE);

    //
    // Check the input args
    //

    if (InputBufferLength < sizeof(DFS_SPECIAL_SET_DC_INPUT_ARG)) {
        NtStatus =  STATUS_INVALID_PARAMETER;
        goto exit_with_status;
    }

    OFFSET_TO_POINTER(arg->SpecialName.Buffer, arg);
    if (!UNICODESTRING_IS_VALID(arg->SpecialName, InputBuffer, InputBufferLength)) {
        NtStatus = STATUS_INVALID_PARAMETER;
        goto exit_with_status;
    }

    OFFSET_TO_POINTER(arg->DcName.Buffer, arg);
    if (!UNICODESTRING_IS_VALID(arg->DcName, InputBuffer, InputBufferLength)) {
        NtStatus = STATUS_INVALID_PARAMETER;
        goto exit_with_status;
    }

    NtStatus = PktpSetActiveSpcService(
                    &arg->SpecialName,
                    &arg->DcName,
                    TRUE);

exit_with_status:

    DfsCompleteRequest( IrpContext, Irp, NtStatus );

    DfsDbgTrace(-1, Dbg, "DfsFsctrlSpcSetDc -> %08lx\n", ULongToPtr(NtStatus) );

    return( NtStatus );
}


#if DBG


//+-------------------------------------------------------------------------
//
//  Function:   DfsFsctrlReadMem, local
//
//  Synopsis:   DfsFsctrlReadMem is a debugging function which will return
//              the contents of a chunk of kernel space memory
//
//  Arguments:  [IrpContext] -
//              [Irp] -
//              [Request] -- Pointer to a FILE_DFS_READ_MEM struct,
//                      giving the description of the data to be returned.
//              [InputBufferLength] -- Size of InputBuffer
//              [OutputBuffer] -- User's output buffer, in which the
//                      data structure will be returned.
//              [OutputBufferLength] -- Size of OutputBuffer
//
//  Returns:    NTSTATUS - STATUS_SUCCESS if no error.
//
//  Notes:      Available in DBG builds only.
//
//--------------------------------------------------------------------------


NTSTATUS
DfsFsctrlReadMem (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PFILE_DFS_READ_MEM Request,
    IN ULONG InputBufferLength,
    IN OUT PUCHAR OutputBuffer,
    IN ULONG OutputBufferLength
) {
    NTSTATUS Status;
    PUCHAR ReadBuffer;
    ULONG ReadLength;

    DfsDbgTrace(+1, Dbg, "DfsFsctrlReadMem...\n", 0);

    if (InputBufferLength != sizeof (FILE_DFS_READ_MEM)) {
        DfsDbgTrace(0, Dbg, "Input buffer is wrong size\n", 0);

        DfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        Status = STATUS_INVALID_PARAMETER;

        DfsDbgTrace(-1, Dbg, "DfsFsctrlReadMem -> %08lx\n", ULongToPtr(Status) );
        return Status;
    }

    ReadBuffer = (PUCHAR) Request->Address;
    ReadLength = (ULONG) Request->Length;

    //
    // Special case ReadBuffer == 0 and ReadLength == 0 - means return the
    // address of DfsData
    //

    if (ReadLength == 0 && ReadBuffer == 0) {

        if (OutputBufferLength < sizeof(ULONG_PTR)) {
            DfsDbgTrace(0, Dbg, "Output buffer is too small\n", 0);

            DfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
            Status = STATUS_INVALID_PARAMETER;

            DfsDbgTrace(-1, Dbg, "DfsFsctrlReadMem -> %08lx\n", ULongToPtr(Status) );
            return Status;

        } else {

            *(PULONG_PTR) OutputBuffer = (ULONG_PTR) &DfsData;

            Irp->IoStatus.Information = sizeof(ULONG);
            Irp->IoStatus.Status = Status = STATUS_SUCCESS;

            DfsCompleteRequest( IrpContext, Irp, Status );
            return Status;
        }

    }

    //
    // Normal case, read data from the address specified in input buffer
    //

    if (ReadLength > OutputBufferLength) {
        DfsDbgTrace(0, Dbg, "Output buffer is smaller than requested size\n", 0);

        DfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        Status = STATUS_INVALID_PARAMETER;

        DfsDbgTrace(-1, Dbg, "DfsFsctrlReadMem -> %08lx\n", ULongToPtr(Status) );
        return Status;
    }

    try {

        RtlMoveMemory( OutputBuffer, ReadBuffer, ReadLength );

        Irp->IoStatus.Information = ReadLength;
        Irp->IoStatus.Status = Status = STATUS_SUCCESS;

    } except(EXCEPTION_EXECUTE_HANDLER) {

        Status = STATUS_INVALID_USER_BUFFER;
    }

    DfsCompleteRequest(IrpContext, Irp, Status);
    DfsDbgTrace(-1, Dbg, "DfsFsctrlReadMem -> %08lx\n", ULongToPtr(Status) );

    return Status;
}

void
DfsDumpBuf(PCHAR cp, ULONG len)
{
    ULONG i, j, c;

    for (i = 0; i < len; i += 16) {
        DbgPrint("%08x  ", i);
        for (j = 0; j < 16; j++) {
            c = i+j < len ? cp[i+j] & 0xff : ' ';
            DbgPrint("%02x ", c);
            if (j == 7)
                DbgPrint(" ");
        }
        DbgPrint("  ");
        for (j = 0; j < 16; j++) {
            c = i+j < len ? cp[i+j] & 0xff : ' ';
            if (c < ' ' || c > '~')
                c = '.';
            DbgPrint("%c", c);
            if (j == 7)
                DbgPrint("|");
        }
        DbgPrint("\n");
    }
}


#endif // DBG


//+----------------------------------------------------------------------------
//
//  Function:   DfsCaptureCredentials
//
//  Synopsis:   Captures the credentials to use... similar to DnrCaptureCred..
//
//  Arguments:  Irp and Filename.
//
//  Returns:    Credentials
//
//-----------------------------------------------------------------------------

PDFS_CREDENTIALS
DfsCaptureCredentials(
    IN PIRP Irp,
    IN PUNICODE_STRING FileName)
{
#ifdef TERMSRV
    NTSTATUS Status;
    ULONG SessionID;
#endif // TERMSRV
    LUID LogonID;
    PDFS_CREDENTIALS creds;

    DfsDbgTrace(+1, Dbg, "DfsCaptureCredentials: Enter [%wZ] \n", FileName);

    ExAcquireResourceExclusiveLite( &DfsData.Resource, TRUE );
    DfsGetLogonId( &LogonID );

#ifdef TERMSRV

    Status = IoGetRequestorSessionId( Irp, & SessionID );
    if( NT_SUCCESS( Status ) ) {
        creds = DfsLookupCredentials( FileName, SessionID, &LogonID  );
    }
    else {
        creds = NULL;
    }

#else // TERMSRV

    creds = DfsLookupCredentials( FileName, &LogonID );

#endif // TERMSRV

    if (creds !=  NULL)
	creds->RefCount++;

    ExReleaseResourceLite( &DfsData.Resource );
    DfsDbgTrace(-1, Dbg, "DfsCaptureCredentials: Exit. Creds %x\n", creds);

    return creds;
}



//+----------------------------------------------------------------------------
//
//  Function:   DfsReleaseCredentials
//
//  Synopsis:   Releases the credentials supplied.
//
//  Arguments:  Credentials
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

VOID
DfsReleaseCredentials(
    IN PDFS_CREDENTIALS Creds )

{
    ExAcquireResourceExclusiveLite( &DfsData.Resource, TRUE );

    if (Creds != NULL)
         Creds->RefCount--;

    ExReleaseResourceLite( &DfsData.Resource );

}



//+-------------------------------------------------------------------
//
//  Function:   DfsFsctrlGetConnectionPerfInfo, public
//
//  Synopsis:   This routine implements the functionality to get the 
//              performance information of an opened connection.
//
//  Returns:    [NTSTATUS] -- The completion status.
//
//--------------------------------------------------------------------

		      
NTSTATUS
DfsFsctrlGetConnectionPerfInfo(
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PUCHAR InputBuffer,
    IN ULONG InputBufferLength,
    IN OUT PUCHAR OutputBuffer,
    IN ULONG OutputBufferLength)
{
    UNICODE_STRING Prefix;
    NTSTATUS status = STATUS_SUCCESS;
    UNICODE_STRING remPath, shareName;
    PDFS_PKT pkt;
    PDFS_PKT_ENTRY pktEntry;
    PDFS_SERVICE service;
    ULONG i, USN;
    BOOLEAN pktLocked, fRetry;
    PDFS_CREDENTIALS Creds;
    ULONG InfoLen;
    PUCHAR BufToUse;
    UNICODE_STRING UsePrefix;

    BufToUse = Irp->UserBuffer;

    //
    // try to use the User's buffer here. The underlying call sets up 
    // pointers to unicode strings within the output buffer, and passing
    // a kernel buffer and copying it out to the user would not produce
    // the intended results.
    //

    if (BufToUse!= NULL) {
        try {
            ProbeForWrite(BufToUse,OutputBufferLength,sizeof(UCHAR));
        } except(EXCEPTION_EXECUTE_HANDLER) {
	    status = STATUS_INVALID_PARAMETER;
        }
    }
    else {
	status = STATUS_INVALID_PARAMETER;
    }

    if (NT_SUCCESS(status)) {
	if ( (InputBufferLength > 0) &&
	    (InputBufferLength < MAXUSHORT) &&
	    ((InputBufferLength & 0x1) == 0) ) {

	    Prefix.MaximumLength = (USHORT)(InputBufferLength);
	    Prefix.Buffer = (PWCHAR) InputBuffer;
	    Prefix.Length = Prefix.MaximumLength;
	}
	else {
	    status = STATUS_INVALID_PARAMETER;
	}
    }

    if (NT_SUCCESS(status)) {
	Creds = DfsCaptureCredentials (Irp, &Prefix);

	DfsDbgTrace(+1, Dbg, "GetConnPerfInfo entered %wZ\n", &Prefix);
	DfsDbgTrace(0, Dbg, "GetConnPerfInfo creds=0x%x\n", Creds);

        DfsGetServerShare( &UsePrefix, &Prefix);
	pkt = _GetPkt();
	PktAcquireShared( TRUE, &pktLocked );    

	do {
	    fRetry = FALSE;

	    pktEntry = PktLookupEntryByPrefix( pkt, &UsePrefix, &remPath );

	    if (pktEntry != NULL) {
		InterlockedIncrement(&pktEntry->UseCount);
		USN = pktEntry->USN;
		status = STATUS_BAD_NETWORK_PATH;
		for (i = 0; i < pktEntry->Info.ServiceCount; i++) {
		    service = &pktEntry->Info.ServiceList[i];

		    try {
		      status = DfsTreeConnectGetConnectionInfo(
					service, 
					Creds,
					BufToUse,
					OutputBufferLength,
					&InfoLen);
		    }
		    except(EXCEPTION_EXECUTE_HANDLER) {
		      status = STATUS_INVALID_PARAMETER;
		    }
		    
		    //
                    // If tree connect succeeded, we are done.
                    //
		    if (NT_SUCCESS(status))
			break;
		    //
		    // If tree connect failed with an "interesting error" like
                    // STATUS_ACCESS_DENIED, we are done.
                    //
		    if (!ReplIsRecoverableError(status))
			break;
		    //
                    // Tree connect failed because of an error like host not
                    // reachable. In that case, we want to go on to the next
                    // server in the list. But before we do that, we have to see
                    // if the pkt changed on us while we were off doing the tree
                    // connect.
                    //
		    if (USN != pktEntry->USN) {
			fRetry = TRUE;
			break;
		    }
		}
		InterlockedDecrement(&pktEntry->UseCount);
	    } else {
		status = STATUS_BAD_NETWORK_PATH;
	    }
	} while ( fRetry );

	PktRelease();

	DfsReleaseCredentials(Creds);
	//
        // Dont put the InfoLen here... we already have the information in the
        // the user buffer, and dont want a copyout of kernel to user.
        //
    }
    Irp->IoStatus.Information = 0;

    DfsCompleteRequest(IrpContext, Irp, status);

    DfsDbgTrace(-1, Dbg, "GetConnPerfInfo Done, Status %x\n", ULongToPtr(status) );
    return( status );

}



//+-------------------------------------------------------------------
//
//  Function:   DfsTreeConnecGetConnectionInfo, private
//
//  Synopsis:   This routine calls into the provider with FSCTL_LMR
//              fsctl. Only lanman supports this fsctl, and if the provider
//              is lanman, we get our information buffer filled in.
//
//  Returns:    [NTSTATUS] -- The completion status.
//
//--------------------------------------------------------------------
    
NTSTATUS
DfsTreeConnectGetConnectionInfo(
				 IN PDFS_SERVICE Service, 
				 IN PDFS_CREDENTIALS Creds,
				 IN OUT PUCHAR OutputBuffer,
				 IN ULONG OutputBufferLength,
				 OUT PULONG InfoLen)
{
    NTSTATUS status;
    NTSTATUS ObjectRefStatus;
    UNICODE_STRING shareName;
    HANDLE treeHandle;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK ioStatusBlock;
    BOOLEAN pktLocked;
    USHORT i, k;
    
    *InfoLen = 0;

    DfsDbgTrace(+1, Dbg, "DfsTreeConnectGetInfo entered creds %x\n", Creds);
    ASSERT( PKT_LOCKED_FOR_SHARED_ACCESS() );
    //
    // Compute the share name...
    //
    if (Service->pProvider != NULL &&
            Service->pProvider->DeviceName.Buffer != NULL &&
                Service->pProvider->DeviceName.Length > 0) {
        //
        // We have a provider already - use it
        //
        shareName.MaximumLength =
            Service->pProvider->DeviceName.Length +
                Service->Address.Length;
    } else {
        //
        // We don't have a provider yet - give it to the mup to find one
        //
        shareName.MaximumLength =
            sizeof(DD_NFS_DEVICE_NAME_U) +
                Service->Address.Length;
    }
    shareName.Buffer = ExAllocatePoolWithTag(PagedPool, shareName.MaximumLength, ' puM');

    if (shareName.Buffer != NULL) {
        //
        // If we have a cached connection to the IPC$ share of this server,
        // close it or it might conflict with the credentials supplied here.
        //

        if (Service->ConnFile != NULL) {

            ExAcquireResourceExclusiveLite(&DfsData.Resource, TRUE);
            if (Service->ConnFile != NULL)
                DfsCloseConnection(Service);

            ExReleaseResourceLite(&DfsData.Resource);
        }

        //
        // Now, build the share name to tree connect to.
        //

        shareName.Length = 0;

        if (Service->pProvider != NULL &&
                Service->pProvider->DeviceName.Buffer != NULL &&
                    Service->pProvider->DeviceName.Length > 0) {
            //
            // We have a provider already - use it
            //
 
            RtlAppendUnicodeToString(
                &shareName,
                Service->pProvider->DeviceName.Buffer);

        } else {

            //
            // We don't have a provider yet - give it to the mup to find one
            //

            RtlAppendUnicodeToString(
            &shareName,
            DD_NFS_DEVICE_NAME_U);
        }
 
        RtlAppendUnicodeStringToString(&shareName, &Service->Address);

        //
        // One can only do tree connects to server\share. So, in case
        // pService->Address refers to something deeper than the share,
        // make sure we setup a tree-conn only to server\share. Note that
        // by now, shareName is of the form
        // \Device\LanmanRedirector\server\share<\path>. So, count up to
        // 4 slashes and terminate the share name there.
        //

        for (i = 0, k = 0;
                i < shareName.Length/sizeof(WCHAR) && k < 5;
                    i++) {

            if (shareName.Buffer[i] == UNICODE_PATH_SEP)
                k++;
        }

        shareName.Length = i * sizeof(WCHAR);
        if (k == 5)
            shareName.Length -= sizeof(WCHAR);

        InitializeObjectAttributes(
            &objectAttributes,
            &shareName,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL);

        //
        // Release the Pkt before going over the net...
        //

        PktRelease();

        status = ZwCreateFile(
                    &treeHandle,
                    SYNCHRONIZE,
                    &objectAttributes,
                    &ioStatusBlock,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    FILE_SHARE_READ |
                        FILE_SHARE_WRITE |
                        FILE_SHARE_DELETE,
                    FILE_OPEN_IF,
                    FILE_CREATE_TREE_CONNECTION |
                        FILE_SYNCHRONOUS_IO_NONALERT,
                    (PVOID) (Creds) ? Creds->EaBuffer : NULL,
		    (Creds) ? Creds->EaLength : 0);

        if (NT_SUCCESS(status)) {

            PFILE_OBJECT fileObject;
	    LMR_REQUEST_PACKET request;
	    
	    DfsGetLogonId(&request.LogonId);
	    request.Type = GetConnectionInfo;
	    request.Version = REQUEST_PACKET_VERSION;
	    request.Level = 3;

	    status = ZwFsControlFile(
				     treeHandle,
				     NULL,
				     NULL,
				     NULL,
				     &ioStatusBlock,
				     FSCTL_LMR_GET_CONNECTION_INFO,
				     (LPVOID)&request,
				     sizeof(request),
				     OutputBuffer,
				     OutputBufferLength);
			    
	    if (NT_SUCCESS(status)) {
		*InfoLen = (ULONG)ioStatusBlock.Information;
	    }

            //
            // 426184, need to check return code for errors.
            //
            ObjectRefStatus = ObReferenceObjectByHandle(
                                 treeHandle,
                                 0,
                                 NULL,
                                 KernelMode,
                                 &fileObject,
                                 NULL);

            ZwClose( treeHandle );

            if (NT_SUCCESS(ObjectRefStatus)) {
                DfsDeleteTreeConnection( fileObject, USE_FORCE );
            }
        }

        ExFreePool( shareName.Buffer );

        PktAcquireShared( TRUE, &pktLocked );

    } else {

        status = STATUS_INSUFFICIENT_RESOURCES;

    }
    DfsDbgTrace(-1, Dbg, "DfsTreeConnectGetInfo exit: Status %x\n", ULongToPtr(status) );
    return( status );

}



//+-------------------------------------------------------------------
//
//  Function:   DfsFsctrlCscServerOffline, public
//
//  Synopsis:   This routine implements the functionality to mark a server
//              as offline.
//
//  Returns:    [NTSTATUS] -- The completion status.
//
//--------------------------------------------------------------------


NTSTATUS
DfsFsctrlCscServerOffline(
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PUCHAR InputBuffer,
    IN ULONG InputBufferLength,
    IN OUT PUCHAR OutputBuffer,
    IN ULONG OutputBufferLength)
{
    UNICODE_STRING ServerName;
    LPWSTR Name;
    ULONG i, j;
    NTSTATUS NtStatus;

    DfsDbgTrace(+1, Dbg, "DfsFsctrlCscServerOffline -> %ws\n", (WCHAR *)InputBuffer);


    if(InputBuffer == NULL) {
        NtStatus = STATUS_INVALID_PARAMETER;
	DfsCompleteRequest( IrpContext, Irp, NtStatus );
	return NtStatus;
    }
    Name = (WCHAR *)InputBuffer;

    for (i = 0; i < InputBufferLength/sizeof(WCHAR) && (Name[i] == UNICODE_PATH_SEP); i++)
        NOTHING;

    for (j = i; j < InputBufferLength/sizeof(WCHAR) && (Name[j] != UNICODE_PATH_SEP); j++)
        NOTHING;
    
    ServerName.Buffer = &Name[i];
    ServerName.MaximumLength = ServerName.Length = (USHORT)(j - i) * sizeof(WCHAR);

    NtStatus = DfspMarkServerOffline(&ServerName);

    DfsCompleteRequest( IrpContext, Irp, NtStatus );
    DfsDbgTrace(-1, Dbg, "DfsFsctrlCscServerOffline -> %08lx\n", ULongToPtr(NtStatus) );
    return NtStatus;
}



//+-------------------------------------------------------------------
//
//  Function:   DfsFsctrlCscServerOnline, public
//
//  Synopsis:   This routine implements the functionality to mark a server
//              as online.
//
//  Returns:    [NTSTATUS] -- The completion status.
//
//--------------------------------------------------------------------



NTSTATUS
DfsFsctrlCscServerOnline(
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PUCHAR InputBuffer,
    IN ULONG InputBufferLength,
    IN OUT PUCHAR OutputBuffer,
    IN ULONG OutputBufferLength)
{
    UNICODE_STRING ServerName;
    LPWSTR Name;
    ULONG i, j;
    NTSTATUS NtStatus;

    DfsDbgTrace(+1, Dbg, "DfsFsctrlCscServerOnline -> %ws\n", (WCHAR *)InputBuffer);
    
    if(InputBuffer == NULL) {
        NtStatus = STATUS_INVALID_PARAMETER;
	DfsCompleteRequest( IrpContext, Irp, NtStatus );
	return NtStatus;
    }
    Name = (WCHAR *)InputBuffer;

    for (i = 0; i < InputBufferLength/sizeof(WCHAR) && (Name[i] == UNICODE_PATH_SEP); i++)
        NOTHING;

    for (j = i; j < InputBufferLength/sizeof(WCHAR) && (Name[j] != UNICODE_PATH_SEP); j++)
        NOTHING;
    
    ServerName.Buffer = &Name[i];
    ServerName.MaximumLength = ServerName.Length = (USHORT)(j - i) * sizeof(WCHAR);

    NtStatus = DfspMarkServerOnline(&ServerName);

    DfsCompleteRequest( IrpContext, Irp, NtStatus );
    DfsDbgTrace(-1, Dbg, "DfsFsctrlCscServerOnline -> %08lx\n", ULongToPtr(NtStatus) );
    return NtStatus;
}



//+-------------------------------------------------------------------
//
//  Function:   DfsFsctrlSpcRefresh, public
//
//  Synopsis:   This routine implements the functionality to update the
//              special table with a list of trusted domains, based on
//              the passed in domainname and dcname.
//
//  Returns:    [NTSTATUS] -- The completion status.
//
//--------------------------------------------------------------------


#if defined (_WIN64)
// 32 bit structure for handling spcrefresh from 32 bit client

typedef struct _DFS_SPC_REFRESH_INFO32 {
    ULONG  EventType;
    WORD * POINTER_32 DomainName;               // Name of domain
    WORD * POINTER_32 DCName;                   // Path of the share
} DFS_SPC_REFRESH_INFO32, *PDFS_SPC_REFRESH_INFO32;


#endif /* _WIN64 */
NTSTATUS
DfsFsctrlSpcRefresh (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PUCHAR  InputBuffer,
    IN ULONG InputBufferLength
) {
    NTSTATUS NtStatus = STATUS_SUCCESS;
    UNICODE_STRING DomainName;
    UNICODE_STRING DCName;
    ULONG NameLen, i;
    LPWSTR Name, BufferEnd;
    DFS_SPC_REFRESH_INFO Param;
    PDFS_SPC_REFRESH_INFO pParam;

    DfsDbgTrace(+1, Dbg, "DfsFsctrlSpcRefresh\n", 0);
    STD_FSCTRL_PROLOGUE(DfsFsctrlSpcRefresh, TRUE, FALSE, FALSE);

    pParam = (PDFS_SPC_REFRESH_INFO) InputBuffer;

#if defined (_WIN64)
    if (IoIs32bitProcess(Irp)) {
        PDFS_SPC_REFRESH_INFO32 pParam32;
    
        pParam32 = (PDFS_SPC_REFRESH_INFO32) InputBuffer;

        if (InputBufferLength < sizeof(DFS_SPC_REFRESH_INFO32)) {
            NtStatus =  STATUS_INVALID_PARAMETER;
            goto exit_with_status;
        }
   
        Param.EventType = pParam32->EventType;
        Param.DomainName = (WCHAR *)(((ULONG_PTR)pParam32) + (ULONG)pParam32->DomainName);
        Param.DCName = (WCHAR *)(((ULONG_PTR)pParam32) + (ULONG)pParam32->DCName);
        pParam = &Param;
    }
    else {
#endif
    if (InputBufferLength < sizeof(DFS_SPC_REFRESH_INFO)) {
        NtStatus =  STATUS_INVALID_PARAMETER;
        goto exit_with_status;
    }
      
    OFFSET_TO_POINTER(pParam->DomainName, pParam);
    OFFSET_TO_POINTER(pParam->DCName, pParam);

#if defined (_WIN64)
    }
#endif

    if (pParam->EventType != 0) {
        NtStatus =  STATUS_INVALID_PARAMETER;
        goto exit_with_status;
    }

    //
    // If either string is not within the input buffer, error.
    //
    if ((POINTER_IN_BUFFER(pParam->DomainName, sizeof(WCHAR), 
                           InputBuffer, InputBufferLength) == 0) ||
        (POINTER_IN_BUFFER(pParam->DomainName, sizeof(WCHAR),
                           InputBuffer, InputBufferLength) == 0)) {
        NtStatus =  STATUS_INVALID_PARAMETER;
        goto exit_with_status;
    }

    //
    // make sure the strings are valid.
    //
    BufferEnd = (LPWSTR)(InputBuffer + InputBufferLength);
    NameLen = (ULONG)(BufferEnd - pParam->DomainName);
    Name = pParam->DomainName;

    // Strip off leading slashes.
    for (i = 0; i < NameLen; i++) {
      if (*Name != UNICODE_PATH_SEP) {
	break;
      }
      Name++;
    }
    NameLen -= (ULONG)(Name - pParam->DomainName);

    for (i = 0; i < NameLen && Name[i]; i++)
      NOTHING;

    if ((i >= NameLen) || (i >= MAXUSHORT)) {
        NtStatus = STATUS_INVALID_PARAMETER;
        goto exit_with_status;
    }

    RtlInitUnicodeString(&DomainName, Name);


    NameLen = (ULONG)(BufferEnd - pParam->DCName);
    Name = pParam->DCName;

    // Strip off leading slashes.
    for (i = 0; i < NameLen; i++) {
      if (*Name != UNICODE_PATH_SEP) {
	break;
      }
      Name++;
    }
    NameLen -= (ULONG)(Name - pParam->DCName);

    for (i = 0; i < NameLen && Name[i]; i++)
      NOTHING;

    if ((i >= NameLen) || (i >= MAXUSHORT)) {
        NtStatus = STATUS_INVALID_PARAMETER;
        goto exit_with_status;
    }

    RtlInitUnicodeString(&DCName, Name);
    
    NtStatus = PktpUpdateSpecialTable(
                    &DomainName,
                    &DCName);

exit_with_status:

    DfsCompleteRequest( IrpContext, Irp, NtStatus );

    DfsDbgTrace(-1, Dbg, "DfsFsctrlSpcRefresh -> %08lx\n", ULongToPtr(NtStatus) );

    return( NtStatus );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mup\fscontrl.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    fscontrl.c

Abstract:

    This module implements the file system control routines for the MUP
    called by the dispatch driver.

Author:

    Manny Weiser (mannyw)    26-Dec-1991

Revision History:

--*/

#include "mup.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_FSCONTROL)

//
//  local procedure prototypes
//

NTSTATUS
RegisterUncProvider (
    IN PMUP_DEVICE_OBJECT MupDeviceObject,
    IN PIRP Irp
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, MupFsControl )
#pragma alloc_text( PAGE, RegisterUncProvider )
#endif


NTSTATUS
MupFsControl (
    IN PMUP_DEVICE_OBJECT MupDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the the File System Control IRP.

Arguments:

    MupDeviceObject - Supplies the device object to use.

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The status for the Irp

--*/

{
    NTSTATUS status;
    PIO_STACK_LOCATION irpSp;
    PFILE_OBJECT FileObject;

    PAGED_CODE();
    
    irpSp = IoGetCurrentIrpStackLocation( Irp );
    FileObject = irpSp->FileObject;

    DebugTrace(+1, Dbg, "MupFsControl\n", 0);
    MUP_TRACE_HIGH(TRACE_IRP, MupFsControl_Entry,
                   LOGPTR(MupDeviceObject)
                   LOGPTR(Irp)
                   LOGPTR(FileObject));

    //
    //  Reference our input parameters to make things easier
    //


    DebugTrace(+1, Dbg, "MupFileSystemControl\n", 0);
    DebugTrace( 0, Dbg, "Irp                = %08lx\n", (ULONG)Irp);
    DebugTrace( 0, Dbg, "OutputBufferLength = %08lx\n", irpSp->Parameters.FileSystemControl.OutputBufferLength);
    DebugTrace( 0, Dbg, "InputBufferLength  = %08lx\n", irpSp->Parameters.FileSystemControl.InputBufferLength);
    DebugTrace( 0, Dbg, "FsControlCode      = %08lx\n", irpSp->Parameters.FileSystemControl.FsControlCode);

    try {
        //
        // Decide how to handle this IRP.  Call the appropriate worker function.
        //

        switch (irpSp->Parameters.FileSystemControl.FsControlCode) {

        case FSCTL_MUP_REGISTER_UNC_PROVIDER:

            if( Irp->RequestorMode != KernelMode ) {
                status = STATUS_ACCESS_DENIED;
                MupCompleteRequest(Irp, STATUS_ACCESS_DENIED);
                return STATUS_ACCESS_DENIED;
            }

            status = RegisterUncProvider( MupDeviceObject, Irp );
            break;

        default:

            if (MupEnableDfs) {
                status = DfsFsdFileSystemControl(
                            (PDEVICE_OBJECT) MupDeviceObject,
                            Irp);
            } else {
                status = STATUS_INVALID_PARAMETER;
                MupCompleteRequest(Irp, STATUS_INVALID_PARAMETER);
            }

        }

    } except ( EXCEPTION_EXECUTE_HANDLER ) {
        NOTHING;
    }

    //
    // Return to the caller.
    //


    MUP_TRACE_HIGH(TRACE_IRP, MupFsControl_Exit, 
                   LOGSTATUS(status)
                   LOGPTR(MupDeviceObject)
                   LOGPTR(FileObject)
                   LOGPTR(Irp));
    DebugTrace(-1, Dbg, "MupFsControl -> %08lx\n", status);
    return status;
}


NTSTATUS
RegisterUncProvider (
    IN PMUP_DEVICE_OBJECT MupDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This function handles registration of a UNC provider.  The provider
    is added to the list of available providers.

Arguments:

    MupDeviceObject - A pointer to the file system device object.

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - the return status for the operation

--*/

{
    NTSTATUS status;
    PVCB vcb;
    PVOID fsContext2;
    PIO_STACK_LOCATION irpSp;

    PREDIRECTOR_REGISTRATION paramBuffer;
    ULONG paramLength;
    BLOCK_TYPE blockType;

    PUNC_PROVIDER uncProvider = NULL;
    PUNC_PROVIDER provider;
    PLIST_ENTRY listEntry;
    PVOID dataBuffer;

    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK ioStatusBlock;
    OBJECT_HANDLE_INFORMATION handleInformation;
    BOOLEAN InsertInProviderList = FALSE;

    MupDeviceObject;

    PAGED_CODE();
    irpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "RegisterUncProvider\n", 0);

    //
    // Get MUP ordering information, if we haven't already.
    //

    MupAcquireGlobalLock();

    if ( !MupOrderInitialized ) {
        MupOrderInitialized = TRUE;
        MupReleaseGlobalLock();
        MupGetProviderInformation();
    } else {
        MupReleaseGlobalLock();
    }

    //
    // Make local copies of the input parameters to make things easier.
    //

    paramLength = irpSp->Parameters.DeviceIoControl.InputBufferLength;
    paramBuffer = Irp->AssociatedIrp.SystemBuffer;

    //
    // Decode the file object.  If it is the file system VCB, it will be
    // referenced.
    //

    blockType = MupDecodeFileObject(
                    irpSp->FileObject,
                    (PVOID *)&vcb,
                    &fsContext2
                    );

    if ( blockType != BlockTypeVcb ) {

        DebugTrace(0, Dbg, "File is disconnected from us\n", 0);

        MupCompleteRequest( Irp, STATUS_INVALID_HANDLE );
        status = STATUS_INVALID_HANDLE;

        DebugTrace(-1, Dbg, "RegisterUncProvider -> %08lx\n", status );
        return status;
    }

    try {

        UNICODE_STRING deviceName;

        deviceName.Length = (USHORT)paramBuffer->DeviceNameLength;
        deviceName.MaximumLength = (USHORT)paramBuffer->DeviceNameLength;
        deviceName.Buffer = (PWCH)((PCHAR)paramBuffer + paramBuffer->DeviceNameOffset);

        //
        // Do the work
        //

        uncProvider = MupCheckForUnregisteredProvider( &deviceName );

        if ( uncProvider == NULL) {

            InsertInProviderList = TRUE;
	    uncProvider = MupAllocateUncProvider(
                              paramBuffer->DeviceNameLength);

            if (uncProvider != NULL) {

                //
                // Copy the data from the IRP.
                //

                dataBuffer = uncProvider + 1;
                uncProvider->DeviceName = deviceName;
                uncProvider->DeviceName.Buffer = dataBuffer;
                uncProvider->Priority = 0x7FFFFFFF;
                RtlMoveMemory(
                    uncProvider->DeviceName.Buffer,
                    (PCHAR)paramBuffer + paramBuffer->DeviceNameOffset,
                    paramBuffer->DeviceNameLength);

            } else {

                status = STATUS_INVALID_USER_BUFFER;
                try_return( NOTHING );

            }

        }

        dataBuffer = (PCHAR)dataBuffer + uncProvider->DeviceName.MaximumLength;

        uncProvider->MailslotsSupported = paramBuffer->MailslotsSupported;


        //
        // Reference the unc provider
        //

        MupReferenceBlock( uncProvider );

        //
        // Get a handle to the provider.
        //

        InitializeObjectAttributes(
            &objectAttributes,
            &uncProvider->DeviceName,
            OBJ_CASE_INSENSITIVE,      // Attributes
            0,                         // Root Directory
            NULL                       // Security
            );

        status = NtOpenFile(
                    &uncProvider->Handle,
                    FILE_TRAVERSE,
                    &objectAttributes,
                    &ioStatusBlock,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    FILE_DIRECTORY_FILE
                    );

        if ( NT_SUCCESS( status ) ) {
            status = ioStatusBlock.Status;
        }

        if ( NT_SUCCESS( status ) ) {
            //
            // Use the file object, to keep a pointer to the uncProvider
            //

            irpSp->FileObject->FsContext2 = uncProvider;
            //
            // 426184, need to check return code for errors.
            //
            status = ObReferenceObjectByHandle(
                         uncProvider->Handle,
                         0,
                         NULL,
                         KernelMode,
                         (PVOID *)&uncProvider->FileObject,
                         &handleInformation
                         );

	    if (!NT_SUCCESS( status)) {
	      NtClose(uncProvider->Handle);
	    }
        }

        if ( !NT_SUCCESS( status ) ) {
            MupDereferenceUncProvider(uncProvider);
	}
        else {
            uncProvider->DeviceObject = IoGetRelatedDeviceObject(
                                            uncProvider->FileObject
                                            );

            MupAcquireGlobalLock();

            MupProviderCount++;

	    if(InsertInProviderList) {
		//
		// We need to make sure we put the providers in the list in order of priority.
		//

		listEntry = MupProviderList.Flink;
		while ( listEntry != &MupProviderList ) {

		    provider = CONTAINING_RECORD(
			listEntry,
			UNC_PROVIDER,
			ListEntry
			);

		    if( uncProvider->Priority < provider->Priority ) {
			break;
		    }
		    listEntry = listEntry->Flink;
		}

		InsertTailList(listEntry, &uncProvider->ListEntry);
	    }
	    
	    uncProvider->Registered = TRUE;
            MupReleaseGlobalLock();


            //
            // !!! What do we do with the handle?  It is useless.
            //

            //
            // Finish up the fs control IRP.
            //

            status = STATUS_SUCCESS;
        }

try_exit: NOTHING;
    } finally {

        if ( AbnormalTermination() ) {
            status = STATUS_INVALID_USER_BUFFER;
        }

        //
        // Release the reference to the VCB.
        //

        MupDereferenceVcb( vcb );

        DebugTrace(-1, Dbg, "MupRegisterUncProvider -> %08lx\n", status);
    }

    MupCompleteRequest( Irp, status );

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mup\io.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    io.c

Abstract:

    This module contains IRP building routines.

Author:

    Manny Weiser (mannyw)    13-Jan-1992

Revision History:

--*/

#include "mup.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, MupBuildIoControlRequest )
#endif

PIRP
MupBuildIoControlRequest (
    IN OUT PIRP Irp OPTIONAL,
    IN PFILE_OBJECT FileObject OPTIONAL,
    IN PVOID Context,
    IN UCHAR MajorFunction,
    IN ULONG IoControlCode,
    IN PVOID MainBuffer,
    IN ULONG InputBufferLength,
    IN PVOID AuxiliaryBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN PIO_COMPLETION_ROUTINE CompletionRoutine
    )

/*++

Routine Description:

    This function builds an I/O request packet for a device or
    file system I/O control request.

Arguments:

    Irp - Supplies a pointer to an IRP.  If NULL, this routine allocates
        an IRP and returns its address.  Otherwise, it supplies the
        address of an IRP allocated by the caller.

    FileObject - Supplies a pointer the file object to which this
        request is directed.  This pointer is copied into the IRP, so
        that the called driver can find its file-based context.  NOTE
        THAT THIS IS NOT A REFERENCED POINTER.  The caller must ensure
        that the file object is not deleted while the I/O operation is
        in progress.  The server accomplishes this by incrementing a
        reference count in a local block to account for the I/O; the
        local block in turn references the file object.

    Context - Supplies a PVOID value that is passed to the completion
        routine.

    MajorFunction - The major function that we are calling.  Currently
        this most be one of IRP_MJ_FILE_SYSTEM_CONTROL or
        IRP_MJ_DEVICE_IO_CONTROL.

    IoControlCode - Supplies the control code for the operation.

    MainBuffer - Supplies the address of the main buffer.  This must
        be a system virtual address, and the buffer must be locked in
        memory.  If ControlCode specifies a method 0 request, the actual
        length of the buffer must be the greater of InputBufferLength
        and OutputBufferLength.

    InputBufferLength - Supplies the length of the input buffer.

    AuxiliaryBuffer - Supplies the address of the auxiliary buffer.  If the
        control code method is 0, this is a buffered I/O buffer, but the
        data returned by the called driver in the system buffer is not
        automatically copied into the auxiliary buffer.  Instead, the
        auxiliary data ends up in MainBuffer.  If the caller wishes the
        data to be in AuxiliaryBuffer, it must copy the data at some point
        after the completion routine runs.

        If the control code method is 1 or 2, this parameter is ignored;
        instead, the Mdl parameter is used to obtain the starting
        virtual address of the buffer.

    CompletionRoutine - The IO completion routine.

Return Value:

    PIRP - Returns a pointer to the constructed IRP.  If the Irp
        parameter was not NULL on input, the function return value will
        be the same value (so it is safe to discard the return value in
        this case).  It is the responsibility of the calling program to
        deallocate the IRP after the I/O request is complete.

--*/

{
    CLONG method;
    PDEVICE_OBJECT deviceObject;
    PIO_STACK_LOCATION irpSp;
    PMDL pMdl;

    ASSERT( MajorFunction == IRP_MJ_DEVICE_CONTROL );
    PAGED_CODE();

    if (MainBuffer == NULL) {

        return (NULL);

    }


    //
    // Get the method with which the buffers are being passed.
    //

    method = IoControlCode & 3;

    //
    // Allocate an IRP.  The stack size is one higher
    // than that of the target device, to allow for the caller's
    // completion routine.
    //

    deviceObject = IoGetRelatedDeviceObject( FileObject );

    //
    // Get the address of the target device object.
    //

    Irp = IoAllocateIrp( (CCHAR)(deviceObject->StackSize + 1), FALSE );
    if ( Irp == NULL ) {

        //
        // Unable to allocate an IRP.  Inform the caller.
        //

        return NULL;
    }

    IoSetNextIrpStackLocation( Irp );

    Irp->Tail.Overlay.OriginalFileObject = FileObject;
    Irp->Tail.Overlay.Thread = PsGetCurrentThread();

    //
    // Get a pointer to the current stack location and fill in the
    // device object pointer.
    //

    irpSp = IoGetCurrentIrpStackLocation( Irp );
    irpSp->DeviceObject = deviceObject;

    //
    // Set up the completion routine.
    //

    IoSetCompletionRoutine(
        Irp,
        CompletionRoutine,
        Context,
        TRUE,
        TRUE,
        TRUE
        );

    //
    // Get a pointer to the next stack location.  This one is used to
    // hold the parameters for the device I/O control request.
    //

    irpSp = IoGetNextIrpStackLocation( Irp );

    irpSp->MajorFunction = MajorFunction;
    irpSp->MinorFunction = 0;
    irpSp->FileObject = FileObject;
    irpSp->DeviceObject = deviceObject;

    //
    // Copy the caller's parameters to the service-specific portion of the
    // IRP for those parameters that are the same for all three methods.
    //

    irpSp->Parameters.DeviceIoControl.OutputBufferLength = OutputBufferLength;
    irpSp->Parameters.DeviceIoControl.InputBufferLength = InputBufferLength;
    irpSp->Parameters.DeviceIoControl.IoControlCode = IoControlCode;

    //
    // Based on the method by which the buffers are being passed,
    // describe a system buffer and optionally build an MDL.
    //

    switch ( method ) {

    case 0:

        //
        // For this case, InputBuffer must be large enough to contain
        // both the input and the output buffers.
        //

        Irp->MdlAddress = NULL;
        Irp->AssociatedIrp.SystemBuffer = MainBuffer;
        Irp->UserBuffer = AuxiliaryBuffer;

        Irp->Flags = (ULONG)IRP_BUFFERED_IO;
        if ( ARGUMENT_PRESENT(AuxiliaryBuffer) ) {
            Irp->Flags |= IRP_INPUT_OPERATION;
        }

        break;

    case 1:
    case 2:

        //
        // For these two cases, MainBuffer is the buffered I/O "system
        // buffer".  Build an MDL for either read or write access,
        // depending on the method, for the output buffer.
        //

        pMdl = IoAllocateMdl( MainBuffer, InputBufferLength, FALSE, FALSE, Irp );

        if (pMdl == NULL) {

            IoFreeIrp(Irp);
            return NULL;

        }

        Irp->AssociatedIrp.SystemBuffer = MainBuffer;
        Irp->Flags = (ULONG)IRP_BUFFERED_IO;

        //
        // An MDL to describe the buffer has not been built.  Build
        // it now.
        //

        MmProbeAndLockPages(
                    Irp->MdlAddress,
                    KernelMode,
                    IoReadAccess
                    );
        break;

    case 3:

        //
        // For this case, do nothing.  Everything is up to the driver.
        // Simply give the driver a copy of the caller's parameters and
        // let the driver do everything itself.
        //

        Irp->MdlAddress = NULL;
        Irp->AssociatedIrp.SystemBuffer = NULL;
        Irp->UserBuffer = AuxiliaryBuffer;
        irpSp->Parameters.DeviceIoControl.Type3InputBuffer = MainBuffer;
        break;

    }

    return Irp;

} // MupBuildIoControlRequest
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mup\fspdisp.c ===
//+----------------------------------------------------------------------------
//
//  File:       FSPDISP.C
//
//  Contents:   This module implements the main dispatch procedure
//              for the Dsfs FSP.
//
//  Functions:  DfsFsdPostRequest - post an IRP request to the FSP
//              DfsFspDispatch - Dispatch IRP requests from FSP thread
//
//  History:    12 Nov 1991     AlanW   Created from CDFS souce.
//              25 Apr 1993     Alanw   Updated to use Ex worker threads
//
//-----------------------------------------------------------------------------

#include "dfsprocs.h"
#include "dnr.h"


//
//  Define our local debug trace level
//

#define Dbg                             (DEBUG_TRACE_FSP_DISPATCHER)


#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, DfsFspDispatch )
//
// DfsFsdPostRequest cannot be paged since it is called from
// DnrCompleteFileOpen
//
//  DfsFsdPostRequest
//
#endif // ALLOC_PRAGMA

//+-------------------------------------------------------------------
//
//  Function:   DfsFsdPostRequest, public
//
//  Synopsis:   This routine enqueues the request packet specified by
//              IrpContext to the work queue associated with the
//              FileSysDeviceObject.  This is a FSD routine.
//
//  Arguments:  [IrpContext] -- Pointer to the IrpContext to be queued to
//                      the Fsp
//              [Irp] -- I/O Request Packet, or NULL if it has already been
//                      completed.
//
//  Returns:    STATUS_PENDING
//
//--------------------------------------------------------------------

NTSTATUS
DfsFsdPostRequest(
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
) {
    DfsDbgTrace(0, Dbg, "DfsFsdPostRequest: Irp = %08lx\n", Irp);

    ASSERT( ARGUMENT_PRESENT(Irp) &&
            IrpContext->OriginatingIrp == Irp );

    //
    //  Verify our assumptions about not needing DfsPrePostIrp processing.
    //
    ASSERT((IrpContext->MajorFunction != IRP_MJ_READ) &&
           (IrpContext->MajorFunction != IRP_MJ_WRITE) &&
           (IrpContext->MajorFunction != IRP_MJ_DIRECTORY_CONTROL) &&
           (IrpContext->MajorFunction != IRP_MJ_QUERY_EA) &&
           (IrpContext->MajorFunction != IRP_MJ_SET_EA));


    //
    //  Mark that we've already returned pending to the user
    //
    IoMarkIrpPending( Irp );

    //
    //  Send the IRP_CONTEXT off to an Ex worker thread.
    //

    ExInitializeWorkItem( &IrpContext->WorkQueueItem,
                          DfsFspDispatch,
                          IrpContext );

    ExQueueWorkItem( &IrpContext->WorkQueueItem, CriticalWorkQueue );

    //
    //  And return to our caller
    //

    return STATUS_PENDING;
}



//+-------------------------------------------------------------------
//
//  Function:   DfsFspDispatch, public
//
//  Synopsis:   This is the main FSP thread routine that is executed to receive
//              and dispatch IRP requests.  Each FSP requst begins its
//              execution here.
//
//  Arguments:  [Context] -- Supplies a pointer to a DFS IRP context record.
//
//  Returns:    Nonthing
//
//  Notes:
//
//--------------------------------------------------------------------

VOID
DfsFspDispatch (
    IN PVOID Context
) {

//    PFS_DEVICE_OBJECT FileSysDeviceObject = Context;
    PIRP Irp;
    PIRP_CONTEXT IrpContext = Context;

    Irp = IrpContext->OriginatingIrp;

    //
    //  Now because we are the Fsp we will force the IrpContext to
    //  indicate true on Wait.
    //

    IrpContext->Flags |= IRP_CONTEXT_FLAG_WAIT;
    IrpContext->Flags &= ~IRP_CONTEXT_FLAG_IN_FSD;

    //
    //  Now we'll loop forever, reading a new IRP request and dispatching
    //  on the IRP function
    //

    while (TRUE) {

        DfsDbgTrace(0, Dbg, "DfsFspDispatch: Irp = %08lx\n", Irp);

        ASSERT (Irp != NULL && Irp->IoStatus.Status != STATUS_VERIFY_REQUIRED);


        //
        //  Now case on the function code.      For each major function code,
        //  either call the appropriate FSP routine or case on the minor
        //  function and then call the FSP routine.      The FSP routine that
        //  we call is responsible for completing the IRP, and not us.
        //  That way the routine can complete the IRP and then continue
        //  post processing as required.  For example, a read can be
        //  satisfied right away and then read-ahead can be done.
        //
        //  We'll do all of the work within an exception handler that
        //  will be invoked if ever some underlying operation gets into
        //  trouble.
        //

        FsRtlEnterFileSystem();

        try {
            switch (IrpContext->MajorFunction) {

                //
                //  For Create/Open operations, we post a workitem only
                //  to resume DNR after a call to IoCallDriver.
                //
                //

            case IRP_MJ_CREATE:
	    case IRP_MJ_CREATE_NAMED_PIPE:
	    case IRP_MJ_CREATE_MAILSLOT:

                 ASSERT(IrpContext->Context != NULL);
                 ASSERT( ((PDNR_CONTEXT)IrpContext->Context)->NodeTypeCode ==
                        DSFS_NTC_DNR_CONTEXT );
                 DnrNameResolve( (PDNR_CONTEXT)IrpContext->Context );
		 PsAssignImpersonationToken(PsGetCurrentThread(),NULL);
                 break;

                //
                //      For close operations
                //
                case IRP_MJ_CLOSE:
                    DfsFspClose( IrpContext, Irp );
                    break;

                //
                //  For Set Information operations,
                //

                case IRP_MJ_SET_INFORMATION:

                    DfsFspSetInformation( IrpContext, Irp );
                    break;

                //
                //  For Query Volume Information operations,
                //

                case IRP_MJ_QUERY_VOLUME_INFORMATION:

                    DfsFspQueryVolumeInformation( IrpContext, Irp );
                    break;

                //
                //  For Set Volume Information operations,
                //

                case IRP_MJ_SET_VOLUME_INFORMATION:

                    DfsFspSetVolumeInformation( IrpContext, Irp );
                    break;

                //
                //  For File System Control operations,
                //

                case IRP_MJ_FILE_SYSTEM_CONTROL:

                    DfsFspFileSystemControl( IrpContext, Irp );
                    break;

                //
                //  For any other major operations, return an invalid
                //  request.
                //

                default:
                    DfsDbgTrace(0, Dbg, "DfsFspDispatch:  Unhandled request, MajorFunction = %08lx\n", IrpContext->MajorFunction);

                    DfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_DEVICE_REQUEST );
                    break;
            }

        } except( DfsExceptionFilter( IrpContext, GetExceptionCode(), GetExceptionInformation() )) {

            DfsProcessException( IrpContext, Irp, GetExceptionCode() );
        }

        FsRtlExitFileSystem();

        //
        //  NOTE: If we were to process an overflow device queue, we would
        //        do it here.  Instead, we'll just return to the worker
        //        thread.
        //

        break;

    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mup\log.h ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation
//
//  File:       log.h
//
//  Contents:   Module to log messages from the driver to the NT event logging
//		system.
//
//  Classes:
//
//  Functions:  LogWriteMessage()
//	
//  History:    3/30/93		Milans created
//		04/18/93	SudK	Changed this function entirely.
//
//-----------------------------------------------------------------------------

#ifndef _LOG_H_
#define _LOG_H_

#define EVENT_SUCCESSFUL_INIT	0
#define EVENT_RANDOM_ERROR	1

VOID LogWriteMessage(
	IN ULONG	UniqueErrorCode,
	IN NTSTATUS	NtStatusCode,
	IN ULONG	nStrings,
	IN PUNICODE_STRING pustrArg OPTIONAL);

#endif // _LOG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mup\lock.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    lock.c

Abstract:

    This module implements debugging function for locks.

Author:

    Manny Weiser (mannyw) 17-Jan-1992
        This is essentially a copy of the LAN Manager server lock
        debugging

Revision History:

--*/

#if MUPDBG

#include "mup.h"

#define HAS_TEB(_teb) ((BOOLEAN)(((ULONG)(_teb) <= MM_HIGHEST_USER_ADDRESS) ? FALSE : MmIsNonPagedSystemAddressValid(_teb)))

#define MupCurrentTeb( ) ((PTEB)(KeGetCurrentThread( )->Teb))

#define MupTebLockList( ) \
    ((PLIST_ENTRY)&(MupCurrentTeb( )->UserReserved[MUP_TEB_LOCK_LIST]))

#define MupThreadLockAddress( )                                               \
    ( IsListEmpty( MupTebLockList( ) ) ? 0 : CONTAINING_RECORD(               \
                                                 MupTebLockList( )->Flink,    \
                                                 MUP_LOCK,                    \
                                                 Header.ThreadListEntry       \
                                                 ) )

#define MupThreadLockLevel( )                                                 \
    ( IsListEmpty( MupTebLockList( ) ) ? 0 : CONTAINING_RECORD(               \
                                                 MupTebLockList( )->Flink,    \
                                                 MUP_LOCK,                    \
                                                 Header.ThreadListEntry       \
                                                 )->Header.LockLevel )

#define MupThreadLockName( )                                                  \
    ( IsListEmpty( MupTebLockList( ) ) ? "none" : CONTAINING_RECORD(          \
                                                 MupTebLockList( )->Flink,    \
                                                 MUP_LOCK,                    \
                                                 Header.ThreadListEntry       \
                                                 )->Header.LockName )

KSPIN_LOCK LockSpinLock = {0};
BOOLEAN LockSpinLockInitialized = FALSE;

#define MAX_LOCKS_HELD 15

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, MupInitializeLock )
#pragma alloc_text( PAGE, MupDeleteLock )
#pragma alloc_text( PAGE, MupReleaseLock )
#pragma alloc_text( PAGE, MupCheckListIntegrity )
#endif
#if 0
NOT PAGEABLE - MupAcquireLock
#endif

VOID
MupInitializeLock(
    IN PMUP_LOCK Lock,
    IN ULONG LockLevel,
    IN PSZ LockName
    )

/*++

Routine Description:

    This routine initializes the input lock variable.

Arguments:

    Lock - Supplies the lock variable being initialized

    LockLevel - Supplies the level of the lock

    LockName - Supplies the name of the lock

Return Value:

    None.

--*/

{
    PAGED_CODE( );

    if ( !LockSpinLockInitialized ) {
        LockSpinLockInitialized = TRUE;
        KeInitializeSpinLock( &LockSpinLock );
    }

    //
    // Initialize the executive resource.
    //

    ExInitializeResourceLite( &Lock->Resource );

    //
    // Initialize the lock level.  This is used to determine whether a
    // thread may acquire the lock.  Save the lock name.
    //

    LOCK_LEVEL( Lock ) = LockLevel;

    LOCK_NAME( Lock ) = LockName;

    return;

} // MupInitializeLock


VOID
MupDeleteLock (
    IN PMUP_LOCK Lock
    )

/*++

Routine Description:

    This routine deletes (i.e., uninitializes) a lock variable.

Arguments:

    Lock - Supplies the lock variable being deleted

Return Value:

    None.

--*/

{
    PAGED_CODE( );

    //
    // Make sure the lock is unowned.
    //

    if ( LOCK_NUMBER_OF_ACTIVE( Lock ) != 0 ) {

        DbgPrint( "MupDeleteLock: Thread %d\n", KeGetCurrentThread( ) );
        DbgPrint( "MupDeleteLock: Attempt to delete owned lock %s(%lx)",
            LOCK_NAME( Lock ),
            Lock
            );
        DbgBreakPoint();

    }

    //
    // Delete the resource.
    //

    ExDeleteResourceLite( &Lock->Resource );

    return;

} // MupDeleteLock


VOID
MupAcquireLock(
    IN PMUP_LOCK Lock
    )

/*++

Routine Description:

    The routine acquires a lock.

Arguments:

    Lock - Supplies the lock to acquire

Return Value:

    BOOLEAN - Indicates whether the lock was acquired.

--*/

{
    PKTHREAD currentThread;
    PTEB currentTeb;
    BOOLEAN hasTeb;
    ULONG threadLockLevel;
    KIRQL oldIrql;

    currentThread = (PKTHREAD)ExGetCurrentResourceThread( );
    currentTeb = MupCurrentTeb( );
    hasTeb = HAS_TEB(currentTeb);

    //
    // If this thread does not have a nonpaged TEB, do not do lock-level
    // debugging.  (We might be at DPC level, so we can't take page
    // faults.)
    //

    if ( hasTeb ) {

        //
        // Make sure that this thread has been initialized for lock
        // debugging.  If not, initialize it.
        //

        KeAcquireSpinLock( &LockSpinLock, &oldIrql );
        if ( (ULONG)currentTeb->UserReserved[MUP_TEB_LOCK_INIT] !=
                                                        0xbabababa ) {
            PLIST_ENTRY tebLockList = MupTebLockList( );
            InitializeListHead( tebLockList );
            currentTeb->UserReserved[MUP_TEB_LOCK_INIT] = (PVOID)0xbabababa;
        }
        KeReleaseSpinLock( &LockSpinLock, oldIrql );

        //
        // Make sure that the list of locks in the TEB is consistent.
        //

        MupCheckListIntegrity( MupTebLockList( ), MAX_LOCKS_HELD );

        //
        // The "lock level" of this thread is the highest level of the
        // locks currently held exclusively.  If this thread holds no
        // locks, the lock level of the thread is 0 and it can acquire
        // any lock.
        //

        threadLockLevel = MupThreadLockLevel( );

        //
        // Make sure that the lock the thread is attempting to acquire
        // has a higher level than the last-acquired exclusive lock.
        // Note that a recursive exclusive acquisition of a lock should
        // succeed, even if a different, higher-level lock has been
        // acquired since the lock was originally acquired.  Shared
        // acquisition of a lock that is already held exclusively must
        // fail.
        //

        if ( LOCK_LEVEL( Lock ) <= threadLockLevel ) {

            DbgPrint( "Thread %lx, last lock %s(%lx, L%lx) attempted to ",
                        currentThread,
                        MupThreadLockName( ), MupThreadLockAddress( ),
                        threadLockLevel );
            DbgPrint( "acquire %s(%lx, L%lx) for %s access.\n",
                        LOCK_NAME( Lock ), Lock, LOCK_LEVEL( Lock ),
                        "exclusive" );
            DbgBreakPoint( );

        }

    }

    //
    // Acquire the lock.
    //

    ExAcquireResourceExclusiveLite( &Lock->Resource, TRUE );

    //
    // The thread acquired the lock for exlusive access.
    //

    if ( LOCK_NUMBER_OF_ACTIVE( Lock ) == -1 ) {

        if ( hasTeb ) {

            //
            // Insert the lock on the thread's list of locks.
            //

            ExInterlockedInsertHeadList(
                MupTebLockList( ),
                LOCK_THREAD_LIST( Lock ),
                &LockSpinLock
                );

        }

    }

    return;

} // MupAcquireLock


VOID
MupReleaseLock(
    IN PMUP_LOCK Lock
    )

/*++

Routine Description:

    This routine releases a lock.

Arguments:

    Lock - Supplies the lock to release

Return Value:

    None.

--*/

{
    PKTHREAD currentThread;
    PTEB currentTeb;
    BOOLEAN hasTeb;

    PAGED_CODE( );

    currentThread = (PKTHREAD)ExGetCurrentResourceThread( );
    currentTeb = MupCurrentTeb( );
    hasTeb = HAS_TEB(currentTeb);

    //
    // Make sure the lock is really owned by the current thread.
    //

    if ( LOCK_NUMBER_OF_ACTIVE( Lock ) == 0 ) {

        // !!! Should crash server on internal error here.

        DbgPrint( "Thread %lx releasing unowned lock %s(%lx)\n",
                    currentThread, LOCK_NAME( Lock ), Lock );
        DbgBreakPoint( );

    } else if ( (LOCK_NUMBER_OF_ACTIVE( Lock ) < 0) &&
                (LOCK_EXCLUSIVE_OWNER( Lock ) != (ULONG)currentThread) ) {

        // !!! Should crash server on internal error here.

        DbgPrint( "Thread %lx releasing lock %s(%lx) owned by "
                    "thread %lx\n",
                    currentThread, LOCK_NAME( Lock ), Lock,
                    LOCK_EXCLUSIVE_OWNER( Lock ) );
        DbgBreakPoint( );

    } else if ( LOCK_NUMBER_OF_ACTIVE( Lock ) == -1 ) {

        //
        // The thread is fully releasing exclusive access to the lock.
        //

        if ( hasTeb ) {

            //
            // Remove the lock from the list of locks held by this
            // thread.
            //

            ExInterlockedRemoveHeadList(
                LOCK_THREAD_LIST( Lock )->Blink,
                &LockSpinLock
                );
            LOCK_THREAD_LIST( Lock )->Flink = NULL;
            LOCK_THREAD_LIST( Lock )->Blink = NULL;

            //
            // Make sure that the list of locks in the TEB is consistent.
            //

            MupCheckListIntegrity( MupTebLockList( ), MAX_LOCKS_HELD );

        }

    }

    //
    // Now actually do the release.
    //

    ExReleaseResourceLite( &Lock->Resource );

    return;

} // MupReleaseLock


ULONG
MupCheckListIntegrity (
    IN PLIST_ENTRY ListHead,
    IN ULONG MaxEntries
    )

/*++

Routine Description:

    This debug routine checks the integrity of a doubly-linked list by
    walking the list forward and backward.  If the number of elements is
    different in either direction, or there are too many entries in the
    list, execution is stopped.

    *** It is the responsibility of the calling routine to do any
        necessary synchronization.

Arguments:

    ListHead - a pointer to the head of the list.

    MaxEntries - if the number of entries in the list exceeds this
        number, breakpoint.

Return Value:

    ULONG - the number of entries in the list.

--*/

{
    PLIST_ENTRY current;
    ULONG entriesSoFar;
    ULONG flinkEntries;

    for ( current = ListHead->Flink, entriesSoFar = 0;
          current != ListHead;
          current = current->Flink ) {

        if ( ++entriesSoFar >= MaxEntries ) {
            DbgPrint( "Seen %ld entries in list at %lx\n",
                        entriesSoFar, ListHead );
            DbgBreakPoint( );
        }
    }

    flinkEntries = entriesSoFar;

    for ( current = ListHead->Blink, entriesSoFar = 0;
          current != ListHead;
          current = current->Blink ) {

        if ( ++entriesSoFar >= MaxEntries ) {
            DbgPrint( "Seen %ld entries in list at %lx\n",
                        entriesSoFar, ListHead );
            DbgBreakPoint( );
        }
    }

    if ( flinkEntries != entriesSoFar ) {
        DbgPrint( "In list %lx, Flink entries: %ld, Blink entries: %lx\n",
                      ListHead, flinkEntries, entriesSoFar );
        DbgBreakPoint( );
    }

    return entriesSoFar;

} // MupCheckListIntegrity

#endif // MUPDBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mup\know.h ===
//+------------------------------------------------------------------
//
// File:        Know.h
//
// Contents:    Header file for knowledge related functions.
//
// Functions:   
//
// History:     22-March-1992   SudK    Created
//
//-------------------------------------------------------------------



NTSTATUS
DfsTriggerKnowledgeVerification(
    IN  PDNR_CONTEXT    DnrContext
    );

NTSTATUS
DfsDispatchUserModeThread(
    IN PVOID    InputBuffer,
    IN ULONG    InputBufferLength
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mup\know.c ===
//+------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation
//
//  File:       Know.C
//
//  Contents:   This file has all the code that involves with knowledge
//              synchronisation on the DC.
//
//  Synoposis:  This code handles the fixing of knowledge inconsistencies.
//              All this code runs only on the DC in response to FSCTRLs from
//              a client etc.
//
//  Functions:  DfsTriggerKnowledgeVerification -
//
//  History:    22-March-1993   SudK    Created
//              18-June-1992    SudK    Added FixLocalVolumeKnowledge
//
//-------------------------------------------------------------------

#include "dfsprocs.h"
#include "fsctrl.h"
#include "dnr.h"
#include "know.h"
#include "log.h"
#include "smbtypes.h"
#include "smbtrans.h"

#define Dbg     (DEBUG_TRACE_LOCALVOL)


//
//  local function prototypes
//

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, DfsTriggerKnowledgeVerification )
#endif // ALLOC_PRAGMA


//+------------------------------------------------------------------
//
//  Function:   DfsTriggerKnowledgeVerification
//
//  Synopsis:   This function calls the DC and informs it that a specific
//              service for a volume seems to have inconsistenct knowledge
//              with the DC.
//
//              If the service in question is a local service, then it means
//              that there is an extra exit point on the disk. In that event
//              this routine merely deletes the extra exit point.
//
//  Arguments:  [DnrContext] -- The DnrContext has all that this func needs.
//
//  Returns:    The status from this not checked by anyone actually.
//
//  History:    4-April-1993    SudK    Created
//
//  Notes:      This method should be called from DNR only.  It is
//              assumed that the caller has released any locks on the
//              PKT.  There is a possibility of deadlock if the PKT lock
//              is held over this function, since the DC may call back
//              to us to correct knowledge errors.
//
//-------------------------------------------------------------------
NTSTATUS
DfsTriggerKnowledgeVerification(
    IN  PDNR_CONTEXT    DnrContext)
{

    NTSTATUS                    status = STATUS_SUCCESS;
    NTSTATUS                    ReplStatus;
    IO_STATUS_BLOCK             ioStatusBlock;

    ULONG                       size;
    PBYTE                       buffer = NULL;
    PDFS_REFERRAL_V1            ref;

    UNICODE_STRING              prefix, address;

    PDFS_PKT_ENTRY              pPktEntryDC;
    PDFS_SERVICE                DCService;
    PPROVIDER_DEF               DCProvider;
    REPL_SELECT_CONTEXT         DCSelectContext;
    HANDLE                      remoteHandle;

    UNICODE_STRING              puStr[2];

    DfsDbgTrace(+1, Dbg, "DfsTriggerKnowledgeVerification: %wZ\n",
                                            &DnrContext->pPktEntry->Id.Prefix);
    DfsDbgTrace( 0, Dbg, " ServiceName: [%wZ]\n",
        ((DnrContext->pService->Type & DFS_SERVICE_TYPE_LOCAL) ?
            &DnrContext->pService->Address :
                &DnrContext->pService->Name) );

    RtlZeroMemory(&DCSelectContext, sizeof(REPL_SELECT_CONTEXT));

    //
    // First, create a REQ_REPORT_DFS_INCONSISTENCY buffer for the rdr to
    // send to the DC.
    //

    if (DnrContext->pPktEntry->USN != DnrContext->USN) {

        DfsDbgTrace(0, Dbg,"Pkt Entry changed!\n", 0 );
        DfsDbgTrace(0, Dbg, "Old USN: %d\n", ULongToPtr(DnrContext->USN) );
        DfsDbgTrace(0, Dbg, "New USN: %d\n", ULongToPtr(DnrContext->pPktEntry->USN) );

        status = STATUS_INVALID_HANDLE;
    }

    if (NT_SUCCESS(status)) {

        prefix = DnrContext->pPktEntry->Id.Prefix;

        address = DnrContext->pService->Address;

        size = prefix.Length +
                sizeof(WCHAR) +
                    sizeof(DFS_REFERRAL_V1) +
                        address.Length +
                            sizeof(WCHAR);

        // For some strange, undocumented reason, the buffer size passed in
        // to ZwFsControlFile is size + sizeof(ULONG). So allocate that size here.

        buffer = ExAllocatePoolWithTag( PagedPool, size + sizeof(ULONG), ' puM' );

        if (buffer != NULL) {

            RtlMoveMemory( buffer, prefix.Buffer, prefix.Length);

            ((PWCHAR)buffer)[prefix.Length/sizeof(WCHAR)] = UNICODE_NULL;

            ref = (PDFS_REFERRAL_V1) (buffer + prefix.Length + sizeof(WCHAR));

            ref->VersionNumber = 1;

            ref->Size = sizeof(DFS_REFERRAL_V1) + address.Length + sizeof(WCHAR);

            ref->ServerType = 0;

            RtlMoveMemory( ref->ShareName, address.Buffer, address.Length );

            ref->ShareName[ address.Length/sizeof(WCHAR) ] = UNICODE_NULL;

        } else {

            status = STATUS_INSUFFICIENT_RESOURCES;

        }

    }

    //
    // Next, connect to the DC.
    //

    if (NT_SUCCESS(status)) {

        BOOLEAN pktLocked;
        BOOLEAN LastEntry = FALSE;

        //
        // We need to get a handle to the DC now.  So that we can make an
        // FSCTRL to the DC.
        //

        PktAcquireShared( TRUE, &pktLocked );

        ExAcquireResourceExclusiveLite( &DfsData.Resource, TRUE );

        pPktEntryDC = PktLookupReferralEntry(
                            &DfsData.Pkt,
                            DnrContext->pPktEntry);

        if (pPktEntryDC != NULL) {

            ReplStatus = ReplFindFirstProvider(
                                pPktEntryDC,
                                NULL,
                                NULL,
                                &DCService,
                                &DCSelectContext,
                                &LastEntry);

        }

        if (pPktEntryDC == NULL || !NT_SUCCESS(ReplStatus)) {

            DfsDbgTrace(0, Dbg,
                "DfsTriggerKnowVerification. Failed to find DC\n", 0);

            status = STATUS_CANT_ACCESS_DOMAIN_INFO;

        } else {

            DCProvider = DCService->pProvider;

        }

        ExReleaseResourceLite( &DfsData.Resource );

        if (NT_SUCCESS(status)) {

            status = DfsCreateConnection(
                        DCService,
                        DCProvider,
                        (BOOLEAN)((DnrContext->Vcb->VcbState & VCB_STATE_CSCAGENT_VOLUME) != 0),
                        &remoteHandle);

        }

        PktRelease();

    }

    //
    //  Lastly, tell the DC to try and fix up the volume on the server. This
    //  call may result in a call back to ourselves in the event that we
    //  are missing knowledge about a local volume.
    //

    if (NT_SUCCESS(status))     {

        status = ZwFsControlFile(
                    remoteHandle,
                    NULL,
                    NULL,
                    NULL,
                    &ioStatusBlock,
                    FSCTL_DFS_VERIFY_REMOTE_VOLUME_KNOWLEDGE,
                    buffer,
                    size + sizeof(ULONG),
                    NULL,
                    0
                );

        if (NT_SUCCESS(status))
            status = ioStatusBlock.Status;

        ZwClose( remoteHandle );

    }


    if (buffer != NULL)
        ExFreePool(buffer);

    DfsDbgTrace(-1, Dbg,
        "DfsTriggerKnowledgeVerification - exit %08lx\n", ULongToPtr(status) );

    return(status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mup\mup.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    mup.h

Abstract:

    This module is the main include file for the MUP.
    It includes other header files.

Author:

    Manny Weiser (mannyw)    17-Dec-1991

Revision History:

--*/

#ifndef _MUP_
#define _MUP_

#include <dfsprocs.h>

//
// Local, independent include files
//

#include "debug.h"

//
// Local, dependent include files (order is important)
//

#include "lock.h"
#include "mupdata.h"
#include "mupstruc.h"
#include "mupfunc.h"
#include "mupwml.h"

#endif // def _MUP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mup\lock.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    lock.h

Abstract:

    This module defines the data structures and function prototypes used
    for spin lock debugging.

Author:

    Manny Weiser (mannyw)    18-Jan-1992

Revision History:

--*/

#ifndef _LOCK_
#define _LOCK_

#if MUPDBG

#define MUP_TEB_LOCK_LIST 0

#define INITIALIZE_LOCK( lock, level, name ) \
                    MupInitializeLock( (lock), (level), (name) )
#define DELETE_LOCK( lock ) MupDeleteLock( lock )

#define ACQUIRE_LOCK(lock) MupAcquireLock( lock )
#define RELEASE_LOCK(lock) MupReleaseLock( lock )
#define LOCK_NAME( lock ) ((lock)->Header.LockName)
#define LOCK_LEVEL( lock ) ((lock)->Header.LockLevel)
#define LOCK_THREAD_LIST( lock ) (&((lock)->Header.ThreadListEntry))

#define LOCK_NUMBER_OF_ACTIVE( lock ) ((lock)->Resource.ActiveCount)
#define LOCK_EXCLUSIVE_OWNER( lock ) ((ULONG)(lock)->Resource.OwnerThreads[0].OwnerThread)

//
// MUP_LOCK_HEADER is a structure that contains debugging information
// used by the server lock package.  Mup spin locks contain a
// MUP_LOCK_HEADER.
//

typedef struct _MUP_LOCK_HEADER {

    //
    // To prevent deadlocks, locks are assigned level numbers.  If a
    // thread holds a lock with level N, it may only acquire new locks
    // with a level greater then N.  Level numbers are assigned during
    // lock initialization.
    //

    ULONG LockLevel;

    //
    // A doubly-linked list of all the locks owned by a thread is stored
    // in a thread's TEB.  The list is in order of lock level (from
    // highest to lowest), which is also, by definition of lock levels,
    // the order in which the thread acquired the locks.  This allows
    // the thread to release the locks in any order while maintaining
    // easy access to the highest-level lock that the thread owns,
    // thereby providing a mechanism for ensuring that locks are
    // acquired in increasing order.
    //

    LIST_ENTRY ThreadListEntry;

    //
    // The symbolic name of the lock is used in DbgPrint calls.
    //

    PSZ LockName;

} MUP_LOCK_HEADER, *PMUP_LOCK_HEADER;

//
// When debugging is enabled, a server lock is a wrapper around an
// executive resource.
//

typedef struct _MUP_LOCK {

    //
    // The MUP_LOCK_HEADER must appear first!
    //

    MUP_LOCK_HEADER Header;

    //
    // The actual "lock" is maintained by the resource package.
    //

    ERESOURCE Resource;

} MUP_LOCK, *PMUP_LOCK;

VOID
MupInitializeLock(
    IN PMUP_LOCK Lock,
    IN ULONG Locklevel,
    IN PSZ LockName
    );

VOID
MupDeleteLock (
    IN PMUP_LOCK Lock
    );

VOID
MupAcquireLock(
    IN PMUP_LOCK Lock
    );

VOID
MupReleaseLock(
    IN PMUP_LOCK Lock
    );

ULONG
MupCheckListIntegrity (
    IN PLIST_ENTRY ListHead,
    IN ULONG MaxEntries
    );

//
// Macros that define locations in the UserReserved field of the TEB
// where lock level information is stored.
//

#define MUP_TEB_LOCK_LIST 0
#define MUP_TEB_LOCK_INIT 2
#define MUP_TEB_USER_SIZE (3 * sizeof(ULONG))

//
// Levels used for spin locks used in the MUP.  Locks can be acquired
// only in increasing lock level order.  Be careful when adding a new
// lock or when changing the order of lock levels.
//

#define GLOBAL_LOCK_LEVEL                       (ULONG)0x80000100
#define PREFIX_TABLE_LOCK_LEVEL                 (ULONG)0x80000200
#define CCB_LIST_LOCK_LEVEL                     (ULONG)0x80000300
#define QUERY_CONTEXT_LOCK_LEVEL                (ULONG)0x80000400
#define DEBUG_LOCK_LEVEL                        (ULONG)0x80000500

#else

#define INITIALIZE_LOCK( lock, level, name ) ExInitializeResourceLite( (lock) )
#define DELETE_LOCK( lock ) ExDeleteResourceLite( (lock) )
#define ACQUIRE_LOCK( lock ) \
                    ExAcquireResourceExclusiveLite( (lock), TRUE )
#define RELEASE_LOCK(lock) ExReleaseResourceLite( (lock) )

typedef ERESOURCE MUP_LOCK, *PMUP_LOCK;
#endif // MUPDBG

#endif // _LOCK_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mup\minfo.c ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:   MInfo.C
//
//  Contents:
//
//  Functions:
//
//  History:
//
//-----------------------------------------------------------------------------

#ifdef KERNEL_MODE
#include "dfsprocs.h"
#endif

INIT_TADDRESS_MARSHAL_INFO()
INIT_DS_TRANSPORT_P_MARSHAL_INFO()
INIT_DS_TRANSPORT_MARSHAL_INFO()
INIT_DS_MACHINE_P_MARSHAL_INFO()
INIT_DS_MACHINE_MARSHAL_INFO()

INIT_DFS_MACHINE_ENTRY_MARSHAL_INFO()
INIT_DFS_SERVICE_MARSHAL_INFO()
INIT_DFS_PKT_ENTRY_ID_MARSHAL_INFO()
INIT_DFS_PKT_ENTRY_INFO_MARSHAL_INFO()
INIT_DFS_PKT_ENTRY_MARSHAL_INFO()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mup\mupdata.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    mupdata.c

Abstract:

    This module defines global MUP data.

Author:

    Manny Weiser (mannyw)    20-Dec-1991

Revision History:

--*/

#include "mup.h"

//
// MupGlobalLock is used to protect everything that is not protected
// by its own lock.
//

MUP_LOCK MupGlobalLock = {0};

//
// MupVcbLock is used to protect access to the VCB itself.
//

ERESOURCE MupVcbLock = {0};

//
// MupPrefixTableLock is used to protect the prefix table.
//

MUP_LOCK MupPrefixTableLock = {0};

//
// MupCcbListLock is used to protect access to the CCB list for all FCBs
//

MUP_LOCK MupCcbListLock = {0};

//
// MupInterlock is used to protect access to block reference counts.
//

KSPIN_LOCK MupInterlock = {0};

//
// The global list of all providers.  This list is protected by
// MupGlobalLock.
//

LIST_ENTRY MupProviderList = {0};

//
// The list of Mup prefixes

LIST_ENTRY MupPrefixList = {0};

//
// The list of active queries

LIST_ENTRY MupMasterQueryList = {0};

//
// The number of registered providers.
//

ULONG MupProviderCount = 0;

//
// The prefix table save all known prefix blocks.  It is protected by
// MupPrefixTableLock.
//

UNICODE_PREFIX_TABLE MupPrefixTable = {0};

//
// The MUP IRP stack size.
//

CCHAR MupStackSize = 0;

//
// The MUP known prefix timeout.  This is currently set at compile time.
//

LARGE_INTEGER MupKnownPrefixTimeout = {0};

//
// Indicator to know if provider ordering information has been read from
// the registry.
//

BOOLEAN MupOrderInitialized = {0};

//
// When we need to ask several rdrs to do an operation, and they all fail,
//  we need to return a single error code.  MupOrderedErrorList is a list
//  of status codes, from least important to most important, to guide in
//  determining which error codes should be returned.  An error code
//  at a higher index will replace an error code at a lower index.  An error
//  code not in the list always wins.  This processing is in MupDereferenceMasterIoContext()
//
NTSTATUS MupOrderedErrorList[] = {
        STATUS_UNSUCCESSFUL,
        STATUS_INVALID_PARAMETER,
        STATUS_REDIRECTOR_NOT_STARTED,
        STATUS_BAD_NETWORK_NAME,
        STATUS_BAD_NETWORK_PATH,
        0
};

//
// This boolean indicates whether to enable the Dfs client or not.
//

BOOLEAN MupEnableDfs = FALSE;

#ifdef MUPDBG
MUP_LOCK MupDebugLock = {0};
ULONG MupDebugTraceLevel = 0;
ULONG MupDebugTraceIndent = 0;
#endif

#ifdef ALLOC_PRAGMA
#pragma alloc_text( INIT, MupInitializeData )
#pragma alloc_text( PAGE, MupUninitializeData )
#endif
NTSTATUS
MupInitializeData(
    )

/*++

Routine Description:

    This routine initialize the MUP global data.

Arguments:

    None

Return Value:

    NTSTATUS - The function value is the final status from the data
        initialization.

--*/

{
    PAGED_CODE();
    INITIALIZE_LOCK(
        &MupGlobalLock,
        GLOBAL_LOCK_LEVEL,
        "MupGlobalLock"
        );

    INITIALIZE_LOCK(
        &MupPrefixTableLock,
        PREFIX_TABLE_LOCK_LEVEL,
        "MupPrefixTableLock"
        );

    INITIALIZE_LOCK(
        &MupCcbListLock,
        CCB_LIST_LOCK_LEVEL,
        "MupCcbListLock"
        );

#ifdef MUPDBG
    INITIALIZE_LOCK(
        &MupDebugLock,
        DEBUG_LOCK_LEVEL,
        "MupDebugLock"
        );
#endif

    KeInitializeSpinLock( &MupInterlock );

    ExInitializeResourceLite( &MupVcbLock );

    MupProviderCount = 0;

    InitializeListHead( &MupProviderList );
    InitializeListHead( &MupPrefixList );   
    InitializeListHead( &MupMasterQueryList );
    RtlInitializeUnicodePrefix( &MupPrefixTable );


    MupStackSize = 3; // !!!

    //
    // Calculate the timeout in NT relative time.
    //

    MupKnownPrefixTimeout.QuadPart = UInt32x32To64(
                               KNOWN_PREFIX_TIMEOUT * 60,
                               10 * 1000 * 1000
                               );

    MupOrderInitialized = FALSE;

    return STATUS_SUCCESS;
}

VOID
MupUninitializeData(
    )
/*++

Routine Description:

    This routine uninitializes the MUP global data.

Arguments:

    None

Return Value:

    None

--*/
{
    DELETE_LOCK(
        &MupGlobalLock
        );

    DELETE_LOCK(
        &MupPrefixTableLock
        );

    DELETE_LOCK(
        &MupCcbListLock
        );

#ifdef MUPDBG
    DELETE_LOCK(
        &MupDebugLock
        );
#endif

    ExDeleteResourceLite( &MupVcbLock );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mup\logroot.c ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:       logroot.c
//
//  Contents:   This module implements the logical root handling functions.
//
//  Functions:  DfsInitializeLogicalRoot -
//              DfsDeleteLogicalRoot -
//              DfspLogRootNameToPath -
//
//  History:    14-June-1994    SudK    Created (Most stuff moved from Dsinit.c)
//
//-----------------------------------------------------------------------------


#include "dfsprocs.h"
#include "creds.h"
#include "dnr.h"
#include "fcbsup.h"

#include <stdio.h>

#define Dbg     DEBUG_TRACE_LOGROOT

NTSTATUS
DfsDefineDosDevice(
    IN WCHAR Device,
    IN PUNICODE_STRING Target);

NTSTATUS
DfsUndefineDosDevice(
    IN WCHAR Device);

#ifdef ALLOC_PRAGMA

#pragma alloc_text( PAGE, DfsFindLogicalRoot )
#pragma alloc_text( PAGE, DfsInitializeLogicalRoot )
#pragma alloc_text( PAGE, DfsDeleteLogicalRoot )
#pragma alloc_text( PAGE, DfspLogRootNameToPath )
#pragma alloc_text( PAGE, DfsGetResourceFromVcb )
#pragma alloc_text( PAGE, DfsGetResourceFromDevlessRoot )
#pragma alloc_text( PAGE, DfsLogicalRootExists )

#endif

#ifdef TERMSRV

//
// Maximum character string length of a session Id (decimal)
//

#define SESSIONID_MAX_LEN 10

//
// Maximum characters string length of a session ID [10] (decimal) or
// logon ID [16] (hex, base 16)
//
#define ID_MAX_LEN 16

#endif // TERMSRV

//
// Global that denotes whether LUID device maps are enabled
//  TRUE  - LUID device maps are enabled
//  FALSE - LUID device maps are not enabled
//      Defined in nt\base\fs\mup\dfsinit.c
//
extern BOOL DfsLUIDDeviceMapsEnabled;


//+-------------------------------------------------------------------------
//
//  Function:   DfsFindLogicalRoot, local
//
//  Synopsis:   DfsFindLogicalRoot takes as input a DS path name in
//              the standard form (root:\file\path\name), looks up
//              the DFS_VCB associated with the logical root, and returns
//              a string pointing to beyond the logical root part
//              of the input string.
//
//  Arguments:  [PrefixPath] -- Input path name
//              [Vcb] -- Returns DFS_VCB which corresponds to logical root
//                      in PrefixPath
//              [RemainingPath] -- Returns with portion of PrefixPath
//                      after the logical root name and colon
//
//  Returns:    NTSTATUS:
//                      STATUS_SUCCESS if Vcb found
//                      STATUS_OBJECT_PATH_SYNTAX_BAD - no logical root name
//                      STATUS_NO_SUCH_DEVICE - logical root name not found
//
//--------------------------------------------------------------------------


#ifdef TERMSRV

NTSTATUS
DfsFindLogicalRoot(
    IN PUNICODE_STRING PrefixPath,
    IN ULONG SessionID,
    IN PLUID LogonID,
    OUT PDFS_VCB *Vcb,
    OUT PUNICODE_STRING RemainingPath
    )

#else // TERMSRV

NTSTATUS
DfsFindLogicalRoot(
    IN PUNICODE_STRING PrefixPath,
    IN PLUID LogonID,
    OUT PDFS_VCB *Vcb,
    OUT PUNICODE_STRING RemainingPath
    )

#endif // TERMSRV
{
    PLIST_ENTRY Link;
    unsigned int i;
    NTSTATUS    Status = STATUS_SUCCESS;
    NETRESOURCE testnt;

    DfsDbgTrace(+1, Dbg, "DfsFindLogicalRoot...\n", 0);

    *RemainingPath = *PrefixPath;

    for (i = 0; i < RemainingPath->Length/sizeof(WCHAR); i++) {
        if ((RemainingPath->Buffer[i] == (WCHAR)':') ||
            (RemainingPath->Buffer[i] == UNICODE_PATH_SEP))
            break;
    }

    if ((i*sizeof(WCHAR) >= RemainingPath->Length) ||
        (RemainingPath->Buffer[i] == UNICODE_PATH_SEP)) {
        Status = STATUS_OBJECT_PATH_SYNTAX_BAD;
        DfsDbgTrace(-1, Dbg, "DfsFindLogicalRoot -> %08lx\n", ULongToPtr(Status) );
        return(Status);
    }

    RemainingPath->Length = (USHORT)(i * sizeof (WCHAR));

    //
    // Search for the logical root in all known DFS_VCBs
    //

    ExAcquireResourceSharedLite(&DfsData.Resource, TRUE);
    for ( Link = DfsData.VcbQueue.Flink;
          Link != &DfsData.VcbQueue;
          Link = Link->Flink ) {

        *Vcb = CONTAINING_RECORD( Link, DFS_VCB, VcbLinks );

#ifdef TERMSRV
        if ((SessionID == INVALID_SESSIONID) ||
            (SessionID == (*Vcb)->SessionID)) {
#endif
	    if ( RtlEqualLuid(LogonID, &(*Vcb)->LogonID) ) {
		if (RtlEqualString( (PSTRING)&(*Vcb)->LogicalRoot,
				   (PSTRING)RemainingPath, (BOOLEAN)TRUE) ) {
		    break;
		}
	    }
#ifdef TERMSRV
        }
#endif // TERMSRV
    }
    if (Link == &DfsData.VcbQueue) {
        Status = STATUS_NO_SUCH_DEVICE;
        ExReleaseResourceLite(&DfsData.Resource);
        DfsDbgTrace(-1, Dbg, "DfsFindLogicalRoot -> %08lx\n", ULongToPtr(Status) );
        return(Status);
    }

    //
    // Adjust remaining path to point beyond the logical root name
    //

    RemainingPath->Buffer = (WCHAR*)((char*) (RemainingPath->Buffer) +
                                     RemainingPath->Length + sizeof (WCHAR) );
    RemainingPath->Length = PrefixPath->Length -
                                    (RemainingPath->Length + sizeof (WCHAR));

    if (RemainingPath->Length <= 0 ||
        RemainingPath->Buffer[0] != UNICODE_PATH_SEP) {
        Status = STATUS_OBJECT_PATH_SYNTAX_BAD;
        ExReleaseResourceLite(&DfsData.Resource);
        DfsDbgTrace(-1, Dbg, "DfsFindLogicalRoot -> %08lx\n", ULongToPtr(Status) );
        return(Status);
    }

    ExReleaseResourceLite(&DfsData.Resource);
    DfsDbgTrace(-1, Dbg, "DfsFindLogicalRoot -> %08lx\n", ULongToPtr(Status) );
    return(Status);
}

//+-------------------------------------------------------------------------
//
//  Function:   DfsInitializeLogicalRoot, public
//
//  Synopsis:   Allocate and initialize storage for a logical root.
//              This includes creating a device object and DFS_VCB for it.
//
//  Effects:    A logical root device object is created.  A corresponding
//              DFS_VCB is also created and linked into the list of known
//              DFS_VCBs.
//
//  Arguments:  [Name] --   name of logical root.
//              [Prefix] -- Prefix to be prepended to file names opened
//                          via the logical root being created before
//                          they can be resolved in the DFS name space.
//              [Credentials] -- The credentials to use when accessing files
//                          via this logical root.
//              [VcbFlags] -- To be OR'd into the VcbState field of the
//                          DFS_VCB of the newly created logical root device.
//
//  Requires:   DfsData must first be set up. Also an EXCLUSIVE LOCK on
//              DfsData.Resource must be acquired.
//
//  Returns:    NTSTATUS - STATUS_SUCCESS unless there is some problem.
//
//  History:    25 Jan 1992 alanw   created
//
//--------------------------------------------------------------------------

#ifdef TERMSRV

NTSTATUS
DfsInitializeLogicalRoot(
    IN LPCWSTR Name,
    IN PUNICODE_STRING  Prefix OPTIONAL,
    IN PDFS_CREDENTIALS Credentials OPTIONAL,
    IN USHORT VcbFlags,
    IN ULONG SessionID,
    IN PLUID LogonID
    )

#else // TERMSRV

NTSTATUS
DfsInitializeLogicalRoot(
    IN LPCWSTR        Name,
    IN PUNICODE_STRING  Prefix OPTIONAL,
    IN PDFS_CREDENTIALS Credentials OPTIONAL,
    IN USHORT       VcbFlags,
    IN PLUID LogonID
    )


#endif // TERMSRV
{
    UNICODE_STRING UnicodeString = DfsData.LogRootDevName;
    UNICODE_STRING LogRootPrefix;
    UNICODE_STRING RootName, RemainingPath;
    UNICODE_STRING LogicalRoot;

#ifdef TERMSRV

    //
    // The SessionID suffix is :SessionID where SessionID is 10 digits max.
    //

    UNICODE_STRING DeviceString;
    WCHAR DeviceBuffer[MAX_LOGICAL_ROOT_LEN + ID_MAX_LEN + sizeof(WCHAR)];
    UNICODE_STRING IDString;
    WCHAR IDBuffer[ID_MAX_LEN + 1];   // +1 for UNICODE_NULL

#endif // TERMSRV

    WCHAR          *TmpBuf;
    PDFS_VCB       Vcb;
    WCHAR          RootBuffer[MAX_LOGICAL_ROOT_LEN];
    PDFS_PKT_ENTRY pktEntry = NULL;

    LPCWSTR pstr = Name;
    PWSTR pdst;
    PLOGICAL_ROOT_DEVICE_OBJECT DeviceObject = NULL;
    NTSTATUS Status;

    DfsDbgTrace(0, Dbg, "DfsInitializeLogicalRoot -> %ws\n", Name);
    DfsDbgTrace(0, Dbg, "DfsInitializeLogicalRoot -> %wZ\n", Prefix);

    //
    // First, see if a logical root by the given name already exists
    //

    ASSERT(ARGUMENT_PRESENT(Name));
    RootName.Buffer = RootBuffer;
    RootName.MaximumLength = sizeof(RootBuffer);
    Status = DfspLogRootNameToPath(Name, &RootName);
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

#ifdef TERMSRV
    Status = DfsFindLogicalRoot(&RootName, SessionID, LogonID, &Vcb, &RemainingPath);
#else
    Status = DfsFindLogicalRoot(&RootName, &Vcb, LogonID, &RemainingPath);
#endif

    ASSERT(Status != STATUS_OBJECT_PATH_SYNTAX_BAD);
    if (Status != STATUS_NO_SUCH_DEVICE) {
        return(STATUS_OBJECT_NAME_COLLISION);
    }

#ifdef TERMSRV

    //
    // For multiuser,
    // If LUID device maps are enabled,
    // then we add the LogonID to the devicename - e.g.
    // net use f: to a DFS share for logon ID 0x000000000003a3f0 will create
    // a symbolic link with the following format:
    // \??\f: -> \Device\WinDfs\f:000000000003a3f0
    //
    // If LUID device maps are not enabled,
    // then we add the SessionID to the devicename - e.g.
    // net use f: to a DFS share for session ID 3 will create a symbolic link
    // \DosDevices\f::3 -> \device\WinDfs\f:3
    // In the VCB we store the SessionID for matching purposes.
    // Both the symbolic link and the object name shall contain the SessionID
    // in the name. However, in deviceObject->Vcb.LogicalRoot.Buffer, the
    // name does not contain the SessionID. To find a matching VCB, both the name
    // and SessionID must match.
    //

    DeviceString.Buffer = DeviceBuffer;
    DeviceString.MaximumLength = sizeof(DeviceBuffer);
    DeviceString.Length = 0;

    //
    // Build the UnicodeString without the SessionID or LogonID
    //

    RtlAppendUnicodeToString(&UnicodeString, (LPWSTR)Name);


    if( SessionID != INVALID_SESSIONID) {

        if( (DfsLUIDDeviceMapsEnabled == TRUE) &&
            (LogonID != NULL) &&
            (sizeof(*LogonID) == sizeof(LUID)) ) {
            //
            // Build the DeviceString with the LogonID
            //
            _snwprintf( IDBuffer,
                        sizeof(IDBuffer)/sizeof(WCHAR),
                        L"%08x%08x",
                        LogonID->HighPart,
                        LogonID->LowPart );

            RtlInitUnicodeString( &IDString, IDBuffer );
        }
        else {
            //
            // Build the DeviceString with the SessionID
            //
            IDString.Buffer = IDBuffer;
            IDString.MaximumLength = sizeof(IDBuffer);
            IDString.Length = 0;

            RtlIntegerToUnicodeString(SessionID, 10, &IDString);
        }
        
        RtlCopyUnicodeString(&DeviceString, &DfsData.LogRootDevName);
        RtlAppendUnicodeToString(&DeviceString, (LPWSTR)Name);
        RtlAppendUnicodeToString(&DeviceString,L":");
        RtlAppendUnicodeStringToString(&DeviceString, &IDString);
        DeviceString.MaximumLength = DeviceString.Length;

        //
        // Next, try to setup the Dos Device link
        //

        if (Prefix) {
            Status = DfsDefineDosDevice( Name[0], &DeviceString );
            if (!NT_SUCCESS(Status)) {
                return( Status );
            }
        }
    }
    else {

        ASSERT( Prefix == FALSE );
    }

#else // TERMSRV

    //
    // DfsData.LogRootDevName is initialized to be L"\Device\WinDfs\"
    // Here, we tack on the name of the Logical root we are creating
    // to the above string, so that the string becomes, for example,
    // L"\Device\WinDfs\Root". Note that at this point, we are scribbling
    // into the buffer belonging to DfsData.LogRootDevName, but this
    // should be ok, since we are not changing the Length field of that
    // Unicode string! BTW, we need a string of this form to create the
    // device object.
    //

    pdst = &UnicodeString.Buffer[UnicodeString.Length/sizeof (WCHAR)];
    while (*pstr != UNICODE_NULL) {
        *pdst++ = *pstr++;
        UnicodeString.Length += sizeof (WCHAR);
    }

    //
    // Next, try to setup the Dos Device link
    //
    if (Prefix) {
        Status = DfsDefineDosDevice( Name[0], &UnicodeString );
        if (!NT_SUCCESS(Status)) {
            return( Status );
        }
    }

#endif // TERMSRV

    //
    // Before we initialize the Vcb, we need to allocate space for the
    // Prefix. PagedPool should be fine here. We need to reallocate because
    // we will store this permanently in the DFS_VCB.
    //

    LogRootPrefix.Buffer = NULL;

    if (Prefix && Prefix->Length > 0) {
        LogRootPrefix.Length = Prefix->Length;
        LogRootPrefix.MaximumLength = LogRootPrefix.Length + sizeof(WCHAR);
        LogRootPrefix.Buffer = ExAllocatePoolWithTag(
                                    PagedPool,
                                    LogRootPrefix.MaximumLength,
                                    ' puM');

        if (LogRootPrefix.Buffer != NULL) {
            RtlMoveMemory(LogRootPrefix.Buffer,
                          Prefix->Buffer,
                          Prefix->MaximumLength);

            LogRootPrefix.Buffer[Prefix->Length/sizeof(WCHAR)] = UNICODE_NULL;

        } else {

            //
            // Couldn't allocate memory! Ok to return with error code, since
            // we haven't changed the state of the IO subsystem yet.
            //

            if (Prefix) {
                NTSTATUS DeleteStatus;

                DeleteStatus = DfsUndefineDosDevice( Name[0] );

                ASSERT(NT_SUCCESS(DeleteStatus));
            }

            return(STATUS_INSUFFICIENT_RESOURCES);
        }
    } else {
        RtlInitUnicodeString(&LogRootPrefix, NULL);
    }

    //
    //  Save the logical root name for the DFS_VCB structure. Remember, above
    //  we had UnicodeString to be of the form L"\Device\WinDfs\org". Now,
    //  we copy UnicodeString, then adjust the buffer and length fields so that
    //  the Buffer points to the beginning of the L"org"; Then, we allocate
    //  space for LogicalRootBuffer, and copy the name to it!
    //

    LogicalRoot = UnicodeString;

    LogicalRoot.Buffer = &LogicalRoot.Buffer[ DfsData.LogRootDevName.Length/sizeof (WCHAR) ];
    LogicalRoot.Length -= DfsData.LogRootDevName.Length;
    LogicalRoot.MaximumLength -= DfsData.LogRootDevName.Length;

    //
    // Now dup the buffer that LogicalRoot uses
    //

    TmpBuf = ExAllocatePoolWithTag( PagedPool,
                                    LogicalRoot.Length,
                                    ' puM');

    if (TmpBuf == NULL) {

        //
        // Couldn't allocate memory! Ok to return with error code, since
        // we still haven't changed the state of the IO subsystem yet.
        //

        if (LogRootPrefix.Buffer != NULL) {

            ExFreePool(LogRootPrefix.Buffer);

        }

        if (Prefix) {
            NTSTATUS DeleteStatus;

            DeleteStatus = DfsUndefineDosDevice( Name[0] );

            ASSERT(NT_SUCCESS(DeleteStatus));
        }

        return(STATUS_INSUFFICIENT_RESOURCES);

    } else {

        RtlMoveMemory( TmpBuf,
                       LogicalRoot.Buffer,
                       LogicalRoot.Length );

        LogicalRoot.Buffer = TmpBuf;

    }

    //
    //  Create the device object for the logical root.
    //

#ifdef TERMSRV

    Status = IoCreateDevice( DfsData.DriverObject,
                 sizeof( LOGICAL_ROOT_DEVICE_OBJECT ) -
                    sizeof( DEVICE_OBJECT ),
                 (SessionID != INVALID_SESSIONID) ?
                    &DeviceString : &UnicodeString,
                 FILE_DEVICE_DFS,
                 FILE_REMOTE_DEVICE,
                 FALSE,
                 (PDEVICE_OBJECT *) &DeviceObject );

#else // TERMSRV

    Status = IoCreateDevice( DfsData.DriverObject,
                 sizeof( LOGICAL_ROOT_DEVICE_OBJECT ) -
                 sizeof( DEVICE_OBJECT ),
                 &UnicodeString,
                 FILE_DEVICE_DFS,
                 FILE_REMOTE_DEVICE,
                 FALSE,
                 (PDEVICE_OBJECT *) &DeviceObject );

#endif // TERMSRV

    if ( !NT_SUCCESS( Status ) ) {
        if (LogRootPrefix.Buffer) {
            ExFreePool(LogRootPrefix.Buffer);
            ExFreePool(LogicalRoot.Buffer);
        }
        if (Prefix) {
            NTSTATUS DeleteStatus;

            DeleteStatus = DfsUndefineDosDevice( Name[0] );

            ASSERT(NT_SUCCESS(DeleteStatus));
        }
        return Status;
    }

    //
    // Pin the pkt entry in the cache by incrementing the Usecount
    //

    if (LogRootPrefix.Buffer != NULL && LogRootPrefix.Length > 0) {

        UNICODE_STRING prefix = LogRootPrefix;
        USHORT i, j;

        //
        // We want to work with the \server\share part of the prefix only,
        // so count up to 3 backslashes, then stop.
        //

        for (i = j = 0; i < prefix.Length/sizeof(WCHAR) && j < 3; i++) {

            if (prefix.Buffer[i] == UNICODE_PATH_SEP) {

                j++;

            }

        }

        prefix.Length = (j >= 3) ? (i-1) * sizeof(WCHAR) : i * sizeof(WCHAR);

        pktEntry = PktLookupEntryByPrefix(&DfsData.Pkt,
                                            &prefix,
                                            &RemainingPath);

        if (pktEntry != NULL && RemainingPath.Length == 0) {

            InterlockedIncrement(&pktEntry->UseCount);

        }
	else {
	  pktEntry = NULL;
	}
    }

    DeviceObject->DeviceObject.StackSize = 5;

    DfsInitializeVcb ( NULL,
               &DeviceObject->Vcb,
               &LogRootPrefix,
               Credentials,
               (PDEVICE_OBJECT)DeviceObject );

    DeviceObject->Vcb.VcbState |= VcbFlags;

#ifdef TERMSRV
    DeviceObject->Vcb.SessionID = SessionID;
#endif
    DeviceObject->Vcb.pktEntry = pktEntry;

    RtlCopyLuid(&DeviceObject->Vcb.LogonID, LogonID);

    //
    // Above we preallocated the buffer we need here.  So just use it.
    //

    DeviceObject->Vcb.LogicalRoot = LogicalRoot;

    //
    //  This is not documented anywhere, but calling IoCreateDevice has set
    //  the DO_DEVICE_INITIALIZING flag in DeviceObject->Flags. Normally,
    //  device objects are created only at driver init time, and IoLoadDriver
    //  will clear this bit for all device objects created at init time.
    //  Since in Dfs, we need to create and delete devices on the fly (ie,
    //  via FsCtl), we need to manually clear this bit.
    //

    DeviceObject->DeviceObject.Flags &= ~DO_DEVICE_INITIALIZING;

    return STATUS_SUCCESS;
}


//+----------------------------------------------------------------------------
//
//  Function:   DfsDeleteLogicalRoot
//
//  Synopsis:   Removes a logical root if found and possible.
//
//  Arguments:  [Name] -- Name of the Logical Root
//              [fForce] -- Whether to Forcibly delete logical root inspite of
//                          open files.
//
//  Returns:    STATUS_SUCCESS -- If successfully deleted logical root
//
//              STATUS_NO_SUCH_DEVICE -- If there is no logical root to
//                      delete.
//
//              STATUS_DEVICE_BUSY -- If fForce is false and there are open
//                      files via this logical root.
//
//-----------------------------------------------------------------------------

#ifdef TERMSRV

NTSTATUS
DfsDeleteLogicalRoot(
    IN PWSTR Name,
    IN BOOLEAN fForce,
    IN ULONG SessionID,
    IN PLUID LogonID
)

#else // TERMSRV

NTSTATUS
DfsDeleteLogicalRoot(
    IN PWSTR Name,
    IN BOOLEAN fForce,
    IN PLUID LogonID
)

#endif // TERMSRV
{
    UNICODE_STRING RootName;
    UNICODE_STRING RemainingPath;
    WCHAR          RootBuffer[MAX_LOGICAL_ROOT_LEN + 2];
    PDFS_PKT_ENTRY PktEntry;
    PDFS_VCB       Vcb;
    NTSTATUS       Status;
    PLOGICAL_ROOT_DEVICE_OBJECT DeviceObject;
    BOOLEAN        pktLocked;
    PDFS_PKT_ENTRY pktEntry;

    //
    // The 2 extra spots are for holding :\ to form a path out of a
    // root name; ie, to go from root to a root:\ form.
    //
    DfsDbgTrace(0, Dbg, "DfsDeleteLogicalRoot -> %ws\n", Name);
    DfsDbgTrace(0, Dbg, "DfsDeleteLogicalRoot -> %s\n", fForce ? "TRUE":"FALSE");


    //
    // First see if the logical root even exists.
    //

    ASSERT(ARGUMENT_PRESENT(Name));

    RootName.Buffer = RootBuffer;
    RootName.MaximumLength = sizeof(RootBuffer);

    Status = DfspLogRootNameToPath(Name, &RootName);

    if (!NT_SUCCESS(Status))
        return(Status);

    //
    // Acquire Pkt and DfsData, wait till we do so.
    //

    PktAcquireExclusive(TRUE, &pktLocked);

    ExAcquireResourceExclusiveLite(&DfsData.Resource, TRUE);

#ifdef TERMSRV
    Status = DfsFindLogicalRoot(&RootName, SessionID, LogonID, &Vcb, &RemainingPath);
#else // TERMSRV
    Status = DfsFindLogicalRoot(&RootName, LogonID, &Vcb, &RemainingPath);
#endif // TERMSRV

    if (!NT_SUCCESS(Status)) {

        goto Cleanup;
    }

    //
    // Check to see if there are open files via this volume.
    //

    if (!fForce &&
            ((Vcb->DirectAccessOpenCount != 0) ||
                (Vcb->OpenFileCount != 0))) {

        Status = STATUS_DEVICE_BUSY;

        goto Cleanup;

    }

    //
    // Delete the credentials used by this connection
    //

    if (Vcb->Credentials != NULL) {
       DfsDeleteCredentials( Vcb->Credentials );
    }

    //
    // Get rid of the Dos Device
    //

    DfsUndefineDosDevice( Name[0] );

    //
    // Dec ref count on pkt entry
    //
    if (Vcb->pktEntry != NULL) {
      InterlockedDecrement(&Vcb->pktEntry->UseCount);

      Vcb->pktEntry = NULL;
    }

    //
    // Now, get rid of the Device itself. This is a bit tricky, because there
    // might be files open on this device. So, we reference the device and
    // call ObMakeTemporaryObject. This causes the object to be removed from
    // the NT Object table, but, since atleast our reference is active,
    // prevents the object from being freed. Then, we insert this object into
    // our DeletedVcb list. The timer routine will periodically wake up and
    // see if all references to this device have been released, at which
    // point the device will be finally freed.
    //

    RemoveEntryList(&Vcb->VcbLinks);

    InsertTailList( &DfsData.DeletedVcbQueue, &Vcb->VcbLinks );

    DeviceObject = CONTAINING_RECORD( Vcb, LOGICAL_ROOT_DEVICE_OBJECT, Vcb);

    ObReferenceObjectByPointer( DeviceObject, 0, NULL, KernelMode );

    ObMakeTemporaryObject((PVOID) DeviceObject);

    DeviceObject->DeviceObject.Flags &= ~DO_DEVICE_HAS_NAME;

Cleanup:

    ExReleaseResourceLite(&DfsData.Resource);

    PktRelease();

    return(Status);
}


//+----------------------------------------------------------------------------
//
//  Function:   DfspLogRootNameToPath
//
//  Synopsis:   Amazingly enough, all it does it takes a PWSTR, copies it into
//              a Unicode string's buffer, and appends a \ to the tail of the
//              buffer, thus making a path out of a Logical root name.
//
//  Arguments:  [Name] --   Name of logical root, like L"org"
//              [RootName] --   Destination for L"org\\"
//
//  Returns:    STATUS_BUFFER_OVERFLOW, STATUS_SUCCESS
//
//-----------------------------------------------------------------------------

NTSTATUS
DfspLogRootNameToPath(
    IN  LPCWSTR Name,
    OUT PUNICODE_STRING RootName
)
{
    unsigned short i, nMaxNameLen;

    //
    // The two extra spots are required to append a ":\" after the root name.
    //
    nMaxNameLen = (RootName->MaximumLength/sizeof(WCHAR)) - 2;

    //
    // Copy the name
    //
    for (i = 0; Name[i] != UNICODE_NULL && i < nMaxNameLen; i++) {
        RootName->Buffer[i] = Name[i];
    }

    //
    // Make sure entire name was copied before we ran out of space
    //
    if (Name[i] != UNICODE_NULL) {
        //
        // Someone sent in a name bigger than allowed.
        //
        return(STATUS_BUFFER_OVERFLOW);
    }

    //
    // Append the ":\" to form a path
    //
    RootName->Length = i * sizeof(WCHAR);
    return(RtlAppendUnicodeToString(RootName, L":\\"));
}

#define PackMem(buf, str, len, pulen) {                                 \
        ASSERT(*(pulen) >= (len));                                      \
        RtlMoveMemory((buf) + *(pulen) - (len), (str), (len));          \
        *(pulen) -= (len);                                              \
        }


//+----------------------------------------------------------------------------
//
//  Function:   DfsGetResourceFromVcb
//
//  Synopsis:   Given a DFS_VCB it constructs a NETRESOURCE struct into the buffer
//              passed in. At the same time it uses the end of the buffer to
//              fill in a string. If the buffer is insufficient in size the
//              required size is returned in "pulen". If everything succeeds
//              then the pulen arg is decremented to indicate remaining size
//              of buffer.
//
//  Arguments:  [Vcb] -- The source DFS_VCB
//              [ProviderName] -- Provider Name to stuff in the NETRESOURCE
//              [BufBegin] -- Start of actual buffer for computing offsets
//              [Buf] -- The NETRESOURCE structure to fill
//              [BufSize] -- On entry, size of buf. On return, contains
//                      remaining size of buf.
//
//  Returns:    [STATUS_SUCCESS] -- Operation completed successfully.
//              [STATUS_BUFFER_OVERFLOW] -- buf is not big enough.
//
//  Notes:      This routine fills in a NETRESOURCE structure starting at
//              Buf. The strings in the NETRESOURCE are filled in starting
//              from the *end* (ie, starting at Buf + *BufSize)
//
//-----------------------------------------------------------------------------


#if defined (_WIN64)
typedef struct  _DFS_NETRESOURCE32 {
    DWORD    dwScope;
    DWORD    dwType;
    DWORD    dwDisplayType;
    DWORD    dwUsage;
    ULONG    lpLocalName;
    ULONG    lpRemoteName;
    ULONG    lpComment ;
    ULONG    lpProvider;
}DFS_NETRESOURCE32, *PDFS_NETRESOURCE32;

#endif

NTSTATUS
DfsGetResourceFromVcb(
    PIRP        pIrp,
    PDFS_VCB    Vcb,
    PUNICODE_STRING ProviderName,
    PUCHAR      BufBegin,
    PUCHAR      Buf,
    PULONG      BufSize,
    PULONG      pResourceSize

)
{
    LPNETRESOURCE netResource = (LPNETRESOURCE) Buf;
    ULONG               sizeRequired = 0, ResourceSize;
    WCHAR               localDrive[ 3 ];
    ULONG32    CommentOffset, ProviderOffset, LocalNameOffset, RemoteNameOffset;

#if defined (_WIN64)
    if (IoIs32bitProcess(pIrp)) {
      ResourceSize = sizeof(DFS_NETRESOURCE32);
    }
    else
#endif
    ResourceSize = sizeof(NETRESOURCE);

    *pResourceSize = ResourceSize;

    sizeRequired = ResourceSize +
                    ProviderName->Length +
                        sizeof(UNICODE_NULL) +
                            3 * sizeof(WCHAR) +     // lpLocalName D: etc.
                                sizeof(UNICODE_PATH_SEP) +
                                    Vcb->LogRootPrefix.Length +
                                        sizeof(UNICODE_NULL);

    if (*BufSize < sizeRequired) {
        *BufSize = sizeRequired;
        return(STATUS_BUFFER_OVERFLOW);
    }

    //
    // Buffer is big enough, fill in the NETRESOURCE structure
    //

    Buf += ResourceSize;
    *BufSize -= ResourceSize;

    netResource->dwScope       = RESOURCE_CONNECTED;
    netResource->dwType        = RESOURCETYPE_DISK;
    netResource->dwDisplayType = RESOURCEDISPLAYTYPE_GENERIC;
    netResource->dwUsage       = RESOURCEUSAGE_CONNECTABLE;

    CommentOffset = 0;
    //
    // Fill in the provider name
    //

    PackMem(Buf, L"", sizeof(L""), BufSize);
    PackMem(Buf, ProviderName->Buffer, ProviderName->Length, BufSize);
    ProviderOffset = (ULONG32)(Buf + *BufSize - BufBegin);

    //
    // Fill in the local name next
    //

    localDrive[0] = Vcb->LogicalRoot.Buffer[0];
    localDrive[1] = UNICODE_DRIVE_SEP;
    localDrive[2] = UNICODE_NULL;

    PackMem(Buf, localDrive, sizeof(localDrive), BufSize);
    LocalNameOffset =  (ULONG32)(Buf + *BufSize - BufBegin);

    //
    // Fill in the remote name last
    //

    PackMem(Buf, L"", sizeof(L""), BufSize);
    PackMem(Buf, Vcb->LogRootPrefix.Buffer, Vcb->LogRootPrefix.Length, BufSize);
    PackMem(Buf, UNICODE_PATH_SEP_STR, sizeof(UNICODE_PATH_SEP), BufSize);
    RemoteNameOffset = (ULONG32)(Buf + *BufSize - BufBegin);

#if defined (_WIN64)
    if (IoIs32bitProcess(pIrp)) {
      PDFS_NETRESOURCE32 pNetResource32 = (PDFS_NETRESOURCE32)netResource;

      pNetResource32->lpComment = CommentOffset;
      pNetResource32->lpProvider = ProviderOffset;
      pNetResource32->lpLocalName = LocalNameOffset;
      pNetResource32->lpRemoteName = RemoteNameOffset;
    }
    else {
#endif

      netResource->lpComment = (LPWSTR)UIntToPtr( CommentOffset );
      netResource->lpProvider = (LPWSTR)UIntToPtr( ProviderOffset );
      netResource->lpLocalName = (LPWSTR)UIntToPtr( LocalNameOffset );
      netResource->lpRemoteName = (LPWSTR)UIntToPtr( RemoteNameOffset );
#if defined (_WIN64)
    }
#endif

    return(STATUS_SUCCESS);
}

//+----------------------------------------------------------------------------
//
//  Function:   DfsGetResourceFromDevlessRoot
//
//  Synopsis:   Builds a NETRESOURCE structure for a device-less connection.
//              The LPWSTR members of NETRESOURCE actually contain offsets
//              from the BufBegin parameter.
//
//  Arguments:  [Drt] -- The DevicelessRoot structure
//              [ProviderName] -- Provider Name to stuff in the NETRESOURCE
//              [BufBegin] -- Start of actual buffer for computing offsets
//              [Buf] -- The NETRESOURCE structure to fill
//              [BufSize] -- On entry, size of buf. On return, contains
//                      remaining size of buf.
//
//  Returns:    [STATUS_SUCCESS] -- Operation completed successfully.
//              [STATUS_BUFFER_OVERFLOW] -- buf is not big enough.
//
//  Notes:      This routine fills in a NETRESOURCE structure starting at
//              Buf. The strings in the NETRESOURCE are filled in starting
//              from the *end* (ie, starting at Buf + *BufSize)
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsGetResourceFromDevlessRoot(
    PIRP        pIrp,
    PDFS_DEVLESS_ROOT pDrt,
    PUNICODE_STRING ProviderName,
    PUCHAR BufBegin,
    PUCHAR Buf,
    PULONG BufSize,
    PULONG pResourceSize)
{
    LPNETRESOURCE netResource = (LPNETRESOURCE) Buf;
    ULONG               sizeRequired = 0, ResourceSize;
    WCHAR               localDrive[ 3 ];
    ULONG32    CommentOffset, ProviderOffset, LocalNameOffset, RemoteNameOffset;
#if defined (_WIN64)
    if (IoIs32bitProcess(pIrp)) {
      ResourceSize = sizeof(DFS_NETRESOURCE32);
    }
    else
#endif
    ResourceSize = sizeof(NETRESOURCE);

    *pResourceSize = ResourceSize;

    sizeRequired = ResourceSize +
                    ProviderName->Length +
                        sizeof(UNICODE_NULL) +
                            2 * sizeof(UNICODE_PATH_SEP) +
				pDrt->DevlessPath.Length +
                                     sizeof(UNICODE_NULL);

    if (*BufSize < sizeRequired) {
        *BufSize = sizeRequired;
        return(STATUS_BUFFER_OVERFLOW);
    }

    //
    // Buffer is big enough, fill in the NETRESOURCE structure
    //

    Buf += ResourceSize;
    *BufSize -= ResourceSize;

    netResource->dwScope       = RESOURCE_CONNECTED;
    netResource->dwType        = RESOURCETYPE_DISK;
    netResource->dwDisplayType = RESOURCEDISPLAYTYPE_GENERIC;
    netResource->dwUsage       = RESOURCEUSAGE_CONNECTABLE;

    CommentOffset = 0;
    LocalNameOffset = 0;

    //
    // Fill in the provider name
    //

    PackMem(Buf, L"", sizeof(L""), BufSize);
    PackMem(Buf, ProviderName->Buffer, ProviderName->Length, BufSize);
    ProviderOffset = (ULONG32)(Buf + *BufSize - BufBegin);

    //
    // Fill in the remote name last
    //

    PackMem(Buf, L"", sizeof(L""), BufSize);
    PackMem(Buf, pDrt->DevlessPath.Buffer, pDrt->DevlessPath.Length, BufSize);

    PackMem(Buf, UNICODE_PATH_SEP_STR, sizeof(UNICODE_PATH_SEP), BufSize);

    RemoteNameOffset = (ULONG32)(Buf + *BufSize - BufBegin);

#if defined (_WIN64)
    if (IoIs32bitProcess(pIrp)) {
      PDFS_NETRESOURCE32 pNetResource32 = (PDFS_NETRESOURCE32)netResource;

      pNetResource32->lpComment = CommentOffset;
      pNetResource32->lpProvider = ProviderOffset;
      pNetResource32->lpLocalName = LocalNameOffset;
      pNetResource32->lpRemoteName = RemoteNameOffset;
    }
    else {
#endif

      netResource->lpComment = (LPWSTR)UIntToPtr( CommentOffset );
      netResource->lpProvider = (LPWSTR)UIntToPtr( ProviderOffset );
      netResource->lpLocalName = (LPWSTR)UIntToPtr( LocalNameOffset );
      netResource->lpRemoteName = (LPWSTR)UIntToPtr( RemoteNameOffset );
#if defined (_WIN64)
    }
#endif

    return(STATUS_SUCCESS);


}


#ifdef TERMSRV

BOOLEAN
DfsLogicalRootExists(
    IN PWSTR pwszName,
    IN ULONG SessionID,
    IN PLUID LogonID
    )

#else // TERMSRV

BOOLEAN
DfsLogicalRootExists(
    IN PWSTR pwszName,
    IN PLUID LogonID
    )

#endif // TERMSRV
{

    UNICODE_STRING RootName;
    UNICODE_STRING RemainingPath;
    WCHAR      RootBuffer[MAX_LOGICAL_ROOT_LEN + 2];
    PDFS_VCB       Vcb;
    NTSTATUS       Status;

    ASSERT(ARGUMENT_PRESENT(pwszName));
    RootName.Buffer = RootBuffer;
    RootName.MaximumLength = sizeof(RootBuffer);

    Status = DfspLogRootNameToPath(pwszName, &RootName);
    if (!NT_SUCCESS(Status)) {
        return(FALSE);
    }

#ifdef TERMSRV
    Status = DfsFindLogicalRoot(&RootName, SessionID, LogonID, &Vcb, &RemainingPath);
#else // TERMSRV
    Status = DfsFindLogicalRoot(&RootName, LogonId, &Vcb, &RemainingPath);
#endif // TERMSRV

    if (!NT_SUCCESS(Status)) {

        //
        // If this asserts, we need to fix the code above that creates the
        // Logical Root name, or fix DfsFindLogicalRoot.
        //
        ASSERT(Status != STATUS_OBJECT_PATH_SYNTAX_BAD);
        return(FALSE);
    }
    else        {
        return(TRUE);
    }

}

//+----------------------------------------------------------------------------
//
//  Function:   DfsDefineDosDevice
//
//  Synopsis:   Creates a dos device to a logical root
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsDefineDosDevice(
    IN WCHAR Device,
    IN PUNICODE_STRING Target)
{
    NTSTATUS status;
    HANDLE device;
    OBJECT_ATTRIBUTES ob;
    UNICODE_STRING deviceName;
    WCHAR Buf[25];

    wcscpy(Buf, L"\\??\\X:");
    RtlInitUnicodeString( &deviceName, Buf);
    deviceName.Buffer[ deviceName.Length/sizeof(WCHAR) - 2] = Device;

    InitializeObjectAttributes(
        &ob,
        &deviceName,
        OBJ_CASE_INSENSITIVE | OBJ_PERMANENT,
        NULL,
        NULL);

    status = ZwCreateSymbolicLinkObject(
                    &device,
                    SYMBOLIC_LINK_ALL_ACCESS,
                    &ob,
                    Target);

    if (NT_SUCCESS(status))
        ZwClose( device );

    return( status );

}

//+----------------------------------------------------------------------------
//
//  Function:   DfsUndefineDosDevice
//
//  Synopsis:   Undefines a dos device
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsUndefineDosDevice(
    IN WCHAR Device
    )
{

    NTSTATUS status;
    HANDLE device;
    OBJECT_ATTRIBUTES ob;
    UNICODE_STRING deviceName;
    WCHAR Buf[25];

    wcscpy(Buf, L"\\??\\X:");
    RtlInitUnicodeString( &deviceName, Buf);
    deviceName.Buffer[ deviceName.Length/sizeof(WCHAR) - 2] = Device;

    InitializeObjectAttributes(
        &ob,
        &deviceName,
        OBJ_CASE_INSENSITIVE | OBJ_PERMANENT,
        NULL,
        NULL);

    status = ZwOpenSymbolicLinkObject(
                &device,
                SYMBOLIC_LINK_QUERY | DELETE,
                &ob);

    if (NT_SUCCESS(status)) {

        status = ZwMakeTemporaryObject( device );

        ZwClose( device );

    }

    return( status );

}



//+-------------------------------------------------------------------------
//
//  Function:   DfsFindDevlessRoot, local
//
//  Synopsis:   DfsFindDevlessRoot takes as input a UNC name
//              looks up the DFS_DEVLESS_ROOT associated with the root,
//              and returns the DevlessRoot
//
//  Arguments:  [Path] -- Input path name
//              [Drt] -- Returns DFS_DEVLESS_ROOT which corresponds to
//                       the root for the Path
//
//  Returns:    NTSTATUS:
//                      STATUS_SUCCESS if Drt found
//                      STATUS_NO_SUCH_DEVICE - root name not found
//
//--------------------------------------------------------------------------


#ifdef TERMSRV

NTSTATUS
DfsFindDevlessRoot(
    IN PUNICODE_STRING Path,
    IN ULONG SessionID,
    IN PLUID LogonID,
    OUT PDFS_DEVLESS_ROOT *Drt
    )

#else // TERMSRV

NTSTATUS
DfsFindDevlessRoot(
    IN PUNICODE_STRING Path,
    IN PLUID LogonID,
    OUT PDFS_DEVLESS_ROOT *Drt,
    )

#endif // TERMSRV
{
    PLIST_ENTRY Link;
    NTSTATUS    Status = STATUS_SUCCESS;

    DfsDbgTrace(+1, Dbg, "DfsFindDevlessRoot...%wZ\n", Path);

    //
    // Search for the devless ROOT.
    //

    ExAcquireResourceSharedLite(&DfsData.Resource, TRUE);

    for ( Link = DfsData.DrtQueue.Flink;
          Link != &DfsData.DrtQueue;
          Link = Link->Flink ) {

        *Drt = CONTAINING_RECORD( Link, DFS_DEVLESS_ROOT, DrtLinks );

#ifdef TERMSRV
        if ((SessionID == INVALID_SESSIONID) ||
            (SessionID == (*Drt)->SessionID)) {
#endif
	    if ( RtlEqualLuid(LogonID, &(*Drt)->LogonID) ) {
		if (RtlEqualString( (PSTRING)&(*Drt)->DevlessPath,
				   (PSTRING)Path, (BOOLEAN)TRUE) ) {
		    break;
		}
	    }
#ifdef TERMSRV
        }
#endif // TERMSRV
    }
    if (Link == &DfsData.DrtQueue) {
        Status = STATUS_NO_SUCH_DEVICE;
        ExReleaseResourceLite(&DfsData.Resource);
        DfsDbgTrace(-1, Dbg, "DfsFindDevlessRoot -> %08lx\n", ULongToPtr(Status) );
        return(Status);
    }

    ExReleaseResourceLite(&DfsData.Resource);
    DfsDbgTrace(-1, Dbg, "DfsFindLogicalRoot -> %08lx\n", ULongToPtr(Status) );
    return(Status);
}

//+-------------------------------------------------------------------------
//
//  Function:   DfsInitializeDevlessRoot, public
//
//  Synopsis:   Allocate and initialize storage for a Deviceless root.
//
//  Effects:    A DFS_DEVLESS_ROOT structure is created.
//
//  Arguments:  [Name] -- Pathname that is the deviceless root.
//              [Credentials] -- The credentials to use when accessing files
//                          via this logical root.
//
//  Requires:   DfsData must first be set up. Also an EXCLUSIVE LOCK on
//              DfsData.Resource must be acquired.
//
//  Returns:    NTSTATUS - STATUS_SUCCESS unless there is some problem.
//
//--------------------------------------------------------------------------

#ifdef TERMSRV

NTSTATUS
DfsInitializeDevlessRoot(
    IN PUNICODE_STRING  Name,
    IN PDFS_CREDENTIALS Credentials OPTIONAL,
    IN ULONG SessionID,
    IN PLUID LogonID
    )

#else // TERMSRV

NTSTATUS
DfsInitializeDevlessRoot(
    IN PUNICODE_STRING  Name,
    IN PDFS_CREDENTIALS Credentials OPTIONAL,
    IN PLUID LogonID
    )

#endif // TERMSRV
{

    PDFS_DEVLESS_ROOT Drt;
    PDFS_PKT_ENTRY pktEntry = NULL;
    UNICODE_STRING DevlessRootName;
    NTSTATUS Status;

    DfsDbgTrace(0, Dbg, "DfsInitializeDevlessRoot -> %wZ\n", Name);

#ifdef TERMSRV
    Status = DfsFindDevlessRoot(Name, SessionID, LogonID, &Drt);
#else
    Status = DfsFindDevlessRoot(Name, LogonID, &Drt);
#endif

    if (Status != STATUS_NO_SUCH_DEVICE) {
        //
        // this means we found a device. In the devless Root case, this means 
        // we dont have to do any more work. Just return a success response.
        // However, we still have the credentials which the caller assumes
        // we will be using. Get rid of it here and return success.
        //
        DfsDeleteCredentials(Credentials);
        return(STATUS_SUCCESS);
    }

    Drt = ExAllocatePoolWithTag( PagedPool,
				sizeof(DFS_DEVLESS_ROOT),
				' puM');
    if (Drt == NULL) {
	return(STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // Before we initialize the Drt, we need to allocate space for the
    // Prefix. PagedPool should be fine here. We need to reallocate because
    // we will store this permanently in the DFS_DEVLESS_ROOT.
    //

    DevlessRootName.Length = Name->Length;
    DevlessRootName.MaximumLength = DevlessRootName.Length + sizeof(WCHAR);
    DevlessRootName.Buffer = ExAllocatePoolWithTag(
                                    PagedPool,
                                    DevlessRootName.MaximumLength,
                                    ' puM');

    if (DevlessRootName.Buffer != NULL) {
            RtlMoveMemory(DevlessRootName.Buffer,
                          Name->Buffer,
                          Name->MaximumLength);
	    
            DevlessRootName.Buffer[Name->Length/sizeof(WCHAR)] = UNICODE_NULL;
    } else {
      ExFreePool(Drt);
      return(STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // Pin the pkt entry in the cache by incrementing the Usecount
    //

    if (DevlessRootName.Buffer != NULL && DevlessRootName.Length > 0) {

        UNICODE_STRING prefix = DevlessRootName;
        USHORT i, j;
        UNICODE_STRING RemainingPath;

        //
        // We want to work with the \server\share part of the prefix only,
        // so count up to 3 backslashes, then stop.
        //

        for (i = j = 0; i < prefix.Length/sizeof(WCHAR) && j < 3; i++) {
            if (prefix.Buffer[i] == UNICODE_PATH_SEP) {
                j++;
            }
        }

        prefix.Length = (j >= 3) ? (i-1) * sizeof(WCHAR) : i * sizeof(WCHAR);

        pktEntry = PktLookupEntryByPrefix(&DfsData.Pkt,
                                            &prefix,
                                            &RemainingPath);

        if (pktEntry != NULL && RemainingPath.Length == 0) {

            InterlockedIncrement(&pktEntry->UseCount);

        }
	else {
	  pktEntry = NULL;
	}

    }

    DfsInitializeDrt ( Drt,
		       &DevlessRootName,
		       Credentials);

#ifdef TERMSRV
    Drt->SessionID = SessionID;
#endif
    Drt->pktEntry = pktEntry;
    RtlCopyLuid(&Drt->LogonID, LogonID);

    return STATUS_SUCCESS;
}


//+----------------------------------------------------------------------------
//
//  Function:   DfsDeleteDevlessRoot
//
//  Synopsis:   Removes a Devless root if found and possible.
//
//  Arguments:  [Name] -- Name of the Logical Root
//
//  Returns:    STATUS_SUCCESS -- If successfully deleted logical root
//
//              STATUS_NO_SUCH_DEVICE -- If there is no logical root to
//                      delete.
//
//
//-----------------------------------------------------------------------------

#ifdef TERMSRV

NTSTATUS
DfsDeleteDevlessRoot(
    IN PUNICODE_STRING  Name,
    IN ULONG SessionID,
    IN PLUID LogonID
)

#else // TERMSRV

NTSTATUS
DfsDeleteDevlessRoot(
    IN PUNICODE_STRING  Name,
    IN PLUID LogonID
)

#endif // TERMSRV
{
    PDFS_PKT_ENTRY PktEntry;
    PDFS_DEVLESS_ROOT Drt;
    NTSTATUS       Status;
    BOOLEAN        pktLocked;
    PDFS_PKT_ENTRY pktEntry;

    DfsDbgTrace(0, Dbg, "DfsDeleteDevlessRoot -> %wZ\n", Name);

    //
    // Acquire Pkt and DfsData, wait till we do so.
    //

    PktAcquireExclusive(TRUE, &pktLocked);

    ExAcquireResourceExclusiveLite(&DfsData.Resource, TRUE);

#ifdef TERMSRV
    Status = DfsFindDevlessRoot(Name, SessionID, LogonID, &Drt);
#else // TERMSRV
    Status = DfsFindDevlessRoot(Name, LogonID, &Drt);
#endif // TERMSRV

    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    //
    // Delete the credentials used by this connection
    //

    DfsDeleteCredentials( Drt->Credentials );

    if (Drt->pktEntry != NULL) {
         InterlockedDecrement(&Drt->pktEntry->UseCount);
 
	 Drt->pktEntry = NULL;
    }

    RemoveEntryList(&Drt->DrtLinks);

    if (Drt->DevlessPath.Buffer) {
	ExFreePool(Drt->DevlessPath.Buffer);
    }
    ExFreePool(Drt);

Cleanup:

    ExReleaseResourceLite(&DfsData.Resource);

    PktRelease();

    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mup\mupdata.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    mupdata.c

Abstract:

    This module declares global MUP data.

Author:

    Manny Weiser (mannyw)    20-Dec-1991

Revision History:

--*/

extern MUP_LOCK MupGlobalLock;
extern ERESOURCE MupVcbLock;
extern MUP_LOCK MupPrefixTableLock;
extern MUP_LOCK MupCcbListLock;
extern KSPIN_LOCK MupInterlock;
extern LIST_ENTRY MupProviderList;
extern LIST_ENTRY MupPrefixList;
extern LIST_ENTRY MupMasterQueryList;
extern ULONG MupProviderCount;
extern UNICODE_PREFIX_TABLE MupPrefixTable;
extern CCHAR MupStackSize;
extern LARGE_INTEGER MupKnownPrefixTimeout;
extern BOOLEAN MupOrderInitialized;
extern NTSTATUS MupOrderedErrorList[];
extern BOOLEAN MupEnableDfs;

#ifdef MUPDBG
extern MUP_LOCK MupDebugLock;
extern ULONG MupDebugTraceLevel;
extern ULONG MupDebugTraceIndent;
#endif

#define MAILSLOT_PREFIX        L"Mailslot"
#define KNOWN_PREFIX_TIMEOUT   15             // 15 minutes
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mup\log.c ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation
//
//  File:       log.c
//
//  Contents:   Module to log messages from the driver to the NT event logging
//              system.
//
//  Classes:
//
//  Functions:  LogWriteMessage()
//
//  History:    3/30/93         Milans created
//              04/18/93        SudK    modified to use a MessageFile. and some
//                                      cleanup to the function below.
//
//-----------------------------------------------------------------------------

#include "dfsprocs.h"

#define Dbg             DEBUG_TRACE_EVENTLOG


VOID LogpPutString(
    IN PUNICODE_STRING pustrString,
    IN OUT PCHAR *ppStringBuffer,
    IN OUT UCHAR *pcbBuffer);

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, LogWriteMessage )
#pragma alloc_text( PAGE, LogpPutString )
#endif // ALLOC_PRAGMA



//+----------------------------------------------------------------------------
//
//  Function:   LogWriteMessage
//
//  Synopsis:   Logs a message to the NT event logging system.
//
//  Arguments:  [UniqueErrCode] -- The code that identifes the message.
//              [NtStatusCode] --  Status code from some error.
//              [nStrings]      -- Number of strings being passed in.
//              [pustrArg]      -- The Array of insertion strings.
//
//  Returns:    Nothing at all.
//
//  History:    04/18/93        SudK    Created.
//
//-----------------------------------------------------------------------------
VOID LogWriteMessage(
        IN ULONG        UniqueErrorCode,
        IN NTSTATUS     NtStatusCode,
        IN ULONG        nStrings,
        IN PUNICODE_STRING pustrArg OPTIONAL)
{
    PIO_ERROR_LOG_PACKET pErrorLog;
    UCHAR                cbSize;
    UCHAR                *pStringBuffer;
    ULONG                i;

    //
    // Compute the size of the Error Log Packet that we need to start with.
    //
    cbSize = sizeof(IO_ERROR_LOG_PACKET);

    for (i = 0; i < nStrings; i++)  {
        cbSize = (UCHAR)( cbSize + pustrArg[i].Length + sizeof(WCHAR));
    }

    if (cbSize > ERROR_LOG_MAXIMUM_SIZE) {
        cbSize = ERROR_LOG_MAXIMUM_SIZE;
    }

    pErrorLog = (PIO_ERROR_LOG_PACKET) IoAllocateErrorLogEntry(
                                            DfsData.DriverObject,
                                            cbSize);
    if (!pErrorLog) {

        //
        // Well, I guess we won't be logging this one.
        //

        return;
    }

    //
    // Zero out all fields, then set the ones we want.
    //

    RtlZeroMemory((PVOID) pErrorLog, sizeof(IO_ERROR_LOG_PACKET));
    pErrorLog->FinalStatus = NtStatusCode;
    pErrorLog->ErrorCode = UniqueErrorCode;
    pErrorLog->NumberOfStrings = (USHORT) nStrings;

    pErrorLog->StringOffset = sizeof(IO_ERROR_LOG_PACKET);
    pStringBuffer = ((PCHAR) pErrorLog) + sizeof(IO_ERROR_LOG_PACKET);

    //
    // Copy the strings into the buffer, making sure we truncate if and when
    // we need to.
    //

    cbSize -= sizeof(IO_ERROR_LOG_PACKET);

    for (i = 0; i < nStrings; i++)  {
        LogpPutString(&pustrArg[i], &pStringBuffer, &cbSize);
    }

    //
    // And finally, write out the log
    //

    IoWriteErrorLogEntry(pErrorLog);

}


//+----------------------------------------------------------------------------
//
//  Function:   LogpPutString
//
//  Synopsis:   Copies a string into the buffer part of an IO_ERROR_LOG_PACKET.
//              Takes care of truncating if the whole string won't fit.
//
//  Arguments:  [pustrString] -- Pointer to unicode string to copy.
//              [ppStringBuffer] -- On input, pointer to beginning of buffer
//                               to copy to. On exit, will point one past the
//                               end of the copied string.
//              [pcbBuffer] -- On input, max size of buffer. On output,
//                               remaining size after string has been copied.
//
//  Returns:    Nothing
//
//  History:    04/18/93        SudK    Created.
//
//-----------------------------------------------------------------------------

VOID LogpPutString(
    IN PUNICODE_STRING pustrString,
    IN OUT PCHAR *ppStringBuffer,
    IN OUT UCHAR *pcbBuffer)
{
    ULONG       len;
    PWCHAR      pwch;

    if ((*pcbBuffer == 0) || (pustrString->Length == 0))        {
        return;
    }

    if ( *pcbBuffer >= (pustrString->Length + sizeof(WCHAR)) ) {
        RtlMoveMemory(*ppStringBuffer, pustrString->Buffer, pustrString->Length);
        (*pcbBuffer) -= pustrString->Length;
        (*ppStringBuffer) += pustrString->Length;

    } else {
        RtlMoveMemory(*ppStringBuffer, pustrString->Buffer, (*pcbBuffer)-sizeof(WCHAR));
        *pcbBuffer = sizeof(WCHAR);
        (*ppStringBuffer) += (*pcbBuffer - sizeof(WCHAR));
    }

    //
    // Null Terminate the String Now if necessary.
    //
    if (*((PWCHAR) *ppStringBuffer - 1) != L'\0')       {
        *((PWCHAR) *ppStringBuffer) = L'\0';
        *ppStringBuffer += sizeof(WCHAR);
        (*pcbBuffer) -= sizeof(WCHAR);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mup\mupfunc.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    mupfunc.h

Abstract:

    This module defines all the function prototypes and macros for the MUP.

Author:

    Manny Weiser (mannyw)    17-Dec-1991

Revision History:

--*/

#ifndef _MUPFUNC_
#define _MUPFUNC_


NTSTATUS
MupCreate (
    IN PMUP_DEVICE_OBJECT MupDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MupFsControl (
    IN PMUP_DEVICE_OBJECT MupDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MupCleanup (
    IN PMUP_DEVICE_OBJECT MupDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MupClose (
    IN PMUP_DEVICE_OBJECT MupDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MupForwardIoRequest (
    IN PMUP_DEVICE_OBJECT MupDeviceObject,
    IN PIRP Irp
    );

//
// Internal support functions
//

NTSTATUS
MupInitializeData(
    );

VOID
MupUninitializeData(
    VOID
    );

PIRP
MupBuildIoControlRequest (
    IN OUT PIRP Irp OPTIONAL,
    IN PFILE_OBJECT FileObject OPTIONAL,
    IN PVOID Context,
    IN UCHAR MajorFunction,
    IN ULONG IoControlCode,
    IN PVOID MainBuffer,
    IN ULONG InputBufferLength,
    IN PVOID AuxiliaryBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN PIO_COMPLETION_ROUTINE CompletionRoutine
    );

NTSTATUS
MupRerouteOpen (
    IN PFILE_OBJECT FileObject,
    IN PUNC_PROVIDER UncProvider
    );

VOID
MupCalculateTimeout(
    PLARGE_INTEGER Time
    );

//
// Block Management functions.
//

VOID
MupInitializeVcb(
    IN PVCB Vcb
    );

VOID
MupDereferenceVcb(
    PVCB Vcb
    );

PFCB
MupCreateFcb(
    VOID
    );

VOID
MupDereferenceFcb(
    PFCB Fcb
    );

VOID
MupFreeFcb(
    PFCB Fcb
    );

PCCB
MupCreateCcb(
    VOID
    );

VOID
MupDereferenceCcb(
    PCCB Ccb
    );

VOID
MupFreeCcb(
    PCCB Ccb
    );

PUNC_PROVIDER
MupAllocateUncProvider(
    ULONG DataLength
    );

VOID
MupDereferenceUncProvider(
    PUNC_PROVIDER UncProvider
    );

VOID
MupCloseUncProvider(
    PUNC_PROVIDER UncProvider
    );

PKNOWN_PREFIX
MupAllocatePrefixEntry(
    ULONG DataLength
    );

VOID
MupDereferenceKnownPrefix(
    PKNOWN_PREFIX KnownPrefix
    );

VOID
MupFreeKnownPrefix(
    PKNOWN_PREFIX KnownPrefix
    );

PMASTER_FORWARDED_IO_CONTEXT
MupAllocateMasterIoContext(
    VOID
    );

NTSTATUS
MupDereferenceMasterIoContext(
    PMASTER_FORWARDED_IO_CONTEXT MasterContext,
    PNTSTATUS Status
    );

VOID
MupFreeMasterIoContext(
    PMASTER_FORWARDED_IO_CONTEXT MasterContext
    );

PMASTER_QUERY_PATH_CONTEXT
MupAllocateMasterQueryContext(
    VOID
    );

NTSTATUS
MupDereferenceMasterQueryContext(
    PMASTER_QUERY_PATH_CONTEXT MasterContext
    );

VOID
MupFreeMasterQueryContext(
    PMASTER_QUERY_PATH_CONTEXT MasterContext
    );

//
// File object support functions.
//

VOID
MupSetFileObject (
    IN PFILE_OBJECT FileObject OPTIONAL,
    IN PVOID FsContext,
    IN PVOID FsContext2
    );

BLOCK_TYPE
MupDecodeFileObject (
    IN PFILE_OBJECT FileObject,
    OUT PVOID *FsContext,
    OUT PVOID *FsContext2
    );

//
// Registry Functions
//

VOID
MupGetProviderInformation (
    VOID
    );

PUNC_PROVIDER
MupCheckForUnregisteredProvider(
    PUNICODE_STRING DeviceName
    );

VOID
MupRemoveKnownPrefixEntry(
    PKNOWN_PREFIX KnownPrefix
    );

//
//  Acquiring and releasing MUP locks.
//

#define MupAcquireGlobalLock() ACQUIRE_LOCK( &MupGlobalLock )
#define MupReleaseGlobalLock() RELEASE_LOCK( &MupGlobalLock )

#define BlockType( Block )                 ((PBLOCK_HEADER)(Block))->BlockType

#define MupCompleteRequest( Irp, Status )  FsRtlCompleteRequest( Irp, Status )
#define MupReferenceBlock( Block )         ++((PBLOCK_HEADER)(Block))->ReferenceCount
#define MupVerifyBlock( Block, Type)  \
                                                                   \
    if ( ((PBLOCK_HEADER)(Block))->BlockState != BlockStateActive  \
                ||                                                 \
         ((PBLOCK_HEADER)(Block))->BlockType != Type) {            \
                                                                   \
        ExRaiseStatus( STATUS_INVALID_HANDLE );                    \
                                                                   \
    }

//
// Memory allocation and free
//

#if !MUPDBG

#define ALLOCATE_PAGED_POOL( size, type ) FsRtlAllocatePoolWithTag( PagedPool, (size), ' puM' )
#define ALLOCATE_NONPAGED_POOL( size, type ) FsRtlAllocatePoolWithTag( NonPagedPool, (size), ' puM' )
#define FREE_POOL( buffer ) ExFreePool( buffer )

#else

PVOID
MupAllocatePoolDebug (
    IN POOL_TYPE PoolType,
    IN CLONG BlockSize,
    IN BLOCK_TYPE BlockType
    );

VOID
MupFreePoolDebug (
    IN PVOID P
    );

#define ALLOCATE_PAGED_POOL( size, type ) MupAllocatePoolDebug( PagedPool, (size), (type) )
#define ALLOCATE_NONPAGED_POOL( size, type ) MupAllocatePoolDebug( NonPagedPool, (size), (type) )
#define FREE_POOL( buffer ) MupFreePoolDebug( buffer )

#endif

//
//  The following macros are used to establish the semantics needed
//  to do a return from within a try-finally clause.  As a rule every
//  try clause must end with a label call try_exit.  For example,
//
//      try {
//              :
//              :
//
//      try_exit: NOTHING;
//      } finally {
//
//              :
//              :
//      }
//
//  Every return statement executed inside of a try clause should use the
//  try_return macro.  If the compiler fully supports the try-finally construct
//  then the macro should be
//
//      #define try_return(S)  { return(S); }
//
//  If the compiler does not support the try-finally construct then the macro
//  should be
//
//      #define try_return(S)  { S; goto try_exit; }
//

#define try_return(S) { S; goto try_exit; }

//
// General purpose
//

#define MIN(a,b)  (((a) < (b)) ? (a) : (b))

//
// Terminal Server Macro.
//

#define IsTerminalServer() (BOOLEAN)(SharedUserData->SuiteMask & (1 << TerminalServer))

#endif // _MUPFUNC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mup\mupinit.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    mupinit.c

Abstract:

    This module implements the DRIVER_INITIALIZATION routine for the
    multiple UNC provider file system.

Author:

    Manny Weiser (mannyw)    12-17-91

Revision History:

--*/

#include "mup.h"

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

VOID
MupUnload(
    IN PDRIVER_OBJECT DriverObject
    );

BOOLEAN
MuppIsDfsEnabled();

BOOLEAN
MupCheckNullSessionUsage();

BOOLEAN MupUseNullSessionForDfs = TRUE;

//
// Globals
//
PMUP_DEVICE_OBJECT mupDeviceObject;

#ifdef ALLOC_PRAGMA
#pragma alloc_text( INIT, DriverEntry )
#pragma alloc_text( PAGE, MuppIsDfsEnabled )
#pragma alloc_text( PAGE, MupUnload )
#endif

NTSTATUS MupDrvWmiDispatch(PDEVICE_OBJECT p, PIRP i);

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This is the initialization routine for the mup file system
    device driver.  This routine creates the device object for the mup
    device and performs all other driver initialization.

Arguments:

    DriverObject - Pointer to driver object created by the system.

Return Value:

    NTSTATUS - The function value is the final status from the initialization
        operation.

--*/

{
    NTSTATUS status = STATUS_SUCCESS;
    UNICODE_STRING nameString;
    PDEVICE_OBJECT deviceObject;

    PAGED_CODE();
    //
    // Initialize MUP global data.
    //

    MupInitializeData();

    //
    // Initialize the Dfs client
    //

    MupEnableDfs = MuppIsDfsEnabled();


    if (MupEnableDfs) {
        status = DfsDriverEntry( DriverObject, RegistryPath );
        if (!NT_SUCCESS( status )) {
            MupEnableDfs = FALSE;
        }
    }

    //
    // Create the MUP device object.
    //

    RtlInitUnicodeString( &nameString, DD_MUP_DEVICE_NAME );
    status = IoCreateDevice( DriverObject,
                             sizeof(MUP_DEVICE_OBJECT)-sizeof(DEVICE_OBJECT),
                             &nameString,
                             FILE_DEVICE_MULTI_UNC_PROVIDER,
                             0,
                             FALSE,
                             &deviceObject );

    if (!NT_SUCCESS( status )) {
        if (MupEnableDfs) {
            DfsUnload (DriverObject);
        }
        MupUninitializeData();
        return status;

    }
    DriverObject->DriverUnload = MupUnload;

    //
    // Initialize the driver object with this driver's entry points.
    //
    // 2/27/96 MilanS - Be careful with these. If you add to this list
    // of dispatch routines, you'll need to make appropriate calls to the
    // corresponding Dfs fsd routine.
    //

    DriverObject->MajorFunction[IRP_MJ_CREATE] =
        (PDRIVER_DISPATCH)MupCreate;
    DriverObject->MajorFunction[IRP_MJ_CREATE_NAMED_PIPE] =
        (PDRIVER_DISPATCH)MupCreate;
    DriverObject->MajorFunction[IRP_MJ_CREATE_MAILSLOT] =
        (PDRIVER_DISPATCH)MupCreate;

    DriverObject->MajorFunction[IRP_MJ_WRITE] =
        (PDRIVER_DISPATCH)MupForwardIoRequest;
    DriverObject->MajorFunction[IRP_MJ_FILE_SYSTEM_CONTROL] =
        (PDRIVER_DISPATCH)MupFsControl;

    DriverObject->MajorFunction[IRP_MJ_CLEANUP] =
        (PDRIVER_DISPATCH)MupCleanup;
    DriverObject->MajorFunction[IRP_MJ_CLOSE] =
        (PDRIVER_DISPATCH)MupClose;

    //
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = 
                                         (PDRIVER_DISPATCH) MupDrvWmiDispatch;



    status = IoWMIRegistrationControl (deviceObject, WMIREG_ACTION_REGISTER);
    // Initialize the VCB
    //

    mupDeviceObject = (PMUP_DEVICE_OBJECT)deviceObject;
    MupInitializeVcb( &mupDeviceObject->Vcb );

    //
    // Return to the caller.
    //
    return( STATUS_SUCCESS );
}

VOID
MupUnload(
    IN PDRIVER_OBJECT DriverObject
    )
/*++

Routine Description:

    This is the unload routine for the mup driver

Arguments:

    DriverObject - Mups driver object 

Return Value:

    None

--*/
{
    IoDeleteDevice (&mupDeviceObject->DeviceObject);
    if (MupEnableDfs) {
        DfsUnload (DriverObject);
    }
    MupUninitializeData();
}


BOOLEAN
MuppIsDfsEnabled()

/*++

Routine Description:

    This routine checks a registry key to see if the Dfs client is enabled.
    The client is assumed to be enabled by default, and disabled only if there
    is a registry value indicating that it should be disabled.

Arguments:

    None

Return Value:

    TRUE if Dfs client is enabled, FALSE otherwise.

--*/

{
    NTSTATUS status;
    HANDLE mupRegHandle;
    OBJECT_ATTRIBUTES objectAttributes;
    ULONG valueSize;
    BOOLEAN dfsEnabled = TRUE;

#define MUP_KEY L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Mup"
#define DISABLE_DFS_VALUE_NAME  L"DisableDfs"

    UNICODE_STRING mupRegKey = {
        sizeof(MUP_KEY) - sizeof(WCHAR),
        sizeof(MUP_KEY),
        MUP_KEY};

    UNICODE_STRING disableDfs = {
        sizeof(DISABLE_DFS_VALUE_NAME) - sizeof(WCHAR),
        sizeof(DISABLE_DFS_VALUE_NAME),
        DISABLE_DFS_VALUE_NAME};

    struct {
        KEY_VALUE_PARTIAL_INFORMATION Info;
        ULONG Buffer;
    } disableDfsValue;


    InitializeObjectAttributes(
        &objectAttributes,
        &mupRegKey,
        OBJ_CASE_INSENSITIVE,
        0,
        NULL
        );

    status = ZwOpenKey(&mupRegHandle, KEY_READ, &objectAttributes);

    if (NT_SUCCESS(status)) {

        status = ZwQueryValueKey(
                    mupRegHandle,
                    &disableDfs,
                    KeyValuePartialInformation,
                    (PVOID) &disableDfsValue,
                    sizeof(disableDfsValue),
                    &valueSize);

        if (NT_SUCCESS(status) && disableDfsValue.Info.Type == REG_DWORD) {

            if ( (*((PULONG) disableDfsValue.Info.Data)) == 1 )
                dfsEnabled = FALSE;

        }

        ZwClose( mupRegHandle );

    }

    return( dfsEnabled );

}


BOOLEAN
MupCheckNullSessionUsage()
{
    NTSTATUS status;
    HANDLE mupRegHandle;
    OBJECT_ATTRIBUTES objectAttributes;
    ULONG valueSize;
    BOOLEAN NullSessionEnabled = FALSE;

#define MUP_KEY L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Mup"
#define DFS_NULL_SESSION_VALUE_NAME  L"DfsUseNullSession"

    UNICODE_STRING mupRegKey = {
        sizeof(MUP_KEY) - sizeof(WCHAR),
        sizeof(MUP_KEY),
        MUP_KEY};

    UNICODE_STRING UseNullSession = {
        sizeof(DFS_NULL_SESSION_VALUE_NAME) - sizeof(WCHAR),
        sizeof(DFS_NULL_SESSION_VALUE_NAME),
        DFS_NULL_SESSION_VALUE_NAME};

    struct {
        KEY_VALUE_PARTIAL_INFORMATION Info;
        ULONG Buffer;
    } DfsUseNullSessionValue;


    InitializeObjectAttributes(
        &objectAttributes,
        &mupRegKey,
        OBJ_CASE_INSENSITIVE,
        0,
        NULL
        );

    status = ZwOpenKey(&mupRegHandle, KEY_READ, &objectAttributes);

    if (NT_SUCCESS(status)) {

        status = ZwQueryValueKey(
                    mupRegHandle,
                    &UseNullSession,
                    KeyValuePartialInformation,
                    (PVOID) &DfsUseNullSessionValue,
                    sizeof(DfsUseNullSessionValue),
                    &valueSize);

        if (NT_SUCCESS(status) && DfsUseNullSessionValue.Info.Type == REG_DWORD) {

            if ( (*((PULONG) DfsUseNullSessionValue.Info.Data)) == 1 )
                NullSessionEnabled = TRUE;
        }

        ZwClose( mupRegHandle );

    }

    return( NullSessionEnabled );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mup\mupwml.c ===
#include "mupwml.h"


WML_CONTROL_GUID_REG _MupDrv_ControlGuids[] = {
    { //fc4b0d39-e8be-4a83-a32f-c0c7c4f61ee4  Debug control guid
        0xfc4b0d39, 0xe8be, 0x4a83, 
            { 0xa3, 0x2f, 0xc0, 0xc7, 0xc4, 0xf6, 0x1e, 0xe4 },
            // 3 trace guids per control guid.
            { 
               {// f1ca510b-57a7-4f4b-ab4c-561cacca158d 
                   0xf1ca510b, 0x57a7, 0x4f4b,
                       { 0xab, 0x4c, 0x56, 0x1c, 0xac, 0xca, 0x15, 0x8d },
               },
               { // d5ade09c-c701-48c6-99ac-d95ff213a0a3
                   0xd5ade09c, 0xc701, 0x48c6,
                       { 0x99, 0xac, 0xd9, 0x5f, 0xf2, 0x13, 0xa0, 0xa3 },
               },
               { // 8a97d97c-30d0-454b-8109-5a9b9389f1b2
                   0x8a97d97c, 0x30d0, 0x454b,
                       { 0x81, 0x09, 0x5a, 0x9b, 0x93, 0x89, 0xf1, 0xb2 },
               }
            },
    },
    { //fc570986-5967-4641-a6f9-05291bce66c5  Perf  control guid
        0xfc570986, 0x5967, 0x4641, 
            { 0xa6, 0xf9, 0x05, 0x29, 0x1b, 0xce, 0x66, 0xc5 },
            // 3 traced guids per control guid
            {
               {// 2ef42982-ccf7-4880-87bf-bc835d09ab66
                   0x2ef42982, 0xccf7, 0x4880,
                       { 0x87, 0xbf, 0xbc, 0x83, 0x5d, 0x09, 0xab, 0x66 },
               },
               {// 99e51b5c-cffc-4a46-b940-0e395014b54a
                   0x99e51b5c, 0xcffc, 0x4a46,
                       { 0xb9, 0x40, 0x0e, 0x39, 0x50, 0x14, 0xb5, 0x4a },
               },
               {// acd929fb-ec34-4d8e-b068-4c11636f6e9d
                   0xacd929fb, 0xec34, 0x4d8e,
                       {0xb0, 0x68, 0x4c, 0x11, 0x63, 0x6f, 0x6e, 0x9d },
               }
            },
    },
    { //39a7b5e0-be85-47fc-b9f5-593a659abac1  Instr. control guid
        0x39a7b5e0, 0xbe85, 0x47fc, 
            { 0xb9, 0xf5, 0x59, 0x3a, 0x65, 0x9a, 0xba, 0xc1 },
            // 3 trace guids per control guid
            {
               {// 6a13aa9a-7330-4415-bb26-60c105a4c6ae
                   0x6a13aa9a, 0x7330, 0x4415, 
                       { 0xbb, 0x26, 0x60, 0xc1, 0x05, 0xa4, 0xc6, 0xae },
               },
               { // 2bb352a4-7261-42e6-9f40-b91c214ed59a
                   0x2bb352a4, 0x7261, 0x42e6,
                       { 0x9f, 0x40, 0xb9, 0x1c, 0x21, 0x4e, 0xd5, 0x9a },
               },
               {// 6dfa04f0-cf82-426e-ae9e-735f72faa11d
                   0x6dfa04f0, 0xcf82, 0x426e,
                       { 0xae, 0x9e, 0x73, 0x5f, 0x72, 0xfa, 0xa1, 0x1d },
               }
            },
    },
};



ULONG called = 0;

NTSTATUS
MupDrvWmiDispatch(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP           pIrp
    )
{
    WML_TINY_INFO Info;
    NTSTATUS Status;
    UNICODE_STRING RegPath;

    called = 1;
    RtlInitUnicodeString (&RegPath, L"Mup");

    RtlZeroMemory (&Info, sizeof(Info));

    Info.ControlGuids = _MupDrv_ControlGuids;
    Info.GuidCount = sizeof(_MupDrv_ControlGuids) / sizeof(WML_CONTROL_GUID_REG);
    Info.DriverRegPath = &RegPath;
    
    Status = WmlTinySystemControl (&Info, pDeviceObject, pIrp);

    return Status;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mup\mupstruc.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    mupstruc.h

Abstract:

    This module defines the data structures that make up the major internal
    part of the MUP.

Author:

    Manny Weiser (mannyw)    16-Dec-1991

Revision History:

--*/

#ifndef _MUPSTRUC_
#define _MUPSTRUC_



typedef enum _BLOCK_TYPE {
    BlockTypeUndefined,
    BlockTypeVcb,
    BlockTypeUncProvider,
    BlockTypeKnownPrefix,
    BlockTypeFcb,
    BlockTypeCcb,
    BlockTypeMasterIoContext,
    BlockTypeIoContext,
    BlockTypeMasterQueryContext,
    BlockTypeQueryContext,
    BlockTypeBuffer
} BLOCK_TYPE;

typedef enum _BLOCK_STATE {
    BlockStateUnknown,
    BlockStateActive,
    BlockStateClosing
} BLOCK_STATE;

//
// A block header starts every block
//

typedef struct _BLOCK_HEADER {
    BLOCK_TYPE BlockType;
    BLOCK_STATE BlockState;
    ULONG ReferenceCount;
    ULONG BlockSize;
} BLOCK_HEADER, *PBLOCK_HEADER;

//
// The MUP volume control block.  This structure is used to track access
// the the MUP device object.
//

typedef struct _VCB {
    BLOCK_HEADER BlockHeader;

    //
    // The IO share access.
    //

    SHARE_ACCESS ShareAccess;

} VCB, *PVCB;

//
// The MUP Device Object is an I/O system device object.
//

typedef struct _MUP_DEVICE_OBJECT {

    DEVICE_OBJECT DeviceObject;
    VCB Vcb;

} MUP_DEVICE_OBJECT, *PMUP_DEVICE_OBJECT;


//
// A UNC provider.  A UNC provider block corresponds to a registered UNC
// provider device.
//

typedef struct _UNC_PROVIDER {

    BLOCK_HEADER BlockHeader;
    LIST_ENTRY ListEntry;

    //
    // The device name of the provider
    //

    UNICODE_STRING DeviceName;

    //
    // Our handle to the UNC device and the associated file and device objects
    //

    HANDLE Handle;

    PDEVICE_OBJECT DeviceObject;
    PFILE_OBJECT FileObject;

    //
    // The priority of the provider.
    //

    ULONG Priority;

    //
    // Indicate if the provider supports mailslots.
    //

    BOOLEAN MailslotsSupported;

    //
    // Indicate if the provider is currently registered or unregistered
    //

    BOOLEAN Registered;

} UNC_PROVIDER, *PUNC_PROVIDER;

//
// A known prefix.  A known prefix is a path prefix (like \\server\share)
// that is "owned" by a specific UNC provider.
//

typedef struct _KNOWN_PREFIX {

    BLOCK_HEADER BlockHeader;

    UNICODE_PREFIX_TABLE_ENTRY TableEntry;

    //
    // The prefix string
    //

    UNICODE_STRING Prefix;

    //
    // The time the prefix was last used.
    //

    LARGE_INTEGER LastUsedTime;

    //
    // A referenced pointer to the owning UNC Provider
    //

    PUNC_PROVIDER UncProvider;

    //
    // If TRUE the Prefix string was allocated separately to this block.
    //

    BOOLEAN PrefixStringAllocated;

    //
    // If TRUE the Prefix string has been inserted in the prefix table
    //

    BOOLEAN InTable;

    //
    // If Active, the entry either is in the table or had been inserted in the
    // table at some point.

    BOOLEAN Active;
    //
    // Links for the linked list of entries
    //

    LIST_ENTRY ListEntry;

} KNOWN_PREFIX, *PKNOWN_PREFIX;


//
// A File Control Block.  The FCB corresponds to an open broadcast file,
// i.e. a mailslot handle.  We don't store any information about the FCB,
// we let the various providers handle all of that.
//

typedef struct _FCB {

    BLOCK_HEADER BlockHeader;

    //
    // A pointer to the IO system's file object, that references this FCB.
    //

    PFILE_OBJECT FileObject;

    //
    // A list of CCBs for this FCB.   The list is protected by MupCcbListLock.
    //

    LIST_ENTRY CcbList;

} FCB, *PFCB;

//
// A CCB.  The CCB is the per provider version of the FCB, all provider
// specific information about an FCB is kept here.
//

typedef struct _CCB {

    BLOCK_HEADER BlockHeader;

    //
    // A referenced pointer to the FCB for this CCB.
    //

    PFCB Fcb;

    //
    // A list entry to keep this block on the FCB's CcbList.
    //

    LIST_ENTRY ListEntry;

    //
    // The file and device objects for this open file.
    //

    PDEVICE_OBJECT DeviceObject;
    PFILE_OBJECT FileObject;

} CCB, *PCCB;


//
// The master and slave forward i/o context blocks are used to track
// forward IRPs.  Each forwarded IRP is tracked by the
// Master Forwarded Io Context (which corresponds to our FCB) and a per
// provider Io Context (which corresponse to our CCB).
//
// Since the Forwarded Io Context is never referenced or dereferenced it
// doesn't get a block header.
//

typedef struct _MASTER_FORWARDED_IO_CONTEXT {

    BLOCK_HEADER BlockHeader;

    //
    // The original IRP (i.e. the one sent to the MUP) that is being handled.
    //

    PIRP OriginalIrp;

    //
    // The status that will be used to complete the Irp. If all the mailslot
    // writes fail (eg. a portable not in its docking station) then the status
    // from the last write will be returned. If one works then STATUS_SUCCESS.
    //
    //

    NTSTATUS SuccessStatus;
    NTSTATUS ErrorStatus;

    //
    // A referenced pointer to the FCB for this i/o.
    //

    PFCB Fcb;

} MASTER_FORWARDED_IO_CONTEXT, *PMASTER_FORWARDED_IO_CONTEXT;

typedef struct _FORWARDED_IO_CONTEXT {

    //
    // A referenced pointer to the CCB.
    //

    PCCB Ccb;

    //
    // A referenced pointer to the Master Context.
    //

    PMASTER_FORWARDED_IO_CONTEXT MasterContext;

    //
    //  These structures are used for posting to the Ex worker threads.
    //

    WORK_QUEUE_ITEM WorkQueueItem;
    PDEVICE_OBJECT DeviceObject;
    PIRP pIrp;

} FORWARDED_IO_CONTEXT, *PFORWARDED_IO_CONTEXT;


//
// The master and slave query path context blocks are used to track
// create IRPs.  Each forwarded IRP is tracked by the
// Master query Path Context (which corresponds to our FCB) and a per
// provider query path (which corresponse to our CCB).
//
// Since the query path context is never referenced or dereferenced it
// doesn't get a block header.
//

typedef struct _MASTER_QUERY_PATH_CONTEXT {

    BLOCK_HEADER BlockHeader;

    //
    // A pointer to the original create IRP.
    //

    PIRP OriginalIrp;

    //
    // A pointer to the FileObject in the original create IRP.
    //

    PFILE_OBJECT FileObject;

    //
    // This is used to track the identity of the provider that will
    // receive the Create IRP.
    //

    PUNC_PROVIDER Provider;

    //
    // A lock to protect access to Provider
    //

    MUP_LOCK Lock;

    //
    // An unreferenced pointer to the newly allocated known prefix block.
    //

    PKNOWN_PREFIX KnownPrefix;

    //
    // The status code to be returned from this operation
    //
    NTSTATUS ErrorStatus;

    //
    // A list of QUERY_PATH_CONTEXTs outstadning for this MasterContext
    //
    LIST_ENTRY QueryList;

    //
    // The entry for this master context in the global list MupMasterQueryList
    //
    LIST_ENTRY MasterQueryList;

} MASTER_QUERY_PATH_CONTEXT, *PMASTER_QUERY_PATH_CONTEXT;

typedef struct _QUERY_PATH_CONTEXT {

    //
    // A referenced poitner to the master query path context block.
    //

    PMASTER_QUERY_PATH_CONTEXT MasterContext;

    //
    // A referenced pointer to the UNC provider we are querying.
    //

    PUNC_PROVIDER Provider;

    //
    // A pointer to the Device Io Control buffer we allocated to query
    // the above provider.
    //

    PVOID Buffer;

    //
    // The entry for this context in the MasterContext's QueryList
    //
    LIST_ENTRY QueryList;

    //
    // The IRP associated with this query context (i.e., the IRP sent to the UNC_PROVIDER)
    //
    PIRP QueryIrp;

} QUERY_PATH_CONTEXT, *PQUERY_PATH_CONTEXT;

#endif // _MUPSTRUC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mup\nodetype.h ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:       NODETYPE.H
//
//  Contents:
//      This module defines all of the node type codes used in this development
//      shell.  Every major data structure in the file system is assigned a
//      node type code.  This code is the first CSHORT in the structure and is
//      followed by a CSHORT containing the size, in bytes, of the structure.
//
//  Functions:
//
//  History:    12 Nov 1991     AlanW   Created from CDFS souce.
//               8 May 1992     PeterCo Removed all EP related stuff.
//                                      Added PKT related stuff.
//
//-----------------------------------------------------------------------------


#ifndef _NODETYPE_
#define _NODETYPE_

typedef CSHORT NODE_TYPE_CODE, *PNODE_TYPE_CODE;

#define NTC_UNDEFINED                   ((NODE_TYPE_CODE)0x0000)

#define DSFS_NTC_DATA_HEADER            ((NODE_TYPE_CODE)0x0D01)
#define DSFS_NTC_IRP_CONTEXT            ((NODE_TYPE_CODE)0x0D02)
#define DSFS_NTC_REFERRAL               ((NODE_TYPE_CODE)0x0D03)
#define DSFS_NTC_VCB                    ((NODE_TYPE_CODE)0x0D04)
#define DSFS_NTC_PROVIDER               ((NODE_TYPE_CODE)0x0D05)
#define DSFS_NTC_FCB_HASH               ((NODE_TYPE_CODE)0x0D06)
#define DSFS_NTC_FCB                    ((NODE_TYPE_CODE)0x0D07)
#define DSFS_NTC_DNR_CONTEXT            ((NODE_TYPE_CODE)0x0D08)
#define DSFS_NTC_PKT                    ((NODE_TYPE_CODE)0x0D09)
#define DSFS_NTC_PKT_ENTRY              ((NODE_TYPE_CODE)0x0D0A)
#define DSFS_NTC_PKT_STUB               ((NODE_TYPE_CODE)0x0D0B)
#define DSFS_NTC_INSTRUM                ((NODE_TYPE_CODE)0x0D0C)
#define DSFS_NTC_INSTRUM_FREED          ((NODE_TYPE_CODE)0x0D0D)
#define DSFS_NTC_PWSTR                  ((NODE_TYPE_CODE)0x0D0E)
#define DSFS_NTC_SPECIAL_ENTRY          ((NODE_TYPE_CODE)0x0D0F)
#define DSFS_NTC_DRT                    ((NODE_TYPE_CODE)0x0D10)

typedef CSHORT NODE_BYTE_SIZE, *PNODE_BYTE_SIZE;

//
//  So all records start with
//
//  typedef struct _RECORD_NAME {
//      NODE_TYPE_CODE NodeTypeCode;
//      NODE_BYTE_SIZE NodeByteSize;
//          :
//  } RECORD_NAME;
//  typedef RECORD_NAME *PRECORD_NAME;
//

#define NodeType(Ptr) (*((NODE_TYPE_CODE UNALIGNED *)(Ptr)))
#define NodeSize(Ptr) (*(((PNODE_BYTE_SIZE)(Ptr))+1))

#endif // _NODETYPE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mup\mupwml.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    mupwml.h

Abstract:

    This file defines macro for use by the mup driver

Author:

    udayh

Revision History:

--*/

#ifndef __MUP_MUPWML_H__
#define __MUP_MUPWML_H__
#include <dfsprocs.h>
#define _NTDDK_
#include "wmlkm.h"
#include "wmlmacro.h"
// Streams 

#define _MUP_TRACE_STREAM               0x00
#define _MUP_PERF_STREAM                0x01
#define _MUP_INSTR_STREAM               0x02

#define _MUP_ENABLE_0                   0x0000
#define _MUP_ENABLE_DEFAULT             0x0001
#define _MUP_ENABLE_TRACE_IRP           0x0004
#define _MUP_ENABLE_FILEIO              0x0002
#define _MUP_ENABLE_FILEINFO            0x0008
#define _MUP_ENABLE_SURROGATE           0x0010
#define _MUP_ENABLE_PKT                 0x0020
#define _MUP_ENABLE_KNOWN_PREFIX        0x0040
#define _MUP_ENABLE_DNR                 0x0080
#define _MUP_ENABLE_UNUSED6             0x0100
#define _MUP_ENABLE_UNUSED5             0x0200
#define _MUP_ENABLE_UNUSED4             0x0400
#define _MUP_ENABLE_UNUSED3             0x0800
#define _MUP_ENABLE_UNUSED2             0x1000
#define _MUP_ENABLE_ALL_ERROR           0x2000
#define _MUP_ENABLE_ERROR               0x4000
#define _MUP_ENABLE_MONITOR             0x8000


#define _MUP_LEVEL_HIGH                    0x1
#define _MUP_LEVEL_NORM                    0x2
#define _MUP_LEVEL_LOW                     0x4



#define MUP_LOG_STREAM(_stream)   _MUP_ ## _stream ## _STREAM
#define MUP_LOG_FLAGS(_flag)      _MUP_ENABLE_ ## _flag
#define MUP_LOG_LEVEL(_level)     _MUP_LEVEL_ ## _level

#define MUP_LOG(_why, _level, _flag, _type, _arg) \
            WML_LOG(_MupDrv, MUP_LOG_STREAM(_why), MUP_LOG_LEVEL(_level), _flag, _type, _arg 0)

#define LOGARG(_val)    (_val),
#define LOGNOTHING      0,
#define MUP_TRACE_HIGH(_flag, _type, _arg)              \
            MUP_LOG(TRACE, HIGH, MUP_LOG_FLAGS(_flag), _type, _arg)
#define MUP_TRACE_NORM(_flag, _type, _arg)              \
            MUP_LOG(TRACE, NORM, MUP_LOG_FLAGS(_flag), _type, _arg)
#define MUP_TRACE_LOW(_flag, _type, _arg)               \
            MUP_LOG(TRACE, LOW, MUP_LOG_FLAGS(_flag), _type, _arg)

#define MUP_TRACE_ERROR(_status, _flag, _type, _arg)    \
            MUP_LOG(TRACE, NORM, (MUP_LOG_FLAGS(_flag) | (NT_SUCCESS(_status) ? 0 : MUP_LOG_FLAGS(ERROR))), _type, _arg)

#define MUP_TRACE_ERROR_HIGH(_status, _flag, _type, _arg)    \
            MUP_LOG(TRACE, HIGH, (MUP_LOG_FLAGS(_flag) | (NT_SUCCESS(_status) ? 0 : MUP_LOG_FLAGS(ERROR))), _type, _arg)

#define MUP_TRACE_ERROR_LOW(_status, _flag, _type, _arg)    \
            MUP_LOG(TRACE, LOW, (MUP_LOG_FLAGS(_flag) | (NT_SUCCESS(_status) ? 0 : MUP_LOG_FLAGS(ERROR))), _type, _arg)


#define MUP_PERF(_flag, _type, _arg)                    \
            MUP_LOG (PERF, HIGH, MUP_LOG_FLAGS(_flag), _type, _arg)
#define MUP_INSTR(_flag, _type, _arg)                   \
            MUP_LOG (INSTR, HIGH, MUP_LOG_FLAGS(_flag), _type, _arg)

#if 0
#define MUP_PRINTF(_why, _flag, _type, _fmtstr, _arg)   \
            WML_PRINTF(_MupDrv, MUP_LOG_STREAM(_why), MUP_LOG_FLAGS(_flag), _type, _fmtstr, _arg 0)

#define MUP_DBG_PRINT(_flag, _fmtstr, _arg)             \
            MUP_PRINTF(DBGLOG, _flag, MupDefault, _fmtstr, _arg)
            
#define MUP_ERR_PRINT (_status, _fmtstr, _arg) \
            if (NT_SUCCESS(_status)) {                \
                MUP_PRINTF (DBGLOG, LOG_ERROR, MupDefault, _fmtstr, _arg) \
            }

#endif

// from the WPP generated .h file
// We use different macros, so need to do some cut and paste
// Hopefully this will get automated in the future.

#  define WPP_DEFINE_MSG_ID(_a,_b)   ( ((_a) << 16) | ( _b) )

#  define MSG_ID_BroadcastOpen_Error1	 WPP_DEFINE_MSG_ID(0,47)
#  define MSG_ID_BroadcastOpen_Error2	 WPP_DEFINE_MSG_ID(0,48)
#  define MSG_ID_BroadcastOpen_Error3	 WPP_DEFINE_MSG_ID(0,50)
#  define MSG_ID_BroadcastOpen_Error_IoCreateFile	 WPP_DEFINE_MSG_ID(0,49)
#  define MSG_ID_BroadcastOpen_Error_ObReferenceObjectByHandle	 WPP_DEFINE_MSG_ID(0,51)
#  define MSG_ID_CreateRedirectedFile_Before_IoCallDriver	 WPP_DEFINE_MSG_ID(0,39)
#  define MSG_ID_CreateRedirectedFile_Entry	 WPP_DEFINE_MSG_ID(0,35)
#  define MSG_ID_CreateRedirectedFile_Error_EmptyFilename	 WPP_DEFINE_MSG_ID(0,36)
#  define MSG_ID_CreateRedirectedFile_Error_IoCallDriver	 WPP_DEFINE_MSG_ID(0,40)
#  define MSG_ID_CreateRedirectedFile_Error_MupRerouteOpen	 WPP_DEFINE_MSG_ID(0,37)
#  define MSG_ID_CreateRedirectedFile_Exit	 WPP_DEFINE_MSG_ID(0,41)
#  define MSG_ID_CreateRedirectedFile_Exit_Mailslot	 WPP_DEFINE_MSG_ID(0,38)
#  define MSG_ID_DfsCommonCreate_Error_NullVcb	 WPP_DEFINE_MSG_ID(0,61)
#  define MSG_ID_DfsCommonCreate_Error_PagingFileNotAllowed	 WPP_DEFINE_MSG_ID(0,60)
#  define MSG_ID_DfsCommonFileSystemControl_Error_IoCallDriver	 WPP_DEFINE_MSG_ID(0,87)
#  define MSG_ID_DfsCommonQueryVolumeInformation_Error_IoCallDriver	 WPP_DEFINE_MSG_ID(0,117)
#  define MSG_ID_DfsCommonSetInformation_Error_IoCallDriver	 WPP_DEFINE_MSG_ID(0,84)
#  define MSG_ID_DfsComposeFullName_Error1	 WPP_DEFINE_MSG_ID(0,67)
#  define MSG_ID_DfsCreateConnection_Error_ZwCreateFile	 WPP_DEFINE_MSG_ID(0,83)
#  define MSG_ID_DfsFilePassThrough_Error_IoCallDriver	 WPP_DEFINE_MSG_ID(0,15)
#  define MSG_ID_DfsFsctrlIsThisADfsPath_Error_DfsRootNameHasZeroLength	 WPP_DEFINE_MSG_ID(0,92)
#  define MSG_ID_DfsFsctrlIsThisADfsPath_Error_DfspIsSpecialShare_FALSE	 WPP_DEFINE_MSG_ID(0,94)
#  define MSG_ID_DfsFsctrlIsThisADfsPath_Error_DidNotFindSecondBackSlash	 WPP_DEFINE_MSG_ID(0,91)
#  define MSG_ID_DfsFsctrlIsThisADfsPath_Error_PathDoesNotBeginWithBackSlash	 WPP_DEFINE_MSG_ID(0,90)
#  define MSG_ID_DfsFsctrlIsThisADfsPath_Error_ShareNameHasZeroLength	 WPP_DEFINE_MSG_ID(0,93)
#  define MSG_ID_DfsFsctrlIsThisADfsPath_Exit_NotADfsPath	 WPP_DEFINE_MSG_ID(0,95)
#  define MSG_ID_DfsFsdCleanup_Entry	 WPP_DEFINE_MSG_ID(0,56)
#  define MSG_ID_DfsFsdCleanup_Exit	 WPP_DEFINE_MSG_ID(0,57)
#  define MSG_ID_DfsFsdClose_Entry	 WPP_DEFINE_MSG_ID(0,54)
#  define MSG_ID_DfsFsdClose_Exit	 WPP_DEFINE_MSG_ID(0,55)
#  define MSG_ID_DfsFsdCreate_Entry	 WPP_DEFINE_MSG_ID(0,58)
#  define MSG_ID_DfsFsdCreate_Exit	 WPP_DEFINE_MSG_ID(0,59)
#  define MSG_ID_DfsOpenDevice_Error_BadDisposition	 WPP_DEFINE_MSG_ID(0,62)
#  define MSG_ID_DfsOpenDevice_Error_CannotOpenAsDirectory	 WPP_DEFINE_MSG_ID(0,63)
#  define MSG_ID_DfsOpenDevice_Error_FileInUse	 WPP_DEFINE_MSG_ID(0,64)
#  define MSG_ID_DfsOpenDevice_Error_IoCheckShareAccess	 WPP_DEFINE_MSG_ID(0,65)
#  define MSG_ID_DfsOplockRequest_Error_IoCallDriver	 WPP_DEFINE_MSG_ID(0,89)
#  define MSG_ID_DfsPassThroughRelativeOpen_Error_IoCallDriver	 WPP_DEFINE_MSG_ID(0,66)
#  define MSG_ID_DfsRerouteOpenToMup_Error_NameTooLong	 WPP_DEFINE_MSG_ID(0,68)
#  define MSG_ID_DfsUserFsctl_Error_IoCallDriver	 WPP_DEFINE_MSG_ID(0,88)
#  define MSG_ID_DfsVolumePassThrough_Entry	 WPP_DEFINE_MSG_ID(0,10)
#  define MSG_ID_DfsVolumePassThrough_Error1	 WPP_DEFINE_MSG_ID(0,12)
#  define MSG_ID_DfsVolumePassThrough_Error2	 WPP_DEFINE_MSG_ID(0,13)
#  define MSG_ID_DfsVolumePassThrough_Error_IoCallDriver	 WPP_DEFINE_MSG_ID(0,11)
#  define MSG_ID_DfsVolumePassThrough_Exit	 WPP_DEFINE_MSG_ID(0,14)
#  define MSG_ID_DnrGetAuthenticatedConnection_Error_ObReferenceObjectByHandle	 WPP_DEFINE_MSG_ID(0,82)
#  define MSG_ID_DnrGetAuthenticatedConnection_Error_ZwCreateFile	 WPP_DEFINE_MSG_ID(0,81)
#  define MSG_ID_DnrNameResolve_Error3	 WPP_DEFINE_MSG_ID(0,75)
#  define MSG_ID_DnrNameResolve_Error_IoCallDriver	 WPP_DEFINE_MSG_ID(0,77)
#  define MSG_ID_DnrNameResolve_Error_ObReferenceObjectByHandle	 WPP_DEFINE_MSG_ID(0,76)
#  define MSG_ID_DnrNameResolve_Error_SeImpersonateClientEx	 WPP_DEFINE_MSG_ID(0,73)
#  define MSG_ID_DnrNameResolve_TopOfLoop	 WPP_DEFINE_MSG_ID(0,74)
#  define MSG_ID_DnrRedirectFileOpen_BeforeIoCallDriver	 WPP_DEFINE_MSG_ID(0,79)
#  define MSG_ID_DnrRedirectFileOpen_Entry	 WPP_DEFINE_MSG_ID(0,78)
#  define MSG_ID_DnrRedirectFileOpen_Error_IoCallDriver	 WPP_DEFINE_MSG_ID(0,80)
#  define MSG_ID_DnrStartNameResolution_Entry	 WPP_DEFINE_MSG_ID(0,69)
#  define MSG_ID_DnrStartNameResolution_Error2	 WPP_DEFINE_MSG_ID(0,71)
#  define MSG_ID_DnrStartNameResolution_Error_NameTooLong	 WPP_DEFINE_MSG_ID(0,70)
#  define MSG_ID_DnrStartNameResolution_Error_SeCreateClientSecurity	 WPP_DEFINE_MSG_ID(0,72)
#  define MSG_ID_MupCleanup_Entry	 WPP_DEFINE_MSG_ID(0,18)
#  define MSG_ID_MupCleanup_Error1	 WPP_DEFINE_MSG_ID(0,20)
#  define MSG_ID_MupCleanup_Error_FileClosed	 WPP_DEFINE_MSG_ID(0,19)
#  define MSG_ID_MupCleanup_Exit	 WPP_DEFINE_MSG_ID(0,21)
#  define MSG_ID_MupClose_Entry	 WPP_DEFINE_MSG_ID(0,22)
#  define MSG_ID_MupClose_Error1	 WPP_DEFINE_MSG_ID(0,23)
#  define MSG_ID_MupClose_Error2	 WPP_DEFINE_MSG_ID(0,24)
#  define MSG_ID_MupClose_Exit	 WPP_DEFINE_MSG_ID(0,25)
#  define MSG_ID_MupCreate_Entry	 WPP_DEFINE_MSG_ID(0,27)
#  define MSG_ID_MupCreate_Error_CreateRedirectedFile	 WPP_DEFINE_MSG_ID(0,30)
#  define MSG_ID_MupCreate_Error_DfsFsdCreate	 WPP_DEFINE_MSG_ID(0,28)
#  define MSG_ID_MupCreate_Error_OpenMupFileSystem	 WPP_DEFINE_MSG_ID(0,29)
#  define MSG_ID_MupCreate_Exit	 WPP_DEFINE_MSG_ID(0,31)
#  define MSG_ID_MupDereferenceMasterQueryContext_CompleteRequest	 WPP_DEFINE_MSG_ID(0,17)
#  define MSG_ID_MupDereferenceMasterQueryContext_RerouteOpen	 WPP_DEFINE_MSG_ID(0,16)
#  define MSG_ID_MupFsControl_Entry	 WPP_DEFINE_MSG_ID(0,85)
#  define MSG_ID_MupFsControl_Exit	 WPP_DEFINE_MSG_ID(0,86)
#  define MSG_ID_MupRemoveKnownPrefixEntry	 WPP_DEFINE_MSG_ID(0,53)
#  define MSG_ID_MupRerouteOpenToDfs_Entry	 WPP_DEFINE_MSG_ID(0,44)
#  define MSG_ID_MupRerouteOpenToDfs_Error1	 WPP_DEFINE_MSG_ID(0,45)
#  define MSG_ID_MupRerouteOpenToDfs_Error2	 WPP_DEFINE_MSG_ID(0,46)
#  define MSG_ID_MupRerouteOpen_Error1	 WPP_DEFINE_MSG_ID(0,42)
#  define MSG_ID_MupRerouteOpen_Error2	 WPP_DEFINE_MSG_ID(0,43)
#  define MSG_ID_OpenMupFileSystem_Entry	 WPP_DEFINE_MSG_ID(0,32)
#  define MSG_ID_OpenMupFileSystem_Error_IoCheckShareAccess	 WPP_DEFINE_MSG_ID(0,33)
#  define MSG_ID_OpenMupFileSystem_Exit	 WPP_DEFINE_MSG_ID(0,34)
#  define MSG_ID_PktPostSystemWork_Error_KeWaitForSingleObject	 WPP_DEFINE_MSG_ID(0,115)
#  define MSG_ID_PktpCheckReferralNetworkAddress_Error_NullServerName	 WPP_DEFINE_MSG_ID(0,105)
#  define MSG_ID_PktpCheckReferralNetworkAddress_Error_ShareNameNotFound	 WPP_DEFINE_MSG_ID(0,108)
#  define MSG_ID_PktpCheckReferralNetworkAddress_Error_ShareNameZeroLength	 WPP_DEFINE_MSG_ID(0,107)
#  define MSG_ID_PktpCheckReferralNetworkAddress_Error_TooShortToBeValid	 WPP_DEFINE_MSG_ID(0,104)
#  define MSG_ID_PktpCheckReferralNetworkAddress_Error_ZeroLengthShareName	 WPP_DEFINE_MSG_ID(0,106)
#  define MSG_ID_PktpCheckReferralString_Error	 WPP_DEFINE_MSG_ID(0,103)
#  define MSG_ID_PktpCheckReferralString_Error_StringNotWordAlligned	 WPP_DEFINE_MSG_ID(0,102)
#  define MSG_ID_PktpCheckReferralSyntax_Error_InvalidBuffer2	 WPP_DEFINE_MSG_ID(0,99)
#  define MSG_ID_PktpCheckReferralSyntax_Error_InvalidBuffer3	 WPP_DEFINE_MSG_ID(0,100)
#  define MSG_ID_PktpCheckReferralSyntax_Error_InvalidBuffer4	 WPP_DEFINE_MSG_ID(0,101)
#  define MSG_ID_QueryPathCompletionRoutine_Enter	 WPP_DEFINE_MSG_ID(0,52)
#  define MSG_ID_ReplFindFirstProvider_Error_NotFound	 WPP_DEFINE_MSG_ID(0,116)
#  define MSG_ID_TSGetRequestorSessionId_Error1	 WPP_DEFINE_MSG_ID(0,26)
#  define MSG_ID__PktExpandSpecialName_Error_DCNameNotInitialized	 WPP_DEFINE_MSG_ID(0,111)
#  define MSG_ID__PktExpandSpecialName_Error_ExAllocatePoolWithTag	 WPP_DEFINE_MSG_ID(0,112)
#  define MSG_ID__PktExpandSpecialName_Error_NoSpecialReferralTable	 WPP_DEFINE_MSG_ID(0,109)
#  define MSG_ID__PktExpandSpecialName_Error_NotInSpecialReferralTable	 WPP_DEFINE_MSG_ID(0,110)
#  define MSG_ID__PktExpandSpecialName_Error_UnableToOpenRdr	 WPP_DEFINE_MSG_ID(0,113)
#  define MSG_ID__PktExpandSpecialName_Error_ZwFsControlFile	 WPP_DEFINE_MSG_ID(0,114)
#  define MSG_ID__PktGetReferral_Error_ExallocatePoolWithTag	 WPP_DEFINE_MSG_ID(0,97)
#  define MSG_ID__PktGetReferral_Error_UnableToOpenRdr	 WPP_DEFINE_MSG_ID(0,96)
#  define MSG_ID__PktGetReferral_Error_ZwFsControlFile	 WPP_DEFINE_MSG_ID(0,98)


// end WPP stuff

            
#define WML_ID(_id)    ((MSG_ID_ ## _id) & 0xFF)
#define WML_GUID(_id)  ((MSG_ID_ ## _id) >> 8)
            

extern WML_CONTROL_GUID_REG _MupDrv_ControlGuids[];


//
// Reserved Guids
//
// 
// 
// 
// 
//    
// 6dfa04f0-cf82-426e-ae9e-735f72faa11d
// 5b5f4066-b952-48b5-a4cf-86c942a06968
// 1fd9a84a-6373-4e6c-be34-c16013e3cb07
// d621eecd-6863-4fc4-bb14-80e652739fcf

#endif /* __MUP_MUPWML_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mup\pkt.c ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:       PKT.C
//
//  Contents:   This module implements the Partition Knowledge Table routines
//              for the Dfs driver.
//
//  Functions:  PktInitialize -
//              PktInitializeLocalPartition -
//              RemoveLastComponent -
//              PktCreateEntry -
//              PktCreateDomainEntry -
//              PktCreateSubordinateEntry -
//              PktLookupEntryById -
//              PktEntryModifyPrefix -
//              PktLookupEntryByPrefix -
//              PktLookupEntryByUid -
//              PktLookupReferralEntry -
//              PktTrimSubordinates -
//              PktpRecoverLocalPartition -
//              PktpValidateLocalPartition -
//              PktCreateEntryFromReferral -
//              PktExpandSpecialEntryFromReferral -
//              PktCreateSpecialEntryTableFromReferral -
//              PktGetSpecialReferralTable -
//              PktpAddEntry -
//              PktExpandSpecialName -
//              PktParsePath -
//              PktLookupSpecialNameEntry -
//              PktCreateSpecialNameEntry -
//              PktGetReferral -
//              DfspSetActiveServiceByServerName -
//
//  History:     5 May 1992 PeterCo Created.
//
//-----------------------------------------------------------------------------


#include "dfsprocs.h"
#include <smbtypes.h>
#include <smbtrans.h>

#include "dnr.h"
#include "log.h"
#include "know.h"
#include "mupwml.h"

#include "wincred.h"

#include <netevent.h>


#define Dbg              (DEBUG_TRACE_PKT)

//
// These should come from ntos\inc\ps.h, but
// there are #define conflicts
//

BOOLEAN
PsDisableImpersonation(
    IN PETHREAD Thread,
    IN PSE_IMPERSONATION_STATE ImpersonationState);

VOID
PsRestoreImpersonation(
    IN PETHREAD Thread,
    IN PSE_IMPERSONATION_STATE ImpersonationState);

BOOLEAN
DfspIsSysVolShare(
    PUNICODE_STRING ShareName);


//
//  Local procedure prototypes
//

NTSTATUS
PktpCheckReferralSyntax(
    IN PUNICODE_STRING ReferralPath,
    IN PRESP_GET_DFS_REFERRAL ReferralBuffer,
    IN DWORD ReferralSize);

NTSTATUS
PktpCheckReferralString(
    IN LPWSTR String,
    IN PCHAR ReferralBuffer,
    IN PCHAR ReferralBufferEnd);

NTSTATUS
PktpCheckReferralNetworkAddress(
    IN PWCHAR Address,
    IN ULONG MaxLength);

NTSTATUS
PktpCreateEntryIdFromReferral(
    IN PRESP_GET_DFS_REFERRAL Ref,
    IN PUNICODE_STRING ReferralPath,
    OUT ULONG *MatchingLength,
    OUT PDFS_PKT_ENTRY_ID Peid);

NTSTATUS
PktpAddEntry (
    IN PDFS_PKT Pkt,
    IN PDFS_PKT_ENTRY_ID EntryId,
    IN PRESP_GET_DFS_REFERRAL ReferralBuffer,
    IN ULONG CreateDisposition,
    IN PDFS_TARGET_INFO pDfsTargetInfo,
    OUT PDFS_PKT_ENTRY  *ppPktEntry);

PDS_MACHINE
PktpGetDSMachine(
    IN PUNICODE_STRING ServerName);

VOID
PktShuffleServiceList(
    PDFS_PKT_ENTRY_INFO pInfo);

NTSTATUS
DfspSetServiceListToDc(
    PDFS_PKT_ENTRY pktEntry);

VOID
PktShuffleSpecialEntryList(
    PDFS_SPECIAL_ENTRY pSpecialEntry);

VOID
PktSetSpecialEntryListToDc(
    PDFS_SPECIAL_ENTRY pSpecialEntry);

VOID
PktShuffleGroup(
    PDFS_PKT_ENTRY_INFO pInfo,
    ULONG       nStart,
    ULONG       nEnd);

NTSTATUS
PktGetReferral(
    IN PUNICODE_STRING MachineName,
    IN PUNICODE_STRING DomainName,
    IN PUNICODE_STRING ShareName,
    IN BOOLEAN         CSCAgentCreate);

NTSTATUS
DfspSetActiveServiceByServerName(
    PUNICODE_STRING ServerName,
    PDFS_PKT_ENTRY pktEntry);

BOOLEAN
DfspIsDupPktEntry(
    PDFS_PKT_ENTRY ExistingEntry,
    ULONG EntryType,
    PDFS_PKT_ENTRY_ID EntryId,
    PDFS_PKT_ENTRY_INFO EntryInfo);

BOOLEAN
DfspIsDupSvc(
    PDFS_SERVICE pS1,
    PDFS_SERVICE pS2);

VOID
PktFlushChildren(
    PDFS_PKT_ENTRY pEntry);

BOOLEAN
DfspDnsNameToFlatName(
    PUNICODE_STRING DnsName,
    PUNICODE_STRING FlatName);

NTSTATUS
DfsGetLMRTargetInfo(
    HANDLE IpcHandle,
    PDFS_TARGET_INFO *ppTargetInfo );

NTSTATUS 
PktCreateTargetInfo(
    PUNICODE_STRING pDomainName,
    PUNICODE_STRING pShareName,
    BOOLEAN SpecialName,
    PDFS_TARGET_INFO *ppDfsTargetInfo );

DWORD PktLastReferralStatus = 0;


#ifdef ALLOC_PRAGMA
#pragma alloc_text( INIT, PktInitialize )
#pragma alloc_text( PAGE, PktUninitialize )

#pragma alloc_text( PAGE, RemoveLastComponent )
#pragma alloc_text( PAGE, PktCreateEntry )
#pragma alloc_text( PAGE, PktCreateDomainEntry )
#pragma alloc_text( PAGE, PktEntryModifyPrefix )
#pragma alloc_text( PAGE, PktLookupEntryByPrefix )
#pragma alloc_text( PAGE, PktLookupEntryByUid )
#pragma alloc_text( PAGE, PktLookupReferralEntry )
#pragma alloc_text( PAGE, PktCreateEntryFromReferral )
#pragma alloc_text( PAGE, PktExpandSpecialEntryFromReferral )
#pragma alloc_text( PAGE, PktpCheckReferralSyntax )
#pragma alloc_text( PAGE, PktpCheckReferralString )
#pragma alloc_text( PAGE, PktpCheckReferralNetworkAddress )
#pragma alloc_text( PAGE, PktpCreateEntryIdFromReferral )
#pragma alloc_text( PAGE, PktpAddEntry )
#pragma alloc_text( PAGE, PktExpandSpecialName )
#pragma alloc_text( PAGE, PktpGetDSMachine )
#pragma alloc_text( PAGE, PktShuffleServiceList )
#pragma alloc_text( PAGE, DfspSetServiceListToDc )
#pragma alloc_text( PAGE, PktShuffleSpecialEntryList )
#pragma alloc_text( PAGE, PktSetSpecialEntryListToDc )
#pragma alloc_text( PAGE, PktShuffleGroup )
#pragma alloc_text( PAGE, PktParsePath )
#pragma alloc_text( PAGE, PktLookupSpecialNameEntry )
#pragma alloc_text( PAGE, PktCreateSpecialNameEntry )
#pragma alloc_text( PAGE, PktGetSpecialReferralTable )
#pragma alloc_text( PAGE, PktCreateSpecialEntryTableFromReferral )
#pragma alloc_text( PAGE, DfspSetActiveServiceByServerName )
#pragma alloc_text( PAGE, DfspIsDupPktEntry )
#pragma alloc_text( PAGE, DfspIsDupSvc )
#pragma alloc_text( PAGE, DfspDnsNameToFlatName )
#pragma alloc_text( PAGE, PktpUpdateSpecialTable)
#pragma alloc_text( PAGE, PktFindEntryByPrefix )

#endif // ALLOC_PRAGMA

//
// declare the global null guid
//
GUID _TheNullGuid;

//
// If we are in a workgroup, there's no use in trying to contact the DC!
//
BOOLEAN MupInAWorkGroup = FALSE;


#define SpcIsRecoverableError(x)  ( (x) == STATUS_IO_TIMEOUT ||               \
                                    (x) == STATUS_REMOTE_NOT_LISTENING ||     \
                                    (x) == STATUS_VIRTUAL_CIRCUIT_CLOSED ||   \
                                    (x) == STATUS_BAD_NETWORK_PATH ||         \
                                    (x) == STATUS_NETWORK_BUSY ||             \
                                    (x) == STATUS_INVALID_NETWORK_RESPONSE || \
                                    (x) == STATUS_UNEXPECTED_NETWORK_ERROR || \
                                    (x) == STATUS_NETWORK_NAME_DELETED ||     \
                                    (x) == STATUS_BAD_NETWORK_NAME ||         \
                                    (x) == STATUS_REQUEST_NOT_ACCEPTED ||     \
                                    (x) == STATUS_DISK_OPERATION_FAILED ||    \
                                    (x) == STATUS_NETWORK_UNREACHABLE ||      \
                                    (x) == STATUS_INSUFFICIENT_RESOURCES ||   \
                                    (x) == STATUS_SHARING_PAUSED ||           \
                                    (x) == STATUS_DFS_UNAVAILABLE ||          \
                                    (x) == STATUS_DEVICE_OFF_LINE ||          \
                                    (x) == STATUS_NETLOGON_NOT_STARTED        \
                                  )

//+-------------------------------------------------------------------------
//
//  Function:   PktInitialize, public
//
//  Synopsis:   PktInitialize initializes the partition knowledge table.
//
//  Arguments:  [Pkt] - pointer to an uninitialized PKT
//
//  Returns:    NTSTATUS - STATUS_SUCCESS if no error.
//
//  Notes:      This routine is called only at driver init time.
//
//--------------------------------------------------------------------------

NTSTATUS
PktInitialize(
    IN  PDFS_PKT Pkt
) {
    PDFS_SPECIAL_TABLE pSpecialTable = &Pkt->SpecialTable;

    DfsDbgTrace(+1, Dbg, "PktInitialize: Entered\n", 0);

    //
    // initialize the NULL GUID.
    //
    RtlZeroMemory(&_TheNullGuid, sizeof(GUID));

    //
    // Always zero the pkt first
    //
    RtlZeroMemory(Pkt, sizeof(DFS_PKT));

    //
    // do basic initialization
    //
    Pkt->NodeTypeCode = DSFS_NTC_PKT;
    Pkt->NodeByteSize = sizeof(DFS_PKT);
    ExInitializeResourceLite(&Pkt->Resource);
    InitializeListHead(&Pkt->EntryList);
    DfsInitializeUnicodePrefix(&Pkt->PrefixTable);
    DfsInitializeUnicodePrefix(&Pkt->ShortPrefixTable);
    RtlInitializeUnicodePrefix(&Pkt->DSMachineTable);
    Pkt->EntryTimeToLive = MAX_REFERRAL_LIFE_TIME;

    InitializeListHead(&pSpecialTable->SpecialEntryList);

    DfsDbgTrace(-1, Dbg, "PktInitialize: Exit -> VOID\n", 0 );
    return STATUS_SUCCESS;
}

//+-------------------------------------------------------------------------
//
//  Function:   PktUninitialize, public
//
//  Synopsis:   PktUninitialize uninitializes the partition knowledge table.
//
//  Arguments:  [Pkt] - pointer to an initialized PKT
//
//  Returns:    None
//
//  Notes:      This routine is called only at driver unload time
//
//--------------------------------------------------------------------------
VOID
PktUninitialize(
    IN  PDFS_PKT Pkt
    )
{
    DfsFreePrefixTable(&Pkt->PrefixTable);
    DfsFreePrefixTable(&Pkt->ShortPrefixTable);
    ExDeleteResourceLite(&Pkt->Resource);
}


//+-------------------------------------------------------------------------
//
//  Function:   RemoveLastComponent, public
//
//  Synopsis:   Removes the last component of the string passed.
//
//  Arguments:  [Prefix] -- The prefix whose last component is to be returned.
//              [newPrefix] -- The new Prefix with the last component removed.
//
//  Returns:    NTSTATUS - STATUS_SUCCESS if no error.
//
//  Notes:      On return, the newPrefix points to the same memory buffer
//              as Prefix.
//
//--------------------------------------------------------------------------

void
RemoveLastComponent(
    PUNICODE_STRING     Prefix,
    PUNICODE_STRING     newPrefix
)
{
    PWCHAR      pwch;
    USHORT      i=0;

    *newPrefix = *Prefix;

    pwch = newPrefix->Buffer;
    pwch += (Prefix->Length/sizeof(WCHAR)) - 1;

    while ((*pwch != UNICODE_PATH_SEP) && (pwch != newPrefix->Buffer))  {
        i += sizeof(WCHAR);
        pwch--;
    }

    newPrefix->Length = newPrefix->Length - i;
}



//+-------------------------------------------------------------------------
//
//  Function:   PktCreateEntry, public
//
//  Synopsis:   PktCreateEntry creates a new partition table entry or
//              updates an existing one.  The PKT must be acquired
//              exclusively for this operation.
//
//  Arguments:  [Pkt] - pointer to an initialized (and exclusively acquired) PKT
//              [PktEntryType] - the type of entry to create/update.
//              [PktEntryId] - pointer to the Id of the entry to create
//              [PktEntryInfo] - pointer to the guts of the entry
//              [CreateDisposition] - specifies whether to overwrite if
//                  an entry already exists, etc.
//              [ppPktEntry] - the new entry is placed here.
//
//  Returns:    [STATUS_SUCCESS] - if all is well.
//
//              [DFS_STATUS_NO_SUCH_ENTRY] -  the create disposition was
//                  set to PKT_REPLACE_ENTRY and no entry of the specified
//                  Id exists to replace.
//
//              [DFS_STATUS_ENTRY_EXISTS] - a create disposition of
//                  PKT_CREATE_ENTRY was specified and an entry of the
//                  specified Id already exists.
//
//              [DFS_STATUS_LOCAL_ENTRY] - creation of the entry would
//                  required the invalidation of a local entry or exit point.
//
//              [STATUS_INVALID_PARAMETER] - the Id specified for the
//                  new entry is invalid.
//
//              [STATUS_INSUFFICIENT_RESOURCES] - not enough memory was
//                  available to complete the operation.
//
//  Notes:      The PktEntryId and PktEntryInfo structures are MOVED (not
//              COPIED) to the new entry.  The memory used for UNICODE_STRINGS
//              and DFS_SERVICE arrays is used by the new entry.  The
//              associated fields in the PktEntryId and PktEntryInfo
//              structures passed as arguments are Zero'd to indicate that
//              the memory has been "deallocated" from these strutures and
//              reallocated to the newly created PktEntry.  Note that this
//              routine does not deallocate the PktEntryId structure or
//              the PktEntryInfo structure itself. On successful return from
//              this function, the PktEntryId structure will be modified
//              to have a NULL Prefix entry, and the PktEntryInfo structure
//              will be modified to have zero services and a null ServiceList
//              entry.
//
//--------------------------------------------------------------------------
NTSTATUS
PktCreateEntry(
    IN  PDFS_PKT Pkt,
    IN  ULONG PktEntryType,
    IN  PDFS_PKT_ENTRY_ID PktEntryId,
    IN  PDFS_PKT_ENTRY_INFO PktEntryInfo OPTIONAL,
    IN  ULONG CreateDisposition,
    IN  PDFS_TARGET_INFO pDfsTargetInfo,
    OUT PDFS_PKT_ENTRY *ppPktEntry)
{
    NTSTATUS status = STATUS_SUCCESS;
    PDFS_PKT_ENTRY pfxMatchEntry = NULL;
    PDFS_PKT_ENTRY uidMatchEntry = NULL;
    PDFS_PKT_ENTRY entryToUpdate = NULL;
    PDFS_PKT_ENTRY entryToInvalidate = NULL;
    PDFS_PKT_ENTRY SupEntry = NULL;
    UNICODE_STRING remainingPath, newRemainingPath;

    ASSERT(ARGUMENT_PRESENT(Pkt) &&
           ARGUMENT_PRESENT(PktEntryId) &&
           ARGUMENT_PRESENT(ppPktEntry));

    DfsDbgTrace(+1, Dbg, "PktCreateEntry: Entered\n", 0);

    RtlZeroMemory(&remainingPath, sizeof(UNICODE_STRING));
    RtlZeroMemory(&newRemainingPath, sizeof(UNICODE_STRING));

    //
    // We're pessimistic at first...
    //

    *ppPktEntry = NULL;

    //
    // See if there exists an entry with this prefix.  The prefix
    // must match exactly (i.e. No remaining path).
    //

    pfxMatchEntry = PktLookupEntryByPrefix(Pkt,
                                           &PktEntryId->Prefix,
                                           &remainingPath);

    if (remainingPath.Length > 0)       {
        SupEntry = pfxMatchEntry;
        pfxMatchEntry = NULL;
    } else {
        UNICODE_STRING newPrefix;

        RemoveLastComponent(&PktEntryId->Prefix, &newPrefix);
        SupEntry = PktLookupEntryByPrefix(Pkt,
                                          &newPrefix,
                                          &newRemainingPath);
    }


    //
    // Now search for an entry that has the same Uid.
    //

    uidMatchEntry = PktLookupEntryByUid(Pkt, &PktEntryId->Uid);

    //
    // Now we must determine if during this create, we are going to be
    // updating or invalidating any existing entries.  If an existing
    // entry is found that has the same Uid as the one we are trying to
    // create, the entry becomes a target for "updating".  If the Uid
    // passed in is NULL, then we check to see if an entry exists that
    // has a NULL Uid AND a Prefix that matches.  If this is the case,
    // that entry becomes the target for "updating".
    //
    // To determine if there is an entry to invalidate, we look for an
    // entry with the same Prefix as the one we are trying to create, BUT,
    // which has a different Uid.  If we detect such a situation, we
    // we make the entry with the same Prefix the target for invalidation
    // (we do not allow two entries with the same Prefix, and we assume
    // that the new entry takes precedence).
    //

    if (uidMatchEntry != NULL) {

        entryToUpdate = uidMatchEntry;

        if (pfxMatchEntry != uidMatchEntry)
            entryToInvalidate = pfxMatchEntry;

    } else if ((pfxMatchEntry != NULL) &&
              NullGuid(&pfxMatchEntry->Id.Uid)) {

        //
        // This should go away once we don't have any NULL guids at all in
        // the driver. 
        //
        entryToUpdate = pfxMatchEntry;

    } else {

        entryToInvalidate = pfxMatchEntry;

    }

    //
    // Now we check to make sure that our create disposition is
    // consistent with what we are about to do.
    //

    if ((CreateDisposition & PKT_ENTRY_CREATE) && entryToUpdate != NULL) {

        *ppPktEntry = entryToUpdate;

        status = DFS_STATUS_ENTRY_EXISTS;

    } else if ((CreateDisposition & PKT_ENTRY_REPLACE) && entryToUpdate==NULL) {

        status = DFS_STATUS_NO_SUCH_ENTRY;
    }

    //
    //  if we have an error here we can get out now!
    //

    if (!NT_SUCCESS(status)) {

        DfsDbgTrace(-1, Dbg, "PktCreateEntry: Exit -> %08lx\n", ULongToPtr(status) );
        return status;
    }

#if DBG
    if (MupVerbose)
        DbgPrint("  #####CreateDisposition=0x%x, entryToUpdate=[%wZ], PktEntryInfo=0x%x\n",
                        CreateDisposition,
                        &entryToUpdate->Id.Prefix,
                        PktEntryInfo);
#endif

    //
    // If this entry is a dup of the one we will want to replace,
    // simply up the timeout on the existing, destroy the new,
    // then return.
    //
    if (DfspIsDupPktEntry(entryToUpdate, PktEntryType, PktEntryId, PktEntryInfo) == TRUE) {
#if DBG
        if (MupVerbose)
            DbgPrint("  ****DUPLICATE PKT ENTRY!!\n");
#endif
        PktEntryIdDestroy(PktEntryId, FALSE);
        PktEntryInfoDestroy(PktEntryInfo, FALSE);
        entryToUpdate->ExpireTime = 60;
        entryToUpdate->TimeToLive = 60;
        DfspSetServiceListToDc(entryToUpdate);
        (*ppPktEntry) = entryToUpdate;
        DfsDbgTrace(-1, Dbg, "PktCreateEntry: Exit -> %08lx\n", ULongToPtr(status) );
        return status;
    }

    //
    // At this point we must insure that we are not going to
    // be invalidating any local partition entries.
    //

    if ((entryToInvalidate != NULL) &&
        (!(entryToInvalidate->Type &  PKT_ENTRY_TYPE_OUTSIDE_MY_DOM) ) &&
        (entryToInvalidate->Type &
         (PKT_ENTRY_TYPE_LOCAL |
          PKT_ENTRY_TYPE_LOCAL_XPOINT |
          PKT_ENTRY_TYPE_PERMANENT))) {

        DfsDbgTrace(-1, Dbg, "PktCreateEntry: Exit -> %08lx\n",
                    ULongToPtr(DFS_STATUS_LOCAL_ENTRY) );
        return DFS_STATUS_LOCAL_ENTRY;
    }

    //
    // We go up the links till we reach a REFERRAL entry type. Actually
    // we may never go up since we always link to a REFERRAL entry. Anyway
    // no harm done!
    //

    while ((SupEntry != NULL) &&
           !(SupEntry->Type & PKT_ENTRY_TYPE_REFERRAL_SVC))  {
        SupEntry = SupEntry->ClosestDC;
    }

    //
    // If we had success then we need to see if we have to
    // invalidate an entry.
    //

    if (NT_SUCCESS(status) && entryToInvalidate != NULL) {
	if (entryToInvalidate->UseCount != 0) {
	    DbgPrint("PktEntryReassemble: Destroying in use pkt entry %x, usecount %x\n", 
		     entryToInvalidate, entryToInvalidate->UseCount);
	}
	PktEntryDestroy(entryToInvalidate, Pkt, (BOOLEAN)TRUE);
    }

    //
    // If we are not updating an entry we must construct a new one
    // from scratch.  Otherwise we need to update.
    //

    if (entryToUpdate != NULL) {

        status = PktEntryReassemble(entryToUpdate,
                                    Pkt,
                                    PktEntryType,
                                    PktEntryId,
                                    PktEntryInfo,
                                    pDfsTargetInfo);

        if (NT_SUCCESS(status))  {
            (*ppPktEntry) = entryToUpdate;
            PktEntryLinkChild(SupEntry, entryToUpdate);
        }
    } else {

        //
        // Now we are going to create a new entry. So we have to set
        // the ClosestDC Entry pointer while creating this entry. The
        // ClosestDC entry value is already in SupEntry.
        //

        PDFS_PKT_ENTRY newEntry;

        newEntry = (PDFS_PKT_ENTRY) ExAllocatePoolWithTag(
                                                   PagedPool,
                                                   sizeof(DFS_PKT_ENTRY),
                                                   ' puM');
        if (newEntry == NULL) {
            status = STATUS_INSUFFICIENT_RESOURCES;
        } else {
            status = PktEntryAssemble(newEntry,
                                      Pkt,
                                      PktEntryType,
                                      PktEntryId,
                                      PktEntryInfo,
                                      pDfsTargetInfo);
            if (!NT_SUCCESS(status)) {
                ExFreePool(newEntry);
            } else {
                (*ppPktEntry) = newEntry;
                PktEntryLinkChild(SupEntry, newEntry);
            }
        }
    }

    DfsDbgTrace(-1, Dbg, "PktCreateEntry: Exit -> %08lx\n", ULongToPtr(status) );
    return status;
}


//+----------------------------------------------------------------------------
//
//  Function:   PktCreateDomainEntry
//
//  Synopsis:   Given a name that is thought to be a domain name, this routine
//              will create a Pkt Entry for the root of the domain's Dfs.
//              The domain must exist, must have a Dfs root, and must be
//              reachable for this routine to succeed.
//
//  Arguments:  [DomainName] -- Name of domain/machine thought to support a Dfs
//              [ShareName] -- Name of FtDfs or dfs share
//              [CSCAgentCreate] -- TRUE if this is a CSC agent create
//
//  Returns:    [STATUS_SUCCESS] -- Successfully completed operation.
//
//              Status from PktGetReferral
//
//-----------------------------------------------------------------------------

NTSTATUS
PktCreateDomainEntry(
    IN PUNICODE_STRING DomainName,
    IN PUNICODE_STRING ShareName,
    IN BOOLEAN         CSCAgentCreate)
{
    NTSTATUS status;
    PUNICODE_STRING MachineName;
    PDFS_SPECIAL_ENTRY pSpecialEntry = NULL;
    ULONG EntryIdx;
    ULONG Start;
    LARGE_INTEGER StartTime;
    LARGE_INTEGER EndTime;

    DfsDbgTrace(+1, Dbg, "PktCreateDomainEntry: DomainName %wZ \n", DomainName);
    DfsDbgTrace( 0, Dbg, "                      ShareName %wZ \n", ShareName);

    KeQuerySystemTime(&StartTime);

#if DBG
    if (MupVerbose) {
        KeQuerySystemTime(&EndTime);
        DbgPrint("[%d] PktCreateDomainEntry(%wZ,%wZ)\n",
                        (ULONG)((EndTime.QuadPart - StartTime.QuadPart)/(10 * 1000)),
                        DomainName,
                        ShareName);
    }
#endif

    //
    // See if machine name is really a domain name, if so
    // turn it into a DC name
    //

    status = PktExpandSpecialName(DomainName, &pSpecialEntry);

    if (NT_SUCCESS(status)) {

        //
        // Step through the DC list trying for a referral
        // Check the status returned - only continue on recoverable errors
        //
       
        Start = pSpecialEntry->Active;

        for (EntryIdx = Start; EntryIdx < pSpecialEntry->ExpandedCount; EntryIdx++) {

            MachineName = &pSpecialEntry->ExpandedNames[EntryIdx].ExpandedName;

            status = PktGetReferral(MachineName, DomainName, ShareName, CSCAgentCreate);

            if (!NT_SUCCESS(status) && SpcIsRecoverableError(status)) {

                continue;

            }

            break;

        }

        if (status != STATUS_NO_SUCH_DEVICE && !NT_SUCCESS(status) && Start > 0) {

            for (EntryIdx = 0; EntryIdx < Start; EntryIdx++) {

                MachineName = &pSpecialEntry->ExpandedNames[EntryIdx].ExpandedName;

                status = PktGetReferral(MachineName, DomainName, ShareName, CSCAgentCreate);

                if (!NT_SUCCESS(status) && SpcIsRecoverableError(status)) {

                    continue;

                }

                break;

            }

        }

        if (NT_SUCCESS(status) || status == STATUS_NO_SUCH_DEVICE) {

            pSpecialEntry->Active = EntryIdx;

        }

        InterlockedDecrement(&pSpecialEntry->UseCount);

    } else {

        status = PktGetReferral(DomainName, DomainName, ShareName, CSCAgentCreate);
        PktLastReferralStatus = status;

    }

    KeQuerySystemTime(&EndTime);

    DfsDbgTrace(-1, Dbg, "PktCreateDomainEntry: Exit -> %08lx\n", ULongToPtr(status) );

#if DBG
    if (MupVerbose)
        DbgPrint("  [%d] DfsCreateDomainEntry returned %08lx\n",
                                (ULONG)((EndTime.QuadPart - StartTime.QuadPart)/(10 * 1000)),
                                status);
#endif

    return status;

}

//+----------------------------------------------------------------------------
//
//  Function:   PktGetReferral -- helper for PktCreateDomainEntry
//
//  Synopsis:   Ask [MachineName] for referral for \DomainName\ShareName
//
//  Arguments:  [MachineName] -- Name of machine to submit referral request to
//              [DomainName] -- Name of domain/machine thought to support a Dfs
//              [ShareName] -- Name of FtDfs or dfs share
//              [CSCAgentCreate] -- TRUE if this is a CSC agent create
//
//  Returns:    [STATUS_SUCCESS] -- Successfully completed operation.
//
//              [STATUS_INSUFFICIENT_RESOURCES] -- Unable to allocate memory.
//              [BAD_NETWORK_PATH] -- Unable to allocate provider
//              [STATUS_INVALID_NETWORK_RESPONSE] -- Bad referral
//
//-----------------------------------------------------------------------------

NTSTATUS
_PktGetReferral(
    IN PUNICODE_STRING MachineName, // Machine to direct referral to
    IN PUNICODE_STRING DomainName,  // the machine or domain name to use
    IN PUNICODE_STRING ShareName,   // the ftdfs or dfs name
    IN BOOLEAN         CSCAgentCreate) // the CSC agent create flag
{
    NTSTATUS status;
    HANDLE hServer = NULL;
    DFS_SERVICE service;
    PPROVIDER_DEF provider;
    PREQ_GET_DFS_REFERRAL ref = NULL;
    ULONG refSize = 0;
    ULONG type, matchLength;
    UNICODE_STRING refPath;
    IO_STATUS_BLOCK iosb;
    PDFS_PKT_ENTRY pktEntry;
    BOOLEAN attachedToSystemProcess = FALSE;
    BOOLEAN pktLocked;
    KAPC_STATE ApcState;
    ULONG MaxReferralLength;
    ULONG i;
    SE_IMPERSONATION_STATE DisabledImpersonationState;
    BOOLEAN RestoreImpersonationState = FALSE;
    LARGE_INTEGER StartTime;
    LARGE_INTEGER EndTime;

    PDFS_TARGET_INFO pDfsTargetInfo = NULL;

    DfsDbgTrace(+1, Dbg, "PktGetReferral: MachineName %wZ \n", MachineName);
    DfsDbgTrace( 0, Dbg, "                DomainName %wZ \n", DomainName);
    DfsDbgTrace( 0, Dbg, "                ShareName %wZ \n", ShareName);

    KeQuerySystemTime(&StartTime);
#if DBG
    if (MupVerbose) {
        KeQuerySystemTime(&EndTime);
        DbgPrint("  [%d] PktGetReferral([%wZ]->[\\%wZ\\%wZ]\n",
                                (ULONG)((EndTime.QuadPart - StartTime.QuadPart)/(10 * 1000)),
                                MachineName,
                                DomainName,
                                ShareName);
    }
#endif

    //
    // Get a provider (LM rdr) and service (connection to a machine) describing the remote server.
    //

    provider = ReplLookupProvider( PROV_ID_MUP_RDR );

    if (provider == NULL) {
        DfsDbgTrace(-1, Dbg, "Unable to open LM Rdr!\n", 0);
#if DBG
        if (MupVerbose)
            DbgPrint("Unable to open LM Rdr returning STATUS_BAD_NETWORK_PATH\n", 0);
#endif
        if (DfsEventLog > 0)
            LogWriteMessage(LM_REDIR_FAILURE, 0, 0, NULL);
        
        status = STATUS_BAD_NETWORK_PATH;

        MUP_TRACE_HIGH(ERROR, _PktGetReferral_Error_UnableToOpenRdr,
                       LOGUSTR(*MachineName)
                       LOGUSTR(*DomainName)
                       LOGUSTR(*ShareName)
                       LOGBOOLEAN(CSCAgentCreate)
                       LOGSTATUS(status)); 

        return STATUS_BAD_NETWORK_PATH;
    }
    

    RtlZeroMemory( &service, sizeof(DFS_SERVICE) );

    status = PktServiceConstruct(
                &service,
                DFS_SERVICE_TYPE_MASTER | DFS_SERVICE_TYPE_REFERRAL,
                PROV_DFS_RDR,
                STATUS_SUCCESS,
                PROV_ID_MUP_RDR,
                MachineName,
                NULL);

    DfsDbgTrace(0, Dbg, "PktServiceConstruct returned %08lx\n", ULongToPtr(status) );

    //
    // Build a connection to this machine
    //

    if (NT_SUCCESS(status)) {
        PktAcquireShared( TRUE, &pktLocked );
        if (PsGetCurrentProcess() != DfsData.OurProcess) {
            KeStackAttachProcess( DfsData.OurProcess, &ApcState );
            attachedToSystemProcess = TRUE;
        }

        RestoreImpersonationState = PsDisableImpersonation(
                                        PsGetCurrentThread(),
                                        &DisabledImpersonationState);


	status = DfsCreateConnection(
			&service,
			provider,
			CSCAgentCreate,
			&hServer);

#if DBG
        if (MupVerbose) {
            KeQuerySystemTime(&EndTime);
            DbgPrint("  [%d] DfsCreateConnection returned 0x%x\n",
                                (ULONG)((EndTime.QuadPart - StartTime.QuadPart)/(10 * 1000)),
                                status);
        }
#endif
        if (!NT_SUCCESS(status) && DfsEventLog > 0)
            LogWriteMessage(DFS_CONNECTION_FAILURE, status, 1, MachineName);

        
        DfsDbgTrace(0, Dbg, "DfsCreateConnection returned %08lx\n", ULongToPtr(status) );
        
        if (status == STATUS_SUCCESS)
        {
            status = PktGetTargetInfo( hServer,
                                       DomainName,
                                       ShareName,
                                       &pDfsTargetInfo );
        }
        PktRelease();
        pktLocked = FALSE;

    }


    MaxReferralLength = MAX_REFERRAL_LENGTH;

Retry:

    RtlZeroMemory( &refPath, sizeof(UNICODE_STRING) );

    //
    // Build the referral request (\DomainName\ShareName)
    //

    if (NT_SUCCESS(status)) {
        ULONG ReferralSize = 0;

        refPath.Length = 0;
        refPath.MaximumLength = sizeof(UNICODE_PATH_SEP) +
                                    DomainName->Length +
                                        sizeof(UNICODE_PATH_SEP) +
                                            ShareName->Length +
                                                sizeof(UNICODE_NULL);

        ReferralSize = refPath.MaximumLength + sizeof(REQ_GET_DFS_REFERRAL);

        if (ReferralSize > MAX_REFERRAL_MAX) {
            status = STATUS_INVALID_PARAMETER;
        }
        else if (MaxReferralLength < ReferralSize)
        {
            MaxReferralLength = ReferralSize;
        }

        if (NT_SUCCESS(status)) {
            refPath.Buffer = ExAllocatePoolWithTag( NonPagedPool,
                                                    refPath.MaximumLength + MaxReferralLength,
                                                    ' puM');

            if (refPath.Buffer != NULL) {
                ref = (PREQ_GET_DFS_REFERRAL)&refPath.Buffer[refPath.MaximumLength / sizeof(WCHAR)];
                RtlAppendUnicodeToString( &refPath, UNICODE_PATH_SEP_STR);
                RtlAppendUnicodeStringToString( &refPath, DomainName);
                RtlAppendUnicodeToString( &refPath, UNICODE_PATH_SEP_STR);
                RtlAppendUnicodeStringToString( &refPath, ShareName );
                refPath.Buffer[ refPath.Length / sizeof(WCHAR) ] = UNICODE_NULL;
                ref->MaxReferralLevel = 3;

                RtlMoveMemory(
                    &ref->RequestFileName[0],
                    refPath.Buffer,
                    refPath.Length + sizeof(WCHAR));

                DfsDbgTrace(0, Dbg, "Referral Path : %ws\n", ref->RequestFileName);

                refSize = sizeof(USHORT) + refPath.Length + sizeof(WCHAR);

                DfsDbgTrace(0, Dbg, "Referral Size is %d bytes\n", ULongToPtr(refSize) );
            } else {

                DfsDbgTrace(0, Dbg, "Unable to allocate %d bytes\n",
                            ULongToPtr(refPath.MaximumLength + MaxReferralLength));
                status = STATUS_INSUFFICIENT_RESOURCES;
                MUP_TRACE_HIGH(ERROR, _PktGetReferral_Error_ExallocatePoolWithTag,
                               LOGUSTR(*MachineName)
                               LOGUSTR(*DomainName)
                               LOGUSTR(*ShareName)
                               LOGBOOLEAN(CSCAgentCreate)
                               LOGSTATUS(status));
            }
        }
    }

    //
    // Send the referral out
    //

    if (NT_SUCCESS(status)) {

        DfsDbgTrace(0, Dbg, "Ref Buffer @%08lx\n", ref);

        status = ZwFsControlFile(
                    hServer,                     // Target
                    NULL,                        // Event
                    NULL,                        // APC Routine
                    NULL,                        // APC Context,
                    &iosb,                       // Io Status block
                    FSCTL_DFS_GET_REFERRALS,     // FS Control code
                    (PVOID) ref,                 // Input Buffer
                    refSize,                     // Input Buffer Length
                    (PVOID) ref,                 // Output Buffer
                    MaxReferralLength);          // Output Buffer Length

        MUP_TRACE_ERROR_HIGH(status, ALL_ERROR, _PktGetReferral_Error_ZwFsControlFile,
                             LOGUSTR(*MachineName)
                             LOGUSTR(*DomainName)
                             LOGUSTR(*ShareName)
                             LOGBOOLEAN(CSCAgentCreate)
                             LOGSTATUS(status));

        DfsDbgTrace(0, Dbg, "Fscontrol returned %08lx\n", ULongToPtr(status) );
        KeQuerySystemTime(&EndTime);
#if DBG
        if (MupVerbose) {
            KeQuerySystemTime(&EndTime);
            DbgPrint("  [%d] ZwFsControlFile returned %08lx\n",
                                (ULONG)((EndTime.QuadPart - StartTime.QuadPart)/(10 * 1000)),
                                status);
        }
#endif 

    }

    //
    // ...and handle the response
    //

    if (NT_SUCCESS(status)) {
        status = PktCreateEntryFromReferral(
                    &DfsData.Pkt,
                    &refPath,
                    (ULONG)iosb.Information,
                    (PRESP_GET_DFS_REFERRAL) ref,
                    PKT_ENTRY_SUPERSEDE,
                    pDfsTargetInfo,
                    &matchLength,
                    &type,
                    &pktEntry);

        DfsDbgTrace(0, Dbg, "PktCreateEntryFromReferral returned %08lx\n", ULongToPtr(status) );
#if DBG
        if (MupVerbose)
            DbgPrint("  PktCreateEntryFromReferral returned %08lx\n", status);
#endif

    } else if (status == STATUS_BUFFER_OVERFLOW && (refPath.Buffer != NULL) && MaxReferralLength < MAX_REFERRAL_MAX) {

        //
        // The referral didn't fit in the buffer supplied.  Make it bigger and try
        // again.
        //

        DfsDbgTrace(0, Dbg, "PktGetSpecialReferralTable: MaxReferralLength %d too small\n",
                        ULongToPtr(MaxReferralLength) );

        ExFreePool(refPath.Buffer);
        refPath.Buffer = NULL;
        MaxReferralLength *= 2;
        if (MaxReferralLength > MAX_REFERRAL_MAX)
            MaxReferralLength = MAX_REFERRAL_MAX;
        status = STATUS_SUCCESS;
        goto Retry;

    } else if (status == STATUS_NO_SUCH_DEVICE) {

        UNICODE_STRING ustr;
        UNICODE_STRING RemPath;
        WCHAR *wCp = NULL;
        ULONG Size;
        PDFS_PKT_ENTRY pEntry = NULL;
        PDFS_PKT Pkt;
        BOOLEAN pktLocked;

        //
        // Check if there is a pkt entry (probably stale) that needs to be removed
        //
#if DBG
        if (MupVerbose)
            DbgPrint("  PktGetReferral: remove PKT entry for \\%wZ\\%wZ\n",
                    DomainName,
                    ShareName);
#endif

       Size = sizeof(WCHAR) +
                DomainName->Length +
                    sizeof(WCHAR) +
                        ShareName->Length;

       ustr.Buffer = ExAllocatePoolWithTag(
                            PagedPool,
                            Size,
                            ' puM');

       if (ustr.Buffer == NULL) {
            status = STATUS_INSUFFICIENT_RESOURCES;
       } else {
            wCp = ustr.Buffer;
            ustr.Length = (USHORT)Size;
            *wCp++ = UNICODE_PATH_SEP;
            RtlCopyMemory(wCp, DomainName->Buffer, DomainName->Length);
            wCp += DomainName->Length/sizeof(WCHAR);
            *wCp++ = UNICODE_PATH_SEP;
            RtlCopyMemory(wCp, ShareName->Buffer, ShareName->Length);
            Pkt = _GetPkt();
            PktAcquireExclusive(TRUE, &pktLocked);
#if DBG
            if (MupVerbose)
                DbgPrint("Looking up %wZ\n", &ustr);
#endif
            pEntry = PktLookupEntryByPrefix(
                            &DfsData.Pkt,
                            &ustr,
                            &RemPath);
#if DBG
            if (MupVerbose)
                DbgPrint("pEntry=0x%x\n", pEntry);
#endif
            if (pEntry != NULL && (pEntry->Type & PKT_ENTRY_TYPE_PERMANENT) == 0) {
                PktFlushChildren(pEntry);
                if (pEntry->UseCount == 0) {
                    PktEntryDestroy(pEntry, Pkt, (BOOLEAN) TRUE);
                } else {
                    pEntry->Type |= PKT_ENTRY_TYPE_DELETE_PENDING;
                    pEntry->ExpireTime = 0;
                    DfsRemoveUnicodePrefix(&Pkt->PrefixTable, &(pEntry->Id.Prefix));
                    DfsRemoveUnicodePrefix(&Pkt->ShortPrefixTable, &(pEntry->Id.ShortPrefix));
                }
            }
            ExFreePool(ustr.Buffer);
            PktRelease();
        }
    }

    if (!NT_SUCCESS(status) && DfsEventLog > 0 && refPath.Buffer != NULL) {
        UNICODE_STRING puStr[2];

        puStr[0] = refPath;
        puStr[1] = *MachineName;

        LogWriteMessage(DFS_REFERRAL_FAILURE, status, 2, puStr);

    }

    if (NT_SUCCESS(status) && DfsEventLog > 1 && refPath.Buffer != NULL) {
        UNICODE_STRING puStr[2];

        puStr[0] = refPath;
        puStr[1] = *MachineName;

        LogWriteMessage(DFS_REFERRAL_SUCCESS, status, 2, puStr);

    }

    //
    // Well, we are done. Cleanup all the things we allocated...
    //
    PktServiceDestroy( &service, FALSE );

    if (pDfsTargetInfo != NULL)
    {
        PktReleaseTargetInfo( pDfsTargetInfo ); 
    }
    if (hServer != NULL) {
        ZwClose( hServer );
    }

    if (refPath.Buffer != NULL) {
        ExFreePool( refPath.Buffer );
    }

    if (RestoreImpersonationState) {
            PsRestoreImpersonation(
                PsGetCurrentThread(),
                &DisabledImpersonationState);
    }

    if (attachedToSystemProcess) {
        KeUnstackDetachProcess(&ApcState);
    }

    DfsDbgTrace(-1, Dbg, "PktGetReferral returning %08lx\n", ULongToPtr(status) );

#if DBG
    if (MupVerbose) {
        KeQuerySystemTime(&EndTime);
        DbgPrint("  [%d] PktGetReferral returning %08lx\n",
                        (ULONG)((EndTime.QuadPart - StartTime.QuadPart)/(10 * 1000)),
                        status);
    }
#endif

    return( status );

}



//+-------------------------------------------------------------------------
//
//  Function:   PktLookupEntryByPrefix, public
//
//  Synopsis:   PktLookupEntryByPrefix finds an entry that has a
//              specified prefix.  The PKT must be acquired for
//              this operation.
//
//  Arguments:  [Pkt] - pointer to a initialized (and acquired) PKT
//              [Prefix] - the partitions prefix to lookup.
//              [Remaining] - any remaining path.  Points within
//                  the Prefix to where any trailing (nonmatched)
//                  characters are.
//
//  Returns:    The PKT_ENTRY that has the exact same prefix, or NULL,
//              if none exists or is marked for delete.
//
//  Notes:
//
//--------------------------------------------------------------------------
PDFS_PKT_ENTRY
PktLookupEntryByPrefix(
    IN  PDFS_PKT Pkt,
    IN  PUNICODE_STRING Prefix,
    OUT PUNICODE_STRING Remaining
)
{
    PUNICODE_PREFIX_TABLE_ENTRY pfxEntry;
    PDFS_PKT_ENTRY              pktEntry;

    DfsDbgTrace(+1, Dbg, "PktLookupEntryByPrefix: Entered\n", 0);
    //
    // If there really is a prefix to lookup, use the prefix table
    //  to initially find an entry
    //

    if ((Prefix->Length != 0) &&
       (pfxEntry = DfsFindUnicodePrefix(&Pkt->PrefixTable,Prefix,Remaining))) {
        USHORT pfxLength;

        //
        // reset a pointer to the corresponding entry
        //

        pktEntry = CONTAINING_RECORD(pfxEntry,
                                     DFS_PKT_ENTRY,
                                     PrefixTableEntry);

        if (!(pktEntry->Type & PKT_ENTRY_TYPE_DELETE_PENDING)) {

            pfxLength = pktEntry->Id.Prefix.Length;

            //
            //  Now calculate the remaining path and return
            //  the entry we found.  Note that we bump the length
            //  up by one char so that we skip any path separater.
            //

            if ((pfxLength < Prefix->Length) &&
                    (Prefix->Buffer[pfxLength/sizeof(WCHAR)] == UNICODE_PATH_SEP))
                pfxLength += sizeof(WCHAR);

            if (pfxLength < Prefix->Length) {
                Remaining->Length = (USHORT)(Prefix->Length - pfxLength);
                Remaining->Buffer = &Prefix->Buffer[pfxLength/sizeof(WCHAR)];
                Remaining->MaximumLength = (USHORT)(Prefix->MaximumLength - pfxLength);
                DfsDbgTrace( 0, Dbg, "PktLookupEntryByPrefix: Remaining = %wZ\n",
                            Remaining);
            } else {
                Remaining->Length = Remaining->MaximumLength = 0;
                Remaining->Buffer = NULL;
                DfsDbgTrace( 0, Dbg, "PktLookupEntryByPrefix: No Remaining\n", 0);
            }

            DfsDbgTrace(-1, Dbg, "PktLookupEntryByPrefix: Exit -> %08lx\n",
                        pktEntry);
            return pktEntry;

        }
    }

    DfsDbgTrace(-1, Dbg, "PktLookupEntryByPrefix: Exit -> %08lx\n", NULL);
    return NULL;
}


//+-------------------------------------------------------------------------
//
//  Function:   PktLookupEntryByShortPrefix, public
//
//  Synopsis:   PktLookupEntryByShortPrefix finds an entry that has a
//              specified prefix.  The PKT must be acquired for
//              this operation.
//
//  Arguments:  [Pkt] - pointer to a initialized (and acquired) PKT
//              [Prefix] - the partitions prefix to lookup.
//              [Remaining] - any remaining path.  Points within
//                  the Prefix to where any trailing (nonmatched)
//                  characters are.
//
//  Returns:    The PKT_ENTRY that has the exact same prefix, or NULL,
//              if none exists or is marked for delete.
//
//  Notes:
//
//--------------------------------------------------------------------------
PDFS_PKT_ENTRY
PktLookupEntryByShortPrefix(
    IN  PDFS_PKT Pkt,
    IN  PUNICODE_STRING Prefix,
    OUT PUNICODE_STRING Remaining
)
{
    PUNICODE_PREFIX_TABLE_ENTRY pfxEntry;
    PDFS_PKT_ENTRY              pktEntry;

    DfsDbgTrace(+1, Dbg, "PktLookupEntryByShortPrefix: Entered\n", 0);

    //
    // If there really is a prefix to lookup, use the prefix table
    //  to initially find an entry
    //

    if ((Prefix->Length != 0) &&
       (pfxEntry = DfsFindUnicodePrefix(&Pkt->ShortPrefixTable,Prefix,Remaining))) {
        USHORT pfxLength;

        //
        // reset a pointer to the corresponding entry
        //

        pktEntry = CONTAINING_RECORD(pfxEntry,
                                     DFS_PKT_ENTRY,
                                     PrefixTableEntry);

        if (!(pktEntry->Type & PKT_ENTRY_TYPE_DELETE_PENDING)) {

            pfxLength = pktEntry->Id.ShortPrefix.Length;

            //
            //  Now calculate the remaining path and return
            //  the entry we found.  Note that we bump the length
            //  up by one char so that we skip any path separater.
            //

            if ((pfxLength < Prefix->Length) &&
                    (Prefix->Buffer[pfxLength/sizeof(WCHAR)] == UNICODE_PATH_SEP))
                pfxLength += sizeof(WCHAR);

            if (pfxLength < Prefix->Length) {
                Remaining->Length = (USHORT)(Prefix->Length - pfxLength);
                Remaining->Buffer = &Prefix->Buffer[pfxLength/sizeof(WCHAR)];
                Remaining->MaximumLength = (USHORT)(Prefix->MaximumLength - pfxLength);
                DfsDbgTrace( 0, Dbg, "PktLookupEntryByShortPrefix: Remaining = %wZ\n",
                            Remaining);
            } else {
                Remaining->Length = Remaining->MaximumLength = 0;
                Remaining->Buffer = NULL;
                DfsDbgTrace( 0, Dbg, "PktLookupEntryByShortPrefix: No Remaining\n", 0);
            }

            DfsDbgTrace(-1, Dbg, "PktLookupEntryByShortPrefix: Exit -> %08lx\n",
                        pktEntry);
            return pktEntry;

        }

    }

    DfsDbgTrace(-1, Dbg, "PktLookupEntryByShortPrefix: Exit -> %08lx\n", NULL);
    return NULL;
}



//+-------------------------------------------------------------------------
//
//  Function:   PktLookupEntryByUid, public
//
//  Synopsis:   PktLookupEntryByUid finds an entry that has a
//              specified Uid.  The PKT must be acquired for this operation.
//
//  Arguments:  [Pkt] - pointer to a initialized (and acquired) PKT
//              [Uid] - a pointer to the partitions Uid to lookup.
//
//  Returns:    A pointer to the PKT_ENTRY that has the exact same
//              Uid, or NULL, if none exists.
//
//  Notes:      The input Uid cannot be the Null GUID.
//
//              On a DC where there may be *lots* of entries in the PKT,
//              we may want to consider using some other algorithm for
//              looking up by ID.
//
//--------------------------------------------------------------------------

PDFS_PKT_ENTRY
PktLookupEntryByUid(
    IN  PDFS_PKT Pkt,
    IN  GUID *Uid
) {
    PDFS_PKT_ENTRY entry;

    DfsDbgTrace(+1, Dbg, "PktLookupEntryByUid: Entered\n", 0);

    //
    // We don't lookup NULL Uids
    //

    if (NullGuid(Uid)) {
        DfsDbgTrace(0, Dbg, "PktLookupEntryByUid: NULL Guid\n", NULL);

        entry = NULL;
    } else {
        entry = PktFirstEntry(Pkt);
    }

    while (entry != NULL) {
        if (GuidEqual(&entry->Id.Uid, Uid))
            break;
        entry = PktNextEntry(Pkt, entry);
    }

    //
    // Don't return the entry if it is marked for delete
    //

    if (entry != NULL && (entry->Type & PKT_ENTRY_TYPE_DELETE_PENDING) != 0) {
        entry = NULL;
    }

    DfsDbgTrace(-1, Dbg, "PktLookupEntryByUid: Exit -> %08lx\n", entry);
    return entry;
}



//+-------------------------------------------------------------------------
//
//  Function:   PktLookupReferralEntry, public
//
//  Synopsis:   Given a PKT Entry pointer it returns the closest referral
//              entry in the PKT to this entry.
//
//  Arguments:  [Pkt] - A pointer to the PKT that is being manipulated.
//              [Entry] - The PKT entry passed in by caller.
//
//  Returns:    The pointer to the referral entry that was requested.
//              This could have a NULL value if we could not get anything
//              at all - The caller's responsibility to do whatever he wants
//              with it.
//
//  Note:       If the data structures in the PKT are not linked up right
//              this function might return a pointer to the DOMAIN_SERVICE
//              entry on the DC.  If DNR uses this to do an FSCTL we will have
//              a deadlock.  However, this should never happen.  If it does we
//              have a BUG somewhere in our code. I cannot even have an
//              assert out here.
//
//--------------------------------------------------------------------------
PDFS_PKT_ENTRY
PktLookupReferralEntry(
    PDFS_PKT            Pkt,
    PDFS_PKT_ENTRY      Entry
) {

    UNICODE_STRING FileName;
    UNICODE_STRING RemPath;
    USHORT i, j;

    DfsDbgTrace(+1, Dbg, "PktLookupReferralEntry: Entered\n", 0);

    if (Entry == NULL)  {

        DfsDbgTrace(-1, Dbg, "PktLookupReferralEntry: Exit -> NULL\n", 0);

        return( NULL );

    }

    FileName = Entry->Id.Prefix;

#if DBG
    if (MupVerbose)
        DbgPrint("  PktLookupReferralEntry(1): FileName=[%wZ]\n", &FileName);
#endif

    //
    // We want to work with the \Server\Share part of the FileName only,
    // so count up to 3 backslashes, then stop.
    //

    for (i = j = 0; i < FileName.Length/sizeof(WCHAR) && j < 3; i++) {

        if (FileName.Buffer[i] == UNICODE_PATH_SEP) {

            j++;

        }

    }

    FileName.Length = (j >= 3) ? (i-1) * sizeof(WCHAR) : i * sizeof(WCHAR);

#if DBG
    if (MupVerbose)
        DbgPrint("  PktLookupReferralEntry(2): FileName=[%wZ]\n", &FileName);
#endif

    //
    // Now find the pkt entry
    //

    Entry = PktLookupEntryByPrefix(
                Pkt,
                &FileName,
                &RemPath);

#if DBG
    if (MupVerbose)
        if (Entry != NULL)
            DbgPrint("  Parent Entry=[%wZ]\n", &Entry->Id.Prefix);
        else
            DbgPrint("  Parent Entry=NULL\n");
#endif

    //
    // Make sure that we found an entry for machine that can give out a referral
    //

    if (
        Entry != NULL
                &&
        (
            (Entry->Type & PKT_ENTRY_TYPE_REFERRAL_SVC) == 0
                ||
            (Entry->Type & PKT_ENTRY_TYPE_DELETE_PENDING) != 0
        )
    ) {

        Entry = NULL;

    }

    DfsDbgTrace(-1, Dbg, "PktLookupReferralEntry: Exit -> %08lx\n", Entry);

#if DBG
    if (MupVerbose)
        DbgPrint("  PktLookupReferralEntry: Exit -> %08lx\n", Entry);
#endif

    return(Entry);
}


//+-------------------------------------------------------------------------
//
//  Function:   PktCreateEntryFromReferral, public
//
//  Synopsis:   PktCreateEntryFromReferral creates a new partition
//              table entry from a referral and places it in the table.
//              The PKT must be aquired exclusively for this operation.
//
//  Arguments:  [Pkt] -- pointer to a initialized (and exclusively
//                      acquired) PKT
//              [ReferralPath] -- Path for which this referral was obtained.
//              [ReferralSize] -- size (in bytes) of the referral buffer.
//              [ReferralBuffer] -- pointer to a referral buffer
//              [CreateDisposition] -- specifies whether to overwrite if
//                      an entry already exists, etc.
//              [MatchingLength] -- The length in bytes of referralPath that
//                      matched.
//              [ReferralType] - On successful return, this is set to
//                      DFS_STORAGE_REFERRAL or DFS_REFERRAL_REFERRAL
//                      depending on the type of referral we just processed.
//              [ppPktEntry] - the new entry is placed here.
//
//  Returns:    NTSTATUS - STATUS_SUCCESS if no error.
//
//  Notes:
//
//--------------------------------------------------------------------------
NTSTATUS
PktCreateEntryFromReferral(
    IN  PDFS_PKT Pkt,
    IN  PUNICODE_STRING ReferralPath,
    IN  ULONG ReferralSize,
    IN  PRESP_GET_DFS_REFERRAL ReferralBuffer,
    IN  ULONG CreateDisposition,
    IN  PDFS_TARGET_INFO pDfsTargetInfo,
    OUT ULONG   *MatchingLength,
    OUT ULONG   *ReferralType,
    OUT PDFS_PKT_ENTRY *ppPktEntry
)
{
    DFS_PKT_ENTRY_ID EntryId;
    UNICODE_STRING RemainingPath;
    ULONG RefListSize;
    NTSTATUS Status;
    BOOLEAN bPktAcquired = FALSE;


    UNREFERENCED_PARAMETER(Pkt);

    DfsDbgTrace(+1, Dbg, "PktCreateEntryFromReferral: Entered\n", 0);

    try {

        RtlZeroMemory(&EntryId, sizeof(EntryId));

        //
        // Do some parameter validation
        //

        Status = PktpCheckReferralSyntax(
                    ReferralPath,
                    ReferralBuffer,
                    ReferralSize);

        if (!NT_SUCCESS(Status)) {
            try_return(Status);
        }

        Status = PktpCreateEntryIdFromReferral(
                    ReferralBuffer,
                    ReferralPath,
                    MatchingLength,
                    &EntryId);

        if (!NT_SUCCESS(Status)) {
            try_return(Status);
        }

	//
        //  Create/Update the prefix entry
        //

        PktAcquireExclusive(TRUE, &bPktAcquired);

        Status = PktpAddEntry(&DfsData.Pkt,
                              &EntryId,
			      ReferralBuffer,
                              CreateDisposition,
                              pDfsTargetInfo,
                              ppPktEntry);

        PktRelease();
        bPktAcquired = FALSE;

        //
        // We have to tell the caller as to what kind of referral was just
        // received through ReferralType.
        //

        if (ReferralBuffer->StorageServers == 1) {
            *ReferralType = DFS_STORAGE_REFERRAL;
        } else {
            *ReferralType = DFS_REFERRAL_REFERRAL;
        }

    try_exit:   NOTHING;

    } finally {

        DebugUnwind(PktCreateEntryFromReferral);

        if (bPktAcquired)
            PktRelease();

        if (AbnormalTermination())
            Status = STATUS_INVALID_USER_BUFFER;

        PktEntryIdDestroy( &EntryId, FALSE );

    }

    DfsDbgTrace(-1, Dbg, "PktCreateEntryFromReferral: Exit -> %08lx\n", ULongToPtr(Status) );

    return Status;
}

//+-------------------------------------------------------------------------
//
//  Function:   PktExpandSpecialEntryFromReferral, public
//
//  Synopsis:   Creates a special list corresponding to the list of names
//              in a referral.
//
//  Arguments:  [Pkt] -- pointer to a initialized (and exclusively
//                      acquired) PKT
//              [ReferralPath] -- Path for which this referral was obtained.
//              [ReferralSize] -- size (in bytes) of the referral buffer.
//              [ReferralBuffer] -- pointer to a referral buffer
//              [pSpecialEntry] - the entry to expand
//
//  Returns:    NTSTATUS - STATUS_SUCCESS if no error.
//
//  Notes:
//
//--------------------------------------------------------------------------
NTSTATUS
PktExpandSpecialEntryFromReferral(
    IN  PDFS_PKT Pkt,
    IN  PUNICODE_STRING ReferralPath,
    IN  ULONG ReferralSize,
    IN  PRESP_GET_DFS_REFERRAL ReferralBuffer,
    IN  PDFS_SPECIAL_ENTRY pSpecialEntry
)
{
    PUNICODE_STRING ustrExpandedName;
    NTSTATUS Status = STATUS_SUCCESS;
    PDFS_REFERRAL_V3 v3;
    PDFS_EXPANDED_NAME pExpandedNames;
    LPWSTR wzSpecialName;
    LPWSTR wzExpandedName;
    ULONG TimeToLive = 0;
    ULONG i, j;

    DfsDbgTrace(+1, Dbg, "PktExpandSpecialEntryFromReferral(%wZ): Entered\n", ReferralPath);

    //
    // We can't update if another thread is using this entry
    //

    if (pSpecialEntry->UseCount > 1) {
        return STATUS_SUCCESS;
    }

    //
    // Do some parameter validation
    //

    try {

        Status = PktpCheckReferralSyntax(
                    ReferralPath,
                    ReferralBuffer,
                    ReferralSize);

    } except (EXCEPTION_EXECUTE_HANDLER) {
        Status = STATUS_INVALID_USER_BUFFER;
    }

    if (!NT_SUCCESS(Status)) {
        DfsDbgTrace(-1, Dbg, "PktExpandSpecialEntryFromReferral exit 0x%x\n", ULongToPtr(Status) );
        return( Status);
    }

    v3 = &ReferralBuffer->Referrals[0].v3;

    if (v3->NumberOfExpandedNames > 0) {

        pExpandedNames = ExAllocatePoolWithTag(
                            PagedPool,
                            sizeof(DFS_EXPANDED_NAME) * v3->NumberOfExpandedNames,
                            ' puM');
        if (pExpandedNames == NULL) {
            if (pSpecialEntry->NeedsExpansion == FALSE) {
                pSpecialEntry->Stale = FALSE;
                Status = STATUS_SUCCESS;
            } else {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
            DfsDbgTrace( 0, Dbg, "Unable to allocate ExpandedNames\n", 0);
            DfsDbgTrace(-1, Dbg, "PktExpandSpecialEntryFromReferral: Exit -> %08lx\n", ULongToPtr(Status) );
            return (Status);
        }
        RtlZeroMemory(
            pExpandedNames,
            sizeof(DFS_EXPANDED_NAME) * v3->NumberOfExpandedNames);

        //
        // Loop over the referral, filling in the expanded names
        // If we fail an allocate request, we simply go on.
        //
        wzExpandedName = (LPWSTR) (( (PCHAR) v3) + v3->ExpandedNameOffset);
        for (i = j = 0; i < v3->NumberOfExpandedNames; i++) {
            TimeToLive = v3->TimeToLive;
            //
            // Strip leading '\'
            //
            if (*wzExpandedName == UNICODE_PATH_SEP)
                wzExpandedName++;

            DfsDbgTrace( 0, Dbg, "%ws\n", wzExpandedName);

            ustrExpandedName = &pExpandedNames[j].ExpandedName;
            if (wcslen(wzExpandedName) > 0) {
                ustrExpandedName->Length = wcslen(wzExpandedName) * sizeof(WCHAR);
                ustrExpandedName->MaximumLength = ustrExpandedName->Length + sizeof(WCHAR);
                ustrExpandedName->Buffer = ExAllocatePoolWithTag(
                                                PagedPool,
                                                ustrExpandedName->MaximumLength,
                                                ' puM');
                if (ustrExpandedName->Buffer != NULL) {
                    RtlCopyMemory(
                        ustrExpandedName->Buffer,
                        wzExpandedName,
                        ustrExpandedName->MaximumLength);
                    j++;
                } else {
                    ustrExpandedName->Length = ustrExpandedName->MaximumLength = 0;
                }
            }
            wzExpandedName += wcslen(wzExpandedName) + 1;
        }

        if (j > 0) {
            if (pSpecialEntry->ExpandedNames != NULL) {
                PUNICODE_STRING pustr;

	        for (i = 0; i < pSpecialEntry->ExpandedCount; i++) {
                    pustr = &pSpecialEntry->ExpandedNames[i].ExpandedName;
                    if (pustr->Buffer) {
                       ExFreePool(pustr->Buffer);
                    }		      
		}
                ExFreePool(pSpecialEntry->ExpandedNames);
                pSpecialEntry->ExpandedNames = NULL;
                pSpecialEntry->ExpandedCount = 0;
            }
            pSpecialEntry->ExpandedCount = j;
            pSpecialEntry->Active = 0;
            pSpecialEntry->ExpandedNames = pExpandedNames;
            pSpecialEntry->NeedsExpansion = FALSE;
            pSpecialEntry->Stale = FALSE;
            // PktShuffleSpecialEntryList(pSpecialEntry);
            PktSetSpecialEntryListToDc(pSpecialEntry);
        } else {
            ExFreePool(pExpandedNames);
        }

    }

    DfsDbgTrace(-1, Dbg, "PktExpandSpecialEntryFromReferral: Exit -> %08lx\n", ULongToPtr(Status) );

    return Status;
}

NTSTATUS
PktCreateSpecialEntryTableFromReferral(
    IN  PDFS_PKT Pkt,
    IN  PUNICODE_STRING ReferralPath,
    IN  ULONG ReferralSize,
    IN  PRESP_GET_DFS_REFERRAL ReferralBuffer,
    IN  PUNICODE_STRING DCName)
{
    PUNICODE_STRING ustrSpecialName;
    PUNICODE_STRING ustrExpandedName;
    PDFS_EXPANDED_NAME pExpandedNames;
    PDFS_SPECIAL_ENTRY pSpecialEntry;
    PDFS_REFERRAL_V3 v3;
    LPWSTR wzSpecialName;
    LPWSTR wzExpandedName;
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG TimeToLive = 0;
    ULONG i, j, n;

    DfsDbgTrace(+1, Dbg, "PktCreateSpecialEntryTableFromReferral(%wZ): Entered\n", ReferralPath);

    //
    // Do some parameter validation
    //

    try {

        Status = PktpCheckReferralSyntax(
                    ReferralPath,
                    ReferralBuffer,
                    ReferralSize);

    } except (EXCEPTION_EXECUTE_HANDLER) {
        Status = STATUS_INVALID_USER_BUFFER;
    }

    if (!NT_SUCCESS(Status)) {
        DfsDbgTrace(-1, Dbg, "PktCreateSpecialEntryTableFromReferral exit 0x%x\n", ULongToPtr(Status) );
        return( Status);
    }

    //
    // Loop over referrals
    //

    v3 = &ReferralBuffer->Referrals[0].v3;

    for (n = 0; n < ReferralBuffer->NumberOfReferrals; n++) {

        //
        // Create the entry itself
        //
        pSpecialEntry = ExAllocatePoolWithTag(
                            PagedPool,
                            sizeof(DFS_SPECIAL_ENTRY),
                            ' puM');
        if (pSpecialEntry == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            DfsDbgTrace( 0, Dbg, "Unable to allocate SpecialEntry\n", 0);
            DfsDbgTrace(-1, Dbg, "PktCreateSpecialEntryTableFromReferral: Exit -> %08lx\n", ULongToPtr(Status) );
            return (Status);
        }
        //
        // Mundate initialization
        //
        RtlZeroMemory(pSpecialEntry, sizeof(DFS_SPECIAL_ENTRY));
        pSpecialEntry->NodeTypeCode = DSFS_NTC_SPECIAL_ENTRY;
        pSpecialEntry->NodeByteSize = sizeof(DFS_SPECIAL_ENTRY);
        pSpecialEntry->USN = 1;
        pSpecialEntry->UseCount = 0;
        pSpecialEntry->ExpandedCount = 0;
        pSpecialEntry->Active = 0;
        pSpecialEntry->ExpandedNames = NULL;
        pSpecialEntry->NeedsExpansion = TRUE;
        pSpecialEntry->Stale = FALSE;
        //
        // Set gotdcreferral to false. This gets set to true only when
        // we have already been asked (via an fsctl) to get the
        // trusted domainlist for the domain represented by this special entry
        //
        pSpecialEntry->GotDCReferral = FALSE;

        //
        // Fill in the Special Name, without the leading '\'
        //
        wzSpecialName = (PWCHAR) (((PCHAR) v3) + v3->SpecialNameOffset);
        if (*wzSpecialName == UNICODE_PATH_SEP) {
            wzSpecialName++;
        }
        ustrSpecialName = &pSpecialEntry->SpecialName;
        ustrSpecialName->Length = wcslen(wzSpecialName) * sizeof(WCHAR);
        ustrSpecialName->MaximumLength = ustrSpecialName->Length + sizeof(WCHAR);
        ustrSpecialName->Buffer = ExAllocatePoolWithTag(
                                        PagedPool,
                                        ustrSpecialName->MaximumLength,
                                        ' puM');
        if (ustrSpecialName->Buffer == NULL) {
            ExFreePool(pSpecialEntry);
            Status = STATUS_INSUFFICIENT_RESOURCES;
            DfsDbgTrace( 0, Dbg, "Unable to allocate SpecialName\n", 0);
            DfsDbgTrace(-1, Dbg, "PktCreateSpecialEntryTableFromReferral: Exit -> %08lx\n", ULongToPtr(Status) );
            return (Status);
        }
        RtlCopyMemory(
                ustrSpecialName->Buffer,
                wzSpecialName,
                ustrSpecialName->MaximumLength);
	
        // If the DCName is non-null, copy it into the special entry.
        // We store null dcname for all the special entries that get to use  
        // the global pkt->dcname.

        if (DCName != NULL) {
            pSpecialEntry->DCName.Buffer = ExAllocatePoolWithTag(
                                                 PagedPool,
                                                 DCName->MaximumLength,
                                                 ' puM');
            if (pSpecialEntry->DCName.Buffer == NULL) {
	        ExFreePool(pSpecialEntry->SpecialName.Buffer);
                ExFreePool(pSpecialEntry);
                Status = STATUS_INSUFFICIENT_RESOURCES;
                DfsDbgTrace( 0, Dbg, "Unable to allocate DCName\n", 0);
                DfsDbgTrace(-1, Dbg, "PktCreateSpecialEntryTableFromReferral: Exit -> %08lx\n", ULongToPtr(Status) );
                return (Status);
            }
            pSpecialEntry->DCName.MaximumLength = DCName->MaximumLength;
            RtlCopyUnicodeString(&pSpecialEntry->DCName, DCName);
        }
	
        //
        // Clip the UNICODE_NULL off the end
        //
        if (ustrSpecialName->Buffer[(ustrSpecialName->Length/sizeof(WCHAR))-1] == UNICODE_NULL) {
            ustrSpecialName->Length -= sizeof(WCHAR);
        }

        DfsDbgTrace( 0, Dbg, "SpecialName %wZ\n", ustrSpecialName);

        TimeToLive = v3->TimeToLive;

        if (v3->NumberOfExpandedNames > 0) {
            pExpandedNames = ExAllocatePoolWithTag(
                                PagedPool,
                                sizeof(DFS_EXPANDED_NAME) * v3->NumberOfExpandedNames,
                                ' puM');
            if (pExpandedNames == NULL) {
                DfsDbgTrace( 0, Dbg, "Unable to allocate ExpandedNames\n", 0);
                DfsDbgTrace(-1, Dbg, "PktCreateSpecialEntryTableFromReferral: Exit -> %08lx\n",
                    ULongToPtr(Status) );
            }
            if (pExpandedNames != NULL) {
                RtlZeroMemory(
                    pExpandedNames,
                    sizeof(DFS_EXPANDED_NAME) * v3->NumberOfExpandedNames);
                //
                // Loop over the referral, filling in the expanded names
                // If we fail an allocate request, we simply go on.
                //
                wzExpandedName = (LPWSTR) (( (PCHAR) v3) + v3->ExpandedNameOffset);
                for (i = j = 0; i < v3->NumberOfExpandedNames; i++) {
                    //
                    // Strip leading '\'
                    //
                    if (*wzExpandedName == UNICODE_PATH_SEP)
                        wzExpandedName++;

                    DfsDbgTrace( 0, Dbg, "..expands to %ws\n", wzExpandedName);

                    ustrExpandedName = &pExpandedNames[j].ExpandedName;
                    if (wcslen(wzExpandedName) > 0) {
                        ustrExpandedName->Length = wcslen(wzExpandedName) * sizeof(WCHAR);
                        ustrExpandedName->MaximumLength = ustrExpandedName->Length + sizeof(WCHAR);
                        ustrExpandedName->Buffer = ExAllocatePoolWithTag(
                                                        PagedPool,
                                                        ustrExpandedName->MaximumLength,
                                                        ' puM');
                        if (ustrExpandedName->Buffer != NULL) {
                            RtlCopyMemory(
                                ustrExpandedName->Buffer,
                                wzExpandedName,
                                ustrExpandedName->MaximumLength);
                            j++;
                        } else {
                            ustrExpandedName->Length = ustrExpandedName->MaximumLength = 0;
                        }
                    }
                    wzExpandedName += wcslen(wzExpandedName) + 1;
                }

                if (j > 0) {
                    pSpecialEntry->ExpandedCount = j;
                    pSpecialEntry->Active = 0;
                    pSpecialEntry->ExpandedNames = pExpandedNames;
                    pSpecialEntry->NeedsExpansion = FALSE;
                    pSpecialEntry->Stale = FALSE;
                    // PktShuffleSpecialEntryList(pSpecialEntry);
                    PktSetSpecialEntryListToDc(pSpecialEntry);
                } else {
                    ExFreePool(pExpandedNames);
                }
            }
        }
        //
        // If we got a referral with a TimeToLive, use the TimeToLive we got
        //
        if (TimeToLive != 0) {
            Pkt->SpecialTable.TimeToLive = TimeToLive;
        }
        //
        // Put it in the pkt!!
        //
        PktCreateSpecialNameEntry(pSpecialEntry);

        v3 = (PDFS_REFERRAL_V3) (((PUCHAR) v3) + v3->Size);
    }

    DfsDbgTrace(-1, Dbg, "PktCreateSpecialEntryTableFromReferral: Exit -> %08lx\n", ULongToPtr(Status) );

    return Status;
}

//+----------------------------------------------------------------------------
//
//  Function:   PktpCheckReferralSyntax
//
//  Synopsis:   Does some validation of a Referral
//
//  Arguments:  [ReferralPath] -- The Path for which a referral was obtained
//              [ReferralBuffer] -- Pointer to RESP_GET_DFS_REFERRAL Buffer
//              [ReferralSize] -- Size of ReferralBuffer
//
//  Returns:    [STATUS_SUCCESS] -- Referral looks ok.
//
//              [STATUS_INVALID_USER_BUFFER] -- Buffer looks hoky.
//
//-----------------------------------------------------------------------------

NTSTATUS
PktpCheckReferralSyntax(
    IN PUNICODE_STRING ReferralPath,
    IN PRESP_GET_DFS_REFERRAL ReferralBuffer,
    IN DWORD ReferralSize)
{
    NTSTATUS status = STATUS_SUCCESS;
    ULONG i, sizeRemaining;
    PDFS_REFERRAL_V1 ref;
    PCHAR ReferralBufferEnd = (((PCHAR) ReferralBuffer) + ReferralSize);

    DfsDbgTrace(+1, Dbg, "PktpCheckReferralSyntax: Entered\n", 0);

    if (ReferralBuffer->PathConsumed > ReferralPath->Length) {
        DfsDbgTrace( 0, Dbg, "        PathConsumed=0x%x\n", ReferralBuffer->PathConsumed);
        DfsDbgTrace( 0, Dbg, "        Length=0x%x\n", ReferralPath->Length);
        DfsDbgTrace(-1, Dbg, "PktpCheckReferralSyntax: INVALID_USER_BUFFER(1)\n", 0);
        // return( STATUS_INVALID_USER_BUFFER );
    }

    if (ReferralBuffer->NumberOfReferrals == 0) {
        status = STATUS_INVALID_USER_BUFFER;
        DfsDbgTrace(-1, Dbg, "PktpCheckReferralSyntax: INVALID_USER_BUFFER(2)\n", 0);
        MUP_TRACE_HIGH(ERROR, PktpCheckReferralSyntax_Error_InvalidBuffer2,
                       LOGSTATUS(status)
                       LOGUSTR(*ReferralPath));
        return( status );
    }

    if (ReferralBuffer->NumberOfReferrals * sizeof(DFS_REFERRAL_V1) > ReferralSize) {
        DfsDbgTrace(-1, Dbg, "PktpCheckReferralSyntax: INVALID_USER_BUFFER(3)\n", 0);
        status = STATUS_INVALID_USER_BUFFER;
        MUP_TRACE_HIGH(ERROR, PktpCheckReferralSyntax_Error_InvalidBuffer3,
                       LOGSTATUS(status)
                       LOGUSTR(*ReferralPath));
        return( status );
    }

    for (i = 0,
            ref = &ReferralBuffer->Referrals[0].v1,
                status = STATUS_SUCCESS,
                    sizeRemaining = ReferralSize -
                        FIELD_OFFSET(RESP_GET_DFS_REFERRAL, Referrals);
                            i < ReferralBuffer->NumberOfReferrals;
                                    i++) {

         ULONG lenAddress;

         if ((ref->VersionNumber < 1 || ref->VersionNumber > 3) ||
                ref->Size > sizeRemaining) {
             DfsDbgTrace( 0, Dbg, "PktpCheckReferralSyntax: INVALID_USER_BUFFER(4)\n", 0);
             status = STATUS_INVALID_USER_BUFFER;
             MUP_TRACE_HIGH(ERROR, PktpCheckReferralSyntax_Error_InvalidBuffer4,
                            LOGSTATUS(status)
                            LOGUSTR(*ReferralPath));
             break;
         }

         //
         // Check the network address syntax
         //

         switch (ref->VersionNumber) {

         case 1:

             {

                 status = PktpCheckReferralString(
                            (LPWSTR) ref->ShareName,
                            (PCHAR) ReferralBuffer,
                            ReferralBufferEnd);

                 if (NT_SUCCESS(status)) {

                     lenAddress = ref->Size -
                                    FIELD_OFFSET(DFS_REFERRAL_V1, ShareName);

                     lenAddress /= sizeof(WCHAR);

                     status = PktpCheckReferralNetworkAddress(
                                (LPWSTR) ref->ShareName,
                                lenAddress);
                 }

             }

             break;

         case 2:

             {

                 PDFS_REFERRAL_V2 refV2 = (PDFS_REFERRAL_V2) ref;
                 PWCHAR dfsPath, dfsAlternatePath, networkAddress;

                 dfsPath =
                    (PWCHAR) (((PCHAR) refV2) + refV2->DfsPathOffset);

                 dfsAlternatePath =
                    (PWCHAR) (((PCHAR) refV2) + refV2->DfsAlternatePathOffset);


                 networkAddress =
                    (PWCHAR) (((PCHAR) refV2) + refV2->NetworkAddressOffset);

                 status = PktpCheckReferralString(
                            dfsPath,
                            (PCHAR) ReferralBuffer,
                            ReferralBufferEnd);

                 if (NT_SUCCESS(status)) {

                     status = PktpCheckReferralString(
                                dfsAlternatePath,
                                (PCHAR) ReferralBuffer,
                                ReferralBufferEnd);

                 }

                 if (NT_SUCCESS(status)) {

                     status = PktpCheckReferralString(
                                networkAddress,
                                (PCHAR) ReferralBuffer,
                                ReferralBufferEnd);

                 }

                 if (NT_SUCCESS(status)) {

                     lenAddress = (ULONG)(((ULONG_PTR) ReferralBufferEnd) -
                                    ((ULONG_PTR) networkAddress));

                     lenAddress /= sizeof(WCHAR);

                     status = PktpCheckReferralNetworkAddress(
                                networkAddress,
                                lenAddress);

                 }

             }

             break;

         case 3:

             {

                 PDFS_REFERRAL_V3 refV3 = (PDFS_REFERRAL_V3) ref;

                 if (refV3->NameListReferral != 0) {
                     PWCHAR dfsSpecialName, dfsExpandedNames;
                     ULONG i;

                     dfsSpecialName =
                        (PWCHAR) (((PCHAR) refV3) + refV3->SpecialNameOffset);

                     dfsExpandedNames =
                        (PWCHAR) (((PCHAR) refV3) + refV3->ExpandedNameOffset);

                     status = PktpCheckReferralString(
                                dfsSpecialName,
                                (PCHAR) ReferralBuffer,
                                ReferralBufferEnd);

                     if (!NT_SUCCESS(status)) {
                                DfsDbgTrace(0,
                                    Dbg,
                                    "PktpCheckReferralSyntax: INVALID_USER_BUFFER(5)\n",
                                    0);
                     }

                     if (NT_SUCCESS(status)) {

                         for (i = 0; i < refV3->NumberOfExpandedNames; i++) {

                             status = PktpCheckReferralString(
                                        dfsSpecialName,
                                        (PCHAR) ReferralBuffer,
                                        ReferralBufferEnd);

                             if (!NT_SUCCESS(status)) {
                                DfsDbgTrace(0,
                                    Dbg,
                                    "PktpCheckReferralSyntax: INVALID_USER_BUFFER(6)\n",
                                    0);
                                break;
                             }

                             dfsSpecialName += wcslen(dfsSpecialName) + 1;

                         }

                     }

                 } else {

                     PWCHAR dfsPath, dfsAlternatePath, networkAddress;

                     dfsPath =
                        (PWCHAR) (((PCHAR) refV3) + refV3->DfsPathOffset);

                     dfsAlternatePath =
                        (PWCHAR) (((PCHAR) refV3) + refV3->DfsAlternatePathOffset);


                     networkAddress =
                        (PWCHAR) (((PCHAR) refV3) + refV3->NetworkAddressOffset);

                     status = PktpCheckReferralString(
                                dfsPath,
                                (PCHAR) ReferralBuffer,
                                ReferralBufferEnd);

                     if (NT_SUCCESS(status)) {

                         status = PktpCheckReferralString(
                                    dfsAlternatePath,
                                    (PCHAR) ReferralBuffer,
                                    ReferralBufferEnd);

                     }

                     if (NT_SUCCESS(status)) {

                         status = PktpCheckReferralString(
                                    networkAddress,
                                    (PCHAR) ReferralBuffer,
                                    ReferralBufferEnd);

                     }

                     if (NT_SUCCESS(status)) {

                         lenAddress = (ULONG)(((ULONG_PTR) ReferralBufferEnd) -
                                        ((ULONG_PTR) networkAddress));

                         lenAddress /= sizeof(WCHAR);

                         status = PktpCheckReferralNetworkAddress(
                                    networkAddress,
                                    lenAddress);

                     }

                 }

             }

             break;

         default:

            ASSERT(FALSE && "bad ref->VersionNumber\n");

            status = STATUS_INVALID_USER_BUFFER;

            break;
         }

         //
         // This ref is ok. Go on to the next one...
         //

         sizeRemaining -= ref->Size;

         ref = (PDFS_REFERRAL_V1) (((PUCHAR) ref) + ref->Size);

    }

    DfsDbgTrace(-1, Dbg, "PktpCheckReferralSyntax: Exit -> %08lx\n", ULongToPtr(status) );

    return( status );

}

//+----------------------------------------------------------------------------
//
//  Function:   PktpCheckReferralString
//
//  Synopsis:   Validates part of a Referral as being a valid "string"
//
//  Arguments:  [String] -- Pointer to buffer thought to contain string.
//              [ReferralBuffer] -- Start of Referral Buffer
//              [ReferralBufferEnd] -- End of Referral Buffer
//
//  Returns:    [STATUS_SUCCESS] -- Valid string at String.
//
//              [STATUS_INVALID_USER_BUFFER] -- String doesn't check out.
//
//-----------------------------------------------------------------------------

NTSTATUS
PktpCheckReferralString(
    IN LPWSTR String,
    IN PCHAR ReferralBuffer,
    IN PCHAR ReferralBufferEnd)
{
    NTSTATUS status = STATUS_SUCCESS;
    ULONG i, length;

    if ( (((ULONG_PTR) String) & 0x1) != 0 ) {

        //
        // Strings should always start at word aligned addresses!
        //
        status = STATUS_INVALID_USER_BUFFER;
        MUP_TRACE_HIGH(ERROR, PktpCheckReferralString_Error_StringNotWordAlligned,
                       LOGSTATUS(status)
                       LOGWSTR(String));
        return( status );

    }

    if ( (((ULONG_PTR) String) >= ((ULONG_PTR) ReferralBuffer)) &&
            (((ULONG_PTR) String) < ((ULONG_PTR) ReferralBufferEnd)) ) {

        length = (ULONG)(( ((ULONG_PTR) ReferralBufferEnd) - ((ULONG_PTR) String) )) /
                    sizeof(WCHAR);

        for (i = 0; (i < length) && (String[i] != UNICODE_NULL); i++) {
            NOTHING;
        }

        if (i >= length)
            status = STATUS_INVALID_USER_BUFFER;

    } else {

        status = STATUS_INVALID_USER_BUFFER;

    }
    MUP_TRACE_ERROR_HIGH(status, ALL_ERROR, PktpCheckReferralString_Error,
                         LOGWSTR(String)
                         LOGSTATUS(status));
    return( status );
}

//+----------------------------------------------------------------------------
//
//  Function:   PktpCheckReferralNetworkAddress
//
//  Synopsis:   Checks to see if a NetworkAddress inside a referral
//              is of a valid form
//
//  Arguments:  [Address] -- Pointer to buffer containing network addresss
//
//              [MaxLength] -- Maximum length, in wchars, that Address can be.
//
//  Returns:    [STATUS_SUCCESS] -- Network address checks out
//
//              [STATUS_INVALID_USER_BUFFER] -- Network address looks bogus
//
//-----------------------------------------------------------------------------

NTSTATUS
PktpCheckReferralNetworkAddress(
    IN PWCHAR Address,
    IN ULONG MaxLength)
{
    ULONG j;
    BOOLEAN foundShare;
    NTSTATUS status;

    //
    // Address must be atleast \a\b followed by a NULL
    //

    if (MaxLength < 5) {
        status = STATUS_INVALID_USER_BUFFER;
        MUP_TRACE_HIGH(ERROR, PktpCheckReferralNetworkAddress_Error_TooShortToBeValid,
                       LOGWSTR(Address)
                       LOGSTATUS(status));
        return(STATUS_INVALID_USER_BUFFER);
    }
    //
    // Make sure the server name part is not NULL
    //

    if (Address[0] != UNICODE_PATH_SEP ||
            Address[1] == UNICODE_PATH_SEP) {
        status = STATUS_INVALID_USER_BUFFER;
        MUP_TRACE_HIGH(ERROR, PktpCheckReferralNetworkAddress_Error_NullServerName,
                       LOGWSTR(Address)
                       LOGSTATUS(status));
        return(STATUS_INVALID_USER_BUFFER);
    }

    //
    // Find the backslash after the server name
    //

    for (j = 2, foundShare = FALSE;
            j < MaxLength && !foundShare;
                j++) {

        if (Address[j] == UNICODE_PATH_SEP)
            foundShare = TRUE;
    }

    if (foundShare) {

        //
        // We found the second backslash. Make sure the share name
        // part is not 0 length.
        //

        if (j == MaxLength) {
            status = STATUS_INVALID_USER_BUFFER;
            MUP_TRACE_HIGH(ERROR, PktpCheckReferralNetworkAddress_Error_ZeroLengthShareName,
                           LOGWSTR(Address)
                           LOGSTATUS(status));
            return(status);
        }
        else {

            ASSERT(Address[j-1] == UNICODE_PATH_SEP);

            if (Address[j] == UNICODE_PATH_SEP ||
                    Address[j] == UNICODE_NULL) {
                status = STATUS_INVALID_USER_BUFFER;
                MUP_TRACE_HIGH(ERROR, PktpCheckReferralNetworkAddress_Error_ShareNameZeroLength,
                               LOGWSTR(Address)
                               LOGSTATUS(status));
                return(status);
            }
        }

    } else {
        status = STATUS_INVALID_USER_BUFFER;
        MUP_TRACE_HIGH(ERROR, PktpCheckReferralNetworkAddress_Error_ShareNameNotFound,
                       LOGWSTR(Address)
                       LOGSTATUS(status));
        return(status);
    }

    return( STATUS_SUCCESS );

}

//+--------------------------------------------------------------------
//
// Function:    PktpAddEntry
//
// Synopsis:    This function is called to create an entry which was obtained
//              in the form of a referral from a DC. This method should only
//              be called for adding entries which were obtained through
//              referrals. It sets an expire time on all these entries.
//
// Arguments:   [Pkt] --
//              [EntryId] --
//              [ReferralBuffer] --
//              [CreateDisposition] --
//              [ppPktEntry] --
//
// Returns:     NTSTATUS
//
//---------------------------------------------------------------------

NTSTATUS
PktpAddEntry (
    IN PDFS_PKT Pkt,
    IN PDFS_PKT_ENTRY_ID EntryId,
    IN PRESP_GET_DFS_REFERRAL ReferralBuffer,
    IN ULONG CreateDisposition,
    IN PDFS_TARGET_INFO pDfsTargetInfo,
    OUT PDFS_PKT_ENTRY  *ppPktEntry
)
{
    NTSTATUS                    status;
    DFS_PKT_ENTRY_INFO          pktEntryInfo;
    ULONG                       Type = 0;
    ULONG                       n;
    PDFS_SERVICE                service;
    PDFS_REFERRAL_V1            ref;
    LPWSTR                      shareName;
    PDS_MACHINE                 pMachine;
    ULONG                       TimeToLive = 0;
    BOOLEAN                     ShuffleList = TRUE;
    UNICODE_STRING              ServerName;
    ULONG                       i;
    BOOLEAN DomainDfsService = FALSE;

    DfsDbgTrace(+1, Dbg, "PktpAddEntry: Entered\n", 0);

    RtlZeroMemory(&pktEntryInfo, sizeof(DFS_PKT_ENTRY_INFO));

    DfsDbgTrace( 0, Dbg, "PktpAddEntry: Id.Prefix = %wZ\n", &EntryId->Prefix);

    //
    // Now we go about the business of creating the entry Info structure.
    //

    pktEntryInfo.ServiceCount = ReferralBuffer->NumberOfReferrals;

    if (pktEntryInfo.ServiceCount > 0) {

        //
        // Allocate the service list.
        //

        n = pktEntryInfo.ServiceCount;

        pktEntryInfo.ServiceList = (PDFS_SERVICE) ExAllocatePoolWithTag(
                                                        PagedPool,
                                                        sizeof(DFS_SERVICE) * n,
                                                        ' puM');

        if (pktEntryInfo.ServiceList == NULL)   {
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;

        }

        RtlZeroMemory(pktEntryInfo.ServiceList, sizeof(DFS_SERVICE) * n);

        //
        // initialize temporary pointers
        //
        service = pktEntryInfo.ServiceList;
        ref = &ReferralBuffer->Referrals[0].v1;

        //
        // Cycle through the list of referrals initializing
        // service structures on the way.
        //
        while (n--) {

            if (ref->ServerType == 1) {
                service->Type = DFS_SERVICE_TYPE_MASTER;
                service->Capability = PROV_DFS_RDR;
                service->ProviderId = PROV_ID_DFS_RDR;
            } else {
                service->Type = DFS_SERVICE_TYPE_MASTER |
                                    DFS_SERVICE_TYPE_DOWN_LEVEL;
                service->Capability = PROV_STRIP_PREFIX;
                service->ProviderId = PROV_ID_MUP_RDR;
            }

            switch (ref->VersionNumber) {

            case 1:

                shareName = (LPWSTR) (ref->ShareName); break;

            case 2:

                {

                    PDFS_REFERRAL_V2 refV2 = (PDFS_REFERRAL_V2) ref;

                    service->Cost = refV2->Proximity;

                    TimeToLive = refV2->TimeToLive;

                    shareName =
                        (LPWSTR) (((PCHAR) refV2) + refV2->NetworkAddressOffset);

                }

                break;

            case 3:

                {

                    PDFS_REFERRAL_V3 refV3 = (PDFS_REFERRAL_V3) ref;

                    service->Cost = 0;

                    TimeToLive = refV3->TimeToLive;

                    shareName =
                        (LPWSTR) (((PCHAR) refV3) + refV3->NetworkAddressOffset);

                    //
                    // Don't shuffle v3 referral list - it's ordered for us
                    // using site information
                    //

                    ShuffleList = FALSE;

                }

                break;

            default:

                ASSERT(FALSE && "Bad ref->VersionNumber\n");

                break;

            }

            //
            // Now try and figure out the server name
            //

            {
                USHORT plen;
                WCHAR *pbuf;

                ASSERT( shareName[0] == UNICODE_PATH_SEP );

                pbuf = wcschr( &shareName[1], UNICODE_PATH_SEP );
                
                if(pbuf) {
                    plen = (USHORT) (((ULONG_PTR)pbuf) - ((ULONG_PTR)&shareName[1]));
                } else {
                    plen = 0;
                }
                
                service->Name.Length = plen;
                service->Name.MaximumLength = plen + sizeof(WCHAR);
                service->Name.Buffer = (PWCHAR) ExAllocatePoolWithTag(
                                                    PagedPool,
                                                    plen + sizeof(WCHAR),
                                                    ' puM');
                if (service->Name.Buffer == NULL)       {
                    status = STATUS_INSUFFICIENT_RESOURCES;
                    goto Cleanup;
                }
                RtlMoveMemory(service->Name.Buffer, &shareName[1], plen);
                service->Name.Buffer[ service->Name.Length / sizeof(WCHAR) ] =
                    UNICODE_NULL;

                if ((DomainDfsService != TRUE) &&
                    PktLookupSpecialNameEntry(&service->Name) != NULL)
                {
                    DomainDfsService = TRUE;
                }
            }

            //
            // Next, try and copy the address...
            //

            service->Address.Length = (USHORT) wcslen(shareName) *
                                                sizeof(WCHAR);
            service->Address.MaximumLength = service->Address.Length +
                                                sizeof(WCHAR);
            service->Address.Buffer = (PWCHAR) ExAllocatePoolWithTag(
                                                    PagedPool,
                                                    service->Address.MaximumLength,
                                                    ' puM');
            if (service->Address.Buffer == NULL)        {
                    status = STATUS_INSUFFICIENT_RESOURCES;
                    goto Cleanup;
            }
            RtlMoveMemory(service->Address.Buffer,
                          shareName,
                          service->Address.MaximumLength);

            DfsDbgTrace( 0, Dbg, "PktpAddEntry: service->Address = %wZ\n",
                &service->Address);

            //
            // Get the Machine Address structure for this server...
            //

            pMachine = PktpGetDSMachine( &service->Name );

            if (pMachine == NULL) {
                status = STATUS_INSUFFICIENT_RESOURCES;
                goto Cleanup;
            }

            service->pMachEntry = ExAllocatePoolWithTag(
                                        PagedPool, sizeof(DFS_MACHINE_ENTRY),
                                        ' puM');

            if (service->pMachEntry == NULL) {
                DfsDbgTrace( 0, Dbg, "PktpAddEntry: Unable to allocate DFS_MACHINE_ENTRY\n", 0);
                status = STATUS_INSUFFICIENT_RESOURCES;
                goto Cleanup;
            }

            RtlZeroMemory( (PVOID) service->pMachEntry, sizeof(DFS_MACHINE_ENTRY));
            service->pMachEntry->pMachine = pMachine;
            service->pMachEntry->UseCount = 1;


            //
            // Now we need to advance to the next referral, and to
            // the next service structure.
            //

            ref = (PDFS_REFERRAL_V1)  (((PUCHAR)ref) + ref->Size);

            service++;

        }

        //
        // Finally, if needed, we shuffle the services so that we achieve load balancing
        // while still maintaining site-cost based replica selection.
        //
        // Note: we only shuffle v1 and v2 referrals. V3 referrals are ordered by site.
        //

        if (ShuffleList == TRUE) {

            PktShuffleServiceList( &pktEntryInfo );

        }

    }

    //
    // Now we have to figure out the type for this entry.
    //

    // 
    // Ignore the storage server bit from the server.
    // Bug: 332061.
    // 
    //if (ReferralBuffer->StorageServers == 0)     {
    //
    //  ASSERT(ReferralBuffer->ReferralServers == 1);
    //
    //    Type = PKT_ENTRY_TYPE_OUTSIDE_MY_DOM;
    //
    // } else {
    //
    //    Type = PKT_ENTRY_TYPE_DFS;
    //
    //}


    Type = 0;
    if (DomainDfsService == TRUE)
    {
        Type |= PKT_ENTRY_TYPE_OUTSIDE_MY_DOM;
    } 
    else {
        Type = PKT_ENTRY_TYPE_DFS;
        if (ReferralBuffer->ReferralServers == 1) 
        {
            Type |= PKT_ENTRY_TYPE_REFERRAL_SVC;
        }
    }


    //
    //  At this point we have everything we need to create an entry, so
    //  try to add the entry.
    //

    status = PktCreateEntry(
                Pkt,
                Type,
                EntryId,
                &pktEntryInfo,
                CreateDisposition,
                pDfsTargetInfo,
                ppPktEntry);

    if (!NT_SUCCESS(status))    {

        //
        // Since we failed to add the entry, at least we need to release
        // all the memory before we return back.
        //

        goto Cleanup;
    }

    //
    // Set the active service, if possible
    //

    ServerName = (*ppPktEntry)->Id.Prefix;

    //
    // Skip any leading leading '\'
    //

    if (ServerName.Buffer != NULL) {

        if (*ServerName.Buffer == UNICODE_PATH_SEP) {

            ServerName.Buffer++;
            ServerName.Length -= sizeof(WCHAR);

        }

        //
        // Find the first '\' or end
        //

        for (i = 0;
                i < ServerName.Length/sizeof(WCHAR) &&
                    ServerName.Buffer[i] != UNICODE_PATH_SEP;
                        i++) {

            NOTHING;
        
        }

        ServerName.Length = ServerName.MaximumLength = (USHORT) (i * sizeof(WCHAR));

        //
        // Ignore the return value - for FtDfs names using \\domainname\ftdfsname,
        // there will be no services with the domain name.
        //
#if 0
        DfspSetActiveServiceByServerName(
            &ServerName,
            *ppPktEntry);
#endif
    }

    //
    // If one of the services is our DC, we try to make it the active service
    // DONT DO THIS! Screws up site selection!
#if 0
    DfspSetServiceListToDc(*ppPktEntry);
#endif
    //
    // We set the ExpireTime in this entry to
    // Pkt->EntryTimeToLive. After these many number of seconds this
    // entry will get deleted from the PKT. Do this only for non-permanent
    // entries.
    //

    if (TimeToLive != 0) {
        (*ppPktEntry)->ExpireTime = TimeToLive;
        (*ppPktEntry)->TimeToLive = TimeToLive;
    } else {
        (*ppPktEntry)->ExpireTime = Pkt->EntryTimeToLive;
        (*ppPktEntry)->TimeToLive = Pkt->EntryTimeToLive;
    }

#if DBG
    if (MupVerbose)
        DbgPrint("  Setting expiretime/timetolive = %d/%d\n",
            (*ppPktEntry)->ExpireTime,
            (*ppPktEntry)->TimeToLive);
#endif

#if DBG
    if (MupVerbose >= 2) {
        DbgPrint("  Setting expiretime and timetolive to 10\n");

        (*ppPktEntry)->ExpireTime = 10;
        (*ppPktEntry)->TimeToLive = 10;
    }
#endif

    DfsDbgTrace(-1, Dbg, "PktpAddEntry: Exit -> %08lx\n", ULongToPtr(status) );
    return status;

Cleanup:

    if (pktEntryInfo.ServiceCount > 0)    {

        n = pktEntryInfo.ServiceCount;
        if (pktEntryInfo.ServiceList != NULL)   {
            service = pktEntryInfo.ServiceList;

            while (n--) {

                if (service->Name.Buffer != NULL)
                        DfsFree(service->Name.Buffer);
                if (service->Address.Buffer != NULL)
                        DfsFree(service->Address.Buffer);
                if (service->pMachEntry != NULL) {

                    DfsDecrementMachEntryCount( service->pMachEntry, TRUE);
                }

                service++;
            }

            ExFreePool(pktEntryInfo.ServiceList);
        }
    }

    DfsDbgTrace(-1, Dbg, "PktpAddEntry: Exit -> %08lx\n", ULongToPtr(status) );
    return status;
}


//+----------------------------------------------------------------------------
//
//  Function:   PktpCreateEntryIdFromReferral
//
//  Synopsis:   Given a dfs referral, this routine constructs a PKT_ENTRY_ID
//              from the referral buffer which can then be used to create
//              the Pkt Entry.
//
//  Arguments:  [Ref] -- The referral buffer
//              [ReferralPath] -- The path for which the referral was obtained
//              [MatchingLength] -- The length in bytes of ReferralPath that
//                      matched.
//              [Peid] -- On successful return, the entry id is returned
//                      here.
//
//  Returns:    [STATUS_SUCCESS] -- Successfully create entry id.
//
//              [STATUS_INSUFFICIENT_RESOURCES] -- Out of memory condition
//
//-----------------------------------------------------------------------------

NTSTATUS
PktpCreateEntryIdFromReferral(
    IN PRESP_GET_DFS_REFERRAL Ref,
    IN PUNICODE_STRING ReferralPath,
    OUT ULONG *MatchingLength,
    OUT PDFS_PKT_ENTRY_ID Peid)
{
    NTSTATUS status = STATUS_SUCCESS;
    PDFS_REFERRAL_V2 pv2;
    PDFS_REFERRAL_V3 pv3;
    UNICODE_STRING prefix, shortPrefix;

    DfsDbgTrace(+1, Dbg, "PktpCreateIdFromReferral: Entered\n", 0);

    Peid->Prefix.Buffer = NULL;

    Peid->ShortPrefix.Buffer = NULL;

    pv2 = &Ref->Referrals[0].v2;

    switch (pv2->VersionNumber) {

    case 1:

        {

            //
            // A version 1 referral only has the number of characters that
            // matched, and it does not have short names.
            //

            prefix = *ReferralPath;

            prefix.Length = Ref->PathConsumed;

            if (prefix.Buffer[ prefix.Length/sizeof(WCHAR) - 1 ] ==
                    UNICODE_PATH_SEP) {
                prefix.Length -= sizeof(WCHAR);
            }

            prefix.MaximumLength = prefix.Length + sizeof(WCHAR);

            shortPrefix = prefix;

            *MatchingLength = prefix.Length;

        }

        break;

    case 2:

        {

            LPWSTR volPrefix;
            LPWSTR volShortPrefix;

            volPrefix = (LPWSTR) (((PCHAR) pv2) + pv2->DfsPathOffset);

            volShortPrefix = (LPWSTR) (((PCHAR) pv2) + pv2->DfsAlternatePathOffset);

            RtlInitUnicodeString(&prefix, volPrefix);

            RtlInitUnicodeString(&shortPrefix, volShortPrefix);

            *MatchingLength = Ref->PathConsumed;

        }

        break;

    case 3:

        {

            LPWSTR volPrefix;
            LPWSTR volShortPrefix;

            pv3 = &Ref->Referrals[0].v3;

            volPrefix = (LPWSTR) (((PCHAR) pv3) + pv3->DfsPathOffset);

            volShortPrefix = (LPWSTR) (((PCHAR) pv3) + pv3->DfsAlternatePathOffset);

            RtlInitUnicodeString(&prefix, volPrefix);

            RtlInitUnicodeString(&shortPrefix, volShortPrefix);

            *MatchingLength = Ref->PathConsumed;

        }

        break;

    default:

        // Fix for 440914 (prefix bug). Remove assert and return so that
        // we are not dealing with uninitialized variables.

        status = STATUS_INVALID_PARAMETER;

        return status;

    }

    Peid->Prefix.Buffer = ExAllocatePoolWithTag(
                            PagedPool,
                            prefix.MaximumLength,
                            ' puM');

    if (Peid->Prefix.Buffer == NULL)
        status = STATUS_INSUFFICIENT_RESOURCES;

    if (NT_SUCCESS(status)) {

        Peid->ShortPrefix.Buffer = ExAllocatePoolWithTag(
                                        PagedPool,
                                        shortPrefix.MaximumLength,
                                        ' puM');

        if (Peid->ShortPrefix.Buffer == NULL) {
            status = STATUS_INSUFFICIENT_RESOURCES;
        }

    }

    if (NT_SUCCESS(status)) {

        Peid->Prefix.Length =  prefix.Length;

        Peid->Prefix.MaximumLength = prefix.MaximumLength;

        RtlCopyMemory(
            Peid->Prefix.Buffer,
            prefix.Buffer,
            prefix.Length);

        Peid->Prefix.Buffer[Peid->Prefix.Length/sizeof(WCHAR)] =
            UNICODE_NULL;

        Peid->ShortPrefix.Length = shortPrefix.Length;

        Peid->ShortPrefix.MaximumLength = shortPrefix.MaximumLength;

        RtlCopyMemory(
            Peid->ShortPrefix.Buffer,
            shortPrefix.Buffer,
            shortPrefix.Length);

        Peid->ShortPrefix.Buffer[Peid->ShortPrefix.Length/sizeof(WCHAR)] =
            UNICODE_NULL;

    }

    if (!NT_SUCCESS(status)) {

        if (Peid->Prefix.Buffer != NULL) {
            ExFreePool( Peid->Prefix.Buffer );
            Peid->Prefix.Buffer = NULL;
        }

        if (Peid->ShortPrefix.Buffer != NULL) {
            ExFreePool( Peid->ShortPrefix.Buffer );
            Peid->ShortPrefix.Buffer = NULL;
        }

    }

    DfsDbgTrace(-1, Dbg, "PktpCreateIdFromReferral: Exit -> 0x%x\n", ULongToPtr(status) );

    return( status );

}


//+----------------------------------------------------------------------------
//
//  Function:   PktpGetDSMachine
//
//  Synopsis:   Builds a DS_MACHINE with a single NetBIOS address
//
//  Arguments:  [ServerName] -- Name of server.
//
//  Returns:    If successful, a pointer to a newly allocate DS_MACHINE,
//              otherwise, NULL
//
//-----------------------------------------------------------------------------

PDS_MACHINE
PktpGetDSMachine(
    IN PUNICODE_STRING ServerName)
{
    PDS_MACHINE pMachine = NULL;
    PDS_TRANSPORT pdsTransport;
    PTDI_ADDRESS_NETBIOS ptdiNB;
    ANSI_STRING astrNetBios;

    //
    // Allocate the DS_MACHINE structure
    //

    pMachine = ExAllocatePoolWithTag(PagedPool, sizeof(DS_MACHINE), ' puM');

    if (pMachine == NULL) {
        goto Cleanup;
    }

    RtlZeroMemory(pMachine, sizeof(DS_MACHINE));

    //
    // Allocate the array of principal names
    //

    pMachine->cPrincipals = 1;

    pMachine->prgpwszPrincipals = (LPWSTR *) ExAllocatePoolWithTag(
                                                PagedPool,
                                                sizeof(LPWSTR),
                                                ' puM');

    if (pMachine->prgpwszPrincipals == NULL) {
        goto Cleanup;
    }

    //
    // Allocate the principal name
    //

    pMachine->prgpwszPrincipals[0] = (PWCHAR) ExAllocatePoolWithTag(
                                        PagedPool,
                                        ServerName->MaximumLength,
                                        ' puM');
    if (pMachine->prgpwszPrincipals[0] == NULL) {
        goto Cleanup;
    }
    RtlMoveMemory(
        pMachine->prgpwszPrincipals[0],
        ServerName->Buffer,
        ServerName->MaximumLength);

    //
    // Allocate a single DS_TRANSPORT
    //

    pMachine->cTransports = 1;

    pMachine->rpTrans[0] = (PDS_TRANSPORT) ExAllocatePoolWithTag(
                                            PagedPool,
                                            sizeof(DS_TRANSPORT) + sizeof(TDI_ADDRESS_NETBIOS),
                                            ' puM');
    if (pMachine->rpTrans[0] == NULL) {
        goto Cleanup;
    }

    //
    // Initialize the DS_TRANSPORT
    //

    pdsTransport = pMachine->rpTrans[0];

    pdsTransport->usFileProtocol = FSP_SMB;

    pdsTransport->iPrincipal = 0;

    pdsTransport->grfModifiers = 0;

    //
    // Build the TA_ADDRESS_NETBIOS
    //

    pdsTransport->taddr.AddressLength = sizeof(TDI_ADDRESS_NETBIOS);

    pdsTransport->taddr.AddressType = TDI_ADDRESS_TYPE_NETBIOS;

    ptdiNB = (PTDI_ADDRESS_NETBIOS) &pdsTransport->taddr.Address[0];

    ptdiNB->NetbiosNameType = TDI_ADDRESS_NETBIOS_TYPE_UNIQUE;

    RtlFillMemory( &ptdiNB->NetbiosName[0], 16, ' ' );

    astrNetBios.Length = 0;
    astrNetBios.MaximumLength = 16;
    astrNetBios.Buffer = ptdiNB->NetbiosName;

    RtlUnicodeStringToAnsiString(&astrNetBios, ServerName, FALSE);

    return( pMachine );

Cleanup:

    if (pMachine) {

        PktDSMachineDestroy( pMachine, TRUE );

        pMachine = NULL;
    }

    return( pMachine );
}


//+----------------------------------------------------------------------------
//
//  Function:  PktShuffleServiceList
//
//  Synopsis:  Randomizes a service list for proper load balancing. This
//             routine assumes that the service list is ordered based on
//             site costs. For each equivalent cost group, this routine
//             shuffles the service list.
//
//  Arguments: [pInfo] -- Pointer to PktEntryInfo whose service list needs to
//                        be shuffled.
//
//  Returns:   Nothing, unless rand() fails!
//
//-----------------------------------------------------------------------------

VOID
PktShuffleServiceList(
    PDFS_PKT_ENTRY_INFO pInfo)
{
    PktShuffleGroup(pInfo, 0, pInfo->ServiceCount);
}

//+----------------------------------------------------------------------------
//
//  Function:   PktShuffleGroup
//
//  Synopsis:   Shuffles a cost equivalent group of services around for load
//              balancing. Uses the classic card shuffling algorithm - for
//              each card in the deck, exchange it with a random card in the
//              deck.
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

VOID
PktShuffleGroup(
    PDFS_PKT_ENTRY_INFO pInfo,
    ULONG       nStart,
    ULONG       nEnd)
{
    ULONG i;
    LARGE_INTEGER seed;

    ASSERT( nStart < pInfo->ServiceCount );
    ASSERT( nEnd <= pInfo->ServiceCount );

    KeQuerySystemTime( &seed );

    for (i = nStart; i < nEnd; i++) {

        DFS_SERVICE TempService;
        ULONG j;

        ASSERT (nEnd - nStart != 0);

        j = (RtlRandom( &seed.LowPart ) % (nEnd - nStart)) + nStart;

        ASSERT( j >= nStart && j <= nEnd );

        TempService = pInfo->ServiceList[i];

        pInfo->ServiceList[i] = pInfo->ServiceList[j];

        pInfo->ServiceList[j] = TempService;

    }
}


//+----------------------------------------------------------------------------
//
//  Function:  DfspSetServiceListToDc
//
//  Synopsis:  If this is a sysvol service list, try to set the
//             DC to the one we got from DsGetDcName().
//
//  Arguments: [pInfo] -- Pointer to DFS_PKT_ENTRY whose service list is to
//                        be set.
//
//-----------------------------------------------------------------------------

NTSTATUS
DfspSetServiceListToDc(
    PDFS_PKT_ENTRY pktEntry)
{
    PDFS_PKT Pkt;
    UNICODE_STRING DCNameShort;
    PDFS_PKT_ENTRY_INFO pInfo = &pktEntry->Info;
    ULONG i, pathSepCount;
    UNICODE_STRING ShareName;

    ShareName = (pktEntry)->Id.Prefix;
    pathSepCount = 2; // 2 \ before we reach the sharename.
    
    for (i = 0; 
	   i < ShareName.Length/sizeof(WCHAR) && pathSepCount;
               i++) {
        if (ShareName.Buffer[i] == UNICODE_PATH_SEP) {
            pathSepCount--;
	}
    }

    if (pathSepCount == 0 && ShareName.Length > i) {
        ShareName.Buffer += i;
        ShareName.Length -= (USHORT)(i * sizeof(WCHAR));

        for (i = 0;
                i < ShareName.Length/sizeof(WCHAR) &&
                   ShareName.Buffer[i] != UNICODE_PATH_SEP;
                      i++) {
             NOTHING;
        }
        ShareName.Length = (USHORT)i * sizeof(WCHAR);
        ShareName.MaximumLength = ShareName.Length;

        if (DfspIsSysVolShare(&ShareName) == FALSE) {
           return STATUS_INVALID_PARAMETER;
        }
    } else {
        return STATUS_INVALID_PARAMETER;
    }
    //
    // We simply scan the list and try to match on the DC name.  If we get
    // a hit, set the active service pointer
    //

    Pkt = _GetPkt();

    if ( Pkt->DCName.Length > 0 && pInfo != NULL) { 

        DfspDnsNameToFlatName(&Pkt->DCName, &DCNameShort);

        for (i = 0; i < pInfo->ServiceCount; i++) {
            if (
                RtlCompareUnicodeString(&pInfo->ServiceList[i].Name, &Pkt->DCName, TRUE) == 0
                    ||
                RtlCompareUnicodeString(&pInfo->ServiceList[i].Name, &DCNameShort, TRUE) == 0
             ) {
                pktEntry->ActiveService = &pInfo->ServiceList[i];
                return STATUS_SUCCESS;
             }
         }
     }
     return STATUS_INVALID_PARAMETER;
}

//+----------------------------------------------------------------------------
//
//  Function:   PktShuffleSpecialEntryList
//
//  Synopsis:   Shuffles the Special Entries
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

VOID
PktShuffleSpecialEntryList(
    PDFS_SPECIAL_ENTRY pSpecialEntry)
{
    ULONG i;
    LARGE_INTEGER seed;

    if (pSpecialEntry->ExpandedCount < 2)

        return;

    KeQuerySystemTime( &seed );

    for (i = 0; i < pSpecialEntry->ExpandedCount; i++) {

        DFS_EXPANDED_NAME TempExpandedName;
        ULONG j;

        j = RtlRandom( &seed.LowPart ) % pSpecialEntry->ExpandedCount;

        ASSERT( j < pSpecialEntry->ExpandedCount );

        TempExpandedName = pSpecialEntry->ExpandedNames[i];

        pSpecialEntry->ExpandedNames[i] = pSpecialEntry->ExpandedNames[j];

        pSpecialEntry->ExpandedNames[j] = TempExpandedName;

    }
}

//+----------------------------------------------------------------------------
//
//  Function:   PktSetSpecialEntryListToDc
//
//  Synopsis:   Sets the Special list active selection to the DC we got
//              from DsGetDcName()
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

VOID
PktSetSpecialEntryListToDc(
    PDFS_SPECIAL_ENTRY pSpecialEntry)
{
    PDFS_PKT Pkt;

    //
    // Set the 'active' entry to be the DC that DsGetDcName() gave us, if this is
    // the current domain.
    //

    Pkt = _GetPkt();

    //
    // If in our domain, start with DC last fetched by DsGetDcName()
    //

    if (
        Pkt->DCName.Length > 0
            &&
        Pkt->DomainNameFlat.Length > 0
            &&
        Pkt->DomainNameDns.Length > 0
            &&
        (RtlCompareUnicodeString(&pSpecialEntry->SpecialName, &Pkt->DomainNameFlat, TRUE) == 0
            ||
        RtlCompareUnicodeString(&pSpecialEntry->SpecialName, &Pkt->DomainNameDns, TRUE) == 0)
    ) {

        UNICODE_STRING DCNameShort;
        PUNICODE_STRING pExpandedName;
        ULONG EntryIdx;

#if DBG
        if (MupVerbose)
            DbgPrint("  PktSetSpecialEntryListToDc(SpecialName=[%wZ] Flat=[%wZ] Dns=[%wZ])\n",
                &pSpecialEntry->SpecialName,
                &Pkt->DomainNameFlat,
                &Pkt->DomainNameDns);
#endif
        DfspDnsNameToFlatName(&Pkt->DCName, &DCNameShort);
        for (EntryIdx = 0; EntryIdx < pSpecialEntry->ExpandedCount; EntryIdx++) {
            pExpandedName = &pSpecialEntry->ExpandedNames[EntryIdx].ExpandedName;
            if (
                RtlCompareUnicodeString(&Pkt->DCName, pExpandedName, TRUE) == 0
                    ||
                RtlCompareUnicodeString(&DCNameShort, pExpandedName, TRUE) == 0
            ) {
                pSpecialEntry->Active = EntryIdx;
#if DBG
                if (MupVerbose)
                    DbgPrint("    EntryIdx=%d\n", EntryIdx);
#endif
                break;
            }
        }
    }
}

//+----------------------------------------------------------------------------
//
//  Function:   PktParsePrefix
//
//  Synopsis:   Helper routine to break a path into domain, share, remainder
//
//  Arguments:  [Path] -- PUNICODE string of path to parse
//
//  Returns:    [MachineName] -- UNICODE_STRING containing MachineName, if present
//              [ShareName] -- UNICODE_STRING containing ShareName, if present
//              [Remainder] -- UNICODE_STRING containing remainder of Path
//
//-----------------------------------------------------------------------------

VOID
PktParsePath(
    IN  PUNICODE_STRING PathName,
    OUT PUNICODE_STRING MachineName,
    OUT PUNICODE_STRING ShareName,
    OUT PUNICODE_STRING Remainder OPTIONAL)
{
    LPWSTR ustrp, ustart, uend;

    DfsDbgTrace(+1, Dbg, "PktParsePath(%wZ)\n", PathName);

    RtlInitUnicodeString(MachineName, NULL);
    RtlInitUnicodeString(ShareName, NULL);
    if (ARGUMENT_PRESENT(Remainder)) {
        RtlInitUnicodeString(Remainder, NULL);
    }

    // Be sure there's something to do

    if (PathName->Length == 0) {
        DfsDbgTrace(-1, Dbg, "PathName is empty\n",0 );
        return;
    }

    // Skip leading '\'s

    ustart = ustrp = PathName->Buffer;
    uend = &PathName->Buffer[PathName->Length / sizeof(WCHAR)] - 1;

    // strip trailing nulls
    while (uend >= ustart && *uend == UNICODE_NULL)
        uend--;

    while (ustrp <= uend && *ustrp == UNICODE_PATH_SEP)
        ustrp++;

    // MachineName

    ustart = ustrp;

    while (ustrp <= uend && *ustrp != UNICODE_PATH_SEP)
        ustrp++;

    if (ustrp != ustart) {

        MachineName->Buffer = ustart;
        MachineName->Length = (USHORT)(ustrp - ustart) * sizeof(WCHAR);
        MachineName->MaximumLength = MachineName->Length;

        // ShareName

        ustart = ++ustrp;

        while (ustrp <= uend && *ustrp != UNICODE_PATH_SEP)
            ustrp++;

        if (ustrp != ustart) {
            ShareName->Buffer = ustart;
            ShareName->Length = (USHORT)(ustrp - ustart) * sizeof(WCHAR);
            ShareName->MaximumLength = ShareName->Length;

            // Remainder is whatever's left

            ustart = ++ustrp;

            while (ustrp <= uend)
                ustrp++;

            if (ustrp != ustart && ARGUMENT_PRESENT(Remainder)) {
                Remainder->Buffer = ustart;
                Remainder->Length = (USHORT)(ustrp - ustart) * sizeof(WCHAR);
                Remainder->MaximumLength = Remainder->Length;
            }
        }
    }
    DfsDbgTrace( 0, Dbg, "PktParsePath:  MachineName -> %wZ\n", MachineName);
    if (!ARGUMENT_PRESENT(Remainder)) {
        DfsDbgTrace(-1, Dbg, "                ShareName  -> %wZ\n", ShareName);
    } else {
        DfsDbgTrace( 0, Dbg, "                ShareName  -> %wZ\n", ShareName);
        DfsDbgTrace(-1, Dbg, "                Remainder  -> %wZ\n", Remainder);
    }
}

//+--------------------------------------------------------------------
//
// Function:    PktExpandSpecialName
//
// Synopsis:    This function is called to expand a Special name into a list
//              of Names.  It returns a pointer to an array of DFS_SPECIAL_ENTRY's
//
// Arguments:   Name - Name to expand
//              ppSpecialEntry - pointer to pointer for results
//
// Returns:     STATUS_SUCCESS
//              STATUS_BAD_NETWORK_PATH
//              STATUS_INSUFFICIENT_RESOURCES
//
//---------------------------------------------------------------------

NTSTATUS
_PktExpandSpecialName(
    PUNICODE_STRING Name,
    PDFS_SPECIAL_ENTRY *ppSpecialEntry)
{
    NTSTATUS status;
    HANDLE hServer = NULL;
    DFS_SERVICE service;
    PPROVIDER_DEF provider;
    PREQ_GET_DFS_REFERRAL ref = NULL;
    ULONG refSize = 0;
    UNICODE_STRING refPath;
    IO_STATUS_BLOCK iosb;
    BOOLEAN attachedToSystemProcess = FALSE;
    PDFS_SPECIAL_ENTRY pSpecialEntry;
    PDFS_PKT Pkt;
    BOOLEAN pktLocked;
    PDFS_SPECIAL_TABLE pSpecial = &DfsData.Pkt.SpecialTable;
    LARGE_INTEGER now;
    KAPC_STATE ApcState;
    ULONG MaxReferralLength;
    SE_IMPERSONATION_STATE DisabledImpersonationState;
    BOOLEAN RestoreImpersonationState = FALSE;
    LARGE_INTEGER StartTime;
    LARGE_INTEGER EndTime;
    PUNICODE_STRING origDCName;
    UNICODE_STRING DCName;
 
    DfsDbgTrace(+1, Dbg, "PktExpandSpecialName(%wZ)\n", Name);

    DCName.Buffer = NULL;
    KeQuerySystemTime(&StartTime);
#if DBG
    if (MupVerbose) {
        KeQuerySystemTime(&EndTime);
        DbgPrint("[%d] PktExpandSpecialName: Name %wZ \n",
                    (ULONG)((EndTime.QuadPart - StartTime.QuadPart)/(10 * 1000)),
                    Name);
    }
#endif

    *ppSpecialEntry = NULL;

    Pkt = _GetPkt();
    PktAcquireShared(TRUE, &pktLocked);

    if (Pkt->SpecialTable.SpecialEntryCount == 0) {
        PktRelease();
        pktLocked = FALSE;
        status = STATUS_BAD_NETWORK_PATH;
        MUP_TRACE_HIGH(ERROR, _PktExpandSpecialName_Error_NoSpecialReferralTable,
                       LOGSTATUS(status)
                       LOGUSTR(*Name));
        DfsDbgTrace( 0, Dbg, "No special referral table.\n", 0);
        DfsDbgTrace(-1, Dbg, "PktExpandSpecialName returning %08lx\n", ULongToPtr(status) );
        return (status);
    }

    pSpecialEntry = PktLookupSpecialNameEntry(Name);

    //
    // We don't have any expansion for this name
    //
    if (pSpecialEntry == NULL) {
        PktRelease();
        pktLocked = FALSE;
        status = STATUS_BAD_NETWORK_PATH;
        MUP_TRACE_HIGH(ERROR, _PktExpandSpecialName_Error_NotInSpecialReferralTable,
                       LOGUSTR(*Name)
                       LOGSTATUS(status));
        DfsDbgTrace( 0, Dbg, "... not in SpecialName table(cache miss)\n", 0);
        DfsDbgTrace(-1, Dbg, "PktExpandSpecialName returning %08lx\n", ULongToPtr(status) );
        return (status);
    }

    origDCName = &pSpecialEntry->DCName;
    if (origDCName->Buffer == NULL) {
      origDCName = &Pkt->DCName;
    }

    DfsDbgTrace( 0, Dbg, "Expanded Referral DCName = %wZ\n", origDCName);
    //
    // We have a (potential) expansion
    //
    if (origDCName->Buffer == NULL) {
        status = STATUS_BAD_NETWORK_PATH;
        MUP_TRACE_HIGH(ERROR, _PktExpandSpecialName_Error_DCNameNotInitialized,
                       LOGSTATUS(status)
                       LOGUSTR(*Name));
        DfsDbgTrace( 0, Dbg, "PktExpandSpecialName:DCName not initialized - \n", 0);
        DfsDbgTrace(-1, Dbg, "PktExpandSpecialName returning %08lx\n", ULongToPtr(status) );
        PktRelease();
        pktLocked = FALSE;
        return (status);
    }

    InterlockedIncrement(&pSpecialEntry->UseCount);

    if (pSpecialEntry->Stale == FALSE && pSpecialEntry->NeedsExpansion == FALSE) {
        PktRelease();
        pktLocked = FALSE;
        *ppSpecialEntry = pSpecialEntry;
        status = STATUS_SUCCESS;
        DfsDbgTrace( 0, Dbg, "... found in Special Name table (cache hit 1)\n", 0);
        DfsDbgTrace(-1, Dbg, "PktExpandSpecialName returning %08lx\n", ULongToPtr(status) );
        return (status);
    }

    //
    // It's in the special name table, but needs to be expanded or refreshed
    //

    ASSERT(pSpecialEntry->NeedsExpansion == TRUE || pSpecialEntry->Stale == TRUE);

    // Now copy the DC we are going to use before releasing the lock.

    DCName.Buffer = ExAllocatePoolWithTag(
                         PagedPool,
                         origDCName->MaximumLength,
                         ' puM');
    if (DCName.Buffer == NULL) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        MUP_TRACE_HIGH(ERROR, _PktExpandSpecialName_Error_ExAllocatePoolWithTag,
                       LOGSTATUS(status)
                       LOGUSTR(*Name));
        DfsDbgTrace(-1, Dbg, "PktExpandSpecialName returning %08lx\n", ULongToPtr(status) );
        PktRelease();
        pktLocked = FALSE;
        return (status);

    }
    DCName.Length = origDCName->Length;
    DCName.MaximumLength = origDCName->MaximumLength;
    RtlCopyMemory(
         DCName.Buffer,
         origDCName->Buffer,
         origDCName->MaximumLength);


    PktRelease();
    pktLocked = FALSE;

    DfsDbgTrace( 0, Dbg, "... in special name table (cache hit 2)\n", 0);

    //
    // get a provider and service describing the remote server.
    //

    provider = ReplLookupProvider( PROV_ID_DFS_RDR );
    if (provider == NULL) {
        DfsDbgTrace(-1, Dbg, "Unable to open LM Rdr!\n", 0);
        status =  STATUS_BAD_NETWORK_PATH;
        MUP_TRACE_HIGH(ERROR, _PktExpandSpecialName_Error_UnableToOpenRdr,
                       LOGSTATUS(status)
                       LOGUSTR(*Name));
	goto Cleanup;
    }

    RtlZeroMemory( &service, sizeof(DFS_SERVICE) );
    status = PktServiceConstruct(
                &service,
                DFS_SERVICE_TYPE_MASTER | DFS_SERVICE_TYPE_REFERRAL,
                PROV_DFS_RDR,
                STATUS_SUCCESS,
                PROV_ID_DFS_RDR,
                &DCName,
                NULL);

    DfsDbgTrace(0, Dbg, "PktServiceConstruct returned %08lx\n", ULongToPtr(status) );

    //
    // Next, we build a connection to this machine and ask it for a referral.
    //

    if (NT_SUCCESS(status)) {
        PktAcquireShared( TRUE, &pktLocked );
        if (PsGetCurrentProcess() != DfsData.OurProcess) {
            KeStackAttachProcess( DfsData.OurProcess, &ApcState );
            attachedToSystemProcess = TRUE;
        }

        RestoreImpersonationState = PsDisableImpersonation(
                                        PsGetCurrentThread(),
                                        &DisabledImpersonationState);

        status = DfsCreateConnection(
                    &service,
                    provider,
                    FALSE,
                    &hServer);
#if DBG
        if (MupVerbose) {
            KeQuerySystemTime(&EndTime);
            DbgPrint("  [%d] DfsCreateConnection to %wZ returned 0x%x\n",
                        (ULONG)((EndTime.QuadPart - StartTime.QuadPart)/(10 * 1000)),
		        &DCName,
                        status);
        }
#endif

        if (!NT_SUCCESS(status) && DfsEventLog > 0)
            LogWriteMessage(DFS_CONNECTION_FAILURE, status, 1, &DCName);

        PktRelease();
        pktLocked = FALSE;
        DfsDbgTrace(0, Dbg, "DfsCreateConnection returned %08lx\n", ULongToPtr(status) );
    }

    MaxReferralLength = MAX_REFERRAL_LENGTH;

Retry:

    RtlZeroMemory( &refPath, sizeof(UNICODE_STRING) );

    if (NT_SUCCESS(status)) {
        ULONG ReferralSize = 0;

        refPath.Length = 0;
        refPath.MaximumLength = sizeof(UNICODE_PATH_SEP) +
                                    Name->Length +
                                        sizeof(UNICODE_NULL);

        ReferralSize = refPath.MaximumLength + sizeof(REQ_GET_DFS_REFERRAL);

        if (ReferralSize > MAX_REFERRAL_MAX) {
            status = STATUS_INVALID_PARAMETER;
        }
        else if (MaxReferralLength < ReferralSize)
        {
            MaxReferralLength = ReferralSize;
        }

        if (NT_SUCCESS(status)) {
            refPath.Buffer = ExAllocatePoolWithTag( NonPagedPool,
                                                    refPath.MaximumLength + MaxReferralLength,
                                                    ' puM');

            if (refPath.Buffer != NULL) {
                ref = (PREQ_GET_DFS_REFERRAL)
                &refPath.Buffer[refPath.MaximumLength / sizeof(WCHAR)];
                RtlAppendUnicodeToString( &refPath, UNICODE_PATH_SEP_STR);
                RtlAppendUnicodeStringToString( &refPath, Name);
                refPath.Buffer[ refPath.Length / sizeof(WCHAR) ] = UNICODE_NULL;
                ref->MaxReferralLevel = 3;

                RtlMoveMemory(&ref->RequestFileName[0],
                              refPath.Buffer,
                              refPath.Length + sizeof(WCHAR));

                DfsDbgTrace(0, Dbg, "Referral Path : %ws\n", ref->RequestFileName);

                refSize = sizeof(USHORT) + refPath.Length + sizeof(WCHAR);

                DfsDbgTrace(0, Dbg, "Referral Size is %d bytes\n", ULongToPtr(refSize) );
            } else {

                DfsDbgTrace(0, Dbg, "Unable to allocate %d bytes\n",
                            ULongToPtr(refPath.MaximumLength + MaxReferralLength));

                status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
    }


    if (NT_SUCCESS(status)) {

        DfsDbgTrace(0, Dbg, "Ref Buffer @%08lx\n", ref);

        status = ZwFsControlFile(
                    hServer,                     // Target
                    NULL,                        // Event
                    NULL,                        // APC Routine
                    NULL,                        // APC Context,
                    &iosb,                       // Io Status block
                    FSCTL_DFS_GET_REFERRALS,     // FS Control code
                    (PVOID) ref,                 // Input Buffer
                    refSize,                     // Input Buffer Length
                    (PVOID) ref,                 // Output Buffer
                    MaxReferralLength);          // Output Buffer Length

        MUP_TRACE_ERROR_HIGH(status, ALL_ERROR, _PktExpandSpecialName_Error_ZwFsControlFile,
                             LOGUSTR(*Name)
                             LOGSTATUS(status));

        DfsDbgTrace(0, Dbg, "Fscontrol returned %08lx\n", ULongToPtr(status) );
#if DBG
        if (MupVerbose) {
            KeQuerySystemTime(&EndTime);
            DbgPrint("  [%d] ZwFsControlFile returned 0x%x\n",
                        (ULONG)((EndTime.QuadPart - StartTime.QuadPart)/(10 * 1000)),
                        status);
        }
#endif

    }

    //
    // Use the referral to expand the entry
    //

    if (NT_SUCCESS(status)) {
        PktAcquireExclusive(TRUE, &pktLocked );
        status = PktExpandSpecialEntryFromReferral(
                    &DfsData.Pkt,
                    &refPath,
                    (ULONG)iosb.Information,
                    (PRESP_GET_DFS_REFERRAL) ref,
                    pSpecialEntry);

        DfsDbgTrace(0, Dbg, "PktExpandSpecialEntryFromReferral returned %08lx\n",
            ULongToPtr(status) );

    } else if (status == STATUS_BUFFER_OVERFLOW && (refPath.Buffer != NULL) && MaxReferralLength < MAX_REFERRAL_MAX) {

        //
        // The referral didn't fit in the buffer supplied.  Make it bigger and try
        // again.
        //

        DfsDbgTrace(0, Dbg, "PktGetSpecialReferralTable: MaxReferralLength %d too small\n",
                        ULongToPtr(MaxReferralLength) );

        ExFreePool(refPath.Buffer);
        refPath.Buffer = NULL;
        MaxReferralLength *= 2;
        if (MaxReferralLength > MAX_REFERRAL_MAX)
            MaxReferralLength = MAX_REFERRAL_MAX;
        status = STATUS_SUCCESS;
        goto Retry;

    }

    if (NT_SUCCESS(status) || 
        ((pSpecialEntry->NeedsExpansion == FALSE) &&
         (status != STATUS_NO_SUCH_DEVICE))) {
        *ppSpecialEntry = pSpecialEntry;
        status = STATUS_SUCCESS;
    } else {
        InterlockedDecrement(&pSpecialEntry->UseCount);
    }

    if (pktLocked) {
        PktRelease();
        pktLocked = FALSE;
    }

    //
    // Well, we are done. Cleanup all the things we allocated...
    //

    PktServiceDestroy( &service, FALSE );
    if (hServer != NULL) {
        ZwClose( hServer );
    }

    if (refPath.Buffer != NULL) {
        ExFreePool( refPath.Buffer );
    }

    if (attachedToSystemProcess) {
        KeUnstackDetachProcess(&ApcState);
    }

    if (RestoreImpersonationState) {
            PsRestoreImpersonation(
                PsGetCurrentThread(),
                &DisabledImpersonationState);
    }

    if (status != STATUS_SUCCESS && status != STATUS_INSUFFICIENT_RESOURCES) {
        status = STATUS_BAD_NETWORK_PATH;
    }

#if DBG
    if (MupVerbose) {
        KeQuerySystemTime(&EndTime);
        DbgPrint("[%d] PktExpandSpecialName exit 0x%x\n",
                    (ULONG)((EndTime.QuadPart - StartTime.QuadPart)/(10 * 1000)),
                    status);
    }
#endif

Cleanup:
    if (DCName.Buffer != NULL) 
        ExFreePool( DCName.Buffer );

    DfsDbgTrace(-1, Dbg, "PktExpandSpecialName returning %08lx\n", ULongToPtr(status) );

    return( status );
}

//+--------------------------------------------------------------------
//
// Function:    PktGetSpecialReferralTable
//
// Synopsis:    This function is called to load the special name table.
//
// Arguments:   [machine] - Machine to contact
//              [systemDC] - true if the table uses the pkt->dcname.
//
// Returns:     STATUS_SUCCESS
//              STATUS_BAD_NETWORK_PATH
//              STATUS_INSUFFICIENT_RESOURCES
//
//---------------------------------------------------------------------

NTSTATUS
_PktGetSpecialReferralTable(
    PUNICODE_STRING Machine,
    BOOLEAN SystemDC)
{
    NTSTATUS status;
    HANDLE hServer = NULL;
    DFS_SERVICE service;
    PPROVIDER_DEF provider;
    PREQ_GET_DFS_REFERRAL ref = NULL;
    ULONG refSize = 0;
    UNICODE_STRING refPath;
    IO_STATUS_BLOCK iosb;
    BOOLEAN attachedToSystemProcess = FALSE;
    PDFS_SPECIAL_ENTRY pSpecialEntry;
    PDFS_PKT Pkt;
    BOOLEAN pktLocked = FALSE;
    PDFS_SPECIAL_TABLE pSpecial = &DfsData.Pkt.SpecialTable;
    LARGE_INTEGER now;
    KAPC_STATE ApcState;
    ULONG MaxReferralLength;
    SE_IMPERSONATION_STATE DisabledImpersonationState;
    BOOLEAN RestoreImpersonationState = FALSE;
    LARGE_INTEGER StartTime;
    LARGE_INTEGER EndTime;

    DfsDbgTrace(+1, Dbg, "PktGetSpecialReferralTable(%wZ)\n", Machine);
    KeQuerySystemTime(&StartTime);
#if DBG
    if (MupVerbose) {
        KeQuerySystemTime(&EndTime);
        DbgPrint("[%d] PktGetSpecialReferralTable(%wZ)\n",
                    (ULONG)((EndTime.QuadPart - StartTime.QuadPart)/(10 * 1000)),
                    Machine);
    }
#endif
    provider = ReplLookupProvider( PROV_ID_DFS_RDR );
    if (provider == NULL) {
        DfsDbgTrace(-1, Dbg, "Unable to open LM Rdr!\n", 0);
        return( STATUS_BAD_NETWORK_PATH );
    }

    RtlZeroMemory( &service, sizeof(DFS_SERVICE) );
    status = PktServiceConstruct(
                &service,
                DFS_SERVICE_TYPE_MASTER | DFS_SERVICE_TYPE_REFERRAL,
                PROV_DFS_RDR,
                STATUS_SUCCESS,
                PROV_ID_DFS_RDR,
                Machine,
                NULL);

    DfsDbgTrace(0, Dbg, "PktServiceConstruct returned %08lx\n", ULongToPtr(status) );

    //
    // Next, we build a connection to this machine and ask it for a referral.
    //

    if (NT_SUCCESS(status)) {

        PktAcquireShared( TRUE, &pktLocked );
        if (PsGetCurrentProcess() != DfsData.OurProcess) {
            KeStackAttachProcess( DfsData.OurProcess, &ApcState );
            attachedToSystemProcess = TRUE;
        }

        RestoreImpersonationState = PsDisableImpersonation(
                                        PsGetCurrentThread(),
                                        &DisabledImpersonationState);

        status = DfsCreateConnection(
                    &service,
                    provider,
                    FALSE,
                    &hServer);

#if DBG
        if (MupVerbose) {
            KeQuerySystemTime(&EndTime);
            DbgPrint("  [%d] DfsCreateConnection returned 0x%x\n",
                        (ULONG)((EndTime.QuadPart - StartTime.QuadPart)/(10 * 1000)),
                        status);
        }
#endif

        if (!NT_SUCCESS(status) && DfsEventLog > 0)
            LogWriteMessage(DFS_CONNECTION_FAILURE, status, 1, Machine);

        PktRelease();
        pktLocked = FALSE;
        DfsDbgTrace(0, Dbg, "DfsCreateConnection returned %08lx\n", ULongToPtr(status) );
    }

    MaxReferralLength = MAX_REFERRAL_LENGTH;

Retry:

    RtlZeroMemory( &refPath, sizeof(UNICODE_STRING) );

    if (NT_SUCCESS(status)) {
        ULONG ReferralSize = 0;

        refPath.Length = 0;
        refPath.MaximumLength = sizeof(UNICODE_NULL);

        ReferralSize = refPath.MaximumLength + sizeof(REQ_GET_DFS_REFERRAL);

        if (ReferralSize > MAX_REFERRAL_MAX) {
            status = STATUS_INVALID_PARAMETER;
        }
        else if (MaxReferralLength < ReferralSize)
        {
            MaxReferralLength = ReferralSize;
        }

        if (NT_SUCCESS(status)) {
            refPath.Buffer = ExAllocatePoolWithTag(NonPagedPool,
                                                   refPath.MaximumLength + MaxReferralLength,
                                                   ' puM');


            if (refPath.Buffer != NULL) {
                ref = (PREQ_GET_DFS_REFERRAL)
                &refPath.Buffer[refPath.MaximumLength / sizeof(WCHAR)];
                refPath.Buffer[ refPath.Length / sizeof(WCHAR) ] = UNICODE_NULL;
                ref->MaxReferralLevel = 3;

                RtlMoveMemory(&ref->RequestFileName[0],
                              refPath.Buffer,
                              refPath.Length + sizeof(WCHAR));

                DfsDbgTrace(0, Dbg, "Referral Path : (%ws)\n", ref->RequestFileName);

                refSize = sizeof(USHORT) + refPath.Length + sizeof(WCHAR);

                DfsDbgTrace(0, Dbg, "Referral Size is %d bytes\n", ULongToPtr(refSize) );
            } else {

                DfsDbgTrace(0, Dbg, "Unable to allocate %d bytes\n",
                            ULongToPtr(refPath.MaximumLength + MaxReferralLength));

                status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
    }

    if (NT_SUCCESS(status)) {

        DfsDbgTrace(0, Dbg, "Ref Buffer @%08lx\n", ref);

        status = ZwFsControlFile(
                    hServer,                     // Target
                    NULL,                        // Event
                    NULL,                        // APC Routine
                    NULL,                        // APC Context,
                    &iosb,                       // Io Status block
                    FSCTL_DFS_GET_REFERRALS,     // FS Control code
                    (PVOID) ref,                 // Input Buffer
                    refSize,                     // Input Buffer Length
                    (PVOID) ref,                 // Output Buffer
                    MaxReferralLength);          // Output Buffer Length

        DfsDbgTrace(0, Dbg, "Fscontrol returned %08lx\n", ULongToPtr(status) );
#if DBG
        if (MupVerbose) {
            KeQuerySystemTime(&EndTime);
            DbgPrint("  [%d] ZwFsControlFile returned 0x%x\n",
                        (ULONG)((EndTime.QuadPart - StartTime.QuadPart)/(10 * 1000)),
                        status);
        }
#endif

    }

    //
    // Use the referral to expand the entry
    //

    if (NT_SUCCESS(status)) {
        PktAcquireExclusive( TRUE, &pktLocked );
        status = PktCreateSpecialEntryTableFromReferral(
                    &DfsData.Pkt,
                    &refPath,
                    (ULONG)iosb.Information,
                    (PRESP_GET_DFS_REFERRAL) ref,
		    (SystemDC == TRUE) ? NULL : Machine);

        DfsDbgTrace(0, Dbg, "PktGetSpecialReferralTable returned %08lx\n",
            ULongToPtr(status) );

    } else if (status == STATUS_BUFFER_OVERFLOW && (refPath.Buffer!= NULL) && MaxReferralLength < MAX_REFERRAL_MAX) {

        //
        // The referral didn't fit in the buffer supplied.  Make it bigger and try
        // again.
        //

        DfsDbgTrace(0, Dbg, "PktGetSpecialReferralTable: MaxReferralLength %d too small\n",
                        ULongToPtr(MaxReferralLength) );

        ExFreePool(refPath.Buffer);
        refPath.Buffer = NULL;
        MaxReferralLength *= 2;
        if (MaxReferralLength > MAX_REFERRAL_MAX)
            MaxReferralLength = MAX_REFERRAL_MAX;
        status = STATUS_SUCCESS;
        goto Retry;

    }

    if (!NT_SUCCESS(status) && DfsEventLog > 0)
        LogWriteMessage(DFS_SPECIAL_REFERRAL_FAILURE, status, 1, Machine);

    if (pktLocked) {
        PktRelease();
        pktLocked = FALSE;
    }

    //
    // Well, we are done. Cleanup all the things we allocated...
    //
    PktServiceDestroy( &service, FALSE );
    if (hServer != NULL) {
        ZwClose( hServer );
    }

    if (refPath.Buffer != NULL) {
        ExFreePool( refPath.Buffer );
    }

    if (attachedToSystemProcess) {
        KeUnstackDetachProcess(&ApcState);
    }

    if (RestoreImpersonationState) {
            PsRestoreImpersonation(
                PsGetCurrentThread(),
                &DisabledImpersonationState);
    }

    DfsDbgTrace(-1, Dbg, "PktGetSpecialReferralTable returning %08lx\n", ULongToPtr(status) );

#if DBG
    if (MupVerbose) {
        KeQuerySystemTime(&EndTime);
        DbgPrint("[%d] PktGetSpecialReferralTable exit 0x%x\n",
                    (ULONG)((EndTime.QuadPart - StartTime.QuadPart)/(10 * 1000)),
                    status);
    }
#endif
    return( status );
}

//+--------------------------------------------------------------------
//
// Function:    PktLookupSpecialEntry
//
// Synopsis:    Looks up a PDFS_SPECIAL_ENTRY by name in the pkt
//
// Arguments:   Name - Name to search on
//
// Returns:     [pointer] PDFS_SPECIAL_ENTRY, if found
//              [pointer] NULL, if not found
//
//---------------------------------------------------------------------

PDFS_SPECIAL_ENTRY
PktLookupSpecialNameEntry(
    PUNICODE_STRING Name)
{
    PDFS_SPECIAL_ENTRY pSpecialEntry;
    PDFS_SPECIAL_TABLE pSpecialTable;
    PDFS_PKT Pkt;
    ULONG i;

    DfsDbgTrace(+1, Dbg, "PktLookupSpecialNameEntry(%wZ)\n", Name);

    Pkt = _GetPkt();
    pSpecialTable = &Pkt->SpecialTable;

    if (pSpecialTable->SpecialEntryCount == 0) {
        return (NULL);
    }

    DfsDbgTrace( 0, Dbg, "Cache contains %d entries...\n", ULongToPtr(pSpecialTable->SpecialEntryCount) );

    pSpecialEntry = CONTAINING_RECORD(
                        pSpecialTable->SpecialEntryList.Flink,
                        DFS_SPECIAL_ENTRY,
                        Link);

    for (i = 0; i < pSpecialTable->SpecialEntryCount; i++) {

        DfsDbgTrace( 0, Dbg, "Comparing with %wZ\n", &pSpecialEntry->SpecialName);

        if (RtlCompareUnicodeString(Name, &pSpecialEntry->SpecialName, TRUE) == 0) {

            DfsDbgTrace( 0, Dbg, "Cache hit\n", 0);
            DfsDbgTrace(-1, Dbg, "returning 0x%x\n", pSpecialEntry);

            return (pSpecialEntry);
        }
        pSpecialEntry = CONTAINING_RECORD(
                            pSpecialEntry->Link.Flink,
                            DFS_SPECIAL_ENTRY,
                            Link);
    }
    //
    // Nothing found
    //

    DfsDbgTrace(-1, Dbg, "PktLookupSpecialNameEntry: returning NULL\n", 0);

    return (NULL);
}

//+--------------------------------------------------------------------
//
// Function:    PktCreateSpecialNameEntry
//
// Synopsis:    Inserts a DFS_SPECIAL_ENTRY into the pkt, on a best-effort
//              basis.
//
// Arguments:   pSpecialEntry - Entry to insert
//
// Returns:     STATUS_SUCCESS
//
//---------------------------------------------------------------------

NTSTATUS
PktCreateSpecialNameEntry(
    PDFS_SPECIAL_ENTRY pSpecialEntry)
{
    PDFS_PKT Pkt;
    PDFS_SPECIAL_TABLE pSpecialTable;
    PDFS_SPECIAL_ENTRY pExistingEntry;

    Pkt = _GetPkt();
    pSpecialTable = &Pkt->SpecialTable;

    DfsDbgTrace(+1, Dbg, "PktCreateSpecialNameEntry entered\n", 0);

    pExistingEntry = PktLookupSpecialNameEntry(&pSpecialEntry->SpecialName);

    if (pExistingEntry == NULL) {

        //
        // Put the new one in
        //

        InsertHeadList(&pSpecialTable->SpecialEntryList, &pSpecialEntry->Link);
        pSpecialTable->SpecialEntryCount++;

        DfsDbgTrace(-1, Dbg, "added entry %d\n", ULongToPtr(pSpecialTable->SpecialEntryCount) );

    } else { // entry already exists

        if (pExistingEntry->UseCount == 0) {
        
            if (pSpecialEntry->ExpandedCount > 0) {

                //
                // Unlink the entry
                //

                RemoveEntryList(&pExistingEntry->Link);
                pSpecialTable->SpecialEntryCount--;

                //
                // And free it...

                PktSpecialEntryDestroy(pExistingEntry);

                //
                // Now put the new one in
                //

                InsertHeadList(&pSpecialTable->SpecialEntryList, &pSpecialEntry->Link);
                pSpecialTable->SpecialEntryCount++;

                DfsDbgTrace(-1, Dbg, "added entry %d\n", ULongToPtr(pSpecialTable->SpecialEntryCount) );

            } else {

                pExistingEntry->Stale = TRUE;
                PktSpecialEntryDestroy(pSpecialEntry);
                DfsDbgTrace(-1, Dbg, "marked exising stale, dropping new entry on the floor\n", 0);

            }

        } else {

            //
            // Entry in use - can't replace, so free the replacement one
            //

            PktSpecialEntryDestroy(pSpecialEntry);

            DfsDbgTrace(-1, Dbg, "dropped entry\n", 0);

        }

    }

    return (STATUS_SUCCESS);
}

//+--------------------------------------------------------------------
//
// Function:    PktEntryFromSpecialEntry
//
// Synopsis:    Creates a DFS_PKT_ENTRY from a DFS_SPECIAL_ENTRY, used
//              to support sysvols
//
// Arguments:   pSpecialEntry - Entry to Convert
//              pShareName - Name of share to append to address
//              ppPktEntry - The result
//
// Returns:     STATUS_SUCCESS
//              STATUS_INSUFFICIENT_RESOURCES
//
//---------------------------------------------------------------------

NTSTATUS
PktEntryFromSpecialEntry(
    IN  PDFS_SPECIAL_ENTRY pSpecialEntry,
    IN  PUNICODE_STRING pShareName,
    OUT PDFS_PKT_ENTRY *ppPktEntry)
{
    NTSTATUS status;
    PDFS_PKT_ENTRY pktEntry = NULL;
    PDFS_SERVICE pServices = NULL;
    PDS_MACHINE pMachine = NULL;
    PDFS_EXPANDED_NAME pExpandedNames;
    ULONG svc;
    ULONG Size;
    PWCHAR pwch;

    if (pSpecialEntry->ExpandedCount == 0
            ||
        DfspIsSysVolShare(pShareName) == FALSE
    ) {

        return STATUS_BAD_NETWORK_PATH;

    }

    pktEntry = ExAllocatePoolWithTag(
                            PagedPool,
                            sizeof(DFS_PKT_ENTRY),
                            ' puM');

    if (pktEntry == NULL) {

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;

    }

    RtlZeroMemory( pktEntry, sizeof(DFS_PKT_ENTRY) );

    pServices = ExAllocatePoolWithTag(
                            PagedPool,
                            sizeof(DFS_SERVICE) * pSpecialEntry->ExpandedCount,
                            ' puM');

    if (pServices == NULL) {

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;

    }

    RtlZeroMemory( pServices, sizeof(DFS_SERVICE) * pSpecialEntry->ExpandedCount);

    pktEntry->NodeTypeCode = DSFS_NTC_PKT_ENTRY;
    pktEntry->NodeByteSize = sizeof(DFS_PKT_ENTRY);
    pktEntry->USN = 1;
    pktEntry->Type = PKT_ENTRY_TYPE_NONDFS | PKT_ENTRY_TYPE_SYSVOL;
    pktEntry->ExpireTime = 60 * 60;
    pktEntry->TimeToLive = 60 * 60;

    InitializeListHead(&pktEntry->Link);
    InitializeListHead(&pktEntry->SubordinateList);
    InitializeListHead(&pktEntry->ChildList);

    //
    // Create Prefix and ShortPrefix from SpecialName and ShareName
    //

    Size = sizeof(UNICODE_PATH_SEP) +
                   pSpecialEntry->SpecialName.Length +
                       sizeof(UNICODE_PATH_SEP) +
                           pShareName->Length;

    pwch = ExAllocatePoolWithTag(
                    PagedPool,
                    Size,
                    ' puM');

    if (pwch == NULL) {

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;

    }

    pktEntry->Id.Prefix.Buffer = pwch;
    pktEntry->Id.Prefix.Length = (USHORT) Size;
    pktEntry->Id.Prefix.MaximumLength = (USHORT) Size;

    *pwch++ = UNICODE_PATH_SEP;

    RtlCopyMemory(
            pwch,
            pSpecialEntry->SpecialName.Buffer,
            pSpecialEntry->SpecialName.Length);

    pwch += pSpecialEntry->SpecialName.Length/sizeof(WCHAR);

    *pwch++ = UNICODE_PATH_SEP;

    RtlCopyMemory(
            pwch,
            pShareName->Buffer,
            pShareName->Length);

    pwch = ExAllocatePoolWithTag(
                    PagedPool,
                    Size,
                    ' puM');

    if (pwch == NULL) {

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;

    }

    pktEntry->Id.ShortPrefix.Buffer = pwch;
    pktEntry->Id.ShortPrefix.Length = (USHORT) Size;
    pktEntry->Id.ShortPrefix.MaximumLength = (USHORT) Size;

    RtlCopyMemory(
            pwch,
            pktEntry->Id.Prefix.Buffer,
            pktEntry->Id.Prefix.Length);

    pktEntry->Info.ServiceCount = pSpecialEntry->ExpandedCount;
    pktEntry->Info.ServiceList = pServices;

    //
    // Loop over the Expanded names, creating a Service for each
    //

    pExpandedNames = pSpecialEntry->ExpandedNames;
    for (svc = 0; svc < pSpecialEntry->ExpandedCount; svc++) {

        pServices[svc].Type = DFS_SERVICE_TYPE_MASTER | DFS_SERVICE_TYPE_DOWN_LEVEL;
        pServices[svc].Capability = PROV_STRIP_PREFIX;
        pServices[svc].ProviderId = PROV_ID_MUP_RDR;

        //
        // Machine name
        //

        Size = pExpandedNames[svc].ExpandedName.Length;
        pwch = ExAllocatePoolWithTag(
                        PagedPool,
                        Size,
                        ' puM');

        if (pwch == NULL) {

            status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;

        }

        pServices[svc].Name.Buffer = pwch;
        pServices[svc].Name.Length = (USHORT) Size;
        pServices[svc].Name.MaximumLength = (USHORT) Size;

        RtlCopyMemory(
                pwch,
                pExpandedNames[svc].ExpandedName.Buffer,
                pExpandedNames[svc].ExpandedName.Length);

        //
        // Address (\machine\share)
        //

        Size = sizeof(UNICODE_PATH_SEP) +
                   pExpandedNames[svc].ExpandedName.Length +
                       sizeof(UNICODE_PATH_SEP) +
                           pShareName->Length;

        pwch = ExAllocatePoolWithTag(
                        PagedPool,
                        Size,
                        ' puM');

        if (pwch == NULL) {

            status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;

        }

        pServices[svc].Address.Buffer = pwch;
        pServices[svc].Address.Length = (USHORT) Size;
        pServices[svc].Address.MaximumLength = (USHORT) Size;

        *pwch++ = UNICODE_PATH_SEP;

        RtlCopyMemory(
                pwch,
                pExpandedNames[svc].ExpandedName.Buffer,
                pExpandedNames[svc].ExpandedName.Length);

        pwch += pExpandedNames[svc].ExpandedName.Length/sizeof(WCHAR);

        *pwch++ = UNICODE_PATH_SEP;

        RtlCopyMemory(
                pwch,
                pShareName->Buffer,
                pShareName->Length);

        //
        // Alloc and init a DSMachine struct
        //

        pMachine = PktpGetDSMachine( &pServices[svc].Name );

        if (pMachine == NULL) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        pServices[svc].pMachEntry = ExAllocatePoolWithTag(
                                    PagedPool, sizeof(DFS_MACHINE_ENTRY),
                                    ' puM');

        if (pServices[svc].pMachEntry == NULL) {

            status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;

        }

        RtlZeroMemory( (PVOID) pServices[svc].pMachEntry, sizeof(DFS_MACHINE_ENTRY));
        pServices[svc].pMachEntry->pMachine = pMachine;
        pServices[svc].pMachEntry->UseCount = 1;



    }

    //
    // Set active service to the same as the spc's active entry
    //

    pktEntry->ActiveService = &pServices[pSpecialEntry->Active];

    *ppPktEntry = pktEntry;

    return STATUS_SUCCESS;

Cleanup:

    if (pServices != NULL) {

        for (svc = 0; svc < pSpecialEntry->ExpandedCount; svc++) {

            if (pServices[svc].Name.Buffer != NULL)
                    ExFreePool(pServices[svc].Name.Buffer);
            if (pServices[svc].Address.Buffer != NULL)
                    ExFreePool(pServices[svc].Address.Buffer);
            if (pServices[svc].pMachEntry != NULL) {

                DfsDecrementMachEntryCount(pServices[svc].pMachEntry, TRUE);
            }

        }

        ExFreePool(pServices);
    }

    //
    // Cleanup on error
    //

    if (pktEntry != NULL) {

        if (pktEntry->Id.Prefix.Buffer != NULL)
            ExFreePool(pktEntry->Id.Prefix.Buffer);
        if (pktEntry->Id.ShortPrefix.Buffer != NULL)
            ExFreePool(pktEntry->Id.ShortPrefix.Buffer);

        ExFreePool(pktEntry);

    }

    return status;

}

//+----------------------------------------------------------------------------
//
//  Function:   DfspSetActiveServiceByServerName
//
//  Synopsis:   Makes a given ServerName active
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------
NTSTATUS
DfspSetActiveServiceByServerName(
    PUNICODE_STRING ServerName,
    PDFS_PKT_ENTRY pktEntry)
{
    UNICODE_STRING Server;
    PDFS_SERVICE pService;
    NTSTATUS NtStatus = STATUS_OBJECT_NAME_NOT_FOUND;
    ULONG i;

    DfsDbgTrace(+1, Dbg, "DfspSetActiveServiceByServerName\n", 0);

    for (i = 0; i < pktEntry->Info.ServiceCount && NtStatus != STATUS_SUCCESS; i++) {

        LPWSTR wp;

        pService = &pktEntry->Info.ServiceList[i];

        DfsDbgTrace( 0, Dbg, "Examining %wZ\n", &pService->Address);

        //
        // Tease apart the address (of form \Server\Share) into Server and Share
        //
        RemoveLastComponent(&pService->Address, &Server);

        //
        // Remove leading & trailing '\'s
        //
        Server.Length -= 2* sizeof(WCHAR);
        Server.MaximumLength = Server.Length;
        Server.Buffer++;

        //
        // If ServerName doesn't match, then move on to the next service
        //
        if ( RtlCompareUnicodeString(ServerName, &Server, TRUE) ) {

            continue;

        }

        DfsDbgTrace( 0, Dbg, "DfspSetActiveServiceByServerName: Server=%wZ\n", &Server);

        //
        // Make this the active share
        //

        pktEntry->ActiveService = pService;

        NtStatus = STATUS_SUCCESS;

    }

    DfsDbgTrace(-1, Dbg, "DfspSetActiveServiceByServerName -> %08lx\n", ULongToPtr(NtStatus) );

    return NtStatus;
}

//+----------------------------------------------------------------------------
//
//  Function:   DfspIsDupPktEntry
//
//  Synopsis:   Checks if a potential pkt entry is a dup of an existing one
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------
BOOLEAN
DfspIsDupPktEntry(
    PDFS_PKT_ENTRY ExistingEntry,
    ULONG EntryType,
    PDFS_PKT_ENTRY_ID EntryId,
    PDFS_PKT_ENTRY_INFO EntryInfo)
{
    ULONG i;
    ULONG j;
    PDFS_SERVICE pNewSvc;
    PDFS_SERVICE pExistSvc;
    BOOLEAN FoundDup = FALSE;


    if (
        ExistingEntry == NULL
            ||
        EntryId == NULL
            ||
        EntryInfo == NULL
    )
        return FALSE;

#if DBG
    if (MupVerbose)
        DbgPrint("  DfspIsDupPktEntry([%wZ][%wZ])\n",
                &EntryId->Prefix,
                &ExistingEntry->Id.Prefix);
#endif

    if (EntryType != ExistingEntry->Type) {
#if DBG
        if (MupVerbose)
            DbgPrint("  DfspIsDupPktEntry(1) returning FALSE\n");
#endif
        return FALSE;
    }

    if (!GuidEqual(&EntryId->Uid, &ExistingEntry->Id.Uid)) {
#if DBG
        if (MupVerbose)
            DbgPrint("  DfspIsDupPktEntry(2) returning FALSE\n");
#endif
        return FALSE;
    }

    if (
        RtlCompareUnicodeString(&EntryId->Prefix, &ExistingEntry->Id.Prefix,TRUE) != 0
            ||
        RtlCompareUnicodeString(&EntryId->ShortPrefix, &ExistingEntry->Id.ShortPrefix,TRUE) != 0
    ) {
#if DBG
        if (MupVerbose)
            DbgPrint("  DfspIsDupPktEntry(3) returning FALSE\n");
#endif
        return FALSE;
    }

    //
    // Now we have to compare all the services
    //

    if (EntryInfo->ServiceCount != ExistingEntry->Info.ServiceCount) {
#if DBG
        if (MupVerbose)
            DbgPrint("  DfspIsDupPktEntry(4) returning FALSE\n");
#endif
        return FALSE;
    }

    for (i = 0; i < EntryInfo->ServiceCount; i++) {
        FoundDup = FALSE;
        pNewSvc = &EntryInfo->ServiceList[i];
        for (j = 0; j < ExistingEntry->Info.ServiceCount; j++) {
            pExistSvc = &ExistingEntry->Info.ServiceList[j];
            if (DfspIsDupSvc(pExistSvc,pNewSvc) == TRUE) {
                FoundDup = TRUE;
                break;
            }
        }
        if (FoundDup != TRUE) {
#if DBG
            if (MupVerbose)
                DbgPrint("  DfspIsDupPktEntry(5) returning FALSE\n");
#endif
            return FALSE;
        }
    }

    for (i = 0; i < ExistingEntry->Info.ServiceCount; i++) {
        FoundDup = FALSE;
        pExistSvc = &ExistingEntry->Info.ServiceList[i];
        for (j = 0; j < EntryInfo->ServiceCount; j++) {
            pNewSvc = &EntryInfo->ServiceList[j];
            if (DfspIsDupSvc(pExistSvc,pNewSvc) == TRUE) {
                FoundDup = TRUE;
                break;
            }
         }
         if (FoundDup != TRUE) {
#if DBG
            if (MupVerbose)
                DbgPrint("  DfspIsDupPktEntry(6) returning FALSE\n");
#endif
            return FALSE;
        }
    }

#if DBG
    if (MupVerbose)
        DbgPrint("  DfspIsDupPktEntry returning TRUE\n");
#endif
    return TRUE;

}

//+----------------------------------------------------------------------------
//
//  Function:   DfspIsDupSvc
//
//  Synopsis:   Checks if two services are, for all dfs purposes, identical
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

BOOLEAN
DfspIsDupSvc(
    PDFS_SERVICE pExistSvc,
    PDFS_SERVICE pNewSvc)
{
#if DBG
    if (MupVerbose & 0x80000000) {
        DbgPrint("DfspIsDupSvc([%wZ][%wZ] vs [%wZ][%wZ])\n",
            &pExistSvc->Name, &pExistSvc->Address,
            &pNewSvc->Name, &pNewSvc->Address);
        DbgPrint("Type: 0x%x vs 0x%x\n", pExistSvc->Type, pNewSvc->Type);
        DbgPrint("Capability: 0x%x vs 0x%x\n", pExistSvc->Capability, pNewSvc->Capability);
        DbgPrint("ProviderId: 0x%x vs 0x%x\n", pExistSvc->ProviderId, pNewSvc->ProviderId);
    }
#endif
    if (
        pExistSvc->Capability != pNewSvc->Capability
            ||
        RtlCompareUnicodeString(&pExistSvc->Name, &pNewSvc->Name, TRUE) != 0
            ||
        RtlCompareUnicodeString(&pExistSvc->Address, &pNewSvc->Address, TRUE) != 0
    ) {
#if DBG
        if (MupVerbose & 0x80000000)
            DbgPrint("...FALSE\n");
#endif
        return FALSE;
    }

#if DBG
    if (MupVerbose & 0x80000000)
        DbgPrint("...TRUE\n");
#endif

    return TRUE;
}

BOOLEAN
DfspDnsNameToFlatName(
    PUNICODE_STRING DnsName,
    PUNICODE_STRING FlatName)
{
    USHORT i;

    *FlatName = *DnsName;

    for (i = 1; i < (DnsName->Length/sizeof(WCHAR)); i++) {
        if (FlatName->Buffer[i] == L'.') {
            FlatName->Length = i * sizeof(WCHAR);
            break;
        }
    }
#if DBG
    if (MupVerbose)
        DbgPrint("  DfspDnsNameToFlatName:[%wZ]->[%wZ]\n",
            DnsName,
            FlatName);
#endif
    return TRUE;
}


#define MAX_SPECIAL_ENTRIES 500

//+----------------------------------------------------------------------------
//
//  Function:   PktpUpdateSpecialTable
//
//  Synopsis:   Adds entries to the special table, given a domain and a dcname.
//              We contact the dc for a list of trusted domains either if we
//              dont have the domain already in our list OR we have the domain
//              but we haven't called this code atleast once with that domain
//              name.
//  Arguments:  DomainName and DCName.
//
//  Returns:    Success or Failure status
//
//-----------------------------------------------------------------------------

NTSTATUS
PktpUpdateSpecialTable(
    PUNICODE_STRING DomainName,
    PUNICODE_STRING DCName
)
{		       
        ULONG count = 0;
        BOOLEAN needReferral = FALSE;
        NTSTATUS status = STATUS_SUCCESS;
        PDFS_SPECIAL_ENTRY pSpecialEntry;
        BOOLEAN pktLocked = FALSE;
        PDFS_PKT Pkt = _GetPkt();

        DfsDbgTrace(+1, Dbg, "PktpUpdateSpecialTable -> Domain %wZ\n", 
                    DomainName);
        DfsDbgTrace(0, Dbg, "PktpUpdateSpecialTable -> DCname %wZ\n", 
        	    DCName);

        if ((DomainName->Length ==0) || (DCName->Length == 0)) {
          return STATUS_BAD_NETWORK_PATH;
        }
	
        PktAcquireExclusive(TRUE, &pktLocked);
        pSpecialEntry = PktLookupSpecialNameEntry(DomainName);

        // If we dont have the domain in our table, or we haven't checked
        // against this domain atleast once AND the DC is not the dc that
        // is stored in our pkt table, we decide we need a referral.
        //
    
        if (pSpecialEntry == NULL) {
            needReferral = TRUE;
        }
        else {
            if (pSpecialEntry->GotDCReferral == FALSE) {
              pSpecialEntry->GotDCReferral = TRUE;
              needReferral = TRUE;
            }
        }

        if ((needReferral == TRUE) && (Pkt->DCName.Length != 0)) {
          if (RtlEqualUnicodeString(&Pkt->DCName, DCName, TRUE)) {
            needReferral = FALSE;
          }
        }
        PktRelease();
	
        if (needReferral) {
	    
            count = Pkt->SpecialTable.SpecialEntryCount;
            if (Pkt->SpecialTable.SpecialEntryCount >= MAX_SPECIAL_ENTRIES) {
                  status = STATUS_DOMAIN_LIMIT_EXCEEDED;
            }
            else {
                  status = PktGetSpecialReferralTable(DCName, FALSE);	
            }
        }

	if (NT_SUCCESS(status)) {
	  DfsDbgTrace(0, Dbg, "PktpUpdateSpecialTable: added %d entries\n",
		      ULongToPtr( Pkt->SpecialTable.SpecialEntryCount - count ));
	}

        DfsDbgTrace(-1, Dbg, "PktpUpdateSpecialTable -> Status 0x%x\n", 
        	    ULongToPtr( status ));

        return status;
}



PDFS_PKT_ENTRY
PktFindEntryByPrefix(
    IN  PDFS_PKT Pkt,
    IN  PUNICODE_STRING Prefix
)
{
    PUNICODE_PREFIX_TABLE_ENTRY pfxEntry;
    PDFS_PKT_ENTRY              pktEntry = NULL;
    UNICODE_STRING Remaining;

    Remaining.Length = 0;
    DfsDbgTrace(+1, Dbg, "PktFindEntryByPrefix: Entered\n", 0);

    //
    // If there really is a prefix to lookup, use the prefix table
    //  to initially find an entry
    //

    if ((Prefix->Length != 0) &&
       (pfxEntry = DfsFindUnicodePrefix(&Pkt->PrefixTable,Prefix,&Remaining))) {

        pktEntry = CONTAINING_RECORD(pfxEntry,
                                     DFS_PKT_ENTRY,
                                     PrefixTableEntry);
    }

    return pktEntry;
}


//
// Fix for bug: 29300.
// Do not attach the process to system thread. Instead, post the work to the
// system process.
//


typedef enum _TYPE_OF_REFERRAL {
    REFERRAL_TYPE_GET_PKT,
    REFERRAL_TYPE_EXPAND_SPECIAL_TABLE,
    REFERRAL_TYPE_GET_REFERRAL_TABLE
} TYPE_OF_REFERRAL;


typedef struct _PKT_REFERRAL_CONTEXT {
    UNICODE_STRING ContextName;
    UNICODE_STRING DomainName;
    UNICODE_STRING ShareName;
    BOOLEAN ContextBool;
    WORK_QUEUE_ITEM WorkQueueItem;
    KEVENT  Event;
    TYPE_OF_REFERRAL   Type;
    ULONG   RefCnt;
    NTSTATUS Status;
    PVOID   Data;
} PKT_REFERRAL_CONTEXT, *PPKT_REFERRAL_CONTEXT;




VOID
PktWorkInSystemContext(
    PPKT_REFERRAL_CONTEXT Context )
{

    NTSTATUS Status;

    switch (Context->Type) {

    case REFERRAL_TYPE_GET_PKT:
       Status = _PktGetReferral( &Context->ContextName,
                                 &Context->DomainName,
                                 &Context->ShareName,
                                 Context->ContextBool );
       break;

    case REFERRAL_TYPE_EXPAND_SPECIAL_TABLE:
       Status = _PktExpandSpecialName( &Context->ContextName,
                                       (PDFS_SPECIAL_ENTRY *)&Context->Data );
       break;

    case REFERRAL_TYPE_GET_REFERRAL_TABLE:
       Status = _PktGetSpecialReferralTable( &Context->ContextName,
                                             Context->ContextBool );
       break;

    default:
       Status = STATUS_INVALID_PARAMETER;
       break;
    }

    Context->Status = Status;

    KeSetEvent( &Context->Event, 0, FALSE );

    if (InterlockedDecrement(&Context->RefCnt) == 0) {
        ExFreePool(Context);
    }
}

NTSTATUS
PktPostSystemWork( 
    PPKT_REFERRAL_CONTEXT pktContext,
    PVOID *Data )
{
    NTSTATUS Status;

    KeInitializeEvent( &pktContext->Event,
                        SynchronizationEvent, 
                        FALSE );
  
    ExInitializeWorkItem( &pktContext->WorkQueueItem,
                          PktWorkInSystemContext,
                          pktContext );

    ExQueueWorkItem( &pktContext->WorkQueueItem, CriticalWorkQueue );

    Status = KeWaitForSingleObject( &pktContext->Event,
                                    UserRequest,
                                    KernelMode,
                                    FALSE,
                                    NULL);
    MUP_TRACE_ERROR_HIGH(Status, ALL_ERROR, PktPostSystemWork_Error_KeWaitForSingleObject,
                         LOGSTATUS(Status));

    if (Status == STATUS_SUCCESS) {
        Status = pktContext->Status;
    }
    if (Data != NULL) {
       *Data = pktContext->Data;
    }

    if (InterlockedDecrement(&pktContext->RefCnt) == 0) {
        ExFreePool(pktContext);
    }

    return Status;
}

NTSTATUS
PktGetReferral(
    IN PUNICODE_STRING MachineName, // Machine to direct referral to
    IN PUNICODE_STRING DomainName,  // the machine or domain name to use
    IN PUNICODE_STRING ShareName,   // the ftdfs or dfs name
    IN BOOLEAN         CSCAgentCreate) // the CSC agent create flag
{
    PPKT_REFERRAL_CONTEXT pktContext = NULL;
    NTSTATUS Status;

    ULONG NameSize = 0;

    NameSize = MachineName->Length * sizeof(WCHAR);
    NameSize += DomainName->Length * sizeof(WCHAR);
    NameSize += ShareName->Length *  sizeof(WCHAR);


    if ((MupUseNullSessionForDfs == TRUE) &&
	(PsGetCurrentProcess() != DfsData.OurProcess)) {
       pktContext = ExAllocatePoolWithTag( NonPagedPool,
                                           sizeof (PKT_REFERRAL_CONTEXT) + NameSize,
                                           ' puM');
    }
    if (pktContext != NULL) {
        pktContext->ContextName.MaximumLength = MachineName->Length;
        pktContext->ContextName.Buffer = (WCHAR *)(pktContext + 1);
        RtlCopyUnicodeString(&pktContext->ContextName, MachineName);
        
        pktContext->DomainName.MaximumLength = DomainName->Length;
        pktContext->DomainName.Buffer = pktContext->ContextName.Buffer + pktContext->ContextName.MaximumLength;
        RtlCopyUnicodeString(&pktContext->DomainName, DomainName);

        pktContext->ShareName.MaximumLength = ShareName->Length;
        pktContext->ShareName.Buffer = pktContext->DomainName.Buffer + pktContext->DomainName.MaximumLength;
        RtlCopyUnicodeString(&pktContext->ShareName, ShareName);

        pktContext->ContextBool = CSCAgentCreate;
        pktContext->Type =  REFERRAL_TYPE_GET_PKT;
        pktContext->RefCnt = 2;

        Status = PktPostSystemWork( pktContext, NULL);
    } 
    else {
        Status = _PktGetReferral( MachineName,
                                  DomainName,
                                  ShareName,
                                  CSCAgentCreate );
    }

    return Status;
}

NTSTATUS
PktExpandSpecialName(
    IN PUNICODE_STRING Name,
    PDFS_SPECIAL_ENTRY *ppSpecialEntry)
{
    PPKT_REFERRAL_CONTEXT pktContext = NULL;
    NTSTATUS Status;

    ULONG NameSize = 0;

    NameSize = Name->Length * sizeof(WCHAR);

    if ((MupUseNullSessionForDfs == TRUE) &&
	(PsGetCurrentProcess() != DfsData.OurProcess)) {
       pktContext = ExAllocatePoolWithTag( NonPagedPool,
                                           sizeof (PKT_REFERRAL_CONTEXT) + NameSize,
                                           ' puM');
    }
    if (pktContext != NULL) {
        pktContext->ContextName.MaximumLength = Name->Length;
        pktContext->ContextName.Buffer = (WCHAR *)(pktContext + 1);
        RtlCopyUnicodeString(&pktContext->ContextName, Name);

        pktContext->Type = REFERRAL_TYPE_EXPAND_SPECIAL_TABLE;
        pktContext->RefCnt = 2;
        pktContext->Data = NULL;

        Status = PktPostSystemWork( pktContext, (PVOID *)ppSpecialEntry );
    }
    else {
        Status = _PktExpandSpecialName( Name, 
                                        ppSpecialEntry );
    }

    return Status;
}

NTSTATUS
PktGetSpecialReferralTable(
    IN PUNICODE_STRING Machine,
    BOOLEAN SystemDC)
{
    PPKT_REFERRAL_CONTEXT pktContext = NULL;
    NTSTATUS Status;

    ULONG NameSize = 0;

    NameSize = Machine->Length * sizeof(WCHAR);

    if ((MupUseNullSessionForDfs == TRUE) &&
	(PsGetCurrentProcess() != DfsData.OurProcess)) {
       pktContext = ExAllocatePoolWithTag( NonPagedPool,
                                           sizeof (PKT_REFERRAL_CONTEXT) + NameSize,
                                           ' puM');
    }
    if (pktContext != NULL) {
        pktContext->ContextName.MaximumLength = Machine->Length;
        pktContext->ContextName.Buffer = (WCHAR *)(pktContext + 1);
        RtlCopyUnicodeString(&pktContext->ContextName, Machine);

        pktContext->ContextBool = SystemDC;
        pktContext->Type = REFERRAL_TYPE_GET_REFERRAL_TABLE;
        pktContext->RefCnt = 2;

        Status = PktPostSystemWork( pktContext, NULL );
    } 
    else {
        Status = _PktGetSpecialReferralTable( Machine,
                                              SystemDC );
    }

    return Status;
}






NTSTATUS
PktGetTargetInfo( 
    HANDLE IpcHandle,
    PUNICODE_STRING pDomainName,
    PUNICODE_STRING pShareName,
    PDFS_TARGET_INFO *ppDfsTargetInfo )
{
    BOOLEAN SpecialName;
    PDFS_TARGET_INFO pDfsTargetInfo = NULL;
    NTSTATUS Status;


    SpecialName = (PktLookupSpecialNameEntry(pDomainName) == NULL) ? FALSE : TRUE;
    if ((SpecialName == FALSE) &&
	DfspIsSysVolShare(pShareName)) {
	SpecialName = TRUE;
    }

    if (SpecialName)
    {
        Status = PktCreateTargetInfo( pDomainName, 
                                      pShareName, 
                                      SpecialName,
                                      &pDfsTargetInfo );
    }
    else {
        Status = DfsGetLMRTargetInfo( IpcHandle,
                                      &pDfsTargetInfo );

        if (Status != STATUS_SUCCESS)
        {
            Status = PktCreateTargetInfo( pDomainName, 
                                          pShareName, 
                                          SpecialName,
                                          &pDfsTargetInfo );
        }
    }
    if (Status == STATUS_SUCCESS)
    {
        pDfsTargetInfo->DfsHeader.Type = 'grTM';
        pDfsTargetInfo->DfsHeader.UseCount=1;

        *ppDfsTargetInfo = pDfsTargetInfo;

    }


    return Status;
}
    
#define MAX_TARGET_INFO_RETRIES 3

NTSTATUS
DfsGetLMRTargetInfo(
    HANDLE IpcHandle,
    PDFS_TARGET_INFO *ppTargetInfo )
{
    ULONG TargetInfoSize, DfsTargetInfoSize;

    PDFS_TARGET_INFO pDfsTargetInfo;
    NTSTATUS Status = STATUS_SUCCESS;
    IO_STATUS_BLOCK ioStatusBlock;
    ULONG Retry = 0;
    TargetInfoSize = sizeof(LMR_QUERY_TARGET_INFO) + MAX_PATH;

TargetInfoRetry:
    DfsTargetInfoSize = TargetInfoSize + sizeof(DFS_TARGET_INFO_HEADER) + sizeof(ULONG);

    pDfsTargetInfo = ExAllocatePoolWithTag( PagedPool,
                                            DfsTargetInfoSize,
                                            ' puM');

    if (pDfsTargetInfo == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    if (Status == STATUS_SUCCESS)
    {
        RtlZeroMemory( pDfsTargetInfo, DfsTargetInfoSize );

        pDfsTargetInfo->LMRTargetInfo.BufferLength = TargetInfoSize;

        Status = ZwFsControlFile(
            IpcHandle,
            NULL,
            NULL,
            NULL,
            &ioStatusBlock,
            FSCTL_LMR_QUERY_TARGET_INFO,
            NULL,
            0,
            &pDfsTargetInfo->LMRTargetInfo,
            TargetInfoSize );

        if (Status == STATUS_BUFFER_TOO_SMALL) {
            TargetInfoSize = pDfsTargetInfo->LMRTargetInfo.BufferLength;

            ExFreePool( pDfsTargetInfo );
            pDfsTargetInfo = NULL;

            if (Retry++ < MAX_TARGET_INFO_RETRIES)
            {
                Status = STATUS_SUCCESS;
                goto TargetInfoRetry;
            }
        }
    }
    if (Status == STATUS_SUCCESS)
    {
        pDfsTargetInfo->DfsHeader.Flags = TARGET_INFO_LMR;
        *ppTargetInfo = pDfsTargetInfo;
    }
    else
    {
        if (pDfsTargetInfo != NULL)
        {
            ExFreePool(pDfsTargetInfo);
        }
    }
    return Status;
}

VOID
PktAcquireTargetInfo(
    PDFS_TARGET_INFO pDfsTargetInfo)
{
    ULONG Count;

    if (pDfsTargetInfo != NULL)
    {
        Count = InterlockedIncrement( &pDfsTargetInfo->DfsHeader.UseCount);
    }

    return;
}

VOID
PktReleaseTargetInfo(
    PDFS_TARGET_INFO pDfsTargetInfo)
{
    LONG Count;

    if (pDfsTargetInfo != NULL)
    {
        Count = InterlockedDecrement( &pDfsTargetInfo->DfsHeader.UseCount);
        if (Count == 0)
        {
            ExFreePool(pDfsTargetInfo);
        }
    }
    return;
}



NTSTATUS 
PktCreateTargetInfo(
    PUNICODE_STRING pDomainName,
    PUNICODE_STRING pShareName,
    BOOLEAN SpecialName,
    PDFS_TARGET_INFO *ppDfsTargetInfo )
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG TargetInfoSize;
    PDFS_TARGET_INFO pDfsTargetInfo;
    PCREDENTIAL_TARGET_INFORMATIONW pTargetInfo;
    LPWSTR StringBuf;

    TargetInfoSize = sizeof(DFS_TARGET_INFO) + 
                     sizeof(UNICODE_PATH_SEP)+
                     pDomainName->Length + 
                     sizeof(UNICODE_PATH_SEP) + 
                     pShareName->Length +
                     sizeof(WCHAR) +
                     pDomainName->Length + 
                     sizeof(WCHAR);

    pDfsTargetInfo = ExAllocatePoolWithTag( PagedPool,
                                            TargetInfoSize,
                                            ' puM' );
    if (pDfsTargetInfo == NULL)
     {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }
    else {
        RtlZeroMemory(pDfsTargetInfo,
                      TargetInfoSize);

        pDfsTargetInfo->DfsHeader.Flags = TARGET_INFO_DFS;

        pTargetInfo = &pDfsTargetInfo->TargetInfo;
        StringBuf = (LPWSTR)(pTargetInfo + 1);
            
        pTargetInfo->TargetName = StringBuf;

        RtlCopyMemory( StringBuf,
                       pDomainName->Buffer,
                       pDomainName->Length);
        StringBuf += (pDomainName->Length / sizeof(WCHAR));
        *StringBuf++ = UNICODE_PATH_SEP;
        RtlCopyMemory( StringBuf,
                       pShareName->Buffer,
                       pShareName->Length);
        StringBuf += (pShareName->Length / sizeof(WCHAR));
        *StringBuf++ =  0;

        pTargetInfo->DnsServerName = StringBuf;
        RtlCopyMemory( StringBuf,
                       pDomainName->Buffer,
                       pDomainName->Length);
        StringBuf += (pDomainName->Length / sizeof(WCHAR));
        *StringBuf++ =  0;

        //
        // Add this flag AFTER lab03 RI's, to prevent failure
        //

        pTargetInfo->Flags = CRED_TI_CREATE_EXPLICIT_CRED;

        pTargetInfo->Flags |= CRED_TI_SERVER_FORMAT_UNKNOWN;
        if (SpecialName == TRUE)
        {
            pTargetInfo->DnsDomainName = 
                pTargetInfo->DnsServerName;
            pTargetInfo->Flags |= CRED_TI_DOMAIN_FORMAT_UNKNOWN;
        }
        *ppDfsTargetInfo = pDfsTargetInfo;
    }
    return Status;
}

BOOLEAN
DfsIsSpecialName(
    PUNICODE_STRING pName)
{
    BOOLEAN pktLocked;
    PDFS_PKT Pkt;
    PDFS_SPECIAL_ENTRY pSpecialEntry;
    BOOLEAN ReturnValue;

    Pkt = _GetPkt();
    PktAcquireShared(TRUE, &pktLocked);

    pSpecialEntry = PktLookupSpecialNameEntry(pName);

    PktRelease();

    //
    // We don't have any expansion for this name
    //
    if (pSpecialEntry == NULL)
    {
        ReturnValue = FALSE;
    }
    else
    {
        ReturnValue = TRUE;
    }

    return ReturnValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mup\pkt.h ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:       PKT.H
//
//  Contents:   This module defines the data structures that make up the
//              major internal part of the Partition Knowledge Table (PKT).
//              The Partition Knowledge Table is used by the Dfs file
//              system to resolve a name to a specific partition (volume).
//
//  Functions:
//
//  History:    1 May 1992  PeterCo Created.
//-----------------------------------------------------------------------------



#ifndef _PKT_
#define _PKT_

//
// Pick up marshalling info for gluons
//

#include "dfsgluon.h"

//
// New Prefix Table Implementation
//
#include "prefix.h"

//
//  For determining the status of the Uid
//
#define GuidEqual(g1, g2)\
    (RtlCompareMemory((g1), (g2), sizeof(GUID)) == sizeof(GUID))

extern GUID _TheNullGuid;

#define NullGuid( guid )\
    (GuidEqual(guid, &_TheNullGuid))




//
//  Defines for Create Dispositions (we mimic the io system here).
//

#define PKT_ENTRY_CREATE            FILE_CREATE
#define PKT_ENTRY_REPLACE           FILE_OPEN
#define PKT_ENTRY_SUPERSEDE         FILE_SUPERSEDE

//
//  Different kind of referrals that a DC can give out.
//

#define DFS_STORAGE_REFERRAL                    (0x0001)
#define DFS_REFERRAL_REFERRAL                   (0x0002)

//
//  Types of service that can be supported by a provider.
//  A disjunction of any of the following values.
//

#define DFS_SERVICE_TYPE_MASTER                 (0x0001)
#define DFS_SERVICE_TYPE_READONLY               (0x0002)
#define DFS_SERVICE_TYPE_LOCAL                  (0x0004)
#define DFS_SERVICE_TYPE_REFERRAL               (0x0008)
#define DFS_SERVICE_TYPE_ACTIVE                 (0x0010)
#define DFS_SERVICE_TYPE_DOWN_LEVEL             (0x0020)
#define DFS_SERVICE_TYPE_COSTLIER               (0x0040)
#define DFS_SERVICE_TYPE_OFFLINE                (0x0080)

//
//  The status possibilities...
//

#define DFS_SERVICE_STATUS_VERIFIED     (0x0001)
#define DFS_SERVICE_STATUS_UNVERIFIED   (0x0002)

//
//  Types of Partition Knowledge Table Entries.
//  Low-order bits in these definitions correspond to volume object
//  types as defined in dfsh.idl.  High-order bits are specific
//  to PKT entries.
//

#define PKT_ENTRY_TYPE_DFS              0x0001   // Entry is to Dfs Aware srv
#define PKT_ENTRY_TYPE_MACHINE          0x0002   // Entry is a machine volume
#define PKT_ENTRY_TYPE_NONDFS           0x0004   // Entry refers to downlevel
#define PKT_ENTRY_TYPE_LEAFONLY         0x0008
#define PKT_ENTRY_TYPE_OUTSIDE_MY_DOM   0x0010   // Entry refers to volume in
                                                 // foreign domain
#define PKT_ENTRY_TYPE_SYSVOL           0x0040   // Sysvol
#define PKT_ENTRY_TYPE_REFERRAL_SVC     0x0080   // Entry refers to a DC

#define PKT_ENTRY_TYPE_PERMANENT        0x0100   // Entry cannot be scavenged
#define PKT_ENTRY_TYPE_DELETE_PENDING   0x0200   // Entry has pending delete
#define PKT_ENTRY_TYPE_LOCAL            0x0400   // Entry refers to local vol
#define PKT_ENTRY_TYPE_LOCAL_XPOINT     0x0800   // Entry refers to exit pt
#define PKT_ENTRY_TYPE_OFFLINE          0x2000   // Entry refers to a volume
                                                 // that is offline

//
// Type of messages the driver can send to DfsManager / DfsService
//

#define DFS_MSGTYPE_KNOW_INCONSISTENCY  0x0001
#define DFS_MSGTYPE_GET_DOMAIN_REFERRAL 0x0002
#define DFS_MSGTYPE_GET_DC_NAME         0x0003


//
//  There is one DFS_MACHINE_ENTRY for every unique DS_MACHINE that the
//  Dfs driver knows about. If a particular cairo server services multiple Dfs
//  volumes, then multiple DFS_SERVICE structs will point to a single, ref
//  counted DFS_MACHINE_ENTRY.
//

typedef struct DFS_MACHINE_ENTRY {

    PDS_MACHINE         pMachine;       // The addressing info is here.
    UNICODE_STRING      MachineName;    // The MachineName (principalName).
    ULONG               UseCount;       // Number of DFS_SVC structs using this
    ULONG               ConnectionCount;// The number of pkt entries that are
                                        // using this as their active machine
    PFILE_OBJECT        AuthConn;       // Handle to the tree connect with
    struct _DFS_CREDENTIALS *Credentials; // these credentials.
    UNICODE_PREFIX_TABLE_ENTRY  PrefixTableEntry;

} DFS_MACHINE_ENTRY, *PDFS_MACHINE_ENTRY;

//
// Marshalling info for DFS_MACHINE_ENTRY
//

extern MARSHAL_INFO MiMachineEntry;

#define INIT_DFS_MACHINE_ENTRY_MARSHAL_INFO()                               \
    static MARSHAL_TYPE_INFO _MCode_Machine_Entry[] = {                     \
        _MCode_pstruct(DFS_MACHINE_ENTRY, pMachine, &MiDSMachine)           \
    };                                                                      \
    MARSHAL_INFO MiMachineEntry = _mkMarshalInfo(DFS_SERVICE, _MCode_Machine_Entry);


//
//  A DFS_SERVICE structure is used to describe the provider and
//  network address to be contacted for a specific partition of
//  the distributed file system.
//

typedef struct _DFS_SERVICE {

    ULONG Type;             // type of service (see above)
    ULONG Capability;       // capability of this service
    ULONG ProviderId;       // identifies which provider
    UNICODE_STRING Name;    // service name (for authentication)
    PFILE_OBJECT ConnFile;  // FileObject for tree conn to IPC$ of server
    struct _PROVIDER_DEF* pProvider;    // pointer to provider definition
    UNICODE_STRING Address; // network address
    PDFS_MACHINE_ENTRY  pMachEntry;  // The addressing info is here.
    ULONG Cost;             // The site based cost of this service.

} DFS_SERVICE, *PDFS_SERVICE;

//
//  Marshalling information for DFS_SERVICE
//
//  NOTE:       ConnFile and pProvider have significance only to the driver and
//              are not marshalled.
//
extern MARSHAL_INFO MiService;

#define INIT_DFS_SERVICE_MARSHAL_INFO()                                     \
    static MARSHAL_TYPE_INFO _MCode_Service[] = {                           \
        _MCode_ul(DFS_SERVICE, Type),                                       \
        _MCode_ul(DFS_SERVICE, Capability),                                 \
        _MCode_ul(DFS_SERVICE, ProviderId),                                 \
        _MCode_ustr(DFS_SERVICE, Name),                                     \
        _MCode_ustr(DFS_SERVICE, Address),                                  \
        _MCode_pstruct(DFS_SERVICE, pMachEntry, &MiMachineEntry)            \
    };                                                                      \
    MARSHAL_INFO MiService = _mkMarshalInfo(DFS_SERVICE, _MCode_Service);


//
//  Structure used in FSCTL_DFS_UPDATE_MACH_ADDRESS
//

typedef struct _DFS_MACHINE_INFO        {

    UNICODE_STRING      MachineName;    // Name of Machine (prefix alone).
    PDS_MACHINE         pMachine;       // The new addressing info is here

} DFS_MACHINE_INFO, *PDFS_MACHINE_INFO;

//
// Marshalling info for DFS_MACHINE_INFO
//

extern MARSHAL_INFO MiDfsMachineInfo;

#define INIT_DFS_MACHINE_INFO()                                         \
    static MARSHAL_TYPE_INFO _MCode_MachineInfo[] = {                   \
        _MCode_ustr(DFS_MACHINE_INFO, MachineName),                     \
        _MCode_pstruct(DFS_MACHINE_INFO, pMachine, &MiDSMachine)        \
    };                                                                  \
    MARSHAL_INFO MiDfsMachineInfo =                                     \
                _mkMarshalInfo(DFS_MACHINE_INFO, _MCode_MachineInfo);



//
//  How a partition table entry is identified.
//
typedef struct _DFS_PKT_ENTRY_ID {

    GUID Uid;               // a unique identifier for this partition
    UNICODE_STRING Prefix;  //  The entry path prefix of this partition
    UNICODE_STRING ShortPrefix; // The 8.3 form of entry path prefix

} DFS_PKT_ENTRY_ID, *PDFS_PKT_ENTRY_ID;

//
// Marshalling information for DFS_PKT_ENTRY_ID
//
extern MARSHAL_INFO MiPktEntryId;

#define INIT_DFS_PKT_ENTRY_ID_MARSHAL_INFO()                                \
    static MARSHAL_TYPE_INFO _MCode_PktEntryId[] = {                        \
        _MCode_guid(DFS_PKT_ENTRY_ID, Uid),                                 \
        _MCode_ustr(DFS_PKT_ENTRY_ID, Prefix)                               \
    };                                                                      \
    MARSHAL_INFO MiPktEntryId =                                             \
        _mkMarshalInfo(DFS_PKT_ENTRY_ID, _MCode_PktEntryId);


//
//  The guts of a partition table entry
//
typedef struct _DFS_PKT_ENTRY_INFO {

    ULONG ServiceCount;         // number of services in list
    PDFS_SERVICE ServiceList;   // array of servers that support the partition

} DFS_PKT_ENTRY_INFO, *PDFS_PKT_ENTRY_INFO;

typedef struct _DFS_TARGET_INFO_HEADER {
    ULONG Type;
    LONG UseCount;
    ULONG Flags;
} DFS_TARGET_INFO_HEADER, *PDFS_TARGET_INFO_HEADER;

#define TARGET_INFO_DFS 1
#define TARGET_INFO_LMR 2

typedef struct _DFS_TARGET_INFO {
    DFS_TARGET_INFO_HEADER DfsHeader;
    union {
        CREDENTIAL_TARGET_INFORMATIONW TargetInfo;
        LMR_QUERY_TARGET_INFO  LMRTargetInfo;
    };
} DFS_TARGET_INFO, *PDFS_TARGET_INFO;

NTSTATUS
PktGetTargetInfo( 
    HANDLE IpcHandle,
    PUNICODE_STRING pDomainName,
    PUNICODE_STRING pShareName,
    PDFS_TARGET_INFO *ppTargetInfo );

VOID
PktAcquireTargetInfo(
    pTargetInfo);

VOID
PktReleaseTargetInfo(
    pTargetInfo);



//
// Marshalling information for DFS_PKT_ENTRY_INFO
//
extern MARSHAL_INFO MiPktEntryInfo;

#define INIT_DFS_PKT_ENTRY_INFO_MARSHAL_INFO()                              \
    static MARSHAL_TYPE_INFO _MCode_PktEntryInfo[] = {                      \
        _MCode_ul(DFS_PKT_ENTRY_INFO, ServiceCount),                        \
        _MCode_pcastruct(DFS_PKT_ENTRY_INFO,ServiceList,ServiceCount,&MiService)\
    };                                                                      \
    MARSHAL_INFO MiPktEntryInfo =                                           \
        _mkMarshalInfo(DFS_PKT_ENTRY_INFO, _MCode_PktEntryInfo);



//
//  A Partition Knowledge Table Entry (PktEntry) identifies each known
//  partition.
//

typedef struct _DFS_PKT_ENTRY {

    NODE_TYPE_CODE NodeTypeCode;    // node type -> DSFS_NTC_PKT_ENTRY
    NODE_BYTE_SIZE NodeByteSize;    // node size
    LIST_ENTRY Link;                // link for PKT EntryList
    ULONG Type;                     // type of partition (see above)
    ULONG USN;                      // Unique Serial Number
    DFS_PKT_ENTRY_ID Id;            // the Id of this entry
    DFS_PKT_ENTRY_INFO Info;        // info of this entry
    ULONG ExpireTime;               // time when partition should be deleted
    ULONG TimeToLive;               // time to keep this entry in the cache
    ULONG UseCount;                 // # threads (DnrContexts) are looking at it.
    ULONG FileOpenCount;            // # of files opened via this entry
    PDFS_TARGET_INFO pDfsTargetInfo;
    PDFS_SERVICE ActiveService;     // pointer into info to active service
    PDFS_SERVICE LocalService;      // pointer to local service (if any)
    struct _DFS_PKT_ENTRY *Superior;// this entrys  superior (if any)
    ULONG SubordinateCount;         // number of subordinates (if any)
    LIST_ENTRY SubordinateList;     // list of subordinates (if any)
    LIST_ENTRY SiblingLink;         // link to other siblings (if any)
    struct _DFS_PKT_ENTRY *ClosestDC; // Link to closest superiorDC in PKT.
    LIST_ENTRY ChildList;           // Link to subordinate PKT entries (if any)
    LIST_ENTRY NextLink;            // Link to link up parent's Subord list.
    UNICODE_PREFIX_TABLE_ENTRY PrefixTableEntry;// prefix table entry

} DFS_PKT_ENTRY, *PDFS_PKT_ENTRY;

//
// Marshalling information for DFS_PKT_ENTRY
//
// Note that we only marshal the id and the info...no relational info
//
//
extern MARSHAL_INFO MiPktEntry;

#define INIT_DFS_PKT_ENTRY_MARSHAL_INFO()                                   \
    static MARSHAL_TYPE_INFO _MCode_PktEntry[] = {                          \
        _MCode_ul(DFS_PKT_ENTRY, Type),                                     \
        _MCode_struct(DFS_PKT_ENTRY, Id, &MiPktEntryId),                    \
        _MCode_struct(DFS_PKT_ENTRY, Info, &MiPktEntryInfo)                 \
    };                                                                      \
    MARSHAL_INFO MiPktEntry = _mkMarshalInfo(DFS_PKT_ENTRY, _MCode_PktEntry);

//
//  A special entry table contains a special name and a list of expanded
//  names.
//

typedef struct _DFS_EXPANDED_NAME {

    UNICODE_STRING ExpandedName;    // expanded name itself
    GUID Guid;                      // GUID associated with this name;

} DFS_EXPANDED_NAME, *PDFS_EXPANDED_NAME;

typedef struct _DFS_SPECIAL_ENTRY {

    NODE_TYPE_CODE NodeTypeCode;        // node type -> DSFS_NTC_SPECIAL_ENTRY
    NODE_BYTE_SIZE NodeByteSize;        // node size
    LIST_ENTRY Link;                    // link for PKT SpecialEntryList
    ULONG USN;                          // unique serial number
    ULONG UseCount;                     // # threads (DnrContexts) are looking at it.
    UNICODE_STRING SpecialName;         // Special name itself
    ULONG ExpandedCount;                // count of expanded names
    ULONG Active;                       // active expanded name
    UNICODE_STRING DCName;              // DC to go to, to get referrals
    PDFS_EXPANDED_NAME ExpandedNames;   // the expanded names
    BOOLEAN NeedsExpansion;             // need to expand this name
    BOOLEAN Stale;                      // Entry has gone stale
    BOOLEAN GotDCReferral;              // This domain name has already 
                                        // been checked for
} DFS_SPECIAL_ENTRY, *PDFS_SPECIAL_ENTRY;

typedef struct _DFS_SPECIAL_TABLE {

    LIST_ENTRY SpecialEntryList;        // list of special entries in the PKT
    ULONG SpecialEntryCount;            // number of special entries in the PKT
    ULONG TimeToLive;                   // time when table should be deleted

} DFS_SPECIAL_TABLE, *PDFS_SPECIAL_TABLE;



//
//  A Parition Knowledge Table encapsulates all the knowledge that has
//  been obtained about partitions in the distributed file system. There
//  is only one instance of this struct in the entire system, and is
//  part of the DsData structure.
//

typedef struct _DFS_PKT {

    NODE_TYPE_CODE NodeTypeCode;        // node type -> DSFS_NTC_PKT
    NODE_BYTE_SIZE NodeByteSize;        // node size...
    ERESOURCE Resource;                 // resource to guard access to Pkt
    KSPIN_LOCK  UseCountLock;           // Use while changing UseCount
    ULONG EntryCount;                   // number of entries in the PKT
    ULONG EntryTimeToLive;              // time to live for each entry
    LIST_ENTRY EntryList;               // list of entries in the PKT
    UNICODE_STRING DCName;              // where to go for expanded referrals
    UNICODE_STRING DomainNameFlat;      // our domain name (flat)
    UNICODE_STRING DomainNameDns;       // our domain in dns format
    DFS_SPECIAL_TABLE SpecialTable;     // special entry table
    DFS_PREFIX_TABLE PrefixTable;       // prefix table
    DFS_PREFIX_TABLE ShortPrefixTable;  // prefix table for 8.3 names
    UNICODE_PREFIX_TABLE DSMachineTable;// Table for DSMachines

} DFS_PKT, *PDFS_PKT;

#ifndef _UPKT_

//
//  PARTITION KNOWLEDGE TABLE PUBLIC INLINE FUNCTIONS
//

#define _GetPkt()       (&DfsData.Pkt)

//+-------------------------------------------------------------------------
//
//  Function:   PktAcquireShared, public inline
//
//  Synopsis:   PktAcquireShared acquires the partition knowledge table
//              for shared access.
//
//  Arguments:  [WaitOk] - indicates if the call is allowed to wait for
//                      the PKT to become available or must return immediately
//              [Result] - Pointer to boolean that will receive result of
//                      lock acquisition
//
//  Returns:    Nothing
//
//  Notes:      We first check to see if there are any threads waiting to
//              update the Pkt. If so, we hold off until that thread has
//              finished before we acquire a shared lock on the Pkt.
//              Under NT, a thread waiting to acquire a resource exclusive
//              does !not! automatically prevent threads from acquiring it
//              shared. This is necessary to allow for recursive acquisition
//              of resources. So, this event mechanism is required.
//
//--------------------------------------------------------------------------
#define PktAcquireShared( WaitOk, Result )      \
{                                               \
    KeWaitForSingleObject(                      \
        &DfsData.PktWritePending,               \
        Spare2,                                 \
        KernelMode,                             \
        FALSE,                                  \
        NULL);                                  \
    *(Result) = ExAcquireResourceSharedLite(        \
                &DfsData.Pkt.Resource,          \
                WaitOk );                       \
}

//+-------------------------------------------------------------------------
//
//  Function:   PktAcquireExclusive, public inline
//
//  Synopsis:   PktAcquireExclusive acquires the partition knowledge table
//              for exclusive access.
//
//  Arguments:  [WaitOk] - indicates if the call is allowed to wait for
//                  the PKT to become available or must return immediately.
//              [Result] - Pointer to boolean that will receive result of
//                      lock acquisition
//
//  Returns:    Nothing
//
//  Notes:
//
//--------------------------------------------------------------------------
#define PktAcquireExclusive( WaitOk, Result )   \
{                                               \
    KeResetEvent(&DfsData.PktWritePending);     \
    *(Result) = ExAcquireResourceExclusiveLite(     \
                    &DfsData.Pkt.Resource,      \
                    WaitOk );                   \
}


//+-------------------------------------------------------------------------
//
//  Function:   PktRelease, public inline
//
//  Synopsis:   PktRelease releases the PKT.  It can have been acquired
//              for exclusive or shared access.
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//  Notes:
//
//--------------------------------------------------------------------------
#define PktRelease()                            \
{                                               \
    ExReleaseResourceLite( &DfsData.Pkt.Resource ); \
    KeSetEvent(                                 \
        &DfsData.PktWritePending,               \
        0,                                      \
        FALSE);                                 \
}

//+----------------------------------------------------------------------------
//
//  Function:   PktConvertExclusiveToShared, public inline
//
//  Synopsis:   Converts an exclusive lock on Pkt to a shared lock
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

#define PktConvertExclusiveToShared()                           \
{                                                               \
    ExConvertExclusiveToSharedLite( &DfsData.Pkt.Resource );        \
    KeSetEvent(&DfsData.PktWritePending, 0, FALSE);             \
}

//+----------------------------------------------------------------------------
//
//  Function:   PKT_LOCKED_FOR_SHARED_ACCESS, public inline
//
//  Synopsis:   Returns TRUE if Pkt is locked for shared access, FALSE if not
//
//  Arguments:  None
//
//  Returns:    TRUE if Pkt is locked for shared access, FALSE otherwise
//
//-----------------------------------------------------------------------------

#define PKT_LOCKED_FOR_SHARED_ACCESS()      \
    ( ExIsResourceAcquiredSharedLite( &DfsData.Pkt.Resource ) )

//+----------------------------------------------------------------------------
//
//  Function:   PKT_LOCKED_FOR_EXCLUSIVE_ACCESS, public inline
//
//  Synopsis:   Returns TRUE if Pkt is locked for exclusive access, FALSE if
//              not
//
//  Arguments:  None
//
//  Returns:    TRUE if Pkt is locked for exclusive access, FALSE otherwise
//
//-----------------------------------------------------------------------------

#define PKT_LOCKED_FOR_EXCLUSIVE_ACCESS()   \
    ( ExIsResourceAcquiredExclusiveLite( &DfsData.Pkt.Resource ) )

//+-------------------------------------------------------------------------
//
//  Function:   PktInvalidateEntry, public inline
//
//  Synopsis:   PktInvalidateEntry destroys a PKT Entry.  The entry cannot
//              be local, and it cannot be an exit point.
//
//  Arguments:  [Pkt] - pointer to an initialized PKT.
//              [Victim] - pointer to the entry to be invalidated.
//
//  Returns:    [STATUS_SUCCESS] - all is well.
//              [DFS_STATUS_LOCAL_ENTRY] - an attempt was made to
//                  invalidate a local entry, or an entry that is a
//                  local exit point.
//
//  Notes:
//
//--------------------------------------------------------------------------
#define PktInvalidateEntry(p, e) (                                          \
    ((e)->Type & (PKT_ENTRY_TYPE_LOCAL|PKT_ENTRY_TYPE_LOCAL_XPOINT))        \
    ? (DFS_STATUS_LOCAL_ENTRY)                                              \
    : (PktEntryDestroy(e, p, (BOOLEAN)TRUE), STATUS_SUCCESS)                \
    )


//+-------------------------------------------------------------------------
//
//  Function:   PktFirstEntry, public inline
//
//  Synopsis:   PktFirstEntry returns the first entry in the list of
//              PKT entries.
//
//  Arguments:  [Pkt] - pointer to an initialized PKT.
//
//  Returns:    A pointer to the first entry in the PKT, or NULL if the
//              PKT is empty.
//
//  Notes:
//
//--------------------------------------------------------------------------
#define PktFirstEntry(p) (                                                  \
    ((p)->EntryList.Flink != &(p)->EntryList)                               \
    ? (CONTAINING_RECORD((p)->EntryList.Flink, DFS_PKT_ENTRY, Link))        \
    : (NULL)                                                                \
    )

//+-------------------------------------------------------------------------
//
//  Function:   PktNextEntry, public inline
//
//  Synopsis:   PktNextEntry returns the next entry in the list of
//              PKT entries.
//
//  Arguments:  [Pkt] - pointer to an initialized PKT.
//              [Entry] - a pointer to the previous entry.
//
//  Returns:    A pointer to the next entry in the PKT, or NULL if we
//              are at the end of the list.
//
//  Notes:
//
//--------------------------------------------------------------------------
#define PktNextEntry(p, e) (                                                \
    ((e)->Link.Flink != &(p)->EntryList)                                    \
    ? (CONTAINING_RECORD((e)->Link.Flink, DFS_PKT_ENTRY, Link))             \
    : (NULL)                                                                \
    )

//+-------------------------------------------------------------------------
//
//  Function:   PktFirstSpecialEntry, public inline
//
//  Synopsis:   PktFirstSpecialEntry returns the first special entry in the list of
//              PKT entries.
//
//  Arguments:  [Pkt] - pointer to an initialized PKT.
//
//  Returns:    A pointer to the first special entry in the PKT, or NULL if the
//              PKT is empty.
//
//  Notes:
//
//--------------------------------------------------------------------------
#define PktFirstSpecialEntry(p) (                                           \
    ((p)->SpecialEntryList.Flink != &(p)->SpecialEntryList)                 \
    ? (CONTAINING_RECORD((p)->SpecialEntryList.Flink, DFS_SPECIAL_ENTRY, Link)) \
    : (NULL)                                                                \
    )

//+-------------------------------------------------------------------------
//
//  Function:   PktNextSpecialEntry, public inline
//
//  Synopsis:   PktNextSpecialEntry returns the next special entry in the list of
//              PKT entries.
//
//  Arguments:  [Pkt] - pointer to an initialized PKT.
//              [Entry] - a pointer to the previous special entry.
//
//  Returns:    A pointer to the next special entry in the PKT, or NULL if we
//              are at the end of the list.
//
//  Notes:
//
//--------------------------------------------------------------------------
#define PktNextSpecialEntry(p, e) (                                         \
    ((e)->Link.Flink != &(p)->SpecialEntryList)                             \
    ? (CONTAINING_RECORD((e)->Link.Flink, DFS_SPECIAL_ENTRY, Link))         \
    : (NULL)                                                                \
    )

//+-------------------------------------------------------------------------
//
//  Function:   PktLinkEntry, public inline
//
//  Synopsis:   PktLinkEntry links an entry into the list of entries
//              in the PKT.
//
//  Arguments:  [Pkt] - pointer to an initialized PKT.
//              [Entry] - a pointer to the entry to be linked in.
//
//  Returns:    VOID
//
//  Notes:      Care must be taken to insure that the entry is not already
//              linked into the PKT entry list before calling this routine.
//              No checking is done to prevent an entry from being linked
//              twice...
//
//--------------------------------------------------------------------------
#define PktLinkEntry(p, e) {                                                \
    InsertTailList(&(p)->EntryList, &(e)->Link);                            \
    (p)->EntryCount++;                                                      \
    }

//+-------------------------------------------------------------------------
//
//  Function:   PktUnlinkEntry, public inline
//
//  Synopsis:   PktUnlinkEntry unlinks an entry from the list of entries
//              in the PKT.
//
//  Arguments:  [Pkt] - pointer to an initialized PKT.
//              [Entry] - a pointer to the entry to be unlinked.
//
//  Returns:    VOID
//
//  Notes:      Care must be taken to insure that the entry is in fact
//              already linked into the PKT entry list before calling this
//              routine. No checking is done to prevent an entry from being
//              unlinked twice...
//
//--------------------------------------------------------------------------
#define PktUnlinkEntry(p, e) {                                              \
    RemoveEntryList(&(e)->Link);                                            \
    (p)->EntryCount--;                                                      \
    }

#define PktServiceListValidate(e)       TRUE


//
//  PARTITION KNOWLEDGE TABLE PUBLIC FUNCTIONS (pkt.c)
//

NTSTATUS
PktInitialize(
    IN  PDFS_PKT Pkt
    );

VOID
PktUninitialize(
    IN  PDFS_PKT Pkt
    );

NTSTATUS
PktCreateEntry(
    IN  PDFS_PKT Pkt,
    IN  ULONG EntryType,
    IN  PDFS_PKT_ENTRY_ID PktEntryId,
    IN  PDFS_PKT_ENTRY_INFO PktEntryInfo OPTIONAL,
    IN  ULONG CreateDisposition,
    IN  PDFS_TARGET_INFO pDfsTargetInfo,
    OUT PDFS_PKT_ENTRY *ppPktEntry
    );

NTSTATUS
PktCreateDomainEntry(
    IN  PUNICODE_STRING DomainName,
    IN  PUNICODE_STRING ShareName,
    IN  BOOLEAN         CSCAgentCreate);

NTSTATUS
PktCreateEntryFromReferral(
    IN  PDFS_PKT Pkt,
    IN  PUNICODE_STRING ReferralPath,
    IN  ULONG ReferralSize,
    IN  PVOID ReferralBuffer,
    IN  ULONG CreateDisposition,
    IN  PDFS_TARGET_INFO pDfsTargetInfo,
    OUT ULONG *MatchingLength,
    OUT ULONG *ReferralType,
    OUT PDFS_PKT_ENTRY *ppPktEntry
    );

NTSTATUS
PktExpandSpecialEntryFromReferral(
    IN  PDFS_PKT Pkt,
    IN  PUNICODE_STRING ReferralPath,
    IN  ULONG ReferralSize,
    IN  PVOID ReferralBuffer,
    IN  PDFS_SPECIAL_ENTRY pSpecialEntry
    );

VOID
PktSpecialEntryDestroy(
    IN  PDFS_SPECIAL_ENTRY pSpecialEntry
    );

NTSTATUS
PktCreateSubordinateEntry(
    IN      PDFS_PKT Pkt,
    IN      PDFS_PKT_ENTRY Superior,
    IN      ULONG SubordinateType,
    IN      PDFS_PKT_ENTRY_ID SubordinateId,
    IN      PDFS_PKT_ENTRY_INFO SubordinateInfo OPTIONAL,
    IN      ULONG CreateDisposition,
    IN  OUT PDFS_PKT_ENTRY *Subordinate
    );

PDFS_PKT_ENTRY
PktLookupEntryById(
    IN      PDFS_PKT Pkt,
    IN      PDFS_PKT_ENTRY_ID Id
    );

PDFS_PKT_ENTRY
PktLookupEntryByPrefix(
    IN  PDFS_PKT Pkt,
    IN  PUNICODE_STRING Prefix,
    OUT PUNICODE_STRING Remaining
    );

PDFS_PKT_ENTRY
PktLookupEntryByShortPrefix(
    IN  PDFS_PKT Pkt,
    IN  PUNICODE_STRING Prefix,
    OUT PUNICODE_STRING Remaining
    );

NTSTATUS
PktEntryModifyPrefix(
    IN  PDFS_PKT        Pkt,
    IN  PUNICODE_STRING LocalPath,
    IN  PDFS_PKT_ENTRY  Entry
    );

PDFS_PKT_ENTRY
PktLookupEntryByUid(
    IN  PDFS_PKT Pkt,
    IN  GUID *Uid
    );

PDFS_PKT_ENTRY
PktLookupReferralEntry(
    IN  PDFS_PKT        Pkt,
    IN  PDFS_PKT_ENTRY  pEntry
);

PDFS_PKT_ENTRY
PktGetReferralEntryForPath(
    PDFS_PKT            Pkt,
    UNICODE_STRING      Path,
    ULONG               *Type
);

//
//  DFS PKT PRIVATE FUNCTIONS (pkt.c)
//

NTSTATUS
PktpOpenDomainService(
    IN      PDFS_PKT Pkt,
    IN      PDFS_PKT_ENTRY PktEntry,
    IN  OUT PHANDLE DomainServiceHandle
    );

NTSTATUS
DfsGetMachPktEntry(
    UNICODE_STRING      Path
);

VOID
RemoveLastComponent(
    IN PUNICODE_STRING  Prefix,
    OUT PUNICODE_STRING newPrefix);


//
//  DFS SERVICE PUBLIC FUNCTIONS (pktsup.c)
//

NTSTATUS
PktServiceConstruct(
    OUT PDFS_SERVICE Service,
    IN  ULONG ServiceType,
    IN  ULONG ServiceCapability,
    IN  ULONG ServiceStatus,
    IN  ULONG ServiceProviderId,
    IN  PUNICODE_STRING ServiceName OPTIONAL,
    IN  PUNICODE_STRING ServiceAddress OPTIONAL
    );

VOID
PktServiceDestroy(
    IN  PDFS_SERVICE Victim OPTIONAL,
    IN  BOOLEAN DeallocateAll
    );

VOID
DfsDecrementMachEntryCount(
    PDFS_MACHINE_ENTRY  pMachEntry,
    BOOLEAN     DeallocateMachine
);

VOID
PktDSMachineDestroy(
    IN  PDS_MACHINE Victim OPTIONAL,
    IN  BOOLEAN DeallocateAll
    );

VOID
PktDSTransportDestroy(
    IN  PDS_TRANSPORT Victim OPTIONAL,
    IN  BOOLEAN DeallocateAll
    );


//
//  PKT ENTRY ID PUBLIC FUNCTIONS (pktsup.c)
//

NTSTATUS
PktEntryIdConstruct(
    OUT PDFS_PKT_ENTRY_ID PktEntryId,
    IN  GUID *Uid OPTIONAL,
    IN  UNICODE_STRING *Prefix OPTIONAL
    );

VOID
PktEntryIdDestroy(
    IN  PDFS_PKT_ENTRY_ID Victim OPTIONAL,
    IN  BOOLEAN DeallocateAll
    );

//
//  PKT ENTRY ID PUBLIC INLINE FUNCTIONS
//

//+-------------------------------------------------------------------------
//
//  Function:   PktEntryIdEqual, public inline
//
//  Synopsis:   PktpEntryIdEqual determines if two entry Ids are equal
//              or not.
//
//  Arguments:  [Id1] - a pointer to an Id to compare.
//              [Id2] - a pointer to an Id to compare.
//
//  Returns:    [TRUE] - if both Ids are equal.
//              [FALSE] - if the Ids are not equal.
//
//  Notes:      The comparison on the Prefix is done case insensitive.
//
//--------------------------------------------------------------------------
#define PktEntryIdEqual(Id1, Id2) (                                         \
    (GuidEqual(&(Id1)->Uid, &(Id2)->Uid)) &&                                \
    (RtlEqualUnicodeString(&(Id1)->Prefix, &(Id2)->Prefix, (BOOLEAN)TRUE))  \
    )

//
//  PKT ENTRY ID PRIVATE INLINE FUNCTIONS
//

//+-------------------------------------------------------------------------
//
//  Function:   PktpEntryIdMove, private inline
//
//  Synopsis:   PktpEntryIdMove removes the values from the source Id and
//              places them on the destination Id.
//
//  Arguments:  [DestId] - a pointer to an Id that is to receive the
//                  sources values.
//              [SrcId] - a pointer to an Id that is to be stripped of
//                  its values.
//
//  Returns:    VOID
//
//  Notes:      Any values that are currently on the destination Id are
//              overwritten.  No memory is freed (either on the source,
//              or the destination) by this call.
//
//--------------------------------------------------------------------------
#define PktpEntryIdMove(DestId, SrcId) {                                    \
    (*(DestId)) = (*(SrcId));                                               \
    (SrcId)->Prefix.Length = (SrcId)->Prefix.MaximumLength = 0;             \
    (SrcId)->Prefix.Buffer = NULL;                                          \
    (SrcId)->ShortPrefix.Length = (SrcId)->ShortPrefix.MaximumLength = 0;   \
    (SrcId)->ShortPrefix.Buffer = NULL;                                     \
    }


//
//  PKT ENTRY INFO PUBLIC FUNCTIONS (pktsup.c)
//

//NTSTATUS
//PktEntryInfoConstruct(
//    OUT PDFS_PKT_ENTRY_INFO PktEntryInfo,
//    IN  PULONG ExpireTime OPTIONAL,
//    IN  ULONG ServiceCount,
//    IN  PDFS_SERVICE ServiceList OPTIONAL
//    );

VOID
PktEntryInfoDestroy(
    IN  PDFS_PKT_ENTRY_INFO Victim OPTIONAL,
    IN  BOOLEAN DeallocateAll
    );

//
//  PKT ENTRY INFO PRIVATE INLINE FUNCTIONS
//

//
// The following inlines operate on Entry Infos
//

//+-------------------------------------------------------------------------
//
//  Function:   PktpEntryInfoMove, private inline
//
//  Synopsis:   PktpEntryInfoMove removes the values from the source Info and
//              places them on the destination Info.
//
//  Arguments:  [DestInfo] - a pointer to an Info that is to receive the
//                  sources values.
//              [SrcInfo] - a pointer to an Info that is to be stripped of
//                  its values.
//
//  Returns:    VOID
//
//  Notes:      Any values that are currently on the destination Info are
//              overwritten.  No memory is freed (either on the source,
//              or the destination) by this call.
//
//--------------------------------------------------------------------------
#define PktpEntryInfoMove(DestInfo, SrcInfo) {                          \
    (*(DestInfo)) = (*(SrcInfo));                                       \
    (SrcInfo)->ServiceCount = 0L;                                       \
    (SrcInfo)->ServiceList = NULL;                                      \
    }


//
// PKT ENTRY PUBLIC INLINE FUNCTIONS
//

//+-------------------------------------------------------------------------
//
//  Function:   PktEntryFirstSubordinate, public inline
//
//  Synopsis:   PktEntryFirstSubordinate returns the first entry in the
//              list of subordinates.
//
//  Arguments:  [Superior] - pointer to a PKT entry.
//
//  Returns:    A pointer to the first entry in the list of subordinates,
//              or NULL if the list is empty.
//
//  Notes:
//
//--------------------------------------------------------------------------
#define PktEntryFirstSubordinate(s) (                                   \
      ((s)->SubordinateList.Flink != &(s)->SubordinateList)             \
      ? (CONTAINING_RECORD((s)->SubordinateList.Flink, DFS_PKT_ENTRY,   \
                                SiblingLink))                           \
      : (NULL)                                                          \
    )

//+-------------------------------------------------------------------------
//
//  Function:   PktEntryNextSubordinate, public inline
//
//  Synopsis:   PktEntryNextSubordinate returns the next entry in the
//              list of subordinates.
//
//  Arguments:  [Superior] - pointer to the superior PKT entry (the one
//                  which we are getting the subordinates for).
//              [Subordinate] - pointer to the last subordinate retreived
//                  via this routine (or PktEntryFirstSubordinate).
//
//  Returns:    A pointer to the next entry in the list of subordinates,
//              or NULL if we've hit the end of the list.
//
//  Notes:
//
//--------------------------------------------------------------------------
#define PktEntryNextSubordinate(s, m) (                                     \
    ((m)->SiblingLink.Flink != &(s)->SubordinateList)                       \
    ? (CONTAINING_RECORD((m)->SiblingLink.Flink,DFS_PKT_ENTRY,SiblingLink))\
    : (NULL)                                                                \
    )

//+-------------------------------------------------------------------------
//
//  Function:   PktEntryLinkSubordinate, public inline
//
//  Synopsis:   PktEntryLinkSubordinate links a subordinate to a superior's
//              list of subordinates.
//
//  Arguments:  [Superior] - pointer to the superior PKT entry.
//              [Subordinate] - pointer to the subordinate to be linked in.
//
//  Returns:    VOID
//
//  Notes:      If the subordinate is part of another superior's list, it
//              will be removed from that list as a by-product of being
//              put on the specified Superior's list.  The Superior pointer
//              of the subordinate is adjusted appropriately.
//
//              If the superior is a local entry, the subordinate will
//              be modified to indicate that it is a local exit point.
//
//--------------------------------------------------------------------------
#define PktEntryLinkSubordinate(sup, sub) {                                 \
    while(1) {                                                              \
        if((sub)->Superior == (sup))                                        \
            break;                                                          \
        if((sub)->Superior != NULL)                                         \
            PktEntryUnlinkSubordinate((sub)->Superior, (sub));              \
        InsertTailList(&(sup)->SubordinateList, &(sub)->SiblingLink);       \
        (sup)->SubordinateCount++;                                          \
        (sub)->Superior = (sup);                                            \
        if((sup)->Type & PKT_ENTRY_TYPE_LOCAL)                              \
            (sub)->Type |= PKT_ENTRY_TYPE_LOCAL_XPOINT;                     \
        break;                                                              \
    }                                                                       \
    }

//+-------------------------------------------------------------------------
//
//  Function:   PktEntryUnlinkSubordinate, public inline
//
//  Synopsis:   PktEntryUnlinkSubordinate unlinks a subordinate from a
//              superior's list of subordinates.
//
//  Arguments:  [Superior] - pointer to the superior PKT entry.
//              [Subordinate] - pointer to the subordinate to be unlinked.
//
//  Returns:    VOID
//
//  Notes:      The Superior pointer of the subordinate is NULLed as a
//              by-product of this operation.
//
//              By default, the subordinate is modified to indicate that
//              it is not an exit point (it cannot be an exit point if it
//              has no superior).
//
//              Milans - We need to turn off the PKT_ENTRY_TYPE_PERMANENT
//              bit if the PKT_ENTRY_TYPE_LOCAL bit is not set, and we are
//              not the DC. If we decide that a machine can be a server for
//              a volume in another domain, then we need to do something
//              about the != DS_DC clause.
//
//--------------------------------------------------------------------------
#define PktEntryUnlinkSubordinate(sup, sub) {                               \
    ASSERT((sub)->Superior == (sup));                                       \
    ASSERT((sup)->SubordinateCount > 0);                                    \
    RemoveEntryList(&(sub)->SiblingLink);                                   \
    (sup)->SubordinateCount--;                                              \
    (sub)->Superior = NULL;                                                 \
    (sub)->Type &= ~PKT_ENTRY_TYPE_LOCAL_XPOINT;                            \
    if ( DfsData.MachineState != DFS_ROOT_SERVER &&                         \
         (((sub)->Type & PKT_ENTRY_TYPE_LOCAL) == 0) ) {                    \
         (sub)->Type &= ~PKT_ENTRY_TYPE_PERMANENT;                          \
    }                                                                       \
}

//
// The following set of inline functions work on the Links maintained in
// the PKT to be able to get to referral entries for interdomain stuff real
// fast. These functions are similar to the above functions.
//

//+-------------------------------------------------------------------------
//
//  Function:   PktEntryFirstChild, public inline
//
//  Synopsis:   PktEntryFirstChild returns the first entry in the
//              list of child links of a PKT entry.
//
//  Arguments:  [SuperiorDC] - pointer to a PKT entry.
//
//  Returns:    A pointer to the first entry in the list of children,
//              or NULL if the list is empty.
//
//  Notes:
//
//--------------------------------------------------------------------------
#define PktEntryFirstChild(s) (                                         \
    ((s)->ChildList.Flink != &(s)->ChildList)                           \
    ? (CONTAINING_RECORD((s)->ChildList.Flink,DFS_PKT_ENTRY,NextLink))  \
    : (NULL)                                                            \
    )

//+-------------------------------------------------------------------------
//
//  Function:   PktEntryNextChild, public inline
//
//  Synopsis:   PktEntryNextChild returns the next entry in the
//              list of children.
//
//  Arguments:  [Superior] - pointer to the superior PKT entry (the one
//                  which we are getting the subordinates for).
//              [Subordinate] - pointer to the last child retreived
//                  via this routine (or PktEntryFirstChild).
//
//  Returns:    A pointer to the next entry in the list of children,
//              or NULL if we've hit the end of the list.
//
//  Notes:
//
//--------------------------------------------------------------------------
#define PktEntryNextChild(s, m) (                                       \
    ((m)->NextLink.Flink != &(s)->ChildList)                            \
    ? (CONTAINING_RECORD((m)->NextLink.Flink,DFS_PKT_ENTRY,NextLink))   \
    : (NULL)                                                            \
    )

//+-------------------------------------------------------------------------
//
//  Function:   PktEntryLinkChild, public inline
//
//  Synopsis:   PktEntryLinkChild links a child to a closestDC's
//              list of children.
//
//  Arguments:  [Superior] - pointer to the superior PKT entry.
//              [Subordinate] - pointer to the subordinate to be linked in.
//
//  Returns:    VOID
//
//  Notes:      If the child is part of another superior's list, it
//              will be removed from that list as a by-product of being
//              put on the specified Superior's list.  The Superior pointer
//              of the child is adjusted appropriately.
//
//
//--------------------------------------------------------------------------
#define PktEntryLinkChild(sup, sub) {                                     \
    while(1) {                                                            \
        if (sub == sup) {                                                 \
            (sub)->ClosestDC = NULL;                                      \
            break;                                                        \
        }                                                                 \
        if((sub)->ClosestDC == (sup))                                     \
            break;                                                        \
        if((sub)->ClosestDC != NULL)                                      \
            PktEntryUnlinkChild((sub)->ClosestDC, (sub));                 \
        InsertTailList(&(sup)->ChildList, &(sub)->NextLink);              \
        (sub)->ClosestDC = (sup);                                         \
        break;                                                            \
    }                                                                     \
    }

//+-------------------------------------------------------------------------
//
//  Function:   PktEntryUnlinkChild, public inline
//
//  Synopsis:   PktEntryUnlinkChild unlinks a child from a
//              superior's list of children.
//
//  Arguments:  [Superior] - pointer to the superior PKT entry.
//              [Subordinate] - pointer to the subordinate to be unlinked.
//
//  Returns:    VOID
//
//  Notes:      The Superior pointer of the child is NULLed as a
//              by-product of this operation.
//
//
//--------------------------------------------------------------------------
#define PktEntryUnlinkChild(sup, sub) {                                  \
    ASSERT((sub)->ClosestDC == (sup));                                   \
    RemoveEntryList(&(sub)->NextLink);                                   \
    (sub)->ClosestDC = NULL;                                             \
    }

//+-------------------------------------------------------------------------
//
//  Function:   PktEntryUnlinkAndRelinkChild, public inline
//
//  Synopsis:   PktEntryUnlinkAndRelinkChild unlinks a child from a
//              superior's list of children and relinks it to the parent of
//              the superior.
//
//  Arguments:  [Superior] - pointer to the superior PKT entry.
//              [Subordinate] - pointer to the subordinate to be unlinked.
//
//  Returns:    VOID
//
//--------------------------------------------------------------------------
#define PktEntryUnlinkAndRelinkChild(sup, sub) {                        \
    PktEntryUnlinkChild(sup, sub);                                      \
    if ((sup)->ClosestDC != NULL) {                                     \
        PktEntryLinkChild((sup)->ClosestDC, sub);                       \
    }                                                                   \
    }

//
// PKT ENTRY PUBLIC FUNCTIONS (pktsup.c)
//

NTSTATUS
PktEntryAssemble(
    IN  OUT PDFS_PKT_ENTRY Entry,
    IN      PDFS_PKT Pkt,
    IN      ULONG EntryType,
    IN      PDFS_PKT_ENTRY_ID EntryId,
    IN      PDFS_PKT_ENTRY_INFO EntryInfo OPTIONAL,
    IN  PDFS_TARGET_INFO pDfsTargetInfo
    );

NTSTATUS
PktEntryReassemble(
    IN  OUT PDFS_PKT_ENTRY Entry,
    IN      PDFS_PKT Pkt OPTIONAL,
    IN      ULONG EntryType,
    IN      PDFS_PKT_ENTRY_ID EntryId OPTIONAL,
    IN      PDFS_PKT_ENTRY_INFO EntryInfo OPTIONAL,
    IN  PDFS_TARGET_INFO pDfsTargetInfo
    );

VOID
PktEntryDestroy(
    IN  PDFS_PKT_ENTRY Victim OPTIONAL,
    IN  PDFS_PKT Pkt,
    IN  BOOLEAN DeallocateAll
    );

VOID
PktEntryClearSubordinates(
    IN      PDFS_PKT_ENTRY PktEntry
    );

VOID
PktEntryClearChildren(
    IN      PDFS_PKT_ENTRY PktEntry
    );

NTSTATUS
PktEntryCreateReferral(
    IN  PDFS_PKT_ENTRY PktEntry,
    IN  ULONG ServiceTypes,
    IN  PVOID ReferralBuffer
    );

VOID
PktParsePath(
    IN  PUNICODE_STRING PathName,
    OUT PUNICODE_STRING MachineName,
    OUT PUNICODE_STRING ShareName,
    OUT PUNICODE_STRING Remainder OPTIONAL
    );

NTSTATUS
PktExpandSpecialName(
    IN  PUNICODE_STRING Name,
    OUT PDFS_SPECIAL_ENTRY *ppSpecialEntry
    );

PDFS_SPECIAL_ENTRY
PktLookupSpecialNameEntry(
    PUNICODE_STRING Name
    );

NTSTATUS
PktCreateSpecialNameEntry(
    PDFS_SPECIAL_ENTRY pSpecialEntry
    );

NTSTATUS
PktGetDCName(
    ULONG Flags
    );

NTSTATUS
PktGetSpecialReferralTable(
    PUNICODE_STRING Machine,
    BOOLEAN Type
    );

NTSTATUS
PktCreateSpecialEntryTableFromReferral(
    IN  PDFS_PKT Pkt,
    IN  PUNICODE_STRING ReferralPath,
    IN  ULONG ReferralSize,
    IN  PVOID ReferralBuffer,
    IN  PUNICODE_STRING DCName
    );

NTSTATUS
PktEntryFromSpecialEntry(
    IN  PDFS_SPECIAL_ENTRY pSpecialEntry,
    IN  PUNICODE_STRING pShareName,
    OUT PDFS_PKT_ENTRY *ppPktEntry
    );

PDFS_PKT_ENTRY
PktFindEntryByPrefix(
    IN  PDFS_PKT Pkt,
    IN  PUNICODE_STRING Prefix
    );


#endif // NOT _UPKT_

#endif // _PKT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mup\pool.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    heapmgr.c

Abstract:

    This module contains debugging routines for the MUP use of
    non-paged pool.

Author:

    Manny Weiser (mannyw)    27-Jan-1992

--*/

#include "mup.h"

#if MUPDBG

LIST_ENTRY PagedPoolList = { &PagedPoolList, &PagedPoolList };

typedef struct _POOL_HEADER {
    LIST_ENTRY ListEntry;
    ULONG RequestedSize;
    BLOCK_TYPE BlockType;
    PVOID Caller;
    PVOID CallersCaller;
} POOL_HEADER, *PPOOL_HEADER;

struct _MEMORY_STATISTICS {
    ULONG BytesInUse;
    ULONG TotalBytesAllocated;
    ULONG MaxBytesInUse;
    ULONG TotalBytesFreed;
    ULONG BlocksInUse;
    ULONG TotalBlocksAllocated;
    ULONG MaxBlocksInUse;
    ULONG TotalBlocksFreed;
} MupMemoryUsage = { 0, 0, 0, 0, 0, 0, 0, 0 };

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, MupAllocatePoolDebug )
#pragma alloc_text( PAGE, MupFreePoolDebug )
#endif

PVOID
MupAllocatePoolDebug (
    IN POOL_TYPE PoolType,
    IN CLONG BlockSize,
    IN BLOCK_TYPE BlockType
    )
{
    PPOOL_HEADER header;
    KIRQL oldIrql;

    PAGED_CODE();

    header = FsRtlAllocatePool( PoolType, sizeof(POOL_HEADER) + BlockSize );

    header->RequestedSize = BlockSize;
    header->BlockType = BlockType;
    RtlGetCallersAddress( &header->Caller, &header->CallersCaller );

    ACQUIRE_LOCK( &MupDebugLock );
    InsertTailList( &PagedPoolList, &header->ListEntry );

    MupMemoryUsage.TotalBlocksAllocated += 1;
    MupMemoryUsage.BlocksInUse += 1;
    MupMemoryUsage.TotalBytesAllocated += BlockSize;
    MupMemoryUsage.BytesInUse += BlockSize;

    if ( MupMemoryUsage.BlocksInUse > MupMemoryUsage.MaxBlocksInUse ) {
        MupMemoryUsage.MaxBlocksInUse = MupMemoryUsage.BlocksInUse;
    }

    if ( MupMemoryUsage.BytesInUse > MupMemoryUsage.MaxBytesInUse ) {
        MupMemoryUsage.MaxBytesInUse = MupMemoryUsage.BytesInUse;
    }

    RELEASE_LOCK( &MupDebugLock );

    return (PVOID)(header + 1);

} // MupAllocatePagedPoolDebug

VOID
MupFreePoolDebug (
    IN PVOID P
    )
{
    PPOOL_HEADER header;
    KIRQL oldIrql;

    PAGED_CODE();

    header = (PPOOL_HEADER)P - 1;

    ACQUIRE_LOCK( &MupDebugLock );
    RemoveEntryList( &header->ListEntry );

    MupMemoryUsage.TotalBlocksFreed += 1;
    MupMemoryUsage.BlocksInUse -= 1;
    MupMemoryUsage.TotalBytesFreed += header->RequestedSize;
    MupMemoryUsage.BytesInUse -= header->RequestedSize;
    RELEASE_LOCK( &MupDebugLock );

    ExFreePool( header );

} // MupFreePagedPoolDebug

#endif // MUPDBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mup\pktfsctl.c ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:       PKTFSCTL.C
//
//  Contents:   This module contains the implementation for FS controls
//              which manipulate the PKT.
//
//  Functions:  PktFsctrlUpdateDomainKnowledge -
//              PktFsctrlGetRelationInfo -
//              PktFsctrlSetRelationInfo -
//              PktFsctrlIsChildnameLegal -
//              PktFsctrlCreateEntry -
//              PktFsctrlCreateSubordinateEntry -
//              PktFsctrlDestroyEntry -
//              PktFsctrlUpdateSiteCosts -
//              DfsFsctrlSetDCName -
//              DfsAgePktEntries - Flush PKT entries periodically
//
//              Private Functions
//
//              DfsCreateExitPathOnRoot
//              PktpHashSiteCostList
//              PktpLookupSiteCost
//              PktpUpdateSiteCosts
//              PktpSetActiveSpcService
//
//              Debug Only Functions
//
//              PktFsctrlFlushCache - Flush PKT entries on command
//              PktFsctrlFlushSpcCache - Flush SPC entries on command
//              PktFsctrlGetFirstSvc - Test hooks for testing replica
//              PktFsctrlGetNextSvc - selection.
//
//  History:    12 Jul 1993     Alanw   Created from localvol.c.
//
//-----------------------------------------------------------------------------

#include "dfsprocs.h"
#include "dfserr.h"
#include "fsctrl.h"
#include "log.h"
#include "dnr.h"
#include "know.h"

#include <stdlib.h>

//
//  The local debug trace level
//

#define Dbg             (DEBUG_TRACE_LOCALVOL)

//
//  Local function prototypes
//

NTSTATUS
DfspProtocolToService(
    IN PDS_TRANSPORT pdsTransport,
    IN PWSTR         pwszPrincipalName,
    IN PWSTR         pwszShareName,
    IN BOOLEAN       fIsDfs,
    IN OUT PDFS_SERVICE pService);

NTSTATUS
PktFsctrlFlushCache(
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength
);

NTSTATUS
PktFsctrlFlushSpcCache(
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength
);

VOID
PktFlushChildren(
    PDFS_PKT_ENTRY pEntry
);

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, DfsAgePktEntries )
#pragma alloc_text( PAGE, DfspProtocolToService )
#pragma alloc_text( PAGE, DfsFsctrlSetDCName )
#pragma alloc_text( PAGE, PktpSetActiveSpcService )
#pragma alloc_text( PAGE, PktFlushChildren )
#pragma alloc_text( PAGE, PktFsctrlFlushCache )
#pragma alloc_text( PAGE, PktFsctrlFlushSpcCache )
#endif // ALLOC_PRAGMA


//+----------------------------------------------------------------------
//
// Function:    DfsAgePktEntries, public
//
// Synopsis:    This function gets called in the FSP to step through the PKT
//              entries and delete those entries which are old.
//
// Arguments:   [TimerContext] -- This context block contains a busy flag
//                                and a count of the number of ticks that
//                                have elapsed.
//
// Returns:     Nothing.
//
// Notes:       In case the PKT cannot be acquired exclusive, the
//              routine just returns without doing anything.  We
//              will have missed an aging interval, but aging is
//              a non-critical activity.
//
// History:     04/23/93        SudK    Created.
//
//-----------------------------------------------------------------------
VOID
DfsAgePktEntries(PDFS_TIMER_CONTEXT     DfsTimerContext)
{

    PDFS_PKT            pkt = _GetPkt();
    PDFS_PKT_ENTRY      entry, nextEntry;
    PDFS_SPECIAL_ENTRY  sentry, snextEntry;
    PLIST_ENTRY         link;
    PDFS_CREDENTIALS    creds;
    BOOLEAN             pktLocked = FALSE;
    PDFS_SPECIAL_TABLE  pSpecialTable;

    DfsDbgTrace(+1, Dbg, "DfsAgePktEntries called\n", 0);

    pSpecialTable = &pkt->SpecialTable;

    //
    // First we need to acquire a lock on the PKT and step through the PKT
    //
    //

    // If we can't get to the resource then let us return right away.
    // This is really not that critical.  We can always try again.
    //

    PktAcquireExclusive(FALSE, &pktLocked);

    if (pktLocked == FALSE) {

        DfsTimerContext->TickCount = 0;

        DfsTimerContext->InUse = FALSE;

        DfsDbgTrace(-1, Dbg, "DfsAgePktEntries Exit (no scan)\n", 0);

        return;

    }

    if (ExAcquireResourceExclusiveLite(&DfsData.Resource, FALSE) == FALSE) {

        PktRelease();

        DfsTimerContext->TickCount = 0;

        DfsTimerContext->InUse = FALSE;

        DfsDbgTrace(-1, Dbg, "DfsAgePktEntries Exit (no scan 2)\n", 0);

        return;

    }

    //
    // Age all the Pkt entries
    //

    entry = PktFirstEntry(pkt);

    while (entry != NULL)       {

        DfsDbgTrace(0, Dbg, "DfsAgePktEntries: Scanning %wZ\n", &entry->Id.Prefix);

        nextEntry = PktNextEntry(pkt, entry);

        if (entry->ExpireTime < DfsTimerContext->TickCount) {
#if DBG
            if (MupVerbose)
                DbgPrint("DfsAgePktEntries:Setting expiretime on %wZ to 0\n",
                        &entry->Id.Prefix);
#endif
            entry->ExpireTime = 0;
        } else {
            entry->ExpireTime -= DfsTimerContext->TickCount;
        }

        entry = nextEntry;

    }

    //
    // Age the special table
    //

    if (pkt->SpecialTable.SpecialEntryCount > 0) {

        if (pkt->SpecialTable.TimeToLive >= DfsTimerContext->TickCount) {

            pkt->SpecialTable.TimeToLive -= DfsTimerContext->TickCount;

        } else { // make it zero

            pkt->SpecialTable.TimeToLive = 0;

        }

    }
    
    //
    // Check the deleted credentials queue...
    //

    for (link = DfsData.DeletedCredentials.Flink;
            link != &DfsData.DeletedCredentials;
                NOTHING) {

         creds = CONTAINING_RECORD(link, DFS_CREDENTIALS, Link);

         link = link->Flink;

         if (creds->RefCount == 0) {

             RemoveEntryList( &creds->Link );

             ExFreePool( creds );

         }

    }


    ExReleaseResourceLite( &DfsData.Resource );

    PktRelease();

    //
    // Finally we need to reset the count so that the Timer Routine can
    // work fine.  We also release the context block by resetting the InUse
    // boolean.  This will make sure that the next count towards the PKT
    // aging will start again.
    //

    DfsTimerContext->TickCount = 0;

    DfsTimerContext->InUse = FALSE;

    DfsDbgTrace(-1, Dbg, "DfsAgePktEntries Exit\n", 0);
}


//+----------------------------------------------------------------------------
//
//  Function:   DfspProtocolToService
//
//  Synopsis:   Given a NetBIOS protocol definition in a DS_PROTOCOL structure
//              this function creates a corresponding DFS_SERVICE structure.
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

NTSTATUS
DfspProtocolToService(
    IN PDS_TRANSPORT pdsTransport,
    IN PWSTR         pwszPrincipalName,
    IN PWSTR         pwszShareName,
    IN BOOLEAN       fIsDfs,
    IN OUT PDFS_SERVICE pService)
{
    NTSTATUS status = STATUS_SUCCESS;
    PTA_ADDRESS pTaddr = &pdsTransport->taddr;
    PTDI_ADDRESS_NETBIOS pNBAddress;
    USHORT i;
    WCHAR    NetBiosAddress[ TDI_ADDRESS_LENGTH_NETBIOS + 1];
    ULONG cbUnused;
    PUNICODE_STRING pServiceAddr;
    ULONG AllocLen;

    DfsDbgTrace(+1, Dbg, "DfspProtocolToService - entered\n", 0);

    //
    // Initialize the service to nulls
    //

    RtlZeroMemory(pService, sizeof(DFS_SERVICE));

    ASSERT(pTaddr->AddressType == TDI_ADDRESS_TYPE_NETBIOS);

    pNBAddress = (PTDI_ADDRESS_NETBIOS) pTaddr->Address;
    ASSERT(pTaddr->AddressLength == sizeof(TDI_ADDRESS_NETBIOS));

    RtlMultiByteToUnicodeN(
        NetBiosAddress,
        sizeof(NetBiosAddress),
        &cbUnused,
        pNBAddress->NetbiosName,
        16);

    //
    // Process a NetBIOS name. Throw away char 16, then ignore the trailing
    // spaces
    //

    for (i = 14; i >= 0 && NetBiosAddress[i] == L' '; i--) {
        NOTHING;
    }
    NetBiosAddress[i+1] = UNICODE_NULL;

    DfsDbgTrace(0, Dbg, "NetBIOS address is %ws\n", NetBiosAddress);

    pService->Name.Length = wcslen(pwszPrincipalName) * sizeof(WCHAR);
    pService->Name.MaximumLength = pService->Name.Length +
                                        sizeof(UNICODE_NULL);
    pService->Name.Buffer = ExAllocatePoolWithTag(
                                PagedPool,
                                pService->Name.MaximumLength,
                                ' puM');

    if (!pService->Name.Buffer) {
        DfsDbgTrace(0, Dbg, "Unable to create principal name!\n", 0);
        status = STATUS_INSUFFICIENT_RESOURCES;
        DfsDbgTrace(-1, Dbg, "DfsProtocolToService returning %08lx\n", ULongToPtr(status) );
        return(status);
    }

    RtlCopyMemory(pService->Name.Buffer, pwszPrincipalName, pService->Name.Length);

    AllocLen = sizeof(UNICODE_PATH_SEP) +
                    pService->Name.Length +
                        sizeof(UNICODE_PATH_SEP) +
                            wcslen(pwszShareName) * sizeof(WCHAR) +
                                sizeof(UNICODE_NULL);

    if (AllocLen <= MAXUSHORT) {
        pService->Address.MaximumLength = (USHORT) AllocLen;
    } else {
        DfsDbgTrace(0, Dbg, "Address too long!\n", 0);
        ExFreePool(pService->Name.Buffer);
        status = STATUS_NAME_TOO_LONG;
        DfsDbgTrace(-1, Dbg, "DfsProtocolToService returning %08lx\n", ULongToPtr(status) );
        return(status);
    }

    pService->Address.Buffer = ExAllocatePoolWithTag(
                                    PagedPool,
                                    pService->Address.MaximumLength,
                                    ' puM');

    if (!pService->Address.Buffer) {
        DfsDbgTrace(0, Dbg, "Unable to create address!\n", 0);
        ExFreePool(pService->Name.Buffer);
        pService->Name.Buffer = NULL;
        status = STATUS_INSUFFICIENT_RESOURCES;
        DfsDbgTrace(-1, Dbg, "DfsProtocolToService returning %08lx\n", ULongToPtr(status) );
        return(status);
    }

    pService->Address.Length = sizeof(UNICODE_PATH_SEP);

    pService->Address.Buffer[0] = UNICODE_PATH_SEP;

    DnrConcatenateFilePath(
        &pService->Address,
        pService->Name.Buffer,
        pService->Name.Length);

    DnrConcatenateFilePath(
        &pService->Address,
        pwszShareName,
        (USHORT) (wcslen(pwszShareName) * sizeof(WCHAR)));

    DfsDbgTrace(0, Dbg, "Server Name is %wZ\n", &pService->Name);

    DfsDbgTrace(0, Dbg, "Address is %wZ\n", &pService->Address);

    pService->Type = DFS_SERVICE_TYPE_MASTER;

    if (fIsDfs) {
        pService->Capability = PROV_DFS_RDR;
        pService->ProviderId = PROV_ID_DFS_RDR;
    } else {
        pService->Capability = PROV_STRIP_PREFIX;
        pService->ProviderId = PROV_ID_MUP_RDR;
    }
    pService->pProvider = NULL;

    DfsDbgTrace(-1, Dbg, "DfsProtocolToService returning %08lx\n", ULongToPtr(status) );
    return(status);
}

//+----------------------------------------------------------------------------
//
//  Function:   DfsFsctrlSetDCName
//
//  Synopsis:   Sets the DC to use for special referrals,
//              also tries for more referrals if the table is emty or old,
//              and also sets the preferred DC if a new DC is passed in.
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsFsctrlSetDCName(
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PDFS_PKT Pkt = _GetPkt();
    BOOLEAN GotPkt = FALSE;
    BOOLEAN GotNewDc = FALSE;
    ULONG i;
    WCHAR *DCNameArg;
    UNICODE_STRING DomainNameDns;
    UNICODE_STRING DomainNameFlat;
    UNICODE_STRING DCNameFlat;
    UNICODE_STRING DCName;

    STD_FSCTRL_PROLOGUE(DfsFsctrlSetDCName, TRUE, FALSE, FALSE);

    DfsDbgTrace(+1, Dbg, "DfsFsctrlSetDCName()\n", 0);

    RtlZeroMemory(&DomainNameDns, sizeof(UNICODE_STRING));
    RtlZeroMemory(&DomainNameFlat, sizeof(UNICODE_STRING));
    RtlZeroMemory(&DCName, sizeof(UNICODE_STRING));
    RtlZeroMemory(&DCNameFlat, sizeof(UNICODE_STRING));

    DCNameArg = (WCHAR *)InputBuffer;

    //
    // We expect a the buffer to be unicode, so it had better be
    // of even length
    //

    if ((InputBufferLength & 0x1) != 0) {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Verify there's a null someplace in the buffer
    //

    for (i = 0; i < InputBufferLength/sizeof(WCHAR) && DCNameArg[i]; i++)
        NOTHING;

    if (i >= InputBufferLength/sizeof(WCHAR)) { 
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Verify that the name given (with an added NULL) will fit
    // into a USHORT
    //

    if ((wcslen(DCNameArg) * sizeof(WCHAR)) > MAXUSHORT - sizeof(WCHAR)) {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    GotNewDc = (i > 0) ? TRUE : FALSE;

    //
    // If we have a new DC name, switch to it
    //

    if (GotNewDc == TRUE) {

        UNICODE_STRING NewDCName;

        DfsDbgTrace(0, Dbg, "DCNameArg=%ws\n", DCNameArg);

        NewDCName.Length = wcslen(DCNameArg) * sizeof(WCHAR);
        NewDCName.MaximumLength = NewDCName.Length + sizeof(UNICODE_NULL);

        NewDCName.Buffer = ExAllocatePoolWithTag(PagedPool, NewDCName.MaximumLength, ' puM');

        if (NewDCName.Buffer == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        PktAcquireExclusive(TRUE, &GotPkt);

        RtlCopyMemory(NewDCName.Buffer, DCNameArg, NewDCName.MaximumLength);

	if (Pkt->DCName.Buffer != NULL) {
           ExFreePool(Pkt->DCName.Buffer);
	}
        Pkt->DCName = NewDCName;

    }

    //
    // We need to reference the DCName in the Pkt even without the Pkt locked,
    // so we make a copy.
    //

    if (GotPkt == FALSE) {

        PktAcquireExclusive(TRUE, &GotPkt);

    }

    if (Pkt->DCName.Length > 0) {

        DFS_DUPLICATE_STRING(DCName,Pkt->DCName.Buffer, Status);

        if (!NT_SUCCESS(Status)) {
            goto Cleanup;
        }

    }

    if (GotNewDc == TRUE) {

        if (Pkt->DomainNameDns.Length > 0) {

            DFS_DUPLICATE_STRING(DomainNameDns,Pkt->DomainNameDns.Buffer, Status);

            if (!NT_SUCCESS(Status)) {
                goto CheckSpcTable;
            }

        }

        if (Pkt->DomainNameFlat.Length > 0) {

            DFS_DUPLICATE_STRING(DomainNameFlat,Pkt->DomainNameFlat.Buffer, Status);

            if (!NT_SUCCESS(Status)) {
                goto CheckSpcTable;
            }

        }

        PktRelease();
        GotPkt = FALSE;
       
        if (DCName.Length > 0 && DomainNameDns.Length > 0) {

            PktpSetActiveSpcService(
                &DomainNameDns,
                &DCName,
                FALSE);

            DCNameFlat = DCName;

            for (i = 0;
                    i < DCNameFlat.Length / sizeof(WCHAR) && DCNameFlat.Buffer[i] != L'.';
                        i++
            ) {
                NOTHING;
            }

            DCNameFlat.Length = (USHORT) (i * sizeof(WCHAR));

            if (DCNameFlat.Length > Pkt->DCName.Length)
                DCNameFlat.Length = Pkt->DCName.Length;

        }

        if (DCNameFlat.Length > 0 && DomainNameFlat.Length > 0) {

            PktpSetActiveSpcService(
                &DomainNameFlat,
                &DCNameFlat,
                FALSE);

        }

    }

    if (GotPkt == TRUE) {

        PktRelease();
        GotPkt = FALSE;

     }

CheckSpcTable:

    if (NT_SUCCESS(Status) &&
        (Pkt->SpecialTable.SpecialEntryCount == 0 || Pkt->SpecialTable.TimeToLive == 0)) {

        if (DCName.Length > 0) {

            Status = PktGetSpecialReferralTable(&DCName, TRUE);

        } else {

            Status = STATUS_BAD_NETWORK_PATH;

        }

    }

Cleanup:

    //
    // Free the local copies
    //

    if (DomainNameDns.Buffer != NULL)
        ExFreePool(DomainNameDns.Buffer);

    if (DomainNameFlat.Buffer != NULL)
        ExFreePool(DomainNameFlat.Buffer);

    if (DCName.Buffer != NULL)
        ExFreePool(DCName.Buffer);

    if (GotPkt == TRUE) {

        PktRelease();
        GotPkt = FALSE;

     }

    DfsCompleteRequest(IrpContext, Irp, Status);
    DfsDbgTrace(+1, Dbg, "DfsFsctrlSetDCName exit 0x%x\n", ULongToPtr(Status) );

    return (Status);
}

//+----------------------------------------------------------------------------
//
//  Function:   DfsFsctrlSetDomainNameFlat
//
//  Synopsis:   Sets the DomainName (flat)
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsFsctrlSetDomainNameFlat(
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PDFS_PKT Pkt = _GetPkt();
    BOOLEAN GotPkt;
    ULONG i;
    WCHAR *DomainNameFlat;

    STD_FSCTRL_PROLOGUE(DfsFsctrlSetDomainNameFlat, TRUE, FALSE, FALSE);

    DfsDbgTrace(+1, Dbg, "DfsFsctrlSetDomainNameFlat()\n", 0);

    DomainNameFlat = (WCHAR *)InputBuffer;

    //
    // Verify there's a null someplace in the buffer
    //

    for (i = 0; i < InputBufferLength/sizeof(WCHAR) && DomainNameFlat[i]; i++)
        NOTHING;

    //
    // Zero-len is as bad as no terminating NULL
    //
    if (i == 0 || i >= InputBufferLength/sizeof(WCHAR)) { 
        DfsCompleteRequest(IrpContext, Irp, Status);
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Verify that the name given (with an added NULL) will fit
    // into a USHORT
    //

    if ((wcslen(DomainNameFlat) * sizeof(WCHAR)) > MAXUSHORT - sizeof(WCHAR)) {
        Status = STATUS_INVALID_PARAMETER;
        DfsCompleteRequest(IrpContext, Irp, Status);
        return STATUS_INVALID_PARAMETER;
    }

    PktAcquireExclusive(TRUE, &GotPkt);

    DfsDbgTrace(0, Dbg, "DomainNameFlat=%ws\n", DomainNameFlat);

    //
    // Replace old
    //
    if (Pkt->DomainNameFlat.Buffer) {
        ExFreePool(Pkt->DomainNameFlat.Buffer);
    }
        
    Pkt->DomainNameFlat.Length = wcslen(DomainNameFlat) * sizeof(WCHAR);
    Pkt->DomainNameFlat.MaximumLength = Pkt->DomainNameFlat.Length + sizeof(UNICODE_NULL);

    Pkt->DomainNameFlat.Buffer = ExAllocatePoolWithTag(
                                    PagedPool,
                                    Pkt->DomainNameFlat.MaximumLength,
                                    ' puM');

    if (Pkt->DomainNameFlat.Buffer != NULL) {
        RtlCopyMemory(
                Pkt->DomainNameFlat.Buffer,
                DomainNameFlat,
                Pkt->DomainNameFlat.MaximumLength);
    } else {
        Pkt->DomainNameFlat.Length = Pkt->DomainNameFlat.MaximumLength = 0;
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    PktRelease();

    DfsCompleteRequest(IrpContext, Irp, Status);
    DfsDbgTrace(+1, Dbg, "DfsFsctrlSetDomainNameFlat exit 0x%x\n", ULongToPtr(Status) );

    return (Status);
}

//+----------------------------------------------------------------------------
//
//  Function:   DfsFsctrlSetDomainNameDns
//
//  Synopsis:   Sets the DomainName (flat)
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsFsctrlSetDomainNameDns(
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PDFS_PKT Pkt = _GetPkt();
    BOOLEAN GotPkt;
    ULONG i;
    WCHAR *DomainNameDns;

    STD_FSCTRL_PROLOGUE(DfsFsctrlSetDomainNameDns, TRUE, FALSE, FALSE);

    DfsDbgTrace(+1, Dbg, "DfsFsctrlSetDomainNameDns()\n", 0);

    DomainNameDns = (WCHAR *)InputBuffer;

    //
    // Verify there's a null someplace in the buffer
    //

    for (i = 0; i < InputBufferLength/sizeof(WCHAR) && DomainNameDns[i]; i++)
        NOTHING;

    //
    // Zero-len is as bad as no terminating NULL
    //
    if (i == 0 || i >= InputBufferLength/sizeof(WCHAR)) { 
        DfsCompleteRequest(IrpContext, Irp, Status);
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Verify that the name given (with an added NULL) will fit
    // into a USHORT
    //

    if ((wcslen(DomainNameDns) * sizeof(WCHAR)) > MAXUSHORT - sizeof(WCHAR)) {
        Status = STATUS_INVALID_PARAMETER;
        DfsCompleteRequest(IrpContext, Irp, Status);
        return STATUS_INVALID_PARAMETER;
    }

    PktAcquireExclusive(TRUE, &GotPkt);

    DfsDbgTrace(0, Dbg, "DomainNameDns=%ws\n", DomainNameDns);

    //
    // Replace old
    //
    if (Pkt->DomainNameDns.Buffer) {
        ExFreePool(Pkt->DomainNameDns.Buffer);
    }
        
    Pkt->DomainNameDns.Length = wcslen(DomainNameDns) * sizeof(WCHAR);
    Pkt->DomainNameDns.MaximumLength = Pkt->DomainNameDns.Length + sizeof(UNICODE_NULL);

    Pkt->DomainNameDns.Buffer = ExAllocatePoolWithTag(
                                    PagedPool,
                                    Pkt->DomainNameDns.MaximumLength,
                                    ' puM');

    if (Pkt->DomainNameDns.Buffer != NULL) {
        RtlCopyMemory(
                Pkt->DomainNameDns.Buffer,
                DomainNameDns,
                Pkt->DomainNameDns.MaximumLength);
    } else {
        Pkt->DomainNameDns.Length = Pkt->DomainNameDns.MaximumLength = 0;
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    PktRelease();

    DfsCompleteRequest(IrpContext, Irp, Status);
    DfsDbgTrace(+1, Dbg, "DfsFsctrlSetDomainNameDns exit 0x%x\n", ULongToPtr(Status) );

    return (Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   PktFsctrlFlushCache, public
//
//  Synopsis:   This function will flush all entries which match the specified
//              input path.
//              However, this function will refuse to delete any Permanent
//              entries of the PKT.
//
//  Arguments:  
//
//  Returns:
//
//--------------------------------------------------------------------------
NTSTATUS
PktFsctrlFlushCache(
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength
)
{
    NTSTATUS status = STATUS_SUCCESS;
    PDFS_PKT Pkt;
    PDFS_PKT_ENTRY  curEntry;
    PDFS_PKT_ENTRY  nextEntry;
    PDFS_PKT_ENTRY  pEntry;
    BOOLEAN pktLocked;
    UNICODE_STRING ustrPrefix, RemainingPath;
    PWCHAR wCp = (PWCHAR) InputBuffer;

    STD_FSCTRL_PROLOGUE(PktFsctrlFlushCache, TRUE, FALSE, FALSE);

    DfsDbgTrace(+1,Dbg, "PktFsctrlFlushCache()\n", 0);

    //
    // If InputBufferLength == 2 and InputBuffer == '*', flush all entries
    //

    if (InputBufferLength == sizeof(WCHAR) && wCp[0] == L'*') {

        Pkt = _GetPkt();
        PktAcquireExclusive(TRUE, &pktLocked);
        ExAcquireResourceExclusiveLite(&DfsData.Resource, TRUE);
        curEntry = PktFirstEntry(Pkt);

        while (curEntry!=NULL)  {

            nextEntry = PktNextEntry(Pkt, curEntry);

            if ( !(curEntry->Type & PKT_ENTRY_TYPE_PERMANENT) ) {

                if (curEntry->UseCount == 0) {

                    PktEntryDestroy(curEntry, Pkt, (BOOLEAN) TRUE);

                } else if ( !(curEntry->Type & PKT_ENTRY_TYPE_REFERRAL_SVC) ) {

                    //
                    // We can't delete this entry because it is in use, so
                    // mark it DELETE_PENDING, set its timeout to zero
                    // and remove from the prefix tables
                    // 

                    curEntry->Type |= PKT_ENTRY_TYPE_DELETE_PENDING;
                    curEntry->ExpireTime = 0;
                    curEntry->USN++;
                    DfsRemoveUnicodePrefix(&Pkt->PrefixTable, &(curEntry->Id.Prefix));
                    DfsRemoveUnicodePrefix(&Pkt->ShortPrefixTable, &(curEntry->Id.ShortPrefix));

                }

            }

            curEntry = nextEntry;
        }

        PktRelease();
        ExReleaseResourceLite( &DfsData.Resource );

        DfsCompleteRequest( IrpContext, Irp, status );
        DfsDbgTrace(-1,Dbg, "PktFsctrlFlushCache: Exit -> %08lx\n", ULongToPtr(status) );
        return(status);

    }

    //
    // Verify the buffer contains at least a '\' and is of even length
    //

    if (InputBufferLength < sizeof(WCHAR)
            ||
        (InputBufferLength & 0x1) != 0
            ||
        wCp[0] != UNICODE_PATH_SEP) {

        status = STATUS_INVALID_PARAMETER;
        DfsCompleteRequest( IrpContext, Irp, status );
        return status;

    }

    //
    // Flush one entry
    //

    ustrPrefix.Length = (USHORT) InputBufferLength;
    ustrPrefix.MaximumLength = (USHORT) InputBufferLength;
    ustrPrefix.Buffer = (PWCHAR) InputBuffer;

    if (ustrPrefix.Length >= sizeof(WCHAR) * 2 &&
        ustrPrefix.Buffer[0] == UNICODE_PATH_SEP &&
        ustrPrefix.Buffer[1] == UNICODE_PATH_SEP
    ) {
        ustrPrefix.Buffer++;
        ustrPrefix.Length -= sizeof(WCHAR);
    }

    if (ustrPrefix.Buffer[ustrPrefix.Length/sizeof(WCHAR)-1] == UNICODE_NULL) {
        ustrPrefix.Length -= sizeof(WCHAR);
    }

    Pkt = _GetPkt();

    PktAcquireExclusive(TRUE, &pktLocked);
    ExAcquireResourceExclusiveLite(&DfsData.Resource, TRUE);

    pEntry = PktLookupEntryByPrefix(Pkt,
                                    &ustrPrefix,
                                    &RemainingPath);

    if (pEntry == NULL || RemainingPath.Length != 0) {

        status = STATUS_OBJECT_NAME_NOT_FOUND;

    } else {

        if ( !(pEntry->Type & PKT_ENTRY_TYPE_PERMANENT) ) {
        
            if (pEntry->UseCount == 0) {

                PktEntryDestroy(pEntry, Pkt, (BOOLEAN) TRUE);

            } else if ( !(pEntry->Type & PKT_ENTRY_TYPE_REFERRAL_SVC) ) {

                //
                // We can't delete this entry because it is in use, so
                // mark it DELETE_PENDING, set its timeout to zero
                // and remove from the prefix tables
                //

                pEntry->Type |= PKT_ENTRY_TYPE_DELETE_PENDING;
                pEntry->ExpireTime = 0;
                DfsRemoveUnicodePrefix(&Pkt->PrefixTable, &(pEntry->Id.Prefix));
                DfsRemoveUnicodePrefix(&Pkt->ShortPrefixTable, &(pEntry->Id.ShortPrefix));

            }

        } else {

            status = STATUS_INVALID_PARAMETER;

        }

    }

    PktRelease();
    ExReleaseResourceLite( &DfsData.Resource );

    DfsCompleteRequest( IrpContext, Irp, status );
    DfsDbgTrace(-1,Dbg, "PktFsctrlFlushCache: Exit -> %08lx\n", ULongToPtr(status) );
    return status;

}

//+-------------------------------------------------------------------------
//
//  Function:   PktFsctrlFlushSpcCache, public
//
//  Synopsis:   This function will flush all entries which match the specified
//              input path.
//              However, this function will refuse to delete any Permanent
//              entries of the PKT.
//
//  Arguments:  
//
//  Returns:
//
//--------------------------------------------------------------------------
NTSTATUS
PktFsctrlFlushSpcCache(
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength
)
{
    NTSTATUS status = STATUS_INVALID_PARAMETER;
    PDFS_PKT Pkt;
    BOOLEAN pktLocked;
    PDFS_SPECIAL_ENTRY pSpecialEntry;
    PDFS_SPECIAL_TABLE pSpecialTable;
    PWCHAR wCp = (PWCHAR) InputBuffer;
    ULONG i;

    STD_FSCTRL_PROLOGUE(PktFsctrlFlushSpcCache, TRUE, FALSE, FALSE);

    DfsDbgTrace(+1,Dbg, "PktFsctrlFlushSpcCache()\n", 0);

    //
    // InputBufferLength == 2 and InputBuffer == '*'
    //

    if (InputBufferLength == sizeof(WCHAR) && wCp[0] == L'*') {

        Pkt = _GetPkt();
        PktAcquireExclusive(TRUE, &pktLocked);
        pSpecialTable = &Pkt->SpecialTable;

        pSpecialTable->TimeToLive = 0;

        pSpecialEntry = CONTAINING_RECORD(
                            pSpecialTable->SpecialEntryList.Flink,
                            DFS_SPECIAL_ENTRY,
                            Link);

        for (i = 0; i < pSpecialTable->SpecialEntryCount; i++) {

            pSpecialEntry->Stale = TRUE;

            pSpecialEntry = CONTAINING_RECORD(
                                pSpecialEntry->Link.Flink,
                                DFS_SPECIAL_ENTRY,
                                Link);
        }

        PktRelease();

        status = STATUS_SUCCESS;

    } else {

        status = STATUS_INVALID_PARAMETER;

    }

    DfsCompleteRequest( IrpContext, Irp, status );
    DfsDbgTrace(-1,Dbg, "PktFsctrlFlushSpcCache: Exit -> %08lx\n", ULongToPtr(status) );
    return status;

}

//+-------------------------------------------------------------------------
//
//  Function:   PktFlushChildren
//
//  Synopsis:   This function will flush all entries which are children
//              of the entry passed in.
//              However, this function will refuse to delete any Permanent
//              entries of the PKT.
//
//  Arguments:  
//
//  Returns:
//
//--------------------------------------------------------------------------
VOID
PktFlushChildren(
    PDFS_PKT_ENTRY pEntry
)
{
    NTSTATUS status = STATUS_SUCCESS;
    PDFS_PKT Pkt;
    PDFS_PKT_ENTRY curEntry;
    PDFS_PKT_ENTRY nextEntry;
    BOOLEAN pktLocked;

    DfsDbgTrace(+1,Dbg, "PktFlushChildren(%wZ)\n", &pEntry->Id.Prefix);

#if DBG
    if (MupVerbose)
        DbgPrint("PktFlushChildren(%wZ)\n", &pEntry->Id.Prefix);
#endif

    PktAcquireExclusive(TRUE, &pktLocked);
    ExAcquireResourceExclusiveLite(&DfsData.Resource, TRUE);

    Pkt = _GetPkt();

    curEntry = PktEntryFirstChild(pEntry);

    while (curEntry != NULL)       {

        DfsDbgTrace(0, Dbg, "PktFlushChildren: examining %wZ\n",
                                        &curEntry->Id.Prefix);
        //
        // We may lose this entry due to deletion. Let us get the Next
        // entry before we go into the next stage.
        //

        nextEntry = PktEntryNextChild(pEntry,curEntry);

        //
        // Try to delete the entry.
        //

        if ( !(curEntry->Type & PKT_ENTRY_TYPE_PERMANENT) ) {
        
            if (curEntry->UseCount == 0) {

                PktEntryDestroy(curEntry, Pkt, (BOOLEAN) TRUE);

            } else if ( !(curEntry->Type & PKT_ENTRY_TYPE_REFERRAL_SVC) ) {

                //
                // We can't delete this entry because it is in use, so
                // mark it DELETE_PENDING, set its timeout to zero
                // and remove from the prefix tables
                //

                curEntry->Type |= PKT_ENTRY_TYPE_DELETE_PENDING;
                curEntry->ExpireTime = 0;
                DfsRemoveUnicodePrefix(&Pkt->PrefixTable, &(curEntry->Id.Prefix));
                DfsRemoveUnicodePrefix(&Pkt->ShortPrefixTable, &(curEntry->Id.ShortPrefix));

            }

        }

        curEntry = nextEntry;

    }

    PktRelease();
    ExReleaseResourceLite( &DfsData.Resource );

#if DBG
    if (MupVerbose)
        DbgPrint("PktFlushChildren returning VOID\n");
#endif

    DfsDbgTrace(-1,Dbg, "PktFlushChildren returning VOID\n", 0);

}

//+-------------------------------------------------------------------------
//
//  Function:   PktpSetActiveSpcService
//
//  Synopsis:   This function will attempt to set the 'active' DC in the specified
//              domain
//
//  Arguments:  
//
//  Returns: STATUS_SUCCESS or STATUS_NOT_FOUND
//
//--------------------------------------------------------------------------
NTSTATUS
PktpSetActiveSpcService(
    PUNICODE_STRING DomainName,
    PUNICODE_STRING DcName,
    BOOLEAN ResetTimeout)
{
    NTSTATUS status = STATUS_NOT_FOUND;
    ULONG EntryIdx;
    USHORT i;
    PDFS_SPECIAL_ENTRY pSpecialEntry;
    UNICODE_STRING DcNameFlat;
    BOOLEAN pktLocked;

    if (DomainName != NULL && DomainName->Length > 0) {

        status = PktExpandSpecialName(DomainName, &pSpecialEntry);

        if (NT_SUCCESS(status)) {

            for (EntryIdx = 0; EntryIdx < pSpecialEntry->ExpandedCount; EntryIdx++) {

                if (RtlCompareUnicodeString(
                        DcName,
                        &pSpecialEntry->ExpandedNames[EntryIdx].ExpandedName,
                        TRUE) == 0) {

                    pSpecialEntry->Active = EntryIdx;
                    //
                    // Keep the spc table around for a while longer
                    //
                    if (ResetTimeout == TRUE) {
                        PktAcquireExclusive(TRUE, &pktLocked);
                        if (DfsData.Pkt.SpecialTable.TimeToLive < 60 * 15) {
                            DfsData.Pkt.SpecialTable.TimeToLive += 60 * 15; // 15 min
                        }
                        PktRelease();
                    }
                    status = STATUS_SUCCESS;
                    break;

                }

                status = STATUS_NOT_FOUND;

            }

            InterlockedDecrement(&pSpecialEntry->UseCount);

        } else {

            status = STATUS_NOT_FOUND;

        }

    }

    return status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mup\pktsup.c ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:       PktSup.C
//
//  Contents:   This module implements routines specific to the partition
//              knowledge table entry.
//
//  Functions:  PktDSTransportDestroy -
//              PktDSMachineDestroy -
//              PktServiceConstruct -
//              PktServiceDestroy -
//              PktEntryIdConstruct -
//              PktEntryIdDestroy -
//              PktEntryInfoConstruct -
//              PktEntryInfoDestroy -
//              PktEntryAssemble -
//              PktEntryReassemble -
//              PktEntryDestroy -
//              PktEntryClearSubordinates -
//              PktEntryClearChildren -
//              PktpServiceToReferral -
//              DfsFixDSMachineStructs -
//              DfspFixService -
//              DfsDecrementMachEntryCount -
//              PktSpecialEntryDestroy -
//
//  History:    27 May 1992 PeterCo Created.
//
//-----------------------------------------------------------------------------

#include "dfsprocs.h"
#include "dnr.h"
#include "creds.h"
#include "fsctrl.h"
#include "know.h"
#include "log.h"

#define Dbg              (DEBUG_TRACE_PKT)

ULONG MupErrorCase = 0;


NTSTATUS
DfsFixDSMachineStructs(
    PDFS_PKT_ENTRY      pEntry
);

NTSTATUS
DfspFixService(
    PDFS_SERVICE        pService
);

VOID
PktDSTransportDestroy(
    IN  PDS_TRANSPORT Victim OPTIONAL,
    IN  BOOLEAN DeallocateAll
);

VOID
PktDSMachineDestroy(
    IN  PDS_MACHINE Victim OPTIONAL,
    IN  BOOLEAN DeallocateAll
);


#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, PktServiceConstruct )
#pragma alloc_text( PAGE, PktServiceDestroy )
#pragma alloc_text( PAGE, PktEntryIdConstruct )
#pragma alloc_text( PAGE, PktEntryIdDestroy )
#pragma alloc_text( PAGE, PktEntryInfoDestroy )
#pragma alloc_text( PAGE, PktEntryAssemble )
#pragma alloc_text( PAGE, PktEntryReassemble )
#pragma alloc_text( PAGE, PktEntryDestroy)
#pragma alloc_text( PAGE, PktEntryClearSubordinates )
#pragma alloc_text( PAGE, PktEntryClearChildren )
#pragma alloc_text( PAGE, DfsFixDSMachineStructs )
#pragma alloc_text( PAGE, DfspFixService )
#pragma alloc_text( PAGE, DfsDecrementMachEntryCount )
#pragma alloc_text( PAGE, PktDSTransportDestroy )
#pragma alloc_text( PAGE, PktDSMachineDestroy )
#pragma alloc_text( PAGE, PktSpecialEntryDestroy )
#endif // ALLOC_PRAGMA
//
// NOTE - we designed for only one system-wide PKT; there is no provision
//        for multiple PKTs.
//

#define _GetPkt() (&DfsData.Pkt)


//+-------------------------------------------------------------------------
//
//  Function:   PktServiceConstruct, public
//
//  Synopsis:   PktServiceConstruct creates a new service structure.
//
//  Arguments:  [Service] - a pointer to a service structure to fill.
//              [ServiceType] - the type of the new service.
//              [ServiceCapability] - the capabilities of the new service.
//              [ServiceStatus] - the initial status of the new service.
//              [ServiceProviderId] - the provider Id of the new service.
//              [ServiceName] - the name of the principal for the service
//              [ServiceAddress] - a string which gives the address
//                                 of the service.
//
//  Returns:    [STATUS_SUCCESS] - all is well.
//              [STATUS_INSUFFICIENT_RESOURCES] - memory could not be
//                  allocated for this new service.
//
//  Notes:      All data is copied (Not MOVED).
//
//--------------------------------------------------------------------------

NTSTATUS
PktServiceConstruct(
    OUT PDFS_SERVICE Service,
    IN  ULONG ServiceType,
    IN  ULONG ServiceCapability,
    IN  ULONG ServiceStatus,
    IN  ULONG ServiceProviderId,
    IN  PUNICODE_STRING ServiceName OPTIONAL,
    IN  PUNICODE_STRING ServiceAddress OPTIONAL
) {
    DfsDbgTrace(+1, Dbg, "PktServiceConstruct: Entered\n", 0);

    ASSERT(ARGUMENT_PRESENT(Service));

    RtlZeroMemory(Service, sizeof(DFS_SERVICE));

    if (ARGUMENT_PRESENT(ServiceName) && ServiceName->Length != 0) {

        Service->Name.Buffer = DfsAllocate(ServiceName->Length);
        if (Service->Name.Buffer == NULL) {
            DfsDbgTrace(-1, Dbg, "PktServiceConstruct: Exit -> %08lx\n",
                                    ULongToPtr(STATUS_INSUFFICIENT_RESOURCES) );
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        Service->Name.Length = ServiceName->Length;
        Service->Name.MaximumLength = ServiceName->Length;
        RtlCopyUnicodeString(&Service->Name, ServiceName);
    } else {
        Service->Name.Buffer = NULL;
        Service->Name.Length = Service->Name.MaximumLength = 0;
    }

    if (ARGUMENT_PRESENT(ServiceAddress) && ServiceAddress->Length != 0) {
        Service->Address.Buffer = DfsAllocate(ServiceAddress->Length);
        if (Service->Address.Buffer == NULL) {

            if (Service->Name.Buffer != NULL)
                DfsFree(Service->Name.Buffer);

            DfsDbgTrace(-1, Dbg, "PktServiceConstruct: Exit -> %08lx\n",
                                    ULongToPtr(STATUS_INSUFFICIENT_RESOURCES) );
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlMoveMemory(Service->Address.Buffer, ServiceAddress->Buffer,
                                               ServiceAddress->Length);
        Service->Address.Length =
        Service->Address.MaximumLength = ServiceAddress->Length;
    } else {
        Service->Address.Buffer = NULL;
        Service->Address.Length = Service->Address.MaximumLength = 0;
    }

    Service->Type = ServiceType;
    Service->Capability = ServiceCapability;
    Service->ProviderId = ServiceProviderId;
    Service->pProvider = NULL;

    DfsDbgTrace(-1, Dbg, "PktServiceConstruct: Exit -> %08lx\n",
        STATUS_SUCCESS );
    return STATUS_SUCCESS;
}



//+-------------------------------------------------------------------------
//
//  Function:   PktDSTransportDestroy, public
//
//  Synopsis:   PktDSTransportDestroy destroys a DS_TRANSPORT structure, and
//              optionally deallocates the structure itself.
//
//  Arguments:  [Victim] - the DS_TRANSPORT structure to destroy
//              [DeallocateAll] - if True, indicates that the structure
//                  it self is to be deallocated, otherwise, only the
//                  strings within the structure are deallocated.
//
//  Returns:    VOID
//
//  Notes:
//
//--------------------------------------------------------------------------
VOID
PktDSTransportDestroy(
    IN  PDS_TRANSPORT Victim OPTIONAL,
    IN  BOOLEAN DeallocateAll
)
{

    DfsDbgTrace(+1, Dbg, "PktDSTransportDestroy: Entered\n", 0);

    if (ARGUMENT_PRESENT(Victim))       {

        //
        // Nothing to free in this structure??
        //

        if (DeallocateAll)
            ExFreePool(Victim);
    } else
        DfsDbgTrace(0, Dbg, "PktDSTransportDestroy: No Victim\n", 0 );

    DfsDbgTrace(-1, Dbg, "PktDSTransportDestroy: Exit -> VOID\n", 0 );
}



//+-------------------------------------------------------------------------
//
//  Function:   PktDSMachineDestroy, public
//
//  Synopsis:   PktDSMachineDestroy destroys a DS_MACHINE structure, and
//              optionally deallocates the structure itself.
//
//  Arguments:  [Victim] - the DS_MACHINE structure to destroy
//              [DeallocateAll] - if True, indicates that the structure
//                  it self is to be deallocated, otherwise, only the
//                  strings within the structure are deallocated.
//
//  Returns:    VOID
//
//  Notes:
//
//--------------------------------------------------------------------------
VOID
PktDSMachineDestroy(
    IN  PDS_MACHINE Victim OPTIONAL,
    IN  BOOLEAN DeallocateAll
)
{
    ULONG       i;
    DfsDbgTrace(+1, Dbg, "PktDSMachineDestroy: Entered\n", 0);

    if (ARGUMENT_PRESENT(Victim)) {

        if (Victim->pwszShareName != NULL) {
            DfsFree(Victim->pwszShareName);
            Victim->pwszShareName = NULL;
        }

        if (Victim->prgpwszPrincipals != NULL && Victim->cPrincipals > 0) {
            for (i = 0; i < Victim->cPrincipals; i++)   {
                if (Victim->prgpwszPrincipals[i] != NULL) {
                    DfsFree(Victim->prgpwszPrincipals[i]);
                    Victim->prgpwszPrincipals[i] = NULL;
                }
            }
        }

        if (Victim->prgpwszPrincipals) {
            ExFreePool(Victim->prgpwszPrincipals);
            Victim->prgpwszPrincipals = NULL;
        }

        for (i = 0; i < Victim->cTransports; i++)   {
            PktDSTransportDestroy(Victim->rpTrans[i], TRUE);
        }

        if (DeallocateAll)
            ExFreePool(Victim);
    } else
        DfsDbgTrace(0, Dbg, "PktDSMachineDestroy: No Victim\n", 0 );

    DfsDbgTrace(-1, Dbg, "PktDSMachineDestroy: Exit -> VOID\n", 0 );
}



//+-------------------------------------------------------------------------
//
//  Function:   DfsDecrementMachEntryCount
//
//  Synopsis:   This function decrements the count for the pMachine passed
//              in and if necessary will also free up the DS_MACHINE struct
//
//--------------------------------------------------------------------------

VOID
DfsDecrementMachEntryCount(
    PDFS_MACHINE_ENTRY  pMachEntry,
    BOOLEAN     DeallocateMachine
)
{

    NTSTATUS            status = STATUS_SUCCESS;
    UNICODE_STRING      ustrMachineName;
    PUNICODE_PREFIX_TABLE_ENTRY pfxEntry;
    PDS_MACHINE         pMachine;
    PDFS_PKT            Pkt;
    LONG Count;

    ASSERT(pMachEntry != NULL);
    if (pMachEntry == NULL)
        return;

    pMachine = pMachEntry->pMachine;
    ASSERT(pMachine != NULL);
    if (pMachine == NULL)
        return;

    //
    // We already have appropriate locks
    //
    Pkt = _GetPkt();

    //
    // For now we only expect one principal, by design?
    //
    ASSERT(pMachine->cPrincipals == 1);

    Count = InterlockedDecrement( &pMachEntry->UseCount );

    if (Count == 0) {

        if (pMachEntry->AuthConn != NULL) {

            DfsDeleteTreeConnection( pMachEntry->AuthConn, USE_LOTS_OF_FORCE );

            pMachEntry->Credentials->RefCount--;

        }

        //
        // This means we can now actually delete this DS_MACHINE structure
        //
        RtlRemoveUnicodePrefix(&Pkt->DSMachineTable,
                                   &pMachEntry->PrefixTableEntry);

        if (DeallocateMachine)
            PktDSMachineDestroy(pMachine, TRUE);

        //
        // Free the entry itself. Note that the UNICODE_STRING in the
        // entry gets freed up as part of above pMachine deletion.
        //
        DfsFree(pMachEntry);
    }

}



//+-------------------------------------------------------------------------
//
//  Function:   PktServiceDestroy, public
//
//  Synopsis:   PktServiceDestroy destroys a service structure, and
//              optionally deallocates the structure itself.
//
//  Arguments:  [Victim] - the service structure to destroy
//              [DeallocateAll] - if True, indicates that the structure
//                  it self is to be deallocated, otherwise, only the
//                  strings within the structure are deallocated.
//
//  Returns:    VOID
//
//  Notes:
//
//--------------------------------------------------------------------------

VOID
PktServiceDestroy(
    IN  PDFS_SERVICE Victim OPTIONAL,
    IN  BOOLEAN DeallocateAll
)
{
    DfsDbgTrace(+1, Dbg, "PktServiceDestroy: Entered\n", 0);

    if (ARGUMENT_PRESENT(Victim)) {

        if (Victim->ConnFile != NULL) {
            DfsCloseConnection(Victim);
            Victim->ConnFile = NULL;
        }

        if (Victim->Name.Buffer != NULL) {
            DfsFree(Victim->Name.Buffer);
            Victim->Name.Buffer = NULL;
        }

        if (Victim->Address.Buffer != NULL) {
            DfsFree(Victim->Address.Buffer);
            Victim->Address.Buffer = NULL;
        }

        //
        // Decrement the usage count. If it is to be deleted it will happen
        // automatically.
        //
        if (Victim->pMachEntry != NULL) {
            DfsDecrementMachEntryCount(Victim->pMachEntry, TRUE);
        }

        if (DeallocateAll)
            ExFreePool(Victim);
    } else
        DfsDbgTrace(0, Dbg, "PktServiceDestroy: No Victim\n", 0 );

    DfsDbgTrace(-1, Dbg, "PktServiceDestroy: Exit -> VOID\n", 0 );
}



//+-------------------------------------------------------------------------
//
//  Function:   PktEntryIdConstruct, public
//
//  Synopsis:   PktEntryIdConstruct creates a PKT Entry Id
//
//  Arguments:  [NewPktEntryId] - Where the new entry is placed
//              [NewUid] - The UID of the new Pkt Entry
//              [NewPrefix] - The new prefix of the new Pkt Entry
//
//  Returns:    [STATUS_SUCCESS] - all is well.
//              [STATUS_INSUFFICIENT_RESOURCES] - could not allocate
//                  memory for the Prefix part of the Id.
//
//  Notes:      The UNICODE_STRING used in the Prefix of the Id is COPIED,
//              not MOVED!
//
//--------------------------------------------------------------------------
NTSTATUS
PktEntryIdConstruct(
    OUT PDFS_PKT_ENTRY_ID PktEntryId,
    IN  GUID *Uid OPTIONAL,
    IN  UNICODE_STRING *Prefix OPTIONAL
)
{
    DfsDbgTrace(+1, Dbg, "PktEntryIdConstruct: Entered\n", 0);

    ASSERT(ARGUMENT_PRESENT(PktEntryId));
    ASSERT(ARGUMENT_PRESENT(Prefix));

    //
    // Zero the memory
    //
    RtlZeroMemory(PktEntryId, sizeof(DFS_PKT_ENTRY_ID));

    //
    // deal with the prefix.
    //
    if (ARGUMENT_PRESENT(Prefix)) {

        PUNICODE_STRING pus = &PktEntryId->Prefix;

        if (Prefix->Length != 0) {
            pus->Length = pus->MaximumLength = Prefix->Length;
            pus->Buffer = DfsAllocate(pus->Length);
            if (pus->Buffer != NULL) {
                RtlCopyUnicodeString(pus, Prefix);
            } else {
                DfsDbgTrace(-1,Dbg,"PktEntryIdConstruct: Exit -> %08lx\n",
                    ULongToPtr(STATUS_INSUFFICIENT_RESOURCES) );
                return STATUS_INSUFFICIENT_RESOURCES;
            }
        }
    }

    //
    // deal with the GUID.
    //
    if (ARGUMENT_PRESENT(Uid)) {
        PktEntryId->Uid = (*Uid);
    }

    DfsDbgTrace(-1,Dbg,"PktEntryIdConstruct: Exit -> %08lx\n",STATUS_SUCCESS);
    return STATUS_SUCCESS;
}


//+-------------------------------------------------------------------------
//
//  Function:   PktEntryIdDestroy, public
//
//  Synopsis:   PktEntryIdDestroy destroys a PKT Entry Id
//
//  Arguments:  [Victim] - Id to destroy
//              [DeallocateAll] - if true, indicates that the memory
//                  for the Id itself is to be release, otherwise,
//                  this memory is not released (only the memory for
//                  the UNICODE_STRING in the Prefix is released).
//
//  Returns:    VOID
//
//  Notes:      Memory for the UNICODE_STRING in the Prefix is released.
//
//--------------------------------------------------------------------------

VOID
PktEntryIdDestroy(
    IN  PDFS_PKT_ENTRY_ID Victim OPTIONAL,
    IN  BOOLEAN DeallocateAll
)
{
    DfsDbgTrace(+1, Dbg, "PktEntryIdDestroy: Entered\n", 0);
    if (ARGUMENT_PRESENT(Victim)) {
        if (Victim->Prefix.Buffer != NULL) {
            DfsFree(Victim->Prefix.Buffer);
            Victim->Prefix.Buffer = NULL;
        }
        if (Victim->ShortPrefix.Buffer != NULL) {
            DfsFree(Victim->ShortPrefix.Buffer);
            Victim->ShortPrefix.Buffer = NULL;
        }
        if (DeallocateAll)
            ExFreePool(Victim);
    } else
        DfsDbgTrace(0, Dbg, "PktEntryIdDestroy: No Victim\n", 0 );
    DfsDbgTrace(-1, Dbg, "PktEntryIdDestroy: Exit -> VOID\n", 0 );
}



//+-------------------------------------------------------------------------
//
//  Function:   PktEntryInfoDestroy, public
//
//  Synopsis:   PktEntryInfoDestroy destroys an info structure, and
//              optionally deallocates the structure itself.
//
//  Arguments:  [Victim] - the info structure to destroy
//              [DeallocateAll] - if True, indicates that the structure
//                  itself is to be deallocated, otherwise, only the
//                  service list within the structure is deallocated.
//
//  Returns:    VOID
//
//  Notes:
//
//--------------------------------------------------------------------------
VOID
PktEntryInfoDestroy(
    IN  PDFS_PKT_ENTRY_INFO Victim OPTIONAL,
    IN  BOOLEAN DeallocateAll
)
{
    DfsDbgTrace(+1, Dbg, "PktEntryInfoDestroy: Entered\n", 0);

    if (ARGUMENT_PRESENT(Victim)) {

        ULONG i;

        ExAcquireResourceExclusiveLite( &DfsData.Resource, TRUE );

        if (Victim->ServiceList != NULL) {
            for (i = 0; i < Victim->ServiceCount; i++)
                PktServiceDestroy(&Victim->ServiceList[i], FALSE);
        }

        Victim->ServiceCount = 0;

        if (Victim->ServiceList != NULL) {
            ExFreePool(Victim->ServiceList);
            Victim->ServiceList = NULL;
        }

        if (DeallocateAll)
            ExFreePool(Victim);

        ExReleaseResourceLite( &DfsData.Resource );

    } else
        DfsDbgTrace(0, Dbg, "PktEntryInfoDestroy: No Victim\n", 0 );

    DfsDbgTrace(-1, Dbg, "PktEntryInfoDestroy: Exit -> VOID\n", 0 );
}



//+-------------------------------------------------------------------------
//
//  Function:   DfspFixService
//
//  Synopsis:   This function should be called when a new service's DS_MACHINE
//              struct has to be adjusted to make sure there is a unique one
//              for each machine in the PKT.
//
//  Arguments:  [pService] -- The Service struct to fix up.
//
//  History:    23 August 1994          SudK    Created.
//
//--------------------------------------------------------------------------
NTSTATUS
DfspFixService(
    PDFS_SERVICE        pService
)
{

    NTSTATUS            status = STATUS_SUCCESS;
    UNICODE_STRING      ustrMachineName;
    PDS_MACHINE         pMachine;
    PUNICODE_PREFIX_TABLE_ENTRY pfxEntry;
    PDFS_MACHINE_ENTRY  machEntry;
    PDFS_PKT            Pkt;

    ASSERT(pService != NULL);
    ASSERT(pService->pMachEntry != NULL);
    pMachine = pService->pMachEntry->pMachine;
    if (pMachine->cPrincipals == 0)     {
        ASSERT(pService->Type && DFS_SERVICE_TYPE_DOWN_LEVEL);
        pService->pMachEntry->UseCount = 1;

        return(status);
    }
    //
    // We are called during PktCreateEntry. We already have appropriate locks
    //
    Pkt = _GetPkt();

    //
    // For now we only expect one principal. by design
    //
    ASSERT(pMachine->cPrincipals == 1);

    RtlInitUnicodeString(&ustrMachineName,
                        pMachine->prgpwszPrincipals[0]);


    ASSERT(ustrMachineName.Buffer != NULL);

    pfxEntry = RtlFindUnicodePrefix(&Pkt->DSMachineTable,&ustrMachineName,TRUE);
    if (pfxEntry != NULL) {
        //
        // In this case the DS_Machine structure already exists. Just use the
        // existing DS_Machine struct and bump the UseCount
        //
        machEntry = CONTAINING_RECORD(pfxEntry,
                                     DFS_MACHINE_ENTRY,
                                     PrefixTableEntry);

        InterlockedIncrement( &machEntry->UseCount );

        //
        // Even though we are "reusing" the Machine Entry, we might have a
        // better DS_MACHINE (ie, one with more transports) in the incoming
        // one. If so, lets use the new one.
        //

        if (pMachine->cTransports > machEntry->pMachine->cTransports) {
            PDS_MACHINE pTempMachine;

            DfsDbgTrace(0, 0, "DfspFixService: Using new DS_MACHINE for [%wZ]\n", &ustrMachineName);

            pTempMachine = machEntry->pMachine;
            machEntry->pMachine = pMachine;
            pService->pMachEntry->pMachine = pTempMachine;

            RtlRemoveUnicodePrefix(
                &Pkt->DSMachineTable,
                &machEntry->PrefixTableEntry);

            machEntry->MachineName = ustrMachineName;

            RtlInsertUnicodePrefix(
                &Pkt->DSMachineTable,
                &machEntry->MachineName,
                &machEntry->PrefixTableEntry);

        }
        pService->pMachEntry = machEntry;

    } else {
        //
        // In this case the DS_Machine is not there in the table. Need to add
        // current one to the table.
        //
        machEntry = pService->pMachEntry;
        machEntry->UseCount = 1;

        machEntry->MachineName = ustrMachineName; // Use same mem in DS_MACHINE.

        //
        // Now insert the machEntry and then we are done. This better not fail.
        //
        if (!RtlInsertUnicodePrefix(&Pkt->DSMachineTable,
                               &machEntry->MachineName,
                               &machEntry->PrefixTableEntry))   {
            BugCheck("DFS Pkt inconsistent DfspFixService");
        }

    }
    return(status);
}



//+-------------------------------------------------------------------------
//
//  Function:   DfsFixDSMachineStructs
//
//  Synopsis:   For the entry given this function makes sure that there is
//              only one DS_MACHINE structure in the PKT. If there isn't one
//              then one is registered. If there is one then the same one is
//              used and the current one in the DFS_SERVICE struct is freed up.
//
//  Arguments:  [pEntry] -- The PKT entry that has to be fixed.
//
//  Notes:      If this function fails then it will reset the pEntry to the
//              same format it was when it was called.
//
//  History:    22 Aug 1994     SudK    Created.
//
//--------------------------------------------------------------------------
NTSTATUS
DfsFixDSMachineStructs(
    PDFS_PKT_ENTRY      pEntry
)
{
    NTSTATUS            status = STATUS_SUCCESS;
    ULONG               i;
    PDFS_MACHINE_ENTRY  *apMachineEntry;
    PDFS_SERVICE        pService;

    if (pEntry->Info.ServiceCount == 0)
        return(status);

    //
    // In case of downlevel we do nothing
    //
    if (pEntry->Type & PKT_ENTRY_TYPE_NONDFS)
        return(status);

    apMachineEntry =
        ExAllocatePoolWithTag(PagedPool,
            sizeof(PDFS_MACHINE_ENTRY) * pEntry->Info.ServiceCount,
            ' puM');

    if (apMachineEntry == NULL)      {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    for (i=0; i < pEntry->Info.ServiceCount; i++) {
        //
        // First Save the current DS_Machine and then fix up
        //
        apMachineEntry[i] = pEntry->Info.ServiceList[i].pMachEntry;
        status = DfspFixService(&pEntry->Info.ServiceList[i]);
        if (!NT_SUCCESS(status))        {
            //
            // In this case we break and let the cleanup part below take care
            // of cleaning up everything.
            //
            break;
        }
    }

    if (!NT_SUCCESS(status))    {
        //
        // We need to cleanup in this case. I.E. reset all the PDS_MACHINEs
        // back to old values and decrement any usage counts on DS_MACHINE
        // structures.
        //
        ULONG j;
        for (j=0; j < i; j++)     {
            pService = &pEntry->Info.ServiceList[j];
            //
            // These have already been fixed up so decrement the count on the
            // pMachine structs. Dont want to deallocate the pMachine structs
            // if we were the last one to use it.
            //
            DfsDecrementMachEntryCount(pService->pMachEntry, FALSE);

            if (apMachineEntry[j] != pService->pMachEntry)
                pService->pMachEntry = apMachineEntry[j];
        }
    }
    else        {
        //
        // In this case everything went fine. So we need to free up the
        // DS_MACHINE structures that were superfluously allocated for now.
        //
        for (i=0; i<pEntry->Info.ServiceCount; i++)     {
            if (apMachineEntry[i] != pEntry->Info.ServiceList[i].pMachEntry) {
                //
                // This means that the pMachine in the service list got replaced
                // by a different one so let us free this one now.
                //
                PktDSMachineDestroy(apMachineEntry[i]->pMachine, TRUE);
                ExFreePool( apMachineEntry[i] );
            }
        }
    }

    ExFreePool(apMachineEntry);
    return(status);
}



//+-------------------------------------------------------------------------
//
//  Function:   PktEntryAssemble, private
//
//  Synopsis:   PktpEntryAssemble blindly constructs a new partition
//              table entry and places it in the PKT.  The caller must
//              have previously determined that no other entry with this
//              UID or Prefix existed.  The PKT must be acquired exclusively
//              for this operation.
//
//  Arguments:  [Entry] - a pointer to an entry to be filled.
//              [Pkt] - pointer to a initialized (and acquired
//                      exclusively) PKT
//              [EntryType] - the type of entry to assemble.
//              [EntryId] - pointer to the new entry's Id.
//              [EntryInfo] - pointer to the guts of the entry.
//
//  Returns:    [STATUS_SUCCESS] if no error.
//              [STATUS_INVALID_PARAMETER] - if the EntryId does not have a
//                  UID or a Prefix (no such thing as an anonymous entry).
//              [PKT_ENTRY_EXISTS] - a new prefix table entry could not
//                  be made.
//
//  Notes:      The EntryId and EntryInfo structures are MOVED (not
//              COPIED) to the new entry.  The memory used for UNICODE_STRINGS
//              and DFS_SERVICE arrays is used by the new entry.  The
//              associated fields in the EntryId and EntryInfo
//              structures passed as arguments are Zero'd to indicate that
//              the memory has been "deallocated" from these strutures and
//              reallocated to the newly create Entry.  Note that this
//              routine does not deallocate the EntryId structure or
//              the EntryInfo structure itself. On successful return from
//              this function, the EntryId structure will be modified
//              to have a NULL Prefix entry, and the EntryInfo structure
//              will be modified to have zero services and a null ServiceList
//              entry.
//
//--------------------------------------------------------------------------
NTSTATUS
PktEntryAssemble(
    IN  OUT PDFS_PKT_ENTRY Entry,
    IN      PDFS_PKT Pkt,
    IN      ULONG EntryType,
    IN      PDFS_PKT_ENTRY_ID EntryId,
    IN      PDFS_PKT_ENTRY_INFO EntryInfo,
    IN      PDFS_TARGET_INFO pDfsTargetInfo
)
{
    NTSTATUS status = STATUS_SUCCESS;
    ULONG               i;
    PDFS_SERVICE        pService;

    DfsDbgTrace(+1, Dbg, "PktEntryAssemble: Entered\n", 0);

    ASSERT(ARGUMENT_PRESENT(Entry) &&
           ARGUMENT_PRESENT(EntryId));

    //
    // We do not allow the creation of entries
    // without any Uid or Prefix.
    //

    if (NullGuid(&EntryId->Uid) && EntryId->Prefix.Length == 0) {
        DfsDbgTrace(-1, Dbg, "PktEntryAssemble: Exit -> %08lx\n",
                    ULongToPtr(STATUS_INVALID_PARAMETER) );
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Zero out the entry.
    //
    RtlZeroMemory(Entry, sizeof(DFS_PKT_ENTRY));

    //
    // Mundane initialization
    //
    Entry->NodeTypeCode =  DSFS_NTC_PKT_ENTRY;
    Entry->NodeByteSize = sizeof(DFS_PKT_ENTRY);

    //
    // Initialize the USN to 1
    //
    Entry->USN = 1;

    //
    // Move the Type, Id, and Info into this entry.
    //
    Entry->Type = EntryType;
    PktpEntryIdMove(&Entry->Id, EntryId);
    if (ARGUMENT_PRESENT(EntryInfo))  {
        PktpEntryInfoMove(&Entry->Info, EntryInfo);

        for (i = 0; i < Entry->Info.ServiceCount; i++) {
            Entry->Info.ServiceList[i].pMachEntry->UseCount = 1;
        }

        //
        // If we are setting up a PKT_ENTRY_TYPE_REFERRAL_SVC entry then we want
        // to mark ALL of its services to be REFERRAL_SERVICES as well.
        //
        if (EntryType & PKT_ENTRY_TYPE_REFERRAL_SVC)    {
            pService = Entry->Info.ServiceList;
            for (i=0; i<Entry->Info.ServiceCount; i++)  {
                pService->Type = pService->Type | DFS_SERVICE_TYPE_REFERRAL;
                pService++;
            }
        }
        //
        // Now we need to make sure that there is only one copy of the
        // DS_MACHINE structures for each of the above services that we added.
        //
        if (!(EntryType & PKT_ENTRY_TYPE_NONDFS)) {
            status = DfsFixDSMachineStructs(Entry);
            if (!NT_SUCCESS(status))    {
                //
                // We messed up. This means that something is really messed up.
                //
                DfsDbgTrace(0, 1,
                        "DFS: DfsFixDSMachineStructs failed for %wZ\n",
                        &Entry->Id.Prefix);

                PktpEntryIdMove(EntryId, &Entry->Id);

                if (ARGUMENT_PRESENT(EntryInfo))
                    PktpEntryInfoMove(EntryInfo, &Entry->Info);

                return(status);
            }
        }
    }
    //
    // Initialize the head of the subordinate list.
    //
    InitializeListHead(&Entry->SubordinateList);

    //
    // Initialize the head of the childList.
    //
    InitializeListHead(&Entry->ChildList);

    //
    // Try to get us into the prefix table.
    //

    if (DfsInsertUnicodePrefix(&Pkt->PrefixTable,
                               &Entry->Id.Prefix,
                               &Entry->PrefixTableEntry)) {

        //
        // We successfully created the prefix entry, so now we link
        // this entry into the PKT.
        //
        PktLinkEntry(Pkt, Entry);

        //
        // And insert into the short prefix table. We don't do error
        // recovery if this fails.
        //

        DfsInsertUnicodePrefix(&Pkt->ShortPrefixTable,
                               &Entry->Id.ShortPrefix,
                               &Entry->PrefixTableEntry);

    } else {

        //
        // We failed to get the entry into the prefix table.  This
        // can only happen if a prefix already exists, and a prefix
        // can only exist if we've really gotten messed up...
        // We disassemble the entry and return an error.
        //

        DfsDbgTrace(0, 1,
                "DFS: PktEntryAssemble failed prefix table insert of %wZ\n",
                &Entry->Id.Prefix);

        PktpEntryIdMove(EntryId, &Entry->Id);
        if (ARGUMENT_PRESENT(EntryInfo))
            PktpEntryInfoMove(EntryInfo, &Entry->Info);

        MupErrorCase++;
        status = DFS_STATUS_ENTRY_EXISTS;
    }

    if (status == STATUS_SUCCESS)
    {
        Entry->pDfsTargetInfo = pDfsTargetInfo;
        PktAcquireTargetInfo(pDfsTargetInfo);
    }
    DfsDbgTrace(-1, Dbg, "PktEntryAssemble: Exit -> %08lX\n", ULongToPtr(status) );


    // Bug 435639: if insert fails dont return SUCCESS!!
    return status;
}



//+-------------------------------------------------------------------------
//
//  Function:   PktEntryReassemble, private
//
//  Synopsis:   PktpEntryReassemble blindly reconstructs a partition
//              table entry.  It provides a mechanism by which an existing
//              entry can be modified.  The caller must have previously
//              determined that no other entry with this UID or Prefix
//              existed. The PKT must be acquired exclusively for this
//              operation.
//
//  Arguments:  [Entry] - a pointer to an entry to be reassembled.
//              [Pkt] - pointer to a initialized (and acquired
//                      exclusively) PKT - must be provided if EntryId
//                      is provided.
//              [EntryType] - the type of entry to reassemble.
//              [EntryId] - pointer to the entry's new Id.
//              [EntryInfo] - pointer to the new guts of the entry.
//
//  Returns:    [STATUS_SUCCESS] if no error.
//              [STATUS_INVALID_PARAMETER] - if the EntryId does not have a
//                  UID or a Prefix (no such thing as an anonymous entry), or
//                  and EntryId was provided but a PKT argument was not.
//              [DFS_STATUS_ENTRY_EXISTS] - a new prefix table entry could not
//                  be made.
//              [DFS_STATUS_INCONSISTENT] - a new prefix table entry could
//                  not be made, and we could not back out of the operation.
//                  This status return indicates that the entry is no longer
//                  in the prefix table associated with the PKT and that
//                  it is likely that the PKT is inconsistent as a result.
//
//  Notes:      The EntryId and EntryInfo structures are MOVED (not
//              COPIED) to the entry, the old Id and Info are destroyed.
//              The memory used for UNICODE_STRINGS and DFS_SERVICE arrays
//              is used by the entry.  The associated fields in the EntryId
//              and EntryInfo structures passed as arguments are Zero'd to
//              indicate that the memory has been "deallocated" from these
//              structures and reallocated to the newly created Entry.  Note
//              that this routine does not deallocate the EntryId structure
//              or the EntryInfo structure itself.  On successful return from
//              this function, the EntryId structure will be modified
//              to have a NULL Prefix entry, and the EntryInfo structure
//              will be modified to have zero services and a null ServiceList
//              entry.
//
//--------------------------------------------------------------------------
NTSTATUS
PktEntryReassemble(
    IN  OUT PDFS_PKT_ENTRY Entry,
    IN      PDFS_PKT Pkt,
    IN      ULONG EntryType,
    IN      PDFS_PKT_ENTRY_ID EntryId,
    IN      PDFS_PKT_ENTRY_INFO EntryInfo,
    IN      PDFS_TARGET_INFO pDfsTargetInfo
)
{
    NTSTATUS            status = STATUS_SUCCESS;
    ULONG               i;
    PDFS_SERVICE        pService;

    DfsDbgTrace(+1, Dbg, "PktEntryReassemble: Entered\n", 0);

    ASSERT(ARGUMENT_PRESENT(Entry) &&
           ARGUMENT_PRESENT(Pkt));

    if (ARGUMENT_PRESENT(EntryId)) {

        DFS_PKT_ENTRY_ID oldId;

        //
        // We do not allow the creation of entries
        // without any Prefix.
        //

        if (EntryId->Prefix.Length == 0) {
            DfsDbgTrace(-1, Dbg, "PktEntryReassemble: Exit -> %08lx\n",
                                    ULongToPtr(STATUS_INVALID_PARAMETER) );
            return STATUS_INVALID_PARAMETER;
        }

        //
        // need to get rid of our current prefix info.  We save the
        // old Id in case we fail to reassemble the new entry.
        //

        DfsRemoveUnicodePrefix(&Pkt->PrefixTable, &(Entry->Id.Prefix));
        DfsRemoveUnicodePrefix(&Pkt->ShortPrefixTable, &Entry->Id.ShortPrefix);
        PktpEntryIdMove(&oldId, &Entry->Id);

        //
        // Now we assemble the new Id and attempt to make a new entry
        // in the Pkt prefix table.
        //

        PktpEntryIdMove(&Entry->Id, EntryId);

        if (DfsInsertUnicodePrefix(&Pkt->PrefixTable,
                                   &Entry->Id.Prefix,
                                   &Entry->PrefixTableEntry)
        ) {
            //
            // Everything looks good so its safe to unload the old Id.
            //

            DfsInsertUnicodePrefix(&Pkt->ShortPrefixTable,
                                   &Entry->Id.ShortPrefix,
                                   &Entry->PrefixTableEntry);

            PktEntryIdDestroy(&oldId, FALSE);
        } else {

            //
            // We were unable to make the new prefix entry, so we
            // attempt to back out and put things back the way
            // they were.
            //

            status = DFS_STATUS_ENTRY_EXISTS;

            PktpEntryIdMove(EntryId, &Entry->Id);
            PktpEntryIdMove(&Entry->Id, &oldId);

            status = DfsInsertInPrefixTable(&Pkt->PrefixTable,
                                        &Entry->Id.Prefix,
                                        &Entry->PrefixTableEntry);

            if( !NT_SUCCESS( status ) ) {

                //
                // We can't get things back to where they were. Return
                // the error that DfsInsertInPrefixTable returned to us
                // (probably STATUS_INSUFFICIENT_RESOURCES)
                //
                // Destory the entry since it can't be found.
                //
                PktEntryDestroy(Entry, Pkt, TRUE);
                DfsDbgTrace(-1, Dbg, "PktEntryReassemble: Exit -> %08lx\n", ULongToPtr(status) );
                return status;

            } else {

                DfsInsertUnicodePrefix(&Pkt->ShortPrefixTable,
                                       &Entry->Id.ShortPrefix,
                                       &Entry->PrefixTableEntry);

            }

        }

    }

    //
    // Now we work on the entry info
    //

    if (NT_SUCCESS(status) && EntryInfo != 0) {

        //
        // Destroy the existing info structure and move the new
        // one into its place.  Note that the active service is
        // Nulled.
        //

        PktEntryInfoDestroy(&Entry->Info, FALSE);
        PktpEntryInfoMove(&Entry->Info, EntryInfo);

        for (i = 0; i < Entry->Info.ServiceCount; i++) {
            Entry->Info.ServiceList[i].pMachEntry->UseCount = 1;

        }

        if (EntryType & PKT_ENTRY_TYPE_REFERRAL_SVC)    {
            pService = Entry->Info.ServiceList;
            for (i=0; i<Entry->Info.ServiceCount; i++)  {
                pService->Type = pService->Type | DFS_SERVICE_TYPE_REFERRAL;
                pService++;
            }
        }

        Entry->ActiveService = NULL;

        //
        // Now we need to make sure that there is only one copy of the
        // DS_MACHINE structures for each of the above services that we added.
        //
        if (!(EntryType & PKT_ENTRY_TYPE_NONDFS))    {
            status = DfsFixDSMachineStructs(Entry);
            if (!NT_SUCCESS(status))    {
                //
                // We messed up. This means that something is really messed up.
                //
                DfsDbgTrace(0, 1,
                        "DFS: DfsFixDSMachineStructs failed for %wZ\n",
                        &Entry->Id.Prefix);

                PktpEntryIdMove(EntryId, &Entry->Id);

                if (ARGUMENT_PRESENT(EntryInfo))
                    PktpEntryInfoMove(EntryInfo, &Entry->Info);

                return(status);
            }
        }
    }

    if (NT_SUCCESS(status) && EntryInfo != 0) {
        Entry->Type |= EntryType;

        //
        // If the new entry type is "local" we adjust all the
        // subordinates to indicate that they are all now
        // local exit points.
        //
        if (Entry->Type & PKT_ENTRY_TYPE_LOCAL) {

            PDFS_PKT_ENTRY subEntry;

            for (subEntry = PktEntryFirstSubordinate(Entry);
                subEntry != NULL;
                subEntry = PktEntryNextSubordinate(Entry, subEntry)) {

                    subEntry->Type |= PKT_ENTRY_TYPE_LOCAL_XPOINT;
            }
        }

        //
        // Finally, we update the USN
        //

        Entry->USN++;
        DfsDbgTrace(0, Dbg, "Updated USN for %wZ", &Entry->Id.Prefix);
        DfsDbgTrace(0, Dbg, " to %d\n", ULongToPtr(Entry->USN) );
    }

    if (status == STATUS_SUCCESS)
    {
        if (Entry->pDfsTargetInfo != NULL)
        {
            PktReleaseTargetInfo( Entry->pDfsTargetInfo );
            Entry->pDfsTargetInfo = pDfsTargetInfo;
            PktAcquireTargetInfo( pDfsTargetInfo );
        }
    }

    DfsDbgTrace(-1, Dbg, "PktEntryReassemble: Exit -> %08lx\n", ULongToPtr(status) );
    return status;
}



//+-------------------------------------------------------------------------
//
//  Function:   PktEntryDestroy, public
//
//  Synopsis:   PktEntryDestroy destroys an pkt entry structure, and
//              optionally deallocates the structure itself.
//
//  Arguments:  [Victim] - the entry structure to destroy
//              [Pkt] - pointer to the PKT this entry is in.
//              [DeallocateAll] - if True, indicates that the structure
//                  itself is to be deallocated, otherwise, only the
//                  service list within the structure is deallocated.
//
//  Returns:    VOID
//
//  Notes:      This should not be called on an entry that has a
//              local service attached, or which is a local exit point.
//
//--------------------------------------------------------------------------
VOID
PktEntryDestroy(
    IN  PDFS_PKT_ENTRY Victim OPTIONAL,
    IN  PDFS_PKT Pkt,
    IN  BOOLEAN DeallocateAll
)
{
    DfsDbgTrace(+1, Dbg, "PktEntryDestroy: Entered\n", 0);

    ASSERT(ARGUMENT_PRESENT(Pkt));

    //
    // Make sure we have a victim...
    //
    if (!ARGUMENT_PRESENT(Victim)) {
        DfsDbgTrace(-1, Dbg, "PktEntryDestroy: Exit -> No Victim\n", 0);
        return;
    }

    //
    // We really don't expect to have a LocalService but then even if we
    // do have one due to running DFSINIT again etc. let us try to handle it.
    //

    ASSERT(Victim->LocalService == NULL);

    //
    // Remove the entry from the prefix table and from the PKT.
    //

    DfsRemoveUnicodePrefix(&Pkt->PrefixTable, &(Victim->Id.Prefix));
    DfsRemoveUnicodePrefix(&Pkt->ShortPrefixTable, &(Victim->Id.ShortPrefix));
    PktUnlinkEntry(Pkt, Victim);

    //
    // We clear away all subordinates and parents.
    //
    PktEntryClearSubordinates(Victim);
    if (Victim->Superior)
        PktEntryUnlinkSubordinate(Victim->Superior, Victim);

    //
    // We clear all the children and parent pointers from here.
    //
    PktEntryClearChildren(Victim);
    if (Victim->ClosestDC) {
        PktEntryUnlinkChild(Victim->ClosestDC, Victim);
    }

    //
    // Now destroy the body of the entry (id, and info).
    //

    Victim->ActiveService = NULL;
    PktEntryIdDestroy(&Victim->Id, FALSE);
    PktEntryInfoDestroy(&Victim->Info, FALSE);

    
    if (Victim->pDfsTargetInfo != NULL)
    {
        PktReleaseTargetInfo(Victim->pDfsTargetInfo);
        Victim->pDfsTargetInfo = NULL;
    }
    //
    // Deallocate everything if they want us to.
    //
    if (DeallocateAll)
        ExFreePool(Victim);


    DfsDbgTrace(-1, Dbg, "PktEntryDestroy: Exit -> VOID\n", 0);
}


//+-------------------------------------------------------------------------
//
//  Function:   PktEntryClearSubordinates, public
//
//  Synopsis:   PktEntryClearSubordinates unlinks all subordinates from
//              this entry.
//
//  Arguments:  [PktEntry] - a pointer to an entry that is to have all its
//                  subordinates unlinked.
//
//  Returns:    VOID
//
//  Notes:
//
//--------------------------------------------------------------------------
VOID
PktEntryClearSubordinates(
    IN      PDFS_PKT_ENTRY PktEntry
)
{
    PDFS_PKT_ENTRY subEntry;

    DfsDbgTrace(+1, Dbg, "PktEntryClearSubordinates: Entered\n", 0);

    ASSERT(ARGUMENT_PRESENT(PktEntry));

    subEntry = PktEntryFirstSubordinate(PktEntry);
    while (subEntry) {
        PktEntryUnlinkSubordinate(PktEntry, subEntry);
        subEntry = PktEntryFirstSubordinate(PktEntry);
    }

    DfsDbgTrace(-1, Dbg, "PktEntryClearSubordinates: Exit -> VOID\n", 0)
}



//+-------------------------------------------------------------------------
//
//  Function:   PktEntryClearChildren, public
//
//  Synopsis:   PktEntryClearChildren unlinks all children from
//              this entry.
//
//  Arguments:  [PktEntry] - a pointer to an entry that is to have all its
//                           children unlinked.
//
//  Returns:    VOID
//
//  Notes:
//
//--------------------------------------------------------------------------

VOID
PktEntryClearChildren(
    IN      PDFS_PKT_ENTRY PktEntry
)
{
    PDFS_PKT_ENTRY subEntry;

    DfsDbgTrace(+1, Dbg, "PktEntryClearChildren: Entered\n", 0);

    ASSERT(ARGUMENT_PRESENT(PktEntry));

    subEntry = PktEntryFirstChild(PktEntry);
    while (subEntry) {
        PktEntryUnlinkAndRelinkChild(PktEntry, subEntry);
        subEntry = PktEntryFirstChild(PktEntry);
    }

    DfsDbgTrace(-1, Dbg, "PktEntryClearChildren: Exit -> VOID\n", 0)
}

//+-------------------------------------------------------------------------
//
//  Function:   PktSpecialEntryDestroy, public
//
//  Synopsis:   Returns a DFS_SPECIAL_ENTRY's expansion list to the free pool
//
//  Arguments:  [pSpecialEntry] - Pointer to DFS_SPECIAL_ENTRY
//
//  Returns:    VOID
//
//  Notes:
//
//--------------------------------------------------------------------------

VOID
PktSpecialEntryDestroy(
    IN  PDFS_SPECIAL_ENTRY pSpecialEntry)
{
    PDFS_EXPANDED_NAME pExpandedNames = pSpecialEntry->ExpandedNames;
    PUNICODE_STRING pustr;
    ULONG i;

    //
    // Free all the UNICODE_STRING ExpandedName buffers
    //
    if (pExpandedNames) {
        for (i = 0; i < pSpecialEntry->ExpandedCount; i++) {
            pustr = &pExpandedNames[i].ExpandedName;
            if (pustr->Buffer) {
                ExFreePool(pustr->Buffer);
            }
        }
        //
        // Free the array of ExpandedNames
        //
        ExFreePool(pExpandedNames);
    }

    //
    // Free the SpecialName buffer
    //

    if (pSpecialEntry->SpecialName.Buffer != NULL) {

        ExFreePool(pSpecialEntry->SpecialName.Buffer);

    }

    //
    // Free the entry itself
    //
    ExFreePool(pSpecialEntry);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mup\prefix.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       prefix.hxx
//
//  Contents:   PREFIX table definition
//
//  History:    SethuR -- Implemented
//
//  Notes:      The DFS prefix table data structure consists of three
//              entities and methods to manipulate them. They are the
//              DFS_PREFIX_TABLE_ENTRY,DFS_PREFIX_TABLE_BUCKET and the
//              DFS_PREFIX_TABLE.
//
//              The DFS_PREFIX_TABLE is a hash table of DFS_PREFIX_TABLE_ENTRY's
//              wherein collisions are resolved through linear chaining. The
//              hash table is organized as an array of collision lists
//              (DFS_PREFIX_TABLE_BUCKET). A brief description with each of
//              these entities is attached to the declaration.
//
//              There are certain characterstics that distinguish this
//              hash table from other hash tables. These are the extensions
//              provided to accomodate the special operations.
//
//--------------------------------------------------------------------------

#ifndef __PREFIX_HXX__
#define __PREFIX_HXX__

//+---------------------------------------------------------------------
//
// Struct:  DFS_PREFIX_TABLE_ENTRY
//
// History:
//
// Notes:   Each DFS_PREFIX_TABLE entry is in reality a member of two linked
//          lists -- a doubly linked list chaining the entries in a bucket
//          and a singly linked list establishing the path from any entry to
//          the root of the name space. In addition we have the data associated
//          with each entry, viz., the name and the data (pData). We also
//          keep track of the number of children of each entry. It can also
//          be defined as the number of paths to the root of which this entry
//          is a member.
//
//----------------------------------------------------------------------

typedef struct _DFS_PREFIX_TABLE_ENTRY_
{
   struct _DFS_PREFIX_TABLE_ENTRY_  *pParentEntry;
   struct _DFS_PREFIX_TABLE_ENTRY_  *pNextEntry;
   struct _DFS_PREFIX_TABLE_ENTRY_  *pPrevEntry;

   //
   // pFirstChildEntry and pSiblingEntry are used purely for enumeration
   //
   struct _DFS_PREFIX_TABLE_ENTRY_  *pFirstChildEntry;
   struct _DFS_PREFIX_TABLE_ENTRY_  *pSiblingEntry;

   ULONG                             NoOfChildren;

   UNICODE_STRING                    PathSegment;
   PVOID                             pData;
} DFS_PREFIX_TABLE_ENTRY, *PDFS_PREFIX_TABLE_ENTRY;

//+---------------------------------------------------------------------
//
// Struct:  DFS_PREFIX_TABLE_BUCKET
//
// History:
//
// Notes:   The DFS_PREFIX_TABLE_BUCKET is a doubly linked list of
//          DFS_PREFIX_TABLE_ENTRY's. The current implementation employs
//          the notion of a sentinel entry associated with each bucket. The
//          end pointers are never null but are always looped back to the
//          sentinel entry. The reason we employ such an organization is that
//          it considerably simplifies the list manipulation routines. The
//          reason this needs to be a doubly linked list is that we would like
//          to have the ability of deleting entries without having to traverse
//          the buckets from beginning.
//
//          The following inline methods ( macro defns. ) are provided for
//          inserting, deleting and looking up an entry in the bucket.
//
//----------------------------------------------------------------------

typedef struct _PREFIX_TABLE_BUCKET_
{
   ULONG                  NoOfEntries;   // High water mark for entries hashing to the bkt.
   DFS_PREFIX_TABLE_ENTRY SentinelEntry;
} PREFIX_TABLE_BUCKET, *PPREFIX_TABLE_BUCKET;

//+---------------------------------------------------------------------
//
// Struct:  NAME_PAGE
//
// History:
//
// Notes:   The name segments associated with the various entries are all
//          stored together in a name page. This allows us to amortize the
//          memory allocation costs over a number of entries and also allows
//          us to speed up traversal ( for details see DFS_PREFIX_TABLE
//          definition ).
//
//----------------------------------------------------------------------

#define FREESPACE_IN_NAME_PAGE ((PAGE_SIZE - sizeof(ULONG) - sizeof(PVOID)) / sizeof(WCHAR))

typedef struct _NAME_PAGE_
{
   struct _NAME_PAGE_  *pNextPage;
   LONG                cFreeSpace; // free space avilable in WCHAR's
   WCHAR               Names[FREESPACE_IN_NAME_PAGE];
} NAME_PAGE, *PNAME_PAGE;

typedef struct _NAME_PAGE_LIST_
{
   PNAME_PAGE  pFirstPage;
} NAME_PAGE_LIST, *PNAME_PAGE_LIST;

//+---------------------------------------------------------------------
//
// Struct:  DFS_PREFIX_TABLE
//
// History:
//
// Notes:   The DFS_PREFIX_TABLE is a hashed collection of DFS_PREFIX_TABLE_ENTRY
//          organized in the form of buckets. In addition one other space
//          conserving measure is adopted. There is only one copy of each
//          name segment stored in the table. As an example consider the
//          two pathnames \foo\bar and \bar\foo. We only store one copy of foo
//          and bar eventhough we accomdate both these paths. A beneficial
//          side effect of storing single copies is that our traversal of the
//          collision chain is considerably speeded up since once we have
//          located the pointer to the name, subsequent comparisons need merely
//          compare pointers as opposed to strings.
//
//----------------------------------------------------------------------

#define NO_OF_HASH_BUCKETS 57

typedef struct _DFS_PREFIX_TABLE
{
   BOOLEAN             CaseSensitive;
   NAME_PAGE_LIST      NamePageList;
   //
   // NextEntry is used purely for enumeration
   //
   PDFS_PREFIX_TABLE_ENTRY NextEntry;
   DFS_PREFIX_TABLE_ENTRY RootEntry;
   PREFIX_TABLE_BUCKET Buckets[NO_OF_HASH_BUCKETS];

#ifdef KERNEL_MODE

   // Zone for allocating DFS_PREFIX_TABLE entries .....

   ZONE_HEADER         PrefixTableEntryZone;

#else

   // A DFS_PREFIX_TABLE is part of DS_DATA. We need to make the sizes of
   // these structures identical in user and kernel mode, so that user-mode
   // utilities like dfsdump can work.

   CHAR                UnusedBuffer[sizeof(ZONE_HEADER)];

#endif
} DFS_PREFIX_TABLE, *PDFS_PREFIX_TABLE;

//+---------------------------------------------------------------------
//
// Struct:  DFS_PREFIX_TABLE API.
//
// History:
//
// Notes:   The following API's are provided for manipulating the
//          DFS_PREFIX_TABLE.
//
//----------------------------------------------------------------------

extern
NTSTATUS DfsInitializePrefixTable(PDFS_PREFIX_TABLE pTable,
                                  BOOLEAN           fCaseSensitive);

extern
NTSTATUS DfsInsertInPrefixTable(PDFS_PREFIX_TABLE pTable,
                                PUNICODE_STRING   pPath,
                                PVOID             pData);
extern
NTSTATUS DfsLookupPrefixTable(PDFS_PREFIX_TABLE   pTable,
                              PUNICODE_STRING     pPath,
                              PUNICODE_STRING     pSuffix,
                              PVOID               *ppData);

extern
NTSTATUS DfsRemoveFromPrefixTable(PDFS_PREFIX_TABLE pTable,
                                  PUNICODE_STRING pPath);

NTSTATUS
DfsFreePrefixTable(
    PDFS_PREFIX_TABLE pTable);

//
// The RTL Prefix Table function signatures are slightly different.
// For now we will define a mapping between them to ease the porting
// effort. Subsequently we will change our signatures to confirm to
// the RTL routine.
//

#define DfsInitializeUnicodePrefix(pTable) \
        (DfsInitializePrefixTable(pTable,FALSE) == STATUS_SUCCESS)

#define DfsRemoveUnicodePrefix(pTable,pPath)  \
        (DfsRemoveFromPrefixTable(pTable,pPath) == STATUS_SUCCESS)

#define DfsInsertUnicodePrefix(pTable,pPath,pData) \
        (DfsInsertInPrefixTable(pTable,pPath,pData) == STATUS_SUCCESS)

PVOID    DfsFindUnicodePrefix(PDFS_PREFIX_TABLE   pTable,
                              PUNICODE_STRING     pPath,
                              PUNICODE_STRING     pSuffix);

PVOID   DfsNextUnicodePrefix(PDFS_PREFIX_TABLE    pTable,
                             BOOLEAN              fRestart);

#endif // __PREFIX_HXX__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mup\prefix.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       prefix.c
//
//  Contents:   PREFIX table implementation
//
//  History:    SethuR -- Implemented
//
//  Notes:
//
//--------------------------------------------------------------------------

#ifdef KERNEL_MODE
#include "dfsprocs.h"

#define Dbg     DEBUG_TRACE_RTL

#else

#define DfsDbgTrace(x,y,z,a)

#endif

#include <prefix.h>
#include <prefixp.h>

PDFS_PREFIX_TABLE_ENTRY
DfspNextUnicodeTableEntry(
    IN PDFS_PREFIX_TABLE_ENTRY pEntry);

#ifdef ALLOC_PRAGMA

#pragma alloc_text( PAGE, DfsFreePrefixTable )
#pragma alloc_text( PAGE, DfsInitializePrefixTable )
#pragma alloc_text( PAGE, DfsInsertInPrefixTable )
#pragma alloc_text( PAGE, DfsLookupPrefixTable )
#pragma alloc_text( PAGE, DfsFindUnicodePrefix )
#pragma alloc_text( PAGE, DfsRemoveFromPrefixTable )

#endif  // ALLOC_PRAGMA

//+---------------------------------------------------------------------------
//
//  Function:   DfsInitializePrefixTable
//
//  Synopsis:   API for initializing the prefix table
//
//  Arguments:  [pTable] -- the DFS prefix table instance
//
//  Returns:    one of the following NTSTATUS codes
//                  STATUS_SUCCESS -- call was successfull.
//
//  History:    04-18-94  SethuR Created
//
//  Notes:
//
//----------------------------------------------------------------------------

NTSTATUS DfsInitializePrefixTable(PDFS_PREFIX_TABLE pTable, BOOLEAN fCaseSensitive)
{
    NTSTATUS status = STATUS_SUCCESS;

    DfsDbgTrace(+1, Dbg,"DfsInitializePrefixTable -- Entry\n", 0);

    if (pTable != NULL)
    {
        ULONG i;

        // Initialize flags
        pTable->CaseSensitive = fCaseSensitive;

        // Initialize the root entry
        INITIALIZE_PREFIX_TABLE_ENTRY(&pTable->RootEntry);

        // Initialize the various buckets.
        for (i = 0;i < NO_OF_HASH_BUCKETS;i++)
        {
            INITIALIZE_BUCKET(pTable->Buckets[i]);
        }

        // Initialize the name page list.
        pTable->NamePageList.pFirstPage = ALLOCATE_NAME_PAGE();
        if (pTable->NamePageList.pFirstPage != NULL)
        {
            INITIALIZE_NAME_PAGE(pTable->NamePageList.pFirstPage);

            // Initialize the prefix table entry allocation mechanism.
            status = _InitializePrefixTableEntryAllocation(pTable);
        }
        else
        {
            status = STATUS_NO_MEMORY;
            DfsDbgTrace(0, Dbg,"DfsInitializePrefixTable Error -- %lx\n", ULongToPtr(status) );
        }
    }
    else
    {
        status = STATUS_INVALID_PARAMETER;
        DfsDbgTrace(0, Dbg,"DfsInitializePrefixTable Error -- %lx\n", ULongToPtr(status) );
    }

    DfsDbgTrace(-1, Dbg, "DfsInitializePrefixTable -- Exit\n", 0);
    return  status;
}

//+---------------------------------------------------------------------------
//
//  Function:   DfsInsertInPrefixTable
//
//  Synopsis:   API for inserting a path in the prefix table
//
//  Arguments:  [pTable] -- the DFS prefix table instance
//
//              [pPath]  -- the path to be looked up.
//
//              [pData] -- BLOB associated with the path
//
//  Returns:    one of the following NTSTATUS codes
//                  STATUS_SUCCESS -- call was successfull.
//
//  History:    04-18-94  SethuR Created
//
//  Notes:
//
//----------------------------------------------------------------------------

NTSTATUS DfsInsertInPrefixTable(PDFS_PREFIX_TABLE pTable,
                                 PUNICODE_STRING   pPath,
                                 PVOID             pData)
{
    NTSTATUS                status = STATUS_SUCCESS;
    WCHAR                   Buffer[MAX_PATH_SEGMENT_SIZE];
    PWCHAR                  NameBuffer = Buffer;
    USHORT                  cbNameBuffer = sizeof(Buffer);
    UNICODE_STRING          Path,Name;
    ULONG                   BucketNo;
    PDFS_PREFIX_TABLE_ENTRY pEntry = NULL;
    PDFS_PREFIX_TABLE_ENTRY pParentEntry = NULL;
    BOOLEAN                 fNameFound = FALSE;

    DfsDbgTrace(+1, Dbg, "DfsInsertInPrefixTable -- Entry\n", 0);

    // There is one special case, i.e., in which the prefix is '\'.
    // Since this is the PATH_DELIMITER which is treated in a special
    // way, we do the processing upfront.

    if (pPath->Length == 0)
    {
        return STATUS_SUCCESS;
    }
    else if ((pPath->Length == sizeof(WCHAR)) &&
        (pPath->Buffer[0] == PATH_DELIMITER))
    {
       pTable->RootEntry.pData = pData;
       return STATUS_SUCCESS;
    }
    else
    {
        Path.Length = pPath->Length - sizeof(WCHAR);
        Path.MaximumLength = pPath->MaximumLength;
        Path.Buffer = &pPath->Buffer[1];
        pParentEntry = &pTable->RootEntry;
    }

    if (Path.Length > MAX_PATH_SEGMENT_SIZE * sizeof(WCHAR) ) {
        NameBuffer = ExAllocatePoolWithTag( NonPagedPool, Path.Length + sizeof(WCHAR), ' puM' );
        if (NameBuffer == NULL) {
            DfsDbgTrace(0, Dbg, "Unable to allocate %d non-paged bytes\n", (Path.Length + sizeof(WCHAR)) );
            return( STATUS_INSUFFICIENT_RESOURCES );
        } else {
            cbNameBuffer = Path.Length + sizeof(WCHAR);
        }
    }

    while (Path.Length > 0)
    {
        Name.Length = 0;
        Name.Buffer = NameBuffer;
        Name.MaximumLength = cbNameBuffer;

        // Process the name segment
        if (pTable->CaseSensitive)
        {
            SPLIT_CASE_SENSITIVE_PATH(&Path,&Name,BucketNo);
        }
        else
        {
            SPLIT_CASE_INSENSITIVE_PATH(&Path,&Name,BucketNo);
        }

        if (Name.Length > 0)
        {
            // Lookup the table to see if the name segment already exists.
            DfsDbgTrace(0, Dbg, "LOOKUP_BUCKET: Bucket(%ld)\n", ULongToPtr(BucketNo) );
            DfsDbgTrace(0, Dbg, " for Name(%wZ)\n", &Name);

            LOOKUP_BUCKET(pTable->Buckets[BucketNo],Name,pParentEntry,pEntry,fNameFound);

            DfsDbgTrace(0, Dbg, "returned pEntry(%lx)", pEntry);
            DfsDbgTrace(0, Dbg, " fNameFound(%s)\n", fNameFound ? "TRUE" : "FALSE");

            if (pEntry == NULL)
            {
                // Initialize the new entry and initialize the name segment.
                pEntry = ALLOCATE_DFS_PREFIX_TABLE_ENTRY(pTable);
                if (pEntry != NULL)
                {
                    INITIALIZE_PREFIX_TABLE_ENTRY(pEntry);

                    // Allocate the name space entry if there is no entry in the
                    // name page.
                    if (!fNameFound || fNameFound)
                    {
                        PWSTR pBuffer;

                        // Allocate the entry in the name page.
                        pBuffer = ALLOCATE_NAME_PAGE_ENTRY((pTable->NamePageList),(Name.Length/sizeof(WCHAR)));

                        if (pBuffer != NULL)
                        {
                            RtlZeroMemory(pBuffer,Name.Length);
                            RtlCopyMemory(pBuffer,Name.Buffer,Name.Length);
                            pEntry->PathSegment = Name;
                            pEntry->PathSegment.Buffer = pBuffer;
                        }
                        else
                        {
                            status = STATUS_NO_MEMORY;
                            break;
                        }
                    }
                    else
                        pEntry->PathSegment = Name;

                    // thread the entry to point to the parent.
                    pEntry->pParentEntry = pParentEntry;

                    // Insert the entry in the bucket.
                    INSERT_IN_BUCKET(pTable->Buckets[BucketNo],pEntry);

                    // Insert the entry in the parent's children list.
                    INSERT_IN_CHILD_LIST(pEntry, pParentEntry);
                }
                else
                {
                    status = STATUS_NO_MEMORY;
                    DfsDbgTrace(0, Dbg, "DfsInsertInPrefixTable Error -- %lx\n", ULongToPtr(status) );
                    break;
                }
            }
            else
            {
                // Increment the no. of children associated with  this entry

                pEntry->NoOfChildren++;
            }

            pParentEntry = pEntry;
        }
        else
        {
            status = STATUS_INVALID_PARAMETER;
            DfsDbgTrace(0, Dbg, "DfsInsertInPrefixTable Error -- %lx\n", ULongToPtr(status) );
            break;
        }
    }

    // If a new entry was not successfully inserted we need to walk up the chain
    // of parent entries to undo the increment to the reference count and
    // remove the entries from their parent links.
    if (NT_SUCCESS(status))
    {
        // The entry was successfully inserted in the prefix table. Update
        // the data (BLOB) associated with it.
        // We do it outside the loop to prevent redundant comparisons within
        // the loop.

        pEntry->pData = pData;
    }
    else
    {
        while (pParentEntry != NULL)
        {
            PDFS_PREFIX_TABLE_ENTRY pMaybeTempEntry;

            pMaybeTempEntry = pParentEntry;
            pParentEntry = pParentEntry->pParentEntry;

            if (--pMaybeTempEntry->NoOfChildren == 0) {
                //
                // If pParentEntry == NULL, pMaybeTempEntry is
                // pTable->RootEntry. Do not try to remove it.
                //
                if (pParentEntry != NULL) {
                    REMOVE_FROM_CHILD_LIST(pMaybeTempEntry);
                    REMOVE_FROM_BUCKET(pMaybeTempEntry);
                    FREE_DFS_PREFIX_TABLE_ENTRY(pTable, pMaybeTempEntry);
                }
            }
        }
    }

    if (NameBuffer != Buffer) {
        ExFreePool( NameBuffer );
    }

    DfsDbgTrace(-1, Dbg, "DfsInsertInPrefixTable -- Exit\n", 0);
    return status;
}

//+---------------------------------------------------------------------------
//
//  Function:   DfsLookupPrefixTable
//
//  Synopsis:   private fn. for looking up a name segment in a prefix table
//
//  Arguments:  [pTable] -- the DFS prefix table instance
//
//              [pPath]  -- the path to be looked up.
//
//              [pSuffix] -- the suffix that could not be found.
//
//              [ppData] -- placeholder for the BLOB for the prefix.
//
//
//  Returns:    one of the following NTSTATUS codes
//                  STATUS_SUCCESS -- call was successfull.
//                  STATUS_OBJECT_PATH_NOT_FOUND -- no entry for the path
//
//  History:    04-18-94  SethuR Created
//
//  Notes:
//
//----------------------------------------------------------------------------

NTSTATUS DfsLookupPrefixTable(PDFS_PREFIX_TABLE   pTable,
                               PUNICODE_STRING     pPath,
                               PUNICODE_STRING     pSuffix,
                               PVOID               *ppData)
{
    NTSTATUS                status = STATUS_SUCCESS;
    PDFS_PREFIX_TABLE_ENTRY pEntry = NULL;

    DfsDbgTrace(+1, Dbg, "DfsLookupInPrefixTable -- Entry\n", 0);

    if (pPath->Length == 0)
    {
        DfsDbgTrace(-1, Dbg, "DfsLookupInPrefixTable Exited - Null Path!\n", 0);
        return STATUS_SUCCESS;
    }
    else
    {
        status = _LookupPrefixTable(pTable,pPath,pSuffix,&pEntry);

        // Update the BLOB placeholder with the results of the lookup.
        if (NT_SUCCESS(status))
        {
             *ppData = pEntry->pData;
        }

        DfsDbgTrace(-1, Dbg, "DfsLookupInPrefixTable -- Exit\n", 0);
        return status;
    }

}

//+---------------------------------------------------------------------------
//
//  Function:   DfsFindUnicodePrefix
//
//  Synopsis:   fn. for looking up a name segment in a prefix table
//
//  Arguments:  [pTable] -- the DFS prefix table instance
//
//              [pPath]  -- the path to be looked up.
//
//              [pSuffix] -- the suffix that could not be found.
//
//  Returns:    a valid ptr if successfull, NULL otherwise
//
//  History:    04-18-94  SethuR Created
//
//  Notes:
//
//----------------------------------------------------------------------------

PVOID DfsFindUnicodePrefix(PDFS_PREFIX_TABLE   pTable,
                           PUNICODE_STRING     pPath,
                           PUNICODE_STRING     pSuffix)
{
    NTSTATUS                status = STATUS_SUCCESS;
    PDFS_PREFIX_TABLE_ENTRY pEntry = NULL;
    PVOID                   pData  = NULL;

    DfsDbgTrace(+1, Dbg, "DfsFindUnicodePrefix -- Entry\n", 0);

    if (pPath->Length == 0)
    {
        DfsDbgTrace(-1, Dbg, "DfsFindUnicodePrefix Exited - Null Path!\n", 0);
        return NULL;
    }
    else
    {
        status = _LookupPrefixTable(pTable,pPath,pSuffix,&pEntry);

        // Update the BLOB placeholder with the results of the lookup.
        if (NT_SUCCESS(status))
        {
             pData = pEntry->pData;
        }

        DfsDbgTrace(-1, Dbg, "DfsFindUnicodePrefix -- Exit\n", 0);
        return pData;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   DfsRemoveFromPrefixTable
//
//  Synopsis:   private fn. for looking up a name segment in a prefix table
//
//  Arguments:  [pTable] -- the DFS prefix table instance
//
//              [pPath]  -- the path to be looked up.
//
//  Returns:    one of the following NTSTATUS codes
//                  STATUS_SUCCESS -- call was successfull.
//                  STATUS_OBJECT_PATH_NOT_FOUND -- no entry for the path
//
//  History:    04-18-94  SethuR Created
//
//  Notes:
//
//----------------------------------------------------------------------------

NTSTATUS DfsRemoveFromPrefixTable(PDFS_PREFIX_TABLE pTable,
                                   PUNICODE_STRING pPath)
{
    NTSTATUS status = STATUS_SUCCESS;
    UNICODE_STRING Path,Suffix;
    ULONG    BucketNo;

    PDFS_PREFIX_TABLE_ENTRY pEntry = NULL;

    DfsDbgTrace(+1, Dbg, "DfsRemoveFromPrefixTable -- Entry\n", 0);

    Suffix.Length = 0;
    Suffix.Buffer = NULL;

    if (pPath->Length == 0)
    {
        DfsDbgTrace(-1, Dbg, "DfsRemoveFromPrefixTable Exited -- Null Path!\n", 0);
        return STATUS_SUCCESS;
    }

    else if ((pPath->Length == sizeof(WCHAR)) &&
        (pPath->Buffer[0] == PATH_DELIMITER))
    {
        if (pTable->RootEntry.pData == NULL)
        {
            status = STATUS_OBJECT_PATH_NOT_FOUND;
        }
        else
        {
            pTable->RootEntry.pData = NULL;
            DfsDbgTrace(-1, Dbg, "DfsRemoveFromPrefixTable Exited.\n", 0);
            return  STATUS_SUCCESS;
        }
    }
    else
    {
        Path.Length = pPath->Length - sizeof(WCHAR);
        Path.MaximumLength = pPath->MaximumLength;
        Path.Buffer = &pPath->Buffer[1];

        status = _LookupPrefixTable(pTable,&Path,&Suffix,&pEntry);

        if (NT_SUCCESS(status) && (Suffix.Length == 0))
        {
            // Destroy the association between the data associated with
            // this prefix.
            pEntry->pData = NULL;

            // found an exact match for the given path name in the table.
            // traverse the list of parent pointers and delete them if
            // required.

            while (pEntry != NULL)
            {
                if ((--pEntry->NoOfChildren) == 0)
                {
                    PDFS_PREFIX_TABLE_ENTRY pTempEntry = pEntry;
                    pEntry = pEntry->pParentEntry;

                    //
                    // pEntry == NULL means pTempEntry is pTable->RootEntry.
                    // Do not try to remove it.
                    //
                    if (pEntry != NULL) {
                        REMOVE_FROM_CHILD_LIST(pTempEntry);
                        REMOVE_FROM_BUCKET(pTempEntry);
                        FREE_DFS_PREFIX_TABLE_ENTRY(pTable,pTempEntry);
                    }
                }
                else
                   break;
            }
        }
    }

    DfsDbgTrace(-1, Dbg, "DfsRemoveFromPrefixTable -- Exit\n", 0);
    return status;
}

//+---------------------------------------------------------------------------
//
//  Function:   DfsFreePrefixTable
//
//  Synopsis:   API for freeing a prefix table
//
//  Arguments:  [pTable] -- the DFS prefix table instance
//
//  Returns:    one of the following NTSTATUS codes
//                  STATUS_SUCCESS -- call was successfull.
//
//  History:    08-01-99 JHarper Created
//
//  Notes:
//
//----------------------------------------------------------------------------

NTSTATUS
DfsFreePrefixTable(
    PDFS_PREFIX_TABLE pTable)
{
    NTSTATUS status = STATUS_SUCCESS;
    PNAME_PAGE pNamePage = NULL;
    PNAME_PAGE pNextPage = NULL;
    PDFS_PREFIX_TABLE_ENTRY pEntry = NULL;
    PDFS_PREFIX_TABLE_ENTRY pSentinelEntry = NULL;
    ULONG i;

    if (pTable != NULL) {
       for (i = 0; i < NO_OF_HASH_BUCKETS; i++) {
            pSentinelEntry = &pTable->Buckets[i].SentinelEntry;
            while (pSentinelEntry->pNextEntry != pSentinelEntry) {
                pEntry = pSentinelEntry->pNextEntry;
                REMOVE_FROM_BUCKET(pEntry);
                if (pEntry->PathSegment.Buffer != NULL)
                    ExFreePool(pEntry->PathSegment.Buffer);
                ExFreePool(pEntry);
            }
            pTable->Buckets[i].NoOfEntries = 0;
        }
        if (pTable->RootEntry.PathSegment.Buffer != NULL)
            ExFreePool(pTable->RootEntry.PathSegment.Buffer);

        for (pNamePage = pTable->NamePageList.pFirstPage;
                pNamePage;
                    pNamePage = pNextPage
        ) {
            pNextPage = pNamePage->pNextPage;
            ExFreePool(pNamePage);
        }

    } else {
        status = STATUS_INVALID_PARAMETER;
    }

    return  status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mup\provider.h ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation
//
//  File:       provider.h
//
//  Contents:   Interface to the provider defining module
//
//  Classes:
//
//  Functions:  ProviderInit
//
//  History:    12 Sep 1992 	Milans created.
//
//-----------------------------------------------------------------------------

#ifndef _DFS_PROVIDERS_
#define _DFS_PROVIDERS_

NTSTATUS ProviderInit(void);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mup\prefixp.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       prefixp.c
//
//  Contents:   PREFIX table implementation
//
//  History:    SethuR -- Implemented
//
//  Notes:
//
//--------------------------------------------------------------------------

#ifdef KERNEL_MODE

#include "dfsprocs.h"

#define Dbg DEBUG_TRACE_RTL

#else

#define DfsDbgTrace(x,y,z,a)

#endif


#include <prefix.h>
#include <prefixp.h>

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, _InitializePrefixTableEntryAllocation )
#pragma alloc_text( PAGE, _AllocateNamePageEntry )
#pragma alloc_text( PAGE, _AllocatePrefixTableEntry )
#pragma alloc_text( PAGE, _LookupPrefixTable )
#endif // ALLOC_PRAGMA

//
//  This macro takes a pointer (or ulong) and returns its rounded up quadword
//  value
//

#define QuadAlign(Ptr) (        \
    ((((ULONG)(Ptr)) + 7) & 0xfffffff8) \
    )

//+---------------------------------------------------------------------------
//
//  Function:   _InitializePrefixTableEntryAllocation
//
//  Synopsis:   private fn. for initializing prefix table entry allocation
//
//  Arguments:  [pTable] -- table to be initialized
//
//  Returns:    one of the following NTSTATUS codes
//                  STATUS_SUCCESS -- call was successfull.
//                  STATUS_NO_MEMORY -- no resource available
//
//  History:    04-18-94  SethuR Created
//
//  Notes:
//
//----------------------------------------------------------------------------

NTSTATUS _InitializePrefixTableEntryAllocation(PDFS_PREFIX_TABLE pTable)
{
    NTSTATUS status = STATUS_SUCCESS;

    return  status;
}


//+---------------------------------------------------------------------------
//
//  Function:   _AllocateNamePageEntry
//
//  Synopsis:   private fn. for allocating a name page entry
//
//  Arguments:  [pNamePageList] -- name page list to allocate from
//
//              [cLength]  -- length of the buffer in WCHAR's
//
//  Returns:    NULL if unsuccessfull otherwise valid pointer
//
//  History:    04-18-94  SethuR Created
//
//  Notes:
//
//----------------------------------------------------------------------------

PWSTR _AllocateNamePageEntry(PNAME_PAGE_LIST pNamePageList,
                             ULONG           cLength)
{
   PNAME_PAGE pTempPage = pNamePageList->pFirstPage;
   PWSTR pBuffer = NULL;

   while (pTempPage != NULL)
   {
       if (pTempPage->cFreeSpace > (LONG)cLength)
          break;
       else
          pTempPage = pTempPage->pNextPage;
   }

   if (pTempPage == NULL)
   {
       pTempPage = ALLOCATE_NAME_PAGE();

       if (pTempPage != NULL)
       {
           INITIALIZE_NAME_PAGE(pTempPage);
           pTempPage->pNextPage = pNamePageList->pFirstPage;
           pNamePageList->pFirstPage = pTempPage;
           pTempPage->cFreeSpace = FREESPACE_IN_NAME_PAGE;
       }
   }

   if ((pTempPage != NULL) && (pTempPage->cFreeSpace >= (LONG)cLength))
   {
       pTempPage->cFreeSpace -= cLength;
       pBuffer = &pTempPage->Names[pTempPage->cFreeSpace];
   }

   return pBuffer;
}

//+---------------------------------------------------------------------------
//
//  Function:   _AllocatePrefixTableEntry
//
//  Synopsis:   allocate prefic table entry
//
//  Arguments:  [pTable] -- the prefix table from which we need to allocate.
//
//  Returns:    returns a valid pointer if successfull otherwise NULL
//
//  History:    04-18-94  SethuR Created
//
//  Notes:
//
//----------------------------------------------------------------------------

PDFS_PREFIX_TABLE_ENTRY _AllocatePrefixTableEntry(PDFS_PREFIX_TABLE pTable)
{
    PDFS_PREFIX_TABLE_ENTRY pEntry = NULL;

#ifdef KERNEL_MODE
    NTSTATUS status;
    PVOID    pSegment = NULL;

    pSegment = ExAllocatePoolWithTag(PagedPool,PREFIX_TABLE_ENTRY_SEGMENT_SIZE, ' puM');
    if (pSegment != NULL)
    {
        status = ExExtendZone(&pTable->PrefixTableEntryZone,
                              pSegment,
                              PREFIX_TABLE_ENTRY_SEGMENT_SIZE);

        if (NT_SUCCESS(status))
        {
            pEntry = ALLOCATE_DFS_PREFIX_TABLE_ENTRY(pTable);
        }
        else
        {
            DfsDbgTrace(0, Dbg, "ExExtendZone returned %lx\n", ULongToPtr(status) );
        }
    }
#endif

    return  pEntry;
}

//+---------------------------------------------------------------------------
//
//  Function:   _LookupPrefixTable
//
//  Synopsis:   private fn. for looking up a name segment in a prefix table
//
//  Arguments:  [pTable] -- the DFS prefix table instance
//
//              [pPath]  -- the path to be looked up.
//
//              [pSuffix] -- the suffix that could not be found.
//
//              [ppEntry] -- placeholder for the matching entry for the prefix.
//
//
//  Returns:    one of the following NTSTATUS codes
//                  STATUS_SUCCESS -- call was successfull.
//                  STATUS_OBJECT_PATH_NOT_FOUND -- no entry for the path
//
//  History:    04-18-94  SethuR Created
//
//  Notes:
//
//----------------------------------------------------------------------------

NTSTATUS _LookupPrefixTable(PDFS_PREFIX_TABLE        pTable,
                            UNICODE_STRING           *pPath,
                            UNICODE_STRING           *pSuffix,
                            PDFS_PREFIX_TABLE_ENTRY  *ppEntry)
{
    NTSTATUS                status = STATUS_SUCCESS;
    UNICODE_STRING          Path = *pPath;
    WCHAR                   Buffer[MAX_PATH_SEGMENT_SIZE];
    PWCHAR                  NameBuffer = Buffer;
    USHORT                  cbNameBuffer = sizeof(Buffer);
    UNICODE_STRING          Name;
    ULONG                   BucketNo;
    BOOLEAN                 fPrefixFound = FALSE;
    PDFS_PREFIX_TABLE_ENTRY pEntry = NULL;
    PDFS_PREFIX_TABLE_ENTRY pParentEntry = &pTable->RootEntry;
    BOOLEAN                 fNameFound = FALSE;

    DfsDbgTrace(0, Dbg, "_LookupPrefixTable -- Entry\n", 0);


    // The \ is treated as a special case. The test for all names starting with
    // a delimiter is done before we initiate the complete search process.

    if (Path.Buffer[0] == PATH_DELIMITER)
    {
        Path.Length = Path.Length - sizeof(WCHAR);
        Path.Buffer += 1; // Skip the path delimiter at the beginning.

        if (pTable->RootEntry.pData != NULL)
        {
            fPrefixFound = TRUE;
            *pSuffix     = Path;
            *ppEntry     = &pTable->RootEntry;
        }
    }

    if (Path.Length > MAX_PATH_SEGMENT_SIZE) {
        NameBuffer = ExAllocatePoolWithTag( NonPagedPool, Path.Length + sizeof(WCHAR), ' puM' );
        if (NameBuffer == NULL) {
            DfsDbgTrace(0, Dbg, "Unable to allocate %d non-paged bytes\n", (Path.Length + sizeof(WCHAR)) );
            return( STATUS_INSUFFICIENT_RESOURCES );
        } else {
            cbNameBuffer = Path.Length + sizeof(WCHAR);
        }
    }

    while (Path.Length > 0)
    {
        Name.Length = 0;
        Name.Buffer = NameBuffer;
        Name.MaximumLength = cbNameBuffer;

        if (pTable->CaseSensitive)
        {
            SPLIT_CASE_SENSITIVE_PATH(&Path,&Name,BucketNo);
        }
        else
        {
            SPLIT_CASE_INSENSITIVE_PATH(&Path,&Name,BucketNo);
        }

        if (Name.Length > 0)
        {
            // Process the name segment
            // Lookup the bucket to see if the entry exists.
            DfsDbgTrace(0, Dbg, "LOOKUP_BUCKET: Bucket(%ld)", ULongToPtr(BucketNo) );
            DfsDbgTrace(0, Dbg, "for Name(%wZ)\n", &Name);

            LOOKUP_BUCKET(pTable->Buckets[BucketNo],Name,pParentEntry,pEntry,fNameFound);

            DfsDbgTrace(0, Dbg, "Returned pEntry(%lx)", pEntry);
            DfsDbgTrace(0, Dbg, " and fNameFound(%s)\n",fNameFound ? "TRUE" : "FALSE" );

            if (pEntry != NULL)
            {
                // Cache the data available for this prefix if any.
                if (pEntry->pData != NULL)
                {
                    *pSuffix      = Path;
                    *ppEntry      = pEntry;
                    fPrefixFound  = TRUE;
                }
            }
            else
            {
                break;
            }

            // set the stage for processing the next name segment.
            pParentEntry = pEntry;
        }
    }

    if (!fPrefixFound)
    {
        status = STATUS_OBJECT_PATH_NOT_FOUND;
        DfsDbgTrace(0, Dbg, "_LookupPrefixTable Error -- %lx\n", ULongToPtr(status) );
    }

    if (NameBuffer != Buffer) {
        ExFreePool( NameBuffer );
    }

    DfsDbgTrace(-1, Dbg, "_LookupPrefixTable -- Exit\n", 0);
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mup\prefixp.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       prefix.hxx
//
//  Contents:   PREFIX table definition
//
//  History:    SethuR -- Implemented
//
//  Notes:      The DFS prefix table data structure consists of three
//              entities and methods to manipulate them. They are the
//              DFS_PREFIX_TABLE_ENTRY,DFS_PREFIX_TABLE_BUCKET and the
//              DFS_PREFIX_TABLE.
//
//              The DFS_PREFIX_TABLE is a hash table of DFS_PREFIX_TABLE_ENTRY's
//              wherein collisions are resolved through linear chaining. The
//              hash table is organized as an array of collision lists
//              (DFS_PREFIX_TABLE_BUCKET). A brief description with each of
//              these entities is attached to the declaration.
//
//              There are certain characterstics that distinguish this
//              hash table from other hash tables. These are the extensions
//              provided to accomodate the special operations.
//
//--------------------------------------------------------------------------

#ifndef __PREFIXP_H__
#define __PREFIXP_H__

#include <prefix.h>


//--------------------------------------------------------------------------
//
// PREFIX TABLE UTILITIES
//
// A Path is a sequence of one or more name segments alternated with a
// distinguished concatenation character ( typically \ in FAT,NTFS,HPFS and
// / in UNIX file systems). These utilities are used to split a given path
// into the first path segment followed by the remainder of the path.
//
// SPLIT_PATH("foo\bar\bar1",Name,RemainingPath) binds Name to foo and
// RemainingPath to bar\bar1
//
// Similarly PROCESS_CASE_SENSITIVE_NAME and PROCESS_CASE_INSENSITIVE_NAME
// compute the hash signatures ( bucket no. ) for a given string.
//
//--------------------------------------------------------------------------


//
// MAX_PATH_SEGMENT_SIZE is simply used as a good size buffer to do prefix
// lookups and insertions. This should save us from having to allocate for
// most cases.
//

#define MAX_PATH_SEGMENT_SIZE  256
#define PATH_DELIMITER L'\\'

//+---------------------------------------------------------------------------
//
//  Function:   SPLIT_CASE_INSENSITIVE_PATH
//
//  Synopsis:   Split the path name around deleimiters.
//
//  Arguments:  [pPath] -- path to be split(PUNICODE_STRING)
//
//              [pName] -- the leftmost component of the path(PUNICODE_STRING)
//
//              [BucketNo] -- Hash Bucket no. corresponding to the name(ULONG)
//
//  SideEffects: the UNICODE_STRING pointed to by pName and BucketNo are
//               modified.
//
//  PreRequisite: pName be associated with a valid buffer.
//
//  History:    04-18-94  SethuR Created
//
//  Notes:      defined as a macro for inlining
//
//----------------------------------------------------------------------------

#define SPLIT_CASE_INSENSITIVE_PATH(pPath,pName,BucketNo)                    \
{                                                                            \
    WCHAR *pPathBuffer   = (pPath)->Buffer;                                  \
    WCHAR *pNameBuffer   = (pName)->Buffer;                                  \
    WCHAR *pPathBufferEnd = &pPathBuffer[(pPath)->Length / sizeof(WCHAR)];   \
                                                                             \
    BucketNo = 0;                                                            \
    while ((pPathBufferEnd != pPathBuffer) &&                                \
           ((*pNameBuffer = *pPathBuffer++) != PATH_DELIMITER))              \
    {                                                                        \
        *pNameBuffer = (*pNameBuffer < L'a')                                 \
                       ? *pNameBuffer                                        \
                       : ((*pNameBuffer < L'z')                              \
                          ? (*pNameBuffer - L'a' + L'A')                     \
                          : RtlUpcaseUnicodeChar(*pNameBuffer));             \
        BucketNo *= 131;                                                     \
        BucketNo += *pNameBuffer;                                            \
        pNameBuffer++;                                                       \
    }                                                                        \
                                                                             \
    BucketNo = BucketNo % NO_OF_HASH_BUCKETS;                                \
    *pNameBuffer = L'\0';                                                    \
    (pName)->Length = (USHORT)((CHAR *)pNameBuffer - (CHAR *)(pName)->Buffer); \
                                                                             \
    (pPath)->Length = (USHORT)((CHAR *)pPathBufferEnd - (CHAR *)pPathBuffer); \
    (pPath)->Buffer = pPathBuffer;                                           \
    DfsDbgTrace(0, Dbg, "SPLIT_PATH:Path (%wZ)",pPath);                      \
    DfsDbgTrace(0, Dbg, " Name (%wZ)\n",pName);                              \
}                                                                            \

//+---------------------------------------------------------------------------
//
//  Function:   SPLIT_CASE_SENSITIVE_PATH
//
//  Synopsis:   Split the patah name around deleimiters.
//
//  Arguments:  [pPath] -- path to be split(PUNICODE_STRING)
//
//              [pName] -- the leftmost component of the path(PUNICODE_STRING)
//
//              [BucketNo] -- Hash Bucket no. corresponding to the name(ULONG)
//
//  SideEffects: the UNICODE_STRING pointed to by pName and BucketNo are modified.
//
//  PreRequisite: pName be associated with a valid buffer.
//
//  History:    04-18-94  SethuR Created
//
//  Notes:      defined as a macro for inlining
//
//----------------------------------------------------------------------------

#define SPLIT_CASE_SENSITIVE_PATH(pPath,pName,BucketNo)                      \
{                                                                            \
    WCHAR *pPathBuffer   = (pPath)->Buffer;                                  \
    WCHAR *pNameBuffer   = (pName)->Buffer;                                  \
    WCHAR *pPathBufferEnd = &pPathBuffer[(pPath)->Length / sizeof(WCHAR)];   \
                                                                             \
    BucketNo = 0;                                                            \
    while ((pPathBufferEnd != pPathBuffer) &&                                \
           ((*pNameBuffer = *pPathBuffer++) != PATH_DELIMITER))              \
    {                                                                        \
        BucketNo *= 131;                                                     \
        BucketNo += *pNameBuffer;                                            \
        pNameBuffer++;                                                       \
    }                                                                        \
                                                                             \
    BucketNo = BucketNo % NO_OF_HASH_BUCKETS;                                \
    *pNameBuffer = L'\0';                                                    \
    (pName)->Length = (USHORT)((CHAR *)pNameBuffer - (CHAR *)(pName)->Buffer); \
                                                                             \
    (pPath)->Length = (USHORT)((CHAR *)pPathBufferEnd - (CHAR *)pPathBuffer); \
    (pPath)->Buffer = pPathBuffer;                                           \
    DfsDbgTrace(0, Dbg, "SPLIT_PATH:Path (%wZ)",pPath);                      \
    DfsDbgTrace(0, Dbg, " Name (%wZ)\n",pName);                              \
}                                                                            \


//+---------------------------------------------------------------------------
//
//  Function:   INITIALIZE_BUCKET
//
//  Synopsis:   Initializes a hash bucket.
//
//  Arguments:  [Bucket] -- the bucket to be initialized(DFS_PREFIX_TABLE_BUCKET)
//
//  SideEffects: the bucket is intialized ( the collision list and count are
//               initialized
//
//  History:    04-18-94  SethuR Created
//
//  Notes:      defined as a macro for inlining
//
//----------------------------------------------------------------------------

#define INITIALIZE_BUCKET(Bucket)                                           \
{                                                                           \
   (Bucket).SentinelEntry.pNextEntry = &(Bucket).SentinelEntry;             \
   (Bucket).SentinelEntry.pPrevEntry = &(Bucket).SentinelEntry;             \
   (Bucket).NoOfEntries = 0;                                                \
}                                                                           \

//+---------------------------------------------------------------------------
//
//  Function:   LOOKUP_BUCKET
//
//  Synopsis:   lookups the bucket for an entry.
//
//  Arguments:  [Bucket] -- the bucket to be used (DFS_PREFIX_TABLE_BUCKET)
//
//              [Name]   -- the name to be looked up (UNICODE_STRING)
//
//              [pParentEntry] -- the parent entry of the entry we are
//                                searching for.
//
//              [pEntry] -- placeholder for the desired entry.
//
//              [fNameFound] -- indicates if the name was found.
//
//  SideEffects: Name,fNameFound and pEntry are modified
//
//  History:    04-18-94  SethuR Created
//
//  Notes:      defined as a macro for inlining
//
//              We only store one copy of a string irrespective of the no. of
//              places it appears in, e.g. foo\bar and foo1\bar will result
//              in only one copy of bar being stored. This implies that the
//              lookup routine will have to return sufficient info. to prevent
//              the allocation of memory space for a string. If on exit
//              fNameFound is set to TRUE then this indicates that a similar
//              string was located in the table and the Name.Buffer field is
//              modified to point to the first instance of the string in
//              the table.
//
//----------------------------------------------------------------------------

#define LOOKUP_BUCKET(Bucket,Name,pParentEntry,pEntry,fNameFound)           \
{                                                                           \
    PDFS_PREFIX_TABLE_ENTRY pCurEntry = Bucket.SentinelEntry.pNextEntry;    \
                                                                            \
    DfsDbgTrace(0, Dbg, "LOOKUP_BUCKET: Looking for (%wZ)\n", &Name);        \
    fNameFound = FALSE;                                                     \
    pEntry = NULL;                                                          \
                                                                            \
    while (pCurEntry != &Bucket.SentinelEntry)                              \
    {                                                                       \
        if (pCurEntry->PathSegment.Length == Name.Length)                   \
        {                                                                   \
            DfsDbgTrace(0, Dbg, "LOOKUP_BUCKET: Looking at Entry with Name (%wZ)\n",&pCurEntry->PathSegment); \
            if (fNameFound &&                                               \
               (pCurEntry->PathSegment.Buffer == Name.Buffer))              \
            {                                                               \
                if (pCurEntry->pParentEntry == pParentEntry)                \
                {                                                           \
                    pEntry = pCurEntry;                                     \
                    break;                                                  \
                }                                                           \
            }                                                               \
            else if (!memcmp(pCurEntry->PathSegment.Buffer,                 \
                             Name.Buffer,                                   \
                             Name.Length))                                  \
            {                                                               \
                fNameFound = TRUE;                                          \
                Name.Buffer = pCurEntry->PathSegment.Buffer;                \
                if (pCurEntry->pParentEntry == pParentEntry)                \
                {                                                           \
                    pEntry = pCurEntry;                                     \
                    break;                                                  \
                }                                                           \
            }                                                               \
        }                                                                   \
                                                                            \
        pCurEntry = pCurEntry->pNextEntry;                                  \
    }                                                                       \
}                                                                           \

//+---------------------------------------------------------------------------
//
//  Function:   INSERT_IN_BUCKET
//
//  Synopsis:   inserts the entry in the bucket
//
//  Arguments:  [Bucket] -- the bucket to be initialized(DFS_PREFIX_TABLE_BUCKET)
//
//              [pEntry] -- the entry to be inserted
//
//  SideEffects: Bucket is modified to include the entry
//
//  History:    04-18-94  SethuR Created
//
//  Notes:      defined as a macro for inlining
//
//----------------------------------------------------------------------------

#define INSERT_IN_BUCKET(Bucket,pEntry)                                     \
{                                                                           \
    (Bucket).NoOfEntries++;                                                 \
    (pEntry)->pPrevEntry = (Bucket).SentinelEntry.pPrevEntry;               \
    (pEntry)->pNextEntry = &((Bucket).SentinelEntry);                       \
    ((Bucket).SentinelEntry.pPrevEntry)->pNextEntry = (pEntry);             \
    (Bucket).SentinelEntry.pPrevEntry = (pEntry);                           \
}                                                                           \

//+---------------------------------------------------------------------------
//
//  Function:   REMOVE_FROM_BUCKET
//
//  Synopsis:   removes the entry from the bucket
//
//  Arguments:  [pEntry] -- the entry to be inserted
//
//  SideEffects: Bucket is modified to exclude the entry
//
//  History:    04-18-94  SethuR Created
//
//  Notes:      defined as a macro for inlining
//
//----------------------------------------------------------------------------

#define REMOVE_FROM_BUCKET(pEntry)                                          \
{                                                                           \
    PDFS_PREFIX_TABLE_ENTRY pPrevEntry = (pEntry)->pPrevEntry;              \
    PDFS_PREFIX_TABLE_ENTRY pNextEntry = (pEntry)->pNextEntry;              \
                                                                            \
    pPrevEntry->pNextEntry = pNextEntry;                                    \
    pNextEntry->pPrevEntry = pPrevEntry;                                    \
}                                                                           \

//+---------------------------------------------------------------------------
//
//  Function:   INSERT_IN_CHILD_LIST
//
//  Synopsis:   Inserts this entry in the parent's list of children
//
//  Arguments:  [pEntry] -- the entry to be inserted
//
//              [pParentEntry] -- the entry into whose list of children
//                      pEntry has to be inserted.
//
//  SideEffects: Parent's list of children is modified.
//
//  History:    01-09-96  MilanS Created
//
//  Notes:      defined as a macro for inlining
//
//----------------------------------------------------------------------------

#define INSERT_IN_CHILD_LIST(pEntry, pParentEntry)                           \
{                                                                            \
    PDFS_PREFIX_TABLE_ENTRY pLastChild;                                      \
                                                                             \
    if (pParentEntry->pFirstChildEntry == NULL) {                            \
        pParentEntry->pFirstChildEntry = pEntry;                             \
    } else {                                                                 \
        for (pLastChild = pParentEntry->pFirstChildEntry;                    \
                pLastChild->pSiblingEntry != NULL;                           \
                    pLastChild = pLastChild->pSiblingEntry) {                \
             NOTHING;                                                        \
        }                                                                    \
        pLastChild->pSiblingEntry = pEntry;                                  \
    }                                                                        \
}

//+----------------------------------------------------------------------------
//
//  Function:   REMOVE_FROM_CHILD_LIST
//
//  Synopsis:   Removes an entry from its parent's list of children
//
//  Arguments:  [pEntry] -- the Entry to remove from children list.
//
//  SideEffects: The children list of pParentEntry is modified.
//
//  History:    01-09-96  MilanS Created
//
//  Notes:      Defined as a macro for inlining.
//
//              This routine will ASSERT if pEntry is not in the parent's
//              list of children.
//
//-----------------------------------------------------------------------------

#define REMOVE_FROM_CHILD_LIST(pEntry)                                       \
{                                                                            \
    PDFS_PREFIX_TABLE_ENTRY pParentEntry = pEntry->pParentEntry;             \
    PDFS_PREFIX_TABLE_ENTRY pPrevSibling;                                    \
                                                                             \
    if (pParentEntry->pFirstChildEntry == pEntry) {                          \
        pParentEntry->pFirstChildEntry = pEntry->pSiblingEntry;              \
    } else {                                                                 \
        for (pPrevSibling = pParentEntry->pFirstChildEntry;                  \
                pPrevSibling->pSiblingEntry != pEntry;                       \
                    pPrevSibling = pPrevSibling->pSiblingEntry) {            \
             ASSERT(pPrevSibling->pSiblingEntry != NULL);                    \
        }                                                                    \
        pPrevSibling->pSiblingEntry = pEntry->pSiblingEntry;                 \
    }                                                                        \
}

//+---------------------------------------------------------------------------
//
//  Function:   INITIALIZE_NAME_PAGE
//
//  Synopsis:   initializes the name page
//
//  Arguments:  [pNamePage] -- the NAME_PAGE to be initialized
//
//  SideEffects: the name page is initialized
//
//  History:    04-18-94  SethuR Created
//
//  Notes:      defined as a macro for inlining
//
//----------------------------------------------------------------------------

#define INITIALIZE_NAME_PAGE(pNamePage)                                      \
{                                                                            \
    pNamePage->pNextPage = NULL;                                             \
    pNamePage->cFreeSpace = FREESPACE_IN_NAME_PAGE - 1;                      \
    pNamePage->Names[FREESPACE_IN_NAME_PAGE - 1] = L'\0';                    \
}                                                                            \

//+---------------------------------------------------------------------------
//
//  Function:   INITIALIZE_PREFIX_TABLE_ENTRY
//
//  Synopsis:   initializes the prefix table entry
//
//  Arguments:  [pEntry] -- the entry to be initialized
//
//  SideEffects: the prefix table entry is modified
//
//  History:    04-18-94  SethuR Created
//
//  Notes:      defined as a macro for inlining
//
//----------------------------------------------------------------------------

#define INITIALIZE_PREFIX_TABLE_ENTRY(pEntry)                                \
{                                                                            \
    RtlZeroMemory( pEntry, sizeof( DFS_PREFIX_TABLE_ENTRY ) );               \
    (pEntry)->NoOfChildren = 1;                                              \
}                                                                            \

//+---------------------------------------------------------------------------
//
//  Function:   private fns. extern declarations
//
//----------------------------------------------------------------------------

extern
NTSTATUS _LookupPrefixTable(PDFS_PREFIX_TABLE        pTable,
                            UNICODE_STRING           *pPath,
                            UNICODE_STRING           *pSuffix,
                            PDFS_PREFIX_TABLE_ENTRY  *ppEntry);

//+---------------------------------------------------------------------------
//
//  Function:   ALLOCATION ROUTINES
//
//  Synopsis:   all the allocation routines are defined to be used in the KERNEL as
//              well as user mode. The KERNEL mode is turned on by defining KERNEL
//
//  History:    04-18-94  SethuR Created
//
//  Notes:      defined as a macro for inlining
//
//----------------------------------------------------------------------------

#define PREFIX_TABLE_ENTRY_SEGMENT_SIZE PAGE_SIZE

extern
NTSTATUS
_InitializePrefixTableEntryAllocation(PDFS_PREFIX_TABLE pTable);

extern
PWSTR _AllocateNamePageEntry(PNAME_PAGE_LIST pPageList,ULONG cLength);

extern
PDFS_PREFIX_TABLE_ENTRY _AllocatePrefixTableEntry(PDFS_PREFIX_TABLE pTable);

#ifdef KERNEL_MODE

#define ALLOCATE_NAME_PAGE() (PNAME_PAGE)ExAllocatePoolWithTag(PagedPool,sizeof(NAME_PAGE), ' puM')

#define FREE_NAME_PAGE(pPage) ExFreePool(pPage)

#define ALLOCATE_NAME_PAGE_ENTRY(PageList,cLength)                           \
    ExAllocatePoolWithTag(PagedPool, cLength * sizeof(WCHAR), ' puM');       \

#define FREE_NAME_PAGE_ENTRY(PageList,pName)

#define ALLOCATE_DFS_PREFIX_TABLE_ENTRY(pTable)                             \
 (PDFS_PREFIX_TABLE_ENTRY) ExAllocatePoolWithTag(PagedPool,sizeof(DFS_PREFIX_TABLE_ENTRY), ' puM')

#define FREE_DFS_PREFIX_TABLE_ENTRY(pTable,pEntry)                           \
    if ((pEntry)->PathSegment.Buffer != NULL) {                              \
        ExFreePool((pEntry)->PathSegment.Buffer);                            \
    }                                                                        \
    ExFreePool((pEntry));

#define COMPARE_MEMORY(s,d,l)   (!RtlEqualMemory(s,d,l))

#else

#define ALLOCATE_NAME_PAGE() (PNAME_PAGE)malloc(sizeof(NAME_PAGE))

#define FREE_NAME_PAGE(pPage) free(pPage)

#define ALLOCATE_NAME_PAGE_ENTRY(PageList,cLength) malloc(cLength * sizeof(WCHAR))

#define FREE_NAME_PAGE_ENTRY(PageList,pName)

#define ALLOCATE_DFS_PREFIX_TABLE_ENTRY(pTable)                              \
    (PDFS_PREFIX_TABLE_ENTRY)malloc(sizeof(DFS_PREFIX_TABLE_ENTRY))

#define FREE_DFS_PREFIX_TABLE_ENTRY(pTable,pEntry) free((pEntry))

#define COMPARE_MEMORY(s,d,l)   memcmp(s,d,l)

#endif

#endif // __PREFIXP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mup\regsup.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    regsup.c

Abstract:

    This module contains routine that interact with registry.

Author:

    Manny Weiser (mannyw)    30-Mar-92

Revision History:

--*/

#include "mup.h"
//#include "stdlib.h"
//#include "zwapi.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_FSCONTROL)

//
//  local procedure prototypes
//

#if DBG
VOID
MupGetDebugFlags(void);
#endif

VOID
DfsGetEventLogValue(VOID);

VOID
DfsGetEventLogValue(VOID);

VOID
InitializeProvider(
    PWCH ProviderName,
    ULONG Priority
    );

VOID
AddUnregisteredProvider(
    PWCH providerName,
    ULONG priority
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, AddUnregisteredProvider )
#pragma alloc_text( PAGE, InitializeProvider )
#pragma alloc_text( PAGE, MupCheckForUnregisteredProvider )
#pragma alloc_text( PAGE, MupGetProviderInformation )
#pragma alloc_text( PAGE, DfsGetEventLogValue )
#if DBG
#pragma alloc_text( PAGE, MupGetDebugFlags )
#endif
#endif


VOID
MupGetProviderInformation (
    VOID
    )

/*++

Routine Description:

    This routine reads MUP information from the registry and saves it for
    future use.

Arguments:

    None.

Return Value:

    None.

--*/

{
    HANDLE handle;
    NTSTATUS status;
    UNICODE_STRING valueName;
    UNICODE_STRING keyName;
    OBJECT_ATTRIBUTES objectAttributes;
    PVOID buffer = NULL;
    PWCH providerName;
    ULONG lengthRequired;
    BOOLEAN done;
    ULONG priority;
    PWCH sep;

    PAGED_CODE();
    RtlInitUnicodeString( &keyName, L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Networkprovider\\Order" );
    InitializeObjectAttributes(
        &objectAttributes,
        &keyName,
        OBJ_CASE_INSENSITIVE,
        0,
        NULL
        );

    status = ZwOpenKey(
                 &handle,
                 KEY_QUERY_VALUE,
                 &objectAttributes
                 );

    if ( !NT_SUCCESS( status )) {
        return;
    }

    RtlInitUnicodeString( &valueName, L"ProviderOrder" );

    status = ZwQueryValueKey(
                 handle,
                 &valueName,
                 KeyValueFullInformation,
                 buffer,
                 0,
                 &lengthRequired
                 );

    if ( status == STATUS_BUFFER_TOO_SMALL ) {
        buffer = ExAllocatePoolWithTag( PagedPool, lengthRequired + 2, ' puM');
        if ( buffer == NULL) {
            ZwClose( handle );
            return;
        }

        status = ZwQueryValueKey(
                     handle,
                     &valueName,
                     KeyValueFullInformation,
                     buffer,
                     lengthRequired,
                     &lengthRequired
                     );
    }

    ZwClose( handle );

    if ( !NT_SUCCESS( status)  ) {
        if ( buffer != NULL ) {
            ExFreePool( buffer );
        }
        return;
    }

    //
    // Scan the ordered list of providers, and create record for each.
    //

    providerName = (PWCH)((PCHAR)buffer + ((PKEY_VALUE_FULL_INFORMATION)buffer)->DataOffset);

    done = FALSE;
    priority = 0;
    while ( !done ) {
        sep = wcschr( providerName, L',');
        if ( sep == NULL ) {
            done = TRUE;
        } else {
            *sep = L'\0';
        }

        InitializeProvider( providerName, priority );
        priority++;
        providerName = sep+1;
    }

    ExFreePool( buffer );
    return;
}

VOID
InitializeProvider(
    PWCH ProviderName,
    ULONG Priority
    )

/*++

Routine Description:

    This routine reads provider information out of the registry and
    creates an unregistered provider entry.

Arguments:

    ProviderName - The registry name for the provider.

    Priority - The priority to assign to this provider.

Return Value:

    None.

--*/

{
    UNICODE_STRING keyName;
    PVOID buffer = NULL;
    ULONG bufferLength;
    NTSTATUS status;
    OBJECT_ATTRIBUTES objectAttributes;
    ULONG lengthRequired;
    UNICODE_STRING valueName;
    HANDLE handle;

    PAGED_CODE();
    //
    // Allocate space for the registry string
    //

    bufferLength = sizeof( L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\" ) +
                   wcslen( ProviderName ) * sizeof( WCHAR ) +
                   sizeof( L"\\NetworkProvider" );

    buffer = ExAllocatePoolWithTag( PagedPool, bufferLength, ' puM' );
    if ( buffer == NULL ) {
        return;
    }

    //
    // Build the registry string
    //

    RtlMoveMemory(
        buffer,
        L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\",
        sizeof( L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\" )
        );

    keyName.Buffer = buffer;
    keyName.MaximumLength = (USHORT)bufferLength;
    keyName.Length = sizeof( L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\" ) - 2;

    status = RtlAppendUnicodeToString( &keyName, ProviderName );
    ASSERT( NT_SUCCESS( status ) );
    status = RtlAppendUnicodeToString( &keyName, L"\\NetworkProvider" );
    ASSERT( NT_SUCCESS( status ) );

    InitializeObjectAttributes(
        &objectAttributes,
        &keyName,
        OBJ_CASE_INSENSITIVE,
        0,
        NULL
        );

    status = ZwOpenKey(
                 &handle,
                 KEY_QUERY_VALUE,
                 &objectAttributes
                 );

    ExFreePool( buffer );
    if ( !NT_SUCCESS( status )) {
        return;
    }

    buffer = NULL;
    RtlInitUnicodeString( &valueName, L"DeviceName" );

    status = ZwQueryValueKey(
                 handle,
                 &valueName,
                 KeyValueFullInformation,
                 buffer,
                 0,
                 &lengthRequired
                 );

    if ( status == STATUS_BUFFER_TOO_SMALL ) {
        buffer = ExAllocatePoolWithTag( PagedPool, lengthRequired + 2, ' puM' );
        if ( buffer == NULL) {
            return;
        }

        status = ZwQueryValueKey(
                     handle,
                     &valueName,
                     KeyValueFullInformation,
                     buffer,
                     lengthRequired,
                     &lengthRequired
                     );
    }

    if ( !NT_SUCCESS( status) ) {
        if ( buffer != NULL ) {
            ExFreePool( buffer );
        }
        ZwClose( handle );
        return;
    }

    //
    // Wahoo!  We actually have the device name in hand.  Add the
    // provider to the unregistered list.
    //

    AddUnregisteredProvider(
        (PWCH)((PCHAR)buffer + ((PKEY_VALUE_FULL_INFORMATION)buffer)->DataOffset),
        Priority
        );

    ExFreePool( buffer );
    ZwClose( handle );
    return;
}

PUNC_PROVIDER
MupCheckForUnregisteredProvider(
    PUNICODE_STRING DeviceName
    )

/*++

Routine Description:

    This routine checks the list of unregistered providers for one whose
    device name matches the provider attempting to register.

    If one is found it is dequeued from the list of unregistered providers.

Arguments:

    DeviceName - The device name of the registering provider.

Return Value:

    UNC_PROVIDER - A pointer to the matching unregistered provider, or
        NULL if no match is found.

--*/

{
    PLIST_ENTRY listEntry;
    PUNC_PROVIDER uncProvider;

    PAGED_CODE();
    MupAcquireGlobalLock();

    for (listEntry = MupProviderList.Flink;
         listEntry !=  &MupProviderList;
         listEntry = listEntry->Flink ) {

        uncProvider = CONTAINING_RECORD( listEntry, UNC_PROVIDER, ListEntry );

	if(uncProvider->Registered == FALSE) {
        
	    //
	    // If we find a match take it out of the list, and
	    // return it to the caller.
	    //

	    if ( RtlEqualUnicodeString( DeviceName, &uncProvider->DeviceName, TRUE )) {
	      
		uncProvider->BlockHeader.BlockState = BlockStateActive;
		MupReleaseGlobalLock();
		return uncProvider;

	    }
	}
    }

    MupReleaseGlobalLock();
    return NULL;
}

VOID
AddUnregisteredProvider(
    PWCH ProviderName,
    ULONG Priority
    )
/*++

Routine Description:

    This routine queues an unregistered provider on a list.

Arguments:

    ProviderName - The device name of the provider. (from the registry)

    Priority - A priority for the provider.

Return Value:

    None.

--*/
{
    ULONG nameLength;
    PUNC_PROVIDER uncProvider;

    PAGED_CODE();
    nameLength = wcslen( ProviderName ) * 2;

    try {

        uncProvider = MupAllocateUncProvider( nameLength );

        if (uncProvider != NULL) {

            uncProvider->DeviceName.MaximumLength = (USHORT)nameLength;
            uncProvider->DeviceName.Length = (USHORT)nameLength;
            uncProvider->DeviceName.Buffer = (PWCH)(uncProvider + 1);
            uncProvider->Priority = Priority; 

            RtlMoveMemory(
                (PVOID)(uncProvider + 1),
                ProviderName,
                nameLength
                );

            MupAcquireGlobalLock();
            InsertTailList( &MupProviderList, &uncProvider->ListEntry );
            MupReleaseGlobalLock();

        }
    } except ( EXCEPTION_EXECUTE_HANDLER ) {
        NOTHING;
    }

}

VOID
DfsGetEventLogValue(VOID)

/*++

Routine Description:

    This routine checks registry keys to set the event logging level

Arguments:

    None

Return Value:

    None
    

--*/

{
    NTSTATUS status;
    HANDLE DfsRegHandle;
    OBJECT_ATTRIBUTES ObjAttr;
    ULONG ValueSize;

    UNICODE_STRING DfsRegKey;
    UNICODE_STRING DfsValueName;

    struct {
        KEY_VALUE_PARTIAL_INFORMATION Info;
        ULONG Buffer;
    } DfsValue;

    PAGED_CODE();

    RtlInitUnicodeString(
        &DfsRegKey,
        L"\\Registry\\Machine\\SOFTWARE\\MicroSoft\\Windows NT\\CurrentVersion\\Diagnostics");

    InitializeObjectAttributes(
        &ObjAttr,
        &DfsRegKey,
        OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
        0,
        NULL);

    status = ZwOpenKey(
                &DfsRegHandle,
                KEY_QUERY_VALUE,
                &ObjAttr);

    if (!NT_SUCCESS(status))
        return;

    RtlInitUnicodeString(&DfsValueName, L"RunDiagnosticLoggingGlobal");

    status = ZwQueryValueKey(
                DfsRegHandle,
                &DfsValueName,
                KeyValuePartialInformation,
                (PVOID) &DfsValue,
                sizeof(DfsValue),
                &ValueSize);

    if (NT_SUCCESS(status) && DfsValue.Info.Type == REG_DWORD) {

        DfsEventLog = *((PULONG) DfsValue.Info.Data);
        goto Cleanup;

    }

    RtlInitUnicodeString(&DfsValueName, L"RunDiagnosticLoggingDfs");

    status = ZwQueryValueKey(
                DfsRegHandle,
                &DfsValueName,
                KeyValuePartialInformation,
                (PVOID) &DfsValue,
                sizeof(DfsValue),
                &ValueSize);

    if (NT_SUCCESS(status) && DfsValue.Info.Type == REG_DWORD)
        DfsEventLog = *((PULONG) DfsValue.Info.Data);

Cleanup:

    ZwClose( DfsRegHandle );

}

#if DBG

VOID
MupGetDebugFlags(
    VOID
    )

/*++

Routine Description:

    This routine reads MUP debug flag settings from the registry

Arguments:

    None.

Return Value:

    None.

--*/

{
    HANDLE handle;
    NTSTATUS status;
    UNICODE_STRING valueName;
    UNICODE_STRING keyName;
    OBJECT_ATTRIBUTES objectAttributes;
    PWCH providerName;
    ULONG lengthRequired;
    ULONG Flags = 0;

     union {
        KEY_VALUE_FULL_INFORMATION;
        UCHAR   buffer[ sizeof( KEY_VALUE_FULL_INFORMATION ) + 100 ];
    } keyValueInformation;

    PAGED_CODE();

    //
    // Get MupDebugTraceLevel
    //

    RtlInitUnicodeString(
        &keyName,
        L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Dfs");

    InitializeObjectAttributes(
        &objectAttributes,
        &keyName,
        OBJ_CASE_INSENSITIVE,
        0,
        NULL);

    status = ZwOpenKey(
                 &handle,
                 KEY_QUERY_VALUE,
                 &objectAttributes);

    if (!NT_SUCCESS(status))
        goto GetNext;

    RtlInitUnicodeString( &valueName, L"MupDebugTraceLevel" );

    status = ZwQueryValueKey(
                 handle,
                 &valueName,
                 KeyValueFullInformation,
                 &keyValueInformation,
                 sizeof(keyValueInformation),
                 &lengthRequired
                 );

    if (
        NT_SUCCESS(status) &&
        keyValueInformation.Type == REG_DWORD &&
        keyValueInformation.DataLength != 0
    ) {

        Flags = *(PULONG)(((PUCHAR)(&keyValueInformation)) + keyValueInformation.DataOffset);
        DfsDebugTraceLevel = Flags;

    }

    ZwClose( handle );

GetNext:

    //
    // Now get MupVerbose
    //

    RtlInitUnicodeString(
        &keyName,
        L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Dfs");

    InitializeObjectAttributes(
        &objectAttributes,
        &keyName,
        OBJ_CASE_INSENSITIVE,
        0,
        NULL);

    status = ZwOpenKey(
                 &handle,
                 KEY_QUERY_VALUE,
                 &objectAttributes);

    if (!NT_SUCCESS(status))
        return;

    RtlInitUnicodeString( &valueName, L"MupVerbose" );

    status = ZwQueryValueKey(
                 handle,
                 &valueName,
                 KeyValueFullInformation,
                 &keyValueInformation,
                 sizeof(keyValueInformation),
                 &lengthRequired
                 );

    if (
        NT_SUCCESS(status) &&
        keyValueInformation.Type == REG_DWORD &&
        keyValueInformation.DataLength != 0
    ) {

        Flags = *(PULONG)(((PUCHAR)(&keyValueInformation)) + keyValueInformation.DataOffset);
        MupVerbose = Flags;

    }

    ZwClose( handle );

    return;
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mup\kdext\kdextlib.h ===
/*++

Copyright (c) 1990 Microsoft Corporation

Module Name:

    kdextlib.h

Abstract:

    Kernel Debugger extension

Author:

    Balan Sethu Raman (SethuR) 11-May-1994

Revision History:

    11-Nov-1994 SethuR  Created
    21-Aug-1995 Milans  Copied for use in Mup Kernel Extensions

--*/

#ifndef _KDEXTLIB_H_
#define _KDEXTLIB_H_

#include <windef.h>

//
// The help strings printed out
//

extern LPSTR ExtensionNames[];

extern LPSTR Extensions[];

//
// The FIELD_DESCRIPTOR data structure is used to describe the field in a structure sufficiently
// for displaying information during debugging. The three pieces of information that are required
// are 1) the name of the field, 2) the offset in the corresponding structure and 3) a type descriptor.
// The type descriptor covers most primitive types.
//
// The task of generating these descriptors by augmenting the front end, but that will have to
// wait till we play around with these extensions and modify the data structures to meet most
// of the requirements.
//
// There are some types that can benefit from some auxillary information in the descriptors. A
// case in point is the "enum" defeinition. Merely printing out a numerical value for an enum
// type will invariably force the person using these extensions to refer to the corresponding
// include file. In order to avoid this we will accept an additional array for enum types that
// contains a textual description of the numerical value.
//
// There are certain conventions that have been adopted to ease the definition of the macros
// as well as facilitate the automation of the generation of these descriptors.
// These are as follows ....
//
// 1) All ENUM_VALUE_DESCRIPTOR definitions are named EnumValueDescrsOf_ENUMTYPENAME, where
// ENUMTYPENAME defines the corresponding enumerated type.
//

typedef struct _ENUM_VALUE_DESCRIPTOR {
    ULONG   EnumValue;
    LPSTR   EnumName;
} ENUM_VALUE_DESCRIPTOR;

typedef struct _BIT_MASK_DESCRIPTOR {
    ULONG   BitmaskValue;
    LPSTR   BitmaskName;
} BIT_MASK_DESCRIPTOR;

typedef enum _FIELD_TYPE_CLASS {
    FieldTypeByte,
    FieldTypeChar,
    FieldTypeBoolean,
    FieldTypeBool,
    FieldTypeULong,
    FieldTypeLong,
    FieldTypeUShort,
    FieldTypeShort,
    FieldTypeGuid,
    FieldTypePointer,
    FieldTypePWStr,
    FieldTypeUnicodeString,
    FieldTypeAnsiString,
    FieldTypeSymbol,
    FieldTypeEnum,
    FieldTypeByteBitMask,
    FieldTypeWordBitMask,
    FieldTypeDWordBitMask,
    FieldTypeFloat,
    FieldTypeDouble,
    FieldTypeStruct,
    FieldTypeLargeInteger,
    FieldTypeFileTime
} FIELD_TYPE_CLASS, *PFIELD_TYPE_CLASS;

typedef struct _FIELD_DESCRIPTOR_ {
    FIELD_TYPE_CLASS FieldType;   // The type of variable to be printed
    LPSTR            Name;        // The name of the field
    USHORT           Offset;      // The offset of the field in the structure
    union {
        VOID                   *pDescriptor;     // Generic Auxillary information - used by Field4 macro
        ENUM_VALUE_DESCRIPTOR  *pEnumValueDescriptor; // Auxillary information for enumerated types.
        BIT_MASK_DESCRIPTOR *pBitMaskDescriptor; // Auxillary information for bitmasks.
    } AuxillaryInfo;
} FIELD_DESCRIPTOR;

#define FIELD3(FieldType,StructureName, FieldName) \
        {FieldType, #FieldName , (USHORT) FIELD_OFFSET(StructureName,FieldName) ,NULL}

#define FIELD4(FieldType, StructureName, FieldName, AuxInfo) \
        {FieldType, #FieldName , FIELD_OFFSET(StructureName,FieldName) ,(VOID *) AuxInfo}

//
// The structs that are displayed by the debugger extensions are further
// described in another array. Each entry in the array contains the name of
// the structure and the associated Field descriptor list.
//

typedef struct _STRUCT_DESCRITOR_ {
    LPSTR             StructName;
    ULONG             StructSize;
    FIELD_DESCRIPTOR  *FieldDescriptors;
} STRUCT_DESCRIPTOR;

#define STRUCT(StructTypeName,FieldDescriptors) \
        { #StructTypeName,sizeof(StructTypeName),FieldDescriptors}

//
//  The array of structs handled by the debugger extension.
//

extern STRUCT_DESCRIPTOR Structs[];

#define    SETCALLBACKS() \
    lpOutputRoutine = lpExtensionApis->lpOutputRoutine; \
    lpGetExpressionRoutine = lpExtensionApis->lpGetExpressionRoutine; \
    lpGetSymbolRoutine = lpExtensionApis->lpGetSymbolRoutine; \
    lpReadMemoryRoutine = lpExtensionApis->lpReadVirtualMemRoutine;


VOID
PrintStructFields(
    ULONG_PTR dwAddress,
    VOID *ptr,
    FIELD_DESCRIPTOR *pFieldDescriptors
);

BOOL
PrintStringW(
    LPSTR msg,
    PUNICODE_STRING puStr,
    BOOL nl
);

BOOLEAN
GetData(
    ULONG_PTR dwAddress,
    PVOID ptr,
    ULONG size
);
BOOL
PrintGuid(
    GUID *pguid);
extern ULONG s_NoOfColumns;


#endif // _KDEXTLIB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mup\provider.c ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation
//
//  File:       provider.c
//
//  Contents:   Module to initialize DFS driver providers.
//
//  Classes:
//
//  Functions:  ProviderInit --
//              DfsGetProviderForDevice
//              DfsInsertProvider
//
//  History:    12 Sep 1992     Milans created.
//              05 Apr 1993     Milans moved into driver.
//
//-----------------------------------------------------------------------------

#include "dfsprocs.h"
#include "rpselect.h"
#include "provider.h"

#define MAX_ENTRY_PATH          80               // Max. length of entry path

#define Dbg                     DEBUG_TRACE_INIT
#define prov_debug_out(x, y)    DfsDbgTrace(0, Dbg, x, y)


#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, ProviderInit )
#pragma alloc_text( PAGE, DfsGetProviderForDevice )
#pragma alloc_text( PAGE, DfsInsertProvider )
#endif // ALLOC_PRAGMA


//+----------------------------------------------------------------------------
//
//  Function:  ProviderInit
//
//  Synopsis:  Initializes the provider list with
//              - Local File service provider
//              - Standard remote Cairo provider
//              - Downlevel LanMan provider.
//
//  Arguments: None
//
//  Returns:   STATUS_SUCCESS
//
//-----------------------------------------------------------------------------

NTSTATUS
ProviderInit(void)
{
    NTSTATUS Status;
    UNICODE_STRING ustrProviderName;

    //
    // Initialize the Dfs aware SMB provider
    //

    RtlInitUnicodeString(&ustrProviderName, DD_NFS_DEVICE_NAME_U);

    Status = DfsInsertProvider(
                 &ustrProviderName,
                 PROV_DFS_RDR,
                 PROV_ID_DFS_RDR);

    if (!NT_SUCCESS(Status))
        return(Status);

    RtlInitUnicodeString(&ustrProviderName, DD_MUP_DEVICE_NAME);

    Status = DfsInsertProvider(
                 &ustrProviderName,
                 PROV_STRIP_PREFIX,
                 PROV_ID_MUP_RDR);

    return( Status );

}

//+----------------------------------------------------------------------------
//
//  Function:   DfsGetProviderForDevice
//
//  Synopsis:   Retrieves a provider definition given a Device Name. If the
//              provider definition does not exist, a new one is created and
//              returned.
//
//              This routine is meant for use in handling a STATUS_REPARSE
//              returned by the MUP. Since only downlevel requests are sent
//              to the MUP, this routine will always return a provider def
//              that is marked as downlevel (ie, Capability has the
//              PROV_STRIP_PREFIX bit set).
//
//  Arguments:  [DeviceName] -- Name of Device to look for.
//
//              [Provider] -- On successful return, contains pointer to
//                      PROVIDER_DEF with given DeviceName.
//
//  Returns:    [STATUS_SUCCESS] -- Provider returned.
//
//              [STATUS_INSUFFICIENT_RESOURCES] -- Out of memory condition.
//
//              [STATUS_FS_DRIVER_REQUIRED] -- Don't have appropriate
//                      provider.
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsGetProviderForDevice(
    PUNICODE_STRING DeviceName,
    PPROVIDER_DEF *Provider)
{
    NTSTATUS status;
    int i;

    ExAcquireResourceExclusiveLite( &DfsData.Resource, TRUE );

    *Provider = NULL;

    for (i = 0; i < DfsData.cProvider && *Provider == NULL; i++) {

        if ((DfsData.pProvider[i].DeviceName.Length == DeviceName->Length) &&
                (DfsData.pProvider[i].fProvCapability & PROV_STRIP_PREFIX) != 0) {

            if (RtlEqualUnicodeString(
                    &DfsData.pProvider[i].DeviceName,
                        DeviceName, TRUE)) {

                *Provider = &DfsData.pProvider[i];

                status = STATUS_SUCCESS;

                break;

            }

        }

    }

    if (*Provider == NULL) {

        //
        // Attempt to create a new provider def
        //

        UNICODE_STRING ProviderName;

        ProviderName.Length = DeviceName->Length;
        ProviderName.MaximumLength = ProviderName.Length + sizeof(WCHAR);

        ProviderName.Buffer = (PWCHAR) ExAllocatePoolWithTag(
                                PagedPool,
                                ProviderName.MaximumLength,
                                ' puM');

        if (ProviderName.Buffer != NULL) {

            RtlZeroMemory(
                ProviderName.Buffer,
                ProviderName.MaximumLength);

            RtlMoveMemory(
                ProviderName.Buffer,
                DeviceName->Buffer,
                ProviderName.Length);

            status = DfsInsertProvider(
                        &ProviderName,
                        PROV_STRIP_PREFIX,
                        i);

            if (status == STATUS_SUCCESS) {

                *Provider = &DfsData.pProvider[i];

            } else {

                ExFreePool( ProviderName.Buffer );

            }

        } else {

            status = STATUS_INSUFFICIENT_RESOURCES;

        }

    }

    ExReleaseResourceLite( &DfsData.Resource );

    if (*Provider != NULL && (*Provider)->FileObject == NULL) {

        //
        // We found (or created) a provider definition that is
        //

        *Provider = ReplLookupProvider( i );

        if (*Provider == NULL)
            status = STATUS_FS_DRIVER_REQUIRED;

    }

    return( status );

}


//+----------------------------------------------------------------------------
//
//  Function:   DfsInsertProvider
//
//  Synopsis:   Given a provider name, id, and capability, will add a new or
//              overwrite an existing provider definition.
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

NTSTATUS DfsInsertProvider(
    IN PUNICODE_STRING  ProviderName,
    IN ULONG            fProvCapability,
    IN ULONG            eProviderId)
{
    PPROVIDER_DEF pProv = DfsData.pProvider;
    int iProv;

    //
    //  Find a free provider structure, or overwrite an existing one.
    //

    for (iProv = 0; iProv < DfsData.cProvider; iProv++, pProv++) {
        if (pProv->eProviderId == eProviderId)
            break;
    }

    if (iProv >= DfsData.maxProvider) {
        ASSERT(iProv >= DfsData.maxProvider && "Out of provider structs");
        return(STATUS_INSUFFICIENT_RESOURCES);

    }

    if (iProv < DfsData.cProvider) {

        //
        // Decrement reference counts on saved objects
        //
        if (pProv->FileObject)
            ObDereferenceObject(pProv->FileObject);
        if (pProv->DeviceObject)
            ObDereferenceObject(pProv->DeviceObject);
        if (pProv->DeviceName.Buffer)
            ExFreePool(pProv->DeviceName.Buffer);
    }

    pProv->FileObject = NULL;
    pProv->DeviceObject = NULL;


    pProv->eProviderId = (USHORT) eProviderId;
    pProv->fProvCapability = (USHORT) fProvCapability;
    pProv->DeviceName = *ProviderName;

    if (iProv == DfsData.cProvider) {
        DfsData.cProvider++;
    }

    return(STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mup\kdext\dumps.c ===
#define KDEXTMODE

#include <dumpsup.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mup\rpselect.h ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation
//
//  File:       rpselect.h
//
//  Contents:   Function & Data Structure prototypes for replica selection.
//
//  Classes:
//
//  Functions:  ReplFindFirstProvider - find first appropriate provider and
//                      initialize the select context.
//              ReplFindNextProvider - get next provider from the list of
//                      providers based on an initialized select context.
//              ReplSetActiveService - a courtesy routine to tell replica
//                      selection that a particular service "worked". Will
//                      cause this service to be the first one to be tried
//                      on subsequent calls to FindFirst.
//              ReplIsRecoverableError - see if error code is something worth
//                      trying a replica for.
//
//  Data Structures:
//              REPL_SELECT_CONTEXT
//
//  History:    02 Sep 92       MilanS created.
//
//-----------------------------------------------------------------------------

#ifndef _RPSELECT_
#define _RPSELECT_

//
// This structure is supposed to be opaque to the user of this module.
// It should only be used to create select contexts to be passed to
// FindFirstProvider and FindNextProvider.
//

typedef struct _REPL_SELECT_CONTEXT {
   unsigned short       Flags;
   ULONG                iFirstSvcIndex;          // index of first svc
   ULONG                iSvcIndex;               // index of the last svc
                                                 // returned to caller.
} REPL_SELECT_CONTEXT, *PREPL_SELECT_CONTEXT;


//
// Define flags for SelectContext structures.
//

#define REPL_UNINITIALIZED      0x0001
#define REPL_SVC_IS_LOCAL       0x0002
#define REPL_SVC_IS_REMOTE      0x0004
#define REPL_PRINCIPAL_SPECD    0x0008
#define REPL_NO_MORE_ENTRIES    0x0010


NTSTATUS
ReplFindFirstProvider(
    IN  PDFS_PKT_ENTRY pPktEntry,                // for which a svc is needed
    IN  GUID *pidPrincipal,                      // look for this service
    IN  PUNICODE_STRING pustrPrincipal,          // or look for this service
    OUT PDFS_SERVICE *ppService,                 // return selected service
    OUT PREPL_SELECT_CONTEXT pSelectContext,     // Context to be initialized.
    OUT BOOLEAN *pLastEntry                      // Last entry
    );


NTSTATUS
ReplFindNextProvider(
    IN  PDFS_PKT_ENTRY pPktEntry,                // for which another svc is
    OUT PDFS_SERVICE *ppService,                 // needed.
    IN  OUT PREPL_SELECT_CONTEXT pSelectContext, // Context to use
    OUT BOOLEAN *pLastEntry                      // Last entry
    );

PPROVIDER_DEF
ReplLookupProvider(ULONG ProviderId);



//+----------------------------------------------------------------------------
//
//  Function:  ReplSetActiveService
//
//  Synopsis:  Sets the ActiveService pointer of a PKT Entry. This is an
//             Optimization. People who later look for a service for this
//             PKT Entry will be asked to look at the ActiveService first.
//
//  Arguments: [pPktEntry]      Pointer to PKT Entry.
//             [SelectContext]  Initialized Select Context returned by
//                              FindFirst or FindNext.
//
//  Returns:   Nothing
//
//  Notes:     For now, this is a #define. Later, when we support multi-
//             threaded operation, we can change it to a function that tests
//             whether the Pkt Entry has changed under it etc.
//
//-----------------------------------------------------------------------------

#define ReplSetActiveService(p,s)                                       \
    {                                                                   \
        if ((s).Flags & REPL_SVC_IS_REMOTE ) {                          \
            (p)->ActiveService = &(p)->Info.ServiceList[(s).iSvcIndex]; \
            if ((p)->ActiveService->pMachEntry != NULL) {               \
                InterlockedIncrement(                             \
                    &(p)->ActiveService->pMachEntry->ConnectionCount);  \
            }                                                           \
        }                                                               \
    }


//+----------------------------------------------------------------------------
//
//  Function:  ReplIsRecoverableError
//
//  Synopsis:  True if the argument is an NTSTATUS error code for which it
//             makes sense to try a replica if one is available.
//
//  Arguments: [x] - The NTSTATUS error code to be tested.
//
//  Returns:   True / False
//
//  Notes:     For now, this is simply #defined to be a relatively big OR
//             statement that tests for a bunch of specific error codes. If we
//             need to test for more error codes, it might be worth organizing
//             them into a hash table, which can then quickly be tested.
//
//             My initial estimates are that a hash table with either a modulo
//             or multiplication hash function will become cheaper at around
//             7-8 error codes, assuming clock cycle estimates of x86. A tree
//             type organization becomes effective after 10 error codes. The
//             problem with the latter is generating at compile time a
//             static, balanced tree.
//
//-----------------------------------------------------------------------------

#define ReplIsRecoverableError(x) ( (x) == STATUS_IO_TIMEOUT ||               \
                                    (x) == STATUS_REMOTE_NOT_LISTENING ||     \
                                    (x) == STATUS_VIRTUAL_CIRCUIT_CLOSED ||   \
                                    (x) == STATUS_BAD_NETWORK_PATH ||         \
                                    (x) == STATUS_NETWORK_BUSY ||             \
                                    (x) == STATUS_INVALID_NETWORK_RESPONSE || \
                                    (x) == STATUS_UNEXPECTED_NETWORK_ERROR || \
                                    (x) == STATUS_NETWORK_NAME_DELETED ||     \
                                    (x) == STATUS_BAD_NETWORK_NAME ||         \
                                    (x) == STATUS_REQUEST_NOT_ACCEPTED ||     \
                                    (x) == STATUS_DISK_OPERATION_FAILED ||    \
                                    (x) == STATUS_DEVICE_OFF_LINE ||          \
                                    (x) == STATUS_NETWORK_UNREACHABLE ||      \
                                    (x) == STATUS_INSUFFICIENT_RESOURCES ||   \
                                    (x) == STATUS_SHARING_PAUSED ||           \
                                    (x) == STATUS_DFS_UNAVAILABLE ||          \
                                    (x) == STATUS_NO_SUCH_DEVICE ||           \
                                    (x) == STATUS_NETLOGON_NOT_STARTED ||     \
                                    (x) == STATUS_UNMAPPABLE_CHARACTER ||     \
                                    (x) == STATUS_CONNECTION_DISCONNECTED ||  \
                                    (x) == STATUS_USER_SESSION_DELETED ||     \
                                    (x) == STATUS_NO_SUCH_LOGON_SESSION       \
                                  )
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mup\volinfo.c ===
//+----------------------------------------------------------------------------
//
//  File:       VOLINFO.C
//
//  Contents:   This module implements the volume information routines for
//              Dfs called by the dispatch driver.
//
//  Functions:  DfsFsdQueryVolumeInformation
//              DfsFspQueryVolumeInformation
//              DfsCommonQueryVolumeInformation
//              DfsFsdSetVolumeInformation
//              DfsFspSetVolumeInformation
//              DfsCommonSetVolumeInformation
//
//  Notes:      The Query information call is a candidate for directly
//              passing through via DfsVolumePassThrough.  We'll keep
//              the entry point around for now as a convenient place
//              for breakpointing and tracing volume information calls.
//
//  History:    12 Nov 1991     AlanW   Created from CDFS souce.
//
//-----------------------------------------------------------------------------


#include "dfsprocs.h"
#include "mupwml.h"

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_VOLINFO)

//
//  Local procedure prototypes
//

NTSTATUS
DfsCommonQueryVolumeInformation (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
DfsCommonSetVolumeInformation (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

#define DfsSetFsLabelInfo(irpc,pvcb,pbuf)       (STATUS_ACCESS_DENIED)


#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, DfsFsdQueryVolumeInformation )
#pragma alloc_text( PAGE, DfsFspQueryVolumeInformation )
#pragma alloc_text( PAGE, DfsCommonQueryVolumeInformation )
#pragma alloc_text( PAGE, DfsFsdSetVolumeInformation )
#pragma alloc_text( PAGE, DfsFspSetVolumeInformation )
#pragma alloc_text( PAGE, DfsCommonSetVolumeInformation )
#endif // ALLOC_PRAGMA


//+-------------------------------------------------------------------
//
//  Function:   DfsFsdQueryVolumeInformation, public
//
//  Synopsis:   This routine implements the Fsd part of the
//              NtQueryVolumeInformation API call.
//
//  Arguments:  [DeviceObject] -- Supplies the device object where the file
//                      being queried exists.
//              [Irp] -- Supplies the Irp being processed.
//
//  Returns:    NTSTATUS - The FSD status for the Irp.
//
//--------------------------------------------------------------------

NTSTATUS
DfsFsdQueryVolumeInformation (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
) {
    NTSTATUS Status;
    PIRP_CONTEXT IrpContext;

    DfsDbgTrace(+1, Dbg, "DfsFsdQueryVolumeInformation: Entered\n", 0);

    if (DeviceObject->DeviceType == FILE_DEVICE_MULTI_UNC_PROVIDER) {
        DfsCompleteRequest( NULL, Irp, STATUS_INVALID_DEVICE_REQUEST );
        DfsDbgTrace(-1, Dbg, "DfsFsdQueryVolumeInformation - Mup file\n", 0);
        return( STATUS_INVALID_DEVICE_REQUEST );
    }

    if (DeviceObject->DeviceType == FILE_DEVICE_DFS_VOLUME) {
        Status = DfsVolumePassThrough(DeviceObject, Irp);
        DfsDbgTrace(-1, Dbg, "DfsFsdQueryVolumeInformation: Exit -> %08x\n",
                                ULongToPtr(Status) );
        return Status;
    }

    //
    //  Call the common query routine, with blocking allowed if synchronous
    //

    FsRtlEnterFileSystem();

    try {

        IrpContext = DfsCreateIrpContext( Irp, CanFsdWait( Irp ) );
        if (IrpContext == NULL)
            ExRaiseStatus(STATUS_INSUFFICIENT_RESOURCES);
        Status = DfsCommonQueryVolumeInformation( IrpContext, Irp );

    } except(DfsExceptionFilter( IrpContext, GetExceptionCode(), GetExceptionInformation() )) {

        //
        //  We had some trouble trying to perform the requested
        //  operation, so we'll abort the I/O request with
        //  the error status that we get back from the
        //  execption code
        //

        Status = DfsProcessException( IrpContext, Irp, GetExceptionCode() );
    }

    FsRtlExitFileSystem();

    //
    //  And return to our caller
    //

    DfsDbgTrace(-1, Dbg, "DfsFsdQueryVolumeInformation: Exit -> %08x\n",
                                ULongToPtr(Status) );

    return Status;

    UNREFERENCED_PARAMETER( DeviceObject );
}


//+-------------------------------------------------------------------
//
//  Function:   DfsFspQueryVolumeInformation, public
//
//  Synopsis:   This routine implements the FSP part of the
//              NtQueryVolumeInformation API call.
//
//  Arguments:  [IrpContext] -- the IRP_CONTEXT for the request
//              [Irp] -- Supplies the Irp being processed.
//
//  Returns:    Nothing
//
//--------------------------------------------------------------------

VOID
DfsFspQueryVolumeInformation (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )
{
    DfsDbgTrace(+1, Dbg, "DfsFspQueryVolumeInformation: Entered\n", 0);

    //
    //  Call the common query routine.
    //

    (VOID)DfsCommonQueryVolumeInformation( IrpContext, Irp );

    //
    //  And return to our caller
    //

    DfsDbgTrace(-1, Dbg, "DfsFspQueryVolumeInformation: Exit -> VOID\n", 0);

    return;
}


//+-------------------------------------------------------------------
//
//  Function:   DfsCommonQueryVolumeInformation, private
//
//  Synopsis:   This is the common routine for querying volume information
//              called by both the FSD and FSP threads.
//
//  Arguments:  [IrpContext] -- Supplies the context block for the IRP
//              [Irp] -- Supplies the IRP being processed
//
//  Returns:    NTSTATUS - The return status for the operation
//
//--------------------------------------------------------------------

NTSTATUS
DfsCommonQueryVolumeInformation (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
) {
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;
    PIO_STACK_LOCATION NextIrpSp;
    PFILE_OBJECT FileObject;

    PDFS_VCB Vcb;
    PDFS_FCB Fcb;

    ULONG Length;
    FS_INFORMATION_CLASS FsInformationClass;
    PVOID Buffer;

    TYPE_OF_OPEN TypeOfOpen;

    //
    //  Get the current stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );
    FileObject = IrpSp->FileObject;

    DfsDbgTrace(+1, Dbg, "DfsCommonQueryVolumeInformation: Entered\n", 0);
    DfsDbgTrace( 0, Dbg, "Irp                  = %08x\n", Irp );
    DfsDbgTrace( 0, Dbg, "->Length             = %08x\n", ULongToPtr(IrpSp->Parameters.QueryVolume.Length) );
    DfsDbgTrace( 0, Dbg, "->FsInformationClass = %08x\n", IrpSp->Parameters.QueryVolume.FsInformationClass);
    DfsDbgTrace( 0, Dbg, "->Buffer             = %08x\n", Irp->AssociatedIrp.SystemBuffer);

    //
    //  Reference our input parameters to make things easier
    //

    Length = IrpSp->Parameters.QueryVolume.Length;
    FsInformationClass = IrpSp->Parameters.QueryVolume.FsInformationClass;
    Buffer = Irp->AssociatedIrp.SystemBuffer;

    //
    //  Decode the file object to get the Vcb
    //

    TypeOfOpen = DfsDecodeFileObject( IrpSp->FileObject, &Vcb, &Fcb);

    try {

        Status = STATUS_INVALID_PARAMETER;

        //
        //  Case on the type of open.
        //

        switch (TypeOfOpen) {

        default:
            DfsDbgTrace(0, Dbg,
                        "DfsCommonQueryVolumeInfo: Unknown open type\n", 0);

        invalid:
            // NOTE:  FALL THROUGH
        case FilesystemDeviceOpen:
            DfsCompleteRequest( IrpContext, Irp, STATUS_INVALID_DEVICE_REQUEST );
            Status = STATUS_INVALID_DEVICE_REQUEST;
            break;

        case LogicalRootDeviceOpen:
            DfsDbgTrace(0, Dbg,
                        "DfsCommonQueryVolumeInfo: Logical root open\n", 0);
            goto invalid;

        case RedirectedFileOpen:

            //
            //  Nothing special is done base on the information class.
            //  We simply pass each request through to the underlying
            //  file system and let it handle the request.
            //

            //
            // Copy the stack from one to the next...
            //
            NextIrpSp = IoGetNextIrpStackLocation(Irp);
            (*NextIrpSp) = (*IrpSp);

            IoSetCompletionRoutine( Irp,
                                    NULL,
                                    NULL,
                                    FALSE,
                                    FALSE,
                                    FALSE);

            //
            //  Call the next device in the chain
            //

            Status = IoCallDriver( Fcb->TargetDevice, Irp );
            MUP_TRACE_ERROR_HIGH(Status, ALL_ERROR, DfsCommonQueryVolumeInformation_Error_IoCallDriver,
                                 LOGSTATUS(Status)
                                 LOGPTR(Irp)
                                 LOGPTR(FileObject));
            //
            //  The IRP will be completed by the called driver.  We have
            //  no need for the IrpContext in the completion routine.
            //

            DfsDeleteIrpContext(IrpContext);
            IrpContext = NULL;
            Irp = NULL;
            break;
        }

    } finally {

        DfsDbgTrace(-1, Dbg, "DfsCommonQueryVolumeInformation: Exit -> %08x\n",
                                ULongToPtr(Status) );
    }

    return Status;
}


//+-------------------------------------------------------------------
//
//  Function:   DfsFsdSetVolumeInformation, public
//
//  Synopsis:   This routine implements the Fsd part of the
//              NtSetVolumeInformation API call.
//
//  Arguments:  [DeviceObject] -- Supplies the device object where the file
//                      being queried exists.
//              [Irp] -- Supplies the Irp being processed.
//
//  Returns:    NTSTATUS - The FSD status for the Irp.
//
//--------------------------------------------------------------------

NTSTATUS
DfsFsdSetVolumeInformation (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
) {
    NTSTATUS Status;
    PIRP_CONTEXT IrpContext;

    DfsDbgTrace(+1, Dbg, "DfsFsdSetVolumeInformation: Entered\n", 0);

    if (DeviceObject->DeviceType == FILE_DEVICE_MULTI_UNC_PROVIDER) {
        DfsCompleteRequest( NULL, Irp, STATUS_INVALID_DEVICE_REQUEST );
        DfsDbgTrace(-1, Dbg, "DfsFsdSetVolumeInformation - Mup file\n", 0);
        return( STATUS_INVALID_DEVICE_REQUEST );
    }

    if (DeviceObject->DeviceType == FILE_DEVICE_DFS_VOLUME) {
        Status = DfsVolumePassThrough(DeviceObject, Irp);
        DfsDbgTrace(-1, Dbg, "DfsFsdSetVolumeInformation: Exit -> %08x\n",
                                ULongToPtr(Status) );
        return Status;
    }

    //
    //  Call the common Set routine, with blocking allowed if synchronous
    //

    FsRtlEnterFileSystem();

    try {

        IrpContext = DfsCreateIrpContext( Irp, CanFsdWait( Irp ) );
        if (IrpContext == NULL)
            ExRaiseStatus(STATUS_INSUFFICIENT_RESOURCES);
        Status = DfsCommonSetVolumeInformation( IrpContext, Irp );

    } except(DfsExceptionFilter( IrpContext, GetExceptionCode(), GetExceptionInformation() )) {

        //
        //  We had some trouble trying to perform the requested
        //  operation, so we'll abort the I/O request with
        //  the error status that we get back from the
        //  execption code
        //

        Status = DfsProcessException( IrpContext, Irp, GetExceptionCode() );
    }

    FsRtlExitFileSystem();

    //
    //  And return to our caller
    //

    DfsDbgTrace(-1, Dbg, "DfsFsdSetVolumeInformation: Exit -> %08x\n",
                                ULongToPtr(Status) );

    return Status;

    UNREFERENCED_PARAMETER( DeviceObject );
}


//+-------------------------------------------------------------------
//
//  Function:   DfsFspSetVolumeInformation, public
//
//  Synopsis:   This routine implements the FSP part of the
//              NtSetVolumeInformation API call.
//
//  Arguments:  [IrpContext] -- the IRP_CONTEXT for the request
//              [Irp] -- Supplies the Irp being processed.
//
//  Returns:    Nothing
//
//--------------------------------------------------------------------

VOID
DfsFspSetVolumeInformation (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )
{
    DfsDbgTrace(+1, Dbg, "DfsFspSetVolumeInformation: Entered\n", 0);

    //
    //  Call the common Set routine.
    //

    (VOID)DfsCommonSetVolumeInformation( IrpContext, Irp );

    //
    //  And return to our caller
    //

    DfsDbgTrace(-1, Dbg, "DfsFspSetVolumeInformation: Exit -> VOID\n", 0);

    return;
}


//+-------------------------------------------------------------------
//
//  Function:   DfsCommonSetVolumeInformation, private
//
//  Synopsis:   This is the common routine for Seting volume information
//              called by both the FSD and FSP threads.
//
//  Arguments:  [IrpContext] -- Supplies the context block for the IRP
//              [Irp] -- Supplies the IRP being processed
//
//  Returns:    NTSTATUS - The return status for the operation
//
//--------------------------------------------------------------------

NTSTATUS
DfsCommonSetVolumeInformation (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
) {
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;

    PDFS_VCB Vcb;
    PDFS_FCB Fcb;

    FS_INFORMATION_CLASS FsInformationClass;
    PVOID Buffer;

    TYPE_OF_OPEN TypeOfOpen;

    //
    //  Get the current stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );


    DfsDbgTrace(+1, Dbg, "DfsCommonSetVolumeInformation: Entered\n", 0);
    DfsDbgTrace( 0, Dbg, "Irp                  = %08x\n", Irp );
    DfsDbgTrace( 0, Dbg, "->Length             = %08x\n", ULongToPtr(IrpSp->Parameters.SetVolume.Length) );
    DfsDbgTrace( 0, Dbg, "->FsInformationClass = %08x\n", IrpSp->Parameters.SetVolume.FsInformationClass);
    DfsDbgTrace( 0, Dbg, "->Buffer             = %08x\n", Irp->AssociatedIrp.SystemBuffer);

    //
    //  Reference our input parameters to make things easier
    //

    FsInformationClass = IrpSp->Parameters.SetVolume.FsInformationClass;
    Buffer = Irp->AssociatedIrp.SystemBuffer;

    //
    //  Decode the file object to get the Vcb
    //

    TypeOfOpen = DfsDecodeFileObject( IrpSp->FileObject, &Vcb, &Fcb);

    try {

        Status = STATUS_INVALID_PARAMETER;

        //
        //  Case on the type of open.
        //

        switch (TypeOfOpen) {

        default:
            DfsDbgTrace(0, Dbg, "DfsCommonSetVolumeInfo: Unknown open type\n", 0);

            // NOTE:  FALL THROUGH
        case FilesystemDeviceOpen:
            Status = STATUS_INVALID_DEVICE_REQUEST;
            break;

        case LogicalRootDeviceOpen:
        case RedirectedFileOpen:

            //
            //  Based on the information class we'll do different actions.
            //  Each of the procedures that we're calling fills up the output
            //  buffer if possible and returns true if it successfully filled
            //  the buffer and false if it couldn't wait for any I/O to
            //  complete.
            //

            switch (FsInformationClass) {

            case FileFsLabelInformation:
                Status = DfsSetFsLabelInfo( IrpContext, Vcb, Buffer);
                break;

            default:
                DfsDbgTrace(0, Dbg, "DfsCommonSetVolumeInfo: Unknown InformationClass\n", 0);
                Status = STATUS_INVALID_DEVICE_REQUEST;
                break;
            }
        }

    } finally {

        if (!AbnormalTermination()) {
            DfsCompleteRequest( IrpContext, Irp, Status );
        }

        DfsDbgTrace(-1, Dbg, "DfsCommonSetVolumeInformation: Exit -> %08x\n",
                                ULongToPtr(Status) );
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mup\rpselect.c ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation
//
//  File:       rpselect.c
//
//  Contents:   Routines to select and walk down a PKT Entry's svc list.
//
//  Classes:
//
//  Functions:  ReplFindFirstProvider - find first appropriate provider
//              ReplFindNextProvider - walk the list of providers.
//
//              ReplFindRemoteService - Helper function to find a remote
//                      (ie, not local) service.
//
//  History:    31 Aug 92       MilanS created.
//
//-----------------------------------------------------------------------------

#include "dfsprocs.h"
#include "rpselect.h"
#include "mupwml.h"

#define Dbg     (DEBUG_TRACE_DNR)

NTSTATUS ReplFindRemoteService(
    IN PDFS_PKT_ENTRY           pPktEntry,
    IN PREPL_SELECT_CONTEXT     pSelectContext,
    OUT ULONG                   *piSvc);


#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, ReplFindFirstProvider )
#pragma alloc_text( PAGE, ReplFindNextProvider )
#pragma alloc_text( PAGE, ReplLookupProvider )
#pragma alloc_text( PAGE, ReplFindRemoteService )
#endif // ALLOC_PRAGMA


//+----------------------------------------------------------------------------
//
//  Function:  ReplFindFirstProvider
//
//  Synopsis:  Supports the abstraction that a PKT Entry's service list is an
//             ORDERED list, with a distinguished "first" element. This
//             function returns that first element.
//
//  Arguments: [pPktEntry]      - Contains the Service List.
//             [pidPrincipal]   - Look for a service with this machine id
//             [pustrPrincipal] - Look for a service with this principal name
//             [ppService]      - Will be set to point to the Service Structure
//             [pSelectContext] - An opaque structure that will get initialized
//                                properly for future calls to
//                                ReplFindNextProvider().
//             [pLastEntry]     - TRUE if last entry, FALSE otherwise
//
//  Notes:      Assumes PktEntry is locked.
//
//  Returns:    [STATUS_SUCCESS] -- If provider found.
//
//              [STATUS_NO_MORE_ENTRIES] -- If no provider found.
//
//              [STATUS_OBJECT_NAME_NOT_FOUND] if prin. name spec'd but no
//                      service has that name.
//
//              [STATUS_OBJECT_TYPE_MISMATCH] if prin. name spec'd and matched
//                      with service, but service can't be used because of
//                      type or provider incompatibility.
//
//-----------------------------------------------------------------------------

NTSTATUS
ReplFindFirstProvider(
    IN PDFS_PKT_ENTRY pPktEntry,
    IN GUID *pidPrincipal,
    IN PUNICODE_STRING pustrPrincipal,
    OUT PDFS_SERVICE *ppService,
    OUT PREPL_SELECT_CONTEXT pSelectContext,
    OUT BOOLEAN *pLastEntry
) {

    NTSTATUS Status;
    PDFS_SERVICE psvcFirst = NULL;
    ULONG iSvc;

    ASSERT(pPktEntry != NULL);

    DfsDbgTrace(+1, Dbg, "ReplFindFirstProvider Entered.\n", 0);

    *pLastEntry = FALSE;

    //
    // See if the user wants a service with a specific machine id
    //

    ASSERT( pidPrincipal == NULL );

    //
    // See if the user wants us to pick a particular server
    //

    ASSERT( pustrPrincipal == NULL );

    // Initialize the SelectContext

    if ((pSelectContext->Flags & REPL_UNINITIALIZED) == 0) {
        pSelectContext->Flags = REPL_UNINITIALIZED;
        pSelectContext->iFirstSvcIndex = 0;
    }

    //
    // Check to see if Entry has a local service that will do.
    //

    if (pPktEntry->LocalService != NULL) {

        ASSERT(pPktEntry->LocalService->pProvider != NULL);

        DfsDbgTrace(0, Dbg, "Selecting Local Svc\n", 0);

        psvcFirst = pPktEntry->LocalService;

        pSelectContext->Flags = REPL_SVC_IS_LOCAL;

        //
        // pSelectContext->iSvcIndex and iFirstSvcIndex are meaningless
        // because of REPL_SVC_IS_LOCAL flag above. Leave them at unknown
        // values.
        //

    }

    if (psvcFirst == NULL) {
        // No local service, or local service not sufficient, lets find a
        // remote service.
        Status = ReplFindRemoteService(
                    pPktEntry,
                    pSelectContext,
                    &iSvc);
        if (NT_SUCCESS(Status)) {

            pSelectContext->Flags = REPL_SVC_IS_REMOTE;
            pSelectContext->iFirstSvcIndex = pSelectContext->iSvcIndex = iSvc;
            psvcFirst = &pPktEntry->Info.ServiceList[iSvc];
        }
    }

    if (psvcFirst != NULL) {

        DfsDbgTrace(-1, Dbg, "ReplFindFirstProvider: Found service %8lx\n",
                 psvcFirst);
        ASSERT(psvcFirst->pProvider != NULL);
        *ppService = psvcFirst;

        Status = ReplFindRemoteService(
                    pPktEntry,
                    pSelectContext,
                    &iSvc);

        if (!NT_SUCCESS(Status)) {
            *pLastEntry = TRUE;
        }

        return(STATUS_SUCCESS);
    } else {

        //
        //  An appropriate provider or referral was not found.
        //

        DfsDbgTrace(-1, Dbg,
                 "ReplFindFirstProvider: no service or provider found, "
                 "pPktEntry = %x\n", pPktEntry);
        *ppService = NULL;

        RtlZeroMemory(pSelectContext, sizeof(REPL_SELECT_CONTEXT));

        pSelectContext->Flags = REPL_NO_MORE_ENTRIES;
        Status = STATUS_NO_MORE_ENTRIES;
        MUP_TRACE_HIGH(ERROR, ReplFindFirstProvider_Error_NotFound,
                       LOGSTATUS(Status));
        return(STATUS_NO_MORE_ENTRIES);
    }
}



//+----------------------------------------------------------------------------
//
//  Function:  ReplFindNextProvider
//
//  Synopsis:  Supports the abstraction that a PktEntry's service list is an
//             ORDERED list. Based on the SELECT_TOKEN (which the caller is
//             required to have initialized by a call to ReplFindFirstProvider)
//             this call returns the next provider in the ordered sequence.
//
//  Arguments: [pPktEntry]      - Contains the service list to operate on
//             [ppService]      - The next service.
//             [pSelectContext] - The context
//             [pLastEntry]     - TRUE if last entry, FALSE otherwise
//
//  Notes:     Caller is required to have called ReplFindFirstProvider() before
//             calling this.
//
//  Returns:   [STATUS_SUCCESS] -- *ppService is the lucky winner.
//
//             [STATUS_NO_MORE_ENTRIES] -- End of ordered sequence.
//
//-----------------------------------------------------------------------------

NTSTATUS
ReplFindNextProvider(
    IN PDFS_PKT_ENTRY pPktEntry,
    OUT PDFS_SERVICE *ppService,
    IN OUT PREPL_SELECT_CONTEXT pSelectContext,
    OUT BOOLEAN *pLastEntry
)  {

    NTSTATUS Status;
    PDFS_SERVICE psvcNext = NULL;                // The one we will return
    ULONG iSvc;                                  // index into ServiceList

    DfsDbgTrace( 0, Dbg, "ReplFindNextProvider Entered.\n", 0);

    *pLastEntry = FALSE;

    //
    // First, check to see if we have previously determined that the list
    // is exhausted.
    //

    if (pSelectContext->Flags & REPL_NO_MORE_ENTRIES ||
        pSelectContext->Flags & REPL_PRINCIPAL_SPECD) {

        if (pSelectContext->Flags & REPL_PRINCIPAL_SPECD) {
            DfsDbgTrace(0, Dbg,
                "ReplFindNextProvider called for open with principal", 0);
        }

        *pLastEntry = TRUE;

        return(STATUS_NO_MORE_ENTRIES);
    }

    //
    // This routine will never return the local service; if the local service
    // were an appropriate choice, it would be returned by ReplFindFirstProvider
    // So here, we simply find the next appropriate remote service, and adjust
    // pSelectContext accordingly.
    //

    Status = ReplFindRemoteService(
                pPktEntry,
                pSelectContext,
                &iSvc);
    if (!NT_SUCCESS(Status)) {
        DfsDbgTrace( 0, Dbg, "ReplFindNextProvider: No more services.\n", 0);

        pSelectContext->Flags = REPL_NO_MORE_ENTRIES;
        *ppService = NULL;
        *pLastEntry = TRUE;
        return(STATUS_NO_MORE_ENTRIES);
    }

    // Service and provider found. Update pSelectContext and return.

    ASSERT(iSvc <= pPktEntry->Info.ServiceCount);
    psvcNext = &pPktEntry->Info.ServiceList[iSvc];
    DfsDbgTrace( 0, Dbg, "ReplFindNextProvider: Found svc %8lx\n", psvcNext);

    if (pSelectContext->Flags & REPL_SVC_IS_LOCAL) {
        pSelectContext->iFirstSvcIndex = iSvc;
    }

    pSelectContext->Flags = REPL_SVC_IS_REMOTE;
    pSelectContext->iSvcIndex = iSvc;          // Record Svc for next time

    ASSERT(psvcNext->pProvider != NULL);
    *ppService = psvcNext;

    Status = ReplFindRemoteService(
                pPktEntry,
                pSelectContext,
                &iSvc);

    if (!NT_SUCCESS(Status)) {
        *pLastEntry = TRUE;
    }

    return(STATUS_SUCCESS);
}


//+-------------------------------------------------------------------
//
//  Function:   ReplLookupProvider, local
//              (formerly DnrLookupProvider)
//
//  Synopsis:   This routine looks up a provider given a provider ID.
//
//  Arguments:  [ProviderID] -- The ID of the provider to be looked up
//
//  Returns:    [PPROVIDER_DEF] -- the provider found, or NULL
//
//--------------------------------------------------------------------


PPROVIDER_DEF
ReplLookupProvider(
    ULONG ProviderId
) {
    NTSTATUS Status;
    PPROVIDER_DEF pProv;
    HANDLE   hProvider = NULL;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK ioStatusBlock;
    OBJECT_HANDLE_INFORMATION handleInformation;
    PFILE_OBJECT    fileObject;
    int i;

    DfsDbgTrace(+1, Dbg, "ReplLookupProvider Entered: id = %x\n", ULongToPtr(ProviderId) );

    for (pProv = DfsData.pProvider, i=0; i<DfsData.cProvider; pProv++, i++) {

        if (ProviderId == pProv->eProviderId) {

            if (pProv->FileObject == NULL) {

                DfsDbgTrace(0, Dbg, "Provider device not been referenced yet\n", 0);

                //
                // We haven't opened a handle to the provider yet - so
                // lets try to.
                //

                if (pProv->DeviceName.Buffer) {

                    //
                    // Get a handle to the provider.
                    //

                    DfsDbgTrace(0, Dbg, "About to open %wZ\n", &pProv->DeviceName);

                    InitializeObjectAttributes(
                        &objectAttributes,
                        &pProv->DeviceName,
                        OBJ_CASE_INSENSITIVE,    // Attributes
                        0,                       // Root Directory
                        NULL                     // Security
                        );

                    Status = ZwOpenFile(
                                &hProvider,
                                FILE_TRAVERSE,
                                &objectAttributes,
                                &ioStatusBlock,
                                FILE_SHARE_READ | FILE_SHARE_WRITE,
                                FILE_DIRECTORY_FILE
                                );

                    if ( NT_SUCCESS( Status ) ) {
                        Status = ioStatusBlock.Status;
                    }

                    DfsDbgTrace(0, Dbg, "Open returned %08lx\n", ULongToPtr(Status) );

                    if ( NT_SUCCESS( Status ) ) {

                        //
                        // Increment ref count on objects
                        //
 
                        //
                        // 426184, need to check return code for errors.
                        //
                        Status = ObReferenceObjectByHandle(
                                    hProvider,
                                    0,
                                    NULL,
                                    KernelMode,
                                    (PVOID *)&fileObject,
                                    &handleInformation );

                        ZwClose(hProvider);
                    }

                    if ( NT_SUCCESS( Status ) ) {

                        //
                        // We have to do this because the pProv structure is in paged
                        // pool, and ObReferenceObjectByHandle requires the fileObject
                        // argument in NonPaged memory. So, we pass in a stack variable
                        // to ObReferenceObjectByHandle, then copy it to pProv->FileObject
                        //

                        pProv->FileObject = fileObject;

                        ASSERT( NT_SUCCESS( Status ) );

                        pProv->DeviceObject = IoGetRelatedDeviceObject(
                                                        pProv->FileObject
                                                        );
                        Status = ObReferenceObjectByPointer(
                                    pProv->DeviceObject,
                                    0,
                                    NULL,
                                    KernelMode
                             );


                        ASSERT( pProv->DeviceObject->StackSize < 6 );   // see dsinit.c

                        DfsDbgTrace(-1, Dbg, "ReplLookupProvider Exited: "
                                    "Provider Def @ %08lx\n", pProv);
                        return pProv;

                    } else {

                        return NULL;

                    }

                }

            } else {

                DfsDbgTrace(-1, Dbg, "ReplLookupProvider Exited: "
                           "Provider Def @ %08lx\n", pProv);
                return pProv;

            } // If pProv->FileObject == NULL

        } // If ProviderId == pProv->eProviderId

    } // For all provider defs

    DfsDbgTrace(-1, Dbg, "ReplLookupProvider Exited: Failed!", 0);

    return NULL;
}


//+----------------------------------------------------------------------------
//
//  Function:   ReplFindRemoteService
//
//  Synopsis:   This routine is a worker used by both ReplFindFirstProvider
//              and ReplFindNextProvider to find a !remote! service. It
//              completely ignores the local service, if any.
//
//              For now, it will simply scan the list sequentially. Later,
//              this routine can be modified to call a separate
//              component that will compute the transport cost, given the set
//              of network addresses in the service list.
//
//  Arguments:  [pPktEntry] -- The entry for for which a remote provider is
//                      to be selected.
//
//              [pSelectContext] -- The status of replica selection so far.
//
//              [piSvc] -- On successful return, the index in the service list
//                      of the selected service.
//
//  Returns:    [STATUS_SUCCESS] -- ServiceList[*piSvc] is the lucky winner.
//
//              [STATUS_NO_MORE_ENTRIES] -- Either service list is empty, or
//                      none of the services in the service list will do.
//
//-----------------------------------------------------------------------------

NTSTATUS ReplFindRemoteService(
    IN PDFS_PKT_ENTRY           pPktEntry,
    IN PREPL_SELECT_CONTEXT     pSelectContext,
    OUT ULONG                   *piSvc)
{
    ULONG iSvc;
    BOOLEAN bFound = FALSE;

    DfsDbgTrace(+1, Dbg, "ReplFindRemoteService: Entered\n", 0);

    if ( pPktEntry->Info.ServiceCount == 0 ) {
        DfsDbgTrace(0, Dbg, "ReplFindRemoteService: No svcs in pkt entry\n", 0);
        DfsDbgTrace(-1, Dbg, "ReplFindRemoteService: returning %08lx\n",
            ULongToPtr(STATUS_NO_MORE_ENTRIES) );
        return(STATUS_NO_MORE_ENTRIES);
    }


    if (pSelectContext->Flags & REPL_SVC_IS_LOCAL ||
        pSelectContext->Flags & REPL_UNINITIALIZED) {

        //
        // We haven't looked at a remote service yet. Start from the active
        // service or the first service in the svc list.
        //

        PDFS_SERVICE pSvc;

        if (pPktEntry->ActiveService) {
            DfsDbgTrace(0, Dbg, "Starting search at active svc\n", 0);
            pSvc = pPktEntry->ActiveService;
        } else {

            DfsDbgTrace(0, Dbg, "Starting search at first svc\n", 0);
            pSvc = &pPktEntry->Info.ServiceList[ 0 ];
        }

        iSvc = (ULONG)(pSvc - &pPktEntry->Info.ServiceList[0]);

        if (pSvc->pProvider == NULL) {
            pSvc->pProvider = ReplLookupProvider(pSvc->ProviderId);
        }

        if ( pSvc->pProvider != NULL ) {
            bFound = TRUE;
        } else {
            iSvc = (iSvc + 1) % pPktEntry->Info.ServiceCount;
        }

    } else {

        //
        // We have already looked at some remote services, lets continue where
        // we left off.
        //

        ASSERT(pPktEntry->Info.ServiceCount != 0);
        iSvc = (pSelectContext->iSvcIndex + 1) % pPktEntry->Info.ServiceCount;
        DfsDbgTrace(0, Dbg, "Continuing search at svc # %d\n", ULongToPtr(iSvc) );

    }

    //
    // We know where to begin looking and where to stop.
    //

    while ( (iSvc != pSelectContext->iFirstSvcIndex) && !bFound) {

        register PDFS_SERVICE pSvc = &pPktEntry->Info.ServiceList[iSvc];

        if (pSvc->pProvider == NULL) {
            pSvc->pProvider = ReplLookupProvider(pSvc->ProviderId);
        }

        if ( pSvc->pProvider != NULL ) {
            DfsDbgTrace(0, Dbg, "Found svc # %d\n", ULongToPtr(iSvc) );
            bFound = TRUE;
        } else {
            DfsDbgTrace(0, Dbg, "No provider for svc # %d\n", ULongToPtr(iSvc) );
            iSvc = (iSvc + 1) % pPktEntry->Info.ServiceCount;
        }

    }

    if (bFound) {
        *piSvc = iSvc;
        DfsDbgTrace(-1, Dbg, "ReplFindRemoteService: returning svc %08lx\n",
                &pPktEntry->Info.ServiceList[iSvc]);
        return(STATUS_SUCCESS);
    } else {
        DfsDbgTrace(-1, Dbg, "ReplFindRemoteService: Exited-> %08lx\n",
                ULongToPtr(STATUS_NO_MORE_ENTRIES) );
        return(STATUS_NO_MORE_ENTRIES);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mup\wml\inc\wmltypes.inc ===
//#define WMILIB_TYPEDEF(_TypeName, _EquivType, _FmtStr, _Func, _MofStr, _InitType)

#define WMILIB_SIMPLE_TYPE(_TypeName, _EquivType, _FmtStr, _MofStr) \
   WMILIB_TYPEDEF(_TypeName, _EquivType, _FmtStr, FormatSimple, _MofStr, WMILIB_ALIGNEDCOPY)
   
#define WMILIB_COMPLX_TYPE(_TypeName, _EquivType, _Func, _MofStr) \
   WMILIB_TYPEDEF(_TypeName, _EquivType, 0, _Func, _MofStr, WMILIB_ALIGNEDCOPY)

#define WMILIB_STRING_TYPE(_TypeName, _EquivType, _Func, _MofStr) \
   WMILIB_TYPEDEF(_TypeName, _EquivType, 0, _Func, _MofStr, WMILIB_ASIS)

WMILIB_SIMPLE_TYPE(UBYTE, char, "u",          ItemByte)
WMILIB_SIMPLE_TYPE(SBYTE, char, "d",          ItemSByte)
WMILIB_SIMPLE_TYPE(XBYTE, char, "X",          ItemXByte)
WMILIB_SIMPLE_TYPE(OBYTE, char, "02o",        ItemOByte)
WMILIB_COMPLX_TYPE(BBYTE, char, FormatBinary, ItemXByte)

WMILIB_SIMPLE_TYPE(USHORT, short, "u",          ItemUShort)
WMILIB_SIMPLE_TYPE(SSHORT, short, "d",          ItemShort)
WMILIB_SIMPLE_TYPE(XSHORT, short, "X",          ItemXShort)
WMILIB_SIMPLE_TYPE(OSHORT, short, "o",          ItemOShort)
WMILIB_COMPLX_TYPE(BSHORT, short, FormatBinary, ItemXShort)

WMILIB_SIMPLE_TYPE(UINT, int, "u",          ItemULong)
WMILIB_SIMPLE_TYPE(SINT, int, "s",          ItemLong)
WMILIB_SIMPLE_TYPE(XINT, int, "X",          ItemULongX)
WMILIB_SIMPLE_TYPE(OINT, int, "o",          ItemULong)
WMILIB_COMPLX_TYPE(BINT, int, FormatBinary, ItemULong)

WMILIB_SIMPLE_TYPE(HANDLE, HANDLE, "x",     ItemULong)

WMILIB_SIMPLE_TYPE(ULONGLONG, _int64, "u", ItemULongLong)
WMILIB_SIMPLE_TYPE(SLONGLONG, _int64, "s", ItemLongLong)
WMILIB_SIMPLE_TYPE(XLONGLONG, _int64, "X", ItemULongLongX)
WMILIB_SIMPLE_TYPE(OLONGLONG, _int64, "o", ItemULongLong)

WMILIB_SIMPLE_TYPE(PTR,        void*, "x", ItemXPointer)

WMILIB_SIMPLE_TYPE(BOOLEAN, char, "u", ItemListByte (FALSE,TRUE) )

WMILIB_SIMPLE_TYPE(UCHAR, CHAR,  "c", ItemUChar)
WMILIB_SIMPLE_TYPE(ACHAR, CHAR,  "c", ItemChar)
WMILIB_SIMPLE_TYPE(WCHAR, WCHAR, "c", ItemShortSign)

WMILIB_STRING_TYPE(ASTR, WMILIBTYPE_STRING, FormatMisc, ItemString)
WMILIB_STRING_TYPE(WSTR, WMILIBTYPE_STRING, FormatMisc, ItemWString)
WMILIB_STRING_TYPE(USTR, WMILIBTYPE_STRING, FormatMisc, ItemPString)

WMILIB_COMPLX_TYPE(DATE,     LARGE_INTEGER, FormatMisc, ItemDate)
WMILIB_COMPLX_TYPE(TIMENT,   LARGE_INTEGER, FormatMisc, ItemTime)
WMILIB_COMPLX_TYPE(DATETIME, LARGE_INTEGER, FormatMisc, ItemDateTime)
WMILIB_COMPLX_TYPE(MILLISEC, LARGE_INTEGER, FormatMisc, ItemMillisec)
WMILIB_COMPLX_TYPE(ALETTER,  CHAR,          FormatMisc, ItemLetter)
WMILIB_COMPLX_TYPE(WLETTER,  WCHAR,         FormatMisc, ItemWLetter)
WMILIB_COMPLX_TYPE(GUID,     GUID,          FormatMisc, ItemGuid)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mup\strucsup.c ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:       STRUCSUP.C
//
//  Contents:   This module implements the Dsfs in-memory data structure
//              manipulation routines
//
//  Functions:
//              DfsCreateIrpContext -
//              DfsDeleteIrpContext_Real -
//              DfsInitializeVcb -
//              DfsCreateFcb -
//              DfsDeleteFcb_Real -
//              DspAllocateStringRoutine -
//
//  History:    12 Nov 1991     AlanW   Created from CDFS souce.
//               8 May 1992     PeterCo added support for new PKT stuff (M000)
//-----------------------------------------------------------------------------


#include "dfsprocs.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_STRUCSUP)


#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, DfsInitializeVcb )
#pragma alloc_text( PAGE, DfsDeleteIrpContext_Real)
#pragma alloc_text( PAGE, DfsCreateFcb )
#pragma alloc_text( PAGE, DfsDeleteFcb_Real )

//
// The following routines cannot be paged because they acquire/release
// spin locks
//
// DfsCreateIrpContext
// DfsDeleteIrpContext_Real
//

#endif // ALLOC_PRAGMA


//+-------------------------------------------------------------------
//
//  Function:   DfsCreateIrpContext, public
//
//  Synopsis:   This routine creates a new IRP_CONTEXT record
//
//  Arguments:  [Irp] - Supplies the originating Irp.
//              [Wait] - Supplies the wait value to store in the context
//
//  Returns:    PIRP_CONTEXT - returns a pointer to the newly allocate
//                      IRP_CONTEXT Record
//
//--------------------------------------------------------------------

PIRP_CONTEXT
DfsCreateIrpContext (
    IN PIRP Irp,
    IN BOOLEAN Wait
) {
    KIRQL SavedIrql;
    PIRP_CONTEXT IrpContext;
    PIO_STACK_LOCATION IrpSp;

    DfsDbgTrace(+1, Dbg, "DfsCreateIrpContext\n", 0);

    IrpContext = ExAllocateFromNPagedLookasideList (&DfsData.IrpContextLookaside);

    if (IrpContext != NULL) {
        //
        //  Zero out the irp context and indicate that it is from pool and
        //  not zone allocated
        //

        RtlZeroMemory( IrpContext, sizeof(IRP_CONTEXT) );

        //
        //  Set the proper node type code and node byte size
        //

        IrpContext->NodeTypeCode = DSFS_NTC_IRP_CONTEXT;
        IrpContext->NodeByteSize = sizeof(IRP_CONTEXT);

        //
        //  Set the originating Irp field
        //

        IrpContext->OriginatingIrp = Irp;
        IrpSp = IoGetCurrentIrpStackLocation( Irp );

        //
        //  Major/Minor Function codes
        //

        IrpContext->MajorFunction = IrpSp->MajorFunction;
        IrpContext->MinorFunction = IrpSp->MinorFunction;

        //
        //  Set the Wait and InFsd flags
        //

        if (Wait) {
            IrpContext->Flags |= IRP_CONTEXT_FLAG_WAIT;
        }

        IrpContext->Flags |= IRP_CONTEXT_FLAG_IN_FSD;
    }
    //
    //  return and tell the caller
    //

    DfsDbgTrace(-1, Dbg, "DfsCreateIrpContext -> %08lx\n", IrpContext);

    return IrpContext;
}


//+-------------------------------------------------------------------
//
//  Function:   DfsDeleteIrpContext, public
//
//  Synopsis:   This routine deallocates and removes the specified
//              IRP_CONTEXT record from the Dsfs in-memory data
//              structures.  It should only be called by DfsCompleteRequest.
//
//  Arguments:  [IrpContext] -- Supplies the IRP_CONTEXT to remove
//
//  Returns:    None
//
//  Notes:
//
//--------------------------------------------------------------------

VOID
DfsDeleteIrpContext_Real (
    IN PIRP_CONTEXT IrpContext
) {

    DfsDbgTrace(+1, Dbg, "DfsDeleteIrpContext, IrpContext = %08lx\n", IrpContext);

    ASSERT( IrpContext->NodeTypeCode == DSFS_NTC_IRP_CONTEXT );

    ExFreeToNPagedLookasideList (&DfsData.IrpContextLookaside, IrpContext);

    //
    //  return and tell the caller
    //

    DfsDbgTrace(-1, Dbg, "DfsDeleteIrpContext -> VOID\n", 0);

    return;
}




//+-------------------------------------------------------------------
//
//  Function:   DfsInitializeVcb, public
//
//  Synopsis:   This routine initializes a DFS_VCB.
//
//  Arguments:  [IrpContext] --
//              [Vcb] --        Supplies the address of the Vcb record being
//                              initialized.
//              [LogRootPrefix] -- Optional Unicode String pointer that
//                              specifies the relative name of the logical
//                              root to the highest (org) root.
//              [Credentials] -- The credentials associated with this device
//              [TargetDeviceObject] -- Supplies the address of the target
//                              device object to associate with the Vcb record.
//
//  Returns:    None
//
//  Note:       If LogRootPrefix is given, its buffer will be "deallocated"
//
//--------------------------------------------------------------------


VOID
DfsInitializeVcb (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PDFS_VCB Vcb,
    IN PUNICODE_STRING LogRootPrefix,
    IN PDFS_CREDENTIALS Credentials OPTIONAL,
    IN PDEVICE_OBJECT TargetDeviceObject
) {

    DfsDbgTrace(+1, Dbg, "DfsInitializeVcb:  Entered\n", 0);

    //
    //  Zero out the memory to remove stale data.
    //

    RtlZeroMemory( Vcb, sizeof( DFS_VCB ));

    //
    //  Set the proper node type code and node byte size.
    //

    Vcb->NodeTypeCode = DSFS_NTC_VCB;
    Vcb->NodeByteSize = sizeof( DFS_VCB );

    //
    //  Set the prefix string to the input prefix, then `deallocate' the
    //  input pointer.
    //

    Vcb->LogRootPrefix = *LogRootPrefix;
    RtlZeroMemory( LogRootPrefix, sizeof( UNICODE_STRING ));

    //
    //  Save the credentials
    //

    Vcb->Credentials = Credentials;

    //
    //  Insert this Vcb record on the DfsData.VcbQueue
    //

    InsertTailList( &DfsData.VcbQueue, &Vcb->VcbLinks );


    DfsDbgTrace(-1, Dbg, "DfsInitializeVcb:  Exit\n", 0);

    return;
}


//+-------------------------------------------------------------------
//
//  Function:   DfsCreateFcb, public
//
//  Synopsis:   This routine allocates, initializes, and inserts a new
//              DFS_FCB record into the in-memory data structure.
//
//  Arguments:  [Vcb] -- Supplies the Vcb to associate the new Fcb under
//              [FullName] -- Fully qualified file name for the DFS_FCB
//
//  Returns:    PDFS_FCB - Pointer to the newly created and initialized Fcb.
//
//--------------------------------------------------------------------

PDFS_FCB
DfsCreateFcb (
    IN PIRP_CONTEXT IrpContext,
    IN PDFS_VCB Vcb,
    IN PUNICODE_STRING FullName OPTIONAL
) {
    PDFS_FCB NewFcb;
    ULONG TotalLength;

    DfsDbgTrace(+1, Dbg, "DfsCreateFcb:  Entered\n", 0);

    //
    //  Allocate a new Fcb and zero it out.
    //

    TotalLength = sizeof(DFS_FCB);
    if (ARGUMENT_PRESENT(FullName))
        TotalLength += FullName->Length * sizeof(WCHAR);

    NewFcb = (PDFS_FCB) ExAllocatePoolWithTag( NonPagedPool, TotalLength, ' puM' );

    if (NewFcb != NULL) {

        RtlZeroMemory( NewFcb, sizeof( DFS_FCB ));

        //
        //  Set the proper node type code and node byte size
        //

        NewFcb->NodeTypeCode = DSFS_NTC_FCB;
        NewFcb->NodeByteSize = sizeof( DFS_FCB );

        if (ARGUMENT_PRESENT(FullName)) {

            NewFcb->FullFileName.Length =
                NewFcb->FullFileName.MaximumLength = FullName->Length;

            NewFcb->FullFileName.Buffer =
                (PWCHAR) ( (PCHAR)NewFcb + sizeof(DFS_FCB) );

            RtlMoveMemory( NewFcb->FullFileName.Buffer,
                           FullName->Buffer,
                           FullName->Length );

            NewFcb->AlternateFileName.Length = 0;

            NewFcb->AlternateFileName.MaximumLength = FullName->Length;

            NewFcb->AlternateFileName.Buffer =
                &NewFcb->FullFileName.Buffer[FullName->Length/sizeof(WCHAR)];

        }

        NewFcb->Vcb = Vcb;

    }

    DfsDbgTrace(-1, Dbg, "DfsCreateFcb -> %8lx\n", NewFcb);

    return NewFcb;
}

//+-------------------------------------------------------------------
//
//  Function:   DfsDeleteFcb
//
//  Synopsis:   This routine removes the Fcb record from DSFS's in-memory data
//              structures.  It also will remove all associated underlings.
//
//  Arguments:  [Fcb] -- Supplies the Fcb/Dcb to be removed
//
//  Returns:    None
//
//--------------------------------------------------------------------

VOID
DfsDeleteFcb_Real (
    IN PIRP_CONTEXT IrpContext,
    IN PDFS_FCB Fcb
) {
    DfsDbgTrace(+1, Dbg, "DfsDeleteFcb:  Fcb = %08lx\n", Fcb);

    //
    //  Zero out the structure and deallocate.
    //

    ExFreePool( Fcb );

    DfsDbgTrace(-1, Dbg, "DfsDeleteFcb:  Exit\n", 0);

    return;
}


//+-------------------------------------------------------------------
//
//  Function:   DfsGetLogonId
//
//  Synopsis:   This routine gets the current LogonID.
//              It is assumed that this will be called in the user thread
//              or from a thread that is impersonating the user thread.
//
//  Arguments:  LogonId -- Pointer to LUID where we stuff the LUID
//
//  Returns:    None
//
//--------------------------------------------------------------------

NTSTATUS
DfsGetLogonId(
    PLUID LogonId)  
{
    SECURITY_SUBJECT_CONTEXT SubjectContext;
	
    SeCaptureSubjectContext(&SubjectContext);

    if (SubjectContext.ClientToken != NULL) {

        //
        //  If its impersonating someone that is logged in locally then use
        //  the local id.
        //

        SeQueryAuthenticationIdToken(SubjectContext.ClientToken, LogonId);

    } else {

        //
        //  Use the processes LogonId
        //

        SeQueryAuthenticationIdToken(SubjectContext.PrimaryToken, LogonId);
    }

    SeReleaseSubjectContext(&SubjectContext);

    return STATUS_SUCCESS;
}



//+-------------------------------------------------------------------
//
//  Function:   DfsInitializeDrt, public
//
//  Synopsis:   This routine initializes a DFS_DEVLESS_ROOT.
//
//  Arguments:  [Drt] --        Supplies the address of the Vcb record being
//                              initialized.
//              [Name] --       Unicode String pointer that
//                              specifies the relative name of the logical
//                              root to the highest (org) root.
//              [Credentials] -- The credentials associated with this device
//
//  Returns:    None
//
//--------------------------------------------------------------------


VOID
DfsInitializeDrt (
    IN OUT PDFS_DEVLESS_ROOT Drt,
    IN PUNICODE_STRING Name,
    IN PDFS_CREDENTIALS Credentials OPTIONAL
) {

    DfsDbgTrace(+1, Dbg, "DfsInitializeDevlessRoot:  Entered %x\n", Drt);

    //
    //  Zero out the memory to remove stale data.
    //

    RtlZeroMemory( Drt, sizeof( DFS_DEVLESS_ROOT ));

    //
    //  Set the proper node type code and node byte size.
    //

    Drt->NodeTypeCode = DSFS_NTC_DRT;
    Drt->NodeByteSize = sizeof( DFS_DEVLESS_ROOT );

    Drt->DevlessPath = *Name;

    //
    //  Save the credentials
    //

    Drt->Credentials = Credentials;

    //
    //  Insert this Drt record on the DfsData.DrtQueue
    //

    InsertTailList( &DfsData.DrtQueue, &Drt->DrtLinks );

    DfsDbgTrace(-1, Dbg, "DfsInitializeDevlessRoot:  Exit\n", 0);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mup\kdext\kdextlib.c ===
/*++

Copyright (c) 1990 Microsoft Corporation

Module Name:

    kdextlib.c

Abstract:

    Library routines for dumping data structures given a meta level descrioption

Author:

    Balan Sethu Raman (SethuR) 11-May-1994

Notes:
    The implementation tends to avoid memory allocation and deallocation as much as possible.
    Therefore We have choosen an arbitrary length as the default buffer size. A mechanism will
    be provided to modify this buffer length through the debugger extension commands.

Revision History:

    11-Nov-1994 SethuR  Created

--*/

#include <ntos.h>
#include <nturtl.h>
#include "ntverp.h"

#include <windows.h>
#include <wdbgexts.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

#include <kdextlib.h>

BOOL
kdextAtoi(
    LPSTR lpArg,
    int *pRet
);

int
kdextStrlen(
    LPSTR lpsz
);

int
kdextStrnicmp(
    LPSTR lpsz1,
    LPSTR lpsz2,
    int cLen
);

#define    PRINTF    dprintf


PWINDBG_OUTPUT_ROUTINE                lpOutputRoutine;
PWINDBG_GET_EXPRESSION32              lpGetExpressionRoutine;
PWINDBG_GET_SYMBOL32                  lpGetSymbolRoutine;
PWINDBG_READ_PROCESS_MEMORY_ROUTINE   lpReadMemoryRoutine;

#define    NL      1
#define    NONL    0

#define DEFAULT_UNICODE_DATA_LENGTH 512
USHORT s_UnicodeStringDataLength = DEFAULT_UNICODE_DATA_LENGTH;
WCHAR  s_UnicodeStringData[DEFAULT_UNICODE_DATA_LENGTH];
WCHAR *s_pUnicodeStringData = s_UnicodeStringData;

#define DEFAULT_ANSI_DATA_LENGTH 512
USHORT s_AnsiStringDataLength = DEFAULT_ANSI_DATA_LENGTH;
CHAR  s_AnsiStringData[DEFAULT_ANSI_DATA_LENGTH];
CHAR *s_pAnsiStringData = s_AnsiStringData;

//
// No. of columns used to display struct fields;
//

ULONG s_MaxNoOfColumns = 3;
ULONG s_NoOfColumns = 1;

/*
 * Fetches the data at the given address
 */
BOOLEAN
GetData( ULONG_PTR dwAddress, PVOID ptr, ULONG size)
{
    BOOL b;
    ULONG BytesRead;

    b = (lpReadMemoryRoutine)(dwAddress, ptr, size, &BytesRead );


    if (!b || BytesRead != size ) {
        return FALSE;
    }

    return TRUE;
}

/*
 * Fetch the null terminated ASCII string at dwAddress into buf
 */
BOOL
GetStringW( DWORD dwAddress, LPWSTR buf )
{
    do {
        if( !GetData( dwAddress,buf, sizeof(WCHAR)) )
            return FALSE;

        dwAddress += sizeof(WCHAR);
        buf++;

    } while( *buf != '\0' );

    return TRUE;
}

/*
 * Displays a byte in hexadecimal
 */
VOID
PrintHexChar( UCHAR c )
{
    PRINTF( "%c%c", "0123456789abcdef"[ (c>>4)&7 ], "0123456789abcdef"[ c&7 ] );
}

/*
 * Displays a buffer of data in hexadecimal
 */
VOID
PrintHexBuf( PUCHAR buf, ULONG cbuf )
{
    while( cbuf-- ) {
        PrintHexChar( *buf++ );
        PRINTF( " " );
    }
}

/*
 * Displays a unicode string
 */
BOOL
PrintStringW(LPSTR msg, PUNICODE_STRING puStr, BOOL nl )
{
    UNICODE_STRING UnicodeString;
    BOOLEAN        b;

    if( msg )
        PRINTF( msg );

    if( puStr->Length == 0 ) {
        if( nl )
            PRINTF( "\n" );
        return TRUE;
    }

    UnicodeString.Buffer        = s_pUnicodeStringData;
    UnicodeString.MaximumLength = s_UnicodeStringDataLength;
    UnicodeString.Length = (puStr->Length > s_UnicodeStringDataLength)
                            ? s_UnicodeStringDataLength
                            : puStr->Length;

    b = GetData((ULONG_PTR)puStr->Buffer, UnicodeString.Buffer, (ULONG) UnicodeString.Length);

    if (b)    {
        PRINTF("%wZ%s", &UnicodeString, nl ? "\n" : "" );
    }

    return b;
}

/*
 * Displays a ANSI string
 */
BOOL
PrintStringA(LPSTR msg, PANSI_STRING pStr, BOOL nl )
{
    ANSI_STRING AnsiString;
    BOOL b;

    if( msg )
        PRINTF( msg );

    if( pStr->Length == 0 ) {
        if( nl )
            PRINTF( "\n" );
        return TRUE;
    }

    AnsiString.Buffer        = s_pAnsiStringData;
    AnsiString.MaximumLength = s_AnsiStringDataLength;
    AnsiString.Length = (pStr->Length > (s_AnsiStringDataLength - 1))
                        ? (s_AnsiStringDataLength - 1)
                        : pStr->Length;

    b = (lpReadMemoryRoutine)(
                (ULONG_PTR)pStr->Buffer,
                AnsiString.Buffer,
                AnsiString.Length,
                NULL);

    if (b)    {
        AnsiString.Buffer[ AnsiString.Length ] = '\0';
        PRINTF("%s%s", AnsiString.Buffer, nl ? "\n" : "" );
    }

    return b;
}

/*
 * Displays a GUID
 */

BOOL
PrintGuid(
    GUID *pguid)
{
    ULONG i;

    PRINTF( "%08x-%04x-%04x", pguid->Data1, pguid->Data2, pguid->Data3 );
    for (i = 0; i < 8; i++) {
        PRINTF("%02x",pguid->Data4[i]);
    }
    return( TRUE );
}

/*
 * Displays a LARGE_INTEGER
 */

BOOL
PrintLargeInt(
    LARGE_INTEGER *bigint)
{
    PRINTF( "%08x:%08x", bigint->HighPart, bigint->LowPart);
    return( TRUE );
}

/*
 * Displays all the fields of a given struct. This is the driver routine that is called
 * with the appropriate descriptor array to display all the fields in a given struct.
 */



LPSTR LibCommands[] = {
    "help -- This command ",
    "version -- Version of extension ",
    "dump <Struct Type Name>@<address expr> ",
    "columns <d> -- controls the number of columns in the display ",
    0
};

BOOL
help(
    DWORD                   dwCurrentPC,
    PWINDBG_EXTENSION_APIS    lpExtensionApis,
    LPSTR                   lpArgumentString
)
{
    int i;


    PRINTF("\n");

    for( i=0; ExtensionNames[i]; i++ )
        PRINTF( "%s\n", ExtensionNames[i] );

    for( i=0; LibCommands[i]; i++ )
        PRINTF( "   %s\n", LibCommands[i] );

    for( i=0; Extensions[i]; i++) {
        PRINTF( "   %s\n", Extensions[i] );
    }

    return TRUE;
}

BOOL
columns(
    DWORD                   dwCurrentPC,
    PWINDBG_EXTENSION_APIS    lpExtensionApis,
    LPSTR                   lpArgumentString
)
{
    ULONG NoOfColumns;
    int   i;


    if (kdextAtoi(lpArgumentString, &i) && i > 0) {

        NoOfColumns = (ULONG) i;

        if (NoOfColumns > s_MaxNoOfColumns) {
            PRINTF( "No. Of Columns exceeds maximum(%ld) -- directive Ignored\n", s_MaxNoOfColumns );
        } else {
            s_NoOfColumns = NoOfColumns;
        }

    } else {

        PRINTF( "Bad argument to command (%s)", lpArgumentString );

    }

    return TRUE;
}

BOOL
version
(
    DWORD                   dwCurrentPC,
    PWINDBG_EXTENSION_APIS    lpExtensionApis,
    LPSTR                   lpArgumentString
)
{
#if    VER_DEBUG
    char *kind = "checked";
#else
    char *kind = "free";
#endif


    PRINTF( "Mup debugger extension dll for %s build %u\n", kind, VER_PRODUCTBUILD );

    return TRUE;
}


/*
 * KD Extensions should not link with the C-Runtime library routines. So,
 * we implement a few of the needed ones here.
 */

BOOL
kdextAtoi(
    LPSTR lpArg,
    int *pRet
)
{
    int n, cbArg, val = 0;
    BOOL fNegative = FALSE;

    cbArg = kdextStrlen( lpArg );

    if (cbArg > 0) {
        for (n = 0; lpArg[n] == ' '; n++) {
            ;
        }
        if (lpArg[n] == '-') {
            n++;
            fNegative = TRUE;
        }
        for (; lpArg[n] >= '0' && lpArg[n] <= '9'; n++) {
            val *= 10;
            val += (int) (lpArg[n] - '0');
        }
        if (lpArg[n] == 0) {
            *pRet = (fNegative ? -val : val);
            return( TRUE );
        } else {
            return( FALSE );
        }
    } else {
        return( FALSE );
    }

}

int
kdextStrlen(
    LPSTR lpsz
)
{
    int c;

    if (lpsz == NULL) {
        c = 0;
    } else {
        for (c = 0; lpsz[c] != 0; c++) {
            ;
        }
    }

    return( c );
}


#define UPCASE_CHAR(c)  \
    ( (((c) >= 'a') && ((c) <= 'z')) ? ((c) - 'a' + 'A') : (c) )

int
kdextStrnicmp(
    LPSTR lpsz1,
    LPSTR lpsz2,
    int cLen
)
{
    int nDif, i;

    for (i = nDif = 0; nDif == 0 && i < cLen; i++) {
        nDif = UPCASE_CHAR(lpsz1[i]) - UPCASE_CHAR(lpsz2[i]);
    }

    return( nDif );
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mup\kdext\wdbgxlib.c ===
/*++

Copyright (c) 1990 Microsoft Corporation

Module Name:

    wdbgxlib.c

Abstract:

    This module realizes most of the routines needed for the rdbss/smbmini debugger extension.

Author:

    Balan Sethu Raman (SethuR) 11-May-1994

Notes:

Revision History:

    11-Nov-1994 SethuR  Created
    11-Nov-1995         Changed to newer windbg apis

--*/


#include <ntos.h>
#include <nturtl.h>
#include "ntverp.h"

#include <windows.h>
#include <wdbgexts.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

#include <kdextlib.h>




WINDBG_EXTENSION_APIS ExtensionApis;
EXT_API_VERSION ApiVersion = { 3, 5, EXT_API_VERSION_NUMBER, 0 };

#define    ERRPRT     dprintf

#define    NL      1
#define    NONL    0

USHORT SavedMajorVersion;
USHORT SavedMinorVersion;
BOOL   ChkTarget;            // is debuggee a CHK build?


/*
 * Print out an optional message, an ANSI_STRING, and maybe a new-line
 */
BOOL
wPrintStringA( IN LPSTR msg OPTIONAL, IN PANSI_STRING pStr, IN BOOL nl )
{
    PCHAR    StringData;
    ULONG    BytesRead;

    if( msg )
        dprintf( msg );

    if( pStr->Length == 0 ) {
        if( nl )
            dprintf( "\n" );
        return TRUE;
    }

    StringData = (PCHAR)LocalAlloc( LPTR, pStr->Length + 1 );

    if( StringData == NULL ) {
        ERRPRT( "Out of memory!\n" );
        return FALSE;
    }

    ReadMemory( (ULONG_PTR)pStr->Buffer,
               StringData,
               pStr->Length,
               &BytesRead );

    if ( BytesRead ) {
        StringData[ pStr->Length ] = '\0';
        dprintf("%s%s", StringData, nl ? "\n" : "" );
    }

    LocalFree((HLOCAL)StringData);

    return BytesRead;
}

BOOL
wPrintStringW( IN LPSTR msg OPTIONAL, IN PUNICODE_STRING pStr, IN BOOL nl )
{
    UNICODE_STRING NewStr;

    ULONG    BytesRead;

    if( msg )
        dprintf( msg );

    if( pStr->Length == 0 ) {
        if( nl )
            dprintf( "\n" );
        return TRUE;
    }

    NewStr.Buffer = (WCHAR *)LocalAlloc( LPTR, pStr->Length + 1 );
    NewStr.Length = pStr->Length;
    NewStr.MaximumLength = pStr->Length+1;
    if( NewStr.Buffer == NULL ) {
        ERRPRT( "Out of memory!\n" );
        return FALSE;
    }

    ReadMemory( (ULONG_PTR)pStr->Buffer,
               NewStr.Buffer,
               pStr->Length,
               &BytesRead );

    if ( BytesRead ) {
        dprintf("%wZ%s", &NewStr, nl ? "\n" : "" );
    }

    LocalFree((HLOCAL)NewStr.Buffer);

    return BytesRead;
}



/*
 * Fetches the data at the given address
 */
BOOLEAN
wGetData( ULONG_PTR dwAddress, PVOID ptr, ULONG size)
{
    BOOL b;
    ULONG BytesRead;

    b = ReadMemory( dwAddress, ptr, size, &BytesRead );


    if (!b || BytesRead != size ) {
        dprintf( "Unable to read %u bytes at %X, for %s\n", size, dwAddress);
        return FALSE;
    }

    return TRUE;
}

/*
 * Fetch the null terminated ASCII string at dwAddress into buf
 */
BOOL
wGetString( ULONG_PTR dwAddress, PSZ buf )
{
    for(;;) {
        if( !wGetData( dwAddress,buf, 1) ){
            //dprintf("readfailure at %08lx\n",dwAddress);
            return FALSE;
        }

        //dprintf ("stringing %08lx %08lx %c\n", dwAddress, buf,
        //                                     ((*buf==0)?'.':*buf) );

        if ( *buf == '\0' ) { break; }

        dwAddress++;
        buf++;

    };

    return TRUE;
}

#if 0
/*
 * Get 'size' bytes from the debuggee program at 'dwAddress' and place it
 * in our address space at 'ptr'.  Use 'type' in an error printout if necessary
 */
BOOL
wGetData_srv( IN LPVOID ptr, IN ULONG_PTR dwAddress, IN ULONG size, IN PCSTR type )
{
    BOOL b;
    ULONG BytesRead;
    ULONG count;

    while( size > 0 ) {

        count = min( size, 3000 );

        b = ReadMemory((ULONG) dwAddress, ptr, count, &BytesRead );

        if (!b || BytesRead != count ) {
            ERRPRT( "Unable to read %u bytes at %X, for %s\n", size, dwAddress, type );
            return FALSE;
        }

        dwAddress += count;
        size -= count;
        ptr = (LPVOID)((ULONG)ptr + count);
    }

    return TRUE;
}

/*
 * Follow a LIST_ENTRY list beginning with a head at dwListHeadAddr in the debugee's
 * address space.  For each element in the list, print out the pointer value at 'offset'
 */
BOOL
PrintListEntryList( IN ULONG_PTR dwListHeadAddr, IN LONG offset )
{
    LIST_ENTRY    ListEntry;
    ULONG i=0;
    BOOL retval = TRUE;
    ULONG count = 20;

    if( !wGetData_srv( &ListEntry, dwListHeadAddr, sizeof( ListEntry ), "LIST_ENTRY" ) )
        return FALSE;

    while( count-- ) {

        if( (ULONG_PTR)ListEntry.Flink == dwListHeadAddr || (ULONG_PTR)ListEntry.Flink == 0 )
            break;

        if( !wGetData_srv( &ListEntry, (ULONG_PTR)ListEntry.Flink, sizeof( ListEntry ), "ListEntry" ) ) {
            retval = FALSE;
            break;
        }

        dprintf( "%16X%s", (LONG)ListEntry.Flink + offset, (i && !(i&3)) ? "\n" : "" );
        i++;
    }


    if( count == 0 && (ULONG_PTR)ListEntry.Flink != dwListHeadAddr && ListEntry.Flink ) {
        dprintf( "\nTruncated list dump\n" );

    } else if( ! ( i && !(i&3) ) ) {
        dprintf( "\n" );
    }

    return retval;
}
#endif

/*
 * Print out a single HEX character
 */
VOID
wPrintHexChar( IN UCHAR c )
{
    dprintf( "%c%c", "0123456789abcdef"[ (c>>4)&0xf ], "0123456789abcdef"[ c&0xf ] );
}

/*
 * Print out 'buf' of 'cbuf' bytes as HEX characters
 */
VOID
wPrintHexBuf( IN PUCHAR buf, IN ULONG cbuf )
{
    while( cbuf-- ) {
        wPrintHexChar( *buf++ );
        dprintf( " " );
    }
}

#if 0
/*
 * Fetch the null terminated UNICODE string at dwAddress into buf
 */
BOOL
GetString( IN ULONG_PTR dwAddress, IN LPWSTR buf, IN ULONG MaxChars )
{
    do {
        if( !wGetData_srv( buf, dwAddress, sizeof( *buf ), "UNICODE Character" ) )
            return FALSE;

        dwAddress += sizeof( *buf );

    } while( --MaxChars && *buf++ != '\0' );

    return TRUE;
}
#endif

VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ExtensionApis = *lpExtensionApis;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;
    ChkTarget = SavedMajorVersion == 0x0c ? TRUE : FALSE;
}


VOID
CheckVersion(
    VOID
    )
{
#if DBG
    if ((SavedMajorVersion != 0x0c) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Checked) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#else
    if ((SavedMajorVersion != 0x0f) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Free) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#endif
}

LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    return &ApiVersion;
}


ULONG FieldOffsetOfContextListEntryInRxC();
VOID  ReadRxContextFields(ULONG_PTR RxContext,PULONG_PTR pFcb,PULONG_PTR pThread, PULONG_PTR pMiniCtx2);
DECLARE_API( dump );



HANDLE DumpFile;
CHAR wwDumpFormat[] = "-%06d:  %s\n";
VOID DumpRoutine(
    ULONG EntryNumber,
    PSZ   OriginalStringToPrint
    )
{
    UCHAR Buffer[200];
    UCHAR StringToPrint[160];
    PUCHAR p,q,r; LONG i;
    ULONG n,l3,l2,l1,l0; UCHAR Numbuf[32];
    ULONG ReturnedSize;

    //dprintf("before %d\n",EntryNumber);
    for (p=OriginalStringToPrint,q=StringToPrint,i=160;;) {
        PSZ format=NULL;

        if (*p==0) break;

        if (*p==0x4) {
            format = "%lx";
        } else if (*p==0x5) {
            format = "%ld";
        } else if (*p < ' ') {
            p++;i--;continue;
        }

        if (format!=NULL) {
            LONG Length;
            //translate the number
            p++;
            l0=*p++;
            l1=(*p++)<<8;
            l2=(*p++)<<16;
            l3=(*p++)<<24;
            n = l0 + l1 + l2 + l3;
            //dprintf("yaya %d %08lx %08lx %08lx %08lx %08lx\n",n,n,l0,l1,l2,l3);
            Length = sprintf(Numbuf,format,n);
            if (Length <= i) {
                for (r=Numbuf;*r;) { *q++ = *r++; }
                i -= Length;
            } else {
                i = 0;
            }
            if (i>0) continue;
        }
        if (i<=0) break;
        *q++ = *p++; i--;
    }
    *q = 0;

    //dprintf("after %d\n",EntryNumber);
    if (DumpFile == INVALID_HANDLE_VALUE) {
        dprintf(wwDumpFormat,EntryNumber,StringToPrint);
        return;
    }
    sprintf(Buffer,wwDumpFormat,EntryNumber,StringToPrint);
    WriteFile(DumpFile,Buffer,strlen(Buffer),&ReturnedSize,NULL);
    //should i check??
    return;
}




PCWSTR   ExtensionLib   = NULL;
HANDLE   hExtensionMod  = NULL;
ULONG    DebugeeArchitecture = 0;

PCWSTR   GetExtensionLibPerDebugeeArchitecture(ULONG DebugeeArchitecture);


DECLARE_API( dump );

DECLARE_API( flags )
{
    ULONG i,mask,newline,value;

    if( args && *args ) {
        sscanf(args,"%lx",&value);
        dprintf("Flags for %08lx\n",value);
    } else {
        dprintf("error in flags: no value presented\n");
        return;
    }

    for (i=newline=0,mask=1;i<32;i++,mask<<=1) {
        if (value&mask) {
            dprintf("    %02d 0x%08lx%c",i,mask,(newline==0)?' ':'\n');
            newline ^= 1;
        }
    }
    if (newline) {
        dprintf("\n");
    }
}

VOID dprintfsprintfbuffer(BYTE *Buffer)
{
    dprintf("%s\n",Buffer);
}

BOOL
wPrintLargeInt(
    LARGE_INTEGER *bigint)
{
    dprintf( "%08x:%08x", bigint->HighPart, bigint->LowPart);
    return( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mup\kdext\mupkd.c ===
/*++

Copyright (c) 1990 Microsoft Corporation

Module Name:

    dfskd.c

Abstract:

    Dfs Kernel Debugger extension

Author:

    Milan Shah (milans) 21-Aug-1995

Revision History:

    21-Aug-1995 Milans  Created

--*/


#include <ntos.h>
#include <nturtl.h>
#include "ntverp.h"

#include <windows.h>

#include <wdbgexts.h>

#include <stdlib.h>
#include <string.h>
#include <stdio.h>

#include <windef.h>
#include <tdi.h>
#include <wincred.h>
#include <ntddnfs.h>                             // For communicating with
                                                 // the SMB Rdr
#include <ntddmup.h>                             // For UNC registration


#include <winnetwk.h>                            // For NETRESOURCE def'n

#include <dfsfsctl.h>                            // Dfs FsControl Codes.

#include <lmdfs.h>                               // DFS_INFO_X

#include "nodetype.h"
#include "dfsmrshl.h"
#include "dfsfsctl.h"
#include "pkt.h"
#include "dfsstruc.h"
#include "fcbsup.h"
#include "fsctrl.h"
#include "dnr.h"
#include "lock.h"
#include "mupstruc.h"
#include "mupdata.h"

#include <kdextlib.h>
#include <stdlib.h>
#define PRINTF dprintf

#define FIELD_NAME_LENGTH 30
#define NewLineForFields(FieldNo) \
        ((((FieldNo) % s_NoOfColumns) == 0) ? NewLine : FieldSeparator)
char *NewLine  = "\n";
char *FieldSeparator = " ";


BOOLEAN wGetData( ULONG_PTR dwAddress, PVOID ptr, ULONG size);
BOOL wGetString( ULONG_PTR dwAddress, PSZ buf );
BOOL wPrintStringW( IN LPSTR msg OPTIONAL, IN PUNICODE_STRING pStr, IN BOOL nl );
BOOL wPrintStringA( IN LPSTR msg OPTIONAL, IN PANSI_STRING pStr, IN BOOL nl );
BOOL wPrintLargeInt(LARGE_INTEGER *bigint);

/*
 * Mup global variables.
 *
 */

#define NO_SYMBOLS_MESSAGE      \
    "Unable to get address of Mup!DfsData - do you have symbols?\n"

LPSTR ExtensionNames[] = {
    "Mup debugger extensions",
    0
};

LPSTR Extensions[] = {
    "DfsData - dumps Mup!DfsData",
    "Pkt - dumps the global Pkt",
    "FcbTable - dumps all the Dfs FCBs",
    "VcbList - dumps all the Vcbs & Dfs Device Objects (net used objects)",
    "DrtList - dumps all the Devless Roots (net used objects)",
    "OfflineList - dumps all the Offline Roots",
    "CredList - dumps all the defined Credentials",
    "SpecialTable - dumps the special table",
    "PrefixList - dumps all the mup prefixes",
    "Dump - dump a data structure. Type in 'mupkd.dump' for more info",
    0
};

ENUM_VALUE_DESCRIPTOR DfsMachineStateEnum[] = {
    {DFS_UNKNOWN, "Dfs State Unknown"},
    {DFS_CLIENT, "Dfs Client"},
    {DFS_SERVER, "Dfs Server"},
    {DFS_ROOT_SERVER, "Dfs Root"},
    0
};

/*
 * DFS_DATA
 *
 */

FIELD_DESCRIPTOR DfsDataFields[] = {
    FIELD3(FieldTypeShort,DFS_DATA,NodeTypeCode),
    FIELD3(FieldTypeShort,DFS_DATA,NodeByteSize),
    FIELD3(FieldTypeStruct,DFS_DATA,VcbQueue),
    FIELD3(FieldTypeStruct,DFS_DATA,DeletedVcbQueue),
    FIELD3(FieldTypeStruct,DFS_DATA,DrtQueue),
    FIELD3(FieldTypeStruct,DFS_DATA,Credentials),
    FIELD3(FieldTypeStruct,DFS_DATA,DeletedCredentials),
    FIELD3(FieldTypeStruct,DFS_DATA,OfflineRoots),
    FIELD3(FieldTypePointer,DFS_DATA,DriverObject),
    FIELD3(FieldTypePointer,DFS_DATA,FileSysDeviceObject),
    FIELD3(FieldTypePointer,DFS_DATA,pProvider),
    FIELD3(FieldTypeULong,DFS_DATA,cProvider),
    FIELD3(FieldTypeULong,DFS_DATA,maxProvider),
    FIELD3(FieldTypeStruct,DFS_DATA,Resource),
    FIELD3(FieldTypeStruct,DFS_DATA,DfsLock),
    FIELD3(FieldTypePointer,DFS_DATA,OurProcess),
    FIELD3(FieldTypeUnicodeString,DFS_DATA,LogRootDevName),
    FIELD4(FieldTypeEnum,DFS_DATA,MachineState,DfsMachineStateEnum),
    FIELD3(FieldTypeStruct,DFS_DATA,Pkt),
    FIELD3(FieldTypeStruct,DFS_DATA,PktWritePending),
    FIELD3(FieldTypeStruct,DFS_DATA,PktReferralRequests),
    FIELD3(FieldTypePointer,DFS_DATA,FcbHashTable),
    0
};

/*
 * DFS_PKT
 *
 */

FIELD_DESCRIPTOR DfsPktFields[] = {
    FIELD3(FieldTypeUShort,DFS_PKT,NodeTypeCode),
    FIELD3(FieldTypeUShort,DFS_PKT,NodeByteSize),
    FIELD3(FieldTypeStruct,DFS_PKT,Resource),
    FIELD3(FieldTypeStruct,DFS_PKT,UseCountLock),
    FIELD3(FieldTypeULong,DFS_PKT,EntryCount),
    FIELD3(FieldTypeULong,DFS_PKT,EntryTimeToLive),
    FIELD3(FieldTypeStruct,DFS_PKT,EntryList),
    FIELD3(FieldTypeUnicodeString,DFS_PKT,DCName),
    FIELD3(FieldTypeUnicodeString,DFS_PKT,DomainNameFlat),
    FIELD3(FieldTypeUnicodeString,DFS_PKT,DomainNameDns),
    FIELD3(FieldTypeStruct,DFS_PKT,SpecialTable),
    FIELD3(FieldTypeStruct,DFS_PKT,PrefixTable),
    FIELD3(FieldTypeStruct,DFS_PKT,ShortPrefixTable),
    FIELD3(FieldTypeStruct,DFS_PKT,DSMachineTable),
    0
};


/*
 * DFS_SPECIAL_TABLE
 *
 */
FIELD_DESCRIPTOR DfsSpecialTableFields[] = {
    FIELD3(FieldTypeStruct,DFS_SPECIAL_TABLE,SpecialEntryList),
    FIELD3(FieldTypeULong,DFS_SPECIAL_TABLE,SpecialEntryCount),
    FIELD3(FieldTypeULong,DFS_SPECIAL_TABLE,TimeToLive),
    0
};

/*
 * DFS_PKT_ENTRY
 *
 */

BIT_MASK_DESCRIPTOR PktEntryType[]  = {
    {PKT_ENTRY_TYPE_DFS, "Uplevel Volume"},
    {PKT_ENTRY_TYPE_MACHINE, "Machine Volume"},
    {PKT_ENTRY_TYPE_NONDFS, "Downlevel Volume"},
    {PKT_ENTRY_TYPE_SYSVOL, "Sysvol"},
    {PKT_ENTRY_TYPE_OUTSIDE_MY_DOM, "Inter-Domain Volume"},
    {PKT_ENTRY_TYPE_REFERRAL_SVC, "Referral Service (DC)"},
    {PKT_ENTRY_TYPE_PERMANENT, "Permanent Entry"},
    {PKT_ENTRY_TYPE_LOCAL,"Local Volume"},
    {PKT_ENTRY_TYPE_LOCAL_XPOINT,"Local Exit Point"},
    {PKT_ENTRY_TYPE_OFFLINE,"Offline Volume"},
    0
};

FIELD_DESCRIPTOR DfsPktEntryFields[] = {
    FIELD3(FieldTypeUShort,DFS_PKT_ENTRY,NodeTypeCode),
    FIELD3(FieldTypeUShort,DFS_PKT_ENTRY,NodeByteSize),
    FIELD3(FieldTypeStruct,DFS_PKT_ENTRY,Link),
    FIELD4(FieldTypeDWordBitMask,DFS_PKT_ENTRY,Type,PktEntryType),
    FIELD3(FieldTypeULong,DFS_PKT_ENTRY,USN),
    FIELD3(FieldTypeUnicodeString,DFS_PKT_ENTRY,Id.Prefix),
    FIELD3(FieldTypeUnicodeString,DFS_PKT_ENTRY,Id.ShortPrefix),
    FIELD3(FieldTypeULong,DFS_PKT_ENTRY,Info.ServiceCount),
    FIELD3(FieldTypePointer,DFS_PKT_ENTRY,Info.ServiceList),
    FIELD3(FieldTypeULong,DFS_PKT_ENTRY,ExpireTime),
    FIELD3(FieldTypeULong,DFS_PKT_ENTRY,TimeToLive),
    FIELD3(FieldTypeULong,DFS_PKT_ENTRY,UseCount),
    FIELD3(FieldTypeULong,DFS_PKT_ENTRY,FileOpenCount),
    FIELD3(FieldTypePointer,DFS_PKT_ENTRY,ActiveService),
    FIELD3(FieldTypePointer,DFS_PKT_ENTRY,LocalService),
    FIELD3(FieldTypePointer,DFS_PKT_ENTRY,Superior),
    FIELD3(FieldTypeULong,DFS_PKT_ENTRY,SubordinateCount),
    FIELD3(FieldTypeStruct,DFS_PKT_ENTRY,SubordinateList),
    FIELD3(FieldTypeStruct,DFS_PKT_ENTRY,SiblingLink),
    FIELD3(FieldTypePointer,DFS_PKT_ENTRY,ClosestDC),
    FIELD3(FieldTypeStruct,DFS_PKT_ENTRY,ChildList),
    FIELD3(FieldTypeStruct,DFS_PKT_ENTRY,NextLink),
    FIELD3(FieldTypeStruct,DFS_PKT_ENTRY,PrefixTableEntry),
    0
};

/*
 * DFS_SERVICE
 *
 */

BIT_MASK_DESCRIPTOR ServiceType[] = {
    {DFS_SERVICE_TYPE_MASTER, "Master Svc"},
    {DFS_SERVICE_TYPE_READONLY, "Read-Only Svc"},
    {DFS_SERVICE_TYPE_LOCAL, "Local Svc"},
    {DFS_SERVICE_TYPE_REFERRAL, "Referral Svc"},
    {DFS_SERVICE_TYPE_ACTIVE, "Active Svc"},
    {DFS_SERVICE_TYPE_DOWN_LEVEL, "Down-level Svc"},
    {DFS_SERVICE_TYPE_COSTLIER, "Costlier than previous"},
    {DFS_SERVICE_TYPE_OFFLINE, "Svc Offline"},
    0
};

BIT_MASK_DESCRIPTOR ServiceCapability[] = {
    {PROV_DFS_RDR, "Use Dfs Rdr"},
    {PROV_STRIP_PREFIX, "Strip Prefix (downlevel or local) Svc"},
    0
};


FIELD_DESCRIPTOR DfsServiceFields[] = {
    FIELD4(FieldTypeDWordBitMask,DFS_SERVICE,Type,ServiceType),
    FIELD4(FieldTypeDWordBitMask,DFS_SERVICE,Capability,ServiceCapability),
    FIELD3(FieldTypeULong,DFS_SERVICE,ProviderId),
    FIELD3(FieldTypeUnicodeString,DFS_SERVICE,Name),
    FIELD3(FieldTypePointer,DFS_SERVICE,ConnFile),
    FIELD3(FieldTypePointer,DFS_SERVICE,pProvider),
    FIELD3(FieldTypeUnicodeString,DFS_SERVICE,Address),
    FIELD3(FieldTypePointer,DFS_SERVICE,pMachEntry),
    FIELD3(FieldTypeULong,DFS_SERVICE,Cost),
    0
};

/*
 * DFS_MACHINE_ENTRY
 *
 */

FIELD_DESCRIPTOR DfsMachineEntryFields[] = {
    FIELD3(FieldTypePointer,DFS_MACHINE_ENTRY,pMachine),
    FIELD3(FieldTypeUnicodeString,DFS_MACHINE_ENTRY,MachineName),
    FIELD3(FieldTypeULong,DFS_MACHINE_ENTRY,UseCount),
    FIELD3(FieldTypeULong,DFS_MACHINE_ENTRY,ConnectionCount),
    FIELD3(FieldTypePointer,DFS_MACHINE_ENTRY,AuthConn),
    FIELD3(FieldTypePointer,DFS_MACHINE_ENTRY,Credentials),
    0
};

/*
 * DFS_SPECIAL_ENTRY
 *
 */

FIELD_DESCRIPTOR DfsSpecialEntryFields[] = {
    FIELD3(FieldTypeShort,DFS_SPECIAL_ENTRY,NodeTypeCode),
    FIELD3(FieldTypeShort,DFS_SPECIAL_ENTRY,NodeByteSize),
    FIELD3(FieldTypeStruct,DFS_SPECIAL_ENTRY,Link),
    FIELD3(FieldTypeULong,DFS_SPECIAL_ENTRY,USN),
    FIELD3(FieldTypeULong,DFS_SPECIAL_ENTRY,UseCount),
    FIELD3(FieldTypeUnicodeString,DFS_SPECIAL_ENTRY,SpecialName),
    FIELD3(FieldTypeULong,DFS_SPECIAL_ENTRY,ExpandedCount),
    FIELD3(FieldTypeULong,DFS_SPECIAL_ENTRY,Active),
    FIELD3(FieldTypePointer,DFS_SPECIAL_ENTRY,ExpandedNames),
    FIELD3(FieldTypeBoolean,DFS_SPECIAL_ENTRY,NeedsExpansion),
    FIELD3(FieldTypeBoolean,DFS_SPECIAL_ENTRY,Stale),
    0
};

/*
 * DFS_EXPANDED_NAME
 *
 */

FIELD_DESCRIPTOR DfsExpandedNameFields[] = {
    FIELD3(FieldTypeUnicodeString,DFS_EXPANDED_NAME,ExpandedName),
    FIELD3(FieldTypeStruct,DFS_EXPANDED_NAME,Guid),
    0
};

/*
 * DS_MACHINE
 *
 */

FIELD_DESCRIPTOR DsMachineFields[] = {
    FIELD3(FieldTypeGuid,DS_MACHINE,guidSite),
    FIELD3(FieldTypeGuid,DS_MACHINE,guidMachine),
    FIELD3(FieldTypeULong,DS_MACHINE,grfFlags),
    FIELD3(FieldTypePWStr,DS_MACHINE,pwszShareName),
    FIELD3(FieldTypeULong,DS_MACHINE,cPrincipals),
    FIELD3(FieldTypePointer,DS_MACHINE,prgpwszPrincipals),
    FIELD3(FieldTypeULong,DS_MACHINE,cTransports),
    FIELD3(FieldTypeStruct,DS_MACHINE,rpTrans),
    0
};

/*
 * PROVIDER_DEF
 *
 */

FIELD_DESCRIPTOR ProviderDefFields[] = {
    FIELD3(FieldTypeUShort,PROVIDER_DEF,NodeTypeCode),
    FIELD3(FieldTypeUShort,PROVIDER_DEF,NodeByteSize),
    FIELD3(FieldTypeUShort,PROVIDER_DEF,eProviderId),
    FIELD4(FieldTypeDWordBitMask,PROVIDER_DEF,fProvCapability,ServiceCapability),
    FIELD3(FieldTypeUnicodeString,PROVIDER_DEF,DeviceName),
    FIELD3(FieldTypePointer,PROVIDER_DEF,DeviceObject),
    FIELD3(FieldTypePointer,PROVIDER_DEF,FileObject),
    0
};

/*
 * DFS_PREFIX_TABLE
 *
 */

FIELD_DESCRIPTOR DfsPrefixTableFields[] = {
    FIELD3(FieldTypeBoolean,DFS_PREFIX_TABLE,CaseSensitive),
    FIELD3(FieldTypePointer,DFS_PREFIX_TABLE,NamePageList.pFirstPage),
    FIELD3(FieldTypePointer,DFS_PREFIX_TABLE,NextEntry),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,RootEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[0].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[0].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[1].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[1].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[2].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[2].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[3].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[3].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[4].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[4].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[5].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[5].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[6].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[6].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[7].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[7].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[8].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[8].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[9].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[9].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[10].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[10].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[11].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[11].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[12].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[12].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[13].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[13].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[14].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[14].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[15].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[15].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[16].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[16].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[17].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[17].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[18].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[18].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[19].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[19].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[20].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[20].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[21].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[21].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[22].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[22].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[23].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[23].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[24].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[24].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[25].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[25].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[26].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[26].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[27].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[27].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[28].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[28].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[29].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[29].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[30].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[30].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[31].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[31].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[32].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[32].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[33].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[33].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[34].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[34].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[35].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[35].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[36].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[36].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[37].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[37].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[38].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[38].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[39].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[39].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[40].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[40].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[41].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[41].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[42].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[42].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[43].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[43].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[44].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[44].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[45].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[45].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[46].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[46].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[47].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[47].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[48].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[48].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[49].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[49].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[50].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[50].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[51].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[51].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[52].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[52].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[53].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[53].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[54].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[54].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[55].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[55].SentinelEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE,Buckets[56].NoOfEntries),
    FIELD3(FieldTypeStruct,DFS_PREFIX_TABLE,Buckets[56].SentinelEntry),
    0
};

/*
 * DFS_PREFIX_TABLE_ENTRY
 *
 */

FIELD_DESCRIPTOR DfsPrefixTableEntryFields[] = {
    FIELD3(FieldTypePointer,DFS_PREFIX_TABLE_ENTRY,pParentEntry),
    FIELD3(FieldTypePointer,DFS_PREFIX_TABLE_ENTRY,pNextEntry),
    FIELD3(FieldTypePointer,DFS_PREFIX_TABLE_ENTRY,pPrevEntry),
    FIELD3(FieldTypePointer,DFS_PREFIX_TABLE_ENTRY,pFirstChildEntry),
    FIELD3(FieldTypePointer,DFS_PREFIX_TABLE_ENTRY,pSiblingEntry),
    FIELD3(FieldTypeULong,DFS_PREFIX_TABLE_ENTRY,NoOfChildren),
    FIELD3(FieldTypeUnicodeString,DFS_PREFIX_TABLE_ENTRY,PathSegment),
    FIELD3(FieldTypePointer,DFS_PREFIX_TABLE_ENTRY,pData),
    0
};


/*
 * DFS_FCB
 *
 */

FIELD_DESCRIPTOR FcbFields[] = {
    FIELD3(FieldTypeUShort, DFS_FCB, NodeTypeCode),
    FIELD3(FieldTypeUShort, DFS_FCB, NodeByteSize),
    FIELD3(FieldTypePointer, DFS_FCB, Vcb),
    FIELD3(FieldTypeUnicodeString, DFS_FCB, FullFileName),
    FIELD3(FieldTypePointer, DFS_FCB, FileObject),
    FIELD3(FieldTypePointer, DFS_FCB, TargetDevice),
    FIELD3(FieldTypePointer, DFS_FCB, DfsMachineEntry),
    0
};

/*
 * DFS_VCB
 *
 */

BIT_MASK_DESCRIPTOR VcbStateFlagBits[] = {
    {VCB_STATE_FLAG_LOCKED, "Vcb Locked"},
    {VCB_STATE_FLAG_ALLOC_FCB, "Allocate Fcb"},
    0
};

FIELD_DESCRIPTOR VcbFields[] = {
    FIELD3(FieldTypeUShort,DFS_VCB,NodeTypeCode),
    FIELD3(FieldTypeUShort,DFS_VCB,NodeByteSize),
    FIELD3(FieldTypeStruct,DFS_VCB,VcbLinks),
    FIELD4(FieldTypeDWordBitMask,DFS_VCB,VcbState,VcbStateFlagBits),
    FIELD3(FieldTypeUnicodeString,DFS_VCB,LogicalRoot),
    FIELD3(FieldTypeUnicodeString,DFS_VCB,LogRootPrefix),
    FIELD3(FieldTypePointer,DFS_VCB,Credentials),
    FIELD3(FieldTypeULong,DFS_VCB,DirectAccessOpenCount),
    FIELD3(FieldTypeStruct,DFS_VCB,ShareAccess),
    FIELD3(FieldTypeULong,DFS_VCB,OpenFileCount),
    FIELD3(FieldTypePointer,DFS_VCB,FileObjectWithVcbLocked),
#ifdef TERMSRV
    FIELD3(FieldTypeULong,DFS_VCB,SessionID),
#endif // TERMSRV
    FIELD3(FieldTypeULong,DFS_VCB,LogonID),
    0
};

FIELD_DESCRIPTOR DrtFields[] = {
    FIELD3(FieldTypeUShort,DFS_DEVLESS_ROOT,NodeTypeCode),
    FIELD3(FieldTypeUShort,DFS_DEVLESS_ROOT,NodeByteSize),
    FIELD3(FieldTypeStruct,DFS_DEVLESS_ROOT,DrtLinks),
    FIELD3(FieldTypeUnicodeString,DFS_DEVLESS_ROOT,DevlessPath),
    FIELD3(FieldTypePointer,DFS_DEVLESS_ROOT,Credentials),
#ifdef TERMSRV
    FIELD3(FieldTypeULong,DFS_DEVLESS_ROOT,SessionID),
#endif // TERMSRV
    FIELD3(FieldTypeULong,DFS_DEVLESS_ROOT,LogonID),
    0
};

FIELD_DESCRIPTOR OfflineRootFields[] = {
    FIELD3(FieldTypeUnicodeString,DFS_OFFLINE_SERVER,LogicalServerName),
    FIELD3(FieldTypeStruct,DFS_OFFLINE_SERVER,ListEntry),
    0
};


FIELD_DESCRIPTOR KnownPrefixFields[] = {
    FIELD3(FieldTypeULong,KNOWN_PREFIX,BlockHeader.ReferenceCount),
    FIELD3(FieldTypeStruct,KNOWN_PREFIX,TableEntry),
    FIELD3(FieldTypeUnicodeString,KNOWN_PREFIX,Prefix),
    FIELD3(FieldTypeStruct,KNOWN_PREFIX,LastUsedTime),
    FIELD3(FieldTypeLargeInteger,KNOWN_PREFIX,LastUsedTime),
    FIELD3(FieldTypePointer,KNOWN_PREFIX,UncProvider),
    FIELD3(FieldTypeBoolean,KNOWN_PREFIX,InTable),
    FIELD3(FieldTypeBoolean,KNOWN_PREFIX,Active),
    0
};


FIELD_DESCRIPTOR UncProviderFields[] = {
    FIELD3(FieldTypeULong,UNC_PROVIDER,BlockHeader.ReferenceCount),
    FIELD3(FieldTypeUnicodeString,UNC_PROVIDER,DeviceName),
    FIELD3(FieldTypeStruct,UNC_PROVIDER,Handle),
    FIELD3(FieldTypePointer,UNC_PROVIDER,DeviceObject),
    FIELD3(FieldTypePointer,UNC_PROVIDER,FileObject),
    FIELD3(FieldTypeULong,UNC_PROVIDER,Priority),
    FIELD3(FieldTypeBoolean,UNC_PROVIDER,MailslotsSupported),
    0
};

/*
 * DFS_CREDENTIALS
 *
 */

FIELD_DESCRIPTOR CredentialsFields[] = {
     FIELD3(FieldTypeStruct,DFS_CREDENTIALS,Link),
     FIELD3(FieldTypeULong,DFS_CREDENTIALS,Flags),
     FIELD3(FieldTypeULong,DFS_CREDENTIALS,RefCount),
     FIELD3(FieldTypeULong,DFS_CREDENTIALS,NetUseCount),
     FIELD3(FieldTypeUnicodeString,DFS_CREDENTIALS,ServerName),
     FIELD3(FieldTypeUnicodeString,DFS_CREDENTIALS,ShareName),
     FIELD3(FieldTypeUnicodeString,DFS_CREDENTIALS,DomainName),
     FIELD3(FieldTypeUnicodeString,DFS_CREDENTIALS,UserName),
     FIELD3(FieldTypeUnicodeString,DFS_CREDENTIALS,Password),
#ifdef TERMSRV
     FIELD3(FieldTypeULong,DFS_CREDENTIALS,SessionID),
#endif // TERMSRV
     FIELD3(FieldTypeULong,DFS_CREDENTIALS,LogonID),
     FIELD3(FieldTypeULong,DFS_CREDENTIALS, EaLength),
     FIELD3(FieldTypeStruct,DFS_CREDENTIALS,EaBuffer),
     0
};

/*
 * DNR_CONTEXT
 *
 */

ENUM_VALUE_DESCRIPTOR DnrStateEnum[] = {
    {DnrStateEnter, "DNR State Enter"},
    {DnrStateStart, "DNR State Start"},
    {DnrStateGetFirstDC, "DNR State GetFirstDC"},
    {DnrStateGetReferrals, "DNR State GetReferrals"},
    {DnrStateGetNextDC, "DNR State GetNextDC"},
    {DnrStateCompleteReferral, "DNR State CompleteReferral"},
    {DnrStateSendRequest, "DNR State SendRequest"},
    {DnrStatePostProcessOpen, "DNR State PostProcessOpen"},
    {DnrStateGetFirstReplica, "DNR State GetFirstReplica"},
    {DnrStateGetNextReplica, "DNR State GetNextReplica"},
    {DnrStateSvcListCheck, "DNR State SvcListCheck"},
    {DnrStateDone, "DNR State Done"},
    {DnrStateLocalCompletion, "DNR State LocalCompletion"},
    0
};

FIELD_DESCRIPTOR DnrContextFields[] = {
    FIELD3(FieldTypeUShort, DNR_CONTEXT, NodeTypeCode),
    FIELD3(FieldTypeUShort, DNR_CONTEXT, NodeByteSize),
    FIELD4(FieldTypeEnum, DNR_CONTEXT, State, DnrStateEnum),
    FIELD3(FieldTypeStruct,DNR_CONTEXT,SecurityContext),
    FIELD3(FieldTypePointer,DNR_CONTEXT,pPktEntry),
    FIELD3(FieldTypeULong,DNR_CONTEXT,USN),
    FIELD3(FieldTypePointer,DNR_CONTEXT,pService),
    FIELD3(FieldTypePointer,DNR_CONTEXT,pProvider),
    FIELD3(FieldTypeUShort,DNR_CONTEXT,ProviderId),
    FIELD3(FieldTypePointer,DNR_CONTEXT,TargetDevice),
    FIELD3(FieldTypePointer,DNR_CONTEXT,AuthConn),
    FIELD3(FieldTypePointer,DNR_CONTEXT,DCConnFile),
    FIELD3(FieldTypePointer,DNR_CONTEXT,Credentials),
    FIELD3(FieldTypePointer,DNR_CONTEXT,pIrpContext),
    FIELD3(FieldTypePointer,DNR_CONTEXT,OriginalIrp),
    FIELD3(FieldTypeULong,DNR_CONTEXT,FinalStatus),
    FIELD3(FieldTypePointer,DNR_CONTEXT,FcbToUse),
    FIELD3(FieldTypePointer,DNR_CONTEXT,Vcb),
    FIELD3(FieldTypeUnicodeString,DNR_CONTEXT,FileName),
    FIELD3(FieldTypeUnicodeString,DNR_CONTEXT,RemainingPart),
    FIELD3(FieldTypeUnicodeString,DNR_CONTEXT,SavedFileName),
    FIELD3(FieldTypePointer,DNR_CONTEXT,SavedRelatedFileObject),
    FIELD3(FieldTypeStruct,DNR_CONTEXT,RSelectContext),
    FIELD3(FieldTypeStruct,DNR_CONTEXT,RDCSelectContext),
    FIELD3(FieldTypeULong,DNR_CONTEXT,ReferralSize),
    FIELD3(FieldTypeULong,DNR_CONTEXT,Attempts),
    FIELD3(FieldTypeBoolean,DNR_CONTEXT,ReleasePkt),
    FIELD3(FieldTypeBoolean,DNR_CONTEXT,DnrActive),
    FIELD3(FieldTypeBoolean,DNR_CONTEXT,GotReferral),
    FIELD3(FieldTypeBoolean,DNR_CONTEXT,FoundInconsistency),
    FIELD3(FieldTypeBoolean,DNR_CONTEXT,CalledDCLocator),
    FIELD3(FieldTypeBoolean,DNR_CONTEXT,Impersonate),
    FIELD3(FieldTypeBoolean,DNR_CONTEXT,NameAllocated),
    FIELD3(FieldTypePointer,DNR_CONTEXT,DeviceObject),
    0
};

/*
 * REPL_SELECT_CONTEXT
 *
 */

BIT_MASK_DESCRIPTOR ReplSelectFlagBits[] = {
    {REPL_UNINITIALIZED, "Uninitialized Context"},
    {REPL_SVC_IS_LOCAL, "Local Svc Selected"},
    {REPL_SVC_IS_REMOTE, "Remote Svc Selected"},
    {REPL_PRINCIPAL_SPECD, "Svc Principal Specified"},
    {REPL_NO_MORE_ENTRIES, "Svc List Exhausted"},
    0
};

FIELD_DESCRIPTOR ReplSelectContextFields[] = {
    FIELD4(FieldTypeWordBitMask,REPL_SELECT_CONTEXT,Flags,ReplSelectFlagBits),
    FIELD3(FieldTypeULong,REPL_SELECT_CONTEXT,iFirstSvcIndex),
    FIELD3(FieldTypeULong,REPL_SELECT_CONTEXT,iSvcIndex),
    0
};


STRUCT_DESCRIPTOR Structs[] = {
    STRUCT(DFS_DATA,DfsDataFields),
    STRUCT(DFS_PKT,DfsPktFields),
    STRUCT(DFS_PKT_ENTRY,DfsPktEntryFields),
    STRUCT(DFS_SERVICE,DfsServiceFields),
    STRUCT(DFS_MACHINE_ENTRY,DfsMachineEntryFields),
    STRUCT(DS_MACHINE,DsMachineFields),
    STRUCT(DFS_SPECIAL_ENTRY,DfsSpecialEntryFields),
    STRUCT(DFS_SPECIAL_TABLE,DfsSpecialTableFields),
    STRUCT(DFS_EXPANDED_NAME,DfsExpandedNameFields),
    STRUCT(PROVIDER_DEF,ProviderDefFields),
    STRUCT(DFS_FCB,FcbFields),
    STRUCT(DNR_CONTEXT,DnrContextFields),
    STRUCT(DFS_VCB,VcbFields),
    STRUCT(DFS_DEVLESS_ROOT,DrtFields),
    STRUCT(DFS_OFFLINE_SERVER,OfflineRootFields),
    STRUCT(DFS_CREDENTIALS,CredentialsFields),
    STRUCT(DFS_PREFIX_TABLE,DfsPrefixTableFields),
    STRUCT(DFS_PREFIX_TABLE_ENTRY,DfsPrefixTableEntryFields),
    STRUCT(KNOWN_PREFIX,KnownPrefixFields),
    STRUCT(UNC_PROVIDER,UncProviderFields),
    0
};

/*
 * Dfs specific dump routines
 *
 */


VOID
dumplist(
    ULONG_PTR dwListEntryAddress,
    DWORD linkOffset,
    VOID (*dumpRoutine)(ULONG_PTR dwStructAddress)
);

VOID
dumpPktEntry(
    ULONG_PTR dwAddress
);

VOID
dumpFcb(
    ULONG_PTR dwAddress
);

VOID
dumpVcb(
    ULONG_PTR dwAddress
);

VOID
dumpDrt(
    ULONG_PTR dwAddress
);

VOID
dumpOfflineRoots(
    ULONG_PTR dwAddress
);

VOID
dumpPrefix(
    ULONG_PTR dwAddress
);

VOID
dumpCredentials(
     ULONG_PTR dwAddress
);

BOOL
dumpspecialtable(
     ULONG_PTR dwAddress
);

VOID
dumpspecialentry(
    ULONG_PTR dwAddress
);

/*
 * dfsdata : Routine to dump the global dfs data structure
 *
 */

BOOL
dfsdata(
    ULONG_PTR                  dwCurrentPC,
    PWINDBG_EXTENSION_APIS    lpExtensionApis,
    LPSTR                   lpArgumentString
)
{
    ULONG_PTR dwAddress;

    // SETCALLBACKS();

    dwAddress = (GetExpression)("Mup!DfsData");

    if (dwAddress) {
        DFS_DATA DfsData;

        if (wGetData( dwAddress, &DfsData, sizeof(DfsData) )) {
            PrintStructFields( dwAddress, &DfsData, DfsDataFields);
        } else {
            PRINTF( "Unable to read DfsData @ %08lx\n", dwAddress );
        }
    } else {
        PRINTF( NO_SYMBOLS_MESSAGE );
    }

    return( TRUE );

}

/*
 * pkt : Routine to dump the Dfs PKT data structure
 *
 */

BOOL
pkt(
    ULONG_PTR                  dwCurrentPC,
    PWINDBG_EXTENSION_APIS    lpExtensionApis,
    LPSTR                   lpArgumentString
)
{
    ULONG_PTR dwAddress;

    //    SETCALLBACKS();

    //
    // Figure out the address of the Pkt. This is an offset within
    // Mup!DfsData.
    //

    dwAddress = (GetExpression)("Mup!DfsData");

    if (dwAddress) {
        DFS_PKT pkt;

        dwAddress += FIELD_OFFSET(DFS_DATA, Pkt);

        if (wGetData(dwAddress,&pkt,sizeof(pkt))) {
            PrintStructFields( dwAddress, &pkt, DfsPktFields );
            dwAddress += FIELD_OFFSET(DFS_PKT, EntryList);
            dumplist(
                dwAddress,
                FIELD_OFFSET(DFS_PKT_ENTRY,Link),
                dumpPktEntry);
        }
    } else {
        PRINTF( NO_SYMBOLS_MESSAGE );
    }

    return( TRUE );

}

/*
 * specialtable : Routine to dump out the special table
 *
 */

BOOL
specialtable(
    ULONG_PTR                 dwCurrentPC,
    PWINDBG_EXTENSION_APIS    lpExtensionApis,
    LPSTR                   lpArgumentString)
{
    ULONG i;
    ULONG_PTR dwAddress;

    //   SETCALLBACKS();

    //
    // Figure out the address of the Pkt. This is an offset within
    // dfs!DfsData.
    //

    dwAddress = (GetExpression)("Mup!DfsData");

    if (dwAddress) {

        dwAddress += FIELD_OFFSET(DFS_DATA, Pkt.SpecialTable);
        PRINTF("SpecialTable@0x%x\n", dwAddress);
        return dumpspecialtable(dwAddress);
    } else {
        PRINTF( NO_SYMBOLS_MESSAGE );
    }
    return(TRUE);
}

/*
 * dumpPktEntry : Routine suitable as argument for dumplist; used to dump
 *      list of pkt entries.
 *
 */

VOID
dumpPktEntry(
    ULONG_PTR dwAddress
)
{
    DFS_PKT_ENTRY pktEntry;

    if (wGetData(dwAddress, &pktEntry, sizeof(DFS_PKT_ENTRY))) {

        PRINTF("\n--- Pkt Entry @ %08lx\n", dwAddress);

        wPrintStringW("Prefix : ", &pktEntry.Id.Prefix, TRUE);
        wPrintStringW("ShortPrefix : ", &pktEntry.Id.ShortPrefix, TRUE);

        //
        // Print the local service, if any
        //
        if (pktEntry.LocalService != NULL) {
            DFS_SERVICE Svc;

            PRINTF( "    Local Svc @%08lx : ",pktEntry.LocalService);
            if (wGetData( (ULONG_PTR)pktEntry.LocalService, &Svc, sizeof(Svc))) {
                wPrintStringW("Storage Id = ", &Svc.Address, TRUE);
            } else {
                PRINTF("Storage Id = ?\n");
            }
        }

        //
        // Now, print the service list
        //
        if (pktEntry.Info.ServiceCount != 0) {
            ULONG i;

            for (i = 0; i < pktEntry.Info.ServiceCount; i++) {
                DFS_SERVICE Svc;
                ULONG_PTR dwServiceAddress;

                if (CheckControlC())
                    return;
                dwServiceAddress = 
                    (ULONG_PTR)(pktEntry.Info.ServiceList) +
                        i * sizeof(DFS_SERVICE);
                PRINTF( "    Service %d @%08lx : ",i, dwServiceAddress);
                if (wGetData(dwServiceAddress, &Svc, sizeof(Svc))) {
                    wPrintStringW( "Address =", &Svc.Address, TRUE );
                } else {
                    PRINTF("Address = ?\n");
                }
            }
        }
    } else {
        PRINTF("Unable to get Pkt Entry @%08lx\n", dwAddress);
    }

}

BOOL
dumpspecialtable(
    ULONG_PTR dwAddress)
{
    ULONG i;
    DFS_SPECIAL_TABLE SpecialTable;
    LIST_ENTRY ListEntry;

    if (wGetData(dwAddress,&SpecialTable,sizeof(DFS_SPECIAL_TABLE))) {
        ULONG nEntries = SpecialTable.SpecialEntryCount;
        PRINTF("\n--- Special Table @ %08lx\n", dwAddress);
        PrintStructFields( dwAddress, &SpecialTable, DfsSpecialTableFields );

        dwAddress += FIELD_OFFSET(DFS_SPECIAL_TABLE, SpecialEntryList);
        dumplist(
            dwAddress,
            FIELD_OFFSET(DFS_SPECIAL_ENTRY,Link),
            dumpspecialentry);
    } else {
        PRINTF( NO_SYMBOLS_MESSAGE );
    }
    return TRUE;
}

/*
 * dumpspecialentry : Routine suitable as argument to dumplist; used to dump list of
 *      special entries
 *
 */

VOID
dumpspecialentry(
    ULONG_PTR dwAddress
)
{
    ULONG_PTR dwName;
    ULONG i;
    DFS_EXPANDED_NAME ExpName;
    DFS_SPECIAL_ENTRY specialentry;

    if (wGetData( dwAddress, &specialentry, sizeof(specialentry))) {
        PRINTF("\ndfs_special_entry @ %08lx\n", dwAddress);
        PrintStructFields( dwAddress, &specialentry, DfsSpecialEntryFields );
        dwName = (ULONG_PTR) specialentry.ExpandedNames;
        for (i = 0; i < specialentry.ExpandedCount; i++) {
            if (CheckControlC())
                return;
            wGetData(dwName, &ExpName, sizeof(DFS_EXPANDED_NAME));
            wPrintStringW("\t\tName:", &ExpName.ExpandedName, TRUE);
            dwName += sizeof(DFS_EXPANDED_NAME);
        }
    } else {
        PRINTF("\nUnable to read specialentry @ %08lx\n", dwAddress);
    }
}


/*
 * prefixhash : Routine to compute hash of path component
 *
 */

BOOL
prefixhash(
    ULONG_PTR                   dwCurrentPC,
    PWINDBG_EXTENSION_APIS    lpExtensionApis,
    LPSTR                   lpArgumentString
)
{
    DWORD BucketNo = 0;
    LPSTR lpPath;

    //    SETCALLBACKS();

    if ((lpArgumentString == NULL) || (*lpArgumentString == 0)) {
        PRINTF("Usage: prefixhash <path-component>\n");
    } else {

        lpPath = lpArgumentString;

        while (*lpPath != 0)
        {
            WCHAR wc;

            wc = (*lpPath < 'a')
                           ? (WCHAR) *lpPath
                           : ((*lpPath < 'z')
                              ? (WCHAR) (*lpPath - 'a' + 'A')
                              : (WCHAR) *lpPath);
            BucketNo *= 131;
            BucketNo += wc;

            lpPath++;

        }

        BucketNo = BucketNo % NO_OF_HASH_BUCKETS;

        PRINTF("Hash for <%s> is %d\n", lpArgumentString, BucketNo);

    }

    return( TRUE );
}

/*
 * fcbtable : Routine to dump the dfs fcb hash table
 *
 */

BOOL
fcbtable(
    ULONG_PTR                   dwCurrentPC,
    PWINDBG_EXTENSION_APIS    lpExtensionApis,
    LPSTR                   lpArgumentString
)
{
    ULONG_PTR dwAddress;

    //    SETCALLBACKS();

    //
    // Figure out the address of the Pkt. This is an offset withing
    // Mup!DfsData.
    //

    dwAddress = (GetExpression)("Mup!DfsData");

    if (dwAddress) {
        DFS_DATA DfsData;

        if (wGetData(dwAddress, &DfsData, sizeof(DFS_DATA))) {
            FCB_HASH_TABLE FcbTable;
            dwAddress = (ULONG_PTR) DfsData.FcbHashTable;
            if (wGetData(dwAddress, &FcbTable, sizeof(FCB_HASH_TABLE))) {
                ULONG i, cBuckets;
                ULONG_PTR dwListHeadAddress;
                cBuckets = FcbTable.HashMask + 1;
                dwListHeadAddress =
                    dwAddress + FIELD_OFFSET(FCB_HASH_TABLE, HashBuckets);
                PRINTF(
                    "+++ Fcb Hash Table @ %08lx (%d Buckets) +++\n",
                    dwAddress, cBuckets);
                for (i = 0; i < cBuckets; i++) {
                    if (CheckControlC())
                        return TRUE;
                    PRINTF( "--- Bucket(%d)\n", i );
                    dumplist(
                        dwListHeadAddress,
                        FIELD_OFFSET(DFS_FCB, HashChain),
                        dumpFcb);
                    dwListHeadAddress += sizeof(LIST_ENTRY);
                }
                PRINTF("--- Fcb Hash Table @ %08lx ---\n", dwAddress);

            } else {
                PRINTF( "Unable to read FcbTable @%08lx\n", dwAddress );
            }
        } else {
            PRINTF( "Unable to read DfsData @%08lx\n", dwAddress);
        }
    } else {
        PRINTF( NO_SYMBOLS_MESSAGE );
    }
    return( TRUE );
}

/*
 * dumpFcb : Routine suitable as argument to dumplist; used to dump list of
 *      Fcbs
 *
 */

VOID
dumpFcb(
    ULONG_PTR dwAddress
)
{
    DFS_FCB fcb;

    if (wGetData( dwAddress, &fcb, sizeof(fcb))) {
        PRINTF("\nFcb @ %08lx\n", dwAddress);
        PrintStructFields( dwAddress, &fcb, FcbFields );
    } else {
        PRINTF("\nUnable to read Fcb @ %08lx\n", dwAddress);
    }
}

/*
 * vcblist : Routine to dump out all the Dfs VCBs (ie, all the Dfs Device
 *      object descriptors).
 *
 */

BOOL
vcblist(
    ULONG_PTR                   dwCurrentPC,
    PWINDBG_EXTENSION_APIS    lpExtensionApis,
    LPSTR                   lpArgumentString
)
{
    ULONG_PTR dwAddress;

    //    SETCALLBACKS();

    //
    // Figure out the address of the Pkt. This is an offset withing
    // Mup!DfsData.
    //

    dwAddress = (GetExpression)("Mup!DfsData");

    if (dwAddress) {
        dwAddress += FIELD_OFFSET(DFS_DATA, VcbQueue);
        dumplist(
            dwAddress,
            FIELD_OFFSET(DFS_VCB,VcbLinks),
            dumpVcb);
    } else {
        PRINTF( NO_SYMBOLS_MESSAGE );
    }
    return( TRUE );
}


/*
 * prefixlist : Routine to dump out all the mup prefixes
 *
 */

BOOL
prefixlist(
    ULONG_PTR                   dwCurrentPC,
    PWINDBG_EXTENSION_APIS    lpExtensionApis,
    LPSTR                   lpArgumentString
)
{
    ULONG_PTR dwAddress;

    //    SETCALLBACKS();

    //
    // Figure out the address of the Pkt. This is an offset withing
    // Mup!DfsData.
    //

    dwAddress = (GetExpression)("Mup!MupPrefixList");

    if (dwAddress) {
        dumplist(
            dwAddress,
            FIELD_OFFSET(KNOWN_PREFIX,ListEntry),
            dumpPrefix);
    } else {
        PRINTF( NO_SYMBOLS_MESSAGE );
    }
    return( TRUE );
}

/*
 * dumpDeviceObject
 */

void
dumpDeviceObject(
    ULONG_PTR dwAddress)
{
    ULONG_PTR dwTempAddress;
    OBJECT_HEADER obhd;
    OBJECT_HEADER_NAME_INFO obni;

    dwTempAddress = dwAddress - FIELD_OFFSET(OBJECT_HEADER, Body);

    if (wGetData(dwTempAddress, &obhd, sizeof(obhd))) {
        if (obhd.NameInfoOffset != 0) {
            dwTempAddress -= obhd.NameInfoOffset;
            if (wGetData(dwTempAddress, &obni, sizeof(obni))) {
                wPrintStringW(
                    "    Device Name:                   ",
                    &obni.Name,
                    TRUE);
            } else {
                PRINTF("Unable to read Name Info @%08lx\n", dwTempAddress);
            }
        } else {
            PRINTF("\tDevice Name: NULL\n");
        }
    } else {
        PRINTF("Unable to read Object Header @%08lx\n", dwTempAddress);
    }
}

void
dumpVcb(
    ULONG_PTR dwAddress)
{
    ULONG_PTR dwLogicalRootAddress;
    DFS_VCB vcb;

    dwLogicalRootAddress =
        dwAddress - FIELD_OFFSET(LOGICAL_ROOT_DEVICE_OBJECT, Vcb);

    if (wGetData(dwAddress, &vcb, sizeof(vcb))) {
        PRINTF("+++ Vcb @%08lx : Logical Root Device Object @%08lx +++\n",
            dwAddress, dwLogicalRootAddress);
        PrintStructFields(dwAddress, &vcb, VcbFields);
        dumpDeviceObject( dwLogicalRootAddress );
        PRINTF("--- Vcb @%08lx : Logical Root Device Object @%08lx ---\n",
            dwAddress, dwLogicalRootAddress);
    } else {
        PRINTF("Unable to read Vcb @%08lx\n",dwAddress);
    }
}

void
dumpPrefix(
    ULONG_PTR dwAddress)
{
    KNOWN_PREFIX knownprefix;

    if (wGetData(dwAddress, &knownprefix, sizeof(knownprefix))) {
        PRINTF("+++ KnownPrefix @%08lx +++\n", dwAddress);
        PrintStructFields(dwAddress, &knownprefix, KnownPrefixFields);
        PRINTF("+++ KnownPrefix @%08lx +++\n", dwAddress);
    } else {
        PRINTF("Unable to read knownprefix @%08lx\n",dwAddress);
    }
}

/*
 * credList - dump global list of user credentials
 *
 */

BOOL
credlist(
    ULONG_PTR                   dwCurrentPC,
    PWINDBG_EXTENSION_APIS    lpExtensionApis,
    LPSTR                   lpArgumentString
)
{
    ULONG_PTR dwAddress;

    //    SETCALLBACKS();

    //
    // Figure out the address of the Pkt. This is an offset withing
    // Mup!DfsData.
    //

    dwAddress = (GetExpression)("Mup!DfsData");

    if (dwAddress) {
        dwAddress += FIELD_OFFSET(DFS_DATA, Credentials);
        dumplist(
            dwAddress,
            FIELD_OFFSET(DFS_CREDENTIALS,Link),
            dumpCredentials);
    } else {
        PRINTF( NO_SYMBOLS_MESSAGE );
    }
    return( TRUE );
}

/*
 * dumpCredentials : Routine suitable as argument to dumplist; used to dump
 *      a list of DFS_CREDENTIALs.
 */

void
dumpCredentials(
    ULONG_PTR dwAddress)
{
    DFS_CREDENTIALS creds;

    if (wGetData(dwAddress, &creds, sizeof(creds))) {
        PRINTF("+++ Credentials @%08lx +++\n", dwAddress);
        PrintStructFields(dwAddress, &creds, CredentialsFields);
        PRINTF("--- Credentials @%08lx ---\n", dwAddress);
    } else {
        PRINTF("Unable to read Credentials @%08lx\n",dwAddress);
    }
}

/*
 * dumplist : A general-purpose routine to dump a list of structures
 *
 */

VOID
dumplist(
    ULONG_PTR dwListEntryAddress,
    DWORD linkOffset,
    VOID (*dumpRoutine)(ULONG_PTR dwStructAddress)
)
{
    LIST_ENTRY listHead, listNext;

    //
    // Get the value in the LIST_ENTRY at dwAddress
    //

    PRINTF( "Dumping list @ %08lx\n", dwListEntryAddress );

    if (wGetData(dwListEntryAddress, &listHead, sizeof(LIST_ENTRY))) {

        ULONG_PTR dwNextLink = (ULONG_PTR) listHead.Flink;

        if (dwNextLink == 0) {
            PRINTF( "Uninitialized list!\n" );
        } else if (dwNextLink == dwListEntryAddress) {
            PRINTF( "Empty list!\n" );
        } else {
            while( dwNextLink != dwListEntryAddress) {
                ULONG_PTR dwStructAddress;

                if (CheckControlC())
                    return;
                dwStructAddress = dwNextLink - linkOffset;

                dumpRoutine(dwStructAddress);

                if (wGetData( dwNextLink, &listNext, sizeof(LIST_ENTRY))) {
                    dwNextLink = (ULONG_PTR) listNext.Flink;
                } else {
                    PRINTF( "Unable to get next item @%08lx\n", dwNextLink );
                    break;
                }

            }
        }

    } else {

        PRINTF("Unable to read list head @ %08lx\n", dwListEntryAddress);

    }

}

/*
 * drtlist : Routine to dump out all the Dfs Devless Roots
 *
 */

BOOL
drtlist(
    ULONG_PTR                   dwCurrentPC,
    PWINDBG_EXTENSION_APIS    lpExtensionApis,
    LPSTR                   lpArgumentString
)
{
    ULONG_PTR dwAddress;

    //    SETCALLBACKS();

    //
    // Figure out the address of the Pkt. This is an offset withing
    // Mup!DfsData.
    //

    dwAddress = (GetExpression)("Mup!DfsData");

    if (dwAddress) {
        dwAddress += FIELD_OFFSET(DFS_DATA, DrtQueue);
        dumplist(
            dwAddress,
            FIELD_OFFSET(DFS_DEVLESS_ROOT,DrtLinks),
            dumpDrt);
    } else {
        PRINTF( NO_SYMBOLS_MESSAGE );
    }
    return( TRUE );
}


void
dumpDrt(
    ULONG_PTR dwAddress)
{
    DFS_DEVLESS_ROOT drt;

    if (wGetData(dwAddress, &drt, sizeof(drt))) {
        PRINTF("+++ Drt @%08lx :                        +++\n",
	       dwAddress);
        PrintStructFields(dwAddress, &drt, DrtFields);
        PRINTF("--- Drt @%08lx :                        ---\n",
	       dwAddress);
    } else {
        PRINTF("Unable to read Drt @%08lx\n",dwAddress);
    }
}

BOOL
offlinelist(
    ULONG_PTR                   dwCurrentPC,
    PWINDBG_EXTENSION_APIS    lpExtensionApis,
    LPSTR                   lpArgumentString
)
{
    ULONG_PTR dwAddress;

    //    SETCALLBACKS();

    //
    // Figure out the address of the Pkt. This is an offset withing
    // Mup!DfsData.
    //

    dwAddress = (GetExpression)("Mup!DfsData");

    if (dwAddress) {
        dwAddress += FIELD_OFFSET(DFS_DATA, OfflineRoots);
        dumplist(
            dwAddress,
            FIELD_OFFSET(DFS_OFFLINE_SERVER,ListEntry),
            dumpOfflineRoots);
    } else {
        PRINTF( NO_SYMBOLS_MESSAGE );
    }
    return( TRUE );
}

VOID
dumpOfflineRoots(
    ULONG_PTR dwAddress)
{
    DFS_OFFLINE_SERVER srv;

    if (wGetData(dwAddress, &srv, sizeof(srv))) {
        PRINTF("+++ OfflineRoot @%08lx :                        +++\n",
	       dwAddress);
        PrintStructFields(dwAddress, &srv, OfflineRootFields);
        PRINTF("--- Drt @%08lx :                        ---\n",
	       dwAddress);
    } else {
        PRINTF("Unable to read Srv @%08lx\n",dwAddress);
    }
}
     

VOID
PrintStructFields( ULONG_PTR dwAddress, VOID *ptr, FIELD_DESCRIPTOR *pFieldDescriptors )
{
    int i;
    WCHAR wszBuffer[80];

    // Display the fields in the struct.
    for( i=0; pFieldDescriptors->Name; i++, pFieldDescriptors++ ) {

        // Indentation to begin the struct display.
        PRINTF( "    " );

        if( strlen( pFieldDescriptors->Name ) > FIELD_NAME_LENGTH ) {
            PRINTF( "%-17s...%s ", pFieldDescriptors->Name, pFieldDescriptors->Name+strlen(pFieldDescriptors->Name)-10 );
        } else {
            PRINTF( "%-30s ", pFieldDescriptors->Name );
        }

        switch( pFieldDescriptors->FieldType ) {
        case FieldTypeByte:
        case FieldTypeChar:
           PRINTF( "%-16d%s",
               *(BYTE *)(((char *)ptr) + pFieldDescriptors->Offset ),
               NewLineForFields(i) );
           break;
        case FieldTypeBoolean:
           PRINTF( "%-16s%s",
               *(BOOLEAN *)(((char *)ptr) + pFieldDescriptors->Offset ) ? "TRUE" : "FALSE",
               NewLineForFields(i));
           break;
        case FieldTypeBool:
            PRINTF( "%-16s%s",
                *(BOOLEAN *)(((char *)ptr) + pFieldDescriptors->Offset ) ? "TRUE" : "FALSE",
                NewLineForFields(i));
            break;
        case FieldTypePointer:
            PRINTF( "%-16X%s",
                *(ULONG *)(((char *)ptr) + pFieldDescriptors->Offset ),
                NewLineForFields(i) );
            break;
        case FieldTypeULong:
        case FieldTypeLong:
            PRINTF( "%-16d%s",
                *(ULONG *)(((char *)ptr) + pFieldDescriptors->Offset ),
                NewLineForFields(i) );
            break;
        case FieldTypeShort:
            PRINTF( "%-16X%s",
                *(SHORT *)(((char *)ptr) + pFieldDescriptors->Offset ),
                NewLineForFields(i) );
            break;
        case FieldTypeUShort:
            PRINTF( "%-16X%s",
                *(USHORT *)(((char *)ptr) + pFieldDescriptors->Offset ),
                NewLineForFields(i) );
            break;
        case FieldTypeGuid:
            PrintGuid( (GUID *)(((char *)ptr) + pFieldDescriptors->Offset) );
            PRINTF( NewLine );
            break;
        case FieldTypePWStr:
            if (wGetString( (ULONG_PTR)(((char *)ptr) + pFieldDescriptors->Offset), (char *)wszBuffer )) {
                PRINTF( "%ws", wszBuffer );
            } else {
                PRINTF( "Unable to get string at %08lx", (ULONG_PTR)(((char *)ptr) + pFieldDescriptors->Offset));
            }
            PRINTF( NewLine );
            break;
        case FieldTypeUnicodeString:
            wPrintStringW( NULL, (UNICODE_STRING *)(((char *)ptr) + pFieldDescriptors->Offset ), 0 );
            PRINTF( NewLine );
            break;
        case FieldTypeAnsiString:
            wPrintStringA( NULL, (ANSI_STRING *)(((char *)ptr) + pFieldDescriptors->Offset ), 0 );
            PRINTF( NewLine );
            break;
        case FieldTypeSymbol:
            {
                UCHAR SymbolName[ 200 ];
                ULONG Displacement;
                PVOID sym = (PVOID)(*(ULONG *)(((char *)ptr) + pFieldDescriptors->Offset ));

                GetSymbol(sym, SymbolName, (ULONG_PTR *)&Displacement );
                PRINTF( "%-16s%s",
                        SymbolName,
                        NewLineForFields(i) );
            }
            break;
        case FieldTypeEnum:
            {
               ULONG EnumValue;
               ENUM_VALUE_DESCRIPTOR *pEnumValueDescr;
               // Get the associated numerical value.

               EnumValue = *((ULONG *)((BYTE *)ptr + pFieldDescriptors->Offset));

               if ((pEnumValueDescr = pFieldDescriptors->AuxillaryInfo.pEnumValueDescriptor)
                    != NULL) {
                   //
                   // An auxilary textual description of the value is
                   // available. Display it instead of the numerical value.
                   //

                   LPSTR pEnumName = NULL;

                   while (pEnumValueDescr->EnumName != NULL) {
                       if (EnumValue == pEnumValueDescr->EnumValue) {
                           pEnumName = pEnumValueDescr->EnumName;
                           break;
                       }
                       pEnumValueDescr++;
                   }

                   if (pEnumName != NULL) {
                       PRINTF( "%-16s ", pEnumName );
                   } else {
                       PRINTF( "%-4d (%-10s) ", EnumValue,"Unknown!");
                   }

               } else {
                   //
                   // No auxilary information is associated with the ehumerated type
                   // print the numerical value.
                   //
                   PRINTF( "%-16d",EnumValue);
               }
               PRINTF( NewLineForFields(i) );
            }
            break;

        case FieldTypeByteBitMask:
        case FieldTypeWordBitMask:
        case FieldTypeDWordBitMask:
            {
               BOOL fFirstFlag;
               ULONG BitMaskValue;
               BIT_MASK_DESCRIPTOR *pBitMaskDescr;

               BitMaskValue = *((ULONG *)((BYTE *)ptr + pFieldDescriptors->Offset));

               PRINTF("%-8x ", BitMaskValue);
               PRINTF( NewLineForFields(i) );

               pBitMaskDescr = pFieldDescriptors->AuxillaryInfo.pBitMaskDescriptor;
               fFirstFlag = TRUE;
               if (BitMaskValue != 0 && pBitMaskDescr != NULL) {
                   while (pBitMaskDescr->BitmaskName != NULL) {
                       if ((BitMaskValue & pBitMaskDescr->BitmaskValue) != 0) {
                           if (fFirstFlag) {
                               fFirstFlag = FALSE;
                               PRINTF("      ( %-s", pBitMaskDescr->BitmaskName);
                           } else {
                               PRINTF( " |\n" );
                               PRINTF("        %-s", pBitMaskDescr->BitmaskName);

                           }
                       }
                       pBitMaskDescr++;
                   }
                   PRINTF(" )");
                   PRINTF( NewLineForFields(i) );
               }
            }
            break;

        case FieldTypeStruct:
            PRINTF( "@%-15X%s",
                (dwAddress + pFieldDescriptors->Offset ),
                NewLineForFields(i) );
            break;
        case FieldTypeLargeInteger:
            wPrintLargeInt( (LARGE_INTEGER *)(((char *)ptr) + pFieldDescriptors->Offset) );
            PRINTF( NewLine );
            break;
        case FieldTypeFileTime:
        default:
            dprintf( "Unrecognized field type %c for %s\n", pFieldDescriptors->FieldType, pFieldDescriptors->Name );
            break;
        }
    }
}


#define NAME_DELIMITER '@'
#define INVALID_INDEX 0xffffffff
#define MIN(x,y)  ((x) < (y) ? (x) : (y))

ULONG SearchStructs(LPSTR lpArgument)
{
    ULONG             i = 0;
    STRUCT_DESCRIPTOR *pStructs = Structs;
    ULONG             NameIndex = INVALID_INDEX;
    ULONG               ArgumentLength = strlen(lpArgument);
    BOOLEAN           fAmbiguous = FALSE;


    while ((pStructs->StructName != 0)) {
        ULONG StructLength;
        StructLength = strlen(pStructs->StructName);
        if (StructLength >= ArgumentLength) {
            int Result = _strnicmp(
                            lpArgument,
                            pStructs->StructName,
                            ArgumentLength);

            if (Result == 0) {
                if (StructLength == ArgumentLength) {
                    // Exact match. They must mean this struct!
                    fAmbiguous = FALSE;
                    NameIndex = i;
                    break;
                } else if (NameIndex != INVALID_INDEX) {
                    // We have encountered duplicate matches. Print out the
                    // matching strings and let the user disambiguate.
                   fAmbiguous = TRUE;
                   break;
                } else {
                   NameIndex = i;
                }
            }
        }
        pStructs++;i++;
    }

    if (fAmbiguous) {
       PRINTF("Ambigous Name Specification -- The following structs match\n");
       PRINTF("%s\n",Structs[NameIndex].StructName);
       PRINTF("%s\n",Structs[i].StructName);
       while (pStructs->StructName != 0) {
           if (_strnicmp(lpArgument,
                        pStructs->StructName,
                        MIN(strlen(pStructs->StructName),ArgumentLength)) == 0) {
               PRINTF("%s\n",pStructs->StructName);
           }
           pStructs++;
       }
       PRINTF("Dumping Information for %s\n",Structs[NameIndex].StructName);
    }

    return(NameIndex);
}

VOID DisplayStructs()
{
    STRUCT_DESCRIPTOR *pStructs = Structs;

    PRINTF("The following structs are handled .... \n");
    while (pStructs->StructName != 0) {
        PRINTF("\t%s\n",pStructs->StructName);
        pStructs++;
    }
}


#define NAME_DELIMITERS "@"

DECLARE_API( dump )
{
    ULONG_PTR dwAddress;

    //SETCALLBACKS();

    if( args && *args ) {
        // Parse the argument string to determine the structure to be displayed.
        // Scan for the NAME_DELIMITER ( '@' ).

        LPSTR lpName = (PSTR)args;
        LPSTR lpArgs = strpbrk(args, NAME_DELIMITERS);
        ULONG Index;

        if (lpArgs) {
            //
            // The specified command is of the form
            // dump <name>@<address expr.>
            //
            // Locate the matching struct for the given name. In the case
            // of ambiguity we seek user intervention for disambiguation.
            //
            // We do an inplace modification of the argument string to
            // facilitate matching.
            //
            *lpArgs = '\0';

            for (;*lpName==' ';) { lpName++; } //skip leading blanks

            Index = SearchStructs(lpName);

            //
            // Let us restore the original value back.
            //

            *lpArgs = NAME_DELIMITER;

            if (INVALID_INDEX != Index) {
                BYTE DataBuffer[512];

                dwAddress = GetExpression( ++lpArgs );
                if (wGetData(dwAddress,DataBuffer,Structs[Index].StructSize)) {

                    PRINTF(
                        "++++++++++++++++ %s@%lx ++++++++++++++++\n",
                        Structs[Index].StructName,
                        dwAddress);
                    PrintStructFields(
                        dwAddress,
                        &DataBuffer,
                        Structs[Index].FieldDescriptors);
                    PRINTF(
                        "---------------- %s@%lx ----------------\n",
                        Structs[Index].StructName,
                        dwAddress);
                } else {
                    PRINTF("Error reading Memory @ %lx\n",dwAddress);
                }
            } else {
                // No matching struct was found. Display the list of
                // structs currently handled.

                DisplayStructs();
            }
        } else {
            //
            // The command is of the form
            // dump <name>
            //
            // Currently we do not handle this. In future we will map it to
            // the name of a global variable and display it if required.
            //

            DisplayStructs();
        }
    } else {
        //
        // display the list of structs currently handled.
        //

        DisplayStructs();
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mup\wml\inc\wmlkm.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    wmlkm.h

Abstract:

    Kernel mode definitions for an easy wmi tracing.

Author:

    gorn

Revision History:

Comments:

    Needs to be moved to wmilib\inc when DCR is approved

--*/
#ifndef WMLKM_H
#define WMLKM_H 1

#pragma warning(disable: 4201) // error C4201: nonstandard extension used : nameless struct/union
#include <wmistr.h>
#include <evntrace.h>

#include "wmlmacro.h"
#ifdef __cplusplus
extern "C" {
#endif

#define MAX_TRACE_GUIDS_PER_CONTROL  3

typedef struct _WML_CONTROL_GUID_REG {
    GUID        Guid;
    GUID        TraceGuids[MAX_TRACE_GUIDS_PER_CONTROL];
    ULONG       EnableFlags;
    ULONG       EnableLevel;
    TRACEHANDLE LoggerHandle;
} WML_CONTROL_GUID_REG, *PWML_CONTROL_GUID_REG;

typedef struct _WML_TINY_INFO {
    PWML_CONTROL_GUID_REG    ControlGuids;
    ULONG                    GuidCount;
    PDEVICE_OBJECT           LowerDeviceObject;
    PUNICODE_STRING          DriverRegPath;
} WML_TINY_INFO, *PWML_TINY_INFO;


NTSTATUS
WmlTinySystemControl(
    IN OUT PWML_TINY_INFO WmiLibInfo,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

ULONG
WmlTrace(
    IN ULONG Type,
    IN LPCGUID TraceGuid,
    IN TRACEHANDLE LoggerHandle,
    ... // Pairs: Address, Length
    );

ULONG
WmlPrintf(
    IN ULONG Type,
    IN LPCGUID TraceGuid,
    IN TRACEHANDLE LoggerHandle,
    IN PCHAR FormatString,
    ... // var args
    );



#ifdef __cplusplus
};
#endif

#endif // WMLKM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mup\wml\inc\wmlmacro.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    wmlmacro.h

Abstract:

    This file defines macro for an easy wmi tracing.

Author:

    gorn

Revision History:

--*/
#ifndef WMLMACRO_H
#define WMLMACRO_H 1

typedef struct {char x[418957];} WMILIBTYPE_STRING;

#undef  WMILIB_TYPEDEF
#define WMILIB_TYPEDEF(_TypeName, _EquivType, _FmtStr, _Func, _MofStr, _InitType) \
    typedef _EquivType WMILIBTYPE_ ## _TypeName ;
#include "wmltypes.inc"

typedef union _WMLLOCALSTRUCT {
    UCHAR    uchar;
    USHORT   ushort;
    ULONG    uint;
    WCHAR    wchar;
    LONGLONG longlong;
} WMLLOCALSTRUCT;

#define WMLLOCAL WMLLOCALSTRUCT _wmllocal

#define WMILIB_CHECKED_ZERO(_Value, _Type) \
    (0 * (1/(int)!(sizeof(_Type) - sizeof(_Value) )))

#define WMILIB_CHECKED_SIZEOF(_Value, _Type) \
    (sizeof(_Value) + WMILIB_CHECKED_ZERO( _Value, _Type) )

#define WMILIB_LOGPAIR(_a, _b) (_a),(_b),

#define WMILIB_LOGARGVALTYPE(_value, _type) \
            WMILIB_LOGPAIR(WMILIB_CHECKED_SIZEOF(_value, _type), &(_value) )

#define LOG(_TypeName, _Value)                         \
    WMILIB_LOGARGVALTYPE( _Value, WMILIBTYPE_ ## _TypeName)

#define ANULL "$NULL$"
#define WNULL L"$NULL$"

#define LOGASTR(_value) \
    WMILIB_LOGPAIR( strlen(_value) + WMILIB_CHECKED_ZERO((_value)[0],CHAR), _value )

#define LOGASTR_CHK(_value) \
    WMILIB_LOGPAIR( strlen(_value?_value:ANULL) + WMILIB_CHECKED_ZERO((_value?_value:ANULL)[0],CHAR), _value?_value:ANULL )

#define LOGWSTR(_value) \
    WMILIB_LOGPAIR( (wcslen(_value?_value:WNULL)+1) * sizeof(WCHAR) + WMILIB_CHECKED_ZERO((_value?_value:WNULL)[0],WCHAR), _value?_value:WNULL)

#define LOGWSTR_CHK(_value) \
    WMILIB_LOGPAIR( (wcslen(_value?_value:WNULL)+1) * sizeof(WCHAR) + WMILIB_CHECKED_ZERO((_value?_value:WNULL)[0],WCHAR), _value?_value:WNULL)

#define LOGCSTR(_x) \
    WMILIB_LOGPAIR( sizeof((_x).Length) + WMILIB_CHECKED_ZERO(_x,STRING), &(_x).Length ) \
    WMILIB_LOGPAIR( (_x).Length, (_x).Buffer )

#define LOGUSTR(_x)                                                            \
    WMILIB_LOGPAIR( sizeof((_x).Length)                                        \
                    + WMILIB_CHECKED_ZERO((_x),UNICODE_STRING), &(_x).Length)  \
    WMILIB_LOGPAIR( (_x).Length, (_x).Buffer )

#define LOGCHARARR(_count, _x)                                 \
    WMILIB_LOGARGVALTYPE( _wmllocal.ushort , USHORT )          \
    WMILIB_LOGPAIR( (_wmllocal.ushort = _count * sizeof(CHAR)) \
                    + WMILIB_CHECKED_ZERO((_x)[0], CHAR), _x ) 

#define LOGWCHARARR(_count, _x)                                 \
    WMILIB_LOGARGVALTYPE( _wmllocal.ushort , USHORT )           \
    WMILIB_LOGPAIR( (_wmllocal.ushort = _count * sizeof(WCHAR)) \
                    + WMILIB_CHECKED_ZERO((_x)[0], WCHAR), _x ) 

#define LOGTIME(_Value)    LOG(TIMENT,  _Value)
#define LOGPTR(_Value)     LOG(PTR,     _Value)
#define LOGHANDLE(_Value)  LOG(HANDLE,  _Value)
#define LOGSTATUS(_Value)  LOG(XINT,    _Value)
#define LOGBYTE(_Value)    LOG(UBYTE,   _Value)
#define LOGULONG(_Value)   LOG(UINT,    _Value)
#define LOGULONGLONG(_Value)   LOG(ULONGLONG,    _Value)
#define LOGXLONG(_Value)   LOG(XINT,    _Value)
#define LOGXSHORT(_Value)  LOG(XSHORT,  _Value)
#define LOGUCHAR(_Value)   LOG(UCHAR,   _Value)
#define LOGIRQL(_Value)    LOG(UCHAR,   _Value)
#define LOGBOOL(_Value)    LOG(BOOL,    _Value)
#define LOGBOOLEAN(_Value) LOG(BOOLEAN, _Value)
#define LOGARSTR(_Value)   LOGASTR(_Value)
#define LOGPNPMN(_Value)   LOG(UCHAR,   _Value)
#define LOGIOCTL(_Value)   LOG(ULONG,   _Value)
#define LOGGUID(_Val)      LOG(GUID, _Val)

#define LOGVAL(_val)        (sizeof(_val)), (&(_val)),

#define WML_FLAGS(_Val)  ( (ULONG)(_Val) )
#define WML_STREAM(_Val) ( (ULONG)(_Val) )

#define WML_CONTROL(_prefix, _stream) \
            ( _prefix ## _ControlGuids[ WML_STREAM(_stream) ] )
            
#define WML_ENABLED(_prefix, _stream, _level, _flags) \
            (( WML_CONTROL(_prefix, _stream).EnableLevel >= (_level) ) &&   \
             ( WML_CONTROL(_prefix, _stream).EnableFlags & WML_FLAGS(_flags) ))
            
#define WML_TRACEGUID(_prefix, _stream, _id) \
            ( WML_CONTROL(_prefix, _stream).TraceGuids[ WML_GUID(_id) ] )
            
#define WML_LOG(_prefix, _stream, _level, _flags, _id, _arg) \
    do { \
        if ( WML_ENABLED(_prefix, _stream, _level, _flags) ) { \
            WmlTrace( WML_ID(_id), \
                     &WML_TRACEGUID(_prefix, _stream, _id) , \
                      WML_CONTROL(_prefix, _stream).LoggerHandle, _arg); \
        } \
    } while (0)            

#define WML_PRINTF(_prefix, _stream, _level, _flags, _id, _fmtstr, _arg) \
    do { \
        if ( WML_ENABLED(_prefix, _stream, _level, _flags) ) { \
            WmlPrintf( WML_ID(_id), \
                      &WML_TRACEGUID(_prefix, _stream, _id) , \
                      WML_CONTROL(_prefix, _stream).LoggerHandle, \
                      _fmtstr, _arg); \
        } \
    } while (0)            


#endif // WMLMACRO_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mup\wml\um\wmlum.cpp ===
#define _UNICODE
#define UNICODE

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>

#pragma warning(disable: 4201) // error C4201: nonstandard extension used : nameless struct/union
#include <wmistr.h>
#include <evntrace.h>
#include <guiddef.h>

#define REG_TRACE_REGKEY            TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Tracing")

#define REG_TRACE_ENABLED           TEXT("EnableTracing")

#define REG_TRACE_LOG_FILE_NAME     TEXT("LogFileName")
#define REG_TRACE_LOG_SESSION_NAME  TEXT("LogSessionName")
#define REG_TRACE_LOG_BUFFER_SIZE   TEXT("BufferSize")
#define REG_TRACE_LOG_MIN_BUFFERS   TEXT("MinBuffers")
#define REG_TRACE_LOG_MAX_BUFFERS   TEXT("MaxBuffers")
#define REG_TRACE_LOG_MAX_FILESIZE  TEXT("MaxFileSize")
#define REG_TRACE_LOG_MAX_HISTORY   TEXT("MaxHistorySize")
#define REG_TRACE_LOG_MAX_BACKUPS   TEXT("MaxBackups")

#define REG_TRACE_ACTIVE            TEXT("Active")
#define REG_TRACE_CONTROL           TEXT("ControlFlags")
#define REG_TRACE_LEVEL             TEXT("Level")
#define REG_TRACE_GUID              TEXT("Guid")

#include "wmlum.h"

#ifndef ARRAYSIZE
#define ARRAYSIZE(x) (sizeof(x)/sizeof(*(x)))
#endif

VOID RegisterIfNecessary(LPWSTR KeyName, LPCGUID Guid);

WMILIBPRINTFUNC WmiLibPrint = 0;

#define NT_LOGGER L"NT Kernel Logger"

VOID
MyDbgPrint(
    UINT Level,
    PCHAR FormatString,
    ...
    )
/*++

 Routine Description:

     Prints a message to the debugger or console, as appropriate.

 Arguments:

     String - The initial message string to print.

     Any FormatMessage-compatible arguments to be inserted in the
     ErrorMessage before it is logged.

 Return Value:
     None.

--*/
{
    CHAR Buffer[256];
    DWORD Bytes;
    va_list ArgList;

    if (WmiLibPrint == NULL) {
        return;
    }

    va_start(ArgList, FormatString);

    Bytes = FormatMessageA(FORMAT_MESSAGE_FROM_STRING,
                           FormatString,
                           0,
                           0,
                           Buffer,
                           sizeof(Buffer) / sizeof(CHAR),
                           &ArgList);


    va_end(ArgList);
    if (Bytes != 0) {
        (*WmiLibPrint)(Level, Buffer);
    }
}

UINT HexVal(int ch) { return isdigit(ch) ? ch - '0' : ch - 'a' + 10; }
UINT Hex(LPWSTR s, int n)
{
    UINT res = 0;
    while(n--) {
         res = res * 16 + HexVal(*s++); 
    }
    return res;
}

VOID
GuidFromStr(
    IN LPWSTR str, 
    OUT LPGUID guid)
{    
    int i = wcslen(str);
    if(i == 36) {
        guid->Data1 =            Hex(str +  0, 8);
        guid->Data2 =    (USHORT)Hex(str +  9, 4);
        guid->Data3 =    (USHORT)Hex(str + 14, 4);
        guid->Data4[0] = (UCHAR) Hex(str + 19, 2);
        guid->Data4[1] = (UCHAR) Hex(str + 21, 2);
        guid->Data4[2] = (UCHAR) Hex(str + 24, 2);
        guid->Data4[3] = (UCHAR) Hex(str + 26, 2);
        guid->Data4[4] = (UCHAR) Hex(str + 28, 2);
        guid->Data4[5] = (UCHAR) Hex(str + 30, 2);
        guid->Data4[6] = (UCHAR) Hex(str + 32, 2);
        guid->Data4[7] = (UCHAR) Hex(str + 34, 2);
    } else {
        DbgPrint("[WMLUM} GuidFromStr - Bad guid string: %S, length %d\n", str, i);
    }
}

typedef struct _INHERITED_DATA {
    BOOL Active;
    ULONG ControlFlags;
    ULONG LogLevel;
    ULONG Reserved;
    TRACEHANDLE Logger;
    GUID  Guid;
    BOOL  GuidDefined;
} INHERITED_DATA, *PINHERITED_DATA;

VOID
ReadCommonData(
    IN HKEY hk, 
    IN OUT PINHERITED_DATA data
    )
{
    ULONG ulTemp;
    ULONG dwSize;
    WCHAR szGuid[16 * 3 + 1];
    ULONG Temp;

    dwSize = sizeof(ulTemp);
    if (ERROR_SUCCESS == RegQueryValueEx(hk, REG_TRACE_ACTIVE, 
                             NULL, NULL,(BYTE *) &ulTemp, &dwSize))
    {
        data->Active = ulTemp;
    }
    else {
        dwSize = sizeof(Temp);
        data->Active = Temp = 0;
        RegSetValueEx(hk, REG_TRACE_ACTIVE, 0, REG_DWORD, (BYTE *) &Temp, dwSize);
    }

    dwSize = sizeof(ulTemp);
    if (ERROR_SUCCESS == RegQueryValueEx(hk, REG_TRACE_CONTROL, 
                                         NULL, NULL, 
                                         (BYTE *) &ulTemp, &dwSize)) 
    {
        data->ControlFlags = ulTemp;
    }
    else {
        dwSize = sizeof(Temp);
        data->ControlFlags = Temp = 0;
        RegSetValueEx(hk, REG_TRACE_CONTROL, 0, REG_DWORD, (BYTE *)&Temp, dwSize);
    }


    dwSize = sizeof(ulTemp);
    if (ERROR_SUCCESS == RegQueryValueEx(hk, REG_TRACE_LEVEL, 
                                         NULL, NULL,
                                         (BYTE *) &ulTemp, 
                                         &dwSize)) 
    {
        data->LogLevel = ulTemp;
    }
    else {
        dwSize = sizeof(Temp);
        data->LogLevel = Temp = 0;
        RegSetValueEx(hk, REG_TRACE_LEVEL, 0, REG_DWORD, (BYTE *)&Temp, dwSize);
    }

    dwSize = sizeof(szGuid);
    if (ERROR_SUCCESS == RegQueryValueEx(hk, REG_TRACE_GUID, 
                                         NULL, NULL,
                                         (BYTE *) &szGuid, 
                                         &dwSize)) 
    {
        GuidFromStr(szGuid, &data->Guid);
        data->GuidDefined = TRUE;
    }
    else {
        wcscpy(szGuid, L"d3ecd8e1-d3fb-4f26-8091-978eecb468b1");
        GuidFromStr(szGuid, &data->Guid);
        dwSize = wcslen(szGuid) * sizeof(wchar_t);
        RegSetValueEx(hk, REG_TRACE_GUID, 0, REG_SZ, (BYTE*)&szGuid, dwSize);
    }

    return;
}

typedef struct _FULL_LOGGER_INFO {
    EVENT_TRACE_PROPERTIES LoggerInfo;
    WCHAR logFileName[MAX_PATH + 512];
    WCHAR logSessionName[MAX_PATH + 512];
    ULONG MaxHistorySize;
    ULONG MaxBackups;
} FULL_LOGGER_INFO, *PFULL_LOGGER_INFO;

GUID MySystemTraceControlGuid = { /* 9e814aad-3204-11d2-9a82-006008a86939 */
    0x9e814aad,
    0x3204,
    0x11d2,
    {0x9a, 0x82, 0x00, 0x60, 0x08, 0xa8, 0x69, 0x39}
  };


VOID 
ReadLoggerInfo(
    IN HKEY hk, 
    OUT PTRACEHANDLE Logger) 
{
    FULL_LOGGER_INFO x;
    WCHAR tmpName[MAX_PATH + 512];
    WCHAR tmpName2[MAX_PATH + 512];
    ULONG ulTemp;
    ULONG Temp;
    ULONG dwReadSize = sizeof(ulTemp);    
    ULONG status;
    SYSTEMTIME localTime;
    BOOL success;
    
    RtlZeroMemory(&x, sizeof(x));
    x.LoggerInfo.Wnode.BufferSize = sizeof(x);
    x.LoggerInfo.Wnode.Flags = WNODE_FLAG_TRACED_GUID; 
    x.LoggerInfo.LogFileNameOffset = (ULONG)((ULONG_PTR)x.logFileName - (ULONG_PTR)&x);
    x.LoggerInfo.LoggerNameOffset  = (ULONG)((ULONG_PTR)x.logSessionName - (ULONG_PTR)&x);
    x.LoggerInfo.LogFileMode = EVENT_TRACE_FILE_MODE_CIRCULAR;

    //
    // If the key describes a logger,
    // it should have at least LOG_SESSION_NAME value
    //
    dwReadSize = sizeof(x.logSessionName);
    status = RegQueryValueEx(hk, REG_TRACE_LOG_SESSION_NAME, 
                             NULL, NULL, 
                             (BYTE *) &x.logSessionName, &dwReadSize);
    if (status != ERROR_SUCCESS) {
        wcscpy(x.logSessionName, L"DfsSvcLog");
       // dwReadSize = wcslen(x.logSessionName) * sizeof(wchar_t);
       // RegSetValueEx(hk, REG_TRACE_LOG_SESSION_NAME, 0, REG_SZ,(BYTE*) &x.logSessionName, dwReadSize);
    }

    if ( wcscmp(x.logSessionName, NT_LOGGER) == 0) {
        MyDbgPrint(3,"[WMILIB] Enabling system tracing\n", 
                   x.logSessionName,
                   x.LoggerInfo.Wnode.HistoricalContext);

        x.LoggerInfo.Wnode.Guid = MySystemTraceControlGuid;
        x.LoggerInfo.EnableFlags |= 
            EVENT_TRACE_FLAG_PROCESS |
            EVENT_TRACE_FLAG_THREAD |
            EVENT_TRACE_FLAG_DISK_IO |
            EVENT_TRACE_FLAG_NETWORK_TCPIP |
            EVENT_TRACE_FLAG_REGISTRY;
    }

    // Let's query, whether there is a logger with this name
    status = QueryTrace(0, x.logSessionName, &x.LoggerInfo);
    if (ERROR_SUCCESS == status) {
        MyDbgPrint(1,"[WMILIB] Query successful Logger %1!ws! %2!08X!:%3!08X!\n", 
                   x.logSessionName,
                   x.LoggerInfo.Wnode.HistoricalContext);
        *Logger = x.LoggerInfo.Wnode.HistoricalContext;
        return;
    }

    if (ERROR_WMI_INSTANCE_NOT_FOUND != status) {
        MyDbgPrint(1,"[WMILIB] Query of %1!ws! failed %2!d!\n", 
                   x.logSessionName, status);
    }

    // There is no logger runing

    // First, We will query logFileName value into tmpName variable
    // and then expand it into logFileName
    dwReadSize = sizeof(tmpName);
    status = RegQueryValueEx(hk, REG_TRACE_LOG_FILE_NAME, 
                             NULL, NULL, 
                             (BYTE *) &tmpName, &dwReadSize);
    if (status != ERROR_SUCCESS) {
        // If there is no logFileName, then this node doesn't describe
        // a logger. Bail out.
//        MyDbgPrint(1,"[WMILIB] Cannot read log file name, status %1!d!\n", status);
        wcscpy(tmpName, L"%SystemRoot%\\DfsSvcLogFile");
        //dwReadSize = wcslen(tmpName) * sizeof(wchar_t);;
        //RegSetValueEx(hk, REG_TRACE_LOG_FILE_NAME, 0, REG_SZ,(BYTE*) &tmpName, dwReadSize);
    }
    dwReadSize = ExpandEnvironmentStrings(tmpName, x.logFileName, ARRAYSIZE(x.logFileName) );
    if (dwReadSize == 0 || dwReadSize > ARRAYSIZE(x.logFileName)) {
        MyDbgPrint(1,"[WMILIB] Expansion of %1!ws! failed, return value %2!d!\n", tmpName, dwReadSize);
        CopyMemory(x.logFileName, tmpName, sizeof(x.logFileName));
    }
    
    MyDbgPrint(3,"[WMILIB] FileName %1!S!\n", x.logFileName);
    MyDbgPrint(3,"[WMILIB] Session %1!S!\n", x.logSessionName);

    dwReadSize = sizeof(ulTemp);
    if (ERROR_SUCCESS == RegQueryValueEx(hk, REG_TRACE_LOG_BUFFER_SIZE, 
                                         NULL, NULL, 
                                         (BYTE *) &ulTemp, &dwReadSize)) {
        x.LoggerInfo.BufferSize = ulTemp;
    }
    else {
        x.LoggerInfo.BufferSize = Temp = 0;
      //  RegSetValueEx(hk, REG_TRACE_LOG_BUFFER_SIZE, 0, REG_DWORD,(BYTE*) &Temp, dwReadSize);
    }
    dwReadSize = sizeof(ulTemp);
    if (ERROR_SUCCESS == RegQueryValueEx(hk, REG_TRACE_LOG_MIN_BUFFERS, 
                                         NULL, NULL, 
                                         (BYTE *) &ulTemp, &dwReadSize)){
        x.LoggerInfo.MinimumBuffers = ulTemp;
    }
    else {
        x.LoggerInfo.MinimumBuffers = Temp = 0;
    //    RegSetValueEx(hk, REG_TRACE_LOG_MIN_BUFFERS, 0, REG_DWORD, (BYTE*)&Temp, dwReadSize);
    }
    dwReadSize = sizeof(ulTemp);
    if (ERROR_SUCCESS == RegQueryValueEx(hk, REG_TRACE_LOG_MAX_BUFFERS, 
                                         NULL, NULL, 
                                         (BYTE *) &ulTemp, &dwReadSize)){
        x.LoggerInfo.MaximumBuffers = ulTemp;
    }
    else {
        x.LoggerInfo.MaximumBuffers = Temp = 0;
    //    RegSetValueEx(hk, REG_TRACE_LOG_MAX_BUFFERS, 0, REG_DWORD, (BYTE*)&Temp, dwReadSize);
    }

    dwReadSize = sizeof(ulTemp);
    if (ERROR_SUCCESS == RegQueryValueEx(hk, REG_TRACE_LOG_MAX_FILESIZE, 
                                         NULL, NULL, 
                                         (BYTE *) &ulTemp, &dwReadSize)){
        x.LoggerInfo.MaximumFileSize = ulTemp;
    }
    else{
        x.LoggerInfo.MaximumFileSize = Temp = 2;
     //   RegSetValueEx(hk, REG_TRACE_LOG_MAX_FILESIZE, 0, REG_DWORD, (BYTE*)&Temp, dwReadSize);
    }

	x.MaxHistorySize = 4 * x.LoggerInfo.MaximumFileSize;
    dwReadSize = sizeof(ulTemp);
    if (ERROR_SUCCESS == RegQueryValueEx(hk, REG_TRACE_LOG_MAX_HISTORY, 
                                         NULL, NULL, 
                                         (BYTE *) &ulTemp, &dwReadSize)){
        x.MaxHistorySize = ulTemp;
    }
    else {
        x.MaxHistorySize = Temp = 0;
    //    RegSetValueEx(hk, REG_TRACE_LOG_MAX_HISTORY, 0, REG_DWORD, (BYTE*)&Temp, dwReadSize);
    }

    dwReadSize = sizeof(ulTemp);
    if (ERROR_SUCCESS == RegQueryValueEx(hk, REG_TRACE_LOG_MAX_BACKUPS, 
                                         NULL, NULL, 
                                         (BYTE *) &ulTemp, &dwReadSize)) {
        x.MaxBackups = ulTemp;
    }
    else {
        x.MaxBackups = Temp = 1;
     //   RegSetValueEx(hk, REG_TRACE_LOG_MAX_BACKUPS, 0, REG_DWORD, (BYTE*)&Temp, dwReadSize);
    }


	if (x.MaxBackups == 0) {
	 	// We need to check whether the file already exist and rename it //

	 	GetLocalTime(&localTime);
		_snwprintf(tmpName, ARRAYSIZE(tmpName), 
				   L"%1ws.%04d%02d%02d%02d%02d%02d",
				   x.logFileName,
				   localTime.wYear,localTime.wMonth,localTime.wDay,
				   localTime.wHour,localTime.wMinute,localTime.wSecond);

		success = MoveFile(x.logFileName, tmpName);
		if (!success) {
	    	status = GetLastError();
		} else {
			status = ERROR_SUCCESS;
		}
	    MyDbgPrint(3,"[WMILIB] Rename %1!ws! => %2!ws!, status %3!d!\n", 
	    			x.logFileName, tmpName, status);
	} else {
		int i;
		for (i = x.MaxBackups; i >= 1; --i) {
			_snwprintf(tmpName2, ARRAYSIZE(tmpName), 
					   L"%1ws.%03d",
					   x.logFileName, i);
			if (i == 1) {
				wcscpy(tmpName, x.logFileName);
			} else {
				_snwprintf(tmpName, ARRAYSIZE(tmpName), 
						   L"%1ws.%03d",
						   x.logFileName, i-1);
			}
			success = MoveFile(tmpName, tmpName2);
			if (!success) {
		    	status = GetLastError();
			} else {
				status = ERROR_SUCCESS;
			}
		    MyDbgPrint(3,"[WMILIB] Rename %1!ws! => %2!ws!, status %3!d!\n", 
		    			tmpName, tmpName2, status);
		}
	}

    status = StartTrace(Logger, x.logSessionName, &x.LoggerInfo);
    *Logger = x.LoggerInfo.Wnode.HistoricalContext;
    MyDbgPrint(1,"[WMILIB] Logger %1!ws! started %3!08X!:%4!08X! %2!d!\n", 
               x.logSessionName, status, *Logger);
}

WCHAR szModuleName[MAX_PATH+500];

ULONG
InitWmiInternal(
    IN HKEY Dir OPTIONAL, // if 0, then current ...
    IN LPWSTR ProductName, 
    IN PINHERITED_DATA InheritedData OPTIONAL
    )
{
    ULONG status;
    INHERITED_DATA data;
    HKEY CloseMe = 0;
    HKEY hk      = 0;
    //ULONG ulTemp;
    //ULONG dwReadSize = sizeof(ulTemp);
    DWORD dwSizeOfModuleName;
    DWORD dwIndex;

    MyDbgPrint(2, "[WMILIB] Init %1!ws!\n", ProductName);

    if (InheritedData) {
        data = *InheritedData;
    } else {
        ZeroMemory(&data, sizeof(data));
    }
    data.GuidDefined = FALSE;

    if (!Dir) {
        status = RegCreateKeyEx(HKEY_LOCAL_MACHINE, 
                                REG_TRACE_REGKEY, 
                                0, 
                                NULL,
                                REG_OPTION_NON_VOLATILE, 
                                KEY_READ | KEY_WRITE,
                                NULL,
                                &CloseMe,
                                NULL);
        if (status != ERROR_SUCCESS) {
            MyDbgPrint(1,"[WMILIB] Failed to open Trace Key, %1!d!\n", status);
            goto exit_gracefully;
        }
        Dir = CloseMe;
    }

    status = RegCreateKeyEx(Dir, 
                            ProductName, 
                            0, 
                            NULL,
                            REG_OPTION_NON_VOLATILE, 
                            KEY_READ | KEY_WRITE,
                            NULL,
                            &hk,
                            NULL);
    if (status != ERROR_SUCCESS) {
        MyDbgPrint(1,"[WMILIB] Failed to open %1!ws! subkey, %2!d!\n", ProductName, status);
        goto exit_gracefully;
    }


    ReadLoggerInfo(hk, &data.Logger);
    ReadCommonData(hk, &data);

    if (!data.Active) {
        MyDbgPrint(1,"[WMILIB] Tracing is not active for %1!ws!\n", ProductName);
    	goto exit_gracefully;
    }

    if (data.GuidDefined) {
        // First, try to find its in the map.            //
        // If it is there, we need to register this Guid //
        RegisterIfNecessary(ProductName, &data.Guid);

        // We can try to start tracing //
        if (data.Logger) {
            status = EnableTrace(data.Active, 
                                 data.ControlFlags, 
                                 data.LogLevel,
                                 &data.Guid,
                                 data.Logger);
            MyDbgPrint(1,"[WMILIB] Enable=%1!d! %2!ws!, status %3!d!\n", data.
                       Active, ProductName, status);
        }
    }

    dwSizeOfModuleName = sizeof(szModuleName);
    dwIndex = 0;
    while (ERROR_SUCCESS == (status = RegEnumKeyEx(hk, dwIndex, 
                                                   szModuleName, 
                                                   &dwSizeOfModuleName,
                                                   NULL, NULL, NULL, NULL)))
    {
        InitWmiInternal(hk, szModuleName, &data);

        dwSizeOfModuleName = sizeof(szModuleName);
        ++dwIndex;
    }

    if (ERROR_NO_MORE_ITEMS == status) {
        status = ERROR_SUCCESS;
    }

exit_gracefully:
    if (CloseMe) {
        RegCloseKey(CloseMe);
    }
    if (hk) {
        RegCloseKey(hk);
    }
    return status;
}

ULONG
InitWmi(
    IN LPWSTR ProductName
    )
{
    MyDbgPrint(1, "[WMILIB] Initialize %1!ws!\n", ProductName);
    return InitWmiInternal(0, ProductName, 0);
}

#pragma warning(disable: 4512) // error C4512: 'blah-blah-blah' : assignment operator could not be generated
#pragma warning(disable: 4100) // '_P' : unreferenced formal parameter
#include <xmemory>
#pragma warning(default: 4100)
#include <map>
//#include <xstring>

struct wless {
    bool operator() (LPCWSTR a, LPCWSTR b) const { return lstrcmpW(a,b) < 0; }
};

typedef std::map<LPCWSTR, PWMILIB_REG_STRUCT, wless > WIDE_STRING_MAP;

WIDE_STRING_MAP* map;
PWMILIB_REG_STRUCT head;

ULONG
WmilibControlCallback(
    IN WMIDPREQUESTCODE RequestCode,
    IN PVOID Context,
    IN OUT ULONG *InOutBufferSize,
    IN OUT PVOID Buffer
    )
{
    PWMILIB_REG_STRUCT Ctx = (PWMILIB_REG_STRUCT)Context;
    ULONG Status = ERROR_SUCCESS;

   	switch (RequestCode)
   	{
   	case WMI_ENABLE_EVENTS:
   	    {
   	    Ctx->LoggerHandle = GetTraceLoggerHandle( Buffer );
   	    Ctx->EnableLevel = GetTraceEnableLevel(Ctx->LoggerHandle);
   	    Ctx->EnableFlags = GetTraceEnableFlags(Ctx->LoggerHandle);
        MyDbgPrint(3, "[WMILIB] WMI_ENABLE_EVENTS Ctx 0x%1!08X! Flags %2!X! Lev %3!d! Logger %4!08X!:%5!08X!\n", 
                   Ctx, Ctx->EnableFlags, Ctx->EnableLevel, Ctx->LoggerHandle);
    
        break;
   	    }

   	case WMI_DISABLE_EVENTS:
   	    {
        Ctx->LoggerHandle = 0;
        Ctx->EnableFlags = 0;
        Ctx->EnableLevel = 0;
        MyDbgPrint(3, "[WMILIB] WMI_DISABLE_EVENTS Ctx 0x%1!08X!\n", Ctx);
   	    break;
    	}

   	default:
   	   {
   	       Status = ERROR_INVALID_PARAMETER;
   	       break;
   	   }
   	}
   	*InOutBufferSize = 0;
   	return(Status);
}



VOID RegisterIfNecessary(
    LPWSTR KeyName, 
    LPCGUID Guid)
{
    WIDE_STRING_MAP::iterator i = map->find(KeyName);
    if ( i == map->end() ) {
        MyDbgPrint(2, "[WMILIB] map: %1!ws!, not found\n", KeyName);
        return; // Not found //
    }
    MyDbgPrint(3, "[WMILIB] map[%1!ws!]=0x%2!08X!\n", i->first, i->second);

    TRACE_GUID_REGISTRATION Reg;

    Reg.Guid = Guid;
    Reg.RegHandle = 0;

    ULONG status = RegisterTraceGuids(
        WmilibControlCallback,
        i->second, // Context for the callback
        Guid,      // Control Guid
        1,         // # of dummies
        &Reg,      // dummy trace guid
        0, //ImagePath,
        0, //ResourceName,
        &i->second->RegistrationHandle
        );

    if (status == ERROR_SUCCESS) {
        i->second->Next = head;
        head = i->second;
    } else {
        MyDbgPrint(1, "[WMILIB] Failed to register %1!ws!, status %2!d!\n", KeyName, status);
    }
}

ULONG
WmlInitialize(
    IN LPWSTR              ProductName, 
    IN WMILIBPRINTFUNC     PrintFunc,
    OUT WMILIB_REG_HANDLE* Head, 
    ... // Pairs: LPWSTR CtrlGuidName, Corresponding WMILIB_REG_STRUCT 
    )
{
    WIDE_STRING_MAP map;
    LPWSTR str;
    va_list ap;

    WmiLibPrint = PrintFunc;

    *Head = 0;

    ::head = 0;
    ::map = &map;

    va_start(ap, Head);
    while(0 != (str = va_arg(ap, LPWSTR)) ) {
         map[ str ] = va_arg(ap, PWMILIB_REG_STRUCT);
    }
    va_end(ap);
    ULONG status = InitWmiInternal(0, ProductName, 0);
    *Head = ::head;
    return status;
}

VOID
WmlUninitialize(
    IN PWMILIB_REG_STRUCT head
    )
{
    while (head) {
        MyDbgPrint(3,"[WMILIB] Unregister 0x%1!08X!\n", head);
        UnregisterTraceGuids(head->RegistrationHandle);
        head = head->Next;
    }
}

#define WMILIB_USER_MODE

typedef struct _TRACE_BUFFER {
    union {
        EVENT_TRACE_HEADER Trace;
        WNODE_HEADER       Wnode;
    };
    MOF_FIELD MofFields[MAX_MOF_FIELDS + 1];
} TRACE_BUFFER, *PTRACE_BUFFER;


//////////////////////////////////////////////////////////////////////
//  0  | Size      | ProviderId  |   0  |Size.HT.Mk | Typ.Lev.Version|
//  2  | L o g g e r H a n d l e |   2  |    T h r e a d   I d       |
//  4  | T i m e  S t a m p      |   4  |    T i m e  S t a m p      |
//  6  |    G U I D    L o w     |   6  |    GUID Ptr / Guid L o w   |
//  8  |    G U I D    H I g h   |   8  |    G U I D    H i g h      |
// 10  | ClientCtx | Flags       |  10  |KernelTime | UserTime       |
//////////////////////////////////////////////////////////////////////

ULONG
WmlTrace(
    IN UINT Type,
    IN LPCGUID TraceGuid,
    IN TRACEHANDLE LoggerHandle,
    ... // Pairs: Address, Length
    )
{
    TRACE_BUFFER TraceBuffer;

    ((PULONG)&TraceBuffer)[1] = Type;
    
#ifndef WMILIB_USER_MODE
    TraceBuffer.Wnode.HistoricalContext = LoggerHandle;
#endif

    TraceBuffer.Trace.Guid = *TraceGuid;

    TraceBuffer.Wnode.Flags = 
        WNODE_FLAG_USE_MOF_PTR  | // MOF data are dereferenced
        WNODE_FLAG_TRACED_GUID;   // Trace Event, not a WMI event

    {
        PMOF_FIELD   ptr = TraceBuffer.MofFields;
        va_list      ap;

        va_start(ap, LoggerHandle);
        do {
            if ( 0 == (ptr->Length = (ULONG)va_arg (ap, size_t)) )  {
                break;
            }
            ptr->DataPtr = (ULONGLONG)va_arg(ap, PVOID);
        } while ( ++ptr < &TraceBuffer.MofFields[MAX_MOF_FIELDS] );
        va_end(ap);

        TraceBuffer.Wnode.BufferSize = (ULONG) ((ULONG_PTR)ptr - (ULONG_PTR)&TraceBuffer);
    }
    
#ifdef WMILIB_USER_MODE
    ULONG status = TraceEvent( LoggerHandle, &TraceBuffer.Trace);
    if (status != ERROR_SUCCESS) {
    	// Need to count failures and report them during unintialize or ...//
    }
#else
    IoWMIWriteEvent(&TraceBuffer);
#endif
    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mup\wml\km\wmlkm.c ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

    cldskwmi.c

Abstract:

    km wmi tracing code. 
    
    Will be shared between our drivers.

Authors:

    GorN     10-Aug-1999

Environment:

    kernel mode only

Notes:

Revision History:

Comments:

	This code is a quick hack to enable WMI tracing in cluster drivers.
	It should eventually go away.

	WmlTinySystemControl will be replaced with WmilibSystemControl from wmilib.sys .

	WmlTrace or equivalent will be added to the kernel in addition to IoWMIWriteEvent(&TraceBuffer);

--*/
#include <ntos.h>
#include <ntrtl.h>
#include <nturtl.h>
#include "stdio.h"

#include <wmistr.h>
#include <evntrace.h>

#include "wmlkm.h"

BOOLEAN
WmlpFindGuid(
    IN PWML_CONTROL_GUID_REG GuidList,
    IN ULONG GuidCount,
    IN LPGUID Guid,
    OUT PULONG GuidIndex
    )
/*++

Routine Description:

    This routine will search the list of guids registered and return
    the index for the one that was registered.

Arguments:

    GuidList is the list of guids to search

    GuidCount is the count of guids in the list

    Guid is the guid being searched for

    *GuidIndex returns the index to the guid
        
Return Value:

    TRUE if guid is found else FALSE

--*/
{
    ULONG i;

    for (i = 0; i < GuidCount; i++)
    {
        if (IsEqualGUID(Guid, &GuidList[i].Guid))
        {
            *GuidIndex = i;
            return(TRUE);
        }
    }

    return(FALSE);
}


NTSTATUS
WmlTinySystemControl(
    IN OUT PWML_TINY_INFO WmiLibInfo,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    Dispatch routine for IRP_MJ_SYSTEM_CONTROL. This routine will process
    all wmi requests received, forwarding them if they are not for this
    driver or determining if the guid is valid and if so passing it to
    the driver specific function for handing wmi requests.

Arguments:

    WmiLibInfo has the WMI information control block

    DeviceObject - Supplies a pointer to the device object for this request.

    Irp - Supplies the Irp making the request.

Return Value:

    status

--*/

{
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    ULONG bufferSize;
    PUCHAR buffer;
    NTSTATUS status;
    ULONG retSize;
    UCHAR minorFunction;
    ULONG guidIndex;
    ULONG instanceCount;
    ULONG instanceIndex;

    //
    // If the irp is not a WMI irp or it is not targetted at this device
    // or this device has not regstered with WMI then just forward it on.
    minorFunction = irpStack->MinorFunction;
    if ((minorFunction > IRP_MN_EXECUTE_METHOD) ||
        (irpStack->Parameters.WMI.ProviderId != (ULONG_PTR)DeviceObject) ||
        ((minorFunction != IRP_MN_REGINFO) &&
         (WmiLibInfo->GuidCount == 0) || (WmiLibInfo->ControlGuids == NULL) ))
    {
        //
        // IRP is not for us so forward if there is a lower device object
        if (WmiLibInfo->LowerDeviceObject != NULL)
        {
            IoSkipCurrentIrpStackLocation(Irp);
            return(IoCallDriver(WmiLibInfo->LowerDeviceObject, Irp));
        } else {
            status = STATUS_INVALID_DEVICE_REQUEST;
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return(status);
        }
    }

    buffer = (PUCHAR)irpStack->Parameters.WMI.Buffer;
    bufferSize = irpStack->Parameters.WMI.BufferSize;

    if (minorFunction != IRP_MN_REGINFO)
    {
        //
        // For all requests other than query registration info we are passed
        // a guid. Determine if the guid is one that is supported by the
        // device.
        if (WmlpFindGuid(WmiLibInfo->ControlGuids,
                            WmiLibInfo->GuidCount,
                            (LPGUID)irpStack->Parameters.WMI.DataPath,
                            &guidIndex) )
        {
            status = STATUS_SUCCESS;
        } else {
            status = STATUS_WMI_GUID_NOT_FOUND;
        }

        if (!NT_SUCCESS(status))
        {
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return(status);
        }
    }

    switch(minorFunction)
    {
        case IRP_MN_REGINFO:
        {
            ULONG guidCount;
            PWML_CONTROL_GUID_REG guidList;
            PWMIREGINFOW wmiRegInfo;
            PWMIREGGUIDW wmiRegGuid;
            PDEVICE_OBJECT pdo;
            PUNICODE_STRING regPath;
            PWCHAR stringPtr;
            ULONG registryPathOffset;
            ULONG bufferNeeded;
            ULONG i;
            UNICODE_STRING nullRegistryPath;

            regPath = WmiLibInfo->DriverRegPath;
            guidList = WmiLibInfo->ControlGuids;
            guidCount = WmiLibInfo->GuidCount;

            if (regPath == NULL)
            {
                // No registry path specified. This is a bad thing for 
                // the device to do, but is not fatal
                nullRegistryPath.Buffer = NULL;
                nullRegistryPath.Length = 0;
                nullRegistryPath.MaximumLength = 0;
                regPath = &nullRegistryPath;
            }                
            
            registryPathOffset = FIELD_OFFSET(WMIREGINFOW, WmiRegGuid) +
                                  guidCount * sizeof(WMIREGGUIDW);

            bufferNeeded = registryPathOffset +
                regPath->Length + sizeof(USHORT);

            if (bufferNeeded <= bufferSize)
            {
                retSize = bufferNeeded;
                RtlZeroMemory(buffer, bufferNeeded);

                wmiRegInfo = (PWMIREGINFO)buffer;
                wmiRegInfo->BufferSize = bufferNeeded;
                // wmiRegInfo->NextWmiRegInfo = 0;
                // wmiRegInfo->MofResourceName = 0;
                wmiRegInfo->RegistryPath = registryPathOffset;
                wmiRegInfo->GuidCount = guidCount;

                for (i = 0; i < guidCount; i++)
                {
                    wmiRegGuid = &wmiRegInfo->WmiRegGuid[i];
                    wmiRegGuid->Guid = guidList[i].Guid;
                    wmiRegGuid->Flags = WMIREG_FLAG_TRACED_GUID | WMIREG_FLAG_TRACE_CONTROL_GUID;
                    // wmiRegGuid->InstanceInfo = 0;
                    // wmiRegGuid->InstanceCount = 0;
                }

                stringPtr = (PWCHAR)((PUCHAR)buffer + registryPathOffset);
                *stringPtr++ = regPath->Length;
                RtlCopyMemory(stringPtr,
                          regPath->Buffer,
                          regPath->Length);
                status = STATUS_SUCCESS;
            } else {
                status = STATUS_BUFFER_TOO_SMALL;
                *((PULONG)buffer) = bufferNeeded;
                retSize = sizeof(ULONG);
            }

            Irp->IoStatus.Status = status;
            Irp->IoStatus.Information = retSize;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return(status);
        }

        case IRP_MN_ENABLE_EVENTS:
        case IRP_MN_DISABLE_EVENTS:
        {
            PWNODE_HEADER   Wnode = irpStack->Parameters.WMI.Buffer;
            PWML_CONTROL_GUID_REG Ctx = WmiLibInfo->ControlGuids + guidIndex;
            if (irpStack->Parameters.WMI.BufferSize >= sizeof(WNODE_HEADER)) {
                status = STATUS_SUCCESS;

                if (minorFunction == IRP_MN_DISABLE_EVENTS) {
                    Ctx->EnableLevel = 0;
                    Ctx->EnableFlags = 0;
                } else {
                    Ctx->LoggerHandle = (TRACEHANDLE)( Wnode->HistoricalContext );
                    
                    Ctx->EnableLevel = WmiGetLoggerEnableLevel(Ctx->LoggerHandle);
                    Ctx->EnableFlags = WmiGetLoggerEnableFlags(Ctx->LoggerHandle);
                }
            } else {
                status = STATUS_INVALID_PARAMETER;
            }

            break;
        }

        case IRP_MN_ENABLE_COLLECTION:
        case IRP_MN_DISABLE_COLLECTION:
        {
            status = STATUS_SUCCESS;
            break;
        }

        case IRP_MN_QUERY_ALL_DATA:
        case IRP_MN_QUERY_SINGLE_INSTANCE:
        case IRP_MN_CHANGE_SINGLE_INSTANCE:
        case IRP_MN_CHANGE_SINGLE_ITEM:
        case IRP_MN_EXECUTE_METHOD:
        {
            status = STATUS_INVALID_DEVICE_REQUEST;
            break;
        }

        default:
        {
            status = STATUS_INVALID_DEVICE_REQUEST;
            break;
        }

    }
    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    
    return(status);
}

#define MAX_SCRATCH_LOG 256

typedef struct _TRACE_BUFFER {
    union {
        EVENT_TRACE_HEADER Trace;
        WNODE_HEADER       Wnode;
    };
    union {
        MOF_FIELD MofFields[MAX_MOF_FIELDS + 1];
        UCHAR     ScratchPad[MAX_SCRATCH_LOG];
    };

} TRACE_BUFFER, *PTRACE_BUFFER;


//////////////////////////////////////////////////////////////////////
//  0  | Size      | ProviderId  |   0  |Size.HT.Mk | Typ.Lev.Version|
//  2  | L o g g e r H a n d l e |   2  |    T h r e a d   I d       |
//  4  | T i m e  S t a m p      |   4  |    T i m e  S t a m p      |
//  6  |    G U I D    L o w     |   6  |    GUID Ptr / Guid L o w   |
//  8  |    G U I D    H I g h   |   8  |    G U I D    H i g h      |
// 10  | ClientCtx | Flags       |  10  |KernelTime | UserTime       |
//////////////////////////////////////////////////////////////////////

ULONG
WmlTrace(
    IN ULONG Type,
    IN LPCGUID TraceGuid,
    IN TRACEHANDLE LoggerHandle,
    ... // Pairs: Address, Length
    )
{
    TRACE_BUFFER TraceBuffer;

    TraceBuffer.Trace.Version = Type;
    
    TraceBuffer.Wnode.HistoricalContext = LoggerHandle; // [KM]

    TraceBuffer.Trace.Guid = *TraceGuid;

    TraceBuffer.Wnode.Flags = 
        WNODE_FLAG_USE_MOF_PTR  | // MOF data are dereferenced
        WNODE_FLAG_TRACED_GUID;   // Trace Event, not a WMI event

    {
        PMOF_FIELD   ptr = TraceBuffer.MofFields;
        va_list      ap;

        va_start(ap, LoggerHandle);
        do {
            if ( 0 == (ptr->Length = (ULONG)va_arg (ap, size_t)) )  {
                break;
            }
            ptr->DataPtr = (ULONGLONG)va_arg(ap, PVOID);
        } while ( ++ptr < &TraceBuffer.MofFields[MAX_MOF_FIELDS] );
        va_end(ap);

        TraceBuffer.Wnode.BufferSize = (ULONG) ((ULONG_PTR)ptr - (ULONG_PTR)&TraceBuffer);
    }
    
    IoWMIWriteEvent(&TraceBuffer); // [KM]
    return STATUS_SUCCESS;
}


ULONG
WmlPrintf(
    IN ULONG Type,
    IN LPCGUID TraceGuid,
    IN TRACEHANDLE LoggerHandle,
    IN PCHAR FormatString,
    ... // printf var args
    )
{
    TRACE_BUFFER TraceBuffer;
    va_list ArgList;
    ULONG Length;

    TraceBuffer.Trace.Version = Type;
    
    TraceBuffer.Wnode.HistoricalContext = LoggerHandle; // [KM]

    TraceBuffer.Trace.Guid = *TraceGuid;

    TraceBuffer.Wnode.Flags = 
        WNODE_FLAG_TRACED_GUID;   // Trace Event, not a WMI event

    va_start(ArgList, FormatString);
    Length = _vsnprintf(TraceBuffer.ScratchPad, MAX_SCRATCH_LOG, FormatString, ArgList);
    TraceBuffer.ScratchPad[Length] = 0;
    va_end(ArgList);


    TraceBuffer.Wnode.BufferSize = 
        (ULONG) ((ULONG_PTR)(TraceBuffer.ScratchPad + Length) - (ULONG_PTR)&TraceBuffer);
    
    IoWMIWriteEvent(&TraceBuffer); // [KM]
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\mup\wml\inc\wmlum.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    wmlum.h

Abstract:

    User mode definitions for an easy wmi tracing.

Author:

    gorn

Revision History:

Comments:

    Needs to be moved to wmilib\inc when DCR is approved


--*/
#ifndef WMLUM_H
#define WMLUM_H 1

#pragma warning(disable: 4201) // error C4201: nonstandard extension used : nameless struct/union
#include <wmistr.h>
#include <evntrace.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef struct _WMILIB_REG_STRUCT
{
    TRACEHANDLE LoggerHandle;
    ULONG EnableFlags; 
    ULONG EnableLevel;

    struct _WMILIB_REG_STRUCT* Next;
    TRACEHANDLE RegistrationHandle;
} WMILIB_REG_STRUCT, *PWMILIB_REG_STRUCT;

typedef PWMILIB_REG_STRUCT WMILIB_REG_HANDLE;

typedef void (*WMILIBPRINTFUNC)(UINT Level, PCHAR String);

ULONG
WmlInitialize(
    IN LPWSTR ProductName, 
    IN WMILIBPRINTFUNC PrintFunc,
    OUT WMILIB_REG_HANDLE*, 
    ... // Pairs: LPWSTR CtrlGuidName, Corresponding WMILIB_REG_STRUCT 
    );
    
VOID
WmlUninitialize(
    IN WMILIB_REG_HANDLE
    );

ULONG
WmlTrace(
    IN UINT Type,
    IN LPCGUID TraceGuid,
    IN TRACEHANDLE LoggerHandle,
    ... // Pairs: Address, Length
    );

typedef 
ULONG
(*PWML_INITIALIZE)(
    IN LPWSTR ProductName, 
    IN WMILIBPRINTFUNC PrintFunc,
    OUT WMILIB_REG_HANDLE*, 
    ...
    );

typedef 
VOID 
(*PWML_UNINITIALIZE)(
    IN WMILIB_REG_HANDLE);

typedef 
ULONG
(*PWML_TRACE)(
    IN UINT Type,
    IN LPCGUID TraceGuid,
    IN TRACEHANDLE LoggerHandle,
    ... 
    );

typedef 
struct _WML_DATA {

    PWML_TRACE        Trace;
    PWML_INITIALIZE   Initialize;
    PWML_UNINITIALIZE Uninitialize;
    
    WMILIB_REG_HANDLE WmiRegHandle;
    HINSTANCE         WmlDllInstance;
    
} WML_DATA;

#define LOADWML(status, wml) \
    do \
    { \
            (wml).Trace        =        (PWML_TRACE) WmlTrace; \
            (wml).Initialize   =   (PWML_INITIALIZE) WmlInitialize; \
            (wml).Uninitialize = (PWML_UNINITIALIZE) WmlUninitialize; \
    \
            if (!(wml).Trace || !(wml).Initialize || !(wml).Uninitialize) { \
                status = GetLastError(); \
            } else { \
                status = ERROR_SUCCESS; \
            } \
    } \
    while(0)

/*
#define LOADWML(status, wml) \
    do \
    { \
        HINSTANCE hInst = LoadLibraryW(L"wmlum.dll"); \
        (wml).WmlDllInstance = hInst; \
        if (!hInst) { \
            status = GetLastError(); \
        } else { \
            (wml).Trace        =        (PWML_TRACE) GetProcAddress(hInst, "WmlTrace"); \
            (wml).Initialize   =   (PWML_INITIALIZE) GetProcAddress(hInst, "WmlInitialize"); \
            (wml).Uninitialize = (PWML_UNINITIALIZE) GetProcAddress(hInst, "WmlUninitialize"); \
    \
            if (!(wml).Trace || !(wml).Initialize || !(wml).Uninitialize) { \
                status = GetLastError(); \
            } else { \
                status = ERROR_SUCCESS; \
            } \
        } \
    } \
    while(0)
*/
#define UNLOADWML(wml) \
    do \
    { \
        if ( (wml).Uninitialize ) { \
            (wml).Uninitialize( (wml).WmiRegHandle ); \
        } \
        if ( (wml).WmlDllInstance ) { \
            FreeLibrary( (wml).WmlDllInstance ); \
        } \
        RtlZeroMemory( &(wml) , sizeof(WML_DATA) ); \
    } \
    while(0)  

#ifdef __cplusplus
};
#endif

#endif // WMLUM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\npfs\cleanup.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    Cleanup.c

Abstract:

    This module implements the File Cleanup routine for NPFS called by the
    dispatch driver.

Author:

    Gary Kimura     [GaryKi]    21-Aug-1990

Revision History:

--*/

#include "NpProcs.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_CLEANUP)

//
//  local procedure prototypes
//

NTSTATUS
NpCommonCleanup (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NpCommonCleanup)
#pragma alloc_text(PAGE, NpFsdCleanup)
#endif


NTSTATUS
NpFsdCleanup (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the FSD part of the NtCleanupFile API calls.

Arguments:

    NpfsDeviceObject - Supplies the device object to use.

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The Fsd status for the Irp

--*/

{
    NTSTATUS Status;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "NpFsdCleanup\n", 0);

    //
    //  Call the common Cleanup routine.
    //

    FsRtlEnterFileSystem();

    Status = NpCommonCleanup( NpfsDeviceObject, Irp );

    FsRtlExitFileSystem();

    if (Status != STATUS_PENDING) {
        NpCompleteRequest (Irp, Status);
    }

    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "NpFsdCleanup -> %08lx\n", Status );

    return Status;
}


//
//  Internal support routine
//

NTSTATUS
NpCommonCleanup (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for cleanup

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - the return status for the operation

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;
    NODE_TYPE_CODE NodeTypeCode;
    PCCB Ccb;
    PROOT_DCB RootDcb;
    NAMED_PIPE_END NamedPipeEnd;
    LIST_ENTRY DeferredList;

    PAGED_CODE();

    InitializeListHead (&DeferredList);
    //
    //  Get the current stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "NpCommonCleanup...\n", 0);
    DebugTrace( 0, Dbg, "Irp  = %08lx\n", Irp);

    //
    //  Now acquire exclusive access to the Vcb
    //

    NpAcquireExclusiveVcb();

    //
    //  Decode the file object to figure out who we are.  If the result
    //  is null then the pipe has been disconnected.
    //

    if ((NodeTypeCode = NpDecodeFileObject( IrpSp->FileObject,
                                            &RootDcb,
                                            &Ccb,
                                            &NamedPipeEnd )) == NTC_UNDEFINED) {

            DebugTrace(0, Dbg, "Pipe is disconnected from us\n", 0);

    } else {
        //
        //  Now case on the type of file object we're closing
        //

        switch (NodeTypeCode) {

        case NPFS_NTC_VCB:

            IoRemoveShareAccess( IrpSp->FileObject, &NpVcb->ShareAccess );

            break;

        case NPFS_NTC_ROOT_DCB:

            IoRemoveShareAccess( IrpSp->FileObject, &RootDcb->Specific.Dcb.ShareAccess );

            break;

        case NPFS_NTC_CCB:

            //
            //  If this is the server end of a pipe, decrement the count
            //  of the number of instances the server end has open.
            //  When this count is 0, attempts to connect to the pipe
            //  return OBJECT_NAME_NOT_FOUND instead of
            //  PIPE_NOT_AVAILABLE.
            //

            if ( NamedPipeEnd == FILE_PIPE_SERVER_END ) {
                ASSERT( Ccb->Fcb->ServerOpenCount != 0 );
                Ccb->Fcb->ServerOpenCount -= 1;
            }

            //
            //  The set closing state routines does everything to transition
            //  the named pipe to a closing state.
            //

            Status = NpSetClosingPipeState (Ccb, Irp, NamedPipeEnd, &DeferredList);

            break;
        }
    }
    NpReleaseVcb ();

    //
    // Complete any deferred IRPs now we have released our locks
    //
    NpCompleteDeferredIrps (&DeferredList);

    Status = STATUS_SUCCESS;

    DebugTrace(-1, Dbg, "NpCommonCleanup -> %08lx\n", Status);
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\npfs\close.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    Close.c

Abstract:

    This module implements the File Close routine for NPFS called by the
    dispatch driver.

Author:

    Gary Kimura     [GaryKi]    21-Aug-1990

Revision History:

--*/

#include "NpProcs.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_CLOSE)

//
//  local procedure prototypes
//

NTSTATUS
NpCommonClose (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NpCommonClose)
#pragma alloc_text(PAGE, NpFsdClose)
#endif


NTSTATUS
NpFsdClose (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the FSD part of the NtCloseFile API calls.

Arguments:

    NpfsDeviceObject - Supplies the device object to use.

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The Fsd status for the Irp

--*/

{
    NTSTATUS Status;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "NpFsdClose\n", 0);

    //
    //  Call the common Close routine.
    //

    FsRtlEnterFileSystem();

    Status = NpCommonClose( NpfsDeviceObject, Irp );

    FsRtlExitFileSystem();

    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "NpFsdClose -> %08lx\n", Status );

    return Status;
}

//
//  Internal support routine
//

NTSTATUS
NpCommonClose (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for creating/opening a file.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - the return status for the operation

--*/

{
    NTSTATUS Status;

    PIO_STACK_LOCATION IrpSp;

    NODE_TYPE_CODE NodeTypeCode;
    PFCB Fcb;
    PCCB Ccb;
    LIST_ENTRY DeferredList;

    PAGED_CODE();

    InitializeListHead (&DeferredList);
    //
    //  Get the current stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "NpCommonClose...\n", 0);
    DebugTrace( 0, Dbg, " Irp                    = %08lx\n", Irp);

    //
    //  Now acquire exclusive access to the vcb
    //

    NpAcquireExclusiveVcb();

    //
    //  Decode the file object to figure out who we are.  If the result
    //  is null then the pipe has been disconnected.
    //

    if ((NodeTypeCode = NpDecodeFileObject( IrpSp->FileObject,
                                            &Fcb,
                                            &Ccb,
                                            NULL )) == NTC_UNDEFINED) {

        DebugTrace(0, Dbg, "Pipe is disconnected from us\n", 0);

    } else {

        //
        //  Now case on the type of file object we're closing
        //

        switch (NodeTypeCode) {

        case NPFS_NTC_VCB:

            //
            //  Decrement the Open count
            //

            NpVcb->OpenCount -= 1;

            break;

        case NPFS_NTC_ROOT_DCB:

            //
            //  Decrement the Open count and clear our fields in the file object
            //

            Fcb->OpenCount -= 1;

            //
            //  Remove the root dcb ccb.
            //

            NpDeleteCcb (Ccb, &DeferredList);

            break;

        case NPFS_NTC_CCB:

            break;
        }
    }

    //
    //  Complete the close irp
    //

    NpReleaseVcb( );

    //
    // Complete any deferred IRPs now we have droped the locks
    //
    NpCompleteDeferredIrps (&DeferredList);

    Status = STATUS_SUCCESS;
    NpCompleteRequest (Irp, Status);

    DebugTrace(-1, Dbg, "NpCommonClose -> %08lx\n", Status);
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\npfs\create.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    Create.c

Abstract:

    This module implements the File Create routine for NPFS called by the
    dispatch driver.

Author:

    Gary Kimura     [GaryKi]    21-Aug-1990

Revision History:

--*/

#include "NpProcs.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_CREATE)


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NpCommonCreate)
#pragma alloc_text(PAGE, NpFsdCreate)
#pragma alloc_text(PAGE, NpOpenNamedPipeFileSystem)
#pragma alloc_text(PAGE, NpOpenNamedPipeRootDirectory)
#pragma alloc_text(PAGE, NpCreateClientEnd)
#endif


NTSTATUS
NpFsdCreate (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the FSD part of the NtCreateFile and NtOpenFile
    API calls.

Arguments:

    NpfsDeviceObject - Supplies the device object to use.

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The Fsd status for the Irp

--*/

{
    NTSTATUS Status;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "NpFsdCreate\n", 0);

    //
    //  Call the common create routine.
    //

    FsRtlEnterFileSystem();

    Status = NpCommonCreate( NpfsDeviceObject, Irp );

    FsRtlExitFileSystem();

    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "NpFsdCreate -> %08lx\n", Status );

    return Status;
}

//
//  Internal support routine
//

NTSTATUS
NpCommonCreate (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for creating/opening a file.

Arguments:

    NpfsDeviceObject - Device object for npfs
    
    Irp - Supplies the Irp to process

    DeferredList - List of IRP's to complete later

Return Value:

    NTSTATUS - the return status for the operation

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;

    PFILE_OBJECT FileObject;
    PFILE_OBJECT RelatedFileObject;
    UNICODE_STRING FileName;
    ACCESS_MASK DesiredAccess;
    USHORT ShareAccess;
    BOOLEAN CaseInsensitive = TRUE; //**** Make all searches case insensitive
    PFCB Fcb;
    UNICODE_STRING RemainingPart;
    LIST_ENTRY DeferredList;

    PAGED_CODE();

    InitializeListHead (&DeferredList);
    //
    //  Reference our input parameters to make things easier
    //

    IrpSp             = IoGetCurrentIrpStackLocation( Irp );
    FileObject        = IrpSp->FileObject;
    RelatedFileObject = IrpSp->FileObject->RelatedFileObject;
    FileName          = *(PUNICODE_STRING)&IrpSp->FileObject->FileName;
    DesiredAccess     = IrpSp->Parameters.Create.SecurityContext->DesiredAccess;
    ShareAccess       = IrpSp->Parameters.Create.ShareAccess;

    DebugTrace(+1, Dbg, "NpCommonCreate\n", 0 );
    DebugTrace( 0, Dbg, "NpfsDeviceObject  = %08xl\n", NpfsDeviceObject );
    DebugTrace( 0, Dbg, "Irp               = %08xl\n", Irp );
    DebugTrace( 0, Dbg, "FileObject        = %08xl\n", FileObject );
    DebugTrace( 0, Dbg, "RelatedFileObject = %08xl\n", RelatedFileObject );
    DebugTrace( 0, Dbg, "FileName          = %Z\n",    &FileName );
    DebugTrace( 0, Dbg, "DesiredAccess     = %08xl\n", DesiredAccess );
    DebugTrace( 0, Dbg, "ShareAccess       = %08xl\n", ShareAccess );

    //
    //  Acquire exclusive access to the Vcb
    //

    NpAcquireExclusiveVcb();

    try {

        //
        //  Check if we are trying to open the named pipe file system
        //  (i.e., the Vcb).
        //

        if ((FileName.Length == 0) &&
            ((RelatedFileObject == NULL) || (NodeType(RelatedFileObject->FsContext) == NPFS_NTC_VCB))) {

            DebugTrace(0, Dbg, "Open name pipe file system\n", 0);

            Irp->IoStatus = NpOpenNamedPipeFileSystem( FileObject,
                                                       DesiredAccess,
                                                       ShareAccess );

            Status = Irp->IoStatus.Status;
            try_return( NOTHING );
        }

        //
        //  Check if we are trying to open the root directory
        //

        if (((FileName.Length == 2) && (FileName.Buffer[0] == L'\\') && (RelatedFileObject == NULL))

                ||

            ((FileName.Length == 0) && (NodeType(RelatedFileObject->FsContext) == NPFS_NTC_ROOT_DCB))) {

            DebugTrace(0, Dbg, "Open root directory system\n", 0);

            Irp->IoStatus = NpOpenNamedPipeRootDirectory( NpVcb->RootDcb,
                                                          FileObject,
                                                          DesiredAccess,
                                                          ShareAccess,
                                                          &DeferredList );

            Status = Irp->IoStatus.Status;
            try_return( NOTHING );
        }

        //
        //  If the name is an alias, translate it.
        //

        Status = NpTranslateAlias( &FileName );
        if ( !NT_SUCCESS(Status) ) {
            try_return( NOTHING );
        }

        //
        //  If there is a related file object then this is a relative open
        //  and it better be the root dcb.  Both the then and the else clause
        //  return an Fcb.
        //

        if (RelatedFileObject != NULL) {

            PDCB Dcb;

            Dcb = RelatedFileObject->FsContext;

            if (NodeType(Dcb) != NPFS_NTC_ROOT_DCB) {

                DebugTrace(0, Dbg, "Bad file name\n", 0);

                try_return( Status = STATUS_OBJECT_NAME_INVALID );
            }

            Status = NpFindRelativePrefix( Dcb, &FileName, CaseInsensitive, &RemainingPart, &Fcb );
            if (!NT_SUCCESS (Status)) {
                try_return( NOTHING );
            }

        } else {

            //
            //  The only nonrelative name we allow are of the form "\pipe-name"
            //

            if ((FileName.Length <= 2) || (FileName.Buffer[0] != L'\\')) {

                DebugTrace(0, Dbg, "Bad file name\n", 0);

                try_return( Status = STATUS_OBJECT_NAME_INVALID );
            }

            Fcb = NpFindPrefix( &FileName, CaseInsensitive, &RemainingPart );
        }

        //
        //  If the remaining name is not empty then we have an error, either
        //  we have an illegal name or a non-existent name.
        //

        if (RemainingPart.Length != 0) {

            if (Fcb->NodeTypeCode == NPFS_NTC_FCB) {

                //
                //  We were given a name such as "\pipe-name\another-name"
                //

                DebugTrace(0, Dbg, "Illegal object name\n", 0);

                Status = STATUS_OBJECT_NAME_INVALID;

            } else {

                //
                //  We were given a non-existent name
                //

                DebugTrace(0, Dbg, "non-existent name\n", 0);

                Status = STATUS_OBJECT_NAME_NOT_FOUND;
            }

        } else {

            //
            //  The remaining name is empty so we better have an Fcb otherwise
            //  we have an invalid object name.
            //

            if (Fcb->NodeTypeCode == NPFS_NTC_FCB) {

                DebugTrace(0, Dbg, "Create client end named pipe, Fcb = %08lx\n", Fcb );

                //
                //  If the server has no handles open, then pretend that
                //  the pipe name doesn't exist.
                //

                if ( Fcb->ServerOpenCount == 0 ) {

                    Status = STATUS_OBJECT_NAME_NOT_FOUND;

                } else {

                    Irp->IoStatus = NpCreateClientEnd( Fcb,
                                                       FileObject,
                                                       DesiredAccess,
                                                       ShareAccess,
                                                       IrpSp->Parameters.Create.SecurityContext->SecurityQos,
                                                       IrpSp->Parameters.Create.SecurityContext->AccessState,
                                                       (KPROCESSOR_MODE)(FlagOn(IrpSp->Flags, SL_FORCE_ACCESS_CHECK) ?
                                                                     UserMode : Irp->RequestorMode),
                                                       Irp->Tail.Overlay.Thread,
                                                       &DeferredList );
                    Status = Irp->IoStatus.Status;
                }

            } else {

                DebugTrace(0, Dbg, "Illegal object name\n", 0);

                Status = STATUS_OBJECT_NAME_INVALID;
            }
        }


    try_exit: NOTHING;
    } finally {

        NpReleaseVcb ();

        //
        // Complete any deferred IRPs
        //
        NpCompleteDeferredIrps (&DeferredList);
        NpCompleteRequest (Irp, Status);

        DebugTrace(-1, Dbg, "NpCommonCreate -> %08lx\n", Status);
    }

    return Status;
}


//
//  Internal support routine
//

IO_STATUS_BLOCK
NpCreateClientEnd (
    IN PFCB Fcb,
    IN PFILE_OBJECT FileObject,
    IN ACCESS_MASK DesiredAccess,
    IN USHORT ShareAccess,
    IN PSECURITY_QUALITY_OF_SERVICE SecurityQos,
    IN PACCESS_STATE AccessState,
    IN KPROCESSOR_MODE RequestorMode,
    IN PETHREAD UserThread,
    IN PLIST_ENTRY DeferredList
    )

/*++

Routine Description:

    This routine performs the operation for opening the client end of a named
    pipe.  This routine does not complete the IRP, it performs the function
    and then returns a status

Arguments:

    Fcb - Supplies the Fcb for the named pipe being accessed

    FileObject - Supplies the file object associated with the client end

    DesiredAccess - Supplies the callers desired access

    ShareAccess - Supplies the callers share access

    SecurityQos - Supplies the security qos parameter from the create irp

    AccessState - Supplies the access state parameter from the create irp

    RequestorMode - Supplies the mode of the originating irp

    UserTherad - Supplies the client end user thread

    DeferredList - List of IRP's to complete later

Return Value:

    IO_STATUS_BLOCK - Returns the appropriate status for the operation

--*/

{
    IO_STATUS_BLOCK Iosb={0};

    NAMED_PIPE_CONFIGURATION NamedPipeConfiguration;

    BOOLEAN AccessGranted;
    ACCESS_MASK GrantedAccess;
    UNICODE_STRING Name;

    PCCB Ccb;
    PNONPAGED_CCB NonpagedCcb;
    PLIST_ENTRY Links;
    PPRIVILEGE_SET Privileges = NULL;

    DebugTrace(+1, Dbg, "NpCreateClientEnd\n", 0 );

    NamedPipeConfiguration = Fcb->Specific.Fcb.NamedPipeConfiguration;


    //
    //  "Create Pipe Instance" access is part of generic write and so
    //  we need to mask out the bit.  Even if the client has explicitly
    //  asked for "create pipe instance" access we will mask it out.
    //  This will allow the default ACL to be strengthened to protect
    //  against spurious threads from creating new pipe instances.
    //

    DesiredAccess &= ~FILE_CREATE_PIPE_INSTANCE;

    //
    //  First do an access check for the user against the Fcb
    //

    SeLockSubjectContext( &AccessState->SubjectSecurityContext );

    AccessGranted = SeAccessCheck( Fcb->SecurityDescriptor,
                                   &AccessState->SubjectSecurityContext,
                                   TRUE,                  // Tokens are locked
                                   DesiredAccess,
                                   0,
                                   &Privileges,
                                   IoGetFileObjectGenericMapping(),
                                   RequestorMode,
                                   &GrantedAccess,
                                   &Iosb.Status
                                   );

    if (Privileges != NULL) {

          (VOID) SeAppendPrivileges(
                     AccessState,
                     Privileges
                     );

        SeFreePrivileges( Privileges );
    }

    //
    //  Transfer over the access masks from what is desired to
    //  what we just granted.  Also patch up the maximum allowed
    //  case because we just did the mapping for it.  Note that if
    //  the user didn't ask for maximum allowed then the following
    //  code is still okay because we'll just zero a zero bit.
    //

    if (AccessGranted) {

        AccessState->PreviouslyGrantedAccess |= GrantedAccess;

        AccessState->RemainingDesiredAccess &= ~(GrantedAccess | MAXIMUM_ALLOWED);
    }

    RtlInitUnicodeString( &Name, L"NamedPipe" );

    SeOpenObjectAuditAlarm( &Name,
                            NULL,
                            &FileObject->FileName,
                            Fcb->SecurityDescriptor,
                            AccessState,
                            FALSE,
                            AccessGranted,
                            RequestorMode,
                            &AccessState->GenerateOnClose );

    SeUnlockSubjectContext( &AccessState->SubjectSecurityContext );

    if (!AccessGranted) {

        DebugTrace(0, Dbg, "Access Denied\n", 0 );

        return Iosb;
    }

    //
    //  Check if the user wants to write to an outbound pipe or read from
    //  and inbound pipe.  And if so then tell the user the error
    //

    if ((FlagOn(DesiredAccess, FILE_READ_DATA) && (NamedPipeConfiguration == FILE_PIPE_INBOUND)) ||
        (FlagOn(DesiredAccess, FILE_WRITE_DATA) && (NamedPipeConfiguration == FILE_PIPE_OUTBOUND))) {

        Iosb.Status = STATUS_ACCESS_DENIED;

        return Iosb;
    }

    //
    //  First try and find a ccb that is in the listening state.  If we
    //  exit the loop with Ccb not equal to null then we've found one.
    //

    Ccb = NULL;
    for (Links = Fcb->Specific.Fcb.CcbQueue.Flink;
         Links != &Fcb->Specific.Fcb.CcbQueue;
         Links = Links->Flink) {

        Ccb = CONTAINING_RECORD( Links, CCB, CcbLinks );
        NonpagedCcb = Ccb->NonpagedCcb;

        if (Ccb->NamedPipeState == FILE_PIPE_LISTENING_STATE) {

            DebugTrace(0, Dbg, "Located listening ccb = %08lx\n", Ccb);

            break;
        }

        Ccb = NULL;
    }

    //
    //  Check that we found one
    //

    if (Ccb == NULL) {
        Iosb.Status = STATUS_PIPE_NOT_AVAILABLE;
        return Iosb;
    }

    NpfsVerifyCcb( __FILE__, __LINE__, Ccb );

    //
    //  Now make sure our share access is okay.  If the user is asking
    //  for read data then given him shared read, if he's asking for
    //  write data then given him shared write.
    //

    if (NamedPipeConfiguration == FILE_PIPE_OUTBOUND) {

        ShareAccess = FILE_SHARE_READ;

    } else if (NamedPipeConfiguration == FILE_PIPE_INBOUND) {

        ShareAccess = FILE_SHARE_WRITE;

    } else {

       ShareAccess = (FILE_SHARE_READ | FILE_SHARE_WRITE);
    }

    if (FlagOn(DesiredAccess, FILE_READ_DATA )) { ShareAccess |= FILE_SHARE_READ; }
    if (FlagOn(DesiredAccess, FILE_WRITE_DATA)) { ShareAccess |= FILE_SHARE_WRITE; }


    if (!NT_SUCCESS(Iosb.Status = NpInitializeSecurity( Ccb,
                                                        SecurityQos,
                                                        UserThread ))) {

        DebugTrace(0, Dbg, "Security QOS error\n", 0);

        return Iosb;
    }

    //
    //  Set the pipe into the connect state, the read mode to byte stream,
    //  and the completion mode to queued operation.  This also
    //  sets the client file object's back pointer to the ccb
    //

    if (!NT_SUCCESS(Iosb.Status = NpSetConnectedPipeState( Ccb,
                                                           FileObject,
                                                           DeferredList ))) {

        NpUninitializeSecurity (Ccb);

        NpfsVerifyCcb( __FILE__, __LINE__, Ccb );

        return Iosb;
    }

    NpfsVerifyCcb( __FILE__, __LINE__, Ccb );

    //
    //  Set up the client session and info.  NULL for the
    //  client info indicates a local session.
    //

    Ccb->ClientInfo = NULL;
    Ccb->ClientProcess = IoThreadToProcess( UserThread );

    NpfsVerifyCcb( __FILE__, __LINE__, Ccb );

    //
    //  And set our return status
    //

    Iosb.Status = STATUS_SUCCESS;
    Iosb.Information = FILE_OPENED;

    DebugTrace(-1, Dbg, "NpCreateClientEnd -> %08lx\n", Iosb.Status);

    return Iosb;
}


//
//  Internal support routine
//

IO_STATUS_BLOCK
NpOpenNamedPipeFileSystem (
    IN PFILE_OBJECT FileObject,
    IN ACCESS_MASK DesiredAccess,
    IN USHORT ShareAccess
    )

{
    IO_STATUS_BLOCK Iosb = {0};

    PAGED_CODE();

    DebugTrace(+1, Dbg, "NpOpenNamedPipeFileSystem, Vcb = %08lx\n", NpVcb);


    //
    //  Set the new share access. This is protected by the VCB lock.
    //
    ASSERT (NpIsAcquiredExclusiveVcb(NpVcb));

    if (NT_SUCCESS(Iosb.Status = IoCheckShareAccess( DesiredAccess,
                                                     ShareAccess,
                                                     FileObject,
                                                     &NpVcb->ShareAccess,
                                                     TRUE ))) {


        //
        //  Have the file object point back to the Vcb, and increment the
        //  open count.  The pipe end on the call to set file object really
        //  doesn't matter.
        //

        NpSetFileObject( FileObject, NpVcb, NULL, FILE_PIPE_CLIENT_END );

        NpVcb->OpenCount += 1;

        //
        //  Set our return status
        //
        Iosb.Status = STATUS_SUCCESS;
        Iosb.Information = FILE_OPENED;
    }

    //
    //  And return to our caller
    //

    return Iosb;
}


//
//  Internal support routine
//

IO_STATUS_BLOCK
NpOpenNamedPipeRootDirectory(
    IN PROOT_DCB RootDcb,
    IN PFILE_OBJECT FileObject,
    IN ACCESS_MASK DesiredAccess,
    IN USHORT ShareAccess,
    IN PLIST_ENTRY DeferredList
    )

{
    IO_STATUS_BLOCK Iosb={0};
    PROOT_DCB_CCB Ccb;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "NpOpenNamedPipeRootDirectory, RootDcb = %08lx\n", RootDcb);

    Iosb.Status = NpCreateRootDcbCcb (&Ccb);
    if (!NT_SUCCESS(Iosb.Status)) {
        return Iosb;
    }
    //
    //  Set the new share access, Check we are synchronized.0
    //
    ASSERT (NpIsAcquiredExclusiveVcb(NpVcb));
    if (!NT_SUCCESS(Iosb.Status = IoCheckShareAccess( DesiredAccess,
                                                      ShareAccess,
                                                      FileObject,
                                                      &RootDcb->Specific.Dcb.ShareAccess,
                                                      TRUE ))) {

        DebugTrace(0, Dbg, "bad share access\n", 0);

        NpDeleteCcb ((PCCB) Ccb, DeferredList);
        return Iosb;
    }

    //
    //  Have the file object point back to the Dcb, and reference the root
    //  dcb, ccb, and increment our open count.  The pipe end on the
    //  call to set file object really doesn't matter.
    //

    NpSetFileObject( FileObject,
                     RootDcb,
                     Ccb,
                     FILE_PIPE_CLIENT_END );

    RootDcb->OpenCount += 1;

    //
    //  Set our return status
    //

    Iosb.Status = STATUS_SUCCESS;
    Iosb.Information = FILE_OPENED;

    DebugTrace(-1, Dbg, "NpOpenNamedPipeRootDirectory -> Iosb.Status = %08lx\n", Iosb.Status);

    //
    //  And return to our caller
    //

    return Iosb;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\npfs\aliassup.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    AliasSup.c

Abstract:

    This module implements alias support for the Named Pipe file system.

Author:

    Chuck Lenzmeier [chuckl]    16-Nov-1993

Revision History:

--*/

#include "NpProcs.h"

//
// Registry path (relative to Services key) to alias list
//

#define ALIAS_PATH L"Npfs\\Aliases"

//
//  The Alias record defines an aliased pipe name -- what the original
//  name is, and what it should be translated to.  Alias records are
//  linked together in singly linked lists.
//

typedef struct _ALIAS {
    SINGLE_LIST_ENTRY ListEntry;
    PUNICODE_STRING TranslationString;
    UNICODE_STRING AliasString;
} ALIAS, *PALIAS;

//
//  ALIAS_CONTEXT is used during initialization to pass context to the
//  ReadAlias routine, which is called by RtlQueryRegistryValues.
//

typedef struct _ALIAS_CONTEXT {
    BOOLEAN Phase1;
    ULONG RequiredSize;
    ULONG AliasCount;
    ULONG TranslationCount;
    PALIAS NextAlias;
    PUNICODE_STRING NextTranslation;
    PWCH NextStringData;
} ALIAS_CONTEXT, *PALIAS_CONTEXT;

//
//  Forward declarations.
//

NTSTATUS
NpReadAlias (
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, NpInitializeAliases)
#pragma alloc_text(INIT, NpReadAlias)
#pragma alloc_text(PAGE, NpTranslateAlias)
#pragma alloc_text(PAGE, NpUninitializeAliases)
#endif


NTSTATUS
NpInitializeAliases (
    VOID
    )

/*++

Routine Description:

    This routine initializes the alias package.  It reads the registry,
    builds the alias list, and sorts it.

Arguments:

    None.

Return Value:

    NTSTATUS - Returns an error if the contents of the registry contents
        are invalid or if an allocation fails.

--*/

{
    RTL_QUERY_REGISTRY_TABLE QueryTable[2];
    ALIAS_CONTEXT Context;
    NTSTATUS Status;
    PALIAS Alias;
    ULONG i;
    ULONG Length;
    PSINGLE_LIST_ENTRY PreviousEntry;
    PSINGLE_LIST_ENTRY Entry;
    PALIAS TestAlias;

    //
    //  Phase 1:  Calculate number of aliases and size of alias buffer.
    //

    QueryTable[0].QueryRoutine = NpReadAlias;
    QueryTable[0].Flags = RTL_QUERY_REGISTRY_NOEXPAND;
    QueryTable[0].Name = NULL;
    QueryTable[0].EntryContext = NULL;
    QueryTable[0].DefaultType = REG_NONE;
    QueryTable[0].DefaultData = NULL;
    QueryTable[0].DefaultLength = 0;

    QueryTable[1].QueryRoutine = NULL;
    QueryTable[1].Flags = 0;
    QueryTable[1].Name = NULL;

    Context.Phase1 = TRUE;
    Context.RequiredSize = 0;
    Context.AliasCount = 0;
    Context.TranslationCount = 0;

    Status = RtlQueryRegistryValues(
                RTL_REGISTRY_SERVICES | RTL_REGISTRY_OPTIONAL,
                ALIAS_PATH,
                QueryTable,
                &Context,
                NULL
                );

    //
    //  If an error occurred, return that error, unless the alias
    //  key wasn't present, which is not an error.  Also, if the key
    //  was there, but was empty, this is not an error.
    //

    if (!NT_SUCCESS(Status)) {
        if ( Status == STATUS_OBJECT_NAME_NOT_FOUND ) {
            Status = STATUS_SUCCESS;
        }
        return Status;
    }

    if (Context.RequiredSize == 0) {
        return STATUS_SUCCESS;
    }

    //
    //  Allocate a buffer to hold the alias information.
    //

    NpAliases = NpAllocateNonPagedPool( Context.RequiredSize, 'sfpN');
    if (NpAliases == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    //  Phase 2:  Read alias information into the alias buffer.
    //

    Context.Phase1 = FALSE;
    Context.NextTranslation = (PUNICODE_STRING)NpAliases;
    Alias = Context.NextAlias =
                (PALIAS)(Context.NextTranslation + Context.TranslationCount);
    Context.NextStringData = (PWCH)(Context.NextAlias + Context.AliasCount);

    Status = RtlQueryRegistryValues(
                RTL_REGISTRY_SERVICES | RTL_REGISTRY_OPTIONAL,
                ALIAS_PATH,
                QueryTable,
                &Context,
                NULL
                );
    if (!NT_SUCCESS(Status)) {
        NpFreePool( NpAliases );
        NpAliases = NULL;
        return Status;
    }

    //
    //  Phase 3:  Link aliases into alias lists.
    //

    for ( i = 0;
          i < Context.AliasCount;
          i++, Alias++ ) {

        //
        //  Point to the appropriate list head.
        //

        Length = Alias->AliasString.Length;
        if ( (Length >= MIN_LENGTH_ALIAS_ARRAY) &&
             (Length <= MAX_LENGTH_ALIAS_ARRAY) ) {
            PreviousEntry = &NpAliasListByLength[(Length - MIN_LENGTH_ALIAS_ARRAY) / sizeof(WCHAR)];
        } else {
            PreviousEntry = &NpAliasList;
        }

        //
        //  Walk the list to determine the proper place for this alias.
        //

        for ( Entry = PreviousEntry->Next;
              Entry != NULL;
              PreviousEntry = Entry, Entry = Entry->Next ) {

            TestAlias = CONTAINING_RECORD( Entry, ALIAS, ListEntry );

            //
            //  If the test alias is longer than the new alias, we want to
            //  insert the new alias in front of the test alias.  If the
            //  test alias is shorter, we need to continue walking the list.
            //

            if ( TestAlias->AliasString.Length > Length ) break;
            if ( TestAlias->AliasString.Length < Length ) continue;

            //
            //  The aliases are the same length.  Compare them.  If the new
            //  alias is lexically before the test alias, we want to insert
            //  it in front of the test alias.  If it's after, we need to
            //  keep walking.
            //
            //  Alias and TestAlias should never have the same string, but
            //  if they do, we'll insert the second occurrence of the string
            //  immediately after the first one, and all will be well.
            //

            if ( _wcsicmp( Alias->AliasString.Buffer,
                          TestAlias->AliasString.Buffer ) < 0 ) {
                break;
            }

        }

        //
        //  We have found the place where this alias belongs.  PreviousEntry
        //  points to the alias that the new alias should follow.
        //  (PreviousEntry may point to the list head.)
        //

        Alias->ListEntry.Next = PreviousEntry->Next;
        PreviousEntry->Next = &Alias->ListEntry;

    }

#if 0
    for ( Length = MIN_LENGTH_ALIAS_ARRAY;
          Length <= MAX_LENGTH_ALIAS_ARRAY + 2;
          Length += 2 ) {
        if ( (Length >= MIN_LENGTH_ALIAS_ARRAY) &&
             (Length <= MAX_LENGTH_ALIAS_ARRAY) ) {
            PreviousEntry = &NpAliasListByLength[(Length - MIN_LENGTH_ALIAS_ARRAY) / sizeof(WCHAR)];
            DbgPrint( "Length %d list:\n", Length );
        } else {
            PreviousEntry = &NpAliasList;
            DbgPrint( "Odd length list:\n" );
        }
        for ( Entry = PreviousEntry->Next;
              Entry != NULL;
              Entry = Entry->Next ) {
            Alias = CONTAINING_RECORD( Entry, ALIAS, ListEntry );
            DbgPrint( "  %wZ -> %wZ\n", &Alias->AliasString, Alias->TranslationString );
        }
    }
#endif

    return STATUS_SUCCESS;

}


NTSTATUS
NpReadAlias (
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    )
{
    PALIAS_CONTEXT Ctx = Context;
    USHORT Length;
    PWCH p;
    PUNICODE_STRING TranslationString;
    PALIAS Alias;

    //
    //  The value must be a REG_MULTI_SZ value.
    //

    if (ValueType != REG_MULTI_SZ) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  In phase 1, we calculate the required size of the alias buffer.
    //  In phase 2, we build the alias descriptors.
    //

    if ( Ctx->Phase1 ) {

        //
        //  The value name is the translation.  The value data is one or
        //  more strings that are aliases for the translation.
        //
        //  The "1+" and "sizeof(WCHAR)+" are for the '\' that will be
        //  placed in front of the translation string and the alias string.
        //

        Ctx->TranslationCount++;
        Length = (USHORT)((1 + wcslen(ValueName) + 1) * sizeof(WCHAR));
        Ctx->RequiredSize += Length + sizeof(UNICODE_STRING);

        p = ValueData;
        while ( *p != 0 ) {
            Ctx->AliasCount++;
            Length = (USHORT)((wcslen(p) + 1) * sizeof(WCHAR));
            Ctx->RequiredSize += sizeof(WCHAR) + Length + sizeof(ALIAS);
            p = (PWCH)((PCHAR)p + Length);
        }

    } else {

        //
        //  Build a string descriptor for the translation string.
        //

        TranslationString = Ctx->NextTranslation++;
        Length = (USHORT)((1 + wcslen(ValueName) + 1) * sizeof(WCHAR));
        TranslationString->Length = Length - sizeof(WCHAR);
        TranslationString->MaximumLength = Length;
        TranslationString->Buffer = Ctx->NextStringData;
        Ctx->NextStringData = (PWCH)((PCHAR)Ctx->NextStringData + Length);

        //
        //  Copy the string data.  Place a '\' at the beginning.
        //

        TranslationString->Buffer[0] = L'\\';
        RtlCopyMemory( &TranslationString->Buffer[1],
                       ValueName,
                       Length - sizeof(WCHAR) );

        //
        //  Upcase the string.
        //

        RtlUpcaseUnicodeString( TranslationString,
                                TranslationString,
                                FALSE );
        //
        //  Build aliases descriptors.
        //

        p = ValueData;

        while ( *p != 0 ) {

            Alias = Ctx->NextAlias++;

            //
            //  Point the alias descriptor to the translation string.
            //

            Alias->TranslationString = TranslationString;

            //
            //  Build the alias string descriptor.
            //

            Length = (USHORT)((1 + wcslen(p) + 1) * sizeof(WCHAR));
            Alias->AliasString.Length = Length - sizeof(WCHAR);
            Alias->AliasString.MaximumLength = Length;
            Alias->AliasString.Buffer = Ctx->NextStringData;
            Ctx->NextStringData = (PWCH)((PCHAR)Ctx->NextStringData + Length);

            //
            //  Copy the string data.  Place a '\' at the beginning.
            //

            Alias->AliasString.Buffer[0] = L'\\';
            RtlCopyMemory( &Alias->AliasString.Buffer[1],
                           p,
                           Length - sizeof(WCHAR) );

            //
            //  Upcase the string.
            //

            RtlUpcaseUnicodeString( &Alias->AliasString,
                                    &Alias->AliasString,
                                    FALSE );

            p = (PWCH)((PCHAR)p + Length - sizeof(WCHAR));

        }

    }

    return STATUS_SUCCESS;

}


NTSTATUS
NpTranslateAlias (
    IN OUT PUNICODE_STRING String
    )

/*++

Routine Description:

    This routine translates a pipe name string based on information
    obtained from the registry at boot time.  This translation is used
    to allow RPC services that had different names in NT 1.0 to have
    common names in 1.0a and beyond.

Arguments:

    String - Supplies the input string to search for; returns the output
        string, if the name was translated.  If so, the string points to
        a buffer allocated from paged pool.  The caller should NOT free
        this buffer.

Return Value:

    NTSTATUS - Returns STATUS_SUCCESS unless an allocation failure occurs.
        The status does NOT indicate whether the name was translated.

--*/

{
    NTSTATUS Status;
    UNICODE_STRING UpcaseString;
    ULONG Length;
    PSINGLE_LIST_ENTRY Entry;
    PALIAS Alias;
    PWCH sp, ap;
    WCHAR a, s;
    BOOLEAN NoSlash;

    WCHAR UpcaseBuffer[MAX_LENGTH_ALIAS_ARRAY];
    BOOLEAN FreeUpcaseBuffer;

    PAGED_CODE();

    //
    //  Before upcasing the string (a relatively expensive operation),
    //  make sure that the string length matches at least one alias.
    //

    Length = String->Length;
    if ( Length == 0 ) {
        return STATUS_SUCCESS;
    }

    if ( *String->Buffer != L'\\' ) {
        Length += sizeof(WCHAR);
        NoSlash = TRUE;
    } else {
        NoSlash = FALSE;
    }

    if ( (Length >= MIN_LENGTH_ALIAS_ARRAY) &&
         (Length <= MAX_LENGTH_ALIAS_ARRAY) ) {
        Entry = NpAliasListByLength[(Length - MIN_LENGTH_ALIAS_ARRAY) / sizeof(WCHAR)].Next;
        Alias = CONTAINING_RECORD( Entry, ALIAS, ListEntry );
    } else {
        Entry = NpAliasList.Next;
        while ( Entry != NULL ) {
            Alias = CONTAINING_RECORD( Entry, ALIAS, ListEntry );
            if ( Alias->AliasString.Length == Length ) {
                break;
            }
            if ( Alias->AliasString.Length > Length ) {
                return STATUS_SUCCESS;
            }
            Entry = Entry->Next;
        }
    }

    if ( Entry == NULL ) {
        return STATUS_SUCCESS;
    }

    //
    //  The string's length matches at least one alias.  Upcase the string.
    //

    if ( Length <= MAX_LENGTH_ALIAS_ARRAY ) {
        UpcaseString.MaximumLength = MAX_LENGTH_ALIAS_ARRAY;
        UpcaseString.Buffer = UpcaseBuffer;
        Status = RtlUpcaseUnicodeString( &UpcaseString, String, FALSE );
        ASSERT( NT_SUCCESS(Status) );
        FreeUpcaseBuffer = FALSE;
    } else {
        Status = RtlUpcaseUnicodeString( &UpcaseString, String, TRUE );
        if ( !NT_SUCCESS(Status) ) {
            return Status;
        }
        FreeUpcaseBuffer = TRUE;
    }

    ASSERT( UpcaseString.Length == (Length - (NoSlash ? sizeof(WCHAR) : 0)) );

    //
    //  At this point, Entry points to an alias list entry whose length
    //  matches that of the input string.  This list entry may be the
    //  first element of a length-specific list (in which all entries
    //  have the same length), or it may be an element of a length-ordered
    //  list (in which case we'll need to check each next entry to see if
    //  it's the same length.  In both cases, strings of the same length
    //  are in lexical order.
    //
    //  Try to match the upcased string up to an alias.
    //

    do {

        sp = UpcaseString.Buffer;
        ap = Alias->AliasString.Buffer;
        if ( NoSlash ) {
            ap++;
        }

        while ( TRUE ) {
            a = *ap;
            if ( a == 0 ) {
                *String = *Alias->TranslationString;
                if ( NoSlash ) {
                    String->Length -= sizeof(WCHAR);
                    String->Buffer++;
                }
                goto exit;
            }
            s = *sp;
            if ( s < a ) goto exit;
            if ( s > a ) break;
            sp++;
            ap++;
        }

        //
        //  The input string doesn't match the current alias.  Move to
        //  the next one.
        //

        Entry = Entry->Next;
        if ( Entry == NULL ) {
            goto exit;
        }

        Alias = CONTAINING_RECORD( Entry, ALIAS, ListEntry );

    } while ( Alias->AliasString.Length == Length );

exit:

    if (FreeUpcaseBuffer) {
        ASSERT( UpcaseString.Buffer != UpcaseBuffer );
        NpFreePool( UpcaseString.Buffer );
    }

    return STATUS_SUCCESS;

}

VOID
NpUninitializeAliases (
    VOID
    )

/*++

Routine Description:

    This routine uninitializes the alias package.

Arguments:

    None.

Return Value:

    None

--*/
{
    NpFreePool( NpAliases );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\npfs\createnp.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    CreateNp.c

Abstract:

    This module implements the File Create Named Pipe routine for NPFS called
    by the dispatch driver.

Author:

    Gary Kimura     [GaryKi]    04-Sep-1990

Revision History:

--*/

#include "NpProcs.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_CREATE_NAMED_PIPE)


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NpCommonCreateNamedPipe)
#pragma alloc_text(PAGE, NpCreateExistingNamedPipe)
#pragma alloc_text(PAGE, NpCreateNewNamedPipe)
#pragma alloc_text(PAGE, NpFsdCreateNamedPipe)
#endif


NTSTATUS
NpFsdCreateNamedPipe (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the FSD part of the NtCreateNamedPipeFile
    API call.

Arguments:

    NpfsDeviceObject - Supplies the device object to use.

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The Fsd status for the Irp

--*/

{
    NTSTATUS Status;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "NpFsdCreateNamedPipe\n", 0);

    //
    //  Call the common create routine.
    //

    FsRtlEnterFileSystem();

    Status = NpCommonCreateNamedPipe( NpfsDeviceObject, Irp );

    FsRtlExitFileSystem();

    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "NpFsdCreateNamedPipe -> %08lx\n", Status );

    return Status;
}

//
//  Internal support routine
//

NTSTATUS
NpCommonCreateNamedPipe (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for creating/opening a file.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - the return status for the operation

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;

    PFILE_OBJECT FileObject;
    PFILE_OBJECT RelatedFileObject;
    UNICODE_STRING FileName;
    ACCESS_MASK DesiredAccess;
    ULONG Options;
    USHORT ShareAccess;
    PNAMED_PIPE_CREATE_PARAMETERS Parameters;
    NAMED_PIPE_TYPE NamedPipeType;
    READ_MODE ServerReadMode;
    COMPLETION_MODE ServerCompletionMode;
    ULONG MaximumInstances;
    ULONG InboundQuota;
    ULONG OutboundQuota;
    LARGE_INTEGER DefaultTimeout;
    BOOLEAN TimeoutSpecified;
    PEPROCESS CreatorProcess;
    BOOLEAN CaseInsensitive = TRUE; //**** Make all searches case insensitive
    PFCB Fcb;
    ULONG CreateDisposition;
    UNICODE_STRING RemainingPart;
    LIST_ENTRY DeferredList;

    PAGED_CODE();

    InitializeListHead (&DeferredList);
    //
    //  Reference our input parameters to make things easier
    //

    IrpSp                = IoGetCurrentIrpStackLocation( Irp );
    FileObject           = IrpSp->FileObject;
    RelatedFileObject    = IrpSp->FileObject->RelatedFileObject;
    FileName             = *(PUNICODE_STRING)&IrpSp->FileObject->FileName;
    DesiredAccess        = IrpSp->Parameters.CreatePipe.SecurityContext->DesiredAccess;
    Options              = IrpSp->Parameters.CreatePipe.Options;
    ShareAccess          = IrpSp->Parameters.CreatePipe.ShareAccess;
    Parameters           = IrpSp->Parameters.CreatePipe.Parameters;
    NamedPipeType        = Parameters->NamedPipeType;
    ServerReadMode       = Parameters->ReadMode;
    ServerCompletionMode = Parameters->CompletionMode;
    MaximumInstances     = Parameters->MaximumInstances;
    InboundQuota         = Parameters->InboundQuota;
    OutboundQuota        = Parameters->OutboundQuota;
    DefaultTimeout       = Parameters->DefaultTimeout;
    TimeoutSpecified     = Parameters->TimeoutSpecified;
    CreatorProcess       = IoGetRequestorProcess( Irp );

    DebugTrace(+1, Dbg, "NpCommonCreateNamedPipe\n", 0 );
    DebugTrace( 0, Dbg, "NpfsDeviceObject     = %08lx\n", NpfsDeviceObject );
    DebugTrace( 0, Dbg, "Irp                  = %08lx\n", Irp );
    DebugTrace( 0, Dbg, "FileObject           = %08lx\n", FileObject );
    DebugTrace( 0, Dbg, "RelatedFileObject    = %08lx\n", RelatedFileObject );
    DebugTrace( 0, Dbg, "FileName             = %Z\n",    &FileName );
    DebugTrace( 0, Dbg, "DesiredAccess        = %08lx\n", DesiredAccess );
    DebugTrace( 0, Dbg, "Options              = %08lx\n", Options );
    DebugTrace( 0, Dbg, "ShareAccess          = %08lx\n", ShareAccess );
    DebugTrace( 0, Dbg, "Parameters           = %08lx\n", Parameters );
    DebugTrace( 0, Dbg, "NamedPipeType        = %08lx\n", NamedPipeType );
    DebugTrace( 0, Dbg, "ServerReadMode       = %08lx\n", ServerReadMode );
    DebugTrace( 0, Dbg, "ServerCompletionMode = %08lx\n", ServerCompletionMode );
    DebugTrace( 0, Dbg, "MaximumInstances     = %08lx\n", MaximumInstances );
    DebugTrace( 0, Dbg, "InboundQuota         = %08lx\n", InboundQuota );
    DebugTrace( 0, Dbg, "OutboundQuota        = %08lx\n", OutboundQuota );
    DebugTrace( 0, Dbg, "DefaultTimeout       = %08lx\n", DefaultTimeout );
    DebugTrace( 0, Dbg, "TimeoutSpecified     = %08lx\n", TimeoutSpecified );
    DebugTrace( 0, Dbg, "CreatorProcess       = %08lx\n", CreatorProcess );

    //
    //  Extract the create disposition
    //

    CreateDisposition = (Options >> 24) & 0x000000ff;

    //
    //  Acquire exclusive access to the Vcb.
    //

    NpAcquireExclusiveVcb();
    try {

        //
        //  If there is a related file object then this is a relative open
        //  and it better be the root dcb.  Both the then and the else clause
        //  return an Fcb.
        //

        if (RelatedFileObject != NULL) {

            PDCB Dcb;

            Dcb = RelatedFileObject->FsContext;

            if (NodeType(Dcb) != NPFS_NTC_ROOT_DCB ||
                FileName.Length < 2 || FileName.Buffer[0] == L'\\') {

                DebugTrace(0, Dbg, "Bad file name\n", 0);

                try_return( Status = STATUS_OBJECT_NAME_INVALID );
            }

            Status = NpFindRelativePrefix( Dcb, &FileName, CaseInsensitive, &RemainingPart, &Fcb);
            if (!NT_SUCCESS (Status)) {
                try_return(NOTHING);
            }

        } else {

            //
            //  The only nonrelative name we allow are of the form "\pipe-name"
            //

            if ((FileName.Length <= 2) || (FileName.Buffer[0] != L'\\')) {

                DebugTrace(0, Dbg, "Bad file name\n", 0);

                try_return( Status = STATUS_OBJECT_NAME_INVALID );
            }

            Fcb = NpFindPrefix( &FileName, CaseInsensitive, &RemainingPart );
        }

        //
        //  If the remaining name is empty then we better have an fcb
        //  otherwise we were given a illegal object name.
        //

        if (RemainingPart.Length == 0) {

            if (Fcb->NodeTypeCode == NPFS_NTC_FCB) {

                DebugTrace(0, Dbg, "Create existing named pipe, Fcb = %08lx\n", Fcb );

                Irp->IoStatus = NpCreateExistingNamedPipe( Fcb,
                                                           FileObject,
                                                           DesiredAccess,
                                                           IrpSp->Parameters.CreatePipe.SecurityContext->AccessState,
                                                           (KPROCESSOR_MODE)(FlagOn(IrpSp->Flags, SL_FORCE_ACCESS_CHECK) ?
                                                                             UserMode : Irp->RequestorMode),
                                                           CreateDisposition,
                                                           ShareAccess,
                                                           ServerReadMode,
                                                           ServerCompletionMode,
                                                           InboundQuota,
                                                           OutboundQuota,
                                                           CreatorProcess,
                                                           &DeferredList );
                Status = Irp->IoStatus.Status;

            } else {

                DebugTrace(0, Dbg, "Illegal object name\n", 0);

                Status = STATUS_OBJECT_NAME_INVALID;
            }

        } else {

            //
            //  The remaining name is not empty so we better have the root Dcb
            //

            if (Fcb->NodeTypeCode == NPFS_NTC_ROOT_DCB) {

                DebugTrace(0, Dbg, "Create new named pipe, Fcb = %08lx\n", Fcb );

                Irp->IoStatus = NpCreateNewNamedPipe( Fcb,
                                                      FileObject,
                                                      FileName,
                                                      DesiredAccess,
                                                      IrpSp->Parameters.CreatePipe.SecurityContext->AccessState,
                                                      CreateDisposition,
                                                      ShareAccess,
                                                      NamedPipeType,
                                                      ServerReadMode,
                                                      ServerCompletionMode,
                                                      MaximumInstances,
                                                      InboundQuota,
                                                      OutboundQuota,
                                                      DefaultTimeout,
                                                      TimeoutSpecified,
                                                      CreatorProcess,
                                                      &DeferredList );
                Status = Irp->IoStatus.Status;

            } else {

                DebugTrace(0, Dbg, "Illegal object name\n", 0);

                Status = STATUS_OBJECT_NAME_INVALID;
            }
        }


    try_exit: NOTHING;
    } finally {

        NpReleaseVcb( );

        //
        // complete any deferred IRPs now we have dropped the locks
        //
        NpCompleteDeferredIrps (&DeferredList);

        NpCompleteRequest( Irp, Status );

        DebugTrace(-1, Dbg, "NpCommonCreateNamedPipe -> %08lx\n", Status);
    }

    return Status;
}


//
//  Internal support routine
//

IO_STATUS_BLOCK
NpCreateNewNamedPipe (
    IN PROOT_DCB RootDcb,
    IN PFILE_OBJECT FileObject,
    IN UNICODE_STRING FileName,
    IN ACCESS_MASK DesiredAccess,
    IN PACCESS_STATE AccessState,
    IN ULONG CreateDisposition,
    IN USHORT ShareAccess,
    IN ULONG NamedPipeType,
    IN ULONG ServerReadMode,
    IN ULONG ServerCompletionMode,
    IN ULONG MaximumInstances,
    IN ULONG InboundQuota,
    IN ULONG OutboundQuota,
    IN LARGE_INTEGER DefaultTimeout,
    IN BOOLEAN TimeoutSpecified,
    IN PEPROCESS CreatorProcess,
    IN PLIST_ENTRY DeferredList
    )

/*++

Routine Description:

    This routine performs the operation for creating a new named pipe
    Fcb and its first instance.  This routine does not complete any
    IRP, it preforms its function and then returns an iosb.

Arguments:

    RootDcb - Supplies the root dcb where this is going to be added

    FileObject - Supplies the file object associated with the first
        instance of the named pipe

    FileName - Supplies the name of the named pipe (not qualified i.e.,
        simply "pipe-name" and not "\pipe-name"

    DesiredAccess - Supplies the callers desired access

    AccessState - Supplies the access state from the irp

    CreateDisposition - Supplies the callers create disposition flags

    ShareAccess - Supplies the caller specified share access

    NamedPipeType - Supplies the named type type

    ServerReadMode - Supplies the named pipe read mode

    ServerCompletionMode - Supplies the named pipe completion mode

    MaximumInstances - Supplies the maximum instances for the named pipe

    InboundQuota - Supplies the inbound quota amount

    OutboundQuota - Supplies the outbound quota amount

    DefaultTimeout - Supplies the default time out value

    TimeoutSpecified - Indicates if the time out value was supplied by the
        caller.

    CreatorProcess - Supplies the process creating the named pipe

    DeferredList - List of IRP's to complete after we release the locks

Return Value:

    IO_STATUS_BLOCK - Returns the appropriate status for the operation

--*/

{
    IO_STATUS_BLOCK Iosb={0};

    NAMED_PIPE_CONFIGURATION NamedPipeConfiguration;
    PSECURITY_DESCRIPTOR NewSecurityDescriptor, CachedSecurityDescriptor;

    PFCB Fcb;
    PCCB Ccb;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "NpCreateNewNamedPipe\n", 0 );

    //
    //  Check the parameters that must be supplied for a new named pipe
    //  (i.e., the create disposition, timeout, and max instances better
    //  be greater than zero)
    //

    if (!TimeoutSpecified || MaximumInstances <= 0) {
        Iosb.Status = STATUS_INVALID_PARAMETER;
        return Iosb;
    }

    //
    //  The default timeout needs to be less than zero otherwise it
    //  is an absolute time out which doesn't make sense.
    //
    if (DefaultTimeout.QuadPart >= 0) {
        Iosb.Status = STATUS_INVALID_PARAMETER;
        return Iosb;
    }

    if (CreateDisposition == FILE_OPEN) {
        Iosb.Status = STATUS_OBJECT_NAME_NOT_FOUND;
        return Iosb;
    }

    //
    //  Determine the pipe configuration
    //
    if (ShareAccess == (FILE_SHARE_READ | FILE_SHARE_WRITE)) {
        NamedPipeConfiguration = FILE_PIPE_FULL_DUPLEX;
    } else if (ShareAccess == FILE_SHARE_READ) {
        NamedPipeConfiguration = FILE_PIPE_OUTBOUND;
    } else if (ShareAccess == FILE_SHARE_WRITE) {
        NamedPipeConfiguration = FILE_PIPE_INBOUND;
    } else {
        Iosb.Status = STATUS_INVALID_PARAMETER;
        return Iosb;
    }
    //
    //  Check that if named pipe type is byte stream then the read mode is
    //  not message mode
    //
    if ((NamedPipeType == FILE_PIPE_BYTE_STREAM_TYPE) &&
        (ServerReadMode == FILE_PIPE_MESSAGE_MODE)) {
        Iosb.Status = STATUS_INVALID_PARAMETER;
        return Iosb;
    }
    //
    //  Create a new fcb and ccb for the named pipe
    //

    Iosb.Status = NpCreateFcb( RootDcb,
                               &FileName,
                               MaximumInstances,
                               DefaultTimeout,
                               NamedPipeConfiguration,
                               NamedPipeType,
                               &Fcb );
    if (!NT_SUCCESS (Iosb.Status)) {
        return Iosb;
    }

    Iosb.Status = NpCreateCcb( Fcb,
                               FileObject,
                               FILE_PIPE_LISTENING_STATE,
                               ServerReadMode,
                               ServerCompletionMode,
                               InboundQuota,
                               OutboundQuota,
                               &Ccb );
    if (!NT_SUCCESS (Iosb.Status)) {
        NpDeleteFcb( Fcb, DeferredList );
        return Iosb;
    }

    //
    //  Set the security descriptor in the Fcb
    //

    SeLockSubjectContext( &AccessState->SubjectSecurityContext );

    Iosb.Status = SeAssignSecurity( NULL,
                                    AccessState->SecurityDescriptor,
                                    &NewSecurityDescriptor,
                                    FALSE,
                                    &AccessState->SubjectSecurityContext,
                                    IoGetFileObjectGenericMapping(),
                                    PagedPool );

    SeUnlockSubjectContext( &AccessState->SubjectSecurityContext );

    if (!NT_SUCCESS(Iosb.Status)) {

        DebugTrace(0, Dbg, "Error calling SeAssignSecurity\n", 0 );

        NpDeleteCcb( Ccb, DeferredList );
        NpDeleteFcb( Fcb, DeferredList );
        return Iosb;
    }
    Iosb.Status = ObLogSecurityDescriptor (NewSecurityDescriptor,
                                           &CachedSecurityDescriptor,
                                           1);
    NpFreePool (NewSecurityDescriptor);
    if (!NT_SUCCESS(Iosb.Status)) {

        DebugTrace(0, Dbg, "Error calling ObLogSecurityDescriptor\n", 0 );

        NpDeleteCcb( Ccb, DeferredList );
        NpDeleteFcb( Fcb, DeferredList );
        return Iosb;
    }

    Fcb->SecurityDescriptor = CachedSecurityDescriptor;
    //
    //  Set the file object back pointers and our pointer to the
    //  server file object.
    //

    NpSetFileObject( FileObject, Ccb, Ccb->NonpagedCcb, FILE_PIPE_SERVER_END );
    Ccb->FileObject[ FILE_PIPE_SERVER_END ] = FileObject;

    //
    //  Check to see if we need to notify outstanding Irps for any
    //  changes (i.e., we just added a named pipe).
    //

    NpCheckForNotify( RootDcb, TRUE, DeferredList );

    //
    //  Set our return status
    //

    Iosb.Status = STATUS_SUCCESS;
    Iosb.Information = FILE_CREATED;

    DebugTrace(-1, Dbg, "NpCreateNewNamedPipe -> %08lx\n", Iosb.Status);

    return Iosb;
}


//
//  Internal support routine
//

IO_STATUS_BLOCK
NpCreateExistingNamedPipe (
    IN PFCB Fcb,
    IN PFILE_OBJECT FileObject,
    IN ACCESS_MASK DesiredAccess,
    IN PACCESS_STATE AccessState,
    IN KPROCESSOR_MODE RequestorMode,
    IN ULONG CreateDisposition,
    IN USHORT ShareAccess,
    IN ULONG ServerReadMode,
    IN ULONG ServerCompletionMode,
    IN ULONG InboundQuota,
    IN ULONG OutboundQuota,
    IN PEPROCESS CreatorProcess,
    IN PLIST_ENTRY DeferredList
    )

/*++

Routine Description:

    This routine performs the operation for creating a new instance of
    an existing named pipe.  This routine does not complete any
    IRP, it preforms its function and then returns an iosb.

Arguments:

    Fcb - Supplies the Fcb for the named pipe being created

    FileObject - Supplies the file object associated with this
        instance of the named pipe

    DesiredAccess - Supplies the callers desired access

    CreateDisposition - Supplies the callers create disposition flags

    ShareAccess - Supplies the caller specified share access

    ServerReadMode - Supplies the named pipe read mode

    ServerCompletionMode - Supplies the named pipe completion mode

    InboundQuota - Supplies the inbound quota amount

    OutboundQuota - Supplies the outbound quota amount

    CreatorProcess - Supplies the process creating the named pipe

    DeferredList - List of IRP's to complete after we release the locks

Return Value:

    IO_STATUS_BLOCK - Returns the appropriate status for the operation

--*/

{
    IO_STATUS_BLOCK Iosb;

    BOOLEAN AccessGranted;
    ACCESS_MASK GrantedAccess;
    UNICODE_STRING Name;

    PCCB Ccb;

    NAMED_PIPE_CONFIGURATION NamedPipeConfiguration;

    USHORT OriginalShareAccess;

    PPRIVILEGE_SET  Privileges = NULL;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "NpCreateExistingNamedPipe\n", 0 );


    //
    //  To create a new instance of a named pipe the caller
    //  must have "create pipe instance" access.  Even if the
    //  caller didn't explicitly request this access, the call
    //  to us implicitly requests the bit.  So now jam the bit
    //  into the desired access field
    //

    DesiredAccess |= FILE_CREATE_PIPE_INSTANCE;

    //
    //  First do an access check for the user against the Fcb
    //

    SeLockSubjectContext( &AccessState->SubjectSecurityContext );

    AccessGranted = SeAccessCheck( Fcb->SecurityDescriptor,
                                   &AccessState->SubjectSecurityContext,
                                   TRUE,                      // Tokens are locked
                                   DesiredAccess,
                                   0,
                                   &Privileges,
                                   IoGetFileObjectGenericMapping(),
                                   RequestorMode,
                                   &GrantedAccess,
                                   &Iosb.Status );

    if (Privileges != NULL) {

        (VOID) SeAppendPrivileges(
                     AccessState,
                     Privileges
                     );

        SeFreePrivileges( Privileges );
    }

    //
    //  Transfer over the access masks from what is desired to
    //  what we just granted.  Also patch up the maximum allowed
    //  case because we just did the mapping for it.  Note that if
    //  the user didn't ask for maximum allowed then the following
    //  code is still okay because we'll just zero a zero bit.
    //

    if (AccessGranted) {

        AccessState->PreviouslyGrantedAccess |= GrantedAccess;
        AccessState->RemainingDesiredAccess &= ~(GrantedAccess | MAXIMUM_ALLOWED);
    }

    RtlInitUnicodeString( &Name, L"NamedPipe" );

    SeOpenObjectAuditAlarm( &Name,
                            NULL,
                            &FileObject->FileName,
                            Fcb->SecurityDescriptor,
                            AccessState,
                            FALSE,
                            AccessGranted,
                            RequestorMode,
                            &AccessState->GenerateOnClose );

    SeUnlockSubjectContext( &AccessState->SubjectSecurityContext );

    if (!AccessGranted) {
        DebugTrace(0, Dbg, "Access Denied\n", 0 );
        return Iosb;
    }

    //
    //  Check that we're still under the maximum instances count
    //

    if (Fcb->OpenCount >= Fcb->Specific.Fcb.MaximumInstances) {
        Iosb.Status = STATUS_INSTANCE_NOT_AVAILABLE;
        return Iosb;
    }

    if (CreateDisposition == FILE_CREATE) {
        Iosb.Status = STATUS_ACCESS_DENIED;
        return Iosb;
    }

    //
    //  From the pipe configuration determine the share access specified
    //  on the first instance of this pipe. All subsequent instances must
    //  specify the same share access.
    //

    NamedPipeConfiguration = Fcb->Specific.Fcb.NamedPipeConfiguration;

    if (NamedPipeConfiguration == FILE_PIPE_OUTBOUND) {
        OriginalShareAccess = FILE_SHARE_READ;
    } else if (NamedPipeConfiguration == FILE_PIPE_INBOUND) {
        OriginalShareAccess = FILE_SHARE_WRITE;
    } else {
        OriginalShareAccess = (FILE_SHARE_READ | FILE_SHARE_WRITE);
    }

    if (OriginalShareAccess != ShareAccess) {
        Iosb.Status = STATUS_ACCESS_DENIED;
        return Iosb;
    }

    //
    //  Create a new ccb for the named pipe
    //

    Iosb.Status = NpCreateCcb( Fcb,
                               FileObject,
                               FILE_PIPE_LISTENING_STATE,
                               ServerReadMode,
                               ServerCompletionMode,
                               InboundQuota,
                               OutboundQuota,
                               &Ccb );
    if (!NT_SUCCESS (Iosb.Status)) {
        return Iosb;
    }

    //
    //  Wake up anyone waiting for an instance to go into the listening state
    //

    Iosb.Status = NpCancelWaiter (&NpVcb->WaitQueue,
                                  &Fcb->FullFileName,
                                  STATUS_SUCCESS,
                                  DeferredList);
    if (!NT_SUCCESS (Iosb.Status)) {
        Ccb->Fcb->ServerOpenCount -= 1;
        NpDeleteCcb (Ccb, DeferredList);
        return Iosb;
    }

    //
    //  Set the file object back pointers and our pointer to the
    //  server file object.
    //

    NpSetFileObject( FileObject, Ccb, Ccb->NonpagedCcb, FILE_PIPE_SERVER_END );
    Ccb->FileObject[ FILE_PIPE_SERVER_END ] = FileObject;

    //
    //  Check to see if we need to notify outstanding Irps for
    //  changes (i.e., we just added a new instance of a named pipe).
    //

    NpCheckForNotify( Fcb->ParentDcb, FALSE, DeferredList );

    //
    //  Set our return status
    //

    Iosb.Status = STATUS_SUCCESS;
    Iosb.Information = FILE_CREATED;

    return Iosb;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\npfs\deviosup.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    DevIoSup.c

Abstract:

    This module implements the memory locking routines for Npfs.

Author:

    Brian Andrew    [BrianAn]   03-Apr-1991

Revision History:

--*/

#include "NpProcs.h"

//
//  Local debug trace level
//

#define Dbg                              (DEBUG_TRACE_DEVIOSUP)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NpLockUserBuffer)
#pragma alloc_text(PAGE, NpMapUserBuffer)
#endif


PVOID
NpMapUserBuffer (
    IN OUT PIRP Irp
    )

/*++

Routine Description:

    This routine conditionally maps the user buffer for the current I/O
    request in the specified mode.  If the buffer is already mapped, it
    just returns its address.

Arguments:

    Irp - Pointer to the Irp for the request.

Return Value:

    Mapped address

--*/

{
    PAGED_CODE();

    //
    // If there is no Mdl, then we must be in the Fsd, and we can simply
    // return the UserBuffer field from the Irp.
    //

    if (Irp->MdlAddress == NULL) {

        return Irp->UserBuffer;

    } else {

        return MmGetSystemAddressForMdl( Irp->MdlAddress );
    }
}


VOID
NpLockUserBuffer (
    IN OUT PIRP Irp,
    IN LOCK_OPERATION Operation,
    IN ULONG BufferLength
    )

/*++

Routine Description:

    This routine locks the specified buffer for the specified type of
    access.  The file system requires this routine since it does not
    ask the I/O system to lock its buffers for direct I/O.  This routine
    may only be called from the Fsd while still in the user context.

Arguments:

    Irp - Pointer to the Irp for which the buffer is to be locked.

    Operation - IoWriteAccess for read operations, or IoReadAccess for
                write operations.

    BufferLength - Length of user buffer.

Return Value:

    None

--*/

{
    PMDL Mdl;

    PAGED_CODE();

    if (Irp->MdlAddress == NULL) {

        //
        // This read is bound for the current process.  Perform the
        // same functions as above, only do not switch processes.
        //

        Mdl = IoAllocateMdl( Irp->UserBuffer, BufferLength, FALSE, TRUE, Irp );

        if (Mdl == NULL) {

            ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
        }

        try {

            MmProbeAndLockPages( Mdl,
                                 Irp->RequestorMode,
                                 Operation );

        } except(EXCEPTION_EXECUTE_HANDLER) {

            IoFreeMdl( Mdl );
            Irp->MdlAddress = NULL;
            ExRaiseStatus( FsRtlNormalizeNtstatus( GetExceptionCode(),
                                                   STATUS_INVALID_USER_BUFFER ));
        }
    }
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\npfs\datasup.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    DataSup.c

Abstract:

    This module implements the Named Pipe data queue support routines.

Author:

    Gary Kimura     [GaryKi]    30-Aug-1990

Revision History:

--*/

#include "NpProcs.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_DATASUP)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NpGetNextRealDataQueueEntry)
#pragma alloc_text(PAGE, NpInitializeDataQueue)
#pragma alloc_text(PAGE, NpUninitializeDataQueue)
#pragma alloc_text(PAGE, NpAddDataQueueEntry)
#pragma alloc_text(PAGE, NpCompleteStalledWrites)
#pragma alloc_text(PAGE, NpRemoveDataQueueEntry)
#endif

//
//  The following macro is used to dump a data queue
//

#define DumpDataQueue(S,P) {                   \
    ULONG NpDumpDataQueue(IN PDATA_QUEUE Ptr); \
    DebugTrace(0,Dbg,S,0);                     \
    DebugTrace(0,Dbg,"", NpDumpDataQueue(P));  \
}

//
//  This is a debugging aid
//

_inline BOOLEAN
NpfsVerifyDataQueue( IN ULONG Line, IN PDATA_QUEUE DataQueue ) {
    PDATA_ENTRY Entry;
    ULONG BytesInQueue = 0;
    ULONG EntriesInQueue = 0;
    for (Entry = (PDATA_ENTRY)DataQueue->Queue.Flink;
         Entry != (PDATA_ENTRY)&DataQueue->Queue;
         Entry = (PDATA_ENTRY)Entry->Queue.Flink) {
        BytesInQueue += Entry->DataSize;
        EntriesInQueue += 1;
    }
    if ((DataQueue->EntriesInQueue != EntriesInQueue) ||
        (DataQueue->BytesInQueue != BytesInQueue)) {
        DbgPrint("%d DataQueue is illformed %08lx %x %x\n", Line, DataQueue, BytesInQueue, EntriesInQueue);
        DbgBreakPoint();
        return FALSE;
    }
    return TRUE;
}


VOID
NpCancelDataQueueIrp (
    IN PDEVICE_OBJECT DevictObject,
    IN PIRP Irp
    );



NTSTATUS
NpInitializeDataQueue (
    IN PDATA_QUEUE DataQueue,
    IN ULONG Quota
    )

/*++

Routine Description:

    This routine initializes a new data queue.  The indicated quota is taken
    from the process and not returned until the data queue is uninitialized.

Arguments:

    DataQueue - Supplies the data queue being initialized

    Process - Supplies a pointer to the process creating the named pipe

    Quota - Supplies the quota to assign to the data queue

Return Value:

    None.

--*/

{
    PAGED_CODE();

    DebugTrace(+1, Dbg, "NpInitializeDataQueue, DataQueue = %08lx\n", DataQueue);

    //
    //  Now we can initialize the data queue structure
    //

    DataQueue->QueueState     = Empty;
    DataQueue->BytesInQueue   = 0;
    DataQueue->EntriesInQueue = 0;
    DataQueue->Quota          = Quota;
    DataQueue->QuotaUsed      = 0;
    InitializeListHead (&DataQueue->Queue);
    DataQueue->NextByteOffset = 0;

    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "NpInitializeDataQueue -> VOID\n", 0);

    return STATUS_SUCCESS;
}


VOID
NpUninitializeDataQueue (
    IN PDATA_QUEUE DataQueue
    )

/*++

Routine Description:

    This routine uninitializes a data queue.  The previously debited quota
    is returned to the process.

Arguments:

    DataQueue - Supplies the data queue being uninitialized

    Process - Supplies a pointer to the process who created the named pipe

Return Value:

    None.

--*/

{
    PAGED_CODE();

    DebugTrace(+1, Dbg, "NpUninitializeDataQueue, DataQueue = %08lx\n", DataQueue);

    //
    //  Assert that the queue is empty
    //

    ASSERT( DataQueue->QueueState == Empty );


    //
    //  Then for safety sake we'll zero out the data queue structure
    //

    RtlZeroMemory( DataQueue, sizeof(DATA_QUEUE ) );

    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "NpUnininializeDataQueue -> VOID\n", 0);

    return;
}


NTSTATUS
NpAddDataQueueEntry (
    IN NAMED_PIPE_END NamedPipeEnd,
    IN PCCB Ccb,
    IN PDATA_QUEUE DataQueue,
    IN QUEUE_STATE Who,
    IN DATA_ENTRY_TYPE Type,
    IN ULONG DataSize,
    IN PIRP Irp OPTIONAL,
    IN PVOID DataPointer OPTIONAL,
    IN ULONG ByteOffset
    )

/*++

Routine Description:

    This routine adds a new data entry to the end of the data queue.
    If necessary it will allocate a data entry buffer, or use space in
    the IRP, and possibly complete the indicated IRP.

    The different actions we are perform are based on the type and who
    parameters and quota requirements.

    Type == Internal (i.e, Unbuffered)

        +------+                          - Allocate Data Entry from Irp
        |Irp   |    +----------+
        |      |<---|Unbuffered|          - Reference Irp
        +------+    |InIrp     |
          |         +----------+          - Use system buffer from Irp
          v           |
        +------+      |
        |System|<-----+
        |Buffer|
        +------+

    Type == Buffered && Who == ReadEntries

        +----------+                      - Allocate Data Entry from Irp
        |Irp       |     +-----------+
        |BufferedIo|<----|Buffered   |    - Allocate New System buffer
        |DeallBu...|     |EitherQuota|
        +----------+     +-----------+    - Reference and modify Irp to
          |      |         |                do Buffered I/O, Deallocate
          v      |         v                buffer, and have io completion
        +------+ +------>+------+           copy the buffer (Input operation)
        |User  |         |System|
        |Buffer|         |Buffer|
        +------+         +------+

    Type == Buffered && Who == WriteEntries && PipeQuota Available

        +----------+                      - Allocate Data Entry from Quota
        |Irp       |     +-----------+
        |          |     |Buffered   |    - Allocate New System buffer
        |          |     |PipeQuota  |
        +----------+     +-----------+    - Copy data from User buffer to
          |                |                system buffer
          v                v
        +------+         +------+         - Complete Irp
        |User  |..copy..>|System|
        |Buffer|         |Buffer|
        +------+         +------+

    Type == Buffered && Who == WriteEntries && PipeQuota Not Available

        +----------+                     - Allocate Data Entry from Irp
        |Irp       |     +-----------+
        |BufferedIo|<----|Buffered   |   - Allocate New System buffer
        |DeallBuff |     |UserQuota  |
        +----------+     +-----------+   - Reference and modify Irp to use
          |      |         |               the new system buffer, do Buffered
          v      |         v               I/O, and Deallocate buffer
        +------+ +------>+------+
        |User  |         |System|        - Copy data from User buffer to
        |Buffer|..copy..>|Buffer|          system buffer
        +------+         +------+

    Type == Flush or Close

        +----------+                     - Allocate Data Entry from Irp
        |Irp       |     +-----------+
        |          |<----|Buffered   |   - Reference the Irp
        |          |     |UserQuota  |
        +----------+     +-----------+

Arguments:

    DataQueue - Supplies the Data queue being modified

    Who - Indicates if this is the reader or writer that is adding to the pipe

    Type - Indicates the type of entry to add to the data queue

    DataSize - Indicates the size of the data buffer needed to represent
        this entry

    Irp - Supplies a pointer to the Irp responsible for this entry
        The irp is only optional for buffered write with available pipe quota

    DataPointer - If the Irp is not supplied then this field points to the
        user's write buffer.

    ByteOffset - Part of this buffer satisfied a read. Use this as the initial offset

Return Value:

    PDATA_ENTRY - Returns a pointer to the newly added data entry

--*/

{
    PDATA_ENTRY DataEntry;
    PVOID DataBuffer;
    ULONG TotalSize;
    ULONG QuotaCharged;
    NTSTATUS status;
    PSECURITY_CLIENT_CONTEXT SecurityContext = NULL;
    PETHREAD Thread;
    BOOLEAN PendIRP;
    

    ASSERT((DataQueue->QueueState == Empty) || (DataQueue->QueueState == Who));

    DebugTrace(+1, Dbg, "NpAddDataQueueEntry, DataQueue = %08lx\n", DataQueue);

    status = STATUS_SUCCESS;


    //
    // Capture security context if we have to.
    //
    if (Type != Flush && Who == WriteEntries) {
        if (Irp != NULL) {
            Thread = Irp->Tail.Overlay.Thread;
        } else {
            Thread = PsGetCurrentThread ();
        }
        status = NpGetClientSecurityContext (NamedPipeEnd,
                                             Ccb,
                                             Thread,
                                             &SecurityContext);
        if (!NT_SUCCESS (status)) {
            return status;
        }
    }
    //
    //  Case on the type of operation we are doing
    //

    switch (Type) {

    case Unbuffered:
    case Flush:
    case Close:

        ASSERT(ARGUMENT_PRESENT(Irp));

        //
        //  Allocate a data entry for the Irp
        //

        DataEntry  = NpAllocatePagedPoolWithQuotaCold( sizeof (DATA_ENTRY), 'rFpN' );
        if (DataEntry == NULL) {
            NpFreeClientSecurityContext (SecurityContext);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        DataEntry->DataEntryType = Type;
        DataEntry->QuotaCharged  = 0;
        DataEntry->Irp           = Irp;
        DataEntry->DataSize      = DataSize;

        DataEntry->SecurityClientContext = SecurityContext;

        ASSERT((DataQueue->QueueState == Empty) || (DataQueue->QueueState == Who));
        status = STATUS_PENDING;
        break;

    case Buffered:

        //
        // Allocate a buffer but put the DATA_ENTRY on the end.  We do this
        // so we can free and copy back the data in one chunk in I/O post
        // processing.
        //

        TotalSize = sizeof(DATA_ENTRY);

        if (Who != ReadEntries) {
            TotalSize += DataSize;

            if (TotalSize < DataSize) {

                //
                // DataSize is so large that adding this extra structure and
                // alignment padding causes it to wrap.
                //

                NpFreeClientSecurityContext (SecurityContext);
                return STATUS_INVALID_PARAMETER;
            }
        }

        //
        // Charge the data portion against the named pipe quota if possible and
        // charge the rest against the process.
        //

        if ((DataQueue->Quota - DataQueue->QuotaUsed) >= DataSize - ByteOffset) {
            QuotaCharged = DataSize - ByteOffset;
            PendIRP = FALSE;
        } else {
            QuotaCharged = DataQueue->Quota - DataQueue->QuotaUsed;
            PendIRP = TRUE;
        }

        DataBuffer = NpAllocatePagedPoolWithQuotaCold (TotalSize, 'rFpN');
        if (DataBuffer == NULL) {
            NpFreeClientSecurityContext (SecurityContext);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        DataEntry = (PDATA_ENTRY) DataBuffer;
        DataEntry->QuotaCharged          = QuotaCharged;
        DataEntry->Irp                   = Irp;
        DataEntry->DataEntryType         = Buffered;
        DataEntry->SecurityClientContext = SecurityContext;
        DataEntry->DataSize              = DataSize;
        //
        //  Check if this is the reader or writer
        //

        if (Who == ReadEntries) {

            ASSERT(ARGUMENT_PRESENT(Irp));

            status = STATUS_PENDING;

            ASSERT((DataQueue->QueueState == Empty) || (DataQueue->QueueState == Who));

        } else {

            //
            //  This is a writer entry
            //

            //
            //  Safely copy the user buffer to the new system buffer using either
            //  the irp user buffer is supplied of the data pointer we were given
            //

            if (ARGUMENT_PRESENT(Irp)) {
                DataPointer = Irp->UserBuffer;
            }

            try {
                RtlCopyMemory( DataEntry->DataBuffer, (PUCHAR) DataPointer, DataSize );
            } except(EXCEPTION_EXECUTE_HANDLER) {
                NpFreePool (DataBuffer);
                NpFreeClientSecurityContext (SecurityContext);
                return GetExceptionCode ();
            }
            if (PendIRP == FALSE || Irp == NULL) {
                DataEntry->Irp = NULL;
                status = STATUS_SUCCESS;
            } else {
                status = STATUS_PENDING;
            }
            ASSERT((DataQueue->QueueState == Empty) || (DataQueue->QueueState == Who));
        }

        break;

    }

    ASSERT((DataQueue->QueueState == Empty) || (DataQueue->QueueState == Who));

#if DBG
    if (DataQueue->QueueState == Empty) {
        ASSERT (DataQueue->BytesInQueue == 0);
        ASSERT (DataQueue->EntriesInQueue == 0);
        ASSERT (IsListEmpty (&DataQueue->Queue));
    } else {
        ASSERT( DataQueue->QueueState == Who );
        ASSERT( DataQueue->QueueState != Empty );
        ASSERT( DataQueue->EntriesInQueue != 0 );
    }
#endif

    DataQueue->QuotaUsed      += DataEntry->QuotaCharged;
    DataQueue->QueueState      = Who;
    DataQueue->BytesInQueue   += DataEntry->DataSize;
    DataQueue->EntriesInQueue += 1;

    //
    // This handles the case where this write was used to complete some reads already and so we have to start
    // part way into the buffer. Obviously to have been completing reads we must be at the head of the queue.
    // The two cases that did this where on the outside but we call cancel here and that will need to remove
    // this offset.
    //
    if (ByteOffset) {
        DataQueue->NextByteOffset = ByteOffset;
        ASSERT (Who == WriteEntries);
        ASSERT (ByteOffset < DataEntry->DataSize);
        ASSERT (DataQueue->EntriesInQueue == 1);
    }

    InsertTailList (&DataQueue->Queue, &DataEntry->Queue);

    if (status == STATUS_PENDING) {
        IoMarkIrpPending (Irp);
        //
        // Tie the IRP to the DataQueue and DataEntry. We can divorse this link on cancel etc.
        //
        NpIrpDataQueue(Irp) = DataQueue;
        NpIrpDataEntry(Irp) = DataEntry;
        IoSetCancelRoutine( Irp, NpCancelDataQueueIrp );
        if (Irp->Cancel && IoSetCancelRoutine( Irp, NULL ) != NULL) {
            //
            //  Indicate in the first parameter that we're calling the
            //  cancel routine and not the I/O system.  Therefore
            //  the routine won't take out the VCB exclusive.
            //
            NpCancelDataQueueIrp( NULL, Irp );
        }
    }

    //
    //  And return to our caller
    //

    return status;
}

VOID
NpCompleteStalledWrites (
    IN PDATA_QUEUE DataQueue,
    IN PLIST_ENTRY DeferredList
    )
/*++

Routine Description:

    This routine is used to return any quota added back to the pipe to any stalled writes.
    We stall writes becuase there was no room in the pipe for them. If there is now room we can complete them.

Arguments:

    DataQueue - Supplies a pointer to the data queue being modifed

Return Value:

    None

--*/

{
    PLIST_ENTRY Link;
    PDATA_ENTRY DataEntry;
    ULONG ExtraQuota, Needed, ByteOffset;
    PIRP  Irp;

    ExtraQuota = DataQueue->Quota - DataQueue->QuotaUsed;
    ByteOffset = DataQueue->NextByteOffset;
    for (Link = DataQueue->Queue.Flink;
         (Link != &DataQueue->Queue) && (ExtraQuota != 0);
         Link = Link->Flink, ByteOffset = 0) {
        DataEntry = CONTAINING_RECORD (Link, DATA_ENTRY, Queue);
        Irp = DataEntry->Irp;
        if ((DataEntry->DataEntryType != Buffered) || (Irp == NULL)) {
            continue;
        }
        if (DataEntry->QuotaCharged < DataEntry->DataSize - ByteOffset) {
            Needed = DataEntry->DataSize - ByteOffset - DataEntry->QuotaCharged;
            if (Needed > ExtraQuota) {
                Needed = ExtraQuota;
            }
            ExtraQuota -= Needed;
            DataEntry->QuotaCharged += Needed;
            if (DataEntry->QuotaCharged == DataEntry->DataSize - ByteOffset) {
                //
                // Attempt to complete this IRP. If cancel is already running then leave it in
                // place for cancel to sort out.
                //
                if (IoSetCancelRoutine (Irp, NULL) != NULL) {
                    DataEntry->Irp = NULL;
                    Irp->IoStatus.Information = DataEntry->DataSize;
                    NpDeferredCompleteRequest (Irp, STATUS_SUCCESS, DeferredList);
                }
            }
        }
    }
    DataQueue->QuotaUsed = DataQueue->Quota - ExtraQuota;
}


PIRP
NpRemoveDataQueueEntry (
    IN PDATA_QUEUE DataQueue,
    IN BOOLEAN CompletedFlushes,
    IN PLIST_ENTRY DeferredList
    )

/*++

Routine Description:

    This routines remove the first entry from the front of the indicated
    data queue, and possibly returns the Irp associated with the entry if
    it wasn't already completed when we did the insert.

    If the data entry we are removing indicates buffered I/O then we also
    need to deallocate the data buffer besides the data entry but only
    if the Irp is null.  Note that the data entry might be stored in an IRP.
    If it is then we are going to return the IRP it is stored in.

Arguments:

    DataQueue - Supplies a pointer to the data queue being modifed

    CompleteFlushes - Specifies if this routine should look to complete pended flushes

    DeferredList - List of IRPs to complete later after we drop the locks

Return Value:

    PIRP - Possibly returns a pointer to an IRP.

--*/

{
    PDATA_ENTRY DataEntry;

    DATA_ENTRY_TYPE DataEntryType;
    PIRP Irp;
    ULONG DataSize;
    PVOID DataPointer;
    PLIST_ENTRY Links;
    PSECURITY_CLIENT_CONTEXT ClientContext;
    QUEUE_STATE Who;
    BOOLEAN DoScan;

    DebugTrace(+1, Dbg, "NpRemoveDataQueueEntry, DataQueue = %08lx\n", DataQueue);

    //
    //  Check if the queue is empty, and if so then we simply return null
    //

    if (DataQueue->QueueState == Empty) {
        ASSERT (IsListEmpty (&DataQueue->Queue));
        ASSERT (DataQueue->EntriesInQueue == 0);
        ASSERT (DataQueue->BytesInQueue == 0);
        ASSERT (DataQueue->QuotaUsed == 0);

        Irp = NULL;

    } else {

        //
        //  Reference the front of the data queue, and remove the entry
        //  from the queue itself.
        //

        Links = (PLIST_ENTRY) RemoveHeadList (&DataQueue->Queue);
        DataEntry = CONTAINING_RECORD (Links, DATA_ENTRY, Queue);

        DataQueue->BytesInQueue   -= DataEntry->DataSize;
        DataQueue->EntriesInQueue -= 1;

        Who = DataQueue->QueueState;
        //
        // If quota was completely used until now and we are adding some back in then we need to look for write
        // IRPs that were blocked becuase of pipe quota.
        //
        if (Who != WriteEntries || DataQueue->QuotaUsed < DataQueue->Quota || DataEntry->QuotaCharged == 0) {
            DoScan = FALSE;
        } else {
            DoScan = TRUE;
        }
        DataQueue->QuotaUsed      -= DataEntry->QuotaCharged;

        //
        //  Now if the queue is empty we need to reset the end of queue and
        //  queue state
        //

        if (IsListEmpty (&DataQueue->Queue)) {
            DataQueue->QueueState = Empty;
            DoScan = FALSE;
        }

        //
        //  Capture some of the fields from the data entry to make our
        //  other references a little easier
        //

        DataEntryType = DataEntry->DataEntryType;
        Irp           = DataEntry->Irp;
        DataSize      = DataEntry->DataSize;
        ClientContext = DataEntry->SecurityClientContext;

        NpFreeClientSecurityContext (ClientContext);


        if (Irp != NULL) {

            //
            // Cancel is alreayd active. Let it complete this IRP.
            //
            if (IoSetCancelRoutine( Irp, NULL ) == NULL) {
                //
                // Divorce this IRP from the data entry so it doesn't clean up
                //
                NpIrpDataEntry(Irp) = NULL;
                Irp = NULL;
            }
        }

        NpFreePool( DataEntry );

        //
        //
        //
        if (CompletedFlushes) {
            NpGetNextRealDataQueueEntry (DataQueue, DeferredList);
        }
        if (DoScan) {
            NpCompleteStalledWrites (DataQueue, DeferredList);
        }
    }

    //
    //  In all cases we'll also zero out the next byte offset.
    //

    DataQueue->NextByteOffset = 0;

    //
    //  And return to our caller
    //

    DumpDataQueue( "After RemoveDataQueueEntry\n", DataQueue );
    DebugTrace(-1, Dbg, "NpRemoveDataQueueEntry -> %08lx\n", Irp);

    return Irp;
}


PDATA_ENTRY
NpGetNextRealDataQueueEntry (
    IN PDATA_QUEUE DataQueue,
    IN PLIST_ENTRY DeferredList
    )

/*++

Routine Description:

    This routine will returns a pointer to the next real data queue entry
    in the indicated data queue.  A real entry is either a read or write
    entry (i.e., buffered or unbuffered).  It will complete (as necessary)
    any flush and close Irps that are in the queue until either the queue
    is empty or a real data queue entry is at the front of the queue.

Arguments:

    DataQueue - Supplies a pointer to the data queue being modified

Return Value:

    PDATA_ENTRY - Returns a pointer to the next data queue entry or NULL
        if there isn't any.

--*/

{
    PDATA_ENTRY DataEntry;
    PIRP Irp;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "NpGetNextRealDataQueueEntry, DataQueue = %08lx\n", DataQueue);

    //
    //  While the next data queue entry at the head of the data queue is not
    //  a real data queue entry we'll dequeue that entry and complete
    //  its corresponding IRP.
    //

    for (DataEntry = NpGetNextDataQueueEntry( DataQueue, NULL);

         (DataEntry != (PDATA_ENTRY) &DataQueue->Queue) &&
         ((DataEntry->DataEntryType != Buffered) &&
          (DataEntry->DataEntryType != Unbuffered));

         DataEntry = NpGetNextDataQueueEntry( DataQueue, NULL)) {

        //
        //  We have a non real data queue entry that needs to be removed
        //  and completed.
        //

        Irp = NpRemoveDataQueueEntry( DataQueue, FALSE, DeferredList );

        if (Irp != NULL) {
            NpDeferredCompleteRequest( Irp, STATUS_SUCCESS, DeferredList );
        }
    }

    //
    //  At this point we either have an empty data queue and data entry is
    //  null, or we have a real data queue entry.  In either case it
    //  is time to return to our caller
    //

    DebugTrace(-1, Dbg, "NpGetNextRealDataQueueEntry -> %08lx\n", DataEntry);

    return DataEntry;
}


//
//  Local support routine
//

VOID
NpCancelDataQueueIrp (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the cancel function for an IRP saved in a
    data queue

Arguments:

    DeviceObject - Generally ignored but the low order bit is a flag indicating
        if we are being called locally (i.e., not from the I/O system) and
        therefore don't need to take out the VCB.

    Irp - Supplies the Irp being cancelled.  A pointer to the data queue
        structure is stored in the information field of the Irp Iosb
        field.

Return Value:

    None.

--*/

{
    PDATA_QUEUE DataQueue;
    PDATA_ENTRY DataEntry;
    PCCB Ccb;
    PIO_STACK_LOCATION IrpSp;
    PFILE_OBJECT FileObject;
    ULONG DataSize;
    PSECURITY_CLIENT_CONTEXT ClientContext;
    QUEUE_STATE Who;
    BOOLEAN AtHead;
    BOOLEAN DoScan;
    LIST_ENTRY DeferredList;


    if (DeviceObject != NULL) {
        IoReleaseCancelSpinLock (Irp->CancelIrql);
    }

    //
    //  The status field is used to store a pointer to the data queue
    //  containing this irp
    //

    InitializeListHead (&DeferredList);

    IrpSp = IoGetCurrentIrpStackLocation (Irp);

    FileObject = IrpSp->FileObject;

    DataQueue = NpIrpDataQueue (Irp);

    ClientContext = NULL;


    if (DeviceObject != NULL) {
        FsRtlEnterFileSystem ();
        NpAcquireExclusiveVcb ();
    }


    DataEntry = NpIrpDataEntry (Irp);
    if (DataEntry != NULL) {
        //
        //  If what we are about to removed is in the front of the queue then we must
        //  reset the next byte offset
        //

        if (DataEntry->Queue.Blink == &DataQueue->Queue) {
            DataQueue->NextByteOffset = 0;
            AtHead = TRUE;
        } else {
            AtHead = FALSE;
        }
        RemoveEntryList (&DataEntry->Queue);
        Who = DataQueue->QueueState;
        //
        //  Capture some of the fields from the data entry to make our
        //  other references a little easier
        //

        DataSize      = DataEntry->DataSize;
        ClientContext = DataEntry->SecurityClientContext;

        //
        // If quota was completely used until now and we are adding some back in then we need to look for write
        // IRPs that were blocked because of pipe quota.
        //
        if (Who != WriteEntries || DataQueue->QuotaUsed < DataQueue->Quota || DataEntry->QuotaCharged == 0) {
            DoScan = FALSE;
        } else {
            DoScan = TRUE;
        }

        //
        //  Return pipe quota for the entry.
        //
        DataQueue->QuotaUsed -= DataEntry->QuotaCharged;

        //
        //  Update the data queue header information
        //
        DataQueue->BytesInQueue   -= DataSize;
        DataQueue->EntriesInQueue -= 1;

        //
        // If the list is now empty then mark it as such. Complete any flushes at queue head as all the
        // requests a head of them have been completed.
        //
        if (IsListEmpty (&DataQueue->Queue)) {
            DataQueue->QueueState = Empty;
            ASSERT (DataQueue->BytesInQueue == 0);
            ASSERT (DataQueue->EntriesInQueue == 0);
            ASSERT (DataQueue->QuotaUsed == 0);
        } else {
            if (AtHead) {
                NpGetNextRealDataQueueEntry (DataQueue, &DeferredList);
            }
            if (DoScan) {
                NpCompleteStalledWrites (DataQueue, &DeferredList);
            }
        }
    }

    if (DeviceObject != NULL) {
        NpReleaseVcb ();
        FsRtlExitFileSystem ();
    }
    //
    //  Finally complete the request saying that it has been cancelled.
    //
    if (DataEntry != NULL) {

        NpFreePool (DataEntry);
    }

    NpFreeClientSecurityContext (ClientContext);

    NpCompleteRequest (Irp, STATUS_CANCELLED);

    NpCompleteDeferredIrps (&DeferredList);

    //
    //  And return to our caller
    //

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\npfs\dir.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    Dir.c

Abstract:

    This module implements the File Directory routines for the Named Pipe
    file system by the dispatch driver.

Author:

    Gary Kimura     [GaryKi]    28-Dec-1989

Revision History:

--*/

#include "NpProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (NPFS_BUG_CHECK_DIR)

//
//  Local debug trace level
//

#define Dbg                              (DEBUG_TRACE_DIR)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NpCheckForNotify)
#pragma alloc_text(PAGE, NpCommonDirectoryControl)
#pragma alloc_text(PAGE, NpFsdDirectoryControl)
#pragma alloc_text(PAGE, NpQueryDirectory)
#pragma alloc_text(PAGE, NpNotifyChangeDirectory)
#endif


NTSTATUS
NpFsdDirectoryControl (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the FSD routine that handles directory control
    functions (i.e., query and notify).

Arguments:

    NpfsDeviceObject - Supplies the device object for the directory function.

    Irp - Supplies the IRP to process

Return Value:

    NTSTATUS - The appropriate result status

--*/

{
    NTSTATUS Status;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "NpFsdDirectoryControl\n", 0);

    //
    //  Call the common Direcotry Control routine.
    //

    FsRtlEnterFileSystem();
    NpAcquireExclusiveVcb( );

    Status = NpCommonDirectoryControl( NpfsDeviceObject, Irp );

    NpReleaseVcb();
    FsRtlExitFileSystem();

    if (Status != STATUS_PENDING) {
        NpCompleteRequest (Irp, Status);
    }

    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "NpFsdDirectoryControl -> %08lx\n", Status );

    return Status;
}

VOID
NpCheckForNotify (
    IN PDCB Dcb,
    IN BOOLEAN CheckAllOutstandingIrps,
    IN PLIST_ENTRY DeferredList
    )

/*++

Routine Description:

    This routine checks the notify queues of a dcb and completes any
    outstanding IRPS.

    Note that the caller of this procedure must guarantee that the DCB
    is acquired for exclusive access.

Arguments:

    Dcb - Supplies the Dcb to check if is has any notify Irps outstanding

    CheckAllOutstandingIrps - Indicates if only the NotifyFullQueue should be
        checked.  If TRUE then all notify queues are checked, and if FALSE
        then only the NotifyFullQueue is checked.

Return Value:

    None.

--*/

{
    PLIST_ENTRY Links;
    PIRP Irp;

    PAGED_CODE();

    //
    //  We'll always signal the notify full queue entries.  They want
    //  to be notified if every any change is made to a directory
    //

    while (!IsListEmpty( &Dcb->Specific.Dcb.NotifyFullQueue )) {

        //
        //  Remove the Irp from the head of the queue, and complete it
        //  with success.
        //

        Links = RemoveHeadList( &Dcb->Specific.Dcb.NotifyFullQueue );

        Irp = CONTAINING_RECORD( Links, IRP, Tail.Overlay.ListEntry );

        if (IoSetCancelRoutine (Irp, NULL) != NULL) {
            NpDeferredCompleteRequest( Irp, STATUS_SUCCESS, DeferredList );
        } else {
            InitializeListHead (&Irp->Tail.Overlay.ListEntry);
        }
    }

    //
    //  Now check if we should also do the partial notify queue.
    //

    if (CheckAllOutstandingIrps) {

        while (!IsListEmpty( &Dcb->Specific.Dcb.NotifyPartialQueue )) {

            //
            //  Remove the Irp from the head of the queue, and complete it
            //  with success.
            //

            Links = RemoveHeadList( &Dcb->Specific.Dcb.NotifyPartialQueue );

            Irp = CONTAINING_RECORD( Links, IRP, Tail.Overlay.ListEntry );

            if (IoSetCancelRoutine (Irp, NULL) != NULL) {
                NpDeferredCompleteRequest( Irp, STATUS_SUCCESS, DeferredList );
            } else {
                InitializeListHead (&Irp->Tail.Overlay.ListEntry);
            }
        }
    }

    return;
}


//
//  Local Support Routine
//

NTSTATUS
NpCommonDirectoryControl (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine does the common code for directory control functions.

Arguments:

    NpfsDeviceObject - Supplies the named pipe device object

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;

    PIO_STACK_LOCATION IrpSp;

    PFCB Fcb;
    PROOT_DCB_CCB Ccb;

    PAGED_CODE();

    //
    //  Get the current stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "NpCommonDirectoryControl...\n", 0);
    DebugTrace( 0, Dbg, "Irp  = %08lx\n", Irp);

    //
    //  Decode the file object to figure out who we are.  If the result
    //  is not the root dcb then its an illegal parameter.
    //

    if (NpDecodeFileObject( IrpSp->FileObject,
                            &Fcb,
                            (PCCB *)&Ccb,
                            NULL ) != NPFS_NTC_ROOT_DCB) {

        DebugTrace(0, Dbg, "Not a directory\n", 0);

        Status = STATUS_INVALID_PARAMETER;

        DebugTrace(-1, Dbg, "NpCommonDirectoryControl -> %08lx\n", Status );
        return Status;
    }

    //
    //  We know this is a directory control so we'll case on the
    //  minor function, and call the appropriate work routines.
    //

    switch (IrpSp->MinorFunction) {

    case IRP_MN_QUERY_DIRECTORY:

        Status = NpQueryDirectory( Fcb, Ccb, Irp );
        break;

    case IRP_MN_NOTIFY_CHANGE_DIRECTORY:

        Status = NpNotifyChangeDirectory( Fcb, Ccb, Irp );
        break;

    default:

        //
        //  For all other minor function codes we say they're invalid
        //  and complete the request.
        //

        DebugTrace(0, DEBUG_TRACE_ERROR, "Invalid FS Control Minor Function Code %08lx\n", IrpSp->MinorFunction);

        Status = STATUS_INVALID_DEVICE_REQUEST;
        break;
    }

    DebugTrace(-1, Dbg, "NpCommonDirectoryControl -> %08lx\n", Status);
    return Status;
}


//
//  Internal support routine
//

NTSTATUS
NpQueryDirectory (
    IN PROOT_DCB RootDcb,
    IN PROOT_DCB_CCB Ccb,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the work routine for querying a directory.

Arugments:

    RootDcb - Supplies the dcb being queried

    Ccb - Supplies the context of the caller

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The return status for the operation.

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;

    PUCHAR Buffer;
    CLONG SystemBufferLength;

    UNICODE_STRING FileName;
    ULONG FileIndex;
    FILE_INFORMATION_CLASS FileInformationClass;
    BOOLEAN RestartScan;
    BOOLEAN ReturnSingleEntry;
    BOOLEAN IndexSpecified;

    static WCHAR Star = L'*';

    BOOLEAN CaseInsensitive = TRUE; //*** Make searches case insensitive

    ULONG CurrentIndex;

    ULONG LastEntry;
    ULONG NextEntry;

    PLIST_ENTRY Links;
    PFCB Fcb;

    PFILE_DIRECTORY_INFORMATION DirInfo;
    PFILE_NAMES_INFORMATION NamesInfo;

    PAGED_CODE();

    //
    //  Get the current stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "NpQueryDirectory\n", 0 );
    DebugTrace( 0, Dbg, "RootDcb              = %08lx\n", RootDcb);
    DebugTrace( 0, Dbg, "Ccb                  = %08lx\n", Ccb);
    DebugTrace( 0, Dbg, "SystemBuffer         = %08lx\n", Irp->AssociatedIrp.SystemBuffer);
    DebugTrace( 0, Dbg, "Length               = %08lx\n", IrpSp->Parameters.QueryDirectory.Length);
    DebugTrace( 0, Dbg, "FileName             = %Z\n",    IrpSp->Parameters.QueryDirectory.FileName);
    DebugTrace( 0, Dbg, "FileIndex            = %08lx\n", IrpSp->Parameters.QueryDirectory.FileIndex);
    DebugTrace( 0, Dbg, "FileInformationClass = %08lx\n", IrpSp->Parameters.QueryDirectory.FileInformationClass);
    DebugTrace( 0, Dbg, "RestartScan          = %08lx\n", FlagOn(IrpSp->Flags, SL_RESTART_SCAN));
    DebugTrace( 0, Dbg, "ReturnSingleEntry    = %08lx\n", FlagOn(IrpSp->Flags, SL_RETURN_SINGLE_ENTRY));
    DebugTrace( 0, Dbg, "IndexSpecified       = %08lx\n", FlagOn(IrpSp->Flags, SL_INDEX_SPECIFIED));

    //
    //  Save references to the input parameters within the Irp
    //

    SystemBufferLength   = IrpSp->Parameters.QueryDirectory.Length;

    FileIndex            = IrpSp->Parameters.QueryDirectory.FileIndex;

    FileInformationClass = IrpSp->Parameters.QueryDirectory.FileInformationClass;

    RestartScan          = BooleanFlagOn(IrpSp->Flags, SL_RESTART_SCAN);
    ReturnSingleEntry    = BooleanFlagOn(IrpSp->Flags, SL_RETURN_SINGLE_ENTRY);
    IndexSpecified       = BooleanFlagOn(IrpSp->Flags, SL_INDEX_SPECIFIED);

    if (IrpSp->Parameters.QueryDirectory.FileName != NULL) {

        FileName = *(PUNICODE_STRING)IrpSp->Parameters.QueryDirectory.FileName;

        //
        //  Make sure that the user called us with a proper unicode string.
        //  We will reject odd length file names (i.e., lengths with the low
        //  bit set)
        //

        if (FileName.Length & 0x1) {

            return STATUS_INVALID_PARAMETER;
        }

    } else {

        FileName.Length = 0;
        FileName.Buffer = NULL;
    }

    //
    //  Check if the ccb already has a query template attached.  If it
    //  does not already have one then we either use the string we are
    //  given or we attach our own containing "*"
    //

    if (Ccb->QueryTemplate == NULL) {

        //
        //  This is our first time calling query directory so we need
        //  to either set the query template to the user specified string
        //  or to "*"
        //

        if (FileName.Buffer == NULL) {

            DebugTrace(0, Dbg, "Set template to *\n", 0);

            FileName.Length = 2;
            FileName.Buffer = &Star;
        }

        DebugTrace(0, Dbg, "Set query template -> %Z\n", &FileName);

        //
        //  Allocate space for the query template
        //

        Ccb->QueryTemplate = NpAllocatePagedPoolWithQuota(sizeof(UNICODE_STRING) + FileName.Length, 'qFpN' );
        if (Ccb->QueryTemplate == NULL) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        //
        //  Initialize the query template and copy over the string
        //

        Ccb->QueryTemplate->Length = FileName.Length;
        Ccb->QueryTemplate->Buffer = (PWCH)Ccb->QueryTemplate +
                                     sizeof(UNICODE_STRING) / sizeof(WCHAR);

        RtlCopyMemory( Ccb->QueryTemplate->Buffer,
                       FileName.Buffer,
                       FileName.Length );

        //
        //  Now zero out the FileName so we won't think we're to use it
        //  as a subsearch string.
        //

        FileName.Length = 0;
        FileName.Buffer = NULL;
    }

    //
    //  Check if we were given an index to start with or if we need to
    //  restart the scan or if we should use the index that was saved in
    //  the ccb
    //

    if (RestartScan) {

        FileIndex = 0;

    } else if (!IndexSpecified) {

        FileIndex = Ccb->IndexOfLastCcbReturned + 1;
    }

    //
    //  Now we are committed to completing the Irp, we do that in
    //  the finally clause of the following try.
    //

    try {

        ULONG BaseLength;
        ULONG LengthAdded;
        BOOLEAN Match;

        //
        //  Map the user buffer
        //

        Buffer = NpMapUserBuffer( Irp );

        //
        //  At this point we are about to enter our query loop.  We have
        //  already decided which Fcb index we need to return.  The variables
        //  LastEntry and NextEntry are used to index into the user buffer.
        //  LastEntry is the last entry we added to the user buffer, and
        //  NextEntry is the current one we're working on.  CurrentIndex
        //  is the Fcb index that we are looking at next.  Logically the
        //  way the loop works is as follows.
        //
        //  Scan all of the Fcb in the directory
        //
        //      if the Fcb matches the query template then
        //
        //          if the CurrentIndex is >= the FileIndex then
        //
        //              process this fcb, and decide if we should
        //              continue the main loop
        //
        //          end if
        //
        //          Increment the current index
        //
        //      end if
        //
        //  end scan
        //

        CurrentIndex = 0;

        LastEntry = 0;
        NextEntry =0;

        switch (FileInformationClass) {

        case FileDirectoryInformation:

            BaseLength = FIELD_OFFSET( FILE_DIRECTORY_INFORMATION,
                                       FileName[0] );
            break;

        case FileFullDirectoryInformation:

            BaseLength = FIELD_OFFSET( FILE_FULL_DIR_INFORMATION,
                                       FileName[0] );
            break;

        case FileNamesInformation:

            BaseLength = FIELD_OFFSET( FILE_NAMES_INFORMATION,
                                       FileName[0] );
            break;

        case FileBothDirectoryInformation:

            BaseLength = FIELD_OFFSET( FILE_BOTH_DIR_INFORMATION,
                                       FileName[0] );
            break;

        default:

            try_return( Status = STATUS_INVALID_INFO_CLASS );
        }

        for (Links = RootDcb->Specific.Dcb.ParentDcbQueue.Flink;
             Links != &RootDcb->Specific.Dcb.ParentDcbQueue;
             Links = Links->Flink) {

            Fcb = CONTAINING_RECORD(Links, FCB, ParentDcbLinks);

            ASSERT(Fcb->NodeTypeCode == NPFS_NTC_FCB);

            DebugTrace(0, Dbg, "Top of Loop\n", 0);
            DebugTrace(0, Dbg, "Fcb          = %08lx\n", Fcb);
            DebugTrace(0, Dbg, "CurrentIndex = %08lx\n", CurrentIndex);
            DebugTrace(0, Dbg, "FileIndex    = %08lx\n", FileIndex);
            DebugTrace(0, Dbg, "LastEntry    = %08lx\n", LastEntry);
            DebugTrace(0, Dbg, "NextEntry    = %08lx\n", NextEntry);

            //
            //  Check if the Fcb represents a named pipe that is part of
            //  our query template
            //

            try {
                Match = FsRtlIsNameInExpression( Ccb->QueryTemplate,
                                                 &Fcb->LastFileName,
                                                 CaseInsensitive,
                                                 NULL );
            } except (EXCEPTION_EXECUTE_HANDLER) {
                try_return( Status = GetExceptionCode ());
            }

            if (Match) {

                //
                //  The fcb is in the query template so now check if
                //  this is the index we should start returning
                //

                if (CurrentIndex >= FileIndex) {

                    ULONG BytesToCopy;
                    ULONG BytesRemainingInBuffer;

                    //
                    //  Here are the rules concerning filling up the buffer:
                    //
                    //  1.  The Io system garentees that there will always be
                    //      enough room for at least one base record.
                    //
                    //  2.  If the full first record (including file name) cannot
                    //      fit, as much of the name as possible is copied and
                    //      STATUS_BUFFER_OVERFLOW is returned.
                    //
                    //  3.  If a subsequent record cannot completely fit into the
                    //      buffer, none of it (as in 0 bytes) is copied, and
                    //      STATUS_SUCCESS is returned.  A subsequent query will
                    //      pick up with this record.
                    //

                    BytesRemainingInBuffer = SystemBufferLength - NextEntry;

                    if ( (NextEntry != 0) &&
                         ( (BaseLength + Fcb->LastFileName.Length > BytesRemainingInBuffer) ||
                           (SystemBufferLength < NextEntry) ) ) {

                        DebugTrace(0, Dbg, "Next entry won't fit\n", 0);

                        try_return( Status = STATUS_SUCCESS );
                    }

                    ASSERT( BytesRemainingInBuffer >= BaseLength );

                    //
                    //  See how much of the name we will be able to copy into
                    //  the system buffer.  This also dictates out return
                    //  value.
                    //

                    if ( BaseLength + Fcb->LastFileName.Length <=
                         BytesRemainingInBuffer ) {

                        BytesToCopy = Fcb->LastFileName.Length;
                        Status = STATUS_SUCCESS;

                    } else {

                        BytesToCopy = BytesRemainingInBuffer - BaseLength;
                        Status = STATUS_BUFFER_OVERFLOW;
                    }

                    //
                    //  Note how much of buffer we are consuming and zero
                    //  the base part of the structure.  Protect our access
                    //  because it is the user's buffer.
                    //

                    LengthAdded = BaseLength + BytesToCopy;

                    try {

                        RtlZeroMemory( &Buffer[NextEntry], BaseLength );

                    } except (EXCEPTION_EXECUTE_HANDLER) {

                        try_return (Status = GetExceptionCode ());
                    }

                    //
                    //  Now fill the base parts of the strucure that are
                    //  applicable.
                    //

                    switch (FileInformationClass) {

                    case FileBothDirectoryInformation:

                        //
                        //  We don't need short name
                        //

                        DebugTrace(0, Dbg, "Getting directory full information\n", 0);

                    case FileFullDirectoryInformation:

                        //
                        //  We don't use EaLength, so fill in nothing here.
                        //

                        DebugTrace(0, Dbg, "Getting directory full information\n", 0);

                    case FileDirectoryInformation:

                        DebugTrace(0, Dbg, "Getting directory information\n", 0);

                        //
                        //  The eof indicates the number of instances and
                        //  allocation size is the maximum allowed.  Protect
                        //  our access because it is the user's buffer.
                        //

                        DirInfo = (PFILE_DIRECTORY_INFORMATION)&Buffer[NextEntry];

                        try {

                            DirInfo->EndOfFile.QuadPart = Fcb->OpenCount;
                            DirInfo->AllocationSize.QuadPart = Fcb->Specific.Fcb.MaximumInstances;

                            DirInfo->FileAttributes = FILE_ATTRIBUTE_NORMAL;

                            DirInfo->FileNameLength = Fcb->LastFileName.Length;

                        } except (EXCEPTION_EXECUTE_HANDLER) {

                            try_return (Status = GetExceptionCode ());
                        }

                        break;

                    case FileNamesInformation:

                        DebugTrace(0, Dbg, "Getting names information\n", 0);

                        //
                        //  Proctect our access because it is the user's buffer
                        //

                        NamesInfo = (PFILE_NAMES_INFORMATION)&Buffer[NextEntry];

                        try {

                            NamesInfo->FileNameLength = Fcb->LastFileName.Length;

                        } except (EXCEPTION_EXECUTE_HANDLER) {

                            try_return (Status = GetExceptionCode ());
                        }

                        break;

                    default:

                        NpBugCheck( FileInformationClass, 0, 0 );
                    }

                    //
                    //  Protect our access because it is the user's buffer
                    //

                    try {

                        RtlCopyMemory( &Buffer[NextEntry + BaseLength],
                                       Fcb->LastFileName.Buffer,
                                       BytesToCopy );

                    } except (EXCEPTION_EXECUTE_HANDLER) {

                        try_return (Status = GetExceptionCode ());
                    }

                    //
                    //  Update the ccb to the index we've just used
                    //

                    Ccb->IndexOfLastCcbReturned = CurrentIndex;

                    //
                    //  And indicate how much of the system buffer we have
                    //  currently used up.  We must compute this value before
                    //  we long align outselves for the next entry
                    //

                    Irp->IoStatus.Information = NextEntry + LengthAdded;

                    //
                    //  Setup the previous next entry offset.  Protect our
                    //  access because it is the user's buffer.
                    //

                    try {

                        *((PULONG)(&Buffer[LastEntry])) = NextEntry - LastEntry;

                    } except (EXCEPTION_EXECUTE_HANDLER) {

                        try_return (Status = GetExceptionCode ());
                    }

                    //
                    //  Check if the last entry didn't completely fit
                    //

                    if ( Status == STATUS_BUFFER_OVERFLOW ) {

                        try_return( NOTHING );
                    }

                    //
                    //  Check if we are only to return a single entry
                    //

                    if (ReturnSingleEntry) {

                        try_return( Status = STATUS_SUCCESS );
                    }

                    //
                    //  Set ourselves up for the next iteration
                    //

                    LastEntry = NextEntry;
                    NextEntry += (ULONG)QuadAlign( LengthAdded );
                }

                //
                //  Increment the current index by one
                //

                CurrentIndex += 1;
            }
        }

        //
        //  At this point we've scanned the entire list of Fcb so if
        //  the NextEntry is zero then we haven't found anything so we
        //  will return no more files, otherwise we return success.
        //

        if (NextEntry == 0) {

            Status = STATUS_NO_MORE_FILES;

        } else {

            Status = STATUS_SUCCESS;
        }

    try_exit: NOTHING;
    } finally {

        DebugTrace(-1, Dbg, "NpQueryDirectory -> %08lx\n", Status);
    }

    return Status;
}


//
//  Internal support routine
//

NTSTATUS
NpNotifyChangeDirectory (
    IN PROOT_DCB RootDcb,
    IN PROOT_DCB_CCB Ccb,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for doing the notify change directory.

Arugments:

    RootDcb - Supplies the dcb being queried

    Ccb - Supplies the context of the caller

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - STATUS_PENDING

--*/

{
    PIO_STACK_LOCATION IrpSp;
    PLIST_ENTRY Head;

    UNREFERENCED_PARAMETER( Ccb );

    PAGED_CODE();

    //
    //  Get the current stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "NpNotifyChangeDirectory\n", 0 );
    DebugTrace( 0, Dbg, "RootDcb = %08lx", RootDcb);
    DebugTrace( 0, Dbg, "Ccb     = %08lx", Ccb);


    if (IrpSp->Parameters.NotifyDirectory.CompletionFilter &
        ~FILE_NOTIFY_CHANGE_NAME) {
        Head = &RootDcb->Specific.Dcb.NotifyFullQueue;
    } else {
        Head = &RootDcb->Specific.Dcb.NotifyPartialQueue;
    }

    IoSetCancelRoutine( Irp, NpCancelChangeNotifyIrp );

    if (Irp->Cancel && IoSetCancelRoutine( Irp, NULL ) != NULL) {
        return STATUS_CANCELLED;
    } else {
        //
        //  Mark the Irp pending and insert into list.
        //
        IoMarkIrpPending( Irp );
        InsertTailList( Head,
                        &Irp->Tail.Overlay.ListEntry );
        return STATUS_PENDING;
    }
}


//
//  Local support routine
//

VOID
NpCancelChangeNotifyIrp (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the cancel function for an IRP saved in a change notify
    queue

Arguments:

    DeviceObject - ignored

    Irp - Supplies the Irp being cancelled.  A pointer to the proper dcb queue
        is stored in the information field of the Irp Iosb field.

Return Value:

    None.

--*/

{
    PLIST_ENTRY ListHead;

    UNREFERENCED_PARAMETER( DeviceObject );


    IoReleaseCancelSpinLock( Irp->CancelIrql );

    //
    //  Get exclusive access to the named pipe vcb so we can now do our work
    //
    FsRtlEnterFileSystem();
    NpAcquireExclusiveVcb();

    RemoveEntryList( &Irp->Tail.Overlay.ListEntry );

    NpReleaseVcb();
    FsRtlExitFileSystem();

    NpCompleteRequest( Irp, STATUS_CANCELLED );
    //
    //  And return to our caller
    //

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\npfs\dumpsup.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    DumpSup.c

Abstract:

    This module implements a collection of data structure dump routines
    for debugging the Named Pipe file system

Author:

    Gary Kimura     [GaryKi]    21-Aug-1990

Revision History:

--*/

#include "NpProcs.h"

#ifdef NPDBG

VOID NpDumpEventTableEntry(IN PEVENT_TABLE_ENTRY Ptr);
VOID NpDumpDataQueue(IN PDATA_QUEUE Ptr);
VOID NpDumpDataEntry(IN PDATA_ENTRY Ptr);

VOID NpDump(IN PVOID Ptr);
VOID NpDumpVcb(IN PVCB Ptr);
VOID NpDumpRootDcb(IN PROOT_DCB Ptr);
VOID NpDumpFcb(IN PFCB Ptr);
VOID NpDumpCcb(IN PCCB Ptr);
VOID NpDumpNonpagedCcb(IN PNONPAGED_CCB Ptr);
VOID NpDumpRootDcbCcb(IN PROOT_DCB_CCB Ptr);

ULONG NpDumpCurrentColumn;

#define DumpNewLine() { \
    DbgPrint("\n"); \
    NpDumpCurrentColumn = 1; \
}

#define DumpLabel(Label,Width) { \
    ULONG i; \
    CHAR _Str[20]; \
    for(i=0;i<2;i++) { _Str[i] = UCHAR_SP;} \
    strncpy(&_Str[2],#Label,Width); \
    for(i=strlen(_Str);i<Width;i++) {_Str[i] = UCHAR_SP;} \
    _Str[Width] = '\0'; \
    DbgPrint("%s", _Str); \
}

#define DumpField(Field) { \
    if ((NpDumpCurrentColumn + 18 + 9 + 9) > 80) {DumpNewLine();} \
    NpDumpCurrentColumn += 18 + 9 + 9; \
    DumpLabel(Field,18); \
    DbgPrint(":%8lx", Ptr->Field); \
    DbgPrint("         "); \
}

#define DumpListEntry(Links) { \
    if ((NpDumpCurrentColumn + 18 + 9 + 9) > 80) {DumpNewLine();} \
    NpDumpCurrentColumn += 18 + 9 + 9; \
    DumpLabel(Links,18); \
    DbgPrint(":%8lx", Ptr->Links.Flink); \
    DbgPrint(":%8lx", Ptr->Links.Blink); \
}

#define DumpName(Field,Width) { \
    ULONG i; \
    WCHAR _String[64]; \
    if ((NpDumpCurrentColumn + 18 + Width) > 80) {DumpNewLine();} \
    NpDumpCurrentColumn += 18 + Width; \
    DumpLabel(Field,18); \
    for(i=0;i<Width/2;i++) {_String[i] = Ptr->Field[i];} \
    _String[Width] = '\0'; \
    DbgPrint("%s", _String); \
}

#define TestForNull(Name) { \
    if (Ptr == NULL) { \
        DbgPrint("%s - Cannot dump a NULL pointer\n", Name); \
        return; \
    } \
}


VOID NpDumpEventTableEntry (
    IN PEVENT_TABLE_ENTRY Ptr
    )

{
    TestForNull   ("NpDumpEventTableEntry");

    DumpNewLine   ();
    DbgPrint       ("EventTableEntry@ %08lx", (Ptr));
    DumpNewLine   ();

    DumpField     (Ccb);
    DumpField     (NamedPipeEnd);
    DumpField     (EventHandle);
    DumpField     (Event);
    DumpField     (KeyValue);
    DumpField     (Process);
    DumpNewLine   ();

    return;
}


VOID NpDumpDataQueue (
    IN PDATA_QUEUE Ptr
    )

{
    PDATA_ENTRY Entry;

    TestForNull   ("NpDumpDataQueue");

    DumpNewLine   ();
    DbgPrint       ("DataQueue@ %08lx", (Ptr));
    DumpNewLine   ();

    DumpField     (QueueState);
    DumpField     (BytesInQueue);
    DumpField     (EntriesInQueue);
    DumpField     (Quota);
    DumpField     (QuotaUsed);
    DumpField     (FrontOfQueue);
    DumpField     (EndOfQueue);
    DumpField     (NextByteOffset);
    DumpNewLine   ();

    for (Entry = Ptr->FrontOfQueue;
         Entry != NULL;
         Entry = Entry->Next) {

        NpDumpDataEntry( Entry );
    }

    return;
}


VOID NpDumpDataEntry (
    IN PDATA_ENTRY Ptr
    )

{
    TestForNull   ("NpDumpDataEntry");

    DumpNewLine   ();
    DbgPrint       ("DataEntry@ %08lx", (Ptr));
    DumpNewLine   ();

    DumpField     (DataEntryType);
    DumpField     (From);
    DumpField     (Next);
    DumpField     (Irp);
    DumpField     (DataSize);
    DumpField     (DataPointer);
    DumpField     (SecurityClientContext);
    DumpNewLine   ();

    return;
}


VOID NpDump (
    IN PVOID Ptr
    )

/*++

Routine Description:

    This routine determines the type of internal record reference by ptr and
    calls the appropriate dump routine.

Arguments:

    Ptr - Supplies the pointer to the record to be dumped

Return Value:

    None

--*/

{
    TestForNull("NpDump");

    //
    //  We'll switch on the node type code
    //

    switch (NodeType(Ptr)) {

    case NPFS_NTC_VCB:               NpDumpVcb(Ptr);             break;
    case NPFS_NTC_ROOT_DCB:          NpDumpRootDcb(Ptr);         break;
    case NPFS_NTC_FCB:               NpDumpFcb(Ptr);             break;
    case NPFS_NTC_CCB:               NpDumpCcb(Ptr);             break;
    case NPFS_NTC_NONPAGED_CCB:      NpDumpNonpagedCcb(Ptr);     break;
    case NPFS_NTC_ROOT_DCB_CCB:      NpDumpRootDcbCcb(Ptr);      break;

    default :
        DbgPrint("NpDump - Unknown Node type code %8lx\n", *((PNODE_TYPE_CODE)(Ptr)));
        break;
    }

    return;
}


VOID NpDumpVcb (
    IN PVCB Ptr
    )

/*++

Routine Description:

    Dump an Vcb structure

Arguments:

    Ptr - Supplies the Device record to be dumped

Return Value:

    None

--*/

{
    TestForNull   ("NpDumpVcb");

    DumpNewLine   ();
    DbgPrint       ("Vcb@ %lx", (Ptr));
    DumpNewLine   ();

    DumpField     (NodeTypeCode);
    DumpField     (NodeByteSize);
    DumpField     (RootDcb);
    DumpField     (OpenCount);
    DumpNewLine   ();

    NpDump        (Ptr->RootDcb);

    return;
}


VOID NpDumpRootDcb (
    IN PROOT_DCB Ptr
    )

/*++

Routine Description:

    Dump a root dcb structure

Arguments:

    Ptr - Supplies the Root Dcb record to be dumped

Return Value:

    None

--*/

{
    PLIST_ENTRY Links;

    TestForNull   ("NpDumpRootDcb");

    DumpNewLine   ();
    DbgPrint       ("RootDcb@ %lx", (Ptr));
    DumpNewLine   ();

    DumpField     (NodeTypeCode);
    DumpField     (NodeByteSize);
    DumpListEntry (ParentDcbLinks);
    DumpField     (ParentDcb);
    DumpField     (OpenCount);
    DumpField     (FullFileName.Length);
    DumpField     (FullFileName.Buffer);
    DumpName      (FullFileName.Buffer, 32);
    DumpField     (LastFileName.Length);
    DumpField     (LastFileName.Buffer);
    DumpListEntry (Specific.Dcb.NotifyFullQueue);
    DumpListEntry (Specific.Dcb.NotifyPartialQueue);
    DumpListEntry (Specific.Dcb.ParentDcbQueue);
    DumpNewLine   ();

    for (Links = Ptr->Specific.Dcb.ParentDcbQueue.Flink;
         Links != &Ptr->Specific.Dcb.ParentDcbQueue;
         Links = Links->Flink) {
        NpDump(CONTAINING_RECORD(Links, FCB, ParentDcbLinks));
    }

    return;
}


VOID NpDumpFcb (
    IN PFCB Ptr
    )

/*++

Routine Description:

    Dump an Fcb structure

Arguments:

    Ptr - Supplies the Fcb record to be dumped

Return Value:

    None

--*/

{
    PLIST_ENTRY Links;

    TestForNull   ("NpDumpFcb");

    DumpNewLine   ();
    DbgPrint       ("Fcb@ %lx", (Ptr));
    DumpNewLine   ();

    DumpField     (NodeTypeCode);
    DumpField     (NodeByteSize);
    DumpListEntry (ParentDcbLinks);
    DumpField     (ParentDcb);
    DumpField     (OpenCount);
    DumpField     (FullFileName.Length);
    DumpField     (FullFileName.Buffer);
    DumpName      (FullFileName.Buffer, 32);
    DumpField     (LastFileName.Length);
    DumpField     (LastFileName.Buffer);
    DumpField     (Specific.Fcb.NamedPipeConfiguration);
    DumpField     (Specific.Fcb.NamedPipeType);
    DumpField     (Specific.Fcb.MaximumInstances);
    DumpField     (Specific.Fcb.DefaultTimeOut.LowPart);
    DumpField     (Specific.Fcb.DefaultTimeOut.HighPart);
    DumpListEntry (Specific.Fcb.CcbQueue);
    DumpNewLine   ();

    for (Links = Ptr->Specific.Fcb.CcbQueue.Flink;
         Links != &Ptr->Specific.Fcb.CcbQueue;
         Links = Links->Flink) {
        NpDump(CONTAINING_RECORD(Links, CCB, CcbLinks));
    }

    return;
}


VOID NpDumpCcb (
    IN PCCB Ptr
    )

/*++

Routine Description:

    Dump a Ccb structure

Arguments:

    Ptr - Supplies the Ccb record to be dumped

Return Value:

    None

--*/

{
    TestForNull   ("NpDumpCcb");

    DumpNewLine   ();
    DbgPrint       ("Ccb@ %lx", (Ptr));
    DumpNewLine   ();

    DumpField     (NodeTypeCode);
    DumpField     (NodeByteSize);
    DumpField     (Fcb);
    DumpField     (FileObject[0]);
    DumpField     (FileObject[1]);
    DumpField     (NamedPipeState);
    DumpField     (ReadMode[0]);
    DumpField     (ReadMode[1]);
    DumpField     (CompletionMode[0]);
    DumpField     (CompletionMode[1]);
    DumpField     (CreatorProcess);
    DumpField     (SecurityClientContext);
    DumpNewLine   ();

    NpDumpDataQueue(&Ptr->DataQueue[0]);
    NpDumpDataQueue(&Ptr->DataQueue[1]);

    NpDump        (Ptr->NonpagedCcb);

    return;
}


VOID NpDumpNonpagedCcb (
    IN PNONPAGED_CCB Ptr
    )

/*++

Routine Description:

    Dump a Nonpaged Ccb structure

Arguments:

    Ptr - Supplies the Nonpaged Ccb record to be dumped

Return Value:

    None

--*/

{
    TestForNull   ("NpDumpNonpagedCcb");

    DumpNewLine   ();
    DbgPrint       ("NonpagedCcb@ %lx", (Ptr));
    DumpNewLine   ();

    DumpField     (NodeTypeCode);
    DumpField     (NodeByteSize);
    DumpField     (EventTableEntry[0]);
    DumpField     (EventTableEntry[1]);
    DumpListEntry (ListeningQueue);
    DumpNewLine   ();

    return;
}


VOID NpDumpRootDcbCcb (
    IN PROOT_DCB_CCB Ptr
    )

/*++

Routine Description:

    Dump a Root Dcb Ccb structure

Arguments:

    Ptr - Supplies the Root Dcb Ccb record to be dumped

Return Value:

    None

--*/

{
    TestForNull   ("NpDumpRootDcbCcb");

    DumpNewLine   ();
    DbgPrint       ("RootDcbCcb@ %lx", (Ptr));
    DumpNewLine   ();

    DumpField     (NodeTypeCode);
    DumpField     (NodeByteSize);
    DumpField     (IndexOfLastCcbReturned);
    DumpNewLine   ();

    return;
}

#endif // NPDBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\npfs\filobsup.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    FilObSup.c

Abstract:

    This module implements the Named Pipe File object support routines.

Author:

    Gary Kimura     [GaryKi]    30-Aug-1990

Revision History:

--*/

#include "NpProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (NPFS_BUG_CHECK_FILOBSUP)

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_FILOBSUP)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NpDecodeFileObject)
#pragma alloc_text(PAGE, NpSetFileObject)
#endif


VOID
NpSetFileObject (
    IN PFILE_OBJECT FileObject OPTIONAL,
    IN PVOID FsContext,
    IN PVOID FsContext2,
    IN NAMED_PIPE_END NamedPipeEnd
    )

/*++

Routine Description:

    This routine sets the file system pointers within the file object
    and handles the indicator for storing the named pipe end.

Arguments:

    FileObject - Supplies a pointer to the file object being modified, and
        can optionally be null.

    FsContext - Supplies a pointer to either a ccb, vcb, or root_dcb
        structure.

    FsContext2 - Supplies a pointer to either a nonpaged ccb, root_dcb_ccb,
        or is null

    NamedPipeEnd - Supplies the indication if this is either the server end
        or client end file object.  This is only applicable if the
        fscontext points to a ccb.

Return Value:

    None.

--*/

{
    BOOLEAN GotCcb;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "NpSetFileObject, FileObject = %08lx\n", FileObject );

    //
    //  If no file object was given, do nothing.
    //

    if (ARGUMENT_PRESENT( FileObject )) {

        //
        //  Check if we need to add in the named pipe end to the
        //  fscontext pointer.  We only need to 'OR' in a 1 if this is
        //  the server end and fscontext points to a ccb.  Also remember
        //  now if this is a pointer is a ccb, so that we can later set
        //  the fo_named_pipe flag
        //

        if ((FsContext != NULL) &&
            (*(PNODE_TYPE_CODE)FsContext == NPFS_NTC_CCB)) {

            GotCcb = TRUE;

            if (NamedPipeEnd == FILE_PIPE_SERVER_END) {

                FsContext = (PVOID)((ULONG_PTR)FsContext | 0x00000001);
            }

        } else {

            GotCcb = FALSE;
        }

        //
        //  Now set the fscontext fields of the file object, and conditionally
        //  set the named pipe flag in the file object if necessary.
        //

        FileObject->FsContext  = FsContext;
        FileObject->FsContext2 = FsContext2;

        //
        //  Set the private cache map to 1 and that what we will get our
        //  fast I/O routines called
        //

        FileObject->PrivateCacheMap = (PVOID)1;

        if (GotCcb) {

            FileObject->Flags |= FO_NAMED_PIPE;
        }
    }

    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "NpSetFileObject -> VOID\n", 0);

    return;
}


NODE_TYPE_CODE
NpDecodeFileObject (
    IN PFILE_OBJECT FileObject,
    OUT PFCB *Fcb OPTIONAL,
    OUT PCCB *Ccb,
    OUT PNAMED_PIPE_END NamedPipeEnd OPTIONAL
    )

/*++

Routine Description:

    This procedure takes a pointer to a file object, that has already been
    opened by the named pipe file system and figures out what it really
    is opened.

Arguments:

    FileObject - Supplies the file object pointer being interrogated

    Fcb - Receives a pointer to the Fcb for the file object, if we can
        find it.

    Ccb - Receives a pointer to the Ccb for the file object, if we can
        find it

    NamedPipeEnd - Receives a value indicating if this is a server
        or client end file object.

Return Value:

    NODE_TYPE_CODE - Returns the node type code for a Vcb, RootDcb, Ccb,
        or zero.

        Vcb - indicates that file object opens the named pipe driver.
            Fcb and Ccb are NOT returned.

        RootDcb - indicates that the file object is for the root directory.
            Fcb (RootDcb), and Ccb (RootDcbCcb) are set.

        Ccb - indicates that the file object is for a named pipe instance.
            Ccb is set, while Fcb is optionally set.

        Zero - indicates that the file object was for a named pipe instance
            but became disconnected.  Fcb, Ccb, and NamedPipeEnd are NOT
            returned.

--*/

{
    NODE_TYPE_CODE NodeTypeCode;
    PVOID FsContext;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "NpDecodeFileObject, FileObject = %08lx\n", FileObject);

    //
    //  Reference the fs context fields of the file object.
    //

    FsContext = FileObject->FsContext;

    //
    //  If the fscontext field is null then we been disconnected.
    //

    if ((FsContext == NULL) || ((ULONG_PTR)FsContext == 1)) {

        NodeTypeCode = NTC_UNDEFINED;

    } else {

        //
        //  We're actually pointing to something so first extract the
        //  named pipe end information and then we can reference through
        //  the fscontext pointer after we clean it up.
        //

        if (ARGUMENT_PRESENT(NamedPipeEnd)) {
            if (FlagOn((ULONG_PTR)FsContext, 0x00000001)) {
                *NamedPipeEnd = FILE_PIPE_SERVER_END;
            } else {
                *NamedPipeEnd = FILE_PIPE_CLIENT_END;
            }
        }

        FsContext = (PVOID)((ULONG_PTR)FsContext & ~0x00000001);

        //
        //  Now we can case on the node type code of the fscontext pointer
        //  and set the appropriate out pointers
        //

        NodeTypeCode = *(PNODE_TYPE_CODE)FsContext;

        switch (NodeTypeCode) {

        case NPFS_NTC_VCB:

            break;

        case NPFS_NTC_ROOT_DCB:

            *Ccb = FileObject->FsContext2;
            if (ARGUMENT_PRESENT(Fcb)) {
                *Fcb = FsContext;
            }
            break;

        case NPFS_NTC_CCB:

            *Ccb = FsContext;
            if (ARGUMENT_PRESENT(Fcb)) {
                *Fcb = ((PCCB)FsContext)->Fcb;
            }
            break;

        default:

            NpBugCheck( NodeTypeCode, 0, 0 );
        }
    }

    //
    //  and return to our caller
    //

    DebugTrace(-1, Dbg, "NpDecodeFileObject -> %08lx\n", NodeTypeCode);

    return NodeTypeCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\npfs\flushbuf.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    FlushBuf.c

Abstract:

    This module implements the File Flush Buffers routine for NPFS called by
    the dispatch driver.

Author:

    Gary Kimura     [GaryKi]    21-Aug-1990

Revision History:

--*/

#include "NpProcs.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_FLUSH_BUFFERS)

//
//  local procedure prototypes
//

NTSTATUS
NpCommonFlushBuffers (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NpCommonFlushBuffers)
#pragma alloc_text(PAGE, NpFsdFlushBuffers)
#endif


NTSTATUS
NpFsdFlushBuffers (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the FSD part of the NtFlushBuffersFile API calls.

Arguments:

    NpfsDeviceObject - Supplies the device object to use.

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The Fsd status for the Irp

--*/

{
    NTSTATUS Status;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "NpFsdFlushBuffers\n", 0);

    //
    //  Call the common Flush routine.
    //

    FsRtlEnterFileSystem();

    NpAcquireSharedVcb();

    Status = NpCommonFlushBuffers( NpfsDeviceObject, Irp );

    NpReleaseVcb();

    FsRtlExitFileSystem();

    if (Status != STATUS_PENDING) {
        NpCompleteRequest( Irp, Status );
    }
    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "NpFsdFlushBuffers -> %08lx\n", Status );

    return Status;
}


//
//  Internal support routine
//

NTSTATUS
NpCommonFlushBuffers (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for Flushing buffers for a file.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - the return status for the operation

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;

    PCCB Ccb;
    NAMED_PIPE_END NamedPipeEnd;

    PDATA_QUEUE WriteQueue;

    //
    //  Get the current stack location
    //

    PAGED_CODE();

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "NpCommonFlushBuffers\n", 0);
    DebugTrace( 0, Dbg, "Irp        = %08lx\n", Irp);
    DebugTrace( 0, Dbg, "FileObject = %08lx\n", IrpSp->FileObject);

    //
    //  Decode the file object to figure out who we are.  If the result
    //  is not a ccb then the pipe has been disconnected.  We don't need the
    //  Fcb back from the call
    //

    if (NpDecodeFileObject( IrpSp->FileObject,
                            NULL,
                            &Ccb,
                            &NamedPipeEnd ) != NPFS_NTC_CCB) {

        DebugTrace(0, Dbg, "Pipe is disconnected from us\n", 0);

        Status = STATUS_PIPE_DISCONNECTED;

        DebugTrace(-1, Dbg, "NpCommonFlushBuffers -> %08lx\n", Status );
        return Status;
    }

    NpAcquireExclusiveCcb(Ccb);

    try {

        //
        //  Figure out the data queue that the flush buffer is
        //  targetted at.  It is the queue that we do writes into
        //

        if (NamedPipeEnd == FILE_PIPE_SERVER_END) {

            WriteQueue = &Ccb->DataQueue[ FILE_PIPE_OUTBOUND ];

        } else {

            WriteQueue = &Ccb->DataQueue[ FILE_PIPE_INBOUND ];
        }

        //
        //  Now from the write queue check if contains write entries.  If
        //  it does not contain write entries then we immediately complete
        //  this irp with success because there isn't anything to flush
        //

        if (!NpIsDataQueueWriters( WriteQueue )) {

            DebugTrace(0, Dbg, "Pipe does not contain write entries\n", 0);

            try_return(Status = STATUS_SUCCESS);
        }

        //
        //  Otherwise the queue is full of writes so we simply
        //  enqueue this irp to the back to the queue and set our
        //  return status to pending, also mark the irp pending
        //

        Status = NpAddDataQueueEntry( NamedPipeEnd,
                                      Ccb,
                                      WriteQueue,
                                      WriteEntries,
                                      Flush,
                                      0,
                                      Irp,
                                      NULL,
                                      0 );

    try_exit: NOTHING;
    } finally {
        NpReleaseCcb(Ccb);
    }


    DebugTrace(-1, Dbg, "NpCommonFlushBuffers -> %08lx\n", Status);
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\npfs\npdata.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    NpData.c

Abstract:

    This module declares the global data used by the Named Pipe file system.

Author:

    Gary Kimura     [GaryKi]    28-Dec-1989

Revision History:

--*/

#include "NpProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (NPFS_BUG_CHECK_NPDATA)

//
//  Local debug trace level
//

#define Dbg                              (DEBUG_TRACE_CATCH_EXCEPTIONS)


PVCB NpVcb = NULL;

FAST_IO_DISPATCH NpFastIoDispatch = { sizeof(FAST_IO_DISPATCH),
                                      NULL,         //  FastIoCheck
                                      NpFastRead,   //  Read
                                      NpFastWrite,  //  Write
                                      NULL,         //  QueryBasicInfo
                                      NULL,         //  QueryStandardInfo
                                      NULL,         //  Lock
                                      NULL,         //  UnlockSingle
                                      NULL,         //  UnlockAll
                                      NULL };       //  UnlockAllByKey

//
//  Lists of pipe name aliases.
//

SINGLE_LIST_ENTRY NpAliasListByLength[(MAX_LENGTH_ALIAS_ARRAY-MIN_LENGTH_ALIAS_ARRAY)/sizeof(WCHAR)+1] = {NULL};
SINGLE_LIST_ENTRY NpAliasList = {NULL};

PVOID NpAliases = NULL; // single allocation containing all aliases


#ifdef NPDBG
LONG NpDebugTraceLevel = 0x00000000;
LONG NpDebugTraceIndent = 0;
#endif // NPDBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\npfs\eventsup.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    EventSup.c

Abstract:

    This module implements the Named Pipe Event support routines.

Author:

    Gary Kimura     [GaryKi]    30-Aug-1990

Revision History:

--*/

#include "NpProcs.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_EVENTSUP)

//
//  The following variable is exported from the kernel and is needed by npfs to
//  determine if an event was handed down.
//

extern POBJECT_TYPE *ExEventObjectType;

#ifdef ALLOC_PRAGMA
#pragma alloc_text (PAGE, NpAddEventTableEntry)
#pragma alloc_text (PAGE, NpDeleteEventTableEntry)
#pragma alloc_text (PAGE, NpGetNextEventTableEntry)
#pragma alloc_text (PAGE, NpEventTableCompareRoutine)
#pragma alloc_text (PAGE, NpEventTableAllocate)
#pragma alloc_text (PAGE, NpEventTableDeallocate)
#endif

NTSTATUS
NpAddEventTableEntry (
    IN  PEVENT_TABLE EventTable,
    IN  PCCB Ccb,
    IN  NAMED_PIPE_END NamedPipeEnd,
    IN  HANDLE EventHandle,
    IN  ULONG KeyValue,
    IN  PEPROCESS Process,
    IN  KPROCESSOR_MODE PreviousMode,
    OUT PEVENT_TABLE_ENTRY *ppEventTableEntry
    )

/*++

Routine Description:

    This routine adds a new entry into the event table.  If an entry already
    exists it overwrites the existing entry.

Arguments:

    EventTable - Supplies the event table being modified

    Ccb - Supplies a pointer to the ccb to store in event table entry

    NamedPipeEnd - Indicates the server or client end for the event

    EventHandle - Supplies the handle to the event being added.  The object
        is referenced by this procedure

    KeyValue - Supplies a key value to associate with the event

    Process - Supplies a pointer to the process adding the event

    PreviousMode - Supplies the mode of the user initiating the action

Return Value:

    PEVENT_TABLE_ENTRY - Returns a pointer to the newly added event.
        This is an actual pointer to the table entry.

    This procedure also will raise status if the event handle cannot be
    accessed by the caller

--*/

{
    NTSTATUS Status;
    KIRQL OldIrql;

    EVENT_TABLE_ENTRY Template;
    PEVENT_TABLE_ENTRY EventTableEntry;
    PVOID Event;

    DebugTrace(+1, Dbg, "NpAddEventTableEntry, EventTable = %08lx\n", EventTable);

    //
    //  Reference the event object by handle.
    //

    if (!NT_SUCCESS(Status = ObReferenceObjectByHandle( EventHandle,
                                                        EVENT_MODIFY_STATE,
                                                        *ExEventObjectType,
                                                        PreviousMode,
                                                        &Event,
                                                        NULL ))) {

        return Status;
    }

    //
    //  Set up the template event entry to lookup
    //

    Template.Ccb = Ccb;
    Template.NamedPipeEnd = NamedPipeEnd;
    Template.EventHandle = EventHandle;
    Template.Event = Event;
    Template.KeyValue = KeyValue;
    Template.Process = Process;

    //
    //  Now insert this new entry into the event table
    //

    EventTableEntry = RtlInsertElementGenericTable( &EventTable->Table,
                                                    &Template,
                                                    sizeof(EVENT_TABLE_ENTRY),
                                                    NULL );
    if (EventTableEntry == NULL) {
        ObDereferenceObject (Event);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    //  Copy over the template again just in case we were given an
    //  old entry
    //

    *EventTableEntry = Template;

    DebugTrace(-1, Dbg, "NpAddEventTableEntry -> %08lx\n", EventTableEntry);

    //
    //  And now return to our caller
    //
    *ppEventTableEntry = EventTableEntry;
    return STATUS_SUCCESS;
}


VOID
NpDeleteEventTableEntry (
    IN PEVENT_TABLE EventTable,
    IN PEVENT_TABLE_ENTRY Template
    )

/*++

Routine Description:

    This routine removes an entry from the event table, it also dereferences
    the event object that was referenced when the object was inserted

Arguments:

    EventTable - Supplies a pointer to the event table being modified

    Template - Supplies a copy of the event table entry we are lookin up.
        Note that this can also be a pointer to the actual event table entry.

Return Value:

    None.

--*/

{
    KIRQL OldIrql;

    DebugTrace(+1, Dbg, "NpDeleteEventTableEntry, EventTable = %08lx\n", EventTable);

    //
    //  Only do the work if we are given a non null template
    //

    if (!ARGUMENT_PRESENT(Template)) {

        DebugTrace(-1, Dbg, "NpDeleteEventTableEntry -> VOID\n", 0);

        return;
    }

    //
    //  Dereference the event object
    //

    ObDereferenceObject(Template->Event);

    //
    //  Now remove this element from the generic table
    //

    (VOID)RtlDeleteElementGenericTable( &EventTable->Table,
                                        Template );

    DebugTrace(-1, Dbg, "NpDeleteEventTableEntry -> VOID\n", 0);

    //
    //  And now return to our caller
    //

    return;
}


PEVENT_TABLE_ENTRY
NpGetNextEventTableEntry (
    IN PEVENT_TABLE EventTable,
    IN PVOID *RestartKey
    )

/*++

Routine Description:

    This routine enumerates the events stored within an event table.

Arguments:

    EventTable - Supplies a pointer to the event being enumerated

    Restart - Indicates if the enumeration should restart or continue

Return Value:

    PEVENT_TABLE_ENTRY - Returns a pointer to the next event table entry
        in the table, or NULL if the enumeration is complete.

--*/

{
    KIRQL OldIrql;
    PEVENT_TABLE_ENTRY EventTableEntry;

    DebugTrace(+1, Dbg, "NpGetNextEventTableEntry, EventTable = %08lx\n", EventTable);

    //
    //  Lookup the next element in the table
    //

    EventTableEntry = RtlEnumerateGenericTableWithoutSplaying( &EventTable->Table, RestartKey );

    DebugTrace(-1, Dbg, "NpGetNextEventTableEntry -> %08lx\n", EventTableEntry);

    //
    //  And now return to our caller
    //

    return EventTableEntry;
}


//
//  Local support routines
//

RTL_GENERIC_COMPARE_RESULTS
NpEventTableCompareRoutine (
    IN PRTL_GENERIC_TABLE EventTable,
    IN PVOID FirstStruct,
    IN PVOID SecondStruct
    )

/*++

Routine Description:

    This routine is the comparsion routine for the Event Table which is
    implemented as a generic table.

Arguments:

    EventTable - Supplies a pointer to the event table which is involved
        in this action

    FirstStruct - Supplies a pointer to the first event table entry to examine

    SecondStruct - Supplies a pointer to the second event table entry to
        examine

Return Value:

    RTL_GENERIC_COMPARE_RESULTS - GenericLessThan if FirstEntry is less than
        SecondEntry, GenericGreaterThan if FirstEntry is greater than
        SecondEntry, and GenericEqual otherwise.

--*/

{
    PEVENT_TABLE_ENTRY FirstEntry = FirstStruct;
    PEVENT_TABLE_ENTRY SecondEntry = SecondStruct;

    UNREFERENCED_PARAMETER( EventTable );

    //
    //  We'll compare first the pointer to the ccb and then compare the
    //  pipe end types.  This will guarantee a unique ordering based on
    //  the pipe instance and pipe end (i.e., server and client end).
    //

    if (FirstEntry->Ccb < SecondEntry->Ccb) {

        return GenericLessThan;

    } else if (FirstEntry->Ccb > SecondEntry->Ccb) {

        return GenericGreaterThan;

    } else if (FirstEntry->NamedPipeEnd < SecondEntry->NamedPipeEnd) {

        return GenericLessThan;

    } else if (FirstEntry->NamedPipeEnd > SecondEntry->NamedPipeEnd) {

        return GenericGreaterThan;

    } else {

        return GenericEqual;
    }
}


//
//  Local support routines
//

PVOID
NpEventTableAllocate (
    IN PRTL_GENERIC_TABLE EventTable,
    IN CLONG ByteSize
    )

/*++

Routine Description:

    This routine is the generic allocation routine for the event table.

Arguments:

    EventTable - Supplies a pointer to the event table being used

    ByteSize - Supplies the size, in bytes, to allocate.

Return Value:

    PVOID - Returns a pointer to the newly allocated buffer.

--*/

{
    return NpAllocateNonPagedPoolWithQuota( ByteSize, 'gFpN' );
}


//
//  Local support routines
//

VOID
NpEventTableDeallocate (
    IN PRTL_GENERIC_TABLE EventTable,
    IN PVOID Buffer
    )

/*++

Routine Description:

    This routine is the generic deallocation routine for the event table.

Arguments:

    EventTable - Supplies a pointer to the event table being used

    Buffer - Supplies the buffer being deallocated

Return Value:

    None.

--*/

{
    UNREFERENCED_PARAMETER( EventTable );

    NpFreePool( Buffer );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\npfs\fsctrl.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    FsContrl.c

Abstract:

    This module implements the File System Control routine for NPFS called by
    the dispatch driver.

Author:

    Gary Kimura     [GaryKi]    21-Aug-1990

Revision History:

--*/

#include "NpProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (NPFS_BUG_CHECK_FSCTRL)

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_FSCONTRL)



#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NpAssignEvent)
#pragma alloc_text(PAGE, NpCommonFileSystemControl)
#pragma alloc_text(PAGE, NpCompleteTransceiveIrp)
#pragma alloc_text(PAGE, NpDisconnect)
#pragma alloc_text(PAGE, NpFsdFileSystemControl)
#pragma alloc_text(PAGE, NpImpersonate)
#pragma alloc_text(PAGE, NpInternalRead)
#pragma alloc_text(PAGE, NpInternalTransceive)
#pragma alloc_text(PAGE, NpInternalWrite)
#pragma alloc_text(PAGE, NpListen)
#pragma alloc_text(PAGE, NpPeek)
#pragma alloc_text(PAGE, NpQueryClientProcess)
#pragma alloc_text(PAGE, NpQueryEvent)
#pragma alloc_text(PAGE, NpSetClientProcess)
#pragma alloc_text(PAGE, NpTransceive)
#pragma alloc_text(PAGE, NpWaitForNamedPipe)
#endif



NTSTATUS
NpFsdFileSystemControl (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the FSD part of the NtFsControlFile API calls.

Arguments

    NpfsDeviceObject - Supplies the device object to use.

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The Fsd status for the Irp

--*/

{
    NTSTATUS Status;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "NpFsdFileSystemControl\n", 0);

    //
    //  Call the common FsControl routine.
    //

    FsRtlEnterFileSystem();

    Status = NpCommonFileSystemControl( NpfsDeviceObject,
                                        Irp );
    FsRtlExitFileSystem();

    if (Status != STATUS_PENDING) {
        NpCompleteRequest (Irp, Status);
    }

    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "NpFsdFileSystemControl -> %08lx\n", Status );

    return Status;
}


//
//  Internal Support Routine
//

NTSTATUS
NpCommonFileSystemControl (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine does the common code for handling/dispatching an fsctl
    function.

Arguments:

    NpfsDeviceObject - Supplies the named pipe device object

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;
    BOOLEAN ReadOverflowOperation;
    LIST_ENTRY DeferredList;

    PAGED_CODE();

    //
    //  Reference our input parameters to make things easier
    //

    IrpSp = IoGetCurrentIrpStackLocation (Irp);

    InitializeListHead (&DeferredList);

    DebugTrace(+1, Dbg, "NpCommonFileSystemControl\n", 0);
    DebugTrace( 0, Dbg, "Irp                = %08lx\n", Irp);
    DebugTrace( 0, Dbg, "OutputBufferLength = %08lx\n", IrpSp->Parameters.FileSystemControl.OutputBufferLength);
    DebugTrace( 0, Dbg, "InputBufferLength  = %08lx\n", IrpSp->Parameters.FileSystemControl.InputBufferLength);
    DebugTrace( 0, Dbg, "FsControlCode      = %08lx\n", IrpSp->Parameters.FileSystemControl.FsControlCode);

    //
    //  Case on the type of function we're trying to do.  In each case
    //  we'll call a local work routine to do the actual work.
    //

    ReadOverflowOperation = FALSE;

    switch (IrpSp->Parameters.FileSystemControl.FsControlCode) {

    case FSCTL_PIPE_ASSIGN_EVENT:

        NpAcquireExclusiveVcb ();
        Status = NpAssignEvent (NpfsDeviceObject, Irp);
        break;

    case FSCTL_PIPE_DISCONNECT:

        NpAcquireExclusiveVcb ();
        Status = NpDisconnect (NpfsDeviceObject, Irp, &DeferredList);
        break;

    case FSCTL_PIPE_LISTEN:

        NpAcquireSharedVcb ();
        Status = NpListen (NpfsDeviceObject, Irp, &DeferredList);
        break;

    case FSCTL_PIPE_PEEK:

        NpAcquireExclusiveVcb ();
        Status = NpPeek (NpfsDeviceObject, Irp, &DeferredList);
        break;

    case FSCTL_PIPE_QUERY_EVENT:

        NpAcquireExclusiveVcb ();
        Status = NpQueryEvent (NpfsDeviceObject, Irp);
        break;

    case FSCTL_PIPE_TRANSCEIVE:

        NpAcquireSharedVcb ();
        Status = NpTransceive (NpfsDeviceObject, Irp, &DeferredList);
        break;

    case FSCTL_PIPE_WAIT:

        NpAcquireExclusiveVcb ();
        Status = NpWaitForNamedPipe (NpfsDeviceObject, Irp);
        break;

    case FSCTL_PIPE_IMPERSONATE:

        NpAcquireExclusiveVcb ();
        Status = NpImpersonate (NpfsDeviceObject, Irp);
        break;

    case FSCTL_PIPE_INTERNAL_READ_OVFLOW:

        ReadOverflowOperation = TRUE;

    case FSCTL_PIPE_INTERNAL_READ:

        NpAcquireSharedVcb ();
        Status = NpInternalRead (NpfsDeviceObject, Irp, ReadOverflowOperation, &DeferredList);
        break;

    case FSCTL_PIPE_INTERNAL_WRITE:

        NpAcquireSharedVcb ();
        Status = NpInternalWrite (NpfsDeviceObject, Irp, &DeferredList);
        break;

    case FSCTL_PIPE_INTERNAL_TRANSCEIVE:

        NpAcquireSharedVcb ();
        Status = NpInternalTransceive (NpfsDeviceObject, Irp, &DeferredList);
        break;

    case FSCTL_PIPE_QUERY_CLIENT_PROCESS:

        NpAcquireSharedVcb ();
        Status = NpQueryClientProcess (NpfsDeviceObject, Irp);
        break;

    case FSCTL_PIPE_SET_CLIENT_PROCESS:

        NpAcquireExclusiveVcb ();
        Status = NpSetClientProcess (NpfsDeviceObject, Irp);
        break;

    default:

        return STATUS_NOT_SUPPORTED; // No lock acquired
    }

    NpReleaseVcb ();

    //
    // Complete any deferred IRPs now we have dropped the last lock
    //
    NpCompleteDeferredIrps (&DeferredList);


    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "NpCommonFileSystemControl -> %08lx\n", Status);

    return Status;
}


//
//  Local support routine
//

NTSTATUS
NpAssignEvent (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine does the assign event control function

Arguments:

    NpfsDeviceObject - Supplies our device object

    Irp - Supplies the Irp specifying the function

Return Value:

    NTSTATUS - An appropriate return status

--*/

{
    PIO_STACK_LOCATION IrpSp;

    ULONG InputBufferLength;
    ULONG FsControlCode;

    PCCB Ccb;
    PNONPAGED_CCB NonpagedCcb;
    NAMED_PIPE_END NamedPipeEnd;

    PFILE_PIPE_ASSIGN_EVENT_BUFFER EventBuffer;
    NTSTATUS status;

    PAGED_CODE();

    //
    //  Get the current stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "NpAssignEvent...\n", 0);

    InputBufferLength  = IrpSp->Parameters.FileSystemControl.InputBufferLength;
    FsControlCode      = IrpSp->Parameters.FileSystemControl.FsControlCode;

    //
    //  Decode the file object to figure out who we are.  If the result
    //  is not a ccb then the pipe has been disconnected.
    //

    if (NpDecodeFileObject( IrpSp->FileObject,
                            NULL,
                            &Ccb,
                            &NamedPipeEnd ) != NPFS_NTC_CCB) {

        DebugTrace(0, Dbg, "Pipe is disconnected from us\n", 0);

        return STATUS_PIPE_DISCONNECTED;
    }

    NonpagedCcb = Ccb->NonpagedCcb;

    //
    //  Reference the system buffer as an assign event buffer and make
    //  sure it's large enough
    //

    EventBuffer = Irp->AssociatedIrp.SystemBuffer;


    if (InputBufferLength < sizeof(FILE_PIPE_ASSIGN_EVENT_BUFFER)) {

        DebugTrace(0, Dbg, "System buffer size is too small\n", 0);

        return STATUS_INVALID_PARAMETER;
    }


    //
    //  First thing we do is delete the old event if there is one
    //  for this end of the pipe
    //

    NpDeleteEventTableEntry( &NpVcb->EventTable,
                             NonpagedCcb->EventTableEntry[ NamedPipeEnd ] );

    NonpagedCcb->EventTableEntry[ NamedPipeEnd ] = NULL;

    //
    //  Now if the new event handle is not null then we'll add the new
    //  event to the event table
    //

    status = STATUS_SUCCESS;
    if (EventBuffer->EventHandle != NULL) {

        status = NpAddEventTableEntry( &NpVcb->EventTable,
                                       Ccb,
                                       NamedPipeEnd,
                                       EventBuffer->EventHandle,
                                       EventBuffer->KeyValue,
                                       PsGetCurrentProcess(),
                                       Irp->RequestorMode,
                                       &NonpagedCcb->EventTableEntry[ NamedPipeEnd ] );
    }


    DebugTrace(-1, Dbg, "NpAssignEvent -> STATUS_SUCCESS\n", 0);
    return status;
}


//
//  Local Support Routine
//

NTSTATUS
NpDisconnect (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp,
    IN PLIST_ENTRY DeferredList
    )

/*++

Routine Description:

    This routine does the disconnect control function

Arguments:

    NpfsDeviceObject - Supplies our device object

    Irp - Supplies the being processed

    DeferredList - List of IRPs to complete after we drop the locks

Return Value:

    NTSTATUS - An apprropriate return status

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;

    ULONG FsControlCode;

    PCCB Ccb;
    NAMED_PIPE_END NamedPipeEnd;

    PAGED_CODE();

    //
    //  Get the current stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "NpDisconnect...\n", 0);

    FsControlCode = IrpSp->Parameters.FileSystemControl.FsControlCode;

    //
    //  Decode the file object to figure out who we are.  If the result
    //  is not a ccb then the pipe has been disconnected.
    //

    if (NpDecodeFileObject( IrpSp->FileObject,
                            NULL,
                            &Ccb,
                            &NamedPipeEnd ) != NPFS_NTC_CCB) {

        DebugTrace(0, Dbg, "Pipe is disconnected from us\n", 0);

        return STATUS_PIPE_DISCONNECTED;
    }

    //
    //  Make sure that this is only the server that is doing this
    //  action.
    //

    if (NamedPipeEnd != FILE_PIPE_SERVER_END) {

        DebugTrace(0, Dbg, "Not the server end\n", 0);

        return STATUS_ILLEGAL_FUNCTION;
    }

    NpAcquireExclusiveCcb(Ccb);

    //
    //  Now call the state support routine to set the ccb to
    //  a disconnected state and remove the client's cached security
    //  context.
    //

    Status = NpSetDisconnectedPipeState( Ccb, DeferredList );

    NpUninitializeSecurity( Ccb );

    NpReleaseCcb(Ccb);

    DebugTrace(-1, Dbg, "NpDisconnect -> %08lx\n", Status);
    return Status;
}


//
//  Local Support Routine
//

NTSTATUS
NpListen (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp,
    IN PLIST_ENTRY DeferredList
    )

/*++

Routine Description:

    This routine does the listen control function

Arguments:

    NpfsDeviceObject - Supplies our device object

    Irp - Supplies the being processed

    DeferredList - List of IRPs to complete once we drop the locks

Return Value:

    NTSTATUS - An apprropriate return status

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;

    ULONG FsControlCode;

    PCCB Ccb;
    NAMED_PIPE_END NamedPipeEnd;

    PAGED_CODE();

    //
    //  Get the current stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "NpListen...\n", 0);

    FsControlCode = IrpSp->Parameters.FileSystemControl.FsControlCode;

    //
    //  Decode the file object to figure out who we are.  If the result
    //  is not a ccb then the pipe has been disconnected.
    //

    if (NpDecodeFileObject( IrpSp->FileObject,
                            NULL,
                            &Ccb,
                            &NamedPipeEnd ) != NPFS_NTC_CCB) {

        DebugTrace(0, Dbg, "Pipe is disconnected from us\n", 0);

        DebugTrace(-1, Dbg, "NpListen -> STATUS_ILLEGAL_FUNCTION\n", 0 );
        return STATUS_ILLEGAL_FUNCTION;
    }

    //
    //  Make sure that this is only the server that is doing this
    //  action.
    //

    if (NamedPipeEnd != FILE_PIPE_SERVER_END) {

        DebugTrace(0, Dbg, "Not the server end\n", 0);

        DebugTrace(-1, Dbg, "NpListen -> STATUS_ILLEGAL_FUNCTION\n", 0 );
        return STATUS_ILLEGAL_FUNCTION;
    }

    NpAcquireExclusiveCcb(Ccb);

    //
    //  Now call the state support routine to set the ccb to
    //  a listening state.  This routine will complete the Irp
    //  for us.
    //

    Status = NpSetListeningPipeState( Ccb, Irp, DeferredList );

    NpReleaseCcb(Ccb);

    DebugTrace(-1, Dbg, "NpListen -> %08lx\n", Status);
    return Status;
}


//
//  Local Support Routine
//

NTSTATUS
NpPeek (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp,
    IN PLIST_ENTRY DeferredList
    )

/*++

Routine Description:

    This routine does the peek control function

Arguments:

    NpfsDeviceObject - Supplies our device object

    Irp - Supplies the being processed

    DeferredList - List of IRPS to be completed after we drop the locks

Return Value:

    NTSTATUS - An apprropriate return status

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;

    ULONG OutputBufferLength;
    ULONG FsControlCode;

    NODE_TYPE_CODE NodeTypeCode;
    PCCB Ccb;
    PNONPAGED_CCB NonpagedCcb;
    NAMED_PIPE_END NamedPipeEnd;

    PFILE_PIPE_PEEK_BUFFER PeekBuffer;

    PDATA_QUEUE ReadQueue;
    READ_MODE ReadMode;

    ULONG LengthWritten;

    PUCHAR ReadBuffer;
    ULONG ReadLength;
    ULONG ReadRemaining;
    PDATA_ENTRY DataEntry;

    PAGED_CODE();

    //
    //  Get the current Irp stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "NpPeek...\n", 0);

    //
    //  Extract the important fields from the IrpSp
    //

    OutputBufferLength = IrpSp->Parameters.FileSystemControl.OutputBufferLength;
    FsControlCode      = IrpSp->Parameters.FileSystemControl.FsControlCode;

    DebugTrace( 0, Dbg, "OutputBufferLength = %08lx\n", OutputBufferLength);
    DebugTrace( 0, Dbg, "FsControlCode      = %08lx\n", FsControlCode);

    //
    //  Decode the file object to figure out who we are.  The results
    //  have a disconnected pipe if we get back an undefined ntc
    //

    if ((NodeTypeCode = NpDecodeFileObject( IrpSp->FileObject,
                                            NULL,
                                            &Ccb,
                                            &NamedPipeEnd )) == NTC_UNDEFINED) {

        DebugTrace(0, Dbg, "FileObject has been disconnected\n", 0);

        DebugTrace(-1, Dbg, "NpPeek -> STATUS_PIPE_DISCONNECTED\n", 0 );
        return STATUS_PIPE_DISCONNECTED;
    }

    //
    //  Now make sure the node type code is for a ccb otherwise it is an
    //  invalid parameter
    //

    if (NodeTypeCode != NPFS_NTC_CCB) {

        DebugTrace(0, Dbg, "FileObject is not for a ccb\n", 0);

        DebugTrace(-1, Dbg, "NpPeek -> STATUS_INVALID_PARAMETER\n", 0 );
        return STATUS_INVALID_PARAMETER;
    }

    NonpagedCcb = Ccb->NonpagedCcb;

    //
    //  Reference the system buffer as a peek buffer and make sure it's
    //  large enough
    //

    if (OutputBufferLength < (ULONG)FIELD_OFFSET(FILE_PIPE_PEEK_BUFFER, Data[0])) {

        DebugTrace(0, Dbg, "Output buffer is too small\n", 0);

        DebugTrace(-1, Dbg, "NpPeek -> STATUS_INVALID_PARAMETER\n", 0 );
        return STATUS_INVALID_PARAMETER;
    }

    PeekBuffer = Irp->AssociatedIrp.SystemBuffer;

    //
    //  Now the data queue that we read from is based on the named pipe
    //  end.  The server reads from the inbound queue and the client reads
    //  from the outbound queue
    //

    switch (NamedPipeEnd) {

    case FILE_PIPE_SERVER_END:

        ReadQueue = &Ccb->DataQueue[ FILE_PIPE_INBOUND ];
        //ReadMode  = Ccb->ReadMode[ FILE_PIPE_SERVER_END ];

        break;

    case FILE_PIPE_CLIENT_END:

        ReadQueue = &Ccb->DataQueue[ FILE_PIPE_OUTBOUND ];
        //ReadMode  = Ccb->ReadMode[ FILE_PIPE_CLIENT_END ];

        break;

    default:

        NpBugCheck( NamedPipeEnd, 0, 0 );
    }

    //
    //  Our read mode is really based upon the pipe type and not the set
    //  read mode for the pipe end.
    //

    if (Ccb->Fcb->Specific.Fcb.NamedPipeType == FILE_PIPE_MESSAGE_TYPE) {

        ReadMode = FILE_PIPE_MESSAGE_MODE;

    } else {

        ReadMode = FILE_PIPE_BYTE_STREAM_MODE;
    }

    DebugTrace(0, Dbg, "ReadQueue = %08lx\n", ReadQueue);
    DebugTrace(0, Dbg, "ReadMode  = %08lx\n", ReadMode);

    //
    //  If the state of the pipe is not in the connected or closing
    //  state then it is an invalid pipe state
    //

    if ((Ccb->NamedPipeState != FILE_PIPE_CONNECTED_STATE) &&
        (Ccb->NamedPipeState != FILE_PIPE_CLOSING_STATE)) {

        DebugTrace(0, Dbg, "pipe not connected or closing\n", 0);

        return STATUS_INVALID_PIPE_STATE;
    }

    //
    //  If the state of the pipe is closing and the queue does
    //  not contain any writers then we return eof
    //

    if ((Ccb->NamedPipeState == FILE_PIPE_CLOSING_STATE) &&
        (!NpIsDataQueueWriters( ReadQueue ))) {

        DebugTrace(0, Dbg, "pipe closing and is empty\n", 0);

        return STATUS_PIPE_BROKEN;
    }

    //
    //  Zero out the standard header part of the peek buffer and
    //  set the length written to the amount we've just zeroed out
    //

    RtlZeroMemory( PeekBuffer, FIELD_OFFSET(FILE_PIPE_PEEK_BUFFER, Data[0]) );
    LengthWritten = FIELD_OFFSET(FILE_PIPE_PEEK_BUFFER, Data[0]);

    //
    //  Set the named pipe state
    //

    PeekBuffer->NamedPipeState = Ccb->NamedPipeState;

    //
    //  There is only data available if the read queue contains
    //  write entries otherwise the rest of record is all zero.
    //

    if (NpIsDataQueueWriters( ReadQueue )) {

        //
        //  Now find the first real entry in the read queue.  The
        //  first entry actually better be a real one.
        //

        DataEntry = NpGetNextDataQueueEntry( ReadQueue, NULL );

        ASSERT( (DataEntry->DataEntryType == Buffered) ||
                (DataEntry->DataEntryType == Unbuffered) );

        //
        //  Indicate how many bytes are available to read
        //

        PeekBuffer->ReadDataAvailable = ReadQueue->BytesInQueue - ReadQueue->NextByteOffset;

        //
        //  The number of messages and message length is only filled
        //  in for a message mode pipe
        //

        if (ReadMode == FILE_PIPE_MESSAGE_MODE) {

            PeekBuffer->NumberOfMessages  = ReadQueue->EntriesInQueue;
            PeekBuffer->MessageLength = DataEntry->DataSize - ReadQueue->NextByteOffset;
        }

        //
        //  Now we are ready to copy over the data from the read queue
        //  into the peek buffer.  First establish how much room we
        //  have in the peek buffer and who much is remaining.
        //

        ReadBuffer = &PeekBuffer->Data[0];
        ReadLength = OutputBufferLength - FIELD_OFFSET(FILE_PIPE_PEEK_BUFFER, Data[0]);
        ReadRemaining = ReadLength;

        DebugTrace(0, Dbg, "ReadBuffer = %08lx\n", ReadBuffer);
        DebugTrace(0, Dbg, "ReadLength = %08lx\n", ReadLength);

        //
        //  Now read the data queue.
        //

        if ( ReadLength != 0 ) {
            IO_STATUS_BLOCK Iosb;

            Iosb = NpReadDataQueue( ReadQueue,
                                    TRUE,
                                    FALSE,
                                    ReadBuffer,
                                    ReadLength,
                                    ReadMode,
                                    Ccb,
                                    DeferredList );

            Status = Iosb.Status;
            LengthWritten += (ULONG)Iosb.Information;

        } else {

            if ( PeekBuffer->ReadDataAvailable == 0) {

                Status = STATUS_SUCCESS;

            } else {

                Status = STATUS_BUFFER_OVERFLOW;
            }
        }

    } else {

        Status = STATUS_SUCCESS;
    }

    //
    //  Complete the request.  The amount of information copied
    //  is stored in length written
    //

    Irp->IoStatus.Information = LengthWritten;


    DebugTrace(-1, Dbg, "NpPeek -> %08lx\n", Status);
    return Status;
}


//
//  Local Support Routine
//

NTSTATUS
NpQueryEvent (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine does the query event control function

Arguments:

    NpfsDeviceObject - Supplies our device object

    Irp - Supplies the Irp specifying the function

Return Value:

    NTSTATUS - An appropriate return status

--*/

{
    PIO_STACK_LOCATION IrpSp;

    ULONG InputBufferLength;
    ULONG OutputBufferLength;
    ULONG FsControlCode;

    PCCB Ccb;
    NAMED_PIPE_END NamedPipeEnd;

    HANDLE EventHandle;
    PFILE_PIPE_EVENT_BUFFER EventArray;
    PFILE_PIPE_EVENT_BUFFER EventBuffer;
    ULONG EventArrayMaximumCount;
    ULONG EventCount;

    PEPROCESS Process;

    PEVENT_TABLE_ENTRY Ete;
    PDATA_QUEUE ReadQueue;
    PDATA_QUEUE WriteQueue;

    PVOID RestartKey;

    PAGED_CODE();

    //
    //  Get the current stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "NpQueryEvent...\n", 0);

    InputBufferLength  = IrpSp->Parameters.FileSystemControl.InputBufferLength;
    OutputBufferLength = IrpSp->Parameters.FileSystemControl.OutputBufferLength;
    FsControlCode      = IrpSp->Parameters.FileSystemControl.FsControlCode;

    //
    //  Decode the file object to figure out who we are.  If the result
    //  is not a Vcb then its an invalid parameter
    //

    if (NpDecodeFileObject( IrpSp->FileObject,
                            NULL,
                            &Ccb,
                            &NamedPipeEnd ) != NPFS_NTC_VCB) {

        DebugTrace(0, Dbg, "FileObject is not the named pipe driver\n", 0);

        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Reference the system buffer as a handle and make sure it's large
    //  enough
    //

    if (InputBufferLength < sizeof(HANDLE)) {

        DebugTrace(0, Dbg, "Input System buffer size is too small\n", 0);

        return STATUS_INVALID_PARAMETER;
    }
    EventHandle = *(PHANDLE)Irp->AssociatedIrp.SystemBuffer;


    //
    //  Reference the system buffer as an output event buffer, and compute
    //  how many event buffer records we can put in the buffer.
    //

    EventArray = Irp->AssociatedIrp.SystemBuffer;
    EventArrayMaximumCount = OutputBufferLength / sizeof(FILE_PIPE_EVENT_BUFFER);
    EventCount = 0;

    //
    //  Get our current process pointer that we'll need for our search
    //

    Process = PsGetCurrentProcess();

    //
    //  Now enumerate the event table entries in the event table
    //

    RestartKey = NULL;
    for (Ete = NpGetNextEventTableEntry( &NpVcb->EventTable, &RestartKey);
         Ete != NULL;
         Ete = NpGetNextEventTableEntry( &NpVcb->EventTable, &RestartKey)) {

        //
        //  Check if the event table entry matches the event handle
        //  and the process
        //

        if ((Ete->EventHandle == EventHandle) &&
            (Ete->Process == Process)) {

            //
            //  Now based on the named pipe end we treat the inbound/
            //  outbound as a read/write queue.
            //

            NpAcquireExclusiveCcb(Ete->Ccb);

            switch (Ete->NamedPipeEnd) {

            case FILE_PIPE_CLIENT_END:

                ReadQueue = &Ete->Ccb->DataQueue[ FILE_PIPE_OUTBOUND ];
                WriteQueue = &Ete->Ccb->DataQueue[ FILE_PIPE_INBOUND ];

                break;

            case FILE_PIPE_SERVER_END:

                ReadQueue = &Ete->Ccb->DataQueue[ FILE_PIPE_INBOUND ];
                WriteQueue = &Ete->Ccb->DataQueue[ FILE_PIPE_OUTBOUND ];

                break;

            default:

                NpBugCheck( Ete->NamedPipeEnd, 0, 0 );
            }

            //
            //  Now if there is any data in the read queue to be read
            //  we fill in the buffer
            //

            if (NpIsDataQueueWriters(ReadQueue)) {

                //
                //  First make sure there is enough room in the
                //  EventBuffer to hold another entry
                //

                if (EventCount >= EventArrayMaximumCount) {

                    DebugTrace(0, Dbg, "The event buffer is full\n", 0);

                    NpReleaseCcb(Ete->Ccb);
                    break;
                }

                //
                //  Reference the event buffer and increment the
                //  counter
                //

                EventBuffer = &EventArray[EventCount];
                EventCount += 1;

                //
                //  Fill in the event buffer entry
                //

                EventBuffer->NamedPipeState = Ete->Ccb->NamedPipeState;
                EventBuffer->EntryType = FILE_PIPE_READ_DATA;
                EventBuffer->ByteCount = ReadQueue->BytesInQueue - ReadQueue->NextByteOffset;
                EventBuffer->KeyValue = Ete->KeyValue;
                EventBuffer->NumberRequests = ReadQueue->EntriesInQueue;
            }

            //
            //  We'll always fill in a write space buffer.  The amount
            //  will either be bytes of write space available or
            //  the quota of write space that we can use.
            //

            //
            //  First make sure there is enough room in the
            //  EventBuffer to hold another entry
            //

            if (EventCount >= EventArrayMaximumCount) {

                DebugTrace(0, Dbg, "The event buffer is full\n", 0);

                NpReleaseCcb(Ete->Ccb);
                break;
            }

            //
            //  Reference the event buffer and increment the
            //  counter
            //

            EventBuffer = &EventArray[EventCount];
            EventCount += 1;

            //
            //  Fill in the event buffer entry
            //

            EventBuffer->NamedPipeState = Ete->Ccb->NamedPipeState;
            EventBuffer->EntryType = FILE_PIPE_WRITE_SPACE;
            EventBuffer->KeyValue = Ete->KeyValue;

            //
            //  Now either we put in the write space available or
            //  we put in the quota available
            //

            if (NpIsDataQueueReaders(WriteQueue)) {

                EventBuffer->ByteCount = WriteQueue->BytesInQueue - WriteQueue->NextByteOffset;
                EventBuffer->NumberRequests = WriteQueue->EntriesInQueue;

            } else {

                EventBuffer->ByteCount = WriteQueue->Quota - WriteQueue->QuotaUsed;
                EventBuffer->NumberRequests = 0;
            }

            NpReleaseCcb(Ete->Ccb);
        }
    }

    //
    //  Set the information field to be the number of bytes of output
    //  data we've fill into the system buffer
    //

    Irp->IoStatus.Information = EventCount * sizeof(FILE_PIPE_EVENT_BUFFER);


    DebugTrace(-1, Dbg, "NpQueryEvent -> STATUS_SUCCESS\n", 0);
    return STATUS_SUCCESS;
}


//
//  Local Support Routine
//

NTSTATUS
NpTransceive (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp,
    IN PLIST_ENTRY DeferredList
    )

/*++

Routine Description:

    This routine does the transceive named pipe control function

Arguments:

    NpfsDeviceObject - Supplies our device object

    Irp - Supplies the being processed

    DeferredList - List of IRPs to complete after we drop locks

Return Value:

    NTSTATUS - An apprropriate return status

--*/

{
    static IO_STATUS_BLOCK Iosb;
    NTSTATUS Status;

    PIO_STACK_LOCATION IrpSp;
    PETHREAD UserThread;

    PUCHAR WriteBuffer;
    ULONG WriteLength;

    PUCHAR ReadBuffer;
    ULONG ReadLength;

    NODE_TYPE_CODE NodeTypeCode;
    PCCB Ccb;
    PNONPAGED_CCB NonpagedCcb;
    NAMED_PIPE_END NamedPipeEnd;

    PDATA_QUEUE ReadQueue;
    PDATA_QUEUE WriteQueue;
    PEVENT_TABLE_ENTRY Event;
    READ_MODE ReadMode;

    NAMED_PIPE_CONFIGURATION NamedPipeConfiguration;

    ULONG WriteRemaining;
    PIRP WriteIrp;

    //
    //  The following variable is used during abnormal unwind
    //

    PVOID UnwindStorage = NULL;

    PAGED_CODE();

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "NpTransceive\n", 0);
    DebugTrace( 0, Dbg, "NpfsDeviceObject = %08lx\n", NpfsDeviceObject);
    DebugTrace( 0, Dbg, "Irp              = %08lx\n", Irp);
    DebugTrace( 0, Dbg, "FileObject       = %08lx\n", IrpSp->FileObject);

    WriteLength = IrpSp->Parameters.FileSystemControl.InputBufferLength;
    WriteBuffer = IrpSp->Parameters.FileSystemControl.Type3InputBuffer;

    ReadLength = IrpSp->Parameters.FileSystemControl.OutputBufferLength;
    ReadBuffer = Irp->UserBuffer;

    //
    //  Now if the requestor mode is user mode we need to probe the buffers
    //  We do now need to have an exception handler here because our top
    //  level caller already has one that will complete the Irp with
    //  the appropriate status if we access violate.
    //

    if (Irp->RequestorMode != KernelMode) {

        try {

            ProbeForRead( WriteBuffer, WriteLength, sizeof(UCHAR) );
            ProbeForWrite( ReadBuffer, ReadLength, sizeof(UCHAR) );

        } except(EXCEPTION_EXECUTE_HANDLER) {

            return GetExceptionCode ();
        }
    }

    //
    //  Get the Ccb and figure out who we are, and make sure we're not
    //  disconnected
    //

    if ((NodeTypeCode = NpDecodeFileObject( IrpSp->FileObject,
                                            NULL,
                                            &Ccb,
                                            &NamedPipeEnd )) == NTC_UNDEFINED) {

        DebugTrace(0, Dbg, "Pipe is disconnected from us\n", 0);


        DebugTrace(-1, Dbg, "NpTransceive -> STATUS_PIPE_DISCONNECTED\n", 0 );
        return STATUS_PIPE_DISCONNECTED;
    }

    //
    //  Now we only will allow transceive operations on the pipe and not a
    //  directory or the device
    //

    if (NodeTypeCode != NPFS_NTC_CCB) {

        DebugTrace(0, Dbg, "FileObject is not for a named pipe\n", 0);

        DebugTrace(-1, Dbg, "NpTransceive -> STATUS_PIPE_DISCONNECTED\n", 0 );
        return STATUS_PIPE_DISCONNECTED;
    }

    NonpagedCcb = Ccb->NonpagedCcb;

    NpAcquireExclusiveCcb(Ccb);
    WriteIrp = NULL;

    try {

        //
        //  Check that the pipe is in the connected state
        //

        if (Ccb->NamedPipeState != FILE_PIPE_CONNECTED_STATE) {

            DebugTrace(0, Dbg, "Pipe not connected\n", 0);

            try_return( Status = STATUS_INVALID_PIPE_STATE );
        }

        //
        //  Figure out the read/write queue, read mode, and event based
        //  on the end of the named pipe doing the transceive.
        //

        switch (NamedPipeEnd) {

        case FILE_PIPE_SERVER_END:

            ReadQueue = &Ccb->DataQueue[ FILE_PIPE_INBOUND ];
            WriteQueue = &Ccb->DataQueue[ FILE_PIPE_OUTBOUND ];

            Event = NonpagedCcb->EventTableEntry[ FILE_PIPE_CLIENT_END ];
            ReadMode = Ccb->ReadCompletionMode[ FILE_PIPE_SERVER_END ].ReadMode;

            break;

        case FILE_PIPE_CLIENT_END:

            ReadQueue = &Ccb->DataQueue[ FILE_PIPE_OUTBOUND ];
            WriteQueue = &Ccb->DataQueue[ FILE_PIPE_INBOUND ];

            Event = NonpagedCcb->EventTableEntry[ FILE_PIPE_SERVER_END ];
            ReadMode = Ccb->ReadCompletionMode[ FILE_PIPE_CLIENT_END ].ReadMode;

            break;

        default:

            NpBugCheck( NamedPipeEnd, 0, 0 );
        }

        //
        //  We only allow a transceive on a message mode, full duplex pipe.
        //

        NamedPipeConfiguration = Ccb->Fcb->Specific.Fcb.NamedPipeConfiguration;

        if ((NamedPipeConfiguration != FILE_PIPE_FULL_DUPLEX) ||
            (ReadMode != FILE_PIPE_MESSAGE_MODE)) {

            DebugTrace(0, Dbg, "Bad pipe configuration or read mode\n", 0);

            try_return( Status = STATUS_INVALID_PIPE_STATE );
        }

        //
        //  Check that the read queue is empty.
        //

        if (!NpIsDataQueueEmpty( ReadQueue )) {

            DebugTrace(0, Dbg, "Read queue is not empty\n", 0);

            try_return( Status = STATUS_PIPE_BUSY );
        }

        //
        //  Do the transceive write operation.  We first try and push the data
        //  from the write buffer into any waiting readers in the write queue
        //  and if that succeeds then we can go on and do the read operation
        //  otherwise we need to make a copy of irp and to enqueue as
        //  a data entry into the write queue.
        //
        //  Now we'll call our common write data queue routine to
        //  transfer data out of our write buffer into the data queue.
        //  If the result of the call is FALSE then we still have some
        //  write data to put into the write queue.
        //

        UserThread = Irp->Tail.Overlay.Thread;
        Status = NpWriteDataQueue( WriteQueue,
                                   ReadMode,
                                   WriteBuffer,
                                   WriteLength,
                                   Ccb->Fcb->Specific.Fcb.NamedPipeType,
                                   &WriteRemaining,
                                   Ccb,
                                   NamedPipeEnd,
                                   UserThread,
                                   DeferredList );

        if (Status == STATUS_MORE_PROCESSING_REQUIRED)  {

            PIO_STACK_LOCATION WriteIrpSp;

            ASSERT( !NpIsDataQueueReaders( WriteQueue ));

            DebugTrace(0, Dbg, "Add write to data queue\n", 0);

            //
            //  We need to do some more write processing.  So to handle
            //  this case we'll allocate a new irp and set its system
            //  buffer to be the remaining part of the write buffer
            //

            if ((WriteIrp = IoAllocateIrp( NpfsDeviceObject->DeviceObject.StackSize, TRUE )) == NULL) {

                try_return (Status = STATUS_INSUFFICIENT_RESOURCES);
            }

            IoSetCompletionRoutine( WriteIrp, NpCompleteTransceiveIrp, NULL, TRUE, TRUE, TRUE );

            WriteIrpSp = IoGetNextIrpStackLocation( WriteIrp );

            if (WriteRemaining > 0) {

                WriteIrp->AssociatedIrp.SystemBuffer = NpAllocatePagedPoolWithQuota( WriteRemaining, 'wFpN' );
                if (WriteIrp->AssociatedIrp.SystemBuffer == NULL) {
                    IoFreeIrp (WriteIrp);
                    try_return (Status = STATUS_INSUFFICIENT_RESOURCES);
                }

                //
                //  Safely do the copy
                //

                try {

                    RtlCopyMemory( WriteIrp->AssociatedIrp.SystemBuffer,
                                   &WriteBuffer[ WriteLength - WriteRemaining ],
                                   WriteRemaining );

                } except(EXCEPTION_EXECUTE_HANDLER) {
                    NpFreePool (WriteIrp->AssociatedIrp.SystemBuffer);
                    IoFreeIrp (WriteIrp);
                    try_return (Status = GetExceptionCode ());
                }

            } else {

                WriteIrp->AssociatedIrp.SystemBuffer = NULL;
            }

            //
            //  Set the current stack location, and set in the amount we are
            //  try to write.
            //

            WriteIrp->CurrentLocation -= 1;
            WriteIrp->Tail.Overlay.CurrentStackLocation = WriteIrpSp;
            WriteIrp->Tail.Overlay.Thread = UserThread;
            WriteIrp->IoStatus.Information = WriteRemaining;

            WriteIrpSp->Parameters.Write.Length = WriteRemaining;
            WriteIrpSp->MajorFunction = IRP_MJ_WRITE;

            //
            //  Set it up to do buffered I/O and deallocate the buffer
            //  on completion.

            if (WriteRemaining > 0) {

                WriteIrp->Flags = IRP_BUFFERED_IO | IRP_DEALLOCATE_BUFFER;
            }

            WriteIrp->UserIosb = &Iosb;

            //
            //  Add this write request to the write queue
            //

            Status = NpAddDataQueueEntry( NamedPipeEnd,
                                          Ccb,
                                          WriteQueue,
                                          WriteEntries,
                                          Unbuffered,
                                          WriteRemaining,
                                          WriteIrp,
                                          NULL,
                                          0);

            if (Status != STATUS_PENDING) {
                NpDeferredCompleteRequest (WriteIrp, Status, DeferredList);
            }

        }

        if (!NT_SUCCESS (Status)) {
            try_return (NOTHING);
        }

        //
        //  And because we've done something we need to signal the
        //  other ends event
        //

        NpSignalEventTableEntry( Event );

        //
        //  Do the transceive read operation.  This is just like a
        //  buffered read.
        //
        //  Now we know that the read queue is empty so we'll enqueue this
        //  Irp to the read queue and return status pending, also mark the
        //  irp pending
        //

        ASSERT( NpIsDataQueueEmpty( ReadQueue ));

        Status = NpAddDataQueueEntry( NamedPipeEnd,
                                      Ccb,
                                      ReadQueue,
                                      ReadEntries,
                                      Buffered,
                                      ReadLength,
                                      Irp,
                                      NULL,
                                      0 );
        if (!NT_SUCCESS (Status)) {
            try_return (NOTHING);
        }

        //
        //  And because we've done something we need to signal the
        //  other ends event
        //

        NpSignalEventTableEntry( Event );

    try_exit: NOTHING;
    } finally {
        NpReleaseCcb(Ccb);
    }

    DebugTrace(-1, Dbg, "NpTransceive -> %08lx\n", Status);
    return Status;
}


//
//  Local Support Routine
//

NTSTATUS
NpWaitForNamedPipe (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine does the wait for named pipe control function

Arguments:

    NpfsDeviceObject - Supplies our device object

    Irp - Supplies the being processed

Return Value:

    NTSTATUS - An apprropriate return status

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;

    ULONG InputBufferLength;
    ULONG FsControlCode;

    PFCB Fcb;
    PCCB Ccb;

    PFILE_PIPE_WAIT_FOR_BUFFER WaitBuffer;
    UNICODE_STRING Name;
    PVOID LocalBuffer;

    PLIST_ENTRY Links;

    BOOLEAN CaseInsensitive = TRUE; //**** Make all searches case insensitive
    UNICODE_STRING RemainingPart;
    BOOLEAN Translated;

    PAGED_CODE();

    //
    //  Get the current stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "NpWaitForNamedPipe...\n", 0);

    //
    //  Extract the important fields from the IrpSp
    //

    InputBufferLength = IrpSp->Parameters.FileSystemControl.InputBufferLength;
    FsControlCode     = IrpSp->Parameters.FileSystemControl.FsControlCode;

    Name.Buffer = NULL;
    LocalBuffer = NULL;

    try {

        //
        //  Decode the file object to figure out who we are.  If the result
        //  is an error if the we weren't given a Vcb.
        //

        {
            PCCB Ccb;
            NAMED_PIPE_END NamedPipeEnd;

            if (NpDecodeFileObject( IrpSp->FileObject,
                                    NULL,
                                    &Ccb,
                                    &NamedPipeEnd ) != NPFS_NTC_ROOT_DCB) {

                DebugTrace(0, Dbg, "File Object is not for the named pipe root directory\n", 0);

                try_return( Status = STATUS_ILLEGAL_FUNCTION );
            }
        }

        //
        //  Reference the system buffer as a wait for buffer and make
        //  sure it's large enough
        //

        if (InputBufferLength < sizeof(FILE_PIPE_WAIT_FOR_BUFFER)) {

            DebugTrace(0, Dbg, "System buffer size is too small\n", 0);

            try_return( Status = STATUS_INVALID_PARAMETER );
        }

        WaitBuffer = Irp->AssociatedIrp.SystemBuffer;

        //
        //  Check for an invalid buffer.  The Name Length cannot be greater than
        //  MAXUSHORT minus the backslash otherwise it will overflow the buffer.
        //  We don't need to check for less than 0 because it is unsigned.
        //

        if ((WaitBuffer->NameLength > (MAXUSHORT - 2)) ||
            (FIELD_OFFSET(FILE_PIPE_WAIT_FOR_BUFFER, Name[0]) + WaitBuffer->NameLength > InputBufferLength)) {

            DebugTrace(0, Dbg, "System buffer size or name length is too small\n", 0);

            try_return( Status = STATUS_INVALID_PARAMETER );
        }

        //
        //  Set up the local variable Name to be the name we're looking
        //  for
        //

        Name.Length = (USHORT)(WaitBuffer->NameLength + 2);
        Name.Buffer = LocalBuffer = NpAllocatePagedPool( Name.Length, 'WFpN' );
        if (LocalBuffer == NULL) {
            try_return( Status = STATUS_INSUFFICIENT_RESOURCES );
        }

        Name.Buffer[0] = L'\\';

        RtlCopyMemory( &Name.Buffer[1],
                       &WaitBuffer->Name[0],
                       WaitBuffer->NameLength );

        //
        //  If the name is an alias, translate it
        //

        Status = NpTranslateAlias( &Name );

        if ( !NT_SUCCESS(Status) ) {

            try_return( NOTHING );
        }

        //
        //  Now check to see if we can find a named pipe with the right
        //  name
        //

        Fcb = NpFindPrefix( &Name, CaseInsensitive, &RemainingPart );

        //
        //  If the Fcb is null then we can't wait for it,  Also if the
        //  Fcb is not an Fcb then we also have nothing to wait for
        //

        if (NodeType(Fcb) != NPFS_NTC_FCB) {

            DebugTrace(0, Dbg, "Bad nonexistent named pipe name", 0);

            try_return( Status = STATUS_OBJECT_NAME_NOT_FOUND );
        }

        //
        //  If translated then Name.Buffer would point to the translated buffer
        //

        Translated = (Name.Buffer != LocalBuffer);

        //
        //  Now we need to search to see if we find a ccb already in the
        //  listening state
        //  First try and find a ccb that is in the listening state
        //  If we exit the loop with ccb null then we haven't found
        //  one
        //

        Ccb = NULL;
        for (Links = Fcb->Specific.Fcb.CcbQueue.Flink;
             Links != &Fcb->Specific.Fcb.CcbQueue;
             Links = Links->Flink) {

            Ccb = CONTAINING_RECORD( Links, CCB, CcbLinks );

            if (Ccb->NamedPipeState == FILE_PIPE_LISTENING_STATE) {

                break;
            }

            Ccb = NULL;
        }

        //
        //  Check if we found one
        //

        if (Ccb != NULL) {

            DebugTrace(0, Dbg, "Found a ccb in listening state\n", 0);

            try_return( Status = STATUS_SUCCESS );
        }

        //
        //  We weren't able to find one so we need to add a new waiter
        //

        Status = NpAddWaiter( &NpVcb->WaitQueue,
                              Fcb->Specific.Fcb.DefaultTimeOut,
                              Irp,
                              Translated ? &Name : NULL);



    try_exit: NOTHING;
    } finally {

        if (LocalBuffer != NULL) {
            NpFreePool( LocalBuffer );
        }
    }

    DebugTrace(-1, Dbg, "NpWaitForNamedPipe -> %08lx\n", Status);
    return Status;
}


//
//  Local Support Routine
//

NTSTATUS
NpImpersonate (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine does the impersonate of the named pipe

Arguments:

    NpfsDeviceObject - Supplies our device object

    Irp - Supplies the being processed

Return Value:

    NTSTATUS - An apprropriate return status

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;

    PCCB Ccb;
    NAMED_PIPE_END NamedPipeEnd;

    UNREFERENCED_PARAMETER( NpfsDeviceObject );

    PAGED_CODE();

    //
    //  Get the current stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "NpImpersonate...\n", 0);

    //
    //  Decode the file object to figure out who we are.  If the result
    //  is an error if the we weren't given a Vcb.
    //

    if (NpDecodeFileObject( IrpSp->FileObject,
                            NULL,
                            &Ccb,
                            &NamedPipeEnd ) != NPFS_NTC_CCB) {

        DebugTrace(0, Dbg, "File Object is not a named pipe\n", 0);

        DebugTrace(-1, Dbg, "NpImpersonate -> STATUS_ILLEGAL_FUNCTION\n", 0 );
        return STATUS_ILLEGAL_FUNCTION;
    }

    //
    //  Make sure that we are the server end and not the client end
    //

    if (NamedPipeEnd != FILE_PIPE_SERVER_END) {

        DebugTrace(0, Dbg, "Not the server end\n", 0);

        DebugTrace(-1, Dbg, "NpImpersonate -> STATUS_ILLEGAL_FUNCTION\n", 0 );
        return STATUS_ILLEGAL_FUNCTION;
    }

    //
    //  set up the impersonation
    //

    Status = NpImpersonateClientContext( Ccb );

    DebugTrace(-1, Dbg, "NpImpersonate -> %08lx\n", Status);
    return Status;
}


//
//  Local Support Routine
//

NTSTATUS
NpInternalRead (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp,
    IN BOOLEAN ReadOverflowOperation,
    IN PLIST_ENTRY DeferredList
    )

/*++

Routine Description:

    This routine does the unbuffered read named pipe control function

Arguments:

    NpfsDeviceObject - Supplies our device object

    Irp - Supplies the being processed

    ReadOverflowOperation - Used to indicate if the read being processed is a read overflow
        operation.

    DeferredList - List of IRP's to be completed later after we drop the locks

Return Value:

    NTSTATUS - An apprropriate return status

--*/

{
    NTSTATUS Status;

    PIO_STACK_LOCATION IrpSp;

    NODE_TYPE_CODE NodeTypeCode;
    PCCB Ccb;
    PNONPAGED_CCB NonpagedCcb;
    NAMED_PIPE_END NamedPipeEnd;

    NAMED_PIPE_CONFIGURATION NamedPipeConfiguration;

    PIRP ReadIrp;
    PUCHAR ReadBuffer;
    ULONG ReadLength;
    ULONG ReadRemaining;
    READ_MODE ReadMode;
    COMPLETION_MODE CompletionMode;
    PDATA_QUEUE ReadQueue;
    PEVENT_TABLE_ENTRY Event;

    PAGED_CODE();

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "NpInternalRead\n", 0);
    DebugTrace( 0, Dbg, "NpfsDeviceObject = %08lx\n", NpfsDeviceObject);
    DebugTrace( 0, Dbg, "Irp              = %08lx\n", Irp);
    DebugTrace( 0, Dbg, "FileObject       = %08lx\n", IrpSp->FileObject);

    //
    //  Get the Ccb and figure out who we are, and make sure we're not
    //  disconnected
    //

    if ((NodeTypeCode = NpDecodeFileObject( IrpSp->FileObject,
                                            NULL,
                                            &Ccb,
                                            &NamedPipeEnd )) == NTC_UNDEFINED) {

        DebugTrace(0, Dbg, "Pipe is disconnected from us\n", 0);

        DebugTrace(-1, Dbg, "NpInternalRead -> STATUS_PIPE_DISCONNECTED\n", 0 );
        return STATUS_PIPE_DISCONNECTED;
    }

    //
    //  Now we only will allow Read operations on the pipe and not a directory
    //  or the device
    //

    if (NodeTypeCode != NPFS_NTC_CCB) {

        DebugTrace(0, Dbg, "FileObject is not for a named pipe\n", 0);

        DebugTrace(-1, Dbg, "NpInternalRead -> STATUS_INVALID_PARAMETER\n", 0 );
        return STATUS_INVALID_PARAMETER;
    }

    NonpagedCcb = Ccb->NonpagedCcb;

    NpAcquireExclusiveCcb(Ccb);


    //
    //  Check if the pipe is not in the connected state.
    //

    switch (Ccb->NamedPipeState) {

    case FILE_PIPE_DISCONNECTED_STATE:

        DebugTrace(0, Dbg, "Pipe in disconnected state\n", 0);

        NpReleaseCcb(Ccb);

        DebugTrace(-1, Dbg, "NpInternalRead -> STATUS_PIPE_DISCONNECTED\n", 0 );
        return STATUS_PIPE_DISCONNECTED;

    case FILE_PIPE_LISTENING_STATE:

        DebugTrace(0, Dbg, "Pipe in listening state\n", 0);

        NpReleaseCcb(Ccb);

        DebugTrace(-1, Dbg, "NpInternalRead -> STATUS_PIPE_LISTENING\n", 0 );
        return STATUS_PIPE_LISTENING;

    case FILE_PIPE_CONNECTED_STATE:
    case FILE_PIPE_CLOSING_STATE:

        break;

    default:

        DebugTrace(0, Dbg, "Illegal pipe state = %08lx\n", Ccb->NamedPipeState);
        NpBugCheck( Ccb->NamedPipeState, 0, 0 );
    }

    //
    //  We only allow a read by the server on a non outbound only pipe
    //  and by the client on a non inbound only pipe
    //

    NamedPipeConfiguration = Ccb->Fcb->Specific.Fcb.NamedPipeConfiguration;

    if (((NamedPipeEnd == FILE_PIPE_SERVER_END) &&
         (NamedPipeConfiguration == FILE_PIPE_OUTBOUND))

            ||

        ((NamedPipeEnd == FILE_PIPE_CLIENT_END) &&
         (NamedPipeConfiguration == FILE_PIPE_INBOUND))) {

        DebugTrace(0, Dbg, "Trying to read to the wrong pipe configuration\n", 0);

        NpReleaseCcb(Ccb);

        DebugTrace(-1, Dbg, "NpInternalRead -> STATUS_INVALID_PARAMETER\n", 0 );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Reference our input parameters to make things easier, and
    //  initialize our main variables that describe the Read command
    //

    ReadIrp        = Irp;
    ReadBuffer     = Irp->AssociatedIrp.SystemBuffer;
    ReadLength     = IrpSp->Parameters.FileSystemControl.OutputBufferLength;
    ReadRemaining  = ReadLength;
    ReadMode       = Ccb->ReadCompletionMode[ NamedPipeEnd ].ReadMode;
    CompletionMode = Ccb->ReadCompletionMode[ NamedPipeEnd ].CompletionMode;

    if (ReadOverflowOperation == TRUE && ReadMode != FILE_PIPE_MESSAGE_MODE) {
        NpReleaseCcb(Ccb);
        return STATUS_INVALID_READ_MODE;
    }


    //
    //  Now the data queue that we read from into and the event that we signal
    //  are based on the named pipe end.  The server read from the inbound
    //  queue and signals the client event.  The client does just the
    //  opposite.
    //

    switch (NamedPipeEnd) {

    case FILE_PIPE_SERVER_END:

        ReadQueue = &Ccb->DataQueue[ FILE_PIPE_INBOUND ];

        Event = NonpagedCcb->EventTableEntry[ FILE_PIPE_CLIENT_END ];

        break;

    case FILE_PIPE_CLIENT_END:

        ReadQueue = &Ccb->DataQueue[ FILE_PIPE_OUTBOUND ];

        Event = NonpagedCcb->EventTableEntry[ FILE_PIPE_SERVER_END ];

        break;

    default:

        NpBugCheck( NamedPipeEnd, 0, 0 );
    }

    DebugTrace(0, Dbg, "ReadBuffer     = %08lx\n", ReadBuffer);
    DebugTrace(0, Dbg, "ReadLength     = %08lx\n", ReadLength);
    DebugTrace(0, Dbg, "ReadMode       = %08lx\n", ReadMode);
    DebugTrace(0, Dbg, "CompletionMode = %08lx\n", CompletionMode);
    DebugTrace(0, Dbg, "ReadQueue      = %08lx\n", ReadQueue);
    DebugTrace(0, Dbg, "Event          = %08lx\n", Event);

    //
    //  if the read queue does not contain any write entries
    //  then we either need to enqueue this operation or
    //  fail immediately
    //

    if (!NpIsDataQueueWriters( ReadQueue )) {

        //
        //  Check if the other end of the pipe is closing, and if
        //  so then we complete it with end of file.
        //  Otherwise check to see if we should enqueue the irp
        //  or complete the operation and tell the user the pipe is empty.
        //

        if (Ccb->NamedPipeState == FILE_PIPE_CLOSING_STATE) {

            DebugTrace(0, Dbg, "Complete the irp with eof\n", 0);

            Status = STATUS_PIPE_BROKEN;

        } else if (CompletionMode == FILE_PIPE_QUEUE_OPERATION) {

            DebugTrace(0, Dbg, "Put the irp into the read queue\n", 0);

            Status = NpAddDataQueueEntry( NamedPipeEnd,
                                          Ccb,
                                          ReadQueue,
                                          ReadEntries,
                                          Unbuffered,
                                          ReadLength,
                                          ReadIrp,
                                          NULL,
                                          0 );

        } else {

            DebugTrace(0, Dbg, "Complete the irp with pipe empty\n", 0);

            Status = STATUS_PIPE_EMPTY;
        }

    } else {

        //
        //  otherwise there we have a read irp against a read queue
        //  that contains one or more write entries.
        //

        ReadIrp->IoStatus = NpReadDataQueue( ReadQueue,
                                             FALSE,
                                             ReadOverflowOperation,
                                             ReadBuffer,
                                             ReadLength,
                                             ReadMode,
                                             Ccb,
                                             DeferredList );

        Status = ReadIrp->IoStatus.Status;

        //
        //  Now set the remaining byte count in the allocation size of
        //  the Irp.
        //

        ReadIrp->Overlay.AllocationSize.QuadPart = ReadQueue->BytesInQueue - ReadQueue->NextByteOffset;

        //
        //  Finish up the read irp.
        //
    }

    //
    //  And because we've done something we need to signal the
    //  other ends event
    //

    NpSignalEventTableEntry( Event );

    NpReleaseCcb(Ccb);

    DebugTrace(-1, Dbg, "NpInternalRead -> %08lx\n", Status);
    return Status;
}


//
//  Local Support Routine
//

NTSTATUS
NpInternalWrite (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp,
    IN PLIST_ENTRY DeferredList
    )

/*++

Routine Description:

    This routine does the unbuffered write named pipe control function

Arguments:

    NpfsDeviceObject - Supplies our device object

    Irp - Supplies the being processed

Return Value:

    NTSTATUS - An apprropriate return status

--*/

{
    NTSTATUS Status;

    PIO_STACK_LOCATION IrpSp;
    PETHREAD UserThread;

    NODE_TYPE_CODE NodeTypeCode;
    PCCB Ccb;
    PNONPAGED_CCB NonpagedCcb;
    NAMED_PIPE_END NamedPipeEnd;

    NAMED_PIPE_CONFIGURATION NamedPipeConfiguration;

    PIRP WriteIrp;
    PUCHAR WriteBuffer;
    ULONG WriteLength;
    ULONG WriteRemaining;
    PDATA_QUEUE WriteQueue;

    PEVENT_TABLE_ENTRY Event;
    READ_MODE ReadMode;

    PAGED_CODE();

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "NpInternalWrite\n", 0);
    DebugTrace( 0, Dbg, "NpfsDeviceObject = %08lx\n", NpfsDeviceObject);
    DebugTrace( 0, Dbg, "Irp              = %08lx\n", Irp);
    DebugTrace( 0, Dbg, "FileObject       = %08lx\n", IrpSp->FileObject);

    //
    // This is a FSCTL path being used as a write. Make sure we can set the .Information field to the number
    // of bytes written.
    //
    NpConvertFsctlToWrite (Irp);

    //
    //  Get the Ccb and figure out who we are, and make sure we're not
    //  disconnected
    //

    if ((NodeTypeCode = NpDecodeFileObject( IrpSp->FileObject,
                                            NULL,
                                            &Ccb,
                                            &NamedPipeEnd )) == NTC_UNDEFINED) {

        DebugTrace(0, Dbg, "Pipe is disconnected from us\n", 0);

        DebugTrace(-1, Dbg, "NpInternalWrite -> STATUS_PIPE_DISCONNECTED\n", 0 );
        return STATUS_PIPE_DISCONNECTED;
    }

    //
    //  Now we only will allow write operations on the pipe and not a directory
    //  or the device
    //

    if (NodeTypeCode != NPFS_NTC_CCB) {

        DebugTrace(0, Dbg, "FileObject is not for a named pipe\n", 0);

        DebugTrace(-1, Dbg, "NpInternalWrite -> STATUS_PIPE_DISCONNECTED\n", 0);
        return STATUS_PIPE_DISCONNECTED;
    }

    NonpagedCcb = Ccb->NonpagedCcb;

    NpAcquireExclusiveCcb(Ccb);

    //
    //  We only allow a write by the server on a non inbound only pipe
    //  and by the client on a non outbound only pipe
    //

    NamedPipeConfiguration = Ccb->Fcb->Specific.Fcb.NamedPipeConfiguration;

    if (((NamedPipeEnd == FILE_PIPE_SERVER_END) &&
         (NamedPipeConfiguration == FILE_PIPE_INBOUND))

            ||

        ((NamedPipeEnd == FILE_PIPE_CLIENT_END) &&
         (NamedPipeConfiguration == FILE_PIPE_OUTBOUND))) {

        DebugTrace(0, Dbg, "Trying to write to the wrong pipe configuration\n", 0);

        NpReleaseCcb(Ccb);

        DebugTrace(-1, Dbg, "NpInternalWrite -> STATUS_PIPE_DISCONNECTED\n", 0);
        return STATUS_PIPE_DISCONNECTED;
    }

    //
    //  Reference our input parameters to make things easier, and
    //  initialize our main variables that describe the write command
    //

    WriteIrp = Irp;
    WriteBuffer = Irp->AssociatedIrp.SystemBuffer;
    WriteLength = IrpSp->Parameters.FileSystemControl.InputBufferLength;

    //
    //  Set up the amount of data we will have written by the time this
    //  irp gets completed
    //

    WriteIrp->IoStatus.Information = WriteLength;

    //
    //  Now the data queue that we write into and the event that we signal
    //  are based on the named pipe end.  The server writes to the outbound
    //  queue and signals the client event.  The client does just the
    //  opposite.  We also need to figure out the read mode for the opposite
    //  end of the pipe.
    //

    switch (NamedPipeEnd) {

    case FILE_PIPE_SERVER_END:

        WriteQueue = &Ccb->DataQueue[ FILE_PIPE_OUTBOUND ];

        Event = NonpagedCcb->EventTableEntry[ FILE_PIPE_CLIENT_END ];
        ReadMode = Ccb->ReadCompletionMode[ FILE_PIPE_CLIENT_END ].ReadMode;

        break;

    case FILE_PIPE_CLIENT_END:

        WriteQueue = &Ccb->DataQueue[ FILE_PIPE_INBOUND ];

        Event = NonpagedCcb->EventTableEntry[ FILE_PIPE_SERVER_END ];
        ReadMode = Ccb->ReadCompletionMode[ FILE_PIPE_SERVER_END ].ReadMode;

        break;

    default:

        NpBugCheck( NamedPipeEnd, 0, 0 );
    }

    //
    //  Check if the pipe is not in the connected state.
    //

    switch (Ccb->NamedPipeState) {

    case FILE_PIPE_DISCONNECTED_STATE:

        DebugTrace(0, Dbg, "Pipe in disconnected state\n", 0);

        NpReleaseCcb(Ccb);
        return STATUS_PIPE_DISCONNECTED;

    case FILE_PIPE_LISTENING_STATE:

        DebugTrace(0, Dbg, "Pipe in listening state\n", 0);

        NpReleaseCcb(Ccb);
        return STATUS_PIPE_LISTENING;

    case FILE_PIPE_CONNECTED_STATE:

        break;

    case FILE_PIPE_CLOSING_STATE:

        DebugTrace(0, Dbg, "Pipe in closing state\n", 0);

        NpReleaseCcb(Ccb);
        return STATUS_PIPE_CLOSING;

    default:

        DebugTrace(0, Dbg, "Illegal pipe state = %08lx\n", Ccb->NamedPipeState);
        NpBugCheck( Ccb->NamedPipeState, 0, 0 );
    }

    //
    //  Check if this is a message type pipe and the operation type is complete
    //  operation,  If so then we also check that the queued reads is enough to
    //  complete the message otherwise we need to abort the write irp immediately.
    //

    if ((Ccb->Fcb->Specific.Fcb.NamedPipeType == FILE_PIPE_MESSAGE_TYPE) &&
        (Ccb->ReadCompletionMode[NamedPipeEnd].CompletionMode == FILE_PIPE_COMPLETE_OPERATION)) {

        //
        //  If the pipe contains readers and amount to read is less than the write
        //  length then we cannot do it the write.
        //  Or if pipe does not contain reads then we also cannot do the write.
        //

        if ((NpIsDataQueueReaders( WriteQueue ) &&
            (WriteQueue->BytesInQueue < WriteLength))

                ||

            (!NpIsDataQueueReaders( WriteQueue ))) {

            DebugTrace(0, Dbg, "Cannot complete the message without blocking\n", 0);

            NpReleaseCcb(Ccb);
            Irp->IoStatus.Information = 0;
            return STATUS_SUCCESS;
        }
    }

    //
    //  Now we'll call our common write data queue routine to
    //  transfer data out of our write buffer into the data queue.
    //  If the result of the call is FALSE then we still have some
    //  write data to put into the write queue.
    //

    UserThread = Irp->Tail.Overlay.Thread;
    Status = NpWriteDataQueue( WriteQueue,
                               ReadMode,
                               WriteBuffer,
                               WriteLength,
                               Ccb->Fcb->Specific.Fcb.NamedPipeType,
                               &WriteRemaining,
                               Ccb,
                               NamedPipeEnd,
                               UserThread,
                               DeferredList );

    if (Status == STATUS_MORE_PROCESSING_REQUIRED)  {

        ASSERT( !NpIsDataQueueReaders( WriteQueue ));

        //
        //  Check if the operation is not to block and if so then we
        //  will complete the operation now with what we're written, if what is
        //  left will not fit in the quota for the file
        //

        if (Ccb->ReadCompletionMode[NamedPipeEnd].CompletionMode == FILE_PIPE_COMPLETE_OPERATION) {

            DebugTrace(0, Dbg, "Complete the byte stream write immediately\n", 0);

            Irp->IoStatus.Information = WriteLength - WriteRemaining;

            Status = STATUS_SUCCESS;

        } else {

            DebugTrace(0, Dbg, "Add write to data queue\n", 0);

            //
            //  Add this write request to the write queue
            //

            Status = NpAddDataQueueEntry( NamedPipeEnd,
                                          Ccb,
                                          WriteQueue,
                                          WriteEntries,
                                          Unbuffered,
                                          WriteLength,
                                          Irp,
                                          NULL,
                                          WriteLength - WriteRemaining);

        }

    } else {

        DebugTrace(0, Dbg, "Complete the Write Irp\n", 0);


        //
        //  The write irp is finished so we can complete it now
        //

    }

    //
    //  And because we've done something we need to signal the
    //  other ends event
    //

    NpSignalEventTableEntry( Event );

    NpReleaseCcb(Ccb);

    DebugTrace(-1, Dbg, "NpInternalWrite -> %08lx\n", Status);
    return Status;
}


//
//  Local Support Routine
//

NTSTATUS
NpInternalTransceive (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp,
    IN PLIST_ENTRY DeferredList
    )

/*++

Routine Description:

    This routine does the internal (i.e., unbuffered) transceive named pipe
    control function

Arguments:

    NpfsDeviceObject - Supplies our device object

    Irp - Supplies the being processed

    DeferredList - List of IRP's to be completed once we drop our locks.

Return Value:

    NTSTATUS - An apprropriate return status

--*/

{
    static IO_STATUS_BLOCK Iosb;
    NTSTATUS Status;

    PIO_STACK_LOCATION IrpSp;
    PETHREAD UserThread;

    PUCHAR WriteBuffer;
    ULONG WriteLength;

    PUCHAR ReadBuffer;
    ULONG ReadLength;

    NODE_TYPE_CODE NodeTypeCode;
    PCCB Ccb;
    PNONPAGED_CCB NonpagedCcb;
    NAMED_PIPE_END NamedPipeEnd;

    PDATA_QUEUE ReadQueue;
    PDATA_QUEUE WriteQueue;
    PEVENT_TABLE_ENTRY Event;
    READ_MODE ReadMode;

    NAMED_PIPE_CONFIGURATION NamedPipeConfiguration;

    ULONG WriteRemaining;

    PIRP WriteIrp;

    //
    //  The following variable is used for abnormal unwind
    //

    PVOID UnwindStorage = NULL;

    PAGED_CODE();

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "NpInternalTransceive\n", 0);
    DebugTrace( 0, Dbg, "NpfsDeviceObject = %08lx\n", NpfsDeviceObject);
    DebugTrace( 0, Dbg, "Irp              = %08lx\n", Irp);
    DebugTrace( 0, Dbg, "FileObject       = %08lx\n", IrpSp->FileObject);

    WriteLength = IrpSp->Parameters.FileSystemControl.InputBufferLength;
    WriteBuffer = IrpSp->Parameters.FileSystemControl.Type3InputBuffer;

    ReadLength = IrpSp->Parameters.FileSystemControl.OutputBufferLength;
    ReadBuffer = Irp->AssociatedIrp.SystemBuffer;

    //
    //  Get the Ccb and figure out who we are, and make sure we're not
    //  disconnected
    //

    if ((NodeTypeCode = NpDecodeFileObject( IrpSp->FileObject,
                                            NULL,
                                            &Ccb,
                                            &NamedPipeEnd )) == NTC_UNDEFINED) {

        DebugTrace(0, Dbg, "Pipe is disconnected from us\n", 0);

        DebugTrace(-1, Dbg, "NpInternalTransceive -> STATUS_PIPE_DISCONNECTED\n", 0 );
        return STATUS_PIPE_DISCONNECTED;
    }

    //
    //  Now we only will allow transceive operations on the pipe and not a
    //  directory or the device
    //

    if (NodeTypeCode != NPFS_NTC_CCB) {

        DebugTrace(0, Dbg, "FileObject is not for a named pipe\n", 0);

        DebugTrace(-1, Dbg, "NpInternalTransceive -> STATUS_INVALID_PARAMETER\n", 0 );
        return STATUS_INVALID_PARAMETER;
    }

    NonpagedCcb = Ccb->NonpagedCcb;

    WriteIrp = NULL;
    NpAcquireExclusiveCcb(Ccb);

    try {

        //
        //  Check that the pipe is in the connected state
        //

        if (Ccb->NamedPipeState != FILE_PIPE_CONNECTED_STATE) {

            DebugTrace(0, Dbg, "Pipe not connected\n", 0);

            try_return( Status = STATUS_INVALID_PIPE_STATE );
        }

        //
        //  Figure out the read/write queue, read mode, and event based
        //  on the end of the named pipe doing the transceive.
        //

        switch (NamedPipeEnd) {

        case FILE_PIPE_SERVER_END:

            ReadQueue = &Ccb->DataQueue[ FILE_PIPE_INBOUND ];
            WriteQueue = &Ccb->DataQueue[ FILE_PIPE_OUTBOUND ];

            Event = NonpagedCcb->EventTableEntry[ FILE_PIPE_CLIENT_END ];
            ReadMode = Ccb->ReadCompletionMode[ FILE_PIPE_SERVER_END ].ReadMode;

            break;

        case FILE_PIPE_CLIENT_END:

            ReadQueue = &Ccb->DataQueue[ FILE_PIPE_OUTBOUND ];
            WriteQueue = &Ccb->DataQueue[ FILE_PIPE_INBOUND ];

            Event = NonpagedCcb->EventTableEntry[ FILE_PIPE_SERVER_END ];
            ReadMode = Ccb->ReadCompletionMode[ FILE_PIPE_CLIENT_END ].ReadMode;

            break;

        default:

            NpBugCheck( NamedPipeEnd, 0, 0 );
        }

        //
        //  We only allow a transceive on a message mode, full duplex pipe.
        //

        NamedPipeConfiguration = Ccb->Fcb->Specific.Fcb.NamedPipeConfiguration;

        if ((NamedPipeConfiguration != FILE_PIPE_FULL_DUPLEX) ||
            (ReadMode != FILE_PIPE_MESSAGE_MODE)) {

            DebugTrace(0, Dbg, "Bad pipe configuration or read mode\n", 0);

            try_return( Status = STATUS_INVALID_READ_MODE );
        }

        //
        //  Check that the read queue is empty.
        //

        if (!NpIsDataQueueEmpty( ReadQueue )) {

            DebugTrace(0, Dbg, "Read queue is not empty\n", 0);

            try_return( Status = STATUS_PIPE_BUSY );
        }

        //
        //  Do the transceive write operation.  We first try and push the data
        //  from the write buffer into any waiting readers in the write queue
        //  and if that succeeds then we can go on and do the read operation
        //  otherwise we need to make a copy of irp and to enqueue as
        //  a data entry into the write queue.
        //
        //  Now we'll call our common write data queue routine to
        //  transfer data out of our write buffer into the data queue.
        //  If the result of the call is FALSE then we still have some
        //  write data to put into the write queue.
        //

        UserThread = Irp->Tail.Overlay.Thread;
        Status = NpWriteDataQueue( WriteQueue,
                                   ReadMode,
                                   WriteBuffer,
                                   WriteLength,
                                   Ccb->Fcb->Specific.Fcb.NamedPipeType,
                                   &WriteRemaining,
                                   Ccb,
                                   NamedPipeEnd,
                                   UserThread,
                                   DeferredList );
        if (Status == STATUS_MORE_PROCESSING_REQUIRED)  {

            PIO_STACK_LOCATION WriteIrpSp;

            ASSERT( !NpIsDataQueueReaders( WriteQueue ));

            DebugTrace(0, Dbg, "Add write to data queue\n", 0);

            //
            //  We need to do some more write processing.  So to handle
            //  this case we'll allocate a new irp and set its system
            //  buffer to be the remaining part of the write buffer
            //

            if ((WriteIrp = IoAllocateIrp( NpfsDeviceObject->DeviceObject.StackSize, TRUE )) == NULL) {

                try_return( Status = STATUS_INSUFFICIENT_RESOURCES );
            }

            IoSetCompletionRoutine( WriteIrp, NpCompleteTransceiveIrp, NULL, TRUE, TRUE, TRUE );

            WriteIrpSp = IoGetNextIrpStackLocation( WriteIrp );

            if (WriteRemaining > 0) {

                WriteIrp->AssociatedIrp.SystemBuffer = NpAllocatePagedPoolWithQuota( WriteRemaining, 'wFpN' );
                if (WriteIrp->AssociatedIrp.SystemBuffer == NULL) {
                    IoFreeIrp (WriteIrp);
                    try_return (Status = STATUS_INSUFFICIENT_RESOURCES);
                }
                //
                //  Safely do the copy
                //

                try {

                    RtlCopyMemory( WriteIrp->AssociatedIrp.SystemBuffer,
                                   &WriteBuffer[ WriteLength - WriteRemaining ],
                                   WriteRemaining );

                    WriteIrp->Flags = IRP_BUFFERED_IO | IRP_DEALLOCATE_BUFFER;

                } except(EXCEPTION_EXECUTE_HANDLER) {
                    NpFreePool (WriteIrp->AssociatedIrp.SystemBuffer);
                    IoFreeIrp (WriteIrp);
                    try_return (Status = GetExceptionCode ());
                }

            } else {

                WriteIrp->AssociatedIrp.SystemBuffer = NULL;
            }

            //
            //  Set the current stack location
            //

            WriteIrp->CurrentLocation -= 1;
            WriteIrp->Tail.Overlay.CurrentStackLocation = WriteIrpSp;
            WriteIrp->Tail.Overlay.Thread = UserThread;
            WriteIrpSp->MajorFunction = IRP_MJ_WRITE;
            WriteIrp->UserIosb = &Iosb;

            //
            //  Add this write request to the write queue
            //

            Status = NpAddDataQueueEntry( NamedPipeEnd,
                                          Ccb,
                                          WriteQueue,
                                          WriteEntries,
                                          Unbuffered,
                                          WriteRemaining,
                                          WriteIrp,
                                          NULL,
                                          0 );
            if (Status != STATUS_PENDING) {
                NpDeferredCompleteRequest (WriteIrp, Status, DeferredList);
            }
        }
        if (!NT_SUCCESS (Status)) {
            try_return (NOTHING)
        }
        //
        //  And because we've done something we need to signal the
        //  other ends event
        //

        NpSignalEventTableEntry( Event );

        //
        //  Do the transceive read operation.  This is just like an
        //  unbuffered read.
        //
        //  Now we know that the read queue is empty so we'll enqueue this
        //  Irp to the read queue and return status pending, also mark the
        //  irp pending
        //

        ASSERT( NpIsDataQueueEmpty( ReadQueue ));

        Status = NpAddDataQueueEntry( NamedPipeEnd,
                                      Ccb,
                                      ReadQueue,
                                      ReadEntries,
                                      Unbuffered,
                                      ReadLength,
                                      Irp,
                                      NULL,
                                      0 );
        if (!NT_SUCCESS (Status)) {
            try_return (Status);
        }


        //
        //  And because we've done something we need to signal the
        //  other ends event
        //

        NpSignalEventTableEntry( Event );

    try_exit: NOTHING;
    } finally {

        NpReleaseCcb(Ccb);
    }

    DebugTrace(-1, Dbg, "NpInternalTransceive -> %08lx\n", Status);
    return Status;
}


//
//  Internal support routine
//

NTSTATUS
NpQueryClientProcess (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine does the query client process named pipe control function

    The output buffer may be either a FILE_PIPE_CLIENT_PROCESS_BUFFER or a
    FILE_PIPE_CLIENT_PROCESS_BUFFER_EX.

Arguments:

    NpfsDeviceObject - Supplies our device object

    Irp - Supplies the being processed

Return Value:

    NTSTATUS - An apprropriate return status

--*/

{
    PIO_STACK_LOCATION IrpSp;

    ULONG OutputBufferLength;

    PCCB Ccb;

    PFILE_PIPE_CLIENT_PROCESS_BUFFER_EX ClientProcessBuffer;
    PCLIENT_INFO ClientInfo;
    CLIENT_INFO NullInfo = {0};

    PAGED_CODE();

    //
    //  Get the current stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "NpQueryClientProcess\n", 0);

    OutputBufferLength = IrpSp->Parameters.FileSystemControl.OutputBufferLength;

    //
    //  Decode the file object to figure out who we are.
    //

    if (NpDecodeFileObject( IrpSp->FileObject, NULL, &Ccb, NULL ) != NPFS_NTC_CCB) {

        DebugTrace(0, Dbg, "Pipe is disconnected\n", 0);

        return STATUS_PIPE_DISCONNECTED;
    }

    //
    //  Make sure the output buffer is large enough
    //

    if (OutputBufferLength < sizeof(FILE_PIPE_CLIENT_PROCESS_BUFFER)) {

        DebugTrace(0, Dbg, "Output System buffer size is too small\n", 0);

        return STATUS_INVALID_PARAMETER;
    }

    NpAcquireExclusiveCcb(Ccb);

    //
    //  Copy over the client process ID
    //

    ClientProcessBuffer = Irp->AssociatedIrp.SystemBuffer;
    ClientProcessBuffer->ClientProcess = Ccb->ClientProcess;

    ClientInfo = Ccb->ClientInfo;
    if (ClientInfo == NULL) {
        ClientInfo = &NullInfo;
    }
    ClientProcessBuffer->ClientSession = ClientInfo->ClientSession;

    //
    // Return extended client information if so requested
    // Set the information field to the size of the client process
    // buffer
    //

    if (OutputBufferLength >= sizeof(FILE_PIPE_CLIENT_PROCESS_BUFFER_EX)) {


        ClientProcessBuffer->ClientComputerNameLength =
            ClientInfo->ClientComputerNameLength;

        RtlCopyMemory( ClientProcessBuffer->ClientComputerBuffer,
                       ClientInfo->ClientComputerBuffer,
                       ClientInfo->ClientComputerNameLength );
        ClientProcessBuffer->ClientComputerBuffer[
            ClientProcessBuffer->ClientComputerNameLength / sizeof(WCHAR)] = L'\0';

        Irp->IoStatus.Information = sizeof(FILE_PIPE_CLIENT_PROCESS_BUFFER_EX);

    } else {

        Irp->IoStatus.Information = sizeof(FILE_PIPE_CLIENT_PROCESS_BUFFER);

    }
    NpReleaseCcb(Ccb);

    DebugTrace(-1, Dbg, "NpQueryClientProcess -> STATUS_SUCCESS\n", 0);
    return STATUS_SUCCESS;
}


//
//  Internal support routine
//

NTSTATUS
NpSetClientProcess (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine does the set client process named pipe control function

    Note that we expect a FILE_PIPE_CLIENT_PROCESS_BUFFER_EX structure to be
    passed in to us.

Arguments:

    NpfsDeviceObject - Supplies our device object

    Irp - Supplies the being processed

Return Value:

    NTSTATUS - An apprropriate return status

--*/

{
    PIO_STACK_LOCATION IrpSp;
    PCLIENT_INFO ClientInfo;
    ULONG InputBufferLength;

    PCCB Ccb;

    PFILE_PIPE_CLIENT_PROCESS_BUFFER_EX ClientProcessBuffer;

    PAGED_CODE();

    //
    //  Get the current stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "NpSetClientProcess\n", 0);

    //
    // Only allow kernel callers for this API as RPC relies on this info being solid.
    //
    if (IrpSp->MinorFunction != IRP_MN_KERNEL_CALL) {
        return STATUS_ACCESS_DENIED;
    }


    InputBufferLength = IrpSp->Parameters.FileSystemControl.InputBufferLength;

    //
    //  Decode the file object to figure out who we are.
    //

    if (NpDecodeFileObject( IrpSp->FileObject, NULL, &Ccb, NULL ) != NPFS_NTC_CCB) {

        DebugTrace(0, Dbg, "Pipe is disconnected\n", 0);

        return STATUS_PIPE_DISCONNECTED;
    }

    //
    //  Make sure the input buffer is large enough
    //

    if (InputBufferLength != sizeof(FILE_PIPE_CLIENT_PROCESS_BUFFER_EX)) {

        DebugTrace(0, Dbg, "Input System buffer size is too small\n", 0);

        return STATUS_INVALID_PARAMETER;
    }

    ClientProcessBuffer = Irp->AssociatedIrp.SystemBuffer;

    //
    //  Make verify input length is valid
    //

    if (ClientProcessBuffer->ClientComputerNameLength >
        FILE_PIPE_COMPUTER_NAME_LENGTH * sizeof (WCHAR)) {

        DebugTrace(0, Dbg, "Computer Name length is too large\n", 0);

        return STATUS_INVALID_PARAMETER;
    }

    ClientInfo = NpAllocatePagedPoolWithQuota (FIELD_OFFSET (CLIENT_INFO, ClientComputerBuffer) +
                                                   ClientProcessBuffer->ClientComputerNameLength,
                                               'iFpN');

    if (ClientInfo == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    if (Ccb->ClientInfo != NULL) {
        NpFreePool (Ccb->ClientInfo);
    }

    Ccb->ClientInfo = ClientInfo;
    //
    //  Copy over the client process ID
    //

    ClientInfo->ClientSession = ClientProcessBuffer->ClientSession;
    Ccb->ClientProcess = ClientProcessBuffer->ClientProcess;

    ClientInfo->ClientComputerNameLength = ClientProcessBuffer->ClientComputerNameLength;
    RtlCopyMemory( ClientInfo->ClientComputerBuffer,
                   ClientProcessBuffer->ClientComputerBuffer,
                   ClientProcessBuffer->ClientComputerNameLength );


    DebugTrace(-1, Dbg, "NpSetClientProcess -> STATUS_SUCCESS\n", 0);
    return STATUS_SUCCESS;
}


//
//  Internal support routine
//

NTSTATUS
NpCompleteTransceiveIrp (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    This is a local i/o completion routine used to complete the special
    Irps allocated for transcieve.  This routine simply deallocate the
    irp and return status more processing

Arguments:

    DeviceObject - Supplies the device object

    Irp - Supplies the Irp to complete

    Context - Supplies the context for the Irp

Return Value:

    NTSTATUS - STATUS_MORE_PROCESSING_REQUIRED

--*/

{
    UNREFERENCED_PARAMETER( DeviceObject );
    UNREFERENCED_PARAMETER( Context );

    PAGED_CODE();

    if (Irp->AssociatedIrp.SystemBuffer != NULL) {

        NpFreePool( Irp->AssociatedIrp.SystemBuffer );
    }

    IoFreeIrp( Irp );

    return STATUS_MORE_PROCESSING_REQUIRED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\npfs\fileinfo.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    FileInfo.c

Abstract:

    This module implements the File Info routines for NPFS called by the
    dispatch driver.  There are two entry points NpFsdQueryInformation
    and NpFsdSetInformation.

Author:

    Gary Kimura     [GaryKi]    21-Aug-1990

Revision History:

--*/

#include "NpProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (NPFS_BUG_CHECK_FILEINFO)

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_FILEINFO)


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NpCommonQueryInformation)
#pragma alloc_text(PAGE, NpCommonSetInformation)
#pragma alloc_text(PAGE, NpFsdQueryInformation)
#pragma alloc_text(PAGE, NpFsdSetInformation)
#pragma alloc_text(PAGE, NpQueryBasicInfo)
#pragma alloc_text(PAGE, NpQueryEaInfo)
#pragma alloc_text(PAGE, NpQueryInternalInfo)
#pragma alloc_text(PAGE, NpQueryNameInfo)
#pragma alloc_text(PAGE, NpQueryPipeInfo)
#pragma alloc_text(PAGE, NpQueryPipeLocalInfo)
#pragma alloc_text(PAGE, NpQueryPositionInfo)
#pragma alloc_text(PAGE, NpQueryStandardInfo)
#pragma alloc_text(PAGE, NpSetBasicInfo)
#pragma alloc_text(PAGE, NpSetPipeInfo)
#endif


NTSTATUS
NpFsdQueryInformation (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the FSD part of the NtQueryInformationFile API
    calls.

Arguments:

    NpfsDeviceObject - Supplies the device object to use.

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The Fsd status for the Irp

--*/

{
    NTSTATUS Status;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "NpFsdQueryInformation\n", 0);

    //
    //  Call the common Query Information routine.
    //

    FsRtlEnterFileSystem();

    NpAcquireSharedVcb();

    Status = NpCommonQueryInformation( NpfsDeviceObject, Irp );

    NpReleaseVcb();

    FsRtlExitFileSystem();

    if (Status != STATUS_PENDING) {
        NpCompleteRequest (Irp, Status);
    }
    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "NpFsdQueryInformation -> %08lx\n", Status );

    return Status;
}


NTSTATUS
NpFsdSetInformation (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the FSD part of the NtSetInformationFile API
    calls.

Arguments:

    NpfsDeviceObject - Supplies the device object to use.

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The Fsd status for the Irp

--*/

{
    NTSTATUS Status;
    LIST_ENTRY DeferredList;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "NpFsdSetInformation\n", 0);

    //
    //  Call the common Set Information routine.
    //

    InitializeListHead (&DeferredList);

    FsRtlEnterFileSystem ();

    NpAcquireExclusiveVcb ();

    Status = NpCommonSetInformation (NpfsDeviceObject, Irp, &DeferredList);

    NpReleaseVcb ();

    //
    // Complete the deferred IRPs now we have released the locks
    //
    NpCompleteDeferredIrps (&DeferredList);

    FsRtlExitFileSystem ();

    if (Status != STATUS_PENDING) {
        NpCompleteRequest (Irp, Status);
    }
    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "NpFsdSetInformation -> %08lx\n", Status );
    return Status;
}

//
//  Internal support routine
//

NTSTATUS
NpCommonQueryInformation (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for creating/opening a file.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - the return status for the operation

--*/

{
    PIO_STACK_LOCATION IrpSp;
    NTSTATUS Status;

    ULONG Length;
    FILE_INFORMATION_CLASS FileInformationClass;
    PVOID Buffer;

    NODE_TYPE_CODE NodeTypeCode;
    PFCB Fcb;
    PCCB Ccb;
    NAMED_PIPE_END NamedPipeEnd;

    PFILE_ALL_INFORMATION AllInfo;

    PAGED_CODE();

    //
    //  Get the current stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "NpCommonQueryInformation...\n", 0);
    DebugTrace( 0, Dbg, " Irp                    = %08lx\n", Irp);
    DebugTrace( 0, Dbg, " ->Length               = %08lx\n", IrpSp->Parameters.QueryFile.Length);
    DebugTrace( 0, Dbg, " ->FileInformationClass = %08lx\n", IrpSp->Parameters.QueryFile.FileInformationClass);
    DebugTrace( 0, Dbg, " ->Buffer               = %08lx\n", Irp->AssociatedIrp.SystemBuffer);

    //
    //  Get the ccb and figure out who we are, and make sure we're not
    //  disconnected.
    //

    if ((NodeTypeCode = NpDecodeFileObject( IrpSp->FileObject,
                                            &Fcb,
                                            &Ccb,
                                            &NamedPipeEnd )) == NTC_UNDEFINED) {

        DebugTrace(0, Dbg, "Pipe is disconnected from us\n", 0);

        Status = STATUS_PIPE_DISCONNECTED;

        DebugTrace(-1, Dbg, "NpCommonQueryInformation -> %08lx\n", Status );
        return Status;
    }

    //
    //  Reference our input parameter to make things easier
    //

    Length = IrpSp->Parameters.QueryFile.Length;
    FileInformationClass = IrpSp->Parameters.QueryFile.FileInformationClass;
    Buffer = Irp->AssociatedIrp.SystemBuffer;

    //
    //  Case on the type of the context, We can only query information
    //  on an Fcb, Dcb, or Root Dcb.  If we are not passed on of these
    //  we immediately tell the caller that there is an invalid parameter.
    //

    if (NodeTypeCode != NPFS_NTC_CCB &&
        (NodeTypeCode != NPFS_NTC_ROOT_DCB || FileInformationClass != FileNameInformation)) {

        DebugTrace(0, Dbg, "Node type code is not ccb\n", 0);

        DebugTrace(-1, Dbg, "NpCommonQueryInformation -> STATUS_INVALID_PARAMETER\n", 0);
        return STATUS_INVALID_PARAMETER;
    }


    //
    //  Based on the information class we'll do different actions.  Each
    //  of the procedure that we're calling fill up as much of the
    //  buffer as possible and return the remaining length, and status
    //  This is done so that we can use them to build up the
    //  FileAllInformation request.  These procedures do not complete the
    //  Irp, instead this procedure must complete the Irp.
    //

    switch (FileInformationClass) {

    case FileAllInformation:

        //
        //  For the all information class we'll typecast a local
        //  pointer to the output buffer and then call the
        //  individual routines to fill in the buffer.
        //

        AllInfo = Buffer;

        Length -= (sizeof(FILE_ACCESS_INFORMATION)
                   + sizeof(FILE_MODE_INFORMATION)
                   + sizeof(FILE_ALIGNMENT_INFORMATION));

        //
        //  Only the QueryName call can return non-success
        //

        (VOID)NpQueryBasicInfo( Ccb, &AllInfo->BasicInformation, &Length );
        (VOID)NpQueryStandardInfo( Ccb, &AllInfo->StandardInformation, &Length, NamedPipeEnd );
        (VOID)NpQueryInternalInfo( Ccb, &AllInfo->InternalInformation, &Length );
        (VOID)NpQueryEaInfo( Ccb, &AllInfo->EaInformation, &Length );
        (VOID)NpQueryPositionInfo( Ccb, &AllInfo->PositionInformation, &Length, NamedPipeEnd );

        Status = NpQueryNameInfo( Ccb, &AllInfo->NameInformation, &Length );

        break;

    case FileBasicInformation:

        Status = NpQueryBasicInfo( Ccb, Buffer, &Length );
        break;

    case FileStandardInformation:

        Status = NpQueryStandardInfo( Ccb, Buffer, &Length, NamedPipeEnd );
        break;

    case FileInternalInformation:

        Status = NpQueryInternalInfo( Ccb, Buffer, &Length );
        break;

    case FileEaInformation:

        Status = NpQueryEaInfo( Ccb, Buffer, &Length );
        break;

    case FilePositionInformation:

        Status = NpQueryPositionInfo( Ccb, Buffer, &Length, NamedPipeEnd );
        break;

    case FileNameInformation:

        Status = NpQueryNameInfo( Ccb, Buffer, &Length );
        break;

    case FilePipeInformation:

        Status = NpQueryPipeInfo( Fcb, Ccb, Buffer, &Length, NamedPipeEnd );
        break;

    case FilePipeLocalInformation:

        Status = NpQueryPipeLocalInfo( Fcb, Ccb, Buffer, &Length, NamedPipeEnd );
        break;

    default:

        Status = STATUS_INVALID_PARAMETER;
        break;
    }

    //
    //  Set the information field to the number of bytes actually filled in
    //  and then complete the request
    //

    Irp->IoStatus.Information = IrpSp->Parameters.QueryFile.Length - Length;

    DebugTrace(-1, Dbg, "NpCommonQueryInformation -> %08lx\n", Status );
    return Status;
}


//
//  Internal support routine
//

NTSTATUS
NpCommonSetInformation (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp,
    IN PLIST_ENTRY DeferredList
    )

/*++

Routine Description:

    This is the common routine for creating/opening a file.

Arguments:

    NpfsDeviceObject - Device object for npfs

    Irp - Supplies the Irp to process

    DeferredList - List or IRPs to complete after we drop locks

Return Value:

    NTSTATUS - the return status for the operation

--*/

{
    PIO_STACK_LOCATION IrpSp;
    NTSTATUS Status;

    ULONG Length;
    FILE_INFORMATION_CLASS FileInformationClass;
    PVOID Buffer;

    NODE_TYPE_CODE NodeTypeCode;
    PFCB Fcb;
    PCCB Ccb;
    NAMED_PIPE_END NamedPipeEnd;

    PAGED_CODE();

    //
    //  Get the current Irp stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "NpCommonSetInformation...\n", 0);
    DebugTrace( 0, Dbg, " Irp                    = %08lx\n", Irp);
    DebugTrace( 0, Dbg, " ->Length               = %08lx\n", IrpSp->Parameters.SetFile.Length);
    DebugTrace( 0, Dbg, " ->FileInformationClass = %08lx\n", IrpSp->Parameters.SetFile.FileInformationClass);
    DebugTrace( 0, Dbg, " ->Buffer               = %08lx\n", Irp->AssociatedIrp.SystemBuffer);

    //
    //  Get the ccb and figure out who we are, and make sure we're not
    //  disconnected.
    //

    if ((NodeTypeCode = NpDecodeFileObject( IrpSp->FileObject,
                                            &Fcb,
                                            &Ccb,
                                            &NamedPipeEnd )) == NTC_UNDEFINED) {

        DebugTrace(0, Dbg, "Pipe is disconnected from us\n", 0);

        Status = STATUS_PIPE_DISCONNECTED;

        DebugTrace(-1, Dbg, "NpCommonSetInformation -> %08lx\n", Status );
        return Status;
    }

    //
    //  Case on the type of the context, We can only query information
    //  on an Fcb, Dcb, or Root Dcb.  If we are not passed on of these
    //  we immediately tell the caller that there is an invalid parameter.
    //

    if (NodeTypeCode != NPFS_NTC_CCB) {

        DebugTrace(-1, Dbg, "NpCommonQueryInformation -> STATUS_INVALID_PARAMETER\n", 0);
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Reference our input parameter to make things easier
    //

    Length = IrpSp->Parameters.SetFile.Length;
    FileInformationClass = IrpSp->Parameters.SetFile.FileInformationClass;
    Buffer = Irp->AssociatedIrp.SystemBuffer;

    //
    //  Based on the information class we'll do differnt actions. Each
    //  procedure that we're calling will complete the request.
    //

    switch (FileInformationClass) {

    case FileBasicInformation:

        Status = NpSetBasicInfo( Ccb, Buffer );
        break;

    case FilePipeInformation:

        Status = NpSetPipeInfo( Fcb, Ccb, Buffer, NamedPipeEnd, DeferredList );
        break;

    default:

        Status = STATUS_INVALID_PARAMETER;
        break;
    }


    DebugTrace(-1, Dbg, "NpCommonSetInformation -> %08lx\n", Status);
    return Status;
}


//
//  Internal support routine
//

NTSTATUS
NpQueryBasicInfo (
    IN PCCB Ccb,
    IN PFILE_BASIC_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    This routine performs the query basic information operation.

Arguments:

    Ccb - Supplies the Ccb of the named pipe being queried

    Buffer - Supplies a pointer to the buffer where the information is
        to be returned

    Length - Supplies the length of the buffer in bytes.  This variable
        upon return will receive the remaining bytes free in the buffer.

Return Value:

    NTSTATUS - The result of this query

--*/

{
    UNREFERENCED_PARAMETER( Ccb );

    PAGED_CODE();

    DebugTrace(0, Dbg, "NpQueryBasicInfo...\n", 0);

    //
    //  Update the length field, and zero out the buffer
    //

    *Length -= sizeof( FILE_BASIC_INFORMATION );
    RtlZeroMemory( Buffer, sizeof(FILE_BASIC_INFORMATION) );

    //
    //  Set the various fields in the record
    //
    //**** need to add the time fields to the fcb/ccb
    //

    Buffer->CreationTime.LowPart   = 0; Buffer->CreationTime.HighPart   = 0;
    Buffer->LastAccessTime.LowPart = 0; Buffer->LastAccessTime.HighPart = 0;
    Buffer->LastWriteTime.LowPart  = 0; Buffer->LastWriteTime.HighPart  = 0;
    Buffer->ChangeTime.LowPart     = 0; Buffer->ChangeTime.HighPart     = 0;

    Buffer->FileAttributes = FILE_ATTRIBUTE_NORMAL;

    //
    //  and return to our caller
    //

    return STATUS_SUCCESS;
}


//
//  Internal support routine
//

NTSTATUS
NpQueryStandardInfo (
    IN PCCB Ccb,
    IN PFILE_STANDARD_INFORMATION Buffer,
    IN OUT PULONG Length,
    IN NAMED_PIPE_END NamedPipeEnd
    )

/*++

Routine Description:

    This routine performs the query standard information operation.

Arguments:

    Ccb - Supplies the Ccb of the named pipe being queried

    Buffer - Supplies a pointer to the buffer where the information is
        to be returned

    Length - Supplies the length of the buffer in bytes.  This variable
        upon return will receive the remaining bytes free in the buffer.

Return Value:

    NTSTATUS - The result of this query

--*/

{
    PDATA_QUEUE Inbound;
    PDATA_QUEUE Outbound;
    PDATA_QUEUE Queue;

    PAGED_CODE();

    DebugTrace(0, Dbg, "NpQueryStandardInfo...\n", 0);

    //
    //  Update the length field, and zero out the buffer
    //

    *Length -= sizeof( FILE_STANDARD_INFORMATION );
    RtlZeroMemory( Buffer, sizeof(FILE_STANDARD_INFORMATION) );

    //
    //  Set the various fields in the record
    //

    Inbound = &Ccb->DataQueue[ FILE_PIPE_INBOUND ];
    Outbound = &Ccb->DataQueue[ FILE_PIPE_OUTBOUND ];

    if (NamedPipeEnd == FILE_PIPE_CLIENT_END) {
        Queue = Outbound;
    } else {
        Queue = Inbound;
    }
    //
    //  The allocation size is the amount of quota we've charged this pipe
    //  instance
    //

    Buffer->AllocationSize.QuadPart = Inbound->Quota + Outbound->Quota;

    //
    //  The Eof is the number of writen bytes ready to be read from the queue
    //
    if (NpIsDataQueueWriters( Queue )) {
        Buffer->EndOfFile.QuadPart = Queue->BytesInQueue - Queue->NextByteOffset;
    }

    Buffer->NumberOfLinks = 1;
    Buffer->DeletePending = TRUE;
    Buffer->Directory = FALSE;

    //
    //  And return to our caller
    //

    return STATUS_SUCCESS;
}


//
//  Internal support routine
//

NTSTATUS
NpQueryInternalInfo (
    IN PCCB Ccb,
    IN PFILE_INTERNAL_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    This routine performs the query internal information operation.

Arguments:

    Ccb - Supplies the Ccb of the named pipe being queried

    Buffer - Supplies a pointer to the buffer where the information is
        to be returned

    Length - Supplies the length of the buffer in bytes.  This variable
        upon return will receive the remaining bytes free in the buffer.

Return Value:

    NTSTATUS - The result of this query

--*/

{
    PAGED_CODE();

    DebugTrace(0, Dbg, "NpQueryInternalInfo...\n", 0);

    //
    //  Update the length field, and zero out the buffer
    //

    *Length -= sizeof(FILE_INTERNAL_INFORMATION);
    RtlZeroMemory(Buffer, sizeof(FILE_INTERNAL_INFORMATION));

    //
    //  Set the internal index number to be the fnode lbn;
    //

    Buffer->IndexNumber.QuadPart = (ULONG_PTR)Ccb;

    //
    //  And return to our caller
    //

    return STATUS_SUCCESS;
}


//
//  Internal support routine
//

NTSTATUS
NpQueryEaInfo (
    IN PCCB Ccb,
    IN PFILE_EA_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    This routine performs the query Ea information operation.

Arguments:

    Ccb - Supplies the Ccb of the named pipe being queried

    Buffer - Supplies a pointer to the buffer where the information is
        to be returned

    Length - Supplies the length of the buffer in bytes.  This variable
        upon return will receive the remaining bytes free in the buffer.

Return Value:

    NTSTATUS - The result of this query

--*/

{
    UNREFERENCED_PARAMETER( Ccb );

    PAGED_CODE();

    DebugTrace(0, Dbg, "NpQueryEaInfo...\n", 0);

    //
    //  Update the length field, and zero out the buffer
    //

    *Length -= sizeof(FILE_EA_INFORMATION);
    RtlZeroMemory(Buffer, sizeof(FILE_EA_INFORMATION));

    //
    //  And return to our caller
    //

    return STATUS_SUCCESS;
}


//
//  Internal support routine
//

NTSTATUS
NpQueryNameInfo (
    IN PCCB Ccb,
    IN PFILE_NAME_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    This routine performs the query name information operation.

Arguments:

    Ccb - Supplies the Ccb of the named pipe being queried

    Buffer - Supplies a pointer to the buffer where the information is
        to be returned

    Length - Supplies the length of the buffer in bytes.  This variable
        upon return will receive the remaining bytes free in the buffer.

Return Value:

    NTSTATUS - The result of this query

--*/

{
    ULONG bytesToCopy;
    ULONG fileNameSize;
    PFCB Fcb;

    NTSTATUS status;

    PAGED_CODE();

    DebugTrace(0, Dbg, "NpQueryNameInfo...\n", 0);

    //
    // See if the buffer is large enough, and decide how many bytes to copy.
    //

    *Length -= FIELD_OFFSET( FILE_NAME_INFORMATION, FileName[0] );

    if (Ccb->NodeTypeCode == NPFS_NTC_ROOT_DCB_CCB) {
        Fcb = NpVcb->RootDcb;
    } else {
        Fcb = Ccb->Fcb;
    }
    fileNameSize = Fcb->FullFileName.Length;

    if ( *Length >= fileNameSize ) {

        status = STATUS_SUCCESS;

        bytesToCopy = fileNameSize;

    } else {

        status = STATUS_BUFFER_OVERFLOW;

        bytesToCopy = *Length;
    }

    //
    // Copy over the file name and its length.
    //

    RtlCopyMemory(
        Buffer->FileName,
        Fcb->FullFileName.Buffer,
        bytesToCopy);

    Buffer->FileNameLength = bytesToCopy;

    *Length -= bytesToCopy;

    return status;
}


//
//  Internal support routine
//

NTSTATUS
NpQueryPositionInfo (
    IN PCCB Ccb,
    IN PFILE_POSITION_INFORMATION Buffer,
    IN OUT PULONG Length,
    IN NAMED_PIPE_END NamedPipeEnd
    )

/*++

Routine Description:

    This routine performs the query position information operation.

Arguments:

    Ccb - Supplies the Ccb of the named pipe being queried

    Buffer - Supplies a pointer to the buffer where the information is
        to be returned

    Length - Supplies the length of the buffer in bytes.  This variable
        upon return will receive the remaining bytes free in the buffer.

    NamedPipeEnd - Indicates if the server or client is calling

Return Value:

    NTSTATUS - The result of this query

--*/

{
    PDATA_QUEUE Queue;

    PAGED_CODE();

    DebugTrace(0, Dbg, "PbQueryPositionInfo...\n", 0);

    //
    //  Update the length field, and zero out the buffer
    //

    *Length -= sizeof(FILE_POSITION_INFORMATION);
    RtlZeroMemory(Buffer, sizeof(FILE_POSITION_INFORMATION));

    //
    //  The current byte offset is the number of bytes available in the
    //  read end of the caller's buffer.  The client read from the outbound
    //  end and the server reads from the inbound end.
    //

    if (NamedPipeEnd == FILE_PIPE_CLIENT_END) {
        Queue = &Ccb->DataQueue[ FILE_PIPE_OUTBOUND ];
    } else {
        Queue = &Ccb->DataQueue[ FILE_PIPE_INBOUND ];

    }
    if (NpIsDataQueueWriters( Queue )) {
        Buffer->CurrentByteOffset.QuadPart = Queue->BytesInQueue - Queue->NextByteOffset;
    }

    //
    //  And return to our caller
    //

    return STATUS_SUCCESS;
}


//
//  Internal support routine
//

NTSTATUS
NpQueryPipeInfo (
    IN PFCB Fcb,
    IN PCCB Ccb,
    IN PFILE_PIPE_INFORMATION Buffer,
    IN OUT PULONG Length,
    IN NAMED_PIPE_END NamedPipeEnd
    )

/*++

Routine Description:

    This routine performs the query pipe information operation.

Arguments:

    Fcb - Supplies the Fcb of the named pipe being queried

    Ccb - Supplies the Ccb of the named pipe being queried

    Buffer - Supplies a pointer to the buffer where the information is
        to be returned

    Length - Supplies the length of the buffer in bytes.  This variable
        upon return will receive the remaining bytes free in the buffer.

    NamedPipeEnd - Indicates if the server or client is calling

Return Value:

    NTSTATUS - The result of this query

--*/

{
    UNREFERENCED_PARAMETER( Fcb );
    UNREFERENCED_PARAMETER( Ccb );

    PAGED_CODE();

    DebugTrace(0, Dbg, "PbQueryPipeInfo...\n", 0);

    //
    //  Update the length field, and zero out the buffer
    //

    *Length -= sizeof(FILE_PIPE_INFORMATION);
    RtlZeroMemory(Buffer, sizeof(FILE_PIPE_INFORMATION));

    //
    //  Set the fields in the record
    //

    Buffer->ReadMode       = Ccb->ReadCompletionMode[ NamedPipeEnd ].ReadMode;
    Buffer->CompletionMode = Ccb->ReadCompletionMode[ NamedPipeEnd ].CompletionMode;

    //
    //  And return to our caller
    //

    return STATUS_SUCCESS;
}


//
//  Internal support routine
//

NTSTATUS
NpQueryPipeLocalInfo (
    IN PFCB Fcb,
    IN PCCB Ccb,
    IN PFILE_PIPE_LOCAL_INFORMATION Buffer,
    IN OUT PULONG Length,
    IN NAMED_PIPE_END NamedPipeEnd
    )

/*++

Routine Description:

    This routine performs the query pipe information operation.

Arguments:

    Fcb - Supplies the Fcb of the named pipe being queried

    Ccb - Supplies the Ccb of the named pipe being queried

    Buffer - Supplies a pointer to the buffer where the information is
        to be returned

    Length - Supplies the length of the buffer in bytes.  This variable
        upon return will receive the remaining bytes free in the buffer.

    NamedPipeEnd - Indicates if the server or client is calling

Return Value:

    NTSTATUS - The result of this query

--*/

{
    PDATA_QUEUE Inbound;
    PDATA_QUEUE Outbound;

    UNREFERENCED_PARAMETER( Ccb );

    PAGED_CODE();

    DebugTrace(0, Dbg, "PbQueryPipeLocalInfo...\n", 0);

    //
    //  Update the length field, and zero out the buffer
    //

    *Length -= sizeof(FILE_PIPE_LOCAL_INFORMATION);
    RtlZeroMemory(Buffer, sizeof(FILE_PIPE_LOCAL_INFORMATION));

    Inbound = &Ccb->DataQueue[ FILE_PIPE_INBOUND ];
    Outbound = &Ccb->DataQueue[ FILE_PIPE_OUTBOUND ];

    //
    //  Set the fields in the record
    //

    Buffer->NamedPipeType          = Fcb->Specific.Fcb.NamedPipeType;
    Buffer->NamedPipeConfiguration = Fcb->Specific.Fcb.NamedPipeConfiguration;
    Buffer->MaximumInstances       = Fcb->Specific.Fcb.MaximumInstances;
    Buffer->CurrentInstances       = Fcb->OpenCount;
    Buffer->InboundQuota           = Inbound->Quota;
    Buffer->OutboundQuota          = Outbound->Quota;
    Buffer->NamedPipeState         = Ccb->NamedPipeState;
    Buffer->NamedPipeEnd           = NamedPipeEnd;

    //
    //  The read data available and write quota available depend on which
    //  end of the pipe is doing the query.  The client reads from the outbound
    //  queue, and writes to the inbound queue.
    //

    if (NamedPipeEnd == FILE_PIPE_CLIENT_END) {

        if (NpIsDataQueueWriters( Outbound )) {

            Buffer->ReadDataAvailable = Outbound->BytesInQueue - Outbound->NextByteOffset;
        }

        Buffer->WriteQuotaAvailable = Inbound->Quota - Inbound->QuotaUsed;

    } else {

        if (NpIsDataQueueWriters( Inbound  )) {

            Buffer->ReadDataAvailable = Inbound->BytesInQueue - Inbound->NextByteOffset;
        }

        Buffer->WriteQuotaAvailable = Outbound->Quota - Outbound->QuotaUsed;
    }

    //
    //  And return to our caller
    //

    return STATUS_SUCCESS;
}


//
//  Internal support routine
//

NTSTATUS
NpSetBasicInfo (
    IN PCCB Ccb,
    IN PFILE_BASIC_INFORMATION Buffer
    )

/*++

Routine Description:

    This routine sets the basic information for a named pipe.

Arguments:

    Ccb - Supplies the ccb for the named pipe being modified

    Buffer - Supplies the buffer containing the data being set

Return Value:

    NTSTATUS - Returns our completion status

--*/

{
    UNREFERENCED_PARAMETER( Ccb );

    PAGED_CODE();

    DebugTrace(0, Dbg, "NpSetBasicInfo...\n", 0);

    if (((PLARGE_INTEGER)&Buffer->CreationTime)->QuadPart != 0) {

        //
        //  Modify the creation time
        //

        //**** need to add time fields
    }

    if (((PLARGE_INTEGER)&Buffer->LastAccessTime)->QuadPart != 0) {

        //
        //  Modify the last access time
        //

        //**** need to add time fields
    }

    if (((PLARGE_INTEGER)&Buffer->LastWriteTime)->QuadPart != 0) {

        //
        //  Modify the last write time
        //

        //**** need to add time fields
    }

    if (((PLARGE_INTEGER)&Buffer->ChangeTime)->QuadPart != 0) {

        //
        //  Modify the change time
        //

        //**** need to add time fields
    }

    //
    //  And return to our caller
    //

    return STATUS_SUCCESS;
}


//
//  Internal support routine
//

NTSTATUS
NpSetPipeInfo (
    IN PFCB Fcb,
    IN PCCB Ccb,
    IN PFILE_PIPE_INFORMATION Buffer,
    IN NAMED_PIPE_END NamedPipeEnd,
    IN PLIST_ENTRY DeferredList
    )

/*++

Routine Description:

    This routine sets the pipe information for a named pipe.

Arguments:

    Fcb - Supplies the Fcb for the named pipe being modified

    Ccb - Supplies the ccb for the named pipe being modified

    Buffer - Supplies the buffer containing the data being set

    NamedPipeEnd - Supplies the server/client end doing the operation

    DeferredList - List of IRPs to complete once we release locks

Return Value:

    NTSTATUS - Returns our completion status

--*/

{
    PDATA_QUEUE ReadQueue;
    PDATA_QUEUE WriteQueue;

    UNREFERENCED_PARAMETER( Ccb );

    PAGED_CODE();

    DebugTrace(0, Dbg, "NpSetPipeInfo...\n", 0);

    //
    //  If the caller requests message mode reads but the pipe is
    //  byte stream then its an invalid parameter
    //

    if ((Buffer->ReadMode == FILE_PIPE_MESSAGE_MODE) &&
        (Fcb->Specific.Fcb.NamedPipeType == FILE_PIPE_BYTE_STREAM_MODE)) {

        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Get a reference to our read queue
    //

    switch (NamedPipeEnd) {

    case FILE_PIPE_SERVER_END:

        ReadQueue = &Ccb->DataQueue[ FILE_PIPE_INBOUND ];
        WriteQueue = &Ccb->DataQueue[ FILE_PIPE_OUTBOUND ];

        break;

    case FILE_PIPE_CLIENT_END:

        ReadQueue = &Ccb->DataQueue[ FILE_PIPE_OUTBOUND ];
        WriteQueue = &Ccb->DataQueue[ FILE_PIPE_INBOUND ];

        break;

    default:

        NpBugCheck( NamedPipeEnd, 0, 0 );
    }

    //
    //  If the completion mode is complete operations and the current mode
    //  is queue operations and there and the data queues are not empty
    //  then its pipe busy
    //

    if ((Buffer->CompletionMode == FILE_PIPE_COMPLETE_OPERATION)

            &&

        (Ccb->ReadCompletionMode[ NamedPipeEnd ].CompletionMode == FILE_PIPE_QUEUE_OPERATION)

            &&

        ((NpIsDataQueueReaders(ReadQueue)) ||
         (NpIsDataQueueWriters(WriteQueue)))) {

        return STATUS_PIPE_BUSY;
    }

    //
    //  Everything is fine so update the pipe
    //

    Ccb->ReadCompletionMode[ NamedPipeEnd ].ReadMode = (UCHAR) Buffer->ReadMode;
    Ccb->ReadCompletionMode[ NamedPipeEnd ].CompletionMode = (UCHAR) Buffer->CompletionMode;

    //
    //  Check for notify
    //

    NpCheckForNotify( Fcb->ParentDcb, FALSE, DeferredList );

    //
    //  And return to our caller
    //

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\npfs\nodetype.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    NodeType.h

Abstract:

    This module defines all of the node type codes used in this development
    shell.  Every major data structure in the file system is assigned a node
    type code that is.

Author:

    Gary Kimura     [GaryKi]    20-Aug-1990

Revision History:

--*/

#ifndef _NODETYPE_
#define _NODETYPE_

typedef UCHAR NODE_TYPE_CODE;
typedef NODE_TYPE_CODE *PNODE_TYPE_CODE;

#define NTC_UNDEFINED                    ((NODE_TYPE_CODE)0x00)

#define NPFS_NTC_VCB                     ((NODE_TYPE_CODE)0x01)

#define NPFS_NTC_ROOT_DCB                ((NODE_TYPE_CODE)0x02)

#define NPFS_NTC_FCB                     ((NODE_TYPE_CODE)0x04)

#define NPFS_NTC_CCB                     ((NODE_TYPE_CODE)0x06)
#define NPFS_NTC_NONPAGED_CCB            ((NODE_TYPE_CODE)0x07)

#define NPFS_NTC_ROOT_DCB_CCB            ((NODE_TYPE_CODE)0x08)


#define NodeType(Ptr) ((Ptr) == NULL ? NTC_UNDEFINED : *((PNODE_TYPE_CODE)(Ptr)))


//
//  The following definitions are used to generate meaningful blue bugcheck
//  screens.  On a bugcheck the file system can output 4 ulongs of useful
//  information.  The first ulong will have encoded in it a source file id
//  (in the high word) and the line number of the bugcheck (in the low word).
//  The other values can be whatever the caller of the bugcheck routine deems
//  necessary.
//
//  Each individual file that calls bugcheck needs to have defined at the
//  start of the file a constant called BugCheckFileId with one of the
//  NPFS_BUG_CHECK_ values defined below and then use NpBugCheck to bugcheck
//  the system.
//

#define NPFS_BUG_CHECK_CLEANUP           (0x00010000)
#define NPFS_BUG_CHECK_CLOSE             (0x00020000)
#define NPFS_BUG_CHECK_CREATE            (0x00030000)
#define NPFS_BUG_CHECK_CREATENP          (0x00040000)
#define NPFS_BUG_CHECK_DIR               (0x00050000)
#define NPFS_BUG_CHECK_DATASUP           (0x00060000)
#define NPFS_BUG_CHECK_DEVIOSUP          (0x00070000)
#define NPFS_BUG_CHECK_DUMPSUP           (0x00080000)
#define NPFS_BUG_CHECK_EVENTSUP          (0x00090000)
#define NPFS_BUG_CHECK_FILEINFO          (0x000a0000)
#define NPFS_BUG_CHECK_FILOBSUP          (0x000b0000)
#define NPFS_BUG_CHECK_FLUSHBUF          (0x000c0000)
#define NPFS_BUG_CHECK_FSCTRL            (0x000d0000)
#define NPFS_BUG_CHECK_NPINIT            (0x000e0000)
#define NPFS_BUG_CHECK_NPDATA            (0x000f0000)
#define NPFS_BUG_CHECK_PREFXSUP          (0x00100000)
#define NPFS_BUG_CHECK_READ              (0x00110000)
#define NPFS_BUG_CHECK_READSUP           (0x00120000)
#define NPFS_BUG_CHECK_RESRCSUP          (0x00130000)
#define NPFS_BUG_CHECK_SEINFO            (0x00140000)
#define NPFS_BUG_CHECK_SECURSUP          (0x00150000)
#define NPFS_BUG_CHECK_STATESUP          (0x00160000)
#define NPFS_BUG_CHECK_STRUCSUP          (0x00170000)
#define NPFS_BUG_CHECK_VOLINFO           (0x00180000)
#define NPFS_BUG_CHECK_WAITSUP           (0x00190000)
#define NPFS_BUG_CHECK_WRITE             (0x001a0000)
#define NPFS_BUG_CHECK_WRITESUP          (0x001b0000)

#define NpBugCheck(A,B,C) { KeBugCheckEx(NPFS_FILE_SYSTEM, BugCheckFileId | __LINE__, A, B, C ); }


//
//  In this module we'll also define some globally known constants
//

#define UCHAR_NUL                        0x00
#define UCHAR_SOH                        0x01
#define UCHAR_STX                        0x02
#define UCHAR_ETX                        0x03
#define UCHAR_EOT                        0x04
#define UCHAR_ENQ                        0x05
#define UCHAR_ACK                        0x06
#define UCHAR_BEL                        0x07
#define UCHAR_BS                         0x08
#define UCHAR_HT                         0x09
#define UCHAR_LF                         0x0a
#define UCHAR_VT                         0x0b
#define UCHAR_FF                         0x0c
#define UCHAR_CR                         0x0d
#define UCHAR_SO                         0x0e
#define UCHAR_SI                         0x0f
#define UCHAR_DLE                        0x10
#define UCHAR_DC1                        0x11
#define UCHAR_DC2                        0x12
#define UCHAR_DC3                        0x13
#define UCHAR_DC4                        0x14
#define UCHAR_NAK                        0x15
#define UCHAR_SYN                        0x16
#define UCHAR_ETB                        0x17
#define UCHAR_CAN                        0x18
#define UCHAR_EM                         0x19
#define UCHAR_SUB                        0x1a
#define UCHAR_ESC                        0x1b
#define UCHAR_FS                         0x1c
#define UCHAR_GS                         0x1d
#define UCHAR_RS                         0x1e
#define UCHAR_US                         0x1f
#define UCHAR_SP                         0x20

#endif // _NODETYPE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\npfs\npdata.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    NpData.c

Abstract:

    This module declares the global data used by the Named Pipe file system.

Author:

    Gary Kimura     [GaryKi]    20-Aug-1990

Revision History:

--*/

#ifndef _NPDATA_
#define _NPDATA_

extern PVCB NpVcb;

//
//  The global structure used to contain our fast I/O callbacks
//

extern FAST_IO_DISPATCH NpFastIoDispatch;

//
//  Lists of pipe name aliases.
//

#define MIN_LENGTH_ALIAS_ARRAY (5 * sizeof(WCHAR)) // includes '\'
#define MAX_LENGTH_ALIAS_ARRAY (9 * sizeof(WCHAR))

extern SINGLE_LIST_ENTRY NpAliasListByLength[(MAX_LENGTH_ALIAS_ARRAY-MIN_LENGTH_ALIAS_ARRAY)/sizeof(WCHAR)+1];
extern SINGLE_LIST_ENTRY NpAliasList;

extern PVOID NpAliases; // single allocation containing all aliases

//
//  The global Named Pipe debug level variable, its values are:
//
//      0x00000000      Always gets printed (used when about to bug check)
//
//      0x00000001
//      0x00000002
//      0x00000004
//      0x00000008
//
//      0x00000010
//      0x00000020
//      0x00000040
//      0x00000080
//
//      0x00000100
//      0x00000200
//      0x00000400
//      0x00000800
//
//      0x00001000
//      0x00002000
//      0x00004000
//      0x00008000
//
//      0x00010000
//      0x00020000
//      0x00040000
//      0x00080000
//
//      0x00100000
//      0x00200000
//      0x00400000
//      0x00800000
//
//      0x01000000
//      0x02000000
//      0x04000000
//      0x08000000
//
//      0x10000000
//      0x20000000
//      0x40000000
//      0x80000000
//

#ifdef NPDBG

#define DEBUG_TRACE_ERROR                (0x00000001)
#define DEBUG_TRACE_DEBUG_HOOKS          (0x00000002)
#define DEBUG_TRACE_CATCH_EXCEPTIONS     (0x00000004)
#define DEBUG_TRACE_CREATE               (0x00000008)
#define DEBUG_TRACE_CLOSE                (0x00000010)
#define DEBUG_TRACE_READ                 (0x00000020)
#define DEBUG_TRACE_WRITE                (0x00000040)
#define DEBUG_TRACE_FILEINFO             (0x00000080)
#define DEBUG_TRACE_CLEANUP              (0x00000100)
#define DEBUG_TRACE_DIR                  (0x00000200)
#define DEBUG_TRACE_FSCONTRL             (0x00000400)
#define DEBUG_TRACE_CREATE_NAMED_PIPE    (0x00000800)
#define DEBUG_TRACE_FLUSH_BUFFERS        (0x00001000)
#define DEBUG_TRACE_VOLINFO              (0x00002000)
#define DEBUG_TRACE_SEINFO               (0x00004000)
#define DEBUG_TRACE_0x00008000           (0x00008000)
#define DEBUG_TRACE_0x00010000           (0x00010000)
#define DEBUG_TRACE_SECURSUP             (0x00020000)
#define DEBUG_TRACE_DEVIOSUP             (0x00040000)
#define DEBUG_TRACE_RESRCSUP             (0x00080000)
#define DEBUG_TRACE_READSUP              (0x00100000)
#define DEBUG_TRACE_WRITESUP             (0x00200000)
#define DEBUG_TRACE_STATESUP             (0x00400000)
#define DEBUG_TRACE_FILOBSUP             (0x00800000)
#define DEBUG_TRACE_PREFXSUP             (0x01000000)
#define DEBUG_TRACE_CNTXTSUP             (0x02000000)
#define DEBUG_TRACE_DATASUP              (0x04000000)
#define DEBUG_TRACE_WAITSUP              (0x08000000)
#define DEBUG_TRACE_EVENTSUP             (0x10000000)
#define DEBUG_TRACE_STRUCSUP             (0x20000000)

extern LONG NpDebugTraceLevel;
extern LONG NpDebugTraceIndent;

#define DebugTrace(INDENT,LEVEL,X,Y) {                     \
    LONG _i;                                               \
    if (((LEVEL) == 0) || (NpDebugTraceLevel & (LEVEL))) { \
        DbgPrint("%p:",PsGetCurrentThread());              \
        if ((INDENT) < 0) {                                \
            NpDebugTraceIndent += (INDENT);                \
        }                                                  \
        if (NpDebugTraceIndent < 0) {                      \
            NpDebugTraceIndent = 0;                        \
        }                                                  \
        for (_i=0; _i<NpDebugTraceIndent; _i+=1) {         \
            DbgPrint(" ");                                 \
        }                                                  \
        DbgPrint(X,Y);                                     \
        if ((INDENT) > 0) {                                \
            NpDebugTraceIndent += (INDENT);                \
        }                                                  \
    }                                                      \
}

#define DebugDump(STR,LEVEL,PTR) {                         \
    VOID NpDump(PVOID Ptr);                                \
    if (((LEVEL) == 0) || (NpDebugTraceLevel & (LEVEL))) { \
        DbgPrint("%p:",PsGetCurrentThread());              \
        DbgPrint(STR);                                     \
        if (PTR != NULL) {NpDump(PTR);}                    \
        DbgBreakPoint();                                   \
    }                                                      \
}

#else

#define DebugTrace(INDENT,LEVEL,X,Y)     {NOTHING;}
#define DebugDump(STR,LEVEL,PTR)         {NOTHING;}

#endif // NPDBG

//
//  The following macro is for all people who compile with the DBG switch
//  set, not just fastfat dbg users
//

#if DBG

#define DbgDoit(X)                       {X;}

#else

#define DbgDoit(X)                       {NOTHING;}

#endif // DBG


//
//  Some global debug routines to verify the shape and consistency of various
//  data structures.
//
#ifdef DBG

_inline VOID
NpfsVerifyCcb( IN PCHAR FileName, IN ULONG Line, IN PCCB Ccb ) {
    PFILE_OBJECT FileObject;
    if ((FileObject = Ccb->FileObject[ FILE_PIPE_CLIENT_END ]) != NULL) {
        if ((ULONG_PTR)FileObject->FsContext != (ULONG_PTR)Ccb) {
            DbgPrint("%s(%d) Ccb @ %p with bad client\n", FileName, Line, Ccb );
            DbgBreakPoint();
        }
    }
    if ((FileObject = Ccb->FileObject[ FILE_PIPE_SERVER_END ]) != NULL) {
        if (((ULONG_PTR)FileObject->FsContext & ~0x00000001) != (ULONG_PTR)Ccb) {
            DbgPrint("%s(%d) Ccb @ %p with bad server\n", FileName, Line, Ccb );
            DbgBreakPoint();
        }
    }
}
#else

#define NpfsVerifyCcb( IN PCHAR FileName, IN ULONG Line, IN PCCB Ccb )

#endif

#endif // _NPDATA_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\npfs\npprocs.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    NpProcs.h

Abstract:

    This module defines all of the globally used procedures in the Named
    Pipe file system.

Author:

    Gary Kimura     [GaryKi]    20-Aug-1990

Revision History:

--*/

#ifndef _NPPROCS_
#define _NPPROCS_

#define _NTSRV_
#define _NTDDK_


#include <Ntos.h>
#include <FsRtl.h>
#include <String.h>

//
//  This macro returns TRUE if a flag in a set of flags is on and FALSE
//  otherwise
//

#define FlagOn(Flags,SingleFlag)        ((Flags) & (SingleFlag))

#include "NodeType.h"
#include "NpStruc.h"
#include "NpData.h"

//
//  Tag all of our allocations if tagging is turned on
//

#undef FsRtlAllocatePool
#undef FsRtlAllocatePoolWithQuota

#define FsRtlAllocatePool(a,b) FsRtlAllocatePoolWithTag(a,b,'sfpN')
#define FsRtlAllocatePoolWithQuota(a,b) FsRtlAllocatePoolWithQuotaTag(a,b,'sfpN')


//
//  Data queue support routines, implemented in DataSup.c
//

NTSTATUS
NpInitializeDataQueue (
    IN PDATA_QUEUE DataQueue,
    IN ULONG Quota
    );

VOID
NpUninitializeDataQueue (
    IN PDATA_QUEUE DataQueue
    );

NTSTATUS
NpAddDataQueueEntry (
    IN NAMED_PIPE_END NamedPipeEnd,
    IN PCCB Ccb,
    IN PDATA_QUEUE DataQueue,
    IN QUEUE_STATE Who,
    IN DATA_ENTRY_TYPE Type,
    IN ULONG DataSize,
    IN PIRP Irp OPTIONAL,
    IN PVOID DataPointer OPTIONAL,
    IN ULONG ByteOffset
    );

PIRP
NpRemoveDataQueueEntry (
    IN PDATA_QUEUE DataQueue,
    IN BOOLEAN CompletedFlushes,
    IN PLIST_ENTRY DeferredList
    );

VOID
NpCompleteStalledWrites (
    IN PDATA_QUEUE DataQueue,
    IN PLIST_ENTRY DeferredList
    );

//PDATA_ENTRY
//NpGetNextDataQueueEntry (
//    IN PDATA_QUEUE DataQueue,
//    IN PDATA_ENTRY PreviousDataEntry OPTIONAL
//    );
#define NpGetNextDataQueueEntry(_dq,_pde) \
    ((_pde) != NULL ? (PDATA_ENTRY)(((PDATA_ENTRY)(_pde))->Queue.Flink) : \
                      (PDATA_ENTRY)(((PDATA_QUEUE)(_dq))->Queue.Flink))

PDATA_ENTRY
NpGetNextRealDataQueueEntry (
    IN PDATA_QUEUE DataQueue,
    IN PLIST_ENTRY DeferredList
    );

//BOOLEAN
//NpIsDataQueueEmpty (
//    IN PDATA_QUEUE DataQueue
//    );
#define NpIsDataQueueEmpty(_dq) ((_dq)->QueueState == Empty)

//BOOLEAN
//NpIsDataQueueReaders (
//    IN PDATA_QUEUE DataQueue
//    );
#define NpIsDataQueueReaders(_dq) ((_dq)->QueueState == ReadEntries)

//BOOLEAN
//NpIsDataQueueWriters (
//    IN PDATA_QUEUE DataQueue
//    );
#define NpIsDataQueueWriters(_dq) ((_dq)->QueueState == WriteEntries)


//
//  The following routines are used to manipulate the input buffers and are
//  implemented in DevioSup.c
//

//PVOID
//NpMapUserBuffer (
//    IN OUT PIRP Irp
//    );
#define NpMapUserBuffer(_irp)                                               \
    (Irp->MdlAddress == NULL ? Irp->UserBuffer :                            \
                               MmGetSystemAddressForMdl( Irp->MdlAddress ))


VOID
NpLockUserBuffer (
    IN OUT PIRP Irp,
    IN LOCK_OPERATION Operation,
    IN ULONG BufferLength
    );


//
//  The event support routines, implemented in EventSup.c
//

RTL_GENERIC_COMPARE_RESULTS
NpEventTableCompareRoutine (
    IN PRTL_GENERIC_TABLE EventTable,
    IN PVOID FirstStruct,
    IN PVOID SecondStruct
    );

PVOID
NpEventTableAllocate (
    IN PRTL_GENERIC_TABLE EventTable,
    IN CLONG ByteSize
    );

VOID
NpEventTableDeallocate (
    IN PRTL_GENERIC_TABLE EventTable,
    IN PVOID Buffer
    );

//
//  VOID
//  NpInitializeEventTable (
//      IN PEVENT_TABLE EventTable
//      );
//

#define NpInitializeEventTable(_et) {                       \
    RtlInitializeGenericTable( &(_et)->Table,               \
                               NpEventTableCompareRoutine,  \
                               NpEventTableAllocate,        \
                               NpEventTableDeallocate,      \
                               NULL );       \
}


//VOID
//NpUninitializeEventTable (
//    IN PEVENT_TABLE EventTable
//    );
#define NpUninitializeEventTable(_et) NOTHING

NTSTATUS
NpAddEventTableEntry (
    IN  PEVENT_TABLE EventTable,
    IN  PCCB Ccb,
    IN  NAMED_PIPE_END NamedPipeEnd,
    IN  HANDLE EventHandle,
    IN  ULONG KeyValue,
    IN  PEPROCESS Process,
    IN  KPROCESSOR_MODE PreviousMode,
    OUT PEVENT_TABLE_ENTRY *ppEventTableEntry
    );

VOID
NpDeleteEventTableEntry (
    IN PEVENT_TABLE EventTable,
    IN PEVENT_TABLE_ENTRY Template
    );

// VOID
// NpSignalEventTableEntry (
//    IN PEVENT_TABLE_ENTRY EventTableEntry OPTIONAL
//    );
#define NpSignalEventTableEntry(_ete)                   \
    if (ARGUMENT_PRESENT(_ete)) {                       \
        KeSetEvent((PKEVENT)(_ete)->Event, 0, FALSE);   \
    }

PEVENT_TABLE_ENTRY
NpGetNextEventTableEntry (
    IN PEVENT_TABLE EventTable,
    IN PVOID *RestartKey
    );


//
//  The following routines are used to manipulate the fscontext fields of
//  a file object, implemented in FilObSup.c
//

VOID
NpSetFileObject (
    IN PFILE_OBJECT FileObject OPTIONAL,
    IN PVOID FsContext,
    IN PVOID FsContext2,
    IN NAMED_PIPE_END NamedPipeEnd
    );

NODE_TYPE_CODE
NpDecodeFileObject (
    IN PFILE_OBJECT FileObject,
    OUT PFCB *Fcb OPTIONAL,
    OUT PCCB *Ccb,
    OUT PNAMED_PIPE_END NamedPipeEnd OPTIONAL
    );


//
//  Largest matching prefix searching routines, implemented in PrefxSup.c
//

PFCB
NpFindPrefix (
    IN PUNICODE_STRING String,
    IN BOOLEAN CaseInsensitive,
    OUT PUNICODE_STRING RemainingPart
    );

NTSTATUS
NpFindRelativePrefix (
    IN PDCB Dcb,
    IN PUNICODE_STRING String,
    IN BOOLEAN CaseInsensitive,
    OUT PUNICODE_STRING RemainingPart,
    OUT PFCB *ppFcb
    );


//
//  Pipe name aliases, implemented in AliasSup.c
//

NTSTATUS
NpInitializeAliases (
    VOID
    );

VOID
NpUninitializeAliases (
    VOID
    );

NTSTATUS
NpTranslateAlias (
    IN OUT PUNICODE_STRING String
    );


//
//  The follow routine provides common read data queue support
//  for buffered read, unbuffered read, peek, and transceive
//

IO_STATUS_BLOCK
NpReadDataQueue (
    IN PDATA_QUEUE ReadQueue,
    IN BOOLEAN PeekOperation,
    IN BOOLEAN ReadOverflowOperation,
    IN PUCHAR ReadBuffer,
    IN ULONG ReadLength,
    IN READ_MODE ReadMode,
    IN PCCB Ccb,
    IN PLIST_ENTRY DeferredList
    );


//
//  The following routines are used for setting and manipulating the
//  security fields in the data entry, and nonpaged ccb, implemented in
//  SecurSup.c
//

NTSTATUS
NpInitializeSecurity (
    IN PCCB Ccb,
    IN PSECURITY_QUALITY_OF_SERVICE SecurityQos,
    IN PETHREAD UserThread
    );

VOID
NpUninitializeSecurity (
    IN PCCB Ccb
    );

NTSTATUS
NpGetClientSecurityContext (
    IN  NAMED_PIPE_END NamedPipeEnd,
    IN  PCCB Ccb,
    IN  PETHREAD UserThread,
    OUT PSECURITY_CLIENT_CONTEXT *ppSecurityContext
    );

VOID
NpFreeClientSecurityContext (
    IN PSECURITY_CLIENT_CONTEXT SecurityContext
    );

VOID
NpCopyClientContext (
    IN PCCB Ccb,
    IN PDATA_ENTRY DataEntry
    );

NTSTATUS
NpImpersonateClientContext (
    IN PCCB Ccb
    );


//
//  The following routines are used to manipulate the named pipe state
//  implemented in StateSup.c
//

VOID
NpInitializePipeState (
    IN PCCB Ccb,
    IN PFILE_OBJECT ServerFileObject
    );

VOID
NpUninitializePipeState (
    IN PCCB Ccb
    );

NTSTATUS
NpSetListeningPipeState (
    IN PCCB Ccb,
    IN PIRP Irp,
    IN PLIST_ENTRY DeferredList
    );

NTSTATUS
NpSetConnectedPipeState (
    IN PCCB Ccb,
    IN PFILE_OBJECT ClientFileObject,
    IN PLIST_ENTRY DeferredList
    );

NTSTATUS
NpSetClosingPipeState (
    IN PCCB Ccb,
    IN PIRP Irp,
    IN NAMED_PIPE_END NamedPipeEnd,
    IN PLIST_ENTRY DeferredList
    );

NTSTATUS
NpSetDisconnectedPipeState (
    IN PCCB Ccb,
    IN PLIST_ENTRY DeferredList
    );


//
//  Internal Named Pipe data Structure Routines, implemented in StrucSup.c.
//
//  These routines maniuplate the in memory data structures.
//

VOID
NpInitializeVcb (
    VOID
    );

VOID
NpDeleteVcb (
    IN PLIST_ENTRY DeferredList
    );

NTSTATUS
NpCreateRootDcb (
    VOID
    );

VOID
NpDeleteRootDcb (
    IN PROOT_DCB Dcb,
    IN PLIST_ENTRY DeferredList
    );

NTSTATUS
NpCreateFcb (
    IN  PDCB ParentDcb,
    IN  PUNICODE_STRING FileName,
    IN  ULONG MaximumInstances,
    IN  LARGE_INTEGER DefaultTimeOut,
    IN  NAMED_PIPE_CONFIGURATION NamedPipeConfiguration,
    IN  NAMED_PIPE_TYPE NamedPipeType,
    OUT PFCB *ppFcb
    );

VOID
NpDeleteFcb (
    IN PFCB Fcb,
    IN PLIST_ENTRY DeferredList
    );

NTSTATUS
NpCreateCcb (
    IN  PFCB Fcb,
    IN  PFILE_OBJECT ServerFileObject,
    IN  NAMED_PIPE_STATE NamedPipeState,
    IN  READ_MODE ServerReadMode,
    IN  COMPLETION_MODE ServerCompletionMode,
    IN  ULONG InBoundQuota,
    IN  ULONG OutBoundQuota,
    OUT PCCB *ppCcb
    );

NTSTATUS
NpCreateRootDcbCcb (
    OUT PROOT_DCB_CCB *ppCcb
    );

VOID
NpDeleteCcb (
    IN PCCB Ccb,
    IN PLIST_ENTRY DeferredList
    );


//
//  Waiting for a named pipe support routines, implemented in WaitSup.c
//

VOID
NpInitializeWaitQueue (
    IN PWAIT_QUEUE WaitQueue
    );

VOID
NpUninitializeWaitQueue (
    IN PWAIT_QUEUE WaitQueue
    );

NTSTATUS
NpAddWaiter (
    IN PWAIT_QUEUE WaitQueue,
    IN LARGE_INTEGER DefaultTimeOut,
    IN PIRP Irp,
    IN PUNICODE_STRING TranslatedString
    );

NTSTATUS
NpCancelWaiter (
    IN PWAIT_QUEUE WaitQueue,
    IN PUNICODE_STRING NameOfPipe,
    IN NTSTATUS CompletionStatus,
    IN PLIST_ENTRY DeferredList
    );


//
//  The follow routine provides common write data queue support
//  for buffered write, unbuffered write, peek, and transceive
//

NTSTATUS
NpWriteDataQueue (                      // implemented in WriteSup.c
    IN PDATA_QUEUE WriteQueue,
    IN READ_MODE ReadMode,
    IN PUCHAR WriteBuffer,
    IN ULONG WriteLength,
    IN NAMED_PIPE_TYPE PipeType,
    OUT PULONG WriteRemaining,
    IN PCCB Ccb,
    IN NAMED_PIPE_END NamedPipeEnd,
    IN PETHREAD UserThread,
    IN PLIST_ENTRY DeferredList
    );


//
//  Miscellaneous support routines
//

#define BooleanFlagOn(F,SF) (    \
    (BOOLEAN)(((F) & (SF)) != 0) \
)

//
//  This macro takes a pointer (or ulong) and returns its rounded up word
//  value
//

#define WordAlign(Ptr) (                \
    ((((ULONG)(Ptr)) + 1) & 0xfffffffe) \
    )

//
//  This macro takes a pointer (or ulong) and returns its rounded up longword
//  value
//

#define LongAlign(Ptr) (                \
    ((((ULONG)(Ptr)) + 3) & 0xfffffffc) \
    )

//
//  This macro takes a pointer (or ulong) and returns its rounded up quadword
//  value
//

#define QuadAlign(Ptr) (                \
    ((((ULONG)(Ptr)) + 7) & 0xfffffff8) \
    )

//
//  The following types and macros are used to help unpack the packed and
//  misaligned fields found in the Bios parameter block
//

typedef union _UCHAR1 {
    UCHAR  Uchar[1];
    UCHAR  ForceAlignment;
} UCHAR1, *PUCHAR1;

typedef union _UCHAR2 {
    UCHAR  Uchar[2];
    USHORT ForceAlignment;
} UCHAR2, *PUCHAR2;

typedef union _UCHAR4 {
    UCHAR  Uchar[4];
    ULONG  ForceAlignment;
} UCHAR4, *PUCHAR4;

//
//  This macro copies an unaligned src byte to an aligned dst byte
//

#define CopyUchar1(Dst,Src) {                                \
    *((UCHAR1 *)(Dst)) = *((UNALIGNED UCHAR1 *)(Src)); \
    }

//
//  This macro copies an unaligned src word to an aligned dst word
//

#define CopyUchar2(Dst,Src) {                                \
    *((UCHAR2 *)(Dst)) = *((UNALIGNED UCHAR2 *)(Src)); \
    }

//
//  This macro copies an unaligned src longword to an aligned dsr longword
//

#define CopyUchar4(Dst,Src) {                                \
    *((UCHAR4 *)(Dst)) = *((UNALIGNED UCHAR4 *)(Src)); \
    }


//
//  VOID
//  NpAcquireExclusiveVcb (
//      );
//
//  VOID
//  NpAcquireSharedVcb (
//      );
//
//  VOID
//  NpReleaseVcb (
//      );
//

#define NpAcquireExclusiveVcb() (VOID)ExAcquireResourceExclusiveLite( &NpVcb->Resource, TRUE )

#define NpAcquireSharedVcb()    (VOID)ExAcquireResourceSharedLite( &NpVcb->Resource, TRUE )

#define NpReleaseVcb()          ExReleaseResourceLite( &NpVcb->Resource )

#define NpAcquireExclusiveCcb(Ccb) ExAcquireResourceExclusiveLite(&Ccb->NonpagedCcb->Resource,TRUE);
#define NpReleaseCcb(Ccb) ExReleaseResourceLite(&Ccb->NonpagedCcb->Resource);

#define NpIsAcquiredExclusiveVcb(VCB) ExIsResourceAcquiredExclusiveLite( &(VCB)->Resource )


//
//  The FSD Level dispatch routines.   These routines are called by the
//  I/O system via the dispatch table in the Driver Object.
//
//  They each accept as input a pointer to a device object (actually most
//  expect an npfs device object), and a pointer to the IRP.
//

NTSTATUS
NpFsdCreate (                           //  implemented in Create.c
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
NpFsdCreateNamedPipe (                  //  implemented in CreateNp.c
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
NpFsdClose (                            //  implemented in Close.c
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
NpFsdRead (                             //  implemented in Read.c
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
NpFsdWrite (                            //  implemented in Write.c
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
NpFsdQueryInformation (                 //  implemented in FileInfo.c
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
NpFsdSetInformation (                   //  implemented in FileInfo.c
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
NpFsdCleanup (                          //  implemented in Cleanup.c
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
NpFsdFlushBuffers (                     //  implemented in Flush.c
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
NpFsdDirectoryControl (                 //  implemented in Dir.c
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
NpFsdFileSystemControl (                //  implemented in FsContrl.c
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
NpFsdSetSecurityInfo (                  //  implemented in SeInfo.c
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
NpFsdQuerySecurityInfo (                //  implemented in SeInfo.c
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
NpFsdQueryVolumeInformation (           //  implemented in VolInfo.c
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    );


NTSTATUS
NpCommonFileSystemControl (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
NpAssignEvent (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
NpDisconnect (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp,
    IN PLIST_ENTRY DeferredList
    );

NTSTATUS
NpListen (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp,
    IN PLIST_ENTRY DeferredList
    );

NTSTATUS
NpPeek (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp,
    IN PLIST_ENTRY DeferredList
    );

NTSTATUS
NpQueryEvent (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
NpTransceive (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp,
    IN PLIST_ENTRY DeferredList
    );

NTSTATUS
NpWaitForNamedPipe (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
NpImpersonate (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
NpInternalRead (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp,
    IN BOOLEAN ReadOverflowOperation,
    IN PLIST_ENTRY DeferredList
    );

NTSTATUS
NpInternalWrite (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp,
    IN PLIST_ENTRY DeferredList
    );

NTSTATUS
NpInternalTransceive (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp,
    IN PLIST_ENTRY DeferredList
    );

NTSTATUS
NpQueryClientProcess (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
NpSetClientProcess (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
NpCompleteTransceiveIrp (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );


//
//  The following procedures are callbacks used to do fast I/O
//

BOOLEAN
NpFastRead (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
NpFastWrite (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
NpCommonWrite (
    IN PFILE_OBJECT FileObject,
    IN PVOID WriteBuffer,
    IN ULONG WriteLength,
    IN PETHREAD UserThread,
    OUT PIO_STATUS_BLOCK Iosb,
    IN PIRP Irp OPTIONAL,
    IN PLIST_ENTRY DeferredList
    );


//
// Miscellaneous routines.
//

VOID
NpCheckForNotify (                      //  implemented in Dir.c
    IN PDCB Dcb,
    IN BOOLEAN CheckAllOutstandingIrps,
    IN PLIST_ENTRY DeferredList
    );

NTSTATUS
NpCommonQueryInformation (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    );


NTSTATUS
NpCommonSetInformation (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp,
    IN PLIST_ENTRY DeferredList
    );

NTSTATUS
NpQueryBasicInfo (
    IN PCCB Ccb,
    IN PFILE_BASIC_INFORMATION Buffer,
    IN OUT PULONG Length
    );

NTSTATUS
NpQueryStandardInfo (
    IN PCCB Ccb,
    IN PFILE_STANDARD_INFORMATION Buffer,
    IN OUT PULONG Length,
    IN NAMED_PIPE_END NamedPipeEnd
    );

NTSTATUS
NpQueryInternalInfo (
    IN PCCB Ccb,
    IN PFILE_INTERNAL_INFORMATION Buffer,
    IN OUT PULONG Length
    );

NTSTATUS
NpQueryEaInfo (
    IN PCCB Ccb,
    IN PFILE_EA_INFORMATION Buffer,
    IN OUT PULONG Length
    );

NTSTATUS
NpQueryNameInfo (
    IN PCCB Ccb,
    IN PFILE_NAME_INFORMATION Buffer,
    IN OUT PULONG Length
    );

NTSTATUS
NpQueryPositionInfo (
    IN PCCB Ccb,
    IN PFILE_POSITION_INFORMATION Buffer,
    IN OUT PULONG Length,
    IN NAMED_PIPE_END NamedPipeEnd
    );

NTSTATUS
NpQueryPipeInfo (
    IN PFCB Fcb,
    IN PCCB Ccb,
    IN PFILE_PIPE_INFORMATION Buffer,
    IN OUT PULONG Length,
    IN NAMED_PIPE_END NamedPipeEnd
    );

NTSTATUS
NpQueryPipeLocalInfo (
    IN PFCB Fcb,
    IN PCCB Ccb,
    IN PFILE_PIPE_LOCAL_INFORMATION Buffer,
    IN OUT PULONG Length,
    IN NAMED_PIPE_END NamedPipeEnd
    );

NTSTATUS
NpSetBasicInfo (
    IN PCCB Ccb,
    IN PFILE_BASIC_INFORMATION Buffer
    );

NTSTATUS
NpSetPipeInfo (
    IN PFCB Fcb,
    IN PCCB Ccb,
    IN PFILE_PIPE_INFORMATION Buffer,
    IN NAMED_PIPE_END NamedPipeEnd,
    IN PLIST_ENTRY DeferredList
    );

NTSTATUS
NpCommonCreate (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    );

IO_STATUS_BLOCK
NpCreateClientEnd(
    IN PFCB Fcb,
    IN PFILE_OBJECT FileObject,
    IN ACCESS_MASK DesiredAccess,
    IN USHORT ShareAccess,
    IN PSECURITY_QUALITY_OF_SERVICE SecurityQos,
    IN PACCESS_STATE AccessState,
    IN KPROCESSOR_MODE RequestorMode,
    IN PETHREAD UserThread,
    IN PLIST_ENTRY DeferredList
    );

IO_STATUS_BLOCK
NpOpenNamedPipeFileSystem (
    IN PFILE_OBJECT FileObject,
    IN ACCESS_MASK DesiredAccess,
    IN USHORT ShareAccess
    );

IO_STATUS_BLOCK
NpOpenNamedPipeRootDirectory (
    IN PROOT_DCB RootDcb,
    IN PFILE_OBJECT FileObject,
    IN ACCESS_MASK DesiredAccess,
    IN USHORT ShareAccess,
    IN PLIST_ENTRY DeferredList
    );

NTSTATUS
NpCommonCreateNamedPipe (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    );

IO_STATUS_BLOCK
NpCreateNewNamedPipe (
    IN PROOT_DCB RootDcb,
    IN PFILE_OBJECT FileObject,
    IN UNICODE_STRING FileName,
    IN ACCESS_MASK DesiredAccess,
    IN PACCESS_STATE AccessState,
    IN ULONG CreateDisposition,
    IN USHORT ShareAccess,
    IN NAMED_PIPE_TYPE NamedPipeType,
    IN READ_MODE ServerReadMode,
    IN COMPLETION_MODE ServerCompletionMode,
    IN ULONG MaximumInstances,
    IN ULONG InboundQuota,
    IN ULONG OutboundQuota,
    IN LARGE_INTEGER DefaultTimeout,
    IN BOOLEAN TimeoutSpecified,
    IN PEPROCESS CreatorProcess,
    IN PLIST_ENTRY DeferredList
    );

IO_STATUS_BLOCK
NpCreateExistingNamedPipe (
    IN PFCB Fcb,
    IN PFILE_OBJECT FileObject,
    IN ACCESS_MASK DesiredAccess,
    IN PACCESS_STATE AccessState,
    IN KPROCESSOR_MODE RequestorMode,
    IN ULONG CreateDisposition,
    IN USHORT ShareAccess,
    IN READ_MODE ServerReadMode,
    IN COMPLETION_MODE ServerCompletionMode,
    IN ULONG InboundQuota,
    IN ULONG OutboundQuota,
    IN PEPROCESS CreatorProcess,
    IN PLIST_ENTRY DeferredList
    );

NTSTATUS
NpCommonDirectoryControl (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    );

NTSTATUS
NpQueryDirectory (
    IN PROOT_DCB RootDcb,
    IN PROOT_DCB_CCB Ccb,
    IN PIRP Irp
    );

NTSTATUS
NpNotifyChangeDirectory (
    IN PROOT_DCB RootDcb,
    IN PROOT_DCB_CCB Ccb,
    IN PIRP Irp
    );

VOID
NpCancelChangeNotifyIrp (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
NpTimerDispatch(
    IN PKDPC Dpc,
    IN PVOID Contxt,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

VOID
NpCancelWaitQueueIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );



//
//  The following macro is used by the FSD routines to complete
//  an IRP.
//

#define NpCompleteRequest(IRP,STATUS) FsRtlCompleteRequest( (IRP), (STATUS) );

#define NpDeferredCompleteRequest(IRP,STATUS,LIST) {           \
    (IRP)->IoStatus.Status = STATUS;                           \
    InsertTailList ((LIST), &(IRP)->Tail.Overlay.ListEntry);   \
}
    
VOID
FORCEINLINE
NpCompleteDeferredIrps (
    IN PLIST_ENTRY DeferredList
    )
{
    PIRP Irp;
    PLIST_ENTRY Entry, NextEntry;

    Entry = DeferredList->Flink;
    while (Entry != DeferredList) {
        Irp = CONTAINING_RECORD (Entry, IRP, Tail.Overlay.ListEntry);
        NextEntry = Entry->Flink;
        NpCompleteRequest (Irp, Irp->IoStatus.Status);
        Entry = NextEntry;
    }
}


//
//  The following macros are used to establish the semantics needed
//  to do a return from within a try-finally clause.  As a rule every
//  try clause must end with a label call try_exit.  For example,
//
//      try {
//              :
//              :
//
//      try_exit: NOTHING;
//      } finally {
//
//              :
//              :
//      }
//
//  Every return statement executed inside of a try clause should use the
//  try_return macro.  If the compiler fully supports the try-finally construct
//  then the macro should be
//
//      #define try_return(S)  { return(S); }
//
//  If the compiler does not support the try-finally construct then the macro
//  should be
//
//      #define try_return(S)  { S; goto try_exit; }
//

#define try_return(S) { S; goto try_exit; }

//
// PVOID
// NpAllocatePagedPool (
//     IN ULONG Size,
//     IN ULONG Tag)
// Routine Description:
//
//     This routine will return a pointer to paged pool or NULL if no memory exists.
//
// Arguments:
//
//     Size - Size of memory to allocate
//     Tag  - Tag to use for the pool allocation
//
// Return Value:
//
//    PVOID - pointer to allocated memory or null
//
#define NpAllocatePagedPool( Size, Tag) \
    ExAllocatePoolWithTag( PagedPool, Size, Tag )

//
// PVOID
// NpAllocateNonPagedPool (
//     IN ULONG Size,
//     IN ULONG Tag)
// Routine Description:
//
//     This routine will return a pointer to paged pool or NULL if no memory exists.
//
// Arguments:
//
//     Size - Size of memory to allocate
//     Tag  - Tag to use for the pool allocation
//
// Return Value:
//
//    PVOID - pointer to allocated memory or null
//
#define NpAllocateNonPagedPool( Size, Tag) \
    ExAllocatePoolWithTag( NonPagedPool, Size, Tag )

//
// PVOID
// NpAllocatePagedPoolWithQuota (
//     IN ULONG Size,
//     IN ULONG Tag)
// Routine Description:
//
//     This routine will return a pointer to charged paged pool or NULL if no memory exists.
//
// Arguments:
//
//     Size - Size of memory to allocate
//     Tag  - Tag to use for the pool allocation
//
// Return Value:
//
//    PVOID - pointer to allocated memory or null
//
#define NpAllocatePagedPoolWithQuota( Size, Tag) \
    ExAllocatePoolWithQuotaTag( PagedPool|POOL_QUOTA_FAIL_INSTEAD_OF_RAISE, Size, Tag )

#define NpAllocatePagedPoolWithQuotaCold( Size, Tag) \
    ExAllocatePoolWithQuotaTag( PagedPool|POOL_QUOTA_FAIL_INSTEAD_OF_RAISE|POOL_COLD_ALLOCATION, Size, Tag )

//
// PVOID
// NpAllocateNonPagedPoolWithQuota (
//     IN ULONG Size,
//     IN ULONG Tag)
// Routine Description:
//
//     This routine will return a charged pointer to non-paged pool or NULL if no memory exists.
//
// Arguments:
//
//     Size - Size of memory to allocate
//     Tag  - Tag to use for the pool allocation
//
// Return Value:
//
//    PVOID - pointer to allocated memory or null
//
#define NpAllocateNonPagedPoolWithQuota( Size, Tag) \
    ExAllocatePoolWithQuotaTag( NonPagedPool|POOL_QUOTA_FAIL_INSTEAD_OF_RAISE, Size, Tag )


//
// VOID
// NpFreePool (
//    IN PVOID Mem)
//
// Routine Description:
//
//
//
// Arguments:
//
//     Mem - Memory to be freed
//
// Return Value:
//
//    None
//
#define NpFreePool(Mem) ExFreePool (Mem)

#define NpIrpWaitQueue(Irp) (Irp->Tail.Overlay.DriverContext[0])

#define NpIrpWaitContext(Irp) (Irp->Tail.Overlay.DriverContext[1])

#define NpIrpDataQueue(Irp) (Irp->Tail.Overlay.DriverContext[2])

#define NpIrpDataEntry(Irp) (Irp->Tail.Overlay.DriverContext[3])

#define NpConvertFsctlToWrite(Irp) (Irp->Flags &= ~IRP_INPUT_OPERATION)

#endif // _NPPROCS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\npfs\prefxsup.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    PrefxSup.c

Abstract:

    This module implements the Named Pipe Prefix support routines

Author:

    Gary Kimura     [GaryKi]    13-Feb-1990

Revision History:

--*/

#include "NpProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (NPFS_BUG_CHECK_PREFXSUP)

//
//  The debug trace level for this module
//

#define Dbg                              (DEBUG_TRACE_PREFXSUP)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NpFindPrefix)
#pragma alloc_text(PAGE, NpFindRelativePrefix)
#endif


PFCB
NpFindPrefix (
    IN PUNICODE_STRING String,
    IN BOOLEAN CaseInsensitive,
    OUT PUNICODE_STRING RemainingPart
    )

/*++

Routine Description:

    This routine searches the FCBs/DCBs of a volume and locates the
    FCB/DCB with longest matching prefix for the given input string.  The
    search is relative to the root of the volume.  So all names must start
    with a "\".

Arguments:

    String - Supplies the input string to search for

    CaseInsensitive - Specifies if the search is to be done case sensitive
        (FALSE) or insensitive (TRUE)

    RemainingPart - Returns the string when the prefix no longer matches.
        For example, if the input string is "\alpha\beta" only matches the
        root directory then the remaining string is "alpha\beta".  If the
        same string matches a DCB for "\alpha" then the remaining string is
        "beta".

Return Value:

    PFCB - Returns a pointer to either an FCB or a DCB whichever is the
        longest matching prefix.

--*/

{
    PUNICODE_PREFIX_TABLE_ENTRY PrefixTableEntry;
    PFCB Fcb;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "NpFindPrefix, NpVcb = %08lx\n", NpVcb);
    DebugTrace( 0, Dbg, "  String = %Z\n", String);

    //
    //  Find the longest matching prefix
    //

    PrefixTableEntry = RtlFindUnicodePrefix( &NpVcb->PrefixTable,
                                             String,
                                             CaseInsensitive );

    //
    //  If we didn't find one then it's an error
    //

    if (PrefixTableEntry == NULL) {

        DebugDump("Error looking up a prefix", 0, NpVcb);
        NpBugCheck( 0, 0, 0 );
    }

    //
    //  Get a pointer to the Fcb containing the prefix table entry
    //

    Fcb = CONTAINING_RECORD( PrefixTableEntry, FCB, PrefixTableEntry );

    //
    //  Tell the caller how many characters we were able to match.  We first
    //  set the remaining part to the original string minus the matched
    //  prefix, then we check if the remaining part starts with a backslash
    //  and if it does then we remove the backslash from the remaining string.
    //

    RemainingPart->Length = String->Length - Fcb->FullFileName.Length;
    RemainingPart->MaximumLength = RemainingPart->Length;
    RemainingPart->Buffer = &String->Buffer[ Fcb->FullFileName.Length/sizeof(WCHAR) ];

    if ((RemainingPart->Length > 0) &&
        (RemainingPart->Buffer[0] == L'\\')) {

        RemainingPart->Length -= sizeof(WCHAR);
        RemainingPart->MaximumLength -= sizeof(WCHAR);
        RemainingPart->Buffer += 1;
    }

    DebugTrace(0, Dbg, "RemainingPart set to %Z\n", RemainingPart);

    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "NpFindPrefix -> %08lx\n", Fcb);

    return Fcb;
}


NTSTATUS
NpFindRelativePrefix (
    IN PDCB Dcb,
    IN PUNICODE_STRING String,
    IN BOOLEAN CaseInsensitive,
    OUT PUNICODE_STRING RemainingPart,
    OUT PFCB *ppFcb
    )

/*++

Routine Description:

    This routine searches the FCBs/DCBs of a volume and locates the
    FCB/DCB with longest matching prefix for the given input string.  The
    search is relative to a input DCB, and must not start with a leading "\"
    All searching is done case insensitive.

Arguments:

    Dcb - Supplies the Dcb to start searching from

    String - Supplies the input string to search for

    CaseInsensitive - Specifies if the search is to be done case sensitive
        (FALSE) or insensitive (TRUE)

    RemainingPart - Returns the index into the string when the prefix no
        longer matches.  For example, if the input string is "beta\gamma"
        and the input Dcb is for "\alpha" and we only match beta then
        the remaining string is "gamma".

Return Value:

    PFCB - Returns a pointer to either an FCB or a DCB whichever is the
        longest matching prefix.

--*/

{
    USHORT NameLength, MaxLength;
    PWCH Name;

    UNICODE_STRING FullString;
    PWCH Temp;

    PFCB Fcb;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "NpFindRelativePrefix, Dcb = %08lx\n", Dcb);
    DebugTrace( 0, Dbg, "String = %08lx\n", String);


    //
    //  We first need to build the complete name and then do a relative
    //  search from the root
    //

    NameLength = String->Length;
    MaxLength  = NameLength + 2*sizeof(WCHAR);

    if (MaxLength < NameLength) {
        return STATUS_INVALID_PARAMETER;
    }

    Name       = String->Buffer;

    ASSERT(NodeType(Dcb) == NPFS_NTC_ROOT_DCB);

    Temp = NpAllocatePagedPoolWithQuota( MaxLength, 'nFpN' );
    if (Temp == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    Temp[0] = L'\\';
    RtlCopyMemory( &Temp[1], Name, NameLength );
    Temp[NameLength/sizeof(WCHAR) + 1] = L'\0';

    FullString.Buffer = Temp;
    FullString.Length = NameLength + sizeof(WCHAR);
    FullString.MaximumLength = MaxLength;

    //
    //  Find the prefix relative to the volume
    //

    Fcb = NpFindPrefix( &FullString,
                        CaseInsensitive,
                        RemainingPart );

    NpFreePool (Temp);
    //
    //  Now adjust the remaining part to take care of the relative
    //  volume prefix.
    //

    RemainingPart->Buffer = &String->Buffer[(String->Length -
                                             RemainingPart->Length) / sizeof(WCHAR)];

    DebugTrace(0, Dbg, "RemainingPart set to %Z\n", RemainingPart);

    *ppFcb = Fcb;
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\npfs\read.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    Read.c

Abstract:

    This module implements the File Read routine for NPFS called by the
    dispatch driver.

Author:

    Gary Kimura     [GaryKi]    21-Aug-1990

Revision History:

--*/

#include "NpProcs.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_READ)

#if DBG
ULONG NpFastReadTrue = 0;
ULONG NpFastReadFalse = 0;
ULONG NpSlowReadCalls = 0;
#endif

//
//  local procedure prototypes
//

BOOLEAN
NpCommonRead (
    IN PFILE_OBJECT FileObject,
    OUT PVOID ReadBuffer,
    IN ULONG ReadLength,
    OUT PIO_STATUS_BLOCK Iosb,
    IN PIRP Irp OPTIONAL,
    IN PLIST_ENTRY DeferredList
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NpCommonRead)
#pragma alloc_text(PAGE, NpFastRead)
#pragma alloc_text(PAGE, NpFsdRead)
#endif


NTSTATUS
NpFsdRead (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the FSD part of the NtReadFile API calls.

Arguments:

    NpfsDeviceObject - Supplies the device object to use.

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The Fsd status for the Irp

--*/

{
    IO_STATUS_BLOCK Iosb;
    PIO_STACK_LOCATION IrpSp;
    LIST_ENTRY DeferredList;

    DebugTrace(+1, Dbg, "NpFsdRead\n", 0);
    DbgDoit( NpSlowReadCalls += 1 );

    PAGED_CODE();

    InitializeListHead (&DeferredList);

    IrpSp = IoGetCurrentIrpStackLocation (Irp);

    FsRtlEnterFileSystem ();

    NpAcquireSharedVcb ();

    (VOID) NpCommonRead (IrpSp->FileObject,
                         Irp->UserBuffer,
                         IrpSp->Parameters.Read.Length,
                         &Iosb,
                         Irp,
                         &DeferredList);

    NpReleaseVcb ();

    NpCompleteDeferredIrps (&DeferredList);

    FsRtlExitFileSystem ();

    if (Iosb.Status != STATUS_PENDING) {
        Irp->IoStatus.Information = Iosb.Information;
        NpCompleteRequest (Irp, Iosb.Status);
    }
    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "NpFsdRead -> %08lx\n", Iosb.Status );

    return Iosb.Status;
}


BOOLEAN
NpFastRead (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine does a fast read bypassing the usual file system
    entry routine (i.e., without the Irp).

Arguments:

    FileObject - Pointer to the file object being read.

    FileOffset - Byte offset in file for desired data.

    Length - Length of desired data in bytes.

    Wait - FALSE if caller may not block, TRUE otherwise

    LockKey - Supplies the Key used to use if the byte range being read is locked.

    Buffer - Pointer to output buffer to which data should be copied.

    IoStatus - Pointer to standard I/O status block to receive the status
               for the transfer.

Return Value:

    BOOLEAN - TRUE if the operation completed successfully and FALSE if the
        caller needs to take the long IRP based route.

--*/

{
    BOOLEAN Results = FALSE;
    LIST_ENTRY DeferredList;

    UNREFERENCED_PARAMETER (FileOffset);
    UNREFERENCED_PARAMETER (Wait);
    UNREFERENCED_PARAMETER (LockKey);
    UNREFERENCED_PARAMETER (DeviceObject);

    PAGED_CODE();

    InitializeListHead (&DeferredList);

    FsRtlEnterFileSystem ();

    NpAcquireSharedVcb ();

    Results =  NpCommonRead (FileObject,
                             Buffer,
                             Length,
                             IoStatus,
                             NULL,
                             &DeferredList);
#if DBG
    if (Results) {
        NpFastReadTrue += 1;
    } else {
        NpFastReadFalse += 1;
    }
#endif

    NpReleaseVcb ();

    NpCompleteDeferredIrps (&DeferredList);

    FsRtlExitFileSystem ();
    return Results;
}


//
//  Internal support routine
//

BOOLEAN
NpCommonRead (
    IN PFILE_OBJECT FileObject,
    OUT PVOID ReadBuffer,
    IN ULONG ReadLength,
    OUT PIO_STATUS_BLOCK Iosb,
    IN PIRP Irp OPTIONAL,
    IN PLIST_ENTRY DeferredList
    )

/*++

Routine Description:

    This is the common routine for reading a named pipe both via the fast
    path and with an Irp

Arguments:

    FileObject - Supplies the file object used in this operation

    ReadBuffer - Supplies the buffer where data is to be written

    ReadLength - Supplies the length of read buffer in bytes

    Iosb - Receives the final completion status of this operation

    Irp - Optionally supplies an Irp to be used in this operation

    DeferredList - List of IRP's to be completed after we drop the locks

Return Value:

    BOOLEAN - TRUE if the operation was successful and FALSE if the caller
        needs to take the longer Irp based route.

--*/

{
    NODE_TYPE_CODE NodeTypeCode;
    PCCB Ccb;
    PNONPAGED_CCB NonpagedCcb;
    NAMED_PIPE_END NamedPipeEnd;

    NAMED_PIPE_CONFIGURATION NamedPipeConfiguration;

    ULONG ReadRemaining;
    READ_MODE ReadMode;
    COMPLETION_MODE CompletionMode;
    PDATA_QUEUE ReadQueue;
    PEVENT_TABLE_ENTRY Event;
    BOOLEAN Status;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "NpCommonRead\n", 0);
    DebugTrace( 0, Dbg, "FileObject = %08lx\n", FileObject);
    DebugTrace( 0, Dbg, "ReadBuffer = %08lx\n", ReadBuffer);
    DebugTrace( 0, Dbg, "ReadLength = %08lx\n", ReadLength);
    DebugTrace( 0, Dbg, "Iosb       = %08lx\n", Iosb);
    DebugTrace( 0, Dbg, "Irp        = %08lx\n", Irp);

    Iosb->Information = 0;

    //
    //  Get the Ccb and figure out who we are, and make sure we're not
    //  disconnected
    //

    if ((NodeTypeCode = NpDecodeFileObject( FileObject,
                                            NULL,
                                            &Ccb,
                                            &NamedPipeEnd )) == NTC_UNDEFINED) {

        DebugTrace(0, Dbg, "Pipe is disconnected from us\n", 0);

        Iosb->Status = STATUS_PIPE_DISCONNECTED;

        return TRUE;
    }

    //
    //  Now we only will allow Read operations on the pipe and not a directory
    //  or the device
    //

    if (NodeTypeCode != NPFS_NTC_CCB) {

        DebugTrace(0, Dbg, "FileObject is not for a named pipe\n", 0);

        Iosb->Status = STATUS_INVALID_PARAMETER;

        return TRUE;
    }

    NpAcquireExclusiveCcb(Ccb);

    NonpagedCcb = Ccb->NonpagedCcb;

    try {
        //
        //  Check if the pipe is not in the connected state.
        //

        if ((Ccb->NamedPipeState == FILE_PIPE_DISCONNECTED_STATE) ||
            (Ccb->NamedPipeState == FILE_PIPE_LISTENING_STATE)) {

            DebugTrace(0, Dbg, "Pipe in disconnected or listening state\n", 0);

            if (Ccb->NamedPipeState == FILE_PIPE_DISCONNECTED_STATE) {

                Iosb->Status = STATUS_PIPE_DISCONNECTED;

            } else {

                Iosb->Status = STATUS_PIPE_LISTENING;
            }

            try_return(Status = TRUE);
        }

        ASSERT((Ccb->NamedPipeState == FILE_PIPE_CONNECTED_STATE) ||
               (Ccb->NamedPipeState == FILE_PIPE_CLOSING_STATE));

        //
        //  We only allow a read by the server on a non outbound only pipe
        //  and by the client on a non inbound only pipe
        //

        NamedPipeConfiguration = Ccb->Fcb->Specific.Fcb.NamedPipeConfiguration;

        if (((NamedPipeEnd == FILE_PIPE_SERVER_END) &&
             (NamedPipeConfiguration == FILE_PIPE_OUTBOUND))

                ||

            ((NamedPipeEnd == FILE_PIPE_CLIENT_END) &&
             (NamedPipeConfiguration == FILE_PIPE_INBOUND))) {

            DebugTrace(0, Dbg, "Trying to read to the wrong pipe configuration\n", 0);

            Iosb->Status = STATUS_INVALID_PARAMETER;

            try_return (Status = TRUE);
        }

        //
        //  Reference our input parameters to make things easier, and
        //  initialize our main variables that describe the Read command
        //

        ReadRemaining  = ReadLength;
        ReadMode       = Ccb->ReadCompletionMode[ NamedPipeEnd ].ReadMode;
        CompletionMode = Ccb->ReadCompletionMode[ NamedPipeEnd ].CompletionMode;

        //
        //  Now the data queue that we read from into and the event that we signal
        //  are based on the named pipe end.  The server read from the inbound
        //  queue and signals the client event.  The client does just the
        //  opposite.
        //

        if (NamedPipeEnd == FILE_PIPE_SERVER_END) {

            ReadQueue = &Ccb->DataQueue[ FILE_PIPE_INBOUND ];

            Event = NonpagedCcb->EventTableEntry[ FILE_PIPE_CLIENT_END ];

        } else {

            ReadQueue = &Ccb->DataQueue[ FILE_PIPE_OUTBOUND ];

            Event = NonpagedCcb->EventTableEntry[ FILE_PIPE_SERVER_END ];
        }

        DebugTrace(0, Dbg, "ReadBuffer     = %08lx\n", ReadBuffer);
        DebugTrace(0, Dbg, "ReadLength     = %08lx\n", ReadLength);
        DebugTrace(0, Dbg, "ReadMode       = %08lx\n", ReadMode);
        DebugTrace(0, Dbg, "CompletionMode = %08lx\n", CompletionMode);
        DebugTrace(0, Dbg, "ReadQueue      = %08lx\n", ReadQueue);
        DebugTrace(0, Dbg, "Event          = %08lx\n", Event);

        //
        //  if the read queue does not contain any write entries
        //  then we either need to enqueue this operation or
        //  fail immediately
        //

        if (!NpIsDataQueueWriters( ReadQueue )) {

            //
            //  Check if the other end of the pipe is closing, and if
            //  so then we complete it with end of file.
            //  Otherwise check to see if we should enqueue the irp
            //  or complete the operation and tell the user the pipe is empty.
            //

            if (Ccb->NamedPipeState == FILE_PIPE_CLOSING_STATE) {

                DebugTrace(0, Dbg, "Complete the irp with eof\n", 0);

                Iosb->Status = STATUS_PIPE_BROKEN;

            } else if (CompletionMode == FILE_PIPE_QUEUE_OPERATION) {

                if (!ARGUMENT_PRESENT(Irp)) {

                    DebugTrace(0, Dbg, "Need to supply Irp\n", 0);

                    try_return(Status = FALSE);
                }

                DebugTrace(0, Dbg, "Put the irp into the read queue\n", 0);

                Iosb->Status = NpAddDataQueueEntry( NamedPipeEnd,
                                                    Ccb,
                                                    ReadQueue,
                                                    ReadEntries,
                                                    Buffered,
                                                    ReadLength,
                                                    Irp,
                                                    NULL,
                                                    0 );

                if (!NT_SUCCESS (Iosb->Status)) {
                    try_return(Status = FALSE);
                }


            } else {

                DebugTrace(0, Dbg, "Complete the irp with pipe empty\n", 0);

                Iosb->Status = STATUS_PIPE_EMPTY;
            }

        } else {

            //
            //  otherwise there we have a read irp against a read queue
            //  that contains one or more write entries.
            //

            *Iosb = NpReadDataQueue( ReadQueue,
                                     FALSE,
                                     FALSE,
                                     ReadBuffer,
                                     ReadLength,
                                     ReadMode,
                                     Ccb,
                                     DeferredList );

            if (!NT_SUCCESS (Iosb->Status)) {
                try_return(Status = TRUE);
            }
        }

        Status = TRUE;

        //
        //  And because we've done something we need to signal the
        //  other ends event
        //

        NpSignalEventTableEntry( Event );


        try_exit: NOTHING;
    } finally {
        NpReleaseCcb(Ccb);
    }


    DebugTrace(-1, Dbg, "NpCommonRead -> TRUE\n", 0);
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\npfs\npinit.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    NpInit.c

Abstract:

    This module implements the DRIVER_INITIALIZATION routine for the Named
    Pipe file system.

Author:

    Gary Kimura     [GaryKi]    21-Aug-1990


Revision History:

    Neill Clift     [NeillC]	22-Jan-2000
    Major rework, Don't raise exceptions, fix lots of error handling, Sort out cancel logic etc, fix validation.

--*/


#include "NpProcs.h"
//#include <zwapi.h>

VOID
NpfsUnload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

PNPFS_DEVICE_OBJECT NpfsDeviceObject = NULL;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,DriverEntry)
#pragma alloc_text(PAGE,NpfsUnload)
#endif


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This is the initialization routine for the Named Pipe file system
    device driver.  This routine creates the device object for the named pipe
    device and performs all other driver initialization.

Arguments:

    DriverObject - Pointer to driver object created by the system.

Return Value:

    NTSTATUS - The function value is the final status from the initialization
        operation.

--*/

{
    NTSTATUS Status;
    UNICODE_STRING NameString;
    PDEVICE_OBJECT DeviceObject;

    PAGED_CODE();

    //
    //  Create the alias lists.
    //

    Status = NpInitializeAliases( );
    if (!NT_SUCCESS( Status )) {
        return Status;
    }

    //
    //  Create the device object.
    //

    RtlInitUnicodeString( &NameString, L"\\Device\\NamedPipe" );

    Status = IoCreateDevice( DriverObject,
                             sizeof(NPFS_DEVICE_OBJECT)-sizeof(DEVICE_OBJECT),
                             &NameString,
                             FILE_DEVICE_NAMED_PIPE,
                             0,
                             FALSE,
                             &DeviceObject );

    if (!NT_SUCCESS( Status )) {
        NpUninitializeAliases( );
        return Status;
    }
    //
    // Set up the unload routine
    //
    DriverObject->DriverUnload = NpfsUnload;

    //
    //  Note that because of the way data copying is done, we set neither
    //  the Direct I/O or Buffered I/O bit in DeviceObject->Flags.  If
    //  data is not buffered we may set up for Direct I/O by hand.  We do,
    //  however, set the long term request flag so that IRPs that get
    //  allocated for functions such as Listen requests come out of non-paged
    //  pool always.
    //

    DeviceObject->Flags |= DO_LONG_TERM_REQUESTS;

    //
    //  Initialize the driver object with this driver's entry points.
    //

    DriverObject->MajorFunction[IRP_MJ_CREATE]                   = (PDRIVER_DISPATCH)NpFsdCreate;
    DriverObject->MajorFunction[IRP_MJ_CREATE_NAMED_PIPE]        = (PDRIVER_DISPATCH)NpFsdCreateNamedPipe;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]                    = (PDRIVER_DISPATCH)NpFsdClose;
    DriverObject->MajorFunction[IRP_MJ_READ]                     = (PDRIVER_DISPATCH)NpFsdRead;
    DriverObject->MajorFunction[IRP_MJ_WRITE]                    = (PDRIVER_DISPATCH)NpFsdWrite;
    DriverObject->MajorFunction[IRP_MJ_QUERY_INFORMATION]        = (PDRIVER_DISPATCH)NpFsdQueryInformation;
    DriverObject->MajorFunction[IRP_MJ_SET_INFORMATION]          = (PDRIVER_DISPATCH)NpFsdSetInformation;
    DriverObject->MajorFunction[IRP_MJ_QUERY_VOLUME_INFORMATION] = (PDRIVER_DISPATCH)NpFsdQueryVolumeInformation;
    DriverObject->MajorFunction[IRP_MJ_CLEANUP]                  = (PDRIVER_DISPATCH)NpFsdCleanup;
    DriverObject->MajorFunction[IRP_MJ_FLUSH_BUFFERS]            = (PDRIVER_DISPATCH)NpFsdFlushBuffers;
    DriverObject->MajorFunction[IRP_MJ_DIRECTORY_CONTROL]        = (PDRIVER_DISPATCH)NpFsdDirectoryControl;
    DriverObject->MajorFunction[IRP_MJ_FILE_SYSTEM_CONTROL]      = (PDRIVER_DISPATCH)NpFsdFileSystemControl;
    DriverObject->MajorFunction[IRP_MJ_QUERY_SECURITY]           = (PDRIVER_DISPATCH)NpFsdQuerySecurityInfo;
    DriverObject->MajorFunction[IRP_MJ_SET_SECURITY]             = (PDRIVER_DISPATCH)NpFsdSetSecurityInfo;

#ifdef _PNP_POWER_
    //
    // Npfs doesn't need to handle SetPower requests.   Local named pipes
    // won't lose any state.  Remote pipes will be lost, by a network driver
    // will fail PowerQuery if there are open network connections.
    //

    DeviceObject->DeviceObjectExtension->PowerControlNeeded = FALSE;
#endif


    DriverObject->FastIoDispatch = &NpFastIoDispatch;


    //
    //  Now initialize the Vcb, and create the root dcb
    //

    NpfsDeviceObject = (PNPFS_DEVICE_OBJECT)DeviceObject;

    NpVcb = &NpfsDeviceObject->Vcb;
    NpInitializeVcb ();

    Status = NpCreateRootDcb ();

    if (!NT_SUCCESS (Status)) {
        LIST_ENTRY DeferredList;

        InitializeListHead (&DeferredList);
        NpDeleteVcb (&DeferredList);
        IoDeleteDevice (DeviceObject);
        NpUninitializeAliases ();
        NpCompleteDeferredIrps (&DeferredList);
    }

    //
    //  And return to our caller
    //

    return Status;
}

VOID
NpfsUnload(
    IN PDRIVER_OBJECT DriverObject
    )
/*++
      
Routine Description:
      
    This routine cleans up all of the memory associated with
    the driver.
      
Arguments:
      
    DriverObject    - Supplies the driver object controlling the device.
      
Return Value:
      
    None.
      
--*/
{
    UNICODE_STRING us;
    LIST_ENTRY DeferredList;

    InitializeListHead (&DeferredList);
    NpDeleteVcb (&DeferredList);
    NpCompleteDeferredIrps (&DeferredList);

    RtlInitUnicodeString (&us, L"\\??\\PIPE"); // Created by SMSS
    IoDeleteSymbolicLink (&us);

    IoDeleteDevice (&NpfsDeviceObject->DeviceObject);
    NpUninitializeAliases ();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\npfs\npstruc.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    NpStruc.h

Abstract:

    This module defines the data structures that make up the major internal
    part of the Named Pipe file system.

Author:

    Gary Kimura     [GaryKi]    20-Aug-1990

Revision History:

--*/

#ifndef _NPSTRUC_
#define _NPSTRUC_


//
//  The VCB record is the top record in the Named Pipe file system in-memory
//  data structure.  This structure must be allocated from non-paged pool
//  and immediately follows (in memory) the Device object for the named
//  pipe.  Structurally the layout of the data structure is as follows
//
//    +------------+
//    |NPDO        |
//    |            |
//    +------------+
//    |Vcb         |
//    |            |
//    | EventTable |
//    | WaitQueue  |
//    |            |
//    +------------+
//        | ^
//        | |
//        | |
//        v |
//      +-------------+
//      |RootDcb      |
//      |             |<-+
//      +-------------+  |
//       |               |
//       v               |
//      +-------------+  |
//      |NonPaged     |  |
//      |             |  |
//      +-------------+  |
//          :            |
//          :            |
//          :            |
//          v            |
//        +----------------+    +-------------------+        +---------+
//        |Fcb             |    |Ccb                |        |ServerFO |
//        |                |<---|                   |        |         |
//        | MaxInstances   |    | ServerFO          |<-------|-       1|
//        | CurrentInst    |    | ClientFO          |        |         |
//        | DefaultTimeOut |...>|                   |<-+  +--|-        |
//        |                |    |                   |  |  |  |         |
//        +----------------+    +-------------------+  |  |  +---------+
//         |                     |                     |  |
//         v                     v                     |  |
//        +----------------+    +-------------------+  |  |  +---------+
//        |NonPagedFcb     |    |NonPagedCcb        |<-|--+  |ClientFO |
//        |                |<---|                   |  |     |         |
//        | PipeConfig     |    | PipeState         |  +-----|-       0|
//        | PipeType       |    | ReadMode[2]       |        |         |
//        |                |    | CompletionMode[2] |<-------|-        |
//        |                |    | CreatorProcess    |        |         |
//        |                |    | EventTabEnt[2]    |        +---------+
//        |                |    | DataQueue[2]      |
//        |                |    |                   |     (low bit determines
//        +----------------+    +-------------------+      server/client)
//
//
//  Where there is only one Vcb for the entire Named Pipe file system, and
//  it contains a single pointer to the root dcb for the file system.  Off
//  of the Dcb is a queue of Fcb's.  There is one Fcb for every named pipe.
//  There is one Ccb for every instance of a named pipe.  There are also
//  two additional ccb types for the vcb and the root dcb, and notify records
//  for the notify change operations.
//
//  A newly initialized named pipe file system only contains the Vcb and
//  the root dcb.  A new Fcb is created when a new named pipe is created
//  and then a ccb must also be created.  The file object for the creater
//  (i.e., server end) points to the ccb and indicates that it is the server
//  end.  When a user does an open on the named pipe its file object is
//  set to point to the same ccb and is also set to indicate that it is the
//  client end.  This is denoted by using the last bit of the FsContext pointer
//  if the bit is 1 it is a server end file object, if the bit is 0 it is
//  the client end.
//
//  A file object with a null pointer to the FsContext field is a closed or
//  disconnected pipe.
//
//  The Ccb also contains back pointer to the file objects that have it opened
//


//
//  The following types are used to help during development by keeping the
//  data types distinct.  The manifest contants that go in each is declared
//  in the ntioapi.h file
//

typedef ULONG NAMED_PIPE_TYPE;
typedef NAMED_PIPE_TYPE *PNAMED_PIPE_TYPE;

typedef ULONG READ_MODE;
typedef READ_MODE *PREAD_MODE;

typedef ULONG COMPLETION_MODE;
typedef COMPLETION_MODE *PCOMPLETION_MODE;

typedef ULONG NAMED_PIPE_CONFIGURATION;
typedef NAMED_PIPE_CONFIGURATION *PNAMED_PIPE_CONFIGURATION;

typedef ULONG NAMED_PIPE_STATE;
typedef NAMED_PIPE_STATE *PNAMED_PIPE_STATE;

typedef ULONG NAMED_PIPE_END;
typedef NAMED_PIPE_END *PNAMED_PIPE_END;


//
//  The following two types are used by the event table package.  The first
//  is the event table itself which is just a generic table.  It is protected
//  by the vcb resource, and the second structure is an event table entry.
//

typedef struct _EVENT_TABLE {

    RTL_GENERIC_TABLE Table;

} EVENT_TABLE;
typedef EVENT_TABLE *PEVENT_TABLE;

//
//  The event table is a generic table of event table entries.  Each Ccb
//  optionally contains a pointer to an event table entry for each direction.
//  The entries are part of the global event table defined off of the Vcb
//

typedef struct _EVENT_TABLE_ENTRY {

    //
    //  The first two fields are used as keys in the generic table's
    //  comparison routines.  The pipe end will either be FILE_PIPE_CLIENT_END
    //  or FILE_PIPE_SERVER_END.
    //

    struct _CCB *Ccb;
    NAMED_PIPE_END NamedPipeEnd;

    //
    //  The following three fields are used to identify the event entry
    //  to the named pipe user
    //

    HANDLE EventHandle;
    PVOID Event;
    ULONG KeyValue;
    PEPROCESS Process;

} EVENT_TABLE_ENTRY;
typedef EVENT_TABLE_ENTRY *PEVENT_TABLE_ENTRY;


//
//  Each Ccb has two data queues for holding the outstanding in-bound and
//  out-bound read/write requests.  The following type is used to determine
//  if the data queue contains read requests, write requests, or is empty.
//

typedef enum _QUEUE_STATE {

    ReadEntries,
    WriteEntries,
    Empty

} QUEUE_STATE;

//
//  The data queue is a structure that contains the queue state, quota
//  information, and the list head.  The quota information is used to
//  maintain pipe quota.
//

typedef struct _DATA_QUEUE {

    //
    //  This is the head of a queue of data entries (singly linked)
    //
    LIST_ENTRY Queue;

    //
    //  The current state of what is contained in this data queue,
    //  how many bytes of read/write data there are, and how many individual
    //  requests there are in the queue that contain data (includes
    //  close or flush requests).
    //

    QUEUE_STATE QueueState;
    ULONG BytesInQueue;
    ULONG EntriesInQueue;

    //
    //  The following two fields denote who much quota was reserved for
    //  this pipe direction and how much we've used up.  This is only
    //  the creator quota and not the user quota.
    //

    ULONG Quota;
    ULONG QuotaUsed;


    //
    //  The following field indicates how far we've already processed
    //  into the first entry in the data queue
    //

    ULONG NextByteOffset;

} DATA_QUEUE;
typedef DATA_QUEUE *PDATA_QUEUE;

//
//  Each data entry has a type field that tells us if the operation
//  for the entry is buffered, unbuffered, flush, or a close entry.
//

typedef enum _DATA_ENTRY_TYPE {

    Buffered,
    Unbuffered,
    Flush,
    Close

} DATA_ENTRY_TYPE;

//
//  The following type is used to denote where we got the memory for the
//  data entry and possibly the data buffer.  We either got the memory
//  from the pipe quota, the user quota, or it is part of the next IRP stack
//  location.
//

typedef enum _FROM {

    PipeQuota,
    UserQuota,
    InIrp

} FROM;

//
//  Each entry in the data queue is a data entry.  Processing an IRP
//  has the potential of creating and inserting a new data entry.  If the
//  memory for the entry is taken from the IRP we use the next stack
//  location.
//

typedef struct _DATA_ENTRY {

    //
    //  The following field is how we connect into the queue of data entries
    //

    LIST_ENTRY Queue;


    //
    //  The following field indicates if we still have an IRP associated
    //  with this data entry that need to be completed when the remove
    //  the data entry.  Note that if From is InIrp that this IRP field
    //  must not be null.
    //
    PIRP Irp;

    //
    //  The following field is used to point to the client context if dynamic
    //  impersonation is being used
    //

    PSECURITY_CLIENT_CONTEXT SecurityClientContext;

    //
    //  The following field describe the type of data entry
    //
    ULONG DataEntryType;

    //
    // Record the amount of quota charged for this request.
    //
    ULONG QuotaCharged;

    //
    //  The following field describes the size of the data
    //  buffer described by this entry.
    //
    ULONG DataSize;

    //
    // Start of the data buffer if it exists
    //
    UCHAR DataBuffer[];

} DATA_ENTRY;
typedef DATA_ENTRY *PDATA_ENTRY;


//
//  The following type is used by the wait queue package
//

typedef struct _WAIT_QUEUE {

    LIST_ENTRY Queue;

    KSPIN_LOCK SpinLock;

} WAIT_QUEUE;
typedef WAIT_QUEUE *PWAIT_QUEUE;


typedef struct _VCB {

    //
    //  The type of this record (must be NPFS_NTC_VCB)
    //

    NODE_TYPE_CODE NodeTypeCode;
    //
    //  The following field is used to check share access people who want
    //  to open the named pipe driver
    //

    SHARE_ACCESS ShareAccess;

    //
    //  A pointer to the root DCB for this volume
    //

    struct _FCB *RootDcb;

    //
    //  A count of the number of file objects that have opened the \NamedPipe
    //  object directly, and also a count of the number of file objects
    //  that have opened a name pipe or the root directory.
    //

    CLONG OpenCount;

    //
    //  A prefix table that is used for quick, prefix directed, lookup of
    //  FCBs/DCBs that are part of this volume
    //

    UNICODE_PREFIX_TABLE PrefixTable;

    //
    //  A resource variable to control access to the volume specific data
    //  structures
    //

    ERESOURCE Resource;

    //
    //  The following table is used to hold the named pipe events
    //

    EVENT_TABLE EventTable;

    //
    //  The following field is a queue of waiting IRPS of type WaitForNamedPipe
    //

    WAIT_QUEUE WaitQueue;


} VCB;
typedef VCB *PVCB;


//
//  The Named Pipe Device Object is an I/O system device object with
//  additional workqueue parameters appended to the end.  There is only
//  one of these records created for the entire system during system
//  initialization.
//

typedef struct _NPFS_DEVICE_OBJECT {

    DEVICE_OBJECT DeviceObject;

    //
    //  This is the file system specific volume control block.
    //

    VCB Vcb;

} NPFS_DEVICE_OBJECT;
typedef NPFS_DEVICE_OBJECT *PNPFS_DEVICE_OBJECT;


//
//  The Fcb/Dcb record corresponds to every opened named pipe and directory,
//  and to every directory on an opened path.
//
//  The structure is really divided into two parts.  FCB can be allocated
//  from paged pool which the NONPAGED_FCB must be allocated from non-paged
//  pool.
//

typedef struct _FCB {

    //
    //  Type of this record (must be NPFS_NTC_FCB, or
    //  NPFS_NTC_ROOT_DCB)
    //

    NODE_TYPE_CODE NodeTypeCode;

    //
    //  The links for the queue of all fcbs for a specific dcb off of
    //  Dcb.ParentDcbQueue.  For the root directory this queue is empty
    //

    LIST_ENTRY ParentDcbLinks;

    //
    //  A pointer to the Dcb that is the parent directory containing
    //  this fcb.  If this record itself is the root dcb then this field
    //  is null.
    //

    struct _FCB *ParentDcb;

    //
    //  A pointer to the Vcb containing this fcb
    //

    PVCB Vcb;

    //
    //  A count of the number of file objects that have opened
    //  this file/directory.  For a pipe this is also the number of instances
    //  created for the pipe.
    //

    CLONG OpenCount;

    //
    //  A count of the number of server end file objects that have opened
    //  this pipe.  ServerOpenCount is incremented when OpenCount is
    //  incremented (when the server end creates an instance), but is
    //  decremented when the server end handle is closed, where OpenCount
    //  isn't decremented until both side's handles are closed.  When
    //  ServerOpenCount is 0, a client's attempt to open a named pipe is
    //  met with STATUS_OBJECT_NAME_NOT_FOUND, not STATUS_PIPE_NOT_AVAILABLE,
    //  based on an assumption that since the server doesn't think it has
    //  any instances open, the pipe really doesn't exist anymore.  An
    //  example of when this distinction is useful is when the server
    //  process exits, but the client processes haven't closed their
    //  handles yet.
    //

    CLONG ServerOpenCount;

    //
    //  The following field points to the security descriptor for this named pipe
    //

    PSECURITY_DESCRIPTOR SecurityDescriptor;

    //
    //  The following union is cased off of the node type code for the fcb.
    //  There is a seperate case for the directory versus file fcbs.
    //

    union {

        //
        //  A Directory Control Block (Dcb)
        //

        struct {

            //
            //  A queue of the notify IRPs that will be completed when any
            //  change is made to a file in the directory.  Enqueued using
            //  the Tail.Overlay.ListEntry of the Irp.
            //

            LIST_ENTRY NotifyFullQueue;

            //
            //  A queue of the notify IRPs that will be completed only if a
            //  file is added, deleted, or renamed in the directory.  Enqueued
            //  using the Tail.Overlay.ListEntry of the Irp.
            //

            LIST_ENTRY NotifyPartialQueue;

            //
            //  A queue of all the fcbs/dcbs that are opened under this
            //  Dcb.
            //

            LIST_ENTRY ParentDcbQueue;

            //
            //  The following field is used to check share access people
            //  who want to open the directory.
            //

            SHARE_ACCESS ShareAccess;

        } Dcb;

        //
        //  An File Control Block (Fcb)
        //

        struct {

            //
            //  This is the maximum number of instances we can have for the
            //  named pipe and the current number of instances is the open
            //  count for the fcb (note that the current number also
            //  correspondsto the number of Ccbs)
            //

            ULONG MaximumInstances;

            //
            //  The assigned pipe configuration (FILE_PIPE_INBOUND,
            //  FILE_PIPE_OUTBOUND, or FILE_PIPE_FULL_DUPLEX) and pipe
            //  type (FILE_PIPE_MESSAGE_TYPE or
            //  FILE_PIPE_BYTE_STREAM_TYPE).
            //

            NAMED_PIPE_CONFIGURATION NamedPipeConfiguration : 16;
            NAMED_PIPE_TYPE NamedPipeType : 16;

            //
            //  The following field is the default timeout assigned to the
            //  named pipe
            //

            LARGE_INTEGER DefaultTimeOut;

            //
            //  The Following field is a queue head for a list of ccbs
            //  that are opened under us
            //

            LIST_ENTRY CcbQueue;

        } Fcb;

    } Specific;

    //
    //  The following field is the fully qualified file name for this FCB/DCB
    //  starting from the root of the volume, and last file name in the
    //  fully qualified name.
    //

    UNICODE_STRING FullFileName;
    UNICODE_STRING LastFileName;

    //
    //  The following field contains a prefix table entry that is used when
    //  searching a volume for a name (or longest matching prefix)
    //

    UNICODE_PREFIX_TABLE_ENTRY PrefixTableEntry;


} FCB, DCB, ROOT_DCB;

typedef FCB *PFCB;
typedef DCB *PDCB;
typedef ROOT_DCB *PROOT_DCB;

typedef struct _CLIENT_INFO {
    PVOID ClientSession;
    USHORT ClientComputerNameLength;
    WCHAR ClientComputerBuffer[];
} CLIENT_INFO, *PCLIENT_INFO;


//
//  The Ccb record is allocated for every opened instance of a named pipe.
//  There are two parts to a ccb a paged part and a Nonpaged part.  Both
//  parts are pointed at by the FsContext and FsContext2 field of a file
//  object.
//

typedef struct _CCB {

    //
    //  Type of this record (must be NPFS_NTC_CCB).
    //

    NODE_TYPE_CODE NodeTypeCode;
    //
    //  Pipe state indicates the current state of the pipe
    //  (FILE_PIPE_DISCONNECTED_STATE, FILE_PIPE_LISTENING_STATE,
    //  FILE_PIPE_CONNECTED_STATE, or FILE_PIPE_CLOSING_STATE).
    //

    UCHAR NamedPipeState;

    //
    //  read mode (FILE_PIPE_MESSAGE_MODE or FILE_PIPE_BYTE_STREAM_MODE),
    //  and completion mode (FILE_PIPE_QUEUE_OPERATION or
    //  FILE_PIPE_COMPLETE_OPERATION) describe how to handle requests to the
    //  pipe.  Both of these fields are indexed by either FILE_PIPE_SERVER_END
    //  or FILE_PIPE_CLIENT_END.
    //
    struct {
        UCHAR ReadMode : 1;
        UCHAR CompletionMode : 1;
    } ReadCompletionMode[2];

    //
    // Stored client impersonation level
    //

    SECURITY_QUALITY_OF_SERVICE SecurityQos;

    //
    //  The following field is a list entry for the list of ccb that we
    //  are a member of
    //

    LIST_ENTRY CcbLinks;

    //
    //  A pointer to the paged Fcb, or Vcb that we are tied to
    //

    PFCB Fcb;

    //
    //  Back pointers to the server and client file objects that have us
    //  opened.  This is indexed by either FILE_PIPE_CLIENT_END or
    //  FILE_PIPE_SERVER_END.
    //

    PFILE_OBJECT FileObject[2];
    //
    //  The following fields contain the session and process IDs of the
    //  client side of the named pipe instance.  They are originally set
    //  to NULL (indicating local session) and the real client process
    //  ID but can be changed via FsCtl calls.
    //
    PVOID ClientProcess;
    PCLIENT_INFO ClientInfo;

    //
    //  A pointer to the Nonpaged part of the ccb
    //

    struct _NONPAGED_CCB *NonpagedCcb;


    //
    //  The following data queues are used to contain the buffered information
    //  for each direction in the pipe.  They array is indexed by
    //  PIPE_DIRECTION.
    //

    DATA_QUEUE DataQueue[2];

    //
    // Stored client security for impersonation
    //

    PSECURITY_CLIENT_CONTEXT SecurityClientContext;

    //
    //  A queue of waiting listening IRPs.  They are linked into the
    //  Tail.Overlay.ListEntry field in the Irp.
    //

    LIST_ENTRY ListeningQueue;

} CCB;
typedef CCB *PCCB;

typedef struct _NONPAGED_CCB {

    //
    //  Type of this record (must be NPFS_NTC_NONPAGED_CCB)
    //

    NODE_TYPE_CODE NodeTypeCode;

    //
    //  The following pointers denote the events we are to signal for the
    //  server and client ends of the named pipe.  The actual entry
    //  is stored in the event table, and referenced here for easy access.
    //  The client end is signaled if ever a read/write occurs to the client
    //  of the pipe, and likewise for the server end.  The array is
    //  indexed by either FILE_PIPE_SERVER_END or FILE_PIPE_CLIENT_END.
    //

    PEVENT_TABLE_ENTRY EventTableEntry[2];


    //
    // Resource for synchronizing access
    //
    ERESOURCE Resource;

} NONPAGED_CCB;
typedef NONPAGED_CCB *PNONPAGED_CCB;


//
//  The Root Dcb Ccb record is allocated for every opened instance of the
//  root dcb.  This record is pointed at by FsContext2.
//

typedef struct _ROOT_DCB_CCB {

    //
    //  Type of this record (must be NPFS_NTC_ROOT_DCB_CCB).
    //

    NODE_TYPE_CODE NodeTypeCode;
    //
    //  The following field is a count of the last index returned
    //  by query directory.
    //

    ULONG IndexOfLastCcbReturned;

    //
    //  The following string is used as a query template for directory
    //  query operations
    //

    PUNICODE_STRING QueryTemplate;

} ROOT_DCB_CCB;
typedef ROOT_DCB_CCB *PROOT_DCB_CCB;

#endif // _NPSTRUC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\npfs\resrcsup.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    ResrcSup.c

Abstract:

    This module implements the NamedPipe Resource acquisition routines

Author:

    Gary Kimura     [GaryKi]    22-Mar-1990

Revision History:

--*/

#include "NpProcs.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_RESRCSUP)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NpAcquireExclusiveCcb)
#pragma alloc_text(PAGE, NpAcquireExclusiveVcb)
#pragma alloc_text(PAGE, NpAcquireSharedCcb)
#pragma alloc_text(PAGE, NpAcquireSharedVcb)
#pragma alloc_text(PAGE, NpReleaseCcb)
#pragma alloc_text(PAGE, NpReleaseVcb)
#endif


VOID
NpAcquireExclusiveVcb (
    )

/*++

Routine Description:

    This routine acquires exclusive access to the Vcb

Arguments:

Return Value:

    None.

--*/

{
    PAGED_CODE();

    DebugTrace(+1, Dbg, "NpAcquireExclusiveVcb\n", 0);

    ExAcquireResourceExclusive( &(NpVcb->Resource), TRUE );

    DebugTrace(-1, Dbg, "NpAcquireExclusiveVcb -> (VOID)\n", 0);

    return;
}


VOID
NpAcquireSharedVcb (
    )

/*++

Routine Description:

    This routine acquires shared access to the Vcb

Arguments:

Return Value:

    None.

--*/

{
    PAGED_CODE();

    DebugTrace(+1, Dbg, "NpAcquireSharedVcb\n", 0);

    ExAcquireResourceShared( &(NpVcb->Resource), TRUE );

    DebugTrace(-1, Dbg, "NpAcquireSharedVcb -> (VOID)\n", 0);

    return;
}


VOID
NpAcquireExclusiveCcb (
    IN PNONPAGED_CCB NonpagedCcb
    )

/*++

Routine Description:

    This routine acquires exclusive access to the Ccb by first getting
    shared access to the Fcb.

Arguments:

    NonpagedCcb - Supplies the Ccb to acquire

Return Value:

    None.

--*/

{
    PAGED_CODE();

    DebugTrace(+1, Dbg, "NpAcquireExclusiveCcb, NonpagedCcb = %08lx\n", NonpagedCcb);

    (VOID)ExAcquireResourceShared( &(NpVcb->Resource), TRUE );

    (VOID)ExAcquireResourceExclusive( &(NonpagedCcb->Resource), TRUE );

    DebugTrace(-1, Dbg, "NpAcquireExclusiveCcb -> (VOID)\n", 0);

    return;
}


VOID
NpAcquireSharedCcb (
    IN PNONPAGED_CCB NonpagedCcb
    )

/*++

Routine Description:

    This routine acquires shared access to the Ccb by first getting
    shared access to the Fcb.

Arguments:

    NonpagedCcb - Supplies the Ccb to acquire

Return Value:

    None.

--*/

{
    PAGED_CODE();

    DebugTrace(+1, Dbg, "NpAcquireSharedCcb, NonpagedCcb = %08lx\n", NonpagedCcb);

    (VOID)ExAcquireResourceShared( &(NpVcb->Resource), TRUE );

    (VOID)ExAcquireResourceShared( &(NonpagedCcb->Resource), TRUE );

    DebugTrace(-1, Dbg, "NpAcquireSharedCcb -> (VOID)\n", 0);

    return;
}


VOID
NpReleaseVcb (
    )

/*++

Routine Description:

    This routine releases access to the Vcb

Arguments:

Return Value:

    None.

--*/

{
    PAGED_CODE();

    DebugTrace(0, Dbg, "NpReleaseVcb\n", 0);

    ExReleaseResource( &(NpVcb->Resource) );

    return;
}


VOID
NpReleaseCcb (
    IN PNONPAGED_CCB NonpagedCcb
    )

/*++

Routine Description:

    This routine releases access to the Ccb

Arguments:

    Ccb - Supplies the Ccb being released

Return Value:

    None.

--*/

{
    PAGED_CODE();

    DebugTrace(0, Dbg, "NpReleaseCcb, NonpagedCcb = %08lx\n", NonpagedCcb);

    ExReleaseResource( &(NonpagedCcb->Resource) );
    ExReleaseResource( &(NpVcb->Resource) );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\npfs\readsup.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    ReadSup.c

Abstract:

    This module implements the Read support routine.  This is a common
    read function that is called to do read, unbuffered read, peek, and
    transceive.

Author:

    Gary Kimura     [GaryKi]    20-Sep-1990

Revision History:

--*/

#include "NpProcs.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_READSUP)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NpReadDataQueue)
#endif


IO_STATUS_BLOCK
NpReadDataQueue (
    IN PDATA_QUEUE ReadQueue,
    IN BOOLEAN PeekOperation,
    IN BOOLEAN ReadOverflowOperation,
    IN PUCHAR ReadBuffer,
    IN ULONG ReadLength,
    IN READ_MODE ReadMode,
    IN PCCB Ccb,
    IN PLIST_ENTRY DeferredList
    )

/*++

Routine Description:

    This procedure reads data from the read queue and fills up the
    read buffer.  It will also dequeue the queue or leave it alone based
    on an input parameter.

Arguments:

    ReadQueue - Provides the read queue to examine.  Its state must
        already be set to WriteEntries.

    PeekOperation - Indicates if the operation is to dequeue information
        off of the queue as it is being read or leave the queue alone.
        TRUE means to leave the queue alone.

    ReadOverflowOperation - Indicates if this is a read overflow operation.
        With read overflow we will not alter the named pipe if the data
        will overflow the read buffer.

    ReadBuffer - Supplies a buffer to receive the data

    ReadLength - Supplies the length, in bytes, of ReadBuffer.

    ReadMode - Indicates if the read operation is message mode or
        byte stream mode.

    NamedPipeEnd - Supplies the end of the named pipe doing the read

    Ccb - Supplies the ccb for the pipe

    DeferredList - List of IRP's to complete later after we drop locks

Return Value:

    IO_STATUS_BLOCK - Indicates the result of the operation.

--*/

{
    IO_STATUS_BLOCK Iosb= {0};

    PDATA_ENTRY DataEntry;

    ULONG ReadRemaining;
    ULONG AmountRead;

    PUCHAR WriteBuffer;
    ULONG WriteLength;
    ULONG WriteRemaining;
    BOOLEAN StartStalled = FALSE;

    ULONG AmountToCopy;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "NpReadDataQueue\n", 0);
    DebugTrace( 0, Dbg, "ReadQueue             = %08lx\n", ReadQueue);
    DebugTrace( 0, Dbg, "PeekOperation         = %08lx\n", PeekOperation);
    DebugTrace( 0, Dbg, "ReadOverflowOperation = %08lx\n", ReadOverflowOperation);
    DebugTrace( 0, Dbg, "ReadBuffer            = %08lx\n", ReadBuffer);
    DebugTrace( 0, Dbg, "ReadLength            = %08lx\n", ReadLength);
    DebugTrace( 0, Dbg, "ReadMode              = %08lx\n", ReadMode);
    DebugTrace( 0, Dbg, "Ccb                   = %08lx\n", Ccb);

    //
    //  If this is an overflow operation then we will force us to do peeks.
    //  Later when are determine that the opreation succeeded we will complete
    //  the write irp.
    //

    if (ReadOverflowOperation) {

        PeekOperation = TRUE;
    }

    //
    //  Now for every real data entry we loop until either we run out
    //  of data entries or until the read buffer is full
    //

    ReadRemaining = ReadLength;
    Iosb.Status = STATUS_SUCCESS;
    Iosb.Information = 0;
    AmountRead = 0;

    for (DataEntry = (PeekOperation ? NpGetNextDataQueueEntry( ReadQueue, NULL )
                                    : NpGetNextRealDataQueueEntry( ReadQueue, DeferredList ));

         (DataEntry != (PDATA_ENTRY) &ReadQueue->Queue) && (ReadRemaining > 0);

         DataEntry = (PeekOperation ? NpGetNextDataQueueEntry( ReadQueue, DataEntry )
                                    : NpGetNextRealDataQueueEntry( ReadQueue, DeferredList ))) {

        DebugTrace(0, Dbg, "Top of Loop\n", 0);
        DebugTrace(0, Dbg, "ReadRemaining  = %08lx\n", ReadRemaining);

        //
        //  If this is a peek operation then make sure we got a real
        //  data entry and not a close or flush
        //

        if (!PeekOperation ||
            (DataEntry->DataEntryType == Buffered) ||
            (DataEntry->DataEntryType == Unbuffered)) {

            //
            //  Calculate how much data is in this entry.  The write
            //  remaining is based on whether this is the first entry
            //  in the queue or a later data entry
            //

            if (DataEntry->DataEntryType == Unbuffered) {
                WriteBuffer = DataEntry->Irp->AssociatedIrp.SystemBuffer;
            } else {
                WriteBuffer = DataEntry->DataBuffer;
            }

            WriteLength = DataEntry->DataSize;
            WriteRemaining = WriteLength;

            if (DataEntry == NpGetNextDataQueueEntry( ReadQueue, NULL )) {

                WriteRemaining -= ReadQueue->NextByteOffset;
            }

            DebugTrace(0, Dbg, "WriteBuffer    = %08lx\n", WriteBuffer);
            DebugTrace(0, Dbg, "WriteLength    = %08lx\n", WriteLength);
            DebugTrace(0, Dbg, "WriteRemaining = %08lx\n", WriteRemaining);

            //
            //  copy data from the write buffer at write offset to the
            //  read buffer at read offset by the mininum of write
            //  remaining or read remaining
            //

            AmountToCopy = (WriteRemaining < ReadRemaining ? WriteRemaining
                                                           : ReadRemaining);

            try {

                RtlCopyMemory( &ReadBuffer[ ReadLength - ReadRemaining ],
                               &WriteBuffer[ WriteLength - WriteRemaining ],
                               AmountToCopy );

            } except(EXCEPTION_EXECUTE_HANDLER) {

                Iosb.Status = GetExceptionCode ();
                goto exit_1;
            }

            //
            //  Update the Read and Write remaining counts, the total
            //  amount we've read and the next byte offset field in the
            //  read queue
            //

            ReadRemaining  -= AmountToCopy;
            WriteRemaining -= AmountToCopy;
            AmountRead += AmountToCopy;

            if (!PeekOperation) {
                DataEntry->QuotaCharged -= AmountToCopy;
                ReadQueue->QuotaUsed -= AmountToCopy;
                ReadQueue->NextByteOffset += AmountToCopy;
                StartStalled = TRUE;
            }

            //
            //  Now update the security fields in the ccb
            //

            NpCopyClientContext( Ccb, DataEntry );

            //
            //  If the remaining write length is greater than zero
            //  then we've filled up the read buffer so we need to
            //  figure out if its an overflow error
            //

            if (WriteRemaining > 0 ||
                (ReadOverflowOperation && (AmountRead == 0))) {

                DebugTrace(0, Dbg, "Write remaining is > 0\n", 0);

                if (ReadMode == FILE_PIPE_MESSAGE_MODE) {

                    DebugTrace(0, Dbg, "Overflow message mode read\n", 0);

                    //
                    //  Set the status field and break out of the for-loop.
                    //

                    Iosb.Status = STATUS_BUFFER_OVERFLOW;
                    break;
                }

            } else {

                DebugTrace(0, Dbg, "Remaining Write is zero\n", 0);

                //
                //  The write entry is done so remove it from the read
                //  queue, if this is not a peek operation.  This might
                //  also have an Irp that needs to be completed
                //

                if (!PeekOperation || ReadOverflowOperation) {

                    PIRP WriteIrp;

                    //
                    //  For a read overflow operation we need to get the read data
                    //  queue entry and remove it.
                    //

                    if (ReadOverflowOperation) {
                        PDATA_ENTRY TempDataEntry;
                        TempDataEntry = NpGetNextRealDataQueueEntry( ReadQueue, DeferredList );
                        ASSERT(TempDataEntry == DataEntry);
                    }

                    if ((WriteIrp = NpRemoveDataQueueEntry( ReadQueue, TRUE,  DeferredList)) != NULL) {
                        WriteIrp->IoStatus.Information = WriteLength;
                        NpDeferredCompleteRequest( WriteIrp, STATUS_SUCCESS, DeferredList );
                    }
                }

                //
                //  And if we are doing message mode reads then we'll
                //  work on completing this irp without going back
                //  to the top of the loop
                //

                if (ReadMode == FILE_PIPE_MESSAGE_MODE) {

                    DebugTrace(0, Dbg, "Successful message mode read\n", 0);

                    //
                    //  Set the status field and break out of the for-loop.
                    //

                    Iosb.Status = STATUS_SUCCESS;
                    break;
                }

                ASSERTMSG("Srv cannot use read overflow on a byte stream pipe ", !ReadOverflowOperation);
            }
        }
    }

    DebugTrace(0, Dbg, "End of loop, AmountRead = %08lx\n", AmountRead);

    Iosb.Information = AmountRead;

exit_1:
    if (StartStalled) {
        NpCompleteStalledWrites (ReadQueue, DeferredList);
    }

    DebugTrace(-1, Dbg, "NpReadDataQueue -> Iosb.Status = %08lx\n", Iosb.Status);
    return Iosb;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\npfs\seinfo.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    SeInfo.c

Abstract:

    This module implements the Security Info routines for NPFS called by the
    dispatch driver.  There are two entry points NpFsdQueryInformation
    and NpFsdSetInformation.

Author:

    Gary Kimura     [GaryKi]    21-Aug-1990

Revision History:

--*/

#include "NpProcs.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_SEINFO)

//
//  local procedure prototypes
//

NTSTATUS
NpCommonQuerySecurityInfo (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    );


NTSTATUS
NpCommonSetSecurityInfo (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NpCommonQuerySecurityInfo)
#pragma alloc_text(PAGE, NpCommonSetSecurityInfo)
#pragma alloc_text(PAGE, NpFsdQuerySecurityInfo)
#pragma alloc_text(PAGE, NpFsdSetSecurityInfo)
#endif


NTSTATUS
NpFsdQuerySecurityInfo (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the FSD part of the Query Security Information API
    calls.

Arguments:

    NpfsDeviceObject - Supplies the device object to use.

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The Fsd status for the Irp

--*/

{
    NTSTATUS Status;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "NpFsdQuerySecurityInfo\n", 0);

    //
    //  Call the common Query Information routine.
    //

    FsRtlEnterFileSystem();

    NpAcquireExclusiveVcb();

    Status = NpCommonQuerySecurityInfo( NpfsDeviceObject, Irp );

    NpReleaseVcb();

    FsRtlExitFileSystem();

    if (Status != STATUS_PENDING) {
        NpCompleteRequest (Irp, Status);
    }

    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "NpFsdQuerySecurityInfo -> %08lx\n", Status );

    return Status;
}


NTSTATUS
NpFsdSetSecurityInfo (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the FSD part of the Set Security Information API
    calls.

Arguments:

    NpfsDeviceObject - Supplies the device object to use.

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The Fsd status for the Irp

--*/

{
    NTSTATUS Status;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "NpFsdSetSecurityInfo\n", 0);

    //
    //  Call the common Set Information routine.
    //

    FsRtlEnterFileSystem();

    NpAcquireExclusiveVcb();

    Status = NpCommonSetSecurityInfo( NpfsDeviceObject, Irp );

    NpReleaseVcb();

    FsRtlExitFileSystem();

    if (Status != STATUS_PENDING) {
        NpCompleteRequest (Irp, Status);
    }
    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "NpFsdSetSecurityInfo -> %08lx\n", Status );

    return Status;
}


//
//  Internal support routine
//

NTSTATUS
NpCommonQuerySecurityInfo (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for querying security information.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - the return status for the operation

--*/

{
    PIO_STACK_LOCATION IrpSp;
    NTSTATUS Status;

    NODE_TYPE_CODE NodeTypeCode;
    PFCB Fcb;
    PCCB Ccb;
    NAMED_PIPE_END NamedPipeEnd;

    PAGED_CODE();

    //
    //  Get the current stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "NpCommonQuerySecurityInfo...\n", 0);
    DebugTrace( 0, Dbg, " Irp                   = %08lx\n", Irp);
    DebugTrace( 0, Dbg, " ->SecurityInformation = %08lx\n", IrpSp->Parameters.QuerySecurity.SecurityInformation);
    DebugTrace( 0, Dbg, " ->Length              = %08lx\n", IrpSp->Parameters.QuerySecurity.Length);
    DebugTrace( 0, Dbg, " ->UserBuffer          = %08lx\n", Irp->UserBuffer);

    //
    //  Get the ccb and figure out who we are, and make sure we're not
    //  disconnected.
    //

    if ((NodeTypeCode = NpDecodeFileObject( IrpSp->FileObject,
                                            &Fcb,
                                            &Ccb,
                                            &NamedPipeEnd )) == NTC_UNDEFINED) {

        DebugTrace(0, Dbg, "Pipe is disconnected from us\n", 0);

        Status = STATUS_PIPE_DISCONNECTED;

        DebugTrace(-1, Dbg, "NpCommonQueryInformation -> %08lx\n", Status );
        return Status;
    }

    //
    //  Now we only will allow write operations on the pipe and not a directory
    //  or the device
    //

    if (NodeTypeCode != NPFS_NTC_CCB) {

        DebugTrace(0, Dbg, "FileObject is not for a named pipe\n", 0);

        Status = STATUS_INVALID_PARAMETER;

        DebugTrace(-1, Dbg, "NpCommonQueryInformation -> %08lx\n", Status );
        return Status;
    }

    //
    //  Call the security routine to do the actual query
    //

    Status = SeQuerySecurityDescriptorInfo( &IrpSp->Parameters.QuerySecurity.SecurityInformation,
                                            Irp->UserBuffer,
                                            &IrpSp->Parameters.QuerySecurity.Length,
                                            &Fcb->SecurityDescriptor );

    if (  Status == STATUS_BUFFER_TOO_SMALL ) {

        Irp->IoStatus.Information = IrpSp->Parameters.QuerySecurity.Length;

        Status = STATUS_BUFFER_OVERFLOW;
    }



    DebugTrace(-1, Dbg, "NpCommonQuerySecurityInfo -> %08lx\n", Status );
    return Status;
}


//
//  Internal support routine
//

NTSTATUS
NpCommonSetSecurityInfo (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for Setting security information.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - the return status for the operation

--*/

{
    PIO_STACK_LOCATION IrpSp;
    NTSTATUS Status;

    NODE_TYPE_CODE NodeTypeCode;
    PFCB Fcb;
    PCCB Ccb;
    NAMED_PIPE_END NamedPipeEnd;

    PSECURITY_DESCRIPTOR OldSecurityDescriptor, NewSecurityDescriptor, CachedSecurityDescriptor;

    PAGED_CODE();

    //
    //  Get the current stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "NpCommonSetSecurityInfo...\n", 0);
    DebugTrace( 0, Dbg, " Irp                   = %08lx\n", Irp);
    DebugTrace( 0, Dbg, " ->SecurityInformation = %08lx\n", IrpSp->Parameters.SetSecurity.SecurityInformation);
    DebugTrace( 0, Dbg, " ->SecurityDescriptor  = %08lx\n", IrpSp->Parameters.SetSecurity.SecurityDescriptor);

    //
    //  Get the ccb and figure out who we are, and make sure we're not
    //  disconnected.
    //

    if ((NodeTypeCode = NpDecodeFileObject( IrpSp->FileObject,
                                            &Fcb,
                                            &Ccb,
                                            &NamedPipeEnd )) == NTC_UNDEFINED) {

        DebugTrace(0, Dbg, "Pipe is disconnected from us\n", 0);

        Status = STATUS_PIPE_DISCONNECTED;

        DebugTrace(-1, Dbg, "NpCommonQueryInformation -> %08lx\n", Status );
        return Status;
    }

    //
    //  Now we only will allow write operations on the pipe and not a directory
    //  or the device
    //

    if (NodeTypeCode != NPFS_NTC_CCB) {

        DebugTrace(0, Dbg, "FileObject is not for a named pipe\n", 0);

        Status = STATUS_INVALID_PARAMETER;

        DebugTrace(-1, Dbg, "NpCommonQueryInformation -> %08lx\n", Status );
        return Status;
    }

    //
    //  Call the security routine to do the actual set
    //

    NewSecurityDescriptor = OldSecurityDescriptor = Fcb->SecurityDescriptor;

    Status = SeSetSecurityDescriptorInfo( NULL,
                                          &IrpSp->Parameters.SetSecurity.SecurityInformation,
                                          IrpSp->Parameters.SetSecurity.SecurityDescriptor,
                                          &NewSecurityDescriptor,
                                          PagedPool,
                                          IoGetFileObjectGenericMapping() );

    if (NT_SUCCESS(Status)) {
        Status = ObLogSecurityDescriptor (NewSecurityDescriptor,
                                          &CachedSecurityDescriptor,
                                          1);
        NpFreePool (NewSecurityDescriptor);
        if (NT_SUCCESS(Status)) {
            Fcb->SecurityDescriptor = CachedSecurityDescriptor;
            ObDereferenceSecurityDescriptor( OldSecurityDescriptor, 1 );
        }
        
    }

    DebugTrace(-1, Dbg, "NpCommonSetSecurityInfo -> %08lx\n", Status );
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\npfs\secursup.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    SecurSup.c

Abstract:

    This module implements the Named Pipe Security support routines

Author:

    Gary Kimura     [GaryKi]    06-May-1991

Revision History:

--*/

#include "NpProcs.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_SECURSUP)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NpCopyClientContext)
#pragma alloc_text(PAGE, NpImpersonateClientContext)
#pragma alloc_text(PAGE, NpInitializeSecurity)
#pragma alloc_text(PAGE, NpGetClientSecurityContext)
#pragma alloc_text(PAGE, NpUninitializeSecurity)
#pragma alloc_text(PAGE, NpFreeClientSecurityContext)
#endif


NTSTATUS
NpInitializeSecurity (
    IN PCCB Ccb,
    IN PSECURITY_QUALITY_OF_SERVICE SecurityQos,
    IN PETHREAD UserThread
    )

/*++

Routine Description:

    This routine initializes the security (impersonation) fields
    in the ccb.  It is called when the client end gets opened.

Arguments:

    Ccb - Supplies the ccb being initialized

    SecurityQos - Supplies the clients quality of service parameter

    UserThread - Supplise the client's user thread

Return Value:

    NTSTATUS - Returns the result of the operation

--*/

{
    NTSTATUS Status;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "NpInitializeSecurity, Ccb = %08lx\n", Ccb);

    //
    //  Either copy the security qos parameter, if it is not null or
    //  create a dummy qos
    //

    if (SecurityQos != NULL) {

        RtlCopyMemory( &Ccb->SecurityQos,
                       SecurityQos,
                       sizeof(SECURITY_QUALITY_OF_SERVICE) );

    } else {

        Ccb->SecurityQos.Length              = sizeof(SECURITY_QUALITY_OF_SERVICE);
        Ccb->SecurityQos.ImpersonationLevel  = SecurityImpersonation;
        Ccb->SecurityQos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
        Ccb->SecurityQos.EffectiveOnly       = TRUE;
    }

    //
    //  Because we might be asked to reinitialize the ccb we need
    //  to first check if the security client context is not null and if so then
    //  free its pool and zero out the context pointer so that if we raise out
    //  this time then a second time through the code we won't try and free the
    //  pool twice.
    //

    if (Ccb->SecurityClientContext != NULL) {

        SeDeleteClientSecurity( Ccb->SecurityClientContext );
        NpFreePool( Ccb->SecurityClientContext );
        Ccb->SecurityClientContext = NULL;
    }

    //
    //  If the tracking mode is static then we need to capture the
    //  client context now otherwise we set the client context field
    //  to null
    //

    if (Ccb->SecurityQos.ContextTrackingMode == SECURITY_STATIC_TRACKING) {

        //
        //  Allocate a client context record, and then initialize it
        //

        Ccb->SecurityClientContext = NpAllocatePagedPoolWithQuota ( sizeof(SECURITY_CLIENT_CONTEXT), 'sFpN' );
        if (Ccb->SecurityClientContext == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        } else {
            DebugTrace(0, Dbg, "Static tracking, ClientContext = %08lx\n", Ccb->SecurityClientContext);

            if (!NT_SUCCESS(Status = SeCreateClientSecurity( UserThread,
                                                             &Ccb->SecurityQos,
                                                             FALSE,
                                                             Ccb->SecurityClientContext ))) {

                DebugTrace(0, Dbg, "Not successful at creating client security, %08lx\n", Status);

                NpFreePool( Ccb->SecurityClientContext );
                Ccb->SecurityClientContext = NULL;
            }
        }

    } else {

        DebugTrace(0, Dbg, "Dynamic tracking\n", 0);

        Ccb->SecurityClientContext = NULL;
        Status = STATUS_SUCCESS;
    }

    DebugTrace(-1, Dbg, "NpInitializeSecurity -> %08lx\n", Status);

    return Status;
}


VOID
NpUninitializeSecurity (
    IN PCCB Ccb
    )

/*++

Routine Description:

    This routine deletes the client context referenced by the ccb

Arguments:

    Ccb - Supplies the ccb being uninitialized

Return Value:

    None

--*/

{
    PAGED_CODE();

    DebugTrace(+1, Dbg, "NpUninitializeSecurity, Ccb = %08lx\n", Ccb);

    //
    //  We only have work to do if the client context field is not null
    //  and then we need to delete the client context, and free the memory.
    //

    if (Ccb->SecurityClientContext != NULL) {

        DebugTrace(0, Dbg, "Delete client context, %08lx\n", Ccb->SecurityClientContext);

        SeDeleteClientSecurity( Ccb->SecurityClientContext );

        NpFreePool( Ccb->SecurityClientContext );
        Ccb->SecurityClientContext = NULL;
    }

    DebugTrace(-1, Dbg, "NpUninitializeSecurity -> VOID\n", 0);

    return;
}

VOID
NpFreeClientSecurityContext (
    IN PSECURITY_CLIENT_CONTEXT SecurityContext
    )
/*++

Routine Description:

    This routine frees previously captured security context.

Arguments:

    SecurityContext - Previously captured security context.

Return Value:

    None.

--*/
{
    if (SecurityContext != NULL) {
        SeDeleteClientSecurity (SecurityContext);
        NpFreePool (SecurityContext );
    }
}


NTSTATUS
NpGetClientSecurityContext (
    IN  NAMED_PIPE_END NamedPipeEnd,
    IN  PCCB Ccb,
    IN  PETHREAD UserThread,
    OUT PSECURITY_CLIENT_CONTEXT *ppSecurityContext
    )

/*++

Routine Description:

    This routine captures a new client context and stores it in the indicated
    data entry, but only if the tracking mode is dynamic and only for the
    client end of the named pipe.

Arguments:

    NamedPipeEnd - Indicates the client or server end of the named pipe.
        Only the client end does anything.

    Ccb - Supplies the ccb for this instance of the named pipe.

    DataEntry - Supplies the data entry to use to store the client context

    UserThread - Supplies the thread of the client

Return Value:

    NTSTATUS - Returns our success code.

--*/

{
    NTSTATUS Status;
    PSECURITY_CLIENT_CONTEXT SecurityContext;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "NpSetDataEntryClientContext, Ccb = %08lx\n", Ccb);

    //
    //  Only do the work if this is the client end and tracking is dynamic
    //

    if ((NamedPipeEnd == FILE_PIPE_CLIENT_END) &&
        (Ccb->SecurityQos.ContextTrackingMode == SECURITY_DYNAMIC_TRACKING)) {

        //
        //  Allocate a client context record, and then initialize it
        //

        SecurityContext = NpAllocatePagedPoolWithQuota (sizeof(SECURITY_CLIENT_CONTEXT), 'sFpN');
        if (SecurityContext == NULL) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        DebugTrace(0, Dbg, "Client End, Dynamic Tracking, ClientContext = %08lx\n", DataEntry->SecurityClientContext);

        if (!NT_SUCCESS (Status = SeCreateClientSecurity (UserThread,
                                                          &Ccb->SecurityQos,
                                                          FALSE,
                                                          SecurityContext))) {

            DebugTrace(0, Dbg, "Not successful at creating client security, %08lx\n", Status);

            NpFreePool (SecurityContext);
            SecurityContext = NULL;
        }

    } else {

        DebugTrace(0, Dbg, "Static Tracking or Not Client End\n", 0);

        SecurityContext = NULL;
        Status = STATUS_SUCCESS;
    }

    DebugTrace(-1, Dbg, "NpSetDataEntryClientContext -> %08lx\n", Status);

    *ppSecurityContext = SecurityContext;
    return Status;
}


VOID
NpCopyClientContext (
    IN PCCB Ccb,
    IN PDATA_ENTRY DataEntry
    )

/*++

Routine Description:

    This routine copies the client context stored in the data entry into
    the ccb, but only for dynamic tracking.

Arguments:

    Ccb - Supplies the ccb to update.

    DataEntry - Supplies the DataEntry to copy from.

Return Value:

--*/

{
    PAGED_CODE();

    DebugTrace(+1, Dbg, "NpCopyClientContext, Ccb = %08lx\n", Ccb);

    //
    //  Only do the copy if the data entries client context field is not null
    //  which means that we are doing dynamic tracking.  Note we will
    //  not be called with a server write data entry that has a non null
    //  client context.
    //

    if (DataEntry->SecurityClientContext != NULL) {

        DebugTrace(0, Dbg, "have something to copy %08lx\n", DataEntry->SecurityClientContext);

        //
        //  First check if we need to delete and deallocate the client
        //  context in the nonpaged ccb
        //

        if (Ccb->SecurityClientContext != NULL) {

            DebugTrace(0, Dbg, "Remove current client context %08lx\n", Ccb->SecurityClientContext);

            SeDeleteClientSecurity (Ccb->SecurityClientContext);

            NpFreePool (Ccb->SecurityClientContext);
        }

        //
        //  Now copy over the reference to the client context, and zero
        //  out the reference in the data entry.
        //

        Ccb->SecurityClientContext = DataEntry->SecurityClientContext;
        DataEntry->SecurityClientContext = NULL;
    }

    DebugTrace(-1, Dbg, "NpCopyClientContext -> VOID\n", 0 );

    return;
}


NTSTATUS
NpImpersonateClientContext (
    IN PCCB Ccb
    )

/*++

Routine Description:

    This routine impersonates the current client context stored in the
    ccb

Arguments:

    Ccb - Supplies the ccb for the named pipe

Return Value:

    NTSTATUS - returns our status code.

--*/

{
    NTSTATUS Status;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "NpImpersonateClientContext, Ccb = %08lx\n", Ccb);

    if (Ccb->SecurityClientContext == NULL) {

        DebugTrace(0, Dbg, "Cannot impersonate\n", 0);

        Status = STATUS_CANNOT_IMPERSONATE;

    } else {

        Status = SeImpersonateClientEx( Ccb->SecurityClientContext, NULL );

    }

    DebugTrace(-1, Dbg, "NpImpersonateClientContext -> %08lx\n", Status);

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\npfs\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

MAJORCOMP=ntos
MINORCOMP=npfs

TARGETNAME=npfs
TARGETTYPE=DRIVER

INCLUDES=..;..\..\inc;$(PROJECT_ROOT)\ntos\inc


MSC_WARNING_LEVEL=/W3 /WX

C_DEFINES=$(C_DEFINES) -D_NTDRIVER_

SOURCES=           \
        ..\AliasSup.c \
        ..\Cleanup.c  \
        ..\Close.c    \
        ..\Create.c   \
        ..\CreateNp.c \
        ..\DataSup.c  \
        ..\Dir.c      \
        ..\DumpSup.c  \
        ..\EventSup.c \
        ..\FileInfo.c \
        ..\FilObSup.c \
        ..\FlushBuf.c \
        ..\FsCtrl.c   \
        ..\NpData.c   \
        ..\Npfs.rc    \
        ..\NpInit.c   \
        ..\PrefxSup.c \
        ..\Read.c     \
        ..\ReadSup.c  \
        ..\SecurSup.c \
        ..\SeInfo.c   \
        ..\StateSup.c \
        ..\StrucSup.c \
        ..\VolInfo.c  \
        ..\WaitSup.c  \
        ..\Write.c    \
        ..\WriteSup.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\npfs\strucsup.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    StrucSup.c

Abstract:

    This module implements the Named Pipe in-memory data structure manipulation
    routines

Author:

    Gary Kimura     [GaryKi]    22-Jan-1990

Revision History:

--*/

#include "NpProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (NPFS_BUG_CHECK_STRUCSUP)

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_STRUCSUP)


WCHAR NpRootDCBName[] = L"\\";

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, NpInitializeVcb)
#pragma alloc_text(INIT, NpCreateRootDcb)
#pragma alloc_text(PAGE, NpCreateCcb)
#pragma alloc_text(PAGE, NpCreateFcb)
#pragma alloc_text(PAGE, NpCreateRootDcbCcb)
#pragma alloc_text(PAGE, NpDeleteCcb)
#pragma alloc_text(PAGE, NpDeleteFcb)
#pragma alloc_text(PAGE, NpDeleteRootDcb)
#pragma alloc_text(PAGE, NpDeleteVcb)
#endif


VOID
NpInitializeVcb (
    VOID
    )

/*++

Routine Description:

    This routine initializes new Vcb record. The Vcb record "hangs" off the
    end of the Npfs device object and must be allocated by our caller.

Arguments:

    None.

Return Value:

    None.

--*/

{

    PAGED_CODE();

    DebugTrace(+1, Dbg, "NpInitializeVcb, Vcb = %08lx\n", NpVcb);

    //
    //  We start by first zeroing out all of the VCB, this will guarantee
    //  that any stale data is wiped clean
    //

    RtlZeroMemory( NpVcb, sizeof(VCB) );

    //
    //  Set the proper node type code and node byte size
    //

    NpVcb->NodeTypeCode = NPFS_NTC_VCB;

    //
    //  Initialize the Prefix table
    //

    RtlInitializeUnicodePrefix( &NpVcb->PrefixTable );

    //
    //  Initialize the resource variable for the Vcb
    //

    ExInitializeResourceLite( &NpVcb->Resource );

    //
    //  Initialize the event table
    //

    NpInitializeEventTable( &NpVcb->EventTable );

    //
    //  Initialize the wait queue
    //

    NpInitializeWaitQueue( &NpVcb->WaitQueue );


    //
    //  return and tell the caller
    //

    return;
}


VOID
NpDeleteVcb (
    IN PLIST_ENTRY DeferredList
    )

/*++

Routine Description:

    This routine removes the Vcb record from our in-memory data
    structures.  It also will remove all associated underlings
    (i.e., FCB records).

Arguments:

    DeferredList - List of deferred IRPs to complete once we release locks

Return Value:

    None

--*/

{
    PAGED_CODE();

    DebugTrace(+1, Dbg, "NpDeleteVcb, Vcb = %08lx\n", NpVcb);

    //
    //  Make sure the open count is zero, and the open underling count
    //  is also zero.
    //

    if (NpVcb->OpenCount != 0) {

        DebugDump("Error deleting Vcb\n", 0, NpVcb);
        NpBugCheck( 0, 0, 0 );
    }

    //
    //  Remove the Root Dcb
    //

    if (NpVcb->RootDcb != NULL) {

        NpDeleteRootDcb( NpVcb->RootDcb, DeferredList );
    }

    //
    //  Uninitialize the resource variable for the Vcb
    //

    ExDeleteResourceLite( &NpVcb->Resource );

    //
    //  Uninitialize the event table
    //

    NpUninitializeEventTable( &NpVcb->EventTable );

    //
    //  Uninitialize the wait queue
    //

    NpUninitializeWaitQueue( &NpVcb->WaitQueue );

    //
    //  And zero out the Vcb, this will help ensure that any stale data is
    //  wiped clean
    //

    RtlZeroMemory( NpVcb, sizeof(VCB) );

    //
    //  return and tell the caller
    //

    DebugTrace(-1, Dbg, "NpDeleteVcb -> VOID\n", 0);

    return;
}


NTSTATUS
NpCreateRootDcb (
    VOID
    )

/*++

Routine Description:

    This routine allocates, initializes, and inserts a new root DCB record
    into the in memory data structure.

Arguments:

    None.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    DebugTrace(+1, Dbg, "NpCreateRootDcb, Vcb = %08lx\n", NpVcb);

    //
    //  Make sure we don't already have a root dcb for this vcb
    //

    if (NpVcb->RootDcb != NULL) {

        DebugDump("Error trying to create multiple root dcbs\n", 0, NpVcb);
        NpBugCheck( 0, 0, 0 );
    }

    //
    //  Allocate a new DCB and zero it out
    //

    NpVcb->RootDcb = NpAllocatePagedPool ( sizeof(DCB), 'DFpN' );

    if (NpVcb->RootDcb == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory( NpVcb->RootDcb, sizeof(DCB));

    //
    //  Set the proper node type code and node byte size
    //

    NpVcb->RootDcb->NodeTypeCode = NPFS_NTC_ROOT_DCB;

    //
    //  The root Dcb has an empty parent dcb links field
    //

    InitializeListHead( &NpVcb->RootDcb->ParentDcbLinks );

    //
    //  initialize the notify queues, and the parent dcb queue.
    //

    InitializeListHead( &NpVcb->RootDcb->Specific.Dcb.NotifyFullQueue );
    InitializeListHead( &NpVcb->RootDcb->Specific.Dcb.NotifyPartialQueue );
    InitializeListHead( &NpVcb->RootDcb->Specific.Dcb.ParentDcbQueue );

    NpVcb->RootDcb->FullFileName.Buffer = NpRootDCBName;
    NpVcb->RootDcb->FullFileName.Length = sizeof (NpRootDCBName) - sizeof (UNICODE_NULL);
    NpVcb->RootDcb->FullFileName.MaximumLength = sizeof (NpRootDCBName);

    //
    // Last file name is the same as file name.
    //
    NpVcb->RootDcb->LastFileName = NpVcb->RootDcb->FullFileName;

    //
    //  Insert this dcb into the prefix table
    //

    if (!RtlInsertUnicodePrefix( &NpVcb->PrefixTable,
                                 &NpVcb->RootDcb->FullFileName,
                                 &NpVcb->RootDcb->PrefixTableEntry )) {

        DebugDump("Error trying to insert root dcb into prefix table\n", 0, NpVcb);
        NpBugCheck( 0, 0, 0 );
    }

    DebugTrace(-1, Dbg, "NpCreateRootDcb -> %8lx\n", NpVcb->RootDcb);

    return STATUS_SUCCESS;
}


VOID
NpDeleteRootDcb (
    IN PROOT_DCB RootDcb,
    IN PLIST_ENTRY DeferredList
    )

/*++

Routine Description:

    This routine deallocates and removes the ROOT DCB record
    from our in-memory data structures.  It also will remove all
    associated underlings (i.e., Notify queues and child FCB records).

Arguments:

    RootDcb - Supplies the ROOT DCB to be removed

    DeferredList - List of IRPs to complete after we release locks

Return Value:

    None

--*/

{
    PLIST_ENTRY Links;
    PIRP Irp;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "NpDeleteRootDcb, RootDcb = %08lx\n", RootDcb);

    //
    //  We can only delete this record if the open count is zero.
    //

    if (RootDcb->OpenCount != 0) {

        DebugDump("Error deleting RootDcb, Still Open\n", 0, RootDcb);
        NpBugCheck( 0, 0, 0 );
    }

    //
    //  Remove every Notify Irp from the two notify queues
    //

    while (!IsListEmpty(&RootDcb->Specific.Dcb.NotifyFullQueue)) {

        Links = RemoveHeadList( &RootDcb->Specific.Dcb.NotifyFullQueue );

        Irp = CONTAINING_RECORD( Links, IRP, Tail.Overlay.ListEntry );

        NpDeferredCompleteRequest( Irp, STATUS_FILE_FORCED_CLOSED, DeferredList );
    }

    while (!IsListEmpty(&RootDcb->Specific.Dcb.NotifyPartialQueue)) {

        Links = RemoveHeadList( &RootDcb->Specific.Dcb.NotifyPartialQueue );

        Irp = CONTAINING_RECORD( Links, IRP, Tail.Overlay.ListEntry );

        NpDeferredCompleteRequest( Irp, STATUS_FILE_FORCED_CLOSED, DeferredList );
    }

    //
    //  We can only be removed if the no other FCB have us referenced
    //  as a their parent DCB.
    //

    if (!IsListEmpty(&RootDcb->Specific.Dcb.ParentDcbQueue)) {

        DebugDump("Error deleting RootDcb\n", 0, RootDcb);
        NpBugCheck( 0, 0, 0 );
    }

    //
    //  Remove the entry from the prefix table, and then remove the full
    //  file name
    //

    RtlRemoveUnicodePrefix( &NpVcb->PrefixTable, &RootDcb->PrefixTableEntry );

    //
    //  Finally deallocate the Dcb record
    //

    NpFreePool( RootDcb );

    //
    //  and return to our caller
    //

    DebugTrace(-1, Dbg, "NpDeleteRootDcb -> VOID\n", 0);

    return;
}


NTSTATUS
NpCreateFcb (
    IN PDCB ParentDcb,
    IN PUNICODE_STRING FileName,
    IN ULONG MaximumInstances,
    IN LARGE_INTEGER DefaultTimeOut,
    IN NAMED_PIPE_CONFIGURATION NamedPipeConfiguration,
    IN NAMED_PIPE_TYPE NamedPipeType,
    OUT PFCB *ppFcb
    )

/*++

Routine Description:

    This routine allocates, initializes, and inserts a new Fcb record into
    the in memory data structures.

Arguments:

    ParentDcb - Supplies the parent dcb that the new FCB is under.

    FileName - Supplies the file name of the file relative to the directory
        it's in (e.g., the file \config.sys is called "CONFIG.SYS" without
        the preceding backslash).

    MaximumInstances - Supplies the maximum number of pipe instances

    DefaultTimeOut - Supplies the default wait time out value

    NamedPipeConfiguration - Supplies our initial pipe configuration

    NamedPipeType - Supplies our initial pipe type

Return Value:

    PFCB - Returns a pointer to the newly allocated FCB

--*/

{
    PFCB Fcb;
    PWCH Name;
    USHORT Length;
    USHORT MaximumLength;
    BOOLEAN AddBackSlash = FALSE;
    ULONG i;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "NpCreateFcb\n", 0);

    Length = FileName->Length;
    MaximumLength = Length + sizeof (WCHAR);
    if (Length < sizeof (WCHAR) || MaximumLength < Length) {
        return STATUS_INVALID_PARAMETER;
    }
    if (FileName->Buffer[0] != '\\') {
        AddBackSlash = TRUE;
        MaximumLength += sizeof (WCHAR);
        if (MaximumLength < sizeof (WCHAR)) {
            return STATUS_INVALID_PARAMETER;
        }
    }

    //
    //  Allocate a new FCB record and zero it out
    //

    Fcb = NpAllocatePagedPoolWithQuota( sizeof(FCB), 'FfpN' );
    if (Fcb == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory( Fcb, sizeof(FCB) );

    //
    //  Set the proper node type code and node byte size
    //

    Fcb->NodeTypeCode = NPFS_NTC_FCB;

    //
    //  Point back to our parent dcb
    //

    Fcb->ParentDcb = ParentDcb;

    //
    //  Set our maximum instances, default timeout, and initialize our
    //  ccb queue
    //

    Fcb->Specific.Fcb.MaximumInstances = MaximumInstances;
    Fcb->Specific.Fcb.DefaultTimeOut = DefaultTimeOut;
    InitializeListHead( &Fcb->Specific.Fcb.CcbQueue );

    //
    //  set the file name.  We need to do this from nonpaged pool because
    //  cancel waiters works while holding a spinlock and uses the fcb name
    //


    Name = NpAllocateNonPagedPoolWithQuota( MaximumLength, 'nFpN' );
    if (Name == NULL) {
        NpFreePool (Fcb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    //  Insert this fcb into our parent dcb's queue
    //

    InsertTailList( &ParentDcb->Specific.Dcb.ParentDcbQueue,
                    &Fcb->ParentDcbLinks );

    i = 0;
    if (AddBackSlash == TRUE) {
        i++;
        Name[0] = '\\';
    }
    RtlCopyMemory( &Name[i], FileName->Buffer, Length );
    Name[ i + Length / sizeof(WCHAR) ] = L'\0';

    Fcb->FullFileName.Length = MaximumLength - sizeof (WCHAR);
    Fcb->FullFileName.MaximumLength = MaximumLength ;
    Fcb->FullFileName.Buffer = Name;

    Fcb->LastFileName.Length = MaximumLength - 2*sizeof (WCHAR);
    Fcb->LastFileName.MaximumLength = MaximumLength - sizeof (WCHAR);
    Fcb->LastFileName.Buffer = &Name[1];

    //
    //  Insert this Fcb into the prefix table
    //

    if (!RtlInsertUnicodePrefix( &NpVcb->PrefixTable,
                                 &Fcb->FullFileName,
                                 &Fcb->PrefixTableEntry )) {

        DebugDump("Error trying to name into prefix table\n", 0, Fcb);
        NpBugCheck( 0, 0, 0 );
    }
    //
    //  Set the configuration and pipe type
    //

    Fcb->Specific.Fcb.NamedPipeConfiguration = NamedPipeConfiguration;
    Fcb->Specific.Fcb.NamedPipeType = NamedPipeType;

    DebugTrace(-1, Dbg, "NpCreateFcb -> %08lx\n", Fcb);

    //
    //  return and tell the caller
    //
    *ppFcb = Fcb;
    return STATUS_SUCCESS;
}


VOID
NpDeleteFcb (
    IN PFCB Fcb,
    IN PLIST_ENTRY DeferredList
    )

/*++

Routine Description:

    This routine deallocates and removes an FCB
    from our in-memory data structures.  It also will remove all
    associated underlings.

Arguments:

    Fcb - Supplies the FCB to be removed

    DeferredList - List of IRPs to complete later

Return Value:

    None

--*/

{
    PDCB ParentDcb;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "NpDeleteFcb, Fcb = %08lx\n", Fcb);

    ParentDcb = Fcb->ParentDcb;

    //
    //  We can only delete this record if the open count is zero.
    //

    if (Fcb->OpenCount != 0) {

        DebugDump("Error deleting Fcb, Still Open\n", 0, Fcb);
        NpBugCheck( 0, 0, 0 );
    }

    //
    // Complete any waiters waiting on this server. All instances have now gone.
    //
    NpCancelWaiter (&NpVcb->WaitQueue,
                    &Fcb->FullFileName,
                    STATUS_OBJECT_NAME_NOT_FOUND,
                    DeferredList);

    //
    //  Remove ourselves from our parents Dcb queue
    //

    RemoveEntryList( &(Fcb->ParentDcbLinks) );

    //
    //  If there is a security descriptor on the named pipe then deassign it
    //

    if (Fcb->SecurityDescriptor != NULL) {

        ObDereferenceSecurityDescriptor( Fcb->SecurityDescriptor, 1 );
    }

    //
    //  Remove the entry from the prefix table, and then remove the full
    //  file name
    //

    RtlRemoveUnicodePrefix( &NpVcb->PrefixTable, &Fcb->PrefixTableEntry );
    NpFreePool( Fcb->FullFileName.Buffer );

    //
    //  Finally deallocate the Fcb record
    //

    NpFreePool( Fcb );

    //
    //  Check for any outstanding notify irps
    //

    NpCheckForNotify( ParentDcb, TRUE, DeferredList );

    //
    //  and return to our caller
    //

    DebugTrace(-1, Dbg, "NpDeleteFcb -> VOID\n", 0);

    return;
}


NTSTATUS
NpCreateCcb (
    IN  PFCB Fcb,
    IN  PFILE_OBJECT ServerFileObject,
    IN  NAMED_PIPE_STATE NamedPipeState,
    IN  READ_MODE ServerReadMode,
    IN  COMPLETION_MODE ServerCompletionMode,
    IN  ULONG InBoundQuota,
    IN  ULONG OutBoundQuota,
    OUT PCCB *ppCcb
    )

/*++

Routine Description:

    This routine creates a new CCB record

Arguments:

    Fcb - Supplies a pointer to the fcb we are attached to

    ServerFileObject - Supplies a pointer to the file object for the server
        end

    NamedPipeState - Supplies the initial pipe state

    ServerReadMode - Supplies our initial read mode

    ServerCompletionMode - Supplies our initial completion mode

    CreatorProcess - Supplies a pointer to our creator process

    InBoundQuota - Supplies the initial inbound quota

    OutBoundQuota - Supplies the initial outbound quota

Return Value:

    PCCB - returns a pointer to the newly allocate CCB

--*/

{
    PCCB Ccb;
    NTSTATUS status;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "NpCreateCcb\n", 0);

    //
    //  Allocate a new CCB record (paged and nonpaged), and zero them out
    //

    Ccb = NpAllocatePagedPoolWithQuotaCold( sizeof(CCB), 'cFpN' );
    if (Ccb == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory( Ccb, sizeof(CCB) );

    Ccb->NonpagedCcb = NpAllocateNonPagedPoolWithQuota( sizeof(NONPAGED_CCB), 'cFpN');
    if (Ccb->NonpagedCcb == NULL) {
        NpFreePool (Ccb);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory( Ccb->NonpagedCcb, sizeof(NONPAGED_CCB) );

    //
    //  Set the proper node type code and node byte size
    //

    Ccb->NodeTypeCode = NPFS_NTC_CCB;

    Ccb->Fcb = Fcb;

    //
    //  Set the server file object
    //

    Ccb->FileObject[ FILE_PIPE_SERVER_END ] = ServerFileObject;

    //
    //  Initialize the nonpaged ccb
    //
    //  Set the proper node type code and node byte size
    //

    Ccb->NonpagedCcb->NodeTypeCode = NPFS_NTC_NONPAGED_CCB;

    //
    //  Set the pipe state, read mode, completion mode, and creator process
    //

    Ccb->NamedPipeState = (UCHAR) NamedPipeState;
    Ccb->ReadCompletionMode[ FILE_PIPE_SERVER_END ].ReadMode       = (UCHAR) ServerReadMode;
    Ccb->ReadCompletionMode[ FILE_PIPE_SERVER_END ].CompletionMode = (UCHAR) ServerCompletionMode;

    //
    //  Initialize the data queues
    //

    status = NpInitializeDataQueue( &Ccb->DataQueue[ FILE_PIPE_INBOUND ],
                                    InBoundQuota );
    if (!NT_SUCCESS (status)) {
        NpFreePool (Ccb->NonpagedCcb);
        NpFreePool (Ccb);
        return status;
    }

    status = NpInitializeDataQueue( &Ccb->DataQueue[ FILE_PIPE_OUTBOUND ],
                                    OutBoundQuota );
    if (!NT_SUCCESS (status)) {
        NpUninitializeDataQueue (&Ccb->DataQueue[ FILE_PIPE_INBOUND ]);
        NpFreePool (Ccb->NonpagedCcb);
        NpFreePool (Ccb);
    }

    //
    //  Insert ourselves in the list of ccb for the fcb, and increment
    //  the reference count in the fcb.
    //
    InsertTailList( &Fcb->Specific.Fcb.CcbQueue, &Ccb->CcbLinks );
    Fcb->OpenCount += 1;
    Fcb->ServerOpenCount += 1;

    //
    //  Initialize the listening queue
    //

    InitializeListHead( &Ccb->ListeningQueue );

    ExInitializeResourceLite(&Ccb->NonpagedCcb->Resource);

    //
    //  return and tell the caller
    //

    *ppCcb = Ccb;
    return STATUS_SUCCESS;
}


NTSTATUS
NpCreateRootDcbCcb (
    OUT PROOT_DCB_CCB *ppCcb
    )

/*++

Routine Description:

    This routine creates a new ROOT DCB CCB record

Arguments:

Return Value:

    PROOT_DCB_CCB - returns a pointer to the newly allocate ROOT_DCB_CCB

--*/

{
    PROOT_DCB_CCB Ccb;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "NpCreateRootDcbCcb\n", 0);

    //
    //  Allocate a new ROOT DCB CCB record, and zero it out
    //

    Ccb = NpAllocatePagedPoolWithQuotaCold ( sizeof(ROOT_DCB_CCB), 'CFpN' );

    if (Ccb == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory( Ccb, sizeof(ROOT_DCB_CCB) );

    //
    //  Set the proper node type code and node byte size
    //

    Ccb->NodeTypeCode = NPFS_NTC_ROOT_DCB_CCB;

    //
    //  return and tell the caller
    //

    *ppCcb = Ccb;

    DebugTrace(-1, Dbg, "NpCreateRootDcbCcb -> %08lx\n", Ccb);

    return STATUS_SUCCESS;
}


VOID
NpDeleteCcb (
    IN PCCB Ccb,
    IN PLIST_ENTRY DeferredList
    )

/*++

Routine Description:

    This routine deallocates and removes the specified CCB record
    from the our in memory data structures

Arguments:

    Ccb - Supplies the CCB to remove

    DeferredList - List of IRPs to complete once we drop locks

Return Value:

    None

--*/

{
    PAGED_CODE();

    DebugTrace(+1, Dbg, "NpDeleteCcb, Ccb = %08lx\n", Ccb);

    //
    //  Case on the type of ccb we are deleting
    //

    switch (Ccb->NodeTypeCode) {

    case NPFS_NTC_CCB:

        RemoveEntryList (&Ccb->CcbLinks);
        Ccb->Fcb->OpenCount -= 1;

        NpDeleteEventTableEntry (&NpVcb->EventTable,
                                 Ccb->NonpagedCcb->EventTableEntry[FILE_PIPE_CLIENT_END]);

        NpDeleteEventTableEntry (&NpVcb->EventTable,
                                 Ccb->NonpagedCcb->EventTableEntry[FILE_PIPE_SERVER_END]);

        NpUninitializeDataQueue (&Ccb->DataQueue[FILE_PIPE_INBOUND]);

        NpUninitializeDataQueue (&Ccb->DataQueue[FILE_PIPE_OUTBOUND]);

        //
        //  Check for any outstanding notify irps
        //

        NpCheckForNotify (Ccb->Fcb->ParentDcb, FALSE, DeferredList);

        //
        // Delete the resource
        //
        ExDeleteResourceLite (&Ccb->NonpagedCcb->Resource);

        //
        //  Free up the security fields in the ccb and then free the nonpaged
        //  ccb
        //

        NpUninitializeSecurity (Ccb);

        //
        // Free up client info if it was allocated.
        //
        if (Ccb->ClientInfo != NULL) {
            NpFreePool (Ccb->ClientInfo);
            Ccb->ClientInfo = NULL;
        }

        NpFreePool (Ccb->NonpagedCcb);

        break;

    case NPFS_NTC_ROOT_DCB_CCB:

        if (((PROOT_DCB_CCB)Ccb)->QueryTemplate != NULL) {

            NpFreePool (((PROOT_DCB_CCB)Ccb)->QueryTemplate);
        }
        break;
    }

    //  Deallocate the Ccb record
    //

    NpFreePool (Ccb);

    //
    //  return and tell the caller
    //

    DebugTrace(-1, Dbg, "NpDeleteCcb -> VOID\n", 0);

    return;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\npfs\statesup.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    StateSup.c

Abstract:

    This module implements the Named Pipe State Support routines

Author:

    Gary Kimura     [GaryKi]    30-Aug-1990

Revision History:

--*/

#include "NpProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (NPFS_BUG_CHECK_STATESUP)

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_STATESUP)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NpInitializePipeState)
#pragma alloc_text(PAGE, NpUninitializePipeState)
#pragma alloc_text(PAGE, NpSetListeningPipeState)
#pragma alloc_text(PAGE, NpSetConnectedPipeState)
#pragma alloc_text(PAGE, NpSetClosingPipeState)
#pragma alloc_text(PAGE, NpSetDisconnectedPipeState)
#endif

VOID
NpCancelListeningQueueIrp (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );


VOID
NpInitializePipeState (
    IN PCCB Ccb,
    IN PFILE_OBJECT ServerFileObject
    )

/*++

Routine Description:

    This routine initialize a named pipe instance to the disconnected state.

Arguments:

    Ccb - Supplies a pointer to the Ccb representing the pipe state

    ServerFileObject - Supplies a pointer to the server file object

Return Value:

    None.

--*/

{
    PAGED_CODE();

    DebugTrace(+1, Dbg, "NpInitializePipeState, Ccb = %08lx\n", Ccb);

    //
    //  Set the ccb and nonpaged ccb fields
    //

    Ccb->FileObject[ FILE_PIPE_SERVER_END ] = ServerFileObject;
    Ccb->NamedPipeState = FILE_PIPE_DISCONNECTED_STATE;

    //
    //  The file object contexts pointers.
    //

    NpSetFileObject( ServerFileObject,
                     Ccb,
                     Ccb->NonpagedCcb,
                     FILE_PIPE_SERVER_END );

    //
    //  and return to our caller
    //

    DebugTrace(-1, Dbg, "NpInitializePipeState -> VOID\n", 0);

    return;
}


VOID
NpUninitializePipeState (
    IN PCCB Ccb
    )

/*++

Routine Description:

    This routine initialize a named pipe instance to the disconnected state.

Arguments:

    Ccb - Supplies a pointer to the Ccb representing the pipe state

Return Value:

    None.

--*/

{
    PAGED_CODE();

    DebugTrace(+1, Dbg, "NpUninitializePipeState, Ccb = %08lx\n", Ccb);

    //
    //  The file object contexts pointers for our server to null
    //

    NpSetFileObject( Ccb->FileObject[ FILE_PIPE_SERVER_END ],
                     NULL,
                     NULL,
                     FILE_PIPE_SERVER_END );
    Ccb->FileObject[ FILE_PIPE_SERVER_END ] = NULL;


    //
    //  The file object contexts pointers for our client to null
    //

    NpSetFileObject( Ccb->FileObject[ FILE_PIPE_CLIENT_END ],
                     NULL,
                     NULL,
                     FILE_PIPE_CLIENT_END );
    Ccb->FileObject[ FILE_PIPE_CLIENT_END ] = NULL;

    //
    //  Set to null both pointers to file object.
    //

    Ccb->FileObject[ FILE_PIPE_SERVER_END ] = NULL;
    Ccb->FileObject[ FILE_PIPE_CLIENT_END ] = NULL;

    //
    //  and return to our caller
    //

    DebugTrace(-1, Dbg, "NpUninitializePipeState -> VOID\n", 0);

    return;
}


NTSTATUS
NpSetListeningPipeState (
    IN PCCB Ccb,
    IN PIRP Irp,
    IN PLIST_ENTRY DeferredList
    )

/*++

Routine Description:

    This routine sets a named pipe to the listening state.  This routine
    will either complete the IRP right away or put in the listening queue
    to be completed later.

Arguments:

    Ccb - Supplies a pointer to the Ccb representing the pipe state

    Irp - Supplies the Irp doing the listening operation

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS Status;

    DebugTrace(+1, Dbg, "NpSetListeningPipeState, Ccb = %08lx\n", Ccb);

    //
    //  Case on the current state of the named pipe
    //

    switch (Ccb->NamedPipeState) {

    case FILE_PIPE_DISCONNECTED_STATE:

        DebugTrace(0, Dbg, "Pipe was disconnected\n", 0);

        //
        //  Set the state to listening and check for any wait for named
        //  pipe requests.
        //

        Status = NpCancelWaiter (&NpVcb->WaitQueue,
                                 &Ccb->Fcb->FullFileName,
                                 STATUS_SUCCESS,
                                 DeferredList);
        if (!NT_SUCCESS (Status)) {
            break;
        }

        //
        //  If the completion mode is complete operation then we can
        //  complete this irp otherwise we need to enqueue the irp
        //  into the listening queue, and mark it pending.
        //

        if (Ccb->ReadCompletionMode[ FILE_PIPE_SERVER_END ].CompletionMode == FILE_PIPE_COMPLETE_OPERATION) {

            Ccb->NamedPipeState = FILE_PIPE_LISTENING_STATE;
            Status = STATUS_PIPE_LISTENING;

        } else {

            //
            //  Set the cancel routine and also check if the irp is already cancelled
            //
            IoSetCancelRoutine( Irp, NpCancelListeningQueueIrp );

            if (Irp->Cancel && IoSetCancelRoutine( Irp, NULL ) != NULL) {
                Status = STATUS_CANCELLED;
            } else {
                Ccb->NamedPipeState = FILE_PIPE_LISTENING_STATE;
                IoMarkIrpPending( Irp );
                InsertTailList( &Ccb->ListeningQueue, &Irp->Tail.Overlay.ListEntry );
                Status = STATUS_PENDING;
            }
        }

        break;

    case FILE_PIPE_LISTENING_STATE:

        DebugTrace(0, Dbg, "Pipe was listening\n", 0);

        //
        //  If the completion mode is complete operation then we can
        //  complete this irp otherwise we need to enqueue the irp
        //  into the listening queue, and mark it pending.
        //

        if (Ccb->ReadCompletionMode[ FILE_PIPE_SERVER_END ].CompletionMode == FILE_PIPE_COMPLETE_OPERATION) {

            Status = STATUS_PIPE_LISTENING;

        } else {

            //
            //  Set the cancel routine and also check if the irp is already cancelled
            //

            IoSetCancelRoutine( Irp, NpCancelListeningQueueIrp );

            if (Irp->Cancel && IoSetCancelRoutine( Irp, NULL ) != NULL) {
                Status = STATUS_CANCELLED;
            } else {
                IoMarkIrpPending( Irp );
                InsertTailList( &Ccb->ListeningQueue, &Irp->Tail.Overlay.ListEntry );
                Status = STATUS_PENDING;
            }
        }

        break;

    case FILE_PIPE_CONNECTED_STATE:

        DebugTrace(0, Dbg, "Pipe was connected\n", 0);

        Status = STATUS_PIPE_CONNECTED;

        break;

    case FILE_PIPE_CLOSING_STATE:

        DebugTrace(0, Dbg, "Pipe was closing\n", 0);

        Status = STATUS_PIPE_CLOSING;

        break;

    default:

        NpBugCheck( Ccb->NamedPipeState, 0, 0 );
    }

    //
    //  and return to our caller
    //

    DebugTrace(-1, Dbg, "NpSetListeningPipeState -> %08lx\n", Status);

    return Status;
}


NTSTATUS
NpSetConnectedPipeState (
    IN PCCB Ccb,
    IN PFILE_OBJECT ClientFileObject,
    IN PLIST_ENTRY DeferredList
    )

/*++

Routine Description:

    This routine sets the state of a named pipe to connected.

Arguments:

    Ccb - Supplies a pointer to the Ccb representing the pipe state

    ClientFileObject - Supplies the file object for the client that is
        doing the connect.

    DeferredList - List of IRP's to complete after we drop locks

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS Status;
    PNONPAGED_CCB NonpagedCcb;
    PIRP LocalIrp;

    DebugTrace(+1, Dbg, "NpSetConnectedPipeState, Ccb = %08lx\n", Ccb);

    //
    //  Save a pointer to the nonpaged ccb, we really need to do this now so when we
    //  complete our listening waiters we won't touch paged pool
    //

    NonpagedCcb = Ccb->NonpagedCcb;

    //
    //  Case on the current state of the named pipe
    //

    switch (Ccb->NamedPipeState) {

    case FILE_PIPE_DISCONNECTED_STATE:

        DebugTrace(0, Dbg, "Pipe was disconnected\n", 0);

        NpBugCheck( 0, 0, 0 );

    case FILE_PIPE_LISTENING_STATE:

        DebugTrace(0, Dbg, "Pipe was listening\n", 0);

        //
        //  Set the state of the pipe to connected and adjust the
        //  appropriate read mode and completion mode values
        //

        Ccb->NamedPipeState                         = FILE_PIPE_CONNECTED_STATE;
        Ccb->ReadCompletionMode[ FILE_PIPE_CLIENT_END ].ReadMode      = FILE_PIPE_BYTE_STREAM_MODE;
        Ccb->ReadCompletionMode[ FILE_PIPE_CLIENT_END ].CompletionMode = FILE_PIPE_QUEUE_OPERATION;

        //
        //  Set our back pointer to the client file object and set the
        //  client file object context pointers
        //

        Ccb->FileObject[ FILE_PIPE_CLIENT_END ] = ClientFileObject;

        NpSetFileObject( ClientFileObject,
                         Ccb,
                         NonpagedCcb,
                         FILE_PIPE_CLIENT_END );

        //
        //  And complete any listening waiters
        //

        while (!IsListEmpty( &Ccb->ListeningQueue )) {
            PLIST_ENTRY Links;

            Links = RemoveHeadList( &Ccb->ListeningQueue );

            LocalIrp = CONTAINING_RECORD( Links, IRP, Tail.Overlay.ListEntry );

            //
            // Remove the cancel routine and detect if cancel is active. If it is leave the IRP to the
            // cancel routine.

            if (IoSetCancelRoutine( LocalIrp, NULL ) != NULL) {
                NpDeferredCompleteRequest( LocalIrp, STATUS_SUCCESS, DeferredList );
            } else {
                InitializeListHead (&LocalIrp->Tail.Overlay.ListEntry);
            }
        }

        Status = STATUS_SUCCESS;

        break;

    case FILE_PIPE_CONNECTED_STATE:

        DebugTrace(0, Dbg, "Pipe was connected\n", 0);

        NpBugCheck( 0, 0, 0 );

    case FILE_PIPE_CLOSING_STATE:

        DebugTrace(0, Dbg, "Pipe was closing\n", 0);

        NpBugCheck( 0, 0, 0 );

    default:

        NpBugCheck( Ccb->NamedPipeState, 0, 0 );
    }

    //
    //  and return to our caller
    //

    DebugTrace(-1, Dbg, "NpSetConnectedPipeState -> %08lx\n", Status);

    return Status;
}


NTSTATUS
NpSetClosingPipeState (
    IN PCCB Ccb,
    IN PIRP Irp,
    IN NAMED_PIPE_END NamedPipeEnd,
    IN PLIST_ENTRY DeferredList
    )

/*++

Routine Description:

    This routine sets a pipe state to closing.  This routine will
    either complete the irp right away or put in on the data queue
    to be completed later.

Arguments:

    Ccb - Supplies a pointer to the Ccb representing the pipe state

    Irp - Supplies the Irp trying to do the close operation

    NamedPipeEnd - Indicates if the server or client is doing the transition

Return Value:

    NTSTATUS -

--*/

{
    NTSTATUS Status;

    PNONPAGED_CCB NonpagedCcb;

    PFCB Fcb;
    PIRP LocalIrp;
    KIRQL CancelIrql;

    PDATA_QUEUE ReadQueue;
    PDATA_QUEUE WriteQueue;

    PEVENT_TABLE_ENTRY Event;

    DebugTrace(+1, Dbg, "NpSetClosingPipeState, Ccb = %08lx\n", Ccb);

    Fcb = Ccb->Fcb;

    //
    //  Save a pointer to the nonpaged ccb, we really need to do this now so when we
    //  complete our listening waiters we won't touch paged pool
    //

    NonpagedCcb = Ccb->NonpagedCcb;

    //
    //  Case on the current state of the named pipe
    //

    switch (Ccb->NamedPipeState) {

    case FILE_PIPE_DISCONNECTED_STATE:

        DebugTrace(0, Dbg, "Pipe was disconnected\n", 0);

        ASSERT( NamedPipeEnd == FILE_PIPE_SERVER_END );

        //
        //  Pipe is disconnected, for safety sake we'll zero out the
        //  file objects context pointers to use
        //

        NpSetFileObject( Ccb->FileObject[ FILE_PIPE_SERVER_END ],
                         NULL,
                         NULL,
                         FILE_PIPE_SERVER_END );
        Ccb->FileObject[ FILE_PIPE_SERVER_END ] = NULL;

        NpSetFileObject( Ccb->FileObject[ FILE_PIPE_CLIENT_END ],
                         NULL,
                         NULL,
                         FILE_PIPE_CLIENT_END );
        Ccb->FileObject[ FILE_PIPE_CLIENT_END ] = NULL;

        //
        //  Close it we delete the instance, and possibly the Fcb if its
        //  open count is now zero.
        //

        NpDeleteCcb( Ccb, DeferredList );
        if (Fcb->OpenCount == 0) {

            NpDeleteFcb( Fcb, DeferredList );
        }

        Status = STATUS_SUCCESS;

        break;

    case FILE_PIPE_LISTENING_STATE:

        DebugTrace(0, Dbg, "Pipe was listening\n", 0);

        ASSERT( NamedPipeEnd == FILE_PIPE_SERVER_END );

        //
        //  Pipe in listening state, so complete all IRPs that are in the
        //  listening queue with a closing status, and then delete the
        //  instance and possibly the Fcb if its open count is now zero
        //

        //
        //  And complete any listening waiters
        //

        while (!IsListEmpty( &Ccb->ListeningQueue )) {
            PLIST_ENTRY Links;

            Links = RemoveHeadList( &Ccb->ListeningQueue );

            LocalIrp = CONTAINING_RECORD( Links, IRP, Tail.Overlay.ListEntry );

            //
            // Remove the cancel routine and detect if cancel is active. If it is leave the IRP to the
            // cancel routine.

            if (IoSetCancelRoutine( LocalIrp, NULL ) != NULL) {
                NpDeferredCompleteRequest( LocalIrp, STATUS_PIPE_BROKEN, DeferredList );
            } else {
                InitializeListHead (&LocalIrp->Tail.Overlay.ListEntry);
            }
        }

        //
        //  For safety sake we'll zero out the file objects context
        //  pointers to use
        //

        NpSetFileObject( Ccb->FileObject[ FILE_PIPE_SERVER_END ],
                         NULL,
                         NULL,
                         FILE_PIPE_SERVER_END );
        Ccb->FileObject[ FILE_PIPE_SERVER_END ] = NULL;

        NpSetFileObject( Ccb->FileObject[ FILE_PIPE_CLIENT_END ],
                         NULL,
                         NULL,
                         FILE_PIPE_CLIENT_END );
        Ccb->FileObject[ FILE_PIPE_CLIENT_END ] = NULL;

        //
        //  Remove the ccb and possibly the Fcb
        //

        NpDeleteCcb( Ccb, DeferredList );
        if (Fcb->OpenCount == 0) {

            NpDeleteFcb( Fcb, DeferredList );
        }

        //
        //  And now complete the irp
        //

        Status = STATUS_SUCCESS;

        break;

    case FILE_PIPE_CONNECTED_STATE:

        //
        //  The pipe is connected so decide who is trying to do the close
        //  and then fall into common code
        //

        if (NamedPipeEnd == FILE_PIPE_SERVER_END) {

            DebugTrace(0, Dbg, "Pipe was connected, server doing close\n", 0);

            ReadQueue = &Ccb->DataQueue[ FILE_PIPE_INBOUND ];
            WriteQueue = &Ccb->DataQueue[ FILE_PIPE_OUTBOUND ];

            Event = NonpagedCcb->EventTableEntry[ FILE_PIPE_CLIENT_END ];

            //
            //  For safety sake we'll zero out the file objects context
            //  pointers to use
            //

            NpSetFileObject( Ccb->FileObject[ FILE_PIPE_SERVER_END ],
                             NULL,
                             NULL,
                             FILE_PIPE_SERVER_END );
            Ccb->FileObject[ FILE_PIPE_SERVER_END ] = NULL;

        } else {

            DebugTrace(0, Dbg, "Pipe was connected, client doing close\n", 0);

            ReadQueue = &Ccb->DataQueue[ FILE_PIPE_OUTBOUND ];
            WriteQueue = &Ccb->DataQueue[ FILE_PIPE_INBOUND ];

            Event = NonpagedCcb->EventTableEntry[ FILE_PIPE_SERVER_END ];

            //
            //  For safety sake we'll zero out the file objects context
            //  pointers to use
            //

            NpSetFileObject( Ccb->FileObject[ FILE_PIPE_CLIENT_END ],
                             NULL,
                             NULL,
                             FILE_PIPE_CLIENT_END );
            Ccb->FileObject[ FILE_PIPE_CLIENT_END ] = NULL;
        }

        //
        //  To do a close on a connected pipe we set its state to closing
        //  drain the read queue and drain reads on the write queue.
        //
        //
        //      Closing <---ReadQueue----  [ Remove all entries ]
        //      End
        //               ---WriteQueue---> [ Remove only read entries ]
        //

        Ccb->NamedPipeState = FILE_PIPE_CLOSING_STATE;

        while (!NpIsDataQueueEmpty( ReadQueue )) {

            if ((LocalIrp = NpRemoveDataQueueEntry( ReadQueue, FALSE, DeferredList )) != NULL) {

                NpDeferredCompleteRequest( LocalIrp, STATUS_PIPE_BROKEN, DeferredList );
            }
        }

        while (!NpIsDataQueueEmpty( WriteQueue ) &&
               (WriteQueue->QueueState == ReadEntries)) {

            if ((LocalIrp = NpRemoveDataQueueEntry( WriteQueue, FALSE, DeferredList )) != NULL) {

                NpDeferredCompleteRequest( LocalIrp, STATUS_PIPE_BROKEN, DeferredList );
            }
        }

        Status = STATUS_SUCCESS;

        //
        //  Now signal the other sides event to show that something has
        //  happened
        //

        NpSignalEventTableEntry( Event );

        break;

    case FILE_PIPE_CLOSING_STATE:

        //
        //  The pipe is closing so decide who is trying to complete the close
        //  and then fall into common code
        //

        if (NamedPipeEnd == FILE_PIPE_SERVER_END) {

            DebugTrace(0, Dbg, "Pipe was closing, server doing close\n", 0);

            ReadQueue = &Ccb->DataQueue[ FILE_PIPE_INBOUND ];

            //
            //  For safety sake we'll zero out the file objects context
            //  pointers to use
            //

            NpSetFileObject( Ccb->FileObject[ FILE_PIPE_SERVER_END ],
                             NULL,
                             NULL,
                             FILE_PIPE_SERVER_END );
            Ccb->FileObject[ FILE_PIPE_SERVER_END ] = NULL;

            NpSetFileObject( Ccb->FileObject[ FILE_PIPE_CLIENT_END ],
                             NULL,
                             NULL,
                             FILE_PIPE_CLIENT_END );
            Ccb->FileObject[ FILE_PIPE_CLIENT_END ] = NULL;

        } else {

            DebugTrace(0, Dbg, "Pipe was closing, client doing close\n", 0);

            ReadQueue = &Ccb->DataQueue[ FILE_PIPE_OUTBOUND ];

            //
            //  For safety sake we'll zero out the file objects context
            //  pointers to use
            //

            NpSetFileObject( Ccb->FileObject[ FILE_PIPE_SERVER_END ],
                             NULL,
                             NULL,
                             FILE_PIPE_SERVER_END );
            Ccb->FileObject[ FILE_PIPE_SERVER_END ] = NULL;

            NpSetFileObject( Ccb->FileObject[ FILE_PIPE_CLIENT_END ],
                             NULL,
                             NULL,
                             FILE_PIPE_CLIENT_END );
            Ccb->FileObject[ FILE_PIPE_CLIENT_END ] = NULL;
        }

        //
        //  To do a close on a closing pipe we drain the read queue of
        //  all its entries, delete the instance, and possibly delete the
        //  Fcb if its open count is now zero.
        //
        //
        //      Previously  <-----Closed-----   Closing
        //      Closed                          End
        //      End          ----ReadQueue--->
        //

        while (!NpIsDataQueueEmpty( ReadQueue )) {

            if ((LocalIrp = NpRemoveDataQueueEntry( ReadQueue, FALSE, DeferredList )) != NULL) {

                NpDeferredCompleteRequest( LocalIrp, STATUS_PIPE_BROKEN, DeferredList );
            }
        }

        NpUninitializeSecurity (Ccb);

        if (Ccb->ClientInfo != NULL) {
            NpFreePool (Ccb->ClientInfo);
            Ccb->ClientInfo = NULL;
        }

        NpDeleteCcb( Ccb, DeferredList );
        if (Fcb->OpenCount == 0) {

            NpDeleteFcb( Fcb, DeferredList );
        }

        Status = STATUS_SUCCESS;

        break;

    default:

        NpBugCheck( Ccb->NamedPipeState, 0, 0 );
    }

    //
    //  and return to our caller
    //

    DebugTrace(-1, Dbg, "NpSetClosingPipeState -> %08lx\n", Status);

    return Status;
}


NTSTATUS
NpSetDisconnectedPipeState (
    IN PCCB Ccb,
    IN PLIST_ENTRY DeferredList
    )

/*++

Routine Description:

    This routine sets a pipe state to disconnected, only the server is
    allowed to do this transition

Arguments:

    Ccb - Supplies a pointer to the Ccb representing the pipe instance

    DeferredList - List of IRPs to complete later after we drop the locks

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS Status;

    PNONPAGED_CCB NonpagedCcb;

    PIRP Irp;

    PDATA_QUEUE Inbound;
    PDATA_QUEUE Outbound;
    PEVENT_TABLE_ENTRY ClientEvent;


    DebugTrace(+1, Dbg, "NpSetDisconnectedPipeState, Ccb = %08lx\n", Ccb);


    //
    //  Save a pointer to the nonpaged ccb, we really need to do this now so when we
    //  complete our listening waiters we won't touch paged pool
    //

    NonpagedCcb = Ccb->NonpagedCcb;

    //
    //  Case on the current state of the named pipe
    //

    switch (Ccb->NamedPipeState) {

    case FILE_PIPE_DISCONNECTED_STATE:

        DebugTrace(0, Dbg, "Pipe already disconnected\n", 0);

        //
        //  pipe already disconnected so there is no work for us to do
        //

        Status = STATUS_PIPE_DISCONNECTED;

        break;

    case FILE_PIPE_LISTENING_STATE:

        DebugTrace(0, Dbg, "Pipe was listening\n", 0);

        //
        //  Pipe in listening state, so complete all IRPs that are in the
        //  listening queue with a disconnected status
        //

        while (!IsListEmpty( &Ccb->ListeningQueue )) {
            PLIST_ENTRY Links;

            Links = RemoveHeadList( &Ccb->ListeningQueue );

            Irp = CONTAINING_RECORD( Links, IRP, Tail.Overlay.ListEntry );

            //
            // Remove the cancel routine and detect if cancel is active. If it is leave the IRP to the
            // cancel routine.

            if (IoSetCancelRoutine( Irp, NULL ) != NULL) {
                NpDeferredCompleteRequest( Irp, STATUS_PIPE_DISCONNECTED, DeferredList );
            } else {
                InitializeListHead (&Irp->Tail.Overlay.ListEntry);
            }
        }

        Status = STATUS_SUCCESS;

        break;

    case FILE_PIPE_CONNECTED_STATE:

        DebugTrace(0, Dbg, "Pipe was connected\n", 0);

        Inbound = &Ccb->DataQueue[ FILE_PIPE_INBOUND ];
        Outbound = &Ccb->DataQueue[ FILE_PIPE_OUTBOUND ];
        ClientEvent = NonpagedCcb->EventTableEntry[ FILE_PIPE_CLIENT_END ];

        //
        //  Pipe is connected so we need to discard all of the data queues
        //  and complete any of their IRPs with status disconnected.
        //

        while (!NpIsDataQueueEmpty( Inbound )) {

            if ((Irp = NpRemoveDataQueueEntry( Inbound, FALSE, DeferredList )) != NULL) {

                NpDeferredCompleteRequest( Irp, STATUS_PIPE_DISCONNECTED, DeferredList );
            }
        }

        while (!NpIsDataQueueEmpty( Outbound )) {

            if ((Irp = NpRemoveDataQueueEntry( Outbound, FALSE, DeferredList )) != NULL) {

                NpDeferredCompleteRequest( Irp, STATUS_PIPE_DISCONNECTED, DeferredList );
            }
        }

        //
        //  Signal the client event and then remove it from the pipe
        //

        NpSignalEventTableEntry( ClientEvent );

        NpDeleteEventTableEntry( &NpVcb->EventTable, ClientEvent );
        NonpagedCcb->EventTableEntry[ FILE_PIPE_CLIENT_END ] = NULL;

        //
        //  Disable the client's file object
        //

        NpSetFileObject( Ccb->FileObject[ FILE_PIPE_CLIENT_END ],
                         NULL,
                         NULL,
                         FILE_PIPE_CLIENT_END );
        Ccb->FileObject[ FILE_PIPE_CLIENT_END ] = NULL;

        NpUninitializeSecurity (Ccb);

        if (Ccb->ClientInfo != NULL) {
            NpFreePool (Ccb->ClientInfo);
            Ccb->ClientInfo = NULL;
        }

        Status = STATUS_SUCCESS;

        break;

    case FILE_PIPE_CLOSING_STATE:

        DebugTrace(0, Dbg, "Pipe was closing\n", 0);

        Inbound = &Ccb->DataQueue[ FILE_PIPE_INBOUND ];
        Outbound = &Ccb->DataQueue[ FILE_PIPE_OUTBOUND ];
        ClientEvent = NonpagedCcb->EventTableEntry[ FILE_PIPE_CLIENT_END ];

        //
        //  Pipe is closing (this had to have been done by the client) we
        //  need to discard all of the data queues (only the inbound can have
        //  entries) and complete any of their IRPs with status disconnected.
        //
        //
        //      Server  <----Inbound----    Client
        //      End                         End
        //               ----Closed----->
        //

        while (!NpIsDataQueueEmpty( Inbound )) {

            if ((Irp = NpRemoveDataQueueEntry( Inbound, FALSE, DeferredList )) != NULL) {

                NpDeferredCompleteRequest( Irp, STATUS_PIPE_DISCONNECTED, DeferredList );
            }
        }

        ASSERT( NpIsDataQueueEmpty( Outbound ) );

        //
        //  The client event should already be gone but for safety sake
        //  we'll make sure its gone.
        //

        NpDeleteEventTableEntry( &NpVcb->EventTable, ClientEvent );
        NonpagedCcb->EventTableEntry[ FILE_PIPE_CLIENT_END ] = NULL;

        //
        //  Also if it's still connected, disable the client's file object
        //

        NpSetFileObject( Ccb->FileObject[ FILE_PIPE_CLIENT_END ],
                         NULL,
                         NULL,
                         FILE_PIPE_CLIENT_END );
        Ccb->FileObject[ FILE_PIPE_CLIENT_END ] = NULL;

        NpUninitializeSecurity (Ccb);

        if (Ccb->ClientInfo != NULL) {
            NpFreePool (Ccb->ClientInfo);
            Ccb->ClientInfo = NULL;
        }

        Status = STATUS_SUCCESS;

        break;

    default:

        NpBugCheck( Ccb->NamedPipeState, 0, 0 );
    }

    //
    //  Set the state to disconnected
    //

    Ccb->NamedPipeState = FILE_PIPE_DISCONNECTED_STATE;

    //
    //  and return to our caller
    //

    DebugTrace(-1, Dbg, "NpSetDisconnectedPipeState -> %08lx\n", Status);

    return Status;
}


//
//  Local support routine
//

VOID
NpCancelListeningQueueIrp (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the cancel function for an IRP saved in a listening
    queue

Arguments:

    DeviceObject - ignored

    Irp - Supplies the Irp being cancelled.  A pointer to the ccb
        structure is stored in the information field of the Irp Iosb
        field.

Return Value:

    None.

--*/

{
    UNREFERENCED_PARAMETER( DeviceObject );


    IoReleaseCancelSpinLock( Irp->CancelIrql );

    //
    //  Get exclusive access to the named pipe vcb so we can now do our work
    //

    FsRtlEnterFileSystem();
    NpAcquireExclusiveVcb();

    RemoveEntryList( &Irp->Tail.Overlay.ListEntry );

    NpReleaseVcb();
    FsRtlExitFileSystem();

    NpCompleteRequest( Irp, STATUS_CANCELLED );
    //
    //  And return to our caller
    //

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\npfs\volinfo.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    VolInfo.c

Abstract:

    This module implements the volume information routines for NPFS called by
    the dispatch driver.

Author:

    Gary Kimura     [GaryKi]    12-Apr-1990

Revision History:

--*/

#include "NpProcs.h"

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_VOLINFO)

//
//  Local procedure prototypes
//

NTSTATUS
NpCommonQueryVolumeInformation (
    IN PIRP Irp
    );

NTSTATUS
NpQueryFsDeviceInfo (
    IN PFILE_FS_DEVICE_INFORMATION Buffer,
    IN OUT PULONG Length
    );

NTSTATUS
NpQueryFsAttributeInfo (
    IN PFILE_FS_ATTRIBUTE_INFORMATION Buffer,
    IN OUT PULONG Length
    );

NTSTATUS
NpQueryFsVolumeInfo (
    IN PFILE_FS_VOLUME_INFORMATION Buffer,
    IN OUT PULONG Length
    );

NTSTATUS
NpQueryFsSizeInfo (
    IN PFILE_FS_SIZE_INFORMATION Buffer,
    IN OUT PULONG Length
    );

NTSTATUS
NpQueryFsFullSizeInfo (
    IN PFILE_FS_FULL_SIZE_INFORMATION Buffer,
    IN OUT PULONG Length
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NpCommonQueryVolumeInformation)
#pragma alloc_text(PAGE, NpFsdQueryVolumeInformation)
#pragma alloc_text(PAGE, NpQueryFsAttributeInfo)
#pragma alloc_text(PAGE, NpQueryFsDeviceInfo)
#pragma alloc_text(PAGE, NpQueryFsVolumeInfo)
#pragma alloc_text(PAGE, NpQueryFsSizeInfo)
#pragma alloc_text(PAGE, NpQueryFsFullSizeInfo)
#endif


NTSTATUS
NpFsdQueryVolumeInformation (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the Fsd part of the NtQueryVolumeInformation API
    call.

Arguments:

    VolumeDeviceObject - Supplies the volume device object where the file
        being queried exists.

    Irp - Supplies the Irp being processed.

Return Value:

    NTSTATUS - The FSD status for the Irp.

--*/

{
    NTSTATUS Status;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "NpFsdQueryVolumeInformation\n", 0);

    //
    //  Call the common query routine, with blocking allowed if synchronous
    //

    FsRtlEnterFileSystem();

    Status = NpCommonQueryVolumeInformation( Irp );

    FsRtlExitFileSystem();

    if (Status != STATUS_PENDING) {
        NpCompleteRequest (Irp, Status);
    }

    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "NpFsdQueryVolumeInformation -> %08lx\n", Status);

    return Status;
}

//
//  Internal support routine
//

NTSTATUS
NpCommonQueryVolumeInformation (
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for querying volume information.

Arguments:

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;

    ULONG Length;
    FS_INFORMATION_CLASS FsInformationClass;
    PVOID Buffer;

    PAGED_CODE();

    //
    //  Get the current stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "NptCommonQueryVolumeInfo...\n", 0);
    DebugTrace( 0, Dbg, "Irp                = %08lx\n", Irp );
    DebugTrace( 0, Dbg, "Length             = %08lx\n", IrpSp->Parameters.QueryVolume.Length);
    DebugTrace( 0, Dbg, "FsInformationClass = %08lx\n", IrpSp->Parameters.QueryVolume.FsInformationClass);
    DebugTrace( 0, Dbg, "Buffer             = %08lx\n", Irp->AssociatedIrp.SystemBuffer);

    //
    //  Reference our input parameters to make things easier
    //

    Length = IrpSp->Parameters.QueryVolume.Length;
    FsInformationClass = IrpSp->Parameters.QueryVolume.FsInformationClass;
    Buffer = Irp->AssociatedIrp.SystemBuffer;

    switch (FsInformationClass) {

    case FileFsDeviceInformation:

        Status = NpQueryFsDeviceInfo( Buffer, &Length );
        break;

    case FileFsAttributeInformation:

        Status = NpQueryFsAttributeInfo( Buffer, &Length );
        break;

    case FileFsVolumeInformation:

        Status = NpQueryFsVolumeInfo( Buffer, &Length );
        break;

    case FileFsSizeInformation:

        Status = NpQueryFsSizeInfo( Buffer, &Length );
        break;

    case FileFsFullSizeInformation:

        Status = NpQueryFsFullSizeInfo( Buffer, &Length );
        break;

    default:

        Status = STATUS_NOT_SUPPORTED;
        break;
    }

    //
    //  Set the information field to the number of bytes actually filled in
    //

    Irp->IoStatus.Information = IrpSp->Parameters.QueryVolume.Length - Length;

    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "NpCommonQueryVolumeInformation -> %08lx\n", Status);

    return Status;
}


//
//  Internal support routine
//

NTSTATUS
NpQueryFsDeviceInfo (
    IN PFILE_FS_DEVICE_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    This routine implements the query volume device call

Arguments:

    Buffer - Supplies a pointer to the output buffer where the information
        is to be returned

    Length - Supplies the length of the buffer in byte.  This variable
        upon return recieves the remaining bytes free in the buffer

Return Value:

    Status - Returns the status for the query

--*/

{
    PAGED_CODE();

    DebugTrace(0, Dbg, "NpQueryFsDeviceInfo...\n", 0);

    //
    //  Make sure the buffer is large enough
    //

    if (*Length < sizeof(FILE_FS_DEVICE_INFORMATION)) {

        return STATUS_BUFFER_OVERFLOW;
    }

    RtlZeroMemory( Buffer, sizeof(FILE_FS_DEVICE_INFORMATION) );

    //
    //  Set the output buffer
    //

    Buffer->DeviceType = FILE_DEVICE_NAMED_PIPE;

    //
    //  Adjust the length variable
    //

    *Length -= sizeof(FILE_FS_DEVICE_INFORMATION);

    //
    //  And return success to our caller
    //

    return STATUS_SUCCESS;
}


//
//  Internal support routine
//

NTSTATUS
NpQueryFsAttributeInfo (
    IN PFILE_FS_ATTRIBUTE_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    This routine implements the query volume attribute call

Arguments:

    Buffer - Supplies a pointer to the output buffer where the information
        is to be returned

    Length - Supplies the length of the buffer in byte.  This variable
        upon return recieves the remaining bytes free in the buffer

Return Value:

    Status - Returns the status for the query

--*/

{
    ULONG BytesToCopy;

    NTSTATUS Status;

    PAGED_CODE();

    DebugTrace(0, Dbg, "NpQueryFsAttributeInfo...\n", 0);

    //
    //  Determine how much of the file system name will fit.
    //

    if ( (*Length - FIELD_OFFSET( FILE_FS_ATTRIBUTE_INFORMATION,
                                  FileSystemName[0] )) >= 8 ) {

        BytesToCopy = 8;
        *Length -= FIELD_OFFSET( FILE_FS_ATTRIBUTE_INFORMATION,
                                 FileSystemName[0] ) + 8;
        Status = STATUS_SUCCESS;

    } else {

        BytesToCopy = *Length - FIELD_OFFSET( FILE_FS_ATTRIBUTE_INFORMATION,
                                              FileSystemName[0]);
        *Length = 0;

        Status = STATUS_BUFFER_OVERFLOW;
    }

    //
    //  Set the output buffer
    //

    Buffer->FileSystemAttributes       = FILE_CASE_PRESERVED_NAMES;
    Buffer->MaximumComponentNameLength = MAXULONG;
    Buffer->FileSystemNameLength       = BytesToCopy;

    RtlCopyMemory( &Buffer->FileSystemName[0], L"NPFS", BytesToCopy );

    //
    //  And return success to our caller
    //

    return Status;
}

NTSTATUS
NpQueryFsVolumeInfo (
    IN PFILE_FS_VOLUME_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    This routine implements the query volume info call

Arguments:

    Buffer - Supplies a pointer to the buffer where the information is
        to be returned.

    Length - Supplies the length of the buffer in bytes.

Return Value:

    NTSTATUS - The result of this query.

--*/

{

#define NPFS_VOLUME_LABEL                L"NamedPipe"

    ULONG BytesToCopy;
    NTSTATUS Status;

    Status = STATUS_SUCCESS;

    Buffer->VolumeCreationTime.QuadPart = 0;
    Buffer->VolumeSerialNumber = 0;

    Buffer->SupportsObjects = FALSE;

    *Length -= FIELD_OFFSET( FILE_FS_VOLUME_INFORMATION, VolumeLabel[0] );
    //
    //  Check if the buffer we're given is long enough
    //

    BytesToCopy = sizeof (NPFS_VOLUME_LABEL) - sizeof (WCHAR);

    if (*Length < BytesToCopy) {

        BytesToCopy = *Length;

        Status = STATUS_BUFFER_OVERFLOW;
    }

    //
    //  Copy over what we can of the volume label, and adjust *Length
    //

    Buffer->VolumeLabelLength = BytesToCopy;

    if (BytesToCopy) {

        RtlCopyMemory( &Buffer->VolumeLabel[0],
                       NPFS_VOLUME_LABEL,
                       BytesToCopy );
    }

    *Length -= BytesToCopy;

    //
    //  Set our status and return to our caller
    //

    return Status;
}

NTSTATUS
NpQueryFsSizeInfo (
    IN PFILE_FS_SIZE_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    This routine implements the query size info call

Arguments:

    Buffer - Supplies a pointer to the buffer where the information is
        to be returned.

    Length - Supplies the length of the buffer in bytes.

Return Value:

    NTSTATUS - The result of this query.

--*/

{

    Buffer->TotalAllocationUnits.QuadPart = 0;
    Buffer->AvailableAllocationUnits.QuadPart = 0;
    Buffer->SectorsPerAllocationUnit = 1;
    Buffer->BytesPerSector = 1;

    *Length -= sizeof( FILE_FS_SIZE_INFORMATION );

    //
    //  Set our status and return to our caller
    //

    return STATUS_SUCCESS;
}

NTSTATUS
NpQueryFsFullSizeInfo (
    IN PFILE_FS_FULL_SIZE_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    This routine implements the query full size info call

Arguments:

    Buffer - Supplies a pointer to the buffer where the information is
        to be returned.

    Length - Supplies the length of the buffer in bytes.

Return Value:

    NTSTATUS - The result of this query.

--*/

{

    RtlZeroMemory( Buffer, sizeof(FILE_FS_FULL_SIZE_INFORMATION) );


    *Length -= sizeof(FILE_FS_FULL_SIZE_INFORMATION);

    //
    //  Set our status and return to our caller
    //

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\npfs\write.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    Write.c

Abstract:

    This module implements the File Write routine for NPFS called by the
    dispatch driver.

Author:

    Gary Kimura     [GaryKi]    21-Aug-1990

Revision History:

--*/

#include "NpProcs.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_WRITE)

#if DBG
ULONG NpFastWriteTrue = 0;
ULONG NpFastWriteFalse = 0;
ULONG NpSlowWriteCalls = 0;
#endif

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NpCommonWrite)
#pragma alloc_text(PAGE, NpFastWrite)
#pragma alloc_text(PAGE, NpFsdWrite)
#endif


NTSTATUS
NpFsdWrite (
    IN PNPFS_DEVICE_OBJECT NpfsDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the FSD part of the NtWriteFile API calls.

Arguments:

    NpfsDeviceObject - Supplies the device object to use.

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The Fsd status for the Irp

--*/

{
    IO_STATUS_BLOCK Iosb;
    PIO_STACK_LOCATION IrpSp;
    LIST_ENTRY DeferredList;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "NpFsdWrite\n", 0);
    DbgDoit( NpSlowWriteCalls += 1 );

    InitializeListHead (&DeferredList);

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    FsRtlEnterFileSystem();

    NpAcquireSharedVcb();

    (VOID) NpCommonWrite( IrpSp->FileObject,
                          Irp->UserBuffer,
                          IrpSp->Parameters.Write.Length,
                          Irp->Tail.Overlay.Thread,
                          &Iosb,
                          Irp,
                          &DeferredList );

    NpReleaseVcb();

    //
    // Complete any deferred IRPs now we have dropped the locks
    //
    NpCompleteDeferredIrps (&DeferredList);

    FsRtlExitFileSystem();

    if (Iosb.Status != STATUS_PENDING) {
        Irp->IoStatus.Information = Iosb.Information;
        NpCompleteRequest (Irp, Iosb.Status);
    }

    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "NpFsdWrite -> %08lx\n", Iosb.Status );

    return Iosb.Status;
}


BOOLEAN
NpFastWrite (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine does a fast write bypassing the usual file system
    entry routine (i.e., without the Irp).

Arguments:

    FileObject - Pointer to the file object being read.

    FileOffset - Byte offset in file for desired data.

    Length - Length of desired data in bytes.

    Wait - FALSE if caller may not block, TRUE otherwise

    LockKey - Supplies the Key used to use if the byte range being read is locked.

    Buffer - Pointer to output buffer to which data should be copied.

    IoStatus - Pointer to standard I/O status block to receive the status
               for the transfer.

Return Value:

    BOOLEAN - TRUE if the operation completed successfully and FALSE if the
        caller needs to take the long IRP based route.

--*/

{
    BOOLEAN Results = FALSE;
    LIST_ENTRY DeferredList;

    UNREFERENCED_PARAMETER( FileOffset );
    UNREFERENCED_PARAMETER( Wait );
    UNREFERENCED_PARAMETER( LockKey );
    UNREFERENCED_PARAMETER( DeviceObject );

    PAGED_CODE();

    InitializeListHead (&DeferredList);

    FsRtlEnterFileSystem();

    NpAcquireSharedVcb();

    if (NpCommonWrite( FileObject,
                       Buffer,
                       Length,
                       PsGetCurrentThread(),
                       IoStatus,
                       NULL,
                       &DeferredList )) {

        DbgDoit( NpFastWriteTrue += 1 );

        Results = TRUE;
    } else {

        DbgDoit( NpFastWriteFalse += 1 );
    }

    NpReleaseVcb();

    //
    // Complete any deferred IRPs now we have dropped the locks
    //
    NpCompleteDeferredIrps (&DeferredList);

    FsRtlExitFileSystem();
    return Results;
}


//
//  Internal support routine
//

BOOLEAN
NpCommonWrite (
    IN PFILE_OBJECT FileObject,
    IN PVOID WriteBuffer,
    IN ULONG WriteLength,
    IN PETHREAD UserThread,
    OUT PIO_STATUS_BLOCK Iosb,
    IN PIRP Irp OPTIONAL,
    IN PLIST_ENTRY DeferredList
    )

/*++

Routine Description:

    This is the common routine for writing data to a named pipe both via the
    fast path and with an Irp.

Arguments:

    FileObject - Supplies the file object used in this operation

    WriteBuffer - Supplies the buffer where data from which data is to be read

    WriteLength - Supplies the length of the write buffer in bytes

    UserThread - Supplies the thread id of the caller

    Iosb - Receives the final completion status of this operation

    Irp - Optionally supplies an Irp to be used in this operation

Return Value:

    NTSTATUS - the return status for the operation

--*/

{
    NODE_TYPE_CODE NodeTypeCode;
    PCCB Ccb;
    PNONPAGED_CCB NonpagedCcb;
    NAMED_PIPE_END NamedPipeEnd;

    NAMED_PIPE_CONFIGURATION NamedPipeConfiguration;

    ULONG WriteRemaining;
    PDATA_QUEUE WriteQueue;

    PEVENT_TABLE_ENTRY Event;
    READ_MODE ReadMode;
    BOOLEAN Status;

    PDATA_ENTRY DataEntry;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "NpCommonWrite\n", 0);
    DebugTrace( 0, Dbg, "FileObject  = %08lx\n", FileObject);
    DebugTrace( 0, Dbg, "WriteBuffer = %08lx\n", WriteBuffer);
    DebugTrace( 0, Dbg, "WriteLength = %08lx\n", WriteLength);
    DebugTrace( 0, Dbg, "UserThread  = %08lx\n", UserThread);
    DebugTrace( 0, Dbg, "Iosb        = %08lx\n", Iosb);
    DebugTrace( 0, Dbg, "Irp         = %08lx\n", Irp);

    Iosb->Information = 0;

    //
    //  Get the Ccb and figure out who we are, and make sure we're not
    //  disconnected
    //

    if ((NodeTypeCode = NpDecodeFileObject( FileObject,
                                            NULL,
                                            &Ccb,
                                            &NamedPipeEnd )) == NTC_UNDEFINED) {

        DebugTrace(0, Dbg, "Pipe is disconnected from us\n", 0);

        Iosb->Status = STATUS_PIPE_DISCONNECTED;
        return TRUE;
    }

    //
    //  Now we only will allow write operations on the pipe and not a directory
    //  or the device
    //

    if (NodeTypeCode != NPFS_NTC_CCB) {

        DebugTrace(0, Dbg, "FileObject is not for a named pipe\n", 0);

        Iosb->Status = STATUS_INVALID_PARAMETER;
        return TRUE;
    }

    NpAcquireExclusiveCcb(Ccb);

    NonpagedCcb = Ccb->NonpagedCcb;

    try {
        //
        //  Check if the pipe is not in the connected state.
        //

        if ((Ccb->NamedPipeState == FILE_PIPE_DISCONNECTED_STATE) ||
            (Ccb->NamedPipeState == FILE_PIPE_LISTENING_STATE) ||
            (Ccb->NamedPipeState == FILE_PIPE_CLOSING_STATE)) {

            DebugTrace(0, Dbg, "Pipe in disconnected or listening or closing state\n", 0);

            if (Ccb->NamedPipeState == FILE_PIPE_DISCONNECTED_STATE) {

                Iosb->Status = STATUS_PIPE_DISCONNECTED;

            } else if (Ccb->NamedPipeState == FILE_PIPE_LISTENING_STATE) {

                Iosb->Status = STATUS_PIPE_LISTENING;

            } else {

                Iosb->Status = STATUS_PIPE_CLOSING;
            }

            try_return(Status = TRUE);
        }

        ASSERT(Ccb->NamedPipeState == FILE_PIPE_CONNECTED_STATE);

        //
        //  We only allow a write by the server on a non inbound only pipe
        //  and by the client on a non outbound only pipe
        //

        NamedPipeConfiguration = Ccb->Fcb->Specific.Fcb.NamedPipeConfiguration;

        if (((NamedPipeEnd == FILE_PIPE_SERVER_END) &&
             (NamedPipeConfiguration == FILE_PIPE_INBOUND))

                ||

            ((NamedPipeEnd == FILE_PIPE_CLIENT_END) &&
             (NamedPipeConfiguration == FILE_PIPE_OUTBOUND))) {

            DebugTrace(0, Dbg, "Trying to write to the wrong pipe configuration\n", 0);

            Iosb->Status = STATUS_INVALID_PARAMETER;

            try_return(Status = TRUE);
        }

        //
        //  Set up the amount of data we will have written by the time this
        //  operation gets completed and indicate success until we set it otherwise.
        //

        Iosb->Status = STATUS_SUCCESS;
        Iosb->Information = WriteLength;

        //
        //  Now the data queue that we write into and the event that we signal
        //  are based on the named pipe end.  The server writes to the outbound
        //  queue and signals the client event.  The client does just the
        //  opposite.  We also need to figure out the read mode for the opposite
        //  end of the pipe.
        //

        if (NamedPipeEnd == FILE_PIPE_SERVER_END) {

            WriteQueue = &Ccb->DataQueue[ FILE_PIPE_OUTBOUND ];

            Event = NonpagedCcb->EventTableEntry[ FILE_PIPE_CLIENT_END ];
            ReadMode = Ccb->ReadCompletionMode[ FILE_PIPE_CLIENT_END ].ReadMode;

        } else {

            WriteQueue = &Ccb->DataQueue[ FILE_PIPE_INBOUND ];

            Event = NonpagedCcb->EventTableEntry[ FILE_PIPE_SERVER_END ];
            ReadMode = Ccb->ReadCompletionMode[ FILE_PIPE_SERVER_END ].ReadMode;
        }

        //
        //  The next section checks if we should continue with the write operation.
        //  The reasons why we will not continue are if we recongnize that the
        //  pipe quota will not support this write and it is a message mode type
        //  with complete operations.  We will also bail out now if the quota will
        //  not support the write and this is a fast I/O write request.
        //
        //  If the pipe contains readers and amount to read plus pipe quota is less
        //  than the write length then we need to do some additional checks.
        //  Or if pipe does not contain reads and the amount of quota left is less
        //  than the write length then we need to do some additional checks.
        //

        if ((NpIsDataQueueReaders( WriteQueue ) &&
            (WriteQueue->BytesInQueue < WriteLength) &&
            (WriteQueue->Quota < WriteLength - WriteQueue->BytesInQueue))

                ||

            (!NpIsDataQueueReaders( WriteQueue ) &&
            ((WriteQueue->Quota - WriteQueue->QuotaUsed) < WriteLength))) {

            DebugTrace(0, Dbg, "Quota is not sufficient for the request\n", 0);

            //
            //  If this is a message mode pipe with complete operations then we
            //  complete without writing the message
            //

            if ((Ccb->Fcb->Specific.Fcb.NamedPipeType == FILE_PIPE_MESSAGE_TYPE) &&
                (Ccb->ReadCompletionMode[NamedPipeEnd].CompletionMode == FILE_PIPE_COMPLETE_OPERATION)) {

                Iosb->Information = 0;
                Iosb->Status = STATUS_SUCCESS;

                try_return(Status = TRUE);
            }

            //
            //  If this is a fast I/O pipe then we tell the call to take the long
            //  Irp based route
            //

            if (!ARGUMENT_PRESENT(Irp)) {

                DebugTrace(0, Dbg, "Need to supply Irp\n", 0);

                try_return(Status = FALSE);
            }
        }

        //
        //  Now we'll call our common write data queue routine to
        //  transfer data out of our write buffer into the data queue.
        //  If the result of the call is FALSE then we still have some
        //  write data to put into the write queue.
        //
        Iosb->Status = NpWriteDataQueue( WriteQueue,
                                         ReadMode,
                                         WriteBuffer,
                                         WriteLength,
                                         Ccb->Fcb->Specific.Fcb.NamedPipeType,
                                         &WriteRemaining,
                                         Ccb,
                                         NamedPipeEnd,
                                         UserThread,
                                         DeferredList );

        if (Iosb->Status == STATUS_MORE_PROCESSING_REQUIRED)  {

            ASSERT( !NpIsDataQueueReaders( WriteQueue ));

            //
            //  Check if the operation is not to block and if so then we
            //  will complete the operation now with what we're written, if what is
            //  left will not fit in the quota for the file
            //

            if (((Ccb->ReadCompletionMode[NamedPipeEnd].CompletionMode == FILE_PIPE_COMPLETE_OPERATION) ||
                 Irp == NULL) &&
                ((WriteQueue->Quota - WriteQueue->QuotaUsed) < WriteRemaining)) {

                DebugTrace(0, Dbg, "Complete the byte stream write immediately\n", 0);

                Iosb->Information = WriteLength - WriteRemaining;
                Iosb->Status = STATUS_SUCCESS;

            } else {

                DebugTrace(0, Dbg, "Add write to data queue\n", 0);

                //
                //  Add this write request to the write queue
                //

                ASSERT( !NpIsDataQueueReaders( WriteQueue ));

                Iosb->Status = NpAddDataQueueEntry( NamedPipeEnd,
                                                    Ccb,
                                                    WriteQueue,
                                                    WriteEntries,
                                                    Buffered,
                                                    WriteLength,
                                                    Irp,
                                                    WriteBuffer,
                                                    WriteLength - WriteRemaining );

            }

        } else {

            DebugTrace(0, Dbg, "Complete the Write Irp\n", 0);

        }


        //
        //  And because we've done something we need to signal the
        //  other ends event
        //

        NpSignalEventTableEntry( Event );

        Status = TRUE;

    try_exit: NOTHING;
    } finally {
        NpReleaseCcb(Ccb);
    }


    DebugTrace(-1, Dbg, "NpCommonWrite -> TRUE\n", 0);
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\npfs\waitsup.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    WaitSup.c

Abstract:

    This module implements the Wait for Named Pipe support routines.

Author:

    Gary Kimura     [GaryKi]    30-Aug-1990

Revision History:

--*/

#include "NpProcs.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_WAITSUP)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NpInitializeWaitQueue)
#pragma alloc_text(PAGE, NpUninitializeWaitQueue)
#endif


//
//  Local procedures and structures
//

typedef struct _WAIT_CONTEXT {
    PIRP Irp;
    KDPC Dpc;
    KTIMER Timer;
    PWAIT_QUEUE WaitQueue;
    UNICODE_STRING TranslatedString;
    PFILE_OBJECT FileObject;
} WAIT_CONTEXT;
typedef WAIT_CONTEXT *PWAIT_CONTEXT;



VOID
NpInitializeWaitQueue (
    IN PWAIT_QUEUE WaitQueue
    )

/*++

Routine Description:

    This routine initializes the wait for named pipe queue.

Arguments:

    WaitQueue - Supplies a pointer to the list head being initialized

Return Value:

    None.

--*/

{
    PAGED_CODE();

    DebugTrace(+1, Dbg, "NpInitializeWaitQueue, WaitQueue = %08lx\n", WaitQueue);

    //
    //  Initialize the List head
    //

    InitializeListHead( &WaitQueue->Queue );

    //
    //  Initialize the Wait Queue's spinlock
    //

    KeInitializeSpinLock( &WaitQueue->SpinLock );

    //
    //  and return to our caller
    //

    DebugTrace(-1, Dbg, "NpInitializeWaitQueue -> VOID\n", 0);

    return;
}


VOID
NpUninitializeWaitQueue (
    IN PWAIT_QUEUE WaitQueue
    )

/*++

Routine Description:

    This routine uninitializes the wait for named pipe queue.

Arguments:

    WaitQueue - Supplies a pointer to the list head being uninitialized

Return Value:

    None.

--*/

{
    PAGED_CODE();

    DebugTrace(+1, Dbg, "NpInitializeWaitQueue, WaitQueue = %08lx\n", WaitQueue);

    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "NpInitializeWaitQueue -> VOID\n", 0);

    return;
}


NTSTATUS
NpAddWaiter (
    IN PWAIT_QUEUE WaitQueue,
    IN LARGE_INTEGER DefaultTimeOut,
    IN PIRP Irp,
    IN PUNICODE_STRING TranslatedString
    )

/*++

Routine Description:

    This routine adds a new "wait for named pipe" IRP to the wait queue.
    After calling this function the caller nolonger can access the IRP

Arguments:

    WaitQueue - Supplies the wait queue being used

    DefaultTimeOut - Supplies the default time out to use if one is
        not supplied in the Irp

    Irp - Supplies a pointer to the wait Irp

    TranslatedString - If not NULL points to the translated string

Return Value:

    None.

--*/

{
    KIRQL OldIrql;
    PWAIT_CONTEXT Context;
    PFILE_PIPE_WAIT_FOR_BUFFER WaitForBuffer;
    LARGE_INTEGER Timeout;
    ULONG i;
    NTSTATUS status;
    PIO_STACK_LOCATION IrpSp;

    DebugTrace(+1, Dbg, "NpAddWaiter, WaitQueue = %08lx\n", WaitQueue);

    IrpSp = IoGetCurrentIrpStackLocation (Irp);
    //
    //  Allocate a dpc and timer structure and initialize them
    //

    Context = NpAllocateNonPagedPoolWithQuota( sizeof(WAIT_CONTEXT), 'wFpN' );
    if (Context == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    KeInitializeDpc( &Context->Dpc, NpTimerDispatch, Context );

    KeInitializeTimer( &Context->Timer );

    if (TranslatedString) {

        Context->TranslatedString = (*TranslatedString);

    } else {

        Context->TranslatedString.Length = 0;
        Context->TranslatedString.Buffer = NULL;
    }

    Context->WaitQueue = WaitQueue;
    Context->Irp = Irp;


    //
    //  Figure out our timeout value
    //

    WaitForBuffer = (PFILE_PIPE_WAIT_FOR_BUFFER)Irp->AssociatedIrp.SystemBuffer;

    if (WaitForBuffer->TimeoutSpecified) {

        Timeout = WaitForBuffer->Timeout;

    } else {

        Timeout = DefaultTimeOut;
    }

    //
    //  Upcase the name of the pipe we are waiting for
    //

    for (i = 0; i < WaitForBuffer->NameLength/sizeof(WCHAR); i += 1) {

        WaitForBuffer->Name[i] = RtlUpcaseUnicodeChar(WaitForBuffer->Name[i]);
    }

    NpIrpWaitQueue(Irp) = WaitQueue;
    NpIrpWaitContext(Irp) = Context;

    //
    //  Acquire the spinlock
    //
    KeAcquireSpinLock( &WaitQueue->SpinLock, &OldIrql );

    //
    //  Now set the cancel routine for the irp and check if it has been cancelled.
    //

    IoSetCancelRoutine( Irp, NpCancelWaitQueueIrp );
    if (Irp->Cancel && IoSetCancelRoutine( Irp, NULL ) != NULL) {
        status = STATUS_CANCELLED;
    } else {
        //
        //  Now insert this new entry into the Wait Queue
        //
        InsertTailList( &WaitQueue->Queue, &Irp->Tail.Overlay.ListEntry );
        IoMarkIrpPending (Irp);
        //
        // The DPC routine may run without an IRP if it gets completed before it runs. To keep the WaitQueue
        // valid we need a file object reference. This is an unload issue becuase the wait queue is in the VCB.
        //
        Context->FileObject = IrpSp->FileObject;
        ObReferenceObject (IrpSp->FileObject);
        //
        //  And set the timer to go off
        //
        (VOID)KeSetTimer( &Context->Timer, Timeout, &Context->Dpc );
        Context = NULL;
        status = STATUS_PENDING;
    }

    //
    //  Release the spinlock
    //

    KeReleaseSpinLock( &WaitQueue->SpinLock, OldIrql );

    if (Context != NULL) {
        NpFreePool (Context);
    }

    //
    //  And now return to our caller
    //

    DebugTrace(-1, Dbg, "NpAddWaiter -> VOID\n", 0);

    return status;
}


NTSTATUS
NpCancelWaiter (
    IN PWAIT_QUEUE WaitQueue,
    IN PUNICODE_STRING NameOfPipe,
    IN NTSTATUS Completionstatus,
    IN PLIST_ENTRY DeferredList
    )

/*++

Routine Description:

    This procedure cancels all waiters that are waiting for the named
    pipe to reach the listening state.  The corresponding IRPs are completed
    with Completionstatus.

Arguments:

    WaitQueue - Supplies the wait queue being modified

    NameOfPipe - Supplies the name of the named pipe (device relative)
        that has just reached the listening state.

    CompletionStatus - Status to complete IRPs with

    DeferredList - List or IRPs to complete once we drop locks

Return Value:

    None.

--*/

{
    KIRQL OldIrql;
    PLIST_ENTRY Links;
    PIRP Irp;
    PFILE_PIPE_WAIT_FOR_BUFFER WaitForBuffer;
    PWAIT_CONTEXT Context, ContextList= NULL;
    ULONG i;
    BOOLEAN SuccessfullMatch = FALSE;
    UNICODE_STRING NonPagedNameOfPipe;

    DebugTrace(+1, Dbg, "NpCancelWaiter, WaitQueue = %08lx\n", WaitQueue);

    //
    //  Capture the name of pipe before we grab the spinlock, and upcase it
    //

    NonPagedNameOfPipe.Buffer = NpAllocateNonPagedPool( NameOfPipe->Length, 'tFpN' );
    if (NonPagedNameOfPipe.Buffer == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    NonPagedNameOfPipe.Length = 0;
    NonPagedNameOfPipe.MaximumLength = NameOfPipe->Length;

    (VOID) RtlUpcaseUnicodeString( &NonPagedNameOfPipe, NameOfPipe, FALSE );

    //
    //  Acquire the spinlock
    //
    KeAcquireSpinLock( &WaitQueue->SpinLock, &OldIrql );

    //
    //  For each waiting irp check if the name matches
    //

    for (Links = WaitQueue->Queue.Flink;
         Links != &WaitQueue->Queue;
         Links = Links->Flink) {

        Irp = CONTAINING_RECORD( Links, IRP, Tail.Overlay.ListEntry );
        WaitForBuffer = (PFILE_PIPE_WAIT_FOR_BUFFER)Irp->AssociatedIrp.SystemBuffer;
        Context = NpIrpWaitContext(Irp);

        //
        //  Check if this Irp matches the one we've been waiting for
        //  First check the lengths for equality, and then compare
        //  the strings.  They match if we exit the inner loop with
        //  i >= name length.
        //

        SuccessfullMatch = FALSE;

        if (Context->TranslatedString.Length ) {
            if (NonPagedNameOfPipe.Length == Context->TranslatedString.Length) {

                if (RtlEqualMemory(Context->TranslatedString.Buffer, NonPagedNameOfPipe.Buffer, NonPagedNameOfPipe.Length)) {

                    SuccessfullMatch = TRUE;

                }
            }

        } else  {

            if (((USHORT)(WaitForBuffer->NameLength + sizeof(WCHAR))) == NonPagedNameOfPipe.Length) {

                for (i = 0; i < WaitForBuffer->NameLength/sizeof(WCHAR); i += 1) {

                    if (WaitForBuffer->Name[i] != NonPagedNameOfPipe.Buffer[i+1]) {

                        break;
                    }
                }

                if (i >= WaitForBuffer->NameLength/sizeof(WCHAR)) {

                    SuccessfullMatch = TRUE;
                }
            }
        }

        if (SuccessfullMatch) {

            Links = Links->Blink;
            RemoveEntryList( &Irp->Tail.Overlay.ListEntry );
            //
            // Attempt to stop the timer. If its already running then it must be stalled before obtaining
            // this spinlock or it would have removed this item from the list. Break the link between the timer
            // context and the IRP in this case and let it run on.
            //

            if (KeCancelTimer( &Context->Timer )) {
                 //
                 // Time got stopped. The context gets freed below after we drop the lock.
                 //
                 Context->WaitQueue = (PWAIT_QUEUE) ContextList;
                 ContextList = Context;
            } else {
                //
                // Break the link between the timer and the IRP
                //
                Context->Irp = NULL;
                NpIrpWaitContext(Irp) = NULL;
            }

            //
            // Remove cancelation. If its already running then let it complete the IRP.
            //
            if (IoSetCancelRoutine( Irp, NULL ) != NULL) {
                Irp->IoStatus.Information = 0;
                NpDeferredCompleteRequest (Irp, Completionstatus, DeferredList);
            } else {
                //
                // Cancel is already running. Let it complete this IRP but let it know its orphaned.
                //
                NpIrpWaitContext(Irp) = NULL;
            }
        }
    }

    //
    //  Release the spinlock
    //
    KeReleaseSpinLock( &WaitQueue->SpinLock, OldIrql );

    NpFreePool (NonPagedNameOfPipe.Buffer);

    while (ContextList != NULL) {
        Context = ContextList;
        ContextList = (PWAIT_CONTEXT) Context->WaitQueue;
        ObDereferenceObject (Context->FileObject);
        NpFreePool( Context );
    }

    DebugTrace(-1, Dbg, "NpCancelWaiter -> VOID\n", 0);
    //
    //  And now return to our caller
    //

    return STATUS_SUCCESS;
}


//
//  Local support routine
//

VOID
NpTimerDispatch(
    IN PKDPC Dpc,
    IN PVOID Contxt,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )

/*++

Routine Description:

    This routine is called whenever a timer on a wait queue Irp goes off

Arguments:

    Dpc - Ignored

    Contxt - Supplies a pointer to the context whose timer went off

    SystemArgument1 - Ignored

    SystemArgument2 - Ignored

Return Value:

    none.

--*/

{
    PIRP Irp;
    KIRQL OldIrql;
    PLIST_ENTRY Links;
    PWAIT_CONTEXT Context;
    PWAIT_QUEUE WaitQueue;

    UNREFERENCED_PARAMETER( Dpc );
    UNREFERENCED_PARAMETER( SystemArgument1 );
    UNREFERENCED_PARAMETER( SystemArgument2 );

    Context = (PWAIT_CONTEXT)Contxt;
    WaitQueue = Context->WaitQueue;

    KeAcquireSpinLock( &WaitQueue->SpinLock, &OldIrql );

    Irp = Context->Irp;
    if (Irp != NULL) {
        RemoveEntryList( &Irp->Tail.Overlay.ListEntry );
        if (IoSetCancelRoutine (Irp, NULL) == NULL) {
           //
           // Cancel started running. Let it complete the IRP but show its orphaned
           //
           NpIrpWaitContext(Irp) = NULL;
           Irp = NULL;
        }
    }

    KeReleaseSpinLock( &WaitQueue->SpinLock, OldIrql );

    if (Irp != NULL) {
        NpCompleteRequest( Irp, STATUS_IO_TIMEOUT );
    }

    //
    // Remove the file reference now we have finished with the wait queue.
    //
    ObDereferenceObject (Context->FileObject);

    //
    //  Deallocate the context
    //
    NpFreePool (Context);

    //
    //  And now return to our caller
    //

    return;
}


//
//  Local Support routine
//

VOID
NpCancelWaitQueueIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called to cancel a wait queue irp

Arguments:

    DeviceObject - Ignored

    Irp - Supplies the Irp being cancelled.  The Iosb.Status field in the irp
        points to the wait queue

Return Value:

    none.

--*/

{
    PWAIT_QUEUE WaitQueue;
    KIRQL OldIrql;
    PLIST_ENTRY Links;
    PWAIT_CONTEXT Context;

    UNREFERENCED_PARAMETER( DeviceObject );

    IoReleaseCancelSpinLock( Irp->CancelIrql );

    //
    //  The status field is used to store a pointer to the wait queue
    //  containing this irp
    //
    WaitQueue = NpIrpWaitQueue(Irp);
    //
    //  Get the spinlock proctecting the wait queue
    //

    KeAcquireSpinLock( &WaitQueue->SpinLock, &OldIrql );

    Context = NpIrpWaitContext(Irp);
    if (Context != NULL) {
        RemoveEntryList (&Irp->Tail.Overlay.ListEntry);
        if (!KeCancelTimer( &Context->Timer )) {
            //
            // Timer is already running. Break the link between the timer and the IRP as this thread is going to complete it.
            //
            Context->Irp = NULL;
            Context = NULL;
        }
    }

    KeReleaseSpinLock( &WaitQueue->SpinLock, OldIrql );

    if (Context) {
        ObDereferenceObject (Context->FileObject);
        NpFreePool (Context);
    }
    Irp->IoStatus.Information = 0;
    NpCompleteRequest( Irp, STATUS_CANCELLED );
    //
    //  And return to our caller
    //

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\npfs\npfskd\npfskd.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Npfskd.c

Abstract:

    KD Extension Api for examining Npfs specific data structures

Author:

    Narayanan   Ganapathy   - 9/21/99
    
Environment:

    User Mode.

Revision History:

--*/


#include "NpProcs.h"


//
// This file should not include wdbgexts.h as it includes windows.h
// windows.h defines a structure called _DCB that clashes with the DCB for NPFS.
// So the debugger functions are called from kdexts.c and indirectly called from this function
// 




BOOLEAN NpDumpEventTableEntry(IN PEVENT_TABLE_ENTRY Ptr);
BOOLEAN NpDumpDataQueue(IN PDATA_QUEUE Ptr);
BOOLEAN NpDumpDataEntry(IN PDATA_ENTRY Ptr);

BOOLEAN NpDump(IN PVOID Ptr);
BOOLEAN NpDumpVcb(IN PVCB Ptr);
BOOLEAN NpDumpRootDcb(IN PROOT_DCB Ptr);
BOOLEAN NpDumpFcb(IN PFCB Ptr);
BOOLEAN NpDumpCcb(IN PCCB Ptr);
BOOLEAN NpDumpNonpagedCcb(IN PNONPAGED_CCB Ptr);
BOOLEAN NpDumpRootDcbCcb(IN PROOT_DCB_CCB Ptr);

extern  VOID    NpfskdPrint(PCHAR, ULONG_PTR);
extern  VOID    NpfskdPrintString(PCHAR, PCHAR);
extern  VOID    NpfskdPrintWideString(PWCHAR, PWCHAR);
extern  BOOLEAN NpfskdReadMemory(PVOID, PVOID, ULONG);
extern  ULONG   NpfskdCheckControlC(VOID);

extern  ULONG   NpDumpFlags;

ULONG NpDumpCurrentColumn;


#define DumpField(Field) NpfskdPrint( #Field , (ULONG_PTR)Ptr->Field)


#define DumpListEntry(Links)  \
    NpfskdPrint( #Links "->Flink", (ULONG_PTR)Ptr->Links.Flink);  \
    NpfskdPrint( #Links "->Blink", (ULONG_PTR)Ptr->Links.Blink)

#define DumpName(Field) { \
    ULONG i; \
    WCHAR _String[64]; \
    if (!NpfskdReadMemory(Ptr->Field, _String, sizeof(_String))) \
        return FALSE; \
    NpfskdPrintWideString(L#Field, _String); \
}

#define DumpTitle(Title, Value)    { \
    NpfskdPrint("\n                      "#Title"@                ", (Value)); \
    }
    
#define TestForNull(Name) { \
    if (targetPtr == NULL) { \
        NpfskdPrintString("Cannot dump a NULL pointer\n", Name); \
        return FALSE; \
    } \
}

#define NP_READ_MEMORY(targetPtr, localStore, localPtr)  \
    {   \
        if (!NpfskdReadMemory((targetPtr),   \
                        &(localStore),  \
                        sizeof(localStore))) { \
            return FALSE; \
        }   \
        localPtr = &(localStore);   \
    }


#define NPFS_FULL_INFORMATION   1
#define NPFS_WALK_LISTS         2


BOOLEAN 
NpDumpEventTableEntry (
    IN PEVENT_TABLE_ENTRY targetPtr
    )

{
    PEVENT_TABLE_ENTRY  Ptr;
    EVENT_TABLE_ENTRY   Event;
    TestForNull   ("NpDumpEventTableEntry");

    DumpTitle       (EventTableEntry, (ULONG_PTR)(targetPtr));

    NP_READ_MEMORY(targetPtr, Event, Ptr);

    DumpField     (Ccb);
    DumpField     (NamedPipeEnd);
    DumpField     (EventHandle);
    DumpField     (Event);
    DumpField     (KeyValue);
    DumpField     (Process);

    return TRUE;
}



BOOLEAN NpDumpDataQueue (
    IN PDATA_QUEUE targetPtr
    )

{
    PDATA_ENTRY Entry;
    DATA_ENTRY DataEntry;
    PDATA_QUEUE Ptr;
    DATA_QUEUE  Dqueue;


    TestForNull   ("NpDumpDataQueue");

    DumpTitle       (DataQueue, (ULONG_PTR)(targetPtr));

    NP_READ_MEMORY(targetPtr, Dqueue, Ptr);


    DumpField     (QueueState);
    DumpField     (BytesInQueue);
    DumpField     (EntriesInQueue);
    DumpField     (Quota);
    DumpField     (QuotaUsed);
    DumpField     (Queue.Flink);
    DumpField     (Queue.Blink);
    DumpField     (NextByteOffset);

    Entry = (PDATA_ENTRY) Ptr->Queue.Flink;

    if (!(NpDumpFlags & NPFS_WALK_LISTS)) {
        return TRUE;
    }

    while (Entry != (PDATA_ENTRY) &Ptr->Queue){

        if (!NpfskdReadMemory(Entry, &DataEntry, sizeof(DataEntry))) {
            return FALSE;
        }
        NpDumpDataEntry( Entry );
        if (NpfskdCheckControlC()) {
            NpfskdPrintString("^C Typed. Bailing out","");
            return FALSE;
        }
        Entry = (PDATA_ENTRY) DataEntry.Queue.Flink;
    }

    return TRUE;
}


BOOLEAN NpDumpDataEntry (
    IN PDATA_ENTRY targetPtr
    )

{
    DATA_ENTRY  Dentry;
    PDATA_ENTRY Ptr;

    TestForNull   ("NpDumpDataEntry");

    DumpTitle       (DataEntry, (ULONG_PTR)(targetPtr));

    NP_READ_MEMORY(targetPtr, Dentry, Ptr);

    DumpField     (DataEntryType);
    DumpField     (Queue.Flink);
    DumpField     (Irp);
    DumpField     (DataSize);
    DumpField     (SecurityClientContext);

    return TRUE;
}


BOOLEAN NpDump (
    IN PVOID Ptr
    )

/*++

Routine Description:

    This routine determines the type of internal record reference by ptr and
    calls the appropriate dump routine.

Arguments:

    Ptr - Supplies the pointer to the record to be dumped

Return Value:

    None

--*/

{
    NODE_TYPE_CODE  NodeType;
    PNODE_TYPE_CODE pNodeType;
    BOOLEAN         Ret;

    //
    //  We'll switch on the node type code
    //

    NP_READ_MEMORY(Ptr, NodeType, pNodeType);

    switch (NodeType) {

    case NPFS_NTC_VCB:               Ret = NpDumpVcb((PVCB)Ptr);             break;
    case NPFS_NTC_ROOT_DCB:          Ret = NpDumpRootDcb((PDCB)Ptr);         break;
    case NPFS_NTC_FCB:               Ret = NpDumpFcb((PFCB)Ptr);             break;
    case NPFS_NTC_CCB:               Ret = NpDumpCcb((PCCB)Ptr);             break;
    case NPFS_NTC_NONPAGED_CCB:      Ret = NpDumpNonpagedCcb((PNONPAGED_CCB)Ptr);     break;
    case NPFS_NTC_ROOT_DCB_CCB:      Ret = NpDumpRootDcbCcb((PROOT_DCB_CCB)Ptr);      break;

    default :
        Ret = TRUE;
        NpfskdPrint("NpDump - Unknown Node type code ", NodeType);
        break;
    }

    return Ret;
}


BOOLEAN NpDumpVcb (
    IN PVCB targetPtr
    )

/*++

Routine Description:

    Dump an Vcb structure

Arguments:

    Ptr - Supplies the Device record to be dumped

Return Value:

    None

--*/

{
    VCB Vcb;
    PVCB Ptr;

    TestForNull   ("NpDumpVcb");

    DumpTitle     (Vcb, (ULONG_PTR)(targetPtr));

    NP_READ_MEMORY(targetPtr, Vcb, Ptr);
    DumpField     (NodeTypeCode);
    DumpField     (RootDcb);
    DumpField     (OpenCount);

    NpDump        (Ptr->RootDcb);

    return TRUE;
}


BOOLEAN NpDumpRootDcb (
    IN PROOT_DCB targetPtr
    )

/*++

Routine Description:

    Dump a root dcb structure

Arguments:

    Ptr - Supplies the Root Dcb record to be dumped

Return Value:

    None

--*/

{
    PLIST_ENTRY Links;
    LIST_ENTRY  NextEntry;
    ROOT_DCB   RootDcb;
    PROOT_DCB   Ptr;

    TestForNull   ("NpDumpRootDcb");

    DumpTitle     (RootDcb, (ULONG_PTR)(targetPtr));
    NP_READ_MEMORY(targetPtr, RootDcb, Ptr);

    DumpField     (NodeTypeCode);
    DumpListEntry (ParentDcbLinks);
    DumpField     (ParentDcb);
    DumpField     (OpenCount);
    DumpField     (FullFileName.Length);
    DumpField     (FullFileName.Buffer);
    DumpName      (FullFileName.Buffer);
    DumpField     (LastFileName.Length);
    DumpName      (LastFileName.Buffer);
    DumpListEntry (Specific.Dcb.NotifyFullQueue);
    DumpListEntry (Specific.Dcb.NotifyPartialQueue);
    DumpListEntry (Specific.Dcb.ParentDcbQueue);


    Links = Ptr->Specific.Dcb.ParentDcbQueue.Flink;

    if (!(NpDumpFlags & NPFS_WALK_LISTS)) {
        return TRUE;
    }

    while (Links != &Ptr->Specific.Dcb.ParentDcbQueue) {
        if (!NpfskdReadMemory(Links, &NextEntry, sizeof(NextEntry))) {
            return FALSE;
        }
        if (!NpDump(CONTAINING_RECORD(Links, FCB, ParentDcbLinks))) {
            return FALSE;
        }
        if (NpfskdCheckControlC()) {
            NpfskdPrintString("^C Typed. Bailing out","");
            return FALSE;
        }
        Links = NextEntry.Flink;
    }

    return TRUE;
}


BOOLEAN NpDumpFcb (
    IN PFCB targetPtr
    )

/*++

Routine Description:

    Dump an Fcb structure

Arguments:

    Ptr - Supplies the Fcb record to be dumped

Return Value:

    None

--*/

{
    PLIST_ENTRY Links;
    LIST_ENTRY  NextEntry;
    FCB Fcb;
    PFCB  Ptr;


    TestForNull   ("NpDumpFcb");

    DumpTitle     (Fcb, (ULONG_PTR)(targetPtr));

    NP_READ_MEMORY(targetPtr, Fcb , Ptr);

    DumpField     (NodeTypeCode);
    DumpField     (FullFileName.Length);
    DumpField     (FullFileName.Buffer);
    DumpName      (FullFileName.Buffer);

    if (NpDumpFlags & NPFS_FULL_INFORMATION) {
        DumpListEntry (ParentDcbLinks);
        DumpField     (ParentDcb);
        DumpField     (OpenCount);
        DumpField     (LastFileName.Length);
        DumpName      (LastFileName.Buffer);
        DumpField     (Specific.Fcb.NamedPipeConfiguration);
        DumpField     (Specific.Fcb.NamedPipeType);
        DumpField     (Specific.Fcb.MaximumInstances);
        DumpField     (Specific.Fcb.DefaultTimeOut.LowPart);
        DumpField     (Specific.Fcb.DefaultTimeOut.HighPart);
        DumpListEntry (Specific.Fcb.CcbQueue);
    }

    if (!(NpDumpFlags & NPFS_WALK_LISTS)) {
        return TRUE;
    }

    Links = Ptr->Specific.Fcb.CcbQueue.Flink;
    while (Links != &Ptr->Specific.Fcb.CcbQueue) {
        if (!NpfskdReadMemory(Links, &NextEntry, sizeof(NextEntry))) {
            return FALSE;
        }
        if (!NpDump(CONTAINING_RECORD(Links, CCB, CcbLinks))) {
            return FALSE;
        }
        if (NpfskdCheckControlC()) {
            NpfskdPrintString("^C Typed. Bailing out","");
            return FALSE;
        }
        Links = NextEntry.Flink;
    }

    return TRUE;
}


BOOLEAN NpDumpCcb (
    IN PCCB targetPtr
    )

/*++

Routine Description:

    Dump a Ccb structure

Arguments:

    Ptr - Supplies the Ccb record to be dumped

Return Value:

    None

--*/

{
    PCCB    Ptr;
    CCB     Ccb;  

    TestForNull   ("NpDumpCcb");

    DumpTitle     (Ccb, (ULONG_PTR)(targetPtr));

    NP_READ_MEMORY(targetPtr, Ccb, Ptr);

    DumpField     (NodeTypeCode);
    DumpField     (Fcb);
    DumpField     (FileObject[FILE_PIPE_CLIENT_END]);
    DumpField     (FileObject[FILE_PIPE_SERVER_END]);

    if (NpDumpFlags & NPFS_FULL_INFORMATION) {

        DumpField     (NamedPipeState);
        DumpField     (SecurityClientContext);
        DumpListEntry (ListeningQueue);
    }

    if (!NpDumpDataQueue(&targetPtr->DataQueue[FILE_PIPE_CLIENT_END])) {
        return FALSE;
    }
    if (!NpDumpDataQueue(&targetPtr->DataQueue[FILE_PIPE_SERVER_END])) {
        return FALSE;
    }

    return NpDump        (Ptr->NonpagedCcb);

}


BOOLEAN NpDumpNonpagedCcb (
    IN PNONPAGED_CCB targetPtr
    )

/*++

Routine Description:

    Dump a Nonpaged Ccb structure

Arguments:

    Ptr - Supplies the Nonpaged Ccb record to be dumped

Return Value:

    None

--*/

{
    NONPAGED_CCB    Ccb;
    PNONPAGED_CCB   Ptr;

    TestForNull   ("NpDumpNonpagedCcb");

    DumpTitle       (NonpagedCcb, (ULONG_PTR)(targetPtr));

    NP_READ_MEMORY(targetPtr, Ccb, Ptr);

    DumpField     (NodeTypeCode);
    DumpField     (EventTableEntry[FILE_PIPE_CLIENT_END]);
    DumpField     (EventTableEntry[FILE_PIPE_SERVER_END]);

    return TRUE;
}


BOOLEAN NpDumpRootDcbCcb (
    IN PROOT_DCB_CCB targetPtr
    )

/*++

Routine Description:

    Dump a Root Dcb Ccb structure

Arguments:

    Ptr - Supplies the Root Dcb Ccb record to be dumped

Return Value:

    None

--*/

{
    ROOT_DCB_CCB    RootDcbCcb;
    PROOT_DCB_CCB   Ptr;

    TestForNull   ("NpDumpRootDcbCcb");

    DumpTitle     (RootDcbCcb, (ULONG_PTR)(targetPtr));

    NP_READ_MEMORY(targetPtr, RootDcbCcb, Ptr);

    DumpField     (NodeTypeCode);
    DumpField     (IndexOfLastCcbReturned);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\npfs\npfskd\kdext.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    kdexts.c

Abstract:

    This file contains the generic routines and initialization code
    for the kernel debugger extensions dll.

Author:

    Nar Ganapathy - 9/21/99

Environment:

    User Mode

--*/

#include <stdio.h>
#include <windows.h>
#include "wdbgexts.h"

#include <ntverp.h>
#include <imagehlp.h>

//
// globals
//
EXT_API_VERSION        ApiVersion = { 3, 5, EXT_API_VERSION_NUMBER, 0 };
WINDBG_EXTENSION_APIS  ExtensionApis;
ULONG                  STeip;
ULONG                  STebp;
ULONG                  STesp;
USHORT                 SavedMajorVersion;
USHORT                 SavedMinorVersion;
ULONG                  NpDumpFlags = 0;

extern VOID NpDump(IN PVOID Ptr);


DllInit(
    HANDLE hModule,
    DWORD  dwReason,
    DWORD  dwReserved
    )
{
    UNREFERENCED_PARAMETER( hModule );
    UNREFERENCED_PARAMETER( dwReserved );
    
    switch (dwReason) {
        case DLL_THREAD_ATTACH:
            break;

        case DLL_THREAD_DETACH:
            break;

        case DLL_PROCESS_DETACH:
            break;

        case DLL_PROCESS_ATTACH:
            break;
    }

    return TRUE;
}


VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ExtensionApis = *lpExtensionApis;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;

    return;
}

DECLARE_API( version )
{
#if DBG
    PCHAR DebuggerType = "Checked";
#else
    PCHAR DebuggerType = "Free";
#endif

    UNREFERENCED_PARAMETER( args );
    UNREFERENCED_PARAMETER( dwProcessor );
    UNREFERENCED_PARAMETER( dwCurrentPc );
    UNREFERENCED_PARAMETER( hCurrentThread );
    UNREFERENCED_PARAMETER( hCurrentProcess );

    dprintf( "%s Extension dll for Build %d debugging %s kernel for Build %d\n",
             DebuggerType,
             VER_PRODUCTBUILD,
             SavedMajorVersion == 0x0c ? "Checked" : "Free",
             SavedMinorVersion
           );
}

VOID
CheckVersion(
    VOID
    )
{
#if DBG
    if ((SavedMajorVersion != 0x0c) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Checked) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#else
    if ((SavedMajorVersion != 0x0f) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Free) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#endif
}

LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    return &ApiVersion;
}

BOOLEAN
IsHexNumber(
   const char *szExpression
   )
{
   if (!szExpression[0]) {
      return FALSE ;
   }

   for(;*szExpression; szExpression++) {
      
      if      ((*szExpression)< '0') { return FALSE ; } 
      else if ((*szExpression)> 'f') { return FALSE ; }
      else if ((*szExpression)>='a') { continue ;     }
      else if ((*szExpression)> 'F') { return FALSE ; }
      else if ((*szExpression)<='9') { continue ;     }
      else if ((*szExpression)>='A') { continue ;     }
      else                           { return FALSE ; }
   }
   return TRUE ;
}

DECLARE_API(npcb)
{

   ULONG_PTR ptrToDump;
   char ExprBuf[256] ;
   char FlagBuf[256] ;
   int ret;

   if (!*args) {
       dprintf("Usage: !npcb <pointer> <Flag>");
       return;
   }

   ExprBuf[0] = '\0' ;
   FlagBuf[0] = '\0' ;

   NpDumpFlags = 0;
   ret = sscanf(args,"%s %lx", ExprBuf, &NpDumpFlags);

   if (ret != EOF) {

       if (IsHexNumber(ExprBuf)) {
          ret = sscanf(ExprBuf, "%lx", &ptrToDump) ;
          if (ret == EOF) {
              ptrToDump = 0;
          }
       } else {
          ptrToDump = GetExpression( ExprBuf ) ;
          if (ptrToDump == 0) {

             dprintf("An error occured trying to evaluate the expression\n");
             return ;
          }
       }
       NpDump((PVOID)ptrToDump);
   } else {
       dprintf("An error occured trying to evaluate the expression\n");
   }
}

VOID
NpfskdPrint(
    PCHAR   String,
    ULONG_PTR Val
    )
{
    dprintf("%-50s 0x%x\n",String, Val);
}

VOID
NpfskdPrintString(
    PCHAR   String1,
    PCHAR   String2
    )
{
    dprintf("%-50s %s\n",String1, String2);
}

VOID
NpfskdPrintWideString(
    PWCHAR   String1,
    PWCHAR   String2
    )
{
    dprintf("%-50S %S\n",String1, String2);
}

BOOLEAN
NpfskdReadMemory(
    PVOID   TargetPtr,
    PVOID   LocalPtr,
    ULONG   Length
    )
{
    ULONG   Result;

    if (!ReadMemory((ULONG_PTR)TargetPtr, LocalPtr, Length, &Result)) {
        dprintf("Cannot read memory at 0x%x\n", TargetPtr);
        return FALSE;
    }

    if (Result != Length) {
        dprintf("Expected length 0x%x != Actual length 0x%x\n", Length, Result);
        return FALSE;
    }

    return TRUE;
}

ULONG
NpfskdCheckControlC()
{
    return (CheckControlC());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\attrdata.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    AttrData.c

Abstract:

    This module contains an initial image of the Attribute Definition File.

Author:

    Tom Miller      [TomM]          7-Jun-1991

Revision History:

--*/

#include "NtfsProc.h"

//
// Define an array to hold the initial attribute definitions.  This is
// essentially the initial contents of the Attribute Definition File.
// NTFS may find it convenient to use this module for attribute
// definitions prior to getting an NTFS volume mounted, however it is valid
// for NTFS to assume knowledge of the system-defined attributes without
// consulting this table.
//

ATTRIBUTE_DEFINITION_COLUMNS NtfsAttributeDefinitions[ ] =

{
    {{'$','S','T','A','N','D','A','R','D','_','I','N','F','O','R','M','A','T','I','O','N'},
    $STANDARD_INFORMATION,                              // Attribute code
    0,                                                  // Display rule
    0,                                                  // Collation rule
    ATTRIBUTE_DEF_MUST_BE_RESIDENT,                     // Flags
    SIZEOF_OLD_STANDARD_INFORMATION,                    // Minimum length
    sizeof(STANDARD_INFORMATION)},                      // Maximum length

    {{'$','A','T','T','R','I','B','U','T','E','_','L','I','S','T'},
    $ATTRIBUTE_LIST,                                    // Attribute code
    0,                                                  // Display rule
    0,                                                  // Collation rule
    ATTRIBUTE_DEF_LOG_NONRESIDENT,                      // Flags
    0,                                                  // Minimum length
    -1},                                                // Maximum length

    {{'$','F','I','L','E','_','N','A','M','E'},
    $FILE_NAME,                                         // Attribute code
    0,                                                  // Display rule
    0,                                                  // Collation rule
    ATTRIBUTE_DEF_MUST_BE_RESIDENT | ATTRIBUTE_DEF_INDEXABLE,   // Flags
    sizeof(FILE_NAME),                                  // Minimum length
    sizeof(FILE_NAME) + (255 * sizeof(WCHAR))},         // Maximum length

    {{'$','O','B','J','E','C','T','_','I','D'},
    $OBJECT_ID,                                         // Attribute code
    0,                                                  // Display rule
    0,                                                  // Collation rule
    ATTRIBUTE_DEF_MUST_BE_RESIDENT,                     // Flags
    0,                                                  // Minimum length
    256},                                               // Maximum length

    {{'$','S','E','C','U','R','I','T','Y','_','D','E','S','C','R','I','P','T','O','R'},
    $SECURITY_DESCRIPTOR,                               // Attribute code
    0,                                                  // Display rule
    0,                                                  // Collation rule
    ATTRIBUTE_DEF_LOG_NONRESIDENT,                      // Flags
    0,                                                  // Minimum length
    -1},                                                // Maximum length

    {{'$','V','O','L','U','M','E','_','N','A','M','E'},
    $VOLUME_NAME,                                       // Attribute code
    0,                                                  // Display rule
    0,                                                  // Collation rule
    ATTRIBUTE_DEF_MUST_BE_RESIDENT,                     // Flags
    2,                                                  // Minimum length
    256},                                               // Maximum length

    {{'$','V','O','L','U','M','E','_','I','N','F','O','R','M','A','T','I','O','N'},
    $VOLUME_INFORMATION,                                // Attribute code
    0,                                                  // Display rule
    0,                                                  // Collation rule
    ATTRIBUTE_DEF_MUST_BE_RESIDENT,                     // Flags
    FIELD_OFFSET( VOLUME_INFORMATION, LastMountedMajorVersion), // Minimum length
    FIELD_OFFSET( VOLUME_INFORMATION, LastMountedMajorVersion)}, // Maximum length

    {{'$','D','A','T','A'},
    $DATA,                                              // Attribute code
    0,                                                  // Display rule
    0,                                                  // Collation rule
    0,                                                  // Flags
    0,                                                  // Minimum length
    -1},                                                // Maximum length

    {{'$','I','N','D','E','X','_','R','O','O','T'},
    $INDEX_ROOT,                                        // Attribute code
    0,                                                  // Display rule
    0,                                                  // Collation rule
    ATTRIBUTE_DEF_MUST_BE_RESIDENT,                     // Flags
    0,                                                  // Minimum length
    -1},                                                // Maximum length

    {{'$','I','N','D','E','X','_','A','L','L','O','C','A','T','I','O','N'},
    $INDEX_ALLOCATION,                                  // Attribute code
    0,                                                  // Display rule
    0,                                                  // Collation rule
    ATTRIBUTE_DEF_LOG_NONRESIDENT,                      // Flags
    0,                                                  // Minimum length
    -1},                                                // Maximum length

    {{'$','B','I','T','M','A','P'},
    $BITMAP,                                            // Attribute code
    0,                                                  // Display rule
    0,                                                  // Collation rule
    ATTRIBUTE_DEF_LOG_NONRESIDENT,                      // Flags
    0,                                                  // Minimum length
    -1},                                                // Maximum length

    {{'$','R','E','P','A','R','S','E','_','P','O','I','N','T'},
    $REPARSE_POINT,                                     // Attribute code
    0,                                                  // Display rule
    0,                                                  // Collation rule
    ATTRIBUTE_DEF_LOG_NONRESIDENT,                      // Flags
    0,                                                  // Minimum length
    16*1024},                                           // Maximum length

    {{'$','E','A','_','I','N','F','O','R','M','A','T','I','O','N'},
    $EA_INFORMATION,                                    // Attribute code
    0,                                                  // Display rule
    0,                                                  // Collation rule
    ATTRIBUTE_DEF_MUST_BE_RESIDENT,                     // Flags
    sizeof(EA_INFORMATION),                             // Minimum length
    sizeof(EA_INFORMATION)},                            // Maximum length

    {{'$','E','A',},
    $EA,                                                // Attribute code
    0,                                                  // Display rule
    0,                                                  // Collation rule
    0,                                                  // Flags
    0,                                                  // Minimum length
    0x10000},                                           // Maximum length

    {{0,0,0,0},
    0xF0, 
    0,
    0,
    0,
    0},

    {{'$','L','O','G','G','E','D','_','U','T','I','L','I','T','Y','_','S','T','R','E','A','M'},
    $LOGGED_UTILITY_STREAM,                             // Attribute code
    0,                                                  // Display rule
    0,                                                  // Collation rule
    ATTRIBUTE_DEF_LOG_NONRESIDENT,                      // Flags
    0,                                                  // Minimum length
    0x10000},                                           // Maximum length

    {{0, 0, 0, 0},
    $UNUSED,                                            // Attribute code
    0,                                                  // Display rule
    0,                                                  // Collation rule
    0,                                                  // Flags
    0,                                                  // Minimum length
    0},                                                 // Maximum length
};

//
//  The number of attributes in the above table, including the end record.
//

ULONG NtfsAttributeDefinitionsCount = sizeof( NtfsAttributeDefinitions ) / sizeof( ATTRIBUTE_DEFINITION_COLUMNS );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\allocsup.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    AllocSup.c

Abstract:

    This module implements the general file stream allocation & truncation
    routines for Ntfs

Author:

    Tom Miller      [TomM]          15-Jul-1991

Revision History:

--*/

#include "NtfsProc.h"

//
//  Local debug trace level
//

#define Dbg                              (DEBUG_TRACE_ALLOCSUP)

//
//  Define a tag for general pool allocations from this module
//

#undef MODULE_POOL_TAG
#define MODULE_POOL_TAG                  ('aFtN')

//
//  Internal support routines
//

VOID
NtfsDeleteAllocationInternal (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PSCB Scb,
    IN VCN StartingVcn,
    IN VCN EndingVcn,
    IN BOOLEAN LogIt
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtfsPreloadAllocation)
#pragma alloc_text(PAGE, NtfsAddAllocation)
#pragma alloc_text(PAGE, NtfsAddSparseAllocation)
#pragma alloc_text(PAGE, NtfsAllocateAttribute)
#pragma alloc_text(PAGE, NtfsBuildMappingPairs)
#pragma alloc_text(PAGE, NtfsCheckForReservedClusters)
#pragma alloc_text(PAGE, NtfsDeleteAllocation)
#pragma alloc_text(PAGE, NtfsDeleteAllocationInternal)
#pragma alloc_text(PAGE, NtfsDeleteReservedBitmap)
#pragma alloc_text(PAGE, NtfsGetHighestVcn)
#pragma alloc_text(PAGE, NtfsGetSizeForMappingPairs)
#pragma alloc_text(PAGE, NtfsIsRangeAllocated)
#pragma alloc_text(PAGE, NtfsReallocateRange)
#endif


ULONG
NtfsPreloadAllocation (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PSCB Scb,
    IN VCN StartingVcn,
    IN VCN EndingVcn
    )

/*++

Routine Description:

    This routine assures that all ranges of the Mcb are loaded in the specified
    Vcn range

Arguments:

    Scb - Specifies which Scb is to be preloaded

    StartingVcn - Specifies the first Vcn to be loaded

    EndingVcn - Specifies the last Vcn to be loaded

Return Value:

    Number of ranges spanned by the load request.

--*/

{
    VCN CurrentVcn, LastCurrentVcn;
    LCN Lcn;
    LONGLONG Count;
    PVOID RangePtr;
    ULONG RunIndex;
    ULONG RangesLoaded = 0;

    PAGED_CODE();

    //
    //  Start with starting Vcn
    //

    CurrentVcn = StartingVcn;

    //
    //  Always load the nonpaged guys from the front, so we don't
    //  produce an Mcb with a "known hole".
    //

    if (FlagOn(Scb->Fcb->FcbState, FCB_STATE_NONPAGED)) {
        CurrentVcn = 0;
    }

    //
    //  Loop until it's all loaded.
    //

    while (CurrentVcn <= EndingVcn) {

        //
        //  Remember this CurrentVcn as a way to know when we have hit the end
        //  (stopped making progress).
        //

        LastCurrentVcn = CurrentVcn;

        //
        //  Load range with CurrentVcn, and if it is not there, get out.
        //

        (VOID)NtfsLookupAllocation( IrpContext, Scb, CurrentVcn, &Lcn, &Count, &RangePtr, &RunIndex );

        //
        //  If preloading the mft flush and purge it afterwards. This is to 
        //  remove any partial pages we generated above if any mft record for 
        //  the mft described others records in the same page after it
        //  

        if (FlagOn( IrpContext->Vcb->VcbState, VCB_STATE_PRELOAD_MFT )) {

            IO_STATUS_BLOCK IoStatus;
            
            CcFlushCache( &Scb->NonpagedScb->SegmentObject, 
                          NULL, 
                          0, 
                          &IoStatus );

            if (!NT_SUCCESS( IoStatus.Status )) {

                NtfsNormalizeAndRaiseStatus( IrpContext,
                                             IoStatus.Status,
                                             STATUS_UNEXPECTED_IO_ERROR );
            }

            CcPurgeCacheSection( &Scb->NonpagedScb->SegmentObject,
                                 (PLARGE_INTEGER)NULL,
                                 0,
                                 FALSE );
        }

        //
        //  Find out how many runs there are in this range
        //

        if (!NtfsNumberOfRunsInRange(&Scb->Mcb, RangePtr, &RunIndex) || (RunIndex == 0)) {
            break;
        }

        //
        //  Get the highest run in this range and calculate the next Vcn beyond this range.
        //

        NtfsGetNextNtfsMcbEntry( &Scb->Mcb, &RangePtr, RunIndex - 1, &CurrentVcn, &Lcn, &Count );

        CurrentVcn += Count;

        //
        //  If we are making no progress, we must have hit the end of the allocation,
        //  and we are done.
        //

        if (CurrentVcn == LastCurrentVcn) {
            break;
        }

        RangesLoaded += 1;
    }

    return RangesLoaded;
}


BOOLEAN
NtfsLookupAllocation (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PSCB Scb,
    IN VCN Vcn,
    OUT PLCN Lcn,
    OUT PLONGLONG ClusterCount,
    OUT PVOID *RangePtr OPTIONAL,
    OUT PULONG RunIndex OPTIONAL
    )

/*++

Routine Description:

    This routine looks up the given Vcn for an Scb, and returns whether it
    is allocated and how many contiguously allocated (or deallocated) Lcns
    exist at that point.

Arguments:

    Scb - Specifies which attribute the lookup is to occur on.

    Vcn - Specifies the Vcn to be looked up.

    Lcn - If returning TRUE, returns the Lcn that the specified Vcn is mapped
          to.  If returning FALSE, the return value is undefined.

    ClusterCount - If returning TRUE, returns the number of contiguously allocated
                   Lcns exist beginning at the Lcn returned.  If returning FALSE,
                   specifies the number of unallocated Vcns exist beginning with
                   the specified Vcn.

    RangePtr - If specified, we return the range index for the start of the mapping.

    RunIndex - If specified, we return the run index within the range for the start of the mapping.

Return Value:

    BOOLEAN - TRUE if the input Vcn has a corresponding Lcn and
        FALSE otherwise.

--*/

{
    ATTRIBUTE_ENUMERATION_CONTEXT Context;
    PATTRIBUTE_RECORD_HEADER Attribute;

    VCN HighestCandidate;

    BOOLEAN Found;
    BOOLEAN EntryAdded;

    VCN CapturedLowestVcn;
    VCN CapturedHighestVcn;

    PVCB Vcb = Scb->Fcb->Vcb;
    BOOLEAN McbMutexAcquired = FALSE;
    LONGLONG AllocationClusters;
    BOOLEAN MountInProgress;


    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_SCB( Scb );

    DebugTrace( +1, Dbg, ("NtfsLookupAllocation\n") );
    DebugTrace( 0, Dbg, ("Scb = %08lx\n", Scb) );
    DebugTrace( 0, Dbg, ("Vcn = %I64x\n", Vcn) );

    MountInProgress = ((IrpContext->TopLevelIrpContext->MajorFunction == IRP_MJ_FILE_SYSTEM_CONTROL) &&
                       (IrpContext->TopLevelIrpContext->MinorFunction == IRP_MN_MOUNT_VOLUME));

    //
    //  First try to look up the allocation in the mcb, and return the run
    //  from there if we can.  Also, if we are doing restart, just return
    //  the answer straight from the Mcb, because we cannot read the disk.
    //  We also do this for the Mft if the volume has been mounted as the
    //  Mcb for the Mft should always represent the entire file.
    //

    HighestCandidate = MAXLONGLONG;
    if ((Found = NtfsLookupNtfsMcbEntry( &Scb->Mcb, Vcn, Lcn, ClusterCount, NULL, NULL, RangePtr, RunIndex ))

          ||

        (Scb == Vcb->MftScb

            &&

         ((!MountInProgress) ||

         //
         //  we will not try to load the mft hole during mount while preloading in any 
         //  recursive faults
         //
          
          (FlagOn( Vcb->VcbState, VCB_STATE_PRELOAD_MFT) &&
           (!NtfsIsTopLevelNtfs( IrpContext )))))

          ||

        FlagOn( Vcb->VcbState, VCB_STATE_RESTART_IN_PROGRESS )) {

        //
        //  If not found (beyond the end of the Mcb), we will return the
        //  count to the largest representable Lcn.
        //

        if ( !Found ) {

            *ClusterCount = MAXLONGLONG - Vcn;

        //
        //  Test if we found a hole in the allocation.  In this case
        //  Found will be TRUE and the Lcn will be the UNUSED_LCN.
        //  We only expect this case at restart.
        //

        } else if (*Lcn == UNUSED_LCN) {

            //
            //  If the Mcb package returned UNUSED_LCN, because of a hole, then
            //  we turn this into FALSE.
            //

            Found = FALSE;
        }

        ASSERT( !Found ||
                (*Lcn != 0) ||
                (NtfsEqualMftRef( &Scb->Fcb->FileReference, &BootFileReference )) ||
                (NtfsEqualMftRef( &Scb->Fcb->FileReference, &VolumeFileReference )));

        DebugTrace( -1, Dbg, ("NtfsLookupAllocation -> %02lx\n", Found) );

        return Found;
    }

    PAGED_CODE();

    //
    //  Prepare for looking up attribute records to get the retrieval
    //  information.
    //

    CapturedLowestVcn = MAXLONGLONG;
    NtfsInitializeAttributeContext( &Context );

    //
    //  Make sure we have the main resource acquired shared so that the
    //  attributes in the file record are not moving around.  We blindly
    //  use Wait = TRUE.  Most of the time when we go to the disk for I/O
    //  (and thus need mapping) we are synchronous, and otherwise, the Mcb
    //  is virtually always loaded anyway and we do not get here.
    //

    NtfsAcquireResourceShared( IrpContext, Scb, TRUE );

    try {

        //
        //  Lookup the attribute record for this Scb.
        //

        NtfsLookupAttributeForScb( IrpContext, Scb, &Vcn, &Context );
        Attribute = NtfsFoundAttribute( &Context );

        ASSERT( !NtfsIsAttributeResident(Attribute) );

        if (FlagOn( Scb->ScbState, SCB_STATE_FILE_SIZE_LOADED )) {
            AllocationClusters = LlClustersFromBytesTruncate( Vcb, Scb->Header.AllocationSize.QuadPart );
        } else {
            ASSERT( NtfsUnsafeSegmentNumber( &Context.FoundAttribute.FileRecord->BaseFileRecordSegment ) == 0 );
            AllocationClusters = LlClustersFromBytesTruncate( Vcb, Attribute->Form.Nonresident.AllocatedLength );
        }

        //
        //  The desired Vcn is not currently in the Mcb.  We will loop to lookup all
        //  the allocation, and we need to make sure we cleanup on the way out.
        //
        //  It is important to note that if we ever optimize this lookup to do random
        //  access to the mapping pairs, rather than sequentially loading up the Mcb
        //  until we get the Vcn he asked for, then NtfsDeleteAllocation will have to
        //  be changed.
        //

        //
        //  Acquire exclusive access to the mcb to keep others from looking at
        //  it while it is not fully loaded.  Otherwise they might see a hole
        //  while we're still filling up the mcb
        //

        if (!FlagOn(Scb->Fcb->FcbState, FCB_STATE_NONPAGED)) {
            NtfsAcquireNtfsMcbMutex( &Scb->Mcb );
            McbMutexAcquired = TRUE;
        }

        //
        //  Store run information in the Mcb until we hit the last Vcn we are
        //  interested in, or until we cannot find any more attribute records.
        //

        while(TRUE) {

            VCN CurrentVcn;
            LCN CurrentLcn;
            LONGLONG Change;
            PCHAR ch;
            ULONG VcnBytes;
            ULONG LcnBytes;

            //
            //  If we raise here either there is some discrepancy between memory
            //  structures and on disk values or the on-disk value is completely corrupted
            //
            //  We Check:
            //  1) Verify the highest and lowest Vcn values on disk are valid.
            //  2) our starting Vcn sits within this range.
            //  3) the on-disk allocation matches the in memory value in the Scb
            //

            if ((Attribute->Form.Nonresident.LowestVcn < 0) ||
                (Attribute->Form.Nonresident.LowestVcn - 1 > Attribute->Form.Nonresident.HighestVcn) ||
                (Vcn < Attribute->Form.Nonresident.LowestVcn) ||
                (Attribute->Form.Nonresident.HighestVcn >= AllocationClusters)) {

                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Scb->Fcb );
            }

            //
            //  Define the new range.
            //

            NtfsDefineNtfsMcbRange( &Scb->Mcb,
                                    CapturedLowestVcn = Attribute->Form.Nonresident.LowestVcn,
                                    CapturedHighestVcn = Attribute->Form.Nonresident.HighestVcn,
                                    McbMutexAcquired );

            //
            //  Implement the decompression algorithm, as defined in ntfs.h.
            //

            HighestCandidate = Attribute->Form.Nonresident.LowestVcn;
            CurrentLcn = 0;
            ch = (PCHAR)Attribute + Attribute->Form.Nonresident.MappingPairsOffset;

            //
            //  Loop to process mapping pairs.
            //

            EntryAdded = FALSE;
            while (!IsCharZero(*ch)) {

                //
                //  Set Current Vcn from initial value or last pass through loop.
                //

                CurrentVcn = HighestCandidate;

                //
                //  VCNs should never be negative.
                //

                if (CurrentVcn < 0) {

                    ASSERT( FALSE );
                    NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Scb->Fcb );
                }

                //
                //  Extract the counts from the two nibbles of this byte.
                //

                VcnBytes = *ch & 0xF;
                LcnBytes = *ch++ >> 4;

                //
                //  Extract the Vcn change (use of RtlCopyMemory works for little-Endian)
                //  and update HighestCandidate.
                //

                Change = 0;

                //
                //  The file is corrupt if there are 0 or more than 8 Vcn change bytes,
                //  more than 8 Lcn change bytes, or if we would walk off the end of
                //  the record, or a Vcn change is negative.
                //

                if (((ULONG)(VcnBytes - 1) > 7) || (LcnBytes > 8) ||
                    ((ch + VcnBytes + LcnBytes + 1) > (PCHAR)Add2Ptr(Attribute, Attribute->RecordLength)) ||
                    IsCharLtrZero(*(ch + VcnBytes - 1))) {

                    ASSERT( FALSE );
                    NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Scb->Fcb );
                }
                RtlCopyMemory( &Change, ch, VcnBytes );
                ch += VcnBytes;
                HighestCandidate = HighestCandidate + Change;

                //
                //  Extract the Lcn change and update CurrentLcn.
                //

                if (LcnBytes != 0) {

                    Change = 0;
                    if (IsCharLtrZero(*(ch + LcnBytes - 1))) {
                        Change = Change - 1;
                    }
                    RtlCopyMemory( &Change, ch, LcnBytes );
                    ch += LcnBytes;
                    CurrentLcn = CurrentLcn + Change;

                    //
                    // Now add it in to the mcb.
                    //

                    if ((CurrentLcn >= 0) && (LcnBytes != 0)) {

                        LONGLONG ClustersToAdd;
                        ClustersToAdd = HighestCandidate - CurrentVcn;

                        //
                        //  Now try to add the current run.  We never expect this
                        //  call to return false.
                        //

                        ASSERT( ((ULONG)CurrentLcn) != 0xffffffff );

#ifdef NTFS_CHECK_BITMAP
                        //
                        //  Make sure these bits are allocated in our copy of the bitmap.
                        //

                        if ((Vcb->BitmapCopy != NULL) &&
                            !NtfsCheckBitmap( Vcb,
                                              (ULONG) CurrentLcn,
                                              (ULONG) ClustersToAdd,
                                              TRUE )) {

                            NtfsBadBitmapCopy( IrpContext, (ULONG) CurrentLcn, (ULONG) ClustersToAdd );
                        }
#endif
                        if (!NtfsAddNtfsMcbEntry( &Scb->Mcb,
                                                  CurrentVcn,
                                                  CurrentLcn,
                                                  ClustersToAdd,
                                                  McbMutexAcquired )) {

                            ASSERTMSG( "Unable to add entry to Mcb\n", FALSE );

                            NtfsRaiseStatus( IrpContext,
                                             STATUS_FILE_CORRUPT_ERROR,
                                             NULL,
                                             Scb->Fcb );
                        }

                        EntryAdded = TRUE;
                    }
                }
            }

            //
            //  Make sure that at least the Mcb gets loaded.
            //

            if (!EntryAdded) {
                NtfsAddNtfsMcbEntry( &Scb->Mcb,
                                     CapturedLowestVcn,
                                     UNUSED_LCN,
                                     1,
                                     McbMutexAcquired );
            }

            if ((Vcn < HighestCandidate) ||
                (!NtfsLookupNextAttributeForScb( IrpContext, Scb, &Context ))) {
                break;
            } else {
                Attribute = NtfsFoundAttribute( &Context );
                ASSERT( !NtfsIsAttributeResident(Attribute) );
            }
        }

        //
        //  Now free the mutex and lookup in the Mcb while we still own
        //  the resource.
        //

        if (McbMutexAcquired) {
            NtfsReleaseNtfsMcbMutex( &Scb->Mcb );
            McbMutexAcquired = FALSE;
        }

        if (NtfsLookupNtfsMcbEntry( &Scb->Mcb, Vcn, Lcn, ClusterCount, NULL, NULL, RangePtr, RunIndex )) {

            Found = (BOOLEAN)(*Lcn != UNUSED_LCN);

            if (Found) { ASSERT_LCN_RANGE_CHECKING( Vcb, (*Lcn + *ClusterCount) ); }

        } else {

            Found = FALSE;

            //
            //  At the end of file, we pretend there is one large hole!
            //

            if (HighestCandidate >=
                LlClustersFromBytes(Vcb, Scb->Header.AllocationSize.QuadPart)) {
                HighestCandidate = MAXLONGLONG;
            }

            *ClusterCount = HighestCandidate - Vcn;
        }

    } finally {

        DebugUnwind( NtfsLookupAllocation );

        //
        //  If this is an error case then we better unload what we've just
        //  loaded
        //

        if (AbnormalTermination() &&
            (CapturedLowestVcn != MAXLONGLONG) ) {

            NtfsUnloadNtfsMcbRange( &Scb->Mcb,
                                    CapturedLowestVcn,
                                    CapturedHighestVcn,
                                    FALSE,
                                    McbMutexAcquired );
        }

        //
        //  In all cases we free up the mcb that we locked before entering
        //  the try statement
        //

        if (McbMutexAcquired) {
            NtfsReleaseNtfsMcbMutex( &Scb->Mcb );
        }

        NtfsReleaseResource( IrpContext, Scb );

        //
        // Cleanup the attribute context on the way out.
        //

        NtfsCleanupAttributeContext( IrpContext, &Context );
    }

    ASSERT( !Found ||
            (*Lcn != 0) ||
            (NtfsEqualMftRef( &Scb->Fcb->FileReference, &BootFileReference )) ||
            (NtfsEqualMftRef( &Scb->Fcb->FileReference, &VolumeFileReference )));

    DebugTrace( 0, Dbg, ("Lcn < %0I64x\n", *Lcn) );
    DebugTrace( 0, Dbg, ("ClusterCount < %0I64x\n", *ClusterCount) );
    DebugTrace( -1, Dbg, ("NtfsLookupAllocation -> %02lx\n", Found) );

    return Found;
}


BOOLEAN
NtfsIsRangeAllocated (
    IN PSCB Scb,
    IN VCN StartVcn,
    IN VCN FinalCluster,
    IN BOOLEAN RoundToSparseUnit,
    OUT PLONGLONG ClusterCount
    )

/*++

Routine Description:

    This routine is called on a sparse file to test the status of a range of the
    file.  Ntfs will return whether the range is allocated and also a known value
    for the length of the allocation.  It is possible that the range extends
    beyond this point but another call needs to be made to check it.

    Our caller needs to verify that the Mcb is loaded in this range i.e precall NtfsPreLoadAllocation

Arguments:

    Scb - Scb for the file to check.  This should be a sparse file.

    StartVcn - Vcn within the range to check first.

    FinalCluster - Trim the clusters found so we don't go beyond this point.

    RoundToSparseUnit - If TRUE the range is rounded up to VCB->SparseFileUnit == 0x10000
                        so you may get a range returned as allocated which contain
                        a partial sparse area depending on the compression unit.

    ClusterCount - Address to store the count of clusters of a known state.

Return Value:

    BOOLEAN - TRUE if the range is allocated, FALSE otherwise.

--*/

{
    BOOLEAN AllocatedRange;
    VCN ThisVcn;
    VCN ThisLcn;
    VCN ThisClusterCount;
    PVOID RangePtr;
    ULONG RunIndex;

    ULONG VcnClusterOffset = 0;
    VCN FoundClusterCount = 0;


    PAGED_CODE();

    //
    //  Assert that the file is sparse, non-resident and we are within file size.
    //

    ASSERT( FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_SPARSE ));
    ASSERT( !FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT ));

    //
    //  Move the starting point back to a sparse file boundary.
    //

    ThisVcn = StartVcn;

    if (RoundToSparseUnit) {
        VcnClusterOffset = ((PLARGE_INTEGER) &ThisVcn)->LowPart & (Scb->Vcb->SparseFileClusters - 1);
        ((PLARGE_INTEGER) &ThisVcn)->LowPart &= ~(Scb->Vcb->SparseFileClusters - 1);
    }

    //
    //  Lookup the allocation at that position.
    //

    AllocatedRange = NtfsLookupNtfsMcbEntry( &Scb->Mcb,
                                             ThisVcn,
                                             &ThisLcn,
                                             &ThisClusterCount,
                                             NULL,
                                             NULL,
                                             &RangePtr,
                                             &RunIndex );

    //
    //  If the range has no mapping then it is entirely sparse.
    //

    if (!AllocatedRange) {

        ThisClusterCount = MAXLONGLONG;

    //
    //  If the block is not allocated and the length of the run is not enough
    //  clusters for a sparse file unit then look to make sure the block
    //  is fully deallocated.
    //

    } else if (ThisLcn == UNUSED_LCN) {

        AllocatedRange = FALSE;

        while (TRUE) {

            FoundClusterCount += ThisClusterCount;
            ThisVcn += ThisClusterCount;
            ThisClusterCount = 0;

            //
            //  Check successive runs to extend the hole.
            //

            if (ThisVcn >= FinalCluster) {

                break;
            }

            RunIndex += 1;
            if (!NtfsGetSequentialMcbEntry( &Scb->Mcb,
                                            &RangePtr,
                                            RunIndex,
                                            &ThisVcn,
                                            &ThisLcn,
                                            &ThisClusterCount )) {

                //
                //  The file is deallocated from here to the end of the Mcb.
                //  Treat this as a large hole.
                //

                ThisClusterCount = MAXLONGLONG - FoundClusterCount;
                break;
            }

            //
            //  If the range is allocated and we haven't found a full sparse unit
            //  then mark the block as allocated.  If we have at lease one sparse
            //  file unit then trim the hole back to the nearest sparse file
            //  unit boundary.
            //

            if (ThisLcn != UNUSED_LCN) {

                if (RoundToSparseUnit) {
                    if (FoundClusterCount < Scb->Vcb->SparseFileClusters) {

                        //
                        //  Set our variables to indicate we are at the start of a fully
                        //  allocated sparse block.
                        //

                        ThisVcn -= FoundClusterCount;
                        ThisClusterCount += FoundClusterCount;
                        FoundClusterCount = 0;

                        AllocatedRange = TRUE;

                    } else {

                        ThisClusterCount = 0;
                        ((PLARGE_INTEGER) &FoundClusterCount)->LowPart &= ~(Scb->Vcb->SparseFileClusters - 1);
                    }
                }

                break;
            }
        }
    }

    //
    //  If we have an allocated block then find all of the contiguous allocated
    //  blocks we can.
    //

    if (AllocatedRange) {

        while (TRUE) {

            if (RoundToSparseUnit) {

                //
                //  Round the clusters found to a sparse file unit and update
                //  the next vcn and count of clusters found.
                //

                ThisClusterCount += Scb->Vcb->SparseFileClusters - 1;
                ((PLARGE_INTEGER) &ThisClusterCount)->LowPart &= ~(Scb->Vcb->SparseFileClusters - 1);
            }

            ThisVcn += ThisClusterCount;
            FoundClusterCount += ThisClusterCount;

            //
            //  Break out if we are past our final target or the beginning of the
            //  next range is not allocated.
            //

            if ((ThisVcn >= FinalCluster) ||
                !NtfsLookupNtfsMcbEntry( &Scb->Mcb,
                                         ThisVcn,
                                         &ThisLcn,
                                         &ThisClusterCount,
                                         NULL,
                                         NULL,
                                         &RangePtr,
                                         &RunIndex ) ||
                (ThisLcn == UNUSED_LCN)) {

                ThisClusterCount = 0;
                break;
            }
        }
    }

    //
    //  Trim the clusters found to either a sparse file unit or the input final
    //  cluster value.
    //

    *ClusterCount = ThisClusterCount + FoundClusterCount - (LONGLONG) VcnClusterOffset;

    if ((FinalCluster - StartVcn) < *ClusterCount) {

        *ClusterCount = FinalCluster - StartVcn;
    }

    return AllocatedRange;
}


BOOLEAN
NtfsAllocateAttribute (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN ATTRIBUTE_TYPE_CODE AttributeTypeCode,
    IN PUNICODE_STRING AttributeName OPTIONAL,
    IN USHORT AttributeFlags,
    IN BOOLEAN AllocateAll,
    IN BOOLEAN LogIt,
    IN LONGLONG Size,
    IN PATTRIBUTE_ENUMERATION_CONTEXT NewLocation OPTIONAL
    )

/*++

Routine Description:

    This routine creates a new attribute and allocates space for it, either in a
    file record, or as a nonresident attribute.

Arguments:

    Scb - Scb for the attribute.

    AttributeTypeCode - Attribute type code to be created.

    AttributeName - Optional name for the attribute.

    AttributeFlags - Flags to be stored in the attribute record for this attribute.

    AllocateAll - Specified as TRUE if all allocation should be allocated,
                  even if we have to break up the transaction.

    LogIt - Most callers should specify TRUE, to have the change logged.  However,
            we can specify FALSE if we are creating a new file record, and
            will be logging the entire new file record.

    Size - Size in bytes to allocate for the attribute.

    NewLocation - If specified, this is the location to store the attribute.

Return Value:

    FALSE - if the attribute was created, but not all of the space was allocated
            (this can only happen if Scb was not specified)
    TRUE - if the space was allocated.

--*/

{
    BOOLEAN UninitializeOnClose = FALSE;
    BOOLEAN NewLocationSpecified;
    ATTRIBUTE_ENUMERATION_CONTEXT Context;
    LONGLONG ClusterCount, SavedClusterCount;
    BOOLEAN FullAllocation;
    PFCB Fcb = Scb->Fcb;
    LONGLONG Delta = NtfsResidentStreamQuota( Fcb->Vcb );

    PAGED_CODE();

    //
    //  Either there is no compression taking place or the attribute
    //  type code allows compression to be specified in the header.
    //  $INDEX_ROOT is a special hack to store the inherited-compression
    //  flag.
    //

    ASSERT( (AttributeFlags == 0) ||
            (AttributeTypeCode == $INDEX_ROOT) ||
            NtfsIsTypeCodeCompressible( AttributeTypeCode ));

    //
    //  If the file is being created compressed, then we need to round its
    //  size to a compression unit boundary.
    //

    if ((Scb->CompressionUnit != 0) &&
        (Scb->Header.NodeTypeCode == NTFS_NTC_SCB_DATA)) {

        Size += Scb->CompressionUnit - 1;
        ((PLARGE_INTEGER) &Size)->LowPart &= ~(Scb->CompressionUnit - 1);
    }

    //
    //  Prepare for looking up attribute records to get the retrieval
    //  information.
    //

    if (ARGUMENT_PRESENT( NewLocation )) {

        NewLocationSpecified = TRUE;

    } else {

        NtfsInitializeAttributeContext( &Context );
        NewLocationSpecified = FALSE;
        NewLocation = &Context;
    }

    try {

        //
        //  If the FILE_SIZE_LOADED flag is not set, then this Scb is for
        //  an attribute that does not yet exist on disk.  We will put zero
        //  into all of the sizes fields and set the flags indicating that
        //  Scb is valid.  NOTE - This routine expects both FILE_SIZE_LOADED
        //  and HEADER_INITIALIZED to be both set or both clear.
        //

        ASSERT( BooleanFlagOn( Scb->ScbState, SCB_STATE_FILE_SIZE_LOADED )
                ==  BooleanFlagOn( Scb->ScbState, SCB_STATE_HEADER_INITIALIZED ));

        if (!FlagOn( Scb->ScbState, SCB_STATE_FILE_SIZE_LOADED )) {

            Scb->ValidDataToDisk =
            Scb->Header.AllocationSize.QuadPart =
            Scb->Header.FileSize.QuadPart =
            Scb->Header.ValidDataLength.QuadPart = 0;

            SetFlag( Scb->ScbState, SCB_STATE_FILE_SIZE_LOADED |
                                    SCB_STATE_HEADER_INITIALIZED |
                                    SCB_STATE_UNINITIALIZE_ON_RESTORE );

            UninitializeOnClose = TRUE;
        }

        //
        //  Now snapshot this Scb.  We use a try-finally so we can uninitialize
        //  the scb if neccessary.
        //

        NtfsSnapshotScb( IrpContext, Scb );

        UninitializeOnClose = FALSE;

        //
        //  First allocate the space he wants.
        //

        SavedClusterCount =
        ClusterCount = LlClustersFromBytes(Fcb->Vcb, Size);

        Scb->TotalAllocated = 0;

        if (Size != 0) {

            ASSERT( NtfsIsExclusiveScb( Scb ));

            Scb->ScbSnapshot->LowestModifiedVcn = 0;
            Scb->ScbSnapshot->HighestModifiedVcn = MAXLONGLONG;

            NtfsAllocateClusters( IrpContext,
                                  Fcb->Vcb,
                                  Scb,
                                  (LONGLONG)0,
                                  (BOOLEAN)!NtfsIsTypeCodeUserData( AttributeTypeCode ),
                                  ClusterCount,
                                  NULL,
                                  &ClusterCount );

            //
            //  Account for any new clusters in the allocation.
            //

            Delta += LlBytesFromClusters( Fcb->Vcb, ClusterCount );
        }

        //
        //  Make sure the owner is allowed to have this space.
        //

        if (FlagOn( Scb->ScbState, SCB_STATE_SUBJECT_TO_QUOTA )) {

            ASSERT( NtfsIsTypeCodeSubjectToQuota( Scb->AttributeTypeCode ));

            NtfsConditionallyUpdateQuota( IrpContext,
                                          Fcb,
                                          &Delta,
                                          LogIt,
                                          TRUE );
        }

        //
        //  Now create the attribute.  Remember if this routine
        //  cut the allocation because of logging problems.
        //

        FullAllocation = NtfsCreateAttributeWithAllocation( IrpContext,
                                                            Scb,
                                                            AttributeTypeCode,
                                                            AttributeName,
                                                            AttributeFlags,
                                                            LogIt,
                                                            NewLocationSpecified,
                                                            NewLocation );

        if (AllocateAll &&
            (!FullAllocation ||
             (ClusterCount < SavedClusterCount))) {

            //
            //  If we are creating the attribute, then we only need to pass a
            //  file object below if we already cached it ourselves, such as
            //  in the case of ConvertToNonresident.
            //

            NtfsAddAllocation( IrpContext,
                               Scb->FileObject,
                               Scb,
                               ClusterCount,
                               (SavedClusterCount - ClusterCount),
                               FALSE,
                               NULL );

            //
            //  Show that we allocated all of the space.
            //

            ClusterCount = SavedClusterCount;
            FullAllocation = TRUE;
        }

    } finally {

        DebugUnwind( NtfsAllocateAttribute );

        //
        //  Cleanup the attribute context on the way out.
        //

        if (!NewLocationSpecified) {

            NtfsCleanupAttributeContext( IrpContext, &Context );
        }

        //
        //  Clear out the Scb if it was uninitialized to begin with.
        //

        if (UninitializeOnClose) {

            ClearFlag( Scb->ScbState, SCB_STATE_FILE_SIZE_LOADED |
                                      SCB_STATE_HEADER_INITIALIZED |
                                      SCB_STATE_UNINITIALIZE_ON_RESTORE );
        }
    }

    return (FullAllocation && (SavedClusterCount <= ClusterCount));
}


VOID
NtfsAddAllocation (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject OPTIONAL,
    IN OUT PSCB Scb,
    IN VCN StartingVcn,
    IN LONGLONG ClusterCount,
    IN LOGICAL AskForMore,
    IN OUT PCCB CcbForWriteExtend OPTIONAL
    )

/*++

Routine Description:

    This routine adds allocation to an existing nonresident attribute.  None of
    the allocation is allowed to already exist, as this would make error recovery
    too difficult.  The caller must insure that he only asks for space not already
    allocated.

Arguments:

    FileObject - FileObject for the Scb

    Scb - Scb for the attribute needing allocation

    StartingVcn - First Vcn to be allocated.

    ClusterCount - Number of clusters to allocate.

    AskForMore - Indicates if we want to ask for extra allocation.

    CcbForWriteExtend - Use the WriteExtendCount in this Ccb to determine the number of times
        this file has been write extended.  Use this in combination with AskForMore to
        determine how much more to ask for.

Return Value:

    None.

--*/

{
    LONGLONG DesiredClusterCount;

    ATTRIBUTE_ENUMERATION_CONTEXT Context;
    BOOLEAN Extending;
    BOOLEAN AllocateAll;


    PVCB Vcb = IrpContext->Vcb;

    LONGLONG LlTemp1;
    LONGLONG LlTemp2;

    PAGED_CODE();

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_SCB( Scb );
    ASSERT_EXCLUSIVE_SCB( Scb );

    DebugTrace( +1, Dbg, ("NtfsAddAllocation\n") );

    //
    //  Determine if we must allocate in one shot or if partial results are allowed.
    //

    if (NtfsIsTypeCodeUserData( Scb->AttributeTypeCode ) &&
        NtfsSegmentNumber( &Scb->Fcb->FileReference ) >= FIRST_USER_FILE_NUMBER) {

        AllocateAll = FALSE;

    } else {

        AllocateAll = TRUE;

    }


    //
    //  We cannot add space in this high level routine during restart.
    //  Everything we can use is in the Mcb.
    //

    if (FlagOn(Scb->Vcb->VcbState, VCB_STATE_RESTART_IN_PROGRESS)) {

        DebugTrace( -1, Dbg, ("NtfsAddAllocation (Nooped for Restart) -> VOID\n") );

        return;
    }

    //
    //  We limit the user to 32 bits for the clusters unless the file is
    //  sparse.  For sparse files we limit ourselves to 63 bits for the file size.
    //

    LlTemp1 = ClusterCount + StartingVcn;

    if (!FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_SPARSE )) {

        if ((((PLARGE_INTEGER)&ClusterCount)->HighPart != 0)
            || (((PLARGE_INTEGER)&StartingVcn)->HighPart != 0)
            || (((PLARGE_INTEGER)&LlTemp1)->HighPart != 0)) {

            NtfsRaiseStatus( IrpContext, STATUS_DISK_FULL, NULL, NULL );
        }
    }

    //
    //  First make sure the Mcb is loaded.
    //

    NtfsPreloadAllocation( IrpContext, Scb, StartingVcn,  StartingVcn + ClusterCount - 1 );

    //
    //  Now make the call to add the new allocation, and get out if we do
    //  not actually have to allocate anything.  Before we do the allocation
    //  call check if we need to compute a new desired cluster count for
    //  extending a data attribute.  We never allocate more than the requested
    //  clusters for the Mft.
    //

    Extending = (BOOLEAN)((LONGLONG)LlBytesFromClusters(Vcb, (StartingVcn + ClusterCount)) >
                          Scb->Header.AllocationSize.QuadPart);

    //
    //  Check if we need to modified the base Vcn value stored in the snapshot for
    //  the abort case.
    //

    ASSERT( NtfsIsExclusiveScb( Scb ));

    if (Scb->ScbSnapshot == NULL) {

        NtfsSnapshotScb( IrpContext, Scb );
    }

    if (Scb->ScbSnapshot != NULL) {

        if (StartingVcn < Scb->ScbSnapshot->LowestModifiedVcn) {

            Scb->ScbSnapshot->LowestModifiedVcn = StartingVcn;
        }

        LlTemp1 -= 1;
        if (LlTemp1 > Scb->ScbSnapshot->HighestModifiedVcn) {

            if (Extending) {
                Scb->ScbSnapshot->HighestModifiedVcn = MAXLONGLONG;
            } else {
                Scb->ScbSnapshot->HighestModifiedVcn = LlTemp1;
            }
        }
    }

    ASSERT( (Scb->ScbSnapshot != NULL) ||
            !NtfsIsTypeCodeUserData( Scb->AttributeTypeCode ) ||
            (Scb == Vcb->BitmapScb) );

    if (AskForMore) {

        LONGLONG MaxFreeClusters;

        //
        //  Assume these are the same.
        //

        DesiredClusterCount = ClusterCount;

        //
        //  If there is a Ccb with a WriteExtend count less than 4 then use it.
        //

        if (ARGUMENT_PRESENT( CcbForWriteExtend )) {

            //
            //  We want to be slightly smart about the rounding factor.  The key thing is to keep
            //  the user's data contiguous within likely IO boundaries (MM flush regions, etc).
            //  We will progressively round to higher even cluster values based on the number of times the
            //  user has extended the file.
            //

            if (CcbForWriteExtend->WriteExtendCount != 0) {

                //
                //  Initialize the rounding mask to 2 clusters and higher multiples of 2.
                //

                ULONG RoundingMask = (1 << CcbForWriteExtend->WriteExtendCount) - 1;

                //
                //  Next perform the basic shift based on the size of this allocation.
                //

                DesiredClusterCount = Int64ShllMod32( ClusterCount, CcbForWriteExtend->WriteExtendCount );

                //
                //  Now bias this by the StartingVcn and round this to the selected boundary.
                //

                DesiredClusterCount += StartingVcn + RoundingMask;

                //
                //  Now truncate to the selected boundary.
                //

                ((PLARGE_INTEGER)&DesiredClusterCount)->LowPart &= ~RoundingMask;

                //
                //  Remove the StartingVcn bias and see if there is anything left.
                //  Note: the 2nd test is for a longlong rollover 
                //

                if ((DesiredClusterCount - StartingVcn < ClusterCount)  ||
                    (DesiredClusterCount < StartingVcn)) {

                    DesiredClusterCount = ClusterCount;
                
                } else {
                    DesiredClusterCount -= StartingVcn;
                }

                //
                //  Don't use more than 2^32 clusters.
                //

                if (StartingVcn + DesiredClusterCount > MAX_CLUSTERS_PER_RANGE) {

                    DesiredClusterCount = ClusterCount;
                }
            }

            //
            //  Increment the extend count.
            //

            if (CcbForWriteExtend->WriteExtendCount < 4) {

                CcbForWriteExtend->WriteExtendCount += 1;
            }
        }

        //
        //  Make sure we don't exceed our maximum file size.
        //  Also don't swallow up too much of the remaining disk space.
        //

        MaxFreeClusters = Int64ShraMod32( Vcb->FreeClusters, 10 ) + ClusterCount;

        if (Vcb->MaxClusterCount - StartingVcn < MaxFreeClusters) {

            MaxFreeClusters = Vcb->MaxClusterCount - StartingVcn;

            ASSERT( MaxFreeClusters >= ClusterCount );
        }

        if (DesiredClusterCount > MaxFreeClusters) {

            DesiredClusterCount = MaxFreeClusters;
        }

        if (NtfsPerformQuotaOperation(Scb->Fcb)) {

            NtfsGetRemainingQuota( IrpContext,
                                   Scb->Fcb->OwnerId,
                                   &LlTemp1,
                                   &LlTemp2,
                                   &Scb->Fcb->QuotaControl->QuickIndexHint );

            //
            //  Do not use LlClustersFromBytesTruncate it is signed and this must be
            //  an unsigned operation.
            //

            LlTemp1 = Int64ShrlMod32( LlTemp1, Vcb->ClusterShift );

            if (DesiredClusterCount > LlTemp1) {

                //
                //  The owner is near their quota limit.  Do not grow the
                //  file past the requested amount.  Note we do not bother
                //  calculating a desired amount based on the remaining quota.
                //  This keeps us from using up a bunch of quota that we may
                //  not need when the user is near the limit.
                //

                DesiredClusterCount = ClusterCount;
            }
        }

    } else {

        DesiredClusterCount = ClusterCount;
    }

    //
    //  All allocation adds for compressed / sparse files should start on a compression unit boundary
    //  

    ASSERT( (Scb->CompressionUnit == 0) ||
            !FlagOn( StartingVcn, ClustersFromBytes( Scb->Vcb, Scb->CompressionUnit ) - 1) );

    //
    //  Prepare for looking up attribute records to get the retrieval
    //  information.
    //

    NtfsInitializeAttributeContext( &Context );

    if (Extending &&
        FlagOn( Scb->ScbState, SCB_STATE_SUBJECT_TO_QUOTA ) &&
        NtfsPerformQuotaOperation( Scb->Fcb )) {

        ASSERT( NtfsIsTypeCodeSubjectToQuota( Scb->AttributeTypeCode ));

        //
        //  The quota index must be acquired before the mft scb is acquired.
        //

        ASSERT(!NtfsIsExclusiveScb( Vcb->MftScb ) || ExIsResourceAcquiredSharedLite( Vcb->QuotaTableScb->Fcb->Resource ));

        NtfsAcquireQuotaControl( IrpContext, Scb->Fcb->QuotaControl );

    }

    try {

        while (TRUE) {

            //  Toplevel action is currently incompatible with our error recovery.
            //  It also costs in performance.
            //
            //  //
            //  //  Start the top-level action by remembering the current UndoNextLsn.
            //  //
            //
            //  if (IrpContext->TransactionId != 0) {
            //
            //      PTRANSACTION_ENTRY TransactionEntry;
            //
            //      NtfsAcquireSharedRestartTable( &Vcb->TransactionTable, TRUE );
            //
            //      TransactionEntry = (PTRANSACTION_ENTRY)GetRestartEntryFromIndex(
            //                          &Vcb->TransactionTable, IrpContext->TransactionId );
            //
            //      StartLsn = TransactionEntry->UndoNextLsn;
            //      SavedUndoRecords = TransactionEntry->UndoRecords;
            //      SavedUndoBytes = TransactionEntry->UndoBytes;
            //      NtfsReleaseRestartTable( &Vcb->TransactionTable );
            //
            //  } else {
            //
            //      StartLsn = *(PLSN)&Li0;
            //      SavedUndoRecords = 0;
            //      SavedUndoBytes = 0;
            //  }
            //

            //
            //  Remember that the clusters are only in the Scb now.
            //

            if (NtfsAllocateClusters( IrpContext,
                                      Scb->Vcb,
                                      Scb,
                                      StartingVcn,
                                      AllocateAll,
                                      ClusterCount,
                                      NULL,
                                      &DesiredClusterCount )) {


                //
                //  We defer looking up the attribute to make the "already-allocated"
                //  case faster.
                //

                NtfsLookupAttributeForScb( IrpContext, Scb, NULL, &Context );

                //
                //  Now add the space to the file record, if any was allocated.
                //

                if (Extending) {

                    LlTemp1 = Scb->Header.AllocationSize.QuadPart;

                    NtfsAddAttributeAllocation( IrpContext,
                                                Scb,
                                                &Context,
                                                NULL,
                                                NULL );

                    //
                    //  Make sure the owner is allowed to have these
                    //  clusters.
                    //

                    if (FlagOn( Scb->ScbState, SCB_STATE_SUBJECT_TO_QUOTA )) {

                        //
                        //  Note the allocated clusters cannot be used
                        //  here because StartingVcn may be greater
                        //  then allocation size.
                        //

                        LlTemp1 = Scb->Header.AllocationSize.QuadPart - LlTemp1;

                        NtfsConditionallyUpdateQuota( IrpContext,
                                                      Scb->Fcb,
                                                      &LlTemp1,
                                                      TRUE,
                                                      TRUE );
                    }
                } else {

                    NtfsAddAttributeAllocation( IrpContext,
                                                Scb,
                                                &Context,
                                                &StartingVcn,
                                                &ClusterCount );
                }

            //
            //  If he did not allocate anything, make sure we get out below.
            //

            } else {
                DesiredClusterCount = ClusterCount;
            }

            //  Toplevel action is currently incompatible with our error recovery.
            //
            //  //
            //  //  Now we will end this routine as a top-level action so that
            //  //  anyone can use this extended space.
            //  //
            //  //  ****If we find that we are always keeping the Scb exclusive anyway,
            //  //      we could eliminate this log call.
            //  //
            //
            //  (VOID)NtfsWriteLog( IrpContext,
            //                      Vcb->MftScb,
            //                      NULL,
            //                      EndTopLevelAction,
            //                      NULL,
            //                      0,
            //                      CompensationLogRecord,
            //                      (PVOID)&StartLsn,
            //                      sizeof(LSN),
            //                      Li0,
            //                      0,
            //                      0,
            //                      0 );
            //
            //  //
            //  //  Now reset the undo information for the top-level action.
            //  //
            //
            //  {
            //      PTRANSACTION_ENTRY TransactionEntry;
            //
            //      NtfsAcquireSharedRestartTable( &Vcb->TransactionTable, TRUE );
            //
            //      TransactionEntry = (PTRANSACTION_ENTRY)GetRestartEntryFromIndex(
            //                          &Vcb->TransactionTable, IrpContext->TransactionId );
            //
            //      ASSERT(TransactionEntry->UndoBytes >= SavedUndoBytes);
            //
            //      LfsResetUndoTotal( Vcb->LogHandle,
            //                         TransactionEntry->UndoRecords - SavedUndoRecords,
            //                         -(TransactionEntry->UndoBytes - SavedUndoBytes) );
            //
            //      TransactionEntry->UndoRecords = SavedUndoRecords;
            //      TransactionEntry->UndoBytes = SavedUndoBytes;
            //
            //
            //      NtfsReleaseRestartTable( &Vcb->TransactionTable );
            //  }
            //

            //
            //  Call the Cache Manager to extend the section, now that we have
            //  succeeded.
            //

            if (ARGUMENT_PRESENT( FileObject) && Extending) {

                NtfsSetBothCacheSizes( FileObject,
                                       (PCC_FILE_SIZES)&Scb->Header.AllocationSize,
                                       Scb );
            }

            //
            //  Set up to truncate on close.
            //

            SetFlag( Scb->ScbState, SCB_STATE_TRUNCATE_ON_CLOSE );

            //
            //  See if we need to loop back.
            //

            if (DesiredClusterCount < ClusterCount) {

                NtfsCleanupAttributeContext( IrpContext, &Context );

                //
                //  Commit the current transaction if we have one.
                //

                NtfsCheckpointCurrentTransaction( IrpContext );

                //
                //  Adjust our parameters and reinitialize the context
                //  for the loop back.
                //

                StartingVcn = StartingVcn + DesiredClusterCount;
                ClusterCount = ClusterCount - DesiredClusterCount;
                DesiredClusterCount = ClusterCount;
                NtfsInitializeAttributeContext( &Context );

            //
            //  Else we are done.
            //

            } else {

                break;
            }
        }

    } finally {

        DebugUnwind( NtfsAddAllocation );

        //
        //  Cleanup the attribute context on the way out.
        //

        NtfsCleanupAttributeContext( IrpContext, &Context );
    }

    DebugTrace( -1, Dbg, ("NtfsAddAllocation -> VOID\n") );

    return;
}


VOID
NtfsAddSparseAllocation (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject OPTIONAL,
    IN OUT PSCB Scb,
    IN LONGLONG StartingOffset,
    IN LONGLONG ByteCount
    )

/*++

Routine Description:

    This routine is called to add a hole to the end of a sparse file.  We need to
    force NtfsAddAttributeAllocation to extend a file via a hole.  We do this be
    adding a new range to the end of the Mcb and force it to have a LargeMcb.
    NtfsAddAttributeAllocation recognizes this and will write the file record.
    Otherwise that routine will truncate the hole at the end of a file.

Arguments:

    FileObject - FileObject for the Scb

    Scb - Scb for the attribute needing allocation

    StartingOffset - File offset which contains the first compression unit to add.

    ByteCount - Number of bytes to allocate from the StartingOffset.

Return Value:

    None.

--*/

{
    LONGLONG Range;
    VCN StartingVcn = LlClustersFromBytesTruncate( Scb->Vcb,
                                                   Scb->Header.AllocationSize.LowPart );
    BOOLEAN UnloadMcb = TRUE;

    ATTRIBUTE_ENUMERATION_CONTEXT Context;

    PAGED_CODE();

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_SCB( Scb );
    ASSERT_EXCLUSIVE_SCB( Scb );

    DebugTrace( +1, Dbg, ("NtfsAddSparseAllocation\n") );

    //
    //  Do a sanity check on the following.
    //
    //      - This is not restart.
    //      - This is a sparse file.
    //      - The StartingOffset is beyond the end of the file.
    //

    ASSERT( !FlagOn( Scb->Vcb->VcbState, VCB_STATE_RESTART_IN_PROGRESS ) &&
            FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_SPARSE ) &&
            (StartingOffset >= Scb->Header.AllocationSize.QuadPart) );

    //
    //  Check if we need to modified the base Vcn value stored in the snapshot for
    //  the abort case.
    //

    if (Scb->ScbSnapshot == NULL) {

        NtfsSnapshotScb( IrpContext, Scb );
    }

    if (Scb->ScbSnapshot != NULL) {

        if (StartingVcn < Scb->ScbSnapshot->LowestModifiedVcn) {

            Scb->ScbSnapshot->LowestModifiedVcn = StartingVcn;
        }

        Scb->ScbSnapshot->HighestModifiedVcn = MAXLONGLONG;
    }

    ASSERT( Scb->ScbSnapshot != NULL );

    //
    //  Round the end of the allocation upto a compression unit boundary.
    //

    Range = StartingOffset + ByteCount + (Scb->CompressionUnit - 1);
    ((PLARGE_INTEGER) &Range)->LowPart &= ~(Scb->CompressionUnit - 1);

    ASSERT( Range <= MAXFILESIZE );

    //
    //  Convert from bytes to clusters.
    //

    StartingVcn = LlClustersFromBytesTruncate( Scb->Vcb, Scb->Header.AllocationSize.QuadPart );
    Range = LlClustersFromBytesTruncate( Scb->Vcb, Range );

    //
    //  Initialize the lookup context.
    //

    NtfsInitializeAttributeContext( &Context );

    try {

        //
        //  Load the allocation for the range ahead of us.
        //

        if (StartingOffset != 0) {

            NtfsPreloadAllocation( IrpContext,
                                   Scb,
                                   StartingVcn - 1,
                                   StartingVcn - 1 );
        }

        //
        //  Define a range past the current end of the file.
        //

        NtfsDefineNtfsMcbRange( &Scb->Mcb,
                                StartingVcn,
                                Range - 1,
                                FALSE );

        //
        //  Now add a single hole so that there is an Mcb entry.
        //

        NtfsAddNtfsMcbEntry( &Scb->Mcb,
                             StartingVcn,
                             UNUSED_LCN,
                             Range - StartingVcn,
                             FALSE );

        //
        //  Lookup the first file record for this Scb.
        //

        NtfsLookupAttributeForScb( IrpContext, Scb, NULL, &Context );

        if (FlagOn( Scb->ScbState, SCB_STATE_SUBJECT_TO_QUOTA ) &&
            NtfsPerformQuotaOperation( Scb->Fcb )) {

            ASSERT( NtfsIsTypeCodeSubjectToQuota( Scb->AttributeTypeCode ));

            //
            //  The quota index must be acquired before the mft scb is acquired.
            //

            ASSERT( !NtfsIsExclusiveScb( Scb->Vcb->MftScb ) ||
                    ExIsResourceAcquiredSharedLite( Scb->Vcb->QuotaTableScb->Fcb->Resource ));

            NtfsAcquireQuotaControl( IrpContext, Scb->Fcb->QuotaControl );
        }

        //
        //  Now add the space to the file record, if any was allocated.
        //

        Range = Scb->Header.AllocationSize.QuadPart;

        NtfsAddAttributeAllocation( IrpContext,
                                    Scb,
                                    &Context,
                                    NULL,
                                    NULL );

        //
        //  Make sure the owner is allowed to have these
        //  clusters.
        //

        if (FlagOn( Scb->ScbState, SCB_STATE_SUBJECT_TO_QUOTA )) {

            //
            //  Note the allocated clusters cannot be used
            //  here because StartingVcn may be greater
            //  then allocation size.
            //

            Range = Scb->Header.AllocationSize.QuadPart - Range;

            NtfsConditionallyUpdateQuota( IrpContext,
                                          Scb->Fcb,
                                          &Range,
                                          TRUE,
                                          TRUE );
        }

        //
        //  Call the Cache Manager to extend the section, now that we have
        //  succeeded.
        //

        if (ARGUMENT_PRESENT( FileObject)) {

            NtfsSetBothCacheSizes( FileObject,
                                   (PCC_FILE_SIZES)&Scb->Header.AllocationSize,
                                   Scb );
        }

        //
        //  Set up to truncate on close.
        //

        SetFlag( Scb->ScbState, SCB_STATE_TRUNCATE_ON_CLOSE );
        UnloadMcb = FALSE;

    } finally {

        DebugUnwind( NtfsAddSparseAllocation );

        //
        //  Manually unload the Mcb in the event of an error.  There may not be a
        //  transaction underway.
        //

        if (UnloadMcb) {

            NtfsUnloadNtfsMcbRange( &Scb->Mcb,
                                    StartingVcn,
                                    MAXLONGLONG,
                                    FALSE,
                                    FALSE );
        }

        //
        //  Cleanup the attribute context on the way out.
        //

        NtfsCleanupAttributeContext( IrpContext, &Context );
    }

    DebugTrace( -1, Dbg, ("NtfsAddSparseAllocation -> VOID\n") );

    return;
}


VOID
NtfsDeleteAllocation (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject OPTIONAL,
    IN OUT PSCB Scb,
    IN VCN StartingVcn,
    IN VCN EndingVcn,
    IN BOOLEAN LogIt,
    IN BOOLEAN BreakupAllowed
    )

/*++

Routine Description:

    This routine deletes allocation from an existing nonresident attribute.  If all
    or part of the allocation does not exist, the effect is benign, and only the
    remaining allocation is deleted.

Arguments:

    FileObject - FileObject for the Scb.  This should always be specified if
                 possible, and must be specified if it is possible that MM has a
                 section created.

    Scb - Scb for the attribute needing allocation

    StartingVcn - First Vcn to be deallocated.

    EndingVcn - Last Vcn to be deallocated, or xxMax to truncate at StartingVcn.
                If EndingVcn is *not* xxMax, a sparse deallocation is performed,
                and none of the stream sizes are changed.

    LogIt - Most callers should specify TRUE, to have the change logged.  However,
            we can specify FALSE if we are deleting the file record, and
            will be logging this delete.

    BreakupAllowed - TRUE if the caller can tolerate breaking up the deletion of
                     allocation into multiple transactions, if there are a large
                     number of runs.

Return Value:

    None.

--*/

{
    VCN MyStartingVcn, MyEndingVcn;
    VCN BlockStartingVcn = 0;
    PVOID FirstRangePtr;
    ULONG FirstRunIndex;
    PVOID LastRangePtr;
    ULONG LastRunIndex;
    BOOLEAN BreakingUp = FALSE;
    PVCB Vcb = Scb->Vcb;

    LCN TempLcn;
    LONGLONG TempCount;
    ULONG CompressionUnitInClusters = 1;

    PAGED_CODE();

    if (Scb->CompressionUnit != 0) {
        CompressionUnitInClusters = ClustersFromBytes( Vcb, Scb->CompressionUnit );
    }

    //
    //  If the file is compressed, make sure we round the allocation
    //  size to a compression unit boundary, so we correctly interpret
    //  the compression state of the data at the point we are
    //  truncating to.  I.e., the danger is that we throw away one
    //  or more clusters at the end of compressed data!  Note that this
    //  adjustment could cause us to noop the call.
    //

    if (Scb->CompressionUnit != 0) {

        //
        //  Now check if we are truncating at the end of the file.
        //

        if (EndingVcn == MAXLONGLONG) {

            StartingVcn = StartingVcn + (CompressionUnitInClusters - 1);
            ((ULONG)StartingVcn) &= ~(CompressionUnitInClusters - 1);
        }
    }

    //
    //  Make sure we have a snapshot and update it with the range of this deallocation.
    //

    ASSERT( NtfsIsExclusiveScb( Scb ));

    if (Scb->ScbSnapshot == NULL) {

        NtfsSnapshotScb( IrpContext, Scb );
    }

    //
    //  Make sure update the VCN range in the snapshot.  We need to
    //  do it each pass through the loop
    //

    if (Scb->ScbSnapshot != NULL) {

        if (StartingVcn < Scb->ScbSnapshot->LowestModifiedVcn) {

            Scb->ScbSnapshot->LowestModifiedVcn = StartingVcn;
        }

        if (EndingVcn > Scb->ScbSnapshot->HighestModifiedVcn) {

            Scb->ScbSnapshot->HighestModifiedVcn = EndingVcn;
        }
    }

    ASSERT( (Scb->ScbSnapshot != NULL) ||
            !NtfsIsTypeCodeUserData( Scb->AttributeTypeCode ));

    //
    //  We may not be able to preload the entire allocation for an
    //  extremely large fragmented file.  The number of Mcb's may exhaust
    //  available pool.  We will break the range to deallocate into smaller
    //  ranges when preloading the allocation.
    //

    do {

        //
        //  If this is a large file and breakup is allowed then see if we
        //  want to break up the range of the deallocation.
        //

        if ((Scb->Header.AllocationSize.HighPart != 0) && BreakupAllowed) {

            //
            //  If this is the first pass through then determine the starting point
            //  for this range.
            //

            if (BlockStartingVcn == 0) {

                MyEndingVcn = EndingVcn;

                if (EndingVcn == MAXLONGLONG) {

                    MyEndingVcn = LlClustersFromBytesTruncate( Vcb,
                                                               Scb->Header.AllocationSize.QuadPart ) - 1;
                }

                BlockStartingVcn = MyEndingVcn - Vcb->ClustersPer4Gig;

                //
                //  Remember we are breaking up now, and that as a result
                //  we have to log everything.
                //

                BreakingUp = TRUE;
                LogIt = TRUE;

            } else {

                //
                //  If we are truncating from the end of the file then raise CANT_WAIT.  This will
                //  cause us to release our resources periodically when deleting a large file.
                //

                if (BreakingUp && (EndingVcn == MAXLONGLONG)) {

                    NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );
                }

                BlockStartingVcn -= Vcb->ClustersPer4Gig;
            }

            if (BlockStartingVcn < StartingVcn) {

                BlockStartingVcn = StartingVcn;

            } else if (Scb->CompressionUnit != 0) {

                //
                //  Now check if we are truncating at the end of the file.
                //  Always truncate to a compression unit boundary.
                //

                if (EndingVcn == MAXLONGLONG) {

                    BlockStartingVcn += (CompressionUnitInClusters - 1);
                    ((ULONG)BlockStartingVcn) &= ~(CompressionUnitInClusters - 1);
                }
            }

        } else {

            BlockStartingVcn = StartingVcn;
        }

        //
        //  First make sure the Mcb is loaded.  Note it is possible that
        //  we could need the previous range loaded if the delete starts
        //  at the beginning of a file record boundary, thus the -1.
        //

        NtfsPreloadAllocation( IrpContext, Scb, ((BlockStartingVcn != 0) ? (BlockStartingVcn - 1) : 0), EndingVcn );

        //
        //  Loop to do one or more deallocate calls.
        //

        MyEndingVcn = EndingVcn;
        do {

            //
            //  Now lookup and get the indices for the first Vcn being deleted.
            //  If we are off the end, get out.  We do this in the loop, because
            //  conceivably deleting space could change the range pointer and
            //  index of the first entry.
            //

            if (!NtfsLookupNtfsMcbEntry( &Scb->Mcb,
                                         BlockStartingVcn,
                                         NULL,
                                         NULL,
                                         NULL,
                                         NULL,
                                         &FirstRangePtr,
                                         &FirstRunIndex )) {

                break;
            }

            //
            //  Now see if we can deallocate everything at once.
            //

            MyStartingVcn = BlockStartingVcn;
            LastRunIndex = MAXULONG;

            if (BreakupAllowed) {

                //
                //  Now lookup and get the indices for the last Vcn being deleted.
                //  If we are off the end, get the last index.
                //

                if (!NtfsLookupNtfsMcbEntry( &Scb->Mcb,
                                             MyEndingVcn,
                                             NULL,
                                             NULL,
                                             NULL,
                                             NULL,
                                             &LastRangePtr,
                                             &LastRunIndex )) {

                    NtfsNumberOfRunsInRange(&Scb->Mcb, LastRangePtr, &LastRunIndex);
                }

                //
                //  If the Vcns to delete span multiple ranges, or there
                //  are too many in the last range to delete, then we
                //  will calculate the index of a run to start with for
                //  this pass through the loop.
                //

                if ((FirstRangePtr != LastRangePtr) ||
                    ((LastRunIndex - FirstRunIndex) > MAXIMUM_RUNS_AT_ONCE)) {

                    //
                    //  Figure out where we can afford to truncate to.
                    //

                    if (LastRunIndex >= MAXIMUM_RUNS_AT_ONCE) {
                        LastRunIndex -= MAXIMUM_RUNS_AT_ONCE;
                    } else {
                        LastRunIndex = 0;
                    }

                    //
                    //  Now lookup the first Vcn in this run.
                    //

                    NtfsGetNextNtfsMcbEntry( &Scb->Mcb,
                                             &LastRangePtr,
                                             LastRunIndex,
                                             &MyStartingVcn,
                                             &TempLcn,
                                             &TempCount );

                    ASSERT(MyStartingVcn > BlockStartingVcn);

                    //
                    //  If compressed, round down to a compression unit boundary.
                    //

                    ((ULONG)MyStartingVcn) &= ~(CompressionUnitInClusters - 1);

                    //
                    //  Remember we are breaking up now, and that as a result
                    //  we have to log everything.
                    //

                    BreakingUp = TRUE;
                    LogIt = TRUE;
                }
            }

            //
            // CAIROBUG Consider optimizing this code when the cairo ifdef's
            // are removed.
            //

            //
            // If this is a user data stream and we are truncating to end the
            // return the quota to the owner.
            //

            if (FlagOn( Scb->ScbState, SCB_STATE_SUBJECT_TO_QUOTA ) &&
                (EndingVcn == MAXLONGLONG)) {

                //
                //  Calculate the amount that allocation size is being reduced.
                //

                TempCount = LlBytesFromClusters( Vcb, MyStartingVcn ) -
                            Scb->Header.AllocationSize.QuadPart;

                NtfsConditionallyUpdateQuota( IrpContext,
                                              Scb->Fcb,
                                              &TempCount,
                                              TRUE,
                                              FALSE );
            }

            //
            //  Now deallocate a range of clusters
            //

            NtfsDeleteAllocationInternal( IrpContext,
                                          Scb,
                                          MyStartingVcn,
                                          EndingVcn,
                                          LogIt );

            //
            //  Now, if we are breaking up this deallocation, then do some
            //  transaction cleanup.
            //

            if (BreakingUp) {

                //
                //  Free the Mft Scb if we currently own it provided we are not
                //  truncating a stream in the Mft.
                //

                if ((NtfsSegmentNumber( &Scb->Fcb->FileReference ) != MASTER_FILE_TABLE_NUMBER) &&
                    (EndingVcn == MAXLONGLONG) &&
                    (Vcb->MftScb != NULL) &&
                    (Vcb->MftScb->Fcb->ExclusiveFcbLinks.Flink != NULL) &&
                    ExIsResourceAcquiredExclusiveLite( Vcb->MftScb->Header.Resource )) {

                    SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_RELEASE_MFT );
                }

                NtfsCheckpointCurrentTransaction( IrpContext );

                //
                //  Move the ending Vcn backwards in the file.  This will
                //  let us move down to the next earlier file record if
                //  this case spans multiple file records.
                //

                MyEndingVcn = MyStartingVcn - 1;
            }

            //
            //  Call the Cache Manager to change allocation size for either
            //  truncate or SplitMcb case (where EndingVcn was set to xxMax!).
            //

            if ((EndingVcn == MAXLONGLONG) && ARGUMENT_PRESENT( FileObject )) {

                NtfsSetBothCacheSizes( FileObject,
                                       (PCC_FILE_SIZES)&Scb->Header.AllocationSize,
                                       Scb );
            }

        } while (MyStartingVcn != BlockStartingVcn);

    } while (BlockStartingVcn != StartingVcn);
}


VOID
NtfsReallocateRange (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PSCB Scb,
    IN VCN DeleteVcn,
    IN LONGLONG DeleteCount,
    IN VCN AllocateVcn,
    IN LONGLONG AllocateCount,
    IN PLCN TargetLcn OPTIONAL
    )

/*++

Routine Description:

    This routine is called to reallocate a individual range within the existing
    allocation of the file.  Typically this might be used to reallocate a
    compression unit or perform MoveFile.  We can modify the Mcb and then
    write a single log record to write the mapping information.  This routine
    doesn't make any attempt to split the Mcb.  Also our caller must know
    that the change of allocation occurs entirely within the existing virtual
    allocation of the file.

    We might expand this routine in the future to optimize the case where we
    are reallocating a compression unit only because we believe it is fragmented
    and there is a good chance to reduce fragmentation.  We could check to see
    if a single run is available and only reallocate if such a run exists.

Arguments:

    Scb - Scb for the attribute needing a change of allocation.

    DeleteVcn - Starting Vcn for the range to delete.

    DeleteClusters - Count of clusters to delete.  May be zero.

    AllocateVcn - Starting Vcn for the range to allocate.

    AllocateClusters - Count of clusters to allocate.  May be zero.

    TargetLcn - If specified reallocate to this particular LCN

Return Value:

    None

--*/

{
    VCN StartingVcn;
    VCN EndingVcn;

    ATTRIBUTE_ENUMERATION_CONTEXT Context;
    ULONG CleanupContext = FALSE;

    BOOLEAN ChangedAllocation = FALSE;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsReallocateRange:  Entered\n") );

    //
    //  Let's make sure we are within the full allocation of the stream.
    //

    ASSERT( (DeleteCount == 0) ||
            ((DeleteVcn <= LlClustersFromBytesTruncate( IrpContext->Vcb, Scb->Header.AllocationSize.QuadPart )) &&
             ((DeleteVcn + DeleteCount) <= LlClustersFromBytesTruncate( IrpContext->Vcb, Scb->Header.AllocationSize.QuadPart ))));


    ASSERT( (AllocateCount == 0) ||
            ((AllocateVcn <= LlClustersFromBytesTruncate( IrpContext->Vcb, Scb->Header.AllocationSize.QuadPart )) &&
             ((AllocateVcn + AllocateCount) <= LlClustersFromBytesTruncate( IrpContext->Vcb, Scb->Header.AllocationSize.QuadPart ))));

    //
    //  Either one or both or our input counts may be zero.  Make sure the zero-length
    //  ranges don't make us do extra work.
    //

    if (DeleteCount == 0) {

        if (AllocateCount == 0) {

            DebugTrace( -1, Dbg, ("NtfsReallocateRange:  Exit\n") );
            return;
        }

        DeleteVcn = AllocateVcn;

        //
        //  The range is set by the allocation clusters.
        //

        StartingVcn = AllocateVcn;
        EndingVcn = AllocateVcn + AllocateCount;

    } else if (AllocateCount == 0) {

        AllocateVcn = DeleteVcn;

        //
        //  The range is set by the deallocation clusters.
        //

        StartingVcn = DeleteVcn;
        EndingVcn = DeleteVcn + DeleteCount;

    } else {

        //
        //  Find the lowest starting point.
        //

        StartingVcn = DeleteVcn;

        if (DeleteVcn > AllocateVcn) {

            StartingVcn = AllocateVcn;
        }

        //
        //  Find the highest ending point.
        //

        EndingVcn = DeleteVcn + DeleteCount;

        if (AllocateVcn + AllocateCount > EndingVcn) {

            EndingVcn = AllocateVcn + AllocateCount;
        }
    }

    //
    //  Make sure we have a snapshot and update it with the range of this deallocation.
    //

    ASSERT( NtfsIsExclusiveScb( Scb ));

    if (Scb->ScbSnapshot == NULL) {

        NtfsSnapshotScb( IrpContext, Scb );
    }

    //
    //  Make sure update the VCN range in the snapshot.  We need to do this for both ranges.
    //

    if (Scb->ScbSnapshot != NULL) {

        if (StartingVcn < Scb->ScbSnapshot->LowestModifiedVcn) {

            Scb->ScbSnapshot->LowestModifiedVcn = StartingVcn;
        }

        if (EndingVcn > Scb->ScbSnapshot->HighestModifiedVcn) {

            Scb->ScbSnapshot->HighestModifiedVcn = EndingVcn;
        }
    }

    ASSERT( (Scb->ScbSnapshot != NULL) ||
            !NtfsIsTypeCodeUserData( Scb->AttributeTypeCode ));

    //
    //  First make sure the Mcb is loaded.  Note it is possible that
    //  we could need the previous range loaded if the delete starts
    //  at the beginning of a file record boundary, thus the -1.
    //

    NtfsPreloadAllocation( IrpContext,
                           Scb,
                           ((StartingVcn != 0) ? (StartingVcn - 1) : 0),
                           EndingVcn - 1 );

    //
    //  Use a try-finally in case we need to unload the Mcb.
    //

    try {

        //
        //  Do the deallocate first.
        //

        if (DeleteCount != 0) {

            ChangedAllocation = NtfsDeallocateClusters( IrpContext,
                                                        Scb->Vcb,
                                                        Scb,
                                                        DeleteVcn,
                                                        DeleteVcn + DeleteCount - 1,
                                                        &Scb->TotalAllocated );
        }

        //
        //  Now do the allocation.
        //

        if (AllocateCount != 0) {

            //
            //  The allocate path is simpler.  We don't worry about ranges.
            //  Remember if any bits are allocated though.
            //

            if (NtfsAllocateClusters( IrpContext,
                                      Scb->Vcb,
                                      Scb,
                                      AllocateVcn,
                                      TRUE,
                                      AllocateCount,
                                      TargetLcn,
                                      &AllocateCount )) {

                ChangedAllocation = TRUE;
            }
        }

        if (ChangedAllocation) {

            //
            //  Now rewrite the mapping for this range.
            //

            AllocateCount = EndingVcn - StartingVcn;

            NtfsInitializeAttributeContext( &Context );
            CleanupContext = TRUE;

            NtfsLookupAttributeForScb( IrpContext, Scb, NULL, &Context );

            NtfsAddAttributeAllocation( IrpContext,
                                        Scb,
                                        &Context,
                                        &StartingVcn,
                                        &AllocateCount );
        }

    } finally {

        if (AbnormalTermination()) {

            //
            //  Unload the Mcb if we don't have a transaction.  We need to do this
            //  in case we have already removed part of a range.
            //

            if (IrpContext->TransactionId == 0) {

                NtfsUnloadNtfsMcbRange( &Scb->Mcb,
                                        StartingVcn,
                                        MAXLONGLONG,
                                        FALSE,
                                        FALSE );
            }
        }

        //
        //  Cleanup the context if needed.
        //

        if (CleanupContext) {

            NtfsCleanupAttributeContext( IrpContext, &Context );
        }

        DebugTrace( -1, Dbg, ("NtfsReallocateRange:  Exit\n") );
    }

    return;
}


//
//  Internal support routine
//

VOID
NtfsDeleteAllocationInternal (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PSCB Scb,
    IN VCN StartingVcn,
    IN VCN EndingVcn,
    IN BOOLEAN LogIt
    )

/*++

Routine Description:

    This routine deletes allocation from an existing nonresident attribute.  If all
    or part of the allocation does not exist, the effect is benign, and only the
    remaining allocation is deleted.

Arguments:

    Scb - Scb for the attribute needing allocation

    StartingVcn - First Vcn to be deallocated.

    EndingVcn - Last Vcn to be deallocated, or xxMax to truncate at StartingVcn.
                If EndingVcn is *not* xxMax, a sparse deallocation is performed,
                and none of the stream sizes are changed.

    LogIt - Most callers should specify TRUE, to have the change logged.  However,
            we can specify FALSE if we are deleting the file record, and
            will be logging this delete.

Return Value:

    None.

--*/

{
    ATTRIBUTE_ENUMERATION_CONTEXT Context, TempContext;
    PATTRIBUTE_RECORD_HEADER Attribute;
    LONGLONG SizeInBytes, SizeInClusters;
    VCN Vcn1;
    PVCB Vcb = Scb->Vcb;
    BOOLEAN AddSpaceBack = FALSE;
    BOOLEAN SplitMcb = FALSE;
    BOOLEAN UpdatedAllocationSize = FALSE;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_SCB( Scb );
    ASSERT_EXCLUSIVE_SCB( Scb );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsDeleteAllocation\n") );

    //
    //  Calculate new allocation size, assuming truncate.
    //

    SizeInBytes = LlBytesFromClusters( Vcb, StartingVcn );

    ASSERT( (Scb->ScbSnapshot == NULL) ||
            (Scb->ScbSnapshot->LowestModifiedVcn <= StartingVcn) );

    //
    //  If this is a sparse deallocation, then we will have to call
    //  NtfsAddAttributeAllocation at the end to complete the fixup.
    //

    if (EndingVcn != MAXLONGLONG) {

        AddSpaceBack = TRUE;

        //
        //  If we have not written anything beyond the last Vcn to be
        //  deleted, then we can actually call FsRtlSplitLargeMcb to
        //  slide the allocated space up and keep the file contiguous!
        //
        //  Ignore this if this is the Mft and we are creating a hole or
        //  if we are in the process of changing the compression state.
        //
        //  If we were called from either SetEOF or SetAllocation for a
        //  compressed file then we can be doing a flush for the last
        //  page of the file as a result of a call to CcSetFileSizes.
        //  In this case we don't want to split the Mcb because we could
        //  reenter CcSetFileSizes and throw away the last page.
        //

        if (FlagOn( Scb->ScbState, SCB_STATE_WRITE_COMPRESSED ) &&
            (EndingVcn >= LlClustersFromBytesTruncate( Vcb,
                                                       ((Scb->ValidDataToDisk + Scb->CompressionUnit - 1) &
                                                        ~((LONGLONG) (Scb->CompressionUnit - 1))))) &&
            (Scb != Vcb->MftScb) &&
            !FlagOn( Scb->ScbState, SCB_STATE_REALLOCATE_ON_WRITE ) &&
            ((IrpContext == IrpContext->TopLevelIrpContext) ||
             (IrpContext->TopLevelIrpContext->MajorFunction != IRP_MJ_SET_INFORMATION))) {

            ASSERT( Scb->CompressionUnit != 0 );

            //
            //  If we are going to split the Mcb, then make sure it is fully loaded.
            //  Do not bother to split if there are multiple ranges involved, so we
            //  do not end up rewriting lots of file records.
            //

            if (NtfsPreloadAllocation(IrpContext, Scb, StartingVcn, MAXLONGLONG) <= 1) {

                SizeInClusters = (EndingVcn - StartingVcn) + 1;

                ASSERT( NtfsIsTypeCodeUserData( Scb->AttributeTypeCode ));

                SplitMcb = NtfsSplitNtfsMcb( &Scb->Mcb, StartingVcn, SizeInClusters );

                //
                //  If the delete is off the end, we can get out.
                //

                if (!SplitMcb) {
                    return;
                }

                //
                //  We must protect the call below with a try-finally in
                //  order to unload the Split Mcb.  If there is no transaction
                //  underway then a release of the Scb would cause the
                //  snapshot to go away.
                //

                try {

                    //
                    //  We are not properly synchronized to change AllocationSize,
                    //  so we will delete any clusters that may have slid off the
                    //  end.  Since we are going to smash EndingVcn soon anyway,
                    //  use it as a scratch to hold AllocationSize in Vcns...
                    //

                    EndingVcn = LlClustersFromBytes(Vcb, Scb->Header.AllocationSize.QuadPart);

                    NtfsDeallocateClusters( IrpContext,
                                            Vcb,
                                            Scb,
                                            EndingVcn,
                                            MAXLONGLONG,
                                            &Scb->TotalAllocated );

                } finally {

                    if (AbnormalTermination()) {

                        NtfsUnloadNtfsMcbRange( &Scb->Mcb,
                                                StartingVcn,
                                                MAXLONGLONG,
                                                FALSE,
                                                FALSE );
                    }
                }

                NtfsUnloadNtfsMcbRange( &Scb->Mcb,
                                        EndingVcn,
                                        MAXLONGLONG,
                                        TRUE,
                                        FALSE );

                //
                //  Since we did a split, jam highest modified all the way up.
                //

                Scb->ScbSnapshot->HighestModifiedVcn = MAXLONGLONG;

                //
                //  We will have to redo all of the allocation to the end now.
                //

                EndingVcn = MAXLONGLONG;
            }
        }
    }

    //
    //  Now make the call to delete the allocation (if we did not just split
    //  the Mcb), and get out if we didn't have to do anything, because a
    //  hole is being created where there is already a hole.
    //

    if (!SplitMcb &&
        !NtfsDeallocateClusters( IrpContext,
                                 Vcb,
                                 Scb,
                                 StartingVcn,
                                 EndingVcn,
                                 &Scb->TotalAllocated ) &&
         EndingVcn != MAXLONGLONG) {

        return;
    }

    //
    //  On successful truncates, we nuke the entire range here.
    //

    if (!SplitMcb && (EndingVcn == MAXLONGLONG)) {

        NtfsUnloadNtfsMcbRange( &Scb->Mcb, StartingVcn, MAXLONGLONG, TRUE, FALSE );
    }

    //
    //  Prepare for looking up attribute records to get the retrieval
    //  information.
    //

    NtfsInitializeAttributeContext( &Context );
    NtfsInitializeAttributeContext( &TempContext );

    try {

        //
        //  Lookup the attribute record so we can ultimately delete space to it.
        //

        NtfsLookupAttributeForScb( IrpContext, Scb, &StartingVcn, &Context );

        //
        //  Now loop to delete the space to the file record.  Do not do this if LogIt
        //  is FALSE, as this is someone trying to delete the entire file
        //  record, so we do not have to clean up the attribute record.
        //

        if (LogIt) {

            do {

                Attribute = NtfsFoundAttribute(&Context);

                //
                //  If there is no overlap, then continue.
                //

                if ((Attribute->Form.Nonresident.HighestVcn < StartingVcn) ||
                    (Attribute->Form.Nonresident.LowestVcn > EndingVcn)) {

                    continue;

                //
                //  If all of the allocation is going away, then delete the entire
                //  record.  We have to show that the allocation is already deleted
                //  to avoid being called back via NtfsDeleteAttributeRecord!  We
                //  avoid this for the first instance of this attribute.
                //

                } else if ((Attribute->Form.Nonresident.LowestVcn >= StartingVcn) &&
                           (EndingVcn == MAXLONGLONG) &&
                           (Attribute->Form.Nonresident.LowestVcn != 0)) {

                    NtfsDeleteAttributeRecord( IrpContext,
                                               Scb->Fcb,
                                               (LogIt ? DELETE_LOG_OPERATION : 0) |
                                                DELETE_RELEASE_FILE_RECORD,
                                               &Context );

                //
                //  If just part of the allocation is going away, then make the
                //  call here to reconstruct the mapping pairs array.
                //

                } else {

                    //
                    //  If this is the end of a sparse deallocation, then break out
                    //  because we will rewrite this file record below anyway.
                    //

                    if (EndingVcn <= Attribute->Form.Nonresident.HighestVcn) {
                        break;

                    //
                    //  If we split the Mcb, then make sure we only regenerate the
                    //  mapping pairs once at the split point (but continue to
                    //  scan for any entire records to delete).
                    //

                    } else if (SplitMcb) {
                        continue;
                    }

                    //
                    //  If this is a sparse deallocation, then we have to call to
                    //  add the allocation, since it is possible that the file record
                    //  must split.
                    //

                    if (EndingVcn != MAXLONGLONG) {

                        //
                        //  Compute the last Vcn in the file,  Then remember if it is smaller,
                        //  because that is the last one we will delete to, in that case.
                        //

                        Vcn1 = Attribute->Form.Nonresident.HighestVcn;

                        SizeInClusters = (Vcn1 - Attribute->Form.Nonresident.LowestVcn) + 1;
                        Vcn1 = Attribute->Form.Nonresident.LowestVcn;

                        NtfsCleanupAttributeContext( IrpContext, &TempContext );
                        NtfsInitializeAttributeContext( &TempContext );

                        NtfsLookupAttributeForScb( IrpContext, Scb, NULL, &TempContext );

                        NtfsAddAttributeAllocation( IrpContext,
                                                    Scb,
                                                    &TempContext,
                                                    &Vcn1,
                                                    &SizeInClusters );

                        //
                        //  Since we used a temporary context we will need to
                        //  restart the scan from the first file record.  We update
                        //  the range to deallocate by the last operation.  In most
                        //  cases we will only need to modify one file record and
                        //  we can exit this loop.
                        //

                        StartingVcn = Vcn1 + SizeInClusters;

                        if (StartingVcn > EndingVcn) {

                            break;
                        }

                        NtfsCleanupAttributeContext( IrpContext, &Context );
                        NtfsInitializeAttributeContext( &Context );

                        NtfsLookupAttributeForScb( IrpContext, Scb, NULL, &Context );
                        continue;

                    //
                    //  Otherwise, we can simply delete the allocation, because
                    //  we know the file record cannot grow.
                    //

                    } else {

                        Vcn1 = StartingVcn - 1;

                        NtfsDeleteAttributeAllocation( IrpContext,
                                                       Scb,
                                                       LogIt,
                                                       &Vcn1,
                                                       &Context,
                                                       TRUE );

                        //
                        //  The call above will update the allocation size and
                        //  set the new file sizes on disk.
                        //

                        UpdatedAllocationSize = TRUE;
                    }
                }

            } while (NtfsLookupNextAttributeForScb(IrpContext, Scb, &Context));

            //
            //  If this deletion makes the file sparse, then we have to call
            //  NtfsAddAttributeAllocation to regenerate the mapping pairs.
            //  Note that potentially they may no longer fit, and we could actually
            //  have to add a file record.
            //

            if (AddSpaceBack) {

                //
                //  If we did not just split the Mcb, we have to calculate the
                //  SizeInClusters parameter for NtfsAddAttributeAllocation.
                //

                if (!SplitMcb) {

                    //
                    //  Compute the last Vcn in the file,  Then remember if it is smaller,
                    //  because that is the last one we will delete to, in that case.
                    //

                    Vcn1 = Attribute->Form.Nonresident.HighestVcn;

                    //
                    //  Get out if there is nothing to delete.
                    //

                    if (Vcn1 < StartingVcn) {
                        try_return(NOTHING);
                    }

                    SizeInClusters = (Vcn1 - Attribute->Form.Nonresident.LowestVcn) + 1;
                    Vcn1 = Attribute->Form.Nonresident.LowestVcn;

                    NtfsCleanupAttributeContext( IrpContext, &Context );
                    NtfsInitializeAttributeContext( &Context );

                    NtfsLookupAttributeForScb( IrpContext, Scb, NULL, &Context );

                    NtfsAddAttributeAllocation( IrpContext,
                                                Scb,
                                                &Context,
                                                &Vcn1,
                                                &SizeInClusters );

                } else {

                    NtfsCleanupAttributeContext( IrpContext, &Context );
                    NtfsInitializeAttributeContext( &Context );

                    NtfsLookupAttributeForScb( IrpContext, Scb, NULL, &Context );

                    NtfsAddAttributeAllocation( IrpContext,
                                                Scb,
                                                &Context,
                                                NULL,
                                                NULL );
                }

            //
            //  If we truncated the file by removing a file record but didn't update
            //  the new allocation size then do so now.  We don't have to worry about
            //  this for the sparse deallocation path.
            //

            } else if (!UpdatedAllocationSize) {

                Scb->Header.AllocationSize.QuadPart = SizeInBytes;

                if (Scb->Header.ValidDataLength.QuadPart > SizeInBytes) {
                    Scb->Header.ValidDataLength.QuadPart = SizeInBytes;
                }

                if (Scb->Header.FileSize.QuadPart > SizeInBytes) {
                    Scb->Header.FileSize.QuadPart = SizeInBytes;
                }

                //
                //  Possibly update ValidDataToDisk
                //

                if (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK ) &&
                    (SizeInBytes < Scb->ValidDataToDisk)) {
                    
                    Scb->ValidDataToDisk = SizeInBytes;
                }
            }
        }

        //
        //  If this was a sparse deallocation, it is time to get out once we
        //  have fixed up the allocation information.
        //

        if (SplitMcb || (EndingVcn != MAXLONGLONG)) {
            try_return(NOTHING);
        }

        //
        //  We update the allocation size in the attribute, only for normal
        //  truncates (AddAttributeAllocation does this for SplitMcb case).
        //

        if (LogIt) {

#ifdef BENL_DBG
            BOOLEAN WroteIt;

            WroteIt =
#endif

            NtfsWriteFileSizes( IrpContext,
                                Scb,
                                &Scb->Header.ValidDataLength.QuadPart,
                                FALSE,
                                TRUE,
                                TRUE );
#ifdef BENL_DBG
            ASSERT( WroteIt );
#endif
        }

        //
        //  Free any reserved clusters in the space freed.
        //

        if ((EndingVcn == MAXLONGLONG) && (Scb->CompressionUnit != 0)) {

            NtfsFreeReservedClusters( Scb,
                                      LlBytesFromClusters(Vcb, StartingVcn),
                                      0 );
        }

    try_exit: NOTHING;
    } finally {

        DebugUnwind( NtfsDeleteAllocationInternal );

        //
        //  Cleanup the attribute context on the way out.
        //

        NtfsCleanupAttributeContext( IrpContext, &Context );
        NtfsCleanupAttributeContext( IrpContext, &TempContext );
    }

    DebugTrace( -1, Dbg, ("NtfsDeleteAllocationInternal -> VOID\n") );

    return;
}


ULONG
NtfsGetSizeForMappingPairs (
    IN PNTFS_MCB Mcb,
    IN ULONG BytesAvailable,
    IN VCN LowestVcn,
    IN PVCN StopOnVcn OPTIONAL,
    OUT PVCN StoppedOnVcn
    )

/*++

Routine Description:

    This routine calculates the size required to describe the given Mcb in
    a mapping pairs array.  The caller may specify how many bytes are available
    for mapping pairs storage, for the event that the entire Mcb cannot be
    be represented.  In any case, StoppedOnVcn returns the Vcn to supply to
    NtfsBuildMappingPairs in order to generate the specified number of bytes.
    In the event that the entire Mcb could not be described in the bytes available,
    StoppedOnVcn is also the correct value to specify to resume the building
    of mapping pairs in a subsequent record.

Arguments:

    Mcb - The Mcb describing new allocation.

    BytesAvailable - Bytes available for storing mapping pairs.  This routine
                     is guaranteed to stop before returning a count greater
                     than this.

    LowestVcn - Lowest Vcn field applying to the mapping pairs array

    StopOnVcn - If specified, calculating size at the first run starting with a Vcn
                beyond the specified Vcn

    StoppedOnVcn - Returns the Vcn on which a stop was necessary, or xxMax if
                   the entire Mcb could be stored.  This Vcn should be
                   subsequently supplied to NtfsBuildMappingPairs to generate
                   the calculated number of bytes.

Return Value:

    Size required required for entire new array in bytes.

--*/

{
    VCN NextVcn, CurrentVcn, LimitVcn;
    LCN CurrentLcn;
    VCN RunVcn;
    LCN RunLcn;
    BOOLEAN Found;
    LONGLONG RunCount;
    VCN HighestVcn;
    PVOID RangePtr;
    ULONG RunIndex;
    ULONG MSize = 0;
    ULONG LastSize = 0;
    BOOLEAN FoundRun = FALSE;

    PAGED_CODE();

    HighestVcn = MAXLONGLONG;

    //
    //  Initialize CurrentLcn as it will be initialized for decode.
    //

    CurrentLcn = 0;
    NextVcn = RunVcn = LowestVcn;

    //
    //  Limit ourselves to less than 32 bits for each mapping pair range.
    //  We use -2 here because we point to the Vcn to stop on, the length
    //  is one greater.
    //

    LimitVcn = MAXLONGLONG - 1;

    //
    //  Use the input stop point if smaller.
    //

    if (ARGUMENT_PRESENT( StopOnVcn )) {

        LimitVcn = *StopOnVcn;
    }

    Found = NtfsLookupNtfsMcbEntry( Mcb, RunVcn, &RunLcn, &RunCount, NULL, NULL, &RangePtr, &RunIndex );

    //
    //  Loop through the Mcb to calculate the size of the mapping array.
    //

    while (TRUE) {

        LONGLONG Change;
        PCHAR cp;

        //
        //  See if there is another entry in the Mcb.
        //

        if (!Found) {

            //
            //  If the caller did not specify StopOnVcn, then break out.
            //

            if (!ARGUMENT_PRESENT(StopOnVcn)) {
                break;
            }

            //
            //  Otherwise, describe the "hole" up to and including the
            //  Vcn we are stopping on.
            //

            RunVcn = NextVcn;
            RunLcn = UNUSED_LCN;

            RunCount = (LimitVcn - RunVcn) + 1;
            RunIndex = MAXULONG - 1;

        //
        //  If this is the first non-hole then we need to enforce a cluster
        //  per range limit.
        //

        } else if (!FoundRun &&
                   (RunLcn != UNUSED_LCN)) {

            if ((LowestVcn + MAX_CLUSTERS_PER_RANGE) <= LimitVcn) {

                //
                //  If we are already beyond the limit then set
                //  the limit back to just before the current run.
                //  We allow a hole which is larger than our limit.
                //

                if (RunVcn >= MAX_CLUSTERS_PER_RANGE) {

                    LimitVcn = RunVcn - 1;

                } else {

                    LimitVcn = LowestVcn + MAX_CLUSTERS_PER_RANGE - 1;
                }
            }

            //
            //  Other checks in the system should prevent rollover.
            //

            ASSERT( (LimitVcn + 1) >= LowestVcn );
            FoundRun = TRUE;
        }

        //
        //  If we were asked to stop after a certain Vcn, or we have
        //  exceeded our limit then stop now.
        //

        if (RunVcn > LimitVcn) {

            if (HighestVcn == MAXLONGLONG) {
                HighestVcn = LimitVcn + 1;
            }
            break;

        //
        //  If this run extends beyond the current end of this attribute
        //  record, then we still need to stop where we are supposed to
        //  after outputting this run.
        //

        } else if ((RunVcn + RunCount) > LimitVcn) {
            HighestVcn = LimitVcn + 1;
        }

        //
        //  Advance the RunIndex for the next call.
        //

        RunIndex += 1;

        //
        //  Add in one for the count byte.
        //

        MSize += 1;

        //
        //  NextVcn becomes current Vcn and we calculate the new NextVcn.
        //

        CurrentVcn = RunVcn;
        NextVcn = RunVcn + RunCount;

        //
        //  Calculate the Vcn change to store.
        //

        Change = NextVcn - CurrentVcn;

        //
        //  Now calculate the first byte to actually output
        //

        if (Change < 0) {

            GetNegativeByte( (PLARGE_INTEGER)&Change, &cp );

        } else {

            GetPositiveByte( (PLARGE_INTEGER)&Change, &cp );
        }

        //
        //  Now add in the number of Vcn change bytes.
        //

        MSize += (ULONG)(cp - (PCHAR)&Change + 1);

        //
        //  Do not output any Lcn bytes if it is the unused Lcn.
        //

        if (RunLcn != UNUSED_LCN) {

            //
            //  Calculate the Lcn change to store.
            //

            Change = RunLcn - CurrentLcn;

            //
            //  Now calculate the first byte to actually output
            //

            if (Change < 0) {

                GetNegativeByte( (PLARGE_INTEGER)&Change, &cp );

            } else {

                GetPositiveByte( (PLARGE_INTEGER)&Change, &cp );
            }

            //
            //  Now add in the number of Lcn change bytes.
            //

            MSize += (ULONG)(cp - (PCHAR)&Change + 1);

            CurrentLcn = RunLcn;

            //
            //  If this is the first run then enforce the 32 bit limit.
            //

            if (!FoundRun) {

                if ((LowestVcn + MAX_CLUSTERS_PER_RANGE - 1) < LimitVcn) {

                    LimitVcn = LowestVcn + MAX_CLUSTERS_PER_RANGE - 1;
                }
                FoundRun = TRUE;
            }
        }

        //
        //  Now see if we can still store the required number of bytes,
        //  and get out if not.
        //

        if ((MSize + 1) > BytesAvailable) {

            HighestVcn = RunVcn;
            MSize = LastSize;
            break;
        }

        //
        //  Now advance some locals before looping back.
        //

        LastSize = MSize;

        Found = NtfsGetSequentialMcbEntry( Mcb, &RangePtr, RunIndex, &RunVcn, &RunLcn, &RunCount );
    }

    //
    //  The caller had sufficient bytes available to store at least one
    //  run, or that we were able to process the entire (empty) Mcb.
    //

    ASSERT( (MSize != 0) || (HighestVcn == LimitVcn + 1) );

    //
    //  Return the Vcn we stopped on (or xxMax) and the size caculated,
    //  adding one for the terminating 0.
    //

    *StoppedOnVcn = HighestVcn;

    return MSize + 1;
}


BOOLEAN
NtfsBuildMappingPairs (
    IN PNTFS_MCB Mcb,
    IN VCN LowestVcn,
    IN OUT PVCN HighestVcn,
    OUT PCHAR MappingPairs
    )

/*++

Routine Description:

    This routine builds a new mapping pairs array or adds to an old one.

    At this time, this routine only supports adding to the end of the
    Mapping Pairs Array.

Arguments:

    Mcb - The Mcb describing new allocation.

    LowestVcn - Lowest Vcn field applying to the mapping pairs array

    HighestVcn - On input supplies the highest Vcn, after which we are to stop.
                 On output, returns the actual Highest Vcn represented in the
                 MappingPairs array, or LlNeg1 if the array is empty.

    MappingPairs - Points to the current mapping pairs array to be extended.
                   To build a new array, the byte pointed to must contain 0.

Return Value:

    BOOLEAN - TRUE if this mapping pair only describes a hole, FALSE otherwise.

--*/

{
    VCN NextVcn, CurrentVcn;
    LCN CurrentLcn;
    VCN RunVcn;
    LCN RunLcn;
    BOOLEAN Found;
    LONGLONG RunCount;
    PVOID RangePtr;
    ULONG RunIndex;
    BOOLEAN SingleHole = TRUE;

    PAGED_CODE();

    //
    //  Initialize NextVcn and CurrentLcn as they will be initialized for decode.
    //

    CurrentLcn = 0;
    NextVcn = RunVcn = LowestVcn;

    Found = NtfsLookupNtfsMcbEntry( Mcb, RunVcn, &RunLcn, &RunCount, NULL, NULL, &RangePtr, &RunIndex );

    //
    //  Loop through the Mcb to calculate the size of the mapping array.
    //

    while (TRUE) {

        LONGLONG ChangeV, ChangeL;
        PCHAR cp;
        ULONG SizeV;
        ULONG SizeL;

        //
        //  See if there is another entry in the Mcb.
        //

        if (!Found) {

            //
            //  Break out in the normal case
            //

            if (*HighestVcn == MAXLONGLONG) {
                break;
            }

            //
            //  Otherwise, describe the "hole" up to and including the
            //  Vcn we are stopping on.
            //

            RunVcn = NextVcn;
            RunLcn = UNUSED_LCN;
            RunCount = *HighestVcn - NextVcn;
            RunIndex = MAXULONG - 1;
        }

        //
        //  Advance the RunIndex for the next call.
        //

        RunIndex += 1;

        //
        //  Exit loop if we hit the HighestVcn we are looking for.
        //

        if (RunVcn >= *HighestVcn) {
            break;
        }

        //
        //  This run may go beyond the highest we are looking for, if so
        //  we need to shrink the count.
        //

        if ((RunVcn + RunCount) > *HighestVcn) {
            RunCount = *HighestVcn - RunVcn;
        }

        //
        //  NextVcn becomes current Vcn and we calculate the new NextVcn.
        //

        CurrentVcn = RunVcn;
        NextVcn = RunVcn + RunCount;

        //
        //  Calculate the Vcn change to store.
        //

        ChangeV = NextVcn - CurrentVcn;

        //
        //  Now calculate the first byte to actually output
        //

        if (ChangeV < 0) {

            GetNegativeByte( (PLARGE_INTEGER)&ChangeV, &cp );

        } else {

            GetPositiveByte( (PLARGE_INTEGER)&ChangeV, &cp );
        }

        //
        //  Now add in the number of Vcn change bytes.
        //

        SizeV = (ULONG)(cp - (PCHAR)&ChangeV + 1);

        //
        //  Do not output any Lcn bytes if it is the unused Lcn.
        //

        SizeL = 0;
        if (RunLcn != UNUSED_LCN) {

            //
            //  Calculate the Lcn change to store.
            //

            ChangeL = RunLcn - CurrentLcn;

            //
            //  Now calculate the first byte to actually output
            //

            if (ChangeL < 0) {

                GetNegativeByte( (PLARGE_INTEGER)&ChangeL, &cp );

            } else {

                GetPositiveByte( (PLARGE_INTEGER)&ChangeL, &cp );
            }

            //
            //  Now add in the number of Lcn change bytes.
            //

            SizeL = (ULONG)(cp - (PCHAR)&ChangeL) + 1;

            //
            //  Now advance CurrentLcn before looping back.
            //

            CurrentLcn = RunLcn;
            SingleHole = FALSE;
        }

        //
        //  Now we can produce our outputs to the MappingPairs array.
        //

        *MappingPairs++ = (CHAR)(SizeV + (SizeL * 16));

        while (SizeV != 0) {
            *MappingPairs++ = (CHAR)(((ULONG)ChangeV) & 0xFF);
            ChangeV = ChangeV >> 8;
            SizeV -= 1;
        }

        while (SizeL != 0) {
            *MappingPairs++ = (CHAR)(((ULONG)ChangeL) & 0xFF);
            ChangeL = ChangeL >> 8;
            SizeL -= 1;
        }

        Found = NtfsGetSequentialMcbEntry( Mcb, &RangePtr, RunIndex, &RunVcn, &RunLcn, &RunCount );
    }

    //
    //  Terminate the size with a 0 byte.
    //

    *MappingPairs = 0;

    //
    //  Also return the actual highest Vcn.
    //

    *HighestVcn = NextVcn - 1;

    return SingleHole;
}

VCN
NtfsGetHighestVcn (
    IN PIRP_CONTEXT IrpContext,
    IN VCN LowestVcn,
    IN PCHAR MappingPairs
    )

/*++

Routine Description:

    This routine returns the highest Vcn from a mapping pairs array.  This
    routine is intended for restart, in order to update the HighestVcn field
    and possibly AllocatedLength in an attribute record after updating the
    MappingPairs array.

Arguments:

    LowestVcn - Lowest Vcn field applying to the mapping pairs array

    MappingPairs - Points to the mapping pairs array from which the highest
                   Vcn is to be extracted.

Return Value:

    The Highest Vcn represented by the MappingPairs array.

--*/

{
    VCN CurrentVcn, NextVcn;
    ULONG VcnBytes, LcnBytes;
    LONGLONG Change;
    PCHAR ch = MappingPairs;

    PAGED_CODE();

    //
    //  Implement the decompression algorithm, as defined in ntfs.h.
    //

    NextVcn = LowestVcn;
    ch = MappingPairs;

    //
    //  Loop to process mapping pairs.
    //

    while (!IsCharZero(*ch)) {

        //
        // Set Current Vcn from initial value or last pass through loop.
        //

        CurrentVcn = NextVcn;

        //
        //  Extract the counts from the two nibbles of this byte.
        //

        VcnBytes = *ch & 0xF;
        LcnBytes = *ch++ >> 4;

        //
        //  Extract the Vcn change (use of RtlCopyMemory works for little-Endian)
        //  and update NextVcn.
        //

        Change = 0;

        if (IsCharLtrZero(*(ch + VcnBytes - 1))) {

            NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, NULL );
        }
        RtlCopyMemory( &Change, ch, VcnBytes );
        NextVcn = NextVcn + Change;

        //
        //  Just skip over Lcn.
        //

        ch += VcnBytes + LcnBytes;
    }

    Change = NextVcn - 1;
    return *(PVCN)&Change;
}


BOOLEAN
NtfsReserveClusters (
    IN PIRP_CONTEXT IrpContext OPTIONAL,
    IN PSCB Scb,
    IN LONGLONG FileOffset,
    IN ULONG ByteCount
    )

/*++

Routine Description:

    This routine reserves all clusters that would be required to write
    the full range of compression units covered by the described range
    of Vcns.  All clusters in the range are reserved, without regard to
    how many clusters are already reserved in that range.  Not paying
    attention to how many clusters are already allocated in that range
    is not only a simplification, but it is also necessary, since we
    sometimes deallocate all existing clusters anyway, and make them
    ineligible for reallocation in the same transaction.  Thus in the
    worst case you do always need an additional 16 clusters when a
    compression unit is first modified. Note that although we could
    specifically reserve (double-reserve, in fact) the entire allocation
    size of the stream, when reserving from the volume, we never reserve
    more than AllocationSize + MM_MAXIMUM_DISK_IO_SIZE - size actually
    allocated, since the worst we could ever need to doubly allocate is
    limited by the maximum flush size.

    For user-mapped streams, we have no way of keeping track of dirty
    pages, so we effectivel always reserve AllocationSize +
    MM_MAXIMUM_DISK_IO_SIZE.

    This routine is called from FastIo, and therefore has no IrpContext.

Arguments:

    IrpContext - If IrpContext is not specified, then not all data is
                 available to determine if the clusters can be reserved,
                 and FALSE may be returned unnecessarily.  This case
                 is intended for the fast I/O path, which will just
                 force us to take the long path to write.

    Scb - Address of a compressed stream for which we are reserving space

    FileOffset - Starting byte being modified by caller

    ByteCount - Number of bytes being modified by caller

Return Value:

    FALSE if not all clusters could be reserved
    TRUE if all clusters were reserved

--*/

{
    ULONG FirstBit, LastBit, CurrentLastBit;
    ULONG FirstRange, LastRange;
    PRESERVED_BITMAP_RANGE FreeBitmap, NextBitmap, CurrentBitmap;
    ULONG CompressionShift;
    PVCB Vcb = Scb->Vcb;
    ULONG SizeTemp;
    LONGLONG TempL;
    PVOID NewBitmapBuffer;
    BOOLEAN ReturnValue = FALSE;
    ULONG MappedFile;
    BOOLEAN FlippedBit = FALSE;

    ASSERT( Scb->Header.NodeTypeCode == NTFS_NTC_SCB_DATA );

    //
    //  Nothing to do if byte count is zero.
    //

    if (ByteCount == 0) { return TRUE; }

    //
    //  Calculate first and last bits to reserve.
    //

    CompressionShift = Vcb->ClusterShift + (ULONG)Scb->CompressionUnitShift;

    FirstBit = ((ULONG) Int64ShraMod32( FileOffset, (CompressionShift) )) & NTFS_BITMAP_RANGE_MASK;
    FirstRange = (ULONG) Int64ShraMod32( FileOffset, CompressionShift + NTFS_BITMAP_RANGE_SHIFT );

    LastBit = ((ULONG) Int64ShraMod32( FileOffset + ByteCount - 1, CompressionShift )) & NTFS_BITMAP_RANGE_MASK;
    LastRange = (ULONG) Int64ShraMod32( FileOffset + ByteCount - 1,
                                        CompressionShift + NTFS_BITMAP_RANGE_SHIFT );
    MappedFile = FlagOn( Scb->Header.Flags, FSRTL_FLAG_USER_MAPPED_FILE );

    //
    //  Make sure we started with numbers in range.
    //

    ASSERT( (((LONGLONG) FirstRange << (CompressionShift + NTFS_BITMAP_RANGE_SHIFT)) +
             ((LONGLONG)(FirstBit + 1) << CompressionShift)) > FileOffset );

    ASSERT( (FirstRange < LastRange) || (LastBit >= FirstBit) );
    ASSERT( FileOffset + ByteCount <= Scb->Header.AllocationSize.QuadPart );

    //
    //  Purge the cache since getting the bitmap may be blocked behind the mft
    //  which needs to wait for the cache to purge
    //

    if (IrpContext) {
        NtfsPurgeFileRecordCache( IrpContext );
    }

    NtfsAcquireResourceExclusive( IrpContext, Vcb->BitmapScb, TRUE );
    NtfsAcquireReservedClusters( Vcb );

    //
    //  Loop through all of the bitmap ranges for this request.
    //

    while (TRUE) {

        CurrentBitmap = NULL;

        //
        //  If we are at the last range then set the current last bit to
        //  our final last bit.
        //

        CurrentLastBit = LastBit;
        if (FirstRange != LastRange) {

            CurrentLastBit = NTFS_BITMAP_RANGE_MASK;
        }

        //
        //  If there is no bitmap then create the first entry in the list.
        //

        if (Scb->ScbType.Data.ReservedBitMap == NULL) {

            //
            //  If we are at range zero and the bitcount is not
            //  too high then use the basic model.
            //

            if ((LastRange == 0) && (CurrentLastBit < NTFS_BITMAP_MAX_BASIC_SIZE)) {

                SizeTemp = NtfsBasicBitmapSize( CurrentLastBit + 1 );

                //
                //  Allocate a buffer for the basic bitmap.
                //

                CurrentBitmap = NtfsAllocatePoolNoRaise( PagedPool, SizeTemp );

                //
                //  Initialize the data if there is no error.
                //

                if (CurrentBitmap == NULL) { goto AllocationFailure; }

                //
                //  Initialize the new structure.
                //

                RtlZeroMemory( CurrentBitmap, SizeTemp );
                RtlInitializeBitMap( &CurrentBitmap->Bitmap,
                                     &CurrentBitmap->RangeOffset,
                                     (SizeTemp - FIELD_OFFSET( RESERVED_BITMAP_RANGE, RangeOffset )) * 8);

            //
            //  Allocate a link entry and create the bitmap.  We will defer
            //  allocating the buffer for the bitmap until later.
            //

            } else {

                CurrentBitmap = NtfsAllocatePoolNoRaise( PagedPool, sizeof( RESERVED_BITMAP_RANGE ));

                if (CurrentBitmap == NULL) { goto AllocationFailure; }

                RtlZeroMemory( CurrentBitmap, sizeof( RESERVED_BITMAP_RANGE ));

                InitializeListHead( &CurrentBitmap->Links );
                CurrentBitmap->RangeOffset = FirstRange;
            }

            //
            //  Update our pointer to the reserved bitmap.
            //

            Scb->ScbType.Data.ReservedBitMap = CurrentBitmap;

        //
        //  Look through the existing ranges to find the range we are interested in.
        //  If we currently have the basic single bitmap structure
        //  then we can either use it or must convert it.
        //

        } else if (Scb->ScbType.Data.ReservedBitMap->Links.Flink == NULL) {

            //
            //  If we are accessing range zero then grow the bitmap if necessary.
            //

            if ((FirstRange == 0) && (CurrentLastBit < NTFS_BITMAP_MAX_BASIC_SIZE)) {

                //
                //  Remember this bitmap.
                //

                NextBitmap = Scb->ScbType.Data.ReservedBitMap;
                if (CurrentLastBit >= NextBitmap->Bitmap.SizeOfBitMap) {

                    SizeTemp = NtfsBasicBitmapSize( CurrentLastBit + 1 );
                    CurrentBitmap = NtfsAllocatePoolNoRaise( PagedPool, SizeTemp );

                    if (CurrentBitmap == NULL) { goto AllocationFailure; }

                    RtlZeroMemory( CurrentBitmap, SizeTemp );
                    RtlInitializeBitMap( &CurrentBitmap->Bitmap,
                                         &CurrentBitmap->RangeOffset,
                                         (SizeTemp - FIELD_OFFSET( RESERVED_BITMAP_RANGE, RangeOffset )) * 8);

                    CurrentBitmap->BasicDirtyBits = NextBitmap->BasicDirtyBits;

                    RtlCopyMemory( CurrentBitmap->Bitmap.Buffer,
                                   NextBitmap->Bitmap.Buffer,
                                   NextBitmap->Bitmap.SizeOfBitMap / 8 );

                    //
                    //  Now store this into the Scb.
                    //

                    Scb->ScbType.Data.ReservedBitMap = CurrentBitmap;
                    NtfsFreePool( NextBitmap );

                } else {

                    CurrentBitmap = NextBitmap;
                }

            //
            //  Otherwise we want to convert to the linked list of bitmap ranges.
            //

            } else {

                NextBitmap = NtfsAllocatePoolNoRaise( PagedPool, sizeof( RESERVED_BITMAP_RANGE ));

                if (NextBitmap == NULL) { goto AllocationFailure; }

                //
                //  Update the new structure.
                //

                RtlZeroMemory( NextBitmap, sizeof( RESERVED_BITMAP_RANGE ));

                InitializeListHead( &NextBitmap->Links );
                NextBitmap->DirtyBits = Scb->ScbType.Data.ReservedBitMap->BasicDirtyBits;

                SizeTemp = Scb->ScbType.Data.ReservedBitMap->Bitmap.SizeOfBitMap / 8;

                //
                //  We will use the existing bitmap as the buffer for the new bitmap.
                //  Move the bits to the start of the buffer and then zero
                //  the remaining bytes.
                //

                RtlMoveMemory( Scb->ScbType.Data.ReservedBitMap,
                               Scb->ScbType.Data.ReservedBitMap->Bitmap.Buffer,
                               SizeTemp );

                RtlZeroMemory( Add2Ptr( Scb->ScbType.Data.ReservedBitMap, SizeTemp ),
                               sizeof( LIST_ENTRY ) + sizeof( RTL_BITMAP ));

                //
                //  Limit ourselves to the maximum range size.
                //

                SizeTemp = (SizeTemp + sizeof( LIST_ENTRY ) + sizeof( RTL_BITMAP )) * 8;
                if (SizeTemp > NTFS_BITMAP_RANGE_SIZE) {

                    SizeTemp = NTFS_BITMAP_RANGE_SIZE;
                }

                RtlInitializeBitMap( &NextBitmap->Bitmap,
                                     (PULONG) Scb->ScbType.Data.ReservedBitMap,
                                     SizeTemp );

                //
                //  Now point to this new bitmap.
                //

                Scb->ScbType.Data.ReservedBitMap = NextBitmap;
            }
        }

        //
        //  If we didn't find the correct bitmap above then scan the list looking
        //  for the entry.
        //

        if (CurrentBitmap == NULL) {

            //
            //  Walk the list looking for a matching entry.
            //

            NextBitmap = Scb->ScbType.Data.ReservedBitMap;
            FreeBitmap = NULL;

            while (TRUE) {

                //
                //  Exit if we found the correct range.
                //

                if (NextBitmap->RangeOffset == FirstRange) {

                    CurrentBitmap = NextBitmap;
                    break;
                }

                //
                //  Remember if this is a free range.
                //

                if (NextBitmap->DirtyBits == 0) {

                    FreeBitmap = NextBitmap;
                }

                //
                //  Exit if we are past our target and have a empty range then break out.
                //

                if ((NextBitmap->RangeOffset > FirstRange) &&
                    (FreeBitmap != NULL)) {

                    break;
                }

                //
                //  Move to the next entry.
                //

                NextBitmap = CONTAINING_RECORD( NextBitmap->Links.Flink,
                                                RESERVED_BITMAP_RANGE,
                                                Links );

                //
                //  Break out if we are back at the beginning of the list.
                //

                if (NextBitmap == Scb->ScbType.Data.ReservedBitMap) {

                    break;
                }
            }

            //
            //  If we still don't have the bitmap then we can look to see if
            //  we found any available free bitmaps.
            //

            if (CurrentBitmap == NULL) {

                //
                //  We lucked out and found a free bitmap.  Let's use it for
                //  this new range.
                //

                if (FreeBitmap != NULL) {

                    CurrentBitmap = FreeBitmap;

                    //
                    //  Go ahead and remove it from the list.  Deal with the cases where
                    //  we are the first entry and possibly the only entry.
                    //

                    if (Scb->ScbType.Data.ReservedBitMap == FreeBitmap) {

                        if (IsListEmpty( &FreeBitmap->Links )) {

                            Scb->ScbType.Data.ReservedBitMap = NULL;

                        } else {

                            Scb->ScbType.Data.ReservedBitMap = CONTAINING_RECORD( FreeBitmap->Links.Flink,
                                                                                     RESERVED_BITMAP_RANGE,
                                                                                     Links );
                        }
                    }

                    //
                    //  Remove this entry from the list.
                    //

                    RemoveEntryList( &FreeBitmap->Links );

                //
                //  We need to allocate a new range and insert it
                //  in the correct location.
                //

                } else {

                    //
                    //  Allocate a new bitmap and remember we need to insert it into the list.
                    //

                    CurrentBitmap = NtfsAllocatePoolNoRaise( PagedPool, sizeof( RESERVED_BITMAP_RANGE ));

                    if (CurrentBitmap == NULL) { goto AllocationFailure; }

                    RtlZeroMemory( CurrentBitmap, sizeof( RESERVED_BITMAP_RANGE ));
                }

                //
                //  Set the correct range value in the new bitmap.
                //

                CurrentBitmap->RangeOffset = FirstRange;

                //
                //  Now walk through and insert the new range into the list.  Start by checking if
                //  we are the only entry in the list.
                //

                if (Scb->ScbType.Data.ReservedBitMap == NULL) {

                    InitializeListHead( &CurrentBitmap->Links );
                    Scb->ScbType.Data.ReservedBitMap = CurrentBitmap;

                } else {

                    NextBitmap = Scb->ScbType.Data.ReservedBitMap;

                    //
                    //  Walk through the list if we are not the new first element.
                    //

                    if (CurrentBitmap->RangeOffset > NextBitmap->RangeOffset) {

                        do {

                            //
                            //  Move to the next entry.
                            //

                            NextBitmap = CONTAINING_RECORD( NextBitmap->Links.Flink,
                                                            RESERVED_BITMAP_RANGE,
                                                            Links );

                            ASSERT( NextBitmap->RangeOffset != CurrentBitmap->RangeOffset );

                            //
                            //  Exit if we are at the last entry.
                            //

                            if (NextBitmap == Scb->ScbType.Data.ReservedBitMap ) {

                                break;
                            }

                        //
                        //  Continue until we find an entry larger than us.
                        //

                        } while (CurrentBitmap->RangeOffset > NextBitmap->RangeOffset);

                    //
                    //  We are the new first element.
                    //

                    } else {

                        Scb->ScbType.Data.ReservedBitMap = CurrentBitmap;
                    }

                    //
                    //  Insert the new entry ahead of the next entry we found.
                    //

                    InsertTailList( &NextBitmap->Links, &CurrentBitmap->Links );
                }
            }
        }

        //
        //  We have a current bitmap.  Make sure it is large enough for the current
        //  bit.
        //

        if (CurrentBitmap->Bitmap.SizeOfBitMap <= CurrentLastBit) {

            //
            //  We should already have adjusted the sizes for the basic bitmap.
            //

            ASSERT( CurrentBitmap->Links.Flink != NULL );

            SizeTemp = NtfsBitmapSize( CurrentLastBit + 1 );

            //
            //  Allocate the new buffer and copy the previous bits over.
            //

            NewBitmapBuffer = NtfsAllocatePoolNoRaise( PagedPool, SizeTemp );

            if (NewBitmapBuffer == NULL) { goto AllocationFailure; }

            if (CurrentBitmap->Bitmap.SizeOfBitMap != 0) {

                RtlCopyMemory( NewBitmapBuffer,
                               CurrentBitmap->Bitmap.Buffer,
                               CurrentBitmap->Bitmap.SizeOfBitMap / 8 );

                NtfsFreePool( CurrentBitmap->Bitmap.Buffer );
            }

            RtlZeroMemory( Add2Ptr( NewBitmapBuffer, CurrentBitmap->Bitmap.SizeOfBitMap / 8 ),
                           SizeTemp - (CurrentBitmap->Bitmap.SizeOfBitMap / 8) );

            //
            //  Limit the bitmap size by the max range size.
            //

            SizeTemp *= 8;

            if (SizeTemp > NTFS_BITMAP_RANGE_SIZE) {

                SizeTemp = NTFS_BITMAP_RANGE_SIZE;
            }

            RtlInitializeBitMap( &CurrentBitmap->Bitmap,
                                 NewBitmapBuffer,
                                 SizeTemp );
        }

        //
        //  Figure out the worst case reservation required for this Scb, in bytes.
        //

        TempL = NtfsCalculateNeededReservedSpace( Scb );

        //
        //  Now loop to reserve the space, a compression unit at a time.
        //  We use the security fast mutex as a convenient end resource.
        //

        do {

            //
            //  If this compression unit is not already reserved do it now.
            //

            FlippedBit = FALSE;
            if (!RtlCheckBit( &CurrentBitmap->Bitmap, FirstBit )) {

                //
                //  If there is not sufficient space on the volume, then
                //  we must see if this Scb is totally reserved anyway.
                //

                if (((Vcb->TotalReserved + (Int64ShraMod32( Vcb->TotalReserved, 8 )) +
                     (1 << Scb->CompressionUnitShift)) >= Vcb->FreeClusters) &&
                    (Scb->ScbType.Data.TotalReserved < TempL) &&
#ifdef BRIANDBG
                    !NtfsIgnoreReserved &&
#endif
                    (FlagOn(Scb->ScbState, SCB_STATE_WRITE_ACCESS_SEEN))) {

                    NtfsReleaseReservedClusters( Vcb );
                    NtfsReleaseResource( IrpContext, Vcb->BitmapScb );
                    return FALSE;
                }

                //
                //  Reserve this compression unit and increase the number of dirty
                //  bits for this range.
                //

                SetFlag( CurrentBitmap->Bitmap.Buffer[FirstBit / 32], 1 << (FirstBit % 32) );
                if (CurrentBitmap->Links.Flink != NULL) {

                    CurrentBitmap->DirtyBits += 1;

                } else {

                    CurrentBitmap->BasicDirtyBits += 1;
                }

                FlippedBit = TRUE;
            }

            if (FlippedBit || (MappedFile && (Scb->ScbType.Data.TotalReserved <= TempL))) {

                //
                //  Increased TotalReserved bytes in the Scb.
                //

                Scb->ScbType.Data.TotalReserved += Scb->CompressionUnit;
                ASSERT( Scb->CompressionUnit != 0 );
                ASSERT( (Scb->CompressionUnitShift != 0) ||
                        (Vcb->BytesPerCluster == 0x10000) );

                //
                //  Increase total reserved clusters in the Vcb, if the user has
                //  write access.  (Otherwise this must be a call from a read
                //  to a usermapped section.)
                //

                if (FlagOn(Scb->ScbState, SCB_STATE_WRITE_ACCESS_SEEN)) {
                    Vcb->TotalReserved += 1 << Scb->CompressionUnitShift;
                }

                TempL -= Scb->CompressionUnit;
                TempL += Int64ShraMod32( Scb->CompressionUnit, 8 );
            }

            FirstBit += 1;
        } while (FirstBit <= CurrentLastBit);

        //
        //  Exit if we have reached the last range.
        //

        if (FirstRange == LastRange) { break; }

        FirstRange += 1;
        FirstBit = 0;
    }

    ReturnValue = TRUE;

AllocationFailure:

    NtfsReleaseReservedClusters( Vcb );
    NtfsReleaseResource( IrpContext, Vcb->BitmapScb );

    //
    //  If we have an Irp Context then we can raise insufficient resources.  Otherwise
    //  return FALSE.
    //

    if (!ReturnValue && ARGUMENT_PRESENT( IrpContext )) {
        NtfsRaiseStatus( IrpContext, STATUS_INSUFFICIENT_RESOURCES, NULL, NULL );
    }

    return ReturnValue;
}



VOID
NtfsFreeReservedClusters (
    IN PSCB Scb,
    IN LONGLONG FileOffset,
    IN ULONG ByteCount
    )

/*++

Routine Description:

    This routine frees any previously reserved clusters in the specified range.

Arguments:

    Scb - Address of a compressed stream for which we are freeing reserved space

    FileOffset - Starting byte being freed

    ByteCount - Number of bytes being freed by caller, or 0 if to end of file

Return Value:

    None (all errors simply raise)

--*/

{
    ULONG FirstBit, LastBit, CurrentLastBit;
    ULONG FirstRange, LastRange;
    ULONG CompressionShift;
    PRESERVED_BITMAP_RANGE CurrentBitmap = NULL;
    PUSHORT DirtyBits;
    PRESERVED_BITMAP_RANGE NextBitmap;
    PVCB Vcb = Scb->Vcb;
    LONGLONG TempL;
    ULONG MappedFile;

    NtfsAcquireReservedClusters( Vcb );

    MappedFile = FlagOn( Scb->Header.Flags, FSRTL_FLAG_USER_MAPPED_FILE );

    //
    //  If there is no bitmap for non mapped files or the reserved count is zero we
    //  can get out immediately.
    //

    if ((Scb->Header.NodeTypeCode != NTFS_NTC_SCB_DATA) ||
        (NULL == Scb->ScbType.Data.ReservedBitMap) ||
        (Scb->ScbType.Data.TotalReserved == 0)) {
        NtfsReleaseReservedClusters( Vcb );
        return;
    }

    TempL = NtfsCalculateNeededReservedSpace( Scb );

    if (MappedFile) {

        //
        //  Mapped files can only shrink reserved down to upper limit
        //

        if (Scb->ScbType.Data.TotalReserved <= TempL + Scb->CompressionUnit) {
            NtfsReleaseReservedClusters( Vcb );
            return;
        }
    }

    //
    //  Calculate first bit to free, and initialize LastBit
    //

    CompressionShift = Vcb->ClusterShift + (ULONG)Scb->CompressionUnitShift;
    FirstBit = ((ULONG) Int64ShraMod32( FileOffset, CompressionShift )) & NTFS_BITMAP_RANGE_MASK;
    FirstRange = (ULONG) Int64ShraMod32( FileOffset, CompressionShift + NTFS_BITMAP_RANGE_SHIFT );
    LastRange = MAXULONG;
    LastBit = MAXULONG;

    //
    //  If ByteCount was specified, then calculate LastBit.
    //

    if (ByteCount != 0) {
        LastBit = ((ULONG) Int64ShraMod32( FileOffset + ByteCount - 1, CompressionShift )) & NTFS_BITMAP_RANGE_MASK;
        LastRange = (ULONG) Int64ShraMod32( FileOffset + ByteCount - 1,
                                            CompressionShift + NTFS_BITMAP_RANGE_SHIFT );
    }

    //
    //  Make sure we started with numbers in range.
    //

    ASSERT( (((LONGLONG) FirstRange << (CompressionShift + NTFS_BITMAP_RANGE_SHIFT)) +
             ((LONGLONG)(FirstBit + 1) << CompressionShift)) > FileOffset );

    ASSERT( (FirstRange < LastRange) || (LastBit >= FirstBit) );

    //
    //  Look for the first range which lies within our input range.
    //

    NextBitmap = Scb->ScbType.Data.ReservedBitMap;

    //
    //  If this is a basic bitmap range then our input should be range zero.
    //

    if (NextBitmap->Links.Flink == NULL) {

        if (FirstRange == 0) {

            CurrentBitmap = NextBitmap;
            DirtyBits = &CurrentBitmap->BasicDirtyBits;
        }

    //
    //  Otherwise loop through the links.
    //

    } else {

        do {

            //
            //  Check if this bitmap is within the range being checked.
            //

            if (NextBitmap->RangeOffset >= FirstRange) {

                if (NextBitmap->RangeOffset <= LastRange) {

                    CurrentBitmap = NextBitmap;
                    DirtyBits = &CurrentBitmap->DirtyBits;

                    if (NextBitmap->RangeOffset != FirstRange) {

                        FirstBit = 0;
                        FirstRange = NextBitmap->RangeOffset;
                    }
                }

                break;
            }

            NextBitmap = CONTAINING_RECORD( NextBitmap->Links.Flink,
                                            RESERVED_BITMAP_RANGE,
                                            Links );

        } while (NextBitmap != Scb->ScbType.Data.ReservedBitMap);
    }

    //
    //  If we didn't find a match we can exit.
    //

    if (CurrentBitmap == NULL) {

        NtfsReleaseReservedClusters( Vcb );
        return;
    }

    //
    //  Loop for each bitmap in the input range.
    //

    while (TRUE) {

        //
        //  If we are at the last range then use the input last bit.
        //

        CurrentLastBit = LastBit;
        if (FirstRange != LastRange) {

            CurrentLastBit = NTFS_BITMAP_RANGE_MASK;
        }

        //
        //  Under no circumstances should we go off the end!
        //

        if (CurrentLastBit >= CurrentBitmap->Bitmap.SizeOfBitMap) {
            CurrentLastBit = CurrentBitmap->Bitmap.SizeOfBitMap - 1;
        }

        //
        //  Now loop to free the space, a compression unit at a time.
        //  We use the security fast mutex as a convenient end resource.
        //

        if (MappedFile || (*DirtyBits != 0)) {

            while (FirstBit <= CurrentLastBit) {

                //
                //  If this compression unit is reserved, then free it.
                //

                if (MappedFile || RtlCheckBit( &CurrentBitmap->Bitmap, FirstBit )) {

                    //
                    //  Free this compression unit and decrement the dirty bits
                    //  for this bitmap if required.
                    //

                    if (!MappedFile) {
                        ClearFlag( CurrentBitmap->Bitmap.Buffer[FirstBit / 32], 1 << (FirstBit % 32) );
                    }

                    //
                    //  Decrease TotalReserved bytes in the Scb.
                    //

                    ASSERT( Scb->ScbType.Data.TotalReserved >= Scb->CompressionUnit );
                    Scb->ScbType.Data.TotalReserved -= Scb->CompressionUnit;
                    ASSERT( Scb->CompressionUnit != 0 );

                    //
                    //  Decrease total reserved clusters in the Vcb, if we are counting
                    //  against the Vcb.
                    //

                    if (FlagOn(Scb->ScbState, SCB_STATE_WRITE_ACCESS_SEEN)) {
                        ASSERT(Vcb->TotalReserved >= (1  << Scb->CompressionUnitShift));
                        Vcb->TotalReserved -= 1 << Scb->CompressionUnitShift;
                    }

                    if (MappedFile) {

                        TempL += Scb->CompressionUnit;
                        TempL -= Int64ShraMod32( Scb->CompressionUnit, 8 );

                        if (Scb->ScbType.Data.TotalReserved <= TempL) {
                            break;
                        }
                    }

                    //
                    //  Go ahead and break out if the count of dirty bits goes to zero.
                    //

                    ASSERT( MappedFile || *DirtyBits != 0 );

                    if (!MappedFile) {
                        *DirtyBits -= 1;

                        if (*DirtyBits == 0) { break; }
                    }
                }
                FirstBit += 1;
            }
        }

        //
        //  Break out if we are last the last range or there is no next range
        //  or we're mapped and not at the limit
        //

        if ((NULL == CurrentBitmap->Links.Flink) ||
            (FirstRange == LastRange) ||
            (MappedFile &&
             (Scb->ScbType.Data.TotalReserved <= TempL))) {

            break;
        }

        //
        //  Move to the next range.
        //

        CurrentBitmap = CONTAINING_RECORD( CurrentBitmap->Links.Flink,
                                           RESERVED_BITMAP_RANGE,
                                           Links );

        //
        //  Exit if we did not find a new range within the user specified range.
        //

        if ((CurrentBitmap->RangeOffset > LastRange) ||
            (CurrentBitmap->RangeOffset <= FirstRange)) {

            break;
        }

        FirstRange = CurrentBitmap->RangeOffset;
        DirtyBits = &CurrentBitmap->DirtyBits;

        FirstBit = 0;
    }

    NtfsReleaseReservedClusters( Vcb );
}


BOOLEAN
NtfsCheckForReservedClusters (
    IN PSCB Scb,
    IN LONGLONG StartingVcn,
    IN OUT PLONGLONG ClusterCount
    )

/*++

Routine Description:

    This routine is called to determine if a range of a stream has reserved
    clusters.  It is used when the user queries for the allocated ranges.  We
    want to tell the user that a range which has reserved clusters is allocated.
    Otherwise he may skip over this range when reading from the file for a
    backup or copy operation.

Arguments:

    Scb - Address of the Scb for a sparsestream for which we are checking for
        reservation.  Our caller should only call us for this type of stream.

    StartingVcn - Starting offset of a potential zeroed range.  This is guaranteed
        to begin on a sparse range boundary.

    ClusterCount - On input this is the length of the range to check.  On output it
        is the length of the deallocated range beginning at this offset.  The length
        will be zero if the first compression unit is reserved.

Return Value:

    BOOLEAN - TRUE if a reserved unit is found in the range, FALSE otherwise.

--*/

{
    ULONG CompressionShift;
    ULONG FirstBit, LastBit, CurrentLastBit, CurrentBits;
    ULONG FirstRange, LastRange;
    ULONG RemainingBits;
    ULONG FoundBit;
    PRESERVED_BITMAP_RANGE CurrentBitmap = NULL;
    PRESERVED_BITMAP_RANGE NextBitmap;
    PUSHORT DirtyBits;
    PVCB Vcb = Scb->Vcb;
    LONGLONG FoundBits = 0;

    BOOLEAN FoundReserved = FALSE;

    RTL_BITMAP LocalBitmap;

    PAGED_CODE();

    //
    //  Check that the stream is really sparse and that the file offset is on a sparse
    //  boundary.
    //

    ASSERT( FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK | ATTRIBUTE_FLAG_SPARSE ));
    ASSERT( (((ULONG) LlBytesFromClusters( Vcb, StartingVcn )) & (Scb->CompressionUnit - 1)) == 0 );

    //
    //  If there is no bitmap, we can get out.
    //

    if ((Scb->ScbType.Data.ReservedBitMap == NULL) ||
        (Scb->ScbType.Data.TotalReserved == 0)) {
        return FoundReserved;
    }

    //
    //  Compute the range of bits that need to be checked.  Trim this by the range of
    //  the bitmap.
    //

    CompressionShift = (ULONG) Scb->CompressionUnitShift;
    FirstBit = ((ULONG) Int64ShraMod32( StartingVcn, CompressionShift )) & NTFS_BITMAP_RANGE_MASK;
    FirstRange = (ULONG) Int64ShraMod32( StartingVcn, CompressionShift + NTFS_BITMAP_RANGE_SHIFT );

    LastBit = ((ULONG) Int64ShraMod32( StartingVcn + *ClusterCount - 1, CompressionShift )) & NTFS_BITMAP_RANGE_MASK;
    LastRange = (ULONG) Int64ShraMod32( StartingVcn + *ClusterCount - 1,
                                        CompressionShift + NTFS_BITMAP_RANGE_SHIFT );

    NtfsAcquireReservedClusters( Vcb );

    //
    //  Look for the first range which lies within our input range.
    //

    NextBitmap = Scb->ScbType.Data.ReservedBitMap;

    //
    //  If this is a basic bitmap range then our input should be range zero.
    //

    if (NextBitmap->Links.Flink == NULL) {

        if (FirstRange == 0) {

            CurrentBitmap = NextBitmap;
            DirtyBits = &CurrentBitmap->BasicDirtyBits;
        }

    //
    //  Otherwise loop through the links.
    //

    } else {

        do {

            //
            //  Check if this bitmap is within the range being checked.
            //

            if (NextBitmap->RangeOffset >= FirstRange) {

                if (NextBitmap->RangeOffset <= LastRange) {

                    CurrentBitmap = NextBitmap;
                    DirtyBits = &CurrentBitmap->DirtyBits;

                    //
                    //  If we are skipping any ranges then remember how
                    //  many bits are implicitly clear.
                    //

                    if (NextBitmap->RangeOffset != FirstRange) {

                        FoundBits = (NextBitmap->RangeOffset - FirstRange) * NTFS_BITMAP_RANGE_SIZE;
                        FoundBits -= FirstBit;
                        FirstBit = 0;
                        FirstRange = NextBitmap->RangeOffset;
                    }
                }

                break;
            }

            NextBitmap = CONTAINING_RECORD( NextBitmap->Links.Flink,
                                            RESERVED_BITMAP_RANGE,
                                            Links );

        } while (NextBitmap != Scb->ScbType.Data.ReservedBitMap);
    }

    //
    //  If we didn't find a match we can exit.
    //

    if (CurrentBitmap == NULL) {

        NtfsReleaseReservedClusters( Vcb );
        return FoundReserved;
    }

    //
    //  Loop for each bitmap in the input range.
    //

    while (TRUE) {

        //
        //  If we are at the last range then use the input last bit.
        //

        CurrentLastBit = LastBit;
        if (FirstRange != LastRange) {

            CurrentLastBit = NTFS_BITMAP_RANGE_MASK;
        }

        CurrentBits = CurrentLastBit - FirstBit + 1;

        //
        //  Skip this range if there are no dirty bits.
        //

        if (*DirtyBits != 0) {

            //
            //  Under no circumstances should we go off the end!
            //

            if (CurrentLastBit >= CurrentBitmap->Bitmap.SizeOfBitMap) {
                CurrentLastBit = CurrentBitmap->Bitmap.SizeOfBitMap - 1;
            }

            //
            //  Check on the number of bits remaining in this bitmap.
            //

            if (FirstBit <= CurrentLastBit) {

                RemainingBits = CurrentLastBit - FirstBit + 1;
                ASSERT( RemainingBits != 0 );

                //
                //  If the starting bit is set then there is nothing else to do.
                //  Otherwise find the length of the clear run.
                //

                if (RtlCheckBit( &CurrentBitmap->Bitmap, FirstBit )) {

                    FoundBit = FirstBit;

                } else {

                    RtlInitializeBitMap( &LocalBitmap,
                                         CurrentBitmap->Bitmap.Buffer,
                                         CurrentLastBit + 1 );

                    FoundBit = RtlFindNextForwardRunClear( &LocalBitmap,
                                                           FirstBit,
                                                           &FirstBit );

                    if (FoundBit == RemainingBits) {

                        FoundBit = 0xffffffff;

                    } else {

                        FoundBit += FirstBit;
                    }
                }

                //
                //  If a bit was found then we need to compute where it lies in the
                //  requested range.
                //

                if (FoundBit != 0xffffffff) {

                    //
                    //  Include any clear bits from this range in our total.
                    //

                    FoundBits += (FoundBit - FirstBit);

                    //
                    //  Convert from compression units to clusters and trim to a compression
                    //  unit boundary.
                    //

                    *ClusterCount = Int64ShllMod32( FoundBits, CompressionShift );
                    ((PLARGE_INTEGER) ClusterCount)->LowPart &= ~(Vcb->SparseFileClusters - 1);

                    //
                    //  Now adjust the output cluster range value.
                    //

                    ASSERT( LlBytesFromClusters( Vcb, StartingVcn + *ClusterCount ) <= (ULONGLONG) Scb->Header.FileSize.QuadPart );
                    FoundReserved = TRUE;
                    break;
                }
            }
        }

        //
        //  Break out if we are last the last range or there is no next range.
        //

        if ((CurrentBitmap->Links.Flink == NULL) ||
            (FirstRange == LastRange)) {

            break;
        }

        //
        //  Move to the next range.
        //

        CurrentBitmap = CONTAINING_RECORD( CurrentBitmap->Links.Flink,
                                           RESERVED_BITMAP_RANGE,
                                           Links );

        //
        //  Exit if we did not find a new range within the user specified range.
        //

        if ((CurrentBitmap->RangeOffset <= FirstRange) ||
            (CurrentBitmap->RangeOffset > LastRange)) {

            break;
        }

        //
        //  Add in the bits for any ranges we skipped.
        //

        FoundBits += (CurrentBitmap->RangeOffset - FirstRange - 1) * NTFS_BITMAP_RANGE_SIZE;
        FirstRange = CurrentBitmap->RangeOffset;
        FirstBit = 0;

        //
        //  Include the bits from the most recent range in our count of found bits.
        //

        FoundBits += CurrentBits;

        //
        //  Remember where the dirty bits field is.
        //

        DirtyBits = &CurrentBitmap->DirtyBits;
    }

    NtfsReleaseReservedClusters( Vcb );
    return FoundReserved;
}


VOID
NtfsDeleteReservedBitmap (
    IN PSCB Scb
    )

/*++

Routine Description:

    This routine is called to free all of the components of the reserved bitmap.  We
    free any remaining reserved clusters and deallocate all of the pool associated with
    the bitmap.

Arguments:

    Scb - Scb for the stream.

Return Value:

    None.

--*/

{
    PRESERVED_BITMAP_RANGE FirstRange;
    PRESERVED_BITMAP_RANGE CurrentRange;

    PAGED_CODE();

    FirstRange = Scb->ScbType.Data.ReservedBitMap;

    ASSERT( FirstRange != NULL );

    //
    //  Free any reserved clusters still present.
    //

    if ((Scb->ScbType.Data.TotalReserved != 0) && FlagOn( Scb->ScbState, SCB_STATE_WRITE_ACCESS_SEEN )) {

        LONGLONG ClusterCount;

        ClusterCount = LlClustersFromBytesTruncate( Scb->Vcb, Scb->ScbType.Data.TotalReserved );

        //
        //  Use the security fast mutex as a convenient end resource.
        //

        NtfsAcquireReservedClusters( Scb->Vcb );

        ASSERT(Scb->Vcb->TotalReserved >= ClusterCount);
        Scb->Vcb->TotalReserved -= ClusterCount;

        NtfsReleaseReservedClusters( Scb->Vcb );
    }

    Scb->ScbType.Data.TotalReserved = 0;

    //
    //  The typical case is where the first range is the only range
    //  for a small file.
    //

    if (FirstRange->Links.Flink == NULL) {

        NtfsFreePool( FirstRange );

    //
    //  Otherwise we need to walk through the list of ranges.
    //

    } else {

        //
        //  Loop through the reserved bitmaps until we hit the first.
        //

        do {

            CurrentRange = CONTAINING_RECORD( FirstRange->Links.Flink,
                                              RESERVED_BITMAP_RANGE,
                                              Links );

            RemoveEntryList( &CurrentRange->Links );

            if (CurrentRange->Bitmap.Buffer != NULL) {

                NtfsFreePool( CurrentRange->Bitmap.Buffer );
            }

            NtfsFreePool( CurrentRange );

        } while (CurrentRange != FirstRange);
    }

    //
    //  Show that the bitmap is gone.
    //

    Scb->ScbType.Data.ReservedBitMap = NULL;

    return;
}


#if (defined(NTFS_RWCMP_TRACE) || defined(SYSCACHE) || defined(NTFS_RWC_DEBUG) || defined(SYSCACHE_DEBUG))

BOOLEAN
FsRtlIsSyscacheFile (
    IN PFILE_OBJECT FileObject
    )

/*++

Routine Description:

    This routine returns to the caller whether or not the specified
    file object is a file to be logged. Originally this was only used for
    the syscache stress test (thus the name).  The function understands minimal
    wildcard patterns.  To change which filename is logged against change the
    variable MakName.

Arguments:

    FileObject - supplies the FileObject to be tested (it must not be
                 cleaned up yet).

Return Value:

    FALSE - if the file is not a Syscache file.
    TRUE - if the file is a Syscache file.

--*/
{
    ULONG iM = 0;
    ULONG iF;
    PWSTR MakName = L"cac*.tmp";
    ULONG LenMakName = wcslen(MakName);

    if (FileObject) {
        iF = FileObject->FileName.Length / 2;
        while ((iF != 0) && (FileObject->FileName.Buffer[iF - 1] != '\\')) {
            iF--;
        }


        while (TRUE) {

            //
            //  If we are past the end of the file object then we are done in any case.
            //

            if ((LONG)iF == FileObject->FileName.Length / 2) {

                //
                //  Both strings exausted then we are done.
                //

                if (iM == LenMakName) {

                    return TRUE;
                }

                break;

            //
            //  Break if more input but the match string is exhausted.
            //

            } else if (iM == LenMakName) {

                break;

            //
            //  If we are at the '*' then match everything but skip to next character
            //  on a '.'
            //

            } else if (MakName[iM] == '*') {

                //
                // if we're at the last character move past wildchar in template
                //


                if ((FileObject->FileName.Buffer[iF] == L'.') && (LenMakName != iM + 1)) {

                    //
                    //  Move past * and . in NakName
                    //

                    ASSERT(MakName[iM + 1] == L'.');

                    iM++; iM++;

                } else if (((LONG)iF + 1 == FileObject->FileName.Length / 2)) {
                    iM++;
                }
                iF++;

            } else if (MakName[iM] == (WCHAR)(FileObject->FileName.Buffer[iF] )) {
                iM++; iF++;
            } else {
                break;
            }
        }
    }

    return FALSE;
}


VOID
FsRtlVerifySyscacheData (
    IN PFILE_OBJECT FileObject,
    IN PVOID Buffer,
    IN ULONG Length,
    IN ULONG Offset
    )

/*

Routine Description:

    This routine scans a buffer to see if it is valid data for a syscache
    file, and stops if it sees bad data.

    HINT TO CALLERS: Make sure (Offset + Length) <= FileSize!

Arguments:

    Buffer - Pointer to the buffer to be checked

    Length - Length of the buffer to be checked in bytes

    Offset - File offset at which this data starts (syscache files are currently
             limited to 24 bits of file offset).

Return Value:

    None (stops on error)

--*/

{
    PULONG BufferEnd;

    BufferEnd = (PULONG)((PCHAR)Buffer + (Length & ~3));

    while ((PULONG)Buffer < BufferEnd) {

        if ((*(PULONG)Buffer != 0) && (((*(PULONG)Buffer & 0xFFFFFF) ^ Offset) != 0xFFFFFF) &&
            ((Offset & 0x1FF) != 0)) {

            DbgPrint("Bad Data, FileObject = %08lx, Offset = %08lx, Buffer = %08lx\n",
                     FileObject, Offset, (PULONG)Buffer );
            DbgBreakPoint();
        }
        Offset += 4;
        Buffer = (PVOID)((PULONG)Buffer + 1);
    }
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\npfs\writesup.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    WriteSup.c

Abstract:

    This module implements the Write support routine.  This is a common
    write function that is called by write, unbuffered write, and transceive.

Author:

    Gary Kimura     [GaryKi]    21-Sep-1990

Revision History:

--*/

#include "NpProcs.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_WRITESUP)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NpWriteDataQueue)
#endif


NTSTATUS
NpWriteDataQueue (
    IN PDATA_QUEUE WriteQueue,
    IN READ_MODE ReadMode,
    IN PUCHAR WriteBuffer,
    IN ULONG WriteLength,
    IN NAMED_PIPE_TYPE PipeType,
    OUT PULONG WriteRemaining,
    IN PCCB Ccb,
    IN NAMED_PIPE_END NamedPipeEnd,
    IN PETHREAD UserThread,
    IN PLIST_ENTRY DeferredList
    )

/*++

Routine Description:

    This procedure writes data from the write buffer into read entries in
    the write queue.  It will also dequeue entries in the queue as necessary.

Arguments:

    WriteQueue - Provides the write queue to process.

    ReadMode - Supplies the read mode of read entries in the write queue.

    WriteBuffer - Provides the buffer from which to read the data.

    WriteLength  - Provides the length, in bytes, of WriteBuffer.

    PipeType - Indicates if type of pipe (i.e., message or byte stream).

    WriteRemaining - Receives the number of bytes remaining to be transfered
        that were not completed by this call.  If the operation wrote
        everything then is value is set to zero.

    Ccb - Supplies the ccb for the operation

    NamedPipeEnd - Supplies the end of the pipe doing the write

    UserThread - Supplies the user thread

    DeferredList - List of IRPs to be completed after we drop the locks

Return Value:

    BOOLEAN - TRUE if the operation wrote everything and FALSE otherwise.
        Note that a zero byte message that hasn't been written will return
        a function result of FALSE and WriteRemaining of zero.

--*/

{
    NTSTATUS Result;

    BOOLEAN WriteZeroMessage;

    PDATA_ENTRY DataEntry;

    PUCHAR ReadBuffer;
    ULONG ReadLength;

    ULONG AmountToCopy;
    NTSTATUS Status;
    PSECURITY_CLIENT_CONTEXT SecurityContext;
    BOOLEAN DoneSecurity=FALSE;
    PIO_STACK_LOCATION IrpSp;
    BOOLEAN FreeBuffer;

    PIRP ReadIrp;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "NpWriteDataQueue\n", 0);
    DebugTrace( 0, Dbg, "WriteQueue   = %08lx\n", WriteQueue);
    DebugTrace( 0, Dbg, "WriteBuffer  = %08lx\n", WriteBuffer);
    DebugTrace( 0, Dbg, "WriteLength  = %08lx\n", WriteLength);
    DebugTrace( 0, Dbg, "PipeType     = %08lx\n", PipeType);
    DebugTrace( 0, Dbg, "Ccb          = %08lx\n", Ccb);
    DebugTrace( 0, Dbg, "NamedPipeEnd = %08lx\n", NamedPipeEnd);
    DebugTrace( 0, Dbg, "UserThread   = %08lx\n", UserThread);

    //
    //  Determine if we are to write a zero byte message, and initialize
    //  WriteRemaining
    //

    *WriteRemaining = WriteLength;

    if ((PipeType == FILE_PIPE_MESSAGE_TYPE) && (WriteLength == 0)) {

        WriteZeroMessage = TRUE;

    } else {

        WriteZeroMessage = FALSE;
    }

    //
    //  Now while the write queue has some read entries in it and
    //  there is some remaining write data or this is a write zero message
    //  then we'll do the following main loop
    //

    for (DataEntry = NpGetNextRealDataQueueEntry( WriteQueue, DeferredList );

         (NpIsDataQueueReaders(WriteQueue) &&
          ((*WriteRemaining > 0) || WriteZeroMessage));

         DataEntry = NpGetNextRealDataQueueEntry( WriteQueue, DeferredList )) {

        ReadLength = DataEntry->DataSize;

        DebugTrace(0, Dbg, "Top of main loop...\n", 0);
        DebugTrace(0, Dbg, "ReadBuffer      = %08lx\n", ReadBuffer);
        DebugTrace(0, Dbg, "ReadLength      = %08lx\n", ReadLength);
        DebugTrace(0, Dbg, "*WriteRemaining = %08lx\n", *WriteRemaining);

        //
        //  Check if this is a ReadOverflow Operation and if so then also check
        //  that the read will succeed otherwise complete this read with
        //  buffer overflow and continue on.
        //

        IrpSp = IoGetCurrentIrpStackLocation( DataEntry->Irp );

        if (IrpSp->MajorFunction == IRP_MJ_FILE_SYSTEM_CONTROL &&
            IrpSp->Parameters.FileSystemControl.FsControlCode == FSCTL_PIPE_INTERNAL_READ_OVFLOW) {

            if ((ReadLength < WriteLength) || WriteZeroMessage) {

                ReadIrp = NpRemoveDataQueueEntry( WriteQueue, TRUE, DeferredList );
                if (ReadIrp != NULL) {
                    NpDeferredCompleteRequest( ReadIrp, STATUS_BUFFER_OVERFLOW, DeferredList );
                }
                continue;
            }
        }


        if (DataEntry->DataEntryType == Unbuffered) {
            DataEntry->Irp->Overlay.AllocationSize.QuadPart = WriteQueue->BytesInQueue - WriteQueue->BytesInQueue;
        }


        //
        //  copy data from the write buffer at write offset to the
        //  read buffer at read offset by the mininum of write remaining
        //  or read remaining
        //

        AmountToCopy = (*WriteRemaining < ReadLength ? *WriteRemaining
                                                        : ReadLength);

        if (DataEntry->DataEntryType != Unbuffered && AmountToCopy > 0) {
            ReadBuffer = NpAllocatePagedPool ( AmountToCopy, 'RFpN' );
            if (ReadBuffer == NULL) {
                return STATUS_INSUFFICIENT_RESOURCES;
            }
            FreeBuffer = TRUE;
        } else {
            ReadBuffer = DataEntry->Irp->AssociatedIrp.SystemBuffer;
            FreeBuffer = FALSE;
        }

        try {

            RtlCopyMemory( ReadBuffer,
                           &WriteBuffer[ WriteLength - *WriteRemaining ],
                           AmountToCopy );

        } except (EXCEPTION_EXECUTE_HANDLER) {
            if (FreeBuffer) {
                NpFreePool (ReadBuffer);
            }
            return GetExceptionCode ();
        }

        //
        // Done update the security in the CCB multiple times. It won't change.
        //
        if (DoneSecurity == FALSE) {
            DoneSecurity = TRUE;
            //
            //  Now update the security fields in the nonpaged ccb
            //
            Status = NpGetClientSecurityContext (NamedPipeEnd,
                                                 Ccb,
                                                 UserThread,
                                                 &SecurityContext);
            if (!NT_SUCCESS(Status)) {
                if (FreeBuffer) {
                    NpFreePool (ReadBuffer);
                }
                return Status;
            }

            if (SecurityContext != NULL) {
                NpFreeClientSecurityContext (Ccb->SecurityClientContext);
                Ccb->SecurityClientContext = SecurityContext;
            }
        }

        //
        //  Now we've done with the read entry so remove it from the
        //  write queue, get its irp, and fill in the information field
        //  to be the bytes that we've transferred into the read buffer.
        //

        ReadIrp = NpRemoveDataQueueEntry( WriteQueue, TRUE, DeferredList );
        if (ReadIrp == NULL) {
            if (FreeBuffer) {
                NpFreePool (ReadBuffer);
            }
            continue;
        }

        //
        //  Update the Write remaining counts
        //

        *WriteRemaining -= AmountToCopy;

        ReadIrp->IoStatus.Information = AmountToCopy;
        if (FreeBuffer) {
            ReadIrp->AssociatedIrp.SystemBuffer = ReadBuffer;
            ReadIrp->Flags |= IRP_BUFFERED_IO | IRP_DEALLOCATE_BUFFER | IRP_INPUT_OPERATION;
        }


        if (*WriteRemaining == 0) {

            DebugTrace(0, Dbg, "Finished up the write remaining\n", 0);

            //**** ASSERT( ReadIrp->IoStatus.Information != 0 );

            NpDeferredCompleteRequest( ReadIrp, STATUS_SUCCESS, DeferredList );

            WriteZeroMessage = FALSE;

        } else {

            //
            //  There is still some space in the write buffer to be
            //  written out, but before we can handle that (in the
            //  following if statement) we need to finish the read.
            //  If the read is message mode then we've overflowed the
            //  buffer otherwise we completed successfully
            //

            if (ReadMode == FILE_PIPE_MESSAGE_MODE) {

                DebugTrace(0, Dbg, "Read buffer Overflow\n", 0);

                NpDeferredCompleteRequest( ReadIrp, STATUS_BUFFER_OVERFLOW, DeferredList );

            } else {

                DebugTrace(0, Dbg, "Read buffer byte stream done\n", 0);

                //**** ASSERT( ReadIrp->IoStatus.Information != 0 );

                NpDeferredCompleteRequest( ReadIrp, STATUS_SUCCESS, DeferredList );
            }
        }
    }

    DebugTrace(0, Dbg, "Finished loop...\n", 0);
    DebugTrace(0, Dbg, "*WriteRemaining  = %08lx\n", *WriteRemaining);
    DebugTrace(0, Dbg, "WriteZeroMessage = %08lx\n", WriteZeroMessage);

    //
    //  At this point we've finished off all of the read entries in the
    //  queue and we might still have something left to write.  If that
    //  is the case then we'll set our result to FALSE otherwise we're
    //  done so we'll return TRUE.
    //

    if ((*WriteRemaining > 0) || (WriteZeroMessage)) {

        ASSERT( !NpIsDataQueueReaders( WriteQueue ));

        Result = STATUS_MORE_PROCESSING_REQUIRED;

    } else {


        Result = STATUS_SUCCESS;
    }

    DebugTrace(-1, Dbg, "NpWriteDataQueue -> %08lx\n", Result);
    return Result;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\cachesup.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    CacheSup.c

Abstract:

    This module implements the cache management routines for Ntfs

Author:

    Your Name       [Email]         dd-Mon-Year

Revision History:

--*/

#include "NtfsProc.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (NTFS_BUG_CHECK_CACHESUP)

#define MAX_ZERO_THRESHOLD               (0x00400000)

//
//  Local debug trace level
//

#define Dbg                              (DEBUG_TRACE_CACHESUP)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NtfsCompleteMdl)
#pragma alloc_text(PAGE, NtfsCreateInternalStreamCommon)
#pragma alloc_text(PAGE, NtfsDeleteInternalAttributeStream)
#pragma alloc_text(PAGE, NtfsMapStream)
#pragma alloc_text(PAGE, NtfsPinMappedData)
#pragma alloc_text(PAGE, NtfsPinStream)
#pragma alloc_text(PAGE, NtfsPreparePinWriteStream)
#pragma alloc_text(PAGE, NtfsZeroData)
#endif


VOID
NtfsCreateInternalStreamCommon (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN BOOLEAN UpdateScb,
    IN BOOLEAN CompressedStream,
    IN UNICODE_STRING const *StreamName
    )

/*++

Routine Description:

    This routine is called to prepare a stream file associated with a
    particular attribute of a file.  On return, the Scb for the attribute
    will have an associated stream file object.  On return, this
    stream file will have been initialized through the cache manager.

    TEMPCODE  The following assumptions have been made or if open issue,
    still unresolved.

        - Assume.  The call to create Scb will initialize the Mcb for
          the non-resident case.

        - Assume.  When this file is created I increment the open count
          but not the unclean count for this Scb.  When we are done with
          the stream file, we should uninitialize it and dereference it.
          We also set the file object pointer to NULL.  Close will then
          do the correct thing.

        - Assume.  Since this call is likely to be followed shortly by
          either a read or write, the cache map is initialized here.

Arguments:

    Scb - Supplies the address to store the Scb for this attribute and
          stream file.  This will exist on return from this function.

    UpdateScb - Indicates if the caller wants to update the Scb from the
                attribute.

    CompressedStream - Supplies TRUE if caller wishes to create the
                       compressed stream.

    StreamName - Internal stream name or NULL is there isn't one available.
                 This is a constant value so we don't have to allocate any pool.

Return Value:

    None.

--*/

{
    PVCB Vcb = Scb->Vcb;

    CC_FILE_SIZES CcFileSizes;
    PFILE_OBJECT CallersFileObject;
    PFILE_OBJECT *FileObjectPtr = &Scb->FileObject;
    PFILE_OBJECT UnwindStreamFile = NULL;

    BOOLEAN UnwindInitializeCacheMap = FALSE;
    BOOLEAN DecrementScbCleanup = FALSE;

    BOOLEAN AcquiredMutex = FALSE;

    ASSERT_IRP_CONTEXT( IrpContext );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsCreateInternalAttributeStream\n") );
    DebugTrace( 0, Dbg, ("Scb        -> %08lx\n", Scb) );

    //
    //  Change FileObjectPtr if he wants the compressed stream
    //

#ifdef  COMPRESS_ON_WIRE
    if (CompressedStream) {
        FileObjectPtr = &Scb->Header.FileObjectC;
    }
#endif

    //
    //  If there is no file object, we create one and initialize
    //  it.
    //

    if (*FileObjectPtr == NULL) {

        //
        //  Only acquire the mutex if we don't have the file exclusive.
        //

        if (!NtfsIsExclusiveScb( Scb )) {

            KeWaitForSingleObject( &StreamFileCreationMutex, Executive, KernelMode, FALSE, NULL );
            AcquiredMutex = TRUE;
        }

        try {

            //
            //  Someone could have gotten there first.
            //

            if (*FileObjectPtr == NULL) {

                UnwindStreamFile = IoCreateStreamFileObjectLite( NULL, Scb->Vcb->Vpb->RealDevice);

                if (ARGUMENT_PRESENT( StreamName )) {
                    UnwindStreamFile->FileName.MaximumLength = StreamName->MaximumLength;
                    UnwindStreamFile->FileName.Length = StreamName->Length;
                    UnwindStreamFile->FileName.Buffer = StreamName->Buffer;
                }

                //
                //  Propagate any flags from the caller's FileObject to our
                //  stream file that the Cache Manager may look at, so we do not
                //  miss hints like sequential only or temporary.
                //

                if (!FlagOn(Scb->ScbState, SCB_STATE_MODIFIED_NO_WRITE) &&
                    (IrpContext->OriginatingIrp != NULL) &&
                    (CallersFileObject = IoGetCurrentIrpStackLocation(IrpContext->OriginatingIrp)->FileObject)) {

                    SetFlag( UnwindStreamFile->Flags,
                             CallersFileObject->Flags & NTFS_FO_PROPAGATE_TO_STREAM );
                }

                UnwindStreamFile->SectionObjectPointer = &Scb->NonpagedScb->SegmentObject;

                //
                //  For a compressed stream, we have to use separate section
                //  object pointers.
                //

#ifdef  COMPRESS_ON_WIRE
                if (CompressedStream) {
                    UnwindStreamFile->SectionObjectPointer = &Scb->NonpagedScb->SegmentObjectC;

                }
#endif

                //
                //  If we have created the stream file, we set it to type
                //  'StreamFileOpen'
                //

                NtfsSetFileObject( UnwindStreamFile,
                                   StreamFileOpen,
                                   Scb,
                                   NULL );

                if (FlagOn( Scb->ScbState, SCB_STATE_TEMPORARY )) {

                    SetFlag( UnwindStreamFile->Flags, FO_TEMPORARY_FILE );
                }

                //
                //  Initialize the fields of the file object.
                //

                UnwindStreamFile->ReadAccess = TRUE;
                UnwindStreamFile->WriteAccess = TRUE;
                UnwindStreamFile->DeleteAccess = TRUE;

                //
                //  Increment the open count and set the section
                //  object pointers.  We don't set the unclean count as the
                //  cleanup call has already occurred.
                //

                NtfsIncrementCloseCounts( Scb, TRUE, FALSE );

                //
                //  Increment the cleanup count in this Scb to prevent the
                //  Scb from going away if the cache call fails.
                //

                InterlockedIncrement( &Scb->CleanupCount );
                DecrementScbCleanup = TRUE;

                //
                //  If the Scb header has not been initialized, we will do so now.
                //

                if (UpdateScb
                    && !FlagOn( Scb->ScbState, SCB_STATE_HEADER_INITIALIZED )) {

                    NtfsUpdateScbFromAttribute( IrpContext, Scb, NULL );
                }

                //
                //  If this is a compressed stream and the file is not already
                //  marked as MODIFIED_NO_WRITE then do it now.  Use the
                //  Extended flag field in the Fsrtl header for this.  Since this
                //  is the only place we make this call with FsContext2 == NULL,
                //  it does not matter how we leave the FsRtl header flag.!
                //

                NtfsAcquireFsrtlHeader( Scb );
                ClearFlag(Scb->Header.Flags2, FSRTL_FLAG2_DO_MODIFIED_WRITE);
                if (!FlagOn( Scb->ScbState, SCB_STATE_MODIFIED_NO_WRITE ) &&
                    !FlagOn( Scb->Header.Flags2, FSRTL_FLAG2_DO_MODIFIED_WRITE ) &&
                    !CompressedStream) {

                    SetFlag(Scb->Header.Flags2, FSRTL_FLAG2_DO_MODIFIED_WRITE);
                }
                NtfsReleaseFsrtlHeader( Scb );

                //
                //  Check if we need to initialize the cache map for the stream file.
                //  The size of the section to map will be the current allocation
                //  for the stream file.
                //

                if (UnwindStreamFile->PrivateCacheMap == NULL) {

                    BOOLEAN PinAccess;

                    CcFileSizes = *(PCC_FILE_SIZES)&Scb->Header.AllocationSize;

                    //
                    //  If this is a stream with Usa protection, we want to tell
                    //  the Cache Manager we do not need to get any valid data
                    //  callbacks.  We do this by having xxMax sitting in
                    //  ValidDataLength for the call, but we have to restore the
                    //  correct value afterwards.
                    //
                    //  We also do this for all of the stream files created during
                    //  restart.  This has the effect of telling Mm to always
                    //  fault the page in from disk.  Don't generate a zero page if
                    //  push up the file size during restart.
                    //

                    if (FlagOn( Scb->ScbState, SCB_STATE_MODIFIED_NO_WRITE )) {

                        CcFileSizes.ValidDataLength.QuadPart = MAXLONGLONG;
                    }

                    PinAccess =
                        (BOOLEAN) (Scb->AttributeTypeCode != $DATA ||
                                   FlagOn(Scb->Fcb->FcbState, FCB_STATE_PAGING_FILE | FCB_STATE_SYSTEM_FILE) ||
                                   FlagOn( Scb->Vcb->VcbState, VCB_STATE_RESTART_IN_PROGRESS ) ||
                                   CompressedStream);

                    //
                    //  Bias this for the Usn journal.
                    //

                    if (FlagOn( Scb->ScbPersist, SCB_PERSIST_USN_JOURNAL )) {

                        CcFileSizes.AllocationSize.QuadPart -= Vcb->UsnCacheBias;
                        CcFileSizes.FileSize.QuadPart -= Vcb->UsnCacheBias;
                    }

                    CcInitializeCacheMap( UnwindStreamFile,
                                          &CcFileSizes,
                                          PinAccess,
                                          &NtfsData.CacheManagerCallbacks,
                                          (PCHAR)Scb + CompressedStream );

                    UnwindInitializeCacheMap = TRUE;
                }

                //
                //  Now call Cc to set the log handle for the file.
                //

                if (FlagOn( Scb->ScbState, SCB_STATE_MODIFIED_NO_WRITE ) &&
                    (Scb != Vcb->LogFileScb)) {

                    CcSetLogHandleForFile( UnwindStreamFile,
                                           Vcb->LogHandle,
                                           &LfsFlushToLsn );
                }

                //
                //  It is now safe to store the stream file in the Scb.  We wait
                //  until now because we don't want an unsafe tester to use the
                //  file object until the cache is initialized.
                //

                *FileObjectPtr = UnwindStreamFile;
            }

        } finally {

            DebugUnwind( NtfsCreateInternalAttributeStream );

            //
            //  Undo our work if an error occurred.
            //

            if (AbnormalTermination()) {

                //
                //  Uninitialize the cache file if we initialized it.
                //

                if (UnwindInitializeCacheMap) {

                    CcUninitializeCacheMap( UnwindStreamFile, NULL, NULL );
                }

                //
                //  Dereference the stream file if we created it.
                //

                if (UnwindStreamFile != NULL) {

                    //
                    //  Clear the internal file name constant
                    //

                    NtfsClearInternalFilename( UnwindStreamFile );

                    ObDereferenceObject( UnwindStreamFile );
                }
            }

            //
            //  Restore the Scb cleanup count.
            //

            if (DecrementScbCleanup) {

                InterlockedDecrement( &Scb->CleanupCount );
            }

            if (AcquiredMutex) {

                KeReleaseMutant( &StreamFileCreationMutex, IO_NO_INCREMENT, FALSE, FALSE );
            }

            DebugTrace( -1, Dbg, ("NtfsCreateInternalAttributeStream -> VOID\n") );
        }
    }

    return;
}


BOOLEAN
NtfsDeleteInternalAttributeStream (
    IN PSCB Scb,
    IN ULONG ForceClose,
    IN ULONG CompressedStreamOnly
    )

/*++

Routine Description:

    This routine is the inverse of NtfsCreateInternalAttributeStream.  It
    uninitializes the cache map and dereferences the stream file object.
    It is coded defensively, in case the stream file object does not exist
    or the cache map has not been initialized.

Arguments:

    Scb - Supplies the Scb for which the stream file is to be deleted.

    ForceClose - Indicates if we to immediately close everything down or
        if we are willing to let Mm slowly migrate things out.

    CompressedStreamOnly - Indicates if we only want to delete the compressed
        stream.

Return Value:

    BOOLEAN - TRUE if we dereference a file object, FALSE otherwise.

--*/

{
    PFILE_OBJECT FileObject;
#ifdef  COMPRESS_ON_WIRE
    PFILE_OBJECT FileObjectC;
#endif

    BOOLEAN Dereferenced = FALSE;

    PAGED_CODE();

    //
    //  We normally already have the paging Io resource.  If we do
    //  not, then it is typically some cleanup path of create or
    //  whatever.  This code assumes that if we cannot get the paging
    //  Io resource, then there is other activity still going on,
    //  and it is ok to not delete the stream!  For example, it could
    //  be the lazy writer, who definitely needs the stream.
    //

    if (
#ifdef  COMPRESS_ON_WIRE
        ((Scb->FileObject != NULL) || (Scb->Header.FileObjectC != NULL)) &&
#else
        (Scb->FileObject != NULL) &&
#endif
        ((Scb->Header.PagingIoResource == NULL) ||
         ExAcquireResourceExclusiveLite( Scb->Header.PagingIoResource, FALSE ))) {


        KeWaitForSingleObject( &StreamFileCreationMutex, Executive, KernelMode, FALSE, NULL );

        //
        //  Capture both file objects and clear the fields so no one else
        //  can access them.
        //

        if (CompressedStreamOnly) {

            FileObject = NULL;

        } else {

            FileObject = Scb->FileObject;
            Scb->FileObject = NULL;

            //
            //  Clear the internal file name constant
            //

            NtfsClearInternalFilename( FileObject );
        }

#ifdef  COMPRESS_ON_WIRE
        FileObjectC = Scb->Header.FileObjectC;
        Scb->Header.FileObjectC = NULL;
#endif

        KeReleaseMutant( &StreamFileCreationMutex, IO_NO_INCREMENT, FALSE, FALSE );

        if (Scb->Header.PagingIoResource != NULL) {
            ExReleaseResourceLite( Scb->Header.PagingIoResource );
        }

        //
        //  Now dereference each file object.
        //

        if (FileObject != NULL) {

            //
            //  We shouldn't be deleting the internal stream objects of the MFT & co, unless
            //  we are in the dismounting, restarting or mounting path.
            //

            ASSERT( (((PSCB) FileObject->FsContext)->Header.NodeTypeCode != NTFS_NTC_SCB_MFT) ||
                     FlagOn( Scb->Vcb->VcbState, VCB_STATE_RESTART_IN_PROGRESS ) ||
                     FlagOn( Scb->Vcb->VcbState, VCB_STATE_PERFORMED_DISMOUNT ) ||
                     !FlagOn( Scb->Vcb->VcbState, VCB_STATE_VOLUME_MOUNTED ) ||
                     Scb->Vcb->RootIndexScb == NULL );

            if (FileObject->PrivateCacheMap != NULL) {

                CcUninitializeCacheMap( FileObject,
                                        (ForceClose ? &Li0 : NULL),
                                        NULL );
            }

            ObDereferenceObject( FileObject );
            Dereferenced = TRUE;
        }

#ifdef  COMPRESS_ON_WIRE
        if (FileObjectC != NULL) {

            if (FileObjectC->PrivateCacheMap != NULL) {

                CcUninitializeCacheMap( FileObjectC,
                                        (ForceClose ? &Li0 : NULL),
                                        NULL );
            }

            //
            //  For the compressed stream, deallocate the additional
            //  section object pointers.
            //

            ObDereferenceObject( FileObjectC );
            Dereferenced = TRUE;
        }
#endif
    }

    return Dereferenced;
}


VOID
NtfsMapStream (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN LONGLONG FileOffset,
    IN ULONG Length,
    OUT PVOID *Bcb,
    OUT PVOID *Buffer
    )

/*++

Routine Description:

    This routine is called to map a range of bytes within the stream file
    for an Scb.  The allowed range to map is bounded by the allocation
    size for the Scb.  This operation is only valid on a non-resident
    Scb.

    TEMPCODE - The following need to be resolved for this routine.

        - Can the caller specify either an empty range or an invalid range.
          In that case we need to able to return the actual length of the
          mapped range.

Arguments:

    Scb - This is the Scb for the operation.

    FileOffset - This is the offset within the Scb where the data is to
                 be pinned.

    Length - This is the number of bytes to pin.

    Bcb - Returns a pointer to the Bcb for this range of bytes.

    Buffer - Returns a pointer to the range of bytes.  We can fault them in
             by touching them, but they aren't guaranteed to stay unless
             we pin them via the Bcb.

Return Value:

    None.

--*/

{
    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_SCB( Scb );
    ASSERT( Length != 0 );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsMapStream\n") );
    DebugTrace( 0, Dbg, ("Scb        = %08lx\n", Scb) );
    DebugTrace( 0, Dbg, ("FileOffset = %016I64x\n", FileOffset) );
    DebugTrace( 0, Dbg, ("Length     = %08lx\n", Length) );

    //
    //  The file object should already exist in the Scb.
    //

    ASSERT( Scb->FileObject != NULL );

    //
    //  If we are trying to go beyond the end of the allocation, assume
    //  we have some corruption.
    //

    if ((FileOffset + Length) > Scb->Header.AllocationSize.QuadPart) {

        NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Scb->Fcb );
    }

    //
    //  Call the cache manager to map the data.  This call may raise, but
    //  will never return an error (including CANT_WAIT).
    //

    if (!CcMapData( Scb->FileObject,
                    (PLARGE_INTEGER)&FileOffset,
                    Length,
                    TRUE,
                    Bcb,
                    Buffer )) {

        NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );
    }
#ifdef MAPCOUNT_DBG
    IrpContext->MapCount++;
#endif

    DebugTrace( 0, Dbg, ("Buffer -> %08lx\n", *Buffer) );
    DebugTrace( -1, Dbg, ("NtfsMapStream -> VOID\n") );

    return;
}


VOID
NtfsPinMappedData (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN LONGLONG FileOffset,
    IN ULONG Length,
    IN OUT PVOID *Bcb
    )

/*++

Routine Description:

    This routine is called to pin a previously mapped range of bytes
    within the stream file for an Scb, for the purpose of subsequently
    modifying this byte range.  The allowed range to map is
    bounded by the allocation size for the Scb.  This operation is only
    valid on a non-resident Scb.

    The data is guaranteed to stay at the same virtual address as previously
    returned from NtfsMapStream.

    TEMPCODE - The following need to be resolved for this routine.

        - Can the caller specify either an empty range or an invalid range.
          In that case we need to able to return the actual length of the
          mapped range.

Arguments:

    Scb - This is the Scb for the operation.

    FileOffset - This is the offset within the Scb where the data is to
                 be pinned.

    Length - This is the number of bytes to pin.

    Bcb - Returns a pointer to the Bcb for this range of bytes.

Return Value:

    None.

--*/

{
    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_SCB( Scb );
    ASSERT( Length != 0 );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsPinMappedData\n") );
    DebugTrace( 0, Dbg, ("Scb        = %08lx\n", Scb) );
    DebugTrace( 0, Dbg, ("FileOffset = %016I64x\n", FileOffset) );
    DebugTrace( 0, Dbg, ("Length     = %08lx\n", Length) );

    //
    //  The file object should already exist in the Scb.
    //

    ASSERT( Scb->FileObject != NULL );

    //
    //  If we are trying to go beyond the end of the allocation, assume
    //  we have some corruption.
    //

    if ((FileOffset + Length) > Scb->Header.AllocationSize.QuadPart) {

        NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Scb->Fcb );
    }

    //
    //  Call the cache manager to map the data.  This call may raise, but
    //  will never return an error (including CANT_WAIT).
    //

    if (!CcPinMappedData( Scb->FileObject,
                          (PLARGE_INTEGER)&FileOffset,
                          Length,
                          FlagOn( IrpContext->State, IRP_CONTEXT_STATE_WAIT ),
                          Bcb )) {

        NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );
    }

    DebugTrace( -1, Dbg, ("NtfsMapStream -> VOID\n") );

    return;
}


VOID
NtfsPinStream (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN LONGLONG FileOffset,
    IN ULONG Length,
    OUT PVOID *Bcb,
    OUT PVOID *Buffer
    )

/*++

Routine Description:

    This routine is called to pin a range of bytes within the stream file
    for an Scb.  The allowed range to pin is bounded by the allocation
    size for the Scb.  This operation is only valid on a non-resident
    Scb.

    TEMPCODE - The following need to be resolved for this routine.

        - Can the caller specify either an empty range or an invalid range.
          In that case we need to able to return the actual length of the
          pinned range.

Arguments:

    Scb - This is the Scb for the operation.

    FileOffset - This is the offset within the Scb where the data is to
                 be pinned.

    Length - This is the number of bytes to pin.

    Bcb - Returns a pointer to the Bcb for this range of bytes.

    Buffer - Returns a pointer to the range of bytes pinned in memory.

Return Value:

    None.

--*/

{
    NTSTATUS OldStatus = IrpContext->ExceptionStatus;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_SCB( Scb );
    ASSERT( Length != 0 );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsPinStream\n") );
    DebugTrace( 0, Dbg, ("Scb        = %08lx\n", Scb) );
    DebugTrace( 0, Dbg, ("FileOffset = %016I64x\n", FileOffset) );
    DebugTrace( 0, Dbg, ("Length     = %08lx\n", Length) );

    //
    //  The file object should already exist in the Scb.
    //

    ASSERT( Scb->FileObject != NULL );

    //
    //  If we are trying to go beyond the end of the allocation, assume
    //  we have some corruption.
    //

    if ((FileOffset + Length) > Scb->Header.AllocationSize.QuadPart) {

        NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Scb->Fcb );
    }

    //
    //  Call the cache manager to map the data.  This call may raise, or
    //  will return FALSE if waiting is required.
    //

    if (FlagOn( Scb->ScbPersist, SCB_PERSIST_USN_JOURNAL )) {

        FileOffset -= Scb->Vcb->UsnCacheBias;
    }

    if (!CcPinRead( Scb->FileObject,
                    (PLARGE_INTEGER)&FileOffset,
                    Length,
                    FlagOn( IrpContext->State, IRP_CONTEXT_STATE_WAIT ),
                    Bcb,
                    Buffer )) {

        ASSERT( !FlagOn( IrpContext->State, IRP_CONTEXT_STATE_WAIT ));

        //
        // Could not pin the data without waiting (cache miss).
        //

        NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );
    }

    //
    //  We don't want to propagate wether or not we hit eof. Its assumed the code pinning is
    //  already filesize synchronized
    //

    if (IrpContext->ExceptionStatus == STATUS_END_OF_FILE) {
        IrpContext->ExceptionStatus = OldStatus;
    }

#ifdef MAPCOUNT_DBG
    IrpContext->MapCount++;
#endif


    DebugTrace( 0, Dbg, ("Bcb -> %08lx\n", *Bcb) );
    DebugTrace( 0, Dbg, ("Buffer -> %08lx\n", *Buffer) );
    DebugTrace( -1, Dbg, ("NtfsMapStream -> VOID\n") );

    return;
}


VOID
NtfsPreparePinWriteStream (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN LONGLONG FileOffset,
    IN ULONG Length,
    IN BOOLEAN Zero,
    OUT PVOID *Bcb,
    OUT PVOID *Buffer
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_SCB( Scb );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsPreparePinWriteStream\n") );
    DebugTrace( 0, Dbg, ("Scb        = %08lx\n", Scb) );
    DebugTrace( 0, Dbg, ("FileOffset = %016I64x\n", FileOffset) );
    DebugTrace( 0, Dbg, ("Length     = %08lx\n", Length) );

    //
    //  The file object should already exist in the Scb.
    //

    ASSERT( Scb->FileObject != NULL );

    //
    //  If we are trying to go beyond the end of the allocation, assume
    //  we have some corruption.
    //

    if ((FileOffset + Length) > Scb->Header.AllocationSize.QuadPart) {

        NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Scb->Fcb );
    }

    //
    //  Call the cache manager to do it.  This call may raise, or
    //  will return FALSE if waiting is required.
    //

    if (!CcPreparePinWrite( Scb->FileObject,
                            (PLARGE_INTEGER)&FileOffset,
                            Length,
                            Zero,
                            FlagOn( IrpContext->State, IRP_CONTEXT_STATE_WAIT ),
                            Bcb,
                            Buffer )) {

        ASSERT( !FlagOn( IrpContext->State, IRP_CONTEXT_STATE_WAIT ));

        //
        // Could not pin the data without waiting (cache miss).
        //

        NtfsRaiseStatus( IrpContext, STATUS_CANT_WAIT, NULL, NULL );
    }
#ifdef MAPCOUNT_DBG
    IrpContext->MapCount++;
#endif

    DebugTrace( 0, Dbg, ("Bcb -> %08lx\n", *Bcb) );
    DebugTrace( 0, Dbg, ("Buffer -> %08lx\n", *Buffer) );
    DebugTrace( -1, Dbg, ("NtfsPreparePinWriteStream -> VOID\n") );

    return;
}


NTSTATUS
NtfsCompleteMdl (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine performs the function of completing Mdl read and write
    requests.  It should be called only from NtfsFsdRead and NtfsFsdWrite.

Arguments:

    Irp - Supplies the originating Irp.

Return Value:

    NTSTATUS - Will always be STATUS_PENDING or STATUS_SUCCESS.

--*/

{
    PFILE_OBJECT FileObject;
    PIO_STACK_LOCATION IrpSp;
    PNTFS_ADVANCED_FCB_HEADER Header;

    ASSERT( FlagOn( IrpContext->TopLevelIrpContext->State, IRP_CONTEXT_STATE_OWNS_TOP_LEVEL ));
    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsCompleteMdl\n") );
    DebugTrace( 0, Dbg, ("IrpContext = %08lx\n", IrpContext) );
    DebugTrace( 0, Dbg, ("Irp        = %08lx\n", Irp) );

    //
    // Do completion processing.
    //

    FileObject = IoGetCurrentIrpStackLocation( Irp )->FileObject;

    switch( IrpContext->MajorFunction ) {

    case IRP_MJ_READ:

        CcMdlReadComplete( FileObject, Irp->MdlAddress );
        break;

    case IRP_MJ_WRITE:

        try {

            PSCB Scb;
            VBO StartingVbo;
            LONGLONG ByteCount;
            LONGLONG ByteRange;
            BOOLEAN DoingIoAtEof = FALSE;

            ASSERT( FlagOn( IrpContext->State, IRP_CONTEXT_STATE_WAIT ));

            IrpSp = IoGetCurrentIrpStackLocation( Irp );
            Scb = (PSCB)(IrpSp->FileObject->FsContext);
            Header = &(Scb->Header);

            //
            //  Now synchronize with the FsRtl Header and Scb.
            //

            if (Header->PagingIoResource != NULL) {

                StartingVbo = IrpSp->Parameters.Write.ByteOffset.QuadPart;
                ByteCount = (LONGLONG) IrpSp->Parameters.Write.Length;
                ByteRange = StartingVbo + ByteCount + PAGE_SIZE - 1;
                ClearFlag( ((ULONG) ByteRange), PAGE_SIZE - 1 );

                ExAcquireResourceSharedLite( Header->PagingIoResource, TRUE );
                NtfsAcquireFsrtlHeader( Scb );

                //
                //  Now see if this is at EOF.
                //  Recursive flush will generate IO which ends on page boundary
                //  which is why we rounded the range
                //

                if (ByteRange > Header->ValidDataLength.QuadPart) {

                    //
                    //  Mark that we are writing to EOF.  If someone else is currently
                    //  writing to EOF, wait for them.
                    //

                    ASSERT( ByteRange - StartingVbo < MAXULONG );

                    DoingIoAtEof = !FlagOn( Header->Flags, FSRTL_FLAG_EOF_ADVANCE_ACTIVE ) ||
                                   NtfsWaitForIoAtEof( Header, (PLARGE_INTEGER)&StartingVbo, (ULONG)(ByteRange - StartingVbo) );

                    if (DoingIoAtEof) {

                        SetFlag( Header->Flags, FSRTL_FLAG_EOF_ADVANCE_ACTIVE );

#if (DBG || defined( NTFS_FREE_ASSERTS ))
                        ((PSCB) Header)->IoAtEofThread = (PERESOURCE_THREAD) ExGetCurrentResourceThread();
#endif
                        //
                        //  Store this in the IrpContext until commit or post.
                        //

                        IrpContext->CleanupStructure = Scb;
                    }
                }

                NtfsReleaseFsrtlHeader( Scb );
            }

            CcMdlWriteComplete( FileObject, &IrpSp->Parameters.Write.ByteOffset, Irp->MdlAddress );

        } finally {

            if (Header->PagingIoResource != NULL) {

                ExReleaseResourceLite( Header->PagingIoResource );
            }
        }

        break;

    default:

        DebugTrace( DEBUG_TRACE_ERROR, 0, ("Illegal Mdl Complete.\n") );

        ASSERTMSG("Illegal Mdl Complete, About to bugcheck ", FALSE);
        NtfsBugCheck( IrpContext->MajorFunction, 0, 0 );
    }

    //
    // Mdl is now deallocated.
    //

    Irp->MdlAddress = NULL;

    //
    //  Ignore errors.  CC has already cleaned up his structures.
    //

    IrpContext->ExceptionStatus = STATUS_SUCCESS;
    NtfsMinimumExceptionProcessing( IrpContext );

    //
    // Complete the request and exit right away.
    //

    NtfsCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );

    DebugTrace( -1, Dbg, ("NtfsCompleteMdl -> STATUS_SUCCESS\n") );

    return STATUS_SUCCESS;
}


BOOLEAN
NtfsZeroData (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PFILE_OBJECT FileObject,
    IN LONGLONG StartingZero,
    IN LONGLONG ByteCount,
    IN OUT PLONGLONG CommittedFileSize OPTIONAL
    )

/*++

Routine Description:

    This routine is called to zero a range of a file in order to
    advance valid data length.

Arguments:

    Scb - Scb for the stream to zero.

    FileObject - FileObject for the stream.

    StartingZero - Offset to begin the zero operation.

    ByteCount - Length of range to zero.

    CommittedFileSize - If we write the file sizes and commit the
        transaction then we want to let our caller know what
        point to roll back file size on a subsequent failure.  On entry
        it has the size our caller wants to roll back the file size to.
        On exit it has the new size to roll back to which takes into
        account any updates to the file size which have been logged.

Return Value:

    BOOLEAN - TRUE if the entire range was zeroed, FALSE if the request
        is broken up or the cache manager would block.

--*/

{
    LONGLONG Temp;

#ifdef  COMPRESS_ON_WIRE
    IO_STATUS_BLOCK IoStatus;
#endif

    ULONG SectorSize;

    BOOLEAN Finished;
    BOOLEAN CompleteZero = TRUE;
    BOOLEAN ScbAcquired = FALSE;

    PVCB Vcb = Scb->Vcb;

    LONGLONG ZeroStart;
    LONGLONG BeyondZeroEnd;
    ULONG CompressionUnit = Scb->CompressionUnit;

    BOOLEAN Wait;

    PAGED_CODE();

    Wait = (BOOLEAN) FlagOn( IrpContext->State, IRP_CONTEXT_STATE_WAIT );

    SectorSize = Vcb->BytesPerSector;

    //
    //  We may be able to simplify the zero operation (sparse file or when writing
    //  compressed) by deallocating large ranges of the file.  Otherwise we have to
    //  generate zeroes for the entire range.  If that is the case we want to split
    //  this operation up.
    //

    if ((ByteCount > MAX_ZERO_THRESHOLD) &&
        !FlagOn( Scb->ScbState, SCB_STATE_WRITE_COMPRESSED ) &&
        !FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_SPARSE )) {

        ByteCount = MAX_ZERO_THRESHOLD;
        CompleteZero = FALSE;
    }

    ZeroStart = StartingZero + (SectorSize - 1);
    (ULONG)ZeroStart &= ~(SectorSize - 1);

    BeyondZeroEnd = StartingZero + ByteCount + (SectorSize - 1);
    (ULONG)BeyondZeroEnd &= ~(SectorSize - 1);

    //
    //  We must flush the first compression unit in case it is partially populated
    //  in the compressed stream.
    //

#ifdef  COMPRESS_ON_WIRE

    if ((Scb->NonpagedScb->SegmentObjectC.DataSectionObject != NULL) &&
        ((StartingZero & (CompressionUnit - 1)) != 0)) {

        (ULONG)StartingZero &= ~(CompressionUnit - 1);
        CcFlushCache( &Scb->NonpagedScb->SegmentObjectC,
                      (PLARGE_INTEGER)&StartingZero,
                      CompressionUnit,
                      &IoStatus );

        if (!NT_SUCCESS(IoStatus.Status)) {
            NtfsNormalizeAndRaiseStatus( IrpContext, IoStatus.Status, STATUS_UNEXPECTED_IO_ERROR );
        }
    }
#endif

    //
    //  If this is a sparse or compressed file and we are zeroing a lot, then let's
    //  just delete the space instead of writing tons of zeros and deleting
    //  the space in the noncached path!  If we are currently decompressing
    //  a compressed file we can't take this path.
    //

    if ((FlagOn( Scb->ScbState, SCB_STATE_WRITE_COMPRESSED ) ||
         FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_SPARSE )) &&
        (ByteCount > (Scb->CompressionUnit * 2))) {

        //
        //  Find the end of the first compression unit being zeroed.
        //

        Temp = ZeroStart + (CompressionUnit - 1);
        (ULONG)Temp &= ~(CompressionUnit - 1);

        //
        //  Zero the first compression unit.
        //

        if ((ULONG)Temp != (ULONG)ZeroStart) {

            Finished = CcZeroData( FileObject, (PLARGE_INTEGER)&ZeroStart, (PLARGE_INTEGER)&Temp, Wait );

            if (!Finished) {return FALSE;}

            ZeroStart = Temp;
        }

        //
        //  Now delete all of the compression units in between.
        //

        //
        //  Calculate the start of the last compression unit in bytes.
        //

        Temp = BeyondZeroEnd;
        (ULONG)Temp &= ~(CompressionUnit - 1);

        //
        //  If the caller has not already started a transaction (like write.c),
        //  then let's just do the delete as an atomic action.
        //

        if (!NtfsIsExclusiveScb( Scb )) {

            NtfsAcquireExclusiveScb( IrpContext, Scb );
            ScbAcquired = TRUE;

            if (ARGUMENT_PRESENT( CommittedFileSize )) {

                NtfsMungeScbSnapshot( IrpContext, Scb, *CommittedFileSize );
            }
        }

        try {

            //
            //  Delete the space.
            //

            NtfsDeleteAllocation( IrpContext,
                                  FileObject,
                                  Scb,
                                  LlClustersFromBytes( Vcb, ZeroStart ),
                                  LlClustersFromBytesTruncate( Vcb, Temp ) - 1,
                                  TRUE,
                                  TRUE );

            //
            //  If we didn't raise then update the Scb values for compressed files.
            //

            if (FlagOn( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK )) {
                Scb->ValidDataToDisk = Temp;
            }

            //
            //  If we succeed, commit the atomic action.  Release all of the exclusive
            //  resources if our user explicitly acquired the Fcb here.
            //

            if (ScbAcquired) {
                NtfsCheckpointCurrentTransaction( IrpContext );

                if (ARGUMENT_PRESENT( CommittedFileSize )) {

                    ASSERT( Scb->ScbSnapshot != NULL );
                    *CommittedFileSize = Scb->ScbSnapshot->FileSize;
                }

                while (!IsListEmpty( &IrpContext->ExclusiveFcbList )) {

                    NtfsReleaseFcb( IrpContext,
                                    (PFCB)CONTAINING_RECORD( IrpContext->ExclusiveFcbList.Flink,
                                                             FCB,
                                                             ExclusiveFcbLinks ));
                }

                ClearFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_RELEASE_USN_JRNL |
                                              IRP_CONTEXT_FLAG_RELEASE_MFT );

                ScbAcquired = FALSE;
            }

            if (FlagOn( Scb->ScbState, SCB_STATE_UNNAMED_DATA )) {

                Scb->Fcb->Info.AllocatedLength = Scb->TotalAllocated;
                SetFlag( Scb->Fcb->InfoFlags, FCB_INFO_CHANGED_ALLOC_SIZE );
            }

        } finally {

            if (ScbAcquired) {
                NtfsReleaseScb( IrpContext, Scb );
            }
        }

        //
        //  Zero the beginning of the last compression unit.
        //

        if ((ULONG)Temp != (ULONG)BeyondZeroEnd) {

            Finished = CcZeroData( FileObject, (PLARGE_INTEGER)&Temp, (PLARGE_INTEGER)&BeyondZeroEnd, Wait );

            if (!Finished) {return FALSE;}

            BeyondZeroEnd = Temp;
        }

        return TRUE;
    }

    //
    //  If we were called to just zero part of a sector we are in trouble.
    //

    if (ZeroStart == BeyondZeroEnd) {

        return TRUE;
    }

    Finished = CcZeroData( FileObject,
                           (PLARGE_INTEGER)&ZeroStart,
                           (PLARGE_INTEGER)&BeyondZeroEnd,
                           Wait );

    //
    //  If we are breaking this request up then commit the current
    //  transaction (including updating the valid data length in
    //  in the Scb) and return FALSE.
    //

    if (Finished && !CompleteZero) {

        //
        //  Synchronize the valid data length change using the mutex.
        //

        ExAcquireFastMutex( Scb->Header.FastMutex );
        Scb->Header.ValidDataLength.QuadPart = BeyondZeroEnd;

        //
        //  Move the rollback point up to include the range of zeroed
        //  data.
        //

        if (ARGUMENT_PRESENT( CommittedFileSize )) {

            if (BeyondZeroEnd > *CommittedFileSize) {

                *CommittedFileSize = BeyondZeroEnd;
            }
        }

        ASSERT( Scb->Header.ValidDataLength.QuadPart <= Scb->Header.FileSize.QuadPart );

        ExReleaseFastMutex( Scb->Header.FastMutex );
        NtfsCheckpointCurrentTransaction( IrpContext );
        return FALSE;
    }

    return Finished;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\ntfs\attrsup.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    AttrSup.c

Abstract:

    This module implements the attribute management routines for Ntfs

Author:

    David Goebel        [DavidGoe]          25-June-1991
    Tom Miller          [TomM]              9-November-1991

Revision History:

--*/

#include "NtfsProc.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (NTFS_BUG_CHECK_ATTRSUP)

//
//  Local debug trace level
//

#define Dbg                              (DEBUG_TRACE_ATTRSUP)

//
//  Define a tag for general pool allocations from this module
//

#undef MODULE_POOL_TAG
#define MODULE_POOL_TAG                  ('AFtN')

#define NTFS_MAX_ZERO_RANGE              (0x40000000)

#define NTFS_CHECK_INSTANCE_ROLLOVER     (0xf000)

//
//
//  Internal support routines
//

BOOLEAN
NtfsFindInFileRecord (
    IN PIRP_CONTEXT IrpContext,
    IN PATTRIBUTE_RECORD_HEADER Attribute,
    OUT PATTRIBUTE_RECORD_HEADER *ReturnAttribute,
    IN ATTRIBUTE_TYPE_CODE QueriedTypeCode,
    IN PCUNICODE_STRING QueriedName OPTIONAL,
    IN BOOLEAN IgnoreCase,
    IN PVOID QueriedValue OPTIONAL,
    IN ULONG QueriedValueLength
    );

//
//  Internal support routines for managing file record space
//

VOID
NtfsCreateNonresidentWithValue (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN ATTRIBUTE_TYPE_CODE AttributeTypeCode,
    IN PUNICODE_STRING AttributeName OPTIONAL,
    IN PVOID Value OPTIONAL,
    IN ULONG ValueLength,
    IN USHORT AttributeFlags,
    IN BOOLEAN WriteClusters,
    IN PSCB ThisScb OPTIONAL,
    IN BOOLEAN LogIt,
    IN PATTRIBUTE_ENUMERATION_CONTEXT Context
    );

BOOLEAN
NtfsGetSpaceForAttribute (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN ULONG Length,
    IN OUT PATTRIBUTE_ENUMERATION_CONTEXT Context
    );

VOID
MakeRoomForAttribute (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN ULONG SizeNeeded,
    IN OUT PATTRIBUTE_ENUMERATION_CONTEXT Context
    );

VOID
FindLargestAttributes (
    IN PFILE_RECORD_SEGMENT_HEADER FileRecord,
    IN ULONG Number,
    OUT PATTRIBUTE_RECORD_HEADER *AttributeArray
    );

LONGLONG
MoveAttributeToOwnRecord (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PATTRIBUTE_RECORD_HEADER Attribute,
    IN OUT PATTRIBUTE_ENUMERATION_CONTEXT Context,
    OUT PBCB *NewBcb OPTIONAL,
    OUT PFILE_RECORD_SEGMENT_HEADER *NewFileRecord OPTIONAL
    );

VOID
SplitFileRecord (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN ULONG SizeNeeded,
    IN OUT PATTRIBUTE_ENUMERATION_CONTEXT Context
    );

PFILE_RECORD_SEGMENT_HEADER
NtfsCloneFileRecord (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN BOOLEAN MftData,
    OUT PBCB *Bcb,
    OUT PMFT_SEGMENT_REFERENCE FileReference
    );

ULONG
GetSizeForAttributeList (
    IN PFILE_RECORD_SEGMENT_HEADER FileRecord
    );

VOID
CreateAttributeList (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PFILE_RECORD_SEGMENT_HEADER FileRecord1,
    IN PFILE_RECORD_SEGMENT_HEADER FileRecord2 OPTIONAL,
    IN MFT_SEGMENT_REFERENCE SegmentReference2,
    IN PATTRIBUTE_RECORD_HEADER OldPosition OPTIONAL,
    IN ULONG SizeOfList,
    IN OUT PATTRIBUTE_ENUMERATION_CONTEXT ListContext
    );

VOID
UpdateAttributeListEntry (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PMFT_SEGMENT_REFERENCE OldFileReference,
    IN USHORT OldInstance,
    IN PMFT_SEGMENT_REFERENCE NewFileReference,
    IN USHORT NewInstance,
    IN OUT PATTRIBUTE_ENUMERATION_CONTEXT ListContext
    );

VOID
NtfsAddNameToParent (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB ParentScb,
    IN PFCB ThisFcb,
    IN BOOLEAN IgnoreCase,
    IN PBOOLEAN LogIt,
    IN PFILE_NAME FileNameAttr,
    OUT PUCHAR FileNameFlags,
    OUT PQUICK_INDEX QuickIndex OPTIONAL,
    IN PNAME_PAIR NamePair OPTIONAL,
    IN PINDEX_CONTEXT IndexContext OPTIONAL
    );

VOID
NtfsAddDosOnlyName (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB ParentScb,
    IN PFCB ThisFcb,
    IN UNICODE_STRING FileName,
    IN BOOLEAN LogIt,
    IN PUNICODE_STRING SuggestedDosName OPTIONAL
    );

BOOLEAN
NtfsAddTunneledNtfsOnlyName (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB ParentScb,
    IN PFCB ThisFcb,
    IN PUNICODE_STRING FileName,
    IN PBOOLEAN LogIt
    );

USHORT
NtfsScanForFreeInstance (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_RECORD_SEGMENT_HEADER FileRecord
    );

VOID
NtfsMergeFileRecords (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN BOOLEAN RestoreContext,
    IN PATTRIBUTE_ENUMERATION_CONTEXT Context
    );

NTSTATUS
NtfsCheckLocksInZeroRange (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PSCB Scb,
    IN PFILE_OBJECT FileObject,
    IN PLONGLONG StartingOffset,
    IN ULONG ByteCount
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, CreateAttributeList)
#pragma alloc_text(PAGE, FindLargestAttributes)
#pragma alloc_text(PAGE, GetSizeForAttributeList)
#pragma alloc_text(PAGE, MakeRoomForAttribute)
#pragma alloc_text(PAGE, MoveAttributeToOwnRecord)
#pragma alloc_text(PAGE, NtfsAddAttributeAllocation)
#pragma alloc_text(PAGE, NtfsAddDosOnlyName)
#pragma alloc_text(PAGE, NtfsAddLink)
#pragma alloc_text(PAGE, NtfsAddNameToParent)
#pragma alloc_text(PAGE, NtfsAddToAttributeList)
#pragma alloc_text(PAGE, NtfsAddTunneledNtfsOnlyName)
#pragma alloc_text(PAGE, NtfsChangeAttributeSize)
#pragma alloc_text(PAGE, NtfsChangeAttributeValue)
#pragma alloc_text(PAGE, NtfsCheckLocksInZeroRange)
#pragma alloc_text(PAGE, NtfsCleanupAttributeContext)
#pragma alloc_text(PAGE, NtfsCloneFileRecord)
#pragma alloc_text(PAGE, NtfsConvertToNonresident)
#pragma alloc_text(PAGE, NtfsCreateAttributeWithAllocation)
#pragma alloc_text(PAGE, NtfsCreateAttributeWithValue)
#pragma alloc_text(PAGE, NtfsCreateNonresidentWithValue)
#pragma alloc_text(PAGE, NtfsDeleteAllocationFromRecord)
#pragma alloc_text(PAGE, NtfsDeleteAttributeAllocation)
#pragma alloc_text(PAGE, NtfsDeleteAttributeRecord)
#pragma alloc_text(PAGE, NtfsDeleteFile)
#pragma alloc_text(PAGE, NtfsDeleteFromAttributeList)
#pragma alloc_text(PAGE, NtfsFindInFileRecord)
#pragma alloc_text(PAGE, NtfsGetAttributeTypeCode)
#pragma alloc_text(PAGE, NtfsGetSpaceForAttribute)
#pragma alloc_text(PAGE, NtfsGrowStandardInformation)
#pragma alloc_text(PAGE, NtfsInitializeFileInExtendDirectory)
#pragma alloc_text(PAGE, NtfsIsFileDeleteable)
#pragma alloc_text(PAGE, NtfsLookupEntry)
#pragma alloc_text(PAGE, NtfsLookupExternalAttribute)
#pragma alloc_text(PAGE, NtfsLookupInFileRecord)
#pragma alloc_text(PAGE, NtfsMapAttributeValue)
#pragma alloc_text(PAGE, NtfsMergeFileRecords)
#pragma alloc_text(PAGE, NtfsModifyAttributeFlags)
#pragma alloc_text(PAGE, NtfsPrepareForUpdateDuplicate)
#pragma alloc_text(PAGE, NtfsRemoveLink)
#pragma alloc_text(PAGE, NtfsRemoveLinkViaFlags)
#pragma alloc_text(PAGE, NtfsRestartChangeAttributeSize)
#pragma alloc_text(PAGE, NtfsRestartChangeMapping)
#pragma alloc_text(PAGE, NtfsRestartChangeValue)
#pragma alloc_text(PAGE, NtfsRestartInsertAttribute)
#pragma alloc_text(PAGE, NtfsRestartRemoveAttribute)
#pragma alloc_text(PAGE, NtfsRestartWriteEndOfFileRecord)
#pragma alloc_text(PAGE, NtfsRewriteMftMapping)
#pragma alloc_text(PAGE, NtfsScanForFreeInstance)
#pragma alloc_text(PAGE, NtfsSetSparseStream)
#pragma alloc_text(PAGE, NtfsSetTotalAllocatedField)
#pragma alloc_text(PAGE, NtfsUpdateDuplicateInfo)
#pragma alloc_text(PAGE, NtfsUpdateFcb)
#pragma alloc_text(PAGE, NtfsUpdateFcbInfoFromDisk)
#pragma alloc_text(PAGE, NtfsUpdateFileNameFlags)
#pragma alloc_text(PAGE, NtfsUpdateLcbDuplicateInfo)
#pragma alloc_text(PAGE, NtfsUpdateScbFromAttribute)
#pragma alloc_text(PAGE, NtfsUpdateStandardInformation)
#pragma alloc_text(PAGE, NtfsWriteFileSizes)
#pragma alloc_text(PAGE, NtfsZeroRangeInStream)
#pragma alloc_text(PAGE, SplitFileRecord)
#pragma alloc_text(PAGE, UpdateAttributeListEntry)
#endif


ATTRIBUTE_TYPE_CODE
NtfsGetAttributeTypeCode (
    IN PVCB Vcb,
    IN PUNICODE_STRING AttributeTypeName
    )

/*++

Routine Description:

    This routine returns the attribute type code for a given attribute name.

Arguments:

    Vcb - Pointer to the Vcb from which to consult the attribute definitions.

    AttributeTypeName - A string containing the attribute type name to be
                        looked up.

Return Value:

    The attribute type code corresponding to the specified name, or 0 if the
    attribute type name does not exist.

--*/

{
    PATTRIBUTE_DEFINITION_COLUMNS AttributeDef = Vcb->AttributeDefinitions;
    ATTRIBUTE_TYPE_CODE AttributeTypeCode = $UNUSED;

    UNICODE_STRING AttributeCodeName;

    PAGED_CODE();

    //
    //  Loop through all of the definitions looking for a name match.
    //

    while (AttributeDef->AttributeName[0] != 0) {

        RtlInitUnicodeString( &AttributeCodeName, AttributeDef->AttributeName );

        //
        //  The name lengths must match and the characters match exactly.
        //

        if ((AttributeCodeName.Length == AttributeTypeName->Length)
            && (RtlEqualMemory( AttributeTypeName->Buffer,
                                AttributeDef->AttributeName,
                                AttributeTypeName->Length ))) {

            AttributeTypeCode = AttributeDef->AttributeTypeCode;
            break;
        }

        //
        //  Lets go to the next attribute column.
        //

        AttributeDef += 1;
    }

    return AttributeTypeCode;
}


VOID
NtfsUpdateScbFromAttribute (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PSCB Scb,
    IN PATTRIBUTE_RECORD_HEADER AttrHeader OPTIONAL
    )

/*++

Routine Description:

    This routine fills in the header of an Scb with the
    information from the attribute for this Scb.

Arguments:

    Scb - Supplies the SCB to update

    AttrHeader - Optionally provides the attribute to update from

Return Value:

    None

--*/

{
    ATTRIBUTE_ENUMERATION_CONTEXT AttrContext;

    BOOLEAN CleanupAttrContext = FALSE;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsUpdateScbFromAttribute:  Entered\n") );

    //
    //  If the attribute has been deleted, we can return immediately
    //  claiming that the Scb has been initialized.
    //

    if (FlagOn( Scb->ScbState, SCB_STATE_ATTRIBUTE_DELETED )) {

        SetFlag( Scb->ScbState, SCB_STATE_HEADER_INITIALIZED );
        DebugTrace( -1, Dbg, ("NtfsUpdateScbFromAttribute:  Exit\n") );

        return;
    }

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  If we weren't given the attribute header, we look it up now.
        //

        if (!ARGUMENT_PRESENT( AttrHeader )) {

            NtfsInitializeAttributeContext( &AttrContext );

            CleanupAttrContext = TRUE;

            NtfsLookupAttributeForScb( IrpContext, Scb, NULL, &AttrContext );

            AttrHeader = NtfsFoundAttribute( &AttrContext );
        }

        //
        //  Check whether this is resident or nonresident
        //

        if (NtfsIsAttributeResident( AttrHeader )) {

            //
            //  Verify the resident value length.
            //

            if (AttrHeader->Form.Resident.ValueLength > AttrHeader->RecordLength - AttrHeader->Form.Resident.ValueOffset) {

                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Scb->Fcb );
            }

            Scb->Header.AllocationSize.QuadPart = AttrHeader->Form.Resident.ValueLength;

            if (!FlagOn( Scb->ScbState, SCB_STATE_FILE_SIZE_LOADED )) {

                Scb->Header.ValidDataLength =
                Scb->Header.FileSize = Scb->Header.AllocationSize;
                SetFlag(Scb->ScbState, SCB_STATE_FILE_SIZE_LOADED);
            }

#ifdef SYSCACHE_DEBUG
            if (ScbIsBeingLogged( Scb )) {
                FsRtlLogSyscacheEvent( Scb, SCE_VDL_CHANGE, SCE_FLAG_UPDATE_FROM_DISK, Scb->Header.ValidDataLength.QuadPart, 0, 0 );
            }
#endif

            Scb->Header.AllocationSize.LowPart =
              QuadAlign( Scb->Header.AllocationSize.LowPart );

            Scb->TotalAllocated = Scb->Header.AllocationSize.QuadPart;

            //
            //  Set the resident flag in the Scb.
            //

            SetFlag( Scb->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT );

        } else {

            VCN FileClusters;
            VCN AllocationClusters;

            if (!FlagOn(Scb->ScbState, SCB_STATE_FILE_SIZE_LOADED)) {

                Scb->Header.ValidDataLength.QuadPart = AttrHeader->Form.Nonresident.ValidDataLength;
                Scb->Header.FileSize.QuadPart = AttrHeader->Form.Nonresident.FileSize;
                SetFlag(Scb->ScbState, SCB_STATE_FILE_SIZE_LOADED);

                if (FlagOn( AttrHeader->Flags, ATTRIBUTE_FLAG_COMPRESSION_MASK )) {
                    Scb->ValidDataToDisk = AttrHeader->Form.Nonresident.ValidDataLength;
                } else {
                    Scb->ValidDataToDisk = 0;
                }
            }

#ifdef SYSCACHE_DEBUG
            if (ScbIsBeingLogged( Scb )) {
                FsRtlLogSyscacheEvent( Scb, SCE_VDL_CHANGE, SCE_FLAG_UPDATE_FROM_DISK, Scb->Header.ValidDataLength.QuadPart, 1, 0 );
            }
#endif

            Scb->Header.AllocationSize.QuadPart = AttrHeader->Form.Nonresident.AllocatedLength;
            Scb->TotalAllocated = Scb->Header.AllocationSize.QuadPart;

            //
            //  Sanity Checks filesize lengths
            //

            if ((Scb->Header.FileSize.QuadPart < 0) ||
                (Scb->Header.ValidDataLength.QuadPart < 0 ) ||
                (Scb->Header.AllocationSize.QuadPart < 0) ||
                (Scb->Header.FileSize.QuadPart > Scb->Header.AllocationSize.QuadPart)) {

                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Scb->Fcb );
            }


            if (FlagOn( AttrHeader->Flags,
                        ATTRIBUTE_FLAG_COMPRESSION_MASK | ATTRIBUTE_FLAG_SPARSE )) {

                Scb->TotalAllocated = AttrHeader->Form.Nonresident.TotalAllocated;

                if (Scb->TotalAllocated < 0) {

                    Scb->TotalAllocated = 0;

                } else if (Scb->TotalAllocated > Scb->Header.AllocationSize.QuadPart) {

                    Scb->TotalAllocated = Scb->Header.AllocationSize.QuadPart;
                }
            }

            ClearFlag( Scb->ScbState, SCB_STATE_ATTRIBUTE_RESIDENT );

            //
            //  Get the size of the compression unit.
            //

            ASSERT((AttrHeader->Form.Nonresident.CompressionUnit == 0) ||
                   (AttrHeader->Form.Nonresident.CompressionUnit == NTFS_CLUSTERS_PER_COMPRESSION) ||
                   FlagOn( AttrHeader->Flags, ATTRIBUTE_FLAG_SPARSE ));

            Scb->CompressionUnit = 0;
            Scb->CompressionUnitShift = 0;

            if ((AttrHeader->Form.Nonresident.CompressionUnit != 0) &&
                (AttrHeader->Form.Nonresident.CompressionUnit < 31)) {

                Scb->CompressionUnit = BytesFromClusters( Scb->Vcb,
                                                          1 << AttrHeader->Form.Nonresident.CompressionUnit );
                Scb->CompressionUnitShift = AttrHeader->Form.Nonresident.CompressionUnit;

                ASSERT( NtfsIsTypeCodeCompressible( Scb->AttributeTypeCode ));
            }

            //
            //  Compute the clusters for the file and its allocation.
            //

            AllocationClusters = LlClustersFromBytes( Scb->Vcb, Scb->Header.AllocationSize.QuadPart );

            if (Scb->CompressionUnit == 0) {

                FileClusters = LlClustersFromBytes(Scb->Vcb, Scb->Header.FileSize.QuadPart);

            } else {

                FileClusters = Scb->Header.FileSize.QuadPart + Scb->CompressionUnit - 1;
                FileClusters &= ~((ULONG_PTR)Scb->CompressionUnit - 1);
            }

            //
            //  If allocated clusters are greater than file clusters, mark
            //  the Scb to truncate on close.
            //

            if (AllocationClusters > FileClusters) {

                SetFlag( Scb->ScbState, SCB_STATE_TRUNCATE_ON_CLOSE );
            }
        }

        //
        //  Update compression information if this is not an index
        //

        if (Scb->AttributeTypeCode != $INDEX_ALLOCATION) {

            Scb->AttributeFlags = AttrHeader->Flags;

            if (FlagOn( AttrHeader->Flags,
                        ATTRIBUTE_FLAG_COMPRESSION_MASK | ATTRIBUTE_FLAG_SPARSE )) {

                //
                //  For sparse files indicate CC should flush when they're mapped
                //  to keep reservations accurate
                //

                if (FlagOn( AttrHeader->Flags, ATTRIBUTE_FLAG_SPARSE )) {

                    SetFlag( Scb->Header.Flags2, FSRTL_FLAG2_PURGE_WHEN_MAPPED );
                }

                //
                //  Only support compression on data streams.
                //

                if ((Scb->AttributeTypeCode != $DATA) &&
                    FlagOn( AttrHeader->Flags, ATTRIBUTE_FLAG_COMPRESSION_MASK )) {

                    ClearFlag( Scb->ScbState, SCB_STATE_WRITE_COMPRESSED );
                    Scb->CompressionUnit = 0;
                    Scb->CompressionUnitShift = 0;
                    ClearFlag( Scb->AttributeFlags, ATTRIBUTE_FLAG_COMPRESSION_MASK );

                } else {

                    ASSERT( NtfsIsTypeCodeCompressible( Scb->AttributeTypeCode ));

                    //
                    //  Do not try to infer whether we are writing compressed or not
                    //  if we are actively changing the compression state.
                    //

                    if (!FlagOn( Scb->ScbState, SCB_STATE_REALLOCATE_ON_WRITE )) {

                        SetFlag( Scb->ScbState, SCB_STATE_WRITE_COMPRESSED );

                        if (!FlagOn( AttrHeader->Flags, ATTRIBUTE_FLAG_COMPRESSION_MASK )) {

                            ClearFlag( Scb->ScbState, SCB_STATE_WRITE_COMPRESSED );
                        }
                    }

                    //
                    //  If the attribute is resident, then we will use our current
                    //  default.
                    //

                    if (Scb->CompressionUnit == 0) {

                        Scb->CompressionUnit = BytesFromClusters( Scb->Vcb, 1 << NTFS_CLUSTERS_PER_COMPRESSION );
                        Scb->CompressionUnitShift = NTFS_CLUSTERS_PER_COMPRESSION;

                        while (Scb->CompressionUnit > Scb->Vcb->SparseFileUnit) {

                            Scb->CompressionUnit >>= 1;
                            Scb->CompressionUnitShift -= 1;
                        }
                    }
                }

            } else {

                //
                //  If this file is NOT compressed or sparse, the WRITE_COMPRESSED flag
                //  has no reason to be ON, irrespective of the REALLOCATE_ON_WRITE flag.
                //  If we don't clear the flag here unconditionally, we can end up with Scbs with
                //  WRITE_COMPRESSED flags switched on, but CompressionUnits of 0.
                //

                ClearFlag( Scb->ScbState, SCB_STATE_WRITE_COMPRESSED );

                //
                //  Make sure compression unit is 0
                //

                Scb->CompressionUnit = 0;
                Scb->CompressionUnitShift = 0;
            }
        }

        //
        //  If the compression unit is non-zero or this is a resident file
        //  then set the flag in the common header for the Modified page writer.
        //

        NtfsAcquireFsrtlHeader( Scb );
        if (NodeType( Scb ) == NTFS_NTC_SCB_DATA) {

            Scb->Header.IsFastIoPossible = NtfsIsFastIoPossible( Scb );

        } else {

            Scb->Header.IsFastIoPossible = FastIoIsNotPossible;
        }

        NtfsReleaseFsrtlHeader( Scb );

        //
        //  Set the flag indicating this is the data attribute.
        //

        if (Scb->AttributeTypeCode == $DATA
            && Scb->AttributeName.Length == 0) {

            SetFlag( Scb->ScbState, SCB_STATE_UNNAMED_DATA );

        } else {

            ClearFlag( Scb->ScbState, SCB_STATE_UNNAMED_DATA );
        }

        SetFlag( Scb->ScbState, SCB_STATE_HEADER_INITIALIZED );

        if (NtfsIsExclusiveScb(Scb)) {

            NtfsSnapshotScb( IrpContext, Scb );
        }

    } finally {

        DebugUnwind( NtfsUpdateScbFromAttribute );

        //
        //  Cleanup the attribute context.
        //

        if (CleanupAttrContext) {

            NtfsCleanupAttributeContext( IrpContext, &AttrContext );
        }

        DebugTrace( -1, Dbg, ("NtfsUpdateScbFromAttribute:  Exit\n") );
    }

    return;
}


BOOLEAN
NtfsUpdateFcbInfoFromDisk (
    IN PIRP_CONTEXT IrpContext,
    IN BOOLEAN LoadSecurity,
    IN OUT PFCB Fcb,
    OUT POLD_SCB_SNAPSHOT UnnamedDataSizes OPTIONAL
    )

/*++

Routine Description:

    This routine is called to update an Fcb from the on-disk attributes
    for a file.  We read the standard information and ea information.
    The first one must be present, we raise if not.  The other does not
    have to exist.  If this is not a directory, then we also need the
    size of the unnamed data attribute.

Arguments:

    LoadSecurity - Indicates if we should load the security for this file
        if not already present.

    Fcb - This is the Fcb to update.

    UnnamedDataSizes - If specified, then we store the details of the unnamed
        data attribute as we encounter it.

Return Value:

    TRUE - if we updated the unnamedatasizes

--*/

{
    ATTRIBUTE_ENUMERATION_CONTEXT AttrContext;
    PATTRIBUTE_RECORD_HEADER AttributeHeader;
    BOOLEAN FoundEntry;
    BOOLEAN CorruptDisk = FALSE;
    BOOLEAN UpdatedNamedDataSizes = FALSE;

    PBCB Bcb = NULL;

    PDUPLICATED_INFORMATION Info;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsUpdateFcbInfoFromDisk:  Entered\n") );

    NtfsInitializeAttributeContext( &AttrContext );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Look for standard information.  This routine assumes it must be
        //  the first attribute.
        //

        if (FoundEntry = NtfsLookupAttribute( IrpContext,
                                              Fcb,
                                              &Fcb->FileReference,
                                              &AttrContext )) {

            //
            //  Verify that we found the standard information attribute.
            //

            AttributeHeader = NtfsFoundAttribute( &AttrContext );

            if (AttributeHeader->TypeCode != $STANDARD_INFORMATION) {

                try_return( CorruptDisk = TRUE );
            }

        } else {

            try_return( CorruptDisk = TRUE );
        }

        Info = &Fcb->Info;

        //
        //  Copy out the standard information values.
        //

        {
            PSTANDARD_INFORMATION StandardInformation;
            StandardInformation = (PSTANDARD_INFORMATION) NtfsAttributeValue( AttributeHeader );

            Info->CreationTime = StandardInformation->CreationTime;
            Info->LastModificationTime = StandardInformation->LastModificationTime;
            Info->LastChangeTime = StandardInformation->LastChangeTime;
            Info->LastAccessTime = StandardInformation->LastAccessTime;
            Info->FileAttributes = StandardInformation->FileAttributes;

            if (AttributeHeader->Form.Resident.ValueLength >=
                sizeof(STANDARD_INFORMATION)) {

                Fcb->OwnerId = StandardInformation->OwnerId;
                Fcb->SecurityId = StandardInformation->SecurityId;

                Fcb->Usn = StandardInformation->Usn;
                if (FlagOn( Fcb->Vcb->VcbState, VCB_STATE_USN_DELETE )) {

                    Fcb->Usn = 0;
                }

                SetFlag(Fcb->FcbState, FCB_STATE_LARGE_STD_INFO);
            }

        }

        Fcb->CurrentLastAccess = Info->LastAccessTime;

        //
        //  We initialize the fields that describe the EaSize or the tag of a reparse point.
        //  ReparsePointTag is a ULONG that is the union of  PackedEaSize  and  Reserved.
        //

        Info->ReparsePointTag = 0;

        //
        //  We get the FILE_NAME_INDEX_PRESENT bit by reading the
        //  file record.
        //

        if (FlagOn( NtfsContainingFileRecord( &AttrContext )->Flags,
                    FILE_FILE_NAME_INDEX_PRESENT )) {

            SetFlag( Info->FileAttributes, DUP_FILE_NAME_INDEX_PRESENT );

        } else {

            ClearFlag( Info->FileAttributes, DUP_FILE_NAME_INDEX_PRESENT );
        }

        //
        //  Ditto for the VIEW_INDEX_PRESENT bit.
        //

        if (FlagOn( NtfsContainingFileRecord( &AttrContext )->Flags,
                    FILE_VIEW_INDEX_PRESENT )) {

            SetFlag( Info->FileAttributes, DUP_VIEW_INDEX_PRESENT );

        } else {

            ClearFlag( Info->FileAttributes, DUP_VIEW_INDEX_PRESENT );
        }

        //
        //  We now walk through all of the filename attributes, counting the
        //  number of non-8dot3-only links.
        //

        Fcb->TotalLinks =
        Fcb->LinkCount = 0;

        FoundEntry = NtfsLookupNextAttributeByCode( IrpContext,
                                                    Fcb,
                                                    $FILE_NAME,
                                                    &AttrContext );

        while (FoundEntry) {

            PFILE_NAME FileName;

            AttributeHeader = NtfsFoundAttribute( &AttrContext );

            if (AttributeHeader->TypeCode != $FILE_NAME) {

                break;
            }

            FileName = (PFILE_NAME) NtfsAttributeValue( AttributeHeader );

            //
            //  We increment the count as long as this is not a 8.3 link
            //  only.
            //

            if (FileName->Flags != FILE_NAME_DOS) {

                Fcb->LinkCount += 1;
                Fcb->TotalLinks += 1;
            }

            //
            //  Now look for the next link.
            //

            FoundEntry = NtfsLookupNextAttribute( IrpContext,
                                                  Fcb,
                                                  &AttrContext );
        }

        //
        //  There better be at least one unless this is a system file.
        //

        if ((Fcb->LinkCount == 0) &&
            (NtfsSegmentNumber( &Fcb->FileReference ) >= FIRST_USER_FILE_NUMBER)) {

            try_return( CorruptDisk = TRUE );
        }

        //
        //  If we are to load the security and it is not already present we
        //  find the security attribute.
        //

        if (LoadSecurity && Fcb->SharedSecurity == NULL) {

            //
            //  We have two sources of security descriptors.  First, we have
            //  the SecurityId that is present in a large $STANDARD_INFORMATION.
            //  The other case is where we don't have such a security Id and must
            //  retrieve it from the $SECURITY_DESCRIPTOR attribute
            //
            //  In the case where we have the Id, we load it from the volume
            //  cache or index.
            //

            if (FlagOn( Fcb->FcbState, FCB_STATE_LARGE_STD_INFO ) &&
                (Fcb->SecurityId != SECURITY_ID_INVALID) &&
                (Fcb->Vcb->SecurityDescriptorStream != NULL)) {

                ASSERT( Fcb->SharedSecurity == NULL );
                Fcb->SharedSecurity = NtfsCacheSharedSecurityBySecurityId( IrpContext,
                                                                           Fcb->Vcb,
                                                                           Fcb->SecurityId );

                ASSERT( Fcb->SharedSecurity != NULL );

            } else {

                PSECURITY_DESCRIPTOR SecurityDescriptor;
                ULONG SecurityDescriptorLength;

                //
                //  We may have to walk forward to the security descriptor.
                //

                while (FoundEntry) {

                    AttributeHeader = NtfsFoundAttribute( &AttrContext );

                    if (AttributeHeader->TypeCode == $SECURITY_DESCRIPTOR) {

                        NtfsMapAttributeValue( IrpContext,
                                               Fcb,
                                               (PVOID *)&SecurityDescriptor,
                                               &SecurityDescriptorLength,
                                               &Bcb,
                                               &AttrContext );

                        NtfsSetFcbSecurityFromDescriptor(
                                               IrpContext,
                                               Fcb,
                                               SecurityDescriptor,
                                               SecurityDescriptorLength,
                                               FALSE );

                        //
                        //  If the security descriptor was resident then the Bcb field
                        //  in the attribute context was stored in the returned Bcb and
                        //  the Bcb in the attribute context was cleared.  In that case
                        //  the resumption of the attribute search will fail because
                        //  this module using the Bcb field to determine if this
                        //  is the initial enumeration.
                        //

                        if (NtfsIsAttributeResident( AttributeHeader )) {

                            NtfsFoundBcb( &AttrContext ) = Bcb;
                            Bcb = NULL;
                        }

                    } else if (AttributeHeader->TypeCode > $SECURITY_DESCRIPTOR) {

                        break;
                    }

                    FoundEntry = NtfsLookupNextAttribute( IrpContext,
                                                          Fcb,
                                                          &AttrContext );
                }
            }
        }

        //
        //  If this is not a directory, we need the file size.
        //

        if (!IsDirectory( Info ) && !IsViewIndex( Info )) {

            BOOLEAN FoundData = FALSE;

            //
            //  Look for the unnamed data attribute.
            //

            while (FoundEntry) {

                AttributeHeader = NtfsFoundAttribute( &AttrContext );

                if (AttributeHeader->TypeCode > $DATA) {

                    break;
                }

                if ((AttributeHeader->TypeCode == $DATA) &&
                    (AttributeHeader->NameLength == 0)) {

                    //
                    //  This can vary depending whether the attribute is resident
                    //  or nonresident.
                    //

                    if (NtfsIsAttributeResident( AttributeHeader )) {

                        //
                        //  Verify the resident value length.
                        //

                        if (AttributeHeader->Form.Resident.ValueLength > AttributeHeader->RecordLength - AttributeHeader->Form.Resident.ValueOffset) {

                            NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
                        }

                        Info->AllocatedLength = AttributeHeader->Form.Resident.ValueLength;
                        Info->FileSize = Info->AllocatedLength;

                        ((ULONG)Info->AllocatedLength) = QuadAlign( (ULONG)(Info->AllocatedLength) );

                        //
                        //  If the user passed in a ScbSnapshot, then copy the attribute
                        //  sizes to that.  We use the trick of setting the low bit of the
                        //  attribute size to indicate a resident attribute.
                        //

                        if (ARGUMENT_PRESENT( UnnamedDataSizes )) {

                            UnnamedDataSizes->TotalAllocated =
                            UnnamedDataSizes->AllocationSize = Info->AllocatedLength;
                            UnnamedDataSizes->FileSize = Info->FileSize;
                            UnnamedDataSizes->ValidDataLength = Info->FileSize;

                            UnnamedDataSizes->Resident = TRUE;
                            UnnamedDataSizes->CompressionUnit = 0;

                            UnnamedDataSizes->AttributeFlags = AttributeHeader->Flags;
                            NtfsVerifySizesLongLong( UnnamedDataSizes );
                            UpdatedNamedDataSizes = TRUE;
                        }

                        FoundData = TRUE;

                    } else if (AttributeHeader->Form.Nonresident.LowestVcn == 0) {

                        Info->AllocatedLength = AttributeHeader->Form.Nonresident.AllocatedLength;
                        Info->FileSize = AttributeHeader->Form.Nonresident.FileSize;

                        if (ARGUMENT_PRESENT( UnnamedDataSizes )) {

                            UnnamedDataSizes->TotalAllocated =
                            UnnamedDataSizes->AllocationSize = Info->AllocatedLength;
                            UnnamedDataSizes->FileSize = Info->FileSize;
                            UnnamedDataSizes->ValidDataLength = AttributeHeader->Form.Nonresident.ValidDataLength;

                            UnnamedDataSizes->Resident = FALSE;
                            UnnamedDataSizes->CompressionUnit = AttributeHeader->Form.Nonresident.CompressionUnit;

                            NtfsVerifySizesLongLong( UnnamedDataSizes );

                            //
                            //  Remember if it is compressed.
                            //

                            UnnamedDataSizes->AttributeFlags = AttributeHeader->Flags;
                            UpdatedNamedDataSizes = TRUE;
                        }

                        if (FlagOn( AttributeHeader->Flags,
                                    ATTRIBUTE_FLAG_COMPRESSION_MASK | ATTRIBUTE_FLAG_SPARSE )) {

                            Info->AllocatedLength = AttributeHeader->Form.Nonresident.TotalAllocated;

                            if (ARGUMENT_PRESENT( UnnamedDataSizes )) {

                                UnnamedDataSizes->TotalAllocated = Info->AllocatedLength;

                                if (UnnamedDataSizes->TotalAllocated < 0) {

                                    UnnamedDataSizes->TotalAllocated = 0;

                                } else if (UnnamedDataSizes->TotalAllocated > Info->AllocatedLength) {

                                    UnnamedDataSizes->TotalAllocated = Info->AllocatedLength;
                                }
                            }
                        }

                        FoundData = TRUE;
                    }

                    break;
                }

                FoundEntry = NtfsLookupNextAttribute( IrpContext,
                                                      Fcb,
                                                      &AttrContext );
            }

            //
            //  The following test is bad for the 5.0 support.  Assume if someone is actually
            //  trying to open the unnamed data attribute, that the right thing will happen.
            //
            //
            //  if (!FoundData) {
            //
            //      try_return( CorruptDisk = TRUE );
            //  }

        } else {

            //
            //  Since it is a directory, try to find the $INDEX_ROOT.
            //

            while (FoundEntry) {

                AttributeHeader = NtfsFoundAttribute( &AttrContext );

                if (AttributeHeader->TypeCode > $INDEX_ROOT) {

                    //
                    //  We thought this was a directory, yet it has now index
                    //  root.  That's not a legal state to be in, so let's
                    //  take the corrupt disk path out of here.
                    //

                    ASSERT( FALSE );
                    try_return( CorruptDisk = TRUE );

                    break;
                }

                //
                //  Look for encryption bit and store in Fcb.
                //

                if (AttributeHeader->TypeCode == $INDEX_ROOT) {

                    if (FlagOn( AttributeHeader->Flags, ATTRIBUTE_FLAG_ENCRYPTED )) {

                        SetFlag( Fcb->FcbState, FCB_STATE_DIRECTORY_ENCRYPTED );
                    }

                    break;
                }

                FoundEntry = NtfsLookupNextAttribute( IrpContext,
                                                      Fcb,
                                                      &AttrContext );
            }

            Info->AllocatedLength = 0;
            Info->FileSize = 0;
        }

        //
        //  Now we look for a reparse point attribute.  This one doesn't have to
        //  be there. It may also not be resident.
        //

        while (FoundEntry) {

            PREPARSE_DATA_BUFFER ReparseInformation;

            AttributeHeader = NtfsFoundAttribute( &AttrContext );

            if (AttributeHeader->TypeCode > $REPARSE_POINT) {

                break;

            } else if (AttributeHeader->TypeCode == $REPARSE_POINT) {

                if (NtfsIsAttributeResident( AttributeHeader )) {

                    ReparseInformation = (PREPARSE_DATA_BUFFER) NtfsAttributeValue( NtfsFoundAttribute( &AttrContext ));

                } else {

                    ULONG Length;

                    if (AttributeHeader->Form.Nonresident.FileSize > MAXIMUM_REPARSE_DATA_BUFFER_SIZE) {
                        NtfsRaiseStatus( IrpContext,STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
                    }

                    NtfsMapAttributeValue( IrpContext,
                                           Fcb,
                                           (PVOID *)&ReparseInformation,   //  point to the value
                                           &Length,
                                           &Bcb,
                                           &AttrContext );
                }

                Info->ReparsePointTag = ReparseInformation->ReparseTag;

                break;
            }

            FoundEntry = NtfsLookupNextAttribute( IrpContext,
                                                  Fcb,
                                                  &AttrContext );
        }

        //
        //  Now we look for an Ea information attribute.  This one doesn't have to
        //  be there.
        //

        while (FoundEntry) {

            PEA_INFORMATION EaInformation;

            AttributeHeader = NtfsFoundAttribute( &AttrContext );

            if (AttributeHeader->TypeCode > $EA_INFORMATION) {

                break;

            } else if (AttributeHeader->TypeCode == $EA_INFORMATION) {

                EaInformation = (PEA_INFORMATION) NtfsAttributeValue( NtfsFoundAttribute( &AttrContext ));

                Info->PackedEaSize = EaInformation->PackedEaSize;

                break;
            }

            FoundEntry = NtfsLookupNextAttributeByCode( IrpContext,
                                                        Fcb,
                                                        $EA_INFORMATION,
                                                        &AttrContext );
        }

        //
        //  Set the flag in the Fcb to indicate that we set these fields.
        //

        SetFlag( Fcb->FcbState, FCB_STATE_DUP_INITIALIZED );

    try_exit: NOTHING;
    } finally {

        DebugUnwind( NtfsUpdateFcbInfoFromDisk );

        NtfsCleanupAttributeContext( IrpContext, &AttrContext );
        NtfsUnpinBcb( IrpContext, &Bcb );

        DebugTrace( -1, Dbg, ("NtfsUpdateFcbInfoFromDisk:  Exit\n") );
    }

    //
    //  If we encountered a corrupt disk, we generate a popup and raise the file
    //  corrupt error.
    //

    if (CorruptDisk) {

        NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
    }

    return UpdatedNamedDataSizes;
}


VOID
NtfsCleanupAttributeContext (
    IN OUT PIRP_CONTEXT IrpContext,
    IN OUT PATTRIBUTE_ENUMERATION_CONTEXT AttributeContext
    )

/*++

Routine Description:

    This routine is called to free any resources claimed within an enumeration
    context and to unpin mapped or pinned data.

Arguments:

    IrpContext - context of the call

    AttributeContext - Pointer to the enumeration context to perform cleanup
                       on.

Return Value:

    None.

--*/

{

    UNREFERENCED_PARAMETER( IrpContext );

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsCleanupAttributeContext\n") );

    //
    //  TEMPCODE   We need a call to cleanup any Scb's created.
    //

    //
    //  Unpin any Bcb's pinned here.
    //

    NtfsUnpinBcb( IrpContext, &AttributeContext->FoundAttribute.Bcb );
    NtfsUnpinBcb( IrpContext, &AttributeContext->AttributeList.Bcb );
    NtfsUnpinBcb( IrpContext, &AttributeContext->AttributeList.NonresidentListBcb );

    //
    //  Originally, we zeroed the entire context at this point.  This is
    //  wildly inefficient since the context is either deallocated soon thereafter
    //  or is initialized again.
    //
    //  RtlZeroMemory( AttributeContext, sizeof(ATTRIBUTE_ENUMERATION_CONTEXT) );
    //

    //  Set entire contents to -1 (and reset Bcb's to NULL) to verify
    //  that no one reuses this data structure

#if DBG
    RtlFillMemory( AttributeContext, sizeof( *AttributeContext ), -1 );
    AttributeContext->FoundAttribute.Bcb = NULL;
    AttributeContext->AttributeList.Bcb = NULL;
    AttributeContext->AttributeList.NonresidentListBcb = NULL;
#endif

    DebugTrace( -1, Dbg, ("NtfsCleanupAttributeContext -> VOID\n") );

    return;
}


BOOLEAN
NtfsWriteFileSizes (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB Scb,
    IN PLONGLONG ValidDataLength,
    IN BOOLEAN AdvanceOnly,
    IN BOOLEAN LogIt,
    IN BOOLEAN RollbackMemStructures
    )

/*++

Routine Description:

    This routine is called to modify the filesize and valid data size
    on the disk from the Scb.

Arguments:

    Scb - Scb whose attribute is being modified.

    ValidDataLength - Supplies pointer to the new desired ValidDataLength

    AdvanceOnly - TRUE if the valid data length should be set only if
                  greater than the current value on disk.  FALSE if
                  the valid data length should be set only if
                  less than the current value on disk.

    LogIt - Indicates whether we should log this change.

    RollbackMemStructures - If true then there had better be snapshots to support doing this
                            if not this indicates we're transferring persisted in memory
                            changes to disk.  I.e a the final writefilesizes at close time
                            or the check_attribute_sizes related calls

Return Value:

    TRUE if a log record was written out

--*/

{
    ATTRIBUTE_ENUMERATION_CONTEXT AttrContext;
    PATTRIBUTE_RECORD_HEADER AttributeHeader;
    PFILE_RECORD_SEGMENT_HEADER FileRecord;

    NEW_ATTRIBUTE_SIZES OldAttributeSizes;
    NEW_ATTRIBUTE_SIZES NewAttributeSizes;

    ULONG LogRecordSize = SIZEOF_PARTIAL_ATTRIBUTE_SIZES;
    BOOLEAN SparseAllocation = FALSE;

    BOOLEAN UpdateMft = FALSE;
    BOOLEAN Logged = FALSE;

    PAGED_CODE();

    UNREFERENCED_PARAMETER( RollbackMemStructures );

    //
    //  Return immediately if the volume is locked unless we have grown the Mft or the Bitmap.
    //  In some cases the user can grow the Mft with the volume locked (i.e. add
    //  a Usn journal).
    //

    if (FlagOn( Scb->Vcb->VcbState, VCB_STATE_LOCKED ) &&
        (Scb != Scb->Vcb->MftScb) && (Scb != Scb->Vcb->BitmapScb)) {

        return Logged;
    }

    DebugTrace( +1, Dbg, ("NtfsWriteFileSizes:  Entered\n") );

    ASSERT( (Scb->ScbSnapshot != NULL) || !RollbackMemStructures );

    //
    //  Use a try_finally to facilitate cleanup.
    //

    try {

        //
        //  Find the attribute on the disk.
        //

        NtfsInitializeAttributeContext( &AttrContext );

        NtfsLookupAttributeForScb( IrpContext, Scb, NULL, &AttrContext );

        //
        //  Pull the pointers out of the attribute context.
        //

        FileRecord = NtfsContainingFileRecord( &AttrContext );
        AttributeHeader = NtfsFoundAttribute( &AttrContext );

        //
        //  Check if this is a resident attribute, and if it is then we only
        //  want to assert that the file sizes match and then return to
        //  our caller
        //

        if (NtfsIsAttributeResident( AttributeHeader )) {

            try_return( NOTHING );
        }

        //
        //  Remember the existing values.
        //

        OldAttributeSizes.TotalAllocated =
        OldAttributeSizes.AllocationSize = AttributeHeader->Form.Nonresident.AllocatedLength;
        OldAttributeSizes.ValidDataLength = AttributeHeader->Form.Nonresident.ValidDataLength;
        OldAttributeSizes.FileSize = AttributeHeader->Form.Nonresident.FileSize;
        NtfsVerifySizesLongLong( &OldAttributeSizes );

        if (FlagOn( AttributeHeader->Flags,
                    ATTRIBUTE_FLAG_COMPRESSION_MASK | ATTRIBUTE_FLAG_SPARSE )) {

            SparseAllocation = TRUE;
            OldAttributeSizes.TotalAllocated = AttributeHeader->Form.Nonresident.TotalAllocated;
        }

        //
        //  Copy these values.
        //

        NewAttributeSizes = OldAttributeSizes;

        //
        //  We only want to modify the sizes if the current thread owns the
        //  EOF.  The exception is the TotalAllocated field for a compressed file.
        //  Otherwise this transaction might update the file size on disk at the
        //  same time an operation on EOF might roll back the Scb value.  The
        //  two resulting numbers would conflict.
        //
        //  Use the same test that NtfsRestoreScbSnapshots uses.
        //

/*
        //
        //  Disable for now - fix for attribute lists in server release
        //  

        ASSERT( !RollbackMemStructures ||
                !NtfsSnapshotFileSizesTest( IrpContext, Scb ) ||
                (Scb->ScbSnapshot->OwnerIrpContext == IrpContext) ||
                (Scb->ScbSnapshot->OwnerIrpContext == IrpContext->TopLevelIrpContext));
*/                

        if (((Scb->ScbSnapshot != NULL) &&
             ((Scb->ScbSnapshot->OwnerIrpContext == IrpContext) ||
              (Scb->ScbSnapshot->OwnerIrpContext == IrpContext->TopLevelIrpContext))) ||
            (!RollbackMemStructures && NtfsSnapshotFileSizesTest( IrpContext, Scb ))) {

            //
            //  Check if we will be modifying the valid data length on
            //  disk.  Don't acquire this for the paging file in case the
            //  current code block needs to be paged in.
            //

            if (!FlagOn( Scb->Fcb->FcbState, FCB_STATE_PAGING_FILE )) {

                NtfsAcquireFsrtlHeader(Scb);
            }

            if ((AdvanceOnly
                 && (*ValidDataLength > OldAttributeSizes.ValidDataLength))

                || (!AdvanceOnly
                    && (*ValidDataLength < OldAttributeSizes.ValidDataLength))) {

                //
                //  Copy the valid data length into the new size structure.
                //

                NewAttributeSizes.ValidDataLength = *ValidDataLength;
                UpdateMft = TRUE;
            }

            //
            //  Now check if we're modifying the filesize.
            //

            if (Scb->Header.FileSize.QuadPart != OldAttributeSizes.FileSize) {

                NewAttributeSizes.FileSize = Scb->Header.FileSize.QuadPart;
                UpdateMft = TRUE;
            }

            if (!FlagOn( Scb->Fcb->FcbState, FCB_STATE_PAGING_FILE )) {

                NtfsReleaseFsrtlHeader(Scb);
            }

            //
            //  Finally, update the allocated length from the Scb if it is different.
            //

            if (Scb->Header.AllocationSize.QuadPart != AttributeHeader->Form.Nonresident.AllocatedLength) {

                NewAttributeSizes.AllocationSize = Scb->Header.AllocationSize.QuadPart;
                UpdateMft = TRUE;
            }
        }

        //
        //  If this is compressed then check if totally allocated has changed.
        //

        if (SparseAllocation) {

            LogRecordSize = SIZEOF_FULL_ATTRIBUTE_SIZES;

            if (Scb->TotalAllocated != OldAttributeSizes.TotalAllocated) {

                ASSERT( !RollbackMemStructures || (Scb->ScbSnapshot != NULL) );

                NewAttributeSizes.TotalAllocated = Scb->TotalAllocated;
                UpdateMft = TRUE;
            }
        }

        //
        //  Continue on if we need to update the Mft.
        //

        if (UpdateMft) {

            //
            //  Pin the attribute.
            //

            NtfsPinMappedAttribute( IrpContext,
                                    Scb->Vcb,
                                    &AttrContext );

            AttributeHeader = NtfsFoundAttribute( &AttrContext );

            if (NewAttributeSizes.ValidDataLength > NewAttributeSizes.FileSize) {

                // ASSERT(XxLeq(NewAttributeSizes.ValidDataLength,NewAttributeSizes.FileSize));

                NewAttributeSizes.ValidDataLength = NewAttributeSizes.FileSize;
            }

            ASSERT(NewAttributeSizes.FileSize <= NewAttributeSizes.AllocationSize);
            ASSERT(NewAttributeSizes.ValidDataLength <= NewAttributeSizes.AllocationSize);

            NtfsVerifySizesLongLong( &NewAttributeSizes );

            //
            //  Log this change to the attribute header.
            //

            if (LogIt) {

                FileRecord->Lsn = NtfsWriteLog( IrpContext,
                                                Scb->Vcb->MftScb,
                                                NtfsFoundBcb( &AttrContext ),
                                                SetNewAttributeSizes,
                                                &NewAttributeSizes,
                                                LogRecordSize,
                                                SetNewAttributeSizes,
                                                &OldAttributeSizes,
                                                LogRecordSize,
                                                NtfsMftOffset( &AttrContext ),
                                                PtrOffset( FileRecord, AttributeHeader ),
                                                0,
                                                Scb->Vcb->BytesPerFileRecordSegment );

                Logged = TRUE;

            } else {

                CcSetDirtyPinnedData( NtfsFoundBcb( &AttrContext ), NULL );
            }

            AttributeHeader->Form.Nonresident.AllocatedLength = NewAttributeSizes.AllocationSize;
            AttributeHeader->Form.Nonresident.FileSize = NewAttributeSizes.FileSize;
            AttributeHeader->Form.Nonresident.ValidDataLength = NewAttributeSizes.ValidDataLength;

            //
            //  Don't modify the total allocated field unless there is an actual field for it.
            //

            if (SparseAllocation &&
                ((AttributeHeader->NameOffset >= SIZEOF_FULL_NONRES_ATTR_HEADER) ||
                 ((AttributeHeader->NameOffset == 0) &&
                  (AttributeHeader->Form.Nonresident.MappingPairsOffset >= SIZEOF_FULL_NONRES_ATTR_HEADER)))) {

                AttributeHeader->Form.Nonresident.TotalAllocated = NewAttributeSizes.TotalAllocated;
            }
        }

    try_exit: NOTHING;
    } finally {

        DebugUnwind( NtfsWriteFileSizes );

        //
        //  Cleanup the attribute context.
        //

        NtfsCleanupAttributeContext( IrpContext, &AttrContext );

        DebugTrace( -1, Dbg, ("NtfsWriteFileSizes:  Exit\n") );
    }

    return Logged;
}


VOID
NtfsUpdateStandardInformation (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb
    )

/*++

Routine Description:

    This routine is called to update the standard information attribute
    for a file from the information in the Fcb.  The fields being modified
    are the time fields and the file attributes.

Arguments:

    Fcb - Fcb for the file to modify.

Return Value:

    None

--*/

{
    ATTRIBUTE_ENUMERATION_CONTEXT AttrContext;
    STANDARD_INFORMATION StandardInformation;
    ULONG Length;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsUpdateStandardInformation:  Entered\n") );

    //
    //  Return immediately if the volume is mounted readonly.
    //

    if (NtfsIsVolumeReadOnly( Fcb->Vcb )) {

        return;
    }

    //
    //  Use a try-finally to cleanup the attribute context.
    //

    try {

        //
        //  Initialize the context structure.
        //

        NtfsInitializeAttributeContext( &AttrContext );

        //
        //  Locate the standard information, it must be there.
        //

        if (!NtfsLookupAttributeByCode( IrpContext,
                                        Fcb,
                                        &Fcb->FileReference,
                                        $STANDARD_INFORMATION,
                                        &AttrContext )) {

            DebugTrace( 0, Dbg, ("Can't find standard information\n") );

            NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
        }

        Length = NtfsFoundAttribute( &AttrContext )->Form.Resident.ValueLength;

        //
        //  Copy the existing standard information to our buffer.
        //

        RtlCopyMemory( &StandardInformation,
                       NtfsAttributeValue( NtfsFoundAttribute( &AttrContext )),
                       Length);


        //
        //  Since we are updating standard information, make sure the last
        //  access time is up-to-date.
        //

        if (Fcb->Info.LastAccessTime != Fcb->CurrentLastAccess) {

            Fcb->Info.LastAccessTime = Fcb->CurrentLastAccess;
            SetFlag( Fcb->InfoFlags, FCB_INFO_CHANGED_LAST_ACCESS );
        }

        //
        //  No need to update last access standard information later.
        //

        ClearFlag( Fcb->InfoFlags, FCB_INFO_UPDATE_LAST_ACCESS );

        //
        //  Change the relevant time fields.
        //

        StandardInformation.CreationTime = Fcb->Info.CreationTime;
        StandardInformation.LastModificationTime = Fcb->Info.LastModificationTime;
        StandardInformation.LastChangeTime = Fcb->Info.LastChangeTime;
        StandardInformation.LastAccessTime = Fcb->Info.LastAccessTime;
        StandardInformation.FileAttributes = Fcb->Info.FileAttributes;

        //
        //  We clear the directory bit.
        //

        ClearFlag( StandardInformation.FileAttributes, DUP_FILE_NAME_INDEX_PRESENT );

        //
        //  Fill in the new fields if necessary.
        //

        if (FlagOn(Fcb->FcbState, FCB_STATE_LARGE_STD_INFO)) {

            StandardInformation.ClassId = 0;
            StandardInformation.OwnerId = Fcb->OwnerId;
            StandardInformation.SecurityId = Fcb->SecurityId;
            StandardInformation.Usn = Fcb->Usn;
        }

        //
        //  Call to change the attribute value.
        //

        NtfsChangeAttributeValue( IrpContext,
                                  Fcb,
                                  0,
                                  &StandardInformation,
                                  Length,
                                  FALSE,
                                  FALSE,
                                  FALSE,
                                  FALSE,
                                  &AttrContext );


    } finally {

        DebugUnwind( NtfsUpdateStandadInformation );

        NtfsCleanupAttributeContext( IrpContext, &AttrContext );

        DebugTrace( -1, Dbg, ("NtfsUpdateStandardInformation:  Exit\n") );
    }

    return;
}


VOID
NtfsGrowStandardInformation (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb
    )

/*++

Routine Description:

    This routine is called to grow and update the standard information
    attribute for a file from the information in the Fcb.

Arguments:

    Fcb - Fcb for the file to modify.

Return Value:

    None

--*/

{
    ATTRIBUTE_ENUMERATION_CONTEXT AttrContext;
    STANDARD_INFORMATION StandardInformation;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsGrowStandardInformation:  Entered\n") );

    //
    //  Use a try-finally to cleanup the attribute context.
    //

    try {

        //
        //  Initialize the context structure.
        //

        NtfsInitializeAttributeContext( &AttrContext );

        //
        //  Locate the standard information, it must be there.
        //

        if (!NtfsLookupAttributeByCode( IrpContext,
                                        Fcb,
                                        &Fcb->FileReference,
                                        $STANDARD_INFORMATION,
                                        &AttrContext )) {

            DebugTrace( 0, Dbg, ("Can't find standard information\n") );

            NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
        }

        if (NtfsFoundAttribute( &AttrContext )->Form.Resident.ValueLength ==
            SIZEOF_OLD_STANDARD_INFORMATION) {

            //
            //  Copy the existing standard information to our buffer.
            //

            RtlCopyMemory( &StandardInformation,
                           NtfsAttributeValue( NtfsFoundAttribute( &AttrContext )),
                           SIZEOF_OLD_STANDARD_INFORMATION);

            RtlZeroMemory((PCHAR) &StandardInformation +
                            SIZEOF_OLD_STANDARD_INFORMATION,
                            sizeof( STANDARD_INFORMATION) -
                            SIZEOF_OLD_STANDARD_INFORMATION);
        }

        //
        //  Since we are updating standard information, make sure the last
        //  access time is up-to-date.
        //

        if (Fcb->Info.LastAccessTime != Fcb->CurrentLastAccess) {

            Fcb->Info.LastAccessTime = Fcb->CurrentLastAccess;
            SetFlag( Fcb->InfoFlags, FCB_INFO_CHANGED_LAST_ACCESS );
        }

        //
        //  Change the relevant time fields.
        //

        StandardInformation.CreationTime = Fcb->Info.CreationTime;
        StandardInformation.LastModificationTime = Fcb->Info.LastModificationTime;
        StandardInformation.LastChangeTime = Fcb->Info.LastChangeTime;
        StandardInformation.LastAccessTime = Fcb->Info.LastAccessTime;
        StandardInformation.FileAttributes = Fcb->Info.FileAttributes;

        //
        //  We clear the directory bit.
        //

        ClearFlag( StandardInformation.FileAttributes, DUP_FILE_NAME_INDEX_PRESENT );


        //
        //  Fill in the new fields.
        //

        StandardInformation.ClassId = 0;
        StandardInformation.OwnerId = Fcb->OwnerId;
        StandardInformation.SecurityId = Fcb->SecurityId;
        StandardInformation.Usn = Fcb->Usn;

        //
        //  Call to change the attribute value.
        //

        NtfsChangeAttributeValue( IrpContext,
                                  Fcb,
                                  0,
                                  &StandardInformation,
                                  sizeof( STANDARD_INFORMATION),
                                  TRUE,
                                  FALSE,
                                  FALSE,
                                  FALSE,
                                  &AttrContext );


        ClearFlag( Fcb->FcbState, FCB_STATE_UPDATE_STD_INFO );
        SetFlag( Fcb->FcbState, FCB_STATE_LARGE_STD_INFO );

    } finally {

        DebugUnwind( NtfsGrowStandadInformation );

        NtfsCleanupAttributeContext( IrpContext, &AttrContext );

        DebugTrace( -1, Dbg, ("NtfsGrowStandardInformation:  Exit\n") );
    }

    return;
}

BOOLEAN
NtfsLookupEntry (
    IN PIRP_CONTEXT IrpContext,
    IN PSCB ParentScb,
    IN BOOLEAN IgnoreCase,
    IN OUT PUNICODE_STRING Name,
    IN OUT PFILE_NAME *FileNameAttr,
    IN OUT PUSHORT FileNameAttrLength,
    OUT PQUICK_INDEX QuickIndex OPTIONAL,
    OUT PINDEX_ENTRY *IndexEntry,
    OUT PBCB *IndexEntryBcb,
    OUT PINDEX_CONTEXT IndexContext OPTIONAL
    )

/*++

Routine Description:

    This routine is called to look up a particular file name in a directory.
    It takes a single component name and a parent Scb to search in.
    To do the search, we need to construct a FILE_NAME attribute.
    We use a reusable buffer to do this, to avoid constantly allocating
    and deallocating pool.  We try to keep this larger than we will ever need.

    When we find a match on disk, we copy over the name we were called with so
    we have a record of the actual case on the disk.  In this way we can
    be case perserving.

Arguments:

    ParentScb - This is the Scb for the parent directory.

    IgnoreCase - Indicates if we should ignore case while searching through
        the index.

    Name - This is the path component to search for.  We will overwrite this
        in place if a match is found.

    FileNameAttr - Address of the buffer we will use to create the file name
        attribute.  We will free this buffer and allocate a new buffer
        if needed.

    FileNameAttrLength - This is the length of the FileNameAttr buffer above.

    QuickIndex - If specified, supplies a pointer to a quik lookup structure
        to be updated by this routine.

    IndexEntry - Address to store the cache address of the matching entry.

    IndexEntryBcb - Address to store the Bcb for the IndexEntry above.

    IndexContext - Initialized IndexContext used for the lookup.  Can be used
        later when inserting an entry on a miss.

Return Value:

    BOOLEAN - TRUE if a match was found, FALSE otherwise.

--*/

{
    BOOLEAN FoundEntry;
    USHORT Size;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsLookupEntry:  Entered\n") );

    //
    //  We compute the size of the buffer needed to build the filename
    //  attribute.  If the current buffer is too small we deallocate it
    //  and allocate a new one.  We always allocate twice the size we
    //  need in order to minimize the number of allocations.
    //

    Size = (USHORT)(sizeof( FILE_NAME ) + Name->Length - sizeof(WCHAR));

    if (Size > *FileNameAttrLength) {

        if (*FileNameAttr != NULL) {

            DebugTrace( 0, Dbg, ("Deallocating previous file name attribute buffer\n") );
            NtfsFreePool( *FileNameAttr );

            *FileNameAttr = NULL;
        }

        *FileNameAttr = NtfsAllocatePool(PagedPool, Size << 1 );
        *FileNameAttrLength = Size << 1;
    }

    //
    //  We build the filename attribute.  If this operation is ignore case,
    //  we upcase the expression in the filename attribute.
    //

    NtfsBuildFileNameAttribute( IrpContext,
                                &ParentScb->Fcb->FileReference,
                                *Name,
                                0,
                                *FileNameAttr );

    //
    //  Now we call the index routine to perform the search.
    //

    FoundEntry = NtfsFindIndexEntry( IrpContext,
                                     ParentScb,
                                     *FileNameAttr,
                                     IgnoreCase,
                                     QuickIndex,
                                     IndexEntryBcb,
                                     IndexEntry,
                                     IndexContext );

    //
    //  We always restore the name in the filename attribute to the original
    //  name in case we upcased it in the lookup.
    //

    if (IgnoreCase) {

        RtlCopyMemory( (*FileNameAttr)->FileName,
                       Name->Buffer,
                       Name->Length );
    }

    DebugTrace( -1, Dbg, ("NtfsLookupEntry:  Exit -> %04x\n", FoundEntry) );

    return FoundEntry;
}



VOID
NtfsCreateAttributeWithValue (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN ATTRIBUTE_TYPE_CODE AttributeTypeCode,
    IN PUNICODE_STRING AttributeName OPTIONAL,
    IN PVOID Value OPTIONAL,
    IN ULONG ValueLength,
    IN USHORT AttributeFlags,
    IN PFILE_REFERENCE WhereIndexed OPTIONAL,
    IN BOOLEAN LogIt,
    OUT PATTRIBUTE_ENUMERATION_CONTEXT Context
    )

/*++

Routine Description:

    This routine creates the specified attribute with the specified value,
    and returns a description of it via the attribute context.  If no
    value is specified, then the attribute is created with the specified
    number of zero bytes.

    On successful return, it is up to the caller to clean up the attribute
    context.

Arguments:

    Fcb - Current file.

    AttributeTypeCode - Type code of the attribute to create.

    AttributeName - Optional name for attribute.

    Value - Pointer to the buffer containing the desired attribute value,
            or a NULL if zeros are desired.

    ValueLength - Length of value in bytes.

    AttributeFlags - Desired flags for the created attribute.

    WhereIndexed - Optionally supplies the file reference to the file where
                   this attribute is indexed.

    LogIt - Most callers should specify TRUE, to have the change logged.  However,
            we can specify FALSE if we are creating a new file record, and
            will be logging the entire new file record.

    Context - A handle to the created attribute.  This must be cleaned up upon
              return.  Callers who may have made an attribute nonresident may
              not count on accessing the created attribute via this context upon
              return.

Return Value:

    None.

--*/

{
    UCHAR AttributeBuffer[SIZEOF_FULL_NONRES_ATTR_HEADER];
    ULONG RecordOffset;
    PATTRIBUTE_RECORD_HEADER Attribute;
    PFILE_RECORD_SEGMENT_HEADER FileRecord;
    ULONG SizeNeeded;
    ULONG AttrSizeNeeded;
    PVCB Vcb;
    ULONG Passes = 0;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FCB( Fcb );

    PAGED_CODE();

    ASSERT( (AttributeFlags == 0) ||
            (AttributeTypeCode == $INDEX_ROOT) ||
            NtfsIsTypeCodeCompressible( AttributeTypeCode ));

    Vcb = Fcb->Vcb;

    DebugTrace( +1, Dbg, ("NtfsCreateAttributeWithValue\n") );
    DebugTrace( 0, Dbg, ("Value = %08lx\n", Value) );
    DebugTrace( 0, Dbg, ("ValueLength = %08lx\n", ValueLength) );

    //
    //  Clear out the invalid attribute flags for this volume.
    //

    ClearFlag( AttributeFlags, ~Vcb->AttributeFlagsMask );

    //
    //  Calculate the size needed for this attribute
    //

    SizeNeeded = SIZEOF_RESIDENT_ATTRIBUTE_HEADER + QuadAlign( ValueLength ) +
                 (ARGUMENT_PRESENT( AttributeName ) ?
                   QuadAlign( AttributeName->Length ) : 0);

    //
    //  Loop until we find all the space we need.
    //

    do {

        //
        //  Reinitialize context if this is not the first pass.
        //

        if (Passes != 0) {

            NtfsCleanupAttributeContext( IrpContext, Context );
            NtfsInitializeAttributeContext( Context );
        }

        Passes += 1;

        ASSERT( Passes < 5 );

        //
        //  If the attribute is not indexed, then we will position to the
        //  insertion point by type code and name.
        //

        if (!ARGUMENT_PRESENT( WhereIndexed )) {

            if (NtfsLookupAttributeByName( IrpContext,
                                           Fcb,
                                           &Fcb->FileReference,
                                           AttributeTypeCode,
                                           AttributeName,
                                           NULL,
                                           FALSE,
                                           Context )) {

                DebugTrace( 0, 0,
                            ("Nonindexed attribute already exists, TypeCode = %08lx\n",
                             AttributeTypeCode ));

                ASSERTMSG("Nonindexed attribute already exists, About to raise corrupt ", FALSE);

                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
            }

            //
            //  Check here if the attribute needs to be nonresident and if so just
            //  pass this off.
            //

            FileRecord = NtfsContainingFileRecord(Context);

            if ((SizeNeeded > (FileRecord->BytesAvailable - FileRecord->FirstFreeByte)) &&
                (SizeNeeded >= Vcb->BigEnoughToMove) &&
                !FlagOn( NtfsGetAttributeDefinition( Vcb,
                                                     AttributeTypeCode)->Flags,
                         ATTRIBUTE_DEF_MUST_BE_RESIDENT)) {

                NtfsCreateNonresidentWithValue( IrpContext,
                                                Fcb,
                                                AttributeTypeCode,
                                                AttributeName,
                                                Value,
                                                ValueLength,
                                                AttributeFlags,
                                                FALSE,
                                                NULL,
                                                LogIt,
                                                Context );

                return;
            }

        //
        //  Otherwise, if the attribute is indexed, then we position by the
        //  attribute value.
        //

        } else {

            ASSERT(ARGUMENT_PRESENT(Value));

            if (NtfsLookupAttributeByValue( IrpContext,
                                            Fcb,
                                            &Fcb->FileReference,
                                            AttributeTypeCode,
                                            Value,
                                            ValueLength,
                                            Context )) {

                DebugTrace( 0, 0,
                            ("Indexed attribute already exists, TypeCode = %08lx\n",
                            AttributeTypeCode ));

                ASSERTMSG("Indexed attribute already exists, About to raise corrupt ", FALSE);
                NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
            }
        }

        //
        //  If this attribute is being positioned in the base file record and
        //  there is an attribute list then we need to ask for enough space
        //  for the attribute list entry now.
        //

        FileRecord = NtfsContainingFileRecord( Context );
        Attribute = NtfsFoundAttribute( Context );

        AttrSizeNeeded = SizeNeeded;
        if (Context->AttributeList.Bcb != NULL
            && (ULONG_PTR) FileRecord <= (ULONG_PTR) Context->AttributeList.AttributeList
            && (ULONG_PTR) Attribute >= (ULONG_PTR) Context->AttributeList.AttributeList) {

            //
            //  If the attribute list is non-resident then add a fudge factor of
            //  16 bytes for any new retrieval information.
            //

            if (NtfsIsAttributeResident( Context->AttributeList.AttributeList )) {

                AttrSizeNeeded += QuadAlign( FIELD_OFFSET( ATTRIBUTE_LIST_ENTRY, AttributeName )
                                             + (ARGUMENT_PRESENT( AttributeName ) ?
                                                (ULONG) AttributeName->Length :
                                                sizeof( WCHAR )));

            } else {

                AttrSizeNeeded += 0x10;
            }
        }

        //
        //  Ask for the space we need.
        //

    } while (!NtfsGetSpaceForAttribute( IrpContext, Fcb, AttrSizeNeeded, Context ));

    //
    //  Now point to the file record and calculate the record offset where
    //  our attribute will go.  And point to our local buffer.
    //

    RecordOffset = (ULONG)((PCHAR)NtfsFoundAttribute(Context) - (PCHAR)FileRecord);
    Attribute = (PATTRIBUTE_RECORD_HEADER)AttributeBuffer;

    if (RecordOffset >= Fcb->Vcb->BytesPerFileRecordSegment) {

        ASSERTMSG("RecordOffset beyond FRS size, About to raise corrupt ", FALSE);
        NtfsRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR, NULL, Fcb );
    }

    RtlZeroMemory( Attribute, SIZEOF_RESIDENT_ATTRIBUTE_HEADER );

    Attribute->TypeCode = AttributeTypeCode;
    Attribute->RecordLength = SizeNeeded;
    Attribute->FormCode = RESIDENT_FORM;

    if (ARGUMENT_PRESENT(AttributeName)) {

        ASSERT( AttributeName->Length <= 0x1FF );

        Attribute->NameLength = (UCHAR)(AttributeName->Length / sizeof(WCHAR));
        Attribute->NameOffset = (USHORT)SIZEOF_RESIDENT_ATTRIBUTE_HEADER;
    }

    Attribute->Flags = AttributeFlags;
    Attribute->Instance = FileRecord->NextAttributeInstance;

    //
    //  If someone repeatedly adds and removes attributes from a file record we could
    //  hit a case where the sequence number will overflow.  In this case we
    //  want to scan the file record and find an earlier free instance number.
    //

    if (Attribute->Instance > NTFS_CHECK_INSTANCE_ROLLOVER) {

        Attribute->Instance = NtfsScanForFreeInstance( IrpContext, Vcb, FileRecord );
    }

    Attribute->Form.Resident.ValueLength = ValueLength;
    Attribute->Form.Resident.ValueOffset =
      (USHORT)(SIZEOF_RESIDENT_ATTRIBUTE_HEADER +
      QuadAlign( Attribute->NameLength << 1) );

    //
    //  If this attribute is indexed, then we have to set the right flag
    //  and update the file record reference count.
    //

    if (ARGUMENT_PRESENT(WhereIndexed)) {
        Attribute->Form.Resident.ResidentFlags = RESIDENT_FORM_INDEXED;
    }

    //
    //  Now we will actually create the attribute in place, so that we
    //  save copying everything twice, and can point to the final image
    //  for the log write below.
    //

    NtfsRestartInsertAttribute( IrpContext,
                                FileRecord,
                                RecordOffset,
                                Attribute,
                                AttributeName,
                                Value,
                                ValueLength );

    //
    //  Finally, log the creation of this attribute
    //

    if (LogIt) {

        //
        //  We have actually created the attribute above, but the write
        //  log below could fail.  The reason we did the create already
        //  was to avoid having to allocate pool and copy everything
        //  twice (header, name and value).  Our normal error recovery
        //  just recovers from the log file.  But if we fail to write
        //  the log, we have to remove this attribute by hand, and
        //  raise the condition again.
        //

        try {

            FileRecord->Lsn =
            NtfsWriteLog( IrpContext,
                          Vcb->MftScb,
                          NtfsFoundBcb(Context),
                          CreateAttribute,
                          Add2Ptr(FileRecord, RecordOffset),
                          Attribute->RecordLength,
                          DeleteAttribute,
                          NULL,
                          0,
                          NtfsMftOffset( Context ),
                          RecordOffset,
                          0,
                          Vcb->BytesPerFileRecordSegment );

        } except(NtfsExceptionFilter( IrpContext, GetExceptionInformation() )) {

            NtfsRestartRemoveAttribute( IrpContext, FileRecord, RecordOffset );

            NtfsRaiseStatus( IrpContext, GetExceptionCode(), NULL, NULL );
        }
    }

    //
    //  Now add it to the attribute list if necessary
    //

    if (Context->AttributeList.Bcb != NULL) {

        MFT_SEGMENT_REFERENCE SegmentReference;

        *(PLONGLONG)&SegmentReference = LlFileRecordsFromBytes( Vcb, NtfsMftOffset( Context ));
        SegmentReference.SequenceNumber = FileRecord->SequenceNumber;

        NtfsAddToAttributeList( IrpContext, Fcb, SegmentReference, Context );
    }

    DebugTrace( -1, Dbg, ("NtfsCreateAttributeWithValue -> VOID\n") );

    return;
}


VOID
NtfsCreateNonresidentWithValue (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN ATTRIBUTE_TYPE_CODE AttributeTypeCode,
    IN PUNICODE_STRING AttributeName OPTIONAL,
    IN PVOID Value OPTIONAL,
    IN ULONG ValueLength,
    IN USHORT AttributeFlags,
    IN BOOLEAN WriteClusters,
    IN PSCB ThisScb OPTIONAL,
    IN BOOLEAN LogIt,
    IN PATTRIBUTE_ENUMERATION_CONTEXT Context
    )

/*++

Routine Description:

    This routine creates the specified nonresident attribute with the specified
    value, and returns a description of it via the attribute context. If no
    value is specified, then the attribute is created with the specified
    number of zero bytes.

    On successful return, it is up to the caller to clean up the attribute
    context.

Arguments:

    Fcb - Current file.

    AttributeTypeCode - Type code of the attribute to create.

    AttributeName - Optional name for attribute.

    Value - Pointer to the buffer containing the desired attribute value,
            or a NULL if zeros are desired.

    ValueLength - Length of value in bytes.

    AttributeFlags - Desired flags for the created attribute.

    WriteClusters - if supplied as TRUE, then we cannot write the data into the
        cache but must write the clusters directly to the disk.  The value buffer
        in this case must be quad-aligned and a multiple of cluster size in size.
        If TRUE it also means we are being called during the NtfsConvertToNonresident
        path.  We need to set a flag in the Scb in that case.

    ThisScb - If present, this is the Scb to use for the create.  It also indicates
              that this call is from convert to non-resident.

    LogIt - Most callers should specify TRUE, to have the change logged.  However,
            we can specify FALSE if we are creating a new file record, and
            will be logging the entire new file record.

    Context - This is the location to create the new attribute.

Return Value:

    None.

--*/

{
    PSCB Scb;
    BOOLEAN ReturnedExistingScb;
    UNICODE_STRING LocalName;
    PVCB Vcb = Fcb->Vcb;
    BOOLEAN LogNonresidentToo;
    BOOLEAN AdvanceOnly;

    PAGED_CODE();

    DebugTrace( +1, Dbg, ("NtfsCreateNonresidentWithValue\n") );

    //
    //  When we're updating the attribute definition table, we want that operation
    //  to be logged, even though it's a $DATA attribute.
    //

    //
    //  TODO: post nt5.1 change chkdsk so it can recognize an attrdef table with $EA
    //  log non-resident
    //


    AdvanceOnly =
    LogNonresidentToo = (BooleanFlagOn( NtfsGetAttributeDefinition( Vcb, AttributeTypeCode )->Flags,
                                        ATTRIBUTE_DEF_LOG_NONRESIDENT) ||
                         NtfsEqualMftRef( &Fcb->FileReference, &AttrDefFileReference ) ||
                         ($EA == AttributeTypeCode) );

    ASSERT( (AttributeFlags == 0) || NtfsIsTypeCodeCompressible( AttributeTypeCode ));

    //
    //  Clear out the invalid attribute flags for this volume.
    //

    AttributeFlags &= Vcb->AttributeFlagsMask;

    if (ARGUMENT_PRESENT(AttributeName)) {

        LocalName = *AttributeName;

    } else {

        LocalName.Length = LocalName.MaximumLength = 0;
        LocalName.Buffer = NULL;
    }

    if (ARGUMENT_PRESENT( ThisScb )) {

        Scb = ThisScb;
        ReturnedExistingScb = TRUE;

    } else {

        Scb = NtfsCreateScb( IrpContext,
                             Fcb,
                             AttributeTypeCode,
                             &LocalName,
                             FALSE,
                             &ReturnedExistingScb );

        //
        //  An attribute has gone away but the Scb hasn't left yet.
        //  Also mark the header as unitialized.
        //

        ClearFlag( Scb->ScbState, SCB_STATE_HEADER_INITIALIZED |
                                  SCB_STATE_ATTRIBUTE_RESIDENT |
                                  SCB_STATE_FILE_SIZE_LOADED );

        //
        //  Set a flag in the Scb to indicate that we are converting to non-resident.
        //

        if (WriteClusters) { SetFlag( Scb->ScbState, SCB_STATE_CONVERT_UNDERWAY ); }
    }

    //
    //  Allocate the record for the size we need.
    //

    NtfsAllocateAttribute( IrpContext,
                           Scb,
                           AttributeTypeCode,
                           AttributeName,
                           AttributeFlags,
                           TRUE,
                           LogIt,
                           (LONGLONG) ValueLength,
                           Context );

    NtfsUpdateScbFromAttribute( IrpContext, Scb, NULL );

    SetFlag( Scb->ScbState, SCB_STATE_TRUNCATE_ON_CLOSE );

    //
    //  We need to be careful here, if this call is due to MM creating a
    //  section, we don't want to call into the cache manager or we
    //  will deadlock on the create section call.
    //

    if (!WriteClusters && !ARGUMENT_PRESENT( ThisScb )) {

        //
        //  This call will initialize a stream for use below.
        //

        NtfsCreateInternalAttributeStream( IrpContext,
                                           Scb,
                                           TRUE,
                                           &NtfsInternalUseFile[CREATENONRESIDENTWITHVALUE_FILE_NUMBER] );
    }

    //
    // Now, write in the data.
    //

    Scb->Header.FileSize.QuadPart = ValueLength;
    if ((ARGUMENT_PRESENT( Value )) && (ValueLength != 0)) {

        if (LogNonresidentToo || !WriteClusters) {

            ULONG BytesThisPage;
            PVOID Buffer;
            PBCB Bcb = NULL;

            LONGLONG CurrentFileOffset = 0;
            ULONG RemainingBytes = ValueLength;

            PVOID CurrentValue = Value;

            //
            //  While there is more to write, pin the next page and
            //  write a log record.
            //

            try {

                CC_FILE_SIZES FileSizes;

                //
                //  Call the Cache Manager to truncate and reestablish the FileSize,
                //  so that we are guaranteed to get a valid data length call when
                //  the data goes out.  Otherwise he will likely think he does not
                //  have to call us.
                //

                RtlCopyMemory( &FileSizes, &Scb->Header.AllocationSize, sizeof( CC_FILE_SIZES ));

                FileSizes.FileSize.QuadPart = 0;

                CcSetFileSizes( Scb->FileObject, &FileSizes );
                CcSetFileSizes( Scb->FileObject,
                                (PCC_FILE_SIZES)&Scb->Header.AllocationSize );

                while (RemainingBytes) {

                    BytesThisPage = (RemainingBytes < PAGE_SIZE ? R